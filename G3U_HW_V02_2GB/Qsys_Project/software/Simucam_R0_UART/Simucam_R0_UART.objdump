
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x000484b0 memsz 0x00062770 flags rwx
    LOAD off    0x0004a000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  0004a000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000412e0  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000051a0  8114153c  8114153c  0004253c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  811466dc  811466dc  000476dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a2c0  811484d0  811484d0  000494d0  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  81162790  81162790  0004a000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  0004a000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0004a000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d20  00000000  00000000  0004a028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000698a5  00000000  00000000  0004bd48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00015cc3  00000000  00000000  000b55ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0002038e  00000000  00000000  000cb2b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00008564  00000000  00000000  000eb640  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000bc3d  00000000  00000000  000f3ba4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  000ff7e1  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  001266b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  001266f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00133a55  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  00133a5b  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00133a67  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00133a68  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00133a69  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00133a6d  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00133a71  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  00133a75  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  00133a80  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  00133a8a  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  00133a94  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  00133aa5  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00278448  00000000  00000000  00133ae4  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8114153c l    d  .rodata	00000000 .rodata
811466dc l    d  .rwdata	00000000 .rwdata
811484d0 l    d  .bss	00000000 .bss
81162790 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm.c
00000000 l    df *ABS*	00000000 data_packet.c
00000000 l    df *ABS*	00000000 fee_buffers.c
811484ec l     O .bss	00000004 viCh1HoldContext
811484f0 l     O .bss	00000004 viCh2HoldContext
811484f4 l     O .bss	00000004 viCh3HoldContext
811484f8 l     O .bss	00000004 viCh4HoldContext
811484fc l     O .bss	00000004 viCh5HoldContext
81148500 l     O .bss	00000004 viCh6HoldContext
81148504 l     O .bss	00000004 viCh7HoldContext
81148508 l     O .bss	00000004 viCh8HoldContext
81105128 l     F .text	00000054 vFeebWriteReg
8110517c l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
00000000 l    df *ABS*	00000000 spw_controller.c
81105728 l     F .text	00000050 uliSpwcReadReg
811056d4 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
811483f8 l     O .rwdata	00000001 ucIoValue
81105928 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
81106218 l     F .text	0000013c msgdma_write_extended_descriptor
81106354 l     F .text	00000164 msgdma_construct_extended_descriptor
811064b8 l     F .text	00000318 msgdma_descriptor_async_transfer
811067d0 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110734c l     F .text	00000054 vRstcWriteReg
811073a0 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
81148510 l     O .bss	00000004 viHoldContext
811086d4 l     F .text	00000058 uliSyncReadReg
81108678 l     F .text	0000005c bSyncWriteReg
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
81148520 l     O .bss	00000004 pxNFee.4255
81148524 l     O .bss	00000004 pxNFee.4310
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
81148528 l     O .bss	00000004 xRAckLocal.5046
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
8114852c l     O .bss	00000004 bDmaBack.4410
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
81148530 l     O .bss	00000004 xSAckLocal.5031
00000000 l    df *ABS*	00000000 parser_comm_task.c
81148698 l     O .bss	0000004c PreParsedLocal.5124
811486e4 l     O .bss	00000054 xTcPusL.5123
00000000 l    df *ABS*	00000000 receiver_uart_task.c
81148738 l     O .bss	0000004c xPreParsedReader.5112
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
81148784 l     O .bss	00000054 xPusLocal.5248
811487d8 l     O .bss	00000054 xPusLocal.5280
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
81144147 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
81145b1d l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
811466dc l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
8111827c l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
81145cea l     O .rodata	00000010 zeroes.4389
81145cfa l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
81145d0a l     O .rodata	00000010 zeroes.4404
8111cef4 l     F .text	000000c4 __sbprintf
81145d1a l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
81145d32 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
8111ebdc l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112072c l     F .text	00000008 __fp_unlock
81120740 l     F .text	000001a4 __sinit.part.1
811208e4 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81146f28 l     O .rwdata	00000020 lc_ctype_charset
81146f08 l     O .rwdata	00000020 lc_message_charset
81146f48 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
81145d70 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
81123754 l     F .text	0000006c sulp
81145eb8 l     O .rodata	00000014 fpi.2737
81145ecc l     O .rodata	00000028 tinytens
81145ea4 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81145f04 l     O .rodata	00000010 blanks.4332
81145ef4 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
81126dc4 l     F .text	00000104 __sprint_r.part.0
81145f24 l     O .rodata	00000010 blanks.4348
81145f14 l     O .rodata	00000010 zeroes.4349
81128360 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
81128814 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
8112c5b0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
8112c6f4 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
8112c728 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
8112c9ac l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
8112caa4 l       .text	00000000 tx_next_char
8112cacc l       .text	00000000 end_tx
8112caac l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
8112d5a8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
8112d824 l     F .text	00000044 alt_get_errno
8112d868 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
8112da90 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81148440 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
8112e030 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
8114844c l     O .rwdata	00000004 lockid
811485e0 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81148450 l     O .rwdata	00000004 lockid
811485e8 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
8112fabc l     F .text	00000050 OS_InitMisc
8112fb0c l     F .text	00000074 OS_InitRdyList
8112fc90 l     F .text	000000ec OS_InitTCBList
8112f9d4 l     F .text	000000e8 OS_InitEventList
8112fb80 l     F .text	00000088 OS_InitTaskIdle
8112fc08 l     F .text	00000088 OS_InitTaskStat
8112ff20 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
81131d38 l     F .text	000000fc OS_FlagTaskRdy
81131ae8 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
81133624 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81137ea0 l     F .text	00000044 OSTmr_Lock
81137940 l     F .text	00000074 OSTmr_Alloc
81137ee4 l     F .text	0000003c OSTmr_Unlock
81137da4 l     F .text	000000fc OSTmr_Unlink
811379b4 l     F .text	000000a4 OSTmr_Free
81137c54 l     F .text	00000150 OSTmr_Link
81137bcc l     F .text	00000088 OSTmr_InitTask
81137f20 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
81138030 l     F .text	0000003c alt_dev_reg
811471c4 l     O .rwdata	0000106c jtag_uart_0
81148230 l     O .rwdata	000000d0 rs232_uart
81148300 l     O .rwdata	00000064 dma_DDR_M1
81148364 l     O .rwdata	00000064 dma_DDR_M2
811483c8 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
8113c8c0 l     F .text	000002bc altera_avalon_jtag_uart_irq
8113cb7c l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
8113d380 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
8113d718 l     F .text	000000a4 altera_avalon_uart_irq
8113d7bc l     F .text	00000140 altera_avalon_uart_rxirq
8113d8fc l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
8113db04 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
8113ddb8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
8113e03c l     F .text	00000044 alt_get_errno
8113e080 l     F .text	0000009c alt_msgdma_write_standard_descriptor
8113e11c l     F .text	00000134 alt_msgdma_write_extended_descriptor
8113e250 l     F .text	0000018c alt_msgdma_irq
8113e3dc l     F .text	00000094 alt_msgdma_construct_standard_descriptor
8113e470 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
8113e5cc l     F .text	00000340 alt_msgdma_descriptor_async_transfer
8113e90c l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
8113f014 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
8113f0c0 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8114028c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
811408d0 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81148690 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81148694 g     O .bss	00000004 alt_instruction_exception_handler
81148d54 g     O .bss	00001000 vFeeTask0_stk
811128f4 g     F .text	0000004c vFailDeleteInitialization
81148664 g     O .bss	00000004 aux_status_register
81149d54 g     O .bss	00001000 vInAckHandlerTask_stk
81140048 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
811078d8 g     F .text	0000004c vSyncInitIrq
8110e96c g     F .text	00000284 vCheckRetransmission128
81122dd8 g     F .text	0000007c _mprec_log10
81107a54 g     F .text	00000040 bSyncSetMbt
81105b0c g     F .text	00000108 I2C_Read
8114849e g     O .rwdata	00000002 OSTaskNameSize
8114ad54 g     O .bss	00000260 xBuffer64
81122ecc g     F .text	0000008c __any_on
811218a0 g     F .text	0000005c _isatty_r
81145d7c g     O .rodata	00000028 __mprec_tinytens
8112d6c8 g     F .text	0000015c alt_main
811181a0 g     F .text	000000c8 _puts_r
811049b8 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
811485f0 g     O .bss	00000004 OSTmrFreeList
81162690 g     O .bss	00000100 alt_irq
81121a10 g     F .text	00000068 _lseek_r
81114ce0 g     F .text	00000030 vChangeDefaultAutoResetSync
81132598 g     F .text	000000d4 OS_MemInit
81111428 g     F .text	000009d4 vLoadDefaultETHConf
81109fdc g     F .text	0000014c bCheckInAck64
8114afb4 g     O .bss	00000150 xPus
81136e80 g     F .text	00000068 OSTimeSet
811097c4 g     F .text	00000380 vFeeTask0
81120ae4 g     F .text	000000ac __sflags
811137c8 g     F .text	00000068 vCoudlNotCreateNFee2Task
81113bb4 g     F .text	0000004c vCouldNotGetMutexMebPus
8112b710 g     F .text	00000088 .hidden __eqdf2
8110de18 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
81114bcc g     F .text	00000034 vLoadDefaultSyncSource
81138530 g     F .text	000001ac Check_for_Master_Boot_Record
8115c84c g     O .bss	00000010 OSTmrWheelTbl
8113edd4 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
8114b104 g     O .bss	00000010 xFeeQueueTBL3
8112e720 g     F .text	00000594 OSEventPendMulti
81148538 g     O .bss	00000004 xNfeeSchedule
81162790 g       *ABS*	00000000 __alt_heap_start
81140f08 g     F .text	0000002c OSTaskCreateHook
8113c3a8 g     F .text	000001c4 alt_up_sd_card_fclose
8114853c g     O .bss	00000004 xSemCountBuffer64
81117fe4 g     F .text	00000044 printf
8114850d g     O .bss	00000001 SspdConfigControl
81107e70 g     F .text	00000054 bSyncCtrReset
81148476 g     O .rwdata	00000002 OSMboxEn
811154d0 g     F .text	000000a4 aatoh
8112ed18 g     F .text	00000054 OSIntEnter
81129480 g     F .text	000000a4 _wcrtomb_r
811048c4 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111285c g     F .text	0000004c vFailReceiverCreate
81148518 g     O .bss	00000004 xQMaskDataCtrl
81104528 g     F .text	00000040 vFeebCh2HandleIrq
81118708 g     F .text	00000064 __sseek
81120a94 g     F .text	00000010 __sinit
81106c8c g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
8111e85c g     F .text	00000148 __swbuf_r
8110f144 g     F .text	00000528 bResourcesInitRTOS
8110539c g     F .text	000000f4 bSpwcGetLinkError
81148486 g     O .rwdata	00000002 OSQEn
8112192c g     F .text	00000084 _setlocale_r
811483fc g     O .rwdata	00000004 LedsPainelControl
81148854 g     O .bss	00000100 cDebugBuffer
811208ec g     F .text	00000070 __sfmoreglue
81126dac g     F .text	00000018 ungetc
8112e3dc g     F .text	000000d4 __malloc_unlock
81102d7c g     F .text	00000210 DMA_MULTIPLE_TRANSFER
81140f88 g     F .text	00000028 OSTaskStatHook
8110dcfc g     F .text	00000088 vSendCmdQToNFeeCTRL
81114c3c g     F .text	00000030 vChangeDefaultSyncSource
811485f4 g     O .bss	00000001 OSLockNesting
811485f8 g     O .bss	00000004 OSTmrSemSignal
81114078 g     F .text	000000e8 vNFeeStructureInit
81148540 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
811237c0 g     F .text	00001600 _strtod_r
81148544 g     O .bss	00000004 xSemCountSenderACK
8111560c g     F .text	00000448 .hidden __divsf3
81148688 g     O .bss	00000004 current_sector_modified
811484c4 g     O .rwdata	00000002 OSDataSize
811485fc g     O .bss	00000001 OSRunning
81105560 g     F .text	00000174 bSpwcInitCh
8112d390 g     F .text	00000064 alt_log_jtag_uart_isr_proc
8114b114 g     O .bss	00001000 senderTask_stk
81148548 g     O .bss	00000004 fp
8114c114 g     O .bss	00000030 xNfeeScheduleTBL
81109e94 g     F .text	00000148 bCheckInAck128
81121da0 g     F .text	0000015c memmove
81141004 g     F .text	0000002c OSInitHookBegin
8110830c g     F .text	00000074 bSyncCtrCh8OutEnable
811484bc g     O .rwdata	00000002 OSTmrSize
81120a7c g     F .text	00000018 _cleanup
81115108 g     F .text	00000040 siCloseFile
81121efc g     F .text	000000b0 _Balloc
81114c6c g     F .text	00000038 vLoadDefaultAutoResetSync
8113af84 g     F .text	000000cc alt_up_sd_card_is_Present
8113ed14 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
811484d8 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a4 DMA_DISPATCHER_STOP
81138258 g     F .text	00000054 Save_Modified_Sector
81104b18 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
81148600 g     O .bss	00000004 OSIdleCtr
811485bc g     O .bss	00000001 alt_log_write_on_flag
81105778 g     F .text	0000003c bEnableIsoDrivers
8112b798 g     F .text	000000dc .hidden __gtdf2
81140c98 g     F .text	0000002c altera_nios2_gen2_irq_init
81140d80 g       .text	00000000 OSStartTsk
81107bc8 g     F .text	00000070 bSyncSetNCycles
81130290 g     F .text	000002dc OS_TCBInit
811485bf g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111488c g     F .text	00000078 vInitSimucamBasicHW
8114c144 g     O .bss	00001000 vTimeoutCheckerTask_stk
81108224 g     F .text	00000074 bSyncCtrCh6OutEnable
81105e88 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81148680 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
81148604 g     O .bss	00000002 OSTmrUsed
8114854c g     O .bss	00000004 xSemCountBuffer128
81103254 g     F .text	000000f8 TEMP_Read
8114d144 g     O .bss	00001000 vDataControlTask_stk
811045a8 g     F .text	00000040 vFeebCh4HandleIrq
811484c2 g     O .rwdata	00000002 OSTmrWheelTblSize
81114550 g     F .text	0000002c cFeeSpwChannelDisable
81148462 g     O .rwdata	00000002 OSEventSize
81148606 g     O .bss	00000001 OSPrioHighRdy
81117180 g     F .text	00000064 _fstat_r
81140f34 g     F .text	0000002c OSTaskDelHook
81148598 g     O .bss	00000004 errno
81108600 g     F .text	0000003c uliSyncGetCtr
8111e7ec g     F .text	0000001c __svfscanf
8111867c g     F .text	00000008 __seofread
81140d60 g       .text	00000000 OSStartHighRdy
81113f48 g     F .text	00000070 vEvtChangeFeeControllerMode
81108e5c g     F .text	00000968 vPrintConsoleNFee
8110af78 g     F .text	000000cc bSendCmdQToNFeeInst
811358b0 g     F .text	000001ec OSTaskCreateExt
8115c820 g     O .bss	00000011 alt_log_write_buf
81112c18 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
811258f0 g     F .text	00001244 ___svfiprintf_internal_r
8110ca60 g     F .text	00000364 bPreParserV2
81131618 g     F .text	00000068 OSFlagPendGetFlagsRdy
811484a2 g     O .rwdata	00000002 OSTaskStatStkSize
81130764 g     F .text	00000310 OSFlagAccept
81133d40 g     F .text	000000c0 OSQFlush
811337bc g     F .text	00000148 OSQAccept
811485d0 g     O .bss	00000004 alt_argv
811503f4 g       *ABS*	00000000 _gp
81112524 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
8112def4 g     F .text	0000013c usleep
8113b55c g     F .text	00000384 alt_up_sd_card_fopen
81114f74 g     F .text	00000030 bSDcardIsPresent
8110cdc4 g     F .text	00000178 vSenderComTask
8113b0c4 g     F .text	000000d8 alt_up_sd_card_find_first
81112db8 g     F .text	00000068 vFailSendNack
81148674 g     O .bss	00000004 command_argument_register
811353b8 g     F .text	000004f8 OSTaskChangePrio
8110d0d0 g     F .text	0000055c vPusMebInTaskConfigMode
81113530 g     F .text	00000088 vCouldNotSendTMPusCommand
811485ec g     O .bss	00000004 alt_heapsem
81106120 g     F .text	00000080 bSetBoardLeds
8113056c g     F .text	000001f8 OSDebugInit
81135a9c g     F .text	0000034c OSTaskDel
8113266c g     F .text	000001ac OSMutexAccept
8114e144 g     O .bss	00000e20 xSimMeb
81114770 g     F .text	00000040 vSetTimeCode
8113f8bc g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
81148550 g     O .bss	00000004 xSemCountPreParsed
81146fa8 g     O .rwdata	00000180 alt_fd_list
81104a68 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81147144 g     O .rwdata	0000001d alt_log_msg_alt_main
8115c85c g     O .bss	00000580 OSFlagTbl
8111268c g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
81114b24 g     F .text	0000003c vLoadDefaultRTValue
8112f79c g     F .text	000000c0 OS_EventTaskRemove
8114ef64 g     O .bss	00001000 vFeeTask5_stk
811485be g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
8113a7d8 g     F .text	00000134 find_first_empty_record_in_root_directory
8114037c g     F .text	00000098 alt_find_dev
81117ccc g     F .text	00000150 memcpy
8112914c g     F .text	00000264 __hexnan
8114ff64 g     O .bss	00000160 xBuffer32
8114848c g     O .rwdata	00000002 OSRdyTblSize
8115cddc g     O .bss	000001a0 OSTmrTbl
81120734 g     F .text	0000000c _cleanup_r
8112c2ec g     F .text	000000e4 .hidden __floatsidf
81111050 g     F .text	000001a8 vSendPusTM64
811079c4 g     F .text	0000004c ucSyncStatusErrorCode
8110dd84 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111464c g     F .text	00000034 cFeeRMAPLogDisable
8110b33c g     F .text	00000e00 vParserCommTask
8114099c g     F .text	00000084 alt_io_redirect
811145e0 g     F .text	00000034 cFeeRMAPEchoingDisable
8112b874 g     F .text	000000f4 .hidden __ltdf2
81113b00 g     F .text	0000004c vFailSendPUStoMebTask
81104d44 g     F .text	000000d4 bFeebSetIrqControl
81113328 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
81148554 g     O .bss	00000004 xMutexReceivedACK
81103bd0 g     F .text	000000b0 bSdmaInitM2Dma
8113fd44 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8114008c g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
81107f18 g     F .text	00000054 bSyncCtrErrInj
8113ffec g     F .text	0000005c alt_msgdma_register_callback
81111dfc g     F .text	00000330 vShowEthConfig
81114904 g     F .text	00000030 bLogWriteSDCard
811129a8 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
81118268 g     F .text	00000014 puts
811410ac g     F .text	000000a4 alt_exception_cause_generated_bad_addr
81107898 g     F .text	00000040 vSyncHandleIrq
8112e4b0 g     F .text	00000128 OSEventNameGet
8110472c g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
81148470 g     O .rwdata	00000002 OSFlagMax
81121b2c g     F .text	000000e0 mbrtowc
8113a3d0 g     F .text	000001b4 find_first_empty_cluster
811081b0 g     F .text	00000074 bSyncCtrCh5OutEnable
81148514 g     O .bss	00000001 vucN
8112352c g     F .text	00000074 __fpclassifyd
81107924 g     F .text	00000054 bSyncStatusExtnIrq
8111e808 g     F .text	00000054 _vfscanf_r
81132cec g     F .text	000005a4 OSMutexPend
81122d2c g     F .text	000000ac __ratio
8113aec0 g     F .text	000000c4 alt_up_sd_card_open_dev
811135b8 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
8112ed6c g     F .text	00000100 OSIntExit
81107a94 g     F .text	00000040 bSyncSetBt
81128344 g     F .text	0000001c __vfiprintf_internal
81113c00 g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
811484aa g     O .rwdata	00000002 OSTCBSize
811046e8 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
81148607 g     O .bss	00000001 OSPrioCur
8110df10 g     F .text	00000090 vMebChangeToRunning
8113cdf0 g     F .text	000002c4 altera_avalon_jtag_uart_read
8113f584 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
81117fac g     F .text	00000038 _printf_r
8112a2b4 g     F .text	00000064 .hidden __udivsi3
8112c9f0 g     F .text	000000ac isatty
8114850c g     O .bss	00000001 LedsBoardControl
81148558 g     O .bss	00000004 xSemCountReceivedACK
81148490 g     O .rwdata	00000002 OSStkWidth
811218fc g     F .text	00000030 iswspace
81145dcc g     O .rodata	000000c8 __mprec_tens
81148484 g     O .rwdata	00000002 OSPtrSize
81113968 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
811219b0 g     F .text	0000000c __locale_charset
811080c8 g     F .text	00000074 bSyncCtrCh3OutEnable
8112a4a4 g     F .text	000000c8 .hidden __lesf2
81148464 g     O .rwdata	00000002 OSEventTblSize
81129680 g     F .text	0000007c .hidden __fixunsdfsi
81140cc4 g       .text	00000000 OSCtxSw
81105c14 g     F .text	00000160 I2C_MultipleRead
8112d534 g     F .text	00000074 alt_log_system_clock
811485a4 g     O .bss	00000004 __malloc_top_pad
81148608 g     O .bss	00000004 OSTCBList
81137900 g     F .text	00000040 OSTmrSignal
811485b4 g     O .bss	00000004 alt_fd_list_lock
8112541c g     F .text	0000001c strtoul
81148414 g     O .rwdata	00000004 __mb_cur_max
811219e0 g     F .text	0000000c _localeconv_r
81125438 g     F .text	000002e0 _strtoull_r
811072dc g     F .text	00000070 vRstcHoldDeviceReset
81122320 g     F .text	00000044 __i2b
81121244 g     F .text	000004c4 __sfvwrite_r
811396b0 g     F .text	000000c0 get_dir_divider_location
8115cf7c g     O .bss	00000c30 OSMemTbl
8114860c g     O .bss	00000001 OSTickStepState
8112d144 g     F .text	00000060 alt_log_printf_proc
811500c4 g     O .bss	00001800 vReceiverUartTask_stk
81118474 g     F .text	0000005c _sbrk_r
8114855c g     O .bss	00000004 xSemTimeoutChecker
81139370 g     F .text	000000cc filename_to_upper_case
811485c0 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
81148488 g     O .rwdata	00000002 OSQMax
8113b8e0 g     F .text	00000090 alt_up_sd_card_set_attributes
811329e8 g     F .text	00000304 OSMutexDel
8115dbac g     O .bss	00001000 OSTaskStatStk
81114fa4 g     F .text	00000030 bSDcardFAT16Check
811321b4 g     F .text	000000f8 OSMemNameGet
81112378 g     F .text	00000060 vFailCreateMutexSResources
811386dc g     F .text	00000284 Read_File_Record_At_Offset
811518c4 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
81148468 g     O .rwdata	00000002 OSFlagEn
81122f58 g     F .text	00000068 _read_r
811484ae g     O .rwdata	00000002 OSTimeTickHookEn
81131e34 g     F .text	000000ac OS_FlagUnlink
81134208 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
81148430 g     O .rwdata	00000004 alt_max_fd
811130d4 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
8112fdd8 g     F .text	00000070 OS_MemCopy
8112fe48 g     F .text	000000d8 OS_Sched
81139f54 g     F .text	0000047c find_file_in_directory
811284f0 g     F .text	000000f8 _fclose_r
811320bc g     F .text	000000f8 OSMemGet
811360e0 g     F .text	000001bc OSTaskNameSet
811206fc g     F .text	00000030 fflush
811485a0 g     O .bss	00000004 __malloc_max_sbrked_mem
81148610 g     O .bss	00000004 OSCtxSwCtr
81140fb0 g     F .text	00000054 OSTimeTickHook
81151904 g     O .bss	00001000 vOutAckHandlerTask_stk
8112c824 g     F .text	00000188 alt_irq_register
81148472 g     O .rwdata	00000002 OSFlagNameSize
8111679c g     F .text	00000118 .hidden __extendsfdf2
8112f85c g     F .text	00000108 OS_EventTaskRemoveMulti
8113b050 g     F .text	00000074 alt_up_sd_card_is_FAT16
811059a4 g     F .text	00000088 I2C_TestAdress
8112a56c g     F .text	000008b4 .hidden __adddf3
8115c834 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
8112a370 g     F .text	00000078 .hidden __nesf2
8112f644 g     F .text	00000158 OS_EventTaskWaitMulti
81122ac4 g     F .text	00000114 __b2d
8113f2bc g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
8114848a g     O .rwdata	00000002 OSQSize
81129c7c g     F .text	00000540 .hidden __umoddi3
8112d5ec g     F .text	000000dc lseek
81134cf8 g     F .text	00000214 OSSemPend
81113b4c g     F .text	00000068 vCouldNotGetCmdQueueMeb
81105490 g     F .text	000000d0 bSpwcGetLinkStatus
81104ff4 g     F .text	00000088 bFeebGetWindowing
81148404 g     O .rwdata	00000004 _global_impure_ptr
8110784c g     F .text	0000004c bSSDisplayUpdate
81139a14 g     F .text	00000540 get_home_directory_cluster_for_file
81122fc0 g     F .text	0000056c _realloc_r
81148474 g     O .rwdata	00000002 OSLowestPrio
81162790 g       *ABS*	00000000 __bss_end
811407d8 g     F .text	000000f8 alt_iic_isr_register
81141080 g     F .text	0000002c OSTCBInitHook
811484ba g     O .rwdata	00000002 OSTmrCfgTicksPerSec
8112dde4 g     F .text	00000110 alt_tick
81112624 g     F .text	00000068 vFailGetMutexSenderTask
811071fc g     F .text	0000006c vRstcSimucamReset
81145f34 g     O .rodata	00000100 __hexdig
8113fe38 g     F .text	000001b4 alt_msgdma_init
811296fc g     F .text	00000580 .hidden __udivdi3
8110c748 g     F .text	0000017c setPreAckSenderFreePos
81128768 g     F .text	00000024 _fputwc_r
8114845c g     O .rwdata	00000002 OSEventEn
81145da4 g     O .rodata	00000028 __mprec_bigtens
811220fc g     F .text	0000010c __s2b
811484b6 g     O .rwdata	00000002 OSTmrCfgNameSize
81152904 g     O .bss	00000010 xFeeQueueTBL4
81107b54 g     F .text	00000074 bSyncSetPolarity
8110ebf0 g     F .text	0000028c vCheckRetransmission64
8112c3d0 g     F .text	000000b0 .hidden __floatunsidf
811485c4 g     O .bss	00000004 alt_system_clock_in_sec
8112d33c g     F .text	00000054 alt_log_jtag_uart_startup_info
81112bb0 g     F .text	00000068 vFailFoundBufferRetransmission
811227fc g     F .text	00000060 __mcmp
8114868c g     O .bss	00000004 current_sector_index
8113d5b0 g     F .text	00000168 altera_avalon_uart_init
81140114 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
811040b0 g     F .text	00000438 bSdmaDmaM2Transfer
811147b0 g     F .text	00000034 vResetTimeCode
81114524 g     F .text	0000002c cFeeSpwChannelEnable
81120ab4 g     F .text	00000018 __fp_lock_all
81113e40 g     F .text	0000004c vFailSendMsgDataCTRL
81140784 g     F .text	00000054 alt_ic_irq_enabled
81105a2c g     F .text	000000e0 I2C_Write
81148614 g     O .bss	00000002 OSTmrFree
81131c50 g     F .text	000000e8 OS_FlagInit
8112dd40 g     F .text	000000a4 alt_alarm_stop
81118adc g     F .text	0000001c strtol
811485bd g     O .bss	00000001 alt_log_sys_clk_on_flag
811370ac g     F .text	00000140 OSTmrDel
81138448 g     F .text	000000e8 mark_cluster
81148498 g     O .rwdata	00000002 OSTaskIdleStkSize
811485b8 g     O .bss	00000004 alt_irq_active
81134918 g     F .text	000000b8 OSSemAccept
81116d18 g     F .text	0000044c _fseeko_r
8110fb08 g     F .text	00000260 vFillMemmoryPattern
81118858 g     F .text	00000044 strnlen
811323c8 g     F .text	000000e0 OSMemPut
81131ee0 g     F .text	000001dc OSMemCreate
81148618 g     O .bss	00000004 OSIdleCtrMax
811111f8 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
8112cb8c g     F .text	000005b8 alt_log_private_printf
81146f80 g     O .rwdata	00000028 alt_dev_null
8113eecc g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
81107b14 g     F .text	00000040 bSyncSetOst
811484ac g     O .rwdata	00000002 OSTicksPerSec
81147128 g     O .rwdata	00000019 alt_log_msg_bss
8113a90c g     F .text	00000194 convert_filename_to_name_extension
8110cf3c g     F .text	00000194 vSimMebTask
81105d74 g     F .text	00000094 i2c_start
81140cc4 g       .text	00000000 OSIntCtxSw
8110813c g     F .text	00000074 bSyncCtrCh4OutEnable
8113fcb0 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
8112c6cc g     F .text	00000028 alt_dcache_flush_all
81122208 g     F .text	00000068 __hi0bits
81114b60 g     F .text	0000003c vChangeRTValue
81148660 g     O .bss	00000004 is_sd_card_formated_as_FAT16
8110e7e8 g     F .text	00000184 vCheck
81114028 g     F .text	00000050 vNFeeNotInUse
8112c26c g     F .text	00000080 .hidden __fixdfsi
8110aa64 g     F .text	0000028c vNFeeControlTask
81152914 g     O .bss	00001000 vInitialTask_stk
81148560 g     O .bss	00000002 usiIdCMD
81107e1c g     F .text	00000054 bSyncCtrStart
8113a584 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
81124dc0 g     F .text	00000018 strtod
8114861c g     O .bss	00000004 OSTCBFreeList
81134f0c g     F .text	00000174 OSSemPendAbort
811127c4 g     F .text	0000004c vFailGetMacRTC
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111303c g     F .text	0000004c vFailCreateTimerRetransmisison
81112b48 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
811100c0 g     F .text	000002f0 bSendUART128v2
811149cc g     F .text	000000b4 vSimucamStructureInit
81148428 g     O .rwdata	00000008 alt_dev_list
81116c48 g     F .text	0000004c _fputc_r
8112e074 g     F .text	0000010c write
81118028 g     F .text	000000a8 _putc_r
81148684 g     O .bss	00000004 device_pointer
811484b0 g     O .rwdata	00000002 OSVersionNbr
8112a3e8 g     F .text	000000bc .hidden __gtsf2
8110c13c g     F .text	00000118 getPreParsedPacket
8112c76c g     F .text	000000b8 fstat
81114818 g     F .text	00000040 vChangeIdNFEEMaster
81116c1c g     F .text	0000002c fprintf
81114614 g     F .text	00000038 cFeeRMAPLogEnable
81102c6c g     F .text	00000110 DMA_SINGLE_TRANSFER
81104ac0 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
81113188 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
811151b0 g     F .text	00000058 _reg_write
81114858 g     F .text	00000034 vChangeDefaultIdNFEEMaster
8112b874 g     F .text	000000f4 .hidden __ledf2
81153914 g     O .bss	00001000 vStackMonitor_stk
811134c8 g     F .text	00000068 vCouldNotSendLog
8113732c g     F .text	000001b8 OSTmrRemainGet
81148458 g     O .rwdata	00000004 OSEndiannessTest
811073f0 g     F .text	00000058 v_spi_start
81122564 g     F .text	00000148 __pow5mult
81126ee0 g     F .text	00001464 ___vfiprintf_internal_r
811485b0 g     O .bss	00000004 __nlocale_changed
8112a318 g     F .text	00000058 .hidden __umodsi3
81107f6c g     F .text	00000074 bSyncCtrSyncOutEnable
81114fd4 g     F .text	000000f8 bInitializeSDCard
81112f58 g     F .text	0000004c vFailParserCommTaskCreate
81113460 g     F .text	00000068 vCouldNotSendReset
81118514 g     F .text	00000038 _scanf_r
81112ff0 g     F .text	0000004c vFailOutAckHandlerTaskCreate
8114846a g     O .rwdata	00000002 OSFlagGrpSize
8110dea0 g     F .text	00000070 vMebChangeToConfig
81154914 g     O .bss	00000058 xInUseRetrans
8113f31c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
811374e4 g     F .text	000000ec OSTmrStateGet
81162790 g       *ABS*	00000000 end
81104628 g     F .text	00000040 vFeebCh6HandleIrq
8110fd68 g     F .text	00000260 vPrintMemmoryPattern
81112ce8 g     F .text	00000068 vNoContentInPreParsedBuffer
81117164 g     F .text	0000001c fseeko
8110c254 g     F .text	00000168 bSendMessagePUStoMebTask
81113688 g     F .text	00000070 vFailCreateNFEEQueue
81116acc g     F .text	0000000c _atoi_r
8113ddfc g     F .text	00000240 altera_avalon_uart_write
8112cad0 g     F .text	00000054 alt_log_txchar
81116cfc g     F .text	0000001c fseek
81110030 g     F .text	00000090 vCCDChangeValues
8113c6f0 g     F .text	000001d0 altera_avalon_jtag_uart_init
811300d8 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
81112424 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
8113d404 g     F .text	00000084 alt_avalon_timer_sc_init
81104f4c g     F .text	000000a8 bFeebSetWindowing
8113d4f0 g     F .text	00000068 altera_avalon_uart_write_fd
81116a5c g     F .text	00000064 .hidden __clzsi2
8113d558 g     F .text	00000058 altera_avalon_uart_close_fd
8115496c g     O .bss	00000020 xMebQTBL
8113d0b4 g     F .text	000002cc altera_avalon_jtag_uart_write
81137a58 g     F .text	00000174 OSTmr_Init
8115498c g     O .bss	00000348 xBuffer128
81120aa4 g     F .text	00000004 __sfp_lock_acquire
8110334c g     F .text	00000048 sense_log_temp
81121cbc g     F .text	000000e4 memchr
8112fd7c g     F .text	0000005c OS_MemClr
8111acd8 g     F .text	00002200 ___vfprintf_internal_r
81140da4 g     F .text	00000164 OSTaskStkInit
8111854c g     F .text	00000060 _sprintf_r
81148562 g     O .bss	00000001 SemCount32
81120f2c g     F .text	00000318 _free_r
81140a20 g     F .text	00000234 alt_printf
81111000 g     F .text	00000050 vTimeoutCheck
81115260 g     F .text	000001fc _print_codec_status
811219bc g     F .text	00000010 __locale_mb_cur_max
8112f38c g     F .text	000001a0 OS_EventTaskRdy
81102bc8 g     F .text	000000a4 DMA_DISPATCHER_RESET
811412f8 g     F .text	00000188 __call_exitprocs
8110ae3c g     F .text	0000013c vPerformActionNFCRunning
81148620 g     O .bss	00000001 OSCPUUsage
81113898 g     F .text	00000068 vCoudlNotCreateNFee4Task
811485ac g     O .bss	00000004 __mlocale_changed
8110acf0 g     F .text	0000014c vPerformActionNFCConfig
81107ec4 g     F .text	00000054 bSyncCtrOneShot
8114840c g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110863c g     F .text	0000003c uliSyncReadStatus
811485d8 g     O .bss	00000004 _alt_tick_rate
81133e00 g     F .text	00000294 OSQPend
81124ee0 g     F .text	000002e8 _strtoll_r
81154cd4 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
811369d0 g     F .text	0000010c OSTimeDly
8110d62c g     F .text	000006d0 vPusMebInTaskRunningMode
811226ac g     F .text	00000150 __lshift
8110b044 g     F .text	000002f8 vOutAckHandlerTask
8113ed74 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
811485dc g     O .bss	00000004 _alt_nticks
8112dad4 g     F .text	00000104 read
811380ac g     F .text	000000f0 alt_sys_init
81115e58 g     F .text	0000012c .hidden __floatsisf
81125718 g     F .text	000001d8 __ssprint_r
81117f44 g     F .text	00000068 _open_r
81115188 g     F .text	00000028 bTestSimucamCriticalHW
8110507c g     F .text	000000ac bFeebGetBuffersStatus
8111212c g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
81148621 g     O .bss	00000001 OSTaskCtr
8112ca9c g       .text	00000000 tx_log_str
81110fb0 g     F .text	00000050 siPosStr
811293b0 g     F .text	000000d0 strncmp
81136adc g     F .text	00000164 OSTimeDlyHMSM
81122364 g     F .text	00000200 __multiply
8113cc88 g     F .text	00000070 altera_avalon_jtag_uart_close
811075c0 g     F .text	00000058 v_spi_end
81115148 g     F .text	00000040 cGetNextChar
8114120c g     F .text	000000ec strncpy
8114882c g     O .bss	00000028 __malloc_current_mallinfo
8114845e g     O .rwdata	00000002 OSEventMax
8112a370 g     F .text	00000078 .hidden __eqsf2
81122bd8 g     F .text	00000154 __d2b
81135080 g     F .text	00000118 OSSemPost
811047b4 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
81114b9c g     F .text	00000030 vChangeDefaultRTValue
811046a8 g     F .text	00000040 vFeebCh8HandleIrq
8114865c g     O .bss	00000004 initialized
81110e60 g     F .text	00000100 vSendLog
8112ef00 g     F .text	000000e4 OSSchedUnlock
81107618 g     F .text	00000164 RTCC_SPI_R_MAC
8114843c g     O .rwdata	00000004 alt_log_boot_on_flag
8113c56c g     F .text	00000068 altera_avalon_jtag_uart_read_fd
811251c8 g     F .text	00000254 _strtoul_r
81154d14 g     O .bss	00000010 xFeeQueueTBL5
81140524 g     F .text	000000e4 alt_get_fd
81148624 g     O .bss	00000004 OSMemFreeList
8112f05c g     F .text	000000b8 OSStatInit
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
81162128 g     O .bss	00000014 search_data
811051cc g     F .text	00000100 bSpwcSetLink
8112c480 g     F .text	00000130 alt_busy_sleep
81131a1c g     F .text	000000cc OSFlagQuery
81107fe0 g     F .text	00000074 bSyncCtrCh1OutEnable
81148494 g     O .rwdata	00000002 OSTaskCreateExtEn
8111545c g     F .text	00000074 _split_codec_status
8111eb80 g     F .text	0000005c _close_r
81112d50 g     F .text	00000068 vCouldNotSendEthConfUART
8110a274 g     F .text	000007f0 vInitialTask
8112d244 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
8113f25c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
81141190 g     F .text	0000007c memcmp
8112f364 g     F .text	00000028 OS_Dummy
8113c63c g     F .text	00000058 altera_avalon_jtag_uart_close_fd
81162790 g       *ABS*	00000000 __alt_stack_base
8113c694 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
811047f8 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
811171e4 g     F .text	000000d4 _fwrite_r
8113f37c g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81104908 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
8111ea24 g     F .text	0000015c __swsetup_r
8115ebac g     O .bss	00000180 OSQTbl
81113cd0 g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
8115c804 g     O .bss	0000001c xConfEth
8112ae20 g     F .text	000008f0 .hidden __divdf3
81114c00 g     F .text	0000003c vChangeSyncSource
8112095c g     F .text	00000120 __sfp
8116213c g     O .bss	00000054 boot_sector_data
81113c68 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
81122e54 g     F .text	00000078 __copybits
81146b00 g     O .rwdata	00000408 __malloc_av_
81120ab0 g     F .text	00000004 __sinit_lock_release
811484d0 g     O .bss	00000004 uliInitialState
81105e08 g     F .text	00000080 i2c_stop
81115574 g     F .text	00000064 Verif_Error
811155d8 g     F .text	00000034 toInt
81112570 g     F .text	0000004c vFailSendPreAckSenderSemaphore
81148628 g     O .bss	00000004 OSTCBHighRdy
8111607c g     F .text	00000720 .hidden __muldf3
81118620 g     F .text	0000005c __sread
81120dc4 g     F .text	0000003c fread
8114862c g     O .bss	00000004 OSQFreeList
81140414 g     F .text	00000110 alt_find_file
811402d0 g     F .text	000000ac alt_dev_llist_insert
8112e2b4 g     F .text	00000128 __malloc_lock
81116bec g     F .text	00000030 _fprintf_r
8112dc44 g     F .text	000000fc sbrk
811144a0 g     F .text	0000002c vFeeSpwRMAPLoadDefault
81112ae0 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
81118af8 g     F .text	000021e0 ___svfprintf_internal_r
811113a0 g     F .text	00000088 vTMPusTestConnection
81148564 g     O .bss	00000004 xMebQ
8112e5d8 g     F .text	00000148 OSEventNameSet
81120698 g     F .text	00000064 _fflush_r
81128424 g     F .text	000000cc _calloc_r
81148630 g     O .bss	00000001 OSRdyGrp
81113df4 g     F .text	0000004c vFailSendMsgFeeCTRL
81107a10 g     F .text	00000044 ucSyncStatusCycleNumber
811375d0 g     F .text	00000148 OSTmrStart
811045e8 g     F .text	00000040 vFeebCh5HandleIrq
81116bd4 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
811484d0 g       *ABS*	00000000 __bss_start
81117e1c g     F .text	00000128 memset
8110c60c g     F .text	0000013c setPreParsedFreePos
81108c34 g     F .text	00000114 vQCmdFEEinStandBy
8113fdd8 g     F .text	00000060 alt_msgdma_open
81114d58 g     F .text	0000021c pattern_createPattern
8110f980 g     F .text	00000188 main
811126f4 g     F .text	00000068 vFailGetMutexReceiverTask
81154d24 g     O .bss	00001000 vNFeeControlTask_stk
81114ab8 g     F .text	0000003c vChangeEPValue
811485d4 g     O .bss	00000004 alt_envp
81113e8c g     F .text	0000004c vFailFlushQueue
8114859c g     O .bss	00000004 __malloc_max_total_mem
8113f67c g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
811121d0 g     F .text	0000005c ucCrc8wInit
81113088 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
8113c5d4 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f8c g     F .text	000002c8 POWER_Read
81105fc0 g     F .text	00000160 i2c_read
8111e9a4 g     F .text	00000018 __swbuf
81146234 g     O .rodata	00000100 OSUnMapTbl
8112a4a4 g     F .text	000000c8 .hidden __ltsf2
8113b970 g     F .text	00000090 alt_up_sd_card_get_attributes
81120b90 g     F .text	00000234 _fread_r
811125bc g     F .text	00000068 vFailGetCountSemaphoreSenderTask
811057b4 g     F .text	0000003c bDisableIsoDrivers
8114848e g     O .rwdata	00000002 OSSemEn
8113819c g     F .text	000000bc Write_Sector_Data
8113bd80 g     F .text	00000628 alt_up_sd_card_write
81155d24 g     O .bss	00000018 xFeeQ
81131680 g     F .text	0000039c OSFlagPost
8111876c g     F .text	00000008 __sclose
81113390 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
811285e8 g     F .text	00000014 fclose
8112f52c g     F .text	00000118 OS_EventTaskWait
81113258 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
8111889c g     F .text	00000240 _strtol_r
811168b4 g     F .text	000001a8 .hidden __truncdfsf2
81155d3c g     O .bss	00000010 xFeeQueueTBL2
811301bc g     F .text	000000d4 OS_TaskStatStkChk
81135de8 g     F .text	00000158 OSTaskDelReq
8111ede4 g     F .text	00001690 _dtoa_r
8113f998 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
811174b8 g     F .text	00000814 _malloc_r
811295ec g     F .text	00000030 __ascii_wctomb
81132818 g     F .text	000001d0 OSMutexCreate
811131f0 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
8110a128 g     F .text	0000014c bCheckInAck32
81148434 g     O .rwdata	00000004 alt_errno
8113f4c4 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
8112efe4 g     F .text	00000078 OSStart
811052cc g     F .text	000000d0 bSpwcGetLink
81106d14 g     F .text	000004e8 POWER_SPI_RW
81126b34 g     F .text	000000dc __submore
8112d1a4 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
8112e24c g     F .text	00000068 __env_unlock
81113760 g     F .text	00000068 vCoudlNotCreateNFee1Task
81121708 g     F .text	000000cc _fwalk
8113629c g     F .text	000001dc OSTaskResume
811324a8 g     F .text	000000f0 OSMemQuery
811484a0 g     O .rwdata	00000002 OSTaskStatEn
81162790 g       *ABS*	00000000 __alt_stack_limit
811484e8 g     O .bss	00000004 ECommSpwCh
81114ca4 g     F .text	0000003c vChangeAutoResetSync
81121c58 g     F .text	00000064 _mbtowc_r
81109b44 g     F .text	00000350 vInAckHandlerTaskV2
8114847a g     O .rwdata	00000002 OSMemMax
81134378 g     F .text	00000178 OSQPostFront
811180d0 g     F .text	000000d0 putc
8112a1bc g     F .text	00000084 .hidden __divsi3
81148631 g     O .bss	00000006 OSRdyTbl
81148454 g     O .rwdata	00000002 OSDebugEn
81147198 g     O .rwdata	0000002a alt_log_msg_cache
81120e00 g     F .text	0000012c _malloc_trim_r
81148590 g     O .bss	00000008 xSdHandle
81115a54 g     F .text	00000404 .hidden __mulsf3
8114846c g     O .rwdata	00000002 OSFlagNodeSize
811484d4 g     O .bss	00000004 pnt_memory
81114d10 g     F .text	00000048 vSyncReset
81107ad4 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
81148668 g     O .bss	00000004 status_register
811484b4 g     O .rwdata	00000002 OSTmrCfgMax
81108468 g     F .text	00000074 bSyncIrqFlagClrError
81112e20 g     F .text	00000068 vFailSetPreAckSenderBuffer
81123678 g     F .text	000000dc strcmp
81148670 g     O .bss	00000004 command_register
81133904 g     F .text	000001b4 OSQCreate
81135f40 g     F .text	000001a0 OSTaskNameGet
81155d4c g     O .bss	00001000 vFeeTask4_stk
81156d4c g     O .bss	00000018 xReceivedACK
811344f0 g     F .text	00000214 OSQPostOpt
8112f114 g     F .text	00000228 OSTimeTick
8114849c g     O .rwdata	00000002 OSTaskMax
811349d0 g     F .text	000000e0 OSSemCreate
811484c0 g     O .rwdata	00000002 OSTmrWheelSize
81113620 g     F .text	00000068 vFailCreateScheduleQueue
81115208 g     F .text	00000058 _reg_read
811334b0 g     F .text	00000174 OSMutexQuery
8112b710 g     F .text	00000088 .hidden __nedf2
81148496 g     O .rwdata	00000002 OSTaskDelEn
81114a80 g     F .text	00000038 vLoadDefaultEPValue
81156d64 g     O .bss	00001000 vFeeTask1_stk
81108298 g     F .text	00000074 bSyncCtrCh7OutEnable
81135198 g     F .text	00000118 OSSemQuery
81133ab8 g     F .text	00000288 OSQDel
81134094 g     F .text	00000174 OSQPendAbort
81148568 g     O .bss	00000004 xMutexPreParsed
8113806c g     F .text	00000040 alt_irq_init
8112dbd8 g     F .text	0000006c alt_release_fd
8113838c g     F .text	000000bc get_cluster_flag
811084dc g     F .text	00000074 bSyncIrqFlagClrBlank
811400d0 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
81147164 g     O .rwdata	00000031 alt_log_msg_stackpointer
811185ac g     F .text	00000074 sprintf
8114591c g     O .rodata	00000100 .hidden __clz_tab
81138960 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
8111275c g     F .text	00000068 vFailGetMutexTxUARTSenderTask
811485a8 g     O .bss	00000004 _PathLocale
811085a8 g     F .text	00000058 bSyncIrqFlagBlank
81106bcc g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
81137718 g     F .text	000001e8 OSTmrStop
81110f60 g     F .text	00000050 usiGetIdCMD
81124dd8 g     F .text	00000108 strtof
81104568 g     F .text	00000040 vFeebCh3HandleIrq
8112a3e8 g     F .text	000000bc .hidden __gesf2
81118774 g     F .text	0000004c strcspn
8111e9bc g     F .text	00000068 _write_r
81107268 g     F .text	00000074 vRstcReleaseDeviceReset
81112fa4 g     F .text	0000004c vFailInAckHandlerTaskCreate
8112ee6c g     F .text	00000094 OSSchedLock
81113830 g     F .text	00000068 vCoudlNotCreateNFee3Task
811219ec g     F .text	00000018 setlocale
8113f424 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
8115ed2c g     O .bss	00000800 OSTmrTaskStk
811184d0 g     F .text	00000044 scanf
81113aa0 g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
81130a74 g     F .text	00000110 OSFlagCreate
81138bf4 g     F .text	00000688 Check_for_DOS_FAT
8113aaa0 g     F .text	000002d0 create_file
81123670 g     F .text	00000008 nanf
81148408 g     O .rwdata	00000004 _impure_ptr
8114866c g     O .bss	00000004 CSD_register_w0
811485cc g     O .bss	00000004 alt_argc
81112a78 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
81120474 g     F .text	00000224 __sflush_r
81121a78 g     F .text	000000b4 _mbrtowc_r
811219d8 g     F .text	00000008 __locale_cjk_lang
81103394 g     F .text	0000078c sense_log
811484e0 g     O .bss	00000004 ESdmaBufferSide
81148466 g     O .rwdata	00000002 OSEventMultiEn
81116cf8 g     F .text	00000004 _fseek_r
81157d64 g     O .bss	00001800 vParserCommTask_stk
81112308 g     F .text	00000070 printErrorTask
81114af4 g     F .text	00000030 vChangeDefaultEPValue
8110ee7c g     F .text	000002c8 vCheckRetransmission32
81136ee8 g     F .text	000001c4 OSTmrCreate
8110dfa0 g     F .text	000007dc vStackMonitor
81118298 g     F .text	000001dc __srefill_r
811057f0 g     F .text	0000003c bEnableLvdsBoard
8114856c g     O .bss	00000004 xMutexBuffer32
81130b84 g     F .text	00000250 OSFlagDel
81148638 g     O .bss	00000004 OSEventFreeList
81105868 g     F .text	000000c0 bSetPreEmphasys
81108b08 g     F .text	0000012c vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
81121c0c g     F .text	0000004c __ascii_mbtowc
81107da4 g     F .text	00000078 bSyncCtrExtnIrq
81122a60 g     F .text	00000064 __ulp
81114680 g     F .text	000000f0 vNFeeControlInit
81131058 g     F .text	000005c0 OSFlagPend
811484b2 g     O .rwdata	00000002 OSTmrEn
81120acc g     F .text	00000018 __fp_unlock_all
81116c94 g     F .text	00000064 fputc
811106a8 g     F .text	000002f8 bSendUART32v2
8110c8c4 g     F .text	0000019c setPreAckReceiverFreePos
81107d64 g     F .text	00000040 bSyncErrInj
81148420 g     O .rwdata	00000008 alt_fs_list
81159564 g     O .bss	00001000 vSimMebTask_stk
81113a38 g     F .text	00000068 vCoudlNotCreateMebTask
8113943c g     F .text	00000274 check_file_name_for_FAT16_compliance
8115a564 g     O .bss	00001000 vFeeTask3_stk
811371ec g     F .text	00000140 OSTmrNameGet
81148954 g     O .bss	00000400 xSZData
81108d48 g     F .text	00000114 vQCmdFEEinFullPattern
8112ff9c g     F .text	0000007c OS_StrCopy
81148678 g     O .bss	00000004 buffer_memory
81112c80 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
81114934 g     F .text	00000098 vLogWriteNUC
8114847c g     O .rwdata	00000002 OSMemNameSize
81103b20 g     F .text	000000b0 bSdmaInitM1Dma
811083f4 g     F .text	00000074 bSyncIrqEnableBlank
81141030 g     F .text	00000028 OSInitHookEnd
81114160 g     F .text	00000340 vUpdateMemMapFEE
81112ef0 g     F .text	00000068 vFailSetPreAckReceiverBuffer
81104b70 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
811484a8 g     O .rwdata	00000002 OSTCBPrioTblMax
81121a04 g     F .text	0000000c localeconv
811139d0 g     F .text	00000068 vCoudlNotCreateDataControllerTask
81148570 g     O .bss	00000004 xTimerRetransmission
8110c3bc g     F .text	00000250 vReceiverUartTask
811485c8 g     O .bss	00000004 alt_log_sys_clk_count
811484a4 g     O .rwdata	00000002 OSTaskStatStkChkEn
8112d3f4 g     F .text	00000140 alt_log_write
8115b564 g     O .bss	00001000 vFeeTask2_stk
81148574 g     O .bss	00000004 xMutexBuffer128
811044e8 g     F .text	00000040 vFeebCh1HandleIrq
81104668 g     F .text	00000040 vFeebCh7HandleIrq
81140608 g     F .text	00000058 alt_ic_isr_register
81148478 g     O .rwdata	00000002 OSMemEn
811483f4 g     O .rwdata	00000004 alt_stack_limit_value
811172b8 g     F .text	0000003c fwrite
8114867c g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
81148482 g     O .rwdata	00000002 OSMutexEn
81113d38 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
811484d0 g       *ABS*	00000000 _edata
8113d488 g     F .text	00000068 altera_avalon_uart_read_fd
811147e4 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81162790 g       *ABS*	00000000 _end
81162190 g     O .bss	00000500 active_files
8114863c g     O .bss	00000001 OSIntNesting
81112810 g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
8111457c g     F .text	0000002c cFeeRMAPDump
81148578 g     O .bss	00000004 xSemCountBuffer32
811285fc g     F .text	0000016c __fputwc
8114851c g     O .bss	00000004 xQMaskFeeCtrl
811144cc g     F .text	0000002c vFeeSpwRMAPChangeConfig
8111e77c g     F .text	00000070 vfscanf
8113ad70 g     F .text	00000150 copy_file_record_name_to_string
8113ccf8 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
81136c40 g     F .text	000001dc OSTimeDlyResume
8113927c g     F .text	000000f4 Look_for_FAT16
81130f04 g     F .text	00000154 OSFlagNameSet
8114857c g     O .bss	00000004 xMutexBuffer64
81136478 g     F .text	000001c8 OSTaskStkChk
811406f0 g     F .text	00000094 alt_ic_irq_disable
81103c80 g     F .text	00000430 bSdmaDmaM1Transfer
8114847e g     O .rwdata	00000002 OSMemSize
81112940 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
81118684 g     F .text	00000084 __swrite
81148410 g     O .rwdata	00000004 __malloc_trim_threshold
811219cc g     F .text	0000000c __locale_msgcharset
8115c564 g     O .bss	00000010 xFeeQueueTBL1
81148640 g     O .bss	00000004 OSTCBCur
811132c0 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
81106cd0 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
81141150 g     F .text	00000040 exit
81133290 g     F .text	00000220 OSMutexPost
81108550 g     F .text	00000058 bSyncIrqFlagError
8113b19c g     F .text	000003c0 alt_up_sd_card_find_next
81148480 g     O .rwdata	00000002 OSMemTblSize
811217d4 g     F .text	000000cc _fwalk_reent
8113f81c g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
81115f84 g     F .text	000000f8 .hidden __floatunsisf
8112285c g     F .text	00000204 __mdiff
811136f8 g     F .text	00000068 vCoudlNotCreateNFee0Task
81104bc8 g     F .text	0000017c vFeebInitIrq
811128a8 g     F .text	0000004c vFailSenderCreate
8112a240 g     F .text	00000074 .hidden __modsi3
81113900 g     F .text	00000068 vCoudlNotCreateNFee5Task
81107cb0 g     F .text	0000003c uliSyncGetPer
81148580 g     O .bss	00000004 xMutexSenderACK
81113120 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
81148400 g     O .rwdata	00000004 __ctype_ptr__
81112e88 g     F .text	00000068 vFailSetPreParsedBuffer
811382ac g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
81120aa8 g     F .text	00000004 __sfp_lock_release
81104e18 g     F .text	000000ac bFeebGetIrqControl
811133f8 g     F .text	00000068 vCouldNotSendTurnOff
8112ecb4 g     F .text	00000064 OSInit
811061a0 g     F .text	00000078 bSetPainelLeds
8113ef64 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
81148644 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
8113682c g     F .text	0000012c OSTaskQuery
81108380 g     F .text	00000074 bSyncIrqEnableError
81148584 g     O .bss	00000004 xMutexPus
81134868 g     F .text	000000b0 OS_QInit
811235a0 g     F .text	000000d0 __sccl
81116ac0 g     F .text	0000000c atoi
81108788 g     F .text	00000380 vFeeTask
81130018 g     F .text	0000005c OS_StrLen
81104960 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111222c g     F .text	000000dc vDataControllerInit
811322ac g     F .text	0000011c OSMemNameSet
81145a1c g     O .rodata	00000101 _ctype_
81107c74 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
81112a10 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
8114849a g     O .rwdata	00000002 OSTaskProfileEn
81113ed8 g     F .text	00000070 vEvtChangeMebMode
8113ee34 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
81148588 g     O .bss	00000004 xTxUARTMutex
81148648 g     O .bss	00000004 OSTime
81148418 g     O .rwdata	00000004 __mbtowc
8113daa8 g     F .text	0000005c altera_avalon_uart_close
8114864c g     O .bss	00000004 OSTmrSem
8115f52c g     O .bss	00001000 OSTaskIdleStk
81116ad8 g     F .text	000000fc _fopen_r
81148534 g     O .bss	00000004 pdata
81141480 g     F .text	000000bc _exit
81140158 g     F .text	00000134 alt_alarm_start
81130dd4 g     F .text	00000130 OSFlagNameGet
81136e1c g     F .text	00000064 OSTimeGet
811484e4 g     O .bss	00000004 ESdmaChBufferId
8113ba00 g     F .text	00000380 alt_up_sd_card_read
811172f4 g     F .text	000001c4 __smakebuf_r
8114858c g     O .bss	00000001 SemCount64
811103b0 g     F .text	000002f8 bSendUART64v2
81104a10 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
811484c8 g     O .rwdata	00000008 alt_msgdma_list
811187c0 g     F .text	00000098 strlen
8110750c g     F .text	000000b4 uc_spi_get_byte
81113da0 g     F .text	00000054 vFailSendMsgAccessDMA
81140f60 g     F .text	00000028 OSTaskSwHook
8112d934 g     F .text	0000015c open
8116052c g     O .bss	00000d00 OSEventTbl
811144f8 g     F .text	0000002c vFeeSpwRMAPChangeDefault
8112b798 g     F .text	000000dc .hidden __gedf2
8115c574 g     O .bss	00000020 xSenderACK
81140c54 g     F .text	00000044 alt_putchar
8116122c g     O .bss	00000e58 OSTCBTbl
81128914 g     F .text	00000838 __gethex
811352b0 g     F .text	00000108 OSSemSet
8110e77c g     F .text	0000006c vTimeoutCheckerTaskv2
811145a8 g     F .text	00000038 cFeeRMAPEchoingEnable
8114841c g     O .rwdata	00000004 __wctomb
8110f66c g     F .text	00000314 vVariablesInitialization
81126ec8 g     F .text	00000018 __sprint_r
81104ec4 g     F .text	00000088 bFeebGetIrqFlags
811484dc g     O .bss	00000004 pxDmaM2Dev
811123d8 g     F .text	0000004c vFailCreateSemaphoreResources
81148438 g     O .rwdata	00000004 alt_priority_mask
8110582c g     F .text	0000003c bDisableLvdsBoard
81134ab0 g     F .text	00000248 OSSemDel
81148650 g     O .bss	00000004 OSFlagFreeList
81107448 g     F .text	000000c4 v_spi_send_byte
8110777c g     F .text	000000d0 bSSDisplayConfig
81140660 g     F .text	00000090 alt_ic_irq_enable
81148460 g     O .rwdata	00000002 OSEventNameSize
8111ced8 g     F .text	0000001c __vfprintf_internal
81148654 g     O .bss	00000001 OSStatRdy
81108054 g     F .text	00000074 bSyncCtrCh2OutEnable
81162084 g     O .bss	000000a4 OSTCBPrioTbl
8113db48 g     F .text	00000270 altera_avalon_uart_read
8112961c g     F .text	00000064 _wctomb_r
8112e180 g     F .text	000000cc __env_lock
811484a6 g     O .rwdata	00000002 OSTaskSwHookEn
81104770 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
8112b968 g     F .text	00000904 .hidden __subdf3
8115c594 g     O .bss	00000260 xPreParsed
81107cec g     F .text	0000003c uliSyncGetOst
8114858d g     O .bss	00000001 SemCount128
8110483c g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
811109a0 g     F .text	00000290 vSendEthConf
81122270 g     F .text	000000b0 __lo0bits
8111cfb8 g     F .text	000017c4 __svfscanf_r
81148444 g     O .rwdata	00000008 alt_alarm_list
81126c10 g     F .text	0000019c _ungetc_r
8114846e g     O .rwdata	00000002 OSFlagWidth
81102a40 g     F .text	0000004c DMA_BUSY
81129524 g     F .text	000000c8 wcrtomb
8110ffc8 g     F .text	00000068 vCCDLoadDefaultValues
8112c5f4 g     F .text	000000d8 close
81107d28 g     F .text	0000003c uliSyncGetGeneral
81113fb8 g     F .text	00000070 vEvtChangeDataControllerMode
811485e4 g     O .bss	00000004 alt_envsem
8112cb24 g     F .text	00000068 alt_log_repchar
81148658 g     O .bss	00000004 OSIdleCtrRun
8112f33c g     F .text	00000028 OSVersion
811484b8 g     O .rwdata	00000002 OSTmrCfgWheelSize
81136958 g     F .text	00000078 OS_TaskStkClr
811150cc g     F .text	0000003c siOpenFile
8110872c g     F .text	0000005c vDataControlTask
81148492 g     O .rwdata	00000002 OSTaskCreateEn
81110c30 g     F .text	00000118 vSendTurnOff
811124d8 g     F .text	0000004c vFailSendPreParsedSemaphore
81139770 g     F .text	000002a4 match_file_record_to_name_ext
8112f964 g     F .text	00000070 OS_EventWaitListInit
8112878c g     F .text	00000088 fputwc
8115c7f4 g     O .bss	00000010 xFeeQueueTBL0
81112470 g     F .text	00000068 vFailSendxSemCommInit
81141058 g     F .text	00000028 OSTaskIdleHook
81110d48 g     F .text	00000118 vSendReset
81120aac g     F .text	00000004 __sinit_lock_acquire
81121fd4 g     F .text	00000128 __multadd
81104880 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
81107978 g     F .text	0000004c ucSyncStatusState
81136640 g     F .text	000001ec OSTaskSuspend
81121fac g     F .text	00000028 _Bfree
81107c38 g     F .text	0000003c uliSyncGetMbt
81130074 g     F .text	00000064 OS_TaskIdle
811484be g     O .rwdata	00000002 OSTmrTblSize
81134704 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	112ed180 	call	8112ed18 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045b4 	movhi	r2,33046
81100150:	1089a404 	addi	r2,r2,9872
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045b4 	movhi	r2,33046
81100168:	1089a404 	addi	r2,r2,9872
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	112ed6c0 	call	8112ed6c <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0a817 	ldw	r2,-32096(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0a817 	ldw	r2,-32096(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	21210f04 	addi	r4,r4,-31684
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204534 	movhi	r4,33044
81100270:	211c6604 	addi	r4,r4,29080
81100274:	112ca9c0 	call	8112ca9c <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	21210f04 	addi	r4,r4,-31684
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204534 	movhi	r4,33044
8110028c:	211c5904 	addi	r4,r4,29028
81100290:	112ca9c0 	call	8112ca9c <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d680fd14 	ori	gp,gp,1012
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	21210f04 	addi	r4,r4,-31684
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204534 	movhi	r4,33044
811002b8:	211c4a04 	addi	r4,r4,28968
811002bc:	112ca9c0 	call	8112ca9c <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
811002c4:	10a13414 	ori	r2,r2,34000

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18c9e414 	ori	r3,r3,10128

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	21210f04 	addi	r4,r4,-31684
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204534 	movhi	r4,33044
811002f8:	211c5104 	addi	r4,r4,28996
811002fc:	112ca9c0 	call	8112ca9c <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	112d6c80 	call	8112d6c8 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18e21504 	addi	r3,r3,-30636
81100330:	00a04534 	movhi	r2,33044
81100334:	10854f04 	addi	r2,r2,5436
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a05517 	ldw	r2,-32428(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	29621504 	addi	r5,r5,-30636
8110035c:	1009883a 	mov	r4,r2
81100360:	1116c1c0 	call	81116c1c <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18e21504 	addi	r3,r3,-30636
811003cc:	00a04534 	movhi	r2,33044
811003d0:	10855804 	addi	r2,r2,5472
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	1117ccc0 	call	81117ccc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a05517 	ldw	r2,-32428(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	29621504 	addi	r5,r5,-30636
811003f8:	1009883a 	mov	r4,r2
811003fc:	1116c1c0 	call	81116c1c <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18e21504 	addi	r3,r3,-30636
81100410:	00a04534 	movhi	r2,33044
81100414:	10856404 	addi	r2,r2,5520
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a05517 	ldw	r2,-32428(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	29621504 	addi	r5,r5,-30636
8110043c:	1009883a 	mov	r4,r2
81100440:	1116c1c0 	call	81116c1c <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	112def40 	call	8112def4 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	1105b0c0 	call	81105b0c <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604534 	movhi	r5,33044
811004b0:	29456a04 	addi	r5,r5,5544
811004b4:	01204574 	movhi	r4,33045
811004b8:	21221504 	addi	r4,r4,-30636
811004bc:	11185ac0 	call	811185ac <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a05517 	ldw	r2,-32428(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	29621504 	addi	r5,r5,-30636
811004cc:	1009883a 	mov	r4,r2
811004d0:	1116c1c0 	call	81116c1c <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18e21504 	addi	r3,r3,-30636
811004e0:	00a04534 	movhi	r2,33044
811004e4:	10856f04 	addi	r2,r2,5564
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	1117ccc0 	call	81117ccc <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a05517 	ldw	r2,-32428(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	29621504 	addi	r5,r5,-30636
8110050c:	1009883a 	mov	r4,r2
81100510:	1116c1c0 	call	81116c1c <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18e21504 	addi	r3,r3,-30636
81100544:	00a04534 	movhi	r2,33044
81100548:	10857504 	addi	r2,r2,5588
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a05517 	ldw	r2,-32428(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	29621504 	addi	r5,r5,-30636
81100570:	1009883a 	mov	r4,r2
81100574:	1116c1c0 	call	81116c1c <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18e21504 	addi	r3,r3,-30636
81100584:	00a04534 	movhi	r2,33044
81100588:	10857e04 	addi	r2,r2,5624
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a05517 	ldw	r2,-32428(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	29621504 	addi	r5,r5,-30636
811005b0:	1009883a 	mov	r4,r2
811005b4:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18e21504 	addi	r3,r3,-30636
811005c0:	00a04534 	movhi	r2,33044
811005c4:	10858604 	addi	r2,r2,5656
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a05517 	ldw	r2,-32428(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	29621504 	addi	r5,r5,-30636
811005ec:	1009883a 	mov	r4,r2
811005f0:	1116c1c0 	call	81116c1c <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	112def40 	call	8112def4 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	1105a2c0 	call	81105a2c <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18e21504 	addi	r3,r3,-30636
81100650:	00a04534 	movhi	r2,33044
81100654:	10858c04 	addi	r2,r2,5680
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a05517 	ldw	r2,-32428(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	29621504 	addi	r5,r5,-30636
8110067c:	1009883a 	mov	r4,r2
81100680:	1116c1c0 	call	81116c1c <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	1105b0c0 	call	81105b0c <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18e21504 	addi	r3,r3,-30636
811006cc:	00a04534 	movhi	r2,33044
811006d0:	10859204 	addi	r2,r2,5704
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	1117ccc0 	call	81117ccc <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a05517 	ldw	r2,-32428(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	29621504 	addi	r5,r5,-30636
811006f8:	1009883a 	mov	r4,r2
811006fc:	1116c1c0 	call	81116c1c <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604534 	movhi	r5,33044
81100730:	29459b04 	addi	r5,r5,5740
81100734:	01204574 	movhi	r4,33045
81100738:	21221504 	addi	r4,r4,-30636
8110073c:	11185ac0 	call	811185ac <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a05517 	ldw	r2,-32428(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	29621504 	addi	r5,r5,-30636
8110074c:	1009883a 	mov	r4,r2
81100750:	1116c1c0 	call	81116c1c <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18e21504 	addi	r3,r3,-30636
81100764:	00a04534 	movhi	r2,33044
81100768:	1085aa04 	addi	r2,r2,5800
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a05517 	ldw	r2,-32428(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	29621504 	addi	r5,r5,-30636
81100790:	1009883a 	mov	r4,r2
81100794:	1116c1c0 	call	81116c1c <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18e21504 	addi	r3,r3,-30636
811007a4:	00a04534 	movhi	r2,33044
811007a8:	1085b304 	addi	r2,r2,5836
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a05517 	ldw	r2,-32428(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	29621504 	addi	r5,r5,-30636
811007d0:	1009883a 	mov	r4,r2
811007d4:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	10a21504 	addi	r2,r2,-30636
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a05517 	ldw	r2,-32428(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	29621504 	addi	r5,r5,-30636
811007f8:	1009883a 	mov	r4,r2
811007fc:	1116c1c0 	call	81116c1c <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18e21504 	addi	r3,r3,-30636
81100840:	00a04534 	movhi	r2,33044
81100844:	1085bb04 	addi	r2,r2,5868
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a05517 	ldw	r2,-32428(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	29621504 	addi	r5,r5,-30636
8110086c:	1009883a 	mov	r4,r2
81100870:	1116c1c0 	call	81116c1c <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18e21504 	addi	r3,r3,-30636
811008dc:	00a04534 	movhi	r2,33044
811008e0:	1085c404 	addi	r2,r2,5904
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	1117ccc0 	call	81117ccc <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a05517 	ldw	r2,-32428(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	29621504 	addi	r5,r5,-30636
81100908:	1009883a 	mov	r4,r2
8110090c:	1116c1c0 	call	81116c1c <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	1105c140 	call	81105c14 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604534 	movhi	r5,33044
81100984:	2945d004 	addi	r5,r5,5952
81100988:	01204574 	movhi	r4,33045
8110098c:	21221504 	addi	r4,r4,-30636
81100990:	11185ac0 	call	811185ac <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a05517 	ldw	r2,-32428(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	29621504 	addi	r5,r5,-30636
811009a0:	1009883a 	mov	r4,r2
811009a4:	1116c1c0 	call	81116c1c <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18e21504 	addi	r3,r3,-30636
811009c0:	00a04534 	movhi	r2,33044
811009c4:	1085dc04 	addi	r2,r2,6000
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	1117ccc0 	call	81117ccc <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a05517 	ldw	r2,-32428(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	29621504 	addi	r5,r5,-30636
811009ec:	1009883a 	mov	r4,r2
811009f0:	1116c1c0 	call	81116c1c <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18e21504 	addi	r3,r3,-30636
81100a0c:	00a04534 	movhi	r2,33044
81100a10:	1085e804 	addi	r2,r2,6048
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a05517 	ldw	r2,-32428(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	29621504 	addi	r5,r5,-30636
81100a38:	1009883a 	mov	r4,r2
81100a3c:	1116c1c0 	call	81116c1c <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18e21504 	addi	r3,r3,-30636
81100a58:	00a04534 	movhi	r2,33044
81100a5c:	1085f004 	addi	r2,r2,6080
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	1117ccc0 	call	81117ccc <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a05517 	ldw	r2,-32428(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	29621504 	addi	r5,r5,-30636
81100a84:	1009883a 	mov	r4,r2
81100a88:	1116c1c0 	call	81116c1c <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18e21504 	addi	r3,r3,-30636
81100aa4:	00a04534 	movhi	r2,33044
81100aa8:	1085fa04 	addi	r2,r2,6120
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	1117ccc0 	call	81117ccc <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a05517 	ldw	r2,-32428(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	29621504 	addi	r5,r5,-30636
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	1116c1c0 	call	81116c1c <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18e21504 	addi	r3,r3,-30636
81100af0:	00a04534 	movhi	r2,33044
81100af4:	10860504 	addi	r2,r2,6164
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	1117ccc0 	call	81117ccc <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a05517 	ldw	r2,-32428(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	29621504 	addi	r5,r5,-30636
81100b1c:	1009883a 	mov	r4,r2
81100b20:	1116c1c0 	call	81116c1c <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18e21504 	addi	r3,r3,-30636
81100b3c:	00a04534 	movhi	r2,33044
81100b40:	10861104 	addi	r2,r2,6212
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a05517 	ldw	r2,-32428(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	29621504 	addi	r5,r5,-30636
81100b68:	1009883a 	mov	r4,r2
81100b6c:	1116c1c0 	call	81116c1c <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18e21504 	addi	r3,r3,-30636
81100b88:	00a04534 	movhi	r2,33044
81100b8c:	10861704 	addi	r2,r2,6236
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a05517 	ldw	r2,-32428(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	29621504 	addi	r5,r5,-30636
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	1116c1c0 	call	81116c1c <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18e21504 	addi	r3,r3,-30636
81100bd4:	00a04534 	movhi	r2,33044
81100bd8:	10861f04 	addi	r2,r2,6268
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	1117ccc0 	call	81117ccc <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a05517 	ldw	r2,-32428(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	29621504 	addi	r5,r5,-30636
81100c00:	1009883a 	mov	r4,r2
81100c04:	1116c1c0 	call	81116c1c <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18e21504 	addi	r3,r3,-30636
81100c20:	00a04534 	movhi	r2,33044
81100c24:	10862c04 	addi	r2,r2,6320
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a05517 	ldw	r2,-32428(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	29621504 	addi	r5,r5,-30636
81100c4c:	1009883a 	mov	r4,r2
81100c50:	1116c1c0 	call	81116c1c <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18e21504 	addi	r3,r3,-30636
81100c6c:	00a04534 	movhi	r2,33044
81100c70:	10863204 	addi	r2,r2,6344
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a05517 	ldw	r2,-32428(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	29621504 	addi	r5,r5,-30636
81100c98:	1009883a 	mov	r4,r2
81100c9c:	1116c1c0 	call	81116c1c <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18e21504 	addi	r3,r3,-30636
81100cb8:	00a04534 	movhi	r2,33044
81100cbc:	10863704 	addi	r2,r2,6364
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a05517 	ldw	r2,-32428(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	29621504 	addi	r5,r5,-30636
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	1116c1c0 	call	81116c1c <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18e21504 	addi	r3,r3,-30636
81100d04:	00a04534 	movhi	r2,33044
81100d08:	10863e04 	addi	r2,r2,6392
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	1117ccc0 	call	81117ccc <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a05517 	ldw	r2,-32428(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	29621504 	addi	r5,r5,-30636
81100d30:	1009883a 	mov	r4,r2
81100d34:	1116c1c0 	call	81116c1c <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18e21504 	addi	r3,r3,-30636
81100d50:	00a04534 	movhi	r2,33044
81100d54:	10864c04 	addi	r2,r2,6448
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	1117ccc0 	call	81117ccc <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a05517 	ldw	r2,-32428(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	29621504 	addi	r5,r5,-30636
81100d7c:	1009883a 	mov	r4,r2
81100d80:	1116c1c0 	call	81116c1c <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18e21504 	addi	r3,r3,-30636
81100d9c:	00a04534 	movhi	r2,33044
81100da0:	10865e04 	addi	r2,r2,6520
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a05517 	ldw	r2,-32428(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	29621504 	addi	r5,r5,-30636
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	1116c1c0 	call	81116c1c <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18e21504 	addi	r3,r3,-30636
81100de8:	00a04534 	movhi	r2,33044
81100dec:	10866604 	addi	r2,r2,6552
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	1117ccc0 	call	81117ccc <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a05517 	ldw	r2,-32428(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	29621504 	addi	r5,r5,-30636
81100e14:	1009883a 	mov	r4,r2
81100e18:	1116c1c0 	call	81116c1c <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18e21504 	addi	r3,r3,-30636
81100e34:	00a04534 	movhi	r2,33044
81100e38:	10867004 	addi	r2,r2,6592
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	1117ccc0 	call	81117ccc <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a05517 	ldw	r2,-32428(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	29621504 	addi	r5,r5,-30636
81100e60:	1009883a 	mov	r4,r2
81100e64:	1116c1c0 	call	81116c1c <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18e21504 	addi	r3,r3,-30636
81100e80:	00a04534 	movhi	r2,33044
81100e84:	10867d04 	addi	r2,r2,6644
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	1117ccc0 	call	81117ccc <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a05517 	ldw	r2,-32428(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	29621504 	addi	r5,r5,-30636
81100eac:	1009883a 	mov	r4,r2
81100eb0:	1116c1c0 	call	81116c1c <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18e21504 	addi	r3,r3,-30636
81100ecc:	00a04534 	movhi	r2,33044
81100ed0:	10868704 	addi	r2,r2,6684
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	1117ccc0 	call	81117ccc <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a05517 	ldw	r2,-32428(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	29621504 	addi	r5,r5,-30636
81100ef8:	1009883a 	mov	r4,r2
81100efc:	1116c1c0 	call	81116c1c <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18e21504 	addi	r3,r3,-30636
81100f18:	00a04534 	movhi	r2,33044
81100f1c:	10869204 	addi	r2,r2,6728
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	1117ccc0 	call	81117ccc <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a05517 	ldw	r2,-32428(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	29621504 	addi	r5,r5,-30636
81100f44:	1009883a 	mov	r4,r2
81100f48:	1116c1c0 	call	81116c1c <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18e21504 	addi	r3,r3,-30636
81100f64:	00a04534 	movhi	r2,33044
81100f68:	1086a304 	addi	r2,r2,6796
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	1117ccc0 	call	81117ccc <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a05517 	ldw	r2,-32428(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	29621504 	addi	r5,r5,-30636
81100f90:	1009883a 	mov	r4,r2
81100f94:	1116c1c0 	call	81116c1c <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18e21504 	addi	r3,r3,-30636
81100fb0:	00a04534 	movhi	r2,33044
81100fb4:	1086ae04 	addi	r2,r2,6840
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	1117ccc0 	call	81117ccc <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a05517 	ldw	r2,-32428(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	29621504 	addi	r5,r5,-30636
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	1116c1c0 	call	81116c1c <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18e21504 	addi	r3,r3,-30636
81100ffc:	00a04534 	movhi	r2,33044
81101000:	1086bb04 	addi	r2,r2,6892
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	1117ccc0 	call	81117ccc <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a05517 	ldw	r2,-32428(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	29621504 	addi	r5,r5,-30636
81101028:	1009883a 	mov	r4,r2
8110102c:	1116c1c0 	call	81116c1c <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18e21504 	addi	r3,r3,-30636
81101048:	00a04534 	movhi	r2,33044
8110104c:	1086c904 	addi	r2,r2,6948
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	1117ccc0 	call	81117ccc <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a05517 	ldw	r2,-32428(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	29621504 	addi	r5,r5,-30636
81101074:	1009883a 	mov	r4,r2
81101078:	1116c1c0 	call	81116c1c <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18e21504 	addi	r3,r3,-30636
81101094:	00a04534 	movhi	r2,33044
81101098:	1086d604 	addi	r2,r2,7000
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	1117ccc0 	call	81117ccc <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a05517 	ldw	r2,-32428(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	29621504 	addi	r5,r5,-30636
811010c0:	1009883a 	mov	r4,r2
811010c4:	1116c1c0 	call	81116c1c <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18e21504 	addi	r3,r3,-30636
811010e0:	00a04534 	movhi	r2,33044
811010e4:	1086e304 	addi	r2,r2,7052
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a05517 	ldw	r2,-32428(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	29621504 	addi	r5,r5,-30636
8110110c:	1009883a 	mov	r4,r2
81101110:	1116c1c0 	call	81116c1c <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	10a21504 	addi	r2,r2,-30636
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a05517 	ldw	r2,-32428(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	29621504 	addi	r5,r5,-30636
81101194:	1009883a 	mov	r4,r2
81101198:	1116c1c0 	call	81116c1c <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18e21504 	addi	r3,r3,-30636
811011b4:	00a04534 	movhi	r2,33044
811011b8:	1086e704 	addi	r2,r2,7068
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a05517 	ldw	r2,-32428(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	29621504 	addi	r5,r5,-30636
811011e0:	1009883a 	mov	r4,r2
811011e4:	1116c1c0 	call	81116c1c <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18e21504 	addi	r3,r3,-30636
81101200:	00a04534 	movhi	r2,33044
81101204:	1086ef04 	addi	r2,r2,7100
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	1117ccc0 	call	81117ccc <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a05517 	ldw	r2,-32428(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	29621504 	addi	r5,r5,-30636
8110122c:	1009883a 	mov	r4,r2
81101230:	1116c1c0 	call	81116c1c <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18e21504 	addi	r3,r3,-30636
8110124c:	00a04534 	movhi	r2,33044
81101250:	1086fd04 	addi	r2,r2,7156
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a05517 	ldw	r2,-32428(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	29621504 	addi	r5,r5,-30636
81101278:	1009883a 	mov	r4,r2
8110127c:	1116c1c0 	call	81116c1c <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18e21504 	addi	r3,r3,-30636
81101298:	00a04534 	movhi	r2,33044
8110129c:	10870504 	addi	r2,r2,7188
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a05517 	ldw	r2,-32428(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	29621504 	addi	r5,r5,-30636
811012c4:	1009883a 	mov	r4,r2
811012c8:	1116c1c0 	call	81116c1c <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18e21504 	addi	r3,r3,-30636
811012e4:	00a04534 	movhi	r2,33044
811012e8:	10870d04 	addi	r2,r2,7220
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	1117ccc0 	call	81117ccc <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a05517 	ldw	r2,-32428(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	29621504 	addi	r5,r5,-30636
81101310:	1009883a 	mov	r4,r2
81101314:	1116c1c0 	call	81116c1c <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18e21504 	addi	r3,r3,-30636
81101330:	00a04534 	movhi	r2,33044
81101334:	10871704 	addi	r2,r2,7260
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a05517 	ldw	r2,-32428(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	29621504 	addi	r5,r5,-30636
8110135c:	1009883a 	mov	r4,r2
81101360:	1116c1c0 	call	81116c1c <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18e21504 	addi	r3,r3,-30636
8110137c:	00a04534 	movhi	r2,33044
81101380:	10871e04 	addi	r2,r2,7288
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	1117ccc0 	call	81117ccc <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a05517 	ldw	r2,-32428(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	29621504 	addi	r5,r5,-30636
811013a8:	1009883a 	mov	r4,r2
811013ac:	1116c1c0 	call	81116c1c <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18e21504 	addi	r3,r3,-30636
811013c8:	00a04534 	movhi	r2,33044
811013cc:	10872804 	addi	r2,r2,7328
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a05517 	ldw	r2,-32428(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	29621504 	addi	r5,r5,-30636
811013f4:	1009883a 	mov	r4,r2
811013f8:	1116c1c0 	call	81116c1c <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	10a21504 	addi	r2,r2,-30636
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a05517 	ldw	r2,-32428(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	29621504 	addi	r5,r5,-30636
81101420:	1009883a 	mov	r4,r2
81101424:	1116c1c0 	call	81116c1c <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18e21504 	addi	r3,r3,-30636
81101454:	00a04534 	movhi	r2,33044
81101458:	10873204 	addi	r2,r2,7368
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a05517 	ldw	r2,-32428(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	29621504 	addi	r5,r5,-30636
81101480:	1009883a 	mov	r4,r2
81101484:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	10a21504 	addi	r2,r2,-30636
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a05517 	ldw	r2,-32428(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	29621504 	addi	r5,r5,-30636
811014a8:	1009883a 	mov	r4,r2
811014ac:	1116c1c0 	call	81116c1c <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18e21504 	addi	r3,r3,-30636
81101538:	00a04534 	movhi	r2,33044
8110153c:	10873804 	addi	r2,r2,7392
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	1117ccc0 	call	81117ccc <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a05517 	ldw	r2,-32428(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	29621504 	addi	r5,r5,-30636
81101564:	1009883a 	mov	r4,r2
81101568:	1116c1c0 	call	81116c1c <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18e21504 	addi	r3,r3,-30636
811015b4:	00a04534 	movhi	r2,33044
811015b8:	10874704 	addi	r2,r2,7452
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a05517 	ldw	r2,-32428(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	29621504 	addi	r5,r5,-30636
811015e0:	1009883a 	mov	r4,r2
811015e4:	1116c1c0 	call	81116c1c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18e21504 	addi	r3,r3,-30636
81101648:	00a04534 	movhi	r2,33044
8110164c:	10855804 	addi	r2,r2,5472
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	1117ccc0 	call	81117ccc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a05517 	ldw	r2,-32428(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	29621504 	addi	r5,r5,-30636
81101674:	1009883a 	mov	r4,r2
81101678:	1116c1c0 	call	81116c1c <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604534 	movhi	r5,33044
81101694:	29475104 	addi	r5,r5,7492
81101698:	01204574 	movhi	r4,33045
8110169c:	21221504 	addi	r4,r4,-30636
811016a0:	11185ac0 	call	811185ac <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a05517 	ldw	r2,-32428(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	29621504 	addi	r5,r5,-30636
811016b0:	1009883a 	mov	r4,r2
811016b4:	1116c1c0 	call	81116c1c <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a07a17 	ldw	r2,-32280(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10a25504 	addi	r2,r2,-30380
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10a25504 	addi	r2,r2,-30380
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10a25504 	addi	r2,r2,-30380
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10a25504 	addi	r2,r2,-30380
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10a25504 	addi	r2,r2,-30380
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10a25504 	addi	r2,r2,-30380
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10a25504 	addi	r2,r2,-30380
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18e21504 	addi	r3,r3,-30636
81101868:	00a04534 	movhi	r2,33044
8110186c:	10875704 	addi	r2,r2,7516
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a05517 	ldw	r2,-32428(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	29621504 	addi	r5,r5,-30636
81101894:	1009883a 	mov	r4,r2
81101898:	1116c1c0 	call	81116c1c <fprintf>
8110189c:	d0a07a17 	ldw	r2,-32280(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	29625504 	addi	r5,r5,-30380
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	1117ccc0 	call	81117ccc <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604534 	movhi	r5,33044
81101990:	29475c04 	addi	r5,r5,7536
81101994:	01204574 	movhi	r4,33045
81101998:	21221504 	addi	r4,r4,-30636
8110199c:	11185ac0 	call	811185ac <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a05517 	ldw	r2,-32428(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	29621504 	addi	r5,r5,-30636
811019ac:	1009883a 	mov	r4,r2
811019b0:	1116c1c0 	call	81116c1c <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	112c6cc0 	call	8112c6cc <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	10a21504 	addi	r2,r2,-30636
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a05517 	ldw	r2,-32428(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	29621504 	addi	r5,r5,-30636
811019e4:	1009883a 	mov	r4,r2
811019e8:	1116c1c0 	call	81116c1c <fprintf>
811019ec:	d0e07a17 	ldw	r3,-32280(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	1115e580 	call	81115e58 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a07917 	ldw	r2,-32284(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	1115f840 	call	81115f84 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111560c0 	call	8111560c <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	111679c0 	call	8111679c <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604534 	movhi	r5,33044
81101a54:	29475e04 	addi	r5,r5,7544
81101a58:	01204574 	movhi	r4,33045
81101a5c:	21221504 	addi	r4,r4,-30636
81101a60:	11185ac0 	call	811185ac <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a05517 	ldw	r2,-32428(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	29621504 	addi	r5,r5,-30636
81101a70:	1009883a 	mov	r4,r2
81101a74:	1116c1c0 	call	81116c1c <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18e21504 	addi	r3,r3,-30636
81101a84:	00a04534 	movhi	r2,33044
81101a88:	10876a04 	addi	r2,r2,7592
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a05517 	ldw	r2,-32428(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	29621504 	addi	r5,r5,-30636
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	10a21504 	addi	r2,r2,-30636
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a05517 	ldw	r2,-32428(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	29621504 	addi	r5,r5,-30636
81101ad8:	1009883a 	mov	r4,r2
81101adc:	1116c1c0 	call	81116c1c <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18e21504 	addi	r3,r3,-30636
81101b30:	00a04534 	movhi	r2,33044
81101b34:	10877004 	addi	r2,r2,7616
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a05517 	ldw	r2,-32428(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	29621504 	addi	r5,r5,-30636
81101b5c:	1009883a 	mov	r4,r2
81101b60:	1116c1c0 	call	81116c1c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18e21504 	addi	r3,r3,-30636
81101bc4:	00a04534 	movhi	r2,33044
81101bc8:	10855804 	addi	r2,r2,5472
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	1117ccc0 	call	81117ccc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a05517 	ldw	r2,-32428(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	29621504 	addi	r5,r5,-30636
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	1116c1c0 	call	81116c1c <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604534 	movhi	r5,33044
81101c10:	29477a04 	addi	r5,r5,7656
81101c14:	01204574 	movhi	r4,33045
81101c18:	21221504 	addi	r4,r4,-30636
81101c1c:	11185ac0 	call	811185ac <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a05517 	ldw	r2,-32428(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	29621504 	addi	r5,r5,-30636
81101c2c:	1009883a 	mov	r4,r2
81101c30:	1116c1c0 	call	81116c1c <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18e21504 	addi	r3,r3,-30636
81101cd0:	00a04534 	movhi	r2,33044
81101cd4:	10878004 	addi	r2,r2,7680
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a05517 	ldw	r2,-32428(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	29621504 	addi	r5,r5,-30636
81101cfc:	1009883a 	mov	r4,r2
81101d00:	1116c1c0 	call	81116c1c <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a07a17 	ldw	r2,-32280(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10a25504 	addi	r2,r2,-30380
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10a25504 	addi	r2,r2,-30380
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604534 	movhi	r5,33044
81101df4:	29478704 	addi	r5,r5,7708
81101df8:	01204574 	movhi	r4,33045
81101dfc:	21221504 	addi	r4,r4,-30636
81101e00:	11185ac0 	call	811185ac <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a05517 	ldw	r2,-32428(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	29621504 	addi	r5,r5,-30636
81101e10:	1009883a 	mov	r4,r2
81101e14:	1116c1c0 	call	81116c1c <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604534 	movhi	r5,33044
81101e98:	29475c04 	addi	r5,r5,7536
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	21221504 	addi	r4,r4,-30636
81101ea4:	11185ac0 	call	811185ac <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a05517 	ldw	r2,-32428(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	29621504 	addi	r5,r5,-30636
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	1116c1c0 	call	81116c1c <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	10a21504 	addi	r2,r2,-30636
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a05517 	ldw	r2,-32428(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	29621504 	addi	r5,r5,-30636
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	1116c1c0 	call	81116c1c <fprintf>
81101ef8:	d0e07a17 	ldw	r3,-32280(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	1115e580 	call	81115e58 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a07917 	ldw	r2,-32284(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	1115f840 	call	81115f84 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111560c0 	call	8111560c <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	111679c0 	call	8111679c <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604534 	movhi	r5,33044
81101f60:	29479504 	addi	r5,r5,7764
81101f64:	01204574 	movhi	r4,33045
81101f68:	21221504 	addi	r4,r4,-30636
81101f6c:	11185ac0 	call	811185ac <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a05517 	ldw	r2,-32428(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	29621504 	addi	r5,r5,-30636
81101f7c:	1009883a 	mov	r4,r2
81101f80:	1116c1c0 	call	81116c1c <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18e21504 	addi	r3,r3,-30636
81101f90:	00a04534 	movhi	r2,33044
81101f94:	1087a104 	addi	r2,r2,7812
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a05517 	ldw	r2,-32428(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	29621504 	addi	r5,r5,-30636
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	10a21504 	addi	r2,r2,-30636
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a05517 	ldw	r2,-32428(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	29621504 	addi	r5,r5,-30636
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	1116c1c0 	call	81116c1c <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18e21504 	addi	r3,r3,-30636
8110204c:	00a04534 	movhi	r2,33044
81102050:	1087a704 	addi	r2,r2,7836
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a05517 	ldw	r2,-32428(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	29621504 	addi	r5,r5,-30636
81102078:	1009883a 	mov	r4,r2
8110207c:	1116c1c0 	call	81116c1c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18e21504 	addi	r3,r3,-30636
811020e0:	00a04534 	movhi	r2,33044
811020e4:	10855804 	addi	r2,r2,5472
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	1117ccc0 	call	81117ccc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a05517 	ldw	r2,-32428(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	29621504 	addi	r5,r5,-30636
8110210c:	1009883a 	mov	r4,r2
81102110:	1116c1c0 	call	81116c1c <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604534 	movhi	r5,33044
8110212c:	29475104 	addi	r5,r5,7492
81102130:	01204574 	movhi	r4,33045
81102134:	21221504 	addi	r4,r4,-30636
81102138:	11185ac0 	call	811185ac <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a05517 	ldw	r2,-32428(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	29621504 	addi	r5,r5,-30636
81102148:	1009883a 	mov	r4,r2
8110214c:	1116c1c0 	call	81116c1c <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a07a17 	ldw	r2,-32280(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18e21504 	addi	r3,r3,-30636
811021ac:	00a04534 	movhi	r2,33044
811021b0:	1087b304 	addi	r2,r2,7884
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a05517 	ldw	r2,-32428(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	29621504 	addi	r5,r5,-30636
811021d8:	1009883a 	mov	r4,r2
811021dc:	1116c1c0 	call	81116c1c <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604534 	movhi	r5,33044
811021f0:	2947b904 	addi	r5,r5,7908
811021f4:	01204574 	movhi	r4,33045
811021f8:	21221504 	addi	r4,r4,-30636
811021fc:	11185ac0 	call	811185ac <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a05517 	ldw	r2,-32428(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	29621504 	addi	r5,r5,-30636
8110220c:	1009883a 	mov	r4,r2
81102210:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a07a17 	ldw	r2,-32280(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604534 	movhi	r5,33044
81102274:	2947bb04 	addi	r5,r5,7916
81102278:	01204574 	movhi	r4,33045
8110227c:	21221504 	addi	r4,r4,-30636
81102280:	11185ac0 	call	811185ac <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a05517 	ldw	r2,-32428(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	29621504 	addi	r5,r5,-30636
81102290:	1009883a 	mov	r4,r2
81102294:	1116c1c0 	call	81116c1c <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	112c6cc0 	call	8112c6cc <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604534 	movhi	r5,33044
811022fc:	2947be04 	addi	r5,r5,7928
81102300:	01204574 	movhi	r4,33045
81102304:	21221504 	addi	r4,r4,-30636
81102308:	11185ac0 	call	811185ac <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a05517 	ldw	r2,-32428(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	29621504 	addi	r5,r5,-30636
81102318:	1009883a 	mov	r4,r2
8110231c:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e07a17 	ldw	r3,-32280(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	1115e580 	call	81115e58 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a07917 	ldw	r2,-32284(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	1115f840 	call	81115f84 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111560c0 	call	8111560c <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	111679c0 	call	8111679c <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604534 	movhi	r5,33044
81102394:	2947c104 	addi	r5,r5,7940
81102398:	01204574 	movhi	r4,33045
8110239c:	21221504 	addi	r4,r4,-30636
811023a0:	11185ac0 	call	811185ac <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a05517 	ldw	r2,-32428(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	29621504 	addi	r5,r5,-30636
811023b0:	1009883a 	mov	r4,r2
811023b4:	1116c1c0 	call	81116c1c <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604534 	movhi	r5,33044
811023c4:	2947cd04 	addi	r5,r5,7988
811023c8:	01204574 	movhi	r4,33045
811023cc:	21221504 	addi	r4,r4,-30636
811023d0:	11185ac0 	call	811185ac <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a05517 	ldw	r2,-32428(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	29621504 	addi	r5,r5,-30636
811023e0:	1009883a 	mov	r4,r2
811023e4:	1116c1c0 	call	81116c1c <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18e21504 	addi	r3,r3,-30636
811023f4:	00a04534 	movhi	r2,33044
811023f8:	10876a04 	addi	r2,r2,7592
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a05517 	ldw	r2,-32428(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	29621504 	addi	r5,r5,-30636
81102420:	1009883a 	mov	r4,r2
81102424:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	10a21504 	addi	r2,r2,-30636
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a05517 	ldw	r2,-32428(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	29621504 	addi	r5,r5,-30636
81102448:	1009883a 	mov	r4,r2
8110244c:	1116c1c0 	call	81116c1c <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18e21504 	addi	r3,r3,-30636
811024b8:	00a04534 	movhi	r2,33044
811024bc:	1087d704 	addi	r2,r2,8028
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a05517 	ldw	r2,-32428(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	29621504 	addi	r5,r5,-30636
811024e4:	1009883a 	mov	r4,r2
811024e8:	1116c1c0 	call	81116c1c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18e21504 	addi	r3,r3,-30636
8110254c:	00a04534 	movhi	r2,33044
81102550:	10855804 	addi	r2,r2,5472
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	1117ccc0 	call	81117ccc <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a05517 	ldw	r2,-32428(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	29621504 	addi	r5,r5,-30636
81102578:	1009883a 	mov	r4,r2
8110257c:	1116c1c0 	call	81116c1c <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604534 	movhi	r5,33044
81102598:	29475104 	addi	r5,r5,7492
8110259c:	01204574 	movhi	r4,33045
811025a0:	21221504 	addi	r4,r4,-30636
811025a4:	11185ac0 	call	811185ac <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a05517 	ldw	r2,-32428(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	29621504 	addi	r5,r5,-30636
811025b4:	1009883a 	mov	r4,r2
811025b8:	1116c1c0 	call	81116c1c <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18e21504 	addi	r3,r3,-30636
81102610:	00a04534 	movhi	r2,33044
81102614:	1087e304 	addi	r2,r2,8076
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a05517 	ldw	r2,-32428(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	29621504 	addi	r5,r5,-30636
8110263c:	1009883a 	mov	r4,r2
81102640:	1116c1c0 	call	81116c1c <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604534 	movhi	r5,33044
81102654:	2947b904 	addi	r5,r5,7908
81102658:	01204574 	movhi	r4,33045
8110265c:	21221504 	addi	r4,r4,-30636
81102660:	11185ac0 	call	811185ac <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a05517 	ldw	r2,-32428(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	29621504 	addi	r5,r5,-30636
81102670:	1009883a 	mov	r4,r2
81102674:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a07a17 	ldw	r2,-32280(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604534 	movhi	r5,33044
811026c8:	2947e904 	addi	r5,r5,8100
811026cc:	01204574 	movhi	r4,33045
811026d0:	21221504 	addi	r4,r4,-30636
811026d4:	11185ac0 	call	811185ac <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a05517 	ldw	r2,-32428(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	29621504 	addi	r5,r5,-30636
811026e4:	1009883a 	mov	r4,r2
811026e8:	1116c1c0 	call	81116c1c <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604534 	movhi	r5,33044
81102710:	2947bb04 	addi	r5,r5,7916
81102714:	01204574 	movhi	r4,33045
81102718:	21221504 	addi	r4,r4,-30636
8110271c:	11185ac0 	call	811185ac <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a05517 	ldw	r2,-32428(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	29621504 	addi	r5,r5,-30636
8110272c:	1009883a 	mov	r4,r2
81102730:	1116c1c0 	call	81116c1c <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604534 	movhi	r5,33044
81102794:	2947be04 	addi	r5,r5,7928
81102798:	01204574 	movhi	r4,33045
8110279c:	21221504 	addi	r4,r4,-30636
811027a0:	11185ac0 	call	811185ac <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a05517 	ldw	r2,-32428(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	29621504 	addi	r5,r5,-30636
811027b0:	1009883a 	mov	r4,r2
811027b4:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e07a17 	ldw	r3,-32280(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	1115e580 	call	81115e58 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a07917 	ldw	r2,-32284(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	1115f840 	call	81115f84 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111560c0 	call	8111560c <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	111679c0 	call	8111679c <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604534 	movhi	r5,33044
8110282c:	2947f104 	addi	r5,r5,8132
81102830:	01204574 	movhi	r4,33045
81102834:	21221504 	addi	r4,r4,-30636
81102838:	11185ac0 	call	811185ac <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a05517 	ldw	r2,-32428(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	29621504 	addi	r5,r5,-30636
81102848:	1009883a 	mov	r4,r2
8110284c:	1116c1c0 	call	81116c1c <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604534 	movhi	r5,33044
8110285c:	2947fd04 	addi	r5,r5,8180
81102860:	01204574 	movhi	r4,33045
81102864:	21221504 	addi	r4,r4,-30636
81102868:	11185ac0 	call	811185ac <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a05517 	ldw	r2,-32428(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	29621504 	addi	r5,r5,-30636
81102878:	1009883a 	mov	r4,r2
8110287c:	1116c1c0 	call	81116c1c <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18e21504 	addi	r3,r3,-30636
8110288c:	00a04534 	movhi	r2,33044
81102890:	1087a104 	addi	r2,r2,7812
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	1117ccc0 	call	81117ccc <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a05517 	ldw	r2,-32428(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	29621504 	addi	r5,r5,-30636
811028b8:	1009883a 	mov	r4,r2
811028bc:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	10a21504 	addi	r2,r2,-30636
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a05517 	ldw	r2,-32428(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	29621504 	addi	r5,r5,-30636
811028e0:	1009883a 	mov	r4,r2
811028e4:	1116c1c0 	call	81116c1c <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	113fdd80 	call	8113fdd8 <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000e1e 	bne	r2,zero,81102ba8 <DMA_DISPATCHER_STOP+0x84>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000706 	br	81102b90 <DMA_DISPATCHER_STOP+0x6c>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	112def40 	call	8112def4 <usleep>
81102b84:	00000206 	br	81102b90 <DMA_DISPATCHER_STOP+0x6c>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e13fff17 	ldw	r4,-4(fp)
81102b8c:	112def40 	call	8112def4 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b90:	e0bffd17 	ldw	r2,-12(fp)
81102b94:	10800317 	ldw	r2,12(r2)
81102b98:	10800037 	ldwio	r2,0(r2)
81102b9c:	1080080c 	andi	r2,r2,32
81102ba0:	103ff41e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba4:	00000206 	br	81102bb0 <DMA_DISPATCHER_STOP+0x8c>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102ba8:	e0bffc17 	ldw	r2,-16(fp)
81102bac:	00000106 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
  }
  
  return bSuccess;
81102bb0:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb4:	e037883a 	mov	sp,fp
81102bb8:	dfc00117 	ldw	ra,4(sp)
81102bbc:	df000017 	ldw	fp,0(sp)
81102bc0:	dec00204 	addi	sp,sp,8
81102bc4:	f800283a 	ret

81102bc8 <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bc8:	defffa04 	addi	sp,sp,-24
81102bcc:	de00012e 	bgeu	sp,et,81102bd4 <DMA_DISPATCHER_RESET+0xc>
81102bd0:	003b68fa 	trap	3
81102bd4:	dfc00515 	stw	ra,20(sp)
81102bd8:	df000415 	stw	fp,16(sp)
81102bdc:	df000404 	addi	fp,sp,16
81102be0:	e13ffd15 	stw	r4,-12(fp)
81102be4:	e17ffe15 	stw	r5,-8(fp)
81102be8:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bec:	00800044 	movi	r2,1
81102bf0:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf4:	e0bffd17 	ldw	r2,-12(fp)
81102bf8:	10800317 	ldw	r2,12(r2)
81102bfc:	10800104 	addi	r2,r2,4
81102c00:	00c00084 	movi	r3,2
81102c04:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c08:	e0bffe17 	ldw	r2,-8(fp)
81102c0c:	10800058 	cmpnei	r2,r2,1
81102c10:	10000e1e 	bne	r2,zero,81102c4c <DMA_DISPATCHER_RESET+0x84>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c14:	00000706 	br	81102c34 <DMA_DISPATCHER_RESET+0x6c>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c18:	e0bfff17 	ldw	r2,-4(fp)
81102c1c:	1000031e 	bne	r2,zero,81102c2c <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c20:	01000044 	movi	r4,1
81102c24:	112def40 	call	8112def4 <usleep>
81102c28:	00000206 	br	81102c34 <DMA_DISPATCHER_RESET+0x6c>
      } else {
        usleep(WaitPeriodUs);
81102c2c:	e13fff17 	ldw	r4,-4(fp)
81102c30:	112def40 	call	8112def4 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c34:	e0bffd17 	ldw	r2,-12(fp)
81102c38:	10800317 	ldw	r2,12(r2)
81102c3c:	10800037 	ldwio	r2,0(r2)
81102c40:	1080100c 	andi	r2,r2,64
81102c44:	103ff41e 	bne	r2,zero,81102c18 <__reset+0xfb0e2c18>
81102c48:	00000206 	br	81102c54 <DMA_DISPATCHER_RESET+0x8c>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c4c:	e0bffc17 	ldw	r2,-16(fp)
81102c50:	00000106 	br	81102c58 <DMA_DISPATCHER_RESET+0x90>
  }
  
  return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
}
81102c58:	e037883a 	mov	sp,fp
81102c5c:	dfc00117 	ldw	ra,4(sp)
81102c60:	df000017 	ldw	fp,0(sp)
81102c64:	dec00204 	addi	sp,sp,8
81102c68:	f800283a 	ret

81102c6c <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c6c:	defff604 	addi	sp,sp,-40
81102c70:	de00012e 	bgeu	sp,et,81102c78 <DMA_SINGLE_TRANSFER+0xc>
81102c74:	003b68fa 	trap	3
81102c78:	dfc00915 	stw	ra,36(sp)
81102c7c:	df000815 	stw	fp,32(sp)
81102c80:	dc000715 	stw	r16,28(sp)
81102c84:	df000804 	addi	fp,sp,32
81102c88:	e13ffb15 	stw	r4,-20(fp)
81102c8c:	e17ffc15 	stw	r5,-16(fp)
81102c90:	e1bffd15 	stw	r6,-12(fp)
81102c94:	e1fffe15 	stw	r7,-8(fp)
81102c98:	defff804 	addi	sp,sp,-32
81102c9c:	d8800204 	addi	r2,sp,8
81102ca0:	108003c4 	addi	r2,r2,15
81102ca4:	1004d13a 	srli	r2,r2,4
81102ca8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cac:	00800044 	movi	r2,1
81102cb0:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cb4:	e0fffc17 	ldw	r3,-16(fp)
81102cb8:	e13ffd17 	ldw	r4,-12(fp)
81102cbc:	e0800217 	ldw	r2,8(fp)
81102cc0:	d8800115 	stw	r2,4(sp)
81102cc4:	e0bffe17 	ldw	r2,-8(fp)
81102cc8:	d8800015 	stw	r2,0(sp)
81102ccc:	200f883a 	mov	r7,r4
81102cd0:	180d883a 	mov	r6,r3
81102cd4:	800b883a 	mov	r5,r16
81102cd8:	e13ffb17 	ldw	r4,-20(fp)
81102cdc:	113edd40 	call	8113edd4 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce0:	10000326 	beq	r2,zero,81102cf0 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102ce4:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102ce8:	e0bffa17 	ldw	r2,-24(fp)
81102cec:	00001d06 	br	81102d64 <DMA_SINGLE_TRANSFER+0xf8>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf0:	800b883a 	mov	r5,r16
81102cf4:	e13ffb17 	ldw	r4,-20(fp)
81102cf8:	11400480 	call	81140048 <alt_msgdma_standard_descriptor_async_transfer>
81102cfc:	10000326 	beq	r2,zero,81102d0c <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d00:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d04:	e0bffa17 	ldw	r2,-24(fp)
81102d08:	00001606 	br	81102d64 <DMA_SINGLE_TRANSFER+0xf8>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	10800060 	cmpeqi	r2,r2,1
81102d14:	1007883a 	mov	r3,r2
81102d18:	e0800317 	ldw	r2,12(fp)
81102d1c:	10800060 	cmpeqi	r2,r2,1
81102d20:	1884703a 	and	r2,r3,r2
81102d24:	10803fcc 	andi	r2,r2,255
81102d28:	10000d26 	beq	r2,zero,81102d60 <DMA_SINGLE_TRANSFER+0xf4>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d2c:	00000706 	br	81102d4c <DMA_SINGLE_TRANSFER+0xe0>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d30:	e0800417 	ldw	r2,16(fp)
81102d34:	1000031e 	bne	r2,zero,81102d44 <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d38:	0100fa04 	movi	r4,1000
81102d3c:	112def40 	call	8112def4 <usleep>
81102d40:	00000206 	br	81102d4c <DMA_SINGLE_TRANSFER+0xe0>
      } else {
        usleep(WaitPeriodUs);
81102d44:	e1000417 	ldw	r4,16(fp)
81102d48:	112def40 	call	8112def4 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d4c:	e0bffb17 	ldw	r2,-20(fp)
81102d50:	10800317 	ldw	r2,12(r2)
81102d54:	10800037 	ldwio	r2,0(r2)
81102d58:	1080004c 	andi	r2,r2,1
81102d5c:	103ff41e 	bne	r2,zero,81102d30 <__reset+0xfb0e2d30>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d60:	e0bffa17 	ldw	r2,-24(fp)
}
81102d64:	e6ffff04 	addi	sp,fp,-4
81102d68:	dfc00217 	ldw	ra,8(sp)
81102d6c:	df000117 	ldw	fp,4(sp)
81102d70:	dc000017 	ldw	r16,0(sp)
81102d74:	dec00304 	addi	sp,sp,12
81102d78:	f800283a 	ret

81102d7c <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d7c:	defff504 	addi	sp,sp,-44
81102d80:	de00012e 	bgeu	sp,et,81102d88 <DMA_MULTIPLE_TRANSFER+0xc>
81102d84:	003b68fa 	trap	3
81102d88:	dfc00a15 	stw	ra,40(sp)
81102d8c:	df000915 	stw	fp,36(sp)
81102d90:	dc000815 	stw	r16,32(sp)
81102d94:	df000904 	addi	fp,sp,36
81102d98:	e13ffb15 	stw	r4,-20(fp)
81102d9c:	e17ffc15 	stw	r5,-16(fp)
81102da0:	e1bffd15 	stw	r6,-12(fp)
81102da4:	3805883a 	mov	r2,r7
81102da8:	e0bffe05 	stb	r2,-8(fp)
81102dac:	defff804 	addi	sp,sp,-32
81102db0:	d8800204 	addi	r2,sp,8
81102db4:	108003c4 	addi	r2,r2,15
81102db8:	1004d13a 	srli	r2,r2,4
81102dbc:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dc0:	00800044 	movi	r2,1
81102dc4:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dc8:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dcc:	00002506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102dd0:	e0bffa03 	ldbu	r2,-24(fp)
81102dd4:	1085883a 	add	r2,r2,r2
81102dd8:	1085883a 	add	r2,r2,r2
81102ddc:	1007883a 	mov	r3,r2
81102de0:	e0bffc17 	ldw	r2,-16(fp)
81102de4:	10c5883a 	add	r2,r2,r3
81102de8:	10800017 	ldw	r2,0(r2)
81102dec:	1009883a 	mov	r4,r2
81102df0:	e0bffa03 	ldbu	r2,-24(fp)
81102df4:	1085883a 	add	r2,r2,r2
81102df8:	1085883a 	add	r2,r2,r2
81102dfc:	1007883a 	mov	r3,r2
81102e00:	e0bffd17 	ldw	r2,-12(fp)
81102e04:	10c5883a 	add	r2,r2,r3
81102e08:	10800017 	ldw	r2,0(r2)
81102e0c:	1007883a 	mov	r3,r2
81102e10:	e0800317 	ldw	r2,12(fp)
81102e14:	10804034 	orhi	r2,r2,256
81102e18:	d8800115 	stw	r2,4(sp)
81102e1c:	e0800217 	ldw	r2,8(fp)
81102e20:	d8800015 	stw	r2,0(sp)
81102e24:	180f883a 	mov	r7,r3
81102e28:	200d883a 	mov	r6,r4
81102e2c:	800b883a 	mov	r5,r16
81102e30:	e13ffb17 	ldw	r4,-20(fp)
81102e34:	113edd40 	call	8113edd4 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e38:	10000226 	beq	r2,zero,81102e44 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e3c:	e03ff915 	stw	zero,-28(fp)
81102e40:	00000506 	br	81102e58 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e44:	800b883a 	mov	r5,r16
81102e48:	e13ffb17 	ldw	r4,-20(fp)
81102e4c:	11400480 	call	81140048 <alt_msgdma_standard_descriptor_async_transfer>
81102e50:	10000126 	beq	r2,zero,81102e58 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e54:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e58:	e0bffa03 	ldbu	r2,-24(fp)
81102e5c:	10800044 	addi	r2,r2,1
81102e60:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e64:	e0bff917 	ldw	r2,-28(fp)
81102e68:	10800060 	cmpeqi	r2,r2,1
81102e6c:	1009883a 	mov	r4,r2
81102e70:	e0fffa03 	ldbu	r3,-24(fp)
81102e74:	e0bffe03 	ldbu	r2,-8(fp)
81102e78:	10bfffc4 	addi	r2,r2,-1
81102e7c:	1884803a 	cmplt	r2,r3,r2
81102e80:	2084703a 	and	r2,r4,r2
81102e84:	10803fcc 	andi	r2,r2,255
81102e88:	103fd11e 	bne	r2,zero,81102dd0 <__reset+0xfb0e2dd0>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e8c:	e0bff917 	ldw	r2,-28(fp)
81102e90:	10800058 	cmpnei	r2,r2,1
81102e94:	1000211e 	bne	r2,zero,81102f1c <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102e98:	e0bffa03 	ldbu	r2,-24(fp)
81102e9c:	1085883a 	add	r2,r2,r2
81102ea0:	1085883a 	add	r2,r2,r2
81102ea4:	1007883a 	mov	r3,r2
81102ea8:	e0bffc17 	ldw	r2,-16(fp)
81102eac:	10c5883a 	add	r2,r2,r3
81102eb0:	10800017 	ldw	r2,0(r2)
81102eb4:	1009883a 	mov	r4,r2
81102eb8:	e0bffa03 	ldbu	r2,-24(fp)
81102ebc:	1085883a 	add	r2,r2,r2
81102ec0:	1085883a 	add	r2,r2,r2
81102ec4:	1007883a 	mov	r3,r2
81102ec8:	e0bffd17 	ldw	r2,-12(fp)
81102ecc:	10c5883a 	add	r2,r2,r3
81102ed0:	10800017 	ldw	r2,0(r2)
81102ed4:	1007883a 	mov	r3,r2
81102ed8:	e0800317 	ldw	r2,12(fp)
81102edc:	d8800115 	stw	r2,4(sp)
81102ee0:	e0800217 	ldw	r2,8(fp)
81102ee4:	d8800015 	stw	r2,0(sp)
81102ee8:	180f883a 	mov	r7,r3
81102eec:	200d883a 	mov	r6,r4
81102ef0:	800b883a 	mov	r5,r16
81102ef4:	e13ffb17 	ldw	r4,-20(fp)
81102ef8:	113edd40 	call	8113edd4 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102efc:	10000226 	beq	r2,zero,81102f08 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f00:	e03ff915 	stw	zero,-28(fp)
81102f04:	00000506 	br	81102f1c <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f08:	800b883a 	mov	r5,r16
81102f0c:	e13ffb17 	ldw	r4,-20(fp)
81102f10:	11400480 	call	81140048 <alt_msgdma_standard_descriptor_async_transfer>
81102f14:	10000126 	beq	r2,zero,81102f1c <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f18:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f1c:	e0bff917 	ldw	r2,-28(fp)
81102f20:	10800060 	cmpeqi	r2,r2,1
81102f24:	1007883a 	mov	r3,r2
81102f28:	e0800417 	ldw	r2,16(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1884703a 	and	r2,r3,r2
81102f34:	10803fcc 	andi	r2,r2,255
81102f38:	10000d26 	beq	r2,zero,81102f70 <DMA_MULTIPLE_TRANSFER+0x1f4>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f3c:	00000706 	br	81102f5c <DMA_MULTIPLE_TRANSFER+0x1e0>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f40:	e0800517 	ldw	r2,20(fp)
81102f44:	1000031e 	bne	r2,zero,81102f54 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f48:	0100fa04 	movi	r4,1000
81102f4c:	112def40 	call	8112def4 <usleep>
81102f50:	00000206 	br	81102f5c <DMA_MULTIPLE_TRANSFER+0x1e0>
      } else {
    	usleep(WaitPeriodUs);
81102f54:	e1000517 	ldw	r4,20(fp)
81102f58:	112def40 	call	8112def4 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f5c:	e0bffb17 	ldw	r2,-20(fp)
81102f60:	10800317 	ldw	r2,12(r2)
81102f64:	10800037 	ldwio	r2,0(r2)
81102f68:	1080004c 	andi	r2,r2,1
81102f6c:	103ff41e 	bne	r2,zero,81102f40 <__reset+0xfb0e2f40>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f70:	e0bff917 	ldw	r2,-28(fp)
}
81102f74:	e6ffff04 	addi	sp,fp,-4
81102f78:	dfc00217 	ldw	ra,8(sp)
81102f7c:	df000117 	ldw	fp,4(sp)
81102f80:	dc000017 	ldw	r16,0(sp)
81102f84:	dec00304 	addi	sp,sp,12
81102f88:	f800283a 	ret

81102f8c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f8c:	deffef04 	addi	sp,sp,-68
81102f90:	de00012e 	bgeu	sp,et,81102f98 <POWER_Read+0xc>
81102f94:	003b68fa 	trap	3
81102f98:	dfc01015 	stw	ra,64(sp)
81102f9c:	df000f15 	stw	fp,60(sp)
81102fa0:	df000f04 	addi	fp,sp,60
81102fa4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fa8:	00800044 	movi	r2,1
81102fac:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fb0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fb4:	00800204 	movi	r2,8
81102fb8:	e0bffc15 	stw	r2,-16(fp)
81102fbc:	00800104 	movi	r2,4
81102fc0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fc4:	00800044 	movi	r2,1
81102fc8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fcc:	00800044 	movi	r2,1
81102fd0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fd4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fd8:	e03ff515 	stw	zero,-44(fp)
81102fdc:	00009206 	br	81103228 <POWER_Read+0x29c>
		NextChannel = 0;
81102fe0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102fe4:	e0bff517 	ldw	r2,-44(fp)
81102fe8:	10c03fcc 	andi	r3,r2,255
81102fec:	e13ffa03 	ldbu	r4,-24(fp)
81102ff0:	e0bfff17 	ldw	r2,-4(fp)
81102ff4:	d8800115 	stw	r2,4(sp)
81102ff8:	e0bff917 	ldw	r2,-28(fp)
81102ffc:	d8800015 	stw	r2,0(sp)
81103000:	e1fff817 	ldw	r7,-32(fp)
81103004:	e1bff717 	ldw	r6,-36(fp)
81103008:	200b883a 	mov	r5,r4
8110300c:	1809883a 	mov	r4,r3
81103010:	1106d140 	call	81106d14 <POWER_SPI_RW>
81103014:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103018:	e03ff415 	stw	zero,-48(fp)
8110301c:	00007406 	br	811031f0 <POWER_Read+0x264>
			NextChannel = i + 1;
81103020:	e0bff417 	ldw	r2,-48(fp)
81103024:	10800044 	addi	r2,r2,1
81103028:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110302c:	e0bff517 	ldw	r2,-44(fp)
81103030:	10c03fcc 	andi	r3,r2,255
81103034:	e13ffa03 	ldbu	r4,-24(fp)
81103038:	e0bffe04 	addi	r2,fp,-8
8110303c:	d8800115 	stw	r2,4(sp)
81103040:	e0bff917 	ldw	r2,-28(fp)
81103044:	d8800015 	stw	r2,0(sp)
81103048:	e1fff817 	ldw	r7,-32(fp)
8110304c:	e1bff717 	ldw	r6,-36(fp)
81103050:	200b883a 	mov	r5,r4
81103054:	1809883a 	mov	r4,r3
81103058:	1106d140 	call	81106d14 <POWER_SPI_RW>
8110305c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103060:	e0bff317 	ldw	r2,-52(fp)
81103064:	10005026 	beq	r2,zero,811031a8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103068:	e0bffe17 	ldw	r2,-8(fp)
8110306c:	1004d7ba 	srli	r2,r2,30
81103070:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103074:	e0bffe17 	ldw	r2,-8(fp)
81103078:	1004d07a 	srli	r2,r2,1
8110307c:	108001cc 	andi	r2,r2,7
81103080:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d13a 	srli	r2,r2,4
8110308c:	1080004c 	andi	r2,r2,1
81103090:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d17a 	srli	r2,r2,5
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1080004c 	andi	r2,r2,1
811030ac:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030b0:	e0bffa43 	ldbu	r2,-23(fp)
811030b4:	10000d26 	beq	r2,zero,811030ec <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030b8:	e1bff417 	ldw	r6,-48(fp)
811030bc:	01604534 	movhi	r5,33044
811030c0:	29480704 	addi	r5,r5,8220
811030c4:	01204574 	movhi	r4,33045
811030c8:	21221504 	addi	r4,r4,-30636
811030cc:	11185ac0 	call	811185ac <sprintf>
					debug(fp, cDebugBuffer);
811030d0:	d0a05517 	ldw	r2,-32428(gp)
811030d4:	01604574 	movhi	r5,33045
811030d8:	29621504 	addi	r5,r5,-30636
811030dc:	1009883a 	mov	r4,r2
811030e0:	1116c1c0 	call	81116c1c <fprintf>
#endif
					bSuccess = FALSE;
811030e4:	e03ff315 	stw	zero,-52(fp)
811030e8:	00002206 	br	81103174 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030ec:	e0fffa83 	ldbu	r3,-22(fp)
811030f0:	e0bff417 	ldw	r2,-48(fp)
811030f4:	18801026 	beq	r3,r2,81103138 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
811030f8:	e0bffa83 	ldbu	r2,-22(fp)
811030fc:	d8800015 	stw	r2,0(sp)
81103100:	e1fff417 	ldw	r7,-48(fp)
81103104:	e1bff417 	ldw	r6,-48(fp)
81103108:	01604534 	movhi	r5,33044
8110310c:	29480d04 	addi	r5,r5,8244
81103110:	01204574 	movhi	r4,33045
81103114:	21221504 	addi	r4,r4,-30636
81103118:	11185ac0 	call	811185ac <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110311c:	d0a05517 	ldw	r2,-32428(gp)
81103120:	01604574 	movhi	r5,33045
81103124:	29621504 	addi	r5,r5,-30636
81103128:	1009883a 	mov	r4,r2
8110312c:	1116c1c0 	call	81116c1c <fprintf>
#endif
					bSuccess = FALSE;
81103130:	e03ff315 	stw	zero,-52(fp)
81103134:	00000f06 	br	81103174 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103138:	e0fffac3 	ldbu	r3,-21(fp)
8110313c:	e0bff817 	ldw	r2,-32(fp)
81103140:	18800c26 	beq	r3,r2,81103174 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103144:	e1bff417 	ldw	r6,-48(fp)
81103148:	01604534 	movhi	r5,33044
8110314c:	29481904 	addi	r5,r5,8292
81103150:	01204574 	movhi	r4,33045
81103154:	21221504 	addi	r4,r4,-30636
81103158:	11185ac0 	call	811185ac <sprintf>
					debug(fp, cDebugBuffer);
8110315c:	d0a05517 	ldw	r2,-32428(gp)
81103160:	01604574 	movhi	r5,33045
81103164:	29621504 	addi	r5,r5,-30636
81103168:	1009883a 	mov	r4,r2
8110316c:	1116c1c0 	call	81116c1c <fprintf>
#endif
					bSuccess = FALSE;
81103170:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103174:	e0bff317 	ldw	r2,-52(fp)
81103178:	10001a26 	beq	r2,zero,811031e4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110317c:	e0bff617 	ldw	r2,-40(fp)
81103180:	10c00044 	addi	r3,r2,1
81103184:	e0fff615 	stw	r3,-40(fp)
81103188:	1085883a 	add	r2,r2,r2
8110318c:	1085883a 	add	r2,r2,r2
81103190:	1007883a 	mov	r3,r2
81103194:	e0bfff17 	ldw	r2,-4(fp)
81103198:	10c5883a 	add	r2,r2,r3
8110319c:	e0fffe17 	ldw	r3,-8(fp)
811031a0:	10c00015 	stw	r3,0(r2)
811031a4:	00000f06 	br	811031e4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031a8:	00e04574 	movhi	r3,33045
811031ac:	18e21504 	addi	r3,r3,-30636
811031b0:	00a04534 	movhi	r2,33044
811031b4:	10881f04 	addi	r2,r2,8316
811031b8:	1009883a 	mov	r4,r2
811031bc:	00800444 	movi	r2,17
811031c0:	100d883a 	mov	r6,r2
811031c4:	200b883a 	mov	r5,r4
811031c8:	1809883a 	mov	r4,r3
811031cc:	1117ccc0 	call	81117ccc <memcpy>
				debug(fp, cDebugBuffer);
811031d0:	d0a05517 	ldw	r2,-32428(gp)
811031d4:	01604574 	movhi	r5,33045
811031d8:	29621504 	addi	r5,r5,-30636
811031dc:	1009883a 	mov	r4,r2
811031e0:	1116c1c0 	call	81116c1c <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031e4:	e0bff417 	ldw	r2,-48(fp)
811031e8:	10800044 	addi	r2,r2,1
811031ec:	e0bff415 	stw	r2,-48(fp)
811031f0:	e0bff517 	ldw	r2,-44(fp)
811031f4:	1085883a 	add	r2,r2,r2
811031f8:	1085883a 	add	r2,r2,r2
811031fc:	e0fff304 	addi	r3,fp,-52
81103200:	1885883a 	add	r2,r3,r2
81103204:	10800904 	addi	r2,r2,36
81103208:	10800017 	ldw	r2,0(r2)
8110320c:	e0fff417 	ldw	r3,-48(fp)
81103210:	1880020e 	bge	r3,r2,8110321c <POWER_Read+0x290>
81103214:	e0bff317 	ldw	r2,-52(fp)
81103218:	103f811e 	bne	r2,zero,81103020 <__reset+0xfb0e3020>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110321c:	e0bff517 	ldw	r2,-44(fp)
81103220:	10800044 	addi	r2,r2,1
81103224:	e0bff515 	stw	r2,-44(fp)
81103228:	e0bff517 	ldw	r2,-44(fp)
8110322c:	10800088 	cmpgei	r2,r2,2
81103230:	1000021e 	bne	r2,zero,8110323c <POWER_Read+0x2b0>
81103234:	e0bff317 	ldw	r2,-52(fp)
81103238:	103f691e 	bne	r2,zero,81102fe0 <__reset+0xfb0e2fe0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110323c:	e0bff317 	ldw	r2,-52(fp)
}
81103240:	e037883a 	mov	sp,fp
81103244:	dfc00117 	ldw	ra,4(sp)
81103248:	df000017 	ldw	fp,0(sp)
8110324c:	dec00204 	addi	sp,sp,8
81103250:	f800283a 	ret

81103254 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103254:	defff904 	addi	sp,sp,-28
81103258:	de00012e 	bgeu	sp,et,81103260 <TEMP_Read+0xc>
8110325c:	003b68fa 	trap	3
81103260:	dfc00615 	stw	ra,24(sp)
81103264:	df000515 	stw	fp,20(sp)
81103268:	df000504 	addi	fp,sp,20
8110326c:	e13ffe15 	stw	r4,-8(fp)
81103270:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103274:	00800c04 	movi	r2,48
81103278:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110327c:	e0bffd83 	ldbu	r2,-10(fp)
81103280:	10c03fcc 	andi	r3,r2,255
81103284:	18c0201c 	xori	r3,r3,128
81103288:	18ffe004 	addi	r3,r3,-128
8110328c:	e0bffdc4 	addi	r2,fp,-9
81103290:	d8800015 	stw	r2,0(sp)
81103294:	000f883a 	mov	r7,zero
81103298:	180d883a 	mov	r6,r3
8110329c:	01600034 	movhi	r5,32768
811032a0:	29426004 	addi	r5,r5,2432
811032a4:	01200034 	movhi	r4,32768
811032a8:	21026404 	addi	r4,r4,2448
811032ac:	1105b0c0 	call	81105b0c <I2C_Read>
811032b0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032b4:	e0bffc17 	ldw	r2,-16(fp)
811032b8:	10000226 	beq	r2,zero,811032c4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032bc:	e0bffdc3 	ldbu	r2,-9(fp)
811032c0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10001226 	beq	r2,zero,81103314 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032cc:	e0bffd83 	ldbu	r2,-10(fp)
811032d0:	10c03fcc 	andi	r3,r2,255
811032d4:	18c0201c 	xori	r3,r3,128
811032d8:	18ffe004 	addi	r3,r3,-128
811032dc:	e0bffdc4 	addi	r2,fp,-9
811032e0:	d8800015 	stw	r2,0(sp)
811032e4:	01c00044 	movi	r7,1
811032e8:	180d883a 	mov	r6,r3
811032ec:	01600034 	movhi	r5,32768
811032f0:	29426004 	addi	r5,r5,2432
811032f4:	01200034 	movhi	r4,32768
811032f8:	21026404 	addi	r4,r4,2448
811032fc:	1105b0c0 	call	81105b0c <I2C_Read>
81103300:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103304:	e0bffc17 	ldw	r2,-16(fp)
81103308:	10000226 	beq	r2,zero,81103314 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110330c:	e0bffdc3 	ldbu	r2,-9(fp)
81103310:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000626 	beq	r2,zero,81103334 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110331c:	e0bffe17 	ldw	r2,-8(fp)
81103320:	e0fffd03 	ldbu	r3,-12(fp)
81103324:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103328:	e0bfff17 	ldw	r2,-4(fp)
8110332c:	e0fffd43 	ldbu	r3,-11(fp)
81103330:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103334:	e0bffc17 	ldw	r2,-16(fp)
}
81103338:	e037883a 	mov	sp,fp
8110333c:	dfc00117 	ldw	ra,4(sp)
81103340:	df000017 	ldw	fp,0(sp)
81103344:	dec00204 	addi	sp,sp,8
81103348:	f800283a 	ret

8110334c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110334c:	defffb04 	addi	sp,sp,-20
81103350:	de00012e 	bgeu	sp,et,81103358 <sense_log_temp+0xc>
81103354:	003b68fa 	trap	3
81103358:	dfc00415 	stw	ra,16(sp)
8110335c:	df000315 	stw	fp,12(sp)
81103360:	df000304 	addi	fp,sp,12
81103364:	e13ffe15 	stw	r4,-8(fp)
81103368:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110336c:	e17fff17 	ldw	r5,-4(fp)
81103370:	e13ffe17 	ldw	r4,-8(fp)
81103374:	11032540 	call	81103254 <TEMP_Read>
81103378:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110337c:	e0bffd17 	ldw	r2,-12(fp)
}
81103380:	e037883a 	mov	sp,fp
81103384:	dfc00117 	ldw	ra,4(sp)
81103388:	df000017 	ldw	fp,0(sp)
8110338c:	dec00204 	addi	sp,sp,8
81103390:	f800283a 	ret

81103394 <sense_log>:

void sense_log(void) {
81103394:	deff0404 	addi	sp,sp,-1008
81103398:	de00012e 	bgeu	sp,et,811033a0 <sense_log+0xc>
8110339c:	003b68fa 	trap	3
811033a0:	dfc0fb15 	stw	ra,1004(sp)
811033a4:	df00fa15 	stw	fp,1000(sp)
811033a8:	dd40f915 	stw	r21,996(sp)
811033ac:	dd00f815 	stw	r20,992(sp)
811033b0:	dcc0f715 	stw	r19,988(sp)
811033b4:	dc80f615 	stw	r18,984(sp)
811033b8:	dc40f515 	stw	r17,980(sp)
811033bc:	dc00f415 	stw	r16,976(sp)
811033c0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033c4:	00902834 	movhi	r2,16544
811033c8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033cc:	008ed174 	movhi	r2,15173
811033d0:	10a6e984 	addi	r2,r2,-25690
811033d4:	e0bf2215 	stw	r2,-888(fp)
811033d8:	008ea0f4 	movhi	r2,14979
811033dc:	10849bc4 	addi	r2,r2,4719
811033e0:	e0bf2315 	stw	r2,-884(fp)
811033e4:	008ed174 	movhi	r2,15173
811033e8:	10a6e984 	addi	r2,r2,-25690
811033ec:	e0bf2415 	stw	r2,-880(fp)
811033f0:	008ed174 	movhi	r2,15173
811033f4:	10a6e984 	addi	r2,r2,-25690
811033f8:	e0bf2515 	stw	r2,-876(fp)
811033fc:	008ed174 	movhi	r2,15173
81103400:	10a6e984 	addi	r2,r2,-25690
81103404:	e0bf2615 	stw	r2,-872(fp)
81103408:	008ed174 	movhi	r2,15173
8110340c:	10a6e984 	addi	r2,r2,-25690
81103410:	e0bf2715 	stw	r2,-868(fp)
81103414:	008ed174 	movhi	r2,15173
81103418:	10a6e984 	addi	r2,r2,-25690
8110341c:	e0bf2815 	stw	r2,-864(fp)
81103420:	008ed174 	movhi	r2,15173
81103424:	10a6e984 	addi	r2,r2,-25690
81103428:	e0bf2915 	stw	r2,-860(fp)
8110342c:	008ed174 	movhi	r2,15173
81103430:	10a6e984 	addi	r2,r2,-25690
81103434:	e0bf2a15 	stw	r2,-856(fp)
81103438:	008ed174 	movhi	r2,15173
8110343c:	10a6e984 	addi	r2,r2,-25690
81103440:	e0bf2b15 	stw	r2,-852(fp)
81103444:	008ed174 	movhi	r2,15173
81103448:	10a6e984 	addi	r2,r2,-25690
8110344c:	e0bf2c15 	stw	r2,-848(fp)
81103450:	008ed174 	movhi	r2,15173
81103454:	10a6e984 	addi	r2,r2,-25690
81103458:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110345c:	008fd9b4 	movhi	r2,16230
81103460:	10999984 	addi	r2,r2,26214
81103464:	e0bf2e15 	stw	r2,-840(fp)
81103468:	008fd9b4 	movhi	r2,16230
8110346c:	10999984 	addi	r2,r2,26214
81103470:	e0bf2f15 	stw	r2,-836(fp)
81103474:	00901034 	movhi	r2,16448
81103478:	e0bf3015 	stw	r2,-832(fp)
8110347c:	008fd9b4 	movhi	r2,16230
81103480:	10999984 	addi	r2,r2,26214
81103484:	e0bf3115 	stw	r2,-828(fp)
81103488:	008ff9b4 	movhi	r2,16358
8110348c:	10999984 	addi	r2,r2,26214
81103490:	e0bf3215 	stw	r2,-824(fp)
81103494:	00900834 	movhi	r2,16416
81103498:	e0bf3315 	stw	r2,-820(fp)
8110349c:	008ff9b4 	movhi	r2,16358
811034a0:	10999984 	addi	r2,r2,26214
811034a4:	e0bf3415 	stw	r2,-816(fp)
811034a8:	00900834 	movhi	r2,16416
811034ac:	e0bf3515 	stw	r2,-812(fp)
811034b0:	008fe374 	movhi	r2,16269
811034b4:	10b33344 	addi	r2,r2,-13107
811034b8:	e0bf3615 	stw	r2,-808(fp)
811034bc:	008fecf4 	movhi	r2,16307
811034c0:	108cccc4 	addi	r2,r2,13107
811034c4:	e0bf3715 	stw	r2,-804(fp)
811034c8:	009014f4 	movhi	r2,16467
811034cc:	108cccc4 	addi	r2,r2,13107
811034d0:	e0bf3815 	stw	r2,-800(fp)
811034d4:	00900834 	movhi	r2,16416
811034d8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034dc:	00a04534 	movhi	r2,33044
811034e0:	10885604 	addi	r2,r2,8536
811034e4:	e0ff3a04 	addi	r3,fp,-792
811034e8:	1009883a 	mov	r4,r2
811034ec:	0080c004 	movi	r2,768
811034f0:	100d883a 	mov	r6,r2
811034f4:	200b883a 	mov	r5,r4
811034f8:	1809883a 	mov	r4,r3
811034fc:	1117ccc0 	call	81117ccc <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103500:	e0bf1604 	addi	r2,fp,-936
81103504:	1009883a 	mov	r4,r2
81103508:	1102f8c0 	call	81102f8c <POWER_Read>
8110350c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103510:	e0bf0f17 	ldw	r2,-964(fp)
81103514:	10016026 	beq	r2,zero,81103a98 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103518:	e03f0c15 	stw	zero,-976(fp)
8110351c:	00014c06 	br	81103a50 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103520:	e0bf0c17 	ldw	r2,-976(fp)
81103524:	1085883a 	add	r2,r2,r2
81103528:	1085883a 	add	r2,r2,r2
8110352c:	e0ff0c04 	addi	r3,fp,-976
81103530:	1885883a 	add	r2,r3,r2
81103534:	10800a04 	addi	r2,r2,40
81103538:	10800017 	ldw	r2,0(r2)
8110353c:	1004d77a 	srli	r2,r2,29
81103540:	1080004c 	andi	r2,r2,1
81103544:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103548:	e0bf0c17 	ldw	r2,-976(fp)
8110354c:	1085883a 	add	r2,r2,r2
81103550:	1085883a 	add	r2,r2,r2
81103554:	e0ff0c04 	addi	r3,fp,-976
81103558:	1885883a 	add	r2,r3,r2
8110355c:	10800a04 	addi	r2,r2,40
81103560:	10800017 	ldw	r2,0(r2)
81103564:	1004d73a 	srli	r2,r2,28
81103568:	1080004c 	andi	r2,r2,1
8110356c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103570:	e0bf0c17 	ldw	r2,-976(fp)
81103574:	1085883a 	add	r2,r2,r2
81103578:	1085883a 	add	r2,r2,r2
8110357c:	e0ff0c04 	addi	r3,fp,-976
81103580:	1885883a 	add	r2,r3,r2
81103584:	10800a04 	addi	r2,r2,40
81103588:	10800017 	ldw	r2,0(r2)
8110358c:	1006d1ba 	srli	r3,r2,6
81103590:	00801034 	movhi	r2,64
81103594:	10bfffc4 	addi	r2,r2,-1
81103598:	1884703a 	and	r2,r3,r2
8110359c:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035a0:	e0bf1117 	ldw	r2,-956(fp)
811035a4:	1000091e 	bne	r2,zero,811035cc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035a8:	e13f1217 	ldw	r4,-952(fp)
811035ac:	1115f840 	call	81115f84 <__floatunsisf>
811035b0:	1007883a 	mov	r3,r2
811035b4:	0152a034 	movhi	r5,19072
811035b8:	1809883a 	mov	r4,r3
811035bc:	111560c0 	call	8111560c <__divsf3>
811035c0:	1007883a 	mov	r3,r2
811035c4:	e0ff0d15 	stw	r3,-972(fp)
811035c8:	00000106 	br	811035d0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035cc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035d0:	e0bf1017 	ldw	r2,-960(fp)
811035d4:	10002626 	beq	r2,zero,81103670 <sense_log+0x2dc>
811035d8:	e0bf1117 	ldw	r2,-956(fp)
811035dc:	10002426 	beq	r2,zero,81103670 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035e0:	014fc034 	movhi	r5,16128
811035e4:	e13f0e17 	ldw	r4,-968(fp)
811035e8:	1115a540 	call	81115a54 <__mulsf3>
811035ec:	1007883a 	mov	r3,r2
811035f0:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811035f4:	e0ff3a04 	addi	r3,fp,-792
811035f8:	e0bf0c17 	ldw	r2,-976(fp)
811035fc:	100491ba 	slli	r2,r2,6
81103600:	18a1883a 	add	r16,r3,r2
81103604:	e0bf0c17 	ldw	r2,-976(fp)
81103608:	1085883a 	add	r2,r2,r2
8110360c:	1085883a 	add	r2,r2,r2
81103610:	e0ff0c04 	addi	r3,fp,-976
81103614:	1885883a 	add	r2,r3,r2
81103618:	10800a04 	addi	r2,r2,40
8110361c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103620:	1023883a 	mov	r17,r2
81103624:	e13f1317 	ldw	r4,-948(fp)
81103628:	111679c0 	call	8111679c <__extendsfdf2>
8110362c:	1009883a 	mov	r4,r2
81103630:	180b883a 	mov	r5,r3
81103634:	d9000015 	stw	r4,0(sp)
81103638:	d9400115 	stw	r5,4(sp)
8110363c:	880f883a 	mov	r7,r17
81103640:	800d883a 	mov	r6,r16
81103644:	01604534 	movhi	r5,33044
81103648:	29482404 	addi	r5,r5,8336
8110364c:	01204574 	movhi	r4,33045
81103650:	21221504 	addi	r4,r4,-30636
81103654:	11185ac0 	call	811185ac <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103658:	d0a05517 	ldw	r2,-32428(gp)
8110365c:	01604574 	movhi	r5,33045
81103660:	29621504 	addi	r5,r5,-30636
81103664:	1009883a 	mov	r4,r2
81103668:	1116c1c0 	call	81116c1c <fprintf>
8110366c:	0000f506 	br	81103a44 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103670:	e0bf1017 	ldw	r2,-960(fp)
81103674:	10006426 	beq	r2,zero,81103808 <sense_log+0x474>
81103678:	e0bf1117 	ldw	r2,-956(fp)
8110367c:	1000621e 	bne	r2,zero,81103808 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103680:	e13f0e17 	ldw	r4,-968(fp)
81103684:	111679c0 	call	8111679c <__extendsfdf2>
81103688:	1011883a 	mov	r8,r2
8110368c:	1813883a 	mov	r9,r3
81103690:	000d883a 	mov	r6,zero
81103694:	01cff834 	movhi	r7,16352
81103698:	4009883a 	mov	r4,r8
8110369c:	480b883a 	mov	r5,r9
811036a0:	111607c0 	call	8111607c <__muldf3>
811036a4:	1009883a 	mov	r4,r2
811036a8:	180b883a 	mov	r5,r3
811036ac:	2021883a 	mov	r16,r4
811036b0:	2823883a 	mov	r17,r5
811036b4:	e13f0d17 	ldw	r4,-972(fp)
811036b8:	111679c0 	call	8111679c <__extendsfdf2>
811036bc:	1009883a 	mov	r4,r2
811036c0:	180b883a 	mov	r5,r3
811036c4:	200d883a 	mov	r6,r4
811036c8:	280f883a 	mov	r7,r5
811036cc:	8009883a 	mov	r4,r16
811036d0:	880b883a 	mov	r5,r17
811036d4:	111607c0 	call	8111607c <__muldf3>
811036d8:	1009883a 	mov	r4,r2
811036dc:	180b883a 	mov	r5,r3
811036e0:	2005883a 	mov	r2,r4
811036e4:	2807883a 	mov	r3,r5
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	11168b40 	call	811168b4 <__truncdfsf2>
811036f4:	1007883a 	mov	r3,r2
811036f8:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811036fc:	e0bf0c17 	ldw	r2,-976(fp)
81103700:	1085883a 	add	r2,r2,r2
81103704:	1085883a 	add	r2,r2,r2
81103708:	e0ff0c04 	addi	r3,fp,-976
8110370c:	1885883a 	add	r2,r3,r2
81103710:	10801604 	addi	r2,r2,88
81103714:	10c00017 	ldw	r3,0(r2)
81103718:	180b883a 	mov	r5,r3
8110371c:	e13f0d17 	ldw	r4,-972(fp)
81103720:	111560c0 	call	8111560c <__divsf3>
81103724:	1007883a 	mov	r3,r2
81103728:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110372c:	e0bf0c17 	ldw	r2,-976(fp)
81103730:	1085883a 	add	r2,r2,r2
81103734:	1085883a 	add	r2,r2,r2
81103738:	e0ff0c04 	addi	r3,fp,-976
8110373c:	1885883a 	add	r2,r3,r2
81103740:	10802204 	addi	r2,r2,136
81103744:	10c00017 	ldw	r3,0(r2)
81103748:	e17f1417 	ldw	r5,-944(fp)
8110374c:	1809883a 	mov	r4,r3
81103750:	1115a540 	call	81115a54 <__mulsf3>
81103754:	1007883a 	mov	r3,r2
81103758:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110375c:	e0ff3a04 	addi	r3,fp,-792
81103760:	e0bf0c17 	ldw	r2,-976(fp)
81103764:	100491ba 	slli	r2,r2,6
81103768:	18a9883a 	add	r20,r3,r2
8110376c:	e0bf0c17 	ldw	r2,-976(fp)
81103770:	1085883a 	add	r2,r2,r2
81103774:	1085883a 	add	r2,r2,r2
81103778:	e0ff0c04 	addi	r3,fp,-976
8110377c:	1885883a 	add	r2,r3,r2
81103780:	10800a04 	addi	r2,r2,40
81103784:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103788:	102b883a 	mov	r21,r2
8110378c:	e13f0d17 	ldw	r4,-972(fp)
81103790:	111679c0 	call	8111679c <__extendsfdf2>
81103794:	1021883a 	mov	r16,r2
81103798:	1823883a 	mov	r17,r3
8110379c:	e13f1417 	ldw	r4,-944(fp)
811037a0:	111679c0 	call	8111679c <__extendsfdf2>
811037a4:	1025883a 	mov	r18,r2
811037a8:	1827883a 	mov	r19,r3
811037ac:	e13f1517 	ldw	r4,-940(fp)
811037b0:	111679c0 	call	8111679c <__extendsfdf2>
811037b4:	1009883a 	mov	r4,r2
811037b8:	180b883a 	mov	r5,r3
811037bc:	d9000415 	stw	r4,16(sp)
811037c0:	d9400515 	stw	r5,20(sp)
811037c4:	dc800215 	stw	r18,8(sp)
811037c8:	dcc00315 	stw	r19,12(sp)
811037cc:	dc000015 	stw	r16,0(sp)
811037d0:	dc400115 	stw	r17,4(sp)
811037d4:	a80f883a 	mov	r7,r21
811037d8:	a00d883a 	mov	r6,r20
811037dc:	01604534 	movhi	r5,33044
811037e0:	29482d04 	addi	r5,r5,8372
811037e4:	01204574 	movhi	r4,33045
811037e8:	21221504 	addi	r4,r4,-30636
811037ec:	11185ac0 	call	811185ac <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
811037f0:	d0a05517 	ldw	r2,-32428(gp)
811037f4:	01604574 	movhi	r5,33045
811037f8:	29621504 	addi	r5,r5,-30636
811037fc:	1009883a 	mov	r4,r2
81103800:	1116c1c0 	call	81116c1c <fprintf>
81103804:	00008f06 	br	81103a44 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103808:	e0bf1017 	ldw	r2,-960(fp)
8110380c:	1000641e 	bne	r2,zero,811039a0 <sense_log+0x60c>
81103810:	e0bf1117 	ldw	r2,-956(fp)
81103814:	10006226 	beq	r2,zero,811039a0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103818:	e13f0e17 	ldw	r4,-968(fp)
8110381c:	111679c0 	call	8111679c <__extendsfdf2>
81103820:	1011883a 	mov	r8,r2
81103824:	1813883a 	mov	r9,r3
81103828:	000d883a 	mov	r6,zero
8110382c:	01cff834 	movhi	r7,16352
81103830:	4009883a 	mov	r4,r8
81103834:	480b883a 	mov	r5,r9
81103838:	111607c0 	call	8111607c <__muldf3>
8110383c:	1009883a 	mov	r4,r2
81103840:	180b883a 	mov	r5,r3
81103844:	2021883a 	mov	r16,r4
81103848:	2823883a 	mov	r17,r5
8110384c:	e13f0d17 	ldw	r4,-972(fp)
81103850:	111679c0 	call	8111679c <__extendsfdf2>
81103854:	1009883a 	mov	r4,r2
81103858:	180b883a 	mov	r5,r3
8110385c:	200d883a 	mov	r6,r4
81103860:	280f883a 	mov	r7,r5
81103864:	8009883a 	mov	r4,r16
81103868:	880b883a 	mov	r5,r17
8110386c:	111607c0 	call	8111607c <__muldf3>
81103870:	1009883a 	mov	r4,r2
81103874:	180b883a 	mov	r5,r3
81103878:	2005883a 	mov	r2,r4
8110387c:	2807883a 	mov	r3,r5
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	11168b40 	call	811168b4 <__truncdfsf2>
8110388c:	1007883a 	mov	r3,r2
81103890:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
81103894:	e0bf0c17 	ldw	r2,-976(fp)
81103898:	1085883a 	add	r2,r2,r2
8110389c:	1085883a 	add	r2,r2,r2
811038a0:	e0ff0c04 	addi	r3,fp,-976
811038a4:	1885883a 	add	r2,r3,r2
811038a8:	10801604 	addi	r2,r2,88
811038ac:	10c00017 	ldw	r3,0(r2)
811038b0:	180b883a 	mov	r5,r3
811038b4:	e13f0d17 	ldw	r4,-972(fp)
811038b8:	111560c0 	call	8111560c <__divsf3>
811038bc:	1007883a 	mov	r3,r2
811038c0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038c4:	e0bf0c17 	ldw	r2,-976(fp)
811038c8:	1085883a 	add	r2,r2,r2
811038cc:	1085883a 	add	r2,r2,r2
811038d0:	e0ff0c04 	addi	r3,fp,-976
811038d4:	1885883a 	add	r2,r3,r2
811038d8:	10802204 	addi	r2,r2,136
811038dc:	10c00017 	ldw	r3,0(r2)
811038e0:	e17f1417 	ldw	r5,-944(fp)
811038e4:	1809883a 	mov	r4,r3
811038e8:	1115a540 	call	81115a54 <__mulsf3>
811038ec:	1007883a 	mov	r3,r2
811038f0:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
811038f4:	e0ff3a04 	addi	r3,fp,-792
811038f8:	e0bf0c17 	ldw	r2,-976(fp)
811038fc:	100491ba 	slli	r2,r2,6
81103900:	18a9883a 	add	r20,r3,r2
81103904:	e0bf0c17 	ldw	r2,-976(fp)
81103908:	1085883a 	add	r2,r2,r2
8110390c:	1085883a 	add	r2,r2,r2
81103910:	e0ff0c04 	addi	r3,fp,-976
81103914:	1885883a 	add	r2,r3,r2
81103918:	10800a04 	addi	r2,r2,40
8110391c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103920:	102b883a 	mov	r21,r2
81103924:	e13f0d17 	ldw	r4,-972(fp)
81103928:	111679c0 	call	8111679c <__extendsfdf2>
8110392c:	1021883a 	mov	r16,r2
81103930:	1823883a 	mov	r17,r3
81103934:	e13f1417 	ldw	r4,-944(fp)
81103938:	111679c0 	call	8111679c <__extendsfdf2>
8110393c:	1025883a 	mov	r18,r2
81103940:	1827883a 	mov	r19,r3
81103944:	e13f1517 	ldw	r4,-940(fp)
81103948:	111679c0 	call	8111679c <__extendsfdf2>
8110394c:	1009883a 	mov	r4,r2
81103950:	180b883a 	mov	r5,r3
81103954:	d9000415 	stw	r4,16(sp)
81103958:	d9400515 	stw	r5,20(sp)
8110395c:	dc800215 	stw	r18,8(sp)
81103960:	dcc00315 	stw	r19,12(sp)
81103964:	dc000015 	stw	r16,0(sp)
81103968:	dc400115 	stw	r17,4(sp)
8110396c:	a80f883a 	mov	r7,r21
81103970:	a00d883a 	mov	r6,r20
81103974:	01604534 	movhi	r5,33044
81103978:	29483d04 	addi	r5,r5,8436
8110397c:	01204574 	movhi	r4,33045
81103980:	21221504 	addi	r4,r4,-30636
81103984:	11185ac0 	call	811185ac <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103988:	d0a05517 	ldw	r2,-32428(gp)
8110398c:	01604574 	movhi	r5,33045
81103990:	29621504 	addi	r5,r5,-30636
81103994:	1009883a 	mov	r4,r2
81103998:	1116c1c0 	call	81116c1c <fprintf>
8110399c:	00002906 	br	81103a44 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039a0:	e0bf1017 	ldw	r2,-960(fp)
811039a4:	1000271e 	bne	r2,zero,81103a44 <sense_log+0x6b0>
811039a8:	e0bf1117 	ldw	r2,-956(fp)
811039ac:	1000251e 	bne	r2,zero,81103a44 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039b0:	e0bf0e17 	ldw	r2,-968(fp)
811039b4:	10a0003c 	xorhi	r2,r2,32768
811039b8:	014fc034 	movhi	r5,16128
811039bc:	1009883a 	mov	r4,r2
811039c0:	1115a540 	call	81115a54 <__mulsf3>
811039c4:	1007883a 	mov	r3,r2
811039c8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039cc:	e0ff3a04 	addi	r3,fp,-792
811039d0:	e0bf0c17 	ldw	r2,-976(fp)
811039d4:	100491ba 	slli	r2,r2,6
811039d8:	18a1883a 	add	r16,r3,r2
811039dc:	e0bf0c17 	ldw	r2,-976(fp)
811039e0:	1085883a 	add	r2,r2,r2
811039e4:	1085883a 	add	r2,r2,r2
811039e8:	e0ff0c04 	addi	r3,fp,-976
811039ec:	1885883a 	add	r2,r3,r2
811039f0:	10800a04 	addi	r2,r2,40
811039f4:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
811039f8:	1023883a 	mov	r17,r2
811039fc:	e13f1317 	ldw	r4,-948(fp)
81103a00:	111679c0 	call	8111679c <__extendsfdf2>
81103a04:	1009883a 	mov	r4,r2
81103a08:	180b883a 	mov	r5,r3
81103a0c:	d9000015 	stw	r4,0(sp)
81103a10:	d9400115 	stw	r5,4(sp)
81103a14:	880f883a 	mov	r7,r17
81103a18:	800d883a 	mov	r6,r16
81103a1c:	01604534 	movhi	r5,33044
81103a20:	29484d04 	addi	r5,r5,8500
81103a24:	01204574 	movhi	r4,33045
81103a28:	21221504 	addi	r4,r4,-30636
81103a2c:	11185ac0 	call	811185ac <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a30:	d0a05517 	ldw	r2,-32428(gp)
81103a34:	01604574 	movhi	r5,33045
81103a38:	29621504 	addi	r5,r5,-30636
81103a3c:	1009883a 	mov	r4,r2
81103a40:	1116c1c0 	call	81116c1c <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a44:	e0bf0c17 	ldw	r2,-976(fp)
81103a48:	10800044 	addi	r2,r2,1
81103a4c:	e0bf0c15 	stw	r2,-976(fp)
81103a50:	e0bf0c17 	ldw	r2,-976(fp)
81103a54:	10800308 	cmpgei	r2,r2,12
81103a58:	1000021e 	bne	r2,zero,81103a64 <sense_log+0x6d0>
81103a5c:	e0bf0f17 	ldw	r2,-964(fp)
81103a60:	103eaf1e 	bne	r2,zero,81103520 <__reset+0xfb0e3520>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a64:	00a04574 	movhi	r2,33045
81103a68:	10a21504 	addi	r2,r2,-30636
81103a6c:	00c00344 	movi	r3,13
81103a70:	10c00005 	stb	r3,0(r2)
81103a74:	00c00284 	movi	r3,10
81103a78:	10c00045 	stb	r3,1(r2)
81103a7c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a80:	d0a05517 	ldw	r2,-32428(gp)
81103a84:	01604574 	movhi	r5,33045
81103a88:	29621504 	addi	r5,r5,-30636
81103a8c:	1009883a 	mov	r4,r2
81103a90:	1116c1c0 	call	81116c1c <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103a94:	00001606 	br	81103af0 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103a98:	00a04574 	movhi	r2,33045
81103a9c:	10a21504 	addi	r2,r2,-30636
81103aa0:	00c01144 	movi	r3,69
81103aa4:	10c00005 	stb	r3,0(r2)
81103aa8:	00c01c84 	movi	r3,114
81103aac:	10c00045 	stb	r3,1(r2)
81103ab0:	00c01c84 	movi	r3,114
81103ab4:	10c00085 	stb	r3,2(r2)
81103ab8:	00c01bc4 	movi	r3,111
81103abc:	10c000c5 	stb	r3,3(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00105 	stb	r3,4(r2)
81103ac8:	00c00344 	movi	r3,13
81103acc:	10c00145 	stb	r3,5(r2)
81103ad0:	00c00284 	movi	r3,10
81103ad4:	10c00185 	stb	r3,6(r2)
81103ad8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103adc:	d0a05517 	ldw	r2,-32428(gp)
81103ae0:	01604574 	movhi	r5,33045
81103ae4:	29621504 	addi	r5,r5,-30636
81103ae8:	1009883a 	mov	r4,r2
81103aec:	1116c1c0 	call	81116c1c <fprintf>
#endif
	}
}
81103af0:	0001883a 	nop
81103af4:	e6fffa04 	addi	sp,fp,-24
81103af8:	dfc00717 	ldw	ra,28(sp)
81103afc:	df000617 	ldw	fp,24(sp)
81103b00:	dd400517 	ldw	r21,20(sp)
81103b04:	dd000417 	ldw	r20,16(sp)
81103b08:	dcc00317 	ldw	r19,12(sp)
81103b0c:	dc800217 	ldw	r18,8(sp)
81103b10:	dc400117 	ldw	r17,4(sp)
81103b14:	dc000017 	ldw	r16,0(sp)
81103b18:	dec00804 	addi	sp,sp,32
81103b1c:	f800283a 	ret

81103b20 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b20:	defffc04 	addi	sp,sp,-16
81103b24:	de00012e 	bgeu	sp,et,81103b2c <bSdmaInitM1Dma+0xc>
81103b28:	003b68fa 	trap	3
81103b2c:	dfc00315 	stw	ra,12(sp)
81103b30:	df000215 	stw	fp,8(sp)
81103b34:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b38:	00800044 	movi	r2,1
81103b3c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b40:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b44:	01204534 	movhi	r4,33044
81103b48:	21091604 	addi	r4,r4,9304
81103b4c:	113fdd80 	call	8113fdd8 <alt_msgdma_open>
81103b50:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b54:	d0a03917 	ldw	r2,-32540(gp)
81103b58:	1000021e 	bne	r2,zero,81103b64 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b5c:	e03ffe15 	stw	zero,-8(fp)
81103b60:	00001506 	br	81103bb8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	10800317 	ldw	r2,12(r2)
81103b6c:	10800104 	addi	r2,r2,4
81103b70:	00c00084 	movi	r3,2
81103b74:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b78:	00000a06 	br	81103ba4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b7c:	01000044 	movi	r4,1
81103b80:	112def40 	call	8112def4 <usleep>
			usiCounter++;
81103b84:	e0bfff0b 	ldhu	r2,-4(fp)
81103b88:	10800044 	addi	r2,r2,1
81103b8c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103b90:	e0bfff0b 	ldhu	r2,-4(fp)
81103b94:	1084e230 	cmpltui	r2,r2,5000
81103b98:	1000021e 	bne	r2,zero,81103ba4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103b9c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103ba0:	00000506 	br	81103bb8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103ba4:	d0a03917 	ldw	r2,-32540(gp)
81103ba8:	10800317 	ldw	r2,12(r2)
81103bac:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bb0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	103ff11e 	bne	r2,zero,81103b7c <__reset+0xfb0e3b7c>
				break;
			}
		}
	}

	return bStatus;
81103bb8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bbc:	e037883a 	mov	sp,fp
81103bc0:	dfc00117 	ldw	ra,4(sp)
81103bc4:	df000017 	ldw	fp,0(sp)
81103bc8:	dec00204 	addi	sp,sp,8
81103bcc:	f800283a 	ret

81103bd0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103bd0:	defffc04 	addi	sp,sp,-16
81103bd4:	de00012e 	bgeu	sp,et,81103bdc <bSdmaInitM2Dma+0xc>
81103bd8:	003b68fa 	trap	3
81103bdc:	dfc00315 	stw	ra,12(sp)
81103be0:	df000215 	stw	fp,8(sp)
81103be4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103be8:	00800044 	movi	r2,1
81103bec:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103bf0:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103bf4:	01204534 	movhi	r4,33044
81103bf8:	21091b04 	addi	r4,r4,9324
81103bfc:	113fdd80 	call	8113fdd8 <alt_msgdma_open>
81103c00:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c04:	d0a03a17 	ldw	r2,-32536(gp)
81103c08:	1000021e 	bne	r2,zero,81103c14 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c0c:	e03ffe15 	stw	zero,-8(fp)
81103c10:	00001506 	br	81103c68 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	10800317 	ldw	r2,12(r2)
81103c1c:	10800104 	addi	r2,r2,4
81103c20:	00c00084 	movi	r3,2
81103c24:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c28:	00000a06 	br	81103c54 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c2c:	01000044 	movi	r4,1
81103c30:	112def40 	call	8112def4 <usleep>
			usiCounter++;
81103c34:	e0bfff0b 	ldhu	r2,-4(fp)
81103c38:	10800044 	addi	r2,r2,1
81103c3c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c40:	e0bfff0b 	ldhu	r2,-4(fp)
81103c44:	1084e230 	cmpltui	r2,r2,5000
81103c48:	1000021e 	bne	r2,zero,81103c54 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c4c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c50:	00000506 	br	81103c68 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c54:	d0a03a17 	ldw	r2,-32536(gp)
81103c58:	10800317 	ldw	r2,12(r2)
81103c5c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c60:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	103ff11e 	bne	r2,zero,81103c2c <__reset+0xfb0e3c2c>
				break;
			}
		}
	}

	return bStatus;
81103c68:	e0bffe17 	ldw	r2,-8(fp)
}
81103c6c:	e037883a 	mov	sp,fp
81103c70:	dfc00117 	ldw	ra,4(sp)
81103c74:	df000017 	ldw	fp,0(sp)
81103c78:	dec00204 	addi	sp,sp,8
81103c7c:	f800283a 	ret

81103c80 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c80:	deffe904 	addi	sp,sp,-92
81103c84:	de00012e 	bgeu	sp,et,81103c8c <bSdmaDmaM1Transfer+0xc>
81103c88:	003b68fa 	trap	3
81103c8c:	dfc01615 	stw	ra,88(sp)
81103c90:	df001515 	stw	fp,84(sp)
81103c94:	dc001415 	stw	r16,80(sp)
81103c98:	df001504 	addi	fp,sp,84
81103c9c:	e13ffb15 	stw	r4,-20(fp)
81103ca0:	2809883a 	mov	r4,r5
81103ca4:	3007883a 	mov	r3,r6
81103ca8:	3805883a 	mov	r2,r7
81103cac:	e13ffc0d 	sth	r4,-16(fp)
81103cb0:	e0fffd05 	stb	r3,-12(fp)
81103cb4:	e0bffe05 	stb	r2,-8(fp)
81103cb8:	defff004 	addi	sp,sp,-64
81103cbc:	d8800904 	addi	r2,sp,36
81103cc0:	108007c4 	addi	r2,r2,31
81103cc4:	1004d17a 	srli	r2,r2,5
81103cc8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103ccc:	00800044 	movi	r2,1
81103cd0:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81103cd4:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103cd8:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cdc:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81103ce0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103ce4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103ce8:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81103cec:	e0bffe03 	ldbu	r2,-8(fp)
81103cf0:	10c00268 	cmpgeui	r3,r2,9
81103cf4:	1800a51e 	bne	r3,zero,81103f8c <bSdmaDmaM1Transfer+0x30c>
81103cf8:	100690ba 	slli	r3,r2,2
81103cfc:	00a04434 	movhi	r2,33040
81103d00:	108f4404 	addi	r2,r2,15632
81103d04:	1885883a 	add	r2,r3,r2
81103d08:	10800017 	ldw	r2,0(r2)
81103d0c:	1000683a 	jmp	r2
81103d10:	81103f8c 	andi	r4,r16,16638
81103d14:	81103d34 	orhi	r4,r16,16628
81103d18:	81103d78 	rdprs	r4,r16,16629
81103d1c:	81103dc4 	addi	r4,r16,16631
81103d20:	81103e10 	cmplti	r4,r16,16632
81103d24:	81103e5c 	xori	r4,r16,16633
81103d28:	81103ea8 	cmpgeui	r4,r16,16634
81103d2c:	81103ef4 	orhi	r4,r16,16635
81103d30:	81103f40 	call	881103f4 <__reset+0x20f03f4>
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d34:	e0bffd03 	ldbu	r2,-12(fp)
81103d38:	10000326 	beq	r2,zero,81103d48 <bSdmaDmaM1Transfer+0xc8>
81103d3c:	10800060 	cmpeqi	r2,r2,1
81103d40:	1000051e 	bne	r2,zero,81103d58 <bSdmaDmaM1Transfer+0xd8>
81103d44:	00000906 	br	81103d6c <bSdmaDmaM1Transfer+0xec>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d48:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d4c:	00800044 	movi	r2,1
81103d50:	e0bff715 	stw	r2,-36(fp)
			break;
81103d54:	00000706 	br	81103d74 <bSdmaDmaM1Transfer+0xf4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d58:	00800074 	movhi	r2,1
81103d5c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d60:	00800044 	movi	r2,1
81103d64:	e0bff715 	stw	r2,-36(fp)
			break;
81103d68:	00000206 	br	81103d74 <bSdmaDmaM1Transfer+0xf4>
		default:
			bStatus = FALSE;
81103d6c:	e03ff415 	stw	zero,-48(fp)
			break;
81103d70:	0001883a 	nop
		}
		break;
81103d74:	00008706 	br	81103f94 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d78:	e0bffd03 	ldbu	r2,-12(fp)
81103d7c:	10000326 	beq	r2,zero,81103d8c <bSdmaDmaM1Transfer+0x10c>
81103d80:	10800060 	cmpeqi	r2,r2,1
81103d84:	1000061e 	bne	r2,zero,81103da0 <bSdmaDmaM1Transfer+0x120>
81103d88:	00000b06 	br	81103db8 <bSdmaDmaM1Transfer+0x138>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103d8c:	00880004 	movi	r2,8192
81103d90:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103d94:	00800044 	movi	r2,1
81103d98:	e0bff715 	stw	r2,-36(fp)
			break;
81103d9c:	00000806 	br	81103dc0 <bSdmaDmaM1Transfer+0x140>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103da0:	00800074 	movhi	r2,1
81103da4:	10880004 	addi	r2,r2,8192
81103da8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103dac:	00800044 	movi	r2,1
81103db0:	e0bff715 	stw	r2,-36(fp)
			break;
81103db4:	00000206 	br	81103dc0 <bSdmaDmaM1Transfer+0x140>
		default:
			bStatus = FALSE;
81103db8:	e03ff415 	stw	zero,-48(fp)
			break;
81103dbc:	0001883a 	nop
		}
		break;
81103dc0:	00007406 	br	81103f94 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103dc4:	e0bffd03 	ldbu	r2,-12(fp)
81103dc8:	10000326 	beq	r2,zero,81103dd8 <bSdmaDmaM1Transfer+0x158>
81103dcc:	10800060 	cmpeqi	r2,r2,1
81103dd0:	1000061e 	bne	r2,zero,81103dec <bSdmaDmaM1Transfer+0x16c>
81103dd4:	00000b06 	br	81103e04 <bSdmaDmaM1Transfer+0x184>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103dd8:	00900004 	movi	r2,16384
81103ddc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103de0:	00800044 	movi	r2,1
81103de4:	e0bff715 	stw	r2,-36(fp)
			break;
81103de8:	00000806 	br	81103e0c <bSdmaDmaM1Transfer+0x18c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103dec:	00800074 	movhi	r2,1
81103df0:	10900004 	addi	r2,r2,16384
81103df4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103df8:	00800044 	movi	r2,1
81103dfc:	e0bff715 	stw	r2,-36(fp)
			break;
81103e00:	00000206 	br	81103e0c <bSdmaDmaM1Transfer+0x18c>
		default:
			bStatus = FALSE;
81103e04:	e03ff415 	stw	zero,-48(fp)
			break;
81103e08:	0001883a 	nop
		}
		break;
81103e0c:	00006106 	br	81103f94 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e10:	e0bffd03 	ldbu	r2,-12(fp)
81103e14:	10000326 	beq	r2,zero,81103e24 <bSdmaDmaM1Transfer+0x1a4>
81103e18:	10800060 	cmpeqi	r2,r2,1
81103e1c:	1000061e 	bne	r2,zero,81103e38 <bSdmaDmaM1Transfer+0x1b8>
81103e20:	00000b06 	br	81103e50 <bSdmaDmaM1Transfer+0x1d0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e24:	00980004 	movi	r2,24576
81103e28:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e2c:	00800044 	movi	r2,1
81103e30:	e0bff715 	stw	r2,-36(fp)
			break;
81103e34:	00000806 	br	81103e58 <bSdmaDmaM1Transfer+0x1d8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e38:	00800074 	movhi	r2,1
81103e3c:	10980004 	addi	r2,r2,24576
81103e40:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e44:	00800044 	movi	r2,1
81103e48:	e0bff715 	stw	r2,-36(fp)
			break;
81103e4c:	00000206 	br	81103e58 <bSdmaDmaM1Transfer+0x1d8>
		default:
			bStatus = FALSE;
81103e50:	e03ff415 	stw	zero,-48(fp)
			break;
81103e54:	0001883a 	nop
		}
		break;
81103e58:	00004e06 	br	81103f94 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e5c:	e0bffd03 	ldbu	r2,-12(fp)
81103e60:	10000326 	beq	r2,zero,81103e70 <bSdmaDmaM1Transfer+0x1f0>
81103e64:	10800060 	cmpeqi	r2,r2,1
81103e68:	1000061e 	bne	r2,zero,81103e84 <bSdmaDmaM1Transfer+0x204>
81103e6c:	00000b06 	br	81103e9c <bSdmaDmaM1Transfer+0x21c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103e70:	00a00014 	movui	r2,32768
81103e74:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103e78:	00800044 	movi	r2,1
81103e7c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e80:	00000806 	br	81103ea4 <bSdmaDmaM1Transfer+0x224>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103e84:	008000b4 	movhi	r2,2
81103e88:	10a00004 	addi	r2,r2,-32768
81103e8c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103e90:	00800044 	movi	r2,1
81103e94:	e0bff715 	stw	r2,-36(fp)
			break;
81103e98:	00000206 	br	81103ea4 <bSdmaDmaM1Transfer+0x224>
		default:
			bStatus = FALSE;
81103e9c:	e03ff415 	stw	zero,-48(fp)
			break;
81103ea0:	0001883a 	nop
		}
		break;
81103ea4:	00003b06 	br	81103f94 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ea8:	e0bffd03 	ldbu	r2,-12(fp)
81103eac:	10000326 	beq	r2,zero,81103ebc <bSdmaDmaM1Transfer+0x23c>
81103eb0:	10800060 	cmpeqi	r2,r2,1
81103eb4:	1000061e 	bne	r2,zero,81103ed0 <bSdmaDmaM1Transfer+0x250>
81103eb8:	00000b06 	br	81103ee8 <bSdmaDmaM1Transfer+0x268>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103ebc:	00a80014 	movui	r2,40960
81103ec0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103ec4:	00800044 	movi	r2,1
81103ec8:	e0bff715 	stw	r2,-36(fp)
			break;
81103ecc:	00000806 	br	81103ef0 <bSdmaDmaM1Transfer+0x270>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103ed0:	008000b4 	movhi	r2,2
81103ed4:	10a80004 	addi	r2,r2,-24576
81103ed8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103edc:	00800044 	movi	r2,1
81103ee0:	e0bff715 	stw	r2,-36(fp)
			break;
81103ee4:	00000206 	br	81103ef0 <bSdmaDmaM1Transfer+0x270>
		default:
			bStatus = FALSE;
81103ee8:	e03ff415 	stw	zero,-48(fp)
			break;
81103eec:	0001883a 	nop
		}
		break;
81103ef0:	00002806 	br	81103f94 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103ef4:	e0bffd03 	ldbu	r2,-12(fp)
81103ef8:	10000326 	beq	r2,zero,81103f08 <bSdmaDmaM1Transfer+0x288>
81103efc:	10800060 	cmpeqi	r2,r2,1
81103f00:	1000061e 	bne	r2,zero,81103f1c <bSdmaDmaM1Transfer+0x29c>
81103f04:	00000b06 	br	81103f34 <bSdmaDmaM1Transfer+0x2b4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f08:	00b00014 	movui	r2,49152
81103f0c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f10:	00800044 	movi	r2,1
81103f14:	e0bff715 	stw	r2,-36(fp)
			break;
81103f18:	00000806 	br	81103f3c <bSdmaDmaM1Transfer+0x2bc>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f1c:	008000b4 	movhi	r2,2
81103f20:	10b00004 	addi	r2,r2,-16384
81103f24:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f28:	00800044 	movi	r2,1
81103f2c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f30:	00000206 	br	81103f3c <bSdmaDmaM1Transfer+0x2bc>
		default:
			bStatus = FALSE;
81103f34:	e03ff415 	stw	zero,-48(fp)
			break;
81103f38:	0001883a 	nop
		}
		break;
81103f3c:	00001506 	br	81103f94 <bSdmaDmaM1Transfer+0x314>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f40:	e0bffd03 	ldbu	r2,-12(fp)
81103f44:	10000326 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x2d4>
81103f48:	10800060 	cmpeqi	r2,r2,1
81103f4c:	1000061e 	bne	r2,zero,81103f68 <bSdmaDmaM1Transfer+0x2e8>
81103f50:	00000b06 	br	81103f80 <bSdmaDmaM1Transfer+0x300>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103f54:	00b80014 	movui	r2,57344
81103f58:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103f5c:	00800044 	movi	r2,1
81103f60:	e0bff715 	stw	r2,-36(fp)
			break;
81103f64:	00000806 	br	81103f88 <bSdmaDmaM1Transfer+0x308>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103f68:	008000b4 	movhi	r2,2
81103f6c:	10b80004 	addi	r2,r2,-8192
81103f70:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103f74:	00800044 	movi	r2,1
81103f78:	e0bff715 	stw	r2,-36(fp)
			break;
81103f7c:	00000206 	br	81103f88 <bSdmaDmaM1Transfer+0x308>
		default:
			bStatus = FALSE;
81103f80:	e03ff415 	stw	zero,-48(fp)
			break;
81103f84:	0001883a 	nop
		}
		break;
81103f88:	00000206 	br	81103f94 <bSdmaDmaM1Transfer+0x314>
	default:
		bStatus = FALSE;
81103f8c:	e03ff415 	stw	zero,-48(fp)
		break;
81103f90:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103f94:	e0bffb17 	ldw	r2,-20(fp)
81103f98:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103f9c:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81103fa0:	e0bff417 	ldw	r2,-48(fp)
81103fa4:	10003b26 	beq	r2,zero,81104094 <bSdmaDmaM1Transfer+0x414>
		if (pxDmaM1Dev == NULL) {
81103fa8:	d0a03917 	ldw	r2,-32540(gp)
81103fac:	1000021e 	bne	r2,zero,81103fb8 <bSdmaDmaM1Transfer+0x338>
			bStatus = FALSE;
81103fb0:	e03ff415 	stw	zero,-48(fp)
81103fb4:	00003706 	br	81104094 <bSdmaDmaM1Transfer+0x414>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81103fb8:	e03ff50d 	sth	zero,-44(fp)
81103fbc:	00003206 	br	81104088 <bSdmaDmaM1Transfer+0x408>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81103fc0:	01000044 	movi	r4,1
81103fc4:	112c4800 	call	8112c480 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103fc8:	d0a03917 	ldw	r2,-32540(gp)
81103fcc:	10800317 	ldw	r2,12(r2)
81103fd0:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81103fd4:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81103fd8:	103ff91e 	bne	r2,zero,81103fc0 <__reset+0xfb0e3fc0>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81103fdc:	d2203917 	ldw	r8,-32540(gp)
81103fe0:	e17ff817 	ldw	r5,-32(fp)
81103fe4:	e1bff617 	ldw	r6,-40(fp)
81103fe8:	e0bff917 	ldw	r2,-28(fp)
81103fec:	e0fff717 	ldw	r3,-36(fp)
81103ff0:	01000044 	movi	r4,1
81103ff4:	d9000815 	stw	r4,32(sp)
81103ff8:	01000044 	movi	r4,1
81103ffc:	d9000715 	stw	r4,28(sp)
81104000:	01000044 	movi	r4,1
81104004:	d9000615 	stw	r4,24(sp)
81104008:	01000044 	movi	r4,1
8110400c:	d9000515 	stw	r4,20(sp)
81104010:	01000044 	movi	r4,1
81104014:	d9000415 	stw	r4,16(sp)
81104018:	d8c00315 	stw	r3,12(sp)
8110401c:	d8800215 	stw	r2,8(sp)
81104020:	e0bffa17 	ldw	r2,-24(fp)
81104024:	d8800115 	stw	r2,4(sp)
81104028:	00802204 	movi	r2,136
8110402c:	d8800015 	stw	r2,0(sp)
81104030:	300f883a 	mov	r7,r6
81104034:	280d883a 	mov	r6,r5
81104038:	800b883a 	mov	r5,r16
8110403c:	4009883a 	mov	r4,r8
81104040:	1106bcc0 	call	81106bcc <iMsgdmaConstructExtendedMmToMmDescriptor>
81104044:	10000226 	beq	r2,zero,81104050 <bSdmaDmaM1Transfer+0x3d0>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104048:	e03ff415 	stw	zero,-48(fp)
					break;
8110404c:	00001106 	br	81104094 <bSdmaDmaM1Transfer+0x414>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
81104050:	d0a03917 	ldw	r2,-32540(gp)
81104054:	800b883a 	mov	r5,r16
81104058:	1009883a 	mov	r4,r2
8110405c:	1106cd00 	call	81106cd0 <iMsgdmaExtendedDescriptorSyncTransfer>
81104060:	10000226 	beq	r2,zero,8110406c <bSdmaDmaM1Transfer+0x3ec>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104064:	e03ff415 	stw	zero,-48(fp)
						break;
81104068:	00000a06 	br	81104094 <bSdmaDmaM1Transfer+0x414>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
8110406c:	e0bff817 	ldw	r2,-32(fp)
81104070:	10802204 	addi	r2,r2,136
81104074:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104078:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
8110407c:	e0bff50b 	ldhu	r2,-44(fp)
81104080:	10800044 	addi	r2,r2,1
81104084:	e0bff50d 	sth	r2,-44(fp)
81104088:	e0fff50b 	ldhu	r3,-44(fp)
8110408c:	e0bffc0b 	ldhu	r2,-16(fp)
81104090:	18bfcd36 	bltu	r3,r2,81103fc8 <__reset+0xfb0e3fc8>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104094:	e0bff417 	ldw	r2,-48(fp)
}
81104098:	e6ffff04 	addi	sp,fp,-4
8110409c:	dfc00217 	ldw	ra,8(sp)
811040a0:	df000117 	ldw	fp,4(sp)
811040a4:	dc000017 	ldw	r16,0(sp)
811040a8:	dec00304 	addi	sp,sp,12
811040ac:	f800283a 	ret

811040b0 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
811040b0:	deffe904 	addi	sp,sp,-92
811040b4:	de00012e 	bgeu	sp,et,811040bc <bSdmaDmaM2Transfer+0xc>
811040b8:	003b68fa 	trap	3
811040bc:	dfc01615 	stw	ra,88(sp)
811040c0:	df001515 	stw	fp,84(sp)
811040c4:	dc001415 	stw	r16,80(sp)
811040c8:	df001504 	addi	fp,sp,84
811040cc:	e13ffb15 	stw	r4,-20(fp)
811040d0:	2809883a 	mov	r4,r5
811040d4:	3007883a 	mov	r3,r6
811040d8:	3805883a 	mov	r2,r7
811040dc:	e13ffc0d 	sth	r4,-16(fp)
811040e0:	e0fffd05 	stb	r3,-12(fp)
811040e4:	e0bffe05 	stb	r2,-8(fp)
811040e8:	defff004 	addi	sp,sp,-64
811040ec:	d8800904 	addi	r2,sp,36
811040f0:	108007c4 	addi	r2,r2,31
811040f4:	1004d17a 	srli	r2,r2,5
811040f8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
811040fc:	00800044 	movi	r2,1
81104100:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81104104:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81104108:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
8110410c:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81104110:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104114:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104118:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
8110411c:	e0bffe03 	ldbu	r2,-8(fp)
81104120:	10c00268 	cmpgeui	r3,r2,9
81104124:	1800a51e 	bne	r3,zero,811043bc <bSdmaDmaM2Transfer+0x30c>
81104128:	100690ba 	slli	r3,r2,2
8110412c:	00a04434 	movhi	r2,33040
81104130:	10905004 	addi	r2,r2,16704
81104134:	1885883a 	add	r2,r3,r2
81104138:	10800017 	ldw	r2,0(r2)
8110413c:	1000683a 	jmp	r2
81104140:	811043bc 	xorhi	r4,r16,16654
81104144:	81104164 	muli	r4,r16,16645
81104148:	811041a8 	cmpgeui	r4,r16,16646
8110414c:	811041f4 	orhi	r4,r16,16647
81104150:	81104240 	call	88110424 <__reset+0x20f0424>
81104154:	8110428c 	andi	r4,r16,16650
81104158:	811042d8 	cmpnei	r4,r16,16651
8110415c:	81104324 	muli	r4,r16,16652
81104160:	81104370 	cmpltui	r4,r16,16653
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81104164:	e0bffd03 	ldbu	r2,-12(fp)
81104168:	10000326 	beq	r2,zero,81104178 <bSdmaDmaM2Transfer+0xc8>
8110416c:	10800060 	cmpeqi	r2,r2,1
81104170:	1000051e 	bne	r2,zero,81104188 <bSdmaDmaM2Transfer+0xd8>
81104174:	00000906 	br	8110419c <bSdmaDmaM2Transfer+0xec>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81104178:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
8110417c:	00800044 	movi	r2,1
81104180:	e0bff715 	stw	r2,-36(fp)
			break;
81104184:	00000706 	br	811041a4 <bSdmaDmaM2Transfer+0xf4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81104188:	00800074 	movhi	r2,1
8110418c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81104190:	00800044 	movi	r2,1
81104194:	e0bff715 	stw	r2,-36(fp)
			break;
81104198:	00000206 	br	811041a4 <bSdmaDmaM2Transfer+0xf4>
		default:
			bStatus = FALSE;
8110419c:	e03ff415 	stw	zero,-48(fp)
			break;
811041a0:	0001883a 	nop
		}
		break;
811041a4:	00008706 	br	811043c4 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
811041a8:	e0bffd03 	ldbu	r2,-12(fp)
811041ac:	10000326 	beq	r2,zero,811041bc <bSdmaDmaM2Transfer+0x10c>
811041b0:	10800060 	cmpeqi	r2,r2,1
811041b4:	1000061e 	bne	r2,zero,811041d0 <bSdmaDmaM2Transfer+0x120>
811041b8:	00000b06 	br	811041e8 <bSdmaDmaM2Transfer+0x138>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
811041bc:	00880004 	movi	r2,8192
811041c0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811041c4:	00800044 	movi	r2,1
811041c8:	e0bff715 	stw	r2,-36(fp)
			break;
811041cc:	00000806 	br	811041f0 <bSdmaDmaM2Transfer+0x140>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811041d0:	00800074 	movhi	r2,1
811041d4:	10880004 	addi	r2,r2,8192
811041d8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
811041dc:	00800044 	movi	r2,1
811041e0:	e0bff715 	stw	r2,-36(fp)
			break;
811041e4:	00000206 	br	811041f0 <bSdmaDmaM2Transfer+0x140>
		default:
			bStatus = FALSE;
811041e8:	e03ff415 	stw	zero,-48(fp)
			break;
811041ec:	0001883a 	nop
		}
		break;
811041f0:	00007406 	br	811043c4 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811041f4:	e0bffd03 	ldbu	r2,-12(fp)
811041f8:	10000326 	beq	r2,zero,81104208 <bSdmaDmaM2Transfer+0x158>
811041fc:	10800060 	cmpeqi	r2,r2,1
81104200:	1000061e 	bne	r2,zero,8110421c <bSdmaDmaM2Transfer+0x16c>
81104204:	00000b06 	br	81104234 <bSdmaDmaM2Transfer+0x184>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104208:	00900004 	movi	r2,16384
8110420c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81104210:	00800044 	movi	r2,1
81104214:	e0bff715 	stw	r2,-36(fp)
			break;
81104218:	00000806 	br	8110423c <bSdmaDmaM2Transfer+0x18c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
8110421c:	00800074 	movhi	r2,1
81104220:	10900004 	addi	r2,r2,16384
81104224:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104228:	00800044 	movi	r2,1
8110422c:	e0bff715 	stw	r2,-36(fp)
			break;
81104230:	00000206 	br	8110423c <bSdmaDmaM2Transfer+0x18c>
		default:
			bStatus = FALSE;
81104234:	e03ff415 	stw	zero,-48(fp)
			break;
81104238:	0001883a 	nop
		}
		break;
8110423c:	00006106 	br	811043c4 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81104240:	e0bffd03 	ldbu	r2,-12(fp)
81104244:	10000326 	beq	r2,zero,81104254 <bSdmaDmaM2Transfer+0x1a4>
81104248:	10800060 	cmpeqi	r2,r2,1
8110424c:	1000061e 	bne	r2,zero,81104268 <bSdmaDmaM2Transfer+0x1b8>
81104250:	00000b06 	br	81104280 <bSdmaDmaM2Transfer+0x1d0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81104254:	00980004 	movi	r2,24576
81104258:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
8110425c:	00800044 	movi	r2,1
81104260:	e0bff715 	stw	r2,-36(fp)
			break;
81104264:	00000806 	br	81104288 <bSdmaDmaM2Transfer+0x1d8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104268:	00800074 	movhi	r2,1
8110426c:	10980004 	addi	r2,r2,24576
81104270:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81104274:	00800044 	movi	r2,1
81104278:	e0bff715 	stw	r2,-36(fp)
			break;
8110427c:	00000206 	br	81104288 <bSdmaDmaM2Transfer+0x1d8>
		default:
			bStatus = FALSE;
81104280:	e03ff415 	stw	zero,-48(fp)
			break;
81104284:	0001883a 	nop
		}
		break;
81104288:	00004e06 	br	811043c4 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
8110428c:	e0bffd03 	ldbu	r2,-12(fp)
81104290:	10000326 	beq	r2,zero,811042a0 <bSdmaDmaM2Transfer+0x1f0>
81104294:	10800060 	cmpeqi	r2,r2,1
81104298:	1000061e 	bne	r2,zero,811042b4 <bSdmaDmaM2Transfer+0x204>
8110429c:	00000b06 	br	811042cc <bSdmaDmaM2Transfer+0x21c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
811042a0:	00a00014 	movui	r2,32768
811042a4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
811042a8:	00800044 	movi	r2,1
811042ac:	e0bff715 	stw	r2,-36(fp)
			break;
811042b0:	00000806 	br	811042d4 <bSdmaDmaM2Transfer+0x224>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
811042b4:	008000b4 	movhi	r2,2
811042b8:	10a00004 	addi	r2,r2,-32768
811042bc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
811042c0:	00800044 	movi	r2,1
811042c4:	e0bff715 	stw	r2,-36(fp)
			break;
811042c8:	00000206 	br	811042d4 <bSdmaDmaM2Transfer+0x224>
		default:
			bStatus = FALSE;
811042cc:	e03ff415 	stw	zero,-48(fp)
			break;
811042d0:	0001883a 	nop
		}
		break;
811042d4:	00003b06 	br	811043c4 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811042d8:	e0bffd03 	ldbu	r2,-12(fp)
811042dc:	10000326 	beq	r2,zero,811042ec <bSdmaDmaM2Transfer+0x23c>
811042e0:	10800060 	cmpeqi	r2,r2,1
811042e4:	1000061e 	bne	r2,zero,81104300 <bSdmaDmaM2Transfer+0x250>
811042e8:	00000b06 	br	81104318 <bSdmaDmaM2Transfer+0x268>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811042ec:	00a80014 	movui	r2,40960
811042f0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811042f4:	00800044 	movi	r2,1
811042f8:	e0bff715 	stw	r2,-36(fp)
			break;
811042fc:	00000806 	br	81104320 <bSdmaDmaM2Transfer+0x270>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81104300:	008000b4 	movhi	r2,2
81104304:	10a80004 	addi	r2,r2,-24576
81104308:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
8110430c:	00800044 	movi	r2,1
81104310:	e0bff715 	stw	r2,-36(fp)
			break;
81104314:	00000206 	br	81104320 <bSdmaDmaM2Transfer+0x270>
		default:
			bStatus = FALSE;
81104318:	e03ff415 	stw	zero,-48(fp)
			break;
8110431c:	0001883a 	nop
		}
		break;
81104320:	00002806 	br	811043c4 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81104324:	e0bffd03 	ldbu	r2,-12(fp)
81104328:	10000326 	beq	r2,zero,81104338 <bSdmaDmaM2Transfer+0x288>
8110432c:	10800060 	cmpeqi	r2,r2,1
81104330:	1000061e 	bne	r2,zero,8110434c <bSdmaDmaM2Transfer+0x29c>
81104334:	00000b06 	br	81104364 <bSdmaDmaM2Transfer+0x2b4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104338:	00b00014 	movui	r2,49152
8110433c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81104340:	00800044 	movi	r2,1
81104344:	e0bff715 	stw	r2,-36(fp)
			break;
81104348:	00000806 	br	8110436c <bSdmaDmaM2Transfer+0x2bc>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
8110434c:	008000b4 	movhi	r2,2
81104350:	10b00004 	addi	r2,r2,-16384
81104354:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104358:	00800044 	movi	r2,1
8110435c:	e0bff715 	stw	r2,-36(fp)
			break;
81104360:	00000206 	br	8110436c <bSdmaDmaM2Transfer+0x2bc>
		default:
			bStatus = FALSE;
81104364:	e03ff415 	stw	zero,-48(fp)
			break;
81104368:	0001883a 	nop
		}
		break;
8110436c:	00001506 	br	811043c4 <bSdmaDmaM2Transfer+0x314>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81104370:	e0bffd03 	ldbu	r2,-12(fp)
81104374:	10000326 	beq	r2,zero,81104384 <bSdmaDmaM2Transfer+0x2d4>
81104378:	10800060 	cmpeqi	r2,r2,1
8110437c:	1000061e 	bne	r2,zero,81104398 <bSdmaDmaM2Transfer+0x2e8>
81104380:	00000b06 	br	811043b0 <bSdmaDmaM2Transfer+0x300>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81104384:	00b80014 	movui	r2,57344
81104388:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
8110438c:	00800044 	movi	r2,1
81104390:	e0bff715 	stw	r2,-36(fp)
			break;
81104394:	00000806 	br	811043b8 <bSdmaDmaM2Transfer+0x308>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104398:	008000b4 	movhi	r2,2
8110439c:	10b80004 	addi	r2,r2,-8192
811043a0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
811043a4:	00800044 	movi	r2,1
811043a8:	e0bff715 	stw	r2,-36(fp)
			break;
811043ac:	00000206 	br	811043b8 <bSdmaDmaM2Transfer+0x308>
		default:
			bStatus = FALSE;
811043b0:	e03ff415 	stw	zero,-48(fp)
			break;
811043b4:	0001883a 	nop
		}
		break;
811043b8:	00000206 	br	811043c4 <bSdmaDmaM2Transfer+0x314>
	default:
		bStatus = FALSE;
811043bc:	e03ff415 	stw	zero,-48(fp)
		break;
811043c0:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
811043c4:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
811043c8:	00a00034 	movhi	r2,32768
811043cc:	1885883a 	add	r2,r3,r2
811043d0:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811043d4:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
811043d8:	e0bff417 	ldw	r2,-48(fp)
811043dc:	10003b26 	beq	r2,zero,811044cc <bSdmaDmaM2Transfer+0x41c>
		if (pxDmaM2Dev == NULL) {
811043e0:	d0a03a17 	ldw	r2,-32536(gp)
811043e4:	1000021e 	bne	r2,zero,811043f0 <bSdmaDmaM2Transfer+0x340>
			bStatus = FALSE;
811043e8:	e03ff415 	stw	zero,-48(fp)
811043ec:	00003706 	br	811044cc <bSdmaDmaM2Transfer+0x41c>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811043f0:	e03ff50d 	sth	zero,-44(fp)
811043f4:	00003206 	br	811044c0 <bSdmaDmaM2Transfer+0x410>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811043f8:	01000044 	movi	r4,1
811043fc:	112c4800 	call	8112c480 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81104400:	d0a03a17 	ldw	r2,-32536(gp)
81104404:	10800317 	ldw	r2,12(r2)
81104408:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
8110440c:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81104410:	103ff91e 	bne	r2,zero,811043f8 <__reset+0xfb0e43f8>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
81104414:	d2203a17 	ldw	r8,-32536(gp)
81104418:	e17ff817 	ldw	r5,-32(fp)
8110441c:	e1bff617 	ldw	r6,-40(fp)
81104420:	e0bff917 	ldw	r2,-28(fp)
81104424:	e0fff717 	ldw	r3,-36(fp)
81104428:	01000044 	movi	r4,1
8110442c:	d9000815 	stw	r4,32(sp)
81104430:	01000044 	movi	r4,1
81104434:	d9000715 	stw	r4,28(sp)
81104438:	01000044 	movi	r4,1
8110443c:	d9000615 	stw	r4,24(sp)
81104440:	01000044 	movi	r4,1
81104444:	d9000515 	stw	r4,20(sp)
81104448:	01000044 	movi	r4,1
8110444c:	d9000415 	stw	r4,16(sp)
81104450:	d8c00315 	stw	r3,12(sp)
81104454:	d8800215 	stw	r2,8(sp)
81104458:	e0bffa17 	ldw	r2,-24(fp)
8110445c:	d8800115 	stw	r2,4(sp)
81104460:	00802204 	movi	r2,136
81104464:	d8800015 	stw	r2,0(sp)
81104468:	300f883a 	mov	r7,r6
8110446c:	280d883a 	mov	r6,r5
81104470:	800b883a 	mov	r5,r16
81104474:	4009883a 	mov	r4,r8
81104478:	1106bcc0 	call	81106bcc <iMsgdmaConstructExtendedMmToMmDescriptor>
8110447c:	10000226 	beq	r2,zero,81104488 <bSdmaDmaM2Transfer+0x3d8>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104480:	e03ff415 	stw	zero,-48(fp)
					break;
81104484:	00001106 	br	811044cc <bSdmaDmaM2Transfer+0x41c>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104488:	d0a03a17 	ldw	r2,-32536(gp)
8110448c:	800b883a 	mov	r5,r16
81104490:	1009883a 	mov	r4,r2
81104494:	1106cd00 	call	81106cd0 <iMsgdmaExtendedDescriptorSyncTransfer>
81104498:	10000226 	beq	r2,zero,811044a4 <bSdmaDmaM2Transfer+0x3f4>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
8110449c:	e03ff415 	stw	zero,-48(fp)
						break;
811044a0:	00000a06 	br	811044cc <bSdmaDmaM2Transfer+0x41c>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
811044a4:	e0bff817 	ldw	r2,-32(fp)
811044a8:	10802204 	addi	r2,r2,136
811044ac:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811044b0:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811044b4:	e0bff50b 	ldhu	r2,-44(fp)
811044b8:	10800044 	addi	r2,r2,1
811044bc:	e0bff50d 	sth	r2,-44(fp)
811044c0:	e0fff50b 	ldhu	r3,-44(fp)
811044c4:	e0bffc0b 	ldhu	r2,-16(fp)
811044c8:	18bfcd36 	bltu	r3,r2,81104400 <__reset+0xfb0e4400>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
811044cc:	e0bff417 	ldw	r2,-48(fp)
}
811044d0:	e6ffff04 	addi	sp,fp,-4
811044d4:	dfc00217 	ldw	ra,8(sp)
811044d8:	df000117 	ldw	fp,4(sp)
811044dc:	dc000017 	ldw	r16,0(sp)
811044e0:	dec00304 	addi	sp,sp,12
811044e4:	f800283a 	ret

811044e8 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
811044e8:	defffc04 	addi	sp,sp,-16
811044ec:	de00012e 	bgeu	sp,et,811044f4 <vFeebCh1HandleIrq+0xc>
811044f0:	003b68fa 	trap	3
811044f4:	dfc00315 	stw	ra,12(sp)
811044f8:	df000215 	stw	fp,8(sp)
811044fc:	df000204 	addi	fp,sp,8
81104500:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104504:	e0bfff17 	ldw	r2,-4(fp)
81104508:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh1IrqFlagClrBufferEmpty();
8110450c:	11046e80 	call	811046e8 <vFeebCh1IrqFlagClrBufferEmpty>
}
81104510:	0001883a 	nop
81104514:	e037883a 	mov	sp,fp
81104518:	dfc00117 	ldw	ra,4(sp)
8110451c:	df000017 	ldw	fp,0(sp)
81104520:	dec00204 	addi	sp,sp,8
81104524:	f800283a 	ret

81104528 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
81104528:	defffc04 	addi	sp,sp,-16
8110452c:	de00012e 	bgeu	sp,et,81104534 <vFeebCh2HandleIrq+0xc>
81104530:	003b68fa 	trap	3
81104534:	dfc00315 	stw	ra,12(sp)
81104538:	df000215 	stw	fp,8(sp)
8110453c:	df000204 	addi	fp,sp,8
81104540:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104544:	e0bfff17 	ldw	r2,-4(fp)
81104548:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh2IrqFlagClrBufferEmpty();
8110454c:	110472c0 	call	8110472c <vFeebCh2IrqFlagClrBufferEmpty>
}
81104550:	0001883a 	nop
81104554:	e037883a 	mov	sp,fp
81104558:	dfc00117 	ldw	ra,4(sp)
8110455c:	df000017 	ldw	fp,0(sp)
81104560:	dec00204 	addi	sp,sp,8
81104564:	f800283a 	ret

81104568 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81104568:	defffc04 	addi	sp,sp,-16
8110456c:	de00012e 	bgeu	sp,et,81104574 <vFeebCh3HandleIrq+0xc>
81104570:	003b68fa 	trap	3
81104574:	dfc00315 	stw	ra,12(sp)
81104578:	df000215 	stw	fp,8(sp)
8110457c:	df000204 	addi	fp,sp,8
81104580:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104584:	e0bfff17 	ldw	r2,-4(fp)
81104588:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh3IrqFlagClrBufferEmpty();
8110458c:	11047700 	call	81104770 <vFeebCh3IrqFlagClrBufferEmpty>
}
81104590:	0001883a 	nop
81104594:	e037883a 	mov	sp,fp
81104598:	dfc00117 	ldw	ra,4(sp)
8110459c:	df000017 	ldw	fp,0(sp)
811045a0:	dec00204 	addi	sp,sp,8
811045a4:	f800283a 	ret

811045a8 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
811045a8:	defffc04 	addi	sp,sp,-16
811045ac:	de00012e 	bgeu	sp,et,811045b4 <vFeebCh4HandleIrq+0xc>
811045b0:	003b68fa 	trap	3
811045b4:	dfc00315 	stw	ra,12(sp)
811045b8:	df000215 	stw	fp,8(sp)
811045bc:	df000204 	addi	fp,sp,8
811045c0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811045c4:	e0bfff17 	ldw	r2,-4(fp)
811045c8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh4IrqFlagClrBufferEmpty();
811045cc:	11047b40 	call	811047b4 <vFeebCh4IrqFlagClrBufferEmpty>
}
811045d0:	0001883a 	nop
811045d4:	e037883a 	mov	sp,fp
811045d8:	dfc00117 	ldw	ra,4(sp)
811045dc:	df000017 	ldw	fp,0(sp)
811045e0:	dec00204 	addi	sp,sp,8
811045e4:	f800283a 	ret

811045e8 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
811045e8:	defffc04 	addi	sp,sp,-16
811045ec:	de00012e 	bgeu	sp,et,811045f4 <vFeebCh5HandleIrq+0xc>
811045f0:	003b68fa 	trap	3
811045f4:	dfc00315 	stw	ra,12(sp)
811045f8:	df000215 	stw	fp,8(sp)
811045fc:	df000204 	addi	fp,sp,8
81104600:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104604:	e0bfff17 	ldw	r2,-4(fp)
81104608:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh5IrqFlagClrBufferEmpty();
8110460c:	11047f80 	call	811047f8 <vFeebCh5IrqFlagClrBufferEmpty>
}
81104610:	0001883a 	nop
81104614:	e037883a 	mov	sp,fp
81104618:	dfc00117 	ldw	ra,4(sp)
8110461c:	df000017 	ldw	fp,0(sp)
81104620:	dec00204 	addi	sp,sp,8
81104624:	f800283a 	ret

81104628 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
81104628:	defffc04 	addi	sp,sp,-16
8110462c:	de00012e 	bgeu	sp,et,81104634 <vFeebCh6HandleIrq+0xc>
81104630:	003b68fa 	trap	3
81104634:	dfc00315 	stw	ra,12(sp)
81104638:	df000215 	stw	fp,8(sp)
8110463c:	df000204 	addi	fp,sp,8
81104640:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104644:	e0bfff17 	ldw	r2,-4(fp)
81104648:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vFeebCh6IrqFlagClrBufferEmpty();
8110464c:	110483c0 	call	8110483c <vFeebCh6IrqFlagClrBufferEmpty>
}
81104650:	0001883a 	nop
81104654:	e037883a 	mov	sp,fp
81104658:	dfc00117 	ldw	ra,4(sp)
8110465c:	df000017 	ldw	fp,0(sp)
81104660:	dec00204 	addi	sp,sp,8
81104664:	f800283a 	ret

81104668 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
81104668:	defffc04 	addi	sp,sp,-16
8110466c:	de00012e 	bgeu	sp,et,81104674 <vFeebCh7HandleIrq+0xc>
81104670:	003b68fa 	trap	3
81104674:	dfc00315 	stw	ra,12(sp)
81104678:	df000215 	stw	fp,8(sp)
8110467c:	df000204 	addi	fp,sp,8
81104680:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104684:	e0bfff17 	ldw	r2,-4(fp)
81104688:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh7IrqFlagClrBufferEmpty();
8110468c:	11048800 	call	81104880 <vFeebCh7IrqFlagClrBufferEmpty>
}
81104690:	0001883a 	nop
81104694:	e037883a 	mov	sp,fp
81104698:	dfc00117 	ldw	ra,4(sp)
8110469c:	df000017 	ldw	fp,0(sp)
811046a0:	dec00204 	addi	sp,sp,8
811046a4:	f800283a 	ret

811046a8 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
811046a8:	defffc04 	addi	sp,sp,-16
811046ac:	de00012e 	bgeu	sp,et,811046b4 <vFeebCh8HandleIrq+0xc>
811046b0:	003b68fa 	trap	3
811046b4:	dfc00315 	stw	ra,12(sp)
811046b8:	df000215 	stw	fp,8(sp)
811046bc:	df000204 	addi	fp,sp,8
811046c0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811046c4:	e0bfff17 	ldw	r2,-4(fp)
811046c8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh8IrqFlagClrBufferEmpty();
811046cc:	11048c40 	call	811048c4 <vFeebCh8IrqFlagClrBufferEmpty>
}
811046d0:	0001883a 	nop
811046d4:	e037883a 	mov	sp,fp
811046d8:	dfc00117 	ldw	ra,4(sp)
811046dc:	df000017 	ldw	fp,0(sp)
811046e0:	dec00204 	addi	sp,sp,8
811046e4:	f800283a 	ret

811046e8 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
811046e8:	defffe04 	addi	sp,sp,-8
811046ec:	de00012e 	bgeu	sp,et,811046f4 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
811046f0:	003b68fa 	trap	3
811046f4:	dfc00115 	stw	ra,4(sp)
811046f8:	df000015 	stw	fp,0(sp)
811046fc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81104700:	01800044 	movi	r6,1
81104704:	01400144 	movi	r5,5
81104708:	01204834 	movhi	r4,33056
8110470c:	210b0004 	addi	r4,r4,11264
81104710:	11051280 	call	81105128 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104714:	0001883a 	nop
81104718:	e037883a 	mov	sp,fp
8110471c:	dfc00117 	ldw	ra,4(sp)
81104720:	df000017 	ldw	fp,0(sp)
81104724:	dec00204 	addi	sp,sp,8
81104728:	f800283a 	ret

8110472c <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
8110472c:	defffe04 	addi	sp,sp,-8
81104730:	de00012e 	bgeu	sp,et,81104738 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
81104734:	003b68fa 	trap	3
81104738:	dfc00115 	stw	ra,4(sp)
8110473c:	df000015 	stw	fp,0(sp)
81104740:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81104744:	01800044 	movi	r6,1
81104748:	01400144 	movi	r5,5
8110474c:	01204834 	movhi	r4,33056
81104750:	210a0004 	addi	r4,r4,10240
81104754:	11051280 	call	81105128 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104758:	0001883a 	nop
8110475c:	e037883a 	mov	sp,fp
81104760:	dfc00117 	ldw	ra,4(sp)
81104764:	df000017 	ldw	fp,0(sp)
81104768:	dec00204 	addi	sp,sp,8
8110476c:	f800283a 	ret

81104770 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
81104770:	defffe04 	addi	sp,sp,-8
81104774:	de00012e 	bgeu	sp,et,8110477c <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81104778:	003b68fa 	trap	3
8110477c:	dfc00115 	stw	ra,4(sp)
81104780:	df000015 	stw	fp,0(sp)
81104784:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81104788:	01800044 	movi	r6,1
8110478c:	01400144 	movi	r5,5
81104790:	01204834 	movhi	r4,33056
81104794:	21090004 	addi	r4,r4,9216
81104798:	11051280 	call	81105128 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
8110479c:	0001883a 	nop
811047a0:	e037883a 	mov	sp,fp
811047a4:	dfc00117 	ldw	ra,4(sp)
811047a8:	df000017 	ldw	fp,0(sp)
811047ac:	dec00204 	addi	sp,sp,8
811047b0:	f800283a 	ret

811047b4 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
811047b4:	defffe04 	addi	sp,sp,-8
811047b8:	de00012e 	bgeu	sp,et,811047c0 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
811047bc:	003b68fa 	trap	3
811047c0:	dfc00115 	stw	ra,4(sp)
811047c4:	df000015 	stw	fp,0(sp)
811047c8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811047cc:	01800044 	movi	r6,1
811047d0:	01400144 	movi	r5,5
811047d4:	01204834 	movhi	r4,33056
811047d8:	21080004 	addi	r4,r4,8192
811047dc:	11051280 	call	81105128 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
811047e0:	0001883a 	nop
811047e4:	e037883a 	mov	sp,fp
811047e8:	dfc00117 	ldw	ra,4(sp)
811047ec:	df000017 	ldw	fp,0(sp)
811047f0:	dec00204 	addi	sp,sp,8
811047f4:	f800283a 	ret

811047f8 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
811047f8:	defffe04 	addi	sp,sp,-8
811047fc:	de00012e 	bgeu	sp,et,81104804 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81104800:	003b68fa 	trap	3
81104804:	dfc00115 	stw	ra,4(sp)
81104808:	df000015 	stw	fp,0(sp)
8110480c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81104810:	01800044 	movi	r6,1
81104814:	01400144 	movi	r5,5
81104818:	01204834 	movhi	r4,33056
8110481c:	21070004 	addi	r4,r4,7168
81104820:	11051280 	call	81105128 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104824:	0001883a 	nop
81104828:	e037883a 	mov	sp,fp
8110482c:	dfc00117 	ldw	ra,4(sp)
81104830:	df000017 	ldw	fp,0(sp)
81104834:	dec00204 	addi	sp,sp,8
81104838:	f800283a 	ret

8110483c <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
8110483c:	defffe04 	addi	sp,sp,-8
81104840:	de00012e 	bgeu	sp,et,81104848 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
81104844:	003b68fa 	trap	3
81104848:	dfc00115 	stw	ra,4(sp)
8110484c:	df000015 	stw	fp,0(sp)
81104850:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104854:	01800044 	movi	r6,1
81104858:	01400144 	movi	r5,5
8110485c:	01204834 	movhi	r4,33056
81104860:	21060004 	addi	r4,r4,6144
81104864:	11051280 	call	81105128 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
81104868:	0001883a 	nop
8110486c:	e037883a 	mov	sp,fp
81104870:	dfc00117 	ldw	ra,4(sp)
81104874:	df000017 	ldw	fp,0(sp)
81104878:	dec00204 	addi	sp,sp,8
8110487c:	f800283a 	ret

81104880 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
81104880:	defffe04 	addi	sp,sp,-8
81104884:	de00012e 	bgeu	sp,et,8110488c <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81104888:	003b68fa 	trap	3
8110488c:	dfc00115 	stw	ra,4(sp)
81104890:	df000015 	stw	fp,0(sp)
81104894:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81104898:	01800044 	movi	r6,1
8110489c:	01400144 	movi	r5,5
811048a0:	01204834 	movhi	r4,33056
811048a4:	21050004 	addi	r4,r4,5120
811048a8:	11051280 	call	81105128 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
811048ac:	0001883a 	nop
811048b0:	e037883a 	mov	sp,fp
811048b4:	dfc00117 	ldw	ra,4(sp)
811048b8:	df000017 	ldw	fp,0(sp)
811048bc:	dec00204 	addi	sp,sp,8
811048c0:	f800283a 	ret

811048c4 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
811048c4:	defffe04 	addi	sp,sp,-8
811048c8:	de00012e 	bgeu	sp,et,811048d0 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
811048cc:	003b68fa 	trap	3
811048d0:	dfc00115 	stw	ra,4(sp)
811048d4:	df000015 	stw	fp,0(sp)
811048d8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811048dc:	01800044 	movi	r6,1
811048e0:	01400144 	movi	r5,5
811048e4:	01204834 	movhi	r4,33056
811048e8:	21040004 	addi	r4,r4,4096
811048ec:	11051280 	call	81105128 <vFeebWriteReg>
	COMM_IRQ_FLAG_REG_OFFSET, (alt_u32) COMM_IRQ_BUFFER_EMPTY_FLAG_MSK);
}
811048f0:	0001883a 	nop
811048f4:	e037883a 	mov	sp,fp
811048f8:	dfc00117 	ldw	ra,4(sp)
811048fc:	df000017 	ldw	fp,0(sp)
81104900:	dec00204 	addi	sp,sp,8
81104904:	f800283a 	ret

81104908 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81104908:	defffd04 	addi	sp,sp,-12
8110490c:	de00012e 	bgeu	sp,et,81104914 <bFeebCh1IrqFlagBufferEmpty+0xc>
81104910:	003b68fa 	trap	3
81104914:	dfc00215 	stw	ra,8(sp)
81104918:	df000115 	stw	fp,4(sp)
8110491c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81104920:	01400144 	movi	r5,5
81104924:	01204834 	movhi	r4,33056
81104928:	210b0004 	addi	r4,r4,11264
8110492c:	110517c0 	call	8110517c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104930:	1080004c 	andi	r2,r2,1
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81104934:	10000326 	beq	r2,zero,81104944 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104938:	00800044 	movi	r2,1
8110493c:	e0bfff15 	stw	r2,-4(fp)
81104940:	00000106 	br	81104948 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104944:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104948:	e0bfff17 	ldw	r2,-4(fp)
}
8110494c:	e037883a 	mov	sp,fp
81104950:	dfc00117 	ldw	ra,4(sp)
81104954:	df000017 	ldw	fp,0(sp)
81104958:	dec00204 	addi	sp,sp,8
8110495c:	f800283a 	ret

81104960 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
81104960:	defffd04 	addi	sp,sp,-12
81104964:	de00012e 	bgeu	sp,et,8110496c <bFeebCh2IrqFlagBufferEmpty+0xc>
81104968:	003b68fa 	trap	3
8110496c:	dfc00215 	stw	ra,8(sp)
81104970:	df000115 	stw	fp,4(sp)
81104974:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81104978:	01400144 	movi	r5,5
8110497c:	01204834 	movhi	r4,33056
81104980:	210a0004 	addi	r4,r4,10240
81104984:	110517c0 	call	8110517c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104988:	1080004c 	andi	r2,r2,1
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110498c:	10000326 	beq	r2,zero,8110499c <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104990:	00800044 	movi	r2,1
81104994:	e0bfff15 	stw	r2,-4(fp)
81104998:	00000106 	br	811049a0 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110499c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811049a0:	e0bfff17 	ldw	r2,-4(fp)
}
811049a4:	e037883a 	mov	sp,fp
811049a8:	dfc00117 	ldw	ra,4(sp)
811049ac:	df000017 	ldw	fp,0(sp)
811049b0:	dec00204 	addi	sp,sp,8
811049b4:	f800283a 	ret

811049b8 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
811049b8:	defffd04 	addi	sp,sp,-12
811049bc:	de00012e 	bgeu	sp,et,811049c4 <bFeebCh3IrqFlagBufferEmpty+0xc>
811049c0:	003b68fa 	trap	3
811049c4:	dfc00215 	stw	ra,8(sp)
811049c8:	df000115 	stw	fp,4(sp)
811049cc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811049d0:	01400144 	movi	r5,5
811049d4:	01204834 	movhi	r4,33056
811049d8:	21090004 	addi	r4,r4,9216
811049dc:	110517c0 	call	8110517c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
811049e0:	1080004c 	andi	r2,r2,1
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811049e4:	10000326 	beq	r2,zero,811049f4 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
811049e8:	00800044 	movi	r2,1
811049ec:	e0bfff15 	stw	r2,-4(fp)
811049f0:	00000106 	br	811049f8 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811049f4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811049f8:	e0bfff17 	ldw	r2,-4(fp)
}
811049fc:	e037883a 	mov	sp,fp
81104a00:	dfc00117 	ldw	ra,4(sp)
81104a04:	df000017 	ldw	fp,0(sp)
81104a08:	dec00204 	addi	sp,sp,8
81104a0c:	f800283a 	ret

81104a10 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81104a10:	defffd04 	addi	sp,sp,-12
81104a14:	de00012e 	bgeu	sp,et,81104a1c <bFeebCh4IrqFlagBufferEmpty+0xc>
81104a18:	003b68fa 	trap	3
81104a1c:	dfc00215 	stw	ra,8(sp)
81104a20:	df000115 	stw	fp,4(sp)
81104a24:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81104a28:	01400144 	movi	r5,5
81104a2c:	01204834 	movhi	r4,33056
81104a30:	21080004 	addi	r4,r4,8192
81104a34:	110517c0 	call	8110517c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104a38:	1080004c 	andi	r2,r2,1
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81104a3c:	10000326 	beq	r2,zero,81104a4c <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104a40:	00800044 	movi	r2,1
81104a44:	e0bfff15 	stw	r2,-4(fp)
81104a48:	00000106 	br	81104a50 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104a4c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104a50:	e0bfff17 	ldw	r2,-4(fp)
}
81104a54:	e037883a 	mov	sp,fp
81104a58:	dfc00117 	ldw	ra,4(sp)
81104a5c:	df000017 	ldw	fp,0(sp)
81104a60:	dec00204 	addi	sp,sp,8
81104a64:	f800283a 	ret

81104a68 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
81104a68:	defffd04 	addi	sp,sp,-12
81104a6c:	de00012e 	bgeu	sp,et,81104a74 <bFeebCh5IrqFlagBufferEmpty+0xc>
81104a70:	003b68fa 	trap	3
81104a74:	dfc00215 	stw	ra,8(sp)
81104a78:	df000115 	stw	fp,4(sp)
81104a7c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81104a80:	01400144 	movi	r5,5
81104a84:	01204834 	movhi	r4,33056
81104a88:	21070004 	addi	r4,r4,7168
81104a8c:	110517c0 	call	8110517c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104a90:	1080004c 	andi	r2,r2,1
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81104a94:	10000326 	beq	r2,zero,81104aa4 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104a98:	00800044 	movi	r2,1
81104a9c:	e0bfff15 	stw	r2,-4(fp)
81104aa0:	00000106 	br	81104aa8 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104aa4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104aa8:	e0bfff17 	ldw	r2,-4(fp)
}
81104aac:	e037883a 	mov	sp,fp
81104ab0:	dfc00117 	ldw	ra,4(sp)
81104ab4:	df000017 	ldw	fp,0(sp)
81104ab8:	dec00204 	addi	sp,sp,8
81104abc:	f800283a 	ret

81104ac0 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81104ac0:	defffd04 	addi	sp,sp,-12
81104ac4:	de00012e 	bgeu	sp,et,81104acc <bFeebCh6IrqFlagBufferEmpty+0xc>
81104ac8:	003b68fa 	trap	3
81104acc:	dfc00215 	stw	ra,8(sp)
81104ad0:	df000115 	stw	fp,4(sp)
81104ad4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104ad8:	01400144 	movi	r5,5
81104adc:	01204834 	movhi	r4,33056
81104ae0:	21060004 	addi	r4,r4,6144
81104ae4:	110517c0 	call	8110517c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104ae8:	1080004c 	andi	r2,r2,1
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104aec:	10000326 	beq	r2,zero,81104afc <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104af0:	00800044 	movi	r2,1
81104af4:	e0bfff15 	stw	r2,-4(fp)
81104af8:	00000106 	br	81104b00 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104afc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104b00:	e0bfff17 	ldw	r2,-4(fp)
}
81104b04:	e037883a 	mov	sp,fp
81104b08:	dfc00117 	ldw	ra,4(sp)
81104b0c:	df000017 	ldw	fp,0(sp)
81104b10:	dec00204 	addi	sp,sp,8
81104b14:	f800283a 	ret

81104b18 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81104b18:	defffd04 	addi	sp,sp,-12
81104b1c:	de00012e 	bgeu	sp,et,81104b24 <bFeebCh7IrqFlagBufferEmpty+0xc>
81104b20:	003b68fa 	trap	3
81104b24:	dfc00215 	stw	ra,8(sp)
81104b28:	df000115 	stw	fp,4(sp)
81104b2c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81104b30:	01400144 	movi	r5,5
81104b34:	01204834 	movhi	r4,33056
81104b38:	21050004 	addi	r4,r4,5120
81104b3c:	110517c0 	call	8110517c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104b40:	1080004c 	andi	r2,r2,1
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81104b44:	10000326 	beq	r2,zero,81104b54 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104b48:	00800044 	movi	r2,1
81104b4c:	e0bfff15 	stw	r2,-4(fp)
81104b50:	00000106 	br	81104b58 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104b54:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104b58:	e0bfff17 	ldw	r2,-4(fp)
}
81104b5c:	e037883a 	mov	sp,fp
81104b60:	dfc00117 	ldw	ra,4(sp)
81104b64:	df000017 	ldw	fp,0(sp)
81104b68:	dec00204 	addi	sp,sp,8
81104b6c:	f800283a 	ret

81104b70 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81104b70:	defffd04 	addi	sp,sp,-12
81104b74:	de00012e 	bgeu	sp,et,81104b7c <bFeebCh8IrqFlagBufferEmpty+0xc>
81104b78:	003b68fa 	trap	3
81104b7c:	dfc00215 	stw	ra,8(sp)
81104b80:	df000115 	stw	fp,4(sp)
81104b84:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81104b88:	01400144 	movi	r5,5
81104b8c:	01204834 	movhi	r4,33056
81104b90:	21040004 	addi	r4,r4,4096
81104b94:	110517c0 	call	8110517c <uliFeebReadReg>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104b98:	1080004c 	andi	r2,r2,1
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81104b9c:	10000326 	beq	r2,zero,81104bac <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAG_REG_OFFSET) & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
		bFlag = TRUE;
81104ba0:	00800044 	movi	r2,1
81104ba4:	e0bfff15 	stw	r2,-4(fp)
81104ba8:	00000106 	br	81104bb0 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81104bac:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81104bb0:	e0bfff17 	ldw	r2,-4(fp)
}
81104bb4:	e037883a 	mov	sp,fp
81104bb8:	dfc00117 	ldw	ra,4(sp)
81104bbc:	df000017 	ldw	fp,0(sp)
81104bc0:	dec00204 	addi	sp,sp,8
81104bc4:	f800283a 	ret

81104bc8 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81104bc8:	defffc04 	addi	sp,sp,-16
81104bcc:	de00012e 	bgeu	sp,et,81104bd4 <vFeebInitIrq+0xc>
81104bd0:	003b68fa 	trap	3
81104bd4:	dfc00315 	stw	ra,12(sp)
81104bd8:	df000215 	stw	fp,8(sp)
81104bdc:	df000204 	addi	fp,sp,8
81104be0:	2005883a 	mov	r2,r4
81104be4:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81104be8:	e0bfff03 	ldbu	r2,-4(fp)
81104bec:	10c00228 	cmpgeui	r3,r2,8
81104bf0:	18004e1e 	bne	r3,zero,81104d2c <vFeebInitIrq+0x164>
81104bf4:	100690ba 	slli	r3,r2,2
81104bf8:	00a04434 	movhi	r2,33040
81104bfc:	10930304 	addi	r2,r2,19468
81104c00:	1885883a 	add	r2,r3,r2
81104c04:	10800017 	ldw	r2,0(r2)
81104c08:	1000683a 	jmp	r2
81104c0c:	81104c2c 	andhi	r4,r16,16688
81104c10:	81104c4c 	andi	r4,r16,16689
81104c14:	81104c6c 	andhi	r4,r16,16689
81104c18:	81104c8c 	andi	r4,r16,16690
81104c1c:	81104cac 	andhi	r4,r16,16690
81104c20:	81104ccc 	andi	r4,r16,16691
81104c24:	81104cec 	andhi	r4,r16,16691
81104c28:	81104d0c 	andi	r4,r16,16692
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81104c2c:	d0a03e04 	addi	r2,gp,-32520
81104c30:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_A_IRQ, pvHoldContext,
81104c34:	01a04434 	movhi	r6,33040
81104c38:	31913a04 	addi	r6,r6,17640
81104c3c:	e17ffe17 	ldw	r5,-8(fp)
81104c40:	01000084 	movi	r4,2
81104c44:	112c8240 	call	8112c824 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81104c48:	00003806 	br	81104d2c <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81104c4c:	d0a03f04 	addi	r2,gp,-32516
81104c50:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_B_IRQ, pvHoldContext,
81104c54:	01a04434 	movhi	r6,33040
81104c58:	31914a04 	addi	r6,r6,17704
81104c5c:	e17ffe17 	ldw	r5,-8(fp)
81104c60:	010000c4 	movi	r4,3
81104c64:	112c8240 	call	8112c824 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81104c68:	00003006 	br	81104d2c <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81104c6c:	d0a04004 	addi	r2,gp,-32512
81104c70:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_C_IRQ, pvHoldContext,
81104c74:	01a04434 	movhi	r6,33040
81104c78:	31915a04 	addi	r6,r6,17768
81104c7c:	e17ffe17 	ldw	r5,-8(fp)
81104c80:	01000104 	movi	r4,4
81104c84:	112c8240 	call	8112c824 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81104c88:	00002806 	br	81104d2c <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81104c8c:	d0a04104 	addi	r2,gp,-32508
81104c90:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_D_IRQ, pvHoldContext,
81104c94:	01a04434 	movhi	r6,33040
81104c98:	31916a04 	addi	r6,r6,17832
81104c9c:	e17ffe17 	ldw	r5,-8(fp)
81104ca0:	01000204 	movi	r4,8
81104ca4:	112c8240 	call	8112c824 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81104ca8:	00002006 	br	81104d2c <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81104cac:	d0a04204 	addi	r2,gp,-32504
81104cb0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_E_IRQ, pvHoldContext,
81104cb4:	01a04434 	movhi	r6,33040
81104cb8:	31917a04 	addi	r6,r6,17896
81104cbc:	e17ffe17 	ldw	r5,-8(fp)
81104cc0:	010001c4 	movi	r4,7
81104cc4:	112c8240 	call	8112c824 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81104cc8:	00001806 	br	81104d2c <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81104ccc:	d0a04304 	addi	r2,gp,-32500
81104cd0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_F_IRQ, pvHoldContext,
81104cd4:	01a04434 	movhi	r6,33040
81104cd8:	31918a04 	addi	r6,r6,17960
81104cdc:	e17ffe17 	ldw	r5,-8(fp)
81104ce0:	01000184 	movi	r4,6
81104ce4:	112c8240 	call	8112c824 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81104ce8:	00001006 	br	81104d2c <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81104cec:	d0a04404 	addi	r2,gp,-32496
81104cf0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_G_IRQ, pvHoldContext,
81104cf4:	01a04434 	movhi	r6,33040
81104cf8:	31919a04 	addi	r6,r6,18024
81104cfc:	e17ffe17 	ldw	r5,-8(fp)
81104d00:	01000144 	movi	r4,5
81104d04:	112c8240 	call	8112c824 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81104d08:	00000806 	br	81104d2c <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81104d0c:	d0a04504 	addi	r2,gp,-32492
81104d10:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_PEDREIRO_V1_01_H_IRQ, pvHoldContext,
81104d14:	01a04434 	movhi	r6,33040
81104d18:	3191aa04 	addi	r6,r6,18088
81104d1c:	e17ffe17 	ldw	r5,-8(fp)
81104d20:	01000244 	movi	r4,9
81104d24:	112c8240 	call	8112c824 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81104d28:	0001883a 	nop
	}
}
81104d2c:	0001883a 	nop
81104d30:	e037883a 	mov	sp,fp
81104d34:	dfc00117 	ldw	ra,4(sp)
81104d38:	df000017 	ldw	fp,0(sp)
81104d3c:	dec00204 	addi	sp,sp,8
81104d40:	f800283a 	ret

81104d44 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81104d44:	defffb04 	addi	sp,sp,-20
81104d48:	de00012e 	bgeu	sp,et,81104d50 <bFeebSetIrqControl+0xc>
81104d4c:	003b68fa 	trap	3
81104d50:	dfc00415 	stw	ra,16(sp)
81104d54:	df000315 	stw	fp,12(sp)
81104d58:	df000304 	addi	fp,sp,12
81104d5c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d60:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d64:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104d68:	e0bfff17 	ldw	r2,-4(fp)
81104d6c:	10002426 	beq	r2,zero,81104e00 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104d70:	e0bfff17 	ldw	r2,-4(fp)
81104d74:	10800017 	ldw	r2,0(r2)
81104d78:	01400104 	movi	r5,4
81104d7c:	1009883a 	mov	r4,r2
81104d80:	110517c0 	call	8110517c <uliFeebReadReg>
81104d84:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CTRL_REG_OFFSET);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81104d88:	e0bfff17 	ldw	r2,-4(fp)
81104d8c:	10800217 	ldw	r2,8(r2)
81104d90:	10000426 	beq	r2,zero,81104da4 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_L_BUFFER_EMPTY_EN_MSK;
81104d94:	e0bffe17 	ldw	r2,-8(fp)
81104d98:	10804014 	ori	r2,r2,256
81104d9c:	e0bffe15 	stw	r2,-8(fp)
81104da0:	00000406 	br	81104db4 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_L_BUFFER_EMPTY_EN_MSK);
81104da4:	e0fffe17 	ldw	r3,-8(fp)
81104da8:	00bfbfc4 	movi	r2,-257
81104dac:	1884703a 	and	r2,r3,r2
81104db0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81104db4:	e0bfff17 	ldw	r2,-4(fp)
81104db8:	10800317 	ldw	r2,12(r2)
81104dbc:	10000426 	beq	r2,zero,81104dd0 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_R_BUFFER_EMPTY_EN_MSK;
81104dc0:	e0bffe17 	ldw	r2,-8(fp)
81104dc4:	10800054 	ori	r2,r2,1
81104dc8:	e0bffe15 	stw	r2,-8(fp)
81104dcc:	00000406 	br	81104de0 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_R_BUFFER_EMPTY_EN_MSK);
81104dd0:	e0fffe17 	ldw	r3,-8(fp)
81104dd4:	00bfff84 	movi	r2,-2
81104dd8:	1884703a 	and	r2,r3,r2
81104ddc:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CTRL_REG_OFFSET,
81104de0:	e0bfff17 	ldw	r2,-4(fp)
81104de4:	10800017 	ldw	r2,0(r2)
81104de8:	e1bffe17 	ldw	r6,-8(fp)
81104dec:	01400104 	movi	r5,4
81104df0:	1009883a 	mov	r4,r2
81104df4:	11051280 	call	81105128 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81104df8:	00800044 	movi	r2,1
81104dfc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104e00:	e0bffd17 	ldw	r2,-12(fp)
}
81104e04:	e037883a 	mov	sp,fp
81104e08:	dfc00117 	ldw	ra,4(sp)
81104e0c:	df000017 	ldw	fp,0(sp)
81104e10:	dec00204 	addi	sp,sp,8
81104e14:	f800283a 	ret

81104e18 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81104e18:	defffb04 	addi	sp,sp,-20
81104e1c:	de00012e 	bgeu	sp,et,81104e24 <bFeebGetIrqControl+0xc>
81104e20:	003b68fa 	trap	3
81104e24:	dfc00415 	stw	ra,16(sp)
81104e28:	df000315 	stw	fp,12(sp)
81104e2c:	df000304 	addi	fp,sp,12
81104e30:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104e34:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104e38:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104e3c:	e0bfff17 	ldw	r2,-4(fp)
81104e40:	10001a26 	beq	r2,zero,81104eac <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104e44:	e0bfff17 	ldw	r2,-4(fp)
81104e48:	10800017 	ldw	r2,0(r2)
81104e4c:	01400104 	movi	r5,4
81104e50:	1009883a 	mov	r4,r2
81104e54:	110517c0 	call	8110517c <uliFeebReadReg>
81104e58:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CTRL_REG_OFFSET);

		if (uliReg & COMM_IRQ_L_BUFFER_EMPTY_EN_MSK) {
81104e5c:	e0bffe17 	ldw	r2,-8(fp)
81104e60:	1080400c 	andi	r2,r2,256
81104e64:	10000426 	beq	r2,zero,81104e78 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81104e68:	e0bfff17 	ldw	r2,-4(fp)
81104e6c:	00c00044 	movi	r3,1
81104e70:	10c00215 	stw	r3,8(r2)
81104e74:	00000206 	br	81104e80 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81104e78:	e0bfff17 	ldw	r2,-4(fp)
81104e7c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_R_BUFFER_EMPTY_EN_MSK) {
81104e80:	e0bffe17 	ldw	r2,-8(fp)
81104e84:	1080004c 	andi	r2,r2,1
81104e88:	10000426 	beq	r2,zero,81104e9c <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81104e8c:	e0bfff17 	ldw	r2,-4(fp)
81104e90:	00c00044 	movi	r3,1
81104e94:	10c00315 	stw	r3,12(r2)
81104e98:	00000206 	br	81104ea4 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81104e9c:	e0bfff17 	ldw	r2,-4(fp)
81104ea0:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81104ea4:	00800044 	movi	r2,1
81104ea8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104eac:	e0bffd17 	ldw	r2,-12(fp)
}
81104eb0:	e037883a 	mov	sp,fp
81104eb4:	dfc00117 	ldw	ra,4(sp)
81104eb8:	df000017 	ldw	fp,0(sp)
81104ebc:	dec00204 	addi	sp,sp,8
81104ec0:	f800283a 	ret

81104ec4 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81104ec4:	defffb04 	addi	sp,sp,-20
81104ec8:	de00012e 	bgeu	sp,et,81104ed0 <bFeebGetIrqFlags+0xc>
81104ecc:	003b68fa 	trap	3
81104ed0:	dfc00415 	stw	ra,16(sp)
81104ed4:	df000315 	stw	fp,12(sp)
81104ed8:	df000304 	addi	fp,sp,12
81104edc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104ee0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104ee4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104ee8:	e0bfff17 	ldw	r2,-4(fp)
81104eec:	10001126 	beq	r2,zero,81104f34 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104ef0:	e0bfff17 	ldw	r2,-4(fp)
81104ef4:	10800017 	ldw	r2,0(r2)
81104ef8:	01400144 	movi	r5,5
81104efc:	1009883a 	mov	r4,r2
81104f00:	110517c0 	call	8110517c <uliFeebReadReg>
81104f04:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAG_REG_OFFSET);

		if (uliReg & COMM_IRQ_BUFFER_EMPTY_FLAG_MSK) {
81104f08:	e0bffe17 	ldw	r2,-8(fp)
81104f0c:	1080004c 	andi	r2,r2,1
81104f10:	10000426 	beq	r2,zero,81104f24 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81104f14:	e0bfff17 	ldw	r2,-4(fp)
81104f18:	00c00044 	movi	r3,1
81104f1c:	10c00415 	stw	r3,16(r2)
81104f20:	00000206 	br	81104f2c <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81104f24:	e0bfff17 	ldw	r2,-4(fp)
81104f28:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
81104f2c:	00800044 	movi	r2,1
81104f30:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104f34:	e0bffd17 	ldw	r2,-12(fp)
}
81104f38:	e037883a 	mov	sp,fp
81104f3c:	dfc00117 	ldw	ra,4(sp)
81104f40:	df000017 	ldw	fp,0(sp)
81104f44:	dec00204 	addi	sp,sp,8
81104f48:	f800283a 	ret

81104f4c <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81104f4c:	defffb04 	addi	sp,sp,-20
81104f50:	de00012e 	bgeu	sp,et,81104f58 <bFeebSetWindowing+0xc>
81104f54:	003b68fa 	trap	3
81104f58:	dfc00415 	stw	ra,16(sp)
81104f5c:	df000315 	stw	fp,12(sp)
81104f60:	df000304 	addi	fp,sp,12
81104f64:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104f68:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104f6c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104f70:	e0bfff17 	ldw	r2,-4(fp)
81104f74:	10001926 	beq	r2,zero,81104fdc <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104f78:	e0bfff17 	ldw	r2,-4(fp)
81104f7c:	10800017 	ldw	r2,0(r2)
81104f80:	000b883a 	mov	r5,zero
81104f84:	1009883a 	mov	r4,r2
81104f88:	110517c0 	call	8110517c <uliFeebReadReg>
81104f8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81104f90:	e0bfff17 	ldw	r2,-4(fp)
81104f94:	10800117 	ldw	r2,4(r2)
81104f98:	10000426 	beq	r2,zero,81104fac <bFeebSetWindowing+0x60>
			uliReg |= COMM_CTRL_MASKING_EN_MSK;
81104f9c:	e0bffe17 	ldw	r2,-8(fp)
81104fa0:	10804014 	ori	r2,r2,256
81104fa4:	e0bffe15 	stw	r2,-8(fp)
81104fa8:	00000406 	br	81104fbc <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_CTRL_MASKING_EN_MSK);
81104fac:	e0fffe17 	ldw	r3,-8(fp)
81104fb0:	00bfbfc4 	movi	r2,-257
81104fb4:	1884703a 	and	r2,r3,r2
81104fb8:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_WINDOW_CTRL_REG_OFFSET,
81104fbc:	e0bfff17 	ldw	r2,-4(fp)
81104fc0:	10800017 	ldw	r2,0(r2)
81104fc4:	e1bffe17 	ldw	r6,-8(fp)
81104fc8:	000b883a 	mov	r5,zero
81104fcc:	1009883a 	mov	r4,r2
81104fd0:	11051280 	call	81105128 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81104fd4:	00800044 	movi	r2,1
81104fd8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104fdc:	e0bffd17 	ldw	r2,-12(fp)
}
81104fe0:	e037883a 	mov	sp,fp
81104fe4:	dfc00117 	ldw	ra,4(sp)
81104fe8:	df000017 	ldw	fp,0(sp)
81104fec:	dec00204 	addi	sp,sp,8
81104ff0:	f800283a 	ret

81104ff4 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81104ff4:	defffb04 	addi	sp,sp,-20
81104ff8:	de00012e 	bgeu	sp,et,81105000 <bFeebGetWindowing+0xc>
81104ffc:	003b68fa 	trap	3
81105000:	dfc00415 	stw	ra,16(sp)
81105004:	df000315 	stw	fp,12(sp)
81105008:	df000304 	addi	fp,sp,12
8110500c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105010:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105014:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105018:	e0bfff17 	ldw	r2,-4(fp)
8110501c:	10001126 	beq	r2,zero,81105064 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105020:	e0bfff17 	ldw	r2,-4(fp)
81105024:	10800017 	ldw	r2,0(r2)
81105028:	000b883a 	mov	r5,zero
8110502c:	1009883a 	mov	r4,r2
81105030:	110517c0 	call	8110517c <uliFeebReadReg>
81105034:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (uliReg & COMM_CTRL_MASKING_EN_MSK) {
81105038:	e0bffe17 	ldw	r2,-8(fp)
8110503c:	1080400c 	andi	r2,r2,256
81105040:	10000426 	beq	r2,zero,81105054 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81105044:	e0bfff17 	ldw	r2,-4(fp)
81105048:	00c00044 	movi	r3,1
8110504c:	10c00115 	stw	r3,4(r2)
81105050:	00000206 	br	8110505c <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81105054:	e0bfff17 	ldw	r2,-4(fp)
81105058:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
8110505c:	00800044 	movi	r2,1
81105060:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105064:	e0bffd17 	ldw	r2,-12(fp)
}
81105068:	e037883a 	mov	sp,fp
8110506c:	dfc00117 	ldw	ra,4(sp)
81105070:	df000017 	ldw	fp,0(sp)
81105074:	dec00204 	addi	sp,sp,8
81105078:	f800283a 	ret

8110507c <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
8110507c:	defffb04 	addi	sp,sp,-20
81105080:	de00012e 	bgeu	sp,et,81105088 <bFeebGetBuffersStatus+0xc>
81105084:	003b68fa 	trap	3
81105088:	dfc00415 	stw	ra,16(sp)
8110508c:	df000315 	stw	fp,12(sp)
81105090:	df000304 	addi	fp,sp,12
81105094:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105098:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110509c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811050a0:	e0bfff17 	ldw	r2,-4(fp)
811050a4:	10001a26 	beq	r2,zero,81105110 <bFeebGetBuffersStatus+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811050a8:	e0bfff17 	ldw	r2,-4(fp)
811050ac:	10800017 	ldw	r2,0(r2)
811050b0:	01400184 	movi	r5,6
811050b4:	1009883a 	mov	r4,r2
811050b8:	110517c0 	call	8110517c <uliFeebReadReg>
811050bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_BUFFER_REG_OFFSET);

		if (uliReg & COMM_BUFF_STAT_L_BUFF_EPY_MSK) {
811050c0:	e0bffe17 	ldw	r2,-8(fp)
811050c4:	1080400c 	andi	r2,r2,256
811050c8:	10000426 	beq	r2,zero,811050dc <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
811050cc:	e0bfff17 	ldw	r2,-4(fp)
811050d0:	00c00044 	movi	r3,1
811050d4:	10c00515 	stw	r3,20(r2)
811050d8:	00000206 	br	811050e4 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
811050dc:	e0bfff17 	ldw	r2,-4(fp)
811050e0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_BUFF_STAT_R_BUFF_EPY_MSK) {
811050e4:	e0bffe17 	ldw	r2,-8(fp)
811050e8:	1080004c 	andi	r2,r2,1
811050ec:	10000426 	beq	r2,zero,81105100 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
811050f0:	e0bfff17 	ldw	r2,-4(fp)
811050f4:	00c00044 	movi	r3,1
811050f8:	10c00615 	stw	r3,24(r2)
811050fc:	00000206 	br	81105108 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81105100:	e0bfff17 	ldw	r2,-4(fp)
81105104:	10000615 	stw	zero,24(r2)
		}

		bStatus = TRUE;
81105108:	00800044 	movi	r2,1
8110510c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105110:	e0bffd17 	ldw	r2,-12(fp)
}
81105114:	e037883a 	mov	sp,fp
81105118:	dfc00117 	ldw	ra,4(sp)
8110511c:	df000017 	ldw	fp,0(sp)
81105120:	dec00204 	addi	sp,sp,8
81105124:	f800283a 	ret

81105128 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81105128:	defffc04 	addi	sp,sp,-16
8110512c:	de00012e 	bgeu	sp,et,81105134 <vFeebWriteReg+0xc>
81105130:	003b68fa 	trap	3
81105134:	df000315 	stw	fp,12(sp)
81105138:	df000304 	addi	fp,sp,12
8110513c:	e13ffd15 	stw	r4,-12(fp)
81105140:	e17ffe15 	stw	r5,-8(fp)
81105144:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81105148:	e0bffe17 	ldw	r2,-8(fp)
8110514c:	1085883a 	add	r2,r2,r2
81105150:	1085883a 	add	r2,r2,r2
81105154:	1007883a 	mov	r3,r2
81105158:	e0bffd17 	ldw	r2,-12(fp)
8110515c:	10c5883a 	add	r2,r2,r3
81105160:	e0ffff17 	ldw	r3,-4(fp)
81105164:	10c00015 	stw	r3,0(r2)
}
81105168:	0001883a 	nop
8110516c:	e037883a 	mov	sp,fp
81105170:	df000017 	ldw	fp,0(sp)
81105174:	dec00104 	addi	sp,sp,4
81105178:	f800283a 	ret

8110517c <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110517c:	defffc04 	addi	sp,sp,-16
81105180:	de00012e 	bgeu	sp,et,81105188 <uliFeebReadReg+0xc>
81105184:	003b68fa 	trap	3
81105188:	df000315 	stw	fp,12(sp)
8110518c:	df000304 	addi	fp,sp,12
81105190:	e13ffe15 	stw	r4,-8(fp)
81105194:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105198:	e0bfff17 	ldw	r2,-4(fp)
8110519c:	1085883a 	add	r2,r2,r2
811051a0:	1085883a 	add	r2,r2,r2
811051a4:	1007883a 	mov	r3,r2
811051a8:	e0bffe17 	ldw	r2,-8(fp)
811051ac:	10c5883a 	add	r2,r2,r3
811051b0:	10800017 	ldw	r2,0(r2)
811051b4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
811051b8:	e0bffd17 	ldw	r2,-12(fp)
}
811051bc:	e037883a 	mov	sp,fp
811051c0:	df000017 	ldw	fp,0(sp)
811051c4:	dec00104 	addi	sp,sp,4
811051c8:	f800283a 	ret

811051cc <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
811051cc:	defffb04 	addi	sp,sp,-20
811051d0:	de00012e 	bgeu	sp,et,811051d8 <bSpwcSetLink+0xc>
811051d4:	003b68fa 	trap	3
811051d8:	dfc00415 	stw	ra,16(sp)
811051dc:	df000315 	stw	fp,12(sp)
811051e0:	df000304 	addi	fp,sp,12
811051e4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811051e8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811051ec:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811051f0:	e0bfff17 	ldw	r2,-4(fp)
811051f4:	10002f26 	beq	r2,zero,811052b4 <bSpwcSetLink+0xe8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811051f8:	e0bfff17 	ldw	r2,-4(fp)
811051fc:	10800017 	ldw	r2,0(r2)
81105200:	000b883a 	mov	r5,zero
81105204:	1009883a 	mov	r4,r2
81105208:	11057280 	call	81105728 <uliSpwcReadReg>
8110520c:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
81105210:	e0bfff17 	ldw	r2,-4(fp)
81105214:	10800117 	ldw	r2,4(r2)
81105218:	10000426 	beq	r2,zero,8110522c <bSpwcSetLink+0x60>
			uliReg |= COMM_CTRL_LINK_AUTOSTART_MSK;
8110521c:	e0bffe17 	ldw	r2,-8(fp)
81105220:	10800114 	ori	r2,r2,4
81105224:	e0bffe15 	stw	r2,-8(fp)
81105228:	00000406 	br	8110523c <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_CTRL_LINK_AUTOSTART_MSK);
8110522c:	e0fffe17 	ldw	r3,-8(fp)
81105230:	00bffec4 	movi	r2,-5
81105234:	1884703a 	and	r2,r3,r2
81105238:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bStart) {
8110523c:	e0bfff17 	ldw	r2,-4(fp)
81105240:	10800217 	ldw	r2,8(r2)
81105244:	10000426 	beq	r2,zero,81105258 <bSpwcSetLink+0x8c>
			uliReg |= COMM_CTRL_LINK_START_MSK;
81105248:	e0bffe17 	ldw	r2,-8(fp)
8110524c:	10800094 	ori	r2,r2,2
81105250:	e0bffe15 	stw	r2,-8(fp)
81105254:	00000406 	br	81105268 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_CTRL_LINK_START_MSK);
81105258:	e0fffe17 	ldw	r3,-8(fp)
8110525c:	00bfff44 	movi	r2,-3
81105260:	1884703a 	and	r2,r3,r2
81105264:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
81105268:	e0bfff17 	ldw	r2,-4(fp)
8110526c:	10800317 	ldw	r2,12(r2)
81105270:	10000426 	beq	r2,zero,81105284 <bSpwcSetLink+0xb8>
			uliReg |= COMM_CTRL_LINK_DISCONNECT_MSK;
81105274:	e0bffe17 	ldw	r2,-8(fp)
81105278:	10800054 	ori	r2,r2,1
8110527c:	e0bffe15 	stw	r2,-8(fp)
81105280:	00000406 	br	81105294 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_CTRL_LINK_DISCONNECT_MSK);
81105284:	e0fffe17 	ldw	r3,-8(fp)
81105288:	00bfff84 	movi	r2,-2
8110528c:	1884703a 	and	r2,r3,r2
81105290:	e0bffe15 	stw	r2,-8(fp)
		}

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_WINDOW_CTRL_REG_OFFSET,
81105294:	e0bfff17 	ldw	r2,-4(fp)
81105298:	10800017 	ldw	r2,0(r2)
8110529c:	e1bffe17 	ldw	r6,-8(fp)
811052a0:	000b883a 	mov	r5,zero
811052a4:	1009883a 	mov	r4,r2
811052a8:	11056d40 	call	811056d4 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
811052ac:	00800044 	movi	r2,1
811052b0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811052b4:	e0bffd17 	ldw	r2,-12(fp)
}
811052b8:	e037883a 	mov	sp,fp
811052bc:	dfc00117 	ldw	ra,4(sp)
811052c0:	df000017 	ldw	fp,0(sp)
811052c4:	dec00204 	addi	sp,sp,8
811052c8:	f800283a 	ret

811052cc <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
811052cc:	defffb04 	addi	sp,sp,-20
811052d0:	de00012e 	bgeu	sp,et,811052d8 <bSpwcGetLink+0xc>
811052d4:	003b68fa 	trap	3
811052d8:	dfc00415 	stw	ra,16(sp)
811052dc:	df000315 	stw	fp,12(sp)
811052e0:	df000304 	addi	fp,sp,12
811052e4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811052e8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811052ec:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811052f0:	e0bfff17 	ldw	r2,-4(fp)
811052f4:	10002326 	beq	r2,zero,81105384 <bSpwcGetLink+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811052f8:	e0bfff17 	ldw	r2,-4(fp)
811052fc:	10800017 	ldw	r2,0(r2)
81105300:	000b883a 	mov	r5,zero
81105304:	1009883a 	mov	r4,r2
81105308:	11057280 	call	81105728 <uliSpwcReadReg>
8110530c:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_CTRL_REG_OFFSET);

		if (uliReg & COMM_CTRL_LINK_AUTOSTART_MSK) {
81105310:	e0bffe17 	ldw	r2,-8(fp)
81105314:	1080010c 	andi	r2,r2,4
81105318:	10000426 	beq	r2,zero,8110532c <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110531c:	e0bfff17 	ldw	r2,-4(fp)
81105320:	00c00044 	movi	r3,1
81105324:	10c00115 	stw	r3,4(r2)
81105328:	00000206 	br	81105334 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110532c:	e0bfff17 	ldw	r2,-4(fp)
81105330:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_CTRL_LINK_START_MSK) {
81105334:	e0bffe17 	ldw	r2,-8(fp)
81105338:	1080008c 	andi	r2,r2,2
8110533c:	10000426 	beq	r2,zero,81105350 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bStart = TRUE;
81105340:	e0bfff17 	ldw	r2,-4(fp)
81105344:	00c00044 	movi	r3,1
81105348:	10c00215 	stw	r3,8(r2)
8110534c:	00000206 	br	81105358 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bStart = FALSE;
81105350:	e0bfff17 	ldw	r2,-4(fp)
81105354:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_CTRL_LINK_DISCONNECT_MSK) {
81105358:	e0bffe17 	ldw	r2,-8(fp)
8110535c:	1080004c 	andi	r2,r2,1
81105360:	10000426 	beq	r2,zero,81105374 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
81105364:	e0bfff17 	ldw	r2,-4(fp)
81105368:	00c00044 	movi	r3,1
8110536c:	10c00315 	stw	r3,12(r2)
81105370:	00000206 	br	8110537c <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
81105374:	e0bfff17 	ldw	r2,-4(fp)
81105378:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
8110537c:	00800044 	movi	r2,1
81105380:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105384:	e0bffd17 	ldw	r2,-12(fp)
}
81105388:	e037883a 	mov	sp,fp
8110538c:	dfc00117 	ldw	ra,4(sp)
81105390:	df000017 	ldw	fp,0(sp)
81105394:	dec00204 	addi	sp,sp,8
81105398:	f800283a 	ret

8110539c <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110539c:	defffb04 	addi	sp,sp,-20
811053a0:	de00012e 	bgeu	sp,et,811053a8 <bSpwcGetLinkError+0xc>
811053a4:	003b68fa 	trap	3
811053a8:	dfc00415 	stw	ra,16(sp)
811053ac:	df000315 	stw	fp,12(sp)
811053b0:	df000304 	addi	fp,sp,12
811053b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811053b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811053bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811053c0:	e0bfff17 	ldw	r2,-4(fp)
811053c4:	10002c26 	beq	r2,zero,81105478 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811053c8:	e0bfff17 	ldw	r2,-4(fp)
811053cc:	10800017 	ldw	r2,0(r2)
811053d0:	01400044 	movi	r5,1
811053d4:	1009883a 	mov	r4,r2
811053d8:	11057280 	call	81105728 <uliSpwcReadReg>
811053dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_STAT_REG_OFFSET);

		if (uliReg & COMM_STAT_LINK_DISC_ERR_MSK) {
811053e0:	e0bffe17 	ldw	r2,-8(fp)
811053e4:	1082000c 	andi	r2,r2,2048
811053e8:	10000426 	beq	r2,zero,811053fc <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
811053ec:	e0bfff17 	ldw	r2,-4(fp)
811053f0:	00c00044 	movi	r3,1
811053f4:	10c00415 	stw	r3,16(r2)
811053f8:	00000206 	br	81105404 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
811053fc:	e0bfff17 	ldw	r2,-4(fp)
81105400:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_STAT_LINK_PAR_ERR_MSK) {
81105404:	e0bffe17 	ldw	r2,-8(fp)
81105408:	1081000c 	andi	r2,r2,1024
8110540c:	10000426 	beq	r2,zero,81105420 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
81105410:	e0bfff17 	ldw	r2,-4(fp)
81105414:	00c00044 	movi	r3,1
81105418:	10c00515 	stw	r3,20(r2)
8110541c:	00000206 	br	81105428 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
81105420:	e0bfff17 	ldw	r2,-4(fp)
81105424:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_STAT_LINK_ESC_ERR_MSK) {
81105428:	e0bffe17 	ldw	r2,-8(fp)
8110542c:	1080800c 	andi	r2,r2,512
81105430:	10000426 	beq	r2,zero,81105444 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
81105434:	e0bfff17 	ldw	r2,-4(fp)
81105438:	00c00044 	movi	r3,1
8110543c:	10c00615 	stw	r3,24(r2)
81105440:	00000206 	br	8110544c <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
81105444:	e0bfff17 	ldw	r2,-4(fp)
81105448:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_STAT_LINK_CRED_ERR_MSK) {
8110544c:	e0bffe17 	ldw	r2,-8(fp)
81105450:	1080400c 	andi	r2,r2,256
81105454:	10000426 	beq	r2,zero,81105468 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
81105458:	e0bfff17 	ldw	r2,-4(fp)
8110545c:	00c00044 	movi	r3,1
81105460:	10c00715 	stw	r3,28(r2)
81105464:	00000206 	br	81105470 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81105468:	e0bfff17 	ldw	r2,-4(fp)
8110546c:	10000715 	stw	zero,28(r2)
		}

		bStatus = TRUE;
81105470:	00800044 	movi	r2,1
81105474:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105478:	e0bffd17 	ldw	r2,-12(fp)
}
8110547c:	e037883a 	mov	sp,fp
81105480:	dfc00117 	ldw	ra,4(sp)
81105484:	df000017 	ldw	fp,0(sp)
81105488:	dec00204 	addi	sp,sp,8
8110548c:	f800283a 	ret

81105490 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
81105490:	defffb04 	addi	sp,sp,-20
81105494:	de00012e 	bgeu	sp,et,8110549c <bSpwcGetLinkStatus+0xc>
81105498:	003b68fa 	trap	3
8110549c:	dfc00415 	stw	ra,16(sp)
811054a0:	df000315 	stw	fp,12(sp)
811054a4:	df000304 	addi	fp,sp,12
811054a8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811054ac:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811054b0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811054b4:	e0bfff17 	ldw	r2,-4(fp)
811054b8:	10002326 	beq	r2,zero,81105548 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811054bc:	e0bfff17 	ldw	r2,-4(fp)
811054c0:	10800017 	ldw	r2,0(r2)
811054c4:	01400044 	movi	r5,1
811054c8:	1009883a 	mov	r4,r2
811054cc:	11057280 	call	81105728 <uliSpwcReadReg>
811054d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_WINDOW_STAT_REG_OFFSET);

		if (uliReg & COMM_STAT_LINK_STARTED_MSK) {
811054d4:	e0bffe17 	ldw	r2,-8(fp)
811054d8:	1080010c 	andi	r2,r2,4
811054dc:	10000426 	beq	r2,zero,811054f0 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
811054e0:	e0bfff17 	ldw	r2,-4(fp)
811054e4:	00c00044 	movi	r3,1
811054e8:	10c00815 	stw	r3,32(r2)
811054ec:	00000206 	br	811054f8 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
811054f0:	e0bfff17 	ldw	r2,-4(fp)
811054f4:	10000815 	stw	zero,32(r2)
		}
		if (uliReg & COMM_STAT_LINK_CONNECTING_MSK) {
811054f8:	e0bffe17 	ldw	r2,-8(fp)
811054fc:	1080008c 	andi	r2,r2,2
81105500:	10000426 	beq	r2,zero,81105514 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
81105504:	e0bfff17 	ldw	r2,-4(fp)
81105508:	00c00044 	movi	r3,1
8110550c:	10c00915 	stw	r3,36(r2)
81105510:	00000206 	br	8110551c <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
81105514:	e0bfff17 	ldw	r2,-4(fp)
81105518:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_STAT_LINK_RUNNING_MSK) {
8110551c:	e0bffe17 	ldw	r2,-8(fp)
81105520:	1080004c 	andi	r2,r2,1
81105524:	10000426 	beq	r2,zero,81105538 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
81105528:	e0bfff17 	ldw	r2,-4(fp)
8110552c:	00c00044 	movi	r3,1
81105530:	10c00a15 	stw	r3,40(r2)
81105534:	00000206 	br	81105540 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
81105538:	e0bfff17 	ldw	r2,-4(fp)
8110553c:	10000a15 	stw	zero,40(r2)
		}

		bStatus = TRUE;
81105540:	00800044 	movi	r2,1
81105544:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105548:	e0bffd17 	ldw	r2,-12(fp)
}
8110554c:	e037883a 	mov	sp,fp
81105550:	dfc00117 	ldw	ra,4(sp)
81105554:	df000017 	ldw	fp,0(sp)
81105558:	dec00204 	addi	sp,sp,8
8110555c:	f800283a 	ret

81105560 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
81105560:	defffb04 	addi	sp,sp,-20
81105564:	de00012e 	bgeu	sp,et,8110556c <bSpwcInitCh+0xc>
81105568:	003b68fa 	trap	3
8110556c:	dfc00415 	stw	ra,16(sp)
81105570:	df000315 	stw	fp,12(sp)
81105574:	df000304 	addi	fp,sp,12
81105578:	e13ffe15 	stw	r4,-8(fp)
8110557c:	2805883a 	mov	r2,r5
81105580:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105584:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
81105588:	e0bffe17 	ldw	r2,-8(fp)
8110558c:	10004b26 	beq	r2,zero,811056bc <bSpwcInitCh+0x15c>
		bStatus = TRUE;
81105590:	00800044 	movi	r2,1
81105594:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81105598:	e0bfff03 	ldbu	r2,-4(fp)
8110559c:	10c00228 	cmpgeui	r3,r2,8
811055a0:	1800361e 	bne	r3,zero,8110567c <bSpwcInitCh+0x11c>
811055a4:	100690ba 	slli	r3,r2,2
811055a8:	00a04434 	movhi	r2,33040
811055ac:	10956f04 	addi	r2,r2,21948
811055b0:	1885883a 	add	r2,r3,r2
811055b4:	10800017 	ldw	r2,0(r2)
811055b8:	1000683a 	jmp	r2
811055bc:	811055dc 	xori	r4,r16,16727
811055c0:	811055f0 	cmpltui	r4,r16,16727
811055c4:	81105604 	addi	r4,r16,16728
811055c8:	81105618 	cmpnei	r4,r16,16728
811055cc:	8110562c 	andhi	r4,r16,16728
811055d0:	81105640 	call	88110564 <__reset+0x20f0564>
811055d4:	81105654 	ori	r4,r16,16729
811055d8:	81105668 	cmpgeui	r4,r16,16729
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811055dc:	e0fffe17 	ldw	r3,-8(fp)
811055e0:	00a04834 	movhi	r2,33056
811055e4:	108b0004 	addi	r2,r2,11264
811055e8:	18800015 	stw	r2,0(r3)
			break;
811055ec:	00002506 	br	81105684 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811055f0:	e0fffe17 	ldw	r3,-8(fp)
811055f4:	00a04834 	movhi	r2,33056
811055f8:	108a0004 	addi	r2,r2,10240
811055fc:	18800015 	stw	r2,0(r3)
			break;
81105600:	00002006 	br	81105684 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81105604:	e0fffe17 	ldw	r3,-8(fp)
81105608:	00a04834 	movhi	r2,33056
8110560c:	10890004 	addi	r2,r2,9216
81105610:	18800015 	stw	r2,0(r3)
			break;
81105614:	00001b06 	br	81105684 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81105618:	e0fffe17 	ldw	r3,-8(fp)
8110561c:	00a04834 	movhi	r2,33056
81105620:	10880004 	addi	r2,r2,8192
81105624:	18800015 	stw	r2,0(r3)
			break;
81105628:	00001606 	br	81105684 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110562c:	e0fffe17 	ldw	r3,-8(fp)
81105630:	00a04834 	movhi	r2,33056
81105634:	10870004 	addi	r2,r2,7168
81105638:	18800015 	stw	r2,0(r3)
			break;
8110563c:	00001106 	br	81105684 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81105640:	e0fffe17 	ldw	r3,-8(fp)
81105644:	00a04834 	movhi	r2,33056
81105648:	10860004 	addi	r2,r2,6144
8110564c:	18800015 	stw	r2,0(r3)
			break;
81105650:	00000c06 	br	81105684 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81105654:	e0fffe17 	ldw	r3,-8(fp)
81105658:	00a04834 	movhi	r2,33056
8110565c:	10850004 	addi	r2,r2,5120
81105660:	18800015 	stw	r2,0(r3)
			break;
81105664:	00000706 	br	81105684 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81105668:	e0fffe17 	ldw	r3,-8(fp)
8110566c:	00a04834 	movhi	r2,33056
81105670:	10840004 	addi	r2,r2,4096
81105674:	18800015 	stw	r2,0(r3)
			break;
81105678:	00000206 	br	81105684 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
8110567c:	e03ffd15 	stw	zero,-12(fp)
			break;
81105680:	0001883a 	nop
		}

		if (bStatus) {
81105684:	e0bffd17 	ldw	r2,-12(fp)
81105688:	10000c26 	beq	r2,zero,811056bc <bSpwcInitCh+0x15c>
//			if (!bFeebGetWindowing(pxSpwcCh)) {
//				bStatus = FALSE;
//			}
			if (!bSpwcGetLink(pxSpwcCh)) {
8110568c:	e13ffe17 	ldw	r4,-8(fp)
81105690:	11052cc0 	call	811052cc <bSpwcGetLink>
81105694:	1000011e 	bne	r2,zero,8110569c <bSpwcInitCh+0x13c>
				bStatus = FALSE;
81105698:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110569c:	e13ffe17 	ldw	r4,-8(fp)
811056a0:	110539c0 	call	8110539c <bSpwcGetLinkError>
811056a4:	1000011e 	bne	r2,zero,811056ac <bSpwcInitCh+0x14c>
				bStatus = FALSE;
811056a8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
811056ac:	e13ffe17 	ldw	r4,-8(fp)
811056b0:	11054900 	call	81105490 <bSpwcGetLinkStatus>
811056b4:	1000011e 	bne	r2,zero,811056bc <bSpwcInitCh+0x15c>
				bStatus = FALSE;
811056b8:	e03ffd15 	stw	zero,-12(fp)
//			if (!bFeebGetBuffersStatus(pxSpwcCh)) {
//				bStatus = FALSE;
//			}
		}
	}
	return bStatus;
811056bc:	e0bffd17 	ldw	r2,-12(fp)
}
811056c0:	e037883a 	mov	sp,fp
811056c4:	dfc00117 	ldw	ra,4(sp)
811056c8:	df000017 	ldw	fp,0(sp)
811056cc:	dec00204 	addi	sp,sp,8
811056d0:	f800283a 	ret

811056d4 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811056d4:	defffc04 	addi	sp,sp,-16
811056d8:	de00012e 	bgeu	sp,et,811056e0 <vSpwcWriteReg+0xc>
811056dc:	003b68fa 	trap	3
811056e0:	df000315 	stw	fp,12(sp)
811056e4:	df000304 	addi	fp,sp,12
811056e8:	e13ffd15 	stw	r4,-12(fp)
811056ec:	e17ffe15 	stw	r5,-8(fp)
811056f0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811056f4:	e0bffe17 	ldw	r2,-8(fp)
811056f8:	1085883a 	add	r2,r2,r2
811056fc:	1085883a 	add	r2,r2,r2
81105700:	1007883a 	mov	r3,r2
81105704:	e0bffd17 	ldw	r2,-12(fp)
81105708:	10c5883a 	add	r2,r2,r3
8110570c:	e0ffff17 	ldw	r3,-4(fp)
81105710:	10c00015 	stw	r3,0(r2)
}
81105714:	0001883a 	nop
81105718:	e037883a 	mov	sp,fp
8110571c:	df000017 	ldw	fp,0(sp)
81105720:	dec00104 	addi	sp,sp,4
81105724:	f800283a 	ret

81105728 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105728:	defffc04 	addi	sp,sp,-16
8110572c:	de00012e 	bgeu	sp,et,81105734 <uliSpwcReadReg+0xc>
81105730:	003b68fa 	trap	3
81105734:	df000315 	stw	fp,12(sp)
81105738:	df000304 	addi	fp,sp,12
8110573c:	e13ffe15 	stw	r4,-8(fp)
81105740:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105744:	e0bfff17 	ldw	r2,-4(fp)
81105748:	1085883a 	add	r2,r2,r2
8110574c:	1085883a 	add	r2,r2,r2
81105750:	1007883a 	mov	r3,r2
81105754:	e0bffe17 	ldw	r2,-8(fp)
81105758:	10c5883a 	add	r2,r2,r3
8110575c:	10800017 	ldw	r2,0(r2)
81105760:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105764:	e0bffd17 	ldw	r2,-12(fp)
}
81105768:	e037883a 	mov	sp,fp
8110576c:	df000017 	ldw	fp,0(sp)
81105770:	dec00104 	addi	sp,sp,4
81105774:	f800283a 	ret

81105778 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
81105778:	defffe04 	addi	sp,sp,-8
8110577c:	de00012e 	bgeu	sp,et,81105784 <bEnableIsoDrivers+0xc>
81105780:	003b68fa 	trap	3
81105784:	dfc00115 	stw	ra,4(sp)
81105788:	df000015 	stw	fp,0(sp)
8110578c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
81105790:	01400204 	movi	r5,8
81105794:	01000044 	movi	r4,1
81105798:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
  return  TRUE;
8110579c:	00800044 	movi	r2,1
}
811057a0:	e037883a 	mov	sp,fp
811057a4:	dfc00117 	ldw	ra,4(sp)
811057a8:	df000017 	ldw	fp,0(sp)
811057ac:	dec00204 	addi	sp,sp,8
811057b0:	f800283a 	ret

811057b4 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
811057b4:	defffe04 	addi	sp,sp,-8
811057b8:	de00012e 	bgeu	sp,et,811057c0 <bDisableIsoDrivers+0xc>
811057bc:	003b68fa 	trap	3
811057c0:	dfc00115 	stw	ra,4(sp)
811057c4:	df000015 	stw	fp,0(sp)
811057c8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
811057cc:	01400204 	movi	r5,8
811057d0:	0009883a 	mov	r4,zero
811057d4:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
  return  TRUE;
811057d8:	00800044 	movi	r2,1
}
811057dc:	e037883a 	mov	sp,fp
811057e0:	dfc00117 	ldw	ra,4(sp)
811057e4:	df000017 	ldw	fp,0(sp)
811057e8:	dec00204 	addi	sp,sp,8
811057ec:	f800283a 	ret

811057f0 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
811057f0:	defffe04 	addi	sp,sp,-8
811057f4:	de00012e 	bgeu	sp,et,811057fc <bEnableLvdsBoard+0xc>
811057f8:	003b68fa 	trap	3
811057fc:	dfc00115 	stw	ra,4(sp)
81105800:	df000015 	stw	fp,0(sp)
81105804:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
81105808:	01400104 	movi	r5,4
8110580c:	01000044 	movi	r4,1
81105810:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
  return  TRUE;
81105814:	00800044 	movi	r2,1
}
81105818:	e037883a 	mov	sp,fp
8110581c:	dfc00117 	ldw	ra,4(sp)
81105820:	df000017 	ldw	fp,0(sp)
81105824:	dec00204 	addi	sp,sp,8
81105828:	f800283a 	ret

8110582c <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110582c:	defffe04 	addi	sp,sp,-8
81105830:	de00012e 	bgeu	sp,et,81105838 <bDisableLvdsBoard+0xc>
81105834:	003b68fa 	trap	3
81105838:	dfc00115 	stw	ra,4(sp)
8110583c:	df000015 	stw	fp,0(sp)
81105840:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
81105844:	01400104 	movi	r5,4
81105848:	0009883a 	mov	r4,zero
8110584c:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
  return  TRUE;
81105850:	00800044 	movi	r2,1
}
81105854:	e037883a 	mov	sp,fp
81105858:	dfc00117 	ldw	ra,4(sp)
8110585c:	df000017 	ldw	fp,0(sp)
81105860:	dec00204 	addi	sp,sp,8
81105864:	f800283a 	ret

81105868 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
81105868:	defffd04 	addi	sp,sp,-12
8110586c:	de00012e 	bgeu	sp,et,81105874 <bSetPreEmphasys+0xc>
81105870:	003b68fa 	trap	3
81105874:	dfc00215 	stw	ra,8(sp)
81105878:	df000115 	stw	fp,4(sp)
8110587c:	df000104 	addi	fp,sp,4
81105880:	2005883a 	mov	r2,r4
81105884:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
81105888:	e0bfff03 	ldbu	r2,-4(fp)
8110588c:	10c00060 	cmpeqi	r3,r2,1
81105890:	18000d1e 	bne	r3,zero,811058c8 <bSetPreEmphasys+0x60>
81105894:	10c00088 	cmpgei	r3,r2,2
81105898:	1800021e 	bne	r3,zero,811058a4 <bSetPreEmphasys+0x3c>
8110589c:	10000626 	beq	r2,zero,811058b8 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
811058a0:	00001b06 	br	81105910 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
811058a4:	10c000a0 	cmpeqi	r3,r2,2
811058a8:	18000e1e 	bne	r3,zero,811058e4 <bSetPreEmphasys+0x7c>
811058ac:	108000e0 	cmpeqi	r2,r2,3
811058b0:	1000131e 	bne	r2,zero,81105900 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
811058b4:	00001606 	br	81105910 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
811058b8:	014000c4 	movi	r5,3
811058bc:	0009883a 	mov	r4,zero
811058c0:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
      break;
811058c4:	00001206 	br	81105910 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
811058c8:	01400084 	movi	r5,2
811058cc:	0009883a 	mov	r4,zero
811058d0:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
811058d4:	01400044 	movi	r5,1
811058d8:	01000044 	movi	r4,1
811058dc:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
      break;
811058e0:	00000b06 	br	81105910 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
811058e4:	01400044 	movi	r5,1
811058e8:	0009883a 	mov	r4,zero
811058ec:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
811058f0:	01400084 	movi	r5,2
811058f4:	01000044 	movi	r4,1
811058f8:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
      break;
811058fc:	00000406 	br	81105910 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
81105900:	014000c4 	movi	r5,3
81105904:	01000044 	movi	r4,1
81105908:	11059280 	call	81105928 <bCtrlIoLvdsDrive>
      break;
8110590c:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
81105910:	00800044 	movi	r2,1
}
81105914:	e037883a 	mov	sp,fp
81105918:	dfc00117 	ldw	ra,4(sp)
8110591c:	df000017 	ldw	fp,0(sp)
81105920:	dec00204 	addi	sp,sp,8
81105924:	f800283a 	ret

81105928 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
81105928:	defffd04 	addi	sp,sp,-12
8110592c:	de00012e 	bgeu	sp,et,81105934 <bCtrlIoLvdsDrive+0xc>
81105930:	003b68fa 	trap	3
81105934:	df000215 	stw	fp,8(sp)
81105938:	df000204 	addi	fp,sp,8
8110593c:	e13ffe15 	stw	r4,-8(fp)
81105940:	2805883a 	mov	r2,r5
81105944:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
81105948:	e0bffe17 	ldw	r2,-8(fp)
8110594c:	1000071e 	bne	r2,zero,8110596c <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
81105950:	e0bfff03 	ldbu	r2,-4(fp)
81105954:	0084303a 	nor	r2,zero,r2
81105958:	1007883a 	mov	r3,r2
8110595c:	d0a00103 	ldbu	r2,-32764(gp)
81105960:	1884703a 	and	r2,r3,r2
81105964:	d0a00105 	stb	r2,-32764(gp)
81105968:	00000406 	br	8110597c <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110596c:	d0e00103 	ldbu	r3,-32764(gp)
81105970:	e0bfff03 	ldbu	r2,-4(fp)
81105974:	1884b03a 	or	r2,r3,r2
81105978:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110597c:	d0a00103 	ldbu	r2,-32764(gp)
81105980:	10c03fcc 	andi	r3,r2,255
81105984:	00a00034 	movhi	r2,32768
81105988:	10822804 	addi	r2,r2,2208
8110598c:	10c00035 	stwio	r3,0(r2)
  return TRUE;
81105990:	00800044 	movi	r2,1
}
81105994:	e037883a 	mov	sp,fp
81105998:	df000017 	ldw	fp,0(sp)
8110599c:	dec00104 	addi	sp,sp,4
811059a0:	f800283a 	ret

811059a4 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
811059a4:	defffa04 	addi	sp,sp,-24
811059a8:	de00012e 	bgeu	sp,et,811059b0 <I2C_TestAdress+0xc>
811059ac:	003b68fa 	trap	3
811059b0:	dfc00515 	stw	ra,20(sp)
811059b4:	df000415 	stw	fp,16(sp)
811059b8:	df000404 	addi	fp,sp,16
811059bc:	e13ffd15 	stw	r4,-12(fp)
811059c0:	e17ffe15 	stw	r5,-8(fp)
811059c4:	3005883a 	mov	r2,r6
811059c8:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
811059cc:	00800044 	movi	r2,1
811059d0:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
811059d4:	e17ffe17 	ldw	r5,-8(fp)
811059d8:	e13ffd17 	ldw	r4,-12(fp)
811059dc:	1105d740 	call	81105d74 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
811059e0:	e0bfff03 	ldbu	r2,-4(fp)
811059e4:	10803fcc 	andi	r2,r2,255
811059e8:	100d883a 	mov	r6,r2
811059ec:	e17ffe17 	ldw	r5,-8(fp)
811059f0:	e13ffd17 	ldw	r4,-12(fp)
811059f4:	1105e880 	call	81105e88 <i2c_write>
811059f8:	1000011e 	bne	r2,zero,81105a00 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
811059fc:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81105a00:	e17ffe17 	ldw	r5,-8(fp)
81105a04:	e13ffd17 	ldw	r4,-12(fp)
81105a08:	1105e080 	call	81105e08 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81105a0c:	0106d604 	movi	r4,7000
81105a10:	112def40 	call	8112def4 <usleep>
    
    return bSuccess;
81105a14:	e0bffc17 	ldw	r2,-16(fp)

}
81105a18:	e037883a 	mov	sp,fp
81105a1c:	dfc00117 	ldw	ra,4(sp)
81105a20:	df000017 	ldw	fp,0(sp)
81105a24:	dec00204 	addi	sp,sp,8
81105a28:	f800283a 	ret

81105a2c <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
81105a2c:	defff804 	addi	sp,sp,-32
81105a30:	de00012e 	bgeu	sp,et,81105a38 <I2C_Write+0xc>
81105a34:	003b68fa 	trap	3
81105a38:	dfc00715 	stw	ra,28(sp)
81105a3c:	df000615 	stw	fp,24(sp)
81105a40:	df000604 	addi	fp,sp,24
81105a44:	e13ffb15 	stw	r4,-20(fp)
81105a48:	e17ffc15 	stw	r5,-16(fp)
81105a4c:	3009883a 	mov	r4,r6
81105a50:	3807883a 	mov	r3,r7
81105a54:	e0800217 	ldw	r2,8(fp)
81105a58:	e13ffd05 	stb	r4,-12(fp)
81105a5c:	e0fffe05 	stb	r3,-8(fp)
81105a60:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81105a64:	00800044 	movi	r2,1
81105a68:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105a6c:	e17ffc17 	ldw	r5,-16(fp)
81105a70:	e13ffb17 	ldw	r4,-20(fp)
81105a74:	1105d740 	call	81105d74 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105a78:	e0bffd03 	ldbu	r2,-12(fp)
81105a7c:	10803fcc 	andi	r2,r2,255
81105a80:	100d883a 	mov	r6,r2
81105a84:	e17ffc17 	ldw	r5,-16(fp)
81105a88:	e13ffb17 	ldw	r4,-20(fp)
81105a8c:	1105e880 	call	81105e88 <i2c_write>
81105a90:	1000011e 	bne	r2,zero,81105a98 <I2C_Write+0x6c>
        bSuccess = FALSE;
81105a94:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81105a98:	e0bffa17 	ldw	r2,-24(fp)
81105a9c:	10000726 	beq	r2,zero,81105abc <I2C_Write+0x90>
81105aa0:	e0bffe03 	ldbu	r2,-8(fp)
81105aa4:	100d883a 	mov	r6,r2
81105aa8:	e17ffc17 	ldw	r5,-16(fp)
81105aac:	e13ffb17 	ldw	r4,-20(fp)
81105ab0:	1105e880 	call	81105e88 <i2c_write>
81105ab4:	1000011e 	bne	r2,zero,81105abc <I2C_Write+0x90>
        bSuccess = FALSE;
81105ab8:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
81105abc:	e0bffa17 	ldw	r2,-24(fp)
81105ac0:	10000726 	beq	r2,zero,81105ae0 <I2C_Write+0xb4>
81105ac4:	e0bfff03 	ldbu	r2,-4(fp)
81105ac8:	100d883a 	mov	r6,r2
81105acc:	e17ffc17 	ldw	r5,-16(fp)
81105ad0:	e13ffb17 	ldw	r4,-20(fp)
81105ad4:	1105e880 	call	81105e88 <i2c_write>
81105ad8:	1000011e 	bne	r2,zero,81105ae0 <I2C_Write+0xb4>
        bSuccess = FALSE;
81105adc:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81105ae0:	e17ffc17 	ldw	r5,-16(fp)
81105ae4:	e13ffb17 	ldw	r4,-20(fp)
81105ae8:	1105e080 	call	81105e08 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81105aec:	0106d604 	movi	r4,7000
81105af0:	112def40 	call	8112def4 <usleep>
    
    return bSuccess;
81105af4:	e0bffa17 	ldw	r2,-24(fp)

}
81105af8:	e037883a 	mov	sp,fp
81105afc:	dfc00117 	ldw	ra,4(sp)
81105b00:	df000017 	ldw	fp,0(sp)
81105b04:	dec00204 	addi	sp,sp,8
81105b08:	f800283a 	ret

81105b0c <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
81105b0c:	defff904 	addi	sp,sp,-28
81105b10:	de00012e 	bgeu	sp,et,81105b18 <I2C_Read+0xc>
81105b14:	003b68fa 	trap	3
81105b18:	dfc00615 	stw	ra,24(sp)
81105b1c:	df000515 	stw	fp,20(sp)
81105b20:	df000504 	addi	fp,sp,20
81105b24:	e13ffc15 	stw	r4,-16(fp)
81105b28:	e17ffd15 	stw	r5,-12(fp)
81105b2c:	3007883a 	mov	r3,r6
81105b30:	3805883a 	mov	r2,r7
81105b34:	e0fffe05 	stb	r3,-8(fp)
81105b38:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81105b3c:	00800044 	movi	r2,1
81105b40:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105b44:	e17ffd17 	ldw	r5,-12(fp)
81105b48:	e13ffc17 	ldw	r4,-16(fp)
81105b4c:	1105d740 	call	81105d74 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105b50:	e0bffe03 	ldbu	r2,-8(fp)
81105b54:	10803fcc 	andi	r2,r2,255
81105b58:	100d883a 	mov	r6,r2
81105b5c:	e17ffd17 	ldw	r5,-12(fp)
81105b60:	e13ffc17 	ldw	r4,-16(fp)
81105b64:	1105e880 	call	81105e88 <i2c_write>
81105b68:	1000011e 	bne	r2,zero,81105b70 <I2C_Read+0x64>
        bSuccess = FALSE;
81105b6c:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81105b70:	e0bffb17 	ldw	r2,-20(fp)
81105b74:	10000726 	beq	r2,zero,81105b94 <I2C_Read+0x88>
81105b78:	e0bfff03 	ldbu	r2,-4(fp)
81105b7c:	100d883a 	mov	r6,r2
81105b80:	e17ffd17 	ldw	r5,-12(fp)
81105b84:	e13ffc17 	ldw	r4,-16(fp)
81105b88:	1105e880 	call	81105e88 <i2c_write>
81105b8c:	1000011e 	bne	r2,zero,81105b94 <I2C_Read+0x88>
        bSuccess = FALSE;
81105b90:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
81105b94:	e17ffd17 	ldw	r5,-12(fp)
81105b98:	e13ffc17 	ldw	r4,-16(fp)
81105b9c:	1105d740 	call	81105d74 <i2c_start>
    DeviceAddr |= 1; // Read
81105ba0:	e0bffe03 	ldbu	r2,-8(fp)
81105ba4:	10800054 	ori	r2,r2,1
81105ba8:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81105bac:	e0bffb17 	ldw	r2,-20(fp)
81105bb0:	10000826 	beq	r2,zero,81105bd4 <I2C_Read+0xc8>
81105bb4:	e0bffe03 	ldbu	r2,-8(fp)
81105bb8:	10803fcc 	andi	r2,r2,255
81105bbc:	100d883a 	mov	r6,r2
81105bc0:	e17ffd17 	ldw	r5,-12(fp)
81105bc4:	e13ffc17 	ldw	r4,-16(fp)
81105bc8:	1105e880 	call	81105e88 <i2c_write>
81105bcc:	1000011e 	bne	r2,zero,81105bd4 <I2C_Read+0xc8>
        bSuccess = FALSE;
81105bd0:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81105bd4:	e0bffb17 	ldw	r2,-20(fp)
81105bd8:	10000526 	beq	r2,zero,81105bf0 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
81105bdc:	000f883a 	mov	r7,zero
81105be0:	e1800217 	ldw	r6,8(fp)
81105be4:	e17ffd17 	ldw	r5,-12(fp)
81105be8:	e13ffc17 	ldw	r4,-16(fp)
81105bec:	1105fc00 	call	81105fc0 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
81105bf0:	e17ffd17 	ldw	r5,-12(fp)
81105bf4:	e13ffc17 	ldw	r4,-16(fp)
81105bf8:	1105e080 	call	81105e08 <i2c_stop>
    
    return bSuccess;
81105bfc:	e0bffb17 	ldw	r2,-20(fp)
}
81105c00:	e037883a 	mov	sp,fp
81105c04:	dfc00117 	ldw	ra,4(sp)
81105c08:	df000017 	ldw	fp,0(sp)
81105c0c:	dec00204 	addi	sp,sp,8
81105c10:	f800283a 	ret

81105c14 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
81105c14:	defff604 	addi	sp,sp,-40
81105c18:	de00012e 	bgeu	sp,et,81105c20 <I2C_MultipleRead+0xc>
81105c1c:	003b68fa 	trap	3
81105c20:	dfc00915 	stw	ra,36(sp)
81105c24:	df000815 	stw	fp,32(sp)
81105c28:	df000804 	addi	fp,sp,32
81105c2c:	e13ffb15 	stw	r4,-20(fp)
81105c30:	e17ffc15 	stw	r5,-16(fp)
81105c34:	3007883a 	mov	r3,r6
81105c38:	e1fffe15 	stw	r7,-8(fp)
81105c3c:	e0800217 	ldw	r2,8(fp)
81105c40:	e0fffd05 	stb	r3,-12(fp)
81105c44:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
81105c48:	00800044 	movi	r2,1
81105c4c:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
81105c50:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81105c54:	e17ffc17 	ldw	r5,-16(fp)
81105c58:	e13ffb17 	ldw	r4,-20(fp)
81105c5c:	1105d740 	call	81105d74 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81105c60:	e0bffd03 	ldbu	r2,-12(fp)
81105c64:	10803fcc 	andi	r2,r2,255
81105c68:	100d883a 	mov	r6,r2
81105c6c:	e17ffc17 	ldw	r5,-16(fp)
81105c70:	e13ffb17 	ldw	r4,-20(fp)
81105c74:	1105e880 	call	81105e88 <i2c_write>
81105c78:	1000011e 	bne	r2,zero,81105c80 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
81105c7c:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81105c80:	e0bff917 	ldw	r2,-28(fp)
81105c84:	10000726 	beq	r2,zero,81105ca4 <I2C_MultipleRead+0x90>
81105c88:	e0bffa03 	ldbu	r2,-24(fp)
81105c8c:	100d883a 	mov	r6,r2
81105c90:	e17ffc17 	ldw	r5,-16(fp)
81105c94:	e13ffb17 	ldw	r4,-20(fp)
81105c98:	1105e880 	call	81105e88 <i2c_write>
81105c9c:	1000011e 	bne	r2,zero,81105ca4 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
81105ca0:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
81105ca4:	e0bff917 	ldw	r2,-28(fp)
81105ca8:	10000326 	beq	r2,zero,81105cb8 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
81105cac:	e17ffc17 	ldw	r5,-16(fp)
81105cb0:	e13ffb17 	ldw	r4,-20(fp)
81105cb4:	1105d740 	call	81105d74 <i2c_start>
    DeviceAddr |= 1; // Read
81105cb8:	e0bffd03 	ldbu	r2,-12(fp)
81105cbc:	10800054 	ori	r2,r2,1
81105cc0:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81105cc4:	e0bff917 	ldw	r2,-28(fp)
81105cc8:	10000826 	beq	r2,zero,81105cec <I2C_MultipleRead+0xd8>
81105ccc:	e0bffd03 	ldbu	r2,-12(fp)
81105cd0:	10803fcc 	andi	r2,r2,255
81105cd4:	100d883a 	mov	r6,r2
81105cd8:	e17ffc17 	ldw	r5,-16(fp)
81105cdc:	e13ffb17 	ldw	r4,-20(fp)
81105ce0:	1105e880 	call	81105e88 <i2c_write>
81105ce4:	1000011e 	bne	r2,zero,81105cec <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
81105ce8:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81105cec:	e0bff917 	ldw	r2,-28(fp)
81105cf0:	10001726 	beq	r2,zero,81105d50 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
81105cf4:	e03ff815 	stw	zero,-32(fp)
81105cf8:	00001006 	br	81105d3c <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
81105cfc:	e0bff817 	ldw	r2,-32(fp)
81105d00:	e0fffe17 	ldw	r3,-8(fp)
81105d04:	1889883a 	add	r4,r3,r2
81105d08:	e0bfff0b 	ldhu	r2,-4(fp)
81105d0c:	10ffffc4 	addi	r3,r2,-1
81105d10:	e0bff817 	ldw	r2,-32(fp)
81105d14:	1884c03a 	cmpne	r2,r3,r2
81105d18:	10803fcc 	andi	r2,r2,255
81105d1c:	100f883a 	mov	r7,r2
81105d20:	200d883a 	mov	r6,r4
81105d24:	e17ffc17 	ldw	r5,-16(fp)
81105d28:	e13ffb17 	ldw	r4,-20(fp)
81105d2c:	1105fc00 	call	81105fc0 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
81105d30:	e0bff817 	ldw	r2,-32(fp)
81105d34:	10800044 	addi	r2,r2,1
81105d38:	e0bff815 	stw	r2,-32(fp)
81105d3c:	e0bfff0b 	ldhu	r2,-4(fp)
81105d40:	e0fff817 	ldw	r3,-32(fp)
81105d44:	1880020e 	bge	r3,r2,81105d50 <I2C_MultipleRead+0x13c>
81105d48:	e0bff917 	ldw	r2,-28(fp)
81105d4c:	103feb1e 	bne	r2,zero,81105cfc <__reset+0xfb0e5cfc>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
81105d50:	e17ffc17 	ldw	r5,-16(fp)
81105d54:	e13ffb17 	ldw	r4,-20(fp)
81105d58:	1105e080 	call	81105e08 <i2c_stop>
    
    return bSuccess;    
81105d5c:	e0bff917 	ldw	r2,-28(fp)
    
}
81105d60:	e037883a 	mov	sp,fp
81105d64:	dfc00117 	ldw	ra,4(sp)
81105d68:	df000017 	ldw	fp,0(sp)
81105d6c:	dec00204 	addi	sp,sp,8
81105d70:	f800283a 	ret

81105d74 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
81105d74:	defffc04 	addi	sp,sp,-16
81105d78:	de00012e 	bgeu	sp,et,81105d80 <i2c_start+0xc>
81105d7c:	003b68fa 	trap	3
81105d80:	dfc00315 	stw	ra,12(sp)
81105d84:	df000215 	stw	fp,8(sp)
81105d88:	df000204 	addi	fp,sp,8
81105d8c:	e13ffe15 	stw	r4,-8(fp)
81105d90:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
81105d94:	e0bfff17 	ldw	r2,-4(fp)
81105d98:	10800104 	addi	r2,r2,4
81105d9c:	1007883a 	mov	r3,r2
81105da0:	00800044 	movi	r2,1
81105da4:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
81105da8:	e0bfff17 	ldw	r2,-4(fp)
81105dac:	00c00044 	movi	r3,1
81105db0:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
81105db4:	e0bffe17 	ldw	r2,-8(fp)
81105db8:	00c00044 	movi	r3,1
81105dbc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81105dc0:	01000044 	movi	r4,1
81105dc4:	112def40 	call	8112def4 <usleep>
     
    SDA_LOW(data_base); // data low
81105dc8:	e0bfff17 	ldw	r2,-4(fp)
81105dcc:	0007883a 	mov	r3,zero
81105dd0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
81105dd4:	01000044 	movi	r4,1
81105dd8:	112def40 	call	8112def4 <usleep>
    SCL_LOW(clk_base); // clock low
81105ddc:	e0bffe17 	ldw	r2,-8(fp)
81105de0:	0007883a 	mov	r3,zero
81105de4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81105de8:	01000044 	movi	r4,1
81105dec:	112def40 	call	8112def4 <usleep>
}
81105df0:	0001883a 	nop
81105df4:	e037883a 	mov	sp,fp
81105df8:	dfc00117 	ldw	ra,4(sp)
81105dfc:	df000017 	ldw	fp,0(sp)
81105e00:	dec00204 	addi	sp,sp,8
81105e04:	f800283a 	ret

81105e08 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
81105e08:	defffc04 	addi	sp,sp,-16
81105e0c:	de00012e 	bgeu	sp,et,81105e14 <i2c_stop+0xc>
81105e10:	003b68fa 	trap	3
81105e14:	dfc00315 	stw	ra,12(sp)
81105e18:	df000215 	stw	fp,8(sp)
81105e1c:	df000204 	addi	fp,sp,8
81105e20:	e13ffe15 	stw	r4,-8(fp)
81105e24:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
81105e28:	e0bfff17 	ldw	r2,-4(fp)
81105e2c:	10800104 	addi	r2,r2,4
81105e30:	1007883a 	mov	r3,r2
81105e34:	00800044 	movi	r2,1
81105e38:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
81105e3c:	e0bfff17 	ldw	r2,-4(fp)
81105e40:	0007883a 	mov	r3,zero
81105e44:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
81105e48:	e0bffe17 	ldw	r2,-8(fp)
81105e4c:	00c00044 	movi	r3,1
81105e50:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
81105e54:	01000044 	movi	r4,1
81105e58:	112def40 	call	8112def4 <usleep>
    SDA_HIGH(data_base); // data high
81105e5c:	e0bfff17 	ldw	r2,-4(fp)
81105e60:	00c00044 	movi	r3,1
81105e64:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
81105e68:	01000044 	movi	r4,1
81105e6c:	112def40 	call	8112def4 <usleep>
    

    
}
81105e70:	0001883a 	nop
81105e74:	e037883a 	mov	sp,fp
81105e78:	dfc00117 	ldw	ra,4(sp)
81105e7c:	df000017 	ldw	fp,0(sp)
81105e80:	dec00204 	addi	sp,sp,8
81105e84:	f800283a 	ret

81105e88 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
81105e88:	defff804 	addi	sp,sp,-32
81105e8c:	de00012e 	bgeu	sp,et,81105e94 <i2c_write+0xc>
81105e90:	003b68fa 	trap	3
81105e94:	dfc00715 	stw	ra,28(sp)
81105e98:	df000615 	stw	fp,24(sp)
81105e9c:	df000604 	addi	fp,sp,24
81105ea0:	e13ffd15 	stw	r4,-12(fp)
81105ea4:	e17ffe15 	stw	r5,-8(fp)
81105ea8:	3005883a 	mov	r2,r6
81105eac:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
81105eb0:	00bfe004 	movi	r2,-128
81105eb4:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
81105eb8:	e0bffe17 	ldw	r2,-8(fp)
81105ebc:	10800104 	addi	r2,r2,4
81105ec0:	1007883a 	mov	r3,r2
81105ec4:	00800044 	movi	r2,1
81105ec8:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
81105ecc:	e03ffb15 	stw	zero,-20(fp)
81105ed0:	00001f06 	br	81105f50 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
81105ed4:	e0bffd17 	ldw	r2,-12(fp)
81105ed8:	0007883a 	mov	r3,zero
81105edc:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
81105ee0:	e0ffff03 	ldbu	r3,-4(fp)
81105ee4:	e0bffa03 	ldbu	r2,-24(fp)
81105ee8:	1884703a 	and	r2,r3,r2
81105eec:	10803fcc 	andi	r2,r2,255
81105ef0:	10000426 	beq	r2,zero,81105f04 <i2c_write+0x7c>
            SDA_HIGH(data_base);
81105ef4:	e0bffe17 	ldw	r2,-8(fp)
81105ef8:	00c00044 	movi	r3,1
81105efc:	10c00035 	stwio	r3,0(r2)
81105f00:	00000306 	br	81105f10 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
81105f04:	e0bffe17 	ldw	r2,-8(fp)
81105f08:	0007883a 	mov	r3,zero
81105f0c:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
81105f10:	e0bffa03 	ldbu	r2,-24(fp)
81105f14:	1004d07a 	srli	r2,r2,1
81105f18:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
81105f1c:	e0bffd17 	ldw	r2,-12(fp)
81105f20:	00c00044 	movi	r3,1
81105f24:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81105f28:	01000044 	movi	r4,1
81105f2c:	112def40 	call	8112def4 <usleep>
        SCL_LOW(clk_base);
81105f30:	e0bffd17 	ldw	r2,-12(fp)
81105f34:	0007883a 	mov	r3,zero
81105f38:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81105f3c:	01000044 	movi	r4,1
81105f40:	112def40 	call	8112def4 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
81105f44:	e0bffb17 	ldw	r2,-20(fp)
81105f48:	10800044 	addi	r2,r2,1
81105f4c:	e0bffb15 	stw	r2,-20(fp)
81105f50:	e0bffb17 	ldw	r2,-20(fp)
81105f54:	10800210 	cmplti	r2,r2,8
81105f58:	103fde1e 	bne	r2,zero,81105ed4 <__reset+0xfb0e5ed4>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
81105f5c:	e0bffe17 	ldw	r2,-8(fp)
81105f60:	10800104 	addi	r2,r2,4
81105f64:	0007883a 	mov	r3,zero
81105f68:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
81105f6c:	e0bffd17 	ldw	r2,-12(fp)
81105f70:	00c00044 	movi	r3,1
81105f74:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
81105f78:	01000044 	movi	r4,1
81105f7c:	112def40 	call	8112def4 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
81105f80:	e0bffe17 	ldw	r2,-8(fp)
81105f84:	10800037 	ldwio	r2,0(r2)
81105f88:	1005003a 	cmpeq	r2,r2,zero
81105f8c:	10803fcc 	andi	r2,r2,255
81105f90:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
81105f94:	e0bffd17 	ldw	r2,-12(fp)
81105f98:	0007883a 	mov	r3,zero
81105f9c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81105fa0:	01000044 	movi	r4,1
81105fa4:	112def40 	call	8112def4 <usleep>
    return bAck;
81105fa8:	e0bffc17 	ldw	r2,-16(fp)
}    
81105fac:	e037883a 	mov	sp,fp
81105fb0:	dfc00117 	ldw	ra,4(sp)
81105fb4:	df000017 	ldw	fp,0(sp)
81105fb8:	dec00204 	addi	sp,sp,8
81105fbc:	f800283a 	ret

81105fc0 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
81105fc0:	defff804 	addi	sp,sp,-32
81105fc4:	de00012e 	bgeu	sp,et,81105fcc <i2c_read+0xc>
81105fc8:	003b68fa 	trap	3
81105fcc:	dfc00715 	stw	ra,28(sp)
81105fd0:	df000615 	stw	fp,24(sp)
81105fd4:	df000604 	addi	fp,sp,24
81105fd8:	e13ffc15 	stw	r4,-16(fp)
81105fdc:	e17ffd15 	stw	r5,-12(fp)
81105fe0:	e1bffe15 	stw	r6,-8(fp)
81105fe4:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
81105fe8:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
81105fec:	e0bffd17 	ldw	r2,-12(fp)
81105ff0:	10800104 	addi	r2,r2,4
81105ff4:	0007883a 	mov	r3,zero
81105ff8:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
81105ffc:	e0bffc17 	ldw	r2,-16(fp)
81106000:	0007883a 	mov	r3,zero
81106004:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81106008:	01000044 	movi	r4,1
8110600c:	112def40 	call	8112def4 <usleep>

    for(i=0;i<8;i++){
81106010:	e03ffb15 	stw	zero,-20(fp)
81106014:	00001606 	br	81106070 <i2c_read+0xb0>
        Data <<= 1;
81106018:	e0bffa03 	ldbu	r2,-24(fp)
8110601c:	1085883a 	add	r2,r2,r2
81106020:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
81106024:	e0bffc17 	ldw	r2,-16(fp)
81106028:	00c00044 	movi	r3,1
8110602c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81106030:	01000044 	movi	r4,1
81106034:	112def40 	call	8112def4 <usleep>
        if (SDA_READ(data_base))  // read data   
81106038:	e0bffd17 	ldw	r2,-12(fp)
8110603c:	10800037 	ldwio	r2,0(r2)
81106040:	10000326 	beq	r2,zero,81106050 <i2c_read+0x90>
            Data |= 0x01;
81106044:	e0bffa03 	ldbu	r2,-24(fp)
81106048:	10800054 	ori	r2,r2,1
8110604c:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
81106050:	e0bffc17 	ldw	r2,-16(fp)
81106054:	0007883a 	mov	r3,zero
81106058:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110605c:	01000044 	movi	r4,1
81106060:	112def40 	call	8112def4 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
81106064:	e0bffb17 	ldw	r2,-20(fp)
81106068:	10800044 	addi	r2,r2,1
8110606c:	e0bffb15 	stw	r2,-20(fp)
81106070:	e0bffb17 	ldw	r2,-20(fp)
81106074:	10800210 	cmplti	r2,r2,8
81106078:	103fe71e 	bne	r2,zero,81106018 <__reset+0xfb0e6018>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110607c:	e0bffc17 	ldw	r2,-16(fp)
81106080:	0007883a 	mov	r3,zero
81106084:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
81106088:	e0bffd17 	ldw	r2,-12(fp)
8110608c:	10800104 	addi	r2,r2,4
81106090:	1007883a 	mov	r3,r2
81106094:	00800044 	movi	r2,1
81106098:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110609c:	e0bfff17 	ldw	r2,-4(fp)
811060a0:	10000426 	beq	r2,zero,811060b4 <i2c_read+0xf4>
        SDA_LOW(data_base);
811060a4:	e0bffd17 	ldw	r2,-12(fp)
811060a8:	0007883a 	mov	r3,zero
811060ac:	10c00035 	stwio	r3,0(r2)
811060b0:	00000306 	br	811060c0 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
811060b4:	e0bffd17 	ldw	r2,-12(fp)
811060b8:	00c00044 	movi	r3,1
811060bc:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
811060c0:	e0bffc17 	ldw	r2,-16(fp)
811060c4:	00c00044 	movi	r3,1
811060c8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
811060cc:	01000044 	movi	r4,1
811060d0:	112def40 	call	8112def4 <usleep>
    SCL_LOW(clk_base); // clock low
811060d4:	e0bffc17 	ldw	r2,-16(fp)
811060d8:	0007883a 	mov	r3,zero
811060dc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
811060e0:	01000044 	movi	r4,1
811060e4:	112def40 	call	8112def4 <usleep>
    SDA_LOW(data_base);  // data low
811060e8:	e0bffd17 	ldw	r2,-12(fp)
811060ec:	0007883a 	mov	r3,zero
811060f0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
811060f4:	01000044 	movi	r4,1
811060f8:	112def40 	call	8112def4 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
811060fc:	e0bffe17 	ldw	r2,-8(fp)
81106100:	e0fffa03 	ldbu	r3,-24(fp)
81106104:	10c00005 	stb	r3,0(r2)
}
81106108:	0001883a 	nop
8110610c:	e037883a 	mov	sp,fp
81106110:	dfc00117 	ldw	ra,4(sp)
81106114:	df000017 	ldw	fp,0(sp)
81106118:	dec00204 	addi	sp,sp,8
8110611c:	f800283a 	ret

81106120 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
81106120:	defffd04 	addi	sp,sp,-12
81106124:	de00012e 	bgeu	sp,et,8110612c <bSetBoardLeds+0xc>
81106128:	003b68fa 	trap	3
8110612c:	df000215 	stw	fp,8(sp)
81106130:	df000204 	addi	fp,sp,8
81106134:	e13ffe15 	stw	r4,-8(fp)
81106138:	2805883a 	mov	r2,r5
8110613c:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
81106140:	e0bffe17 	ldw	r2,-8(fp)
81106144:	10800058 	cmpnei	r2,r2,1
81106148:	1000071e 	bne	r2,zero,81106168 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110614c:	e0bfff03 	ldbu	r2,-4(fp)
81106150:	0084303a 	nor	r2,zero,r2
81106154:	1007883a 	mov	r3,r2
81106158:	d0a04603 	ldbu	r2,-32488(gp)
8110615c:	1884703a 	and	r2,r3,r2
81106160:	d0a04605 	stb	r2,-32488(gp)
81106164:	00000406 	br	81106178 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
81106168:	d0e04603 	ldbu	r3,-32488(gp)
8110616c:	e0bfff03 	ldbu	r2,-4(fp)
81106170:	1884b03a 	or	r2,r3,r2
81106174:	d0a04605 	stb	r2,-32488(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
81106178:	d0a04603 	ldbu	r2,-32488(gp)
8110617c:	10c03fcc 	andi	r3,r2,255
81106180:	00a00034 	movhi	r2,32768
81106184:	10827404 	addi	r2,r2,2512
81106188:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110618c:	00800044 	movi	r2,1
}
81106190:	e037883a 	mov	sp,fp
81106194:	df000017 	ldw	fp,0(sp)
81106198:	dec00104 	addi	sp,sp,4
8110619c:	f800283a 	ret

811061a0 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
811061a0:	defffd04 	addi	sp,sp,-12
811061a4:	de00012e 	bgeu	sp,et,811061ac <bSetPainelLeds+0xc>
811061a8:	003b68fa 	trap	3
811061ac:	df000215 	stw	fp,8(sp)
811061b0:	df000204 	addi	fp,sp,8
811061b4:	e13ffe15 	stw	r4,-8(fp)
811061b8:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
811061bc:	e0bffe17 	ldw	r2,-8(fp)
811061c0:	10800058 	cmpnei	r2,r2,1
811061c4:	1000051e 	bne	r2,zero,811061dc <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
811061c8:	d0e00217 	ldw	r3,-32760(gp)
811061cc:	e0bfff17 	ldw	r2,-4(fp)
811061d0:	1884b03a 	or	r2,r3,r2
811061d4:	d0a00215 	stw	r2,-32760(gp)
811061d8:	00000506 	br	811061f0 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
811061dc:	e0bfff17 	ldw	r2,-4(fp)
811061e0:	0086303a 	nor	r3,zero,r2
811061e4:	d0a00217 	ldw	r2,-32760(gp)
811061e8:	1884703a 	and	r2,r3,r2
811061ec:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
811061f0:	d0a00217 	ldw	r2,-32760(gp)
811061f4:	1007883a 	mov	r3,r2
811061f8:	00a00034 	movhi	r2,32768
811061fc:	10824004 	addi	r2,r2,2304
81106200:	10c00035 	stwio	r3,0(r2)

  return TRUE;
81106204:	00800044 	movi	r2,1
}
81106208:	e037883a 	mov	sp,fp
8110620c:	df000017 	ldw	fp,0(sp)
81106210:	dec00104 	addi	sp,sp,4
81106214:	f800283a 	ret

81106218 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
81106218:	defffc04 	addi	sp,sp,-16
8110621c:	de00012e 	bgeu	sp,et,81106224 <msgdma_write_extended_descriptor+0xc>
81106220:	003b68fa 	trap	3
81106224:	df000315 	stw	fp,12(sp)
81106228:	df000304 	addi	fp,sp,12
8110622c:	e13ffd15 	stw	r4,-12(fp)
81106230:	e17ffe15 	stw	r5,-8(fp)
81106234:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
81106238:	e0bffd17 	ldw	r2,-12(fp)
8110623c:	10800037 	ldwio	r2,0(r2)
81106240:	1080010c 	andi	r2,r2,4
81106244:	10000226 	beq	r2,zero,81106250 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
81106248:	00bff904 	movi	r2,-28
8110624c:	00003d06 	br	81106344 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
81106250:	e0bfff17 	ldw	r2,-4(fp)
81106254:	10800017 	ldw	r2,0(r2)
81106258:	1007883a 	mov	r3,r2
8110625c:	e0bffe17 	ldw	r2,-8(fp)
81106260:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
81106264:	e0bffe17 	ldw	r2,-8(fp)
81106268:	10800104 	addi	r2,r2,4
8110626c:	e0ffff17 	ldw	r3,-4(fp)
81106270:	18c00117 	ldw	r3,4(r3)
81106274:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
81106278:	e0bffe17 	ldw	r2,-8(fp)
8110627c:	10800204 	addi	r2,r2,8
81106280:	e0ffff17 	ldw	r3,-4(fp)
81106284:	18c00217 	ldw	r3,8(r3)
81106288:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110628c:	e0bffe17 	ldw	r2,-8(fp)
81106290:	10800304 	addi	r2,r2,12
81106294:	e0ffff17 	ldw	r3,-4(fp)
81106298:	18c0030b 	ldhu	r3,12(r3)
8110629c:	18ffffcc 	andi	r3,r3,65535
811062a0:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
811062a4:	e0bffe17 	ldw	r2,-8(fp)
811062a8:	10800384 	addi	r2,r2,14
811062ac:	e0ffff17 	ldw	r3,-4(fp)
811062b0:	18c00383 	ldbu	r3,14(r3)
811062b4:	18c03fcc 	andi	r3,r3,255
811062b8:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
811062bc:	e0bffe17 	ldw	r2,-8(fp)
811062c0:	108003c4 	addi	r2,r2,15
811062c4:	e0ffff17 	ldw	r3,-4(fp)
811062c8:	18c003c3 	ldbu	r3,15(r3)
811062cc:	18c03fcc 	andi	r3,r3,255
811062d0:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
811062d4:	e0bffe17 	ldw	r2,-8(fp)
811062d8:	10800404 	addi	r2,r2,16
811062dc:	e0ffff17 	ldw	r3,-4(fp)
811062e0:	18c0040b 	ldhu	r3,16(r3)
811062e4:	18ffffcc 	andi	r3,r3,65535
811062e8:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
811062ec:	e0bffe17 	ldw	r2,-8(fp)
811062f0:	10800484 	addi	r2,r2,18
811062f4:	e0ffff17 	ldw	r3,-4(fp)
811062f8:	18c0048b 	ldhu	r3,18(r3)
811062fc:	18ffffcc 	andi	r3,r3,65535
81106300:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
81106304:	e0bffe17 	ldw	r2,-8(fp)
81106308:	10800504 	addi	r2,r2,20
8110630c:	e0ffff17 	ldw	r3,-4(fp)
81106310:	18c00517 	ldw	r3,20(r3)
81106314:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
81106318:	e0bffe17 	ldw	r2,-8(fp)
8110631c:	10800604 	addi	r2,r2,24
81106320:	e0ffff17 	ldw	r3,-4(fp)
81106324:	18c00617 	ldw	r3,24(r3)
81106328:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110632c:	e0bffe17 	ldw	r2,-8(fp)
81106330:	10800704 	addi	r2,r2,28
81106334:	e0ffff17 	ldw	r3,-4(fp)
81106338:	18c00717 	ldw	r3,28(r3)
8110633c:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
81106340:	0005883a 	mov	r2,zero
}
81106344:	e037883a 	mov	sp,fp
81106348:	df000017 	ldw	fp,0(sp)
8110634c:	dec00104 	addi	sp,sp,4
81106350:	f800283a 	ret

81106354 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
81106354:	defff604 	addi	sp,sp,-40
81106358:	de00012e 	bgeu	sp,et,81106360 <msgdma_construct_extended_descriptor+0xc>
8110635c:	003b68fa 	trap	3
81106360:	df000915 	stw	fp,36(sp)
81106364:	df000904 	addi	fp,sp,36
81106368:	e13ff715 	stw	r4,-36(fp)
8110636c:	e17ff815 	stw	r5,-32(fp)
81106370:	e1bff915 	stw	r6,-28(fp)
81106374:	e1fffa15 	stw	r7,-24(fp)
81106378:	e1800517 	ldw	r6,20(fp)
8110637c:	e1400617 	ldw	r5,24(fp)
81106380:	e1000717 	ldw	r4,28(fp)
81106384:	e0c00817 	ldw	r3,32(fp)
81106388:	e0800917 	ldw	r2,36(fp)
8110638c:	e1bffb0d 	sth	r6,-20(fp)
81106390:	e17ffc05 	stb	r5,-16(fp)
81106394:	e13ffd05 	stb	r4,-12(fp)
81106398:	e0fffe0d 	sth	r3,-8(fp)
8110639c:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
811063a0:	e0bff717 	ldw	r2,-36(fp)
811063a4:	10c01217 	ldw	r3,72(r2)
811063a8:	e0800117 	ldw	r2,4(fp)
811063ac:	18801936 	bltu	r3,r2,81106414 <msgdma_construct_extended_descriptor+0xc0>
811063b0:	e13ff717 	ldw	r4,-36(fp)
811063b4:	20801317 	ldw	r2,76(r4)
811063b8:	20c01417 	ldw	r3,80(r4)
811063bc:	e13ffe0b 	ldhu	r4,-8(fp)
811063c0:	213fffcc 	andi	r4,r4,65535
811063c4:	2015883a 	mov	r10,r4
811063c8:	0017883a 	mov	r11,zero
811063cc:	1ac01136 	bltu	r3,r11,81106414 <msgdma_construct_extended_descriptor+0xc0>
811063d0:	58c0011e 	bne	r11,r3,811063d8 <msgdma_construct_extended_descriptor+0x84>
811063d4:	12800f36 	bltu	r2,r10,81106414 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
811063d8:	e13ff717 	ldw	r4,-36(fp)
811063dc:	20801317 	ldw	r2,76(r4)
811063e0:	20c01417 	ldw	r3,80(r4)
811063e4:	e13fff0b 	ldhu	r4,-4(fp)
811063e8:	213fffcc 	andi	r4,r4,65535
811063ec:	2011883a 	mov	r8,r4
811063f0:	0013883a 	mov	r9,zero
811063f4:	1a400736 	bltu	r3,r9,81106414 <msgdma_construct_extended_descriptor+0xc0>
811063f8:	48c0011e 	bne	r9,r3,81106400 <msgdma_construct_extended_descriptor+0xac>
811063fc:	12000536 	bltu	r2,r8,81106414 <msgdma_construct_extended_descriptor+0xc0>
81106400:	e0bff717 	ldw	r2,-36(fp)
81106404:	10801703 	ldbu	r2,92(r2)
81106408:	10803fcc 	andi	r2,r2,255
8110640c:	10800060 	cmpeqi	r2,r2,1
81106410:	1000021e 	bne	r2,zero,8110641c <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
81106414:	00bffa84 	movi	r2,-22
81106418:	00002306 	br	811064a8 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110641c:	e0bff817 	ldw	r2,-32(fp)
81106420:	e0fff917 	ldw	r3,-28(fp)
81106424:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
81106428:	e0bff817 	ldw	r2,-32(fp)
8110642c:	e0fffa17 	ldw	r3,-24(fp)
81106430:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
81106434:	e0bff817 	ldw	r2,-32(fp)
81106438:	e0c00117 	ldw	r3,4(fp)
8110643c:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
81106440:	e0bff817 	ldw	r2,-32(fp)
81106444:	e0fffb0b 	ldhu	r3,-20(fp)
81106448:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110644c:	e0bff817 	ldw	r2,-32(fp)
81106450:	e0fffc03 	ldbu	r3,-16(fp)
81106454:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
81106458:	e0bff817 	ldw	r2,-32(fp)
8110645c:	e0fffd03 	ldbu	r3,-12(fp)
81106460:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
81106464:	e0bff817 	ldw	r2,-32(fp)
81106468:	e0fffe0b 	ldhu	r3,-8(fp)
8110646c:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
81106470:	e0bff817 	ldw	r2,-32(fp)
81106474:	e0ffff0b 	ldhu	r3,-4(fp)
81106478:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110647c:	e0bff817 	ldw	r2,-32(fp)
81106480:	e0c00317 	ldw	r3,12(fp)
81106484:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
81106488:	e0bff817 	ldw	r2,-32(fp)
8110648c:	e0c00417 	ldw	r3,16(fp)
81106490:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81106494:	e0800217 	ldw	r2,8(fp)
81106498:	10e00034 	orhi	r3,r2,32768
8110649c:	e0bff817 	ldw	r2,-32(fp)
811064a0:	10c00715 	stw	r3,28(r2)

	return 0;
811064a4:	0005883a 	mov	r2,zero

}
811064a8:	e037883a 	mov	sp,fp
811064ac:	df000017 	ldw	fp,0(sp)
811064b0:	dec00104 	addi	sp,sp,4
811064b4:	f800283a 	ret

811064b8 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
811064b8:	deffee04 	addi	sp,sp,-72
811064bc:	de00012e 	bgeu	sp,et,811064c4 <msgdma_descriptor_async_transfer+0xc>
811064c0:	003b68fa 	trap	3
811064c4:	dfc01115 	stw	ra,68(sp)
811064c8:	df001015 	stw	fp,64(sp)
811064cc:	df001004 	addi	fp,sp,64
811064d0:	e13ffd15 	stw	r4,-12(fp)
811064d4:	e17ffe15 	stw	r5,-8(fp)
811064d8:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
811064dc:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
811064e0:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
811064e4:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
811064e8:	e0bffd17 	ldw	r2,-12(fp)
811064ec:	10800317 	ldw	r2,12(r2)
811064f0:	10800204 	addi	r2,r2,8
811064f4:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
811064f8:	10bfffcc 	andi	r2,r2,65535
811064fc:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81106500:	e0bffd17 	ldw	r2,-12(fp)
81106504:	10800317 	ldw	r2,12(r2)
81106508:	10800204 	addi	r2,r2,8
8110650c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
81106510:	1004d43a 	srli	r2,r2,16
81106514:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
81106518:	e0bffd17 	ldw	r2,-12(fp)
8110651c:	10800917 	ldw	r2,36(r2)
81106520:	e0fff417 	ldw	r3,-48(fp)
81106524:	1880042e 	bgeu	r3,r2,81106538 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
81106528:	e0bffd17 	ldw	r2,-12(fp)
8110652c:	10800917 	ldw	r2,36(r2)
81106530:	e0fff317 	ldw	r3,-52(fp)
81106534:	18800236 	bltu	r3,r2,81106540 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
81106538:	00bff904 	movi	r2,-28
8110653c:	00009f06 	br	811067bc <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
81106540:	e0bffd17 	ldw	r2,-12(fp)
81106544:	10801817 	ldw	r2,96(r2)
81106548:	e0bff615 	stw	r2,-40(fp)
8110654c:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81106550:	e0bffc0b 	ldhu	r2,-16(fp)
81106554:	e0fffc84 	addi	r3,fp,-14
81106558:	180d883a 	mov	r6,r3
8110655c:	100b883a 	mov	r5,r2
81106560:	e13ff617 	ldw	r4,-40(fp)
81106564:	1134cf80 	call	81134cf8 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81106568:	00800804 	movi	r2,32
8110656c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106570:	0005303a 	rdctl	r2,status
81106574:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81106578:	e0fff717 	ldw	r3,-36(fp)
8110657c:	00bfff84 	movi	r2,-2
81106580:	1884703a 	and	r2,r3,r2
81106584:	1001703a 	wrctl	status,r2
  
  return context;
81106588:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110658c:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81106590:	e0bffd17 	ldw	r2,-12(fp)
81106594:	10800317 	ldw	r2,12(r2)
81106598:	10800104 	addi	r2,r2,4
8110659c:	e0fff117 	ldw	r3,-60(fp)
811065a0:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
811065a4:	e0bffd17 	ldw	r2,-12(fp)
811065a8:	10800317 	ldw	r2,12(r2)
811065ac:	e0fffd17 	ldw	r3,-12(fp)
811065b0:	18c00317 	ldw	r3,12(r3)
811065b4:	18c00037 	ldwio	r3,0(r3)
811065b8:	10c00035 	stwio	r3,0(r2)
811065bc:	e0bff217 	ldw	r2,-56(fp)
811065c0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811065c4:	e0bffb17 	ldw	r2,-20(fp)
811065c8:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
811065cc:	e0bffe17 	ldw	r2,-8(fp)
811065d0:	10001026 	beq	r2,zero,81106614 <msgdma_descriptor_async_transfer+0x15c>
811065d4:	e0bfff17 	ldw	r2,-4(fp)
811065d8:	10000e1e 	bne	r2,zero,81106614 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
811065dc:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
811065e0:	d0a05517 	ldw	r2,-32428(gp)
811065e4:	100f883a 	mov	r7,r2
811065e8:	01800784 	movi	r6,30
811065ec:	01400044 	movi	r5,1
811065f0:	01204534 	movhi	r4,33044
811065f4:	21092004 	addi	r4,r4,9344
811065f8:	11172b80 	call	811172b8 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
811065fc:	e0bffd17 	ldw	r2,-12(fp)
81106600:	10801817 	ldw	r2,96(r2)
81106604:	1009883a 	mov	r4,r2
81106608:	11350800 	call	81135080 <OSSemPost>

		return -ETIME;
8110660c:	00bff084 	movi	r2,-62
81106610:	00006a06 	br	811067bc <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
81106614:	e0bffe17 	ldw	r2,-8(fp)
81106618:	1000231e 	bne	r2,zero,811066a8 <msgdma_descriptor_async_transfer+0x1f0>
8110661c:	e0bfff17 	ldw	r2,-4(fp)
81106620:	10002126 	beq	r2,zero,811066a8 <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
81106624:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
81106628:	00001506 	br	81106680 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110662c:	01000044 	movi	r4,1
81106630:	112c4800 	call	8112c480 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81106634:	e0bff00b 	ldhu	r2,-64(fp)
81106638:	1084e230 	cmpltui	r2,r2,5000
8110663c:	10000d1e 	bne	r2,zero,81106674 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
81106640:	d0a05517 	ldw	r2,-32428(gp)
81106644:	100f883a 	mov	r7,r2
81106648:	01801544 	movi	r6,85
8110664c:	01400044 	movi	r5,1
81106650:	01204534 	movhi	r4,33044
81106654:	21092804 	addi	r4,r4,9376
81106658:	11172b80 	call	811172b8 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110665c:	e0bffd17 	ldw	r2,-12(fp)
81106660:	10801817 	ldw	r2,96(r2)
81106664:	1009883a 	mov	r4,r2
81106668:	11350800 	call	81135080 <OSSemPost>

				return -ETIME;
8110666c:	00bff084 	movi	r2,-62
81106670:	00005206 	br	811067bc <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
81106674:	e0bff00b 	ldhu	r2,-64(fp)
81106678:	10800044 	addi	r2,r2,1
8110667c:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
81106680:	e0bffd17 	ldw	r2,-12(fp)
81106684:	10c00317 	ldw	r3,12(r2)
81106688:	e0bffd17 	ldw	r2,-12(fp)
8110668c:	10800417 	ldw	r2,16(r2)
81106690:	e1bfff17 	ldw	r6,-4(fp)
81106694:	100b883a 	mov	r5,r2
81106698:	1809883a 	mov	r4,r3
8110669c:	11062180 	call	81106218 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
811066a0:	103fe21e 	bne	r2,zero,8110662c <__reset+0xfb0e662c>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
811066a4:	00000606 	br	811066c0 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
811066a8:	e0bffd17 	ldw	r2,-12(fp)
811066ac:	10801817 	ldw	r2,96(r2)
811066b0:	1009883a 	mov	r4,r2
811066b4:	11350800 	call	81135080 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
811066b8:	00bfffc4 	movi	r2,-1
811066bc:	00003f06 	br	811067bc <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
811066c0:	e0bffd17 	ldw	r2,-12(fp)
811066c4:	10800b17 	ldw	r2,44(r2)
811066c8:	10001c26 	beq	r2,zero,8110673c <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
811066cc:	e0bffd17 	ldw	r2,-12(fp)
811066d0:	10c00d17 	ldw	r3,52(r2)
811066d4:	e0bff117 	ldw	r2,-60(fp)
811066d8:	1884b03a 	or	r2,r3,r2
811066dc:	10800514 	ori	r2,r2,20
811066e0:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
811066e4:	e0fff117 	ldw	r3,-60(fp)
811066e8:	00bff7c4 	movi	r2,-33
811066ec:	1884703a 	and	r2,r3,r2
811066f0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811066f4:	0005303a 	rdctl	r2,status
811066f8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811066fc:	e0fff917 	ldw	r3,-28(fp)
81106700:	00bfff84 	movi	r2,-2
81106704:	1884703a 	and	r2,r3,r2
81106708:	1001703a 	wrctl	status,r2
  
  return context;
8110670c:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
81106710:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81106714:	e0bffd17 	ldw	r2,-12(fp)
81106718:	10800317 	ldw	r2,12(r2)
8110671c:	10800104 	addi	r2,r2,4
81106720:	e0fff117 	ldw	r3,-60(fp)
81106724:	10c00035 	stwio	r3,0(r2)
81106728:	e0bff217 	ldw	r2,-56(fp)
8110672c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106730:	e0bff517 	ldw	r2,-44(fp)
81106734:	1001703a 	wrctl	status,r2
81106738:	00001b06 	br	811067a8 <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110673c:	e0bffd17 	ldw	r2,-12(fp)
81106740:	10c00d17 	ldw	r3,52(r2)
81106744:	e0bff117 	ldw	r2,-60(fp)
81106748:	1884b03a 	or	r2,r3,r2
8110674c:	10800114 	ori	r2,r2,4
81106750:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
81106754:	e0fff117 	ldw	r3,-60(fp)
81106758:	00bff3c4 	movi	r2,-49
8110675c:	1884703a 	and	r2,r3,r2
81106760:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106764:	0005303a 	rdctl	r2,status
81106768:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110676c:	e0fffa17 	ldw	r3,-24(fp)
81106770:	00bfff84 	movi	r2,-2
81106774:	1884703a 	and	r2,r3,r2
81106778:	1001703a 	wrctl	status,r2
  
  return context;
8110677c:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
81106780:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81106784:	e0bffd17 	ldw	r2,-12(fp)
81106788:	10800317 	ldw	r2,12(r2)
8110678c:	10800104 	addi	r2,r2,4
81106790:	e0fff117 	ldw	r3,-60(fp)
81106794:	10c00035 	stwio	r3,0(r2)
81106798:	e0bff217 	ldw	r2,-56(fp)
8110679c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811067a0:	e0bff817 	ldw	r2,-32(fp)
811067a4:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
811067a8:	e0bffd17 	ldw	r2,-12(fp)
811067ac:	10801817 	ldw	r2,96(r2)
811067b0:	1009883a 	mov	r4,r2
811067b4:	11350800 	call	81135080 <OSSemPost>

	return 0;
811067b8:	0005883a 	mov	r2,zero
}
811067bc:	e037883a 	mov	sp,fp
811067c0:	dfc00117 	ldw	ra,4(sp)
811067c4:	df000017 	ldw	fp,0(sp)
811067c8:	dec00204 	addi	sp,sp,8
811067cc:	f800283a 	ret

811067d0 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
811067d0:	deffee04 	addi	sp,sp,-72
811067d4:	de00012e 	bgeu	sp,et,811067dc <msgdma_descriptor_sync_transfer+0xc>
811067d8:	003b68fa 	trap	3
811067dc:	dfc01115 	stw	ra,68(sp)
811067e0:	df001015 	stw	fp,64(sp)
811067e4:	df001004 	addi	fp,sp,64
811067e8:	e13ffd15 	stw	r4,-12(fp)
811067ec:	e17ffe15 	stw	r5,-8(fp)
811067f0:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
811067f4:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
811067f8:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
811067fc:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
81106800:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81106804:	e0bffd17 	ldw	r2,-12(fp)
81106808:	10800317 	ldw	r2,12(r2)
8110680c:	10800204 	addi	r2,r2,8
81106810:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
81106814:	10bfffcc 	andi	r2,r2,65535
81106818:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110681c:	e0bffd17 	ldw	r2,-12(fp)
81106820:	10800317 	ldw	r2,12(r2)
81106824:	10800204 	addi	r2,r2,8
81106828:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110682c:	1004d43a 	srli	r2,r2,16
81106830:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
81106834:	00807804 	movi	r2,480
81106838:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110683c:	00001d06 	br	811068b4 <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
81106840:	01000044 	movi	r4,1
81106844:	112c4800 	call	8112c480 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81106848:	e0bff10b 	ldhu	r2,-60(fp)
8110684c:	1084e230 	cmpltui	r2,r2,5000
81106850:	1000091e 	bne	r2,zero,81106878 <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
81106854:	d0a05517 	ldw	r2,-32428(gp)
81106858:	100f883a 	mov	r7,r2
8110685c:	01801304 	movi	r6,76
81106860:	01400044 	movi	r5,1
81106864:	01204534 	movhi	r4,33044
81106868:	21093e04 	addi	r4,r4,9464
8110686c:	11172b80 	call	811172b8 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
81106870:	00bff084 	movi	r2,-62
81106874:	0000d006 	br	81106bb8 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
81106878:	e0bff10b 	ldhu	r2,-60(fp)
8110687c:	10800044 	addi	r2,r2,1
81106880:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81106884:	e0bffd17 	ldw	r2,-12(fp)
81106888:	10800317 	ldw	r2,12(r2)
8110688c:	10800204 	addi	r2,r2,8
81106890:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
81106894:	10bfffcc 	andi	r2,r2,65535
81106898:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110689c:	e0bffd17 	ldw	r2,-12(fp)
811068a0:	10800317 	ldw	r2,12(r2)
811068a4:	10800204 	addi	r2,r2,8
811068a8:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
811068ac:	1004d43a 	srli	r2,r2,16
811068b0:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
811068b4:	e0bffd17 	ldw	r2,-12(fp)
811068b8:	10800917 	ldw	r2,36(r2)
811068bc:	e0fff317 	ldw	r3,-52(fp)
811068c0:	18bfdf2e 	bgeu	r3,r2,81106840 <__reset+0xfb0e6840>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
811068c4:	e0bffd17 	ldw	r2,-12(fp)
811068c8:	10800917 	ldw	r2,36(r2)
811068cc:	e0fff217 	ldw	r3,-56(fp)
811068d0:	18bfdb2e 	bgeu	r3,r2,81106840 <__reset+0xfb0e6840>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
811068d4:	e0bffd17 	ldw	r2,-12(fp)
811068d8:	10801817 	ldw	r2,96(r2)
811068dc:	e0bff815 	stw	r2,-32(fp)
811068e0:	e03ffc0d 	sth	zero,-16(fp)
811068e4:	e0bffc0b 	ldhu	r2,-16(fp)
811068e8:	e0fffc84 	addi	r3,fp,-14
811068ec:	180d883a 	mov	r6,r3
811068f0:	100b883a 	mov	r5,r2
811068f4:	e13ff817 	ldw	r4,-32(fp)
811068f8:	1134cf80 	call	81134cf8 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811068fc:	0005303a 	rdctl	r2,status
81106900:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81106904:	e0fffb17 	ldw	r3,-20(fp)
81106908:	00bfff84 	movi	r2,-2
8110690c:	1884703a 	and	r2,r3,r2
81106910:	1001703a 	wrctl	status,r2
  
  return context;
81106914:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81106918:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110691c:	e0bffd17 	ldw	r2,-12(fp)
81106920:	10800317 	ldw	r2,12(r2)
81106924:	10800104 	addi	r2,r2,4
81106928:	00c00804 	movi	r3,32
8110692c:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81106930:	e0bffd17 	ldw	r2,-12(fp)
81106934:	10800317 	ldw	r2,12(r2)
81106938:	e0fffd17 	ldw	r3,-12(fp)
8110693c:	18c00317 	ldw	r3,12(r3)
81106940:	18c00037 	ldwio	r3,0(r3)
81106944:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
81106948:	e0bffe17 	ldw	r2,-8(fp)
8110694c:	10001026 	beq	r2,zero,81106990 <msgdma_descriptor_sync_transfer+0x1c0>
81106950:	e0bfff17 	ldw	r2,-4(fp)
81106954:	10000e1e 	bne	r2,zero,81106990 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
81106958:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110695c:	d0a05517 	ldw	r2,-32428(gp)
81106960:	100f883a 	mov	r7,r2
81106964:	01800784 	movi	r6,30
81106968:	01400044 	movi	r5,1
8110696c:	01204534 	movhi	r4,33044
81106970:	21092004 	addi	r4,r4,9344
81106974:	11172b80 	call	811172b8 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81106978:	e0bffd17 	ldw	r2,-12(fp)
8110697c:	10801817 	ldw	r2,96(r2)
81106980:	1009883a 	mov	r4,r2
81106984:	11350800 	call	81135080 <OSSemPost>

		return -ETIME;
81106988:	00bff084 	movi	r2,-62
8110698c:	00008a06 	br	81106bb8 <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
81106990:	e0bffe17 	ldw	r2,-8(fp)
81106994:	1000231e 	bne	r2,zero,81106a24 <msgdma_descriptor_sync_transfer+0x254>
81106998:	e0bfff17 	ldw	r2,-4(fp)
8110699c:	10002126 	beq	r2,zero,81106a24 <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
811069a0:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
811069a4:	00001506 	br	811069fc <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
811069a8:	01000044 	movi	r4,1
811069ac:	112c4800 	call	8112c480 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
811069b0:	e0bff10b 	ldhu	r2,-60(fp)
811069b4:	1084e230 	cmpltui	r2,r2,5000
811069b8:	10000d1e 	bne	r2,zero,811069f0 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
811069bc:	d0a05517 	ldw	r2,-32428(gp)
811069c0:	100f883a 	mov	r7,r2
811069c4:	01801004 	movi	r6,64
811069c8:	01400044 	movi	r5,1
811069cc:	01204534 	movhi	r4,33044
811069d0:	21095204 	addi	r4,r4,9544
811069d4:	11172b80 	call	811172b8 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
811069d8:	e0bffd17 	ldw	r2,-12(fp)
811069dc:	10801817 	ldw	r2,96(r2)
811069e0:	1009883a 	mov	r4,r2
811069e4:	11350800 	call	81135080 <OSSemPost>

				return -ETIME;
811069e8:	00bff084 	movi	r2,-62
811069ec:	00007206 	br	81106bb8 <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
811069f0:	e0bff10b 	ldhu	r2,-60(fp)
811069f4:	10800044 	addi	r2,r2,1
811069f8:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
811069fc:	e0bffd17 	ldw	r2,-12(fp)
81106a00:	10c00317 	ldw	r3,12(r2)
81106a04:	e0bffd17 	ldw	r2,-12(fp)
81106a08:	10800417 	ldw	r2,16(r2)
81106a0c:	e1bfff17 	ldw	r6,-4(fp)
81106a10:	100b883a 	mov	r5,r2
81106a14:	1809883a 	mov	r4,r3
81106a18:	11062180 	call	81106218 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
81106a1c:	103fe21e 	bne	r2,zero,811069a8 <__reset+0xfb0e69a8>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
81106a20:	00000606 	br	81106a3c <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81106a24:	e0bffd17 	ldw	r2,-12(fp)
81106a28:	10801817 	ldw	r2,96(r2)
81106a2c:	1009883a 	mov	r4,r2
81106a30:	11350800 	call	81135080 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
81106a34:	00bfffc4 	movi	r2,-1
81106a38:	00005f06 	br	81106bb8 <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81106a3c:	e0bffd17 	ldw	r2,-12(fp)
81106a40:	10800317 	ldw	r2,12(r2)
81106a44:	10800104 	addi	r2,r2,4
81106a48:	e0fffd17 	ldw	r3,-12(fp)
81106a4c:	19000d17 	ldw	r4,52(r3)
81106a50:	00fff2c4 	movi	r3,-53
81106a54:	20c6703a 	and	r3,r4,r3
81106a58:	18c00114 	ori	r3,r3,4
81106a5c:	10c00035 	stwio	r3,0(r2)
81106a60:	e0bff517 	ldw	r2,-44(fp)
81106a64:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106a68:	e0bff717 	ldw	r2,-36(fp)
81106a6c:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
81106a70:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81106a74:	e0bffd17 	ldw	r2,-12(fp)
81106a78:	10800317 	ldw	r2,12(r2)
81106a7c:	10800037 	ldwio	r2,0(r2)
81106a80:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
81106a84:	00001906 	br	81106aec <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
81106a88:	01000044 	movi	r4,1
81106a8c:	112c4800 	call	8112c480 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81106a90:	e0bff10b 	ldhu	r2,-60(fp)
81106a94:	1084e230 	cmpltui	r2,r2,5000
81106a98:	10000d1e 	bne	r2,zero,81106ad0 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
81106a9c:	d0a05517 	ldw	r2,-32428(gp)
81106aa0:	100f883a 	mov	r7,r2
81106aa4:	01801184 	movi	r6,70
81106aa8:	01400044 	movi	r5,1
81106aac:	01204534 	movhi	r4,33044
81106ab0:	21096304 	addi	r4,r4,9612
81106ab4:	11172b80 	call	811172b8 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
81106ab8:	e0bffd17 	ldw	r2,-12(fp)
81106abc:	10801817 	ldw	r2,96(r2)
81106ac0:	1009883a 	mov	r4,r2
81106ac4:	11350800 	call	81135080 <OSSemPost>

			return -ETIME;
81106ac8:	00bff084 	movi	r2,-62
81106acc:	00003a06 	br	81106bb8 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
81106ad0:	e0bff10b 	ldhu	r2,-60(fp)
81106ad4:	10800044 	addi	r2,r2,1
81106ad8:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81106adc:	e0bffd17 	ldw	r2,-12(fp)
81106ae0:	10800317 	ldw	r2,12(r2)
81106ae4:	10800037 	ldwio	r2,0(r2)
81106ae8:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
81106aec:	e0fff017 	ldw	r3,-64(fp)
81106af0:	e0bff617 	ldw	r2,-40(fp)
81106af4:	1884703a 	and	r2,r3,r2
81106af8:	1000031e 	bne	r2,zero,81106b08 <msgdma_descriptor_sync_transfer+0x338>
81106afc:	e0bff017 	ldw	r2,-64(fp)
81106b00:	1080004c 	andi	r2,r2,1
81106b04:	103fe01e 	bne	r2,zero,81106a88 <__reset+0xfb0e6a88>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
81106b08:	e0fff017 	ldw	r3,-64(fp)
81106b0c:	e0bff617 	ldw	r2,-40(fp)
81106b10:	1884703a 	and	r2,r3,r2
81106b14:	10000626 	beq	r2,zero,81106b30 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81106b18:	e0bffd17 	ldw	r2,-12(fp)
81106b1c:	10801817 	ldw	r2,96(r2)
81106b20:	1009883a 	mov	r4,r2
81106b24:	11350800 	call	81135080 <OSSemPost>

		return error;
81106b28:	e0bff617 	ldw	r2,-40(fp)
81106b2c:	00002206 	br	81106bb8 <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
81106b30:	e0bffd17 	ldw	r2,-12(fp)
81106b34:	10800317 	ldw	r2,12(r2)
81106b38:	10800104 	addi	r2,r2,4
81106b3c:	10800037 	ldwio	r2,0(r2)
81106b40:	10800814 	ori	r2,r2,32
81106b44:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81106b48:	0005303a 	rdctl	r2,status
81106b4c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81106b50:	e0fffa17 	ldw	r3,-24(fp)
81106b54:	00bfff84 	movi	r2,-2
81106b58:	1884703a 	and	r2,r3,r2
81106b5c:	1001703a 	wrctl	status,r2
  
  return context;
81106b60:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81106b64:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81106b68:	e0bffd17 	ldw	r2,-12(fp)
81106b6c:	10800317 	ldw	r2,12(r2)
81106b70:	10800104 	addi	r2,r2,4
81106b74:	e0fff417 	ldw	r3,-48(fp)
81106b78:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81106b7c:	e0bffd17 	ldw	r2,-12(fp)
81106b80:	10800317 	ldw	r2,12(r2)
81106b84:	e0fffd17 	ldw	r3,-12(fp)
81106b88:	18c00317 	ldw	r3,12(r3)
81106b8c:	18c00037 	ldwio	r3,0(r3)
81106b90:	10c00035 	stwio	r3,0(r2)
81106b94:	e0bff517 	ldw	r2,-44(fp)
81106b98:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81106b9c:	e0bff917 	ldw	r2,-28(fp)
81106ba0:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
81106ba4:	e0bffd17 	ldw	r2,-12(fp)
81106ba8:	10801817 	ldw	r2,96(r2)
81106bac:	1009883a 	mov	r4,r2
81106bb0:	11350800 	call	81135080 <OSSemPost>

	return 0;
81106bb4:	0005883a 	mov	r2,zero

}
81106bb8:	e037883a 	mov	sp,fp
81106bbc:	dfc00117 	ldw	ra,4(sp)
81106bc0:	df000017 	ldw	fp,0(sp)
81106bc4:	dec00204 	addi	sp,sp,8
81106bc8:	f800283a 	ret

81106bcc <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
81106bcc:	deffec04 	addi	sp,sp,-80
81106bd0:	de00012e 	bgeu	sp,et,81106bd8 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
81106bd4:	003b68fa 	trap	3
81106bd8:	dfc01315 	stw	ra,76(sp)
81106bdc:	df001215 	stw	fp,72(sp)
81106be0:	df001204 	addi	fp,sp,72
81106be4:	e13ff715 	stw	r4,-36(fp)
81106be8:	e17ff815 	stw	r5,-32(fp)
81106bec:	e1bff915 	stw	r6,-28(fp)
81106bf0:	e1fffa15 	stw	r7,-24(fp)
81106bf4:	e1800617 	ldw	r6,24(fp)
81106bf8:	e1400717 	ldw	r5,28(fp)
81106bfc:	e1000817 	ldw	r4,32(fp)
81106c00:	e0c00917 	ldw	r3,36(fp)
81106c04:	e0800a17 	ldw	r2,40(fp)
81106c08:	e1bffb0d 	sth	r6,-20(fp)
81106c0c:	e17ffc05 	stb	r5,-16(fp)
81106c10:	e13ffd05 	stb	r4,-12(fp)
81106c14:	e0fffe0d 	sth	r3,-8(fp)
81106c18:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
81106c1c:	e0bffb0b 	ldhu	r2,-20(fp)
81106c20:	e0fffc03 	ldbu	r3,-16(fp)
81106c24:	e13ffd03 	ldbu	r4,-12(fp)
81106c28:	e17ffe0b 	ldhu	r5,-8(fp)
81106c2c:	e1bfff0b 	ldhu	r6,-4(fp)
81106c30:	d9800815 	stw	r6,32(sp)
81106c34:	d9400715 	stw	r5,28(sp)
81106c38:	d9000615 	stw	r4,24(sp)
81106c3c:	d8c00515 	stw	r3,20(sp)
81106c40:	d8800415 	stw	r2,16(sp)
81106c44:	e0800517 	ldw	r2,20(fp)
81106c48:	d8800315 	stw	r2,12(sp)
81106c4c:	e0800417 	ldw	r2,16(fp)
81106c50:	d8800215 	stw	r2,8(sp)
81106c54:	e0800317 	ldw	r2,12(fp)
81106c58:	d8800115 	stw	r2,4(sp)
81106c5c:	e0800217 	ldw	r2,8(fp)
81106c60:	d8800015 	stw	r2,0(sp)
81106c64:	e1fffa17 	ldw	r7,-24(fp)
81106c68:	e1bff917 	ldw	r6,-28(fp)
81106c6c:	e17ff817 	ldw	r5,-32(fp)
81106c70:	e13ff717 	ldw	r4,-36(fp)
81106c74:	11063540 	call	81106354 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
81106c78:	e037883a 	mov	sp,fp
81106c7c:	dfc00117 	ldw	ra,4(sp)
81106c80:	df000017 	ldw	fp,0(sp)
81106c84:	dec00204 	addi	sp,sp,8
81106c88:	f800283a 	ret

81106c8c <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
81106c8c:	defffc04 	addi	sp,sp,-16
81106c90:	de00012e 	bgeu	sp,et,81106c98 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
81106c94:	003b68fa 	trap	3
81106c98:	dfc00315 	stw	ra,12(sp)
81106c9c:	df000215 	stw	fp,8(sp)
81106ca0:	df000204 	addi	fp,sp,8
81106ca4:	e13ffe15 	stw	r4,-8(fp)
81106ca8:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
81106cac:	e1bfff17 	ldw	r6,-4(fp)
81106cb0:	000b883a 	mov	r5,zero
81106cb4:	e13ffe17 	ldw	r4,-8(fp)
81106cb8:	11064b80 	call	811064b8 <msgdma_descriptor_async_transfer>
}
81106cbc:	e037883a 	mov	sp,fp
81106cc0:	dfc00117 	ldw	ra,4(sp)
81106cc4:	df000017 	ldw	fp,0(sp)
81106cc8:	dec00204 	addi	sp,sp,8
81106ccc:	f800283a 	ret

81106cd0 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
81106cd0:	defffc04 	addi	sp,sp,-16
81106cd4:	de00012e 	bgeu	sp,et,81106cdc <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
81106cd8:	003b68fa 	trap	3
81106cdc:	dfc00315 	stw	ra,12(sp)
81106ce0:	df000215 	stw	fp,8(sp)
81106ce4:	df000204 	addi	fp,sp,8
81106ce8:	e13ffe15 	stw	r4,-8(fp)
81106cec:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
81106cf0:	e1bfff17 	ldw	r6,-4(fp)
81106cf4:	000b883a 	mov	r5,zero
81106cf8:	e13ffe17 	ldw	r4,-8(fp)
81106cfc:	11067d00 	call	811067d0 <msgdma_descriptor_sync_transfer>
}
81106d00:	e037883a 	mov	sp,fp
81106d04:	dfc00117 	ldw	ra,4(sp)
81106d08:	df000017 	ldw	fp,0(sp)
81106d0c:	dec00204 	addi	sp,sp,8
81106d10:	f800283a 	ret

81106d14 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
81106d14:	defff204 	addi	sp,sp,-56
81106d18:	de00012e 	bgeu	sp,et,81106d20 <POWER_SPI_RW+0xc>
81106d1c:	003b68fa 	trap	3
81106d20:	dfc00d15 	stw	ra,52(sp)
81106d24:	df000c15 	stw	fp,48(sp)
81106d28:	df000c04 	addi	fp,sp,48
81106d2c:	2007883a 	mov	r3,r4
81106d30:	2805883a 	mov	r2,r5
81106d34:	e1bffe15 	stw	r6,-8(fp)
81106d38:	e1ffff15 	stw	r7,-4(fp)
81106d3c:	e0fffc05 	stb	r3,-16(fp)
81106d40:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
81106d44:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
81106d48:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
81106d4c:	008003f4 	movhi	r2,15
81106d50:	10909004 	addi	r2,r2,16960
81106d54:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
81106d58:	00bfe004 	movi	r2,-128
81106d5c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
81106d60:	e0bffe17 	ldw	r2,-8(fp)
81106d64:	10000226 	beq	r2,zero,81106d70 <POWER_SPI_RW+0x5c>
81106d68:	00800804 	movi	r2,32
81106d6c:	00000106 	br	81106d74 <POWER_SPI_RW+0x60>
81106d70:	0005883a 	mov	r2,zero
81106d74:	e0fff403 	ldbu	r3,-48(fp)
81106d78:	10c4b03a 	or	r2,r2,r3
81106d7c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
81106d80:	e0800217 	ldw	r2,8(fp)
81106d84:	10000226 	beq	r2,zero,81106d90 <POWER_SPI_RW+0x7c>
81106d88:	00800404 	movi	r2,16
81106d8c:	00000106 	br	81106d94 <POWER_SPI_RW+0x80>
81106d90:	0005883a 	mov	r2,zero
81106d94:	e0fff403 	ldbu	r3,-48(fp)
81106d98:	10c4b03a 	or	r2,r2,r3
81106d9c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
81106da0:	e0bfff17 	ldw	r2,-4(fp)
81106da4:	10000226 	beq	r2,zero,81106db0 <POWER_SPI_RW+0x9c>
81106da8:	00800204 	movi	r2,8
81106dac:	00000106 	br	81106db4 <POWER_SPI_RW+0xa0>
81106db0:	0005883a 	mov	r2,zero
81106db4:	e0fff403 	ldbu	r3,-48(fp)
81106db8:	10c4b03a 	or	r2,r2,r3
81106dbc:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
81106dc0:	e0bffd03 	ldbu	r2,-12(fp)
81106dc4:	108001cc 	andi	r2,r2,7
81106dc8:	1007883a 	mov	r3,r2
81106dcc:	e0bff403 	ldbu	r2,-48(fp)
81106dd0:	1884b03a 	or	r2,r3,r2
81106dd4:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
81106dd8:	0007883a 	mov	r3,zero
81106ddc:	00a00034 	movhi	r2,32768
81106de0:	10824404 	addi	r2,r2,2320
81106de4:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
81106de8:	0007883a 	mov	r3,zero
81106dec:	00a00034 	movhi	r2,32768
81106df0:	10824c04 	addi	r2,r2,2352
81106df4:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
81106df8:	e0bffc03 	ldbu	r2,-16(fp)
81106dfc:	1000021e 	bne	r2,zero,81106e08 <POWER_SPI_RW+0xf4>
81106e00:	00c00084 	movi	r3,2
81106e04:	00000106 	br	81106e0c <POWER_SPI_RW+0xf8>
81106e08:	00c00044 	movi	r3,1
81106e0c:	00a00034 	movhi	r2,32768
81106e10:	10824804 	addi	r2,r2,2336
81106e14:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
81106e18:	010003c4 	movi	r4,15
81106e1c:	112def40 	call	8112def4 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
81106e20:	00000306 	br	81106e30 <POWER_SPI_RW+0x11c>
		nWait++;
81106e24:	e0bff817 	ldw	r2,-32(fp)
81106e28:	10800044 	addi	r2,r2,1
81106e2c:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
81106e30:	00a00034 	movhi	r2,32768
81106e34:	10825404 	addi	r2,r2,2384
81106e38:	10800037 	ldwio	r2,0(r2)
81106e3c:	1080004c 	andi	r2,r2,1
81106e40:	10000326 	beq	r2,zero,81106e50 <POWER_SPI_RW+0x13c>
81106e44:	e0fff817 	ldw	r3,-32(fp)
81106e48:	e0bffa17 	ldw	r2,-24(fp)
81106e4c:	18bff516 	blt	r3,r2,81106e24 <__reset+0xfb0e6e24>
		nWait++;
	}

	if (SPI_SDO) {
81106e50:	00a00034 	movhi	r2,32768
81106e54:	10825404 	addi	r2,r2,2384
81106e58:	10800037 	ldwio	r2,0(r2)
81106e5c:	1080004c 	andi	r2,r2,1
81106e60:	10000626 	beq	r2,zero,81106e7c <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
81106e64:	00c000c4 	movi	r3,3
81106e68:	00a00034 	movhi	r2,32768
81106e6c:	10824804 	addi	r2,r2,2336
81106e70:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
81106e74:	0005883a 	mov	r2,zero
81106e78:	0000db06 	br	811071e8 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
81106e7c:	e03ff715 	stw	zero,-36(fp)
81106e80:	00002406 	br	81106f14 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
81106e84:	e0bff403 	ldbu	r2,-48(fp)
81106e88:	10803fcc 	andi	r2,r2,255
81106e8c:	1004d1fa 	srli	r2,r2,7
81106e90:	10c03fcc 	andi	r3,r2,255
81106e94:	00a00034 	movhi	r2,32768
81106e98:	10825004 	addi	r2,r2,2368
81106e9c:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
81106ea0:	e0bff403 	ldbu	r2,-48(fp)
81106ea4:	1085883a 	add	r2,r2,r2
81106ea8:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
81106eac:	e0bff517 	ldw	r2,-44(fp)
81106eb0:	1085883a 	add	r2,r2,r2
81106eb4:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
81106eb8:	00a00034 	movhi	r2,32768
81106ebc:	10825404 	addi	r2,r2,2384
81106ec0:	10800037 	ldwio	r2,0(r2)
81106ec4:	1080004c 	andi	r2,r2,1
81106ec8:	1007883a 	mov	r3,r2
81106ecc:	e0bff517 	ldw	r2,-44(fp)
81106ed0:	10c4b03a 	or	r2,r2,r3
81106ed4:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81106ed8:	00c00044 	movi	r3,1
81106edc:	00a00034 	movhi	r2,32768
81106ee0:	10824c04 	addi	r2,r2,2352
81106ee4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106ee8:	010003c4 	movi	r4,15
81106eec:	112def40 	call	8112def4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
81106ef0:	0007883a 	mov	r3,zero
81106ef4:	00a00034 	movhi	r2,32768
81106ef8:	10824c04 	addi	r2,r2,2352
81106efc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106f00:	010003c4 	movi	r4,15
81106f04:	112def40 	call	8112def4 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
81106f08:	e0bff717 	ldw	r2,-36(fp)
81106f0c:	10800044 	addi	r2,r2,1
81106f10:	e0bff715 	stw	r2,-36(fp)
81106f14:	e0bff717 	ldw	r2,-36(fp)
81106f18:	10800090 	cmplti	r2,r2,2
81106f1c:	103fd91e 	bne	r2,zero,81106e84 <__reset+0xfb0e6e84>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
81106f20:	e03ff715 	stw	zero,-36(fp)
81106f24:	00002406 	br	81106fb8 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
81106f28:	e0bff403 	ldbu	r2,-48(fp)
81106f2c:	10803fcc 	andi	r2,r2,255
81106f30:	1004d1fa 	srli	r2,r2,7
81106f34:	10c03fcc 	andi	r3,r2,255
81106f38:	00a00034 	movhi	r2,32768
81106f3c:	10825004 	addi	r2,r2,2368
81106f40:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
81106f44:	e0bff403 	ldbu	r2,-48(fp)
81106f48:	1085883a 	add	r2,r2,r2
81106f4c:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
81106f50:	e0bff517 	ldw	r2,-44(fp)
81106f54:	1085883a 	add	r2,r2,r2
81106f58:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
81106f5c:	00a00034 	movhi	r2,32768
81106f60:	10825404 	addi	r2,r2,2384
81106f64:	10800037 	ldwio	r2,0(r2)
81106f68:	1080004c 	andi	r2,r2,1
81106f6c:	1007883a 	mov	r3,r2
81106f70:	e0bff517 	ldw	r2,-44(fp)
81106f74:	10c4b03a 	or	r2,r2,r3
81106f78:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81106f7c:	00c00044 	movi	r3,1
81106f80:	00a00034 	movhi	r2,32768
81106f84:	10824c04 	addi	r2,r2,2352
81106f88:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106f8c:	010003c4 	movi	r4,15
81106f90:	112def40 	call	8112def4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
81106f94:	0007883a 	mov	r3,zero
81106f98:	00a00034 	movhi	r2,32768
81106f9c:	10824c04 	addi	r2,r2,2352
81106fa0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81106fa4:	010003c4 	movi	r4,15
81106fa8:	112def40 	call	8112def4 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
81106fac:	e0bff717 	ldw	r2,-36(fp)
81106fb0:	10800044 	addi	r2,r2,1
81106fb4:	e0bff715 	stw	r2,-36(fp)
81106fb8:	e0bff717 	ldw	r2,-36(fp)
81106fbc:	10800210 	cmplti	r2,r2,8
81106fc0:	103fd91e 	bne	r2,zero,81106f28 <__reset+0xfb0e6f28>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
81106fc4:	e03ff715 	stw	zero,-36(fp)
81106fc8:	00001a06 	br	81107034 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
81106fcc:	e0bff517 	ldw	r2,-44(fp)
81106fd0:	1085883a 	add	r2,r2,r2
81106fd4:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
81106fd8:	00a00034 	movhi	r2,32768
81106fdc:	10825404 	addi	r2,r2,2384
81106fe0:	10800037 	ldwio	r2,0(r2)
81106fe4:	1080004c 	andi	r2,r2,1
81106fe8:	1007883a 	mov	r3,r2
81106fec:	e0bff517 	ldw	r2,-44(fp)
81106ff0:	10c4b03a 	or	r2,r2,r3
81106ff4:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81106ff8:	00c00044 	movi	r3,1
81106ffc:	00a00034 	movhi	r2,32768
81107000:	10824c04 	addi	r2,r2,2352
81107004:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81107008:	010003c4 	movi	r4,15
8110700c:	112def40 	call	8112def4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
81107010:	0007883a 	mov	r3,zero
81107014:	00a00034 	movhi	r2,32768
81107018:	10824c04 	addi	r2,r2,2352
8110701c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81107020:	010003c4 	movi	r4,15
81107024:	112def40 	call	8112def4 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
81107028:	e0bff717 	ldw	r2,-36(fp)
8110702c:	10800044 	addi	r2,r2,1
81107030:	e0bff715 	stw	r2,-36(fp)
81107034:	e0bff717 	ldw	r2,-36(fp)
81107038:	10800210 	cmplti	r2,r2,8
8110703c:	103fe31e 	bne	r2,zero,81106fcc <__reset+0xfb0e6fcc>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
81107040:	e03ff715 	stw	zero,-36(fp)
81107044:	00001a06 	br	811070b0 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
81107048:	e0bff517 	ldw	r2,-44(fp)
8110704c:	1085883a 	add	r2,r2,r2
81107050:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
81107054:	00a00034 	movhi	r2,32768
81107058:	10825404 	addi	r2,r2,2384
8110705c:	10800037 	ldwio	r2,0(r2)
81107060:	1080004c 	andi	r2,r2,1
81107064:	1007883a 	mov	r3,r2
81107068:	e0bff517 	ldw	r2,-44(fp)
8110706c:	10c4b03a 	or	r2,r2,r3
81107070:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
81107074:	00c00044 	movi	r3,1
81107078:	00a00034 	movhi	r2,32768
8110707c:	10824c04 	addi	r2,r2,2352
81107080:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81107084:	010003c4 	movi	r4,15
81107088:	112def40 	call	8112def4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110708c:	0007883a 	mov	r3,zero
81107090:	00a00034 	movhi	r2,32768
81107094:	10824c04 	addi	r2,r2,2352
81107098:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110709c:	010003c4 	movi	r4,15
811070a0:	112def40 	call	8112def4 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
811070a4:	e0bff717 	ldw	r2,-36(fp)
811070a8:	10800044 	addi	r2,r2,1
811070ac:	e0bff715 	stw	r2,-36(fp)
811070b0:	e0bff717 	ldw	r2,-36(fp)
811070b4:	10800210 	cmplti	r2,r2,8
811070b8:	103fe31e 	bne	r2,zero,81107048 <__reset+0xfb0e7048>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
811070bc:	e03ff715 	stw	zero,-36(fp)
811070c0:	00001a06 	br	8110712c <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
811070c4:	e0bff517 	ldw	r2,-44(fp)
811070c8:	1085883a 	add	r2,r2,r2
811070cc:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
811070d0:	00a00034 	movhi	r2,32768
811070d4:	10825404 	addi	r2,r2,2384
811070d8:	10800037 	ldwio	r2,0(r2)
811070dc:	1080004c 	andi	r2,r2,1
811070e0:	1007883a 	mov	r3,r2
811070e4:	e0bff517 	ldw	r2,-44(fp)
811070e8:	10c4b03a 	or	r2,r2,r3
811070ec:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
811070f0:	00c00044 	movi	r3,1
811070f4:	00a00034 	movhi	r2,32768
811070f8:	10824c04 	addi	r2,r2,2352
811070fc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81107100:	010003c4 	movi	r4,15
81107104:	112def40 	call	8112def4 <usleep>
		SPI_SCK(0); //sck=0; // clock low
81107108:	0007883a 	mov	r3,zero
8110710c:	00a00034 	movhi	r2,32768
81107110:	10824c04 	addi	r2,r2,2352
81107114:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
81107118:	010003c4 	movi	r4,15
8110711c:	112def40 	call	8112def4 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
81107120:	e0bff717 	ldw	r2,-36(fp)
81107124:	10800044 	addi	r2,r2,1
81107128:	e0bff715 	stw	r2,-36(fp)
8110712c:	e0bff717 	ldw	r2,-36(fp)
81107130:	10800190 	cmplti	r2,r2,6
81107134:	103fe31e 	bne	r2,zero,811070c4 <__reset+0xfb0e70c4>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
81107138:	00c00044 	movi	r3,1
8110713c:	00a00034 	movhi	r2,32768
81107140:	10824c04 	addi	r2,r2,2352
81107144:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
81107148:	010003c4 	movi	r4,15
8110714c:	112def40 	call	8112def4 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
81107150:	00c000c4 	movi	r3,3
81107154:	00a00034 	movhi	r2,32768
81107158:	10824804 	addi	r2,r2,2336
8110715c:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
81107160:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
81107164:	00800044 	movi	r2,1
81107168:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110716c:	e03ff715 	stw	zero,-36(fp)
81107170:	00000d06 	br	811071a8 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
81107174:	e0fff517 	ldw	r3,-44(fp)
81107178:	e0bff617 	ldw	r2,-40(fp)
8110717c:	1884703a 	and	r2,r3,r2
81107180:	1000031e 	bne	r2,zero,81107190 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
81107184:	e0bff917 	ldw	r2,-28(fp)
81107188:	10800044 	addi	r2,r2,1
8110718c:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
81107190:	e0bff617 	ldw	r2,-40(fp)
81107194:	1085883a 	add	r2,r2,r2
81107198:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110719c:	e0bff717 	ldw	r2,-36(fp)
811071a0:	10800044 	addi	r2,r2,1
811071a4:	e0bff715 	stw	r2,-36(fp)
811071a8:	e0bff717 	ldw	r2,-36(fp)
811071ac:	10800810 	cmplti	r2,r2,32
811071b0:	103ff01e 	bne	r2,zero,81107174 <__reset+0xfb0e7174>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
811071b4:	e0bff917 	ldw	r2,-28(fp)
811071b8:	1080004c 	andi	r2,r2,1
811071bc:	1005003a 	cmpeq	r2,r2,zero
811071c0:	10803fcc 	andi	r2,r2,255
811071c4:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
811071c8:	e0bffb17 	ldw	r2,-20(fp)
811071cc:	1000021e 	bne	r2,zero,811071d8 <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
811071d0:	0005883a 	mov	r2,zero
811071d4:	00000406 	br	811071e8 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
811071d8:	e0800317 	ldw	r2,12(fp)
811071dc:	e0fff517 	ldw	r3,-44(fp)
811071e0:	10c00015 	stw	r3,0(r2)

	return bSuccess;
811071e4:	e0bffb17 	ldw	r2,-20(fp)
}
811071e8:	e037883a 	mov	sp,fp
811071ec:	dfc00117 	ldw	ra,4(sp)
811071f0:	df000017 	ldw	fp,0(sp)
811071f4:	dec00204 	addi	sp,sp,8
811071f8:	f800283a 	ret

811071fc <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
811071fc:	defffc04 	addi	sp,sp,-16
81107200:	de00012e 	bgeu	sp,et,81107208 <vRstcSimucamReset+0xc>
81107204:	003b68fa 	trap	3
81107208:	dfc00315 	stw	ra,12(sp)
8110720c:	df000215 	stw	fp,8(sp)
81107210:	df000204 	addi	fp,sp,8
81107214:	2005883a 	mov	r2,r4
81107218:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110721c:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
81107220:	e0bfff0b 	ldhu	r2,-4(fp)
81107224:	e0fffe17 	ldw	r3,-8(fp)
81107228:	1884b03a 	or	r2,r3,r2
8110722c:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
81107230:	e0bffe17 	ldw	r2,-8(fp)
81107234:	10800074 	orhi	r2,r2,1
81107238:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110723c:	e1bffe17 	ldw	r6,-8(fp)
81107240:	000b883a 	mov	r5,zero
81107244:	01200034 	movhi	r4,32768
81107248:	21020004 	addi	r4,r4,2048
8110724c:	110734c0 	call	8110734c <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
81107250:	0001883a 	nop
81107254:	e037883a 	mov	sp,fp
81107258:	dfc00117 	ldw	ra,4(sp)
8110725c:	df000017 	ldw	fp,0(sp)
81107260:	dec00204 	addi	sp,sp,8
81107264:	f800283a 	ret

81107268 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
81107268:	defffc04 	addi	sp,sp,-16
8110726c:	de00012e 	bgeu	sp,et,81107274 <vRstcReleaseDeviceReset+0xc>
81107270:	003b68fa 	trap	3
81107274:	dfc00315 	stw	ra,12(sp)
81107278:	df000215 	stw	fp,8(sp)
8110727c:	df000204 	addi	fp,sp,8
81107280:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
81107284:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
81107288:	01400044 	movi	r5,1
8110728c:	01200034 	movhi	r4,32768
81107290:	21020004 	addi	r4,r4,2048
81107294:	11073a00 	call	811073a0 <uliRstReadReg>
81107298:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110729c:	e0bfff17 	ldw	r2,-4(fp)
811072a0:	0084303a 	nor	r2,zero,r2
811072a4:	e0fffe17 	ldw	r3,-8(fp)
811072a8:	1884703a 	and	r2,r3,r2
811072ac:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
811072b0:	e1bffe17 	ldw	r6,-8(fp)
811072b4:	01400044 	movi	r5,1
811072b8:	01200034 	movhi	r4,32768
811072bc:	21020004 	addi	r4,r4,2048
811072c0:	110734c0 	call	8110734c <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
811072c4:	0001883a 	nop
811072c8:	e037883a 	mov	sp,fp
811072cc:	dfc00117 	ldw	ra,4(sp)
811072d0:	df000017 	ldw	fp,0(sp)
811072d4:	dec00204 	addi	sp,sp,8
811072d8:	f800283a 	ret

811072dc <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
811072dc:	defffc04 	addi	sp,sp,-16
811072e0:	de00012e 	bgeu	sp,et,811072e8 <vRstcHoldDeviceReset+0xc>
811072e4:	003b68fa 	trap	3
811072e8:	dfc00315 	stw	ra,12(sp)
811072ec:	df000215 	stw	fp,8(sp)
811072f0:	df000204 	addi	fp,sp,8
811072f4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
811072f8:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
811072fc:	01400044 	movi	r5,1
81107300:	01200034 	movhi	r4,32768
81107304:	21020004 	addi	r4,r4,2048
81107308:	11073a00 	call	811073a0 <uliRstReadReg>
8110730c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
81107310:	e0fffe17 	ldw	r3,-8(fp)
81107314:	e0bfff17 	ldw	r2,-4(fp)
81107318:	1884b03a 	or	r2,r3,r2
8110731c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
81107320:	e1bffe17 	ldw	r6,-8(fp)
81107324:	01400044 	movi	r5,1
81107328:	01200034 	movhi	r4,32768
8110732c:	21020004 	addi	r4,r4,2048
81107330:	110734c0 	call	8110734c <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
81107334:	0001883a 	nop
81107338:	e037883a 	mov	sp,fp
8110733c:	dfc00117 	ldw	ra,4(sp)
81107340:	df000017 	ldw	fp,0(sp)
81107344:	dec00204 	addi	sp,sp,8
81107348:	f800283a 	ret

8110734c <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110734c:	defffc04 	addi	sp,sp,-16
81107350:	de00012e 	bgeu	sp,et,81107358 <vRstcWriteReg+0xc>
81107354:	003b68fa 	trap	3
81107358:	df000315 	stw	fp,12(sp)
8110735c:	df000304 	addi	fp,sp,12
81107360:	e13ffd15 	stw	r4,-12(fp)
81107364:	e17ffe15 	stw	r5,-8(fp)
81107368:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110736c:	e0bffe17 	ldw	r2,-8(fp)
81107370:	1085883a 	add	r2,r2,r2
81107374:	1085883a 	add	r2,r2,r2
81107378:	1007883a 	mov	r3,r2
8110737c:	e0bffd17 	ldw	r2,-12(fp)
81107380:	10c5883a 	add	r2,r2,r3
81107384:	e0ffff17 	ldw	r3,-4(fp)
81107388:	10c00015 	stw	r3,0(r2)
}
8110738c:	0001883a 	nop
81107390:	e037883a 	mov	sp,fp
81107394:	df000017 	ldw	fp,0(sp)
81107398:	dec00104 	addi	sp,sp,4
8110739c:	f800283a 	ret

811073a0 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811073a0:	defffc04 	addi	sp,sp,-16
811073a4:	de00012e 	bgeu	sp,et,811073ac <uliRstReadReg+0xc>
811073a8:	003b68fa 	trap	3
811073ac:	df000315 	stw	fp,12(sp)
811073b0:	df000304 	addi	fp,sp,12
811073b4:	e13ffe15 	stw	r4,-8(fp)
811073b8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811073bc:	e0bfff17 	ldw	r2,-4(fp)
811073c0:	1085883a 	add	r2,r2,r2
811073c4:	1085883a 	add	r2,r2,r2
811073c8:	1007883a 	mov	r3,r2
811073cc:	e0bffe17 	ldw	r2,-8(fp)
811073d0:	10c5883a 	add	r2,r2,r3
811073d4:	10800017 	ldw	r2,0(r2)
811073d8:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
811073dc:	e0bffd17 	ldw	r2,-12(fp)
}
811073e0:	e037883a 	mov	sp,fp
811073e4:	df000017 	ldw	fp,0(sp)
811073e8:	dec00104 	addi	sp,sp,4
811073ec:	f800283a 	ret

811073f0 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
811073f0:	defffe04 	addi	sp,sp,-8
811073f4:	de00012e 	bgeu	sp,et,811073fc <v_spi_start+0xc>
811073f8:	003b68fa 	trap	3
811073fc:	dfc00115 	stw	ra,4(sp)
81107400:	df000015 	stw	fp,0(sp)
81107404:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
81107408:	0007883a 	mov	r3,zero
8110740c:	00a00034 	movhi	r2,32768
81107410:	10823004 	addi	r2,r2,2240
81107414:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
81107418:	0007883a 	mov	r3,zero
8110741c:	00a00034 	movhi	r2,32768
81107420:	10822c04 	addi	r2,r2,2224
81107424:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
81107428:	01002584 	movi	r4,150
8110742c:	112def40 	call	8112def4 <usleep>
}
81107430:	0001883a 	nop
81107434:	e037883a 	mov	sp,fp
81107438:	dfc00117 	ldw	ra,4(sp)
8110743c:	df000017 	ldw	fp,0(sp)
81107440:	dec00204 	addi	sp,sp,8
81107444:	f800283a 	ret

81107448 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
81107448:	defffc04 	addi	sp,sp,-16
8110744c:	de00012e 	bgeu	sp,et,81107454 <v_spi_send_byte+0xc>
81107450:	003b68fa 	trap	3
81107454:	dfc00315 	stw	ra,12(sp)
81107458:	df000215 	stw	fp,8(sp)
8110745c:	df000204 	addi	fp,sp,8
81107460:	2005883a 	mov	r2,r4
81107464:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
81107468:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110746c:	00bfe004 	movi	r2,-128
81107470:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
81107474:	e03ffe05 	stb	zero,-8(fp)
81107478:	00001b06 	br	811074e8 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110747c:	e0ffff03 	ldbu	r3,-4(fp)
81107480:	e0bffe43 	ldbu	r2,-7(fp)
81107484:	1884703a 	and	r2,r3,r2
81107488:	10803fcc 	andi	r2,r2,255
8110748c:	1004c03a 	cmpne	r2,r2,zero
81107490:	10c03fcc 	andi	r3,r2,255
81107494:	00a00034 	movhi	r2,32768
81107498:	10823404 	addi	r2,r2,2256
8110749c:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
811074a0:	e0bffe43 	ldbu	r2,-7(fp)
811074a4:	1004d07a 	srli	r2,r2,1
811074a8:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
811074ac:	00c00044 	movi	r3,1
811074b0:	00a00034 	movhi	r2,32768
811074b4:	10823004 	addi	r2,r2,2240
811074b8:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
811074bc:	01002584 	movi	r4,150
811074c0:	112def40 	call	8112def4 <usleep>
        SPI_SCK(0);//sck=0; // clock low
811074c4:	0007883a 	mov	r3,zero
811074c8:	00a00034 	movhi	r2,32768
811074cc:	10823004 	addi	r2,r2,2240
811074d0:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
811074d4:	01002584 	movi	r4,150
811074d8:	112def40 	call	8112def4 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
811074dc:	e0bffe03 	ldbu	r2,-8(fp)
811074e0:	10800044 	addi	r2,r2,1
811074e4:	e0bffe05 	stb	r2,-8(fp)
811074e8:	e0bffe03 	ldbu	r2,-8(fp)
811074ec:	10800230 	cmpltui	r2,r2,8
811074f0:	103fe21e 	bne	r2,zero,8110747c <__reset+0xfb0e747c>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
811074f4:	0001883a 	nop
811074f8:	e037883a 	mov	sp,fp
811074fc:	dfc00117 	ldw	ra,4(sp)
81107500:	df000017 	ldw	fp,0(sp)
81107504:	dec00204 	addi	sp,sp,8
81107508:	f800283a 	ret

8110750c <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110750c:	defffd04 	addi	sp,sp,-12
81107510:	de00012e 	bgeu	sp,et,81107518 <uc_spi_get_byte+0xc>
81107514:	003b68fa 	trap	3
81107518:	dfc00215 	stw	ra,8(sp)
8110751c:	df000115 	stw	fp,4(sp)
81107520:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
81107524:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
81107528:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110752c:	e03fff05 	stb	zero,-4(fp)
81107530:	00001a06 	br	8110759c <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
81107534:	e0bfff43 	ldbu	r2,-3(fp)
81107538:	1085883a 	add	r2,r2,r2
8110753c:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
81107540:	00a00034 	movhi	r2,32768
81107544:	10823804 	addi	r2,r2,2272
81107548:	10800037 	ldwio	r2,0(r2)
8110754c:	1080004c 	andi	r2,r2,1
81107550:	1007883a 	mov	r3,r2
81107554:	e0bfff43 	ldbu	r2,-3(fp)
81107558:	1884b03a 	or	r2,r3,r2
8110755c:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
81107560:	00c00044 	movi	r3,1
81107564:	00a00034 	movhi	r2,32768
81107568:	10823004 	addi	r2,r2,2240
8110756c:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
81107570:	01002584 	movi	r4,150
81107574:	112def40 	call	8112def4 <usleep>
        SPI_SCK(0);//sck=0; // clock low
81107578:	0007883a 	mov	r3,zero
8110757c:	00a00034 	movhi	r2,32768
81107580:	10823004 	addi	r2,r2,2240
81107584:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
81107588:	01002584 	movi	r4,150
8110758c:	112def40 	call	8112def4 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
81107590:	e0bfff03 	ldbu	r2,-4(fp)
81107594:	10800044 	addi	r2,r2,1
81107598:	e0bfff05 	stb	r2,-4(fp)
8110759c:	e0bfff03 	ldbu	r2,-4(fp)
811075a0:	10800230 	cmpltui	r2,r2,8
811075a4:	103fe31e 	bne	r2,zero,81107534 <__reset+0xfb0e7534>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
811075a8:	e0bfff43 	ldbu	r2,-3(fp)
}
811075ac:	e037883a 	mov	sp,fp
811075b0:	dfc00117 	ldw	ra,4(sp)
811075b4:	df000017 	ldw	fp,0(sp)
811075b8:	dec00204 	addi	sp,sp,8
811075bc:	f800283a 	ret

811075c0 <v_spi_end>:

void v_spi_end(void){
811075c0:	defffe04 	addi	sp,sp,-8
811075c4:	de00012e 	bgeu	sp,et,811075cc <v_spi_end+0xc>
811075c8:	003b68fa 	trap	3
811075cc:	dfc00115 	stw	ra,4(sp)
811075d0:	df000015 	stw	fp,0(sp)
811075d4:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
811075d8:	0007883a 	mov	r3,zero
811075dc:	00a00034 	movhi	r2,32768
811075e0:	10823004 	addi	r2,r2,2240
811075e4:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
811075e8:	01002584 	movi	r4,150
811075ec:	112def40 	call	8112def4 <usleep>
    SPI_CS_N(1);
811075f0:	00c00044 	movi	r3,1
811075f4:	00a00034 	movhi	r2,32768
811075f8:	10822c04 	addi	r2,r2,2224
811075fc:	10c00035 	stwio	r3,0(r2)
}
81107600:	0001883a 	nop
81107604:	e037883a 	mov	sp,fp
81107608:	dfc00117 	ldw	ra,4(sp)
8110760c:	df000017 	ldw	fp,0(sp)
81107610:	dec00204 	addi	sp,sp,8
81107614:	f800283a 	ret

81107618 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
81107618:	defff604 	addi	sp,sp,-40
8110761c:	de00012e 	bgeu	sp,et,81107624 <RTCC_SPI_R_MAC+0xc>
81107620:	003b68fa 	trap	3
81107624:	dfc00915 	stw	ra,36(sp)
81107628:	df000815 	stw	fp,32(sp)
8110762c:	df000804 	addi	fp,sp,32
81107630:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81107634:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
81107638:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110763c:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
81107640:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
81107644:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
81107648:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110764c:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
81107650:	00800084 	movi	r2,2
81107654:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
81107658:	00800cc4 	movi	r2,51
8110765c:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
81107660:	11073f00 	call	811073f0 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
81107664:	e0bffec3 	ldbu	r2,-5(fp)
81107668:	1009883a 	mov	r4,r2
8110766c:	11074480 	call	81107448 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
81107670:	e0bffe83 	ldbu	r2,-6(fp)
81107674:	1009883a 	mov	r4,r2
81107678:	11074480 	call	81107448 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110767c:	110750c0 	call	8110750c <uc_spi_get_byte>
81107680:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
81107684:	110750c0 	call	8110750c <uc_spi_get_byte>
81107688:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110768c:	110750c0 	call	8110750c <uc_spi_get_byte>
81107690:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
81107694:	110750c0 	call	8110750c <uc_spi_get_byte>
81107698:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110769c:	110750c0 	call	8110750c <uc_spi_get_byte>
811076a0:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
811076a4:	110750c0 	call	8110750c <uc_spi_get_byte>
811076a8:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
811076ac:	11075c00 	call	811075c0 <v_spi_end>

    bSuccess = TRUE;
811076b0:	00800044 	movi	r2,1
811076b4:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
811076b8:	e0bfff17 	ldw	r2,-4(fp)
811076bc:	e0fffd03 	ldbu	r3,-12(fp)
811076c0:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
811076c4:	e0bfff17 	ldw	r2,-4(fp)
811076c8:	10800044 	addi	r2,r2,1
811076cc:	e0fffd43 	ldbu	r3,-11(fp)
811076d0:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
811076d4:	e0bfff17 	ldw	r2,-4(fp)
811076d8:	10800084 	addi	r2,r2,2
811076dc:	e0fffd83 	ldbu	r3,-10(fp)
811076e0:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
811076e4:	e0bfff17 	ldw	r2,-4(fp)
811076e8:	108000c4 	addi	r2,r2,3
811076ec:	e0fffdc3 	ldbu	r3,-9(fp)
811076f0:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
811076f4:	e0bfff17 	ldw	r2,-4(fp)
811076f8:	10800104 	addi	r2,r2,4
811076fc:	e0fffe03 	ldbu	r3,-8(fp)
81107700:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
81107704:	e0bfff17 	ldw	r2,-4(fp)
81107708:	10800144 	addi	r2,r2,5
8110770c:	e0fffe43 	ldbu	r3,-7(fp)
81107710:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
81107714:	e1bffd03 	ldbu	r6,-12(fp)
81107718:	e1fffd43 	ldbu	r7,-11(fp)
8110771c:	e0bffd83 	ldbu	r2,-10(fp)
81107720:	e0fffdc3 	ldbu	r3,-9(fp)
81107724:	e13ffe03 	ldbu	r4,-8(fp)
81107728:	e17ffe43 	ldbu	r5,-7(fp)
8110772c:	d9400315 	stw	r5,12(sp)
81107730:	d9000215 	stw	r4,8(sp)
81107734:	d8c00115 	stw	r3,4(sp)
81107738:	d8800015 	stw	r2,0(sp)
8110773c:	01604534 	movhi	r5,33044
81107740:	29497504 	addi	r5,r5,9684
81107744:	01204574 	movhi	r4,33045
81107748:	21221504 	addi	r4,r4,-30636
8110774c:	11185ac0 	call	811185ac <sprintf>
	debug(fp, cDebugBuffer);
81107750:	d0a05517 	ldw	r2,-32428(gp)
81107754:	01604574 	movhi	r5,33045
81107758:	29621504 	addi	r5,r5,-30636
8110775c:	1009883a 	mov	r4,r2
81107760:	1116c1c0 	call	81116c1c <fprintf>
#endif

    return bSuccess;
81107764:	e0bffc17 	ldw	r2,-16(fp)
}
81107768:	e037883a 	mov	sp,fp
8110776c:	dfc00117 	ldw	ra,4(sp)
81107770:	df000017 	ldw	fp,0(sp)
81107774:	dec00204 	addi	sp,sp,8
81107778:	f800283a 	ret

8110777c <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110777c:	defffd04 	addi	sp,sp,-12
81107780:	de00012e 	bgeu	sp,et,81107788 <bSSDisplayConfig+0xc>
81107784:	003b68fa 	trap	3
81107788:	df000215 	stw	fp,8(sp)
8110778c:	df000204 	addi	fp,sp,8
81107790:	2005883a 	mov	r2,r4
81107794:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
81107798:	e0bfff03 	ldbu	r2,-4(fp)
8110779c:	10c00168 	cmpgeui	r3,r2,5
811077a0:	18001c1e 	bne	r3,zero,81107814 <bSSDisplayConfig+0x98>
811077a4:	100690ba 	slli	r3,r2,2
811077a8:	00a04434 	movhi	r2,33040
811077ac:	109def04 	addi	r2,r2,30652
811077b0:	1885883a 	add	r2,r3,r2
811077b4:	10800017 	ldw	r2,0(r2)
811077b8:	1000683a 	jmp	r2
811077bc:	811077d0 	cmplti	r4,r16,16863
811077c0:	811077dc 	xori	r4,r16,16863
811077c4:	811077e8 	cmpgeui	r4,r16,16863
811077c8:	811077fc 	xorhi	r4,r16,16863
811077cc:	8110780c 	andi	r4,r16,16864
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
811077d0:	00800cc4 	movi	r2,51
811077d4:	d0a04645 	stb	r2,-32487(gp)
	    break;
811077d8:	00001006 	br	8110781c <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
811077dc:	00801544 	movi	r2,85
811077e0:	d0a04645 	stb	r2,-32487(gp)
	    break;
811077e4:	00000d06 	br	8110781c <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
811077e8:	d0e04643 	ldbu	r3,-32487(gp)
811077ec:	00bff744 	movi	r2,-35
811077f0:	1884703a 	and	r2,r3,r2
811077f4:	d0a04645 	stb	r2,-32487(gp)
	    break;
811077f8:	00000806 	br	8110781c <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
811077fc:	d0a04643 	ldbu	r2,-32487(gp)
81107800:	10800894 	ori	r2,r2,34
81107804:	d0a04645 	stb	r2,-32487(gp)
	    break;
81107808:	00000406 	br	8110781c <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110780c:	d0204645 	stb	zero,-32487(gp)
	    break;
81107810:	00000206 	br	8110781c <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
81107814:	0005883a 	mov	r2,zero
81107818:	00000806 	br	8110783c <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110781c:	00a00034 	movhi	r2,32768
81107820:	10828404 	addi	r2,r2,2576
81107824:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
81107828:	d0a04643 	ldbu	r2,-32487(gp)
8110782c:	10c03fcc 	andi	r3,r2,255
81107830:	e0bffe17 	ldw	r2,-8(fp)
81107834:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
81107838:	00800044 	movi	r2,1
}
8110783c:	e037883a 	mov	sp,fp
81107840:	df000017 	ldw	fp,0(sp)
81107844:	dec00104 	addi	sp,sp,4
81107848:	f800283a 	ret

8110784c <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110784c:	defffd04 	addi	sp,sp,-12
81107850:	de00012e 	bgeu	sp,et,81107858 <bSSDisplayUpdate+0xc>
81107854:	003b68fa 	trap	3
81107858:	df000215 	stw	fp,8(sp)
8110785c:	df000204 	addi	fp,sp,8
81107860:	2005883a 	mov	r2,r4
81107864:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
81107868:	00a00034 	movhi	r2,32768
8110786c:	10828404 	addi	r2,r2,2576
81107870:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
81107874:	e0bffe17 	ldw	r2,-8(fp)
81107878:	10800104 	addi	r2,r2,4
8110787c:	e0ffff03 	ldbu	r3,-4(fp)
81107880:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
81107884:	00800044 	movi	r2,1
}
81107888:	e037883a 	mov	sp,fp
8110788c:	df000017 	ldw	fp,0(sp)
81107890:	dec00104 	addi	sp,sp,4
81107894:	f800283a 	ret

81107898 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
81107898:	defffd04 	addi	sp,sp,-12
8110789c:	de00012e 	bgeu	sp,et,811078a4 <vSyncHandleIrq+0xc>
811078a0:	003b68fa 	trap	3
811078a4:	df000215 	stw	fp,8(sp)
811078a8:	df000204 	addi	fp,sp,8
811078ac:	e13fff15 	stw	r4,-4(fp)
	// Cast pvContext to viHoldContext's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811078b0:	e0bfff17 	ldw	r2,-4(fp)
811078b4:	e0bffe15 	stw	r2,-8(fp)
	// Use pvContext value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vucN += 1;
811078b8:	d0a04803 	ldbu	r2,-32480(gp)
811078bc:	10800044 	addi	r2,r2,1
811078c0:	d0a04805 	stb	r2,-32480(gp)
}
811078c4:	0001883a 	nop
811078c8:	e037883a 	mov	sp,fp
811078cc:	df000017 	ldw	fp,0(sp)
811078d0:	dec00104 	addi	sp,sp,4
811078d4:	f800283a 	ret

811078d8 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
811078d8:	defffd04 	addi	sp,sp,-12
811078dc:	de00012e 	bgeu	sp,et,811078e4 <vSyncInitIrq+0xc>
811078e0:	003b68fa 	trap	3
811078e4:	dfc00215 	stw	ra,8(sp)
811078e8:	df000115 	stw	fp,4(sp)
811078ec:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
811078f0:	d0a04704 	addi	r2,gp,-32484
811078f4:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
811078f8:	01a04434 	movhi	r6,33040
811078fc:	319e2604 	addi	r6,r6,30872
81107900:	e17fff17 	ldw	r5,-4(fp)
81107904:	01000284 	movi	r4,10
81107908:	112c8240 	call	8112c824 <alt_irq_register>
}
8110790c:	0001883a 	nop
81107910:	e037883a 	mov	sp,fp
81107914:	dfc00117 	ldw	ra,4(sp)
81107918:	df000017 	ldw	fp,0(sp)
8110791c:	dec00204 	addi	sp,sp,8
81107920:	f800283a 	ret

81107924 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
81107924:	defffc04 	addi	sp,sp,-16
81107928:	de00012e 	bgeu	sp,et,81107930 <bSyncStatusExtnIrq+0xc>
8110792c:	003b68fa 	trap	3
81107930:	dfc00315 	stw	ra,12(sp)
81107934:	df000215 	stw	fp,8(sp)
81107938:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110793c:	0009883a 	mov	r4,zero
81107940:	11086d40 	call	811086d4 <uliSyncReadReg>
81107944:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
81107948:	e0bfff17 	ldw	r2,-4(fp)
8110794c:	1000030e 	bge	r2,zero,8110795c <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
81107950:	00800044 	movi	r2,1
81107954:	e0bffe15 	stw	r2,-8(fp)
81107958:	00000106 	br	81107960 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110795c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
81107960:	e0bffe17 	ldw	r2,-8(fp)
}
81107964:	e037883a 	mov	sp,fp
81107968:	dfc00117 	ldw	ra,4(sp)
8110796c:	df000017 	ldw	fp,0(sp)
81107970:	dec00204 	addi	sp,sp,8
81107974:	f800283a 	ret

81107978 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
81107978:	defffc04 	addi	sp,sp,-16
8110797c:	de00012e 	bgeu	sp,et,81107984 <ucSyncStatusState+0xc>
81107980:	003b68fa 	trap	3
81107984:	dfc00315 	stw	ra,12(sp)
81107988:	df000215 	stw	fp,8(sp)
8110798c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81107990:	0009883a 	mov	r4,zero
81107994:	11086d40 	call	811086d4 <uliSyncReadReg>
81107998:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110799c:	e0bffe17 	ldw	r2,-8(fp)
811079a0:	10803fec 	andhi	r2,r2,255
811079a4:	1004d43a 	srli	r2,r2,16
811079a8:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
811079ac:	e0bfff03 	ldbu	r2,-4(fp)
}
811079b0:	e037883a 	mov	sp,fp
811079b4:	dfc00117 	ldw	ra,4(sp)
811079b8:	df000017 	ldw	fp,0(sp)
811079bc:	dec00204 	addi	sp,sp,8
811079c0:	f800283a 	ret

811079c4 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
811079c4:	defffc04 	addi	sp,sp,-16
811079c8:	de00012e 	bgeu	sp,et,811079d0 <ucSyncStatusErrorCode+0xc>
811079cc:	003b68fa 	trap	3
811079d0:	dfc00315 	stw	ra,12(sp)
811079d4:	df000215 	stw	fp,8(sp)
811079d8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
811079dc:	0009883a 	mov	r4,zero
811079e0:	11086d40 	call	811086d4 <uliSyncReadReg>
811079e4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
811079e8:	e0bffe17 	ldw	r2,-8(fp)
811079ec:	10bfc00c 	andi	r2,r2,65280
811079f0:	1004d23a 	srli	r2,r2,8
811079f4:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
811079f8:	e0bfff03 	ldbu	r2,-4(fp)
}
811079fc:	e037883a 	mov	sp,fp
81107a00:	dfc00117 	ldw	ra,4(sp)
81107a04:	df000017 	ldw	fp,0(sp)
81107a08:	dec00204 	addi	sp,sp,8
81107a0c:	f800283a 	ret

81107a10 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
81107a10:	defffc04 	addi	sp,sp,-16
81107a14:	de00012e 	bgeu	sp,et,81107a1c <ucSyncStatusCycleNumber+0xc>
81107a18:	003b68fa 	trap	3
81107a1c:	dfc00315 	stw	ra,12(sp)
81107a20:	df000215 	stw	fp,8(sp)
81107a24:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81107a28:	0009883a 	mov	r4,zero
81107a2c:	11086d40 	call	811086d4 <uliSyncReadReg>
81107a30:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
81107a34:	e0bffe17 	ldw	r2,-8(fp)
81107a38:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
81107a3c:	e0bfff03 	ldbu	r2,-4(fp)
}
81107a40:	e037883a 	mov	sp,fp
81107a44:	dfc00117 	ldw	ra,4(sp)
81107a48:	df000017 	ldw	fp,0(sp)
81107a4c:	dec00204 	addi	sp,sp,8
81107a50:	f800283a 	ret

81107a54 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
81107a54:	defffd04 	addi	sp,sp,-12
81107a58:	de00012e 	bgeu	sp,et,81107a60 <bSyncSetMbt+0xc>
81107a5c:	003b68fa 	trap	3
81107a60:	dfc00215 	stw	ra,8(sp)
81107a64:	df000115 	stw	fp,4(sp)
81107a68:	df000104 	addi	fp,sp,4
81107a6c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
81107a70:	e17fff17 	ldw	r5,-4(fp)
81107a74:	01000104 	movi	r4,4
81107a78:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107a7c:	00800044 	movi	r2,1
}
81107a80:	e037883a 	mov	sp,fp
81107a84:	dfc00117 	ldw	ra,4(sp)
81107a88:	df000017 	ldw	fp,0(sp)
81107a8c:	dec00204 	addi	sp,sp,8
81107a90:	f800283a 	ret

81107a94 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
81107a94:	defffd04 	addi	sp,sp,-12
81107a98:	de00012e 	bgeu	sp,et,81107aa0 <bSyncSetBt+0xc>
81107a9c:	003b68fa 	trap	3
81107aa0:	dfc00215 	stw	ra,8(sp)
81107aa4:	df000115 	stw	fp,4(sp)
81107aa8:	df000104 	addi	fp,sp,4
81107aac:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
81107ab0:	e17fff17 	ldw	r5,-4(fp)
81107ab4:	01000144 	movi	r4,5
81107ab8:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107abc:	00800044 	movi	r2,1
}
81107ac0:	e037883a 	mov	sp,fp
81107ac4:	dfc00117 	ldw	ra,4(sp)
81107ac8:	df000017 	ldw	fp,0(sp)
81107acc:	dec00204 	addi	sp,sp,8
81107ad0:	f800283a 	ret

81107ad4 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
81107ad4:	defffd04 	addi	sp,sp,-12
81107ad8:	de00012e 	bgeu	sp,et,81107ae0 <bSyncSetPer+0xc>
81107adc:	003b68fa 	trap	3
81107ae0:	dfc00215 	stw	ra,8(sp)
81107ae4:	df000115 	stw	fp,4(sp)
81107ae8:	df000104 	addi	fp,sp,4
81107aec:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
81107af0:	e17fff17 	ldw	r5,-4(fp)
81107af4:	01000184 	movi	r4,6
81107af8:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107afc:	00800044 	movi	r2,1
}
81107b00:	e037883a 	mov	sp,fp
81107b04:	dfc00117 	ldw	ra,4(sp)
81107b08:	df000017 	ldw	fp,0(sp)
81107b0c:	dec00204 	addi	sp,sp,8
81107b10:	f800283a 	ret

81107b14 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
81107b14:	defffd04 	addi	sp,sp,-12
81107b18:	de00012e 	bgeu	sp,et,81107b20 <bSyncSetOst+0xc>
81107b1c:	003b68fa 	trap	3
81107b20:	dfc00215 	stw	ra,8(sp)
81107b24:	df000115 	stw	fp,4(sp)
81107b28:	df000104 	addi	fp,sp,4
81107b2c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
81107b30:	e17fff17 	ldw	r5,-4(fp)
81107b34:	010001c4 	movi	r4,7
81107b38:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107b3c:	00800044 	movi	r2,1
}
81107b40:	e037883a 	mov	sp,fp
81107b44:	dfc00117 	ldw	ra,4(sp)
81107b48:	df000017 	ldw	fp,0(sp)
81107b4c:	dec00204 	addi	sp,sp,8
81107b50:	f800283a 	ret

81107b54 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
81107b54:	defffc04 	addi	sp,sp,-16
81107b58:	de00012e 	bgeu	sp,et,81107b60 <bSyncSetPolarity+0xc>
81107b5c:	003b68fa 	trap	3
81107b60:	dfc00315 	stw	ra,12(sp)
81107b64:	df000215 	stw	fp,8(sp)
81107b68:	df000204 	addi	fp,sp,8
81107b6c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
81107b70:	01000204 	movi	r4,8
81107b74:	11086d40 	call	811086d4 <uliSyncReadReg>
81107b78:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107b7c:	e0bfff17 	ldw	r2,-4(fp)
81107b80:	1000051e 	bne	r2,zero,81107b98 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
81107b84:	e0fffe17 	ldw	r3,-8(fp)
81107b88:	00bfbfc4 	movi	r2,-257
81107b8c:	1884703a 	and	r2,r3,r2
81107b90:	e0bffe15 	stw	r2,-8(fp)
81107b94:	00000306 	br	81107ba4 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
81107b98:	e0bffe17 	ldw	r2,-8(fp)
81107b9c:	10804014 	ori	r2,r2,256
81107ba0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
81107ba4:	e17ffe17 	ldw	r5,-8(fp)
81107ba8:	01000204 	movi	r4,8
81107bac:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107bb0:	00800044 	movi	r2,1
}
81107bb4:	e037883a 	mov	sp,fp
81107bb8:	dfc00117 	ldw	ra,4(sp)
81107bbc:	df000017 	ldw	fp,0(sp)
81107bc0:	dec00204 	addi	sp,sp,8
81107bc4:	f800283a 	ret

81107bc8 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
81107bc8:	defffc04 	addi	sp,sp,-16
81107bcc:	de00012e 	bgeu	sp,et,81107bd4 <bSyncSetNCycles+0xc>
81107bd0:	003b68fa 	trap	3
81107bd4:	dfc00315 	stw	ra,12(sp)
81107bd8:	df000215 	stw	fp,8(sp)
81107bdc:	df000204 	addi	fp,sp,8
81107be0:	2005883a 	mov	r2,r4
81107be4:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
81107be8:	01000204 	movi	r4,8
81107bec:	11086d40 	call	811086d4 <uliSyncReadReg>
81107bf0:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
81107bf4:	e0fffe17 	ldw	r3,-8(fp)
81107bf8:	00bfc004 	movi	r2,-256
81107bfc:	1884703a 	and	r2,r3,r2
81107c00:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
81107c04:	e0bfff03 	ldbu	r2,-4(fp)
81107c08:	e0fffe17 	ldw	r3,-8(fp)
81107c0c:	1884b03a 	or	r2,r3,r2
81107c10:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
81107c14:	e17ffe17 	ldw	r5,-8(fp)
81107c18:	01000204 	movi	r4,8
81107c1c:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107c20:	00800044 	movi	r2,1
}
81107c24:	e037883a 	mov	sp,fp
81107c28:	dfc00117 	ldw	ra,4(sp)
81107c2c:	df000017 	ldw	fp,0(sp)
81107c30:	dec00204 	addi	sp,sp,8
81107c34:	f800283a 	ret

81107c38 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
81107c38:	defffd04 	addi	sp,sp,-12
81107c3c:	de00012e 	bgeu	sp,et,81107c44 <uliSyncGetMbt+0xc>
81107c40:	003b68fa 	trap	3
81107c44:	dfc00215 	stw	ra,8(sp)
81107c48:	df000115 	stw	fp,4(sp)
81107c4c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
81107c50:	01000104 	movi	r4,4
81107c54:	11086d40 	call	811086d4 <uliSyncReadReg>
81107c58:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107c5c:	e0bfff17 	ldw	r2,-4(fp)
}
81107c60:	e037883a 	mov	sp,fp
81107c64:	dfc00117 	ldw	ra,4(sp)
81107c68:	df000017 	ldw	fp,0(sp)
81107c6c:	dec00204 	addi	sp,sp,8
81107c70:	f800283a 	ret

81107c74 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
81107c74:	defffd04 	addi	sp,sp,-12
81107c78:	de00012e 	bgeu	sp,et,81107c80 <uliSyncGetBt+0xc>
81107c7c:	003b68fa 	trap	3
81107c80:	dfc00215 	stw	ra,8(sp)
81107c84:	df000115 	stw	fp,4(sp)
81107c88:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
81107c8c:	01000144 	movi	r4,5
81107c90:	11086d40 	call	811086d4 <uliSyncReadReg>
81107c94:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107c98:	e0bfff17 	ldw	r2,-4(fp)
}
81107c9c:	e037883a 	mov	sp,fp
81107ca0:	dfc00117 	ldw	ra,4(sp)
81107ca4:	df000017 	ldw	fp,0(sp)
81107ca8:	dec00204 	addi	sp,sp,8
81107cac:	f800283a 	ret

81107cb0 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
81107cb0:	defffd04 	addi	sp,sp,-12
81107cb4:	de00012e 	bgeu	sp,et,81107cbc <uliSyncGetPer+0xc>
81107cb8:	003b68fa 	trap	3
81107cbc:	dfc00215 	stw	ra,8(sp)
81107cc0:	df000115 	stw	fp,4(sp)
81107cc4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
81107cc8:	01000184 	movi	r4,6
81107ccc:	11086d40 	call	811086d4 <uliSyncReadReg>
81107cd0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107cd4:	e0bfff17 	ldw	r2,-4(fp)
}
81107cd8:	e037883a 	mov	sp,fp
81107cdc:	dfc00117 	ldw	ra,4(sp)
81107ce0:	df000017 	ldw	fp,0(sp)
81107ce4:	dec00204 	addi	sp,sp,8
81107ce8:	f800283a 	ret

81107cec <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
81107cec:	defffd04 	addi	sp,sp,-12
81107cf0:	de00012e 	bgeu	sp,et,81107cf8 <uliSyncGetOst+0xc>
81107cf4:	003b68fa 	trap	3
81107cf8:	dfc00215 	stw	ra,8(sp)
81107cfc:	df000115 	stw	fp,4(sp)
81107d00:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
81107d04:	010001c4 	movi	r4,7
81107d08:	11086d40 	call	811086d4 <uliSyncReadReg>
81107d0c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107d10:	e0bfff17 	ldw	r2,-4(fp)
}
81107d14:	e037883a 	mov	sp,fp
81107d18:	dfc00117 	ldw	ra,4(sp)
81107d1c:	df000017 	ldw	fp,0(sp)
81107d20:	dec00204 	addi	sp,sp,8
81107d24:	f800283a 	ret

81107d28 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
81107d28:	defffd04 	addi	sp,sp,-12
81107d2c:	de00012e 	bgeu	sp,et,81107d34 <uliSyncGetGeneral+0xc>
81107d30:	003b68fa 	trap	3
81107d34:	dfc00215 	stw	ra,8(sp)
81107d38:	df000115 	stw	fp,4(sp)
81107d3c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
81107d40:	01000204 	movi	r4,8
81107d44:	11086d40 	call	811086d4 <uliSyncReadReg>
81107d48:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81107d4c:	e0bfff17 	ldw	r2,-4(fp)
}
81107d50:	e037883a 	mov	sp,fp
81107d54:	dfc00117 	ldw	ra,4(sp)
81107d58:	df000017 	ldw	fp,0(sp)
81107d5c:	dec00204 	addi	sp,sp,8
81107d60:	f800283a 	ret

81107d64 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
81107d64:	defffd04 	addi	sp,sp,-12
81107d68:	de00012e 	bgeu	sp,et,81107d70 <bSyncErrInj+0xc>
81107d6c:	003b68fa 	trap	3
81107d70:	dfc00215 	stw	ra,8(sp)
81107d74:	df000115 	stw	fp,4(sp)
81107d78:	df000104 	addi	fp,sp,4
81107d7c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
81107d80:	e17fff17 	ldw	r5,-4(fp)
81107d84:	01000244 	movi	r4,9
81107d88:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107d8c:	00800044 	movi	r2,1
}
81107d90:	e037883a 	mov	sp,fp
81107d94:	dfc00117 	ldw	ra,4(sp)
81107d98:	df000017 	ldw	fp,0(sp)
81107d9c:	dec00204 	addi	sp,sp,8
81107da0:	f800283a 	ret

81107da4 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
81107da4:	defffc04 	addi	sp,sp,-16
81107da8:	de00012e 	bgeu	sp,et,81107db0 <bSyncCtrExtnIrq+0xc>
81107dac:	003b68fa 	trap	3
81107db0:	dfc00315 	stw	ra,12(sp)
81107db4:	df000215 	stw	fp,8(sp)
81107db8:	df000204 	addi	fp,sp,8
81107dbc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107dc0:	01000284 	movi	r4,10
81107dc4:	11086d40 	call	811086d4 <uliSyncReadReg>
81107dc8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107dcc:	e0bfff17 	ldw	r2,-4(fp)
81107dd0:	1000061e 	bne	r2,zero,81107dec <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
81107dd4:	e0fffe17 	ldw	r3,-8(fp)
81107dd8:	00a00034 	movhi	r2,32768
81107ddc:	10bfffc4 	addi	r2,r2,-1
81107de0:	1884703a 	and	r2,r3,r2
81107de4:	e0bffe15 	stw	r2,-8(fp)
81107de8:	00000306 	br	81107df8 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
81107dec:	e0bffe17 	ldw	r2,-8(fp)
81107df0:	10a00034 	orhi	r2,r2,32768
81107df4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107df8:	e17ffe17 	ldw	r5,-8(fp)
81107dfc:	01000284 	movi	r4,10
81107e00:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107e04:	00800044 	movi	r2,1
}
81107e08:	e037883a 	mov	sp,fp
81107e0c:	dfc00117 	ldw	ra,4(sp)
81107e10:	df000017 	ldw	fp,0(sp)
81107e14:	dec00204 	addi	sp,sp,8
81107e18:	f800283a 	ret

81107e1c <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
81107e1c:	defffd04 	addi	sp,sp,-12
81107e20:	de00012e 	bgeu	sp,et,81107e28 <bSyncCtrStart+0xc>
81107e24:	003b68fa 	trap	3
81107e28:	dfc00215 	stw	ra,8(sp)
81107e2c:	df000115 	stw	fp,4(sp)
81107e30:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107e34:	01000284 	movi	r4,10
81107e38:	11086d40 	call	811086d4 <uliSyncReadReg>
81107e3c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
81107e40:	e0bfff17 	ldw	r2,-4(fp)
81107e44:	10800234 	orhi	r2,r2,8
81107e48:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107e4c:	e17fff17 	ldw	r5,-4(fp)
81107e50:	01000284 	movi	r4,10
81107e54:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107e58:	00800044 	movi	r2,1
}
81107e5c:	e037883a 	mov	sp,fp
81107e60:	dfc00117 	ldw	ra,4(sp)
81107e64:	df000017 	ldw	fp,0(sp)
81107e68:	dec00204 	addi	sp,sp,8
81107e6c:	f800283a 	ret

81107e70 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
81107e70:	defffd04 	addi	sp,sp,-12
81107e74:	de00012e 	bgeu	sp,et,81107e7c <bSyncCtrReset+0xc>
81107e78:	003b68fa 	trap	3
81107e7c:	dfc00215 	stw	ra,8(sp)
81107e80:	df000115 	stw	fp,4(sp)
81107e84:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107e88:	01000284 	movi	r4,10
81107e8c:	11086d40 	call	811086d4 <uliSyncReadReg>
81107e90:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
81107e94:	e0bfff17 	ldw	r2,-4(fp)
81107e98:	10800134 	orhi	r2,r2,4
81107e9c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107ea0:	e17fff17 	ldw	r5,-4(fp)
81107ea4:	01000284 	movi	r4,10
81107ea8:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107eac:	00800044 	movi	r2,1
}
81107eb0:	e037883a 	mov	sp,fp
81107eb4:	dfc00117 	ldw	ra,4(sp)
81107eb8:	df000017 	ldw	fp,0(sp)
81107ebc:	dec00204 	addi	sp,sp,8
81107ec0:	f800283a 	ret

81107ec4 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
81107ec4:	defffd04 	addi	sp,sp,-12
81107ec8:	de00012e 	bgeu	sp,et,81107ed0 <bSyncCtrOneShot+0xc>
81107ecc:	003b68fa 	trap	3
81107ed0:	dfc00215 	stw	ra,8(sp)
81107ed4:	df000115 	stw	fp,4(sp)
81107ed8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107edc:	01000284 	movi	r4,10
81107ee0:	11086d40 	call	811086d4 <uliSyncReadReg>
81107ee4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
81107ee8:	e0bfff17 	ldw	r2,-4(fp)
81107eec:	108000b4 	orhi	r2,r2,2
81107ef0:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107ef4:	e17fff17 	ldw	r5,-4(fp)
81107ef8:	01000284 	movi	r4,10
81107efc:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107f00:	00800044 	movi	r2,1
}
81107f04:	e037883a 	mov	sp,fp
81107f08:	dfc00117 	ldw	ra,4(sp)
81107f0c:	df000017 	ldw	fp,0(sp)
81107f10:	dec00204 	addi	sp,sp,8
81107f14:	f800283a 	ret

81107f18 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
81107f18:	defffd04 	addi	sp,sp,-12
81107f1c:	de00012e 	bgeu	sp,et,81107f24 <bSyncCtrErrInj+0xc>
81107f20:	003b68fa 	trap	3
81107f24:	dfc00215 	stw	ra,8(sp)
81107f28:	df000115 	stw	fp,4(sp)
81107f2c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107f30:	01000284 	movi	r4,10
81107f34:	11086d40 	call	811086d4 <uliSyncReadReg>
81107f38:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
81107f3c:	e0bfff17 	ldw	r2,-4(fp)
81107f40:	10800074 	orhi	r2,r2,1
81107f44:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107f48:	e17fff17 	ldw	r5,-4(fp)
81107f4c:	01000284 	movi	r4,10
81107f50:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107f54:	00800044 	movi	r2,1
}
81107f58:	e037883a 	mov	sp,fp
81107f5c:	dfc00117 	ldw	ra,4(sp)
81107f60:	df000017 	ldw	fp,0(sp)
81107f64:	dec00204 	addi	sp,sp,8
81107f68:	f800283a 	ret

81107f6c <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
81107f6c:	defffc04 	addi	sp,sp,-16
81107f70:	de00012e 	bgeu	sp,et,81107f78 <bSyncCtrSyncOutEnable+0xc>
81107f74:	003b68fa 	trap	3
81107f78:	dfc00315 	stw	ra,12(sp)
81107f7c:	df000215 	stw	fp,8(sp)
81107f80:	df000204 	addi	fp,sp,8
81107f84:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107f88:	01000284 	movi	r4,10
81107f8c:	11086d40 	call	811086d4 <uliSyncReadReg>
81107f90:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81107f94:	e0bfff17 	ldw	r2,-4(fp)
81107f98:	1000051e 	bne	r2,zero,81107fb0 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
81107f9c:	e0fffe17 	ldw	r3,-8(fp)
81107fa0:	00bfbfc4 	movi	r2,-257
81107fa4:	1884703a 	and	r2,r3,r2
81107fa8:	e0bffe15 	stw	r2,-8(fp)
81107fac:	00000306 	br	81107fbc <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
81107fb0:	e0bffe17 	ldw	r2,-8(fp)
81107fb4:	10804014 	ori	r2,r2,256
81107fb8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81107fbc:	e17ffe17 	ldw	r5,-8(fp)
81107fc0:	01000284 	movi	r4,10
81107fc4:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81107fc8:	00800044 	movi	r2,1
}
81107fcc:	e037883a 	mov	sp,fp
81107fd0:	dfc00117 	ldw	ra,4(sp)
81107fd4:	df000017 	ldw	fp,0(sp)
81107fd8:	dec00204 	addi	sp,sp,8
81107fdc:	f800283a 	ret

81107fe0 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
81107fe0:	defffc04 	addi	sp,sp,-16
81107fe4:	de00012e 	bgeu	sp,et,81107fec <bSyncCtrCh1OutEnable+0xc>
81107fe8:	003b68fa 	trap	3
81107fec:	dfc00315 	stw	ra,12(sp)
81107ff0:	df000215 	stw	fp,8(sp)
81107ff4:	df000204 	addi	fp,sp,8
81107ff8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81107ffc:	01000284 	movi	r4,10
81108000:	11086d40 	call	811086d4 <uliSyncReadReg>
81108004:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108008:	e0bfff17 	ldw	r2,-4(fp)
8110800c:	1000051e 	bne	r2,zero,81108024 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
81108010:	e0fffe17 	ldw	r3,-8(fp)
81108014:	00bfff84 	movi	r2,-2
81108018:	1884703a 	and	r2,r3,r2
8110801c:	e0bffe15 	stw	r2,-8(fp)
81108020:	00000306 	br	81108030 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
81108024:	e0bffe17 	ldw	r2,-8(fp)
81108028:	10800054 	ori	r2,r2,1
8110802c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108030:	e17ffe17 	ldw	r5,-8(fp)
81108034:	01000284 	movi	r4,10
81108038:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
8110803c:	00800044 	movi	r2,1
}
81108040:	e037883a 	mov	sp,fp
81108044:	dfc00117 	ldw	ra,4(sp)
81108048:	df000017 	ldw	fp,0(sp)
8110804c:	dec00204 	addi	sp,sp,8
81108050:	f800283a 	ret

81108054 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
81108054:	defffc04 	addi	sp,sp,-16
81108058:	de00012e 	bgeu	sp,et,81108060 <bSyncCtrCh2OutEnable+0xc>
8110805c:	003b68fa 	trap	3
81108060:	dfc00315 	stw	ra,12(sp)
81108064:	df000215 	stw	fp,8(sp)
81108068:	df000204 	addi	fp,sp,8
8110806c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108070:	01000284 	movi	r4,10
81108074:	11086d40 	call	811086d4 <uliSyncReadReg>
81108078:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110807c:	e0bfff17 	ldw	r2,-4(fp)
81108080:	1000051e 	bne	r2,zero,81108098 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
81108084:	e0fffe17 	ldw	r3,-8(fp)
81108088:	00bfff44 	movi	r2,-3
8110808c:	1884703a 	and	r2,r3,r2
81108090:	e0bffe15 	stw	r2,-8(fp)
81108094:	00000306 	br	811080a4 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
81108098:	e0bffe17 	ldw	r2,-8(fp)
8110809c:	10800094 	ori	r2,r2,2
811080a0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
811080a4:	e17ffe17 	ldw	r5,-8(fp)
811080a8:	01000284 	movi	r4,10
811080ac:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
811080b0:	00800044 	movi	r2,1
}
811080b4:	e037883a 	mov	sp,fp
811080b8:	dfc00117 	ldw	ra,4(sp)
811080bc:	df000017 	ldw	fp,0(sp)
811080c0:	dec00204 	addi	sp,sp,8
811080c4:	f800283a 	ret

811080c8 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
811080c8:	defffc04 	addi	sp,sp,-16
811080cc:	de00012e 	bgeu	sp,et,811080d4 <bSyncCtrCh3OutEnable+0xc>
811080d0:	003b68fa 	trap	3
811080d4:	dfc00315 	stw	ra,12(sp)
811080d8:	df000215 	stw	fp,8(sp)
811080dc:	df000204 	addi	fp,sp,8
811080e0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
811080e4:	01000284 	movi	r4,10
811080e8:	11086d40 	call	811086d4 <uliSyncReadReg>
811080ec:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811080f0:	e0bfff17 	ldw	r2,-4(fp)
811080f4:	1000051e 	bne	r2,zero,8110810c <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
811080f8:	e0fffe17 	ldw	r3,-8(fp)
811080fc:	00bffec4 	movi	r2,-5
81108100:	1884703a 	and	r2,r3,r2
81108104:	e0bffe15 	stw	r2,-8(fp)
81108108:	00000306 	br	81108118 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110810c:	e0bffe17 	ldw	r2,-8(fp)
81108110:	10800114 	ori	r2,r2,4
81108114:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108118:	e17ffe17 	ldw	r5,-8(fp)
8110811c:	01000284 	movi	r4,10
81108120:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81108124:	00800044 	movi	r2,1
}
81108128:	e037883a 	mov	sp,fp
8110812c:	dfc00117 	ldw	ra,4(sp)
81108130:	df000017 	ldw	fp,0(sp)
81108134:	dec00204 	addi	sp,sp,8
81108138:	f800283a 	ret

8110813c <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110813c:	defffc04 	addi	sp,sp,-16
81108140:	de00012e 	bgeu	sp,et,81108148 <bSyncCtrCh4OutEnable+0xc>
81108144:	003b68fa 	trap	3
81108148:	dfc00315 	stw	ra,12(sp)
8110814c:	df000215 	stw	fp,8(sp)
81108150:	df000204 	addi	fp,sp,8
81108154:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108158:	01000284 	movi	r4,10
8110815c:	11086d40 	call	811086d4 <uliSyncReadReg>
81108160:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108164:	e0bfff17 	ldw	r2,-4(fp)
81108168:	1000051e 	bne	r2,zero,81108180 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110816c:	e0fffe17 	ldw	r3,-8(fp)
81108170:	00bffdc4 	movi	r2,-9
81108174:	1884703a 	and	r2,r3,r2
81108178:	e0bffe15 	stw	r2,-8(fp)
8110817c:	00000306 	br	8110818c <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
81108180:	e0bffe17 	ldw	r2,-8(fp)
81108184:	10800214 	ori	r2,r2,8
81108188:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110818c:	e17ffe17 	ldw	r5,-8(fp)
81108190:	01000284 	movi	r4,10
81108194:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81108198:	00800044 	movi	r2,1
}
8110819c:	e037883a 	mov	sp,fp
811081a0:	dfc00117 	ldw	ra,4(sp)
811081a4:	df000017 	ldw	fp,0(sp)
811081a8:	dec00204 	addi	sp,sp,8
811081ac:	f800283a 	ret

811081b0 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
811081b0:	defffc04 	addi	sp,sp,-16
811081b4:	de00012e 	bgeu	sp,et,811081bc <bSyncCtrCh5OutEnable+0xc>
811081b8:	003b68fa 	trap	3
811081bc:	dfc00315 	stw	ra,12(sp)
811081c0:	df000215 	stw	fp,8(sp)
811081c4:	df000204 	addi	fp,sp,8
811081c8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
811081cc:	01000284 	movi	r4,10
811081d0:	11086d40 	call	811086d4 <uliSyncReadReg>
811081d4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811081d8:	e0bfff17 	ldw	r2,-4(fp)
811081dc:	1000051e 	bne	r2,zero,811081f4 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
811081e0:	e0fffe17 	ldw	r3,-8(fp)
811081e4:	00bffbc4 	movi	r2,-17
811081e8:	1884703a 	and	r2,r3,r2
811081ec:	e0bffe15 	stw	r2,-8(fp)
811081f0:	00000306 	br	81108200 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
811081f4:	e0bffe17 	ldw	r2,-8(fp)
811081f8:	10800414 	ori	r2,r2,16
811081fc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108200:	e17ffe17 	ldw	r5,-8(fp)
81108204:	01000284 	movi	r4,10
81108208:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
8110820c:	00800044 	movi	r2,1
}
81108210:	e037883a 	mov	sp,fp
81108214:	dfc00117 	ldw	ra,4(sp)
81108218:	df000017 	ldw	fp,0(sp)
8110821c:	dec00204 	addi	sp,sp,8
81108220:	f800283a 	ret

81108224 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
81108224:	defffc04 	addi	sp,sp,-16
81108228:	de00012e 	bgeu	sp,et,81108230 <bSyncCtrCh6OutEnable+0xc>
8110822c:	003b68fa 	trap	3
81108230:	dfc00315 	stw	ra,12(sp)
81108234:	df000215 	stw	fp,8(sp)
81108238:	df000204 	addi	fp,sp,8
8110823c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108240:	01000284 	movi	r4,10
81108244:	11086d40 	call	811086d4 <uliSyncReadReg>
81108248:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110824c:	e0bfff17 	ldw	r2,-4(fp)
81108250:	1000051e 	bne	r2,zero,81108268 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
81108254:	e0fffe17 	ldw	r3,-8(fp)
81108258:	00bff7c4 	movi	r2,-33
8110825c:	1884703a 	and	r2,r3,r2
81108260:	e0bffe15 	stw	r2,-8(fp)
81108264:	00000306 	br	81108274 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
81108268:	e0bffe17 	ldw	r2,-8(fp)
8110826c:	10800814 	ori	r2,r2,32
81108270:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
81108274:	e17ffe17 	ldw	r5,-8(fp)
81108278:	01000284 	movi	r4,10
8110827c:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81108280:	00800044 	movi	r2,1
}
81108284:	e037883a 	mov	sp,fp
81108288:	dfc00117 	ldw	ra,4(sp)
8110828c:	df000017 	ldw	fp,0(sp)
81108290:	dec00204 	addi	sp,sp,8
81108294:	f800283a 	ret

81108298 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
81108298:	defffc04 	addi	sp,sp,-16
8110829c:	de00012e 	bgeu	sp,et,811082a4 <bSyncCtrCh7OutEnable+0xc>
811082a0:	003b68fa 	trap	3
811082a4:	dfc00315 	stw	ra,12(sp)
811082a8:	df000215 	stw	fp,8(sp)
811082ac:	df000204 	addi	fp,sp,8
811082b0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
811082b4:	01000284 	movi	r4,10
811082b8:	11086d40 	call	811086d4 <uliSyncReadReg>
811082bc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811082c0:	e0bfff17 	ldw	r2,-4(fp)
811082c4:	1000051e 	bne	r2,zero,811082dc <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
811082c8:	e0fffe17 	ldw	r3,-8(fp)
811082cc:	00bfefc4 	movi	r2,-65
811082d0:	1884703a 	and	r2,r3,r2
811082d4:	e0bffe15 	stw	r2,-8(fp)
811082d8:	00000306 	br	811082e8 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
811082dc:	e0bffe17 	ldw	r2,-8(fp)
811082e0:	10801014 	ori	r2,r2,64
811082e4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
811082e8:	e17ffe17 	ldw	r5,-8(fp)
811082ec:	01000284 	movi	r4,10
811082f0:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
811082f4:	00800044 	movi	r2,1
}
811082f8:	e037883a 	mov	sp,fp
811082fc:	dfc00117 	ldw	ra,4(sp)
81108300:	df000017 	ldw	fp,0(sp)
81108304:	dec00204 	addi	sp,sp,8
81108308:	f800283a 	ret

8110830c <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110830c:	defffc04 	addi	sp,sp,-16
81108310:	de00012e 	bgeu	sp,et,81108318 <bSyncCtrCh8OutEnable+0xc>
81108314:	003b68fa 	trap	3
81108318:	dfc00315 	stw	ra,12(sp)
8110831c:	df000215 	stw	fp,8(sp)
81108320:	df000204 	addi	fp,sp,8
81108324:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108328:	01000284 	movi	r4,10
8110832c:	11086d40 	call	811086d4 <uliSyncReadReg>
81108330:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108334:	e0bfff17 	ldw	r2,-4(fp)
81108338:	1000051e 	bne	r2,zero,81108350 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110833c:	e0fffe17 	ldw	r3,-8(fp)
81108340:	00bfdfc4 	movi	r2,-129
81108344:	1884703a 	and	r2,r3,r2
81108348:	e0bffe15 	stw	r2,-8(fp)
8110834c:	00000306 	br	8110835c <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
81108350:	e0bffe17 	ldw	r2,-8(fp)
81108354:	10802014 	ori	r2,r2,128
81108358:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110835c:	e17ffe17 	ldw	r5,-8(fp)
81108360:	01000284 	movi	r4,10
81108364:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81108368:	00800044 	movi	r2,1
}
8110836c:	e037883a 	mov	sp,fp
81108370:	dfc00117 	ldw	ra,4(sp)
81108374:	df000017 	ldw	fp,0(sp)
81108378:	dec00204 	addi	sp,sp,8
8110837c:	f800283a 	ret

81108380 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
81108380:	defffc04 	addi	sp,sp,-16
81108384:	de00012e 	bgeu	sp,et,8110838c <bSyncIrqEnableError+0xc>
81108388:	003b68fa 	trap	3
8110838c:	dfc00315 	stw	ra,12(sp)
81108390:	df000215 	stw	fp,8(sp)
81108394:	df000204 	addi	fp,sp,8
81108398:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110839c:	01000044 	movi	r4,1
811083a0:	11086d40 	call	811086d4 <uliSyncReadReg>
811083a4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
811083a8:	e0bfff17 	ldw	r2,-4(fp)
811083ac:	1000051e 	bne	r2,zero,811083c4 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
811083b0:	e0fffe17 	ldw	r3,-8(fp)
811083b4:	00bfff44 	movi	r2,-3
811083b8:	1884703a 	and	r2,r3,r2
811083bc:	e0bffe15 	stw	r2,-8(fp)
811083c0:	00000306 	br	811083d0 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
811083c4:	e0bffe17 	ldw	r2,-8(fp)
811083c8:	10800094 	ori	r2,r2,2
811083cc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
811083d0:	e17ffe17 	ldw	r5,-8(fp)
811083d4:	01000044 	movi	r4,1
811083d8:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
811083dc:	00800044 	movi	r2,1
}
811083e0:	e037883a 	mov	sp,fp
811083e4:	dfc00117 	ldw	ra,4(sp)
811083e8:	df000017 	ldw	fp,0(sp)
811083ec:	dec00204 	addi	sp,sp,8
811083f0:	f800283a 	ret

811083f4 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
811083f4:	defffc04 	addi	sp,sp,-16
811083f8:	de00012e 	bgeu	sp,et,81108400 <bSyncIrqEnableBlank+0xc>
811083fc:	003b68fa 	trap	3
81108400:	dfc00315 	stw	ra,12(sp)
81108404:	df000215 	stw	fp,8(sp)
81108408:	df000204 	addi	fp,sp,8
8110840c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
81108410:	01000044 	movi	r4,1
81108414:	11086d40 	call	811086d4 <uliSyncReadReg>
81108418:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110841c:	e0bfff17 	ldw	r2,-4(fp)
81108420:	1000051e 	bne	r2,zero,81108438 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
81108424:	e0fffe17 	ldw	r3,-8(fp)
81108428:	00bfff84 	movi	r2,-2
8110842c:	1884703a 	and	r2,r3,r2
81108430:	e0bffe15 	stw	r2,-8(fp)
81108434:	00000306 	br	81108444 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
81108438:	e0bffe17 	ldw	r2,-8(fp)
8110843c:	10800054 	ori	r2,r2,1
81108440:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
81108444:	e17ffe17 	ldw	r5,-8(fp)
81108448:	01000044 	movi	r4,1
8110844c:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81108450:	00800044 	movi	r2,1
}
81108454:	e037883a 	mov	sp,fp
81108458:	dfc00117 	ldw	ra,4(sp)
8110845c:	df000017 	ldw	fp,0(sp)
81108460:	dec00204 	addi	sp,sp,8
81108464:	f800283a 	ret

81108468 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
81108468:	defffc04 	addi	sp,sp,-16
8110846c:	de00012e 	bgeu	sp,et,81108474 <bSyncIrqFlagClrError+0xc>
81108470:	003b68fa 	trap	3
81108474:	dfc00315 	stw	ra,12(sp)
81108478:	df000215 	stw	fp,8(sp)
8110847c:	df000204 	addi	fp,sp,8
81108480:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
81108484:	01000084 	movi	r4,2
81108488:	11086d40 	call	811086d4 <uliSyncReadReg>
8110848c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108490:	e0bfff17 	ldw	r2,-4(fp)
81108494:	1000051e 	bne	r2,zero,811084ac <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
81108498:	e0fffe17 	ldw	r3,-8(fp)
8110849c:	00bfff44 	movi	r2,-3
811084a0:	1884703a 	and	r2,r3,r2
811084a4:	e0bffe15 	stw	r2,-8(fp)
811084a8:	00000306 	br	811084b8 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
811084ac:	e0bffe17 	ldw	r2,-8(fp)
811084b0:	10800094 	ori	r2,r2,2
811084b4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
811084b8:	e17ffe17 	ldw	r5,-8(fp)
811084bc:	01000084 	movi	r4,2
811084c0:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
811084c4:	00800044 	movi	r2,1
}
811084c8:	e037883a 	mov	sp,fp
811084cc:	dfc00117 	ldw	ra,4(sp)
811084d0:	df000017 	ldw	fp,0(sp)
811084d4:	dec00204 	addi	sp,sp,8
811084d8:	f800283a 	ret

811084dc <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
811084dc:	defffc04 	addi	sp,sp,-16
811084e0:	de00012e 	bgeu	sp,et,811084e8 <bSyncIrqFlagClrBlank+0xc>
811084e4:	003b68fa 	trap	3
811084e8:	dfc00315 	stw	ra,12(sp)
811084ec:	df000215 	stw	fp,8(sp)
811084f0:	df000204 	addi	fp,sp,8
811084f4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
811084f8:	01000084 	movi	r4,2
811084fc:	11086d40 	call	811086d4 <uliSyncReadReg>
81108500:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
81108504:	e0bfff17 	ldw	r2,-4(fp)
81108508:	1000051e 	bne	r2,zero,81108520 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110850c:	e0fffe17 	ldw	r3,-8(fp)
81108510:	00bfff84 	movi	r2,-2
81108514:	1884703a 	and	r2,r3,r2
81108518:	e0bffe15 	stw	r2,-8(fp)
8110851c:	00000306 	br	8110852c <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
81108520:	e0bffe17 	ldw	r2,-8(fp)
81108524:	10800054 	ori	r2,r2,1
81108528:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110852c:	e17ffe17 	ldw	r5,-8(fp)
81108530:	01000084 	movi	r4,2
81108534:	11086780 	call	81108678 <bSyncWriteReg>
	return TRUE;
81108538:	00800044 	movi	r2,1
}
8110853c:	e037883a 	mov	sp,fp
81108540:	dfc00117 	ldw	ra,4(sp)
81108544:	df000017 	ldw	fp,0(sp)
81108548:	dec00204 	addi	sp,sp,8
8110854c:	f800283a 	ret

81108550 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
81108550:	defffc04 	addi	sp,sp,-16
81108554:	de00012e 	bgeu	sp,et,8110855c <bSyncIrqFlagError+0xc>
81108558:	003b68fa 	trap	3
8110855c:	dfc00315 	stw	ra,12(sp)
81108560:	df000215 	stw	fp,8(sp)
81108564:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
81108568:	010000c4 	movi	r4,3
8110856c:	11086d40 	call	811086d4 <uliSyncReadReg>
81108570:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
81108574:	e0bfff17 	ldw	r2,-4(fp)
81108578:	1080008c 	andi	r2,r2,2
8110857c:	10000326 	beq	r2,zero,8110858c <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
81108580:	00800044 	movi	r2,1
81108584:	e0bffe15 	stw	r2,-8(fp)
81108588:	00000106 	br	81108590 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110858c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
81108590:	e0bffe17 	ldw	r2,-8(fp)
}
81108594:	e037883a 	mov	sp,fp
81108598:	dfc00117 	ldw	ra,4(sp)
8110859c:	df000017 	ldw	fp,0(sp)
811085a0:	dec00204 	addi	sp,sp,8
811085a4:	f800283a 	ret

811085a8 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
811085a8:	defffc04 	addi	sp,sp,-16
811085ac:	de00012e 	bgeu	sp,et,811085b4 <bSyncIrqFlagBlank+0xc>
811085b0:	003b68fa 	trap	3
811085b4:	dfc00315 	stw	ra,12(sp)
811085b8:	df000215 	stw	fp,8(sp)
811085bc:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
811085c0:	010000c4 	movi	r4,3
811085c4:	11086d40 	call	811086d4 <uliSyncReadReg>
811085c8:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
811085cc:	e0bfff17 	ldw	r2,-4(fp)
811085d0:	1080004c 	andi	r2,r2,1
811085d4:	10000326 	beq	r2,zero,811085e4 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
811085d8:	00800044 	movi	r2,1
811085dc:	e0bffe15 	stw	r2,-8(fp)
811085e0:	00000106 	br	811085e8 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
811085e4:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
811085e8:	e0bffe17 	ldw	r2,-8(fp)
}
811085ec:	e037883a 	mov	sp,fp
811085f0:	dfc00117 	ldw	ra,4(sp)
811085f4:	df000017 	ldw	fp,0(sp)
811085f8:	dec00204 	addi	sp,sp,8
811085fc:	f800283a 	ret

81108600 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
81108600:	defffd04 	addi	sp,sp,-12
81108604:	de00012e 	bgeu	sp,et,8110860c <uliSyncGetCtr+0xc>
81108608:	003b68fa 	trap	3
8110860c:	dfc00215 	stw	ra,8(sp)
81108610:	df000115 	stw	fp,4(sp)
81108614:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
81108618:	01000284 	movi	r4,10
8110861c:	11086d40 	call	811086d4 <uliSyncReadReg>
81108620:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
81108624:	e0bfff17 	ldw	r2,-4(fp)
}
81108628:	e037883a 	mov	sp,fp
8110862c:	dfc00117 	ldw	ra,4(sp)
81108630:	df000017 	ldw	fp,0(sp)
81108634:	dec00204 	addi	sp,sp,8
81108638:	f800283a 	ret

8110863c <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110863c:	defffd04 	addi	sp,sp,-12
81108640:	de00012e 	bgeu	sp,et,81108648 <uliSyncReadStatus+0xc>
81108644:	003b68fa 	trap	3
81108648:	dfc00215 	stw	ra,8(sp)
8110864c:	df000115 	stw	fp,4(sp)
81108650:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
81108654:	0009883a 	mov	r4,zero
81108658:	11086d40 	call	811086d4 <uliSyncReadReg>
8110865c:	e0bfff15 	stw	r2,-4(fp)
	return aux;
81108660:	e0bfff17 	ldw	r2,-4(fp)
}
81108664:	e037883a 	mov	sp,fp
81108668:	dfc00117 	ldw	ra,4(sp)
8110866c:	df000017 	ldw	fp,0(sp)
81108670:	dec00204 	addi	sp,sp,8
81108674:	f800283a 	ret

81108678 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
static bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
81108678:	defffc04 	addi	sp,sp,-16
8110867c:	de00012e 	bgeu	sp,et,81108684 <bSyncWriteReg+0xc>
81108680:	003b68fa 	trap	3
81108684:	df000315 	stw	fp,12(sp)
81108688:	df000304 	addi	fp,sp,12
8110868c:	e13ffe15 	stw	r4,-8(fp)
81108690:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
81108694:	00a00034 	movhi	r2,32768
81108698:	10810004 	addi	r2,r2,1024
8110869c:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
811086a0:	e0bffe17 	ldw	r2,-8(fp)
811086a4:	1085883a 	add	r2,r2,r2
811086a8:	1085883a 	add	r2,r2,r2
811086ac:	1007883a 	mov	r3,r2
811086b0:	e0bffd17 	ldw	r2,-12(fp)
811086b4:	10c5883a 	add	r2,r2,r3
811086b8:	e0ffff17 	ldw	r3,-4(fp)
811086bc:	10c00015 	stw	r3,0(r2)
	return TRUE;
811086c0:	00800044 	movi	r2,1
}
811086c4:	e037883a 	mov	sp,fp
811086c8:	df000017 	ldw	fp,0(sp)
811086cc:	dec00104 	addi	sp,sp,4
811086d0:	f800283a 	ret

811086d4 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
static alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
811086d4:	defffc04 	addi	sp,sp,-16
811086d8:	de00012e 	bgeu	sp,et,811086e0 <uliSyncReadReg+0xc>
811086dc:	003b68fa 	trap	3
811086e0:	df000315 	stw	fp,12(sp)
811086e4:	df000304 	addi	fp,sp,12
811086e8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
811086ec:	00a00034 	movhi	r2,32768
811086f0:	10810004 	addi	r2,r2,1024
811086f4:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
811086f8:	e0bfff17 	ldw	r2,-4(fp)
811086fc:	1085883a 	add	r2,r2,r2
81108700:	1085883a 	add	r2,r2,r2
81108704:	1007883a 	mov	r3,r2
81108708:	e0bffd17 	ldw	r2,-12(fp)
8110870c:	10c5883a 	add	r2,r2,r3
81108710:	10800017 	ldw	r2,0(r2)
81108714:	e0bffe15 	stw	r2,-8(fp)
	return value;
81108718:	e0bffe17 	ldw	r2,-8(fp)
}
8110871c:	e037883a 	mov	sp,fp
81108720:	df000017 	ldw	fp,0(sp)
81108724:	dec00104 	addi	sp,sp,4
81108728:	f800283a 	ret

8110872c <vDataControlTask>:


#include "data_control_task.h"


void vDataControlTask(void *task_data) {
8110872c:	defffb04 	addi	sp,sp,-20
81108730:	de00012e 	bgeu	sp,et,81108738 <vDataControlTask+0xc>
81108734:	003b68fa 	trap	3
81108738:	dfc00415 	stw	ra,16(sp)
8110873c:	df000315 	stw	fp,12(sp)
81108740:	df000304 	addi	fp,sp,12
81108744:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
81108748:	e03ffd15 	stw	zero,-12(fp)
	TNData_Control *pxDataC;
	INT8U error_code;


	pxDataC = (TNData_Control *) task_data;
8110874c:	e0bfff17 	ldw	r2,-4(fp)
81108750:	e0bffe15 	stw	r2,-8(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
81108754:	d0a05517 	ldw	r2,-32428(gp)
81108758:	100f883a 	mov	r7,r2
8110875c:	01800804 	movi	r6,32
81108760:	01400044 	movi	r5,1
81108764:	01204534 	movhi	r4,33044
81108768:	21098404 	addi	r4,r4,9744
8110876c:	11172b80 	call	811172b8 <fwrite>
    #endif

	for (;;) {
		OSTimeDlyHMSM(0, 0, 0, 500);; /*todo:Tirar depois do debug*/
81108770:	01c07d04 	movi	r7,500
81108774:	000d883a 	mov	r6,zero
81108778:	000b883a 	mov	r5,zero
8110877c:	0009883a 	mov	r4,zero
81108780:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
	}
81108784:	003ffa06 	br	81108770 <__reset+0xfb0e8770>

81108788 <vFeeTask>:

#include "fee_task.h"



void vFeeTask(void *task_data) {
81108788:	defffa04 	addi	sp,sp,-24
8110878c:	de00012e 	bgeu	sp,et,81108794 <vFeeTask+0xc>
81108790:	003b68fa 	trap	3
81108794:	dfc00515 	stw	ra,20(sp)
81108798:	df000415 	stw	fp,16(sp)
8110879c:	df000404 	addi	fp,sp,16
811087a0:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
811087a4:	e03ffc15 	stw	zero,-16(fp)
	static TNFee *pxNFee;
	INT8U error_code;
	tQMask uiCmdFEE;


	pxNFee = ( TNFee * ) task_data;
811087a8:	e0bfff17 	ldw	r2,-4(fp)
811087ac:	d0a04b15 	stw	r2,-32468(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
811087b0:	d0e05517 	ldw	r3,-32428(gp)
811087b4:	d0a04b17 	ldw	r2,-32468(gp)
811087b8:	10800003 	ldbu	r2,0(r2)
811087bc:	10803fcc 	andi	r2,r2,255
811087c0:	100d883a 	mov	r6,r2
811087c4:	01604534 	movhi	r5,33044
811087c8:	29498d04 	addi	r5,r5,9780
811087cc:	1809883a 	mov	r4,r3
811087d0:	1116c1c0 	call	81116c1c <fprintf>
		//debug(fp,"NFEE Task. (Task on)\n");
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
811087d4:	d0a04b17 	ldw	r2,-32468(gp)
811087d8:	1009883a 	mov	r4,r2
811087dc:	1108e5c0 	call	81108e5c <vPrintConsoleNFee>
	#endif

	for(;;){

		switch ( pxNFee->xControl.eMode ) {
811087e0:	d0a04b17 	ldw	r2,-32468(gp)
811087e4:	10802817 	ldw	r2,160(r2)
811087e8:	10c00328 	cmpgeui	r3,r2,12
811087ec:	1800b31e 	bne	r3,zero,81108abc <vFeeTask+0x334>
811087f0:	100690ba 	slli	r3,r2,2
811087f4:	00a04474 	movhi	r2,33041
811087f8:	10a20204 	addi	r2,r2,-30712
811087fc:	1885883a 	add	r2,r3,r2
81108800:	10800017 	ldw	r2,0(r2)
81108804:	1000683a 	jmp	r2
81108808:	81108838 	rdprs	r4,r16,16928
8110880c:	811088c8 	cmpgei	r4,r16,16931
81108810:	81108928 	cmpgeui	r4,r16,16932
81108814:	811089bc 	xorhi	r4,r16,16934
81108818:	81108abc 	xorhi	r4,r16,16938
8110881c:	81108a5c 	xori	r4,r16,16937
81108820:	81108abc 	xorhi	r4,r16,16938
81108824:	81108abc 	xorhi	r4,r16,16938
81108828:	81108abc 	xorhi	r4,r16,16938
8110882c:	81108848 	cmpgei	r4,r16,16929
81108830:	81108938 	rdprs	r4,r16,16932
81108834:	81108a1c 	xori	r4,r16,16936
			case sFeeInit:

				pxNFee->xControl.eMode = sToFeeConfig;
81108838:	d0a04b17 	ldw	r2,-32468(gp)
8110883c:	00c00244 	movi	r3,9
81108840:	10c02815 	stw	r3,160(r2)

				break;
81108844:	0000af06 	br	81108b04 <vFeeTask+0x37c>
			case sToFeeConfig: /* Transition */

				/* Desabilitar interrupes do buffer duplo */
				/* Limpar interrupes, zerar buffer duplo */

				pxNFee->xControl.bSimulating = FALSE;
81108848:	d0a04b17 	ldw	r2,-32468(gp)
8110884c:	10002615 	stw	zero,152(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
81108850:	d0a04b17 	ldw	r2,-32468(gp)
81108854:	10002215 	stw	zero,136(r2)

				/* Disable the link SPW */
				//todo: tratar retorno
				bSpwcGetLink(&pxNFee->xChannel.xSpacewire);
81108858:	d0a04b17 	ldw	r2,-32468(gp)
8110885c:	10808304 	addi	r2,r2,524
81108860:	1009883a 	mov	r4,r2
81108864:	11052cc0 	call	811052cc <bSpwcGetLink>
				pxNFee->xChannel.xSpacewire.xLinkConfig.bStart = FALSE;
81108868:	d0a04b17 	ldw	r2,-32468(gp)
8110886c:	10008515 	stw	zero,532(r2)
				pxNFee->xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81108870:	d0a04b17 	ldw	r2,-32468(gp)
81108874:	10008415 	stw	zero,528(r2)
				pxNFee->xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81108878:	d0a04b17 	ldw	r2,-32468(gp)
8110887c:	00c00044 	movi	r3,1
81108880:	10c08615 	stw	r3,536(r2)
				bSpwcSetLink(&pxNFee->xChannel.xSpacewire);
81108884:	d0a04b17 	ldw	r2,-32468(gp)
81108888:	10808304 	addi	r2,r2,524
8110888c:	1009883a 	mov	r4,r2
81108890:	11051cc0 	call	811051cc <bSpwcSetLink>

				//todo:Back
				//bSpwcClearTimecode(&pxNFee->xChannel.xSpacewire);

				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Going to Config mode\n", pxNFee->ucId);
81108894:	d0e05517 	ldw	r3,-32428(gp)
81108898:	d0a04b17 	ldw	r2,-32468(gp)
8110889c:	10800003 	ldbu	r2,0(r2)
811088a0:	10803fcc 	andi	r2,r2,255
811088a4:	100d883a 	mov	r6,r2
811088a8:	01604534 	movhi	r5,33044
811088ac:	29499404 	addi	r5,r5,9808
811088b0:	1809883a 	mov	r4,r3
811088b4:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				pxNFee->xControl.eMode = sFeeConfig;
811088b8:	d0a04b17 	ldw	r2,-32468(gp)
811088bc:	00c00044 	movi	r3,1
811088c0:	10c02815 	stw	r3,160(r2)
				break;
811088c4:	00008f06 	br	81108b04 <vFeeTask+0x37c>
			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
811088c8:	d0a04b17 	ldw	r2,-32468(gp)
811088cc:	10800003 	ldbu	r2,0(r2)
811088d0:	10c03fcc 	andi	r3,r2,255
811088d4:	00a04574 	movhi	r2,33045
811088d8:	10974904 	addi	r2,r2,23844
811088dc:	18c7883a 	add	r3,r3,r3
811088e0:	18c7883a 	add	r3,r3,r3
811088e4:	10c5883a 	add	r2,r2,r3
811088e8:	10800017 	ldw	r2,0(r2)
811088ec:	e0fffd04 	addi	r3,fp,-12
811088f0:	180d883a 	mov	r6,r3
811088f4:	000b883a 	mov	r5,zero
811088f8:	1009883a 	mov	r4,r2
811088fc:	1133e000 	call	81133e00 <OSQPend>
81108900:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
81108904:	e0bffd03 	ldbu	r2,-12(fp)
81108908:	10803fcc 	andi	r2,r2,255
8110890c:	1000781e 	bne	r2,zero,81108af0 <vFeeTask+0x368>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
81108910:	d0a04b17 	ldw	r2,-32468(gp)
81108914:	e0fffe17 	ldw	r3,-8(fp)
81108918:	180b883a 	mov	r5,r3
8110891c:	1009883a 	mov	r4,r2
81108920:	1108b080 	call	81108b08 <vQCmdFEEinConfig>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
81108924:	00007206 	br	81108af0 <vFeeTask+0x368>
			case sFeeOn: /* Real mode */

				pxNFee->xControl.eMode = sToFeeStandBy;
81108928:	d0a04b17 	ldw	r2,-32468(gp)
8110892c:	00c00284 	movi	r3,10
81108930:	10c02815 	stw	r3,160(r2)
				break;
81108934:	00007306 	br	81108b04 <vFeeTask+0x37c>
			case sToFeeStandBy: /* Transition */

				pxNFee->xControl.bSimulating = TRUE;
81108938:	d0a04b17 	ldw	r2,-32468(gp)
8110893c:	00c00044 	movi	r3,1
81108940:	10c02615 	stw	r3,152(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
81108944:	d0a04b17 	ldw	r2,-32468(gp)
81108948:	10002215 	stw	zero,136(r2)
				/* Limpar interrupes, zerar buffer duplo */



				/* Enable link SPW the link SPW */
				bSpwcGetLink(&pxNFee->xChannel.xSpacewire);
8110894c:	d0a04b17 	ldw	r2,-32468(gp)
81108950:	10808304 	addi	r2,r2,524
81108954:	1009883a 	mov	r4,r2
81108958:	11052cc0 	call	811052cc <bSpwcGetLink>
				pxNFee->xChannel.xSpacewire.xLinkConfig.bStart = FALSE;
8110895c:	d0a04b17 	ldw	r2,-32468(gp)
81108960:	10008515 	stw	zero,532(r2)
				pxNFee->xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81108964:	d0a04b17 	ldw	r2,-32468(gp)
81108968:	00c00044 	movi	r3,1
8110896c:	10c08415 	stw	r3,528(r2)
				pxNFee->xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81108970:	d0a04b17 	ldw	r2,-32468(gp)
81108974:	10008615 	stw	zero,536(r2)
				bSpwcSetLink(&pxNFee->xChannel.xSpacewire);
81108978:	d0a04b17 	ldw	r2,-32468(gp)
8110897c:	10808304 	addi	r2,r2,524
81108980:	1009883a 	mov	r4,r2
81108984:	11051cc0 	call	811051cc <bSpwcSetLink>




				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Going to Standby mode\n", pxNFee->ucId);
81108988:	d0e05517 	ldw	r3,-32428(gp)
8110898c:	d0a04b17 	ldw	r2,-32468(gp)
81108990:	10800003 	ldbu	r2,0(r2)
81108994:	10803fcc 	andi	r2,r2,255
81108998:	100d883a 	mov	r6,r2
8110899c:	01604534 	movhi	r5,33044
811089a0:	29499e04 	addi	r5,r5,9848
811089a4:	1809883a 	mov	r4,r3
811089a8:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				pxNFee->xControl.eMode = sFeeStandBy;
811089ac:	d0a04b17 	ldw	r2,-32468(gp)
811089b0:	00c000c4 	movi	r3,3
811089b4:	10c02815 	stw	r3,160(r2)
				break;
811089b8:	00005206 	br	81108b04 <vFeeTask+0x37c>
			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
811089bc:	d0a04b17 	ldw	r2,-32468(gp)
811089c0:	10800003 	ldbu	r2,0(r2)
811089c4:	10c03fcc 	andi	r3,r2,255
811089c8:	00a04574 	movhi	r2,33045
811089cc:	10974904 	addi	r2,r2,23844
811089d0:	18c7883a 	add	r3,r3,r3
811089d4:	18c7883a 	add	r3,r3,r3
811089d8:	10c5883a 	add	r2,r2,r3
811089dc:	10800017 	ldw	r2,0(r2)
811089e0:	e0fffd04 	addi	r3,fp,-12
811089e4:	180d883a 	mov	r6,r3
811089e8:	000b883a 	mov	r5,zero
811089ec:	1009883a 	mov	r4,r2
811089f0:	1133e000 	call	81133e00 <OSQPend>
811089f4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
811089f8:	e0bffd03 	ldbu	r2,-12(fp)
811089fc:	10803fcc 	andi	r2,r2,255
81108a00:	10003d1e 	bne	r2,zero,81108af8 <vFeeTask+0x370>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
81108a04:	d0a04b17 	ldw	r2,-32468(gp)
81108a08:	e0fffe17 	ldw	r3,-8(fp)
81108a0c:	180b883a 	mov	r5,r3
81108a10:	1009883a 	mov	r4,r2
81108a14:	1108b080 	call	81108b08 <vQCmdFEEinConfig>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
81108a18:	00003706 	br	81108af8 <vFeeTask+0x370>
			case sToTestFullPattern: /* Transition */

				pxNFee->xControl.bUsingDMA = TRUE;
81108a1c:	d0a04b17 	ldw	r2,-32468(gp)
81108a20:	00c00044 	movi	r3,1
81108a24:	10c02215 	stw	r3,136(r2)

				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Going to FULL Image Pattern mode\n", pxNFee->ucId);
81108a28:	d0e05517 	ldw	r3,-32428(gp)
81108a2c:	d0a04b17 	ldw	r2,-32468(gp)
81108a30:	10800003 	ldbu	r2,0(r2)
81108a34:	10803fcc 	andi	r2,r2,255
81108a38:	100d883a 	mov	r6,r2
81108a3c:	01604534 	movhi	r5,33044
81108a40:	2949a804 	addi	r5,r5,9888
81108a44:	1809883a 	mov	r4,r3
81108a48:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				pxNFee->xControl.eMode = sFeeTestFullPattern;
81108a4c:	d0a04b17 	ldw	r2,-32468(gp)
81108a50:	00c00144 	movi	r3,5
81108a54:	10c02815 	stw	r3,160(r2)
				break;
81108a58:	00002a06 	br	81108b04 <vFeeTask+0x37c>
			case sFeeTestFullPattern: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
81108a5c:	d0a04b17 	ldw	r2,-32468(gp)
81108a60:	10800003 	ldbu	r2,0(r2)
81108a64:	10c03fcc 	andi	r3,r2,255
81108a68:	00a04574 	movhi	r2,33045
81108a6c:	10974904 	addi	r2,r2,23844
81108a70:	18c7883a 	add	r3,r3,r3
81108a74:	18c7883a 	add	r3,r3,r3
81108a78:	10c5883a 	add	r2,r2,r3
81108a7c:	10800017 	ldw	r2,0(r2)
81108a80:	e0fffd04 	addi	r3,fp,-12
81108a84:	180d883a 	mov	r6,r3
81108a88:	000b883a 	mov	r5,zero
81108a8c:	1009883a 	mov	r4,r2
81108a90:	1133e000 	call	81133e00 <OSQPend>
81108a94:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
81108a98:	e0bffd03 	ldbu	r2,-12(fp)
81108a9c:	10803fcc 	andi	r2,r2,255
81108aa0:	1000171e 	bne	r2,zero,81108b00 <vFeeTask+0x378>

					vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
81108aa4:	d0a04b17 	ldw	r2,-32468(gp)
81108aa8:	e0fffe17 	ldw	r3,-8(fp)
81108aac:	180b883a 	mov	r5,r3
81108ab0:	1009883a 	mov	r4,r2
81108ab4:	1108d480 	call	81108d48 <vQCmdFEEinFullPattern>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
81108ab8:	00001106 	br	81108b00 <vFeeTask+0x378>
			default:
				pxNFee->xControl.eMode = sToFeeConfig;
81108abc:	d0a04b17 	ldw	r2,-32468(gp)
81108ac0:	00c00244 	movi	r3,9
81108ac4:	10c02815 	stw	r3,160(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
81108ac8:	d0e05517 	ldw	r3,-32428(gp)
81108acc:	d0a04b17 	ldw	r2,-32468(gp)
81108ad0:	10800003 	ldbu	r2,0(r2)
81108ad4:	10803fcc 	andi	r2,r2,255
81108ad8:	100d883a 	mov	r6,r2
81108adc:	01604534 	movhi	r5,33044
81108ae0:	2949b504 	addi	r5,r5,9940
81108ae4:	1809883a 	mov	r4,r3
81108ae8:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				break;
81108aec:	00000506 	br	81108b04 <vFeeTask+0x37c>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
81108af0:	0001883a 	nop
81108af4:	003f3a06 	br	811087e0 <__reset+0xfb0e87e0>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
81108af8:	0001883a 	nop
81108afc:	003f3806 	br	811087e0 <__reset+0xfb0e87e0>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
81108b00:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
81108b04:	003f3606 	br	811087e0 <__reset+0xfb0e87e0>

81108b08 <vQCmdFEEinConfig>:


}


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
81108b08:	defffb04 	addi	sp,sp,-20
81108b0c:	de00012e 	bgeu	sp,et,81108b14 <vQCmdFEEinConfig+0xc>
81108b10:	003b68fa 	trap	3
81108b14:	dfc00415 	stw	ra,16(sp)
81108b18:	df000315 	stw	fp,12(sp)
81108b1c:	df000304 	addi	fp,sp,12
81108b20:	e13ffe15 	stw	r4,-8(fp)
81108b24:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
81108b28:	e0bfff17 	ldw	r2,-4(fp)
81108b2c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
81108b30:	e0bffdc3 	ldbu	r2,-9(fp)
81108b34:	10c03fcc 	andi	r3,r2,255
81108b38:	e0bffe17 	ldw	r2,-8(fp)
81108b3c:	10800003 	ldbu	r2,0(r2)
81108b40:	10803fcc 	andi	r2,r2,255
81108b44:	10800444 	addi	r2,r2,17
81108b48:	1880341e 	bne	r3,r2,81108c1c <vQCmdFEEinConfig+0x114>

		switch (uiCmdFEEL.ucByte[2]) {
81108b4c:	e0bffd83 	ldbu	r2,-10(fp)
81108b50:	10803fcc 	andi	r2,r2,255
81108b54:	10c000a0 	cmpeqi	r3,r2,2
81108b58:	1800141e 	bne	r3,zero,81108bac <vQCmdFEEinConfig+0xa4>
81108b5c:	10c000c8 	cmpgei	r3,r2,3
81108b60:	1800031e 	bne	r3,zero,81108b70 <vQCmdFEEinConfig+0x68>
81108b64:	10800060 	cmpeqi	r2,r2,1
81108b68:	1000061e 	bne	r2,zero,81108b84 <vQCmdFEEinConfig+0x7c>
81108b6c:	00002106 	br	81108bf4 <vQCmdFEEinConfig+0xec>
81108b70:	10c00120 	cmpeqi	r3,r2,4
81108b74:	1800111e 	bne	r3,zero,81108bbc <vQCmdFEEinConfig+0xb4>
81108b78:	10800220 	cmpeqi	r2,r2,8
81108b7c:	1000131e 	bne	r2,zero,81108bcc <vQCmdFEEinConfig+0xc4>
81108b80:	00001c06 	br	81108bf4 <vQCmdFEEinConfig+0xec>
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
81108b84:	d0e05517 	ldw	r3,-32428(gp)
81108b88:	e0bffe17 	ldw	r2,-8(fp)
81108b8c:	10800003 	ldbu	r2,0(r2)
81108b90:	10803fcc 	andi	r2,r2,255
81108b94:	100d883a 	mov	r6,r2
81108b98:	01604534 	movhi	r5,33044
81108b9c:	2949c004 	addi	r5,r5,9984
81108ba0:	1809883a 	mov	r4,r3
81108ba4:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				break;
81108ba8:	00001c06 	br	81108c1c <vQCmdFEEinConfig+0x114>
			case M_FEE_RUN:
				pxNFeeP->xControl.eMode = sFeeOn;
81108bac:	e0bffe17 	ldw	r2,-8(fp)
81108bb0:	00c00084 	movi	r3,2
81108bb4:	10c02815 	stw	r3,160(r2)
				break;
81108bb8:	00001806 	br	81108c1c <vQCmdFEEinConfig+0x114>
			case M_FEE_STANDBY:
				pxNFeeP->xControl.eMode = sToFeeStandBy;
81108bbc:	e0bffe17 	ldw	r2,-8(fp)
81108bc0:	00c00284 	movi	r3,10
81108bc4:	10c02815 	stw	r3,160(r2)
				break;
81108bc8:	00001406 	br	81108c1c <vQCmdFEEinConfig+0x114>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
81108bcc:	d0e05517 	ldw	r3,-32428(gp)
81108bd0:	e0bffe17 	ldw	r2,-8(fp)
81108bd4:	10800003 	ldbu	r2,0(r2)
81108bd8:	10803fcc 	andi	r2,r2,255
81108bdc:	100d883a 	mov	r6,r2
81108be0:	01604534 	movhi	r5,33044
81108be4:	2949cb04 	addi	r5,r5,10028
81108be8:	1809883a 	mov	r4,r3
81108bec:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				break;
81108bf0:	00000a06 	br	81108c1c <vQCmdFEEinConfig+0x114>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
81108bf4:	d0e05517 	ldw	r3,-32428(gp)
81108bf8:	e0bffe17 	ldw	r2,-8(fp)
81108bfc:	10800003 	ldbu	r2,0(r2)
81108c00:	10803fcc 	andi	r2,r2,255
81108c04:	100d883a 	mov	r6,r2
81108c08:	01604534 	movhi	r5,33044
81108c0c:	2949dc04 	addi	r5,r5,10096
81108c10:	1809883a 	mov	r4,r3
81108c14:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				break;
81108c18:	0001883a 	nop
		}
	}
}
81108c1c:	0001883a 	nop
81108c20:	e037883a 	mov	sp,fp
81108c24:	dfc00117 	ldw	ra,4(sp)
81108c28:	df000017 	ldw	fp,0(sp)
81108c2c:	dec00204 	addi	sp,sp,8
81108c30:	f800283a 	ret

81108c34 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
81108c34:	defffb04 	addi	sp,sp,-20
81108c38:	de00012e 	bgeu	sp,et,81108c40 <vQCmdFEEinStandBy+0xc>
81108c3c:	003b68fa 	trap	3
81108c40:	dfc00415 	stw	ra,16(sp)
81108c44:	df000315 	stw	fp,12(sp)
81108c48:	df000304 	addi	fp,sp,12
81108c4c:	e13ffe15 	stw	r4,-8(fp)
81108c50:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
81108c54:	e0bfff17 	ldw	r2,-4(fp)
81108c58:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
81108c5c:	e0bffdc3 	ldbu	r2,-9(fp)
81108c60:	10c03fcc 	andi	r3,r2,255
81108c64:	e0bffe17 	ldw	r2,-8(fp)
81108c68:	10800003 	ldbu	r2,0(r2)
81108c6c:	10803fcc 	andi	r2,r2,255
81108c70:	10800444 	addi	r2,r2,17
81108c74:	18802e1e 	bne	r3,r2,81108d30 <vQCmdFEEinStandBy+0xfc>

		switch (uiCmdFEEL.ucByte[2]) {
81108c78:	e0bffd83 	ldbu	r2,-10(fp)
81108c7c:	10803fcc 	andi	r2,r2,255
81108c80:	10c000a0 	cmpeqi	r3,r2,2
81108c84:	18000e1e 	bne	r3,zero,81108cc0 <vQCmdFEEinStandBy+0x8c>
81108c88:	10c000c8 	cmpgei	r3,r2,3
81108c8c:	1800031e 	bne	r3,zero,81108c9c <vQCmdFEEinStandBy+0x68>
81108c90:	10800060 	cmpeqi	r2,r2,1
81108c94:	1000061e 	bne	r2,zero,81108cb0 <vQCmdFEEinStandBy+0x7c>
81108c98:	00001b06 	br	81108d08 <vQCmdFEEinStandBy+0xd4>
81108c9c:	10c00120 	cmpeqi	r3,r2,4
81108ca0:	18000b1e 	bne	r3,zero,81108cd0 <vQCmdFEEinStandBy+0x9c>
81108ca4:	10800220 	cmpeqi	r2,r2,8
81108ca8:	1000131e 	bne	r2,zero,81108cf8 <vQCmdFEEinStandBy+0xc4>
81108cac:	00001606 	br	81108d08 <vQCmdFEEinStandBy+0xd4>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.eMode = sToFeeConfig;
81108cb0:	e0bffe17 	ldw	r2,-8(fp)
81108cb4:	00c00244 	movi	r3,9
81108cb8:	10c02815 	stw	r3,160(r2)
				break;
81108cbc:	00001c06 	br	81108d30 <vQCmdFEEinStandBy+0xfc>
			case M_FEE_RUN:
				pxNFeeP->xControl.eMode = sFeeOn;
81108cc0:	e0bffe17 	ldw	r2,-8(fp)
81108cc4:	00c00084 	movi	r3,2
81108cc8:	10c02815 	stw	r3,160(r2)
				break;
81108ccc:	00001806 	br	81108d30 <vQCmdFEEinStandBy+0xfc>
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
81108cd0:	d0e05517 	ldw	r3,-32428(gp)
81108cd4:	e0bffe17 	ldw	r2,-8(fp)
81108cd8:	10800003 	ldbu	r2,0(r2)
81108cdc:	10803fcc 	andi	r2,r2,255
81108ce0:	100d883a 	mov	r6,r2
81108ce4:	01604534 	movhi	r5,33044
81108ce8:	2949ed04 	addi	r5,r5,10164
81108cec:	1809883a 	mov	r4,r3
81108cf0:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				break;
81108cf4:	00000e06 	br	81108d30 <vQCmdFEEinStandBy+0xfc>
			case M_FEE_FULL_PATTERN:
				pxNFeeP->xControl.eMode = sToTestFullPattern;
81108cf8:	e0bffe17 	ldw	r2,-8(fp)
81108cfc:	00c002c4 	movi	r3,11
81108d00:	10c02815 	stw	r3,160(r2)
				break;
81108d04:	00000a06 	br	81108d30 <vQCmdFEEinStandBy+0xfc>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
81108d08:	d0e05517 	ldw	r3,-32428(gp)
81108d0c:	e0bffe17 	ldw	r2,-8(fp)
81108d10:	10800003 	ldbu	r2,0(r2)
81108d14:	10803fcc 	andi	r2,r2,255
81108d18:	100d883a 	mov	r6,r2
81108d1c:	01604534 	movhi	r5,33044
81108d20:	2949dc04 	addi	r5,r5,10096
81108d24:	1809883a 	mov	r4,r3
81108d28:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				break;
81108d2c:	0001883a 	nop
		}
	}
}
81108d30:	0001883a 	nop
81108d34:	e037883a 	mov	sp,fp
81108d38:	dfc00117 	ldw	ra,4(sp)
81108d3c:	df000017 	ldw	fp,0(sp)
81108d40:	dec00204 	addi	sp,sp,8
81108d44:	f800283a 	ret

81108d48 <vQCmdFEEinFullPattern>:

void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
81108d48:	defffb04 	addi	sp,sp,-20
81108d4c:	de00012e 	bgeu	sp,et,81108d54 <vQCmdFEEinFullPattern+0xc>
81108d50:	003b68fa 	trap	3
81108d54:	dfc00415 	stw	ra,16(sp)
81108d58:	df000315 	stw	fp,12(sp)
81108d5c:	df000304 	addi	fp,sp,12
81108d60:	e13ffe15 	stw	r4,-8(fp)
81108d64:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
81108d68:	e0bfff17 	ldw	r2,-4(fp)
81108d6c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
81108d70:	e0bffdc3 	ldbu	r2,-9(fp)
81108d74:	10c03fcc 	andi	r3,r2,255
81108d78:	e0bffe17 	ldw	r2,-8(fp)
81108d7c:	10800003 	ldbu	r2,0(r2)
81108d80:	10803fcc 	andi	r2,r2,255
81108d84:	10800444 	addi	r2,r2,17
81108d88:	18802e1e 	bne	r3,r2,81108e44 <vQCmdFEEinFullPattern+0xfc>

		switch (uiCmdFEEL.ucByte[2]) {
81108d8c:	e0bffd83 	ldbu	r2,-10(fp)
81108d90:	10803fcc 	andi	r2,r2,255
81108d94:	10c000a0 	cmpeqi	r3,r2,2
81108d98:	18000e1e 	bne	r3,zero,81108dd4 <vQCmdFEEinFullPattern+0x8c>
81108d9c:	10c000c8 	cmpgei	r3,r2,3
81108da0:	1800031e 	bne	r3,zero,81108db0 <vQCmdFEEinFullPattern+0x68>
81108da4:	10800060 	cmpeqi	r2,r2,1
81108da8:	1000061e 	bne	r2,zero,81108dc4 <vQCmdFEEinFullPattern+0x7c>
81108dac:	00001b06 	br	81108e1c <vQCmdFEEinFullPattern+0xd4>
81108db0:	10c00120 	cmpeqi	r3,r2,4
81108db4:	18000b1e 	bne	r3,zero,81108de4 <vQCmdFEEinFullPattern+0x9c>
81108db8:	10800220 	cmpeqi	r2,r2,8
81108dbc:	10000d1e 	bne	r2,zero,81108df4 <vQCmdFEEinFullPattern+0xac>
81108dc0:	00001606 	br	81108e1c <vQCmdFEEinFullPattern+0xd4>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.eMode = sToFeeConfig;
81108dc4:	e0bffe17 	ldw	r2,-8(fp)
81108dc8:	00c00244 	movi	r3,9
81108dcc:	10c02815 	stw	r3,160(r2)
				break;
81108dd0:	00001c06 	br	81108e44 <vQCmdFEEinFullPattern+0xfc>
			case M_FEE_RUN:
				pxNFeeP->xControl.eMode = sFeeOn;
81108dd4:	e0bffe17 	ldw	r2,-8(fp)
81108dd8:	00c00084 	movi	r3,2
81108ddc:	10c02815 	stw	r3,160(r2)
				break;
81108de0:	00001806 	br	81108e44 <vQCmdFEEinFullPattern+0xfc>
			case M_FEE_STANDBY:
				pxNFeeP->xControl.eMode = sToFeeStandBy;
81108de4:	e0bffe17 	ldw	r2,-8(fp)
81108de8:	00c00284 	movi	r3,10
81108dec:	10c02815 	stw	r3,160(r2)
				break;
81108df0:	00001406 	br	81108e44 <vQCmdFEEinFullPattern+0xfc>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81108df4:	d0e05517 	ldw	r3,-32428(gp)
81108df8:	e0bffe17 	ldw	r2,-8(fp)
81108dfc:	10800003 	ldbu	r2,0(r2)
81108e00:	10803fcc 	andi	r2,r2,255
81108e04:	100d883a 	mov	r6,r2
81108e08:	01604534 	movhi	r5,33044
81108e0c:	2949f804 	addi	r5,r5,10208
81108e10:	1809883a 	mov	r4,r3
81108e14:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				break;
81108e18:	00000a06 	br	81108e44 <vQCmdFEEinFullPattern+0xfc>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
81108e1c:	d0e05517 	ldw	r3,-32428(gp)
81108e20:	e0bffe17 	ldw	r2,-8(fp)
81108e24:	10800003 	ldbu	r2,0(r2)
81108e28:	10803fcc 	andi	r2,r2,255
81108e2c:	100d883a 	mov	r6,r2
81108e30:	01604534 	movhi	r5,33044
81108e34:	2949dc04 	addi	r5,r5,10096
81108e38:	1809883a 	mov	r4,r3
81108e3c:	1116c1c0 	call	81116c1c <fprintf>
				#endif
				break;
81108e40:	0001883a 	nop
		}
	}
}
81108e44:	0001883a 	nop
81108e48:	e037883a 	mov	sp,fp
81108e4c:	dfc00117 	ldw	ra,4(sp)
81108e50:	df000017 	ldw	fp,0(sp)
81108e54:	dec00204 	addi	sp,sp,8
81108e58:	f800283a 	ret

81108e5c <vPrintConsoleNFee>:



#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
81108e5c:	defffa04 	addi	sp,sp,-24
81108e60:	de00012e 	bgeu	sp,et,81108e68 <vPrintConsoleNFee+0xc>
81108e64:	003b68fa 	trap	3
81108e68:	dfc00515 	stw	ra,20(sp)
81108e6c:	df000415 	stw	fp,16(sp)
81108e70:	df000404 	addi	fp,sp,16
81108e74:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
81108e78:	e0bfff17 	ldw	r2,-4(fp)
81108e7c:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
81108e80:	d0e05517 	ldw	r3,-32428(gp)
81108e84:	e0bffe17 	ldw	r2,-8(fp)
81108e88:	10800003 	ldbu	r2,0(r2)
81108e8c:	10803fcc 	andi	r2,r2,255
81108e90:	100d883a 	mov	r6,r2
81108e94:	01604534 	movhi	r5,33044
81108e98:	294a0604 	addi	r5,r5,10264
81108e9c:	1809883a 	mov	r4,r3
81108ea0:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"\n");
81108ea4:	d0a05517 	ldw	r2,-32428(gp)
81108ea8:	100b883a 	mov	r5,r2
81108eac:	01000284 	movi	r4,10
81108eb0:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
81108eb4:	d0e05517 	ldw	r3,-32428(gp)
81108eb8:	e0bffe17 	ldw	r2,-8(fp)
81108ebc:	10800003 	ldbu	r2,0(r2)
81108ec0:	10803fcc 	andi	r2,r2,255
81108ec4:	100d883a 	mov	r6,r2
81108ec8:	01604534 	movhi	r5,33044
81108ecc:	294a1b04 	addi	r5,r5,10348
81108ed0:	1809883a 	mov	r4,r3
81108ed4:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
81108ed8:	d0e05517 	ldw	r3,-32428(gp)
81108edc:	e0bffe17 	ldw	r2,-8(fp)
81108ee0:	10802a0b 	ldhu	r2,168(r2)
81108ee4:	10bfffcc 	andi	r2,r2,65535
81108ee8:	100d883a 	mov	r6,r2
81108eec:	01604534 	movhi	r5,33044
81108ef0:	294a2104 	addi	r5,r5,10372
81108ef4:	1809883a 	mov	r4,r3
81108ef8:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
81108efc:	d0e05517 	ldw	r3,-32428(gp)
81108f00:	e0bffe17 	ldw	r2,-8(fp)
81108f04:	10802a8b 	ldhu	r2,170(r2)
81108f08:	10bfffcc 	andi	r2,r2,65535
81108f0c:	100d883a 	mov	r6,r2
81108f10:	01604534 	movhi	r5,33044
81108f14:	294a2604 	addi	r5,r5,10392
81108f18:	1809883a 	mov	r4,r3
81108f1c:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
81108f20:	d0e05517 	ldw	r3,-32428(gp)
81108f24:	e0bffe17 	ldw	r2,-8(fp)
81108f28:	10802b0b 	ldhu	r2,172(r2)
81108f2c:	10bfffcc 	andi	r2,r2,65535
81108f30:	100d883a 	mov	r6,r2
81108f34:	01604534 	movhi	r5,33044
81108f38:	294a2c04 	addi	r5,r5,10416
81108f3c:	1809883a 	mov	r4,r3
81108f40:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
81108f44:	d0e05517 	ldw	r3,-32428(gp)
81108f48:	e0bffe17 	ldw	r2,-8(fp)
81108f4c:	10802b8b 	ldhu	r2,174(r2)
81108f50:	10bfffcc 	andi	r2,r2,65535
81108f54:	100d883a 	mov	r6,r2
81108f58:	01604534 	movhi	r5,33044
81108f5c:	294a3004 	addi	r5,r5,10432
81108f60:	1809883a 	mov	r4,r3
81108f64:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
81108f68:	d0e05517 	ldw	r3,-32428(gp)
81108f6c:	e0bffe17 	ldw	r2,-8(fp)
81108f70:	10802c0b 	ldhu	r2,176(r2)
81108f74:	10bfffcc 	andi	r2,r2,65535
81108f78:	100d883a 	mov	r6,r2
81108f7c:	01604534 	movhi	r5,33044
81108f80:	294a3604 	addi	r5,r5,10456
81108f84:	1809883a 	mov	r4,r3
81108f88:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"\n");
81108f8c:	d0a05517 	ldw	r2,-32428(gp)
81108f90:	100b883a 	mov	r5,r2
81108f94:	01000284 	movi	r4,10
81108f98:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
81108f9c:	d0e05517 	ldw	r3,-32428(gp)
81108fa0:	e0bffe17 	ldw	r2,-8(fp)
81108fa4:	10800003 	ldbu	r2,0(r2)
81108fa8:	10803fcc 	andi	r2,r2,255
81108fac:	100d883a 	mov	r6,r2
81108fb0:	01604534 	movhi	r5,33044
81108fb4:	294a3b04 	addi	r5,r5,10476
81108fb8:	1809883a 	mov	r4,r3
81108fbc:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
81108fc0:	d0e05517 	ldw	r3,-32428(gp)
81108fc4:	e0bffe17 	ldw	r2,-8(fp)
81108fc8:	10802817 	ldw	r2,160(r2)
81108fcc:	100d883a 	mov	r6,r2
81108fd0:	01604534 	movhi	r5,33044
81108fd4:	294a4104 	addi	r5,r5,10500
81108fd8:	1809883a 	mov	r4,r3
81108fdc:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
81108fe0:	d0e05517 	ldw	r3,-32428(gp)
81108fe4:	e0bffe17 	ldw	r2,-8(fp)
81108fe8:	10802117 	ldw	r2,132(r2)
81108fec:	100d883a 	mov	r6,r2
81108ff0:	01604534 	movhi	r5,33044
81108ff4:	294a4704 	addi	r5,r5,10524
81108ff8:	1809883a 	mov	r4,r3
81108ffc:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
81109000:	d0e05517 	ldw	r3,-32428(gp)
81109004:	e0bffe17 	ldw	r2,-8(fp)
81109008:	10802217 	ldw	r2,136(r2)
8110900c:	100d883a 	mov	r6,r2
81109010:	01604534 	movhi	r5,33044
81109014:	294a4e04 	addi	r5,r5,10552
81109018:	1809883a 	mov	r4,r3
8110901c:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
81109020:	d0e05517 	ldw	r3,-32428(gp)
81109024:	e0bffe17 	ldw	r2,-8(fp)
81109028:	10802317 	ldw	r2,140(r2)
8110902c:	100d883a 	mov	r6,r2
81109030:	01604534 	movhi	r5,33044
81109034:	294a5504 	addi	r5,r5,10580
81109038:	1809883a 	mov	r4,r3
8110903c:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
81109040:	d0e05517 	ldw	r3,-32428(gp)
81109044:	e0bffe17 	ldw	r2,-8(fp)
81109048:	10802417 	ldw	r2,144(r2)
8110904c:	100d883a 	mov	r6,r2
81109050:	01604534 	movhi	r5,33044
81109054:	294a5c04 	addi	r5,r5,10608
81109058:	1809883a 	mov	r4,r3
8110905c:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
81109060:	d0e05517 	ldw	r3,-32428(gp)
81109064:	e0bffe17 	ldw	r2,-8(fp)
81109068:	10802517 	ldw	r2,148(r2)
8110906c:	100d883a 	mov	r6,r2
81109070:	01604534 	movhi	r5,33044
81109074:	294a6304 	addi	r5,r5,10636
81109078:	1809883a 	mov	r4,r3
8110907c:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
81109080:	d1205517 	ldw	r4,-32428(gp)
81109084:	e0bffe17 	ldw	r2,-8(fp)
81109088:	10802703 	ldbu	r2,156(r2)
8110908c:	11403fcc 	andi	r5,r2,255
81109090:	e0bffe17 	ldw	r2,-8(fp)
81109094:	10802743 	ldbu	r2,157(r2)
81109098:	11803fcc 	andi	r6,r2,255
8110909c:	e0bffe17 	ldw	r2,-8(fp)
811090a0:	10802783 	ldbu	r2,158(r2)
811090a4:	10803fcc 	andi	r2,r2,255
811090a8:	e0fffe17 	ldw	r3,-8(fp)
811090ac:	18c027c3 	ldbu	r3,159(r3)
811090b0:	18c03fcc 	andi	r3,r3,255
811090b4:	d8c00115 	stw	r3,4(sp)
811090b8:	d8800015 	stw	r2,0(sp)
811090bc:	300f883a 	mov	r7,r6
811090c0:	280d883a 	mov	r6,r5
811090c4:	01604534 	movhi	r5,33044
811090c8:	294a6a04 	addi	r5,r5,10664
811090cc:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
811090d0:	d0e05517 	ldw	r3,-32428(gp)
811090d4:	e0bffe17 	ldw	r2,-8(fp)
811090d8:	10802917 	ldw	r2,164(r2)
811090dc:	100d883a 	mov	r6,r2
811090e0:	01604534 	movhi	r5,33044
811090e4:	294a7704 	addi	r5,r5,10716
811090e8:	1809883a 	mov	r4,r3
811090ec:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"\n\n");
811090f0:	d0a05517 	ldw	r2,-32428(gp)
811090f4:	100f883a 	mov	r7,r2
811090f8:	01800084 	movi	r6,2
811090fc:	01400044 	movi	r5,1
81109100:	01204534 	movhi	r4,33044
81109104:	210a7d04 	addi	r4,r4,10740
81109108:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
8110910c:	d0e05517 	ldw	r3,-32428(gp)
81109110:	e0bffe17 	ldw	r2,-8(fp)
81109114:	10800003 	ldbu	r2,0(r2)
81109118:	10803fcc 	andi	r2,r2,255
8110911c:	100d883a 	mov	r6,r2
81109120:	01604534 	movhi	r5,33044
81109124:	294a7e04 	addi	r5,r5,10744
81109128:	1809883a 	mov	r4,r3
8110912c:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    General Info: \n");
81109130:	d0a05517 	ldw	r2,-32428(gp)
81109134:	100f883a 	mov	r7,r2
81109138:	018004c4 	movi	r6,19
8110913c:	01400044 	movi	r5,1
81109140:	01204534 	movhi	r4,33044
81109144:	210a8404 	addi	r4,r4,10768
81109148:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
8110914c:	d0e05517 	ldw	r3,-32428(gp)
81109150:	e0bffe17 	ldw	r2,-8(fp)
81109154:	10800117 	ldw	r2,4(r2)
81109158:	100d883a 	mov	r6,r2
8110915c:	01604534 	movhi	r5,33044
81109160:	294a8904 	addi	r5,r5,10788
81109164:	1809883a 	mov	r4,r3
81109168:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
8110916c:	d0e05517 	ldw	r3,-32428(gp)
81109170:	e0bffe17 	ldw	r2,-8(fp)
81109174:	10800217 	ldw	r2,8(r2)
81109178:	100d883a 	mov	r6,r2
8110917c:	01604534 	movhi	r5,33044
81109180:	294a9104 	addi	r5,r5,10820
81109184:	1809883a 	mov	r4,r3
81109188:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
8110918c:	d0e05517 	ldw	r3,-32428(gp)
81109190:	e0bffe17 	ldw	r2,-8(fp)
81109194:	10800317 	ldw	r2,12(r2)
81109198:	100d883a 	mov	r6,r2
8110919c:	01604534 	movhi	r5,33044
811091a0:	294a9904 	addi	r5,r5,10852
811091a4:	1809883a 	mov	r4,r3
811091a8:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
811091ac:	d0a05517 	ldw	r2,-32428(gp)
811091b0:	100f883a 	mov	r7,r2
811091b4:	01800644 	movi	r6,25
811091b8:	01400044 	movi	r5,1
811091bc:	01204534 	movhi	r4,33044
811091c0:	210aa004 	addi	r4,r4,10880
811091c4:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
811091c8:	d0e05517 	ldw	r3,-32428(gp)
811091cc:	e0bffe17 	ldw	r2,-8(fp)
811091d0:	10800517 	ldw	r2,20(r2)
811091d4:	100d883a 	mov	r6,r2
811091d8:	01604534 	movhi	r5,33044
811091dc:	294aa704 	addi	r5,r5,10908
811091e0:	1809883a 	mov	r4,r3
811091e4:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
811091e8:	d0e05517 	ldw	r3,-32428(gp)
811091ec:	e0bffe17 	ldw	r2,-8(fp)
811091f0:	10800417 	ldw	r2,16(r2)
811091f4:	100d883a 	mov	r6,r2
811091f8:	01604534 	movhi	r5,33044
811091fc:	294aaf04 	addi	r5,r5,10940
81109200:	1809883a 	mov	r4,r3
81109204:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
81109208:	d0e05517 	ldw	r3,-32428(gp)
8110920c:	e0bffe17 	ldw	r2,-8(fp)
81109210:	10800603 	ldbu	r2,24(r2)
81109214:	10803fcc 	andi	r2,r2,255
81109218:	100d883a 	mov	r6,r2
8110921c:	01604534 	movhi	r5,33044
81109220:	294ab704 	addi	r5,r5,10972
81109224:	1809883a 	mov	r4,r3
81109228:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
8110922c:	d2205517 	ldw	r8,-32428(gp)
81109230:	e13ffe17 	ldw	r4,-8(fp)
81109234:	20800717 	ldw	r2,28(r4)
81109238:	20c00817 	ldw	r3,32(r4)
8110923c:	100d883a 	mov	r6,r2
81109240:	180f883a 	mov	r7,r3
81109244:	01604534 	movhi	r5,33044
81109248:	294abf04 	addi	r5,r5,11004
8110924c:	4009883a 	mov	r4,r8
81109250:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"\n");
81109254:	d0a05517 	ldw	r2,-32428(gp)
81109258:	100b883a 	mov	r5,r2
8110925c:	01000284 	movi	r4,10
81109260:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
81109264:	d0e05517 	ldw	r3,-32428(gp)
81109268:	e0bffe17 	ldw	r2,-8(fp)
8110926c:	10800003 	ldbu	r2,0(r2)
81109270:	10803fcc 	andi	r2,r2,255
81109274:	100f883a 	mov	r7,r2
81109278:	000d883a 	mov	r6,zero
8110927c:	01604534 	movhi	r5,33044
81109280:	294ac704 	addi	r5,r5,11036
81109284:	1809883a 	mov	r4,r3
81109288:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Left side \n");
8110928c:	d0a05517 	ldw	r2,-32428(gp)
81109290:	100f883a 	mov	r7,r2
81109294:	018004c4 	movi	r6,19
81109298:	01400044 	movi	r5,1
8110929c:	01204534 	movhi	r4,33044
811092a0:	210ad104 	addi	r4,r4,11076
811092a4:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
811092a8:	d0e05517 	ldw	r3,-32428(gp)
811092ac:	e0bffe17 	ldw	r2,-8(fp)
811092b0:	10800917 	ldw	r2,36(r2)
811092b4:	100d883a 	mov	r6,r2
811092b8:	01604534 	movhi	r5,33044
811092bc:	294ad604 	addi	r5,r5,11096
811092c0:	1809883a 	mov	r4,r3
811092c4:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
811092c8:	d0e05517 	ldw	r3,-32428(gp)
811092cc:	e0bffe17 	ldw	r2,-8(fp)
811092d0:	10800a17 	ldw	r2,40(r2)
811092d4:	100d883a 	mov	r6,r2
811092d8:	01604534 	movhi	r5,33044
811092dc:	294adf04 	addi	r5,r5,11132
811092e0:	1809883a 	mov	r4,r3
811092e4:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
811092e8:	d0e05517 	ldw	r3,-32428(gp)
811092ec:	e0bffe17 	ldw	r2,-8(fp)
811092f0:	10800b17 	ldw	r2,44(r2)
811092f4:	100d883a 	mov	r6,r2
811092f8:	01604534 	movhi	r5,33044
811092fc:	294aea04 	addi	r5,r5,11176
81109300:	1809883a 	mov	r4,r3
81109304:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Right side \n");
81109308:	d0a05517 	ldw	r2,-32428(gp)
8110930c:	100f883a 	mov	r7,r2
81109310:	01800504 	movi	r6,20
81109314:	01400044 	movi	r5,1
81109318:	01204534 	movhi	r4,33044
8110931c:	210af604 	addi	r4,r4,11224
81109320:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
81109324:	d0e05517 	ldw	r3,-32428(gp)
81109328:	e0bffe17 	ldw	r2,-8(fp)
8110932c:	10800c17 	ldw	r2,48(r2)
81109330:	100d883a 	mov	r6,r2
81109334:	01604534 	movhi	r5,33044
81109338:	294ad604 	addi	r5,r5,11096
8110933c:	1809883a 	mov	r4,r3
81109340:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
81109344:	d0e05517 	ldw	r3,-32428(gp)
81109348:	e0bffe17 	ldw	r2,-8(fp)
8110934c:	10800d17 	ldw	r2,52(r2)
81109350:	100d883a 	mov	r6,r2
81109354:	01604534 	movhi	r5,33044
81109358:	294adf04 	addi	r5,r5,11132
8110935c:	1809883a 	mov	r4,r3
81109360:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
81109364:	d0e05517 	ldw	r3,-32428(gp)
81109368:	e0bffe17 	ldw	r2,-8(fp)
8110936c:	10800e17 	ldw	r2,56(r2)
81109370:	100d883a 	mov	r6,r2
81109374:	01604534 	movhi	r5,33044
81109378:	294aea04 	addi	r5,r5,11176
8110937c:	1809883a 	mov	r4,r3
81109380:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"\n");
81109384:	d0a05517 	ldw	r2,-32428(gp)
81109388:	100b883a 	mov	r5,r2
8110938c:	01000284 	movi	r4,10
81109390:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
81109394:	d0e05517 	ldw	r3,-32428(gp)
81109398:	e0bffe17 	ldw	r2,-8(fp)
8110939c:	10800003 	ldbu	r2,0(r2)
811093a0:	10803fcc 	andi	r2,r2,255
811093a4:	100f883a 	mov	r7,r2
811093a8:	01800044 	movi	r6,1
811093ac:	01604534 	movhi	r5,33044
811093b0:	294ac704 	addi	r5,r5,11036
811093b4:	1809883a 	mov	r4,r3
811093b8:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Left side \n");
811093bc:	d0a05517 	ldw	r2,-32428(gp)
811093c0:	100f883a 	mov	r7,r2
811093c4:	018004c4 	movi	r6,19
811093c8:	01400044 	movi	r5,1
811093cc:	01204534 	movhi	r4,33044
811093d0:	210ad104 	addi	r4,r4,11076
811093d4:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
811093d8:	d0e05517 	ldw	r3,-32428(gp)
811093dc:	e0bffe17 	ldw	r2,-8(fp)
811093e0:	10800f17 	ldw	r2,60(r2)
811093e4:	100d883a 	mov	r6,r2
811093e8:	01604534 	movhi	r5,33044
811093ec:	294ad604 	addi	r5,r5,11096
811093f0:	1809883a 	mov	r4,r3
811093f4:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
811093f8:	d0e05517 	ldw	r3,-32428(gp)
811093fc:	e0bffe17 	ldw	r2,-8(fp)
81109400:	10801017 	ldw	r2,64(r2)
81109404:	100d883a 	mov	r6,r2
81109408:	01604534 	movhi	r5,33044
8110940c:	294adf04 	addi	r5,r5,11132
81109410:	1809883a 	mov	r4,r3
81109414:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
81109418:	d0e05517 	ldw	r3,-32428(gp)
8110941c:	e0bffe17 	ldw	r2,-8(fp)
81109420:	10801117 	ldw	r2,68(r2)
81109424:	100d883a 	mov	r6,r2
81109428:	01604534 	movhi	r5,33044
8110942c:	294aea04 	addi	r5,r5,11176
81109430:	1809883a 	mov	r4,r3
81109434:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Right side \n");
81109438:	d0a05517 	ldw	r2,-32428(gp)
8110943c:	100f883a 	mov	r7,r2
81109440:	01800504 	movi	r6,20
81109444:	01400044 	movi	r5,1
81109448:	01204534 	movhi	r4,33044
8110944c:	210af604 	addi	r4,r4,11224
81109450:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
81109454:	d0e05517 	ldw	r3,-32428(gp)
81109458:	e0bffe17 	ldw	r2,-8(fp)
8110945c:	10801217 	ldw	r2,72(r2)
81109460:	100d883a 	mov	r6,r2
81109464:	01604534 	movhi	r5,33044
81109468:	294ad604 	addi	r5,r5,11096
8110946c:	1809883a 	mov	r4,r3
81109470:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
81109474:	d0e05517 	ldw	r3,-32428(gp)
81109478:	e0bffe17 	ldw	r2,-8(fp)
8110947c:	10801317 	ldw	r2,76(r2)
81109480:	100d883a 	mov	r6,r2
81109484:	01604534 	movhi	r5,33044
81109488:	294adf04 	addi	r5,r5,11132
8110948c:	1809883a 	mov	r4,r3
81109490:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
81109494:	d0e05517 	ldw	r3,-32428(gp)
81109498:	e0bffe17 	ldw	r2,-8(fp)
8110949c:	10801417 	ldw	r2,80(r2)
811094a0:	100d883a 	mov	r6,r2
811094a4:	01604534 	movhi	r5,33044
811094a8:	294aea04 	addi	r5,r5,11176
811094ac:	1809883a 	mov	r4,r3
811094b0:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"\n");
811094b4:	d0a05517 	ldw	r2,-32428(gp)
811094b8:	100b883a 	mov	r5,r2
811094bc:	01000284 	movi	r4,10
811094c0:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
811094c4:	d0e05517 	ldw	r3,-32428(gp)
811094c8:	e0bffe17 	ldw	r2,-8(fp)
811094cc:	10800003 	ldbu	r2,0(r2)
811094d0:	10803fcc 	andi	r2,r2,255
811094d4:	100f883a 	mov	r7,r2
811094d8:	01800084 	movi	r6,2
811094dc:	01604534 	movhi	r5,33044
811094e0:	294ac704 	addi	r5,r5,11036
811094e4:	1809883a 	mov	r4,r3
811094e8:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Left side \n");
811094ec:	d0a05517 	ldw	r2,-32428(gp)
811094f0:	100f883a 	mov	r7,r2
811094f4:	018004c4 	movi	r6,19
811094f8:	01400044 	movi	r5,1
811094fc:	01204534 	movhi	r4,33044
81109500:	210ad104 	addi	r4,r4,11076
81109504:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
81109508:	d0e05517 	ldw	r3,-32428(gp)
8110950c:	e0bffe17 	ldw	r2,-8(fp)
81109510:	10801517 	ldw	r2,84(r2)
81109514:	100d883a 	mov	r6,r2
81109518:	01604534 	movhi	r5,33044
8110951c:	294ad604 	addi	r5,r5,11096
81109520:	1809883a 	mov	r4,r3
81109524:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
81109528:	d0e05517 	ldw	r3,-32428(gp)
8110952c:	e0bffe17 	ldw	r2,-8(fp)
81109530:	10801617 	ldw	r2,88(r2)
81109534:	100d883a 	mov	r6,r2
81109538:	01604534 	movhi	r5,33044
8110953c:	294adf04 	addi	r5,r5,11132
81109540:	1809883a 	mov	r4,r3
81109544:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
81109548:	d0e05517 	ldw	r3,-32428(gp)
8110954c:	e0bffe17 	ldw	r2,-8(fp)
81109550:	10801717 	ldw	r2,92(r2)
81109554:	100d883a 	mov	r6,r2
81109558:	01604534 	movhi	r5,33044
8110955c:	294aea04 	addi	r5,r5,11176
81109560:	1809883a 	mov	r4,r3
81109564:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Right side \n");
81109568:	d0a05517 	ldw	r2,-32428(gp)
8110956c:	100f883a 	mov	r7,r2
81109570:	01800504 	movi	r6,20
81109574:	01400044 	movi	r5,1
81109578:	01204534 	movhi	r4,33044
8110957c:	210af604 	addi	r4,r4,11224
81109580:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
81109584:	d0e05517 	ldw	r3,-32428(gp)
81109588:	e0bffe17 	ldw	r2,-8(fp)
8110958c:	10801817 	ldw	r2,96(r2)
81109590:	100d883a 	mov	r6,r2
81109594:	01604534 	movhi	r5,33044
81109598:	294ad604 	addi	r5,r5,11096
8110959c:	1809883a 	mov	r4,r3
811095a0:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
811095a4:	d0e05517 	ldw	r3,-32428(gp)
811095a8:	e0bffe17 	ldw	r2,-8(fp)
811095ac:	10801917 	ldw	r2,100(r2)
811095b0:	100d883a 	mov	r6,r2
811095b4:	01604534 	movhi	r5,33044
811095b8:	294adf04 	addi	r5,r5,11132
811095bc:	1809883a 	mov	r4,r3
811095c0:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
811095c4:	d0e05517 	ldw	r3,-32428(gp)
811095c8:	e0bffe17 	ldw	r2,-8(fp)
811095cc:	10801a17 	ldw	r2,104(r2)
811095d0:	100d883a 	mov	r6,r2
811095d4:	01604534 	movhi	r5,33044
811095d8:	294aea04 	addi	r5,r5,11176
811095dc:	1809883a 	mov	r4,r3
811095e0:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"\n");
811095e4:	d0a05517 	ldw	r2,-32428(gp)
811095e8:	100b883a 	mov	r5,r2
811095ec:	01000284 	movi	r4,10
811095f0:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
811095f4:	d0e05517 	ldw	r3,-32428(gp)
811095f8:	e0bffe17 	ldw	r2,-8(fp)
811095fc:	10800003 	ldbu	r2,0(r2)
81109600:	10803fcc 	andi	r2,r2,255
81109604:	100f883a 	mov	r7,r2
81109608:	018000c4 	movi	r6,3
8110960c:	01604534 	movhi	r5,33044
81109610:	294ac704 	addi	r5,r5,11036
81109614:	1809883a 	mov	r4,r3
81109618:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Left side \n");
8110961c:	d0a05517 	ldw	r2,-32428(gp)
81109620:	100f883a 	mov	r7,r2
81109624:	018004c4 	movi	r6,19
81109628:	01400044 	movi	r5,1
8110962c:	01204534 	movhi	r4,33044
81109630:	210ad104 	addi	r4,r4,11076
81109634:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
81109638:	d0e05517 	ldw	r3,-32428(gp)
8110963c:	e0bffe17 	ldw	r2,-8(fp)
81109640:	10801b17 	ldw	r2,108(r2)
81109644:	100d883a 	mov	r6,r2
81109648:	01604534 	movhi	r5,33044
8110964c:	294ad604 	addi	r5,r5,11096
81109650:	1809883a 	mov	r4,r3
81109654:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
81109658:	d0e05517 	ldw	r3,-32428(gp)
8110965c:	e0bffe17 	ldw	r2,-8(fp)
81109660:	10801c17 	ldw	r2,112(r2)
81109664:	100d883a 	mov	r6,r2
81109668:	01604534 	movhi	r5,33044
8110966c:	294adf04 	addi	r5,r5,11132
81109670:	1809883a 	mov	r4,r3
81109674:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
81109678:	d0e05517 	ldw	r3,-32428(gp)
8110967c:	e0bffe17 	ldw	r2,-8(fp)
81109680:	10801d17 	ldw	r2,116(r2)
81109684:	100d883a 	mov	r6,r2
81109688:	01604534 	movhi	r5,33044
8110968c:	294aea04 	addi	r5,r5,11176
81109690:	1809883a 	mov	r4,r3
81109694:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"        Right side \n");
81109698:	d0a05517 	ldw	r2,-32428(gp)
8110969c:	100f883a 	mov	r7,r2
811096a0:	01800504 	movi	r6,20
811096a4:	01400044 	movi	r5,1
811096a8:	01204534 	movhi	r4,33044
811096ac:	210af604 	addi	r4,r4,11224
811096b0:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
811096b4:	d0e05517 	ldw	r3,-32428(gp)
811096b8:	e0bffe17 	ldw	r2,-8(fp)
811096bc:	10801e17 	ldw	r2,120(r2)
811096c0:	100d883a 	mov	r6,r2
811096c4:	01604534 	movhi	r5,33044
811096c8:	294ad604 	addi	r5,r5,11096
811096cc:	1809883a 	mov	r4,r3
811096d0:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
811096d4:	d0e05517 	ldw	r3,-32428(gp)
811096d8:	e0bffe17 	ldw	r2,-8(fp)
811096dc:	10801f17 	ldw	r2,124(r2)
811096e0:	100d883a 	mov	r6,r2
811096e4:	01604534 	movhi	r5,33044
811096e8:	294adf04 	addi	r5,r5,11132
811096ec:	1809883a 	mov	r4,r3
811096f0:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
811096f4:	d0e05517 	ldw	r3,-32428(gp)
811096f8:	e0bffe17 	ldw	r2,-8(fp)
811096fc:	10802017 	ldw	r2,128(r2)
81109700:	100d883a 	mov	r6,r2
81109704:	01604534 	movhi	r5,33044
81109708:	294aea04 	addi	r5,r5,11176
8110970c:	1809883a 	mov	r4,r3
81109710:	1116c1c0 	call	81116c1c <fprintf>
		fprintf(fp,"\n");
81109714:	d0a05517 	ldw	r2,-32428(gp)
81109718:	100b883a 	mov	r5,r2
8110971c:	01000284 	movi	r4,10
81109720:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"==============================================================================\n");
81109724:	d0a05517 	ldw	r2,-32428(gp)
81109728:	100f883a 	mov	r7,r2
8110972c:	018013c4 	movi	r6,79
81109730:	01400044 	movi	r5,1
81109734:	01204534 	movhi	r4,33044
81109738:	210afc04 	addi	r4,r4,11248
8110973c:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"==============================================================================\n");
81109740:	d0a05517 	ldw	r2,-32428(gp)
81109744:	100f883a 	mov	r7,r2
81109748:	018013c4 	movi	r6,79
8110974c:	01400044 	movi	r5,1
81109750:	01204534 	movhi	r4,33044
81109754:	210afc04 	addi	r4,r4,11248
81109758:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp,"\n");
8110975c:	d0a05517 	ldw	r2,-32428(gp)
81109760:	100b883a 	mov	r5,r2
81109764:	01000284 	movi	r4,10
81109768:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"\n");
8110976c:	d0a05517 	ldw	r2,-32428(gp)
81109770:	100b883a 	mov	r5,r2
81109774:	01000284 	movi	r4,10
81109778:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"\n");
8110977c:	d0a05517 	ldw	r2,-32428(gp)
81109780:	100b883a 	mov	r5,r2
81109784:	01000284 	movi	r4,10
81109788:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"\n");
8110978c:	d0a05517 	ldw	r2,-32428(gp)
81109790:	100b883a 	mov	r5,r2
81109794:	01000284 	movi	r4,10
81109798:	1116c940 	call	81116c94 <fputc>
		fprintf(fp,"\n");
8110979c:	d0a05517 	ldw	r2,-32428(gp)
811097a0:	100b883a 	mov	r5,r2
811097a4:	01000284 	movi	r4,10
811097a8:	1116c940 	call	81116c94 <fputc>
	}
811097ac:	0001883a 	nop
811097b0:	e037883a 	mov	sp,fp
811097b4:	dfc00117 	ldw	ra,4(sp)
811097b8:	df000017 	ldw	fp,0(sp)
811097bc:	dec00204 	addi	sp,sp,8
811097c0:	f800283a 	ret

811097c4 <vFeeTask0>:





	void vFeeTask0(void *task_data) {
811097c4:	defffa04 	addi	sp,sp,-24
811097c8:	de00012e 	bgeu	sp,et,811097d0 <vFeeTask0+0xc>
811097cc:	003b68fa 	trap	3
811097d0:	dfc00515 	stw	ra,20(sp)
811097d4:	df000415 	stw	fp,16(sp)
811097d8:	df000404 	addi	fp,sp,16
811097dc:	e13fff15 	stw	r4,-4(fp)
		bool bSuccess = FALSE;
811097e0:	e03ffc15 	stw	zero,-16(fp)
		static TNFee *pxNFee;
		INT8U error_code;
		tQMask uiCmdFEE;


		pxNFee = ( TNFee * ) task_data;
811097e4:	e0bfff17 	ldw	r2,-4(fp)
811097e8:	d0a04c15 	stw	r2,-32464(gp)

		#ifdef DEBUG_ON
			fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
811097ec:	d0e05517 	ldw	r3,-32428(gp)
811097f0:	d0a04c17 	ldw	r2,-32464(gp)
811097f4:	10800003 	ldbu	r2,0(r2)
811097f8:	10803fcc 	andi	r2,r2,255
811097fc:	100d883a 	mov	r6,r2
81109800:	01604534 	movhi	r5,33044
81109804:	29498d04 	addi	r5,r5,9780
81109808:	1809883a 	mov	r4,r3
8110980c:	1116c1c0 	call	81116c1c <fprintf>
			//debug(fp,"NFEE Task. (Task on)\n");
		#endif

		#ifdef DEBUG_ON
			vPrintConsoleNFee( pxNFee );
81109810:	d0a04c17 	ldw	r2,-32464(gp)
81109814:	1009883a 	mov	r4,r2
81109818:	1108e5c0 	call	81108e5c <vPrintConsoleNFee>
		#endif

		for(;;){

			switch ( pxNFee->xControl.eMode ) {
8110981c:	d0a04c17 	ldw	r2,-32464(gp)
81109820:	10802817 	ldw	r2,160(r2)
81109824:	10c00328 	cmpgeui	r3,r2,12
81109828:	1800b31e 	bne	r3,zero,81109af8 <vFeeTask0+0x334>
8110982c:	100690ba 	slli	r3,r2,2
81109830:	00a04474 	movhi	r2,33041
81109834:	10a61104 	addi	r2,r2,-26556
81109838:	1885883a 	add	r2,r3,r2
8110983c:	10800017 	ldw	r2,0(r2)
81109840:	1000683a 	jmp	r2
81109844:	81109874 	orhi	r4,r16,16993
81109848:	81109904 	addi	r4,r16,16996
8110984c:	81109964 	muli	r4,r16,16997
81109850:	811099f8 	rdprs	r4,r16,16999
81109854:	81109af8 	rdprs	r4,r16,17003
81109858:	81109a98 	cmpnei	r4,r16,17002
8110985c:	81109af8 	rdprs	r4,r16,17003
81109860:	81109af8 	rdprs	r4,r16,17003
81109864:	81109af8 	rdprs	r4,r16,17003
81109868:	81109884 	addi	r4,r16,16994
8110986c:	81109974 	orhi	r4,r16,16997
81109870:	81109a58 	cmpnei	r4,r16,17001
				case sFeeInit:

					pxNFee->xControl.eMode = sToFeeConfig;
81109874:	d0a04c17 	ldw	r2,-32464(gp)
81109878:	00c00244 	movi	r3,9
8110987c:	10c02815 	stw	r3,160(r2)

					break;
81109880:	0000af06 	br	81109b40 <vFeeTask0+0x37c>
				case sToFeeConfig: /* Transition */

					/* Desabilitar interrupes do buffer duplo */
					/* Limpar interrupes, zerar buffer duplo */

					pxNFee->xControl.bSimulating = FALSE;
81109884:	d0a04c17 	ldw	r2,-32464(gp)
81109888:	10002615 	stw	zero,152(r2)
					pxNFee->xControl.bUsingDMA = FALSE;
8110988c:	d0a04c17 	ldw	r2,-32464(gp)
81109890:	10002215 	stw	zero,136(r2)

					/* Disable the link SPW */
					//todo: tratar retorno
					bSpwcGetLink(&pxNFee->xChannel.xSpacewire);
81109894:	d0a04c17 	ldw	r2,-32464(gp)
81109898:	10808304 	addi	r2,r2,524
8110989c:	1009883a 	mov	r4,r2
811098a0:	11052cc0 	call	811052cc <bSpwcGetLink>
					pxNFee->xChannel.xSpacewire.xLinkConfig.bStart = FALSE;
811098a4:	d0a04c17 	ldw	r2,-32464(gp)
811098a8:	10008515 	stw	zero,532(r2)
					pxNFee->xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
811098ac:	d0a04c17 	ldw	r2,-32464(gp)
811098b0:	10008415 	stw	zero,528(r2)
					pxNFee->xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
811098b4:	d0a04c17 	ldw	r2,-32464(gp)
811098b8:	00c00044 	movi	r3,1
811098bc:	10c08615 	stw	r3,536(r2)
					bSpwcSetLink(&pxNFee->xChannel.xSpacewire);
811098c0:	d0a04c17 	ldw	r2,-32464(gp)
811098c4:	10808304 	addi	r2,r2,524
811098c8:	1009883a 	mov	r4,r2
811098cc:	11051cc0 	call	811051cc <bSpwcSetLink>

					//todo:Back
					//bSpwcClearTimecode(&pxNFee->xChannel.xSpacewire);

					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Going to Config mode\n", pxNFee->ucId);
811098d0:	d0e05517 	ldw	r3,-32428(gp)
811098d4:	d0a04c17 	ldw	r2,-32464(gp)
811098d8:	10800003 	ldbu	r2,0(r2)
811098dc:	10803fcc 	andi	r2,r2,255
811098e0:	100d883a 	mov	r6,r2
811098e4:	01604534 	movhi	r5,33044
811098e8:	29499404 	addi	r5,r5,9808
811098ec:	1809883a 	mov	r4,r3
811098f0:	1116c1c0 	call	81116c1c <fprintf>
					#endif
					pxNFee->xControl.eMode = sFeeConfig;
811098f4:	d0a04c17 	ldw	r2,-32464(gp)
811098f8:	00c00044 	movi	r3,1
811098fc:	10c02815 	stw	r3,160(r2)
					break;
81109900:	00008f06 	br	81109b40 <vFeeTask0+0x37c>
				case sFeeConfig: /* Real mode */

					uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
81109904:	d0a04c17 	ldw	r2,-32464(gp)
81109908:	10800003 	ldbu	r2,0(r2)
8110990c:	10c03fcc 	andi	r3,r2,255
81109910:	00a04574 	movhi	r2,33045
81109914:	10974904 	addi	r2,r2,23844
81109918:	18c7883a 	add	r3,r3,r3
8110991c:	18c7883a 	add	r3,r3,r3
81109920:	10c5883a 	add	r2,r2,r3
81109924:	10800017 	ldw	r2,0(r2)
81109928:	e0fffd04 	addi	r3,fp,-12
8110992c:	180d883a 	mov	r6,r3
81109930:	000b883a 	mov	r5,zero
81109934:	1009883a 	mov	r4,r2
81109938:	1133e000 	call	81133e00 <OSQPend>
8110993c:	e0bffe15 	stw	r2,-8(fp)
					if ( error_code == OS_ERR_NONE ) {
81109940:	e0bffd03 	ldbu	r2,-12(fp)
81109944:	10803fcc 	andi	r2,r2,255
81109948:	1000781e 	bne	r2,zero,81109b2c <vFeeTask0+0x368>
						vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110994c:	d0a04c17 	ldw	r2,-32464(gp)
81109950:	e0fffe17 	ldw	r3,-8(fp)
81109954:	180b883a 	mov	r5,r3
81109958:	1009883a 	mov	r4,r2
8110995c:	1108b080 	call	81108b08 <vQCmdFEEinConfig>
					} else {

						/* todo: Criar funo de tratamento de erro*/
					}

					break;
81109960:	00007206 	br	81109b2c <vFeeTask0+0x368>
				case sFeeOn: /* Real mode */

					pxNFee->xControl.eMode = sToFeeStandBy;
81109964:	d0a04c17 	ldw	r2,-32464(gp)
81109968:	00c00284 	movi	r3,10
8110996c:	10c02815 	stw	r3,160(r2)
					break;
81109970:	00007306 	br	81109b40 <vFeeTask0+0x37c>
				case sToFeeStandBy: /* Transition */

					pxNFee->xControl.bSimulating = TRUE;
81109974:	d0a04c17 	ldw	r2,-32464(gp)
81109978:	00c00044 	movi	r3,1
8110997c:	10c02615 	stw	r3,152(r2)
					pxNFee->xControl.bUsingDMA = FALSE;
81109980:	d0a04c17 	ldw	r2,-32464(gp)
81109984:	10002215 	stw	zero,136(r2)
					/* Limpar interrupes, zerar buffer duplo */



					/* Enable link SPW the link SPW */
					bSpwcGetLink(&pxNFee->xChannel.xSpacewire);
81109988:	d0a04c17 	ldw	r2,-32464(gp)
8110998c:	10808304 	addi	r2,r2,524
81109990:	1009883a 	mov	r4,r2
81109994:	11052cc0 	call	811052cc <bSpwcGetLink>
					pxNFee->xChannel.xSpacewire.xLinkConfig.bStart = FALSE;
81109998:	d0a04c17 	ldw	r2,-32464(gp)
8110999c:	10008515 	stw	zero,532(r2)
					pxNFee->xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
811099a0:	d0a04c17 	ldw	r2,-32464(gp)
811099a4:	00c00044 	movi	r3,1
811099a8:	10c08415 	stw	r3,528(r2)
					pxNFee->xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
811099ac:	d0a04c17 	ldw	r2,-32464(gp)
811099b0:	10008615 	stw	zero,536(r2)
					bSpwcSetLink(&pxNFee->xChannel.xSpacewire);
811099b4:	d0a04c17 	ldw	r2,-32464(gp)
811099b8:	10808304 	addi	r2,r2,524
811099bc:	1009883a 	mov	r4,r2
811099c0:	11051cc0 	call	811051cc <bSpwcSetLink>




					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Going to Standby mode\n", pxNFee->ucId);
811099c4:	d0e05517 	ldw	r3,-32428(gp)
811099c8:	d0a04c17 	ldw	r2,-32464(gp)
811099cc:	10800003 	ldbu	r2,0(r2)
811099d0:	10803fcc 	andi	r2,r2,255
811099d4:	100d883a 	mov	r6,r2
811099d8:	01604534 	movhi	r5,33044
811099dc:	29499e04 	addi	r5,r5,9848
811099e0:	1809883a 	mov	r4,r3
811099e4:	1116c1c0 	call	81116c1c <fprintf>
					#endif
					pxNFee->xControl.eMode = sFeeStandBy;
811099e8:	d0a04c17 	ldw	r2,-32464(gp)
811099ec:	00c000c4 	movi	r3,3
811099f0:	10c02815 	stw	r3,160(r2)
					break;
811099f4:	00005206 	br	81109b40 <vFeeTask0+0x37c>
				case sFeeStandBy: /* Real mode */

					uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
811099f8:	d0a04c17 	ldw	r2,-32464(gp)
811099fc:	10800003 	ldbu	r2,0(r2)
81109a00:	10c03fcc 	andi	r3,r2,255
81109a04:	00a04574 	movhi	r2,33045
81109a08:	10974904 	addi	r2,r2,23844
81109a0c:	18c7883a 	add	r3,r3,r3
81109a10:	18c7883a 	add	r3,r3,r3
81109a14:	10c5883a 	add	r2,r2,r3
81109a18:	10800017 	ldw	r2,0(r2)
81109a1c:	e0fffd04 	addi	r3,fp,-12
81109a20:	180d883a 	mov	r6,r3
81109a24:	000b883a 	mov	r5,zero
81109a28:	1009883a 	mov	r4,r2
81109a2c:	1133e000 	call	81133e00 <OSQPend>
81109a30:	e0bffe15 	stw	r2,-8(fp)
					if ( error_code == OS_ERR_NONE ) {
81109a34:	e0bffd03 	ldbu	r2,-12(fp)
81109a38:	10803fcc 	andi	r2,r2,255
81109a3c:	10003d1e 	bne	r2,zero,81109b34 <vFeeTask0+0x370>
						vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
81109a40:	d0a04c17 	ldw	r2,-32464(gp)
81109a44:	e0fffe17 	ldw	r3,-8(fp)
81109a48:	180b883a 	mov	r5,r3
81109a4c:	1009883a 	mov	r4,r2
81109a50:	1108b080 	call	81108b08 <vQCmdFEEinConfig>
					} else {

						/* todo: Criar funo de tratamento de erro*/
					}

					break;
81109a54:	00003706 	br	81109b34 <vFeeTask0+0x370>
				case sToTestFullPattern: /* Transition */

					pxNFee->xControl.bUsingDMA = TRUE;
81109a58:	d0a04c17 	ldw	r2,-32464(gp)
81109a5c:	00c00044 	movi	r3,1
81109a60:	10c02215 	stw	r3,136(r2)

					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Going to FULL Image Pattern mode\n", pxNFee->ucId);
81109a64:	d0e05517 	ldw	r3,-32428(gp)
81109a68:	d0a04c17 	ldw	r2,-32464(gp)
81109a6c:	10800003 	ldbu	r2,0(r2)
81109a70:	10803fcc 	andi	r2,r2,255
81109a74:	100d883a 	mov	r6,r2
81109a78:	01604534 	movhi	r5,33044
81109a7c:	2949a804 	addi	r5,r5,9888
81109a80:	1809883a 	mov	r4,r3
81109a84:	1116c1c0 	call	81116c1c <fprintf>
					#endif
					pxNFee->xControl.eMode = sFeeTestFullPattern;
81109a88:	d0a04c17 	ldw	r2,-32464(gp)
81109a8c:	00c00144 	movi	r3,5
81109a90:	10c02815 	stw	r3,160(r2)
					break;
81109a94:	00002a06 	br	81109b40 <vFeeTask0+0x37c>
				case sFeeTestFullPattern: /* Real mode */

					uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
81109a98:	d0a04c17 	ldw	r2,-32464(gp)
81109a9c:	10800003 	ldbu	r2,0(r2)
81109aa0:	10c03fcc 	andi	r3,r2,255
81109aa4:	00a04574 	movhi	r2,33045
81109aa8:	10974904 	addi	r2,r2,23844
81109aac:	18c7883a 	add	r3,r3,r3
81109ab0:	18c7883a 	add	r3,r3,r3
81109ab4:	10c5883a 	add	r2,r2,r3
81109ab8:	10800017 	ldw	r2,0(r2)
81109abc:	e0fffd04 	addi	r3,fp,-12
81109ac0:	180d883a 	mov	r6,r3
81109ac4:	000b883a 	mov	r5,zero
81109ac8:	1009883a 	mov	r4,r2
81109acc:	1133e000 	call	81133e00 <OSQPend>
81109ad0:	e0bffe15 	stw	r2,-8(fp)
					if ( error_code == OS_ERR_NONE ) {
81109ad4:	e0bffd03 	ldbu	r2,-12(fp)
81109ad8:	10803fcc 	andi	r2,r2,255
81109adc:	1000171e 	bne	r2,zero,81109b3c <vFeeTask0+0x378>

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
81109ae0:	d0a04c17 	ldw	r2,-32464(gp)
81109ae4:	e0fffe17 	ldw	r3,-8(fp)
81109ae8:	180b883a 	mov	r5,r3
81109aec:	1009883a 	mov	r4,r2
81109af0:	1108d480 	call	81108d48 <vQCmdFEEinFullPattern>
					} else {

						/* todo: Criar funo de tratamento de erro*/
					}

					break;
81109af4:	00001106 	br	81109b3c <vFeeTask0+0x378>
				default:
					pxNFee->xControl.eMode = sToFeeConfig;
81109af8:	d0a04c17 	ldw	r2,-32464(gp)
81109afc:	00c00244 	movi	r3,9
81109b00:	10c02815 	stw	r3,160(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
81109b04:	d0e05517 	ldw	r3,-32428(gp)
81109b08:	d0a04c17 	ldw	r2,-32464(gp)
81109b0c:	10800003 	ldbu	r2,0(r2)
81109b10:	10803fcc 	andi	r2,r2,255
81109b14:	100d883a 	mov	r6,r2
81109b18:	01604534 	movhi	r5,33044
81109b1c:	2949b504 	addi	r5,r5,9940
81109b20:	1809883a 	mov	r4,r3
81109b24:	1116c1c0 	call	81116c1c <fprintf>
					#endif
					break;
81109b28:	00000506 	br	81109b40 <vFeeTask0+0x37c>
					} else {

						/* todo: Criar funo de tratamento de erro*/
					}

					break;
81109b2c:	0001883a 	nop
81109b30:	003f3a06 	br	8110981c <__reset+0xfb0e981c>
					} else {

						/* todo: Criar funo de tratamento de erro*/
					}

					break;
81109b34:	0001883a 	nop
81109b38:	003f3806 	br	8110981c <__reset+0xfb0e981c>
					} else {

						/* todo: Criar funo de tratamento de erro*/
					}

					break;
81109b3c:	0001883a 	nop
						fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
					#endif
					break;
			}

		}
81109b40:	003f3606 	br	8110981c <__reset+0xfb0e981c>

81109b44 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81109b44:	defff604 	addi	sp,sp,-40
81109b48:	de00012e 	bgeu	sp,et,81109b50 <vInAckHandlerTaskV2+0xc>
81109b4c:	003b68fa 	trap	3
81109b50:	dfc00915 	stw	ra,36(sp)
81109b54:	df000815 	stw	fp,32(sp)
81109b58:	df000804 	addi	fp,sp,32
81109b5c:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
81109b60:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
81109b64:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81109b68:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81109b6c:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
81109b70:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
81109b74:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
81109b78:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
81109b7c:	d0a05517 	ldw	r2,-32428(gp)
81109b80:	100f883a 	mov	r7,r2
81109b84:	018007c4 	movi	r6,31
81109b88:	01400044 	movi	r5,1
81109b8c:	01204534 	movhi	r4,33044
81109b90:	210b1004 	addi	r4,r4,11328
81109b94:	11172b80 	call	811172b8 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
81109b98:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81109b9c:	e0bff917 	ldw	r2,-28(fp)
81109ba0:	10c00060 	cmpeqi	r3,r2,1
81109ba4:	1800071e 	bne	r3,zero,81109bc4 <vInAckHandlerTaskV2+0x80>
81109ba8:	0080032e 	bgeu	zero,r2,81109bb8 <vInAckHandlerTaskV2+0x74>
81109bac:	108000a0 	cmpeqi	r2,r2,2
81109bb0:	10004a1e 	bne	r2,zero,81109cdc <vInAckHandlerTaskV2+0x198>
81109bb4:	0000ac06 	br	81109e68 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
81109bb8:	00800044 	movi	r2,1
81109bbc:	e0bff915 	stw	r2,-28(fp)
				break;
81109bc0:	0000b306 	br	81109e90 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81109bc4:	00800044 	movi	r2,1
81109bc8:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
81109bcc:	d0a05917 	ldw	r2,-32412(gp)
81109bd0:	e0fffe04 	addi	r3,fp,-8
81109bd4:	180d883a 	mov	r6,r3
81109bd8:	000b883a 	mov	r5,zero
81109bdc:	1009883a 	mov	r4,r2
81109be0:	1134cf80 	call	81134cf8 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81109be4:	e0bffe03 	ldbu	r2,-8(fp)
81109be8:	10803fcc 	andi	r2,r2,255
81109bec:	1000391e 	bne	r2,zero,81109cd4 <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
81109bf0:	d0a05817 	ldw	r2,-32416(gp)
81109bf4:	e0fffe04 	addi	r3,fp,-8
81109bf8:	180d883a 	mov	r6,r3
81109bfc:	000b883a 	mov	r5,zero
81109c00:	1009883a 	mov	r4,r2
81109c04:	1132cec0 	call	81132cec <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81109c08:	e0bffe03 	ldbu	r2,-8(fp)
81109c0c:	10803fcc 	andi	r2,r2,255
81109c10:	10002b1e 	bne	r2,zero,81109cc0 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81109c14:	e03ffa45 	stb	zero,-23(fp)
81109c18:	00002206 	br	81109ca4 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
81109c1c:	e0fffa43 	ldbu	r3,-23(fp)
81109c20:	00a04574 	movhi	r2,33045
81109c24:	109b5304 	addi	r2,r2,27980
81109c28:	18c7883a 	add	r3,r3,r3
81109c2c:	18c7883a 	add	r3,r3,r3
81109c30:	10c5883a 	add	r2,r2,r3
81109c34:	10800003 	ldbu	r2,0(r2)
81109c38:	10803fcc 	andi	r2,r2,255
81109c3c:	1080201c 	xori	r2,r2,128
81109c40:	10bfe004 	addi	r2,r2,-128
81109c44:	10001426 	beq	r2,zero,81109c98 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
81109c48:	e0fffa43 	ldbu	r3,-23(fp)
81109c4c:	00a04574 	movhi	r2,33045
81109c50:	109b5304 	addi	r2,r2,27980
81109c54:	18c7883a 	add	r3,r3,r3
81109c58:	18c7883a 	add	r3,r3,r3
81109c5c:	10c5883a 	add	r2,r2,r3
81109c60:	10c0000b 	ldhu	r3,0(r2)
81109c64:	d0e04d0d 	sth	r3,-32460(gp)
81109c68:	1080008b 	ldhu	r2,2(r2)
81109c6c:	d0a04d8d 	sth	r2,-32458(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81109c70:	e0fffa43 	ldbu	r3,-23(fp)
81109c74:	00a04574 	movhi	r2,33045
81109c78:	109b5304 	addi	r2,r2,27980
81109c7c:	18c7883a 	add	r3,r3,r3
81109c80:	18c7883a 	add	r3,r3,r3
81109c84:	10c5883a 	add	r2,r2,r3
81109c88:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81109c8c:	00800084 	movi	r2,2
81109c90:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81109c94:	00000606 	br	81109cb0 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81109c98:	e0bffa43 	ldbu	r2,-23(fp)
81109c9c:	10800044 	addi	r2,r2,1
81109ca0:	e0bffa45 	stb	r2,-23(fp)
81109ca4:	e0bffa43 	ldbu	r2,-23(fp)
81109ca8:	108001b0 	cmpltui	r2,r2,6
81109cac:	103fdb1e 	bne	r2,zero,81109c1c <__reset+0xfb0e9c1c>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
81109cb0:	d0a05817 	ldw	r2,-32416(gp)
81109cb4:	1009883a 	mov	r4,r2
81109cb8:	11332900 	call	81133290 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81109cbc:	00007406 	br	81109e90 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
81109cc0:	d0a05917 	ldw	r2,-32412(gp)
81109cc4:	1009883a 	mov	r4,r2
81109cc8:	11350800 	call	81135080 <OSSemPost>
                    	vFailGetMutexReceiverTask();
81109ccc:	11126f40 	call	811126f4 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81109cd0:	00006f06 	br	81109e90 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
81109cd4:	111268c0 	call	8111268c <vFailGetCountSemaphoreReceiverTask>
                }
                break;
81109cd8:	00006d06 	br	81109e90 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
81109cdc:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81109ce0:	d0a05b83 	ldbu	r2,-32402(gp)
81109ce4:	10803fcc 	andi	r2,r2,255
81109ce8:	10800218 	cmpnei	r2,r2,8
81109cec:	1000021e 	bne	r2,zero,81109cf8 <vInAckHandlerTaskV2+0x1b4>
81109cf0:	00c00104 	movi	r3,4
81109cf4:	00000106 	br	81109cfc <vInAckHandlerTaskV2+0x1b8>
81109cf8:	0007883a 	mov	r3,zero
81109cfc:	d0a06603 	ldbu	r2,-32360(gp)
81109d00:	10803fcc 	andi	r2,r2,255
81109d04:	10800218 	cmpnei	r2,r2,8
81109d08:	1000021e 	bne	r2,zero,81109d14 <vInAckHandlerTaskV2+0x1d0>
81109d0c:	00800084 	movi	r2,2
81109d10:	00000106 	br	81109d18 <vInAckHandlerTaskV2+0x1d4>
81109d14:	0005883a 	mov	r2,zero
81109d18:	1884b03a 	or	r2,r3,r2
81109d1c:	1007883a 	mov	r3,r2
81109d20:	d0a06643 	ldbu	r2,-32359(gp)
81109d24:	10803fcc 	andi	r2,r2,255
81109d28:	108001a0 	cmpeqi	r2,r2,6
81109d2c:	1884b03a 	or	r2,r3,r2
81109d30:	1007883a 	mov	r3,r2
81109d34:	e0bffa83 	ldbu	r2,-22(fp)
81109d38:	1884b03a 	or	r2,r3,r2
81109d3c:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81109d40:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81109d44:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
81109d48:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
81109d4c:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81109d50:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81109d54:	e0bffa03 	ldbu	r2,-24(fp)
81109d58:	10800044 	addi	r2,r2,1
81109d5c:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81109d60:	e0bffa83 	ldbu	r2,-22(fp)
81109d64:	1080004c 	andi	r2,r2,1
81109d68:	10803fcc 	andi	r2,r2,255
81109d6c:	1000061e 	bne	r2,zero,81109d88 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81109d70:	e0bffd04 	addi	r2,fp,-12
81109d74:	100b883a 	mov	r5,r2
81109d78:	d1204d04 	addi	r4,gp,-32460
81109d7c:	1109e940 	call	81109e94 <bCheckInAck128>
81109d80:	e0bff815 	stw	r2,-32(fp)
81109d84:	00000206 	br	81109d90 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
81109d88:	00800044 	movi	r2,1
81109d8c:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
81109d90:	e0bffa83 	ldbu	r2,-22(fp)
81109d94:	1080008c 	andi	r2,r2,2
81109d98:	10803fcc 	andi	r2,r2,255
81109d9c:	1000081e 	bne	r2,zero,81109dc0 <vInAckHandlerTaskV2+0x27c>
81109da0:	e0bff817 	ldw	r2,-32(fp)
81109da4:	1000061e 	bne	r2,zero,81109dc0 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
81109da8:	e0bffc04 	addi	r2,fp,-16
81109dac:	100b883a 	mov	r5,r2
81109db0:	d1204d04 	addi	r4,gp,-32460
81109db4:	1109fdc0 	call	81109fdc <bCheckInAck64>
81109db8:	e0bff815 	stw	r2,-32(fp)
81109dbc:	00000206 	br	81109dc8 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
81109dc0:	00800044 	movi	r2,1
81109dc4:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
81109dc8:	e0bffa83 	ldbu	r2,-22(fp)
81109dcc:	1080010c 	andi	r2,r2,4
81109dd0:	10803fcc 	andi	r2,r2,255
81109dd4:	1000081e 	bne	r2,zero,81109df8 <vInAckHandlerTaskV2+0x2b4>
81109dd8:	e0bff817 	ldw	r2,-32(fp)
81109ddc:	1000061e 	bne	r2,zero,81109df8 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
81109de0:	e0bffb04 	addi	r2,fp,-20
81109de4:	100b883a 	mov	r5,r2
81109de8:	d1204d04 	addi	r4,gp,-32460
81109dec:	110a1280 	call	8110a128 <bCheckInAck32>
81109df0:	e0bff815 	stw	r2,-32(fp)
81109df4:	00000206 	br	81109e00 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
81109df8:	00800044 	movi	r2,1
81109dfc:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
81109e00:	e0bffa03 	ldbu	r2,-24(fp)
81109e04:	10c00044 	addi	r3,r2,1
81109e08:	e0fffa05 	stb	r3,-24(fp)
81109e0c:	10803fcc 	andi	r2,r2,255
81109e10:	10800ca8 	cmpgeui	r2,r2,50
81109e14:	10000e1e 	bne	r2,zero,81109e50 <vInAckHandlerTaskV2+0x30c>
81109e18:	e0bff817 	ldw	r2,-32(fp)
81109e1c:	10000c1e 	bne	r2,zero,81109e50 <vInAckHandlerTaskV2+0x30c>
81109e20:	e0bffb17 	ldw	r2,-20(fp)
81109e24:	1005003a 	cmpeq	r2,r2,zero
81109e28:	1007883a 	mov	r3,r2
81109e2c:	e0bffc17 	ldw	r2,-16(fp)
81109e30:	1005003a 	cmpeq	r2,r2,zero
81109e34:	1884b03a 	or	r2,r3,r2
81109e38:	10c03fcc 	andi	r3,r2,255
81109e3c:	e0bffd17 	ldw	r2,-12(fp)
81109e40:	1005003a 	cmpeq	r2,r2,zero
81109e44:	10803fcc 	andi	r2,r2,255
81109e48:	1884b03a 	or	r2,r3,r2
81109e4c:	103fc11e 	bne	r2,zero,81109d54 <__reset+0xfb0e9d54>
                
                if (bFound == FALSE) {
81109e50:	e0bff817 	ldw	r2,-32(fp)
81109e54:	1000011e 	bne	r2,zero,81109e5c <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
81109e58:	1112bb00 	call	81112bb0 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
81109e5c:	00800044 	movi	r2,1
81109e60:	e0bff915 	stw	r2,-28(fp)
				break;
81109e64:	00000a06 	br	81109e90 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81109e68:	d0a05517 	ldw	r2,-32428(gp)
81109e6c:	100f883a 	mov	r7,r2
81109e70:	01801144 	movi	r6,69
81109e74:	01400044 	movi	r5,1
81109e78:	01204534 	movhi	r4,33044
81109e7c:	210b1804 	addi	r4,r4,11360
81109e80:	11172b80 	call	811172b8 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
81109e84:	00800044 	movi	r2,1
81109e88:	e0bff915 	stw	r2,-28(fp)
				break;
81109e8c:	0001883a 	nop
		}
	}
81109e90:	003f4206 	br	81109b9c <__reset+0xfb0e9b9c>

81109e94 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81109e94:	defffa04 	addi	sp,sp,-24
81109e98:	de00012e 	bgeu	sp,et,81109ea0 <bCheckInAck128+0xc>
81109e9c:	003b68fa 	trap	3
81109ea0:	dfc00515 	stw	ra,20(sp)
81109ea4:	df000415 	stw	fp,16(sp)
81109ea8:	df000404 	addi	fp,sp,16
81109eac:	e13ffe15 	stw	r4,-8(fp)
81109eb0:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81109eb4:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81109eb8:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81109ebc:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81109ec0:	e0bfff17 	ldw	r2,-4(fp)
81109ec4:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
81109ec8:	d0a06017 	ldw	r2,-32384(gp)
81109ecc:	e0fffd44 	addi	r3,fp,-11
81109ed0:	180d883a 	mov	r6,r3
81109ed4:	01400144 	movi	r5,5
81109ed8:	1009883a 	mov	r4,r2
81109edc:	1132cec0 	call	81132cec <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81109ee0:	e0bffd43 	ldbu	r2,-11(fp)
81109ee4:	10803fcc 	andi	r2,r2,255
81109ee8:	10000226 	beq	r2,zero,81109ef4 <bCheckInAck128+0x60>
        return bFound;
81109eec:	e0bffc17 	ldw	r2,-16(fp)
81109ef0:	00003506 	br	81109fc8 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81109ef4:	e03ffd05 	stb	zero,-12(fp)
81109ef8:	00002706 	br	81109f98 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
81109efc:	e0fffd03 	ldbu	r3,-12(fp)
81109f00:	00a04574 	movhi	r2,33045
81109f04:	10926304 	addi	r2,r2,18828
81109f08:	18c02324 	muli	r3,r3,140
81109f0c:	10c5883a 	add	r2,r2,r3
81109f10:	10802104 	addi	r2,r2,132
81109f14:	10c0000b 	ldhu	r3,0(r2)
81109f18:	e0bffe17 	ldw	r2,-8(fp)
81109f1c:	1080008b 	ldhu	r2,2(r2)
81109f20:	18ffffcc 	andi	r3,r3,65535
81109f24:	10bfffcc 	andi	r2,r2,65535
81109f28:	1880181e 	bne	r3,r2,81109f8c <bCheckInAck128+0xf8>
            bFound = TRUE;
81109f2c:	00800044 	movi	r2,1
81109f30:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
81109f34:	e0fffd03 	ldbu	r3,-12(fp)
81109f38:	00a04574 	movhi	r2,33045
81109f3c:	10924504 	addi	r2,r2,18708
81109f40:	18c7883a 	add	r3,r3,r3
81109f44:	18c7883a 	add	r3,r3,r3
81109f48:	10c5883a 	add	r2,r2,r3
81109f4c:	10000015 	stw	zero,0(r2)
            SemCount128++;
81109f50:	d0a06643 	ldbu	r2,-32359(gp)
81109f54:	10800044 	addi	r2,r2,1
81109f58:	d0a06645 	stb	r2,-32359(gp)
            error_code = OSSemPost(xSemCountBuffer128);
81109f5c:	d0a05617 	ldw	r2,-32424(gp)
81109f60:	1009883a 	mov	r4,r2
81109f64:	11350800 	call	81135080 <OSSemPost>
81109f68:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81109f6c:	e0bffd43 	ldbu	r2,-11(fp)
81109f70:	10803fcc 	andi	r2,r2,255
81109f74:	10000c26 	beq	r2,zero,81109fa8 <bCheckInAck128+0x114>
                SemCount128--;
81109f78:	d0a06643 	ldbu	r2,-32359(gp)
81109f7c:	10bfffc4 	addi	r2,r2,-1
81109f80:	d0a06645 	stb	r2,-32359(gp)
                vFailSetCountSemaphorexBuffer128();
81109f84:	1112a100 	call	81112a10 <vFailSetCountSemaphorexBuffer128>
            }
            break;
81109f88:	00000706 	br	81109fa8 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81109f8c:	e0bffd03 	ldbu	r2,-12(fp)
81109f90:	10800044 	addi	r2,r2,1
81109f94:	e0bffd05 	stb	r2,-12(fp)
81109f98:	e0bffd03 	ldbu	r2,-12(fp)
81109f9c:	108001b0 	cmpltui	r2,r2,6
81109fa0:	103fd61e 	bne	r2,zero,81109efc <__reset+0xfb0e9efc>
81109fa4:	00000106 	br	81109fac <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
81109fa8:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81109fac:	d0a06017 	ldw	r2,-32384(gp)
81109fb0:	1009883a 	mov	r4,r2
81109fb4:	11332900 	call	81133290 <OSMutexPost>
    (*bFinished) = TRUE;
81109fb8:	e0bfff17 	ldw	r2,-4(fp)
81109fbc:	00c00044 	movi	r3,1
81109fc0:	10c00015 	stw	r3,0(r2)

    return bFound;
81109fc4:	e0bffc17 	ldw	r2,-16(fp)
}
81109fc8:	e037883a 	mov	sp,fp
81109fcc:	dfc00117 	ldw	ra,4(sp)
81109fd0:	df000017 	ldw	fp,0(sp)
81109fd4:	dec00204 	addi	sp,sp,8
81109fd8:	f800283a 	ret

81109fdc <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
81109fdc:	defffa04 	addi	sp,sp,-24
81109fe0:	de00012e 	bgeu	sp,et,81109fe8 <bCheckInAck64+0xc>
81109fe4:	003b68fa 	trap	3
81109fe8:	dfc00515 	stw	ra,20(sp)
81109fec:	df000415 	stw	fp,16(sp)
81109ff0:	df000404 	addi	fp,sp,16
81109ff4:	e13ffe15 	stw	r4,-8(fp)
81109ff8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81109ffc:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110a000:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110a004:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110a008:	e0bfff17 	ldw	r2,-4(fp)
8110a00c:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110a010:	d0a06217 	ldw	r2,-32376(gp)
8110a014:	e0fffd44 	addi	r3,fp,-11
8110a018:	180d883a 	mov	r6,r3
8110a01c:	01400044 	movi	r5,1
8110a020:	1009883a 	mov	r4,r2
8110a024:	1132cec0 	call	81132cec <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110a028:	e0bffd43 	ldbu	r2,-11(fp)
8110a02c:	10803fcc 	andi	r2,r2,255
8110a030:	10000226 	beq	r2,zero,8110a03c <bCheckInAck64+0x60>
        return bFound;
8110a034:	e0bffc17 	ldw	r2,-16(fp)
8110a038:	00003606 	br	8110a114 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110a03c:	e03ffd05 	stb	zero,-12(fp)
8110a040:	00002806 	br	8110a0e4 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
8110a044:	e0fffd03 	ldbu	r3,-12(fp)
8110a048:	00a04574 	movhi	r2,33045
8110a04c:	10ab5504 	addi	r2,r2,-21164
8110a050:	18c01324 	muli	r3,r3,76
8110a054:	10c5883a 	add	r2,r2,r3
8110a058:	10801104 	addi	r2,r2,68
8110a05c:	10c0000b 	ldhu	r3,0(r2)
8110a060:	e0bffe17 	ldw	r2,-8(fp)
8110a064:	1080008b 	ldhu	r2,2(r2)
8110a068:	18ffffcc 	andi	r3,r3,65535
8110a06c:	10bfffcc 	andi	r2,r2,65535
8110a070:	1880191e 	bne	r3,r2,8110a0d8 <bCheckInAck64+0xfc>
            bFound = TRUE;
8110a074:	00800044 	movi	r2,1
8110a078:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
8110a07c:	e0fffd03 	ldbu	r3,-12(fp)
8110a080:	00a04574 	movhi	r2,33045
8110a084:	10924504 	addi	r2,r2,18708
8110a088:	18c00184 	addi	r3,r3,6
8110a08c:	18c7883a 	add	r3,r3,r3
8110a090:	18c7883a 	add	r3,r3,r3
8110a094:	10c5883a 	add	r2,r2,r3
8110a098:	10000015 	stw	zero,0(r2)
            SemCount64++;
8110a09c:	d0a06603 	ldbu	r2,-32360(gp)
8110a0a0:	10800044 	addi	r2,r2,1
8110a0a4:	d0a06605 	stb	r2,-32360(gp)
            error_code = OSSemPost(xSemCountBuffer64);
8110a0a8:	d0a05217 	ldw	r2,-32440(gp)
8110a0ac:	1009883a 	mov	r4,r2
8110a0b0:	11350800 	call	81135080 <OSSemPost>
8110a0b4:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110a0b8:	e0bffd43 	ldbu	r2,-11(fp)
8110a0bc:	10803fcc 	andi	r2,r2,255
8110a0c0:	10000c26 	beq	r2,zero,8110a0f4 <bCheckInAck64+0x118>
                SemCount64--;
8110a0c4:	d0a06603 	ldbu	r2,-32360(gp)
8110a0c8:	10bfffc4 	addi	r2,r2,-1
8110a0cc:	d0a06605 	stb	r2,-32360(gp)
                vFailSetCountSemaphorexBuffer64();
8110a0d0:	11129a80 	call	811129a8 <vFailSetCountSemaphorexBuffer64>
            }
            break;
8110a0d4:	00000706 	br	8110a0f4 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110a0d8:	e0bffd03 	ldbu	r2,-12(fp)
8110a0dc:	10800044 	addi	r2,r2,1
8110a0e0:	e0bffd05 	stb	r2,-12(fp)
8110a0e4:	e0bffd03 	ldbu	r2,-12(fp)
8110a0e8:	10800230 	cmpltui	r2,r2,8
8110a0ec:	103fd51e 	bne	r2,zero,8110a044 <__reset+0xfb0ea044>
8110a0f0:	00000106 	br	8110a0f8 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
8110a0f4:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
8110a0f8:	d0a06217 	ldw	r2,-32376(gp)
8110a0fc:	1009883a 	mov	r4,r2
8110a100:	11332900 	call	81133290 <OSMutexPost>
    (*bFinished) = TRUE;
8110a104:	e0bfff17 	ldw	r2,-4(fp)
8110a108:	00c00044 	movi	r3,1
8110a10c:	10c00015 	stw	r3,0(r2)

    return bFound;
8110a110:	e0bffc17 	ldw	r2,-16(fp)
}
8110a114:	e037883a 	mov	sp,fp
8110a118:	dfc00117 	ldw	ra,4(sp)
8110a11c:	df000017 	ldw	fp,0(sp)
8110a120:	dec00204 	addi	sp,sp,8
8110a124:	f800283a 	ret

8110a128 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
8110a128:	defffa04 	addi	sp,sp,-24
8110a12c:	de00012e 	bgeu	sp,et,8110a134 <bCheckInAck32+0xc>
8110a130:	003b68fa 	trap	3
8110a134:	dfc00515 	stw	ra,20(sp)
8110a138:	df000415 	stw	fp,16(sp)
8110a13c:	df000404 	addi	fp,sp,16
8110a140:	e13ffe15 	stw	r4,-8(fp)
8110a144:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110a148:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110a14c:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110a150:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110a154:	e0bfff17 	ldw	r2,-4(fp)
8110a158:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110a15c:	d0a05e17 	ldw	r2,-32392(gp)
8110a160:	e0fffd44 	addi	r3,fp,-11
8110a164:	180d883a 	mov	r6,r3
8110a168:	01400044 	movi	r5,1
8110a16c:	1009883a 	mov	r4,r2
8110a170:	1132cec0 	call	81132cec <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110a174:	e0bffd43 	ldbu	r2,-11(fp)
8110a178:	10803fcc 	andi	r2,r2,255
8110a17c:	10000226 	beq	r2,zero,8110a188 <bCheckInAck32+0x60>
        return bFound;
8110a180:	e0bffc17 	ldw	r2,-16(fp)
8110a184:	00003606 	br	8110a260 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110a188:	e03ffd05 	stb	zero,-12(fp)
8110a18c:	00002806 	br	8110a230 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
8110a190:	e0fffd03 	ldbu	r3,-12(fp)
8110a194:	00a04574 	movhi	r2,33045
8110a198:	10bfd904 	addi	r2,r2,-156
8110a19c:	18c00b24 	muli	r3,r3,44
8110a1a0:	10c5883a 	add	r2,r2,r3
8110a1a4:	10800904 	addi	r2,r2,36
8110a1a8:	10c0000b 	ldhu	r3,0(r2)
8110a1ac:	e0bffe17 	ldw	r2,-8(fp)
8110a1b0:	1080008b 	ldhu	r2,2(r2)
8110a1b4:	18ffffcc 	andi	r3,r3,65535
8110a1b8:	10bfffcc 	andi	r2,r2,65535
8110a1bc:	1880191e 	bne	r3,r2,8110a224 <bCheckInAck32+0xfc>
            bFound = TRUE;
8110a1c0:	00800044 	movi	r2,1
8110a1c4:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
8110a1c8:	e0fffd03 	ldbu	r3,-12(fp)
8110a1cc:	00a04574 	movhi	r2,33045
8110a1d0:	10924504 	addi	r2,r2,18708
8110a1d4:	18c00384 	addi	r3,r3,14
8110a1d8:	18c7883a 	add	r3,r3,r3
8110a1dc:	18c7883a 	add	r3,r3,r3
8110a1e0:	10c5883a 	add	r2,r2,r3
8110a1e4:	10000015 	stw	zero,0(r2)
            SemCount32++;
8110a1e8:	d0a05b83 	ldbu	r2,-32402(gp)
8110a1ec:	10800044 	addi	r2,r2,1
8110a1f0:	d0a05b85 	stb	r2,-32402(gp)
            error_code = OSSemPost(xSemCountBuffer32);
8110a1f4:	d0a06117 	ldw	r2,-32380(gp)
8110a1f8:	1009883a 	mov	r4,r2
8110a1fc:	11350800 	call	81135080 <OSSemPost>
8110a200:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110a204:	e0bffd43 	ldbu	r2,-11(fp)
8110a208:	10803fcc 	andi	r2,r2,255
8110a20c:	10000c26 	beq	r2,zero,8110a240 <bCheckInAck32+0x118>
                SemCount32--;
8110a210:	d0a05b83 	ldbu	r2,-32402(gp)
8110a214:	10bfffc4 	addi	r2,r2,-1
8110a218:	d0a05b85 	stb	r2,-32402(gp)
                vFailSetCountSemaphorexBuffer32();
8110a21c:	11129400 	call	81112940 <vFailSetCountSemaphorexBuffer32>
            }
            break;
8110a220:	00000706 	br	8110a240 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110a224:	e0bffd03 	ldbu	r2,-12(fp)
8110a228:	10800044 	addi	r2,r2,1
8110a22c:	e0bffd05 	stb	r2,-12(fp)
8110a230:	e0bffd03 	ldbu	r2,-12(fp)
8110a234:	10800230 	cmpltui	r2,r2,8
8110a238:	103fd51e 	bne	r2,zero,8110a190 <__reset+0xfb0ea190>
8110a23c:	00000106 	br	8110a244 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
8110a240:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
8110a244:	d0a05e17 	ldw	r2,-32392(gp)
8110a248:	1009883a 	mov	r4,r2
8110a24c:	11332900 	call	81133290 <OSMutexPost>
    (*bFinished) = TRUE;
8110a250:	e0bfff17 	ldw	r2,-4(fp)
8110a254:	00c00044 	movi	r3,1
8110a258:	10c00015 	stw	r3,0(r2)

    return bFound;
8110a25c:	e0bffc17 	ldw	r2,-16(fp)
}
8110a260:	e037883a 	mov	sp,fp
8110a264:	dfc00117 	ldw	ra,4(sp)
8110a268:	df000017 	ldw	fp,0(sp)
8110a26c:	dec00204 	addi	sp,sp,8
8110a270:	f800283a 	ret

8110a274 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
8110a274:	defff704 	addi	sp,sp,-36
8110a278:	de00012e 	bgeu	sp,et,8110a280 <vInitialTask+0xc>
8110a27c:	003b68fa 	trap	3
8110a280:	dfc00815 	stw	ra,32(sp)
8110a284:	df000715 	stw	fp,28(sp)
8110a288:	df000704 	addi	fp,sp,28
8110a28c:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
8110a290:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask0,
8110a294:	d8000415 	stw	zero,16(sp)
8110a298:	d8000315 	stw	zero,12(sp)
8110a29c:	00810004 	movi	r2,1024
8110a2a0:	d8800215 	stw	r2,8(sp)
8110a2a4:	00a04574 	movhi	r2,33045
8110a2a8:	10a35504 	addi	r2,r2,-29356
8110a2ac:	d8800115 	stw	r2,4(sp)
8110a2b0:	00800244 	movi	r2,9
8110a2b4:	d8800015 	stw	r2,0(sp)
8110a2b8:	01c00244 	movi	r7,9
8110a2bc:	01a04574 	movhi	r6,33045
8110a2c0:	31a75404 	addi	r6,r6,-25264
8110a2c4:	01604574 	movhi	r5,33045
8110a2c8:	29787004 	addi	r5,r5,-7744
8110a2cc:	01204474 	movhi	r4,33041
8110a2d0:	2125f104 	addi	r4,r4,-26684
8110a2d4:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a2d8:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a2dc:	e0bffe03 	ldbu	r2,-8(fp)
8110a2e0:	10803fcc 	andi	r2,r2,255
8110a2e4:	10000526 	beq	r2,zero,8110a2fc <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a2e8:	e0bffe03 	ldbu	r2,-8(fp)
8110a2ec:	10803fcc 	andi	r2,r2,255
8110a2f0:	1009883a 	mov	r4,r2
8110a2f4:	11123080 	call	81112308 <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
8110a2f8:	11136f80 	call	811136f8 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110a2fc:	01c17704 	movi	r7,1500
8110a300:	000d883a 	mov	r6,zero
8110a304:	000b883a 	mov	r5,zero
8110a308:	0009883a 	mov	r4,zero
8110a30c:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vFeeTask1_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110a310:	d8000415 	stw	zero,16(sp)
8110a314:	d8000315 	stw	zero,12(sp)
8110a318:	00810004 	movi	r2,1024
8110a31c:	d8800215 	stw	r2,8(sp)
8110a320:	00a04574 	movhi	r2,33045
8110a324:	109b5904 	addi	r2,r2,28004
8110a328:	d8800115 	stw	r2,4(sp)
8110a32c:	00800284 	movi	r2,10
8110a330:	d8800015 	stw	r2,0(sp)
8110a334:	01c00284 	movi	r7,10
8110a338:	01a04574 	movhi	r6,33045
8110a33c:	319f5804 	addi	r6,r6,32096
8110a340:	01604574 	movhi	r5,33045
8110a344:	2978ff04 	addi	r5,r5,-7172
8110a348:	01204474 	movhi	r4,33041
8110a34c:	2121e204 	addi	r4,r4,-30840
8110a350:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a354:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a358:	e0bffe03 	ldbu	r2,-8(fp)
8110a35c:	10803fcc 	andi	r2,r2,255
8110a360:	10000526 	beq	r2,zero,8110a378 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a364:	e0bffe03 	ldbu	r2,-8(fp)
8110a368:	10803fcc 	andi	r2,r2,255
8110a36c:	1009883a 	mov	r4,r2
8110a370:	11123080 	call	81112308 <printErrorTask>
		#endif
			vCoudlNotCreateNFee1Task();
8110a374:	11137600 	call	81113760 <vCoudlNotCreateNFee1Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110a378:	01c17704 	movi	r7,1500
8110a37c:	000d883a 	mov	r6,zero
8110a380:	000b883a 	mov	r5,zero
8110a384:	0009883a 	mov	r4,zero
8110a388:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vFeeTask2_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110a38c:	d8000415 	stw	zero,16(sp)
8110a390:	d8000315 	stw	zero,12(sp)
8110a394:	00810004 	movi	r2,1024
8110a398:	d8800215 	stw	r2,8(sp)
8110a39c:	00a045b4 	movhi	r2,33046
8110a3a0:	10ad5904 	addi	r2,r2,-19100
8110a3a4:	d8800115 	stw	r2,4(sp)
8110a3a8:	008002c4 	movi	r2,11
8110a3ac:	d8800015 	stw	r2,0(sp)
8110a3b0:	01c002c4 	movi	r7,11
8110a3b4:	01a045b4 	movhi	r6,33046
8110a3b8:	31b15804 	addi	r6,r6,-15008
8110a3bc:	01604574 	movhi	r5,33045
8110a3c0:	29798e04 	addi	r5,r5,-6600
8110a3c4:	01204474 	movhi	r4,33041
8110a3c8:	2121e204 	addi	r4,r4,-30840
8110a3cc:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a3d0:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a3d4:	e0bffe03 	ldbu	r2,-8(fp)
8110a3d8:	10803fcc 	andi	r2,r2,255
8110a3dc:	10000526 	beq	r2,zero,8110a3f4 <vInitialTask+0x180>
		//* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a3e0:	e0bffe03 	ldbu	r2,-8(fp)
8110a3e4:	10803fcc 	andi	r2,r2,255
8110a3e8:	1009883a 	mov	r4,r2
8110a3ec:	11123080 	call	81112308 <printErrorTask>
		#endif
			vCoudlNotCreateNFee2Task();
8110a3f0:	11137c80 	call	811137c8 <vCoudlNotCreateNFee2Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110a3f4:	01c17704 	movi	r7,1500
8110a3f8:	000d883a 	mov	r6,zero
8110a3fc:	000b883a 	mov	r5,zero
8110a400:	0009883a 	mov	r4,zero
8110a404:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vFeeTask3_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110a408:	d8000415 	stw	zero,16(sp)
8110a40c:	d8000315 	stw	zero,12(sp)
8110a410:	00810004 	movi	r2,1024
8110a414:	d8800215 	stw	r2,8(sp)
8110a418:	00a045b4 	movhi	r2,33046
8110a41c:	10a95904 	addi	r2,r2,-23196
8110a420:	d8800115 	stw	r2,4(sp)
8110a424:	00800304 	movi	r2,12
8110a428:	d8800015 	stw	r2,0(sp)
8110a42c:	01c00304 	movi	r7,12
8110a430:	01a045b4 	movhi	r6,33046
8110a434:	31ad5804 	addi	r6,r6,-19104
8110a438:	01604574 	movhi	r5,33045
8110a43c:	297a1d04 	addi	r5,r5,-6028
8110a440:	01204474 	movhi	r4,33041
8110a444:	2121e204 	addi	r4,r4,-30840
8110a448:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a44c:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a450:	e0bffe03 	ldbu	r2,-8(fp)
8110a454:	10803fcc 	andi	r2,r2,255
8110a458:	10000526 	beq	r2,zero,8110a470 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a45c:	e0bffe03 	ldbu	r2,-8(fp)
8110a460:	10803fcc 	andi	r2,r2,255
8110a464:	1009883a 	mov	r4,r2
8110a468:	11123080 	call	81112308 <printErrorTask>
		#endif
			vCoudlNotCreateNFee3Task();
8110a46c:	11138300 	call	81113830 <vCoudlNotCreateNFee3Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110a470:	01c17704 	movi	r7,1500
8110a474:	000d883a 	mov	r6,zero
8110a478:	000b883a 	mov	r5,zero
8110a47c:	0009883a 	mov	r4,zero
8110a480:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vFeeTask4_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110a484:	d8000415 	stw	zero,16(sp)
8110a488:	d8000315 	stw	zero,12(sp)
8110a48c:	00810004 	movi	r2,1024
8110a490:	d8800215 	stw	r2,8(sp)
8110a494:	00a04574 	movhi	r2,33045
8110a498:	10975304 	addi	r2,r2,23884
8110a49c:	d8800115 	stw	r2,4(sp)
8110a4a0:	00800344 	movi	r2,13
8110a4a4:	d8800015 	stw	r2,0(sp)
8110a4a8:	01c00344 	movi	r7,13
8110a4ac:	01a04574 	movhi	r6,33045
8110a4b0:	319b5204 	addi	r6,r6,27976
8110a4b4:	01604574 	movhi	r5,33045
8110a4b8:	297aac04 	addi	r5,r5,-5456
8110a4bc:	01204474 	movhi	r4,33041
8110a4c0:	2121e204 	addi	r4,r4,-30840
8110a4c4:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a4c8:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a4cc:	e0bffe03 	ldbu	r2,-8(fp)
8110a4d0:	10803fcc 	andi	r2,r2,255
8110a4d4:	10000526 	beq	r2,zero,8110a4ec <vInitialTask+0x278>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a4d8:	e0bffe03 	ldbu	r2,-8(fp)
8110a4dc:	10803fcc 	andi	r2,r2,255
8110a4e0:	1009883a 	mov	r4,r2
8110a4e4:	11123080 	call	81112308 <printErrorTask>
		#endif
			vCoudlNotCreateNFee4Task();
8110a4e8:	11138980 	call	81113898 <vCoudlNotCreateNFee4Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110a4ec:	01c17704 	movi	r7,1500
8110a4f0:	000d883a 	mov	r6,zero
8110a4f4:	000b883a 	mov	r5,zero
8110a4f8:	0009883a 	mov	r4,zero
8110a4fc:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vFeeTask5_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110a500:	d8000415 	stw	zero,16(sp)
8110a504:	d8000315 	stw	zero,12(sp)
8110a508:	00810004 	movi	r2,1024
8110a50c:	d8800215 	stw	r2,8(sp)
8110a510:	00a04574 	movhi	r2,33045
8110a514:	10bbd904 	addi	r2,r2,-4252
8110a518:	d8800115 	stw	r2,4(sp)
8110a51c:	00800384 	movi	r2,14
8110a520:	d8800015 	stw	r2,0(sp)
8110a524:	01c00384 	movi	r7,14
8110a528:	01a04574 	movhi	r6,33045
8110a52c:	31bfd804 	addi	r6,r6,-160
8110a530:	01604574 	movhi	r5,33045
8110a534:	297b3b04 	addi	r5,r5,-4884
8110a538:	01204474 	movhi	r4,33041
8110a53c:	2121e204 	addi	r4,r4,-30840
8110a540:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a544:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a548:	e0bffe03 	ldbu	r2,-8(fp)
8110a54c:	10803fcc 	andi	r2,r2,255
8110a550:	10000526 	beq	r2,zero,8110a568 <vInitialTask+0x2f4>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a554:	e0bffe03 	ldbu	r2,-8(fp)
8110a558:	10803fcc 	andi	r2,r2,255
8110a55c:	1009883a 	mov	r4,r2
8110a560:	11123080 	call	81112308 <printErrorTask>
		#endif
			vCoudlNotCreateNFee5Task();
8110a564:	11139000 	call	81113900 <vCoudlNotCreateNFee5Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110a568:	01c17704 	movi	r7,1500
8110a56c:	000d883a 	mov	r6,zero
8110a570:	000b883a 	mov	r5,zero
8110a574:	0009883a 	mov	r4,zero
8110a578:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
8110a57c:	d8000415 	stw	zero,16(sp)
8110a580:	d8000315 	stw	zero,12(sp)
8110a584:	00810004 	movi	r2,1024
8110a588:	d8800215 	stw	r2,8(sp)
8110a58c:	00a04574 	movhi	r2,33045
8110a590:	10b45104 	addi	r2,r2,-11964
8110a594:	d8800115 	stw	r2,4(sp)
8110a598:	00800204 	movi	r2,8
8110a59c:	d8800015 	stw	r2,0(sp)
8110a5a0:	01c00204 	movi	r7,8
8110a5a4:	01a04574 	movhi	r6,33045
8110a5a8:	31b85004 	addi	r6,r6,-7872
8110a5ac:	01604574 	movhi	r5,33045
8110a5b0:	29785a04 	addi	r5,r5,-7832
8110a5b4:	01204474 	movhi	r4,33041
8110a5b8:	2121cb04 	addi	r4,r4,-30932
8110a5bc:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a5c0:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a5c4:	e0bffe03 	ldbu	r2,-8(fp)
8110a5c8:	10803fcc 	andi	r2,r2,255
8110a5cc:	10000526 	beq	r2,zero,8110a5e4 <vInitialTask+0x370>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a5d0:	e0bffe03 	ldbu	r2,-8(fp)
8110a5d4:	10803fcc 	andi	r2,r2,255
8110a5d8:	1009883a 	mov	r4,r2
8110a5dc:	11123080 	call	81112308 <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
8110a5e0:	11139d00 	call	811139d0 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110a5e4:	01c17704 	movi	r7,1500
8110a5e8:	000d883a 	mov	r6,zero
8110a5ec:	000b883a 	mov	r5,zero
8110a5f0:	0009883a 	mov	r4,zero
8110a5f4:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
8110a5f8:	d8000415 	stw	zero,16(sp)
8110a5fc:	d8000315 	stw	zero,12(sp)
8110a600:	00810004 	movi	r2,1024
8110a604:	d8800215 	stw	r2,8(sp)
8110a608:	00a04574 	movhi	r2,33045
8110a60c:	10934904 	addi	r2,r2,19748
8110a610:	d8800115 	stw	r2,4(sp)
8110a614:	008001c4 	movi	r2,7
8110a618:	d8800015 	stw	r2,0(sp)
8110a61c:	01c001c4 	movi	r7,7
8110a620:	01a04574 	movhi	r6,33045
8110a624:	31974804 	addi	r6,r6,23840
8110a628:	01604574 	movhi	r5,33045
8110a62c:	29787004 	addi	r5,r5,-7744
8110a630:	01204474 	movhi	r4,33041
8110a634:	212a9904 	addi	r4,r4,-21916
8110a638:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a63c:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a640:	e0bffe03 	ldbu	r2,-8(fp)
8110a644:	10803fcc 	andi	r2,r2,255
8110a648:	10000526 	beq	r2,zero,8110a660 <vInitialTask+0x3ec>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a64c:	e0bffe03 	ldbu	r2,-8(fp)
8110a650:	10803fcc 	andi	r2,r2,255
8110a654:	1009883a 	mov	r4,r2
8110a658:	11123080 	call	81112308 <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
8110a65c:	11139680 	call	81113968 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110a660:	01c17704 	movi	r7,1500
8110a664:	000d883a 	mov	r6,zero
8110a668:	000b883a 	mov	r5,zero
8110a66c:	0009883a 	mov	r4,zero
8110a670:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
8110a674:	d8000415 	stw	zero,16(sp)
8110a678:	d8000315 	stw	zero,12(sp)
8110a67c:	00810004 	movi	r2,1024
8110a680:	d8800215 	stw	r2,8(sp)
8110a684:	00a045b4 	movhi	r2,33046
8110a688:	10a55904 	addi	r2,r2,-27292
8110a68c:	d8800115 	stw	r2,4(sp)
8110a690:	00800184 	movi	r2,6
8110a694:	d8800015 	stw	r2,0(sp)
8110a698:	01c00184 	movi	r7,6
8110a69c:	01a045b4 	movhi	r6,33046
8110a6a0:	31a95804 	addi	r6,r6,-23200
8110a6a4:	01604574 	movhi	r5,33045
8110a6a8:	29785104 	addi	r5,r5,-7868
8110a6ac:	01204474 	movhi	r4,33041
8110a6b0:	2133cf04 	addi	r4,r4,-12484
8110a6b4:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a6b8:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a6bc:	e0bffe03 	ldbu	r2,-8(fp)
8110a6c0:	10803fcc 	andi	r2,r2,255
8110a6c4:	10000526 	beq	r2,zero,8110a6dc <vInitialTask+0x468>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a6c8:	e0bffe03 	ldbu	r2,-8(fp)
8110a6cc:	10803fcc 	andi	r2,r2,255
8110a6d0:	1009883a 	mov	r4,r2
8110a6d4:	11123080 	call	81112308 <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
8110a6d8:	1113a380 	call	81113a38 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110a6dc:	01c17704 	movi	r7,1500
8110a6e0:	000d883a 	mov	r6,zero
8110a6e4:	000b883a 	mov	r5,zero
8110a6e8:	0009883a 	mov	r4,zero
8110a6ec:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
8110a6f0:	d8000415 	stw	zero,16(sp)
8110a6f4:	d8000315 	stw	zero,12(sp)
8110a6f8:	00810004 	movi	r2,1024
8110a6fc:	d8800215 	stw	r2,8(sp)
8110a700:	00a04574 	movhi	r2,33045
8110a704:	10b05104 	addi	r2,r2,-16060
8110a708:	d8800115 	stw	r2,4(sp)
8110a70c:	00800784 	movi	r2,30
8110a710:	d8800015 	stw	r2,0(sp)
8110a714:	01c00784 	movi	r7,30
8110a718:	01a04574 	movhi	r6,33045
8110a71c:	31b45004 	addi	r6,r6,-11968
8110a720:	000b883a 	mov	r5,zero
8110a724:	01204474 	movhi	r4,33041
8110a728:	2139df04 	addi	r4,r4,-6276
8110a72c:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a730:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a734:	e0bffe03 	ldbu	r2,-8(fp)
8110a738:	10803fcc 	andi	r2,r2,255
8110a73c:	10000526 	beq	r2,zero,8110a754 <vInitialTask+0x4e0>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a740:	e0bffe03 	ldbu	r2,-8(fp)
8110a744:	10803fcc 	andi	r2,r2,255
8110a748:	1009883a 	mov	r4,r2
8110a74c:	11123080 	call	81112308 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
8110a750:	11130d40 	call	811130d4 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110a754:	01c03204 	movi	r7,200
8110a758:	000d883a 	mov	r6,zero
8110a75c:	000b883a 	mov	r5,zero
8110a760:	0009883a 	mov	r4,zero
8110a764:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
8110a768:	d8000415 	stw	zero,16(sp)
8110a76c:	d8000315 	stw	zero,12(sp)
8110a770:	00810004 	movi	r2,1024
8110a774:	d8800215 	stw	r2,8(sp)
8110a778:	00a04574 	movhi	r2,33045
8110a77c:	10864104 	addi	r2,r2,6404
8110a780:	d8800115 	stw	r2,4(sp)
8110a784:	008006c4 	movi	r2,27
8110a788:	d8800015 	stw	r2,0(sp)
8110a78c:	01c006c4 	movi	r7,27
8110a790:	01a04574 	movhi	r6,33045
8110a794:	318a4004 	addi	r6,r6,10496
8110a798:	000b883a 	mov	r5,zero
8110a79c:	01204474 	movhi	r4,33041
8110a7a0:	212c1104 	addi	r4,r4,-20412
8110a7a4:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a7a8:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a7ac:	e0bffe03 	ldbu	r2,-8(fp)
8110a7b0:	10803fcc 	andi	r2,r2,255
8110a7b4:	10000526 	beq	r2,zero,8110a7cc <vInitialTask+0x558>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a7b8:	e0bffe03 	ldbu	r2,-8(fp)
8110a7bc:	10803fcc 	andi	r2,r2,255
8110a7c0:	1009883a 	mov	r4,r2
8110a7c4:	11123080 	call	81112308 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
8110a7c8:	1112ff00 	call	81112ff0 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110a7cc:	01c03204 	movi	r7,200
8110a7d0:	000d883a 	mov	r6,zero
8110a7d4:	000b883a 	mov	r5,zero
8110a7d8:	0009883a 	mov	r4,zero
8110a7dc:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
8110a7e0:	d8000415 	stw	zero,16(sp)
8110a7e4:	d8000315 	stw	zero,12(sp)
8110a7e8:	00810004 	movi	r2,1024
8110a7ec:	d8800215 	stw	r2,8(sp)
8110a7f0:	00a04574 	movhi	r2,33045
8110a7f4:	10a75504 	addi	r2,r2,-25260
8110a7f8:	d8800115 	stw	r2,4(sp)
8110a7fc:	00800644 	movi	r2,25
8110a800:	d8800015 	stw	r2,0(sp)
8110a804:	01c00644 	movi	r7,25
8110a808:	01a04574 	movhi	r6,33045
8110a80c:	31ab5404 	addi	r6,r6,-21168
8110a810:	000b883a 	mov	r5,zero
8110a814:	01204474 	movhi	r4,33041
8110a818:	2126d104 	addi	r4,r4,-25788
8110a81c:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a820:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a824:	e0bffe03 	ldbu	r2,-8(fp)
8110a828:	10803fcc 	andi	r2,r2,255
8110a82c:	10000526 	beq	r2,zero,8110a844 <vInitialTask+0x5d0>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a830:	e0bffe03 	ldbu	r2,-8(fp)
8110a834:	10803fcc 	andi	r2,r2,255
8110a838:	1009883a 	mov	r4,r2
8110a83c:	11123080 	call	81112308 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
8110a840:	1112fa40 	call	81112fa4 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110a844:	01c03204 	movi	r7,200
8110a848:	000d883a 	mov	r6,zero
8110a84c:	000b883a 	mov	r5,zero
8110a850:	0009883a 	mov	r4,zero
8110a854:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
8110a858:	d8000415 	stw	zero,16(sp)
8110a85c:	d8000315 	stw	zero,12(sp)
8110a860:	00818004 	movi	r2,1536
8110a864:	d8800215 	stw	r2,8(sp)
8110a868:	00a04574 	movhi	r2,33045
8110a86c:	109f5904 	addi	r2,r2,32100
8110a870:	d8800115 	stw	r2,4(sp)
8110a874:	00800704 	movi	r2,28
8110a878:	d8800015 	stw	r2,0(sp)
8110a87c:	01c00704 	movi	r7,28
8110a880:	01a045b4 	movhi	r6,33046
8110a884:	31a55804 	addi	r6,r6,-27296
8110a888:	000b883a 	mov	r5,zero
8110a88c:	01204474 	movhi	r4,33041
8110a890:	212ccf04 	addi	r4,r4,-19652
8110a894:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a898:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a89c:	e0bffe03 	ldbu	r2,-8(fp)
8110a8a0:	10803fcc 	andi	r2,r2,255
8110a8a4:	10000526 	beq	r2,zero,8110a8bc <vInitialTask+0x648>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110a8a8:	e0bffe03 	ldbu	r2,-8(fp)
8110a8ac:	10803fcc 	andi	r2,r2,255
8110a8b0:	1009883a 	mov	r4,r2
8110a8b4:	11123080 	call	81112308 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
8110a8b8:	1112f580 	call	81112f58 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110a8bc:	01c03204 	movi	r7,200
8110a8c0:	000d883a 	mov	r6,zero
8110a8c4:	000b883a 	mov	r5,zero
8110a8c8:	0009883a 	mov	r4,zero
8110a8cc:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
8110a8d0:	d8000415 	stw	zero,16(sp)
8110a8d4:	d8000315 	stw	zero,12(sp)
8110a8d8:	00818004 	movi	r2,1536
8110a8dc:	d8800215 	stw	r2,8(sp)
8110a8e0:	00a04574 	movhi	r2,33045
8110a8e4:	10803104 	addi	r2,r2,196
8110a8e8:	d8800115 	stw	r2,4(sp)
8110a8ec:	00800804 	movi	r2,32
8110a8f0:	d8800015 	stw	r2,0(sp)
8110a8f4:	01c00804 	movi	r7,32
8110a8f8:	01a04574 	movhi	r6,33045
8110a8fc:	31863004 	addi	r6,r6,6336
8110a900:	000b883a 	mov	r5,zero
8110a904:	01204474 	movhi	r4,33041
8110a908:	2130ef04 	addi	r4,r4,-15428
8110a90c:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a910:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110a914:	e0bffe03 	ldbu	r2,-8(fp)
8110a918:	10803fcc 	andi	r2,r2,255
8110a91c:	10000526 	beq	r2,zero,8110a934 <vInitialTask+0x6c0>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110a920:	e0bffe03 	ldbu	r2,-8(fp)
8110a924:	10803fcc 	andi	r2,r2,255
8110a928:	1009883a 	mov	r4,r2
8110a92c:	11123080 	call	81112308 <printErrorTask>
		#endif
		vFailReceiverCreate();
8110a930:	111285c0 	call	8111285c <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110a934:	01c03204 	movi	r7,200
8110a938:	000d883a 	mov	r6,zero
8110a93c:	000b883a 	mov	r5,zero
8110a940:	0009883a 	mov	r4,zero
8110a944:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
8110a948:	d8000415 	stw	zero,16(sp)
8110a94c:	d8000315 	stw	zero,12(sp)
8110a950:	00810004 	movi	r2,1024
8110a954:	d8800215 	stw	r2,8(sp)
8110a958:	00a04574 	movhi	r2,33045
8110a95c:	10ac4504 	addi	r2,r2,-20204
8110a960:	d8800115 	stw	r2,4(sp)
8110a964:	00800684 	movi	r2,26
8110a968:	d8800015 	stw	r2,0(sp)
8110a96c:	01c00684 	movi	r7,26
8110a970:	01a04574 	movhi	r6,33045
8110a974:	31b04404 	addi	r6,r6,-16112
8110a978:	000b883a 	mov	r5,zero
8110a97c:	01204474 	movhi	r4,33041
8110a980:	21337104 	addi	r4,r4,-12860
8110a984:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110a988:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
8110a98c:	01c03204 	movi	r7,200
8110a990:	000d883a 	mov	r6,zero
8110a994:	000b883a 	mov	r5,zero
8110a998:	0009883a 	mov	r4,zero
8110a99c:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
8110a9a0:	e0bffe03 	ldbu	r2,-8(fp)
8110a9a4:	10803fcc 	andi	r2,r2,255
8110a9a8:	10000526 	beq	r2,zero,8110a9c0 <vInitialTask+0x74c>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110a9ac:	e0bffe03 	ldbu	r2,-8(fp)
8110a9b0:	10803fcc 	andi	r2,r2,255
8110a9b4:	1009883a 	mov	r4,r2
8110a9b8:	11123080 	call	81112308 <printErrorTask>
		#endif
		vFailSenderCreate();
8110a9bc:	11128a80 	call	811128a8 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8110a9c0:	d0a05f17 	ldw	r2,-32388(gp)
8110a9c4:	e17ffe04 	addi	r5,fp,-8
8110a9c8:	1009883a 	mov	r4,r2
8110a9cc:	11375d00 	call	811375d0 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8110a9d0:	e0bffe03 	ldbu	r2,-8(fp)
8110a9d4:	10803fcc 	andi	r2,r2,255
8110a9d8:	10000126 	beq	r2,zero,8110a9e0 <vInitialTask+0x76c>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8110a9dc:	11133900 	call	81113390 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8110a9e0:	01c00084 	movi	r7,2
8110a9e4:	01800784 	movi	r6,30
8110a9e8:	000b883a 	mov	r5,zero
8110a9ec:	0009883a 	mov	r4,zero
8110a9f0:	1136adc0 	call	81136adc <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
8110a9f4:	01003fc4 	movi	r4,255
8110a9f8:	1135a9c0 	call	81135a9c <OSTaskDel>
8110a9fc:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
8110aa00:	e0bffe03 	ldbu	r2,-8(fp)
8110aa04:	10803fcc 	andi	r2,r2,255
8110aa08:	10001026 	beq	r2,zero,8110aa4c <vInitialTask+0x7d8>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110aa0c:	e0bffe03 	ldbu	r2,-8(fp)
8110aa10:	10803fcc 	andi	r2,r2,255
8110aa14:	1009883a 	mov	r4,r2
8110aa18:	11123080 	call	81112308 <printErrorTask>
		#endif
		vFailDeleteInitialization();
8110aa1c:	11128f40 	call	811128f4 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
8110aa20:	014009c4 	movi	r5,39
8110aa24:	01000044 	movi	r4,1
8110aa28:	11353b80 	call	811353b8 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8110aa2c:	01003fc4 	movi	r4,255
8110aa30:	1135a9c0 	call	81135a9c <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
8110aa34:	000f883a 	mov	r7,zero
8110aa38:	01800284 	movi	r6,10
8110aa3c:	000b883a 	mov	r5,zero
8110aa40:	0009883a 	mov	r4,zero
8110aa44:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
		}
8110aa48:	003ff806 	br	8110aa2c <__reset+0xfb0eaa2c>
	}

}
8110aa4c:	0001883a 	nop
8110aa50:	e037883a 	mov	sp,fp
8110aa54:	dfc00117 	ldw	ra,4(sp)
8110aa58:	df000017 	ldw	fp,0(sp)
8110aa5c:	dec00204 	addi	sp,sp,8
8110aa60:	f800283a 	ret

8110aa64 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8110aa64:	defff804 	addi	sp,sp,-32
8110aa68:	de00012e 	bgeu	sp,et,8110aa70 <vNFeeControlTask+0xc>
8110aa6c:	003b68fa 	trap	3
8110aa70:	dfc00715 	stw	ra,28(sp)
8110aa74:	df000615 	stw	fp,24(sp)
8110aa78:	df000604 	addi	fp,sp,24
8110aa7c:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	INT8U error_codeCtrl;
	unsigned char ucFeeInstL;
	static bool bDmaBack;

	pxFeeC = (TNFee_Control *) task_data;
8110aa80:	e0bfff17 	ldw	r2,-4(fp)
8110aa84:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
8110aa88:	d0a05517 	ldw	r2,-32428(gp)
8110aa8c:	100f883a 	mov	r7,r2
8110aa90:	01800804 	movi	r6,32
8110aa94:	01400044 	movi	r5,1
8110aa98:	01204534 	movhi	r4,33044
8110aa9c:	210b2a04 	addi	r4,r4,11432
8110aaa0:	11172b80 	call	811172b8 <fwrite>
    #endif

	bCmdSent = FALSE;
8110aaa4:	e03ffb15 	stw	zero,-20(fp)
	bDmaBack = TRUE;
8110aaa8:	00800044 	movi	r2,1
8110aaac:	d0a04e15 	stw	r2,-32456(gp)
		/* todo: Tem os mesmos estados que o SIMUCAM : Config e Running */
		/* todo: No config ou a Meb ira configurar sozinha os FEEs e os controladores ou ir passar a mensagem completa sem usar a QueueMask */
		/* todo: No modo Running o NFEE control s utiliza o Queue MAsk pois  mais rapido e s transmite no Qmask tbm */

		
		switch (pxFeeC->sMode)
8110aab0:	e0bffa17 	ldw	r2,-24(fp)
8110aab4:	10836717 	ldw	r2,3484(r2)
8110aab8:	10000326 	beq	r2,zero,8110aac8 <vNFeeControlTask+0x64>
8110aabc:	10800060 	cmpeqi	r2,r2,1
8110aac0:	1000201e 	bne	r2,zero,8110ab44 <vNFeeControlTask+0xe0>
8110aac4:	00007e06 	br	8110acc0 <vNFeeControlTask+0x25c>
		{
			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_code); /* Blocking operation */
8110aac8:	d0a04a17 	ldw	r2,-32472(gp)
8110aacc:	e0fffe04 	addi	r3,fp,-8
8110aad0:	180d883a 	mov	r6,r3
8110aad4:	000b883a 	mov	r5,zero
8110aad8:	1009883a 	mov	r4,r2
8110aadc:	1133e000 	call	81133e00 <OSQPend>
8110aae0:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8110aae4:	e0bffe03 	ldbu	r2,-8(fp)
8110aae8:	10803fcc 	andi	r2,r2,255
8110aaec:	1000131e 	bne	r2,zero,8110ab3c <vNFeeControlTask+0xd8>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110aaf0:	e0bffdc3 	ldbu	r2,-9(fp)
8110aaf4:	10803fcc 	andi	r2,r2,255
8110aaf8:	10800418 	cmpnei	r2,r2,16
8110aafc:	1000051e 	bne	r2,zero,8110ab14 <vNFeeControlTask+0xb0>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8110ab00:	e0bffd17 	ldw	r2,-12(fp)
8110ab04:	e17ffa17 	ldw	r5,-24(fp)
8110ab08:	1009883a 	mov	r4,r2
8110ab0c:	110acf00 	call	8110acf0 <vPerformActionNFCConfig>
8110ab10:	00000706 	br	8110ab30 <vNFeeControlTask+0xcc>

					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"Provavel para FEE (Remover)\n");
8110ab14:	d0a05517 	ldw	r2,-32428(gp)
8110ab18:	100f883a 	mov	r7,r2
8110ab1c:	01800704 	movi	r6,28
8110ab20:	01400044 	movi	r5,1
8110ab24:	01204534 	movhi	r4,33044
8110ab28:	210b3304 	addi	r4,r4,11468
8110ab2c:	11172b80 	call	811172b8 <fwrite>
						#endif
					}

					bDmaBack = TRUE;
8110ab30:	00800044 	movi	r2,1
8110ab34:	d0a04e15 	stw	r2,-32456(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
8110ab38:	00006c06 	br	8110acec <vNFeeControlTask+0x288>
					}

					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8110ab3c:	1113cd00 	call	81113cd0 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
8110ab40:	00006a06 	br	8110acec <vNFeeControlTask+0x288>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
8110ab44:	d0a04e17 	ldw	r2,-32456(gp)
8110ab48:	10800058 	cmpnei	r2,r2,1
8110ab4c:	1000201e 	bne	r2,zero,8110abd0 <vNFeeControlTask+0x16c>
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 2, &error_code);
8110ab50:	d0a05117 	ldw	r2,-32444(gp)
8110ab54:	e0fffe04 	addi	r3,fp,-8
8110ab58:	180d883a 	mov	r6,r3
8110ab5c:	01400084 	movi	r5,2
8110ab60:	1009883a 	mov	r4,r2
8110ab64:	1133e000 	call	81133e00 <OSQPend>
8110ab68:	e0bffd15 	stw	r2,-12(fp)
					if ( error_code == OS_ERR_NONE ) {
8110ab6c:	e0bffe03 	ldbu	r2,-8(fp)
8110ab70:	10803fcc 	andi	r2,r2,255
8110ab74:	1000161e 	bne	r2,zero,8110abd0 <vNFeeControlTask+0x16c>
						ucFeeInstL = uiCmdNFC.ucByte[0];
8110ab78:	e0bffd03 	ldbu	r2,-12(fp)
8110ab7c:	e0bffc05 	stb	r2,-16(fp)
						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
8110ab80:	e0bffc03 	ldbu	r2,-16(fp)
8110ab84:	e0fffa17 	ldw	r3,-24(fp)
8110ab88:	10808f24 	muli	r2,r2,572
8110ab8c:	1885883a 	add	r2,r3,r2
8110ab90:	10802204 	addi	r2,r2,136
8110ab94:	10800017 	ldw	r2,0(r2)
8110ab98:	10800058 	cmpnei	r2,r2,1
8110ab9c:	10000c1e 	bne	r2,zero,8110abd0 <vNFeeControlTask+0x16c>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
8110aba0:	e0bffc03 	ldbu	r2,-16(fp)
8110aba4:	e0fffc03 	ldbu	r3,-16(fp)
8110aba8:	180f883a 	mov	r7,r3
8110abac:	000d883a 	mov	r6,zero
8110abb0:	014023c4 	movi	r5,143
8110abb4:	1009883a 	mov	r4,r2
8110abb8:	110af780 	call	8110af78 <bSendCmdQToNFeeInst>
8110abbc:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE )
8110abc0:	e0bffb17 	ldw	r2,-20(fp)
8110abc4:	10800058 	cmpnei	r2,r2,1
8110abc8:	1000011e 	bne	r2,zero,8110abd0 <vNFeeControlTask+0x16c>
								bDmaBack = FALSE;
8110abcc:	d0204e15 	stw	zero,-32456(gp)
						}
					}
				} 

				if ( bDmaBack == FALSE )
8110abd0:	d0a04e17 	ldw	r2,-32456(gp)
8110abd4:	1000081e 	bne	r2,zero,8110abf8 <vNFeeControlTask+0x194>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
8110abd8:	d0a04a17 	ldw	r2,-32472(gp)
8110abdc:	e0fffe44 	addi	r3,fp,-7
8110abe0:	180d883a 	mov	r6,r3
8110abe4:	000b883a 	mov	r5,zero
8110abe8:	1009883a 	mov	r4,r2
8110abec:	1133e000 	call	81133e00 <OSQPend>
8110abf0:	e0bffd15 	stw	r2,-12(fp)
8110abf4:	00000706 	br	8110ac14 <vNFeeControlTask+0x1b0>
				else
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 2, &error_codeCtrl);
8110abf8:	d0a04a17 	ldw	r2,-32472(gp)
8110abfc:	e0fffe44 	addi	r3,fp,-7
8110ac00:	180d883a 	mov	r6,r3
8110ac04:	01400084 	movi	r5,2
8110ac08:	1009883a 	mov	r4,r2
8110ac0c:	1133e000 	call	81133e00 <OSQPend>
8110ac10:	e0bffd15 	stw	r2,-12(fp)

				if ( error_codeCtrl == OS_ERR_NONE ){
8110ac14:	e0bffe43 	ldbu	r2,-7(fp)
8110ac18:	10803fcc 	andi	r2,r2,255
8110ac1c:	1000321e 	bne	r2,zero,8110ace8 <vNFeeControlTask+0x284>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
8110ac20:	e0bffd83 	ldbu	r2,-10(fp)
8110ac24:	10803fcc 	andi	r2,r2,255
8110ac28:	10802058 	cmpnei	r2,r2,129
8110ac2c:	1000031e 	bne	r2,zero,8110ac3c <vNFeeControlTask+0x1d8>
						bDmaBack = TRUE;
8110ac30:	00800044 	movi	r2,1
8110ac34:	d0a04e15 	stw	r2,-32456(gp)
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110ac38:	00002b06 	br	8110ace8 <vNFeeControlTask+0x284>
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
						bDmaBack = TRUE;
					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110ac3c:	e0bffdc3 	ldbu	r2,-9(fp)
8110ac40:	10803fcc 	andi	r2,r2,255
8110ac44:	10800418 	cmpnei	r2,r2,16
8110ac48:	1000051e 	bne	r2,zero,8110ac60 <vNFeeControlTask+0x1fc>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
8110ac4c:	e0bffd17 	ldw	r2,-12(fp)
8110ac50:	e17ffa17 	ldw	r5,-24(fp)
8110ac54:	1009883a 	mov	r4,r2
8110ac58:	110ae3c0 	call	8110ae3c <vPerformActionNFCRunning>
8110ac5c:	00001606 	br	8110acb8 <vNFeeControlTask+0x254>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
8110ac60:	e0bffdc3 	ldbu	r2,-9(fp)
8110ac64:	10803fcc 	andi	r2,r2,255
8110ac68:	10800470 	cmpltui	r2,r2,17
8110ac6c:	1000121e 	bne	r2,zero,8110acb8 <vNFeeControlTask+0x254>
8110ac70:	e0bffdc3 	ldbu	r2,-9(fp)
8110ac74:	10803fcc 	andi	r2,r2,255
8110ac78:	10800628 	cmpgeui	r2,r2,24
8110ac7c:	10000e1e 	bne	r2,zero,8110acb8 <vNFeeControlTask+0x254>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
8110ac80:	e0bffdc3 	ldbu	r2,-9(fp)
8110ac84:	10bffbc4 	addi	r2,r2,-17
8110ac88:	10803fcc 	andi	r2,r2,255
8110ac8c:	e0fffd83 	ldbu	r3,-10(fp)
8110ac90:	18c03fcc 	andi	r3,r3,255
8110ac94:	e13ffd43 	ldbu	r4,-11(fp)
8110ac98:	21003fcc 	andi	r4,r4,255
8110ac9c:	e17ffd03 	ldbu	r5,-12(fp)
8110aca0:	29403fcc 	andi	r5,r5,255
8110aca4:	280f883a 	mov	r7,r5
8110aca8:	200d883a 	mov	r6,r4
8110acac:	180b883a 	mov	r5,r3
8110acb0:	1009883a 	mov	r4,r2
8110acb4:	110af780 	call	8110af78 <bSendCmdQToNFeeInst>

							}
						}
						bDmaBack = FALSE;
8110acb8:	d0204e15 	stw	zero,-32456(gp)
					}
				}
				
				break;		
8110acbc:	00000a06 	br	8110ace8 <vNFeeControlTask+0x284>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknow state, backing to Config Mode.\n");
8110acc0:	d0a05517 	ldw	r2,-32428(gp)
8110acc4:	100f883a 	mov	r7,r2
8110acc8:	01800f04 	movi	r6,60
8110accc:	01400044 	movi	r5,1
8110acd0:	01204534 	movhi	r4,33044
8110acd4:	210b3b04 	addi	r4,r4,11500
8110acd8:	11172b80 	call	811172b8 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
8110acdc:	e0bffa17 	ldw	r2,-24(fp)
8110ace0:	10036715 	stw	zero,3484(r2)
				break;
8110ace4:	00000106 	br	8110acec <vNFeeControlTask+0x288>
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110ace8:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
8110acec:	003f7006 	br	8110aab0 <__reset+0xfb0eaab0>

8110acf0 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110acf0:	defffa04 	addi	sp,sp,-24
8110acf4:	de00012e 	bgeu	sp,et,8110acfc <vPerformActionNFCConfig+0xc>
8110acf8:	003b68fa 	trap	3
8110acfc:	dfc00515 	stw	ra,20(sp)
8110ad00:	df000415 	stw	fp,16(sp)
8110ad04:	df000404 	addi	fp,sp,16
8110ad08:	e13ffe15 	stw	r4,-8(fp)
8110ad0c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
8110ad10:	e0bffe17 	ldw	r2,-8(fp)
8110ad14:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110ad18:	e0bffd83 	ldbu	r2,-10(fp)
8110ad1c:	10803fcc 	andi	r2,r2,255
8110ad20:	10c00060 	cmpeqi	r3,r2,1
8110ad24:	1800031e 	bne	r3,zero,8110ad34 <vPerformActionNFCConfig+0x44>
8110ad28:	108000a0 	cmpeqi	r2,r2,2
8110ad2c:	1000091e 	bne	r2,zero,8110ad54 <vPerformActionNFCConfig+0x64>
8110ad30:	00003406 	br	8110ae04 <vPerformActionNFCConfig+0x114>
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
8110ad34:	d0a05517 	ldw	r2,-32428(gp)
8110ad38:	100f883a 	mov	r7,r2
8110ad3c:	01800d44 	movi	r6,53
8110ad40:	01400044 	movi	r5,1
8110ad44:	01204534 	movhi	r4,33044
8110ad48:	210b4b04 	addi	r4,r4,11564
8110ad4c:	11172b80 	call	811172b8 <fwrite>
			#endif

			/* Do nothing for now */

			break;
8110ad50:	00003406 	br	8110ae24 <vPerformActionNFCConfig+0x134>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to RUN Mode\n");
8110ad54:	d0a05517 	ldw	r2,-32428(gp)
8110ad58:	100f883a 	mov	r7,r2
8110ad5c:	01800ac4 	movi	r6,43
8110ad60:	01400044 	movi	r5,1
8110ad64:	01204534 	movhi	r4,33044
8110ad68:	210b5904 	addi	r4,r4,11620
8110ad6c:	11172b80 	call	811172b8 <fwrite>
			#endif

			vEvtChangeFeeControllerMode(pxFeeCP->sMode, sRun);
8110ad70:	e0bfff17 	ldw	r2,-4(fp)
8110ad74:	10836717 	ldw	r2,3484(r2)
8110ad78:	01400044 	movi	r5,1
8110ad7c:	1009883a 	mov	r4,r2
8110ad80:	1113f480 	call	81113f48 <vEvtChangeFeeControllerMode>
			pxFeeCP->sMode = sRun;
8110ad84:	e0bfff17 	ldw	r2,-4(fp)
8110ad88:	00c00044 	movi	r3,1
8110ad8c:	10c36715 	stw	r3,3484(r2)
			/* ALlow NFEEs to go to any Running mode */

			/* Clear The Queue That gives access to the DMA */
			errorCodeL = OSQFlush(xNfeeSchedule);
8110ad90:	d0a05117 	ldw	r2,-32444(gp)
8110ad94:	1009883a 	mov	r4,r2
8110ad98:	1133d400 	call	81133d40 <OSQFlush>
8110ad9c:	e0bffc45 	stb	r2,-15(fp)
			if ( errorCodeL != OS_NO_ERR ) {
8110ada0:	e0bffc43 	ldbu	r2,-15(fp)
8110ada4:	10000126 	beq	r2,zero,8110adac <vPerformActionNFCConfig+0xbc>
				vFailFlushQueue();
8110ada8:	1113e8c0 	call	81113e8c <vFailFlushQueue>
			}

			for( i = 0; i < N_OF_NFEE; i++)
8110adac:	e03ffc05 	stb	zero,-16(fp)
8110adb0:	00001006 	br	8110adf4 <vPerformActionNFCConfig+0x104>
			{
				errorCodeL = OSQFlush( xFeeQ[ i ] );
8110adb4:	e0fffc03 	ldbu	r3,-16(fp)
8110adb8:	00a04574 	movhi	r2,33045
8110adbc:	10974904 	addi	r2,r2,23844
8110adc0:	18c7883a 	add	r3,r3,r3
8110adc4:	18c7883a 	add	r3,r3,r3
8110adc8:	10c5883a 	add	r2,r2,r3
8110adcc:	10800017 	ldw	r2,0(r2)
8110add0:	1009883a 	mov	r4,r2
8110add4:	1133d400 	call	81133d40 <OSQFlush>
8110add8:	e0bffc45 	stb	r2,-15(fp)
				if ( errorCodeL != OS_NO_ERR ) {
8110addc:	e0bffc43 	ldbu	r2,-15(fp)
8110ade0:	10000126 	beq	r2,zero,8110ade8 <vPerformActionNFCConfig+0xf8>
					vFailFlushQueue();
8110ade4:	1113e8c0 	call	81113e8c <vFailFlushQueue>
			errorCodeL = OSQFlush(xNfeeSchedule);
			if ( errorCodeL != OS_NO_ERR ) {
				vFailFlushQueue();
			}

			for( i = 0; i < N_OF_NFEE; i++)
8110ade8:	e0bffc03 	ldbu	r2,-16(fp)
8110adec:	10800044 	addi	r2,r2,1
8110adf0:	e0bffc05 	stb	r2,-16(fp)
8110adf4:	e0bffc03 	ldbu	r2,-16(fp)
8110adf8:	108001b0 	cmpltui	r2,r2,6
8110adfc:	103fed1e 	bne	r2,zero,8110adb4 <__reset+0xfb0eadb4>
					vFailFlushQueue();
				}
			}


			break;		
8110ae00:	00000806 	br	8110ae24 <vPerformActionNFCConfig+0x134>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
8110ae04:	d0a05517 	ldw	r2,-32428(gp)
8110ae08:	100f883a 	mov	r7,r2
8110ae0c:	01800984 	movi	r6,38
8110ae10:	01400044 	movi	r5,1
8110ae14:	01204534 	movhi	r4,33044
8110ae18:	210b6404 	addi	r4,r4,11664
8110ae1c:	11172b80 	call	811172b8 <fwrite>
			#endif	
			break;
8110ae20:	0001883a 	nop
	}

}
8110ae24:	0001883a 	nop
8110ae28:	e037883a 	mov	sp,fp
8110ae2c:	dfc00117 	ldw	ra,4(sp)
8110ae30:	df000017 	ldw	fp,0(sp)
8110ae34:	dec00204 	addi	sp,sp,8
8110ae38:	f800283a 	ret

8110ae3c <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110ae3c:	defffa04 	addi	sp,sp,-24
8110ae40:	de00012e 	bgeu	sp,et,8110ae48 <vPerformActionNFCRunning+0xc>
8110ae44:	003b68fa 	trap	3
8110ae48:	dfc00515 	stw	ra,20(sp)
8110ae4c:	df000415 	stw	fp,16(sp)
8110ae50:	df000404 	addi	fp,sp,16
8110ae54:	e13ffe15 	stw	r4,-8(fp)
8110ae58:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
8110ae5c:	e0bffe17 	ldw	r2,-8(fp)
8110ae60:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110ae64:	e0bffd83 	ldbu	r2,-10(fp)
8110ae68:	10803fcc 	andi	r2,r2,255
8110ae6c:	10c00060 	cmpeqi	r3,r2,1
8110ae70:	1800031e 	bne	r3,zero,8110ae80 <vPerformActionNFCRunning+0x44>
8110ae74:	108000a0 	cmpeqi	r2,r2,2
8110ae78:	1000291e 	bne	r2,zero,8110af20 <vPerformActionNFCRunning+0xe4>
8110ae7c:	00003006 	br	8110af40 <vPerformActionNFCRunning+0x104>
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to Config Mode\n");
8110ae80:	d0a05517 	ldw	r2,-32428(gp)
8110ae84:	100f883a 	mov	r7,r2
8110ae88:	01800b84 	movi	r6,46
8110ae8c:	01400044 	movi	r5,1
8110ae90:	01204534 	movhi	r4,33044
8110ae94:	210b6e04 	addi	r4,r4,11704
8110ae98:	11172b80 	call	811172b8 <fwrite>
			#endif

			vEvtChangeFeeControllerMode(pxFeeCP->sMode, sMebConfig);
8110ae9c:	e0bfff17 	ldw	r2,-4(fp)
8110aea0:	10836717 	ldw	r2,3484(r2)
8110aea4:	000b883a 	mov	r5,zero
8110aea8:	1009883a 	mov	r4,r2
8110aeac:	1113f480 	call	81113f48 <vEvtChangeFeeControllerMode>
			pxFeeCP->sMode = sMebConfig;
8110aeb0:	e0bfff17 	ldw	r2,-4(fp)
8110aeb4:	10036715 	stw	zero,3484(r2)

			/* Change all NFEEs to Config mode */

			for( i = 0; i < N_OF_NFEE; i++)
8110aeb8:	e03ffc05 	stb	zero,-16(fp)
8110aebc:	00001406 	br	8110af10 <vPerformActionNFCRunning+0xd4>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
8110aec0:	e0bffc03 	ldbu	r2,-16(fp)
8110aec4:	e0ffff17 	ldw	r3,-4(fp)
8110aec8:	1080d684 	addi	r2,r2,858
8110aecc:	1085883a 	add	r2,r2,r2
8110aed0:	1085883a 	add	r2,r2,r2
8110aed4:	1885883a 	add	r2,r3,r2
8110aed8:	10800017 	ldw	r2,0(r2)
8110aedc:	10800017 	ldw	r2,0(r2)
8110aee0:	10800058 	cmpnei	r2,r2,1
8110aee4:	1000071e 	bne	r2,zero,8110af04 <vPerformActionNFCRunning+0xc8>
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG, 0, i  );
8110aee8:	e0bffc03 	ldbu	r2,-16(fp)
8110aeec:	e0fffc03 	ldbu	r3,-16(fp)
8110aef0:	180f883a 	mov	r7,r3
8110aef4:	000d883a 	mov	r6,zero
8110aef8:	01400044 	movi	r5,1
8110aefc:	1009883a 	mov	r4,r2
8110af00:	110af780 	call	8110af78 <bSendCmdQToNFeeInst>
			vEvtChangeFeeControllerMode(pxFeeCP->sMode, sMebConfig);
			pxFeeCP->sMode = sMebConfig;

			/* Change all NFEEs to Config mode */

			for( i = 0; i < N_OF_NFEE; i++)
8110af04:	e0bffc03 	ldbu	r2,-16(fp)
8110af08:	10800044 	addi	r2,r2,1
8110af0c:	e0bffc05 	stb	r2,-16(fp)
8110af10:	e0bffc03 	ldbu	r2,-16(fp)
8110af14:	108001b0 	cmpltui	r2,r2,6
8110af18:	103fe91e 	bne	r2,zero,8110aec0 <__reset+0xfb0eaec0>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG, 0, i  );
				}
			}

			break;
8110af1c:	00001006 	br	8110af60 <vPerformActionNFCRunning+0x124>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
8110af20:	d0a05517 	ldw	r2,-32428(gp)
8110af24:	100f883a 	mov	r7,r2
8110af28:	01800d84 	movi	r6,54
8110af2c:	01400044 	movi	r5,1
8110af30:	01204534 	movhi	r4,33044
8110af34:	210b7a04 	addi	r4,r4,11752
8110af38:	11172b80 	call	811172b8 <fwrite>
			#endif		
			/* Do nothing for now */

			break;		
8110af3c:	00000806 	br	8110af60 <vPerformActionNFCRunning+0x124>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
8110af40:	d0a05517 	ldw	r2,-32428(gp)
8110af44:	100f883a 	mov	r7,r2
8110af48:	01800984 	movi	r6,38
8110af4c:	01400044 	movi	r5,1
8110af50:	01204534 	movhi	r4,33044
8110af54:	210b6404 	addi	r4,r4,11664
8110af58:	11172b80 	call	811172b8 <fwrite>
			#endif	
			break;
8110af5c:	0001883a 	nop
	}
}
8110af60:	0001883a 	nop
8110af64:	e037883a 	mov	sp,fp
8110af68:	dfc00117 	ldw	ra,4(sp)
8110af6c:	df000017 	ldw	fp,0(sp)
8110af70:	dec00204 	addi	sp,sp,8
8110af74:	f800283a 	ret

8110af78 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110af78:	defff704 	addi	sp,sp,-36
8110af7c:	de00012e 	bgeu	sp,et,8110af84 <bSendCmdQToNFeeInst+0xc>
8110af80:	003b68fa 	trap	3
8110af84:	dfc00815 	stw	ra,32(sp)
8110af88:	df000715 	stw	fp,28(sp)
8110af8c:	df000704 	addi	fp,sp,28
8110af90:	2011883a 	mov	r8,r4
8110af94:	2809883a 	mov	r4,r5
8110af98:	3007883a 	mov	r3,r6
8110af9c:	3805883a 	mov	r2,r7
8110afa0:	e23ffc05 	stb	r8,-16(fp)
8110afa4:	e13ffd05 	stb	r4,-12(fp)
8110afa8:	e0fffe05 	stb	r3,-8(fp)
8110afac:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
8110afb0:	e0bffc03 	ldbu	r2,-16(fp)
8110afb4:	10800444 	addi	r2,r2,17
8110afb8:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110afbc:	e0bffd03 	ldbu	r2,-12(fp)
8110afc0:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110afc4:	e0bffe03 	ldbu	r2,-8(fp)
8110afc8:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110afcc:	e0bfff03 	ldbu	r2,-4(fp)
8110afd0:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110afd4:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8110afd8:	e0fffc03 	ldbu	r3,-16(fp)
8110afdc:	00a04574 	movhi	r2,33045
8110afe0:	10974904 	addi	r2,r2,23844
8110afe4:	18c7883a 	add	r3,r3,r3
8110afe8:	18c7883a 	add	r3,r3,r3
8110afec:	10c5883a 	add	r2,r2,r3
8110aff0:	10800017 	ldw	r2,0(r2)
8110aff4:	e0fffb17 	ldw	r3,-20(fp)
8110aff8:	180b883a 	mov	r5,r3
8110affc:	1009883a 	mov	r4,r2
8110b000:	11342080 	call	81134208 <OSQPost>
8110b004:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110b008:	e0bffa03 	ldbu	r2,-24(fp)
8110b00c:	10000526 	beq	r2,zero,8110b024 <bSendCmdQToNFeeInst+0xac>
		vFailSendMsgAccessDMA( ucFeeInstP );
8110b010:	e0bffc03 	ldbu	r2,-16(fp)
8110b014:	1009883a 	mov	r4,r2
8110b018:	1113da00 	call	81113da0 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8110b01c:	e03ff915 	stw	zero,-28(fp)
8110b020:	00000206 	br	8110b02c <bSendCmdQToNFeeInst+0xb4>
	} else {
		bSuccesL =  TRUE;
8110b024:	00800044 	movi	r2,1
8110b028:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
8110b02c:	e0bff917 	ldw	r2,-28(fp)
}
8110b030:	e037883a 	mov	sp,fp
8110b034:	dfc00117 	ldw	ra,4(sp)
8110b038:	df000017 	ldw	fp,0(sp)
8110b03c:	dec00204 	addi	sp,sp,8
8110b040:	f800283a 	ret

8110b044 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
8110b044:	defff704 	addi	sp,sp,-36
8110b048:	de00012e 	bgeu	sp,et,8110b050 <vOutAckHandlerTask+0xc>
8110b04c:	003b68fa 	trap	3
8110b050:	dfc00815 	stw	ra,32(sp)
8110b054:	df000715 	stw	fp,28(sp)
8110b058:	df000704 	addi	fp,sp,28
8110b05c:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
8110b060:	e03ffac5 	stb	zero,-21(fp)
8110b064:	e03ffb05 	stb	zero,-20(fp)
8110b068:	e03ffb45 	stb	zero,-19(fp)
8110b06c:	e03ffb85 	stb	zero,-18(fp)
8110b070:	e03ffbc5 	stb	zero,-17(fp)
8110b074:	e03ffc05 	stb	zero,-16(fp)
8110b078:	e03ffc45 	stb	zero,-15(fp)
8110b07c:	e03ffc85 	stb	zero,-14(fp)
8110b080:	e03ffcc5 	stb	zero,-13(fp)
8110b084:	e03ffd05 	stb	zero,-12(fp)
8110b088:	e03ffd45 	stb	zero,-11(fp)
8110b08c:	e03ffd85 	stb	zero,-10(fp)
8110b090:	e03ffdc5 	stb	zero,-9(fp)
8110b094:	e03ffe05 	stb	zero,-8(fp)
8110b098:	e03ffe45 	stb	zero,-7(fp)
8110b09c:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8110b0a0:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
8110b0a4:	d0a05517 	ldw	r2,-32428(gp)
8110b0a8:	100f883a 	mov	r7,r2
8110b0ac:	01800804 	movi	r6,32
8110b0b0:	01400044 	movi	r5,1
8110b0b4:	01204534 	movhi	r4,33044
8110b0b8:	210b8804 	addi	r4,r4,11808
8110b0bc:	11172b80 	call	811172b8 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
8110b0c0:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
8110b0c4:	e0bff917 	ldw	r2,-28(fp)
8110b0c8:	10c00060 	cmpeqi	r3,r2,1
8110b0cc:	1800071e 	bne	r3,zero,8110b0ec <vOutAckHandlerTask+0xa8>
8110b0d0:	0080032e 	bgeu	zero,r2,8110b0e0 <vOutAckHandlerTask+0x9c>
8110b0d4:	108000a0 	cmpeqi	r2,r2,2
8110b0d8:	1000471e 	bne	r2,zero,8110b1f8 <vOutAckHandlerTask+0x1b4>
8110b0dc:	00008c06 	br	8110b310 <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
8110b0e0:	00800044 	movi	r2,1
8110b0e4:	e0bff915 	stw	r2,-28(fp)
				break;
8110b0e8:	00009306 	br	8110b338 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
8110b0ec:	00800044 	movi	r2,1
8110b0f0:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
8110b0f4:	d0a05417 	ldw	r2,-32432(gp)
8110b0f8:	e0fffa84 	addi	r3,fp,-22
8110b0fc:	180d883a 	mov	r6,r3
8110b100:	000b883a 	mov	r5,zero
8110b104:	1009883a 	mov	r4,r2
8110b108:	1134cf80 	call	81134cf8 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110b10c:	e0bffa83 	ldbu	r2,-22(fp)
8110b110:	10803fcc 	andi	r2,r2,255
8110b114:	1000361e 	bne	r2,zero,8110b1f0 <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
8110b118:	d0a06317 	ldw	r2,-32372(gp)
8110b11c:	e0fffa84 	addi	r3,fp,-22
8110b120:	180d883a 	mov	r6,r3
8110b124:	000b883a 	mov	r5,zero
8110b128:	1009883a 	mov	r4,r2
8110b12c:	1132cec0 	call	81132cec <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110b130:	e0bffa83 	ldbu	r2,-22(fp)
8110b134:	10803fcc 	andi	r2,r2,255
8110b138:	10002b1e 	bne	r2,zero,8110b1e8 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110b13c:	e03ffa05 	stb	zero,-24(fp)
8110b140:	00002206 	br	8110b1cc <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
8110b144:	e0fffa03 	ldbu	r3,-24(fp)
8110b148:	00a045b4 	movhi	r2,33046
8110b14c:	10b15d04 	addi	r2,r2,-14988
8110b150:	18c7883a 	add	r3,r3,r3
8110b154:	18c7883a 	add	r3,r3,r3
8110b158:	10c5883a 	add	r2,r2,r3
8110b15c:	10800003 	ldbu	r2,0(r2)
8110b160:	10803fcc 	andi	r2,r2,255
8110b164:	1080201c 	xori	r2,r2,128
8110b168:	10bfe004 	addi	r2,r2,-128
8110b16c:	10001426 	beq	r2,zero,8110b1c0 <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8110b170:	e0fffa03 	ldbu	r3,-24(fp)
8110b174:	00a045b4 	movhi	r2,33046
8110b178:	10b15d04 	addi	r2,r2,-14988
8110b17c:	18c7883a 	add	r3,r3,r3
8110b180:	18c7883a 	add	r3,r3,r3
8110b184:	10c5883a 	add	r2,r2,r3
8110b188:	10c0000b 	ldhu	r3,0(r2)
8110b18c:	d0e04f0d 	sth	r3,-32452(gp)
8110b190:	1080008b 	ldhu	r2,2(r2)
8110b194:	d0a04f8d 	sth	r2,-32450(gp)
                                eSenderAckState = sSASending;
8110b198:	00800084 	movi	r2,2
8110b19c:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110b1a0:	e0fffa03 	ldbu	r3,-24(fp)
8110b1a4:	00a045b4 	movhi	r2,33046
8110b1a8:	10b15d04 	addi	r2,r2,-14988
8110b1ac:	18c7883a 	add	r3,r3,r3
8110b1b0:	18c7883a 	add	r3,r3,r3
8110b1b4:	10c5883a 	add	r2,r2,r3
8110b1b8:	10000005 	stb	zero,0(r2)
                                break;
8110b1bc:	00000606 	br	8110b1d8 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110b1c0:	e0bffa03 	ldbu	r2,-24(fp)
8110b1c4:	10800044 	addi	r2,r2,1
8110b1c8:	e0bffa05 	stb	r2,-24(fp)
8110b1cc:	e0bffa03 	ldbu	r2,-24(fp)
8110b1d0:	10800230 	cmpltui	r2,r2,8
8110b1d4:	103fdb1e 	bne	r2,zero,8110b144 <__reset+0xfb0eb144>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
8110b1d8:	d0a06317 	ldw	r2,-32372(gp)
8110b1dc:	1009883a 	mov	r4,r2
8110b1e0:	11332900 	call	81133290 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110b1e4:	00005406 	br	8110b338 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
8110b1e8:	11126240 	call	81112624 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110b1ec:	00005206 	br	8110b338 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8110b1f0:	11125bc0 	call	811125bc <vFailGetCountSemaphoreSenderTask>
                }

                break;
8110b1f4:	00005006 	br	8110b338 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
8110b1f8:	d0a04f03 	ldbu	r2,-32452(gp)
8110b1fc:	10803fcc 	andi	r2,r2,255
8110b200:	1080201c 	xori	r2,r2,128
8110b204:	10bfe004 	addi	r2,r2,-128
8110b208:	108008e0 	cmpeqi	r2,r2,35
8110b20c:	1000201e 	bne	r2,zero,8110b290 <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
8110b210:	d0a04f43 	ldbu	r2,-32451(gp)
8110b214:	10c03fcc 	andi	r3,r2,255
8110b218:	18c0201c 	xori	r3,r3,128
8110b21c:	18ffe004 	addi	r3,r3,-128
8110b220:	d0a04f8b 	ldhu	r2,-32450(gp)
8110b224:	113fffcc 	andi	r4,r2,65535
8110b228:	e0bffac4 	addi	r2,fp,-21
8110b22c:	200f883a 	mov	r7,r4
8110b230:	180d883a 	mov	r6,r3
8110b234:	01604534 	movhi	r5,33044
8110b238:	294b9104 	addi	r5,r5,11844
8110b23c:	1009883a 	mov	r4,r2
8110b240:	11185ac0 	call	811185ac <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
8110b244:	e0bffac4 	addi	r2,fp,-21
8110b248:	1009883a 	mov	r4,r2
8110b24c:	11187c00 	call	811187c0 <strlen>
8110b250:	1007883a 	mov	r3,r2
8110b254:	e0bffac4 	addi	r2,fp,-21
8110b258:	180b883a 	mov	r5,r3
8110b25c:	1009883a 	mov	r4,r2
8110b260:	11121d00 	call	811121d0 <ucCrc8wInit>
8110b264:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
8110b268:	e13ffa43 	ldbu	r4,-23(fp)
8110b26c:	e0fffac4 	addi	r3,fp,-21
8110b270:	e0bffac4 	addi	r2,fp,-21
8110b274:	200f883a 	mov	r7,r4
8110b278:	180d883a 	mov	r6,r3
8110b27c:	01604534 	movhi	r5,33044
8110b280:	294b9304 	addi	r5,r5,11852
8110b284:	1009883a 	mov	r4,r2
8110b288:	11185ac0 	call	811185ac <sprintf>
8110b28c:	00000c06 	br	8110b2c0 <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
8110b290:	e0bffac4 	addi	r2,fp,-21
8110b294:	00c008c4 	movi	r3,35
8110b298:	10c00005 	stb	r3,0(r2)
8110b29c:	00c01f04 	movi	r3,124
8110b2a0:	10c00045 	stb	r3,1(r2)
8110b2a4:	00c00d44 	movi	r3,53
8110b2a8:	10c00085 	stb	r3,2(r2)
8110b2ac:	00c00d04 	movi	r3,52
8110b2b0:	10c000c5 	stb	r3,3(r2)
8110b2b4:	00c00ec4 	movi	r3,59
8110b2b8:	10c00105 	stb	r3,4(r2)
8110b2bc:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
8110b2c0:	d0a06517 	ldw	r2,-32364(gp)
8110b2c4:	e0fffa84 	addi	r3,fp,-22
8110b2c8:	180d883a 	mov	r6,r3
8110b2cc:	01401904 	movi	r5,100
8110b2d0:	1009883a 	mov	r4,r2
8110b2d4:	1132cec0 	call	81132cec <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8110b2d8:	e0bffa83 	ldbu	r2,-22(fp)
8110b2dc:	10803fcc 	andi	r2,r2,255
8110b2e0:	1000071e 	bne	r2,zero,8110b300 <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
8110b2e4:	e0bffac4 	addi	r2,fp,-21
8110b2e8:	1009883a 	mov	r4,r2
8110b2ec:	11182680 	call	81118268 <puts>
                    OSMutexPost(xTxUARTMutex);
8110b2f0:	d0a06517 	ldw	r2,-32364(gp)
8110b2f4:	1009883a 	mov	r4,r2
8110b2f8:	11332900 	call	81133290 <OSMutexPost>
8110b2fc:	00000106 	br	8110b304 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8110b300:	111275c0 	call	8111275c <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
8110b304:	00800044 	movi	r2,1
8110b308:	e0bff915 	stw	r2,-28(fp)
                
				break;
8110b30c:	00000a06 	br	8110b338 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
8110b310:	d0a05517 	ldw	r2,-32428(gp)
8110b314:	100f883a 	mov	r7,r2
8110b318:	01801104 	movi	r6,68
8110b31c:	01400044 	movi	r5,1
8110b320:	01204534 	movhi	r4,33044
8110b324:	210b9604 	addi	r4,r4,11864
8110b328:	11172b80 	call	811172b8 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
8110b32c:	00800044 	movi	r2,1
8110b330:	e0bff915 	stw	r2,-28(fp)
				break;
8110b334:	0001883a 	nop
		}
	}
8110b338:	003f6206 	br	8110b0c4 <__reset+0xfb0eb0c4>

8110b33c <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
8110b33c:	deffd704 	addi	sp,sp,-164
8110b340:	de00012e 	bgeu	sp,et,8110b348 <vParserCommTask+0xc>
8110b344:	003b68fa 	trap	3
8110b348:	dfc02815 	stw	ra,160(sp)
8110b34c:	df002715 	stw	fp,156(sp)
8110b350:	df002704 	addi	fp,sp,156
8110b354:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
8110b358:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
8110b35c:	d0a05517 	ldw	r2,-32428(gp)
8110b360:	100f883a 	mov	r7,r2
8110b364:	01800704 	movi	r6,28
8110b368:	01400044 	movi	r5,1
8110b36c:	01204534 	movhi	r4,33044
8110b370:	210ba804 	addi	r4,r4,11936
8110b374:	11172b80 	call	811172b8 <fwrite>
    #endif

	eParserMode = sConfiguring;
8110b378:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
8110b37c:	e0bfdc17 	ldw	r2,-144(fp)
8110b380:	10800168 	cmpgeui	r2,r2,5
8110b384:	1003691e 	bne	r2,zero,8110c12c <vParserCommTask+0xdf0>
8110b388:	e0bfdc17 	ldw	r2,-144(fp)
8110b38c:	100690ba 	slli	r3,r2,2
8110b390:	00a04474 	movhi	r2,33041
8110b394:	10ace904 	addi	r2,r2,-19548
8110b398:	1885883a 	add	r2,r3,r2
8110b39c:	10800017 	ldw	r2,0(r2)
8110b3a0:	1000683a 	jmp	r2
8110b3a4:	8110b3b8 	rdprs	r4,r16,17102
8110b3a8:	8110b3c4 	addi	r4,r16,17103
8110b3ac:	8110b458 	cmpnei	r4,r16,17105
8110b3b0:	8110b5d8 	cmpnei	r4,r16,17111
8110b3b4:	8110b61c 	xori	r4,r16,17112
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
8110b3b8:	00800044 	movi	r2,1
8110b3bc:	e0bfdc15 	stw	r2,-144(fp)
				break;
8110b3c0:	00035d06 	br	8110c138 <vParserCommTask+0xdfc>
			case sWaitingMessage:

				bSuccess = FALSE;
8110b3c4:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
8110b3c8:	00800044 	movi	r2,1
8110b3cc:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
8110b3d0:	d0a05717 	ldw	r2,-32420(gp)
8110b3d4:	e0ffde84 	addi	r3,fp,-134
8110b3d8:	180d883a 	mov	r6,r3
8110b3dc:	000b883a 	mov	r5,zero
8110b3e0:	1009883a 	mov	r4,r2
8110b3e4:	1134cf80 	call	81134cf8 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
8110b3e8:	e0bfde83 	ldbu	r2,-134(fp)
8110b3ec:	10803fcc 	andi	r2,r2,255
8110b3f0:	1000171e 	bne	r2,zero,8110b450 <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
8110b3f4:	01204574 	movhi	r4,33045
8110b3f8:	2121a604 	addi	r4,r4,-31080
8110b3fc:	110c13c0 	call	8110c13c <getPreParsedPacket>
8110b400:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
8110b404:	e0bfdd17 	ldw	r2,-140(fp)
8110b408:	10800058 	cmpnei	r2,r2,1
8110b40c:	10000e1e 	bne	r2,zero,8110b448 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
8110b410:	00a04574 	movhi	r2,33045
8110b414:	10a1a604 	addi	r2,r2,-31080
8110b418:	10800103 	ldbu	r2,4(r2)
8110b41c:	10803fcc 	andi	r2,r2,255
8110b420:	1080201c 	xori	r2,r2,128
8110b424:	10bfe004 	addi	r2,r2,-128
8110b428:	10800858 	cmpnei	r2,r2,33
8110b42c:	1000031e 	bne	r2,zero,8110b43c <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
8110b430:	008000c4 	movi	r2,3
8110b434:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110b438:	00033f06 	br	8110c138 <vParserCommTask+0xdfc>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
8110b43c:	00800084 	movi	r2,2
8110b440:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110b444:	00033c06 	br	8110c138 <vParserCommTask+0xdfc>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
8110b448:	1112ce80 	call	81112ce8 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110b44c:	00033a06 	br	8110c138 <vParserCommTask+0xdfc>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8110b450:	1112c180 	call	81112c18 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
8110b454:	00033806 	br	8110c138 <vParserCommTask+0xdfc>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
8110b458:	00a04574 	movhi	r2,33045
8110b45c:	10a1a604 	addi	r2,r2,-31080
8110b460:	10800143 	ldbu	r2,5(r2)
8110b464:	10803fcc 	andi	r2,r2,255
8110b468:	1080201c 	xori	r2,r2,128
8110b46c:	10bfe004 	addi	r2,r2,-128
8110b470:	10c010e0 	cmpeqi	r3,r2,67
8110b474:	1800031e 	bne	r3,zero,8110b484 <vParserCommTask+0x148>
8110b478:	10801420 	cmpeqi	r2,r2,80
8110b47c:	1000051e 	bne	r2,zero,8110b494 <vParserCommTask+0x158>
8110b480:	00005106 	br	8110b5c8 <vParserCommTask+0x28c>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
8110b484:	11109a00 	call	811109a0 <vSendEthConf>
						eParserMode = sWaitingMessage;
8110b488:	00800044 	movi	r2,1
8110b48c:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110b490:	00005006 	br	8110b5d4 <vParserCommTask+0x298>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							debug(fp,"PUS Received:\n");
8110b494:	d0a05517 	ldw	r2,-32428(gp)
8110b498:	100f883a 	mov	r7,r2
8110b49c:	01800384 	movi	r6,14
8110b4a0:	01400044 	movi	r5,1
8110b4a4:	01204534 	movhi	r4,33044
8110b4a8:	210bb004 	addi	r4,r4,11968
8110b4ac:	11172b80 	call	811172b8 <fwrite>
							memset(cPUSDebug,0,128);
8110b4b0:	e0bfdec4 	addi	r2,fp,-133
8110b4b4:	01802004 	movi	r6,128
8110b4b8:	000b883a 	mov	r5,zero
8110b4bc:	1009883a 	mov	r4,r2
8110b4c0:	1117e1c0 	call	81117e1c <memset>
							sprintf(cPUSDebug, "TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
8110b4c4:	00a04574 	movhi	r2,33045
8110b4c8:	10a1a604 	addi	r2,r2,-31080
8110b4cc:	1080028b 	ldhu	r2,10(r2)
8110b4d0:	117fffcc 	andi	r5,r2,65535
8110b4d4:	00a04574 	movhi	r2,33045
8110b4d8:	10a1a604 	addi	r2,r2,-31080
8110b4dc:	1080030b 	ldhu	r2,12(r2)
8110b4e0:	11bfffcc 	andi	r6,r2,65535
8110b4e4:	00a04574 	movhi	r2,33045
8110b4e8:	10a1a604 	addi	r2,r2,-31080
8110b4ec:	1080038b 	ldhu	r2,14(r2)
8110b4f0:	10ffffcc 	andi	r3,r2,65535
8110b4f4:	00a04574 	movhi	r2,33045
8110b4f8:	10a1a604 	addi	r2,r2,-31080
8110b4fc:	1080040b 	ldhu	r2,16(r2)
8110b500:	113fffcc 	andi	r4,r2,65535
8110b504:	00a04574 	movhi	r2,33045
8110b508:	10a1a604 	addi	r2,r2,-31080
8110b50c:	1080048b 	ldhu	r2,18(r2)
8110b510:	10bfffcc 	andi	r2,r2,65535
8110b514:	e23fdec4 	addi	r8,fp,-133
8110b518:	d8800215 	stw	r2,8(sp)
8110b51c:	d9000115 	stw	r4,4(sp)
8110b520:	d8c00015 	stw	r3,0(sp)
8110b524:	300f883a 	mov	r7,r6
8110b528:	280d883a 	mov	r6,r5
8110b52c:	01604534 	movhi	r5,33044
8110b530:	294bb404 	addi	r5,r5,11984
8110b534:	4009883a 	mov	r4,r8
8110b538:	11185ac0 	call	811185ac <sprintf>
							debug(fp, cPUSDebug );
8110b53c:	d0a05517 	ldw	r2,-32428(gp)
8110b540:	e0ffdec4 	addi	r3,fp,-133
8110b544:	180b883a 	mov	r5,r3
8110b548:	1009883a 	mov	r4,r2
8110b54c:	1116c1c0 	call	81116c1c <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
8110b550:	00a04574 	movhi	r2,33045
8110b554:	10a1a604 	addi	r2,r2,-31080
8110b558:	10c0030b 	ldhu	r3,12(r2)
8110b55c:	00a04574 	movhi	r2,33045
8110b560:	10a1b904 	addi	r2,r2,-31004
8110b564:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
8110b568:	00a04574 	movhi	r2,33045
8110b56c:	10a1a604 	addi	r2,r2,-31080
8110b570:	10c0038b 	ldhu	r3,14(r2)
8110b574:	00a04574 	movhi	r2,33045
8110b578:	10a1b904 	addi	r2,r2,-31004
8110b57c:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
8110b580:	00a04574 	movhi	r2,33045
8110b584:	10a1a604 	addi	r2,r2,-31080
8110b588:	10c0040b 	ldhu	r3,16(r2)
8110b58c:	00a04574 	movhi	r2,33045
8110b590:	10a1b904 	addi	r2,r2,-31004
8110b594:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
8110b598:	00a04574 	movhi	r2,33045
8110b59c:	10a1a604 	addi	r2,r2,-31080
8110b5a0:	10c0048b 	ldhu	r3,18(r2)
8110b5a4:	00a04574 	movhi	r2,33045
8110b5a8:	10a1b904 	addi	r2,r2,-31004
8110b5ac:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
8110b5b0:	00a04574 	movhi	r2,33045
8110b5b4:	10a1b904 	addi	r2,r2,-31004
8110b5b8:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
8110b5bc:	00800104 	movi	r2,4
8110b5c0:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
8110b5c4:	00000306 	br	8110b5d4 <vParserCommTask+0x298>
					default:
						eParserMode = sWaitingMessage;
8110b5c8:	00800044 	movi	r2,1
8110b5cc:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110b5d0:	0001883a 	nop
				}
				break;
8110b5d4:	0002d806 	br	8110c138 <vParserCommTask+0xdfc>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
8110b5d8:	00800044 	movi	r2,1
8110b5dc:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
8110b5e0:	00a04574 	movhi	r2,33045
8110b5e4:	10a1b904 	addi	r2,r2,-31004
8110b5e8:	1080030b 	ldhu	r2,12(r2)
8110b5ec:	10bfffcc 	andi	r2,r2,65535
8110b5f0:	10c01220 	cmpeqi	r3,r2,72
8110b5f4:	1800051e 	bne	r3,zero,8110b60c <vParserCommTask+0x2d0>
8110b5f8:	108014e0 	cmpeqi	r2,r2,83
8110b5fc:	1000051e 	bne	r2,zero,8110b614 <vParserCommTask+0x2d8>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
8110b600:	00800044 	movi	r2,1
8110b604:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8110b608:	00000306 	br	8110b618 <vParserCommTask+0x2dc>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
8110b60c:	0001883a 	nop
8110b610:	0002c906 	br	8110c138 <vParserCommTask+0xdfc>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
8110b614:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
8110b618:	0002c706 	br	8110c138 <vParserCommTask+0xdfc>
			case sPusHandling:
				eParserMode = sWaitingMessage;
8110b61c:	00800044 	movi	r2,1
8110b620:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
8110b624:	00a04574 	movhi	r2,33045
8110b628:	10a1b904 	addi	r2,r2,-31004
8110b62c:	1080030b 	ldhu	r2,12(r2)
8110b630:	10bfffcc 	andi	r2,r2,65535
8110b634:	10c03ea0 	cmpeqi	r3,r2,250
8110b638:	1800401e 	bne	r3,zero,8110b73c <vParserCommTask+0x400>
8110b63c:	10c03ec8 	cmpgei	r3,r2,251
8110b640:	1800031e 	bne	r3,zero,8110b650 <vParserCommTask+0x314>
8110b644:	10800460 	cmpeqi	r2,r2,17
8110b648:	1000061e 	bne	r2,zero,8110b664 <vParserCommTask+0x328>
8110b64c:	0002b306 	br	8110c11c <vParserCommTask+0xde0>
8110b650:	10c03ee0 	cmpeqi	r3,r2,251
8110b654:	18009a1e 	bne	r3,zero,8110b8c0 <vParserCommTask+0x584>
8110b658:	10803f20 	cmpeqi	r2,r2,252
8110b65c:	10012f1e 	bne	r2,zero,8110bb1c <vParserCommTask+0x7e0>
8110b660:	0002ae06 	br	8110c11c <vParserCommTask+0xde0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
8110b664:	00a04574 	movhi	r2,33045
8110b668:	10a1b904 	addi	r2,r2,-31004
8110b66c:	1080038b 	ldhu	r2,14(r2)
8110b670:	10bfffcc 	andi	r2,r2,65535
8110b674:	10800060 	cmpeqi	r2,r2,1
8110b678:	10000e26 	beq	r2,zero,8110b6b4 <vParserCommTask+0x378>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_TEST_CONNECTION\n");
8110b67c:	d0a05517 	ldw	r2,-32428(gp)
8110b680:	100f883a 	mov	r7,r2
8110b684:	01800604 	movi	r6,24
8110b688:	01400044 	movi	r5,1
8110b68c:	01204534 	movhi	r4,33044
8110b690:	210bc704 	addi	r4,r4,12060
8110b694:	11172b80 	call	811172b8 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
8110b698:	00a04574 	movhi	r2,33045
8110b69c:	10a1b904 	addi	r2,r2,-31004
8110b6a0:	1080040b 	ldhu	r2,16(r2)
8110b6a4:	10bfffcc 	andi	r2,r2,65535
8110b6a8:	1009883a 	mov	r4,r2
8110b6ac:	11113a00 	call	811113a0 <vTMPusTestConnection>

								break;
8110b6b0:	00002106 	br	8110b738 <vParserCommTask+0x3fc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110b6b4:	e0bfdec4 	addi	r2,fp,-133
8110b6b8:	01802004 	movi	r6,128
8110b6bc:	000b883a 	mov	r5,zero
8110b6c0:	1009883a 	mov	r4,r2
8110b6c4:	1117e1c0 	call	81117e1c <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110b6c8:	00a04574 	movhi	r2,33045
8110b6cc:	10a1b904 	addi	r2,r2,-31004
8110b6d0:	1080030b 	ldhu	r2,12(r2)
8110b6d4:	113fffcc 	andi	r4,r2,65535
8110b6d8:	00a04574 	movhi	r2,33045
8110b6dc:	10a1b904 	addi	r2,r2,-31004
8110b6e0:	1080038b 	ldhu	r2,14(r2)
8110b6e4:	117fffcc 	andi	r5,r2,65535
8110b6e8:	00a04574 	movhi	r2,33045
8110b6ec:	10a1b904 	addi	r2,r2,-31004
8110b6f0:	1080040b 	ldhu	r2,16(r2)
8110b6f4:	10bfffcc 	andi	r2,r2,65535
8110b6f8:	e0ffdec4 	addi	r3,fp,-133
8110b6fc:	d8800015 	stw	r2,0(sp)
8110b700:	280f883a 	mov	r7,r5
8110b704:	200d883a 	mov	r6,r4
8110b708:	01604534 	movhi	r5,33044
8110b70c:	294bce04 	addi	r5,r5,12088
8110b710:	1809883a 	mov	r4,r3
8110b714:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110b718:	d0a05517 	ldw	r2,-32428(gp)
8110b71c:	e0ffdec4 	addi	r3,fp,-133
8110b720:	180b883a 	mov	r5,r3
8110b724:	1009883a 	mov	r4,r2
8110b728:	1116c1c0 	call	81116c1c <fprintf>
								#endif
								eParserMode = sWaitingMessage;
8110b72c:	00800044 	movi	r2,1
8110b730:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110b734:	0001883a 	nop
						}
                        break;
8110b738:	00027b06 	br	8110c128 <vParserCommTask+0xdec>
                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
8110b73c:	00a04574 	movhi	r2,33045
8110b740:	10a1b904 	addi	r2,r2,-31004
8110b744:	1080038b 	ldhu	r2,14(r2)
8110b748:	10bfffcc 	andi	r2,r2,65535
8110b74c:	10c00f20 	cmpeqi	r3,r2,60
8110b750:	18001a1e 	bne	r3,zero,8110b7bc <vParserCommTask+0x480>
8110b754:	10c00f48 	cmpgei	r3,r2,61
8110b758:	1800031e 	bne	r3,zero,8110b768 <vParserCommTask+0x42c>
8110b75c:	10800ee0 	cmpeqi	r2,r2,59
8110b760:	1000061e 	bne	r2,zero,8110b77c <vParserCommTask+0x440>
8110b764:	00003406 	br	8110b838 <vParserCommTask+0x4fc>
8110b768:	10c00f60 	cmpeqi	r3,r2,61
8110b76c:	18001e1e 	bne	r3,zero,8110b7e8 <vParserCommTask+0x4ac>
8110b770:	10800fa0 	cmpeqi	r2,r2,62
8110b774:	1000271e 	bne	r2,zero,8110b814 <vParserCommTask+0x4d8>
8110b778:	00002f06 	br	8110b838 <vParserCommTask+0x4fc>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_RESET\n");
8110b77c:	d0a05517 	ldw	r2,-32428(gp)
8110b780:	100f883a 	mov	r7,r2
8110b784:	01800384 	movi	r6,14
8110b788:	01400044 	movi	r5,1
8110b78c:	01204534 	movhi	r4,33044
8110b790:	210bde04 	addi	r4,r4,12152
8110b794:	11172b80 	call	811172b8 <fwrite>
								#endif
								vSendReset();
8110b798:	1110d480 	call	81110d48 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,1,0);
8110b79c:	000f883a 	mov	r7,zero
8110b7a0:	01800044 	movi	r6,1
8110b7a4:	000b883a 	mov	r5,zero
8110b7a8:	0009883a 	mov	r4,zero
8110b7ac:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
								vRstcSimucamReset( 50000 );
8110b7b0:	0130d414 	movui	r4,50000
8110b7b4:	11071fc0 	call	811071fc <vRstcSimucamReset>

								break;
8110b7b8:	00004006 	br	8110b8bc <vParserCommTask+0x580>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_CONFIG\n");
8110b7bc:	d0a05517 	ldw	r2,-32428(gp)
8110b7c0:	100f883a 	mov	r7,r2
8110b7c4:	018003c4 	movi	r6,15
8110b7c8:	01400044 	movi	r5,1
8110b7cc:	01204534 	movhi	r4,33044
8110b7d0:	210be204 	addi	r4,r4,12168
8110b7d4:	11172b80 	call	811172b8 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110b7d8:	01204574 	movhi	r4,33045
8110b7dc:	2121b904 	addi	r4,r4,-31004
8110b7e0:	110c2540 	call	8110c254 <bSendMessagePUStoMebTask>

								break;
8110b7e4:	00003506 	br	8110b8bc <vParserCommTask+0x580>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_RUN\n");
8110b7e8:	d0a05517 	ldw	r2,-32428(gp)
8110b7ec:	100f883a 	mov	r7,r2
8110b7f0:	01800304 	movi	r6,12
8110b7f4:	01400044 	movi	r5,1
8110b7f8:	01204534 	movhi	r4,33044
8110b7fc:	210be604 	addi	r4,r4,12184
8110b800:	11172b80 	call	811172b8 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110b804:	01204574 	movhi	r4,33045
8110b808:	2121b904 	addi	r4,r4,-31004
8110b80c:	110c2540 	call	8110c254 <bSendMessagePUStoMebTask>

								break;
8110b810:	00002a06 	br	8110b8bc <vParserCommTask+0x580>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_TURNOFF\n");
8110b814:	d0a05517 	ldw	r2,-32428(gp)
8110b818:	100f883a 	mov	r7,r2
8110b81c:	01800404 	movi	r6,16
8110b820:	01400044 	movi	r5,1
8110b824:	01204534 	movhi	r4,33044
8110b828:	210bea04 	addi	r4,r4,12200
8110b82c:	11172b80 	call	811172b8 <fwrite>
								#endif
								vSendTurnOff();
8110b830:	1110c300 	call	81110c30 <vSendTurnOff>

								/* todo:Enviar emnsagens para a meb, e a meb distribui a mensagem */
								/* todo:Enviar Sinalizar Led quando puder desligar */

								break;
8110b834:	00002106 	br	8110b8bc <vParserCommTask+0x580>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110b838:	e0bfdec4 	addi	r2,fp,-133
8110b83c:	01802004 	movi	r6,128
8110b840:	000b883a 	mov	r5,zero
8110b844:	1009883a 	mov	r4,r2
8110b848:	1117e1c0 	call	81117e1c <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110b84c:	00a04574 	movhi	r2,33045
8110b850:	10a1b904 	addi	r2,r2,-31004
8110b854:	1080030b 	ldhu	r2,12(r2)
8110b858:	113fffcc 	andi	r4,r2,65535
8110b85c:	00a04574 	movhi	r2,33045
8110b860:	10a1b904 	addi	r2,r2,-31004
8110b864:	1080038b 	ldhu	r2,14(r2)
8110b868:	117fffcc 	andi	r5,r2,65535
8110b86c:	00a04574 	movhi	r2,33045
8110b870:	10a1b904 	addi	r2,r2,-31004
8110b874:	1080040b 	ldhu	r2,16(r2)
8110b878:	10bfffcc 	andi	r2,r2,65535
8110b87c:	e0ffdec4 	addi	r3,fp,-133
8110b880:	d8800015 	stw	r2,0(sp)
8110b884:	280f883a 	mov	r7,r5
8110b888:	200d883a 	mov	r6,r4
8110b88c:	01604534 	movhi	r5,33044
8110b890:	294bce04 	addi	r5,r5,12088
8110b894:	1809883a 	mov	r4,r3
8110b898:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110b89c:	d0a05517 	ldw	r2,-32428(gp)
8110b8a0:	e0ffdec4 	addi	r3,fp,-133
8110b8a4:	180b883a 	mov	r5,r3
8110b8a8:	1009883a 	mov	r4,r2
8110b8ac:	1116c1c0 	call	81116c1c <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8110b8b0:	00800044 	movi	r2,1
8110b8b4:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110b8b8:	0001883a 	nop
						}
                        break;
8110b8bc:	00021a06 	br	8110c128 <vParserCommTask+0xdec>
                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8110b8c0:	00a04574 	movhi	r2,33045
8110b8c4:	10a1a604 	addi	r2,r2,-31080
8110b8c8:	1080050b 	ldhu	r2,20(r2)
8110b8cc:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
8110b8d0:	e0bfde0b 	ldhu	r2,-136(fp)
8110b8d4:	108001f0 	cmpltui	r2,r2,7
8110b8d8:	1000121e 	bne	r2,zero,8110b924 <vParserCommTask+0x5e8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
8110b8dc:	e0bfdec4 	addi	r2,fp,-133
8110b8e0:	01802004 	movi	r6,128
8110b8e4:	000b883a 	mov	r5,zero
8110b8e8:	1009883a 	mov	r4,r2
8110b8ec:	1117e1c0 	call	81117e1c <memset>
								sprintf(cPUSDebug, "Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
8110b8f0:	e0ffde0b 	ldhu	r3,-136(fp)
8110b8f4:	e0bfdec4 	addi	r2,fp,-133
8110b8f8:	180d883a 	mov	r6,r3
8110b8fc:	01604534 	movhi	r5,33044
8110b900:	294bef04 	addi	r5,r5,12220
8110b904:	1009883a 	mov	r4,r2
8110b908:	11185ac0 	call	811185ac <sprintf>
								debug(fp, cPUSDebug );
8110b90c:	d0a05517 	ldw	r2,-32428(gp)
8110b910:	e0ffdec4 	addi	r3,fp,-133
8110b914:	180b883a 	mov	r5,r3
8110b918:	1009883a 	mov	r4,r2
8110b91c:	1116c1c0 	call	81116c1c <fprintf>
									break;
							}
						}


                        break;
8110b920:	00020106 	br	8110c128 <vParserCommTask+0xdec>
								sprintf(cPUSDebug, "Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8110b924:	00a04574 	movhi	r2,33045
8110b928:	10a1b904 	addi	r2,r2,-31004
8110b92c:	10800483 	ldbu	r2,18(r2)
8110b930:	10c03fcc 	andi	r3,r2,255
8110b934:	00a04574 	movhi	r2,33045
8110b938:	10a1b904 	addi	r2,r2,-31004
8110b93c:	18c00284 	addi	r3,r3,10
8110b940:	18c7883a 	add	r3,r3,r3
8110b944:	10c5883a 	add	r2,r2,r3
8110b948:	e0ffde0b 	ldhu	r3,-136(fp)
8110b94c:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
8110b950:	00a04574 	movhi	r2,33045
8110b954:	10a1b904 	addi	r2,r2,-31004
8110b958:	10800483 	ldbu	r2,18(r2)
8110b95c:	10800044 	addi	r2,r2,1
8110b960:	1007883a 	mov	r3,r2
8110b964:	00a04574 	movhi	r2,33045
8110b968:	10a1b904 	addi	r2,r2,-31004
8110b96c:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
8110b970:	00a04574 	movhi	r2,33045
8110b974:	10a1b904 	addi	r2,r2,-31004
8110b978:	1080038b 	ldhu	r2,14(r2)
8110b97c:	10bfffcc 	andi	r2,r2,65535
8110b980:	10c000a0 	cmpeqi	r3,r2,2
8110b984:	1800191e 	bne	r3,zero,8110b9ec <vParserCommTask+0x6b0>
8110b988:	10c00160 	cmpeqi	r3,r2,5
8110b98c:	18002c1e 	bne	r3,zero,8110ba40 <vParserCommTask+0x704>
8110b990:	10800060 	cmpeqi	r2,r2,1
8110b994:	10003f26 	beq	r2,zero,8110ba94 <vParserCommTask+0x758>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110b998:	e0bfdec4 	addi	r2,fp,-133
8110b99c:	01802004 	movi	r6,128
8110b9a0:	000b883a 	mov	r5,zero
8110b9a4:	1009883a 	mov	r4,r2
8110b9a8:	1117e1c0 	call	81117e1c <memset>
										sprintf(cPUSDebug, "TC_SCAM_FEE_CONFIG_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
8110b9ac:	e0ffde0b 	ldhu	r3,-136(fp)
8110b9b0:	e0bfdec4 	addi	r2,fp,-133
8110b9b4:	180d883a 	mov	r6,r3
8110b9b8:	01604534 	movhi	r5,33044
8110b9bc:	294bfb04 	addi	r5,r5,12268
8110b9c0:	1009883a 	mov	r4,r2
8110b9c4:	11185ac0 	call	811185ac <sprintf>
										debug(fp, cPUSDebug );
8110b9c8:	d0a05517 	ldw	r2,-32428(gp)
8110b9cc:	e0ffdec4 	addi	r3,fp,-133
8110b9d0:	180b883a 	mov	r5,r3
8110b9d4:	1009883a 	mov	r4,r2
8110b9d8:	1116c1c0 	call	81116c1c <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
8110b9dc:	01204574 	movhi	r4,33045
8110b9e0:	2121b904 	addi	r4,r4,-31004
8110b9e4:	110c2540 	call	8110c254 <bSendMessagePUStoMebTask>

									break;
8110b9e8:	00004b06 	br	8110bb18 <vParserCommTask+0x7dc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110b9ec:	e0bfdec4 	addi	r2,fp,-133
8110b9f0:	01802004 	movi	r6,128
8110b9f4:	000b883a 	mov	r5,zero
8110b9f8:	1009883a 	mov	r4,r2
8110b9fc:	1117e1c0 	call	81117e1c <memset>
										sprintf(cPUSDebug, "TC_SCAM_FEE_STANDBY_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
8110ba00:	e0ffde0b 	ldhu	r3,-136(fp)
8110ba04:	e0bfdec4 	addi	r2,fp,-133
8110ba08:	180d883a 	mov	r6,r3
8110ba0c:	01604534 	movhi	r5,33044
8110ba10:	294c0704 	addi	r5,r5,12316
8110ba14:	1009883a 	mov	r4,r2
8110ba18:	11185ac0 	call	811185ac <sprintf>
										debug(fp, cPUSDebug );
8110ba1c:	d0a05517 	ldw	r2,-32428(gp)
8110ba20:	e0ffdec4 	addi	r3,fp,-133
8110ba24:	180b883a 	mov	r5,r3
8110ba28:	1009883a 	mov	r4,r2
8110ba2c:	1116c1c0 	call	81116c1c <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8110ba30:	01204574 	movhi	r4,33045
8110ba34:	2121b904 	addi	r4,r4,-31004
8110ba38:	110c2540 	call	8110c254 <bSendMessagePUStoMebTask>

									break;
8110ba3c:	00003606 	br	8110bb18 <vParserCommTask+0x7dc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110ba40:	e0bfdec4 	addi	r2,fp,-133
8110ba44:	01802004 	movi	r6,128
8110ba48:	000b883a 	mov	r5,zero
8110ba4c:	1009883a 	mov	r4,r2
8110ba50:	1117e1c0 	call	81117e1c <memset>
										sprintf(cPUSDebug, "TC_SCAM_FEE_CALIBRATION_TEST_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
8110ba54:	e0ffde0b 	ldhu	r3,-136(fp)
8110ba58:	e0bfdec4 	addi	r2,fp,-133
8110ba5c:	180d883a 	mov	r6,r3
8110ba60:	01604534 	movhi	r5,33044
8110ba64:	294c1304 	addi	r5,r5,12364
8110ba68:	1009883a 	mov	r4,r2
8110ba6c:	11185ac0 	call	811185ac <sprintf>
										debug(fp, cPUSDebug );
8110ba70:	d0a05517 	ldw	r2,-32428(gp)
8110ba74:	e0ffdec4 	addi	r3,fp,-133
8110ba78:	180b883a 	mov	r5,r3
8110ba7c:	1009883a 	mov	r4,r2
8110ba80:	1116c1c0 	call	81116c1c <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8110ba84:	01204574 	movhi	r4,33045
8110ba88:	2121b904 	addi	r4,r4,-31004
8110ba8c:	110c2540 	call	8110c254 <bSendMessagePUStoMebTask>

									break;
8110ba90:	00002106 	br	8110bb18 <vParserCommTask+0x7dc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110ba94:	e0bfdec4 	addi	r2,fp,-133
8110ba98:	01802004 	movi	r6,128
8110ba9c:	000b883a 	mov	r5,zero
8110baa0:	1009883a 	mov	r4,r2
8110baa4:	1117e1c0 	call	81117e1c <memset>
										sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110baa8:	00a04574 	movhi	r2,33045
8110baac:	10a1b904 	addi	r2,r2,-31004
8110bab0:	1080030b 	ldhu	r2,12(r2)
8110bab4:	113fffcc 	andi	r4,r2,65535
8110bab8:	00a04574 	movhi	r2,33045
8110babc:	10a1b904 	addi	r2,r2,-31004
8110bac0:	1080038b 	ldhu	r2,14(r2)
8110bac4:	117fffcc 	andi	r5,r2,65535
8110bac8:	00a04574 	movhi	r2,33045
8110bacc:	10a1b904 	addi	r2,r2,-31004
8110bad0:	1080040b 	ldhu	r2,16(r2)
8110bad4:	10bfffcc 	andi	r2,r2,65535
8110bad8:	e0ffdec4 	addi	r3,fp,-133
8110badc:	d8800015 	stw	r2,0(sp)
8110bae0:	280f883a 	mov	r7,r5
8110bae4:	200d883a 	mov	r6,r4
8110bae8:	01604534 	movhi	r5,33044
8110baec:	294bce04 	addi	r5,r5,12088
8110baf0:	1809883a 	mov	r4,r3
8110baf4:	11185ac0 	call	811185ac <sprintf>
										debug(fp, cPUSDebug );
8110baf8:	d0a05517 	ldw	r2,-32428(gp)
8110bafc:	e0ffdec4 	addi	r3,fp,-133
8110bb00:	180b883a 	mov	r5,r3
8110bb04:	1009883a 	mov	r4,r2
8110bb08:	1116c1c0 	call	81116c1c <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
8110bb0c:	00800044 	movi	r2,1
8110bb10:	e0bfdc15 	stw	r2,-144(fp)
									break;
8110bb14:	0001883a 	nop
							}
						}


                        break;
8110bb18:	00018306 	br	8110c128 <vParserCommTask+0xdec>
					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8110bb1c:	00a04574 	movhi	r2,33045
8110bb20:	10a1a604 	addi	r2,r2,-31080
8110bb24:	1080050b 	ldhu	r2,20(r2)
8110bb28:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8110bb2c:	00a04574 	movhi	r2,33045
8110bb30:	10a1b904 	addi	r2,r2,-31004
8110bb34:	10800483 	ldbu	r2,18(r2)
8110bb38:	10c03fcc 	andi	r3,r2,255
8110bb3c:	00a04574 	movhi	r2,33045
8110bb40:	10a1b904 	addi	r2,r2,-31004
8110bb44:	18c00284 	addi	r3,r3,10
8110bb48:	18c7883a 	add	r3,r3,r3
8110bb4c:	10c5883a 	add	r2,r2,r3
8110bb50:	e0ffde0b 	ldhu	r3,-136(fp)
8110bb54:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
8110bb58:	00a04574 	movhi	r2,33045
8110bb5c:	10a1b904 	addi	r2,r2,-31004
8110bb60:	10800483 	ldbu	r2,18(r2)
8110bb64:	10800044 	addi	r2,r2,1
8110bb68:	1007883a 	mov	r3,r2
8110bb6c:	00a04574 	movhi	r2,33045
8110bb70:	10a1b904 	addi	r2,r2,-31004
8110bb74:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
8110bb78:	00a04574 	movhi	r2,33045
8110bb7c:	10a1b904 	addi	r2,r2,-31004
8110bb80:	1080038b 	ldhu	r2,14(r2)
8110bb84:	10bfffcc 	andi	r2,r2,65535
8110bb88:	10c000e0 	cmpeqi	r3,r2,3
8110bb8c:	18000a1e 	bne	r3,zero,8110bbb8 <vParserCommTask+0x87c>
8110bb90:	10c00108 	cmpgei	r3,r2,4
8110bb94:	1800031e 	bne	r3,zero,8110bba4 <vParserCommTask+0x868>
8110bb98:	108000a0 	cmpeqi	r2,r2,2
8110bb9c:	1000451e 	bne	r2,zero,8110bcb4 <vParserCommTask+0x978>
8110bba0:	00013c06 	br	8110c094 <vParserCommTask+0xd58>
8110bba4:	10c00120 	cmpeqi	r3,r2,4
8110bba8:	1800181e 	bne	r3,zero,8110bc0c <vParserCommTask+0x8d0>
8110bbac:	10800160 	cmpeqi	r2,r2,5
8110bbb0:	10002b1e 	bne	r2,zero,8110bc60 <vParserCommTask+0x924>
8110bbb4:	00013706 	br	8110c094 <vParserCommTask+0xd58>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110bbb8:	e0bfdec4 	addi	r2,fp,-133
8110bbbc:	01802004 	movi	r6,128
8110bbc0:	000b883a 	mov	r5,zero
8110bbc4:	1009883a 	mov	r4,r2
8110bbc8:	1117e1c0 	call	81117e1c <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_ENABLE-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110bbcc:	e0ffde0b 	ldhu	r3,-136(fp)
8110bbd0:	e0bfdec4 	addi	r2,fp,-133
8110bbd4:	180d883a 	mov	r6,r3
8110bbd8:	01604534 	movhi	r5,33044
8110bbdc:	294c2204 	addi	r5,r5,12424
8110bbe0:	1009883a 	mov	r4,r2
8110bbe4:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110bbe8:	d0a05517 	ldw	r2,-32428(gp)
8110bbec:	e0ffdec4 	addi	r3,fp,-133
8110bbf0:	180b883a 	mov	r5,r3
8110bbf4:	1009883a 	mov	r4,r2
8110bbf8:	1116c1c0 	call	81116c1c <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110bbfc:	01204574 	movhi	r4,33045
8110bc00:	2121b904 	addi	r4,r4,-31004
8110bc04:	110c2540 	call	8110c254 <bSendMessagePUStoMebTask>

								break;
8110bc08:	00014306 	br	8110c118 <vParserCommTask+0xddc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110bc0c:	e0bfdec4 	addi	r2,fp,-133
8110bc10:	01802004 	movi	r6,128
8110bc14:	000b883a 	mov	r5,zero
8110bc18:	1009883a 	mov	r4,r2
8110bc1c:	1117e1c0 	call	81117e1c <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_DISABLE-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110bc20:	e0ffde0b 	ldhu	r3,-136(fp)
8110bc24:	e0bfdec4 	addi	r2,fp,-133
8110bc28:	180d883a 	mov	r6,r3
8110bc2c:	01604534 	movhi	r5,33044
8110bc30:	294c2f04 	addi	r5,r5,12476
8110bc34:	1009883a 	mov	r4,r2
8110bc38:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110bc3c:	d0a05517 	ldw	r2,-32428(gp)
8110bc40:	e0ffdec4 	addi	r3,fp,-133
8110bc44:	180b883a 	mov	r5,r3
8110bc48:	1009883a 	mov	r4,r2
8110bc4c:	1116c1c0 	call	81116c1c <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110bc50:	01204574 	movhi	r4,33045
8110bc54:	2121b904 	addi	r4,r4,-31004
8110bc58:	110c2540 	call	8110c254 <bSendMessagePUStoMebTask>

								break;
8110bc5c:	00012e06 	br	8110c118 <vParserCommTask+0xddc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110bc60:	e0bfdec4 	addi	r2,fp,-133
8110bc64:	01802004 	movi	r6,128
8110bc68:	000b883a 	mov	r5,zero
8110bc6c:	1009883a 	mov	r4,r2
8110bc70:	1117e1c0 	call	81117e1c <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_RESET-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110bc74:	e0ffde0b 	ldhu	r3,-136(fp)
8110bc78:	e0bfdec4 	addi	r2,fp,-133
8110bc7c:	180d883a 	mov	r6,r3
8110bc80:	01604534 	movhi	r5,33044
8110bc84:	294c3c04 	addi	r5,r5,12528
8110bc88:	1009883a 	mov	r4,r2
8110bc8c:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110bc90:	d0a05517 	ldw	r2,-32428(gp)
8110bc94:	e0ffdec4 	addi	r3,fp,-133
8110bc98:	180b883a 	mov	r5,r3
8110bc9c:	1009883a 	mov	r4,r2
8110bca0:	1116c1c0 	call	81116c1c <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110bca4:	01204574 	movhi	r4,33045
8110bca8:	2121b904 	addi	r4,r4,-31004
8110bcac:	110c2540 	call	8110c254 <bSendMessagePUStoMebTask>

								break;
8110bcb0:	00011906 	br	8110c118 <vParserCommTask+0xddc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
8110bcb4:	00a04574 	movhi	r2,33045
8110bcb8:	10a1b904 	addi	r2,r2,-31004
8110bcbc:	10800483 	ldbu	r2,18(r2)
8110bcc0:	10c03fcc 	andi	r3,r2,255
8110bcc4:	00a04574 	movhi	r2,33045
8110bcc8:	10a1a604 	addi	r2,r2,-31080
8110bccc:	1100058b 	ldhu	r4,22(r2)
8110bcd0:	00a04574 	movhi	r2,33045
8110bcd4:	10a1b904 	addi	r2,r2,-31004
8110bcd8:	18c00284 	addi	r3,r3,10
8110bcdc:	18c7883a 	add	r3,r3,r3
8110bce0:	10c5883a 	add	r2,r2,r3
8110bce4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110bce8:	00a04574 	movhi	r2,33045
8110bcec:	10a1b904 	addi	r2,r2,-31004
8110bcf0:	10800483 	ldbu	r2,18(r2)
8110bcf4:	10800044 	addi	r2,r2,1
8110bcf8:	1007883a 	mov	r3,r2
8110bcfc:	00a04574 	movhi	r2,33045
8110bd00:	10a1b904 	addi	r2,r2,-31004
8110bd04:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
8110bd08:	00a04574 	movhi	r2,33045
8110bd0c:	10a1b904 	addi	r2,r2,-31004
8110bd10:	10800483 	ldbu	r2,18(r2)
8110bd14:	10c03fcc 	andi	r3,r2,255
8110bd18:	00a04574 	movhi	r2,33045
8110bd1c:	10a1a604 	addi	r2,r2,-31080
8110bd20:	1100060b 	ldhu	r4,24(r2)
8110bd24:	00a04574 	movhi	r2,33045
8110bd28:	10a1b904 	addi	r2,r2,-31004
8110bd2c:	18c00284 	addi	r3,r3,10
8110bd30:	18c7883a 	add	r3,r3,r3
8110bd34:	10c5883a 	add	r2,r2,r3
8110bd38:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110bd3c:	00a04574 	movhi	r2,33045
8110bd40:	10a1b904 	addi	r2,r2,-31004
8110bd44:	10800483 	ldbu	r2,18(r2)
8110bd48:	10800044 	addi	r2,r2,1
8110bd4c:	1007883a 	mov	r3,r2
8110bd50:	00a04574 	movhi	r2,33045
8110bd54:	10a1b904 	addi	r2,r2,-31004
8110bd58:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
8110bd5c:	00a04574 	movhi	r2,33045
8110bd60:	10a1b904 	addi	r2,r2,-31004
8110bd64:	10800483 	ldbu	r2,18(r2)
8110bd68:	10c03fcc 	andi	r3,r2,255
8110bd6c:	00a04574 	movhi	r2,33045
8110bd70:	10a1a604 	addi	r2,r2,-31080
8110bd74:	1100068b 	ldhu	r4,26(r2)
8110bd78:	00a04574 	movhi	r2,33045
8110bd7c:	10a1b904 	addi	r2,r2,-31004
8110bd80:	18c00284 	addi	r3,r3,10
8110bd84:	18c7883a 	add	r3,r3,r3
8110bd88:	10c5883a 	add	r2,r2,r3
8110bd8c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110bd90:	00a04574 	movhi	r2,33045
8110bd94:	10a1b904 	addi	r2,r2,-31004
8110bd98:	10800483 	ldbu	r2,18(r2)
8110bd9c:	10800044 	addi	r2,r2,1
8110bda0:	1007883a 	mov	r3,r2
8110bda4:	00a04574 	movhi	r2,33045
8110bda8:	10a1b904 	addi	r2,r2,-31004
8110bdac:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
8110bdb0:	00a04574 	movhi	r2,33045
8110bdb4:	10a1b904 	addi	r2,r2,-31004
8110bdb8:	10800483 	ldbu	r2,18(r2)
8110bdbc:	10c03fcc 	andi	r3,r2,255
8110bdc0:	00a04574 	movhi	r2,33045
8110bdc4:	10a1a604 	addi	r2,r2,-31080
8110bdc8:	1100070b 	ldhu	r4,28(r2)
8110bdcc:	00a04574 	movhi	r2,33045
8110bdd0:	10a1b904 	addi	r2,r2,-31004
8110bdd4:	18c00284 	addi	r3,r3,10
8110bdd8:	18c7883a 	add	r3,r3,r3
8110bddc:	10c5883a 	add	r2,r2,r3
8110bde0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110bde4:	00a04574 	movhi	r2,33045
8110bde8:	10a1b904 	addi	r2,r2,-31004
8110bdec:	10800483 	ldbu	r2,18(r2)
8110bdf0:	10800044 	addi	r2,r2,1
8110bdf4:	1007883a 	mov	r3,r2
8110bdf8:	00a04574 	movhi	r2,33045
8110bdfc:	10a1b904 	addi	r2,r2,-31004
8110be00:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
8110be04:	00a04574 	movhi	r2,33045
8110be08:	10a1b904 	addi	r2,r2,-31004
8110be0c:	10800483 	ldbu	r2,18(r2)
8110be10:	10c03fcc 	andi	r3,r2,255
8110be14:	00a04574 	movhi	r2,33045
8110be18:	10a1a604 	addi	r2,r2,-31080
8110be1c:	1100078b 	ldhu	r4,30(r2)
8110be20:	00a04574 	movhi	r2,33045
8110be24:	10a1b904 	addi	r2,r2,-31004
8110be28:	18c00284 	addi	r3,r3,10
8110be2c:	18c7883a 	add	r3,r3,r3
8110be30:	10c5883a 	add	r2,r2,r3
8110be34:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110be38:	00a04574 	movhi	r2,33045
8110be3c:	10a1b904 	addi	r2,r2,-31004
8110be40:	10800483 	ldbu	r2,18(r2)
8110be44:	10800044 	addi	r2,r2,1
8110be48:	1007883a 	mov	r3,r2
8110be4c:	00a04574 	movhi	r2,33045
8110be50:	10a1b904 	addi	r2,r2,-31004
8110be54:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
8110be58:	00a04574 	movhi	r2,33045
8110be5c:	10a1b904 	addi	r2,r2,-31004
8110be60:	10800483 	ldbu	r2,18(r2)
8110be64:	10c03fcc 	andi	r3,r2,255
8110be68:	00a04574 	movhi	r2,33045
8110be6c:	10a1a604 	addi	r2,r2,-31080
8110be70:	1100080b 	ldhu	r4,32(r2)
8110be74:	00a04574 	movhi	r2,33045
8110be78:	10a1b904 	addi	r2,r2,-31004
8110be7c:	18c00284 	addi	r3,r3,10
8110be80:	18c7883a 	add	r3,r3,r3
8110be84:	10c5883a 	add	r2,r2,r3
8110be88:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110be8c:	00a04574 	movhi	r2,33045
8110be90:	10a1b904 	addi	r2,r2,-31004
8110be94:	10800483 	ldbu	r2,18(r2)
8110be98:	10800044 	addi	r2,r2,1
8110be9c:	1007883a 	mov	r3,r2
8110bea0:	00a04574 	movhi	r2,33045
8110bea4:	10a1b904 	addi	r2,r2,-31004
8110bea8:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110beac:	e0bfdec4 	addi	r2,fp,-133
8110beb0:	01802004 	movi	r6,128
8110beb4:	000b883a 	mov	r5,zero
8110beb8:	1009883a 	mov	r4,r2
8110bebc:	1117e1c0 	call	81117e1c <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_RMAP_CONFIG_UPDATE->\n");
8110bec0:	e0ffdec4 	addi	r3,fp,-133
8110bec4:	00a04534 	movhi	r2,33044
8110bec8:	108c4804 	addi	r2,r2,12576
8110becc:	1009883a 	mov	r4,r2
8110bed0:	00800884 	movi	r2,34
8110bed4:	100d883a 	mov	r6,r2
8110bed8:	200b883a 	mov	r5,r4
8110bedc:	1809883a 	mov	r4,r3
8110bee0:	1117ccc0 	call	81117ccc <memcpy>
									debug(fp, cPUSDebug );
8110bee4:	d0a05517 	ldw	r2,-32428(gp)
8110bee8:	e0ffdec4 	addi	r3,fp,-133
8110beec:	180b883a 	mov	r5,r3
8110bef0:	1009883a 	mov	r4,r2
8110bef4:	1116c1c0 	call	81116c1c <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110bef8:	e0ffde0b 	ldhu	r3,-136(fp)
8110befc:	e0bfdec4 	addi	r2,fp,-133
8110bf00:	180d883a 	mov	r6,r3
8110bf04:	01604534 	movhi	r5,33044
8110bf08:	294c5104 	addi	r5,r5,12612
8110bf0c:	1009883a 	mov	r4,r2
8110bf10:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110bf14:	d0a05517 	ldw	r2,-32428(gp)
8110bf18:	e0ffdec4 	addi	r3,fp,-133
8110bf1c:	180b883a 	mov	r5,r3
8110bf20:	1009883a 	mov	r4,r2
8110bf24:	1116c1c0 	call	81116c1c <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
8110bf28:	00a04574 	movhi	r2,33045
8110bf2c:	10a1a604 	addi	r2,r2,-31080
8110bf30:	1080058b 	ldhu	r2,22(r2)
8110bf34:	10ffffcc 	andi	r3,r2,65535
8110bf38:	e0bfdec4 	addi	r2,fp,-133
8110bf3c:	180d883a 	mov	r6,r3
8110bf40:	01604534 	movhi	r5,33044
8110bf44:	294c5804 	addi	r5,r5,12640
8110bf48:	1009883a 	mov	r4,r2
8110bf4c:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110bf50:	d0a05517 	ldw	r2,-32428(gp)
8110bf54:	e0ffdec4 	addi	r3,fp,-133
8110bf58:	180b883a 	mov	r5,r3
8110bf5c:	1009883a 	mov	r4,r2
8110bf60:	1116c1c0 	call	81116c1c <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
8110bf64:	00a04574 	movhi	r2,33045
8110bf68:	10a1a604 	addi	r2,r2,-31080
8110bf6c:	1080060b 	ldhu	r2,24(r2)
8110bf70:	10ffffcc 	andi	r3,r2,65535
8110bf74:	e0bfdec4 	addi	r2,fp,-133
8110bf78:	180d883a 	mov	r6,r3
8110bf7c:	01604534 	movhi	r5,33044
8110bf80:	294c5c04 	addi	r5,r5,12656
8110bf84:	1009883a 	mov	r4,r2
8110bf88:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110bf8c:	d0a05517 	ldw	r2,-32428(gp)
8110bf90:	e0ffdec4 	addi	r3,fp,-133
8110bf94:	180b883a 	mov	r5,r3
8110bf98:	1009883a 	mov	r4,r2
8110bf9c:	1116c1c0 	call	81116c1c <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
8110bfa0:	00a04574 	movhi	r2,33045
8110bfa4:	10a1a604 	addi	r2,r2,-31080
8110bfa8:	1080068b 	ldhu	r2,26(r2)
8110bfac:	10ffffcc 	andi	r3,r2,65535
8110bfb0:	e0bfdec4 	addi	r2,fp,-133
8110bfb4:	180d883a 	mov	r6,r3
8110bfb8:	01604534 	movhi	r5,33044
8110bfbc:	294c6104 	addi	r5,r5,12676
8110bfc0:	1009883a 	mov	r4,r2
8110bfc4:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110bfc8:	d0a05517 	ldw	r2,-32428(gp)
8110bfcc:	e0ffdec4 	addi	r3,fp,-133
8110bfd0:	180b883a 	mov	r5,r3
8110bfd4:	1009883a 	mov	r4,r2
8110bfd8:	1116c1c0 	call	81116c1c <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
8110bfdc:	00a04574 	movhi	r2,33045
8110bfe0:	10a1a604 	addi	r2,r2,-31080
8110bfe4:	1080070b 	ldhu	r2,28(r2)
8110bfe8:	10ffffcc 	andi	r3,r2,65535
8110bfec:	e0bfdec4 	addi	r2,fp,-133
8110bff0:	180d883a 	mov	r6,r3
8110bff4:	01604534 	movhi	r5,33044
8110bff8:	294c6804 	addi	r5,r5,12704
8110bffc:	1009883a 	mov	r4,r2
8110c000:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110c004:	d0a05517 	ldw	r2,-32428(gp)
8110c008:	e0ffdec4 	addi	r3,fp,-133
8110c00c:	180b883a 	mov	r5,r3
8110c010:	1009883a 	mov	r4,r2
8110c014:	1116c1c0 	call	81116c1c <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
8110c018:	00a04574 	movhi	r2,33045
8110c01c:	10a1a604 	addi	r2,r2,-31080
8110c020:	1080078b 	ldhu	r2,30(r2)
8110c024:	10ffffcc 	andi	r3,r2,65535
8110c028:	e0bfdec4 	addi	r2,fp,-133
8110c02c:	180d883a 	mov	r6,r3
8110c030:	01604534 	movhi	r5,33044
8110c034:	294c6f04 	addi	r5,r5,12732
8110c038:	1009883a 	mov	r4,r2
8110c03c:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110c040:	d0a05517 	ldw	r2,-32428(gp)
8110c044:	e0ffdec4 	addi	r3,fp,-133
8110c048:	180b883a 	mov	r5,r3
8110c04c:	1009883a 	mov	r4,r2
8110c050:	1116c1c0 	call	81116c1c <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
8110c054:	00a04574 	movhi	r2,33045
8110c058:	10a1a604 	addi	r2,r2,-31080
8110c05c:	1080080b 	ldhu	r2,32(r2)
8110c060:	10ffffcc 	andi	r3,r2,65535
8110c064:	e0bfdec4 	addi	r2,fp,-133
8110c068:	180d883a 	mov	r6,r3
8110c06c:	01604534 	movhi	r5,33044
8110c070:	294c7504 	addi	r5,r5,12756
8110c074:	1009883a 	mov	r4,r2
8110c078:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110c07c:	d0a05517 	ldw	r2,-32428(gp)
8110c080:	e0ffdec4 	addi	r3,fp,-133
8110c084:	180b883a 	mov	r5,r3
8110c088:	1009883a 	mov	r4,r2
8110c08c:	1116c1c0 	call	81116c1c <fprintf>
								#endif

								break;
8110c090:	00002106 	br	8110c118 <vParserCommTask+0xddc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110c094:	e0bfdec4 	addi	r2,fp,-133
8110c098:	01802004 	movi	r6,128
8110c09c:	000b883a 	mov	r5,zero
8110c0a0:	1009883a 	mov	r4,r2
8110c0a4:	1117e1c0 	call	81117e1c <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110c0a8:	00a04574 	movhi	r2,33045
8110c0ac:	10a1b904 	addi	r2,r2,-31004
8110c0b0:	1080030b 	ldhu	r2,12(r2)
8110c0b4:	113fffcc 	andi	r4,r2,65535
8110c0b8:	00a04574 	movhi	r2,33045
8110c0bc:	10a1b904 	addi	r2,r2,-31004
8110c0c0:	1080038b 	ldhu	r2,14(r2)
8110c0c4:	117fffcc 	andi	r5,r2,65535
8110c0c8:	00a04574 	movhi	r2,33045
8110c0cc:	10a1b904 	addi	r2,r2,-31004
8110c0d0:	1080040b 	ldhu	r2,16(r2)
8110c0d4:	10bfffcc 	andi	r2,r2,65535
8110c0d8:	e0ffdec4 	addi	r3,fp,-133
8110c0dc:	d8800015 	stw	r2,0(sp)
8110c0e0:	280f883a 	mov	r7,r5
8110c0e4:	200d883a 	mov	r6,r4
8110c0e8:	01604534 	movhi	r5,33044
8110c0ec:	294bce04 	addi	r5,r5,12088
8110c0f0:	1809883a 	mov	r4,r3
8110c0f4:	11185ac0 	call	811185ac <sprintf>
									debug(fp, cPUSDebug );
8110c0f8:	d0a05517 	ldw	r2,-32428(gp)
8110c0fc:	e0ffdec4 	addi	r3,fp,-133
8110c100:	180b883a 	mov	r5,r3
8110c104:	1009883a 	mov	r4,r2
8110c108:	1116c1c0 	call	81116c1c <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8110c10c:	00800044 	movi	r2,1
8110c110:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110c114:	0001883a 	nop
						}
                        break;
8110c118:	00000306 	br	8110c128 <vParserCommTask+0xdec>
                    default:
						eParserMode = sWaitingMessage;
8110c11c:	00800044 	movi	r2,1
8110c120:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8110c124:	0001883a 	nop
                }
				break;				
8110c128:	00000306 	br	8110c138 <vParserCommTask+0xdfc>
			default:
				eParserMode = sWaitingMessage;
8110c12c:	00800044 	movi	r2,1
8110c130:	e0bfdc15 	stw	r2,-144(fp)
				break;
8110c134:	0001883a 	nop
		}
	}
8110c138:	003c9006 	br	8110b37c <__reset+0xfb0eb37c>

8110c13c <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
8110c13c:	defffb04 	addi	sp,sp,-20
8110c140:	de00012e 	bgeu	sp,et,8110c148 <getPreParsedPacket+0xc>
8110c144:	003b68fa 	trap	3
8110c148:	dfc00415 	stw	ra,16(sp)
8110c14c:	df000315 	stw	fp,12(sp)
8110c150:	df000304 	addi	fp,sp,12
8110c154:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c158:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
8110c15c:	d0a05d17 	ldw	r2,-32396(gp)
8110c160:	e0fffe44 	addi	r3,fp,-7
8110c164:	180d883a 	mov	r6,r3
8110c168:	000b883a 	mov	r5,zero
8110c16c:	1009883a 	mov	r4,r2
8110c170:	1132cec0 	call	81132cec <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
8110c174:	e0bffe43 	ldbu	r2,-7(fp)
8110c178:	10803fcc 	andi	r2,r2,255
8110c17c:	10002e1e 	bne	r2,zero,8110c238 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8110c180:	e03ffe05 	stb	zero,-8(fp)
8110c184:	00002506 	br	8110c21c <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
8110c188:	e0fffe03 	ldbu	r3,-8(fp)
8110c18c:	00a045b4 	movhi	r2,33046
8110c190:	10b16504 	addi	r2,r2,-14956
8110c194:	18c01324 	muli	r3,r3,76
8110c198:	10c5883a 	add	r2,r2,r3
8110c19c:	10800104 	addi	r2,r2,4
8110c1a0:	10800003 	ldbu	r2,0(r2)
8110c1a4:	10803fcc 	andi	r2,r2,255
8110c1a8:	1080201c 	xori	r2,r2,128
8110c1ac:	10bfe004 	addi	r2,r2,-128
8110c1b0:	10001726 	beq	r2,zero,8110c210 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
8110c1b4:	e0fffe03 	ldbu	r3,-8(fp)
8110c1b8:	e13fff17 	ldw	r4,-4(fp)
8110c1bc:	00a045b4 	movhi	r2,33046
8110c1c0:	10b16504 	addi	r2,r2,-14956
8110c1c4:	18c01324 	muli	r3,r3,76
8110c1c8:	10c5883a 	add	r2,r2,r3
8110c1cc:	2007883a 	mov	r3,r4
8110c1d0:	1009883a 	mov	r4,r2
8110c1d4:	00801304 	movi	r2,76
8110c1d8:	100d883a 	mov	r6,r2
8110c1dc:	200b883a 	mov	r5,r4
8110c1e0:	1809883a 	mov	r4,r3
8110c1e4:	1117ccc0 	call	81117ccc <memcpy>
                bSuccess = TRUE;
8110c1e8:	00800044 	movi	r2,1
8110c1ec:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
8110c1f0:	e0fffe03 	ldbu	r3,-8(fp)
8110c1f4:	00a045b4 	movhi	r2,33046
8110c1f8:	10b16504 	addi	r2,r2,-14956
8110c1fc:	18c01324 	muli	r3,r3,76
8110c200:	10c5883a 	add	r2,r2,r3
8110c204:	10800104 	addi	r2,r2,4
8110c208:	10000005 	stb	zero,0(r2)
                break;
8110c20c:	00000606 	br	8110c228 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8110c210:	e0bffe03 	ldbu	r2,-8(fp)
8110c214:	10800044 	addi	r2,r2,1
8110c218:	e0bffe05 	stb	r2,-8(fp)
8110c21c:	e0bffe03 	ldbu	r2,-8(fp)
8110c220:	10800230 	cmpltui	r2,r2,8
8110c224:	103fd81e 	bne	r2,zero,8110c188 <__reset+0xfb0ec188>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
8110c228:	d0a05d17 	ldw	r2,-32396(gp)
8110c22c:	1009883a 	mov	r4,r2
8110c230:	11332900 	call	81133290 <OSMutexPost>
8110c234:	00000106 	br	8110c23c <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
8110c238:	1112c800 	call	81112c80 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
8110c23c:	e0bffd17 	ldw	r2,-12(fp)
}
8110c240:	e037883a 	mov	sp,fp
8110c244:	dfc00117 	ldw	ra,4(sp)
8110c248:	df000017 	ldw	fp,0(sp)
8110c24c:	dec00204 	addi	sp,sp,8
8110c250:	f800283a 	ret

8110c254 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
8110c254:	defffa04 	addi	sp,sp,-24
8110c258:	de00012e 	bgeu	sp,et,8110c260 <bSendMessagePUStoMebTask+0xc>
8110c25c:	003b68fa 	trap	3
8110c260:	dfc00515 	stw	ra,20(sp)
8110c264:	df000415 	stw	fp,16(sp)
8110c268:	df000404 	addi	fp,sp,16
8110c26c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c270:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
8110c274:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
8110c278:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
8110c27c:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
8110c280:	d0a06417 	ldw	r2,-32368(gp)
8110c284:	e0fffd44 	addi	r3,fp,-11
8110c288:	180d883a 	mov	r6,r3
8110c28c:	01400284 	movi	r5,10
8110c290:	1009883a 	mov	r4,r2
8110c294:	1132cec0 	call	81132cec <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110c298:	e0bffd43 	ldbu	r2,-11(fp)
8110c29c:	10803fcc 	andi	r2,r2,255
8110c2a0:	1000401e 	bne	r2,zero,8110c3a4 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
8110c2a4:	e03ffd05 	stb	zero,-12(fp)
8110c2a8:	00003806 	br	8110c38c <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
8110c2ac:	e0fffd03 	ldbu	r3,-12(fp)
8110c2b0:	00a04574 	movhi	r2,33045
8110c2b4:	10abed04 	addi	r2,r2,-20556
8110c2b8:	18c01524 	muli	r3,r3,84
8110c2bc:	10c5883a 	add	r2,r2,r3
8110c2c0:	10800104 	addi	r2,r2,4
8110c2c4:	10800017 	ldw	r2,0(r2)
8110c2c8:	10002d1e 	bne	r2,zero,8110c380 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
8110c2cc:	e0fffd03 	ldbu	r3,-12(fp)
8110c2d0:	00a04574 	movhi	r2,33045
8110c2d4:	10abed04 	addi	r2,r2,-20556
8110c2d8:	18c01524 	muli	r3,r3,84
8110c2dc:	10c7883a 	add	r3,r2,r3
8110c2e0:	e0bfff17 	ldw	r2,-4(fp)
8110c2e4:	1009883a 	mov	r4,r2
8110c2e8:	00801504 	movi	r2,84
8110c2ec:	100d883a 	mov	r6,r2
8110c2f0:	200b883a 	mov	r5,r4
8110c2f4:	1809883a 	mov	r4,r3
8110c2f8:	1117ccc0 	call	81117ccc <memcpy>
            	xPus[i].bInUse = TRUE;
8110c2fc:	e0fffd03 	ldbu	r3,-12(fp)
8110c300:	00a04574 	movhi	r2,33045
8110c304:	10abed04 	addi	r2,r2,-20556
8110c308:	18c01524 	muli	r3,r3,84
8110c30c:	10c5883a 	add	r2,r2,r3
8110c310:	10800104 	addi	r2,r2,4
8110c314:	00c00044 	movi	r3,1
8110c318:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
8110c31c:	00800044 	movi	r2,1
8110c320:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
8110c324:	00800044 	movi	r2,1
8110c328:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
8110c32c:	d0a05c17 	ldw	r2,-32400(gp)
8110c330:	e0fffe17 	ldw	r3,-8(fp)
8110c334:	180b883a 	mov	r5,r3
8110c338:	1009883a 	mov	r4,r2
8110c33c:	11342080 	call	81134208 <OSQPost>
8110c340:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
8110c344:	e0bffd43 	ldbu	r2,-11(fp)
8110c348:	10803fcc 	andi	r2,r2,255
8110c34c:	10000926 	beq	r2,zero,8110c374 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
8110c350:	1113b000 	call	81113b00 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
8110c354:	e0fffd03 	ldbu	r3,-12(fp)
8110c358:	00a04574 	movhi	r2,33045
8110c35c:	10abed04 	addi	r2,r2,-20556
8110c360:	18c01524 	muli	r3,r3,84
8110c364:	10c5883a 	add	r2,r2,r3
8110c368:	10800104 	addi	r2,r2,4
8110c36c:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
8110c370:	00000906 	br	8110c398 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
8110c374:	00800044 	movi	r2,1
8110c378:	e0bffc15 	stw	r2,-16(fp)
                break;
8110c37c:	00000606 	br	8110c398 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
8110c380:	e0bffd03 	ldbu	r2,-12(fp)
8110c384:	10800044 	addi	r2,r2,1
8110c388:	e0bffd05 	stb	r2,-12(fp)
8110c38c:	e0bffd03 	ldbu	r2,-12(fp)
8110c390:	10800130 	cmpltui	r2,r2,4
8110c394:	103fc51e 	bne	r2,zero,8110c2ac <__reset+0xfb0ec2ac>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
8110c398:	d0a06417 	ldw	r2,-32368(gp)
8110c39c:	1009883a 	mov	r4,r2
8110c3a0:	11332900 	call	81133290 <OSMutexPost>
    }

    return bSuccess;
8110c3a4:	e0bffc17 	ldw	r2,-16(fp)
}
8110c3a8:	e037883a 	mov	sp,fp
8110c3ac:	dfc00117 	ldw	ra,4(sp)
8110c3b0:	df000017 	ldw	fp,0(sp)
8110c3b4:	dec00204 	addi	sp,sp,8
8110c3b8:	f800283a 	ret

8110c3bc <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
8110c3bc:	deffab04 	addi	sp,sp,-340
8110c3c0:	de00012e 	bgeu	sp,et,8110c3c8 <vReceiverUartTask+0xc>
8110c3c4:	003b68fa 	trap	3
8110c3c8:	dfc05415 	stw	ra,336(sp)
8110c3cc:	df005315 	stw	fp,332(sp)
8110c3d0:	df005304 	addi	fp,sp,332
8110c3d4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c3d8:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
8110c3dc:	d0a05517 	ldw	r2,-32428(gp)
8110c3e0:	100f883a 	mov	r7,r2
8110c3e4:	01800784 	movi	r6,30
8110c3e8:	01400044 	movi	r5,1
8110c3ec:	01204534 	movhi	r4,33044
8110c3f0:	210c7b04 	addi	r4,r4,12780
8110c3f4:	11172b80 	call	811172b8 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
8110c3f8:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
8110c3fc:	e0bfad17 	ldw	r2,-332(fp)
8110c400:	10c00060 	cmpeqi	r3,r2,1
8110c404:	1800091e 	bne	r3,zero,8110c42c <vReceiverUartTask+0x70>
8110c408:	0080052e 	bgeu	zero,r2,8110c420 <vReceiverUartTask+0x64>
8110c40c:	10c000a0 	cmpeqi	r3,r2,2
8110c410:	18005d1e 	bne	r3,zero,8110c588 <vReceiverUartTask+0x1cc>
8110c414:	108000e0 	cmpeqi	r2,r2,3
8110c418:	10006e1e 	bne	r2,zero,8110c5d4 <vReceiverUartTask+0x218>
8110c41c:	00007706 	br	8110c5fc <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
8110c420:	00800044 	movi	r2,1
8110c424:	e0bfad15 	stw	r2,-332(fp)
                break;
8110c428:	00007706 	br	8110c608 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
8110c42c:	e0bfaf04 	addi	r2,fp,-324
8110c430:	01802004 	movi	r6,128
8110c434:	000b883a 	mov	r5,zero
8110c438:	1009883a 	mov	r4,r2
8110c43c:	1117e1c0 	call	81117e1c <memset>
                scanf("%s", cReceive);
8110c440:	e0bfcf04 	addi	r2,fp,-196
8110c444:	100b883a 	mov	r5,r2
8110c448:	01204534 	movhi	r4,33044
8110c44c:	210c8304 	addi	r4,r4,12812
8110c450:	11184d00 	call	811184d0 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
8110c454:	e0ffcf04 	addi	r3,fp,-196
8110c458:	e0bfaf04 	addi	r2,fp,-324
8110c45c:	01801fc4 	movi	r6,127
8110c460:	180b883a 	mov	r5,r3
8110c464:	1009883a 	mov	r4,r2
8110c468:	1117ccc0 	call	81117ccc <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
8110c46c:	e0bfaf04 	addi	r2,fp,-324
8110c470:	01604574 	movhi	r5,33045
8110c474:	2961ce04 	addi	r5,r5,-30920
8110c478:	1009883a 	mov	r4,r2
8110c47c:	110ca600 	call	8110ca60 <bPreParserV2>
8110c480:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
8110c484:	e0bfae17 	ldw	r2,-328(fp)
8110c488:	10800058 	cmpnei	r2,r2,1
8110c48c:	1000281e 	bne	r2,zero,8110c530 <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
8110c490:	00a04574 	movhi	r2,33045
8110c494:	10a1ce04 	addi	r2,r2,-30920
8110c498:	10800103 	ldbu	r2,4(r2)
8110c49c:	10803fcc 	andi	r2,r2,255
8110c4a0:	1080201c 	xori	r2,r2,128
8110c4a4:	10bfe004 	addi	r2,r2,-128
8110c4a8:	10800fe0 	cmpeqi	r2,r2,63
8110c4ac:	1000081e 	bne	r2,zero,8110c4d0 <vReceiverUartTask+0x114>
8110c4b0:	00a04574 	movhi	r2,33045
8110c4b4:	10a1ce04 	addi	r2,r2,-30920
8110c4b8:	10800103 	ldbu	r2,4(r2)
8110c4bc:	10803fcc 	andi	r2,r2,255
8110c4c0:	1080201c 	xori	r2,r2,128
8110c4c4:	10bfe004 	addi	r2,r2,-128
8110c4c8:	10800858 	cmpnei	r2,r2,33
8110c4cc:	1000031e 	bne	r2,zero,8110c4dc <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
8110c4d0:	00800084 	movi	r2,2
8110c4d4:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110c4d8:	00004b06 	br	8110c608 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
8110c4dc:	00a04574 	movhi	r2,33045
8110c4e0:	10a1ce04 	addi	r2,r2,-30920
8110c4e4:	10800103 	ldbu	r2,4(r2)
8110c4e8:	10803fcc 	andi	r2,r2,255
8110c4ec:	1080201c 	xori	r2,r2,128
8110c4f0:	10bfe004 	addi	r2,r2,-128
8110c4f4:	108008d8 	cmpnei	r2,r2,35
8110c4f8:	10000a1e 	bne	r2,zero,8110c524 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
8110c4fc:	00800044 	movi	r2,1
8110c500:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
8110c504:	d0a05517 	ldw	r2,-32428(gp)
8110c508:	100f883a 	mov	r7,r2
8110c50c:	018006c4 	movi	r6,27
8110c510:	01400044 	movi	r5,1
8110c514:	01204534 	movhi	r4,33044
8110c518:	210c8404 	addi	r4,r4,12816
8110c51c:	11172b80 	call	811172b8 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110c520:	00003906 	br	8110c608 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
8110c524:	008000c4 	movi	r2,3
8110c528:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110c52c:	00003606 	br	8110c608 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
8110c530:	00a04574 	movhi	r2,33045
8110c534:	10a1ce04 	addi	r2,r2,-30920
8110c538:	00c008c4 	movi	r3,35
8110c53c:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
8110c540:	00a04574 	movhi	r2,33045
8110c544:	10a1ce04 	addi	r2,r2,-30920
8110c548:	00c00b84 	movi	r3,46
8110c54c:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
8110c550:	00a04574 	movhi	r2,33045
8110c554:	10a1ce04 	addi	r2,r2,-30920
8110c558:	00c00044 	movi	r3,1
8110c55c:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8110c560:	01204574 	movhi	r4,33045
8110c564:	2121ce04 	addi	r4,r4,-30920
8110c568:	110c7480 	call	8110c748 <setPreAckSenderFreePos>
8110c56c:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
8110c570:	e0bfae17 	ldw	r2,-328(fp)
8110c574:	1000011e 	bne	r2,zero,8110c57c <vReceiverUartTask+0x1c0>
                        vFailSendNack();
8110c578:	1112db80 	call	81112db8 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
8110c57c:	00800044 	movi	r2,1
8110c580:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
8110c584:	00002006 	br	8110c608 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8110c588:	01204574 	movhi	r4,33045
8110c58c:	2121ce04 	addi	r4,r4,-30920
8110c590:	110c7480 	call	8110c748 <setPreAckSenderFreePos>
8110c594:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
8110c598:	e0bfae17 	ldw	r2,-328(fp)
8110c59c:	10800058 	cmpnei	r2,r2,1
8110c5a0:	1000081e 	bne	r2,zero,8110c5c4 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
8110c5a4:	01204574 	movhi	r4,33045
8110c5a8:	2121ce04 	addi	r4,r4,-30920
8110c5ac:	110c60c0 	call	8110c60c <setPreParsedFreePos>
8110c5b0:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
8110c5b4:	e0bfae17 	ldw	r2,-328(fp)
8110c5b8:	1000031e 	bne	r2,zero,8110c5c8 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
8110c5bc:	1112e880 	call	81112e88 <vFailSetPreParsedBuffer>
8110c5c0:	00000106 	br	8110c5c8 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
8110c5c4:	1112e200 	call	81112e20 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
8110c5c8:	00800044 	movi	r2,1
8110c5cc:	e0bfad15 	stw	r2,-332(fp)
                break;
8110c5d0:	00000d06 	br	8110c608 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
8110c5d4:	01204574 	movhi	r4,33045
8110c5d8:	2121ce04 	addi	r4,r4,-30920
8110c5dc:	110c8c40 	call	8110c8c4 <setPreAckReceiverFreePos>
8110c5e0:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
8110c5e4:	e0bfae17 	ldw	r2,-328(fp)
8110c5e8:	1000011e 	bne	r2,zero,8110c5f0 <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
8110c5ec:	1112ef00 	call	81112ef0 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
8110c5f0:	00800044 	movi	r2,1
8110c5f4:	e0bfad15 	stw	r2,-332(fp)
                break;
8110c5f8:	00000306 	br	8110c608 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
8110c5fc:	00800044 	movi	r2,1
8110c600:	e0bfad15 	stw	r2,-332(fp)
                break;
8110c604:	0001883a 	nop
        }

    }
8110c608:	003f7c06 	br	8110c3fc <__reset+0xfb0ec3fc>

8110c60c <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
8110c60c:	defffb04 	addi	sp,sp,-20
8110c610:	de00012e 	bgeu	sp,et,8110c618 <setPreParsedFreePos+0xc>
8110c614:	003b68fa 	trap	3
8110c618:	dfc00415 	stw	ra,16(sp)
8110c61c:	df000315 	stw	fp,12(sp)
8110c620:	df000304 	addi	fp,sp,12
8110c624:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c628:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8110c62c:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8110c630:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8110c634:	d0a05d17 	ldw	r2,-32396(gp)
8110c638:	e0fffe44 	addi	r3,fp,-7
8110c63c:	180d883a 	mov	r6,r3
8110c640:	01400284 	movi	r5,10
8110c644:	1009883a 	mov	r4,r2
8110c648:	1132cec0 	call	81132cec <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110c64c:	e0bffe43 	ldbu	r2,-7(fp)
8110c650:	10803fcc 	andi	r2,r2,255
8110c654:	1000361e 	bne	r2,zero,8110c730 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
8110c658:	e03ffe05 	stb	zero,-8(fp)
8110c65c:	00002e06 	br	8110c718 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
8110c660:	e0fffe03 	ldbu	r3,-8(fp)
8110c664:	00a045b4 	movhi	r2,33046
8110c668:	10b16504 	addi	r2,r2,-14956
8110c66c:	18c01324 	muli	r3,r3,76
8110c670:	10c5883a 	add	r2,r2,r3
8110c674:	10800104 	addi	r2,r2,4
8110c678:	10800003 	ldbu	r2,0(r2)
8110c67c:	10803fcc 	andi	r2,r2,255
8110c680:	1080201c 	xori	r2,r2,128
8110c684:	10bfe004 	addi	r2,r2,-128
8110c688:	1000201e 	bne	r2,zero,8110c70c <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
8110c68c:	e0fffe03 	ldbu	r3,-8(fp)
8110c690:	00a045b4 	movhi	r2,33046
8110c694:	10b16504 	addi	r2,r2,-14956
8110c698:	18c01324 	muli	r3,r3,76
8110c69c:	10c7883a 	add	r3,r2,r3
8110c6a0:	e0bfff17 	ldw	r2,-4(fp)
8110c6a4:	1009883a 	mov	r4,r2
8110c6a8:	00801304 	movi	r2,76
8110c6ac:	100d883a 	mov	r6,r2
8110c6b0:	200b883a 	mov	r5,r4
8110c6b4:	1809883a 	mov	r4,r3
8110c6b8:	1117ccc0 	call	81117ccc <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
8110c6bc:	d0a05717 	ldw	r2,-32420(gp)
8110c6c0:	1009883a 	mov	r4,r2
8110c6c4:	11350800 	call	81135080 <OSSemPost>
8110c6c8:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
8110c6cc:	e0bffe43 	ldbu	r2,-7(fp)
8110c6d0:	10803fcc 	andi	r2,r2,255
8110c6d4:	1000031e 	bne	r2,zero,8110c6e4 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
8110c6d8:	00800044 	movi	r2,1
8110c6dc:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
8110c6e0:	00001006 	br	8110c724 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
8110c6e4:	11124d80 	call	811124d8 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
8110c6e8:	e0fffe03 	ldbu	r3,-8(fp)
8110c6ec:	00a045b4 	movhi	r2,33046
8110c6f0:	10b16504 	addi	r2,r2,-14956
8110c6f4:	18c01324 	muli	r3,r3,76
8110c6f8:	10c5883a 	add	r2,r2,r3
8110c6fc:	10800104 	addi	r2,r2,4
8110c700:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
8110c704:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
8110c708:	00000606 	br	8110c724 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
8110c70c:	e0bffe03 	ldbu	r2,-8(fp)
8110c710:	10800044 	addi	r2,r2,1
8110c714:	e0bffe05 	stb	r2,-8(fp)
8110c718:	e0bffe03 	ldbu	r2,-8(fp)
8110c71c:	10800230 	cmpltui	r2,r2,8
8110c720:	103fcf1e 	bne	r2,zero,8110c660 <__reset+0xfb0ec660>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
8110c724:	d0a05d17 	ldw	r2,-32396(gp)
8110c728:	1009883a 	mov	r4,r2
8110c72c:	11332900 	call	81133290 <OSMutexPost>
    }
    return bSuccess;
8110c730:	e0bffd17 	ldw	r2,-12(fp)
}
8110c734:	e037883a 	mov	sp,fp
8110c738:	dfc00117 	ldw	ra,4(sp)
8110c73c:	df000017 	ldw	fp,0(sp)
8110c740:	dec00204 	addi	sp,sp,8
8110c744:	f800283a 	ret

8110c748 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
8110c748:	defffb04 	addi	sp,sp,-20
8110c74c:	de00012e 	bgeu	sp,et,8110c754 <setPreAckSenderFreePos+0xc>
8110c750:	003b68fa 	trap	3
8110c754:	dfc00415 	stw	ra,16(sp)
8110c758:	df000315 	stw	fp,12(sp)
8110c75c:	df000304 	addi	fp,sp,12
8110c760:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c764:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8110c768:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8110c76c:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8110c770:	d0a06317 	ldw	r2,-32372(gp)
8110c774:	e0fffe44 	addi	r3,fp,-7
8110c778:	180d883a 	mov	r6,r3
8110c77c:	01400284 	movi	r5,10
8110c780:	1009883a 	mov	r4,r2
8110c784:	1132cec0 	call	81132cec <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110c788:	e0bffe43 	ldbu	r2,-7(fp)
8110c78c:	10803fcc 	andi	r2,r2,255
8110c790:	1000461e 	bne	r2,zero,8110c8ac <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
8110c794:	e03ffe05 	stb	zero,-8(fp)
8110c798:	00003e06 	br	8110c894 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
8110c79c:	e0fffe03 	ldbu	r3,-8(fp)
8110c7a0:	00a045b4 	movhi	r2,33046
8110c7a4:	10b15d04 	addi	r2,r2,-14988
8110c7a8:	18c7883a 	add	r3,r3,r3
8110c7ac:	18c7883a 	add	r3,r3,r3
8110c7b0:	10c5883a 	add	r2,r2,r3
8110c7b4:	10800003 	ldbu	r2,0(r2)
8110c7b8:	10803fcc 	andi	r2,r2,255
8110c7bc:	1080201c 	xori	r2,r2,128
8110c7c0:	10bfe004 	addi	r2,r2,-128
8110c7c4:	1000301e 	bne	r2,zero,8110c888 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
8110c7c8:	e0fffe03 	ldbu	r3,-8(fp)
8110c7cc:	e0bfff17 	ldw	r2,-4(fp)
8110c7d0:	11000103 	ldbu	r4,4(r2)
8110c7d4:	00a045b4 	movhi	r2,33046
8110c7d8:	10b15d04 	addi	r2,r2,-14988
8110c7dc:	18c7883a 	add	r3,r3,r3
8110c7e0:	18c7883a 	add	r3,r3,r3
8110c7e4:	10c5883a 	add	r2,r2,r3
8110c7e8:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
8110c7ec:	e0fffe03 	ldbu	r3,-8(fp)
8110c7f0:	e0bfff17 	ldw	r2,-4(fp)
8110c7f4:	11000143 	ldbu	r4,5(r2)
8110c7f8:	00a045b4 	movhi	r2,33046
8110c7fc:	10b15d04 	addi	r2,r2,-14988
8110c800:	18c7883a 	add	r3,r3,r3
8110c804:	18c7883a 	add	r3,r3,r3
8110c808:	10c5883a 	add	r2,r2,r3
8110c80c:	10800044 	addi	r2,r2,1
8110c810:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
8110c814:	e0fffe03 	ldbu	r3,-8(fp)
8110c818:	e0bfff17 	ldw	r2,-4(fp)
8110c81c:	1100020b 	ldhu	r4,8(r2)
8110c820:	00a045b4 	movhi	r2,33046
8110c824:	10b15d04 	addi	r2,r2,-14988
8110c828:	18c7883a 	add	r3,r3,r3
8110c82c:	18c7883a 	add	r3,r3,r3
8110c830:	10c5883a 	add	r2,r2,r3
8110c834:	10800084 	addi	r2,r2,2
8110c838:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
8110c83c:	d0a05417 	ldw	r2,-32432(gp)
8110c840:	1009883a 	mov	r4,r2
8110c844:	11350800 	call	81135080 <OSSemPost>
8110c848:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
8110c84c:	e0bffe43 	ldbu	r2,-7(fp)
8110c850:	10803fcc 	andi	r2,r2,255
8110c854:	10000926 	beq	r2,zero,8110c87c <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
8110c858:	11125700 	call	81112570 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
8110c85c:	e0fffe03 	ldbu	r3,-8(fp)
8110c860:	00a045b4 	movhi	r2,33046
8110c864:	10b15d04 	addi	r2,r2,-14988
8110c868:	18c7883a 	add	r3,r3,r3
8110c86c:	18c7883a 	add	r3,r3,r3
8110c870:	10c5883a 	add	r2,r2,r3
8110c874:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
8110c878:	00000906 	br	8110c8a0 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
8110c87c:	00800044 	movi	r2,1
8110c880:	e0bffd15 	stw	r2,-12(fp)
                break;
8110c884:	00000606 	br	8110c8a0 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
8110c888:	e0bffe03 	ldbu	r2,-8(fp)
8110c88c:	10800044 	addi	r2,r2,1
8110c890:	e0bffe05 	stb	r2,-8(fp)
8110c894:	e0bffe03 	ldbu	r2,-8(fp)
8110c898:	10800230 	cmpltui	r2,r2,8
8110c89c:	103fbf1e 	bne	r2,zero,8110c79c <__reset+0xfb0ec79c>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
8110c8a0:	d0a06317 	ldw	r2,-32372(gp)
8110c8a4:	1009883a 	mov	r4,r2
8110c8a8:	11332900 	call	81133290 <OSMutexPost>
    }

    return bSuccess;
8110c8ac:	e0bffd17 	ldw	r2,-12(fp)
}
8110c8b0:	e037883a 	mov	sp,fp
8110c8b4:	dfc00117 	ldw	ra,4(sp)
8110c8b8:	df000017 	ldw	fp,0(sp)
8110c8bc:	dec00204 	addi	sp,sp,8
8110c8c0:	f800283a 	ret

8110c8c4 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
8110c8c4:	defffb04 	addi	sp,sp,-20
8110c8c8:	de00012e 	bgeu	sp,et,8110c8d0 <setPreAckReceiverFreePos+0xc>
8110c8cc:	003b68fa 	trap	3
8110c8d0:	dfc00415 	stw	ra,16(sp)
8110c8d4:	df000315 	stw	fp,12(sp)
8110c8d8:	df000304 	addi	fp,sp,12
8110c8dc:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c8e0:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
8110c8e4:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
8110c8e8:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
8110c8ec:	d0a05817 	ldw	r2,-32416(gp)
8110c8f0:	e0fffe44 	addi	r3,fp,-7
8110c8f4:	180d883a 	mov	r6,r3
8110c8f8:	01400504 	movi	r5,20
8110c8fc:	1009883a 	mov	r4,r2
8110c900:	1132cec0 	call	81132cec <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110c904:	e0bffe43 	ldbu	r2,-7(fp)
8110c908:	10803fcc 	andi	r2,r2,255
8110c90c:	1000471e 	bne	r2,zero,8110ca2c <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8110c910:	e03ffe05 	stb	zero,-8(fp)
8110c914:	00003e06 	br	8110ca10 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
8110c918:	e0fffe03 	ldbu	r3,-8(fp)
8110c91c:	00a04574 	movhi	r2,33045
8110c920:	109b5304 	addi	r2,r2,27980
8110c924:	18c7883a 	add	r3,r3,r3
8110c928:	18c7883a 	add	r3,r3,r3
8110c92c:	10c5883a 	add	r2,r2,r3
8110c930:	10800003 	ldbu	r2,0(r2)
8110c934:	10803fcc 	andi	r2,r2,255
8110c938:	1080201c 	xori	r2,r2,128
8110c93c:	10bfe004 	addi	r2,r2,-128
8110c940:	1000301e 	bne	r2,zero,8110ca04 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
8110c944:	e0fffe03 	ldbu	r3,-8(fp)
8110c948:	e0bfff17 	ldw	r2,-4(fp)
8110c94c:	11000103 	ldbu	r4,4(r2)
8110c950:	00a04574 	movhi	r2,33045
8110c954:	109b5304 	addi	r2,r2,27980
8110c958:	18c7883a 	add	r3,r3,r3
8110c95c:	18c7883a 	add	r3,r3,r3
8110c960:	10c5883a 	add	r2,r2,r3
8110c964:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
8110c968:	e0fffe03 	ldbu	r3,-8(fp)
8110c96c:	e0bfff17 	ldw	r2,-4(fp)
8110c970:	11000143 	ldbu	r4,5(r2)
8110c974:	00a04574 	movhi	r2,33045
8110c978:	109b5304 	addi	r2,r2,27980
8110c97c:	18c7883a 	add	r3,r3,r3
8110c980:	18c7883a 	add	r3,r3,r3
8110c984:	10c5883a 	add	r2,r2,r3
8110c988:	10800044 	addi	r2,r2,1
8110c98c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
8110c990:	e0fffe03 	ldbu	r3,-8(fp)
8110c994:	e0bfff17 	ldw	r2,-4(fp)
8110c998:	1100020b 	ldhu	r4,8(r2)
8110c99c:	00a04574 	movhi	r2,33045
8110c9a0:	109b5304 	addi	r2,r2,27980
8110c9a4:	18c7883a 	add	r3,r3,r3
8110c9a8:	18c7883a 	add	r3,r3,r3
8110c9ac:	10c5883a 	add	r2,r2,r3
8110c9b0:	10800084 	addi	r2,r2,2
8110c9b4:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
8110c9b8:	d0a05917 	ldw	r2,-32412(gp)
8110c9bc:	1009883a 	mov	r4,r2
8110c9c0:	11350800 	call	81135080 <OSSemPost>
8110c9c4:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
8110c9c8:	e0bffe43 	ldbu	r2,-7(fp)
8110c9cc:	10803fcc 	andi	r2,r2,255
8110c9d0:	1000031e 	bne	r2,zero,8110c9e0 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
8110c9d4:	00800044 	movi	r2,1
8110c9d8:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
8110c9dc:	00000f06 	br	8110ca1c <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
8110c9e0:	11125240 	call	81112524 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
8110c9e4:	e0fffe03 	ldbu	r3,-8(fp)
8110c9e8:	00a04574 	movhi	r2,33045
8110c9ec:	109b5304 	addi	r2,r2,27980
8110c9f0:	18c7883a 	add	r3,r3,r3
8110c9f4:	18c7883a 	add	r3,r3,r3
8110c9f8:	10c5883a 	add	r2,r2,r3
8110c9fc:	10000005 	stb	zero,0(r2)
                }
                break;
8110ca00:	00000606 	br	8110ca1c <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8110ca04:	e0bffe03 	ldbu	r2,-8(fp)
8110ca08:	10800044 	addi	r2,r2,1
8110ca0c:	e0bffe05 	stb	r2,-8(fp)
8110ca10:	e0bffe03 	ldbu	r2,-8(fp)
8110ca14:	108001b0 	cmpltui	r2,r2,6
8110ca18:	103fbf1e 	bne	r2,zero,8110c918 <__reset+0xfb0ec918>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
8110ca1c:	d0a05817 	ldw	r2,-32416(gp)
8110ca20:	1009883a 	mov	r4,r2
8110ca24:	11332900 	call	81133290 <OSMutexPost>
8110ca28:	00000706 	br	8110ca48 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
8110ca2c:	d0a05517 	ldw	r2,-32428(gp)
8110ca30:	100f883a 	mov	r7,r2
8110ca34:	01801404 	movi	r6,80
8110ca38:	01400044 	movi	r5,1
8110ca3c:	01204534 	movhi	r4,33044
8110ca40:	210c8b04 	addi	r4,r4,12844
8110ca44:	11172b80 	call	811172b8 <fwrite>
        #endif
    }

    return bSuccess;
8110ca48:	e0bffd17 	ldw	r2,-12(fp)
}
8110ca4c:	e037883a 	mov	sp,fp
8110ca50:	dfc00117 	ldw	ra,4(sp)
8110ca54:	df000017 	ldw	fp,0(sp)
8110ca58:	dec00204 	addi	sp,sp,8
8110ca5c:	f800283a 	ret

8110ca60 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
8110ca60:	defff404 	addi	sp,sp,-48
8110ca64:	de00012e 	bgeu	sp,et,8110ca6c <bPreParserV2+0xc>
8110ca68:	003b68fa 	trap	3
8110ca6c:	dfc00b15 	stw	ra,44(sp)
8110ca70:	df000a15 	stw	fp,40(sp)
8110ca74:	dc000915 	stw	r16,36(sp)
8110ca78:	df000a04 	addi	fp,sp,40
8110ca7c:	e13ffd15 	stw	r4,-12(fp)
8110ca80:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
8110ca84:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
8110ca88:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
8110ca8c:	01402004 	movi	r5,128
8110ca90:	e13ffd17 	ldw	r4,-12(fp)
8110ca94:	11188580 	call	81118858 <strnlen>
8110ca98:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
8110ca9c:	01400ec4 	movi	r5,59
8110caa0:	e13ffd17 	ldw	r4,-12(fp)
8110caa4:	1110fb00 	call	81110fb0 <siPosStr>
8110caa8:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
8110caac:	e0fff98f 	ldh	r3,-26(fp)
8110cab0:	e0bff90f 	ldh	r2,-28(fp)
8110cab4:	10bfffc4 	addi	r2,r2,-1
8110cab8:	18800226 	beq	r3,r2,8110cac4 <bPreParserV2+0x64>
        return bSuccess;
8110cabc:	e0bff617 	ldw	r2,-40(fp)
8110cac0:	0000ba06 	br	8110cdac <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
8110cac4:	01401f04 	movi	r5,124
8110cac8:	e13ffd17 	ldw	r4,-12(fp)
8110cacc:	1110fb00 	call	81110fb0 <siPosStr>
8110cad0:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
8110cad4:	e0bffa0f 	ldh	r2,-24(fp)
8110cad8:	e0fff98f 	ldh	r3,-26(fp)
8110cadc:	1880020e 	bge	r3,r2,8110cae8 <bPreParserV2+0x88>
        return bSuccess;
8110cae0:	e0bff617 	ldw	r2,-40(fp)
8110cae4:	0000b106 	br	8110cdac <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
8110cae8:	01604534 	movhi	r5,33044
8110caec:	294ca004 	addi	r5,r5,12928
8110caf0:	e13ffd17 	ldw	r4,-12(fp)
8110caf4:	11187740 	call	81118774 <strcspn>
8110caf8:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
8110cafc:	e0bffa8f 	ldh	r2,-22(fp)
8110cb00:	e0fffa0f 	ldh	r3,-24(fp)
8110cb04:	1880020e 	bge	r3,r2,8110cb10 <bPreParserV2+0xb0>
        return bSuccess;
8110cb08:	e0bff617 	ldw	r2,-40(fp)
8110cb0c:	0000a706 	br	8110cdac <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
8110cb10:	e0bffa8f 	ldh	r2,-22(fp)
8110cb14:	e0fffd17 	ldw	r3,-12(fp)
8110cb18:	1885883a 	add	r2,r3,r2
8110cb1c:	10c00003 	ldbu	r3,0(r2)
8110cb20:	e0bffe17 	ldw	r2,-8(fp)
8110cb24:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
8110cb28:	e0bffe17 	ldw	r2,-8(fp)
8110cb2c:	10800103 	ldbu	r2,4(r2)
8110cb30:	10803fcc 	andi	r2,r2,255
8110cb34:	1080201c 	xori	r2,r2,128
8110cb38:	10bfe004 	addi	r2,r2,-128
8110cb3c:	108008d8 	cmpnei	r2,r2,35
8110cb40:	1000041e 	bne	r2,zero,8110cb54 <bPreParserV2+0xf4>
        bSuccess = TRUE;
8110cb44:	00800044 	movi	r2,1
8110cb48:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
8110cb4c:	e0bff617 	ldw	r2,-40(fp)
8110cb50:	00009606 	br	8110cdac <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
8110cb54:	e0bffa8f 	ldh	r2,-22(fp)
8110cb58:	e0fffd17 	ldw	r3,-12(fp)
8110cb5c:	1889883a 	add	r4,r3,r2
8110cb60:	e0fffa0f 	ldh	r3,-24(fp)
8110cb64:	e0bffa8f 	ldh	r2,-22(fp)
8110cb68:	1885c83a 	sub	r2,r3,r2
8110cb6c:	100b883a 	mov	r5,r2
8110cb70:	11121d00 	call	811121d0 <ucCrc8wInit>
8110cb74:	1007883a 	mov	r3,r2
8110cb78:	e0bffe17 	ldw	r2,-8(fp)
8110cb7c:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
8110cb80:	e0bffa8f 	ldh	r2,-22(fp)
8110cb84:	10800044 	addi	r2,r2,1
8110cb88:	e0fffd17 	ldw	r3,-12(fp)
8110cb8c:	1885883a 	add	r2,r3,r2
8110cb90:	10c00003 	ldbu	r3,0(r2)
8110cb94:	e0bffe17 	ldw	r2,-8(fp)
8110cb98:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
8110cb9c:	e0bffe17 	ldw	r2,-8(fp)
8110cba0:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
8110cba4:	e0bffe17 	ldw	r2,-8(fp)
8110cba8:	10800204 	addi	r2,r2,8
8110cbac:	01801004 	movi	r6,64
8110cbb0:	000b883a 	mov	r5,zero
8110cbb4:	1009883a 	mov	r4,r2
8110cbb8:	1117e1c0 	call	81117e1c <memset>

    i = siIni + 3; /* "?C:i..." */
8110cbbc:	e0bffa8b 	ldhu	r2,-22(fp)
8110cbc0:	108000c4 	addi	r2,r2,3
8110cbc4:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
8110cbc8:	e0bffb44 	addi	r2,fp,-19
8110cbcc:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
8110cbd0:	e0bffb44 	addi	r2,fp,-19
8110cbd4:	01800184 	movi	r6,6
8110cbd8:	000b883a 	mov	r5,zero
8110cbdc:	1009883a 	mov	r4,r2
8110cbe0:	1117e1c0 	call	81117e1c <memset>
        do {
            c = buffer[i];
8110cbe4:	e0bff703 	ldbu	r2,-36(fp)
8110cbe8:	e0fffd17 	ldw	r3,-12(fp)
8110cbec:	1885883a 	add	r2,r3,r2
8110cbf0:	10800003 	ldbu	r2,0(r2)
8110cbf4:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
8110cbf8:	d0e00317 	ldw	r3,-32756(gp)
8110cbfc:	e0bffb07 	ldb	r2,-20(fp)
8110cc00:	10800044 	addi	r2,r2,1
8110cc04:	1885883a 	add	r2,r3,r2
8110cc08:	10800003 	ldbu	r2,0(r2)
8110cc0c:	10803fcc 	andi	r2,r2,255
8110cc10:	1080010c 	andi	r2,r2,4
8110cc14:	10000626 	beq	r2,zero,8110cc30 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
8110cc18:	e0bff817 	ldw	r2,-32(fp)
8110cc1c:	e0fffb03 	ldbu	r3,-20(fp)
8110cc20:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
8110cc24:	e0bff817 	ldw	r2,-32(fp)
8110cc28:	10800044 	addi	r2,r2,1
8110cc2c:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
8110cc30:	e0bff703 	ldbu	r2,-36(fp)
8110cc34:	10800044 	addi	r2,r2,1
8110cc38:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
8110cc3c:	e0bff90f 	ldh	r2,-28(fp)
8110cc40:	e0fff703 	ldbu	r3,-36(fp)
8110cc44:	1880090e 	bge	r3,r2,8110cc6c <bPreParserV2+0x20c>
8110cc48:	e0bffb07 	ldb	r2,-20(fp)
8110cc4c:	10800ea0 	cmpeqi	r2,r2,58
8110cc50:	1000061e 	bne	r2,zero,8110cc6c <bPreParserV2+0x20c>
8110cc54:	e0bffb07 	ldb	r2,-20(fp)
8110cc58:	10800ee0 	cmpeqi	r2,r2,59
8110cc5c:	1000031e 	bne	r2,zero,8110cc6c <bPreParserV2+0x20c>
8110cc60:	e0bffb07 	ldb	r2,-20(fp)
8110cc64:	10801f18 	cmpnei	r2,r2,124
8110cc68:	103fde1e 	bne	r2,zero,8110cbe4 <__reset+0xfb0ecbe4>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8110cc6c:	e0bff817 	ldw	r2,-32(fp)
8110cc70:	00c00284 	movi	r3,10
8110cc74:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
8110cc78:	e0bffb07 	ldb	r2,-20(fp)
8110cc7c:	10800ea0 	cmpeqi	r2,r2,58
8110cc80:	1000031e 	bne	r2,zero,8110cc90 <bPreParserV2+0x230>
8110cc84:	e0bffb07 	ldb	r2,-20(fp)
8110cc88:	10801f18 	cmpnei	r2,r2,124
8110cc8c:	10001a1e 	bne	r2,zero,8110ccf8 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
8110cc90:	e0bffe17 	ldw	r2,-8(fp)
8110cc94:	10800183 	ldbu	r2,6(r2)
8110cc98:	10803fcc 	andi	r2,r2,255
8110cc9c:	10800828 	cmpgeui	r2,r2,32
8110cca0:	1000041e 	bne	r2,zero,8110ccb4 <bPreParserV2+0x254>
8110cca4:	e0bffe17 	ldw	r2,-8(fp)
8110cca8:	10800183 	ldbu	r2,6(r2)
8110ccac:	14003fcc 	andi	r16,r2,255
8110ccb0:	00000106 	br	8110ccb8 <bPreParserV2+0x258>
8110ccb4:	04000804 	movi	r16,32
8110ccb8:	e0bffb44 	addi	r2,fp,-19
8110ccbc:	1009883a 	mov	r4,r2
8110ccc0:	1116ac00 	call	81116ac0 <atoi>
8110ccc4:	1009883a 	mov	r4,r2
8110ccc8:	e0fffe17 	ldw	r3,-8(fp)
8110cccc:	80800104 	addi	r2,r16,4
8110ccd0:	1085883a 	add	r2,r2,r2
8110ccd4:	1885883a 	add	r2,r3,r2
8110ccd8:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
8110ccdc:	e0bffe17 	ldw	r2,-8(fp)
8110cce0:	10800183 	ldbu	r2,6(r2)
8110cce4:	10800044 	addi	r2,r2,1
8110cce8:	1007883a 	mov	r3,r2
8110ccec:	e0bffe17 	ldw	r2,-8(fp)
8110ccf0:	10c00185 	stb	r3,6(r2)
8110ccf4:	00000906 	br	8110cd1c <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
8110ccf8:	e0bffb07 	ldb	r2,-20(fp)
8110ccfc:	10800ed8 	cmpnei	r2,r2,59
8110cd00:	1000061e 	bne	r2,zero,8110cd1c <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
8110cd04:	e0bffb44 	addi	r2,fp,-19
8110cd08:	1009883a 	mov	r4,r2
8110cd0c:	1116ac00 	call	81116ac0 <atoi>
8110cd10:	1007883a 	mov	r3,r2
8110cd14:	e0bffe17 	ldw	r2,-8(fp)
8110cd18:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8110cd1c:	e0bffb07 	ldb	r2,-20(fp)
8110cd20:	10800ee0 	cmpeqi	r2,r2,59
8110cd24:	1000031e 	bne	r2,zero,8110cd34 <bPreParserV2+0x2d4>
8110cd28:	e0bff90f 	ldh	r2,-28(fp)
8110cd2c:	e0fff703 	ldbu	r3,-36(fp)
8110cd30:	18bfa516 	blt	r3,r2,8110cbc8 <__reset+0xfb0ecbc8>


    if ( c == FINAL_CHAR )
8110cd34:	e0bffb07 	ldb	r2,-20(fp)
8110cd38:	10800ed8 	cmpnei	r2,r2,59
8110cd3c:	1000191e 	bne	r2,zero,8110cda4 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
8110cd40:	e0bffe17 	ldw	r2,-8(fp)
8110cd44:	10c01243 	ldbu	r3,73(r2)
8110cd48:	e0bffe17 	ldw	r2,-8(fp)
8110cd4c:	10801203 	ldbu	r2,72(r2)
8110cd50:	18c03fcc 	andi	r3,r3,255
8110cd54:	10803fcc 	andi	r2,r2,255
8110cd58:	1880031e 	bne	r3,r2,8110cd68 <bPreParserV2+0x308>
            bSuccess = TRUE;
8110cd5c:	00800044 	movi	r2,1
8110cd60:	e0bff615 	stw	r2,-40(fp)
8110cd64:	00001006 	br	8110cda8 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
8110cd68:	d0e05517 	ldw	r3,-32428(gp)
8110cd6c:	e0bffe17 	ldw	r2,-8(fp)
8110cd70:	10801203 	ldbu	r2,72(r2)
8110cd74:	11003fcc 	andi	r4,r2,255
8110cd78:	e0bffe17 	ldw	r2,-8(fp)
8110cd7c:	10801243 	ldbu	r2,73(r2)
8110cd80:	10803fcc 	andi	r2,r2,255
8110cd84:	100f883a 	mov	r7,r2
8110cd88:	200d883a 	mov	r6,r4
8110cd8c:	01604534 	movhi	r5,33044
8110cd90:	294ca204 	addi	r5,r5,12936
8110cd94:	1809883a 	mov	r4,r3
8110cd98:	1116c1c0 	call	81116c1c <fprintf>
            #endif
            bSuccess = FALSE;
8110cd9c:	e03ff615 	stw	zero,-40(fp)
8110cda0:	00000106 	br	8110cda8 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
8110cda4:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
8110cda8:	e0bff617 	ldw	r2,-40(fp)
}
8110cdac:	e6ffff04 	addi	sp,fp,-4
8110cdb0:	dfc00217 	ldw	ra,8(sp)
8110cdb4:	df000117 	ldw	fp,4(sp)
8110cdb8:	dc000017 	ldw	r16,0(sp)
8110cdbc:	dec00304 	addi	sp,sp,12
8110cdc0:	f800283a 	ret

8110cdc4 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
8110cdc4:	defffb04 	addi	sp,sp,-20
8110cdc8:	de00012e 	bgeu	sp,et,8110cdd0 <vSenderComTask+0xc>
8110cdcc:	003b68fa 	trap	3
8110cdd0:	dfc00415 	stw	ra,16(sp)
8110cdd4:	df000315 	stw	fp,12(sp)
8110cdd8:	df000304 	addi	fp,sp,12
8110cddc:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
8110cde0:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
8110cde4:	d0a05517 	ldw	r2,-32428(gp)
8110cde8:	100f883a 	mov	r7,r2
8110cdec:	01800704 	movi	r6,28
8110cdf0:	01400044 	movi	r5,1
8110cdf4:	01204534 	movhi	r4,33044
8110cdf8:	210cae04 	addi	r4,r4,12984
8110cdfc:	11172b80 	call	811172b8 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
8110ce00:	e0bffd17 	ldw	r2,-12(fp)
8110ce04:	10c00060 	cmpeqi	r3,r2,1
8110ce08:	1800091e 	bne	r3,zero,8110ce30 <vSenderComTask+0x6c>
8110ce0c:	0080052e 	bgeu	zero,r2,8110ce24 <vSenderComTask+0x60>
8110ce10:	10c000a0 	cmpeqi	r3,r2,2
8110ce14:	1800471e 	bne	r3,zero,8110cf34 <vSenderComTask+0x170>
8110ce18:	10800160 	cmpeqi	r2,r2,5
8110ce1c:	10002c1e 	bne	r2,zero,8110ced0 <vSenderComTask+0x10c>
8110ce20:	00003a06 	br	8110cf0c <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
8110ce24:	00800044 	movi	r2,1
8110ce28:	e0bffd15 	stw	r2,-12(fp)
                break;
8110ce2c:	00004206 	br	8110cf38 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
8110ce30:	d0a05517 	ldw	r2,-32428(gp)
8110ce34:	100f883a 	mov	r7,r2
8110ce38:	01800784 	movi	r6,30
8110ce3c:	01400044 	movi	r5,1
8110ce40:	01204534 	movhi	r4,33044
8110ce44:	210cb604 	addi	r4,r4,13016
8110ce48:	11172b80 	call	811172b8 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
8110ce4c:	01400044 	movi	r5,1
8110ce50:	01204534 	movhi	r4,33044
8110ce54:	210cbe04 	addi	r4,r4,13048
8110ce58:	11106a80 	call	811106a8 <bSendUART32v2>
8110ce5c:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
8110ce60:	e0bffe17 	ldw	r2,-8(fp)
8110ce64:	10800058 	cmpnei	r2,r2,1
8110ce68:	10000a1e 	bne	r2,zero,8110ce94 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
8110ce6c:	00800144 	movi	r2,5
8110ce70:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
8110ce74:	d0a05517 	ldw	r2,-32428(gp)
8110ce78:	100f883a 	mov	r7,r2
8110ce7c:	01800d44 	movi	r6,53
8110ce80:	01400044 	movi	r5,1
8110ce84:	01204534 	movhi	r4,33044
8110ce88:	210cc104 	addi	r4,r4,13060
8110ce8c:	11172b80 	call	811172b8 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
8110ce90:	00002906 	br	8110cf38 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
8110ce94:	d0a05517 	ldw	r2,-32428(gp)
8110ce98:	100f883a 	mov	r7,r2
8110ce9c:	01800784 	movi	r6,30
8110cea0:	01400044 	movi	r5,1
8110cea4:	01204534 	movhi	r4,33044
8110cea8:	210ccf04 	addi	r4,r4,13116
8110ceac:	11172b80 	call	811172b8 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
8110ceb0:	00800044 	movi	r2,1
8110ceb4:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
8110ceb8:	000f883a 	mov	r7,zero
8110cebc:	01800144 	movi	r6,5
8110cec0:	000b883a 	mov	r5,zero
8110cec4:	0009883a 	mov	r4,zero
8110cec8:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
                }
                break;
8110cecc:	00001a06 	br	8110cf38 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
8110ced0:	00800144 	movi	r2,5
8110ced4:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"sDummySender\n");
8110ced8:	d0a05517 	ldw	r2,-32428(gp)
8110cedc:	100f883a 	mov	r7,r2
8110cee0:	01800344 	movi	r6,13
8110cee4:	01400044 	movi	r5,1
8110cee8:	01204534 	movhi	r4,33044
8110ceec:	210cd704 	addi	r4,r4,13148
8110cef0:	11172b80 	call	811172b8 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 10, 0); /*Sleeps for 3 second*/
8110cef4:	000f883a 	mov	r7,zero
8110cef8:	01800284 	movi	r6,10
8110cefc:	000b883a 	mov	r5,zero
8110cf00:	0009883a 	mov	r4,zero
8110cf04:	1136adc0 	call	81136adc <OSTimeDlyHMSM>

                break;
8110cf08:	00000b06 	br	8110cf38 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
8110cf0c:	d0a05517 	ldw	r2,-32428(gp)
8110cf10:	100f883a 	mov	r7,r2
8110cf14:	018003c4 	movi	r6,15
8110cf18:	01400044 	movi	r5,1
8110cf1c:	01204534 	movhi	r4,33044
8110cf20:	210cdb04 	addi	r4,r4,13164
8110cf24:	11172b80 	call	811172b8 <fwrite>
                #endif
                eSenderMode = sDummySender;
8110cf28:	00800144 	movi	r2,5
8110cf2c:	e0bffd15 	stw	r2,-12(fp)
                break;
8110cf30:	00000106 	br	8110cf38 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
8110cf34:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
8110cf38:	003fb106 	br	8110ce00 <__reset+0xfb0ece00>

8110cf3c <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
8110cf3c:	defffa04 	addi	sp,sp,-24
8110cf40:	de00012e 	bgeu	sp,et,8110cf48 <vSimMebTask+0xc>
8110cf44:	003b68fa 	trap	3
8110cf48:	dfc00515 	stw	ra,20(sp)
8110cf4c:	df000415 	stw	fp,16(sp)
8110cf50:	df000404 	addi	fp,sp,16
8110cf54:	e13fff15 	stw	r4,-4(fp)
	TSimucam_MEB *pxMebC;
	tQMask uiCmdMeb;
	INT8U error_code;

	pxMebC = (TSimucam_MEB *) task_data;
8110cf58:	e0bfff17 	ldw	r2,-4(fp)
8110cf5c:	e0bffc15 	stw	r2,-16(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
8110cf60:	d0a05517 	ldw	r2,-32428(gp)
8110cf64:	100f883a 	mov	r7,r2
8110cf68:	018008c4 	movi	r6,35
8110cf6c:	01400044 	movi	r5,1
8110cf70:	01204534 	movhi	r4,33044
8110cf74:	210cdf04 	addi	r4,r4,13180
8110cf78:	11172b80 	call	811172b8 <fwrite>
    #endif

	for (;;) {
		switch ( pxMebC->eMode )
8110cf7c:	e0bffc17 	ldw	r2,-16(fp)
8110cf80:	10800117 	ldw	r2,4(r2)
8110cf84:	10000326 	beq	r2,zero,8110cf94 <vSimMebTask+0x58>
8110cf88:	10800060 	cmpeqi	r2,r2,1
8110cf8c:	1000231e 	bne	r2,zero,8110d01c <vSimMebTask+0xe0>
8110cf90:	00004406 	br	8110d0a4 <vSimMebTask+0x168>
		{
			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
8110cf94:	d0a05c17 	ldw	r2,-32400(gp)
8110cf98:	e0fffe04 	addi	r3,fp,-8
8110cf9c:	180d883a 	mov	r6,r3
8110cfa0:	000b883a 	mov	r5,zero
8110cfa4:	1009883a 	mov	r4,r2
8110cfa8:	1133e000 	call	81133e00 <OSQPend>
8110cfac:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8110cfb0:	e0bffe03 	ldbu	r2,-8(fp)
8110cfb4:	10803fcc 	andi	r2,r2,255
8110cfb8:	1000151e 	bne	r2,zero,8110d010 <vSimMebTask+0xd4>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
8110cfbc:	e0bffdc3 	ldbu	r2,-9(fp)
8110cfc0:	10803fcc 	andi	r2,r2,255
8110cfc4:	10800058 	cmpnei	r2,r2,1
8110cfc8:	1000081e 	bne	r2,zero,8110cfec <vSimMebTask+0xb0>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
8110cfcc:	e0bffd83 	ldbu	r2,-10(fp)
8110cfd0:	10803fcc 	andi	r2,r2,255
8110cfd4:	10800060 	cmpeqi	r2,r2,1
8110cfd8:	1000011e 	bne	r2,zero,8110cfe0 <vSimMebTask+0xa4>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskConfigMode( pxMebC );
								break;
							default:
								break;
8110cfdc:	00000e06 	br	8110d018 <vSimMebTask+0xdc>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskConfigMode( pxMebC );
8110cfe0:	e13ffc17 	ldw	r4,-16(fp)
8110cfe4:	110d0d00 	call	8110d0d0 <vPusMebInTaskConfigMode>
								break;
8110cfe8:	00000b06 	br	8110d018 <vSimMebTask+0xdc>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored. Not Addressed to Meb. ADDR= %ui\n", uiCmdMeb.ucByte[3]);
8110cfec:	d0a05517 	ldw	r2,-32428(gp)
8110cff0:	e0fffdc3 	ldbu	r3,-9(fp)
8110cff4:	18c03fcc 	andi	r3,r3,255
8110cff8:	180d883a 	mov	r6,r3
8110cffc:	01604534 	movhi	r5,33044
8110d000:	294ce804 	addi	r5,r5,13216
8110d004:	1009883a 	mov	r4,r2
8110d008:	1116c1c0 	call	81116c1c <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
8110d00c:	00002f06 	br	8110d0cc <vSimMebTask+0x190>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
8110d010:	1113b4c0 	call	81113b4c <vCouldNotGetCmdQueueMeb>
				}

				break;
8110d014:	00002d06 	br	8110d0cc <vSimMebTask+0x190>
8110d018:	00002c06 	br	8110d0cc <vSimMebTask+0x190>
			case sRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
8110d01c:	d0a05c17 	ldw	r2,-32400(gp)
8110d020:	e0fffe04 	addi	r3,fp,-8
8110d024:	180d883a 	mov	r6,r3
8110d028:	000b883a 	mov	r5,zero
8110d02c:	1009883a 	mov	r4,r2
8110d030:	1133e000 	call	81133e00 <OSQPend>
8110d034:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d038:	e0bffe03 	ldbu	r2,-8(fp)
8110d03c:	10803fcc 	andi	r2,r2,255
8110d040:	1000151e 	bne	r2,zero,8110d098 <vSimMebTask+0x15c>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
8110d044:	e0bffdc3 	ldbu	r2,-9(fp)
8110d048:	10803fcc 	andi	r2,r2,255
8110d04c:	10800058 	cmpnei	r2,r2,1
8110d050:	1000081e 	bne	r2,zero,8110d074 <vSimMebTask+0x138>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
8110d054:	e0bffd83 	ldbu	r2,-10(fp)
8110d058:	10803fcc 	andi	r2,r2,255
8110d05c:	10800060 	cmpeqi	r2,r2,1
8110d060:	1000011e 	bne	r2,zero,8110d068 <vSimMebTask+0x12c>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskRunningMode( pxMebC );
								break;
							default:
								break;
8110d064:	00000e06 	br	8110d0a0 <vSimMebTask+0x164>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskRunningMode( pxMebC );
8110d068:	e13ffc17 	ldw	r4,-16(fp)
8110d06c:	110d62c0 	call	8110d62c <vPusMebInTaskRunningMode>
								break;
8110d070:	00000b06 	br	8110d0a0 <vSimMebTask+0x164>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored. Not Addressed to Meb. ADDR= %ui\n", uiCmdMeb.ucByte[3]);
8110d074:	d0a05517 	ldw	r2,-32428(gp)
8110d078:	e0fffdc3 	ldbu	r3,-9(fp)
8110d07c:	18c03fcc 	andi	r3,r3,255
8110d080:	180d883a 	mov	r6,r3
8110d084:	01604534 	movhi	r5,33044
8110d088:	294ce804 	addi	r5,r5,13216
8110d08c:	1009883a 	mov	r4,r2
8110d090:	1116c1c0 	call	81116c1c <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			

				break;
8110d094:	00000d06 	br	8110d0cc <vSimMebTask+0x190>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
8110d098:	1113b4c0 	call	81113b4c <vCouldNotGetCmdQueueMeb>
				}			

				break;
8110d09c:	00000b06 	br	8110d0cc <vSimMebTask+0x190>
8110d0a0:	00000a06 	br	8110d0cc <vSimMebTask+0x190>
			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode.\n");
8110d0a4:	d0a05517 	ldw	r2,-32428(gp)
8110d0a8:	100f883a 	mov	r7,r2
8110d0ac:	01800c04 	movi	r6,48
8110d0b0:	01400044 	movi	r5,1
8110d0b4:	01204534 	movhi	r4,33044
8110d0b8:	210cf704 	addi	r4,r4,13276
8110d0bc:	11172b80 	call	811172b8 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebConfig;
8110d0c0:	e0bffc17 	ldw	r2,-16(fp)
8110d0c4:	10000115 	stw	zero,4(r2)
				break;
8110d0c8:	0001883a 	nop
		}
	}
8110d0cc:	003fab06 	br	8110cf7c <__reset+0xfb0ecf7c>

8110d0d0 <vPusMebInTaskConfigMode>:
}

/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal ) {
8110d0d0:	defff904 	addi	sp,sp,-28
8110d0d4:	de00012e 	bgeu	sp,et,8110d0dc <vPusMebInTaskConfigMode+0xc>
8110d0d8:	003b68fa 	trap	3
8110d0dc:	dfc00615 	stw	ra,24(sp)
8110d0e0:	df000515 	stw	fp,20(sp)
8110d0e4:	df000504 	addi	fp,sp,20
8110d0e8:	e13fff15 	stw	r4,-4(fp)
	unsigned char i;
	unsigned short int usiFeeInstL;
	static tTMPus xPusLocal;
	bool bSuccess = FALSE;
8110d0ec:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;

	bSuccess = FALSE;
8110d0f0:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 1, &error_code);
8110d0f4:	d0a06417 	ldw	r2,-32368(gp)
8110d0f8:	e0fffe84 	addi	r3,fp,-6
8110d0fc:	180d883a 	mov	r6,r3
8110d100:	01400044 	movi	r5,1
8110d104:	1009883a 	mov	r4,r2
8110d108:	1132cec0 	call	81132cec <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
8110d10c:	e0bffe83 	ldbu	r2,-6(fp)
8110d110:	10803fcc 	andi	r2,r2,255
8110d114:	10002c1e 	bne	r2,zero,8110d1c8 <vPusMebInTaskConfigMode+0xf8>

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
8110d118:	e03ffc05 	stb	zero,-16(fp)
8110d11c:	00002306 	br	8110d1ac <vPusMebInTaskConfigMode+0xdc>
	    {
            if ( xPus[i].bInUse == TRUE ) {
8110d120:	e0fffc03 	ldbu	r3,-16(fp)
8110d124:	00a04574 	movhi	r2,33045
8110d128:	10abed04 	addi	r2,r2,-20556
8110d12c:	18c01524 	muli	r3,r3,84
8110d130:	10c5883a 	add	r2,r2,r3
8110d134:	10800104 	addi	r2,r2,4
8110d138:	10800017 	ldw	r2,0(r2)
8110d13c:	10800058 	cmpnei	r2,r2,1
8110d140:	1000171e 	bne	r2,zero,8110d1a0 <vPusMebInTaskConfigMode+0xd0>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[i];
8110d144:	e13ffc03 	ldbu	r4,-16(fp)
8110d148:	00e04574 	movhi	r3,33045
8110d14c:	18e1e104 	addi	r3,r3,-30844
8110d150:	00a04574 	movhi	r2,33045
8110d154:	10abed04 	addi	r2,r2,-20556
8110d158:	21001524 	muli	r4,r4,84
8110d15c:	1105883a 	add	r2,r2,r4
8110d160:	1009883a 	mov	r4,r2
8110d164:	00801504 	movi	r2,84
8110d168:	100d883a 	mov	r6,r2
8110d16c:	200b883a 	mov	r5,r4
8110d170:	1809883a 	mov	r4,r3
8110d174:	1117ccc0 	call	81117ccc <memcpy>
            	xPus[i].bInUse = FALSE;
8110d178:	e0fffc03 	ldbu	r3,-16(fp)
8110d17c:	00a04574 	movhi	r2,33045
8110d180:	10abed04 	addi	r2,r2,-20556
8110d184:	18c01524 	muli	r3,r3,84
8110d188:	10c5883a 	add	r2,r2,r3
8110d18c:	10800104 	addi	r2,r2,4
8110d190:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
8110d194:	00800044 	movi	r2,1
8110d198:	e0bffd15 	stw	r2,-12(fp)
                break;
8110d19c:	00000606 	br	8110d1b8 <vPusMebInTaskConfigMode+0xe8>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 1, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
8110d1a0:	e0bffc03 	ldbu	r2,-16(fp)
8110d1a4:	10800044 	addi	r2,r2,1
8110d1a8:	e0bffc05 	stb	r2,-16(fp)
8110d1ac:	e0bffc03 	ldbu	r2,-16(fp)
8110d1b0:	10800130 	cmpltui	r2,r2,4
8110d1b4:	103fda1e 	bne	r2,zero,8110d120 <__reset+0xfb0ed120>
            	xPus[i].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
8110d1b8:	d0a06417 	ldw	r2,-32368(gp)
8110d1bc:	1009883a 	mov	r4,r2
8110d1c0:	11332900 	call	81133290 <OSMutexPost>
8110d1c4:	00000106 	br	8110d1cc <vPusMebInTaskConfigMode+0xfc>
	} else {
		vCouldNotGetMutexMebPus();
8110d1c8:	1113bb40 	call	81113bb4 <vCouldNotGetMutexMebPus>
	}

	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {
8110d1cc:	e0bffd17 	ldw	r2,-12(fp)
8110d1d0:	10800058 	cmpnei	r2,r2,1
8110d1d4:	10010f1e 	bne	r2,zero,8110d614 <vPusMebInTaskConfigMode+0x544>

		switch (xPusLocal.usiType) {
8110d1d8:	00a04574 	movhi	r2,33045
8110d1dc:	10a1e104 	addi	r2,r2,-30844
8110d1e0:	1080030b 	ldhu	r2,12(r2)
8110d1e4:	10bfffcc 	andi	r2,r2,65535
8110d1e8:	10c03ee0 	cmpeqi	r3,r2,251
8110d1ec:	1800381e 	bne	r3,zero,8110d2d0 <vPusMebInTaskConfigMode+0x200>
8110d1f0:	10c03f20 	cmpeqi	r3,r2,252
8110d1f4:	1800781e 	bne	r3,zero,8110d3d8 <vPusMebInTaskConfigMode+0x308>
8110d1f8:	10803ea0 	cmpeqi	r2,r2,250
8110d1fc:	1000011e 	bne	r2,zero,8110d204 <vPusMebInTaskConfigMode+0x134>

						break;
				}
				break;
			default:
				break;
8110d200:	00010406 	br	8110d614 <vPusMebInTaskConfigMode+0x544>
	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {

		switch (xPusLocal.usiType) {
			case 250: /* srv-Type = 250 */
				switch ( xPusLocal.usiSubType )
8110d204:	00a04574 	movhi	r2,33045
8110d208:	10a1e104 	addi	r2,r2,-30844
8110d20c:	1080038b 	ldhu	r2,14(r2)
8110d210:	10bfffcc 	andi	r2,r2,65535
8110d214:	10c00f60 	cmpeqi	r3,r2,61
8110d218:	18000c1e 	bne	r3,zero,8110d24c <vPusMebInTaskConfigMode+0x17c>
8110d21c:	10c00fa0 	cmpeqi	r3,r2,62
8110d220:	18000d1e 	bne	r3,zero,8110d258 <vPusMebInTaskConfigMode+0x188>
8110d224:	10800f20 	cmpeqi	r2,r2,60
8110d228:	10001326 	beq	r2,zero,8110d278 <vPusMebInTaskConfigMode+0x1a8>
				{
					case 60: /* TC_SCAM_CONFIG */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: MEB already in the Config Mode\n");
8110d22c:	d0a05517 	ldw	r2,-32428(gp)
8110d230:	100f883a 	mov	r7,r2
8110d234:	01800a44 	movi	r6,41
8110d238:	01400044 	movi	r5,1
8110d23c:	01204534 	movhi	r4,33044
8110d240:	210d0404 	addi	r4,r4,13328
8110d244:	11172b80 	call	811172b8 <fwrite>
						#endif
						break;
8110d248:	00002006 	br	8110d2cc <vPusMebInTaskConfigMode+0x1fc>


					case 61: /* TC_SCAM_RUN */

						vMebChangeToRunning( pxMebCLocal );
8110d24c:	e13fff17 	ldw	r4,-4(fp)
8110d250:	110df100 	call	8110df10 <vMebChangeToRunning>

						break;
8110d254:	00001d06 	br	8110d2cc <vPusMebInTaskConfigMode+0x1fc>
					case 62: /* TC_SCAM_TURNOFF */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Turnning OFF \n");
8110d258:	d0a05517 	ldw	r2,-32428(gp)
8110d25c:	100f883a 	mov	r7,r2
8110d260:	01800604 	movi	r6,24
8110d264:	01400044 	movi	r5,1
8110d268:	01204534 	movhi	r4,33044
8110d26c:	210d0f04 	addi	r4,r4,13372
8110d270:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* todo:Enviar emnsagens para a meb, e a meb distribui a mensagem */
						/* todo:Enviar Sinalizar Led quando puder desligar */

						break;
8110d274:	00001506 	br	8110d2cc <vPusMebInTaskConfigMode+0x1fc>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110d278:	d0e05517 	ldw	r3,-32428(gp)
8110d27c:	00a04574 	movhi	r2,33045
8110d280:	10a1e104 	addi	r2,r2,-30844
8110d284:	1080030b 	ldhu	r2,12(r2)
8110d288:	113fffcc 	andi	r4,r2,65535
8110d28c:	00a04574 	movhi	r2,33045
8110d290:	10a1e104 	addi	r2,r2,-30844
8110d294:	1080038b 	ldhu	r2,14(r2)
8110d298:	117fffcc 	andi	r5,r2,65535
8110d29c:	00a04574 	movhi	r2,33045
8110d2a0:	10a1e104 	addi	r2,r2,-30844
8110d2a4:	1080040b 	ldhu	r2,16(r2)
8110d2a8:	10bfffcc 	andi	r2,r2,65535
8110d2ac:	d8800015 	stw	r2,0(sp)
8110d2b0:	280f883a 	mov	r7,r5
8110d2b4:	200d883a 	mov	r6,r4
8110d2b8:	01604534 	movhi	r5,33044
8110d2bc:	294d1604 	addi	r5,r5,13400
8110d2c0:	1809883a 	mov	r4,r3
8110d2c4:	1116c1c0 	call	81116c1c <fprintf>
						#endif
						break;
8110d2c8:	0001883a 	nop
				}
				break;
8110d2cc:	0000d106 	br	8110d614 <vPusMebInTaskConfigMode+0x544>
			case 251: /* srv-Type = 251 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
8110d2d0:	00a04574 	movhi	r2,33045
8110d2d4:	10a1e104 	addi	r2,r2,-30844
8110d2d8:	1080050b 	ldhu	r2,20(r2)
8110d2dc:	e0bffe0d 	sth	r2,-8(fp)

				switch ( xPusLocal.usiSubType )
8110d2e0:	00a04574 	movhi	r2,33045
8110d2e4:	10a1e104 	addi	r2,r2,-30844
8110d2e8:	1080038b 	ldhu	r2,14(r2)
8110d2ec:	10bfffcc 	andi	r2,r2,65535
8110d2f0:	10c000a0 	cmpeqi	r3,r2,2
8110d2f4:	1800131e 	bne	r3,zero,8110d344 <vPusMebInTaskConfigMode+0x274>
8110d2f8:	10c00160 	cmpeqi	r3,r2,5
8110d2fc:	1800111e 	bne	r3,zero,8110d344 <vPusMebInTaskConfigMode+0x274>
8110d300:	10800060 	cmpeqi	r2,r2,1
8110d304:	10001e26 	beq	r2,zero,8110d380 <vPusMebInTaskConfigMode+0x2b0>
				{
					case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d308:	d0a05517 	ldw	r2,-32428(gp)
8110d30c:	e0fffe0b 	ldhu	r3,-8(fp)
8110d310:	180d883a 	mov	r6,r3
8110d314:	01604534 	movhi	r5,33044
8110d318:	294d2a04 	addi	r5,r5,13480
8110d31c:	1009883a 	mov	r4,r2
8110d320:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"WARNING: NFEE-%hu is already in Config Mode \n\n", usiFeeInstL);
8110d324:	d0a05517 	ldw	r2,-32428(gp)
8110d328:	e0fffe0b 	ldhu	r3,-8(fp)
8110d32c:	180d883a 	mov	r6,r3
8110d330:	01604534 	movhi	r5,33044
8110d334:	294d3104 	addi	r5,r5,13508
8110d338:	1009883a 	mov	r4,r2
8110d33c:	1116c1c0 	call	81116c1c <fprintf>
						#endif

						/* Build a function to send this command to the FEE instance */

						break;
8110d340:	00002406 	br	8110d3d4 <vPusMebInTaskConfigMode+0x304>
					case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
					case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d344:	d0a05517 	ldw	r2,-32428(gp)
8110d348:	e0fffe0b 	ldhu	r3,-8(fp)
8110d34c:	180d883a 	mov	r6,r3
8110d350:	01604534 	movhi	r5,33044
8110d354:	294d2a04 	addi	r5,r5,13480
8110d358:	1009883a 	mov	r4,r2
8110d35c:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"WARNING: Can't change NFEE mode while MEB is in Config Mode. \n\n");
8110d360:	d0a05517 	ldw	r2,-32428(gp)
8110d364:	100f883a 	mov	r7,r2
8110d368:	01800fc4 	movi	r6,63
8110d36c:	01400044 	movi	r5,1
8110d370:	01204534 	movhi	r4,33044
8110d374:	210d3d04 	addi	r4,r4,13556
8110d378:	11172b80 	call	811172b8 <fwrite>
						#endif

							/* Do nothing */

						break;
8110d37c:	00001506 	br	8110d3d4 <vPusMebInTaskConfigMode+0x304>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110d380:	d0e05517 	ldw	r3,-32428(gp)
8110d384:	00a04574 	movhi	r2,33045
8110d388:	10a1e104 	addi	r2,r2,-30844
8110d38c:	1080030b 	ldhu	r2,12(r2)
8110d390:	113fffcc 	andi	r4,r2,65535
8110d394:	00a04574 	movhi	r2,33045
8110d398:	10a1e104 	addi	r2,r2,-30844
8110d39c:	1080038b 	ldhu	r2,14(r2)
8110d3a0:	117fffcc 	andi	r5,r2,65535
8110d3a4:	00a04574 	movhi	r2,33045
8110d3a8:	10a1e104 	addi	r2,r2,-30844
8110d3ac:	1080040b 	ldhu	r2,16(r2)
8110d3b0:	10bfffcc 	andi	r2,r2,65535
8110d3b4:	d8800015 	stw	r2,0(sp)
8110d3b8:	280f883a 	mov	r7,r5
8110d3bc:	200d883a 	mov	r6,r4
8110d3c0:	01604534 	movhi	r5,33044
8110d3c4:	294d1604 	addi	r5,r5,13400
8110d3c8:	1809883a 	mov	r4,r3
8110d3cc:	1116c1c0 	call	81116c1c <fprintf>
						#endif
						break;
8110d3d0:	0001883a 	nop
				}
				break;
8110d3d4:	00008f06 	br	8110d614 <vPusMebInTaskConfigMode+0x544>
			case 252: /* srv-Type = 252 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
8110d3d8:	00a04574 	movhi	r2,33045
8110d3dc:	10a1e104 	addi	r2,r2,-30844
8110d3e0:	1080050b 	ldhu	r2,20(r2)
8110d3e4:	e0bffe0d 	sth	r2,-8(fp)


				switch ( xPusLocal.usiSubType )
8110d3e8:	00a04574 	movhi	r2,33045
8110d3ec:	10a1e104 	addi	r2,r2,-30844
8110d3f0:	1080038b 	ldhu	r2,14(r2)
8110d3f4:	10bfffcc 	andi	r2,r2,65535
8110d3f8:	10c000e0 	cmpeqi	r3,r2,3
8110d3fc:	18000a1e 	bne	r3,zero,8110d428 <vPusMebInTaskConfigMode+0x358>
8110d400:	10c00108 	cmpgei	r3,r2,4
8110d404:	1800031e 	bne	r3,zero,8110d414 <vPusMebInTaskConfigMode+0x344>
8110d408:	108000a0 	cmpeqi	r2,r2,2
8110d40c:	1000481e 	bne	r2,zero,8110d530 <vPusMebInTaskConfigMode+0x460>
8110d410:	00006a06 	br	8110d5bc <vPusMebInTaskConfigMode+0x4ec>
8110d414:	10c00120 	cmpeqi	r3,r2,4
8110d418:	1800191e 	bne	r3,zero,8110d480 <vPusMebInTaskConfigMode+0x3b0>
8110d41c:	10800160 	cmpeqi	r2,r2,5
8110d420:	10002d1e 	bne	r2,zero,8110d4d8 <vPusMebInTaskConfigMode+0x408>
8110d424:	00006506 	br	8110d5bc <vPusMebInTaskConfigMode+0x4ec>
				{
					case 3: /* TC_SCAM_SPW_LINK_ENABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d428:	d0a05517 	ldw	r2,-32428(gp)
8110d42c:	e0fffe0b 	ldhu	r3,-8(fp)
8110d430:	180d883a 	mov	r6,r3
8110d434:	01604534 	movhi	r5,33044
8110d438:	294d2a04 	addi	r5,r5,13480
8110d43c:	1009883a 	mov	r4,r2
8110d440:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_ENABLE \n");
8110d444:	d0a05517 	ldw	r2,-32428(gp)
8110d448:	100f883a 	mov	r7,r2
8110d44c:	01800844 	movi	r6,33
8110d450:	01400044 	movi	r5,1
8110d454:	01204534 	movhi	r4,33044
8110d458:	210d4d04 	addi	r4,r4,13620
8110d45c:	11172b80 	call	811172b8 <fwrite>
							fprintf(fp,"WARNING: Can't operate the Link while Meb is is Config mode \n\n");
8110d460:	d0a05517 	ldw	r2,-32428(gp)
8110d464:	100f883a 	mov	r7,r2
8110d468:	01800f84 	movi	r6,62
8110d46c:	01400044 	movi	r5,1
8110d470:	01204534 	movhi	r4,33044
8110d474:	210d5604 	addi	r4,r4,13656
8110d478:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						break;
8110d47c:	00006406 	br	8110d610 <vPusMebInTaskConfigMode+0x540>
					case 4: /* TC_SCAM_SPW_LINK_DISABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d480:	d0a05517 	ldw	r2,-32428(gp)
8110d484:	e0fffe0b 	ldhu	r3,-8(fp)
8110d488:	180d883a 	mov	r6,r3
8110d48c:	01604534 	movhi	r5,33044
8110d490:	294d2a04 	addi	r5,r5,13480
8110d494:	1009883a 	mov	r4,r2
8110d498:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_DISABLE \n");
8110d49c:	d0a05517 	ldw	r2,-32428(gp)
8110d4a0:	100f883a 	mov	r7,r2
8110d4a4:	01800884 	movi	r6,34
8110d4a8:	01400044 	movi	r5,1
8110d4ac:	01204534 	movhi	r4,33044
8110d4b0:	210d6604 	addi	r4,r4,13720
8110d4b4:	11172b80 	call	811172b8 <fwrite>
							fprintf(fp,"WARNING: Can't operate the Link while Meb is is Config mode \n\n");
8110d4b8:	d0a05517 	ldw	r2,-32428(gp)
8110d4bc:	100f883a 	mov	r7,r2
8110d4c0:	01800f84 	movi	r6,62
8110d4c4:	01400044 	movi	r5,1
8110d4c8:	01204534 	movhi	r4,33044
8110d4cc:	210d5604 	addi	r4,r4,13656
8110d4d0:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						break;
8110d4d4:	00004e06 	br	8110d610 <vPusMebInTaskConfigMode+0x540>
					case 5: /* TC_SCAM_SPW_LINK_RESET */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d4d8:	d0a05517 	ldw	r2,-32428(gp)
8110d4dc:	e0fffe0b 	ldhu	r3,-8(fp)
8110d4e0:	180d883a 	mov	r6,r3
8110d4e4:	01604534 	movhi	r5,33044
8110d4e8:	294d2a04 	addi	r5,r5,13480
8110d4ec:	1009883a 	mov	r4,r2
8110d4f0:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_RESET \n");
8110d4f4:	d0a05517 	ldw	r2,-32428(gp)
8110d4f8:	100f883a 	mov	r7,r2
8110d4fc:	01800804 	movi	r6,32
8110d500:	01400044 	movi	r5,1
8110d504:	01204534 	movhi	r4,33044
8110d508:	210d6f04 	addi	r4,r4,13756
8110d50c:	11172b80 	call	811172b8 <fwrite>
							fprintf(fp,"WARNING: Can't operate the Link while Meb is is Config mode \n\n");
8110d510:	d0a05517 	ldw	r2,-32428(gp)
8110d514:	100f883a 	mov	r7,r2
8110d518:	01800f84 	movi	r6,62
8110d51c:	01400044 	movi	r5,1
8110d520:	01204534 	movhi	r4,33044
8110d524:	210d5604 	addi	r4,r4,13656
8110d528:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						break;
8110d52c:	00003806 	br	8110d610 <vPusMebInTaskConfigMode+0x540>
					case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d530:	d0a05517 	ldw	r2,-32428(gp)
8110d534:	e0fffe0b 	ldhu	r3,-8(fp)
8110d538:	180d883a 	mov	r6,r3
8110d53c:	01604534 	movhi	r5,33044
8110d540:	294d2a04 	addi	r5,r5,13480
8110d544:	1009883a 	mov	r4,r2
8110d548:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_RMAP_CONFIG_UPDATE \n");
8110d54c:	d0a05517 	ldw	r2,-32428(gp)
8110d550:	100f883a 	mov	r7,r2
8110d554:	01800a04 	movi	r6,40
8110d558:	01400044 	movi	r5,1
8110d55c:	01204534 	movhi	r4,33044
8110d560:	210d7804 	addi	r4,r4,13792
8110d564:	11172b80 	call	811172b8 <fwrite>
						xPusLocal.usiValues[5];
						xPusLocal.usiValues[6];
						xPusLocal.usiValues[7];
							*/

						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusLocal.usiValues[12];
8110d568:	e13ffe0b 	ldhu	r4,-8(fp)
8110d56c:	00a04574 	movhi	r2,33045
8110d570:	10a1e104 	addi	r2,r2,-30844
8110d574:	10800b0b 	ldhu	r2,44(r2)
8110d578:	100b883a 	mov	r5,r2
8110d57c:	e0ffff17 	ldw	r3,-4(fp)
8110d580:	20808f24 	muli	r2,r4,572
8110d584:	1885883a 	add	r2,r3,r2
8110d588:	10805d04 	addi	r2,r2,372
8110d58c:	11400005 	stb	r5,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusLocal.usiValues[9];
8110d590:	e13ffe0b 	ldhu	r4,-8(fp)
8110d594:	00a04574 	movhi	r2,33045
8110d598:	10a1e104 	addi	r2,r2,-30844
8110d59c:	1080098b 	ldhu	r2,38(r2)
8110d5a0:	100b883a 	mov	r5,r2
8110d5a4:	e0ffff17 	ldw	r3,-4(fp)
8110d5a8:	20808f24 	muli	r2,r4,572
8110d5ac:	1885883a 	add	r2,r3,r2
8110d5b0:	10805d44 	addi	r2,r2,373
8110d5b4:	11400005 	stb	r5,0(r2)
							debug(fp, cPUSDebug );
							sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
							debug(fp, cPUSDebug );
						#endif
*/
						break;
8110d5b8:	00001506 	br	8110d610 <vPusMebInTaskConfigMode+0x540>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110d5bc:	d0e05517 	ldw	r3,-32428(gp)
8110d5c0:	00a04574 	movhi	r2,33045
8110d5c4:	10a1e104 	addi	r2,r2,-30844
8110d5c8:	1080030b 	ldhu	r2,12(r2)
8110d5cc:	113fffcc 	andi	r4,r2,65535
8110d5d0:	00a04574 	movhi	r2,33045
8110d5d4:	10a1e104 	addi	r2,r2,-30844
8110d5d8:	1080038b 	ldhu	r2,14(r2)
8110d5dc:	117fffcc 	andi	r5,r2,65535
8110d5e0:	00a04574 	movhi	r2,33045
8110d5e4:	10a1e104 	addi	r2,r2,-30844
8110d5e8:	1080040b 	ldhu	r2,16(r2)
8110d5ec:	10bfffcc 	andi	r2,r2,65535
8110d5f0:	d8800015 	stw	r2,0(sp)
8110d5f4:	280f883a 	mov	r7,r5
8110d5f8:	200d883a 	mov	r6,r4
8110d5fc:	01604534 	movhi	r5,33044
8110d600:	294d1604 	addi	r5,r5,13400
8110d604:	1809883a 	mov	r4,r3
8110d608:	1116c1c0 	call	81116c1c <fprintf>
						#endif

						break;
8110d60c:	0001883a 	nop
				}
				break;
8110d610:	0001883a 	nop
				break;
		}

	}

}
8110d614:	0001883a 	nop
8110d618:	e037883a 	mov	sp,fp
8110d61c:	dfc00117 	ldw	ra,4(sp)
8110d620:	df000017 	ldw	fp,0(sp)
8110d624:	dec00204 	addi	sp,sp,8
8110d628:	f800283a 	ret

8110d62c <vPusMebInTaskRunningMode>:


/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal ) {
8110d62c:	defff904 	addi	sp,sp,-28
8110d630:	de00012e 	bgeu	sp,et,8110d638 <vPusMebInTaskRunningMode+0xc>
8110d634:	003b68fa 	trap	3
8110d638:	dfc00615 	stw	ra,24(sp)
8110d63c:	df000515 	stw	fp,20(sp)
8110d640:	df000504 	addi	fp,sp,20
8110d644:	e13fff15 	stw	r4,-4(fp)
	unsigned char i;
	unsigned short int usiFeeInstL;
	static tTMPus xPusLocal;
	bool bSuccess = FALSE;
8110d648:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;

	bSuccess = FALSE;
8110d64c:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 1, &error_code);
8110d650:	d0a06417 	ldw	r2,-32368(gp)
8110d654:	e0fffe84 	addi	r3,fp,-6
8110d658:	180d883a 	mov	r6,r3
8110d65c:	01400044 	movi	r5,1
8110d660:	1009883a 	mov	r4,r2
8110d664:	1132cec0 	call	81132cec <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
8110d668:	e0bffe83 	ldbu	r2,-6(fp)
8110d66c:	10803fcc 	andi	r2,r2,255
8110d670:	10002c1e 	bne	r2,zero,8110d724 <vPusMebInTaskRunningMode+0xf8>

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
8110d674:	e03ffc05 	stb	zero,-16(fp)
8110d678:	00002306 	br	8110d708 <vPusMebInTaskRunningMode+0xdc>
	    {
            if ( xPus[i].bInUse == TRUE ) {
8110d67c:	e0fffc03 	ldbu	r3,-16(fp)
8110d680:	00a04574 	movhi	r2,33045
8110d684:	10abed04 	addi	r2,r2,-20556
8110d688:	18c01524 	muli	r3,r3,84
8110d68c:	10c5883a 	add	r2,r2,r3
8110d690:	10800104 	addi	r2,r2,4
8110d694:	10800017 	ldw	r2,0(r2)
8110d698:	10800058 	cmpnei	r2,r2,1
8110d69c:	1000171e 	bne	r2,zero,8110d6fc <vPusMebInTaskRunningMode+0xd0>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[i];
8110d6a0:	e13ffc03 	ldbu	r4,-16(fp)
8110d6a4:	00e04574 	movhi	r3,33045
8110d6a8:	18e1f604 	addi	r3,r3,-30760
8110d6ac:	00a04574 	movhi	r2,33045
8110d6b0:	10abed04 	addi	r2,r2,-20556
8110d6b4:	21001524 	muli	r4,r4,84
8110d6b8:	1105883a 	add	r2,r2,r4
8110d6bc:	1009883a 	mov	r4,r2
8110d6c0:	00801504 	movi	r2,84
8110d6c4:	100d883a 	mov	r6,r2
8110d6c8:	200b883a 	mov	r5,r4
8110d6cc:	1809883a 	mov	r4,r3
8110d6d0:	1117ccc0 	call	81117ccc <memcpy>
            	xPus[i].bInUse = FALSE;
8110d6d4:	e0fffc03 	ldbu	r3,-16(fp)
8110d6d8:	00a04574 	movhi	r2,33045
8110d6dc:	10abed04 	addi	r2,r2,-20556
8110d6e0:	18c01524 	muli	r3,r3,84
8110d6e4:	10c5883a 	add	r2,r2,r3
8110d6e8:	10800104 	addi	r2,r2,4
8110d6ec:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
8110d6f0:	00800044 	movi	r2,1
8110d6f4:	e0bffd15 	stw	r2,-12(fp)
                break;
8110d6f8:	00000606 	br	8110d714 <vPusMebInTaskRunningMode+0xe8>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 1, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
8110d6fc:	e0bffc03 	ldbu	r2,-16(fp)
8110d700:	10800044 	addi	r2,r2,1
8110d704:	e0bffc05 	stb	r2,-16(fp)
8110d708:	e0bffc03 	ldbu	r2,-16(fp)
8110d70c:	10800130 	cmpltui	r2,r2,4
8110d710:	103fda1e 	bne	r2,zero,8110d67c <__reset+0xfb0ed67c>
            	xPus[i].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
8110d714:	d0a06417 	ldw	r2,-32368(gp)
8110d718:	1009883a 	mov	r4,r2
8110d71c:	11332900 	call	81133290 <OSMutexPost>
8110d720:	00000106 	br	8110d728 <vPusMebInTaskRunningMode+0xfc>
	} else {
		vCouldNotGetMutexMebPus();
8110d724:	1113bb40 	call	81113bb4 <vCouldNotGetMutexMebPus>
	}

	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {
8110d728:	e0bffd17 	ldw	r2,-12(fp)
8110d72c:	10800058 	cmpnei	r2,r2,1
8110d730:	10016c1e 	bne	r2,zero,8110dce4 <vPusMebInTaskRunningMode+0x6b8>

		switch (xPusLocal.usiType) {
8110d734:	00a04574 	movhi	r2,33045
8110d738:	10a1f604 	addi	r2,r2,-30760
8110d73c:	1080030b 	ldhu	r2,12(r2)
8110d740:	10bfffcc 	andi	r2,r2,65535
8110d744:	10c03ee0 	cmpeqi	r3,r2,251
8110d748:	1800481e 	bne	r3,zero,8110d86c <vPusMebInTaskRunningMode+0x240>
8110d74c:	10c03f20 	cmpeqi	r3,r2,252
8110d750:	1800b51e 	bne	r3,zero,8110da28 <vPusMebInTaskRunningMode+0x3fc>
8110d754:	10803ea0 	cmpeqi	r2,r2,250
8110d758:	1000011e 	bne	r2,zero,8110d760 <vPusMebInTaskRunningMode+0x134>

						break;
				}
				break;
			default:
				break;
8110d75c:	00016106 	br	8110dce4 <vPusMebInTaskRunningMode+0x6b8>
	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {

		switch (xPusLocal.usiType) {
			case 250: /* srv-Type = 250 */
				switch ( xPusLocal.usiSubType )
8110d760:	00a04574 	movhi	r2,33045
8110d764:	10a1f604 	addi	r2,r2,-30760
8110d768:	1080038b 	ldhu	r2,14(r2)
8110d76c:	10bfffcc 	andi	r2,r2,65535
8110d770:	10c00f60 	cmpeqi	r3,r2,61
8110d774:	1800171e 	bne	r3,zero,8110d7d4 <vPusMebInTaskRunningMode+0x1a8>
8110d778:	10c00fa0 	cmpeqi	r3,r2,62
8110d77c:	18001d1e 	bne	r3,zero,8110d7f4 <vPusMebInTaskRunningMode+0x1c8>
8110d780:	10800f20 	cmpeqi	r2,r2,60
8110d784:	10002326 	beq	r2,zero,8110d814 <vPusMebInTaskRunningMode+0x1e8>
				{
					case 60: /* TC_SCAM_CONFIG */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Changing to Config Mode\n");
8110d788:	d0a05517 	ldw	r2,-32428(gp)
8110d78c:	100f883a 	mov	r7,r2
8110d790:	01800884 	movi	r6,34
8110d794:	01400044 	movi	r5,1
8110d798:	01204534 	movhi	r4,33044
8110d79c:	210d8304 	addi	r4,r4,13836
8110d7a0:	11172b80 	call	811172b8 <fwrite>
						#endif

						vEvtChangeMebMode(pxMebCLocal->eMode, sMebConfig);
8110d7a4:	e0bfff17 	ldw	r2,-4(fp)
8110d7a8:	10800117 	ldw	r2,4(r2)
8110d7ac:	000b883a 	mov	r5,zero
8110d7b0:	1009883a 	mov	r4,r2
8110d7b4:	1113ed80 	call	81113ed8 <vEvtChangeMebMode>
						pxMebCLocal->eMode = sMebConfig;
8110d7b8:	e0bfff17 	ldw	r2,-4(fp)
8110d7bc:	10000115 	stw	zero,4(r2)

	/*todo: URGENTE: Passar todos os FEE para modo de configurao  */
	/*todo: URGENTE: Data Controller e NFEE COntroller tambm  */

						vSendCmdQToNFeeCTRL( M_NFC_CONFIG, 0, 0 );
8110d7c0:	000d883a 	mov	r6,zero
8110d7c4:	000b883a 	mov	r5,zero
8110d7c8:	01000044 	movi	r4,1
8110d7cc:	110dcfc0 	call	8110dcfc <vSendCmdQToNFeeCTRL>


						break;
8110d7d0:	00002506 	br	8110d868 <vPusMebInTaskRunningMode+0x23c>

					case 61: /* TC_SCAM_RUN */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: MEB already in the RUN Mode\n");
8110d7d4:	d0a05517 	ldw	r2,-32428(gp)
8110d7d8:	100f883a 	mov	r7,r2
8110d7dc:	01800984 	movi	r6,38
8110d7e0:	01400044 	movi	r5,1
8110d7e4:	01204534 	movhi	r4,33044
8110d7e8:	210d8c04 	addi	r4,r4,13872
8110d7ec:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* Do nothing */

						break;
8110d7f0:	00001d06 	br	8110d868 <vPusMebInTaskRunningMode+0x23c>


					case 62: /* TC_SCAM_TURNOFF */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Turnning OFF \n");
8110d7f4:	d0a05517 	ldw	r2,-32428(gp)
8110d7f8:	100f883a 	mov	r7,r2
8110d7fc:	01800604 	movi	r6,24
8110d800:	01400044 	movi	r5,1
8110d804:	01204534 	movhi	r4,33044
8110d808:	210d0f04 	addi	r4,r4,13372
8110d80c:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* todo:Enviar emnsagens para a meb, e a meb distribui a mensagem */
						/* todo:Enviar Sinalizar Led quando puder desligar */

						break;
8110d810:	00001506 	br	8110d868 <vPusMebInTaskRunningMode+0x23c>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110d814:	d0e05517 	ldw	r3,-32428(gp)
8110d818:	00a04574 	movhi	r2,33045
8110d81c:	10a1f604 	addi	r2,r2,-30760
8110d820:	1080030b 	ldhu	r2,12(r2)
8110d824:	113fffcc 	andi	r4,r2,65535
8110d828:	00a04574 	movhi	r2,33045
8110d82c:	10a1f604 	addi	r2,r2,-30760
8110d830:	1080038b 	ldhu	r2,14(r2)
8110d834:	117fffcc 	andi	r5,r2,65535
8110d838:	00a04574 	movhi	r2,33045
8110d83c:	10a1f604 	addi	r2,r2,-30760
8110d840:	1080040b 	ldhu	r2,16(r2)
8110d844:	10bfffcc 	andi	r2,r2,65535
8110d848:	d8800015 	stw	r2,0(sp)
8110d84c:	280f883a 	mov	r7,r5
8110d850:	200d883a 	mov	r6,r4
8110d854:	01604534 	movhi	r5,33044
8110d858:	294d1604 	addi	r5,r5,13400
8110d85c:	1809883a 	mov	r4,r3
8110d860:	1116c1c0 	call	81116c1c <fprintf>
						#endif
						break;
8110d864:	0001883a 	nop
				}
				break;
8110d868:	00011e06 	br	8110dce4 <vPusMebInTaskRunningMode+0x6b8>
			case 251: /* srv-Type = 251 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
8110d86c:	00a04574 	movhi	r2,33045
8110d870:	10a1f604 	addi	r2,r2,-30760
8110d874:	1080050b 	ldhu	r2,20(r2)
8110d878:	e0bffe0d 	sth	r2,-8(fp)

				switch ( xPusLocal.usiSubType )
8110d87c:	00a04574 	movhi	r2,33045
8110d880:	10a1f604 	addi	r2,r2,-30760
8110d884:	1080038b 	ldhu	r2,14(r2)
8110d888:	10bfffcc 	andi	r2,r2,65535
8110d88c:	10c000a0 	cmpeqi	r3,r2,2
8110d890:	18001d1e 	bne	r3,zero,8110d908 <vPusMebInTaskRunningMode+0x2dc>
8110d894:	10c00160 	cmpeqi	r3,r2,5
8110d898:	1800341e 	bne	r3,zero,8110d96c <vPusMebInTaskRunningMode+0x340>
8110d89c:	10800060 	cmpeqi	r2,r2,1
8110d8a0:	10004b26 	beq	r2,zero,8110d9d0 <vPusMebInTaskRunningMode+0x3a4>
				{
					case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"\nMEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d8a4:	d0a05517 	ldw	r2,-32428(gp)
8110d8a8:	e0fffe0b 	ldhu	r3,-8(fp)
8110d8ac:	180d883a 	mov	r6,r3
8110d8b0:	01604534 	movhi	r5,33044
8110d8b4:	294d9604 	addi	r5,r5,13912
8110d8b8:	1009883a 	mov	r4,r2
8110d8bc:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> FEE_CONFIG_ENTER \n\n");
8110d8c0:	d0a05517 	ldw	r2,-32428(gp)
8110d8c4:	100f883a 	mov	r7,r2
8110d8c8:	018006c4 	movi	r6,27
8110d8cc:	01400044 	movi	r5,1
8110d8d0:	01204534 	movhi	r4,33044
8110d8d4:	210d9e04 	addi	r4,r4,13944
8110d8d8:	11172b80 	call	811172b8 <fwrite>
						#endif

						vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
8110d8dc:	e0bffe0b 	ldhu	r2,-8(fp)
8110d8e0:	10800444 	addi	r2,r2,17
8110d8e4:	10803fcc 	andi	r2,r2,255
8110d8e8:	e0fffe0b 	ldhu	r3,-8(fp)
8110d8ec:	18c03fcc 	andi	r3,r3,255
8110d8f0:	180f883a 	mov	r7,r3
8110d8f4:	000d883a 	mov	r6,zero
8110d8f8:	01400044 	movi	r5,1
8110d8fc:	1009883a 	mov	r4,r2
8110d900:	110dd840 	call	8110dd84 <vSendCmdQToNFeeCTRL_GEN>
						/* Build a function to send this command to the FEE instance */
						 /* Using QMASK send to NfeeControl that will forward */

						break;
8110d904:	00004706 	br	8110da24 <vPusMebInTaskRunningMode+0x3f8>
					case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d908:	d0a05517 	ldw	r2,-32428(gp)
8110d90c:	e0fffe0b 	ldhu	r3,-8(fp)
8110d910:	180d883a 	mov	r6,r3
8110d914:	01604534 	movhi	r5,33044
8110d918:	294d2a04 	addi	r5,r5,13480
8110d91c:	1009883a 	mov	r4,r2
8110d920:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> FEE_STANDBY_ENTER \n");
8110d924:	d0a05517 	ldw	r2,-32428(gp)
8110d928:	100f883a 	mov	r7,r2
8110d92c:	018006c4 	movi	r6,27
8110d930:	01400044 	movi	r5,1
8110d934:	01204534 	movhi	r4,33044
8110d938:	210da504 	addi	r4,r4,13972
8110d93c:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* Using QMASK send to NfeeControl that will foward */
						vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
8110d940:	e0bffe0b 	ldhu	r2,-8(fp)
8110d944:	10800444 	addi	r2,r2,17
8110d948:	10803fcc 	andi	r2,r2,255
8110d94c:	e0fffe0b 	ldhu	r3,-8(fp)
8110d950:	18c03fcc 	andi	r3,r3,255
8110d954:	180f883a 	mov	r7,r3
8110d958:	000d883a 	mov	r6,zero
8110d95c:	01400104 	movi	r5,4
8110d960:	1009883a 	mov	r4,r2
8110d964:	110dd840 	call	8110dd84 <vSendCmdQToNFeeCTRL_GEN>

						break;
8110d968:	00002e06 	br	8110da24 <vPusMebInTaskRunningMode+0x3f8>
					case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110d96c:	d0a05517 	ldw	r2,-32428(gp)
8110d970:	e0fffe0b 	ldhu	r3,-8(fp)
8110d974:	180d883a 	mov	r6,r3
8110d978:	01604534 	movhi	r5,33044
8110d97c:	294d2a04 	addi	r5,r5,13480
8110d980:	1009883a 	mov	r4,r2
8110d984:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> TC_SCAM_FEE_CALIBRATION_TEST_ENTER \n");
8110d988:	d0a05517 	ldw	r2,-32428(gp)
8110d98c:	100f883a 	mov	r7,r2
8110d990:	01800b04 	movi	r6,44
8110d994:	01400044 	movi	r5,1
8110d998:	01204534 	movhi	r4,33044
8110d99c:	210dac04 	addi	r4,r4,14000
8110d9a0:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* Using QMASK send to NfeeControl that will foward */
						vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
8110d9a4:	e0bffe0b 	ldhu	r2,-8(fp)
8110d9a8:	10800444 	addi	r2,r2,17
8110d9ac:	10803fcc 	andi	r2,r2,255
8110d9b0:	e0fffe0b 	ldhu	r3,-8(fp)
8110d9b4:	18c03fcc 	andi	r3,r3,255
8110d9b8:	180f883a 	mov	r7,r3
8110d9bc:	000d883a 	mov	r6,zero
8110d9c0:	01400204 	movi	r5,8
8110d9c4:	1009883a 	mov	r4,r2
8110d9c8:	110dd840 	call	8110dd84 <vSendCmdQToNFeeCTRL_GEN>

						break;
8110d9cc:	00001506 	br	8110da24 <vPusMebInTaskRunningMode+0x3f8>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110d9d0:	d0e05517 	ldw	r3,-32428(gp)
8110d9d4:	00a04574 	movhi	r2,33045
8110d9d8:	10a1f604 	addi	r2,r2,-30760
8110d9dc:	1080030b 	ldhu	r2,12(r2)
8110d9e0:	113fffcc 	andi	r4,r2,65535
8110d9e4:	00a04574 	movhi	r2,33045
8110d9e8:	10a1f604 	addi	r2,r2,-30760
8110d9ec:	1080038b 	ldhu	r2,14(r2)
8110d9f0:	117fffcc 	andi	r5,r2,65535
8110d9f4:	00a04574 	movhi	r2,33045
8110d9f8:	10a1f604 	addi	r2,r2,-30760
8110d9fc:	1080040b 	ldhu	r2,16(r2)
8110da00:	10bfffcc 	andi	r2,r2,65535
8110da04:	d8800015 	stw	r2,0(sp)
8110da08:	280f883a 	mov	r7,r5
8110da0c:	200d883a 	mov	r6,r4
8110da10:	01604534 	movhi	r5,33044
8110da14:	294d1604 	addi	r5,r5,13400
8110da18:	1809883a 	mov	r4,r3
8110da1c:	1116c1c0 	call	81116c1c <fprintf>
						#endif
						break;
8110da20:	0001883a 	nop
				}
				break;
8110da24:	0000af06 	br	8110dce4 <vPusMebInTaskRunningMode+0x6b8>
			case 252: /* srv-Type = 252 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
8110da28:	00a04574 	movhi	r2,33045
8110da2c:	10a1f604 	addi	r2,r2,-30760
8110da30:	1080050b 	ldhu	r2,20(r2)
8110da34:	e0bffe0d 	sth	r2,-8(fp)


				switch ( xPusLocal.usiSubType )
8110da38:	00a04574 	movhi	r2,33045
8110da3c:	10a1f604 	addi	r2,r2,-30760
8110da40:	1080038b 	ldhu	r2,14(r2)
8110da44:	10bfffcc 	andi	r2,r2,65535
8110da48:	10c000e0 	cmpeqi	r3,r2,3
8110da4c:	18000a1e 	bne	r3,zero,8110da78 <vPusMebInTaskRunningMode+0x44c>
8110da50:	10c00108 	cmpgei	r3,r2,4
8110da54:	1800031e 	bne	r3,zero,8110da64 <vPusMebInTaskRunningMode+0x438>
8110da58:	108000a0 	cmpeqi	r2,r2,2
8110da5c:	1000751e 	bne	r2,zero,8110dc34 <vPusMebInTaskRunningMode+0x608>
8110da60:	00008a06 	br	8110dc8c <vPusMebInTaskRunningMode+0x660>
8110da64:	10c00120 	cmpeqi	r3,r2,4
8110da68:	1800331e 	bne	r3,zero,8110db38 <vPusMebInTaskRunningMode+0x50c>
8110da6c:	10800160 	cmpeqi	r2,r2,5
8110da70:	1000611e 	bne	r2,zero,8110dbf8 <vPusMebInTaskRunningMode+0x5cc>
8110da74:	00008506 	br	8110dc8c <vPusMebInTaskRunningMode+0x660>
				{
					case 3: /* TC_SCAM_SPW_LINK_ENABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110da78:	d0a05517 	ldw	r2,-32428(gp)
8110da7c:	e0fffe0b 	ldhu	r3,-8(fp)
8110da80:	180d883a 	mov	r6,r3
8110da84:	01604534 	movhi	r5,33044
8110da88:	294d2a04 	addi	r5,r5,13480
8110da8c:	1009883a 	mov	r4,r2
8110da90:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_ENABLE \n");
8110da94:	d0a05517 	ldw	r2,-32428(gp)
8110da98:	100f883a 	mov	r7,r2
8110da9c:	01800844 	movi	r6,33
8110daa0:	01400044 	movi	r5,1
8110daa4:	01204534 	movhi	r4,33044
8110daa8:	210d4d04 	addi	r4,r4,13620
8110daac:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
8110dab0:	e0bffe0b 	ldhu	r2,-8(fp)
8110dab4:	10808f24 	muli	r2,r2,572
8110dab8:	1080a204 	addi	r2,r2,648
8110dabc:	e0ffff17 	ldw	r3,-4(fp)
8110dac0:	1885883a 	add	r2,r3,r2
8110dac4:	1009883a 	mov	r4,r2
8110dac8:	11052cc0 	call	811052cc <bSpwcGetLink>
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bStart = FALSE;
8110dacc:	e0bffe0b 	ldhu	r2,-8(fp)
8110dad0:	e0ffff17 	ldw	r3,-4(fp)
8110dad4:	10808f24 	muli	r2,r2,572
8110dad8:	1885883a 	add	r2,r3,r2
8110dadc:	1080a404 	addi	r2,r2,656
8110dae0:	10000015 	stw	zero,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
8110dae4:	e0bffe0b 	ldhu	r2,-8(fp)
8110dae8:	e0ffff17 	ldw	r3,-4(fp)
8110daec:	10808f24 	muli	r2,r2,572
8110daf0:	1885883a 	add	r2,r3,r2
8110daf4:	1080a304 	addi	r2,r2,652
8110daf8:	00c00044 	movi	r3,1
8110dafc:	10c00015 	stw	r3,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
8110db00:	e0bffe0b 	ldhu	r2,-8(fp)
8110db04:	e0ffff17 	ldw	r3,-4(fp)
8110db08:	10808f24 	muli	r2,r2,572
8110db0c:	1885883a 	add	r2,r3,r2
8110db10:	1080a504 	addi	r2,r2,660
8110db14:	10000015 	stw	zero,0(r2)
						bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
8110db18:	e0bffe0b 	ldhu	r2,-8(fp)
8110db1c:	10808f24 	muli	r2,r2,572
8110db20:	1080a204 	addi	r2,r2,648
8110db24:	e0ffff17 	ldw	r3,-4(fp)
8110db28:	1885883a 	add	r2,r3,r2
8110db2c:	1009883a 	mov	r4,r2
8110db30:	11051cc0 	call	811051cc <bSpwcSetLink>


						break;
8110db34:	00006a06 	br	8110dce0 <vPusMebInTaskRunningMode+0x6b4>
					case 4: /* TC_SCAM_SPW_LINK_DISABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110db38:	d0a05517 	ldw	r2,-32428(gp)
8110db3c:	e0fffe0b 	ldhu	r3,-8(fp)
8110db40:	180d883a 	mov	r6,r3
8110db44:	01604534 	movhi	r5,33044
8110db48:	294d2a04 	addi	r5,r5,13480
8110db4c:	1009883a 	mov	r4,r2
8110db50:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_DISABLE \n");
8110db54:	d0a05517 	ldw	r2,-32428(gp)
8110db58:	100f883a 	mov	r7,r2
8110db5c:	01800884 	movi	r6,34
8110db60:	01400044 	movi	r5,1
8110db64:	01204534 	movhi	r4,33044
8110db68:	210d6604 	addi	r4,r4,13720
8110db6c:	11172b80 	call	811172b8 <fwrite>
						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */
						/* Disable the link SPW */
						//todo: tratar retorno

						bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
8110db70:	e0bffe0b 	ldhu	r2,-8(fp)
8110db74:	10808f24 	muli	r2,r2,572
8110db78:	1080a204 	addi	r2,r2,648
8110db7c:	e0ffff17 	ldw	r3,-4(fp)
8110db80:	1885883a 	add	r2,r3,r2
8110db84:	1009883a 	mov	r4,r2
8110db88:	11052cc0 	call	811052cc <bSpwcGetLink>
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bStart = FALSE;
8110db8c:	e0bffe0b 	ldhu	r2,-8(fp)
8110db90:	e0ffff17 	ldw	r3,-4(fp)
8110db94:	10808f24 	muli	r2,r2,572
8110db98:	1885883a 	add	r2,r3,r2
8110db9c:	1080a404 	addi	r2,r2,656
8110dba0:	10000015 	stw	zero,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
8110dba4:	e0bffe0b 	ldhu	r2,-8(fp)
8110dba8:	e0ffff17 	ldw	r3,-4(fp)
8110dbac:	10808f24 	muli	r2,r2,572
8110dbb0:	1885883a 	add	r2,r3,r2
8110dbb4:	1080a304 	addi	r2,r2,652
8110dbb8:	10000015 	stw	zero,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
8110dbbc:	e0bffe0b 	ldhu	r2,-8(fp)
8110dbc0:	e0ffff17 	ldw	r3,-4(fp)
8110dbc4:	10808f24 	muli	r2,r2,572
8110dbc8:	1885883a 	add	r2,r3,r2
8110dbcc:	1080a504 	addi	r2,r2,660
8110dbd0:	00c00044 	movi	r3,1
8110dbd4:	10c00015 	stw	r3,0(r2)
						bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
8110dbd8:	e0bffe0b 	ldhu	r2,-8(fp)
8110dbdc:	10808f24 	muli	r2,r2,572
8110dbe0:	1080a204 	addi	r2,r2,648
8110dbe4:	e0ffff17 	ldw	r3,-4(fp)
8110dbe8:	1885883a 	add	r2,r3,r2
8110dbec:	1009883a 	mov	r4,r2
8110dbf0:	11051cc0 	call	811051cc <bSpwcSetLink>

						break;
8110dbf4:	00003a06 	br	8110dce0 <vPusMebInTaskRunningMode+0x6b4>
					case 5: /* TC_SCAM_SPW_LINK_RESET */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110dbf8:	d0a05517 	ldw	r2,-32428(gp)
8110dbfc:	e0fffe0b 	ldhu	r3,-8(fp)
8110dc00:	180d883a 	mov	r6,r3
8110dc04:	01604534 	movhi	r5,33044
8110dc08:	294d2a04 	addi	r5,r5,13480
8110dc0c:	1009883a 	mov	r4,r2
8110dc10:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_RESET \n");
8110dc14:	d0a05517 	ldw	r2,-32428(gp)
8110dc18:	100f883a 	mov	r7,r2
8110dc1c:	01800804 	movi	r6,32
8110dc20:	01400044 	movi	r5,1
8110dc24:	01204534 	movhi	r4,33044
8110dc28:	210d6f04 	addi	r4,r4,13756
8110dc2c:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						break;
8110dc30:	00002b06 	br	8110dce0 <vPusMebInTaskRunningMode+0x6b4>
					case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8110dc34:	d0a05517 	ldw	r2,-32428(gp)
8110dc38:	e0fffe0b 	ldhu	r3,-8(fp)
8110dc3c:	180d883a 	mov	r6,r3
8110dc40:	01604534 	movhi	r5,33044
8110dc44:	294d2a04 	addi	r5,r5,13480
8110dc48:	1009883a 	mov	r4,r2
8110dc4c:	1116c1c0 	call	81116c1c <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_RMAP_CONFIG_UPDATE \n");
8110dc50:	d0a05517 	ldw	r2,-32428(gp)
8110dc54:	100f883a 	mov	r7,r2
8110dc58:	01800a04 	movi	r6,40
8110dc5c:	01400044 	movi	r5,1
8110dc60:	01204534 	movhi	r4,33044
8110dc64:	210d7804 	addi	r4,r4,13792
8110dc68:	11172b80 	call	811172b8 <fwrite>
							fprintf(fp,"WARNING: Operation Forbiden in Meb Running Mode. \n\n");
8110dc6c:	d0a05517 	ldw	r2,-32428(gp)
8110dc70:	100f883a 	mov	r7,r2
8110dc74:	01800cc4 	movi	r6,51
8110dc78:	01400044 	movi	r5,1
8110dc7c:	01204534 	movhi	r4,33044
8110dc80:	210db804 	addi	r4,r4,14048
8110dc84:	11172b80 	call	811172b8 <fwrite>
						#endif

						/* Do nothing */
						/* Return a PUS error? */

						break;
8110dc88:	00001506 	br	8110dce0 <vPusMebInTaskRunningMode+0x6b4>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
8110dc8c:	d0e05517 	ldw	r3,-32428(gp)
8110dc90:	00a04574 	movhi	r2,33045
8110dc94:	10a1f604 	addi	r2,r2,-30760
8110dc98:	1080030b 	ldhu	r2,12(r2)
8110dc9c:	113fffcc 	andi	r4,r2,65535
8110dca0:	00a04574 	movhi	r2,33045
8110dca4:	10a1f604 	addi	r2,r2,-30760
8110dca8:	1080038b 	ldhu	r2,14(r2)
8110dcac:	117fffcc 	andi	r5,r2,65535
8110dcb0:	00a04574 	movhi	r2,33045
8110dcb4:	10a1f604 	addi	r2,r2,-30760
8110dcb8:	1080040b 	ldhu	r2,16(r2)
8110dcbc:	10bfffcc 	andi	r2,r2,65535
8110dcc0:	d8800015 	stw	r2,0(sp)
8110dcc4:	280f883a 	mov	r7,r5
8110dcc8:	200d883a 	mov	r6,r4
8110dccc:	01604534 	movhi	r5,33044
8110dcd0:	294d1604 	addi	r5,r5,13400
8110dcd4:	1809883a 	mov	r4,r3
8110dcd8:	1116c1c0 	call	81116c1c <fprintf>
						#endif

						break;
8110dcdc:	0001883a 	nop
				}
				break;
8110dce0:	0001883a 	nop
			default:
				break;
		}
	}
}
8110dce4:	0001883a 	nop
8110dce8:	e037883a 	mov	sp,fp
8110dcec:	dfc00117 	ldw	ra,4(sp)
8110dcf0:	df000017 	ldw	fp,0(sp)
8110dcf4:	dec00204 	addi	sp,sp,8
8110dcf8:	f800283a 	ret

8110dcfc <vSendCmdQToNFeeCTRL>:

void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110dcfc:	defff904 	addi	sp,sp,-28
8110dd00:	de00012e 	bgeu	sp,et,8110dd08 <vSendCmdQToNFeeCTRL+0xc>
8110dd04:	003b68fa 	trap	3
8110dd08:	dfc00615 	stw	ra,24(sp)
8110dd0c:	df000515 	stw	fp,20(sp)
8110dd10:	df000504 	addi	fp,sp,20
8110dd14:	2807883a 	mov	r3,r5
8110dd18:	3005883a 	mov	r2,r6
8110dd1c:	e13ffd05 	stb	r4,-12(fp)
8110dd20:	e0fffe05 	stb	r3,-8(fp)
8110dd24:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110dd28:	00800404 	movi	r2,16
8110dd2c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110dd30:	e0bffd03 	ldbu	r2,-12(fp)
8110dd34:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110dd38:	e0bffe03 	ldbu	r2,-8(fp)
8110dd3c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110dd40:	e0bfff03 	ldbu	r2,-4(fp)
8110dd44:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8110dd48:	d0a04a17 	ldw	r2,-32472(gp)
8110dd4c:	e0fffc17 	ldw	r3,-16(fp)
8110dd50:	180b883a 	mov	r5,r3
8110dd54:	1009883a 	mov	r4,r2
8110dd58:	11342080 	call	81134208 <OSQPost>
8110dd5c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110dd60:	e0bffb03 	ldbu	r2,-20(fp)
8110dd64:	10000126 	beq	r2,zero,8110dd6c <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
8110dd68:	1113df40 	call	81113df4 <vFailSendMsgFeeCTRL>
	}

}
8110dd6c:	0001883a 	nop
8110dd70:	e037883a 	mov	sp,fp
8110dd74:	dfc00117 	ldw	ra,4(sp)
8110dd78:	df000017 	ldw	fp,0(sp)
8110dd7c:	dec00204 	addi	sp,sp,8
8110dd80:	f800283a 	ret

8110dd84 <vSendCmdQToNFeeCTRL_GEN>:

/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110dd84:	defff804 	addi	sp,sp,-32
8110dd88:	de00012e 	bgeu	sp,et,8110dd90 <vSendCmdQToNFeeCTRL_GEN+0xc>
8110dd8c:	003b68fa 	trap	3
8110dd90:	dfc00715 	stw	ra,28(sp)
8110dd94:	df000615 	stw	fp,24(sp)
8110dd98:	df000604 	addi	fp,sp,24
8110dd9c:	2011883a 	mov	r8,r4
8110dda0:	2809883a 	mov	r4,r5
8110dda4:	3007883a 	mov	r3,r6
8110dda8:	3805883a 	mov	r2,r7
8110ddac:	e23ffc05 	stb	r8,-16(fp)
8110ddb0:	e13ffd05 	stb	r4,-12(fp)
8110ddb4:	e0fffe05 	stb	r3,-8(fp)
8110ddb8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
8110ddbc:	e0bffc03 	ldbu	r2,-16(fp)
8110ddc0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110ddc4:	e0bffd03 	ldbu	r2,-12(fp)
8110ddc8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110ddcc:	e0bffe03 	ldbu	r2,-8(fp)
8110ddd0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110ddd4:	e0bfff03 	ldbu	r2,-4(fp)
8110ddd8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8110dddc:	d0a04a17 	ldw	r2,-32472(gp)
8110dde0:	e0fffb17 	ldw	r3,-20(fp)
8110dde4:	180b883a 	mov	r5,r3
8110dde8:	1009883a 	mov	r4,r2
8110ddec:	11342080 	call	81134208 <OSQPost>
8110ddf0:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110ddf4:	e0bffa03 	ldbu	r2,-24(fp)
8110ddf8:	10000126 	beq	r2,zero,8110de00 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
8110ddfc:	1113df40 	call	81113df4 <vFailSendMsgFeeCTRL>
	}

}
8110de00:	0001883a 	nop
8110de04:	e037883a 	mov	sp,fp
8110de08:	dfc00117 	ldw	ra,4(sp)
8110de0c:	df000017 	ldw	fp,0(sp)
8110de10:	dec00204 	addi	sp,sp,8
8110de14:	f800283a 	ret

8110de18 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110de18:	defff904 	addi	sp,sp,-28
8110de1c:	de00012e 	bgeu	sp,et,8110de24 <vSendCmdQToDataCTRL+0xc>
8110de20:	003b68fa 	trap	3
8110de24:	dfc00615 	stw	ra,24(sp)
8110de28:	df000515 	stw	fp,20(sp)
8110de2c:	df000504 	addi	fp,sp,20
8110de30:	2807883a 	mov	r3,r5
8110de34:	3005883a 	mov	r2,r6
8110de38:	e13ffd05 	stb	r4,-12(fp)
8110de3c:	e0fffe05 	stb	r3,-8(fp)
8110de40:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
8110de44:	00800804 	movi	r2,32
8110de48:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110de4c:	e0bffd03 	ldbu	r2,-12(fp)
8110de50:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110de54:	e0bffe03 	ldbu	r2,-8(fp)
8110de58:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110de5c:	e0bfff03 	ldbu	r2,-4(fp)
8110de60:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
8110de64:	d0a04917 	ldw	r2,-32476(gp)
8110de68:	e0fffc17 	ldw	r3,-16(fp)
8110de6c:	180b883a 	mov	r5,r3
8110de70:	1009883a 	mov	r4,r2
8110de74:	11342080 	call	81134208 <OSQPost>
8110de78:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110de7c:	e0bffb03 	ldbu	r2,-20(fp)
8110de80:	10000126 	beq	r2,zero,8110de88 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgFeeCTRL();
8110de84:	1113df40 	call	81113df4 <vFailSendMsgFeeCTRL>
	}

}
8110de88:	0001883a 	nop
8110de8c:	e037883a 	mov	sp,fp
8110de90:	dfc00117 	ldw	ra,4(sp)
8110de94:	df000017 	ldw	fp,0(sp)
8110de98:	dec00204 	addi	sp,sp,8
8110de9c:	f800283a 	ret

8110dea0 <vMebChangeToConfig>:

void vMebChangeToConfig( TSimucam_MEB *pxMebCLocal ) {
8110dea0:	defffd04 	addi	sp,sp,-12
8110dea4:	de00012e 	bgeu	sp,et,8110deac <vMebChangeToConfig+0xc>
8110dea8:	003b68fa 	trap	3
8110deac:	dfc00215 	stw	ra,8(sp)
8110deb0:	df000115 	stw	fp,4(sp)
8110deb4:	df000104 	addi	fp,sp,4
8110deb8:	e13fff15 	stw	r4,-4(fp)
	vEvtChangeMebMode(pxMebCLocal->eMode, sMebConfig);
8110debc:	e0bfff17 	ldw	r2,-4(fp)
8110dec0:	10800117 	ldw	r2,4(r2)
8110dec4:	000b883a 	mov	r5,zero
8110dec8:	1009883a 	mov	r4,r2
8110decc:	1113ed80 	call	81113ed8 <vEvtChangeMebMode>
	pxMebCLocal->eMode = sMebConfig;
8110ded0:	e0bfff17 	ldw	r2,-4(fp)
8110ded4:	10000115 	stw	zero,4(r2)

/*todo: URGENTE: Passar todos os FEE para modo de configurao  */
/*todo: URGENTE: Data Controller e NFEE COntroller tambm  */

	vSendCmdQToNFeeCTRL( M_NFC_CONFIG, 0, 0 );
8110ded8:	000d883a 	mov	r6,zero
8110dedc:	000b883a 	mov	r5,zero
8110dee0:	01000044 	movi	r4,1
8110dee4:	110dcfc0 	call	8110dcfc <vSendCmdQToNFeeCTRL>
	vSendCmdQToDataCTRL( M_DATA_CONFIG, 0, 0 );
8110dee8:	000d883a 	mov	r6,zero
8110deec:	000b883a 	mov	r5,zero
8110def0:	01000044 	movi	r4,1
8110def4:	110de180 	call	8110de18 <vSendCmdQToDataCTRL>

	/*todo: Para a gerao do Sync  */


}
8110def8:	0001883a 	nop
8110defc:	e037883a 	mov	sp,fp
8110df00:	dfc00117 	ldw	ra,4(sp)
8110df04:	df000017 	ldw	fp,0(sp)
8110df08:	dec00204 	addi	sp,sp,8
8110df0c:	f800283a 	ret

8110df10 <vMebChangeToRunning>:

void vMebChangeToRunning( TSimucam_MEB *pxMebCLocal ) {
8110df10:	defffd04 	addi	sp,sp,-12
8110df14:	de00012e 	bgeu	sp,et,8110df1c <vMebChangeToRunning+0xc>
8110df18:	003b68fa 	trap	3
8110df1c:	dfc00215 	stw	ra,8(sp)
8110df20:	df000115 	stw	fp,4(sp)
8110df24:	df000104 	addi	fp,sp,4
8110df28:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"MEB Task: Changing to RUN Mode\n");
8110df2c:	d0a05517 	ldw	r2,-32428(gp)
8110df30:	100f883a 	mov	r7,r2
8110df34:	018007c4 	movi	r6,31
8110df38:	01400044 	movi	r5,1
8110df3c:	01204534 	movhi	r4,33044
8110df40:	210dc504 	addi	r4,r4,14100
8110df44:	11172b80 	call	811172b8 <fwrite>
	#endif

	vEvtChangeMebMode(pxMebCLocal->eMode, sRun);
8110df48:	e0bfff17 	ldw	r2,-4(fp)
8110df4c:	10800117 	ldw	r2,4(r2)
8110df50:	01400044 	movi	r5,1
8110df54:	1009883a 	mov	r4,r2
8110df58:	1113ed80 	call	81113ed8 <vEvtChangeMebMode>
	pxMebCLocal->eMode = sRun;
8110df5c:	e0bfff17 	ldw	r2,-4(fp)
8110df60:	00c00044 	movi	r3,1
8110df64:	10c00115 	stw	r3,4(r2)

	vSendCmdQToNFeeCTRL( M_NFC_RUN, 0, 0 );
8110df68:	000d883a 	mov	r6,zero
8110df6c:	000b883a 	mov	r5,zero
8110df70:	01000084 	movi	r4,2
8110df74:	110dcfc0 	call	8110dcfc <vSendCmdQToNFeeCTRL>
	vSendCmdQToDataCTRL( M_DATA_RUN, 0, 0 );
8110df78:	000d883a 	mov	r6,zero
8110df7c:	000b883a 	mov	r5,zero
8110df80:	01000084 	movi	r4,2
8110df84:	110de180 	call	8110de18 <vSendCmdQToDataCTRL>


}
8110df88:	0001883a 	nop
8110df8c:	e037883a 	mov	sp,fp
8110df90:	dfc00117 	ldw	ra,4(sp)
8110df94:	df000017 	ldw	fp,0(sp)
8110df98:	dec00204 	addi	sp,sp,8
8110df9c:	f800283a 	ret

8110dfa0 <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
8110dfa0:	defff804 	addi	sp,sp,-32
8110dfa4:	de00012e 	bgeu	sp,et,8110dfac <vStackMonitor+0xc>
8110dfa8:	003b68fa 	trap	3
8110dfac:	dfc00715 	stw	ra,28(sp)
8110dfb0:	df000615 	stw	fp,24(sp)
8110dfb4:	df000604 	addi	fp,sp,24
8110dfb8:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
8110dfbc:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
8110dfc0:	d0a05517 	ldw	r2,-32428(gp)
8110dfc4:	100f883a 	mov	r7,r2
8110dfc8:	018006c4 	movi	r6,27
8110dfcc:	01400044 	movi	r5,1
8110dfd0:	01204534 	movhi	r4,33044
8110dfd4:	210dcd04 	addi	r4,r4,14132
8110dfd8:	11172b80 	call	811172b8 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
8110dfdc:	d0a05517 	ldw	r2,-32428(gp)
8110dfe0:	100f883a 	mov	r7,r2
8110dfe4:	01800b04 	movi	r6,44
8110dfe8:	01400044 	movi	r5,1
8110dfec:	01204534 	movhi	r4,33044
8110dff0:	210dd404 	addi	r4,r4,14160
8110dff4:	11172b80 	call	811172b8 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
8110dff8:	d0a05517 	ldw	r2,-32428(gp)
8110dffc:	100f883a 	mov	r7,r2
8110e000:	01800f84 	movi	r6,62
8110e004:	01400044 	movi	r5,1
8110e008:	01204534 	movhi	r4,33044
8110e00c:	210de004 	addi	r4,r4,14208
8110e010:	11172b80 	call	811172b8 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
8110e014:	e0bffd04 	addi	r2,fp,-12
8110e018:	100b883a 	mov	r5,r2
8110e01c:	01000804 	movi	r4,32
8110e020:	11364780 	call	81136478 <OSTaskStkChk>
8110e024:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
8110e028:	e0bffc03 	ldbu	r2,-16(fp)
8110e02c:	10000f1e 	bne	r2,zero,8110e06c <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e030:	d1205517 	ldw	r4,-32428(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
8110e034:	e0fffd17 	ldw	r3,-12(fp)
8110e038:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e03c:	188b883a 	add	r5,r3,r2
8110e040:	e0bffd17 	ldw	r2,-12(fp)
8110e044:	e0fffe17 	ldw	r3,-8(fp)
8110e048:	d8c00115 	stw	r3,4(sp)
8110e04c:	d8800015 	stw	r2,0(sp)
8110e050:	280f883a 	mov	r7,r5
8110e054:	01a04534 	movhi	r6,33044
8110e058:	318df004 	addi	r6,r6,14272
8110e05c:	01604534 	movhi	r5,33044
8110e060:	294df404 	addi	r5,r5,14288
8110e064:	1116c1c0 	call	81116c1c <fprintf>
8110e068:	00000706 	br	8110e088 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
8110e06c:	d0a05517 	ldw	r2,-32428(gp)
8110e070:	100f883a 	mov	r7,r2
8110e074:	01800904 	movi	r6,36
8110e078:	01400044 	movi	r5,1
8110e07c:	01204534 	movhi	r4,33044
8110e080:	210e0304 	addi	r4,r4,14348
8110e084:	11172b80 	call	811172b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
8110e088:	e0bffd04 	addi	r2,fp,-12
8110e08c:	100b883a 	mov	r5,r2
8110e090:	01000784 	movi	r4,30
8110e094:	11364780 	call	81136478 <OSTaskStkChk>
8110e098:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e09c:	e0bffc03 	ldbu	r2,-16(fp)
8110e0a0:	10000f1e 	bne	r2,zero,8110e0e0 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e0a4:	d1205517 	ldw	r4,-32428(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
8110e0a8:	e0fffd17 	ldw	r3,-12(fp)
8110e0ac:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e0b0:	188b883a 	add	r5,r3,r2
8110e0b4:	e0bffd17 	ldw	r2,-12(fp)
8110e0b8:	e0fffe17 	ldw	r3,-8(fp)
8110e0bc:	d8c00115 	stw	r3,4(sp)
8110e0c0:	d8800015 	stw	r2,0(sp)
8110e0c4:	280f883a 	mov	r7,r5
8110e0c8:	01a04534 	movhi	r6,33044
8110e0cc:	318e0d04 	addi	r6,r6,14388
8110e0d0:	01604534 	movhi	r5,33044
8110e0d4:	294df404 	addi	r5,r5,14288
8110e0d8:	1116c1c0 	call	81116c1c <fprintf>
8110e0dc:	00000706 	br	8110e0fc <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
8110e0e0:	d0a05517 	ldw	r2,-32428(gp)
8110e0e4:	100f883a 	mov	r7,r2
8110e0e8:	01800984 	movi	r6,38
8110e0ec:	01400044 	movi	r5,1
8110e0f0:	01204534 	movhi	r4,33044
8110e0f4:	210e1104 	addi	r4,r4,14404
8110e0f8:	11172b80 	call	811172b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
8110e0fc:	e0bffd04 	addi	r2,fp,-12
8110e100:	100b883a 	mov	r5,r2
8110e104:	01000704 	movi	r4,28
8110e108:	11364780 	call	81136478 <OSTaskStkChk>
8110e10c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e110:	e0bffc03 	ldbu	r2,-16(fp)
8110e114:	10000f1e 	bne	r2,zero,8110e154 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e118:	d1205517 	ldw	r4,-32428(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
8110e11c:	e0fffd17 	ldw	r3,-12(fp)
8110e120:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e124:	188b883a 	add	r5,r3,r2
8110e128:	e0bffd17 	ldw	r2,-12(fp)
8110e12c:	e0fffe17 	ldw	r3,-8(fp)
8110e130:	d8c00115 	stw	r3,4(sp)
8110e134:	d8800015 	stw	r2,0(sp)
8110e138:	280f883a 	mov	r7,r5
8110e13c:	01a04534 	movhi	r6,33044
8110e140:	318e1b04 	addi	r6,r6,14444
8110e144:	01604534 	movhi	r5,33044
8110e148:	294df404 	addi	r5,r5,14288
8110e14c:	1116c1c0 	call	81116c1c <fprintf>
8110e150:	00000706 	br	8110e170 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
8110e154:	d0a05517 	ldw	r2,-32428(gp)
8110e158:	100f883a 	mov	r7,r2
8110e15c:	01800884 	movi	r6,34
8110e160:	01400044 	movi	r5,1
8110e164:	01204534 	movhi	r4,33044
8110e168:	210e1e04 	addi	r4,r4,14456
8110e16c:	11172b80 	call	811172b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
8110e170:	e0bffd04 	addi	r2,fp,-12
8110e174:	100b883a 	mov	r5,r2
8110e178:	010006c4 	movi	r4,27
8110e17c:	11364780 	call	81136478 <OSTaskStkChk>
8110e180:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e184:	e0bffc03 	ldbu	r2,-16(fp)
8110e188:	10000f1e 	bne	r2,zero,8110e1c8 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e18c:	d1205517 	ldw	r4,-32428(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
8110e190:	e0fffd17 	ldw	r3,-12(fp)
8110e194:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e198:	188b883a 	add	r5,r3,r2
8110e19c:	e0bffd17 	ldw	r2,-12(fp)
8110e1a0:	e0fffe17 	ldw	r3,-8(fp)
8110e1a4:	d8c00115 	stw	r3,4(sp)
8110e1a8:	d8800015 	stw	r2,0(sp)
8110e1ac:	280f883a 	mov	r7,r5
8110e1b0:	01a04534 	movhi	r6,33044
8110e1b4:	318e2704 	addi	r6,r6,14492
8110e1b8:	01604534 	movhi	r5,33044
8110e1bc:	294df404 	addi	r5,r5,14288
8110e1c0:	1116c1c0 	call	81116c1c <fprintf>
8110e1c4:	00000706 	br	8110e1e4 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
8110e1c8:	d0a05517 	ldw	r2,-32428(gp)
8110e1cc:	100f883a 	mov	r7,r2
8110e1d0:	018008c4 	movi	r6,35
8110e1d4:	01400044 	movi	r5,1
8110e1d8:	01204534 	movhi	r4,33044
8110e1dc:	210e2b04 	addi	r4,r4,14508
8110e1e0:	11172b80 	call	811172b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
8110e1e4:	e0bffd04 	addi	r2,fp,-12
8110e1e8:	100b883a 	mov	r5,r2
8110e1ec:	01000684 	movi	r4,26
8110e1f0:	11364780 	call	81136478 <OSTaskStkChk>
8110e1f4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e1f8:	e0bffc03 	ldbu	r2,-16(fp)
8110e1fc:	10000f1e 	bne	r2,zero,8110e23c <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e200:	d1205517 	ldw	r4,-32428(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
8110e204:	e0fffd17 	ldw	r3,-12(fp)
8110e208:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e20c:	188b883a 	add	r5,r3,r2
8110e210:	e0bffd17 	ldw	r2,-12(fp)
8110e214:	e0fffe17 	ldw	r3,-8(fp)
8110e218:	d8c00115 	stw	r3,4(sp)
8110e21c:	d8800015 	stw	r2,0(sp)
8110e220:	280f883a 	mov	r7,r5
8110e224:	01a04534 	movhi	r6,33044
8110e228:	318e3404 	addi	r6,r6,14544
8110e22c:	01604534 	movhi	r5,33044
8110e230:	294df404 	addi	r5,r5,14288
8110e234:	1116c1c0 	call	81116c1c <fprintf>
8110e238:	00000706 	br	8110e258 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
8110e23c:	d0a05517 	ldw	r2,-32428(gp)
8110e240:	100f883a 	mov	r7,r2
8110e244:	01800884 	movi	r6,34
8110e248:	01400044 	movi	r5,1
8110e24c:	01204534 	movhi	r4,33044
8110e250:	210e3704 	addi	r4,r4,14556
8110e254:	11172b80 	call	811172b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
8110e258:	e0bffd04 	addi	r2,fp,-12
8110e25c:	100b883a 	mov	r5,r2
8110e260:	01000644 	movi	r4,25
8110e264:	11364780 	call	81136478 <OSTaskStkChk>
8110e268:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e26c:	e0bffc03 	ldbu	r2,-16(fp)
8110e270:	10000f1e 	bne	r2,zero,8110e2b0 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e274:	d1205517 	ldw	r4,-32428(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
8110e278:	e0fffd17 	ldw	r3,-12(fp)
8110e27c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e280:	188b883a 	add	r5,r3,r2
8110e284:	e0bffd17 	ldw	r2,-12(fp)
8110e288:	e0fffe17 	ldw	r3,-8(fp)
8110e28c:	d8c00115 	stw	r3,4(sp)
8110e290:	d8800015 	stw	r2,0(sp)
8110e294:	280f883a 	mov	r7,r5
8110e298:	01a04534 	movhi	r6,33044
8110e29c:	318e4004 	addi	r6,r6,14592
8110e2a0:	01604534 	movhi	r5,33044
8110e2a4:	294df404 	addi	r5,r5,14288
8110e2a8:	1116c1c0 	call	81116c1c <fprintf>
8110e2ac:	00000706 	br	8110e2cc <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
8110e2b0:	d0a05517 	ldw	r2,-32428(gp)
8110e2b4:	100f883a 	mov	r7,r2
8110e2b8:	01800884 	movi	r6,34
8110e2bc:	01400044 	movi	r5,1
8110e2c0:	01204534 	movhi	r4,33044
8110e2c4:	210e4304 	addi	r4,r4,14604
8110e2c8:	11172b80 	call	811172b8 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
8110e2cc:	e0bffd04 	addi	r2,fp,-12
8110e2d0:	100b883a 	mov	r5,r2
8110e2d4:	01000044 	movi	r4,1
8110e2d8:	11364780 	call	81136478 <OSTaskStkChk>
8110e2dc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e2e0:	e0bffc03 	ldbu	r2,-16(fp)
8110e2e4:	10000f1e 	bne	r2,zero,8110e324 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e2e8:	d1205517 	ldw	r4,-32428(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
8110e2ec:	e0fffd17 	ldw	r3,-12(fp)
8110e2f0:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e2f4:	188b883a 	add	r5,r3,r2
8110e2f8:	e0bffd17 	ldw	r2,-12(fp)
8110e2fc:	e0fffe17 	ldw	r3,-8(fp)
8110e300:	d8c00115 	stw	r3,4(sp)
8110e304:	d8800015 	stw	r2,0(sp)
8110e308:	280f883a 	mov	r7,r5
8110e30c:	01a04534 	movhi	r6,33044
8110e310:	318e4c04 	addi	r6,r6,14640
8110e314:	01604534 	movhi	r5,33044
8110e318:	294df404 	addi	r5,r5,14288
8110e31c:	1116c1c0 	call	81116c1c <fprintf>
8110e320:	00000706 	br	8110e340 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
8110e324:	d0a05517 	ldw	r2,-32428(gp)
8110e328:	100f883a 	mov	r7,r2
8110e32c:	01800804 	movi	r6,32
8110e330:	01400044 	movi	r5,1
8110e334:	01204534 	movhi	r4,33044
8110e338:	210e4f04 	addi	r4,r4,14652
8110e33c:	11172b80 	call	811172b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
8110e340:	e0bffd04 	addi	r2,fp,-12
8110e344:	100b883a 	mov	r5,r2
8110e348:	01000244 	movi	r4,9
8110e34c:	11364780 	call	81136478 <OSTaskStkChk>
8110e350:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e354:	e0bffc03 	ldbu	r2,-16(fp)
8110e358:	10000f1e 	bne	r2,zero,8110e398 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e35c:	d1205517 	ldw	r4,-32428(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
8110e360:	e0fffd17 	ldw	r3,-12(fp)
8110e364:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e368:	188b883a 	add	r5,r3,r2
8110e36c:	e0bffd17 	ldw	r2,-12(fp)
8110e370:	e0fffe17 	ldw	r3,-8(fp)
8110e374:	d8c00115 	stw	r3,4(sp)
8110e378:	d8800015 	stw	r2,0(sp)
8110e37c:	280f883a 	mov	r7,r5
8110e380:	01a04534 	movhi	r6,33044
8110e384:	318e5804 	addi	r6,r6,14688
8110e388:	01604534 	movhi	r5,33044
8110e38c:	294df404 	addi	r5,r5,14288
8110e390:	1116c1c0 	call	81116c1c <fprintf>
8110e394:	00000706 	br	8110e3b4 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
8110e398:	d0a05517 	ldw	r2,-32428(gp)
8110e39c:	100f883a 	mov	r7,r2
8110e3a0:	018008c4 	movi	r6,35
8110e3a4:	01400044 	movi	r5,1
8110e3a8:	01204534 	movhi	r4,33044
8110e3ac:	210e5b04 	addi	r4,r4,14700
8110e3b0:	11172b80 	call	811172b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
8110e3b4:	e0bffd04 	addi	r2,fp,-12
8110e3b8:	100b883a 	mov	r5,r2
8110e3bc:	01000284 	movi	r4,10
8110e3c0:	11364780 	call	81136478 <OSTaskStkChk>
8110e3c4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e3c8:	e0bffc03 	ldbu	r2,-16(fp)
8110e3cc:	10000f1e 	bne	r2,zero,8110e40c <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e3d0:	d1205517 	ldw	r4,-32428(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
8110e3d4:	e0fffd17 	ldw	r3,-12(fp)
8110e3d8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e3dc:	188b883a 	add	r5,r3,r2
8110e3e0:	e0bffd17 	ldw	r2,-12(fp)
8110e3e4:	e0fffe17 	ldw	r3,-8(fp)
8110e3e8:	d8c00115 	stw	r3,4(sp)
8110e3ec:	d8800015 	stw	r2,0(sp)
8110e3f0:	280f883a 	mov	r7,r5
8110e3f4:	01a04534 	movhi	r6,33044
8110e3f8:	318e6404 	addi	r6,r6,14736
8110e3fc:	01604534 	movhi	r5,33044
8110e400:	294df404 	addi	r5,r5,14288
8110e404:	1116c1c0 	call	81116c1c <fprintf>
8110e408:	00000706 	br	8110e428 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
8110e40c:	d0a05517 	ldw	r2,-32428(gp)
8110e410:	100f883a 	mov	r7,r2
8110e414:	018008c4 	movi	r6,35
8110e418:	01400044 	movi	r5,1
8110e41c:	01204534 	movhi	r4,33044
8110e420:	210e6704 	addi	r4,r4,14748
8110e424:	11172b80 	call	811172b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
8110e428:	e0bffd04 	addi	r2,fp,-12
8110e42c:	100b883a 	mov	r5,r2
8110e430:	010002c4 	movi	r4,11
8110e434:	11364780 	call	81136478 <OSTaskStkChk>
8110e438:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e43c:	e0bffc03 	ldbu	r2,-16(fp)
8110e440:	10000f1e 	bne	r2,zero,8110e480 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e444:	d1205517 	ldw	r4,-32428(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
8110e448:	e0fffd17 	ldw	r3,-12(fp)
8110e44c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e450:	188b883a 	add	r5,r3,r2
8110e454:	e0bffd17 	ldw	r2,-12(fp)
8110e458:	e0fffe17 	ldw	r3,-8(fp)
8110e45c:	d8c00115 	stw	r3,4(sp)
8110e460:	d8800015 	stw	r2,0(sp)
8110e464:	280f883a 	mov	r7,r5
8110e468:	01a04534 	movhi	r6,33044
8110e46c:	318e7004 	addi	r6,r6,14784
8110e470:	01604534 	movhi	r5,33044
8110e474:	294df404 	addi	r5,r5,14288
8110e478:	1116c1c0 	call	81116c1c <fprintf>
8110e47c:	00000706 	br	8110e49c <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
8110e480:	d0a05517 	ldw	r2,-32428(gp)
8110e484:	100f883a 	mov	r7,r2
8110e488:	018008c4 	movi	r6,35
8110e48c:	01400044 	movi	r5,1
8110e490:	01204534 	movhi	r4,33044
8110e494:	210e7304 	addi	r4,r4,14796
8110e498:	11172b80 	call	811172b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
8110e49c:	e0bffd04 	addi	r2,fp,-12
8110e4a0:	100b883a 	mov	r5,r2
8110e4a4:	01000304 	movi	r4,12
8110e4a8:	11364780 	call	81136478 <OSTaskStkChk>
8110e4ac:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e4b0:	e0bffc03 	ldbu	r2,-16(fp)
8110e4b4:	10000f1e 	bne	r2,zero,8110e4f4 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e4b8:	d1205517 	ldw	r4,-32428(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
8110e4bc:	e0fffd17 	ldw	r3,-12(fp)
8110e4c0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e4c4:	188b883a 	add	r5,r3,r2
8110e4c8:	e0bffd17 	ldw	r2,-12(fp)
8110e4cc:	e0fffe17 	ldw	r3,-8(fp)
8110e4d0:	d8c00115 	stw	r3,4(sp)
8110e4d4:	d8800015 	stw	r2,0(sp)
8110e4d8:	280f883a 	mov	r7,r5
8110e4dc:	01a04534 	movhi	r6,33044
8110e4e0:	318e7c04 	addi	r6,r6,14832
8110e4e4:	01604534 	movhi	r5,33044
8110e4e8:	294df404 	addi	r5,r5,14288
8110e4ec:	1116c1c0 	call	81116c1c <fprintf>
8110e4f0:	00000706 	br	8110e510 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
8110e4f4:	d0a05517 	ldw	r2,-32428(gp)
8110e4f8:	100f883a 	mov	r7,r2
8110e4fc:	018008c4 	movi	r6,35
8110e500:	01400044 	movi	r5,1
8110e504:	01204534 	movhi	r4,33044
8110e508:	210e7f04 	addi	r4,r4,14844
8110e50c:	11172b80 	call	811172b8 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
8110e510:	e0bffd04 	addi	r2,fp,-12
8110e514:	100b883a 	mov	r5,r2
8110e518:	01000344 	movi	r4,13
8110e51c:	11364780 	call	81136478 <OSTaskStkChk>
8110e520:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e524:	e0bffc03 	ldbu	r2,-16(fp)
8110e528:	10000f1e 	bne	r2,zero,8110e568 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e52c:	d1205517 	ldw	r4,-32428(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
8110e530:	e0fffd17 	ldw	r3,-12(fp)
8110e534:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e538:	188b883a 	add	r5,r3,r2
8110e53c:	e0bffd17 	ldw	r2,-12(fp)
8110e540:	e0fffe17 	ldw	r3,-8(fp)
8110e544:	d8c00115 	stw	r3,4(sp)
8110e548:	d8800015 	stw	r2,0(sp)
8110e54c:	280f883a 	mov	r7,r5
8110e550:	01a04534 	movhi	r6,33044
8110e554:	318e8804 	addi	r6,r6,14880
8110e558:	01604534 	movhi	r5,33044
8110e55c:	294df404 	addi	r5,r5,14288
8110e560:	1116c1c0 	call	81116c1c <fprintf>
8110e564:	00000706 	br	8110e584 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
8110e568:	d0a05517 	ldw	r2,-32428(gp)
8110e56c:	100f883a 	mov	r7,r2
8110e570:	018008c4 	movi	r6,35
8110e574:	01400044 	movi	r5,1
8110e578:	01204534 	movhi	r4,33044
8110e57c:	210e8b04 	addi	r4,r4,14892
8110e580:	11172b80 	call	811172b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
8110e584:	e0bffd04 	addi	r2,fp,-12
8110e588:	100b883a 	mov	r5,r2
8110e58c:	01000384 	movi	r4,14
8110e590:	11364780 	call	81136478 <OSTaskStkChk>
8110e594:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e598:	e0bffc03 	ldbu	r2,-16(fp)
8110e59c:	10000f1e 	bne	r2,zero,8110e5dc <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e5a0:	d1205517 	ldw	r4,-32428(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
8110e5a4:	e0fffd17 	ldw	r3,-12(fp)
8110e5a8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e5ac:	188b883a 	add	r5,r3,r2
8110e5b0:	e0bffd17 	ldw	r2,-12(fp)
8110e5b4:	e0fffe17 	ldw	r3,-8(fp)
8110e5b8:	d8c00115 	stw	r3,4(sp)
8110e5bc:	d8800015 	stw	r2,0(sp)
8110e5c0:	280f883a 	mov	r7,r5
8110e5c4:	01a04534 	movhi	r6,33044
8110e5c8:	318e9404 	addi	r6,r6,14928
8110e5cc:	01604534 	movhi	r5,33044
8110e5d0:	294df404 	addi	r5,r5,14288
8110e5d4:	1116c1c0 	call	81116c1c <fprintf>
8110e5d8:	00000706 	br	8110e5f8 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
8110e5dc:	d0a05517 	ldw	r2,-32428(gp)
8110e5e0:	100f883a 	mov	r7,r2
8110e5e4:	018008c4 	movi	r6,35
8110e5e8:	01400044 	movi	r5,1
8110e5ec:	01204534 	movhi	r4,33044
8110e5f0:	210e9704 	addi	r4,r4,14940
8110e5f4:	11172b80 	call	811172b8 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
8110e5f8:	e0bffd04 	addi	r2,fp,-12
8110e5fc:	100b883a 	mov	r5,r2
8110e600:	01000204 	movi	r4,8
8110e604:	11364780 	call	81136478 <OSTaskStkChk>
8110e608:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e60c:	e0bffc03 	ldbu	r2,-16(fp)
8110e610:	10000f1e 	bne	r2,zero,8110e650 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e614:	d1205517 	ldw	r4,-32428(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
8110e618:	e0fffd17 	ldw	r3,-12(fp)
8110e61c:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e620:	188b883a 	add	r5,r3,r2
8110e624:	e0bffd17 	ldw	r2,-12(fp)
8110e628:	e0fffe17 	ldw	r3,-8(fp)
8110e62c:	d8c00115 	stw	r3,4(sp)
8110e630:	d8800015 	stw	r2,0(sp)
8110e634:	280f883a 	mov	r7,r5
8110e638:	01a04534 	movhi	r6,33044
8110e63c:	318ea004 	addi	r6,r6,14976
8110e640:	01604534 	movhi	r5,33044
8110e644:	294df404 	addi	r5,r5,14288
8110e648:	1116c1c0 	call	81116c1c <fprintf>
8110e64c:	00000706 	br	8110e66c <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
8110e650:	d0a05517 	ldw	r2,-32428(gp)
8110e654:	100f883a 	mov	r7,r2
8110e658:	01800884 	movi	r6,34
8110e65c:	01400044 	movi	r5,1
8110e660:	01204534 	movhi	r4,33044
8110e664:	210ea304 	addi	r4,r4,14988
8110e668:	11172b80 	call	811172b8 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
8110e66c:	e0bffd04 	addi	r2,fp,-12
8110e670:	100b883a 	mov	r5,r2
8110e674:	010001c4 	movi	r4,7
8110e678:	11364780 	call	81136478 <OSTaskStkChk>
8110e67c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e680:	e0bffc03 	ldbu	r2,-16(fp)
8110e684:	10000f1e 	bne	r2,zero,8110e6c4 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e688:	d1205517 	ldw	r4,-32428(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
8110e68c:	e0fffd17 	ldw	r3,-12(fp)
8110e690:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e694:	188b883a 	add	r5,r3,r2
8110e698:	e0bffd17 	ldw	r2,-12(fp)
8110e69c:	e0fffe17 	ldw	r3,-8(fp)
8110e6a0:	d8c00115 	stw	r3,4(sp)
8110e6a4:	d8800015 	stw	r2,0(sp)
8110e6a8:	280f883a 	mov	r7,r5
8110e6ac:	01a04534 	movhi	r6,33044
8110e6b0:	318eac04 	addi	r6,r6,15024
8110e6b4:	01604534 	movhi	r5,33044
8110e6b8:	294df404 	addi	r5,r5,14288
8110e6bc:	1116c1c0 	call	81116c1c <fprintf>
8110e6c0:	00000706 	br	8110e6e0 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
8110e6c4:	d0a05517 	ldw	r2,-32428(gp)
8110e6c8:	100f883a 	mov	r7,r2
8110e6cc:	01800844 	movi	r6,33
8110e6d0:	01400044 	movi	r5,1
8110e6d4:	01204534 	movhi	r4,33044
8110e6d8:	210eaf04 	addi	r4,r4,15036
8110e6dc:	11172b80 	call	811172b8 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
8110e6e0:	e0bffd04 	addi	r2,fp,-12
8110e6e4:	100b883a 	mov	r5,r2
8110e6e8:	01000184 	movi	r4,6
8110e6ec:	11364780 	call	81136478 <OSTaskStkChk>
8110e6f0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8110e6f4:	e0bffc03 	ldbu	r2,-16(fp)
8110e6f8:	10000f1e 	bne	r2,zero,8110e738 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e6fc:	d1205517 	ldw	r4,-32428(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
8110e700:	e0fffd17 	ldw	r3,-12(fp)
8110e704:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8110e708:	188b883a 	add	r5,r3,r2
8110e70c:	e0bffd17 	ldw	r2,-12(fp)
8110e710:	e0fffe17 	ldw	r3,-8(fp)
8110e714:	d8c00115 	stw	r3,4(sp)
8110e718:	d8800015 	stw	r2,0(sp)
8110e71c:	280f883a 	mov	r7,r5
8110e720:	01a04534 	movhi	r6,33044
8110e724:	318eb804 	addi	r6,r6,15072
8110e728:	01604534 	movhi	r5,33044
8110e72c:	294df404 	addi	r5,r5,14288
8110e730:	1116c1c0 	call	81116c1c <fprintf>
8110e734:	00000706 	br	8110e754 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
8110e738:	d0a05517 	ldw	r2,-32428(gp)
8110e73c:	100f883a 	mov	r7,r2
8110e740:	018007c4 	movi	r6,31
8110e744:	01400044 	movi	r5,1
8110e748:	01204534 	movhi	r4,33044
8110e74c:	210ebb04 	addi	r4,r4,15084
8110e750:	11172b80 	call	811172b8 <fwrite>
    	}		


    	fprintf(fp, "\n" );
8110e754:	d0a05517 	ldw	r2,-32428(gp)
8110e758:	100b883a 	mov	r5,r2
8110e75c:	01000284 	movi	r4,10
8110e760:	1116c940 	call	81116c94 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
8110e764:	000f883a 	mov	r7,zero
8110e768:	01800284 	movi	r6,10
8110e76c:	000b883a 	mov	r5,zero
8110e770:	0009883a 	mov	r4,zero
8110e774:	1136adc0 	call	81136adc <OSTimeDlyHMSM>
    }
8110e778:	003e1806 	br	8110dfdc <__reset+0xfb0edfdc>

8110e77c <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
8110e77c:	defffc04 	addi	sp,sp,-16
8110e780:	de00012e 	bgeu	sp,et,8110e788 <vTimeoutCheckerTaskv2+0xc>
8110e784:	003b68fa 	trap	3
8110e788:	dfc00315 	stw	ra,12(sp)
8110e78c:	df000215 	stw	fp,8(sp)
8110e790:	df000204 	addi	fp,sp,8
8110e794:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
8110e798:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
8110e79c:	d0a05517 	ldw	r2,-32428(gp)
8110e7a0:	100f883a 	mov	r7,r2
8110e7a4:	01800844 	movi	r6,33
8110e7a8:	01400044 	movi	r5,1
8110e7ac:	01204534 	movhi	r4,33044
8110e7b0:	210ec304 	addi	r4,r4,15116
8110e7b4:	11172b80 	call	811172b8 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
8110e7b8:	d0a05a17 	ldw	r2,-32408(gp)
8110e7bc:	e1bffe04 	addi	r6,fp,-8
8110e7c0:	000b883a 	mov	r5,zero
8110e7c4:	1009883a 	mov	r4,r2
8110e7c8:	1134cf80 	call	81134cf8 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
8110e7cc:	e0bffe03 	ldbu	r2,-8(fp)
8110e7d0:	10803fcc 	andi	r2,r2,255
8110e7d4:	1000021e 	bne	r2,zero,8110e7e0 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
8110e7d8:	110e7e80 	call	8110e7e8 <vCheck>
8110e7dc:	003ff606 	br	8110e7b8 <__reset+0xfb0ee7b8>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
8110e7e0:	11131200 	call	81113120 <vFailGetBlockingSemTimeoutTask>
        }
    }
8110e7e4:	003ff406 	br	8110e7b8 <__reset+0xfb0ee7b8>

8110e7e8 <vCheck>:
}


void vCheck( void ) {
8110e7e8:	defffd04 	addi	sp,sp,-12
8110e7ec:	de00012e 	bgeu	sp,et,8110e7f4 <vCheck+0xc>
8110e7f0:	003b68fa 	trap	3
8110e7f4:	dfc00215 	stw	ra,8(sp)
8110e7f8:	df000115 	stw	fp,4(sp)
8110e7fc:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
8110e800:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
8110e804:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
8110e808:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110e80c:	d0a05b83 	ldbu	r2,-32402(gp)
8110e810:	10803fcc 	andi	r2,r2,255
8110e814:	10800218 	cmpnei	r2,r2,8
8110e818:	1000021e 	bne	r2,zero,8110e824 <vCheck+0x3c>
8110e81c:	00c00104 	movi	r3,4
8110e820:	00000106 	br	8110e828 <vCheck+0x40>
8110e824:	0007883a 	mov	r3,zero
8110e828:	d0a06603 	ldbu	r2,-32360(gp)
8110e82c:	10803fcc 	andi	r2,r2,255
8110e830:	10800218 	cmpnei	r2,r2,8
8110e834:	1000021e 	bne	r2,zero,8110e840 <vCheck+0x58>
8110e838:	00800084 	movi	r2,2
8110e83c:	00000106 	br	8110e844 <vCheck+0x5c>
8110e840:	0005883a 	mov	r2,zero
8110e844:	1884b03a 	or	r2,r3,r2
8110e848:	1007883a 	mov	r3,r2
8110e84c:	d0a06643 	ldbu	r2,-32359(gp)
8110e850:	10803fcc 	andi	r2,r2,255
8110e854:	108001a0 	cmpeqi	r2,r2,6
8110e858:	1884b03a 	or	r2,r3,r2
8110e85c:	1007883a 	mov	r3,r2
8110e860:	e0bfff03 	ldbu	r2,-4(fp)
8110e864:	1884b03a 	or	r2,r3,r2
8110e868:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
8110e86c:	e0bfff03 	ldbu	r2,-4(fp)
8110e870:	108001d8 	cmpnei	r2,r2,7
8110e874:	10003726 	beq	r2,zero,8110e954 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
8110e878:	d0a06517 	ldw	r2,-32364(gp)
8110e87c:	e0ffff44 	addi	r3,fp,-3
8110e880:	180d883a 	mov	r6,r3
8110e884:	000b883a 	mov	r5,zero
8110e888:	1009883a 	mov	r4,r2
8110e88c:	1132cec0 	call	81132cec <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
8110e890:	e0bfff43 	ldbu	r2,-3(fp)
8110e894:	10803fcc 	andi	r2,r2,255
8110e898:	10000826 	beq	r2,zero,8110e8bc <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
8110e89c:	d0a05517 	ldw	r2,-32428(gp)
8110e8a0:	100f883a 	mov	r7,r2
8110e8a4:	01800f04 	movi	r6,60
8110e8a8:	01400044 	movi	r5,1
8110e8ac:	01204534 	movhi	r4,33044
8110e8b0:	210ecc04 	addi	r4,r4,15152
8110e8b4:	11172b80 	call	811172b8 <fwrite>
		#endif
        return;
8110e8b8:	00002706 	br	8110e958 <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8110e8bc:	e0bfff03 	ldbu	r2,-4(fp)
8110e8c0:	1080004c 	andi	r2,r2,1
8110e8c4:	10803fcc 	andi	r2,r2,255
8110e8c8:	1000021e 	bne	r2,zero,8110e8d4 <vCheck+0xec>
        vCheckRetransmission128();
8110e8cc:	110e96c0 	call	8110e96c <vCheckRetransmission128>
8110e8d0:	00000506 	br	8110e8e8 <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
8110e8d4:	01800604 	movi	r6,24
8110e8d8:	000b883a 	mov	r5,zero
8110e8dc:	01204574 	movhi	r4,33045
8110e8e0:	21124504 	addi	r4,r4,18708
8110e8e4:	1117e1c0 	call	81117e1c <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
8110e8e8:	e0bfff03 	ldbu	r2,-4(fp)
8110e8ec:	1080008c 	andi	r2,r2,2
8110e8f0:	10803fcc 	andi	r2,r2,255
8110e8f4:	1000021e 	bne	r2,zero,8110e900 <vCheck+0x118>
        vCheckRetransmission64();
8110e8f8:	110ebf00 	call	8110ebf0 <vCheckRetransmission64>
8110e8fc:	00000506 	br	8110e914 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
8110e900:	01800804 	movi	r6,32
8110e904:	000b883a 	mov	r5,zero
8110e908:	01204574 	movhi	r4,33045
8110e90c:	21124b04 	addi	r4,r4,18732
8110e910:	1117e1c0 	call	81117e1c <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
8110e914:	e0bfff03 	ldbu	r2,-4(fp)
8110e918:	1080010c 	andi	r2,r2,4
8110e91c:	10803fcc 	andi	r2,r2,255
8110e920:	1000021e 	bne	r2,zero,8110e92c <vCheck+0x144>
        vCheckRetransmission32();
8110e924:	110ee7c0 	call	8110ee7c <vCheckRetransmission32>
8110e928:	00000506 	br	8110e940 <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
8110e92c:	01800804 	movi	r6,32
8110e930:	000b883a 	mov	r5,zero
8110e934:	01204574 	movhi	r4,33045
8110e938:	21125304 	addi	r4,r4,18764
8110e93c:	1117e1c0 	call	81117e1c <memset>


    OSMutexPost(xTxUARTMutex);
8110e940:	d0a06517 	ldw	r2,-32364(gp)
8110e944:	1009883a 	mov	r4,r2
8110e948:	11332900 	call	81133290 <OSMutexPost>

    return;
8110e94c:	0001883a 	nop
8110e950:	00000106 	br	8110e958 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
8110e954:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
8110e958:	e037883a 	mov	sp,fp
8110e95c:	dfc00117 	ldw	ra,4(sp)
8110e960:	df000017 	ldw	fp,0(sp)
8110e964:	dec00204 	addi	sp,sp,8
8110e968:	f800283a 	ret

8110e96c <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
8110e96c:	defffd04 	addi	sp,sp,-12
8110e970:	de00012e 	bgeu	sp,et,8110e978 <vCheckRetransmission128+0xc>
8110e974:	003b68fa 	trap	3
8110e978:	dfc00215 	stw	ra,8(sp)
8110e97c:	df000115 	stw	fp,4(sp)
8110e980:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8110e984:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
8110e988:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8110e98c:	d0a06017 	ldw	r2,-32384(gp)
8110e990:	e0ffff44 	addi	r3,fp,-3
8110e994:	180b883a 	mov	r5,r3
8110e998:	1009883a 	mov	r4,r2
8110e99c:	113266c0 	call	8113266c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8110e9a0:	e0bfff43 	ldbu	r2,-3(fp)
8110e9a4:	10803fcc 	andi	r2,r2,255
8110e9a8:	10008b1e 	bne	r2,zero,8110ebd8 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
8110e9ac:	e03fff05 	stb	zero,-4(fp)
8110e9b0:	00008106 	br	8110ebb8 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
8110e9b4:	e0ffff03 	ldbu	r3,-4(fp)
8110e9b8:	00a04574 	movhi	r2,33045
8110e9bc:	10924504 	addi	r2,r2,18708
8110e9c0:	18c7883a 	add	r3,r3,r3
8110e9c4:	18c7883a 	add	r3,r3,r3
8110e9c8:	10c5883a 	add	r2,r2,r3
8110e9cc:	10800017 	ldw	r2,0(r2)
8110e9d0:	10800058 	cmpnei	r2,r2,1
8110e9d4:	1000751e 	bne	r2,zero,8110ebac <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
8110e9d8:	e0ffff03 	ldbu	r3,-4(fp)
8110e9dc:	00a04574 	movhi	r2,33045
8110e9e0:	10926304 	addi	r2,r2,18828
8110e9e4:	18c02324 	muli	r3,r3,140
8110e9e8:	10c5883a 	add	r2,r2,r3
8110e9ec:	10802004 	addi	r2,r2,128
8110e9f0:	10800017 	ldw	r2,0(r2)
8110e9f4:	10800058 	cmpnei	r2,r2,1
8110e9f8:	1000211e 	bne	r2,zero,8110ea80 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
8110e9fc:	e0ffff03 	ldbu	r3,-4(fp)
8110ea00:	00a04574 	movhi	r2,33045
8110ea04:	10926304 	addi	r2,r2,18828
8110ea08:	19002324 	muli	r4,r3,140
8110ea0c:	1105883a 	add	r2,r2,r4
8110ea10:	10802184 	addi	r2,r2,134
8110ea14:	1080000b 	ldhu	r2,0(r2)
8110ea18:	10800044 	addi	r2,r2,1
8110ea1c:	100b883a 	mov	r5,r2
8110ea20:	00a04574 	movhi	r2,33045
8110ea24:	10926304 	addi	r2,r2,18828
8110ea28:	19002324 	muli	r4,r3,140
8110ea2c:	1105883a 	add	r2,r2,r4
8110ea30:	10802184 	addi	r2,r2,134
8110ea34:	1140000d 	sth	r5,0(r2)
8110ea38:	00a04574 	movhi	r2,33045
8110ea3c:	10926304 	addi	r2,r2,18828
8110ea40:	18c02324 	muli	r3,r3,140
8110ea44:	10c5883a 	add	r2,r2,r3
8110ea48:	10802184 	addi	r2,r2,134
8110ea4c:	1080000b 	ldhu	r2,0(r2)
8110ea50:	10bfffcc 	andi	r2,r2,65535
8110ea54:	10a0001c 	xori	r2,r2,32768
8110ea58:	10a00004 	addi	r2,r2,-32768
8110ea5c:	10800090 	cmplti	r2,r2,2
8110ea60:	1000071e 	bne	r2,zero,8110ea80 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
8110ea64:	e0ffff03 	ldbu	r3,-4(fp)
8110ea68:	00a04574 	movhi	r2,33045
8110ea6c:	10926304 	addi	r2,r2,18828
8110ea70:	18c02324 	muli	r3,r3,140
8110ea74:	10c5883a 	add	r2,r2,r3
8110ea78:	10802004 	addi	r2,r2,128
8110ea7c:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
8110ea80:	e0ffff03 	ldbu	r3,-4(fp)
8110ea84:	00a04574 	movhi	r2,33045
8110ea88:	10926304 	addi	r2,r2,18828
8110ea8c:	18c02324 	muli	r3,r3,140
8110ea90:	10c5883a 	add	r2,r2,r3
8110ea94:	10802004 	addi	r2,r2,128
8110ea98:	10800017 	ldw	r2,0(r2)
8110ea9c:	1000431e 	bne	r2,zero,8110ebac <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
8110eaa0:	e0bfff03 	ldbu	r2,-4(fp)
8110eaa4:	10c02324 	muli	r3,r2,140
8110eaa8:	00a04574 	movhi	r2,33045
8110eaac:	10926304 	addi	r2,r2,18828
8110eab0:	1885883a 	add	r2,r3,r2
8110eab4:	1009883a 	mov	r4,r2
8110eab8:	11182680 	call	81118268 <puts>
                xBuffer128[ucIL].bSent = TRUE;
8110eabc:	e0ffff03 	ldbu	r3,-4(fp)
8110eac0:	00a04574 	movhi	r2,33045
8110eac4:	10926304 	addi	r2,r2,18828
8110eac8:	18c02324 	muli	r3,r3,140
8110eacc:	10c5883a 	add	r2,r2,r3
8110ead0:	10802004 	addi	r2,r2,128
8110ead4:	00c00044 	movi	r3,1
8110ead8:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
8110eadc:	e0ffff03 	ldbu	r3,-4(fp)
8110eae0:	00a04574 	movhi	r2,33045
8110eae4:	10926304 	addi	r2,r2,18828
8110eae8:	18c02324 	muli	r3,r3,140
8110eaec:	10c5883a 	add	r2,r2,r3
8110eaf0:	10802184 	addi	r2,r2,134
8110eaf4:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8110eaf8:	e0ffff03 	ldbu	r3,-4(fp)
8110eafc:	00a04574 	movhi	r2,33045
8110eb00:	10926304 	addi	r2,r2,18828
8110eb04:	19002324 	muli	r4,r3,140
8110eb08:	1105883a 	add	r2,r2,r4
8110eb0c:	10802204 	addi	r2,r2,136
8110eb10:	10800003 	ldbu	r2,0(r2)
8110eb14:	10800044 	addi	r2,r2,1
8110eb18:	100b883a 	mov	r5,r2
8110eb1c:	00a04574 	movhi	r2,33045
8110eb20:	10926304 	addi	r2,r2,18828
8110eb24:	19002324 	muli	r4,r3,140
8110eb28:	1105883a 	add	r2,r2,r4
8110eb2c:	10802204 	addi	r2,r2,136
8110eb30:	11400005 	stb	r5,0(r2)
8110eb34:	00a04574 	movhi	r2,33045
8110eb38:	10926304 	addi	r2,r2,18828
8110eb3c:	18c02324 	muli	r3,r3,140
8110eb40:	10c5883a 	add	r2,r2,r3
8110eb44:	10802204 	addi	r2,r2,136
8110eb48:	10800003 	ldbu	r2,0(r2)
8110eb4c:	10803fcc 	andi	r2,r2,255
8110eb50:	108000b0 	cmpltui	r2,r2,2
8110eb54:	1000151e 	bne	r2,zero,8110ebac <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
8110eb58:	e0ffff03 	ldbu	r3,-4(fp)
8110eb5c:	00a04574 	movhi	r2,33045
8110eb60:	10924504 	addi	r2,r2,18708
8110eb64:	18c7883a 	add	r3,r3,r3
8110eb68:	18c7883a 	add	r3,r3,r3
8110eb6c:	10c5883a 	add	r2,r2,r3
8110eb70:	10000015 	stw	zero,0(r2)
                    SemCount128++;
8110eb74:	d0a06643 	ldbu	r2,-32359(gp)
8110eb78:	10800044 	addi	r2,r2,1
8110eb7c:	d0a06645 	stb	r2,-32359(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
8110eb80:	d0a05617 	ldw	r2,-32424(gp)
8110eb84:	1009883a 	mov	r4,r2
8110eb88:	11350800 	call	81135080 <OSSemPost>
8110eb8c:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8110eb90:	e0bfff43 	ldbu	r2,-3(fp)
8110eb94:	10803fcc 	andi	r2,r2,255
8110eb98:	10000426 	beq	r2,zero,8110ebac <vCheckRetransmission128+0x240>
                        SemCount128--;
8110eb9c:	d0a06643 	ldbu	r2,-32359(gp)
8110eba0:	10bfffc4 	addi	r2,r2,-1
8110eba4:	d0a06645 	stb	r2,-32359(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8110eba8:	1112a100 	call	81112a10 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
8110ebac:	e0bfff03 	ldbu	r2,-4(fp)
8110ebb0:	10800044 	addi	r2,r2,1
8110ebb4:	e0bfff05 	stb	r2,-4(fp)
8110ebb8:	e0bfff03 	ldbu	r2,-4(fp)
8110ebbc:	108001b0 	cmpltui	r2,r2,6
8110ebc0:	103f7c1e 	bne	r2,zero,8110e9b4 <__reset+0xfb0ee9b4>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
8110ebc4:	d0a06017 	ldw	r2,-32384(gp)
8110ebc8:	1009883a 	mov	r4,r2
8110ebcc:	11332900 	call	81133290 <OSMutexPost>

    return;
8110ebd0:	0001883a 	nop
8110ebd4:	00000106 	br	8110ebdc <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8110ebd8:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
8110ebdc:	e037883a 	mov	sp,fp
8110ebe0:	dfc00117 	ldw	ra,4(sp)
8110ebe4:	df000017 	ldw	fp,0(sp)
8110ebe8:	dec00204 	addi	sp,sp,8
8110ebec:	f800283a 	ret

8110ebf0 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
8110ebf0:	defffd04 	addi	sp,sp,-12
8110ebf4:	de00012e 	bgeu	sp,et,8110ebfc <vCheckRetransmission64+0xc>
8110ebf8:	003b68fa 	trap	3
8110ebfc:	dfc00215 	stw	ra,8(sp)
8110ec00:	df000115 	stw	fp,4(sp)
8110ec04:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8110ec08:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
8110ec0c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8110ec10:	d0a06217 	ldw	r2,-32376(gp)
8110ec14:	e0ffff44 	addi	r3,fp,-3
8110ec18:	180b883a 	mov	r5,r3
8110ec1c:	1009883a 	mov	r4,r2
8110ec20:	113266c0 	call	8113266c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8110ec24:	e0bfff43 	ldbu	r2,-3(fp)
8110ec28:	10803fcc 	andi	r2,r2,255
8110ec2c:	10008d1e 	bne	r2,zero,8110ee64 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8110ec30:	e03fff05 	stb	zero,-4(fp)
8110ec34:	00008306 	br	8110ee44 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
8110ec38:	e0ffff03 	ldbu	r3,-4(fp)
8110ec3c:	00a04574 	movhi	r2,33045
8110ec40:	10924504 	addi	r2,r2,18708
8110ec44:	18c00184 	addi	r3,r3,6
8110ec48:	18c7883a 	add	r3,r3,r3
8110ec4c:	18c7883a 	add	r3,r3,r3
8110ec50:	10c5883a 	add	r2,r2,r3
8110ec54:	10800017 	ldw	r2,0(r2)
8110ec58:	10800058 	cmpnei	r2,r2,1
8110ec5c:	1000761e 	bne	r2,zero,8110ee38 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
8110ec60:	e0ffff03 	ldbu	r3,-4(fp)
8110ec64:	00a04574 	movhi	r2,33045
8110ec68:	10ab5504 	addi	r2,r2,-21164
8110ec6c:	18c01324 	muli	r3,r3,76
8110ec70:	10c5883a 	add	r2,r2,r3
8110ec74:	10801004 	addi	r2,r2,64
8110ec78:	10800017 	ldw	r2,0(r2)
8110ec7c:	10800058 	cmpnei	r2,r2,1
8110ec80:	1000211e 	bne	r2,zero,8110ed08 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
8110ec84:	e0ffff03 	ldbu	r3,-4(fp)
8110ec88:	00a04574 	movhi	r2,33045
8110ec8c:	10ab5504 	addi	r2,r2,-21164
8110ec90:	19001324 	muli	r4,r3,76
8110ec94:	1105883a 	add	r2,r2,r4
8110ec98:	10801184 	addi	r2,r2,70
8110ec9c:	1080000b 	ldhu	r2,0(r2)
8110eca0:	10800044 	addi	r2,r2,1
8110eca4:	100b883a 	mov	r5,r2
8110eca8:	00a04574 	movhi	r2,33045
8110ecac:	10ab5504 	addi	r2,r2,-21164
8110ecb0:	19001324 	muli	r4,r3,76
8110ecb4:	1105883a 	add	r2,r2,r4
8110ecb8:	10801184 	addi	r2,r2,70
8110ecbc:	1140000d 	sth	r5,0(r2)
8110ecc0:	00a04574 	movhi	r2,33045
8110ecc4:	10ab5504 	addi	r2,r2,-21164
8110ecc8:	18c01324 	muli	r3,r3,76
8110eccc:	10c5883a 	add	r2,r2,r3
8110ecd0:	10801184 	addi	r2,r2,70
8110ecd4:	1080000b 	ldhu	r2,0(r2)
8110ecd8:	10bfffcc 	andi	r2,r2,65535
8110ecdc:	10a0001c 	xori	r2,r2,32768
8110ece0:	10a00004 	addi	r2,r2,-32768
8110ece4:	10800090 	cmplti	r2,r2,2
8110ece8:	1000071e 	bne	r2,zero,8110ed08 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
8110ecec:	e0ffff03 	ldbu	r3,-4(fp)
8110ecf0:	00a04574 	movhi	r2,33045
8110ecf4:	10ab5504 	addi	r2,r2,-21164
8110ecf8:	18c01324 	muli	r3,r3,76
8110ecfc:	10c5883a 	add	r2,r2,r3
8110ed00:	10801004 	addi	r2,r2,64
8110ed04:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
8110ed08:	e0ffff03 	ldbu	r3,-4(fp)
8110ed0c:	00a04574 	movhi	r2,33045
8110ed10:	10ab5504 	addi	r2,r2,-21164
8110ed14:	18c01324 	muli	r3,r3,76
8110ed18:	10c5883a 	add	r2,r2,r3
8110ed1c:	10801004 	addi	r2,r2,64
8110ed20:	10800017 	ldw	r2,0(r2)
8110ed24:	1000441e 	bne	r2,zero,8110ee38 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
8110ed28:	e0bfff03 	ldbu	r2,-4(fp)
8110ed2c:	10c01324 	muli	r3,r2,76
8110ed30:	00a04574 	movhi	r2,33045
8110ed34:	10ab5504 	addi	r2,r2,-21164
8110ed38:	1885883a 	add	r2,r3,r2
8110ed3c:	1009883a 	mov	r4,r2
8110ed40:	11182680 	call	81118268 <puts>
                xBuffer64[ucIL].bSent = TRUE;
8110ed44:	e0ffff03 	ldbu	r3,-4(fp)
8110ed48:	00a04574 	movhi	r2,33045
8110ed4c:	10ab5504 	addi	r2,r2,-21164
8110ed50:	18c01324 	muli	r3,r3,76
8110ed54:	10c5883a 	add	r2,r2,r3
8110ed58:	10801004 	addi	r2,r2,64
8110ed5c:	00c00044 	movi	r3,1
8110ed60:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
8110ed64:	e0ffff03 	ldbu	r3,-4(fp)
8110ed68:	00a04574 	movhi	r2,33045
8110ed6c:	10ab5504 	addi	r2,r2,-21164
8110ed70:	18c01324 	muli	r3,r3,76
8110ed74:	10c5883a 	add	r2,r2,r3
8110ed78:	10801184 	addi	r2,r2,70
8110ed7c:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8110ed80:	e0ffff03 	ldbu	r3,-4(fp)
8110ed84:	00a04574 	movhi	r2,33045
8110ed88:	10ab5504 	addi	r2,r2,-21164
8110ed8c:	19001324 	muli	r4,r3,76
8110ed90:	1105883a 	add	r2,r2,r4
8110ed94:	10801204 	addi	r2,r2,72
8110ed98:	10800003 	ldbu	r2,0(r2)
8110ed9c:	10800044 	addi	r2,r2,1
8110eda0:	100b883a 	mov	r5,r2
8110eda4:	00a04574 	movhi	r2,33045
8110eda8:	10ab5504 	addi	r2,r2,-21164
8110edac:	19001324 	muli	r4,r3,76
8110edb0:	1105883a 	add	r2,r2,r4
8110edb4:	10801204 	addi	r2,r2,72
8110edb8:	11400005 	stb	r5,0(r2)
8110edbc:	00a04574 	movhi	r2,33045
8110edc0:	10ab5504 	addi	r2,r2,-21164
8110edc4:	18c01324 	muli	r3,r3,76
8110edc8:	10c5883a 	add	r2,r2,r3
8110edcc:	10801204 	addi	r2,r2,72
8110edd0:	10800003 	ldbu	r2,0(r2)
8110edd4:	10803fcc 	andi	r2,r2,255
8110edd8:	108000b0 	cmpltui	r2,r2,2
8110eddc:	1000161e 	bne	r2,zero,8110ee38 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
8110ede0:	e0ffff03 	ldbu	r3,-4(fp)
8110ede4:	00a04574 	movhi	r2,33045
8110ede8:	10924504 	addi	r2,r2,18708
8110edec:	18c00184 	addi	r3,r3,6
8110edf0:	18c7883a 	add	r3,r3,r3
8110edf4:	18c7883a 	add	r3,r3,r3
8110edf8:	10c5883a 	add	r2,r2,r3
8110edfc:	10000015 	stw	zero,0(r2)
                    SemCount64++;
8110ee00:	d0a06603 	ldbu	r2,-32360(gp)
8110ee04:	10800044 	addi	r2,r2,1
8110ee08:	d0a06605 	stb	r2,-32360(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
8110ee0c:	d0a05217 	ldw	r2,-32440(gp)
8110ee10:	1009883a 	mov	r4,r2
8110ee14:	11350800 	call	81135080 <OSSemPost>
8110ee18:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8110ee1c:	e0bfff43 	ldbu	r2,-3(fp)
8110ee20:	10803fcc 	andi	r2,r2,255
8110ee24:	10000426 	beq	r2,zero,8110ee38 <vCheckRetransmission64+0x248>
                        SemCount64--;
8110ee28:	d0a06603 	ldbu	r2,-32360(gp)
8110ee2c:	10bfffc4 	addi	r2,r2,-1
8110ee30:	d0a06605 	stb	r2,-32360(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8110ee34:	11129a80 	call	811129a8 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8110ee38:	e0bfff03 	ldbu	r2,-4(fp)
8110ee3c:	10800044 	addi	r2,r2,1
8110ee40:	e0bfff05 	stb	r2,-4(fp)
8110ee44:	e0bfff03 	ldbu	r2,-4(fp)
8110ee48:	10800230 	cmpltui	r2,r2,8
8110ee4c:	103f7a1e 	bne	r2,zero,8110ec38 <__reset+0xfb0eec38>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
8110ee50:	d0a06217 	ldw	r2,-32376(gp)
8110ee54:	1009883a 	mov	r4,r2
8110ee58:	11332900 	call	81133290 <OSMutexPost>

    return;
8110ee5c:	0001883a 	nop
8110ee60:	00000106 	br	8110ee68 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8110ee64:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
8110ee68:	e037883a 	mov	sp,fp
8110ee6c:	dfc00117 	ldw	ra,4(sp)
8110ee70:	df000017 	ldw	fp,0(sp)
8110ee74:	dec00204 	addi	sp,sp,8
8110ee78:	f800283a 	ret

8110ee7c <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
8110ee7c:	defffd04 	addi	sp,sp,-12
8110ee80:	de00012e 	bgeu	sp,et,8110ee88 <vCheckRetransmission32+0xc>
8110ee84:	003b68fa 	trap	3
8110ee88:	dfc00215 	stw	ra,8(sp)
8110ee8c:	df000115 	stw	fp,4(sp)
8110ee90:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8110ee94:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
8110ee98:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
8110ee9c:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8110eea0:	d0a05e17 	ldw	r2,-32392(gp)
8110eea4:	e0ffff84 	addi	r3,fp,-2
8110eea8:	180b883a 	mov	r5,r3
8110eeac:	1009883a 	mov	r4,r2
8110eeb0:	113266c0 	call	8113266c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8110eeb4:	e0bfff83 	ldbu	r2,-2(fp)
8110eeb8:	10803fcc 	andi	r2,r2,255
8110eebc:	10009b1e 	bne	r2,zero,8110f12c <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
8110eec0:	e03fff05 	stb	zero,-4(fp)
8110eec4:	00009106 	br	8110f10c <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
8110eec8:	e0ffff03 	ldbu	r3,-4(fp)
8110eecc:	00a04574 	movhi	r2,33045
8110eed0:	10924504 	addi	r2,r2,18708
8110eed4:	18c00384 	addi	r3,r3,14
8110eed8:	18c7883a 	add	r3,r3,r3
8110eedc:	18c7883a 	add	r3,r3,r3
8110eee0:	10c5883a 	add	r2,r2,r3
8110eee4:	10800017 	ldw	r2,0(r2)
8110eee8:	10800058 	cmpnei	r2,r2,1
8110eeec:	1000841e 	bne	r2,zero,8110f100 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
8110eef0:	e0ffff03 	ldbu	r3,-4(fp)
8110eef4:	00a04574 	movhi	r2,33045
8110eef8:	10bfd904 	addi	r2,r2,-156
8110eefc:	18c00b24 	muli	r3,r3,44
8110ef00:	10c5883a 	add	r2,r2,r3
8110ef04:	10800804 	addi	r2,r2,32
8110ef08:	10800017 	ldw	r2,0(r2)
8110ef0c:	10800058 	cmpnei	r2,r2,1
8110ef10:	1000211e 	bne	r2,zero,8110ef98 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
8110ef14:	e0ffff03 	ldbu	r3,-4(fp)
8110ef18:	00a04574 	movhi	r2,33045
8110ef1c:	10bfd904 	addi	r2,r2,-156
8110ef20:	19000b24 	muli	r4,r3,44
8110ef24:	1105883a 	add	r2,r2,r4
8110ef28:	10800984 	addi	r2,r2,38
8110ef2c:	1080000b 	ldhu	r2,0(r2)
8110ef30:	10800044 	addi	r2,r2,1
8110ef34:	100b883a 	mov	r5,r2
8110ef38:	00a04574 	movhi	r2,33045
8110ef3c:	10bfd904 	addi	r2,r2,-156
8110ef40:	19000b24 	muli	r4,r3,44
8110ef44:	1105883a 	add	r2,r2,r4
8110ef48:	10800984 	addi	r2,r2,38
8110ef4c:	1140000d 	sth	r5,0(r2)
8110ef50:	00a04574 	movhi	r2,33045
8110ef54:	10bfd904 	addi	r2,r2,-156
8110ef58:	18c00b24 	muli	r3,r3,44
8110ef5c:	10c5883a 	add	r2,r2,r3
8110ef60:	10800984 	addi	r2,r2,38
8110ef64:	1080000b 	ldhu	r2,0(r2)
8110ef68:	10bfffcc 	andi	r2,r2,65535
8110ef6c:	10a0001c 	xori	r2,r2,32768
8110ef70:	10a00004 	addi	r2,r2,-32768
8110ef74:	10800090 	cmplti	r2,r2,2
8110ef78:	1000071e 	bne	r2,zero,8110ef98 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
8110ef7c:	e0ffff03 	ldbu	r3,-4(fp)
8110ef80:	00a04574 	movhi	r2,33045
8110ef84:	10bfd904 	addi	r2,r2,-156
8110ef88:	18c00b24 	muli	r3,r3,44
8110ef8c:	10c5883a 	add	r2,r2,r3
8110ef90:	10800804 	addi	r2,r2,32
8110ef94:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
8110ef98:	e0ffff03 	ldbu	r3,-4(fp)
8110ef9c:	00a04574 	movhi	r2,33045
8110efa0:	10bfd904 	addi	r2,r2,-156
8110efa4:	18c00b24 	muli	r3,r3,44
8110efa8:	10c5883a 	add	r2,r2,r3
8110efac:	10800804 	addi	r2,r2,32
8110efb0:	10800017 	ldw	r2,0(r2)
8110efb4:	1000521e 	bne	r2,zero,8110f100 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
8110efb8:	e0bfff03 	ldbu	r2,-4(fp)
8110efbc:	10c00b24 	muli	r3,r2,44
8110efc0:	00a04574 	movhi	r2,33045
8110efc4:	10bfd904 	addi	r2,r2,-156
8110efc8:	1885883a 	add	r2,r3,r2
8110efcc:	1009883a 	mov	r4,r2
8110efd0:	11182680 	call	81118268 <puts>
                xBuffer32[ucIL].bSent = TRUE;
8110efd4:	e0ffff03 	ldbu	r3,-4(fp)
8110efd8:	00a04574 	movhi	r2,33045
8110efdc:	10bfd904 	addi	r2,r2,-156
8110efe0:	18c00b24 	muli	r3,r3,44
8110efe4:	10c5883a 	add	r2,r2,r3
8110efe8:	10800804 	addi	r2,r2,32
8110efec:	00c00044 	movi	r3,1
8110eff0:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
8110eff4:	e0ffff03 	ldbu	r3,-4(fp)
8110eff8:	00a04574 	movhi	r2,33045
8110effc:	10bfd904 	addi	r2,r2,-156
8110f000:	18c00b24 	muli	r3,r3,44
8110f004:	10c5883a 	add	r2,r2,r3
8110f008:	10800984 	addi	r2,r2,38
8110f00c:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
8110f010:	e0ffff03 	ldbu	r3,-4(fp)
8110f014:	00a04574 	movhi	r2,33045
8110f018:	10bfd904 	addi	r2,r2,-156
8110f01c:	18c00b24 	muli	r3,r3,44
8110f020:	10c5883a 	add	r2,r2,r3
8110f024:	10800904 	addi	r2,r2,36
8110f028:	1080000b 	ldhu	r2,0(r2)
8110f02c:	10bfffcc 	andi	r2,r2,65535
8110f030:	10800058 	cmpnei	r2,r2,1
8110f034:	1000021e 	bne	r2,zero,8110f040 <vCheckRetransmission32+0x1c4>
8110f038:	00bffe84 	movi	r2,-6
8110f03c:	00000106 	br	8110f044 <vCheckRetransmission32+0x1c8>
8110f040:	00800044 	movi	r2,1
8110f044:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
8110f048:	e0ffff03 	ldbu	r3,-4(fp)
8110f04c:	00a04574 	movhi	r2,33045
8110f050:	10bfd904 	addi	r2,r2,-156
8110f054:	19000b24 	muli	r4,r3,44
8110f058:	1105883a 	add	r2,r2,r4
8110f05c:	10800a04 	addi	r2,r2,40
8110f060:	10800003 	ldbu	r2,0(r2)
8110f064:	10800044 	addi	r2,r2,1
8110f068:	100b883a 	mov	r5,r2
8110f06c:	00a04574 	movhi	r2,33045
8110f070:	10bfd904 	addi	r2,r2,-156
8110f074:	19000b24 	muli	r4,r3,44
8110f078:	1105883a 	add	r2,r2,r4
8110f07c:	10800a04 	addi	r2,r2,40
8110f080:	11400005 	stb	r5,0(r2)
8110f084:	00a04574 	movhi	r2,33045
8110f088:	10bfd904 	addi	r2,r2,-156
8110f08c:	18c00b24 	muli	r3,r3,44
8110f090:	10c5883a 	add	r2,r2,r3
8110f094:	10800a04 	addi	r2,r2,40
8110f098:	10800003 	ldbu	r2,0(r2)
8110f09c:	10803fcc 	andi	r2,r2,255
8110f0a0:	e0ffff43 	ldbu	r3,-3(fp)
8110f0a4:	1880162e 	bgeu	r3,r2,8110f100 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
8110f0a8:	e0ffff03 	ldbu	r3,-4(fp)
8110f0ac:	00a04574 	movhi	r2,33045
8110f0b0:	10924504 	addi	r2,r2,18708
8110f0b4:	18c00384 	addi	r3,r3,14
8110f0b8:	18c7883a 	add	r3,r3,r3
8110f0bc:	18c7883a 	add	r3,r3,r3
8110f0c0:	10c5883a 	add	r2,r2,r3
8110f0c4:	10000015 	stw	zero,0(r2)
                    SemCount32++;
8110f0c8:	d0a05b83 	ldbu	r2,-32402(gp)
8110f0cc:	10800044 	addi	r2,r2,1
8110f0d0:	d0a05b85 	stb	r2,-32402(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
8110f0d4:	d0a06117 	ldw	r2,-32380(gp)
8110f0d8:	1009883a 	mov	r4,r2
8110f0dc:	11350800 	call	81135080 <OSSemPost>
8110f0e0:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8110f0e4:	e0bfff83 	ldbu	r2,-2(fp)
8110f0e8:	10803fcc 	andi	r2,r2,255
8110f0ec:	10000426 	beq	r2,zero,8110f100 <vCheckRetransmission32+0x284>
                        SemCount32--;
8110f0f0:	d0a05b83 	ldbu	r2,-32402(gp)
8110f0f4:	10bfffc4 	addi	r2,r2,-1
8110f0f8:	d0a05b85 	stb	r2,-32402(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
8110f0fc:	11129400 	call	81112940 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
8110f100:	e0bfff03 	ldbu	r2,-4(fp)
8110f104:	10800044 	addi	r2,r2,1
8110f108:	e0bfff05 	stb	r2,-4(fp)
8110f10c:	e0bfff03 	ldbu	r2,-4(fp)
8110f110:	10800230 	cmpltui	r2,r2,8
8110f114:	103f6c1e 	bne	r2,zero,8110eec8 <__reset+0xfb0eeec8>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
8110f118:	d0a05e17 	ldw	r2,-32392(gp)
8110f11c:	1009883a 	mov	r4,r2
8110f120:	11332900 	call	81133290 <OSMutexPost>

    return;
8110f124:	0001883a 	nop
8110f128:	00000106 	br	8110f130 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8110f12c:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
8110f130:	e037883a 	mov	sp,fp
8110f134:	dfc00117 	ldw	ra,4(sp)
8110f138:	df000017 	ldw	fp,0(sp)
8110f13c:	dec00204 	addi	sp,sp,8
8110f140:	f800283a 	ret

8110f144 <bResourcesInitRTOS>:
 * Control of all Simucam application
 */
TSimucam_MEB xSimMeb; /* Struct */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
8110f144:	defff904 	addi	sp,sp,-28
8110f148:	de00012e 	bgeu	sp,et,8110f150 <bResourcesInitRTOS+0xc>
8110f14c:	003b68fa 	trap	3
8110f150:	dfc00615 	stw	ra,24(sp)
8110f154:	df000515 	stw	fp,20(sp)
8110f158:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
8110f15c:	00800044 	movi	r2,1
8110f160:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
8110f164:	0009883a 	mov	r4,zero
8110f168:	11349d00 	call	811349d0 <OSSemCreate>
8110f16c:	d0a05315 	stw	r2,-32436(gp)
	if (!xSemCommInit) {
8110f170:	d0a05317 	ldw	r2,-32436(gp)
8110f174:	1000021e 	bne	r2,zero,8110f180 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
8110f178:	11123d80 	call	811123d8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110f17c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
8110f180:	e0bfff04 	addi	r2,fp,-4
8110f184:	100b883a 	mov	r5,r2
8110f188:	01000444 	movi	r4,17
8110f18c:	11328180 	call	81132818 <OSMutexCreate>
8110f190:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
8110f194:	e0bfff03 	ldbu	r2,-4(fp)
8110f198:	10803fcc 	andi	r2,r2,255
8110f19c:	10000526 	beq	r2,zero,8110f1b4 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
8110f1a0:	e0bfff03 	ldbu	r2,-4(fp)
8110f1a4:	10803fcc 	andi	r2,r2,255
8110f1a8:	1009883a 	mov	r4,r2
8110f1ac:	11123780 	call	81112378 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110f1b0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
8110f1b4:	e0bfff04 	addi	r2,fp,-4
8110f1b8:	100b883a 	mov	r5,r2
8110f1bc:	01000504 	movi	r4,20
8110f1c0:	11328180 	call	81132818 <OSMutexCreate>
8110f1c4:	d0a06015 	stw	r2,-32384(gp)
	if ( err != OS_ERR_NONE ) {
8110f1c8:	e0bfff03 	ldbu	r2,-4(fp)
8110f1cc:	10803fcc 	andi	r2,r2,255
8110f1d0:	10000526 	beq	r2,zero,8110f1e8 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
8110f1d4:	e0bfff03 	ldbu	r2,-4(fp)
8110f1d8:	10803fcc 	andi	r2,r2,255
8110f1dc:	1009883a 	mov	r4,r2
8110f1e0:	11123780 	call	81112378 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110f1e4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
8110f1e8:	e0bfff04 	addi	r2,fp,-4
8110f1ec:	100b883a 	mov	r5,r2
8110f1f0:	01000544 	movi	r4,21
8110f1f4:	11328180 	call	81132818 <OSMutexCreate>
8110f1f8:	d0a06215 	stw	r2,-32376(gp)
	if ( err != OS_ERR_NONE ) {
8110f1fc:	e0bfff03 	ldbu	r2,-4(fp)
8110f200:	10803fcc 	andi	r2,r2,255
8110f204:	10000526 	beq	r2,zero,8110f21c <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
8110f208:	e0bfff03 	ldbu	r2,-4(fp)
8110f20c:	10803fcc 	andi	r2,r2,255
8110f210:	1009883a 	mov	r4,r2
8110f214:	11123780 	call	81112378 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110f218:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
8110f21c:	e0bfff04 	addi	r2,fp,-4
8110f220:	100b883a 	mov	r5,r2
8110f224:	01000584 	movi	r4,22
8110f228:	11328180 	call	81132818 <OSMutexCreate>
8110f22c:	d0a05e15 	stw	r2,-32392(gp)
	if ( err != OS_ERR_NONE ) {
8110f230:	e0bfff03 	ldbu	r2,-4(fp)
8110f234:	10803fcc 	andi	r2,r2,255
8110f238:	10000526 	beq	r2,zero,8110f250 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
8110f23c:	e0bfff03 	ldbu	r2,-4(fp)
8110f240:	10803fcc 	andi	r2,r2,255
8110f244:	1009883a 	mov	r4,r2
8110f248:	11123780 	call	81112378 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110f24c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
8110f250:	00800184 	movi	r2,6
8110f254:	d0a06645 	stb	r2,-32359(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
8110f258:	01000184 	movi	r4,6
8110f25c:	11349d00 	call	811349d0 <OSSemCreate>
8110f260:	d0a05615 	stw	r2,-32424(gp)
	if (!xSemCountBuffer128) {
8110f264:	d0a05617 	ldw	r2,-32424(gp)
8110f268:	1000031e 	bne	r2,zero,8110f278 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
8110f26c:	d0206645 	stb	zero,-32359(gp)
		vFailCreateSemaphoreResources();
8110f270:	11123d80 	call	811123d8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110f274:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
8110f278:	00800204 	movi	r2,8
8110f27c:	d0a06605 	stb	r2,-32360(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
8110f280:	01000204 	movi	r4,8
8110f284:	11349d00 	call	811349d0 <OSSemCreate>
8110f288:	d0a05215 	stw	r2,-32440(gp)
	if (!xSemCountBuffer64) {
8110f28c:	d0a05217 	ldw	r2,-32440(gp)
8110f290:	1000031e 	bne	r2,zero,8110f2a0 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
8110f294:	d0206605 	stb	zero,-32360(gp)
		vFailCreateSemaphoreResources();
8110f298:	11123d80 	call	811123d8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110f29c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
8110f2a0:	00800204 	movi	r2,8
8110f2a4:	d0a05b85 	stb	r2,-32402(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
8110f2a8:	01000204 	movi	r4,8
8110f2ac:	11349d00 	call	811349d0 <OSSemCreate>
8110f2b0:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountBuffer32) {
8110f2b4:	d0a06117 	ldw	r2,-32380(gp)
8110f2b8:	1000031e 	bne	r2,zero,8110f2c8 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
8110f2bc:	d0205b85 	stb	zero,-32402(gp)
		vFailCreateSemaphoreResources();
8110f2c0:	11123d80 	call	811123d8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110f2c4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
8110f2c8:	e0bfff04 	addi	r2,fp,-4
8110f2cc:	100b883a 	mov	r5,r2
8110f2d0:	010004c4 	movi	r4,19
8110f2d4:	11328180 	call	81132818 <OSMutexCreate>
8110f2d8:	d0a05815 	stw	r2,-32416(gp)
	if ( err != OS_ERR_NONE ) {
8110f2dc:	e0bfff03 	ldbu	r2,-4(fp)
8110f2e0:	10803fcc 	andi	r2,r2,255
8110f2e4:	10000526 	beq	r2,zero,8110f2fc <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
8110f2e8:	e0bfff03 	ldbu	r2,-4(fp)
8110f2ec:	10803fcc 	andi	r2,r2,255
8110f2f0:	1009883a 	mov	r4,r2
8110f2f4:	11123780 	call	81112378 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110f2f8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
8110f2fc:	e0bfff04 	addi	r2,fp,-4
8110f300:	100b883a 	mov	r5,r2
8110f304:	010005c4 	movi	r4,23
8110f308:	11328180 	call	81132818 <OSMutexCreate>
8110f30c:	d0a05d15 	stw	r2,-32396(gp)
	if ( err != OS_ERR_NONE ) {
8110f310:	e0bfff03 	ldbu	r2,-4(fp)
8110f314:	10803fcc 	andi	r2,r2,255
8110f318:	10000526 	beq	r2,zero,8110f330 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
8110f31c:	e0bfff03 	ldbu	r2,-4(fp)
8110f320:	10803fcc 	andi	r2,r2,255
8110f324:	1009883a 	mov	r4,r2
8110f328:	11123780 	call	81112378 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110f32c:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
8110f330:	0009883a 	mov	r4,zero
8110f334:	11349d00 	call	811349d0 <OSSemCreate>
8110f338:	d0a05915 	stw	r2,-32412(gp)
	if (!xSemCountReceivedACK) {
8110f33c:	d0a05917 	ldw	r2,-32412(gp)
8110f340:	1000021e 	bne	r2,zero,8110f34c <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
8110f344:	11123d80 	call	811123d8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110f348:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
8110f34c:	0009883a 	mov	r4,zero
8110f350:	11349d00 	call	811349d0 <OSSemCreate>
8110f354:	d0a05715 	stw	r2,-32420(gp)
	if (!xSemCountPreParsed) {
8110f358:	d0a05717 	ldw	r2,-32420(gp)
8110f35c:	1000021e 	bne	r2,zero,8110f368 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
8110f360:	11123d80 	call	811123d8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110f364:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
8110f368:	0009883a 	mov	r4,zero
8110f36c:	11349d00 	call	811349d0 <OSSemCreate>
8110f370:	d0a05415 	stw	r2,-32432(gp)
	if (!xSemCountSenderACK) {
8110f374:	d0a05417 	ldw	r2,-32432(gp)
8110f378:	1000021e 	bne	r2,zero,8110f384 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
8110f37c:	11123d80 	call	811123d8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110f380:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
8110f384:	e0bfff04 	addi	r2,fp,-4
8110f388:	100b883a 	mov	r5,r2
8110f38c:	01000484 	movi	r4,18
8110f390:	11328180 	call	81132818 <OSMutexCreate>
8110f394:	d0a06315 	stw	r2,-32372(gp)
	if ( err != OS_ERR_NONE ) {
8110f398:	e0bfff03 	ldbu	r2,-4(fp)
8110f39c:	10803fcc 	andi	r2,r2,255
8110f3a0:	10000526 	beq	r2,zero,8110f3b8 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
8110f3a4:	e0bfff03 	ldbu	r2,-4(fp)
8110f3a8:	10803fcc 	andi	r2,r2,255
8110f3ac:	1009883a 	mov	r4,r2
8110f3b0:	11123780 	call	81112378 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8110f3b4:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
8110f3b8:	0009883a 	mov	r4,zero
8110f3bc:	11349d00 	call	811349d0 <OSSemCreate>
8110f3c0:	d0a05a15 	stw	r2,-32408(gp)
	if (!xSemTimeoutChecker) {
8110f3c4:	d0a05a17 	ldw	r2,-32408(gp)
8110f3c8:	1000021e 	bne	r2,zero,8110f3d4 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
8110f3cc:	11123d80 	call	811123d8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8110f3d0:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
8110f3d4:	e0bfff04 	addi	r2,fp,-4
8110f3d8:	d8800215 	stw	r2,8(sp)
8110f3dc:	00a04534 	movhi	r2,33044
8110f3e0:	108edc04 	addi	r2,r2,15216
8110f3e4:	d8800115 	stw	r2,4(sp)
8110f3e8:	d8000015 	stw	zero,0(sp)
8110f3ec:	01e04474 	movhi	r7,33041
8110f3f0:	39c40004 	addi	r7,r7,4096
8110f3f4:	01800084 	movi	r6,2
8110f3f8:	01400104 	movi	r5,4
8110f3fc:	01000284 	movi	r4,10
8110f400:	1136ee80 	call	81136ee8 <OSTmrCreate>
8110f404:	d0a05f15 	stw	r2,-32388(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
8110f408:	e0bfff03 	ldbu	r2,-4(fp)
8110f40c:	10803fcc 	andi	r2,r2,255
8110f410:	10000226 	beq	r2,zero,8110f41c <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
8110f414:	111303c0 	call	8111303c <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
8110f418:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
8110f41c:	01400304 	movi	r5,12
8110f420:	01204574 	movhi	r4,33045
8110f424:	21304504 	addi	r4,r4,-16108
8110f428:	11339040 	call	81133904 <OSQCreate>
8110f42c:	d0a05115 	stw	r2,-32444(gp)
	if ( xNfeeSchedule == NULL ) {
8110f430:	d0a05117 	ldw	r2,-32444(gp)
8110f434:	1000021e 	bne	r2,zero,8110f440 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
8110f438:	11136200 	call	81113620 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
8110f43c:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
8110f440:	01400104 	movi	r5,4
8110f444:	012045b4 	movhi	r4,33046
8110f448:	2131fd04 	addi	r4,r4,-14348
8110f44c:	11339040 	call	81133904 <OSQCreate>
8110f450:	1007883a 	mov	r3,r2
8110f454:	00a04574 	movhi	r2,33045
8110f458:	10974904 	addi	r2,r2,23844
8110f45c:	10c00015 	stw	r3,0(r2)
	if ( xFeeQ[0] == NULL ) {
8110f460:	00a04574 	movhi	r2,33045
8110f464:	10974904 	addi	r2,r2,23844
8110f468:	10800017 	ldw	r2,0(r2)
8110f46c:	1000031e 	bne	r2,zero,8110f47c <bResourcesInitRTOS+0x338>
		vFailCreateNFEEQueue( 0 );
8110f470:	0009883a 	mov	r4,zero
8110f474:	11136880 	call	81113688 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110f478:	e03ffe15 	stw	zero,-8(fp)
	}
	xFeeQ[1] = OSQCreate(&xFeeQueueTBL1[0], N_MSG_FEE);
8110f47c:	01400104 	movi	r5,4
8110f480:	012045b4 	movhi	r4,33046
8110f484:	21315904 	addi	r4,r4,-15004
8110f488:	11339040 	call	81133904 <OSQCreate>
8110f48c:	1007883a 	mov	r3,r2
8110f490:	00a04574 	movhi	r2,33045
8110f494:	10974904 	addi	r2,r2,23844
8110f498:	10c00115 	stw	r3,4(r2)
	if ( xFeeQ[1] == NULL ) {
8110f49c:	00a04574 	movhi	r2,33045
8110f4a0:	10974904 	addi	r2,r2,23844
8110f4a4:	10800117 	ldw	r2,4(r2)
8110f4a8:	1000031e 	bne	r2,zero,8110f4b8 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 1 );
8110f4ac:	01000044 	movi	r4,1
8110f4b0:	11136880 	call	81113688 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110f4b4:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[2] = OSQCreate(&xFeeQueueTBL2[0], N_MSG_FEE);
8110f4b8:	01400104 	movi	r5,4
8110f4bc:	01204574 	movhi	r4,33045
8110f4c0:	21174f04 	addi	r4,r4,23868
8110f4c4:	11339040 	call	81133904 <OSQCreate>
8110f4c8:	1007883a 	mov	r3,r2
8110f4cc:	00a04574 	movhi	r2,33045
8110f4d0:	10974904 	addi	r2,r2,23844
8110f4d4:	10c00215 	stw	r3,8(r2)
	if ( xFeeQ[2] == NULL ) {
8110f4d8:	00a04574 	movhi	r2,33045
8110f4dc:	10974904 	addi	r2,r2,23844
8110f4e0:	10800217 	ldw	r2,8(r2)
8110f4e4:	1000031e 	bne	r2,zero,8110f4f4 <bResourcesInitRTOS+0x3b0>
		vFailCreateNFEEQueue( 2 );
8110f4e8:	01000084 	movi	r4,2
8110f4ec:	11136880 	call	81113688 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110f4f0:	e03ffe15 	stw	zero,-8(fp)
	}
	
	xFeeQ[3] = OSQCreate(&xFeeQueueTBL3[0], N_MSG_FEE);
8110f4f4:	01400104 	movi	r5,4
8110f4f8:	01204574 	movhi	r4,33045
8110f4fc:	212c4104 	addi	r4,r4,-20220
8110f500:	11339040 	call	81133904 <OSQCreate>
8110f504:	1007883a 	mov	r3,r2
8110f508:	00a04574 	movhi	r2,33045
8110f50c:	10974904 	addi	r2,r2,23844
8110f510:	10c00315 	stw	r3,12(r2)
	if ( xFeeQ[0] == NULL ) {
8110f514:	00a04574 	movhi	r2,33045
8110f518:	10974904 	addi	r2,r2,23844
8110f51c:	10800017 	ldw	r2,0(r2)
8110f520:	1000031e 	bne	r2,zero,8110f530 <bResourcesInitRTOS+0x3ec>
		vFailCreateNFEEQueue( 3 );
8110f524:	010000c4 	movi	r4,3
8110f528:	11136880 	call	81113688 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110f52c:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[4] = OSQCreate(&xFeeQueueTBL4[0], N_MSG_FEE);
8110f530:	01400104 	movi	r5,4
8110f534:	01204574 	movhi	r4,33045
8110f538:	210a4104 	addi	r4,r4,10500
8110f53c:	11339040 	call	81133904 <OSQCreate>
8110f540:	1007883a 	mov	r3,r2
8110f544:	00a04574 	movhi	r2,33045
8110f548:	10974904 	addi	r2,r2,23844
8110f54c:	10c00415 	stw	r3,16(r2)
	if ( xFeeQ[4] == NULL ) {
8110f550:	00a04574 	movhi	r2,33045
8110f554:	10974904 	addi	r2,r2,23844
8110f558:	10800417 	ldw	r2,16(r2)
8110f55c:	1000031e 	bne	r2,zero,8110f56c <bResourcesInitRTOS+0x428>
		vFailCreateNFEEQueue( 4 );
8110f560:	01000104 	movi	r4,4
8110f564:	11136880 	call	81113688 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110f568:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[5] = OSQCreate(&xFeeQueueTBL5[0], N_MSG_FEE);
8110f56c:	01400104 	movi	r5,4
8110f570:	01204574 	movhi	r4,33045
8110f574:	21134504 	addi	r4,r4,19732
8110f578:	11339040 	call	81133904 <OSQCreate>
8110f57c:	1007883a 	mov	r3,r2
8110f580:	00a04574 	movhi	r2,33045
8110f584:	10974904 	addi	r2,r2,23844
8110f588:	10c00515 	stw	r3,20(r2)
	if ( xFeeQ[5] == NULL ) {
8110f58c:	00a04574 	movhi	r2,33045
8110f590:	10974904 	addi	r2,r2,23844
8110f594:	10800517 	ldw	r2,20(r2)
8110f598:	1000031e 	bne	r2,zero,8110f5a8 <bResourcesInitRTOS+0x464>
		vFailCreateNFEEQueue( 5 );
8110f59c:	01000144 	movi	r4,5
8110f5a0:	11136880 	call	81113688 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110f5a4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
8110f5a8:	01400204 	movi	r5,8
8110f5ac:	01204574 	movhi	r4,33045
8110f5b0:	21125b04 	addi	r4,r4,18796
8110f5b4:	11339040 	call	81133904 <OSQCreate>
8110f5b8:	d0a05c15 	stw	r2,-32400(gp)
	if ( xFeeQ[5] == NULL ) {
8110f5bc:	00a04574 	movhi	r2,33045
8110f5c0:	10974904 	addi	r2,r2,23844
8110f5c4:	10800517 	ldw	r2,20(r2)
8110f5c8:	1000031e 	bne	r2,zero,8110f5d8 <bResourcesInitRTOS+0x494>
		vFailCreateNFEEQueue( 5 );
8110f5cc:	01000144 	movi	r4,5
8110f5d0:	11136880 	call	81113688 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8110f5d4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
8110f5d8:	e0bfff04 	addi	r2,fp,-4
8110f5dc:	100b883a 	mov	r5,r2
8110f5e0:	01000144 	movi	r4,5
8110f5e4:	11328180 	call	81132818 <OSMutexCreate>
8110f5e8:	d0a06415 	stw	r2,-32368(gp)
	if ( err != OS_ERR_NONE ) {
8110f5ec:	e0bfff03 	ldbu	r2,-4(fp)
8110f5f0:	10803fcc 	andi	r2,r2,255
8110f5f4:	10000526 	beq	r2,zero,8110f60c <bResourcesInitRTOS+0x4c8>
		vFailCreateMutexSPUSQueueMeb(err);
8110f5f8:	e0bfff03 	ldbu	r2,-4(fp)
8110f5fc:	10803fcc 	andi	r2,r2,255
8110f600:	1009883a 	mov	r4,r2
8110f604:	1113aa00 	call	81113aa0 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
8110f608:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
8110f60c:	01400404 	movi	r5,16
8110f610:	01204574 	movhi	r4,33045
8110f614:	21133504 	addi	r4,r4,19668
8110f618:	11339040 	call	81133904 <OSQCreate>
8110f61c:	d0a04a15 	stw	r2,-32472(gp)
	if ( xQMaskFeeCtrl == NULL ) {
8110f620:	d0a04a17 	ldw	r2,-32472(gp)
8110f624:	1000021e 	bne	r2,zero,8110f630 <bResourcesInitRTOS+0x4ec>
		vCouldNotCreateQueueMaskNfeeCtrl( );
8110f628:	1113c000 	call	81113c00 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
8110f62c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
8110f630:	01400404 	movi	r5,16
8110f634:	01204574 	movhi	r4,33045
8110f638:	21063104 	addi	r4,r4,6340
8110f63c:	11339040 	call	81133904 <OSQCreate>
8110f640:	d0a04a15 	stw	r2,-32472(gp)
	if ( xQMaskFeeCtrl == NULL ) {
8110f644:	d0a04a17 	ldw	r2,-32472(gp)
8110f648:	1000021e 	bne	r2,zero,8110f654 <bResourcesInitRTOS+0x510>
		vCouldNotCreateQueueMaskDataCtrl( );
8110f64c:	1113c680 	call	81113c68 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
8110f650:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
8110f654:	e0bffe17 	ldw	r2,-8(fp)
}
8110f658:	e037883a 	mov	sp,fp
8110f65c:	dfc00117 	ldw	ra,4(sp)
8110f660:	df000017 	ldw	fp,0(sp)
8110f664:	dec00204 	addi	sp,sp,8
8110f668:	f800283a 	ret

8110f66c <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
8110f66c:	defffd04 	addi	sp,sp,-12
8110f670:	de00012e 	bgeu	sp,et,8110f678 <vVariablesInitialization+0xc>
8110f674:	003b68fa 	trap	3
8110f678:	dfc00215 	stw	ra,8(sp)
8110f67c:	df000115 	stw	fp,4(sp)
8110f680:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
8110f684:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
8110f688:	00800084 	movi	r2,2
8110f68c:	d0a05b0d 	sth	r2,-32404(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
8110f690:	01800604 	movi	r6,24
8110f694:	000b883a 	mov	r5,zero
8110f698:	01204574 	movhi	r4,33045
8110f69c:	21124504 	addi	r4,r4,18708
8110f6a0:	1117e1c0 	call	81117e1c <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
8110f6a4:	01800804 	movi	r6,32
8110f6a8:	000b883a 	mov	r5,zero
8110f6ac:	01204574 	movhi	r4,33045
8110f6b0:	21124b04 	addi	r4,r4,18732
8110f6b4:	1117e1c0 	call	81117e1c <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
8110f6b8:	01800804 	movi	r6,32
8110f6bc:	000b883a 	mov	r5,zero
8110f6c0:	01204574 	movhi	r4,33045
8110f6c4:	21125304 	addi	r4,r4,18764
8110f6c8:	1117e1c0 	call	81117e1c <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110f6cc:	e03fff05 	stb	zero,-4(fp)
8110f6d0:	00002806 	br	8110f774 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
8110f6d4:	e0bfff03 	ldbu	r2,-4(fp)
8110f6d8:	10c02324 	muli	r3,r2,140
8110f6dc:	00a04574 	movhi	r2,33045
8110f6e0:	10926304 	addi	r2,r2,18828
8110f6e4:	1885883a 	add	r2,r3,r2
8110f6e8:	01802004 	movi	r6,128
8110f6ec:	000b883a 	mov	r5,zero
8110f6f0:	1009883a 	mov	r4,r2
8110f6f4:	1117e1c0 	call	81117e1c <memset>
		xBuffer128[ucIL].bSent = FALSE;
8110f6f8:	e0ffff03 	ldbu	r3,-4(fp)
8110f6fc:	00a04574 	movhi	r2,33045
8110f700:	10926304 	addi	r2,r2,18828
8110f704:	18c02324 	muli	r3,r3,140
8110f708:	10c5883a 	add	r2,r2,r3
8110f70c:	10802004 	addi	r2,r2,128
8110f710:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
8110f714:	e0ffff03 	ldbu	r3,-4(fp)
8110f718:	00a04574 	movhi	r2,33045
8110f71c:	10926304 	addi	r2,r2,18828
8110f720:	18c02324 	muli	r3,r3,140
8110f724:	10c5883a 	add	r2,r2,r3
8110f728:	10802104 	addi	r2,r2,132
8110f72c:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
8110f730:	e0ffff03 	ldbu	r3,-4(fp)
8110f734:	00a04574 	movhi	r2,33045
8110f738:	10926304 	addi	r2,r2,18828
8110f73c:	18c02324 	muli	r3,r3,140
8110f740:	10c5883a 	add	r2,r2,r3
8110f744:	10802184 	addi	r2,r2,134
8110f748:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
8110f74c:	e0ffff03 	ldbu	r3,-4(fp)
8110f750:	00a04574 	movhi	r2,33045
8110f754:	10926304 	addi	r2,r2,18828
8110f758:	18c02324 	muli	r3,r3,140
8110f75c:	10c5883a 	add	r2,r2,r3
8110f760:	10802204 	addi	r2,r2,136
8110f764:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8110f768:	e0bfff03 	ldbu	r2,-4(fp)
8110f76c:	10800044 	addi	r2,r2,1
8110f770:	e0bfff05 	stb	r2,-4(fp)
8110f774:	e0bfff03 	ldbu	r2,-4(fp)
8110f778:	108001b0 	cmpltui	r2,r2,6
8110f77c:	103fd51e 	bne	r2,zero,8110f6d4 <__reset+0xfb0ef6d4>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
8110f780:	e03fff05 	stb	zero,-4(fp)
8110f784:	00002806 	br	8110f828 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
8110f788:	e0bfff03 	ldbu	r2,-4(fp)
8110f78c:	10c01324 	muli	r3,r2,76
8110f790:	00a04574 	movhi	r2,33045
8110f794:	10ab5504 	addi	r2,r2,-21164
8110f798:	1885883a 	add	r2,r3,r2
8110f79c:	01801004 	movi	r6,64
8110f7a0:	000b883a 	mov	r5,zero
8110f7a4:	1009883a 	mov	r4,r2
8110f7a8:	1117e1c0 	call	81117e1c <memset>
		xBuffer64[ucIL].bSent = FALSE;
8110f7ac:	e0ffff03 	ldbu	r3,-4(fp)
8110f7b0:	00a04574 	movhi	r2,33045
8110f7b4:	10ab5504 	addi	r2,r2,-21164
8110f7b8:	18c01324 	muli	r3,r3,76
8110f7bc:	10c5883a 	add	r2,r2,r3
8110f7c0:	10801004 	addi	r2,r2,64
8110f7c4:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
8110f7c8:	e0ffff03 	ldbu	r3,-4(fp)
8110f7cc:	00a04574 	movhi	r2,33045
8110f7d0:	10ab5504 	addi	r2,r2,-21164
8110f7d4:	18c01324 	muli	r3,r3,76
8110f7d8:	10c5883a 	add	r2,r2,r3
8110f7dc:	10801104 	addi	r2,r2,68
8110f7e0:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
8110f7e4:	e0ffff03 	ldbu	r3,-4(fp)
8110f7e8:	00a04574 	movhi	r2,33045
8110f7ec:	10ab5504 	addi	r2,r2,-21164
8110f7f0:	18c01324 	muli	r3,r3,76
8110f7f4:	10c5883a 	add	r2,r2,r3
8110f7f8:	10801184 	addi	r2,r2,70
8110f7fc:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
8110f800:	e0ffff03 	ldbu	r3,-4(fp)
8110f804:	00a04574 	movhi	r2,33045
8110f808:	10ab5504 	addi	r2,r2,-21164
8110f80c:	18c01324 	muli	r3,r3,76
8110f810:	10c5883a 	add	r2,r2,r3
8110f814:	10801204 	addi	r2,r2,72
8110f818:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
8110f81c:	e0bfff03 	ldbu	r2,-4(fp)
8110f820:	10800044 	addi	r2,r2,1
8110f824:	e0bfff05 	stb	r2,-4(fp)
8110f828:	e0bfff03 	ldbu	r2,-4(fp)
8110f82c:	10800230 	cmpltui	r2,r2,8
8110f830:	103fd51e 	bne	r2,zero,8110f788 <__reset+0xfb0ef788>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
8110f834:	e03fff05 	stb	zero,-4(fp)
8110f838:	00002806 	br	8110f8dc <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
8110f83c:	e0bfff03 	ldbu	r2,-4(fp)
8110f840:	10c00b24 	muli	r3,r2,44
8110f844:	00a04574 	movhi	r2,33045
8110f848:	10bfd904 	addi	r2,r2,-156
8110f84c:	1885883a 	add	r2,r3,r2
8110f850:	01800804 	movi	r6,32
8110f854:	000b883a 	mov	r5,zero
8110f858:	1009883a 	mov	r4,r2
8110f85c:	1117e1c0 	call	81117e1c <memset>
		xBuffer32[ucIL].bSent = FALSE;
8110f860:	e0ffff03 	ldbu	r3,-4(fp)
8110f864:	00a04574 	movhi	r2,33045
8110f868:	10bfd904 	addi	r2,r2,-156
8110f86c:	18c00b24 	muli	r3,r3,44
8110f870:	10c5883a 	add	r2,r2,r3
8110f874:	10800804 	addi	r2,r2,32
8110f878:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
8110f87c:	e0ffff03 	ldbu	r3,-4(fp)
8110f880:	00a04574 	movhi	r2,33045
8110f884:	10bfd904 	addi	r2,r2,-156
8110f888:	18c00b24 	muli	r3,r3,44
8110f88c:	10c5883a 	add	r2,r2,r3
8110f890:	10800904 	addi	r2,r2,36
8110f894:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
8110f898:	e0ffff03 	ldbu	r3,-4(fp)
8110f89c:	00a04574 	movhi	r2,33045
8110f8a0:	10bfd904 	addi	r2,r2,-156
8110f8a4:	18c00b24 	muli	r3,r3,44
8110f8a8:	10c5883a 	add	r2,r2,r3
8110f8ac:	10800984 	addi	r2,r2,38
8110f8b0:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
8110f8b4:	e0ffff03 	ldbu	r3,-4(fp)
8110f8b8:	00a04574 	movhi	r2,33045
8110f8bc:	10bfd904 	addi	r2,r2,-156
8110f8c0:	18c00b24 	muli	r3,r3,44
8110f8c4:	10c5883a 	add	r2,r2,r3
8110f8c8:	10800a04 	addi	r2,r2,40
8110f8cc:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
8110f8d0:	e0bfff03 	ldbu	r2,-4(fp)
8110f8d4:	10800044 	addi	r2,r2,1
8110f8d8:	e0bfff05 	stb	r2,-4(fp)
8110f8dc:	e0bfff03 	ldbu	r2,-4(fp)
8110f8e0:	10800230 	cmpltui	r2,r2,8
8110f8e4:	103fd51e 	bne	r2,zero,8110f83c <__reset+0xfb0ef83c>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8110f8e8:	e03fff05 	stb	zero,-4(fp)
8110f8ec:	00001b06 	br	8110f95c <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
8110f8f0:	e0ffff03 	ldbu	r3,-4(fp)
8110f8f4:	00a04574 	movhi	r2,33045
8110f8f8:	10abed04 	addi	r2,r2,-20556
8110f8fc:	18c01524 	muli	r3,r3,84
8110f900:	10c5883a 	add	r2,r2,r3
8110f904:	10800104 	addi	r2,r2,4
8110f908:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
8110f90c:	e0ffff03 	ldbu	r3,-4(fp)
8110f910:	00a04574 	movhi	r2,33045
8110f914:	10abed04 	addi	r2,r2,-20556
8110f918:	18c01524 	muli	r3,r3,84
8110f91c:	10c5883a 	add	r2,r2,r3
8110f920:	10800484 	addi	r2,r2,18
8110f924:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
8110f928:	e0bfff03 	ldbu	r2,-4(fp)
8110f92c:	10801524 	muli	r2,r2,84
8110f930:	10c00504 	addi	r3,r2,20
8110f934:	00a04574 	movhi	r2,33045
8110f938:	10abed04 	addi	r2,r2,-20556
8110f93c:	1885883a 	add	r2,r3,r2
8110f940:	01801004 	movi	r6,64
8110f944:	000b883a 	mov	r5,zero
8110f948:	1009883a 	mov	r4,r2
8110f94c:	1117e1c0 	call	81117e1c <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8110f950:	e0bfff03 	ldbu	r2,-4(fp)
8110f954:	10800044 	addi	r2,r2,1
8110f958:	e0bfff05 	stb	r2,-4(fp)
8110f95c:	e0bfff03 	ldbu	r2,-4(fp)
8110f960:	10800130 	cmpltui	r2,r2,4
8110f964:	103fe21e 	bne	r2,zero,8110f8f0 <__reset+0xfb0ef8f0>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
8110f968:	0001883a 	nop
8110f96c:	e037883a 	mov	sp,fp
8110f970:	dfc00117 	ldw	ra,4(sp)
8110f974:	df000017 	ldw	fp,0(sp)
8110f978:	dec00204 	addi	sp,sp,8
8110f97c:	f800283a 	ret

8110f980 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
8110f980:	defff704 	addi	sp,sp,-36
8110f984:	de00012e 	bgeu	sp,et,8110f98c <main+0xc>
8110f988:	003b68fa 	trap	3
8110f98c:	dfc00815 	stw	ra,32(sp)
8110f990:	df000715 	stw	fp,28(sp)
8110f994:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
8110f998:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
8110f99c:	112ecb40 	call	8112ecb4 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
8110f9a0:	01604534 	movhi	r5,33044
8110f9a4:	294ee004 	addi	r5,r5,15232
8110f9a8:	01204534 	movhi	r4,33044
8110f9ac:	210ee104 	addi	r4,r4,15236
8110f9b0:	1116bd40 	call	81116bd4 <fopen>
8110f9b4:	d0a05515 	stw	r2,-32428(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
8110f9b8:	d0a05517 	ldw	r2,-32428(gp)
8110f9bc:	100f883a 	mov	r7,r2
8110f9c0:	01800484 	movi	r6,18
8110f9c4:	01400044 	movi	r5,1
8110f9c8:	01204534 	movhi	r4,33044
8110f9cc:	210ee604 	addi	r4,r4,15256
8110f9d0:	11172b80 	call	811172b8 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
8110f9d4:	111488c0 	call	8111488c <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
8110f9d8:	11151880 	call	81115188 <bTestSimucamCriticalHW>
8110f9dc:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110f9e0:	e0bffe17 	ldw	r2,-8(fp)
8110f9e4:	1000031e 	bne	r2,zero,8110f9f4 <main+0x74>
		vFailTestCriticasParts();
8110f9e8:	11124240 	call	81112424 <vFailTestCriticasParts>
		return -1;
8110f9ec:	00bfffc4 	movi	r2,-1
8110f9f0:	00004006 	br	8110faf4 <main+0x174>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
8110f9f4:	1114fd40 	call	81114fd4 <bInitializeSDCard>
8110f9f8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110f9fc:	e0bffe17 	ldw	r2,-8(fp)
8110fa00:	1000031e 	bne	r2,zero,8110fa10 <main+0x90>
		vFailTestCriticasParts();
8110fa04:	11124240 	call	81112424 <vFailTestCriticasParts>
		return -1;
8110fa08:	00bfffc4 	movi	r2,-1
8110fa0c:	00003906 	br	8110faf4 <main+0x174>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
8110fa10:	11114280 	call	81111428 <vLoadDefaultETHConf>
8110fa14:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110fa18:	e0bffe17 	ldw	r2,-8(fp)
8110fa1c:	1000091e 	bne	r2,zero,8110fa44 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. (exit) \n");
8110fa20:	d0a05517 	ldw	r2,-32428(gp)
8110fa24:	100f883a 	mov	r7,r2
8110fa28:	01801644 	movi	r6,89
8110fa2c:	01400044 	movi	r5,1
8110fa30:	01204534 	movhi	r4,33044
8110fa34:	210eeb04 	addi	r4,r4,15276
8110fa38:	11172b80 	call	811172b8 <fwrite>
		#endif
		return -1;
8110fa3c:	00bfffc4 	movi	r2,-1
8110fa40:	00002c06 	br	8110faf4 <main+0x174>
	}

	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
8110fa44:	1111dfc0 	call	81111dfc <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
8110fa48:	110f1440 	call	8110f144 <bResourcesInitRTOS>
8110fa4c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8110fa50:	e0bffe17 	ldw	r2,-8(fp)
8110fa54:	1000091e 	bne	r2,zero,8110fa7c <main+0xfc>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
8110fa58:	d0a05517 	ldw	r2,-32428(gp)
8110fa5c:	100f883a 	mov	r7,r2
8110fa60:	01800ac4 	movi	r6,43
8110fa64:	01400044 	movi	r5,1
8110fa68:	01204534 	movhi	r4,33044
8110fa6c:	210f0204 	addi	r4,r4,15368
8110fa70:	11172b80 	call	811172b8 <fwrite>
		return -1;
8110fa74:	00bfffc4 	movi	r2,-1
8110fa78:	00001e06 	br	8110faf4 <main+0x174>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
8110fa7c:	01204574 	movhi	r4,33045
8110fa80:	21385104 	addi	r4,r4,-7868
8110fa84:	11149cc0 	call	811149cc <vSimucamStructureInit>

	vVariablesInitialization();
8110fa88:	110f66c0 	call	8110f66c <vVariablesInitialization>


	vFillMemmoryPattern(&xSimMeb);
8110fa8c:	01204574 	movhi	r4,33045
8110fa90:	21385104 	addi	r4,r4,-7868
8110fa94:	110fb080 	call	8110fb08 <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
8110fa98:	d8000415 	stw	zero,16(sp)
8110fa9c:	d8000315 	stw	zero,12(sp)
8110faa0:	00810004 	movi	r2,1024
8110faa4:	d8800215 	stw	r2,8(sp)
8110faa8:	00a04574 	movhi	r2,33045
8110faac:	108a4504 	addi	r2,r2,10516
8110fab0:	d8800115 	stw	r2,4(sp)
8110fab4:	00800044 	movi	r2,1
8110fab8:	d8800015 	stw	r2,0(sp)
8110fabc:	01c00044 	movi	r7,1
8110fac0:	01a04574 	movhi	r6,33045
8110fac4:	318e4404 	addi	r6,r6,14608
8110fac8:	000b883a 	mov	r5,zero
8110facc:	01204474 	movhi	r4,33041
8110fad0:	21289d04 	addi	r4,r4,-23948
8110fad4:	11358b00 	call	811358b0 <OSTaskCreateExt>
8110fad8:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
8110fadc:	e0bfff03 	ldbu	r2,-4(fp)
8110fae0:	1000021e 	bne	r2,zero,8110faec <main+0x16c>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
8110fae4:	112efe40 	call	8112efe4 <OSStart>
8110fae8:	00000106 	br	8110faf0 <main+0x170>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
8110faec:	11128100 	call	81112810 <vFailInitialization>
	}
  
	return 0;
8110faf0:	0005883a 	mov	r2,zero
}
8110faf4:	e037883a 	mov	sp,fp
8110faf8:	dfc00117 	ldw	ra,4(sp)
8110fafc:	df000017 	ldw	fp,0(sp)
8110fb00:	dec00204 	addi	sp,sp,8
8110fb04:	f800283a 	ret

8110fb08 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
8110fb08:	defff604 	addi	sp,sp,-40
8110fb0c:	de00012e 	bgeu	sp,et,8110fb14 <vFillMemmoryPattern+0xc>
8110fb10:	003b68fa 	trap	3
8110fb14:	dfc00915 	stw	ra,36(sp)
8110fb18:	df000815 	stw	fp,32(sp)
8110fb1c:	df000804 	addi	fp,sp,32
8110fb20:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
8110fb24:	00800044 	movi	r2,1
8110fb28:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
8110fb2c:	d0a05517 	ldw	r2,-32428(gp)
8110fb30:	100f883a 	mov	r7,r2
8110fb34:	018009c4 	movi	r6,39
8110fb38:	01400044 	movi	r5,1
8110fb3c:	01204534 	movhi	r4,33044
8110fb40:	210f0d04 	addi	r4,r4,15412
8110fb44:	11172b80 	call	811172b8 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8110fb48:	e03ffa05 	stb	zero,-24(fp)
8110fb4c:	00007606 	br	8110fd28 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
8110fb50:	e03ffc85 	stb	zero,-14(fp)
8110fb54:	00006706 	br	8110fcf4 <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
8110fb58:	e0bffc83 	ldbu	r2,-14(fp)
8110fb5c:	e0ffff17 	ldw	r3,-4(fp)
8110fb60:	10808f24 	muli	r2,r2,572
8110fb64:	1885883a 	add	r2,r3,r2
8110fb68:	10804b04 	addi	r2,r2,300
8110fb6c:	1080000b 	ldhu	r2,0(r2)
8110fb70:	10ffffcc 	andi	r3,r2,65535
8110fb74:	e0bffc83 	ldbu	r2,-14(fp)
8110fb78:	e13fff17 	ldw	r4,-4(fp)
8110fb7c:	10808f24 	muli	r2,r2,572
8110fb80:	2085883a 	add	r2,r4,r2
8110fb84:	10804a04 	addi	r2,r2,296
8110fb88:	1080000b 	ldhu	r2,0(r2)
8110fb8c:	10bfffcc 	andi	r2,r2,65535
8110fb90:	1885883a 	add	r2,r3,r2
8110fb94:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
8110fb98:	e0bffc83 	ldbu	r2,-14(fp)
8110fb9c:	e0ffff17 	ldw	r3,-4(fp)
8110fba0:	10808f24 	muli	r2,r2,572
8110fba4:	1885883a 	add	r2,r3,r2
8110fba8:	10804a84 	addi	r2,r2,298
8110fbac:	1080000b 	ldhu	r2,0(r2)
8110fbb0:	10ffffcc 	andi	r3,r2,65535
8110fbb4:	e0bffc83 	ldbu	r2,-14(fp)
8110fbb8:	e13fff17 	ldw	r4,-4(fp)
8110fbbc:	10808f24 	muli	r2,r2,572
8110fbc0:	2085883a 	add	r2,r4,r2
8110fbc4:	10804984 	addi	r2,r2,294
8110fbc8:	1080000b 	ldhu	r2,0(r2)
8110fbcc:	10bfffcc 	andi	r2,r2,65535
8110fbd0:	1887883a 	add	r3,r3,r2
8110fbd4:	e0bffc83 	ldbu	r2,-14(fp)
8110fbd8:	e13fff17 	ldw	r4,-4(fp)
8110fbdc:	10808f24 	muli	r2,r2,572
8110fbe0:	2085883a 	add	r2,r4,r2
8110fbe4:	10804904 	addi	r2,r2,292
8110fbe8:	1080000b 	ldhu	r2,0(r2)
8110fbec:	10bfffcc 	andi	r2,r2,65535
8110fbf0:	1885883a 	add	r2,r3,r2
8110fbf4:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
8110fbf8:	e03ffc05 	stb	zero,-16(fp)
8110fbfc:	00003706 	br	8110fcdc <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8110fc00:	e03ffc45 	stb	zero,-15(fp)
8110fc04:	00002606 	br	8110fca0 <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
8110fc08:	e0bffc43 	ldbu	r2,-15(fp)
8110fc0c:	10000b1e 	bne	r2,zero,8110fc3c <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
8110fc10:	e0bffc83 	ldbu	r2,-14(fp)
8110fc14:	e13ffc03 	ldbu	r4,-16(fp)
8110fc18:	e0ffff17 	ldw	r3,-4(fp)
8110fc1c:	21000624 	muli	r4,r4,24
8110fc20:	10808f24 	muli	r2,r2,572
8110fc24:	2085883a 	add	r2,r4,r2
8110fc28:	1885883a 	add	r2,r3,r2
8110fc2c:	10802804 	addi	r2,r2,160
8110fc30:	10800017 	ldw	r2,0(r2)
8110fc34:	e0bffb15 	stw	r2,-20(fp)
8110fc38:	00000a06 	br	8110fc64 <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
8110fc3c:	e0bffc83 	ldbu	r2,-14(fp)
8110fc40:	e13ffc03 	ldbu	r4,-16(fp)
8110fc44:	e0ffff17 	ldw	r3,-4(fp)
8110fc48:	21000624 	muli	r4,r4,24
8110fc4c:	10808f24 	muli	r2,r2,572
8110fc50:	2085883a 	add	r2,r4,r2
8110fc54:	1885883a 	add	r2,r3,r2
8110fc58:	10802b04 	addi	r2,r2,172
8110fc5c:	10800017 	ldw	r2,0(r2)
8110fc60:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
8110fc64:	e0fffa03 	ldbu	r3,-24(fp)
8110fc68:	e13ffc03 	ldbu	r4,-16(fp)
8110fc6c:	e17ffc43 	ldbu	r5,-15(fp)
8110fc70:	e0bffe17 	ldw	r2,-8(fp)
8110fc74:	d8800115 	stw	r2,4(sp)
8110fc78:	e0bffd17 	ldw	r2,-12(fp)
8110fc7c:	d8800015 	stw	r2,0(sp)
8110fc80:	280f883a 	mov	r7,r5
8110fc84:	200d883a 	mov	r6,r4
8110fc88:	e17ffb17 	ldw	r5,-20(fp)
8110fc8c:	1809883a 	mov	r4,r3
8110fc90:	1114d580 	call	81114d58 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8110fc94:	e0bffc43 	ldbu	r2,-15(fp)
8110fc98:	10800044 	addi	r2,r2,1
8110fc9c:	e0bffc45 	stb	r2,-15(fp)
8110fca0:	e0bffc43 	ldbu	r2,-15(fp)
8110fca4:	108000b0 	cmpltui	r2,r2,2
8110fca8:	103fd71e 	bne	r2,zero,8110fc08 <__reset+0xfb0efc08>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
8110fcac:	d0a05517 	ldw	r2,-32428(gp)
8110fcb0:	e0fffc83 	ldbu	r3,-14(fp)
8110fcb4:	e13ffc03 	ldbu	r4,-16(fp)
8110fcb8:	200f883a 	mov	r7,r4
8110fcbc:	180d883a 	mov	r6,r3
8110fcc0:	01604534 	movhi	r5,33044
8110fcc4:	294f1704 	addi	r5,r5,15452
8110fcc8:	1009883a 	mov	r4,r2
8110fccc:	1116c1c0 	call	81116c1c <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
8110fcd0:	e0bffc03 	ldbu	r2,-16(fp)
8110fcd4:	10800044 	addi	r2,r2,1
8110fcd8:	e0bffc05 	stb	r2,-16(fp)
8110fcdc:	e0bffc03 	ldbu	r2,-16(fp)
8110fce0:	10800130 	cmpltui	r2,r2,4
8110fce4:	103fc61e 	bne	r2,zero,8110fc00 <__reset+0xfb0efc00>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
8110fce8:	e0bffc83 	ldbu	r2,-14(fp)
8110fcec:	10800044 	addi	r2,r2,1
8110fcf0:	e0bffc85 	stb	r2,-14(fp)
8110fcf4:	e0fffc83 	ldbu	r3,-14(fp)
8110fcf8:	e0bffcc3 	ldbu	r2,-13(fp)
8110fcfc:	18bf9636 	bltu	r3,r2,8110fb58 <__reset+0xfb0efb58>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
8110fd00:	d0a05517 	ldw	r2,-32428(gp)
8110fd04:	e0fffa03 	ldbu	r3,-24(fp)
8110fd08:	180d883a 	mov	r6,r3
8110fd0c:	01604534 	movhi	r5,33044
8110fd10:	294f1c04 	addi	r5,r5,15472
8110fd14:	1009883a 	mov	r4,r2
8110fd18:	1116c1c0 	call	81116c1c <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8110fd1c:	e0bffa03 	ldbu	r2,-24(fp)
8110fd20:	10800044 	addi	r2,r2,1
8110fd24:	e0bffa05 	stb	r2,-24(fp)
8110fd28:	e0bffa03 	ldbu	r2,-24(fp)
8110fd2c:	108000b0 	cmpltui	r2,r2,2
8110fd30:	103f871e 	bne	r2,zero,8110fb50 <__reset+0xfb0efb50>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
8110fd34:	d0a05517 	ldw	r2,-32428(gp)
8110fd38:	100f883a 	mov	r7,r2
8110fd3c:	01800404 	movi	r6,16
8110fd40:	01400044 	movi	r5,1
8110fd44:	01204534 	movhi	r4,33044
8110fd48:	210f2004 	addi	r4,r4,15488
8110fd4c:	11172b80 	call	811172b8 <fwrite>
#endif


}
8110fd50:	0001883a 	nop
8110fd54:	e037883a 	mov	sp,fp
8110fd58:	dfc00117 	ldw	ra,4(sp)
8110fd5c:	df000017 	ldw	fp,0(sp)
8110fd60:	dec00204 	addi	sp,sp,8
8110fd64:	f800283a 	ret

8110fd68 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
8110fd68:	defff604 	addi	sp,sp,-40
8110fd6c:	de00012e 	bgeu	sp,et,8110fd74 <vPrintMemmoryPattern+0xc>
8110fd70:	003b68fa 	trap	3
8110fd74:	dfc00915 	stw	ra,36(sp)
8110fd78:	df000815 	stw	fp,32(sp)
8110fd7c:	df000804 	addi	fp,sp,32
8110fd80:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
8110fd84:	00800044 	movi	r2,1
8110fd88:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
8110fd8c:	d0a05517 	ldw	r2,-32428(gp)
8110fd90:	100f883a 	mov	r7,r2
8110fd94:	018009c4 	movi	r6,39
8110fd98:	01400044 	movi	r5,1
8110fd9c:	01204534 	movhi	r4,33044
8110fda0:	210f0d04 	addi	r4,r4,15412
8110fda4:	11172b80 	call	811172b8 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8110fda8:	e03ffa05 	stb	zero,-24(fp)
8110fdac:	00007606 	br	8110ff88 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
8110fdb0:	e03ffc85 	stb	zero,-14(fp)
8110fdb4:	00006706 	br	8110ff54 <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
8110fdb8:	e0bffc83 	ldbu	r2,-14(fp)
8110fdbc:	e0ffff17 	ldw	r3,-4(fp)
8110fdc0:	10808f24 	muli	r2,r2,572
8110fdc4:	1885883a 	add	r2,r3,r2
8110fdc8:	10804b04 	addi	r2,r2,300
8110fdcc:	1080000b 	ldhu	r2,0(r2)
8110fdd0:	10ffffcc 	andi	r3,r2,65535
8110fdd4:	e0bffc83 	ldbu	r2,-14(fp)
8110fdd8:	e13fff17 	ldw	r4,-4(fp)
8110fddc:	10808f24 	muli	r2,r2,572
8110fde0:	2085883a 	add	r2,r4,r2
8110fde4:	10804a04 	addi	r2,r2,296
8110fde8:	1080000b 	ldhu	r2,0(r2)
8110fdec:	10bfffcc 	andi	r2,r2,65535
8110fdf0:	1885883a 	add	r2,r3,r2
8110fdf4:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
8110fdf8:	e0bffc83 	ldbu	r2,-14(fp)
8110fdfc:	e0ffff17 	ldw	r3,-4(fp)
8110fe00:	10808f24 	muli	r2,r2,572
8110fe04:	1885883a 	add	r2,r3,r2
8110fe08:	10804a84 	addi	r2,r2,298
8110fe0c:	1080000b 	ldhu	r2,0(r2)
8110fe10:	10ffffcc 	andi	r3,r2,65535
8110fe14:	e0bffc83 	ldbu	r2,-14(fp)
8110fe18:	e13fff17 	ldw	r4,-4(fp)
8110fe1c:	10808f24 	muli	r2,r2,572
8110fe20:	2085883a 	add	r2,r4,r2
8110fe24:	10804984 	addi	r2,r2,294
8110fe28:	1080000b 	ldhu	r2,0(r2)
8110fe2c:	10bfffcc 	andi	r2,r2,65535
8110fe30:	1887883a 	add	r3,r3,r2
8110fe34:	e0bffc83 	ldbu	r2,-14(fp)
8110fe38:	e13fff17 	ldw	r4,-4(fp)
8110fe3c:	10808f24 	muli	r2,r2,572
8110fe40:	2085883a 	add	r2,r4,r2
8110fe44:	10804904 	addi	r2,r2,292
8110fe48:	1080000b 	ldhu	r2,0(r2)
8110fe4c:	10bfffcc 	andi	r2,r2,65535
8110fe50:	1885883a 	add	r2,r3,r2
8110fe54:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
8110fe58:	e03ffc05 	stb	zero,-16(fp)
8110fe5c:	00003706 	br	8110ff3c <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8110fe60:	e03ffc45 	stb	zero,-15(fp)
8110fe64:	00002606 	br	8110ff00 <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
8110fe68:	e0bffc43 	ldbu	r2,-15(fp)
8110fe6c:	10000b1e 	bne	r2,zero,8110fe9c <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
8110fe70:	e0bffc83 	ldbu	r2,-14(fp)
8110fe74:	e13ffc03 	ldbu	r4,-16(fp)
8110fe78:	e0ffff17 	ldw	r3,-4(fp)
8110fe7c:	21000624 	muli	r4,r4,24
8110fe80:	10808f24 	muli	r2,r2,572
8110fe84:	2085883a 	add	r2,r4,r2
8110fe88:	1885883a 	add	r2,r3,r2
8110fe8c:	10802804 	addi	r2,r2,160
8110fe90:	10800017 	ldw	r2,0(r2)
8110fe94:	e0bffb15 	stw	r2,-20(fp)
8110fe98:	00000a06 	br	8110fec4 <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
8110fe9c:	e0bffc83 	ldbu	r2,-14(fp)
8110fea0:	e13ffc03 	ldbu	r4,-16(fp)
8110fea4:	e0ffff17 	ldw	r3,-4(fp)
8110fea8:	21000624 	muli	r4,r4,24
8110feac:	10808f24 	muli	r2,r2,572
8110feb0:	2085883a 	add	r2,r4,r2
8110feb4:	1885883a 	add	r2,r3,r2
8110feb8:	10802b04 	addi	r2,r2,172
8110febc:	10800017 	ldw	r2,0(r2)
8110fec0:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
8110fec4:	e0fffa03 	ldbu	r3,-24(fp)
8110fec8:	e13ffc03 	ldbu	r4,-16(fp)
8110fecc:	e17ffc43 	ldbu	r5,-15(fp)
8110fed0:	e0bffe17 	ldw	r2,-8(fp)
8110fed4:	d8800115 	stw	r2,4(sp)
8110fed8:	e0bffd17 	ldw	r2,-12(fp)
8110fedc:	d8800015 	stw	r2,0(sp)
8110fee0:	280f883a 	mov	r7,r5
8110fee4:	200d883a 	mov	r6,r4
8110fee8:	e17ffb17 	ldw	r5,-20(fp)
8110feec:	1809883a 	mov	r4,r3
8110fef0:	1114d580 	call	81114d58 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8110fef4:	e0bffc43 	ldbu	r2,-15(fp)
8110fef8:	10800044 	addi	r2,r2,1
8110fefc:	e0bffc45 	stb	r2,-15(fp)
8110ff00:	e0bffc43 	ldbu	r2,-15(fp)
8110ff04:	108000b0 	cmpltui	r2,r2,2
8110ff08:	103fd71e 	bne	r2,zero,8110fe68 <__reset+0xfb0efe68>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
8110ff0c:	d0a05517 	ldw	r2,-32428(gp)
8110ff10:	e0fffc83 	ldbu	r3,-14(fp)
8110ff14:	e13ffc03 	ldbu	r4,-16(fp)
8110ff18:	200f883a 	mov	r7,r4
8110ff1c:	180d883a 	mov	r6,r3
8110ff20:	01604534 	movhi	r5,33044
8110ff24:	294f1704 	addi	r5,r5,15452
8110ff28:	1009883a 	mov	r4,r2
8110ff2c:	1116c1c0 	call	81116c1c <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
8110ff30:	e0bffc03 	ldbu	r2,-16(fp)
8110ff34:	10800044 	addi	r2,r2,1
8110ff38:	e0bffc05 	stb	r2,-16(fp)
8110ff3c:	e0bffc03 	ldbu	r2,-16(fp)
8110ff40:	10800130 	cmpltui	r2,r2,4
8110ff44:	103fc61e 	bne	r2,zero,8110fe60 <__reset+0xfb0efe60>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
8110ff48:	e0bffc83 	ldbu	r2,-14(fp)
8110ff4c:	10800044 	addi	r2,r2,1
8110ff50:	e0bffc85 	stb	r2,-14(fp)
8110ff54:	e0fffc83 	ldbu	r3,-14(fp)
8110ff58:	e0bffcc3 	ldbu	r2,-13(fp)
8110ff5c:	18bf9636 	bltu	r3,r2,8110fdb8 <__reset+0xfb0efdb8>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
8110ff60:	d0a05517 	ldw	r2,-32428(gp)
8110ff64:	e0fffa03 	ldbu	r3,-24(fp)
8110ff68:	180d883a 	mov	r6,r3
8110ff6c:	01604534 	movhi	r5,33044
8110ff70:	294f1c04 	addi	r5,r5,15472
8110ff74:	1009883a 	mov	r4,r2
8110ff78:	1116c1c0 	call	81116c1c <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8110ff7c:	e0bffa03 	ldbu	r2,-24(fp)
8110ff80:	10800044 	addi	r2,r2,1
8110ff84:	e0bffa05 	stb	r2,-24(fp)
8110ff88:	e0bffa03 	ldbu	r2,-24(fp)
8110ff8c:	108000b0 	cmpltui	r2,r2,2
8110ff90:	103f871e 	bne	r2,zero,8110fdb0 <__reset+0xfb0efdb0>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
8110ff94:	d0a05517 	ldw	r2,-32428(gp)
8110ff98:	100f883a 	mov	r7,r2
8110ff9c:	01800404 	movi	r6,16
8110ffa0:	01400044 	movi	r5,1
8110ffa4:	01204534 	movhi	r4,33044
8110ffa8:	210f2004 	addi	r4,r4,15488
8110ffac:	11172b80 	call	811172b8 <fwrite>
#endif


}
8110ffb0:	0001883a 	nop
8110ffb4:	e037883a 	mov	sp,fp
8110ffb8:	dfc00117 	ldw	ra,4(sp)
8110ffbc:	df000017 	ldw	fp,0(sp)
8110ffc0:	dec00204 	addi	sp,sp,8
8110ffc4:	f800283a 	ret

8110ffc8 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
8110ffc8:	defffe04 	addi	sp,sp,-8
8110ffcc:	de00012e 	bgeu	sp,et,8110ffd4 <vCCDLoadDefaultValues+0xc>
8110ffd0:	003b68fa 	trap	3
8110ffd4:	df000115 	stw	fp,4(sp)
8110ffd8:	df000104 	addi	fp,sp,4
8110ffdc:	e13fff15 	stw	r4,-4(fp)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadCcdDefsSDCard();

	ccdDef->usiHeight = 4510;
8110ffe0:	e0bfff17 	ldw	r2,-4(fp)
8110ffe4:	00c46784 	movi	r3,4510
8110ffe8:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = 30;
8110ffec:	e0bfff17 	ldw	r2,-4(fp)
8110fff0:	00c00784 	movi	r3,30
8110fff4:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = 2255;
8110fff8:	e0bfff17 	ldw	r2,-4(fp)
8110fffc:	00c233c4 	movi	r3,2255
81110000:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = 15;
81110004:	e0bfff17 	ldw	r2,-4(fp)
81110008:	00c003c4 	movi	r3,15
8111000c:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = 25;
81110010:	e0bfff17 	ldw	r2,-4(fp)
81110014:	00c00644 	movi	r3,25
81110018:	10c0000d 	sth	r3,0(r2)
}
8111001c:	0001883a 	nop
81110020:	e037883a 	mov	sp,fp
81110024:	df000017 	ldw	fp,0(sp)
81110028:	dec00104 	addi	sp,sp,4
8111002c:	f800283a 	ret

81110030 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81110030:	defff904 	addi	sp,sp,-28
81110034:	de00012e 	bgeu	sp,et,8111003c <vCCDChangeValues+0xc>
81110038:	003b68fa 	trap	3
8111003c:	df000615 	stw	fp,24(sp)
81110040:	df000604 	addi	fp,sp,24
81110044:	e13ffa15 	stw	r4,-24(fp)
81110048:	2811883a 	mov	r8,r5
8111004c:	300b883a 	mov	r5,r6
81110050:	3809883a 	mov	r4,r7
81110054:	e0c00117 	ldw	r3,4(fp)
81110058:	e0800217 	ldw	r2,8(fp)
8111005c:	e23ffb0d 	sth	r8,-20(fp)
81110060:	e17ffc0d 	sth	r5,-16(fp)
81110064:	e13ffd0d 	sth	r4,-12(fp)
81110068:	e0fffe0d 	sth	r3,-8(fp)
8111006c:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81110070:	e0bffa17 	ldw	r2,-24(fp)
81110074:	e0fffb0b 	ldhu	r3,-20(fp)
81110078:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
8111007c:	e0bffa17 	ldw	r2,-24(fp)
81110080:	e0fffc0b 	ldhu	r3,-16(fp)
81110084:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81110088:	e0bffa17 	ldw	r2,-24(fp)
8111008c:	e0fffd0b 	ldhu	r3,-12(fp)
81110090:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81110094:	e0bffa17 	ldw	r2,-24(fp)
81110098:	e0fffe0b 	ldhu	r3,-8(fp)
8111009c:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
811100a0:	e0bffa17 	ldw	r2,-24(fp)
811100a4:	e0ffff0b 	ldhu	r3,-4(fp)
811100a8:	10c0000d 	sth	r3,0(r2)
}
811100ac:	0001883a 	nop
811100b0:	e037883a 	mov	sp,fp
811100b4:	df000017 	ldw	fp,0(sp)
811100b8:	dec00104 	addi	sp,sp,4
811100bc:	f800283a 	ret

811100c0 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
811100c0:	defff904 	addi	sp,sp,-28
811100c4:	de00012e 	bgeu	sp,et,811100cc <bSendUART128v2+0xc>
811100c8:	003b68fa 	trap	3
811100cc:	dfc00615 	stw	ra,24(sp)
811100d0:	df000515 	stw	fp,20(sp)
811100d4:	df000504 	addi	fp,sp,20
811100d8:	e13ffe15 	stw	r4,-8(fp)
811100dc:	2805883a 	mov	r2,r5
811100e0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
811100e4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811100e8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811100ec:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811100f0:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811100f4:	d0a05617 	ldw	r2,-32424(gp)
811100f8:	e0fffd04 	addi	r3,fp,-12
811100fc:	180d883a 	mov	r6,r3
81110100:	01400504 	movi	r5,20
81110104:	1009883a 	mov	r4,r2
81110108:	1134cf80 	call	81134cf8 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8111010c:	e0bffd03 	ldbu	r2,-12(fp)
81110110:	10803fcc 	andi	r2,r2,255
81110114:	10000326 	beq	r2,zero,81110124 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81110118:	1112a780 	call	81112a78 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
8111011c:	e0bffc17 	ldw	r2,-16(fp)
81110120:	00009e06 	br	8111039c <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81110124:	d0a06017 	ldw	r2,-32384(gp)
81110128:	e0fffd04 	addi	r3,fp,-12
8111012c:	180d883a 	mov	r6,r3
81110130:	01400104 	movi	r5,4
81110134:	1009883a 	mov	r4,r2
81110138:	1132cec0 	call	81132cec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111013c:	e0bffd03 	ldbu	r2,-12(fp)
81110140:	10803fcc 	andi	r2,r2,255
81110144:	10001126 	beq	r2,zero,8111018c <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81110148:	d0a05517 	ldw	r2,-32428(gp)
8111014c:	100f883a 	mov	r7,r2
81110150:	01801484 	movi	r6,82
81110154:	01400044 	movi	r5,1
81110158:	01204534 	movhi	r4,33044
8111015c:	210f2504 	addi	r4,r4,15508
81110160:	11172b80 	call	811172b8 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81110164:	d0a05617 	ldw	r2,-32424(gp)
81110168:	1009883a 	mov	r4,r2
8111016c:	11350800 	call	81135080 <OSSemPost>
81110170:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81110174:	e0bffd03 	ldbu	r2,-12(fp)
81110178:	10803fcc 	andi	r2,r2,255
8111017c:	10000126 	beq	r2,zero,81110184 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81110180:	1112a100 	call	81112a10 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81110184:	e0bffc17 	ldw	r2,-16(fp)
81110188:	00008406 	br	8111039c <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111018c:	e03ffb05 	stb	zero,-20(fp)
81110190:	00004306 	br	811102a0 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81110194:	e0fffb03 	ldbu	r3,-20(fp)
81110198:	00a04574 	movhi	r2,33045
8111019c:	10924504 	addi	r2,r2,18708
811101a0:	18c7883a 	add	r3,r3,r3
811101a4:	18c7883a 	add	r3,r3,r3
811101a8:	10c5883a 	add	r2,r2,r3
811101ac:	10800017 	ldw	r2,0(r2)
811101b0:	1000381e 	bne	r2,zero,81110294 <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
811101b4:	e0bffb03 	ldbu	r2,-20(fp)
811101b8:	10c02324 	muli	r3,r2,140
811101bc:	00a04574 	movhi	r2,33045
811101c0:	10926304 	addi	r2,r2,18828
811101c4:	1885883a 	add	r2,r3,r2
811101c8:	01802004 	movi	r6,128
811101cc:	000b883a 	mov	r5,zero
811101d0:	1009883a 	mov	r4,r2
811101d4:	1117e1c0 	call	81117e1c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
811101d8:	e0bffb03 	ldbu	r2,-20(fp)
811101dc:	10c02324 	muli	r3,r2,140
811101e0:	00a04574 	movhi	r2,33045
811101e4:	10926304 	addi	r2,r2,18828
811101e8:	1885883a 	add	r2,r3,r2
811101ec:	01801fc4 	movi	r6,127
811101f0:	e17ffe17 	ldw	r5,-8(fp)
811101f4:	1009883a 	mov	r4,r2
811101f8:	1117ccc0 	call	81117ccc <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
811101fc:	e13ffb03 	ldbu	r4,-20(fp)
81110200:	e0ffff0b 	ldhu	r3,-4(fp)
81110204:	00a04574 	movhi	r2,33045
81110208:	10926304 	addi	r2,r2,18828
8111020c:	21002324 	muli	r4,r4,140
81110210:	1105883a 	add	r2,r2,r4
81110214:	10802104 	addi	r2,r2,132
81110218:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
8111021c:	e0fffb03 	ldbu	r3,-20(fp)
81110220:	00a04574 	movhi	r2,33045
81110224:	10926304 	addi	r2,r2,18828
81110228:	18c02324 	muli	r3,r3,140
8111022c:	10c5883a 	add	r2,r2,r3
81110230:	10802204 	addi	r2,r2,136
81110234:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81110238:	e0fffb03 	ldbu	r3,-20(fp)
8111023c:	00a04574 	movhi	r2,33045
81110240:	10926304 	addi	r2,r2,18828
81110244:	18c02324 	muli	r3,r3,140
81110248:	10c5883a 	add	r2,r2,r3
8111024c:	10802184 	addi	r2,r2,134
81110250:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81110254:	e0fffb03 	ldbu	r3,-20(fp)
81110258:	00a04574 	movhi	r2,33045
8111025c:	10926304 	addi	r2,r2,18828
81110260:	18c02324 	muli	r3,r3,140
81110264:	10c5883a 	add	r2,r2,r3
81110268:	10802004 	addi	r2,r2,128
8111026c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81110270:	e0fffb03 	ldbu	r3,-20(fp)
81110274:	00a04574 	movhi	r2,33045
81110278:	10924504 	addi	r2,r2,18708
8111027c:	18c7883a 	add	r3,r3,r3
81110280:	18c7883a 	add	r3,r3,r3
81110284:	10c5883a 	add	r2,r2,r3
81110288:	00c00044 	movi	r3,1
8111028c:	10c00015 	stw	r3,0(r2)
			break;
81110290:	00000606 	br	811102ac <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81110294:	e0bffb03 	ldbu	r2,-20(fp)
81110298:	10800044 	addi	r2,r2,1
8111029c:	e0bffb05 	stb	r2,-20(fp)
811102a0:	e0bffb03 	ldbu	r2,-20(fp)
811102a4:	108001b0 	cmpltui	r2,r2,6
811102a8:	103fba1e 	bne	r2,zero,81110194 <__reset+0xfb0f0194>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
811102ac:	e0bffb03 	ldbu	r2,-20(fp)
811102b0:	108001b0 	cmpltui	r2,r2,6
811102b4:	1000091e 	bne	r2,zero,811102dc <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
811102b8:	d0a05617 	ldw	r2,-32424(gp)
811102bc:	1009883a 	mov	r4,r2
811102c0:	11350800 	call	81135080 <OSSemPost>
811102c4:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
811102c8:	d0a06017 	ldw	r2,-32384(gp)
811102cc:	1009883a 	mov	r4,r2
811102d0:	11332900 	call	81133290 <OSMutexPost>
		return bSuccessL;
811102d4:	e0bffc17 	ldw	r2,-16(fp)
811102d8:	00003006 	br	8111039c <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
811102dc:	00800044 	movi	r2,1
811102e0:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
811102e4:	d0a06643 	ldbu	r2,-32359(gp)
811102e8:	10bfffc4 	addi	r2,r2,-1
811102ec:	d0a06645 	stb	r2,-32359(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811102f0:	d0a06517 	ldw	r2,-32364(gp)
811102f4:	e0fffd04 	addi	r3,fp,-12
811102f8:	180d883a 	mov	r6,r3
811102fc:	01400084 	movi	r5,2
81110300:	1009883a 	mov	r4,r2
81110304:	1132cec0 	call	81132cec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81110308:	e0bffd03 	ldbu	r2,-12(fp)
8111030c:	10803fcc 	andi	r2,r2,255
81110310:	10000c26 	beq	r2,zero,81110344 <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
81110314:	d0a05517 	ldw	r2,-32428(gp)
81110318:	100f883a 	mov	r7,r2
8111031c:	01801c04 	movi	r6,112
81110320:	01400044 	movi	r5,1
81110324:	01204534 	movhi	r4,33044
81110328:	210f3a04 	addi	r4,r4,15592
8111032c:	11172b80 	call	811172b8 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81110330:	d0a06017 	ldw	r2,-32384(gp)
81110334:	1009883a 	mov	r4,r2
81110338:	11332900 	call	81133290 <OSMutexPost>
		return bSuccessL;
8111033c:	e0bffc17 	ldw	r2,-16(fp)
81110340:	00001606 	br	8111039c <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81110344:	e0bffb03 	ldbu	r2,-20(fp)
81110348:	10c02324 	muli	r3,r2,140
8111034c:	00a04574 	movhi	r2,33045
81110350:	10926304 	addi	r2,r2,18828
81110354:	1885883a 	add	r2,r3,r2
81110358:	1009883a 	mov	r4,r2
8111035c:	11182680 	call	81118268 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81110360:	e0fffb03 	ldbu	r3,-20(fp)
81110364:	00a04574 	movhi	r2,33045
81110368:	10926304 	addi	r2,r2,18828
8111036c:	18c02324 	muli	r3,r3,140
81110370:	10c5883a 	add	r2,r2,r3
81110374:	10802004 	addi	r2,r2,128
81110378:	00c00044 	movi	r3,1
8111037c:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81110380:	d0a06517 	ldw	r2,-32364(gp)
81110384:	1009883a 	mov	r4,r2
81110388:	11332900 	call	81133290 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
8111038c:	d0a06017 	ldw	r2,-32384(gp)
81110390:	1009883a 	mov	r4,r2
81110394:	11332900 	call	81133290 <OSMutexPost>

	return bSuccessL;
81110398:	e0bffc17 	ldw	r2,-16(fp)
}
8111039c:	e037883a 	mov	sp,fp
811103a0:	dfc00117 	ldw	ra,4(sp)
811103a4:	df000017 	ldw	fp,0(sp)
811103a8:	dec00204 	addi	sp,sp,8
811103ac:	f800283a 	ret

811103b0 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
811103b0:	defff904 	addi	sp,sp,-28
811103b4:	de00012e 	bgeu	sp,et,811103bc <bSendUART64v2+0xc>
811103b8:	003b68fa 	trap	3
811103bc:	dfc00615 	stw	ra,24(sp)
811103c0:	df000515 	stw	fp,20(sp)
811103c4:	df000504 	addi	fp,sp,20
811103c8:	e13ffe15 	stw	r4,-8(fp)
811103cc:	2805883a 	mov	r2,r5
811103d0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
811103d4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811103d8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811103dc:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811103e0:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811103e4:	d0a05217 	ldw	r2,-32440(gp)
811103e8:	e0fffd04 	addi	r3,fp,-12
811103ec:	180d883a 	mov	r6,r3
811103f0:	01400504 	movi	r5,20
811103f4:	1009883a 	mov	r4,r2
811103f8:	1134cf80 	call	81134cf8 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811103fc:	e0bffd03 	ldbu	r2,-12(fp)
81110400:	10803fcc 	andi	r2,r2,255
81110404:	10000326 	beq	r2,zero,81110414 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81110408:	1112ae00 	call	81112ae0 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
8111040c:	e0bffc17 	ldw	r2,-16(fp)
81110410:	0000a006 	br	81110694 <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81110414:	d0a06217 	ldw	r2,-32376(gp)
81110418:	e0fffd04 	addi	r3,fp,-12
8111041c:	180d883a 	mov	r6,r3
81110420:	01400104 	movi	r5,4
81110424:	1009883a 	mov	r4,r2
81110428:	1132cec0 	call	81132cec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111042c:	e0bffd03 	ldbu	r2,-12(fp)
81110430:	10803fcc 	andi	r2,r2,255
81110434:	10001126 	beq	r2,zero,8111047c <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
81110438:	d0a05517 	ldw	r2,-32428(gp)
8111043c:	100f883a 	mov	r7,r2
81110440:	018013c4 	movi	r6,79
81110444:	01400044 	movi	r5,1
81110448:	01204534 	movhi	r4,33044
8111044c:	210f5704 	addi	r4,r4,15708
81110450:	11172b80 	call	811172b8 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81110454:	d0a05217 	ldw	r2,-32440(gp)
81110458:	1009883a 	mov	r4,r2
8111045c:	11350800 	call	81135080 <OSSemPost>
81110460:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81110464:	e0bffd03 	ldbu	r2,-12(fp)
81110468:	10803fcc 	andi	r2,r2,255
8111046c:	10000126 	beq	r2,zero,81110474 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81110470:	11129a80 	call	811129a8 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81110474:	e0bffc17 	ldw	r2,-16(fp)
81110478:	00008606 	br	81110694 <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8111047c:	e03ffb05 	stb	zero,-20(fp)
81110480:	00004506 	br	81110598 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81110484:	e0fffb03 	ldbu	r3,-20(fp)
81110488:	00a04574 	movhi	r2,33045
8111048c:	10924504 	addi	r2,r2,18708
81110490:	18c00184 	addi	r3,r3,6
81110494:	18c7883a 	add	r3,r3,r3
81110498:	18c7883a 	add	r3,r3,r3
8111049c:	10c5883a 	add	r2,r2,r3
811104a0:	10800017 	ldw	r2,0(r2)
811104a4:	1000391e 	bne	r2,zero,8111058c <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
811104a8:	e0bffb03 	ldbu	r2,-20(fp)
811104ac:	10c01324 	muli	r3,r2,76
811104b0:	00a04574 	movhi	r2,33045
811104b4:	10ab5504 	addi	r2,r2,-21164
811104b8:	1885883a 	add	r2,r3,r2
811104bc:	01801004 	movi	r6,64
811104c0:	000b883a 	mov	r5,zero
811104c4:	1009883a 	mov	r4,r2
811104c8:	1117e1c0 	call	81117e1c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
811104cc:	e0bffb03 	ldbu	r2,-20(fp)
811104d0:	10c01324 	muli	r3,r2,76
811104d4:	00a04574 	movhi	r2,33045
811104d8:	10ab5504 	addi	r2,r2,-21164
811104dc:	1885883a 	add	r2,r3,r2
811104e0:	01800fc4 	movi	r6,63
811104e4:	e17ffe17 	ldw	r5,-8(fp)
811104e8:	1009883a 	mov	r4,r2
811104ec:	1117ccc0 	call	81117ccc <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
811104f0:	e13ffb03 	ldbu	r4,-20(fp)
811104f4:	e0ffff0b 	ldhu	r3,-4(fp)
811104f8:	00a04574 	movhi	r2,33045
811104fc:	10ab5504 	addi	r2,r2,-21164
81110500:	21001324 	muli	r4,r4,76
81110504:	1105883a 	add	r2,r2,r4
81110508:	10801104 	addi	r2,r2,68
8111050c:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81110510:	e0fffb03 	ldbu	r3,-20(fp)
81110514:	00a04574 	movhi	r2,33045
81110518:	10ab5504 	addi	r2,r2,-21164
8111051c:	18c01324 	muli	r3,r3,76
81110520:	10c5883a 	add	r2,r2,r3
81110524:	10801204 	addi	r2,r2,72
81110528:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
8111052c:	e0fffb03 	ldbu	r3,-20(fp)
81110530:	00a04574 	movhi	r2,33045
81110534:	10ab5504 	addi	r2,r2,-21164
81110538:	18c01324 	muli	r3,r3,76
8111053c:	10c5883a 	add	r2,r2,r3
81110540:	10801184 	addi	r2,r2,70
81110544:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81110548:	e0fffb03 	ldbu	r3,-20(fp)
8111054c:	00a04574 	movhi	r2,33045
81110550:	10ab5504 	addi	r2,r2,-21164
81110554:	18c01324 	muli	r3,r3,76
81110558:	10c5883a 	add	r2,r2,r3
8111055c:	10801004 	addi	r2,r2,64
81110560:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81110564:	e0fffb03 	ldbu	r3,-20(fp)
81110568:	00a04574 	movhi	r2,33045
8111056c:	10924504 	addi	r2,r2,18708
81110570:	18c00184 	addi	r3,r3,6
81110574:	18c7883a 	add	r3,r3,r3
81110578:	18c7883a 	add	r3,r3,r3
8111057c:	10c5883a 	add	r2,r2,r3
81110580:	00c00044 	movi	r3,1
81110584:	10c00015 	stw	r3,0(r2)
			break;
81110588:	00000606 	br	811105a4 <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8111058c:	e0bffb03 	ldbu	r2,-20(fp)
81110590:	10800044 	addi	r2,r2,1
81110594:	e0bffb05 	stb	r2,-20(fp)
81110598:	e0bffb03 	ldbu	r2,-20(fp)
8111059c:	10800230 	cmpltui	r2,r2,8
811105a0:	103fb81e 	bne	r2,zero,81110484 <__reset+0xfb0f0484>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
811105a4:	e0bffb03 	ldbu	r2,-20(fp)
811105a8:	10800230 	cmpltui	r2,r2,8
811105ac:	1000091e 	bne	r2,zero,811105d4 <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
811105b0:	d0a05217 	ldw	r2,-32440(gp)
811105b4:	1009883a 	mov	r4,r2
811105b8:	11350800 	call	81135080 <OSSemPost>
811105bc:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
811105c0:	d0a06217 	ldw	r2,-32376(gp)
811105c4:	1009883a 	mov	r4,r2
811105c8:	11332900 	call	81133290 <OSMutexPost>
		return bSuccessL;
811105cc:	e0bffc17 	ldw	r2,-16(fp)
811105d0:	00003006 	br	81110694 <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
811105d4:	00800044 	movi	r2,1
811105d8:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
811105dc:	d0a06603 	ldbu	r2,-32360(gp)
811105e0:	10bfffc4 	addi	r2,r2,-1
811105e4:	d0a06605 	stb	r2,-32360(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811105e8:	d0a06517 	ldw	r2,-32364(gp)
811105ec:	e0fffd04 	addi	r3,fp,-12
811105f0:	180d883a 	mov	r6,r3
811105f4:	01400084 	movi	r5,2
811105f8:	1009883a 	mov	r4,r2
811105fc:	1132cec0 	call	81132cec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81110600:	e0bffd03 	ldbu	r2,-12(fp)
81110604:	10803fcc 	andi	r2,r2,255
81110608:	10000c26 	beq	r2,zero,8111063c <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
8111060c:	d0a05517 	ldw	r2,-32428(gp)
81110610:	100f883a 	mov	r7,r2
81110614:	01801bc4 	movi	r6,111
81110618:	01400044 	movi	r5,1
8111061c:	01204534 	movhi	r4,33044
81110620:	210f6b04 	addi	r4,r4,15788
81110624:	11172b80 	call	811172b8 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
81110628:	d0a06217 	ldw	r2,-32376(gp)
8111062c:	1009883a 	mov	r4,r2
81110630:	11332900 	call	81133290 <OSMutexPost>
		return bSuccessL;
81110634:	e0bffc17 	ldw	r2,-16(fp)
81110638:	00001606 	br	81110694 <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
8111063c:	e0bffb03 	ldbu	r2,-20(fp)
81110640:	10c01324 	muli	r3,r2,76
81110644:	00a04574 	movhi	r2,33045
81110648:	10ab5504 	addi	r2,r2,-21164
8111064c:	1885883a 	add	r2,r3,r2
81110650:	1009883a 	mov	r4,r2
81110654:	11182680 	call	81118268 <puts>
	xBuffer64[ucIL].bSent = TRUE;
81110658:	e0fffb03 	ldbu	r3,-20(fp)
8111065c:	00a04574 	movhi	r2,33045
81110660:	10ab5504 	addi	r2,r2,-21164
81110664:	18c01324 	muli	r3,r3,76
81110668:	10c5883a 	add	r2,r2,r3
8111066c:	10801004 	addi	r2,r2,64
81110670:	00c00044 	movi	r3,1
81110674:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81110678:	d0a06517 	ldw	r2,-32364(gp)
8111067c:	1009883a 	mov	r4,r2
81110680:	11332900 	call	81133290 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81110684:	d0a06217 	ldw	r2,-32376(gp)
81110688:	1009883a 	mov	r4,r2
8111068c:	11332900 	call	81133290 <OSMutexPost>

	return bSuccessL;
81110690:	e0bffc17 	ldw	r2,-16(fp)
}
81110694:	e037883a 	mov	sp,fp
81110698:	dfc00117 	ldw	ra,4(sp)
8111069c:	df000017 	ldw	fp,0(sp)
811106a0:	dec00204 	addi	sp,sp,8
811106a4:	f800283a 	ret

811106a8 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
811106a8:	defff904 	addi	sp,sp,-28
811106ac:	de00012e 	bgeu	sp,et,811106b4 <bSendUART32v2+0xc>
811106b0:	003b68fa 	trap	3
811106b4:	dfc00615 	stw	ra,24(sp)
811106b8:	df000515 	stw	fp,20(sp)
811106bc:	df000504 	addi	fp,sp,20
811106c0:	e13ffe15 	stw	r4,-8(fp)
811106c4:	2805883a 	mov	r2,r5
811106c8:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
811106cc:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811106d0:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811106d4:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811106d8:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811106dc:	d0a06117 	ldw	r2,-32380(gp)
811106e0:	e0fffd04 	addi	r3,fp,-12
811106e4:	180d883a 	mov	r6,r3
811106e8:	01400504 	movi	r5,20
811106ec:	1009883a 	mov	r4,r2
811106f0:	1134cf80 	call	81134cf8 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811106f4:	e0bffd03 	ldbu	r2,-12(fp)
811106f8:	10803fcc 	andi	r2,r2,255
811106fc:	10000326 	beq	r2,zero,8111070c <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81110700:	1112b480 	call	81112b48 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
81110704:	e0bffc17 	ldw	r2,-16(fp)
81110708:	0000a006 	br	8111098c <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8111070c:	d0a05e17 	ldw	r2,-32392(gp)
81110710:	e0fffd04 	addi	r3,fp,-12
81110714:	180d883a 	mov	r6,r3
81110718:	01400104 	movi	r5,4
8111071c:	1009883a 	mov	r4,r2
81110720:	1132cec0 	call	81132cec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81110724:	e0bffd03 	ldbu	r2,-12(fp)
81110728:	10803fcc 	andi	r2,r2,255
8111072c:	10001126 	beq	r2,zero,81110774 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81110730:	d0a05517 	ldw	r2,-32428(gp)
81110734:	100f883a 	mov	r7,r2
81110738:	018013c4 	movi	r6,79
8111073c:	01400044 	movi	r5,1
81110740:	01204534 	movhi	r4,33044
81110744:	210f8704 	addi	r4,r4,15900
81110748:	11172b80 	call	811172b8 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
8111074c:	d0a06117 	ldw	r2,-32380(gp)
81110750:	1009883a 	mov	r4,r2
81110754:	11350800 	call	81135080 <OSSemPost>
81110758:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8111075c:	e0bffd03 	ldbu	r2,-12(fp)
81110760:	10803fcc 	andi	r2,r2,255
81110764:	10000126 	beq	r2,zero,8111076c <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81110768:	11129400 	call	81112940 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
8111076c:	e0bffc17 	ldw	r2,-16(fp)
81110770:	00008606 	br	8111098c <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81110774:	e03ffb05 	stb	zero,-20(fp)
81110778:	00004506 	br	81110890 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
8111077c:	e0fffb03 	ldbu	r3,-20(fp)
81110780:	00a04574 	movhi	r2,33045
81110784:	10924504 	addi	r2,r2,18708
81110788:	18c00384 	addi	r3,r3,14
8111078c:	18c7883a 	add	r3,r3,r3
81110790:	18c7883a 	add	r3,r3,r3
81110794:	10c5883a 	add	r2,r2,r3
81110798:	10800017 	ldw	r2,0(r2)
8111079c:	1000391e 	bne	r2,zero,81110884 <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
811107a0:	e0bffb03 	ldbu	r2,-20(fp)
811107a4:	10c00b24 	muli	r3,r2,44
811107a8:	00a04574 	movhi	r2,33045
811107ac:	10bfd904 	addi	r2,r2,-156
811107b0:	1885883a 	add	r2,r3,r2
811107b4:	01800804 	movi	r6,32
811107b8:	000b883a 	mov	r5,zero
811107bc:	1009883a 	mov	r4,r2
811107c0:	1117e1c0 	call	81117e1c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
811107c4:	e0bffb03 	ldbu	r2,-20(fp)
811107c8:	10c00b24 	muli	r3,r2,44
811107cc:	00a04574 	movhi	r2,33045
811107d0:	10bfd904 	addi	r2,r2,-156
811107d4:	1885883a 	add	r2,r3,r2
811107d8:	018007c4 	movi	r6,31
811107dc:	e17ffe17 	ldw	r5,-8(fp)
811107e0:	1009883a 	mov	r4,r2
811107e4:	1117ccc0 	call	81117ccc <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
811107e8:	e13ffb03 	ldbu	r4,-20(fp)
811107ec:	e0ffff0b 	ldhu	r3,-4(fp)
811107f0:	00a04574 	movhi	r2,33045
811107f4:	10bfd904 	addi	r2,r2,-156
811107f8:	21000b24 	muli	r4,r4,44
811107fc:	1105883a 	add	r2,r2,r4
81110800:	10800904 	addi	r2,r2,36
81110804:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81110808:	e0fffb03 	ldbu	r3,-20(fp)
8111080c:	00a04574 	movhi	r2,33045
81110810:	10bfd904 	addi	r2,r2,-156
81110814:	18c00b24 	muli	r3,r3,44
81110818:	10c5883a 	add	r2,r2,r3
8111081c:	10800a04 	addi	r2,r2,40
81110820:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81110824:	e0fffb03 	ldbu	r3,-20(fp)
81110828:	00a04574 	movhi	r2,33045
8111082c:	10bfd904 	addi	r2,r2,-156
81110830:	18c00b24 	muli	r3,r3,44
81110834:	10c5883a 	add	r2,r2,r3
81110838:	10800984 	addi	r2,r2,38
8111083c:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81110840:	e0fffb03 	ldbu	r3,-20(fp)
81110844:	00a04574 	movhi	r2,33045
81110848:	10bfd904 	addi	r2,r2,-156
8111084c:	18c00b24 	muli	r3,r3,44
81110850:	10c5883a 	add	r2,r2,r3
81110854:	10800804 	addi	r2,r2,32
81110858:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
8111085c:	e0fffb03 	ldbu	r3,-20(fp)
81110860:	00a04574 	movhi	r2,33045
81110864:	10924504 	addi	r2,r2,18708
81110868:	18c00384 	addi	r3,r3,14
8111086c:	18c7883a 	add	r3,r3,r3
81110870:	18c7883a 	add	r3,r3,r3
81110874:	10c5883a 	add	r2,r2,r3
81110878:	00c00044 	movi	r3,1
8111087c:	10c00015 	stw	r3,0(r2)
			break;
81110880:	00000606 	br	8111089c <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81110884:	e0bffb03 	ldbu	r2,-20(fp)
81110888:	10800044 	addi	r2,r2,1
8111088c:	e0bffb05 	stb	r2,-20(fp)
81110890:	e0bffb03 	ldbu	r2,-20(fp)
81110894:	10800230 	cmpltui	r2,r2,8
81110898:	103fb81e 	bne	r2,zero,8111077c <__reset+0xfb0f077c>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
8111089c:	e0bffb03 	ldbu	r2,-20(fp)
811108a0:	10800230 	cmpltui	r2,r2,8
811108a4:	1000091e 	bne	r2,zero,811108cc <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
811108a8:	d0a06117 	ldw	r2,-32380(gp)
811108ac:	1009883a 	mov	r4,r2
811108b0:	11350800 	call	81135080 <OSSemPost>
811108b4:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
811108b8:	d0a05e17 	ldw	r2,-32392(gp)
811108bc:	1009883a 	mov	r4,r2
811108c0:	11332900 	call	81133290 <OSMutexPost>
		return bSuccessL;
811108c4:	e0bffc17 	ldw	r2,-16(fp)
811108c8:	00003006 	br	8111098c <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
811108cc:	00800044 	movi	r2,1
811108d0:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
811108d4:	d0a05b83 	ldbu	r2,-32402(gp)
811108d8:	10bfffc4 	addi	r2,r2,-1
811108dc:	d0a05b85 	stb	r2,-32402(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811108e0:	d0a06517 	ldw	r2,-32364(gp)
811108e4:	e0fffd04 	addi	r3,fp,-12
811108e8:	180d883a 	mov	r6,r3
811108ec:	01400084 	movi	r5,2
811108f0:	1009883a 	mov	r4,r2
811108f4:	1132cec0 	call	81132cec <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811108f8:	e0bffd03 	ldbu	r2,-12(fp)
811108fc:	10803fcc 	andi	r2,r2,255
81110900:	10000c26 	beq	r2,zero,81110934 <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81110904:	d0a05517 	ldw	r2,-32428(gp)
81110908:	100f883a 	mov	r7,r2
8111090c:	01801bc4 	movi	r6,111
81110910:	01400044 	movi	r5,1
81110914:	01204534 	movhi	r4,33044
81110918:	210f9b04 	addi	r4,r4,15980
8111091c:	11172b80 	call	811172b8 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81110920:	d0a05e17 	ldw	r2,-32392(gp)
81110924:	1009883a 	mov	r4,r2
81110928:	11332900 	call	81133290 <OSMutexPost>
		return bSuccessL;
8111092c:	e0bffc17 	ldw	r2,-16(fp)
81110930:	00001606 	br	8111098c <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81110934:	e0bffb03 	ldbu	r2,-20(fp)
81110938:	10c00b24 	muli	r3,r2,44
8111093c:	00a04574 	movhi	r2,33045
81110940:	10bfd904 	addi	r2,r2,-156
81110944:	1885883a 	add	r2,r3,r2
81110948:	1009883a 	mov	r4,r2
8111094c:	11182680 	call	81118268 <puts>
	xBuffer32[ucIL].bSent = TRUE;
81110950:	e0fffb03 	ldbu	r3,-20(fp)
81110954:	00a04574 	movhi	r2,33045
81110958:	10bfd904 	addi	r2,r2,-156
8111095c:	18c00b24 	muli	r3,r3,44
81110960:	10c5883a 	add	r2,r2,r3
81110964:	10800804 	addi	r2,r2,32
81110968:	00c00044 	movi	r3,1
8111096c:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81110970:	d0a06517 	ldw	r2,-32364(gp)
81110974:	1009883a 	mov	r4,r2
81110978:	11332900 	call	81133290 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
8111097c:	d0a05e17 	ldw	r2,-32392(gp)
81110980:	1009883a 	mov	r4,r2
81110984:	11332900 	call	81133290 <OSMutexPost>

	return bSuccessL;
81110988:	e0bffc17 	ldw	r2,-16(fp)
}
8111098c:	e037883a 	mov	sp,fp
81110990:	dfc00117 	ldw	ra,4(sp)
81110994:	df000017 	ldw	fp,0(sp)
81110998:	dec00204 	addi	sp,sp,8
8111099c:	f800283a 	ret

811109a0 <vSendEthConf>:


void vSendEthConf ( void ) {
811109a0:	deffc304 	addi	sp,sp,-244
811109a4:	de00012e 	bgeu	sp,et,811109ac <vSendEthConf+0xc>
811109a8:	003b68fa 	trap	3
811109ac:	dfc03c15 	stw	ra,240(sp)
811109b0:	df003b15 	stw	fp,236(sp)
811109b4:	dd403a15 	stw	r21,232(sp)
811109b8:	dd003915 	stw	r20,228(sp)
811109bc:	dcc03815 	stw	r19,224(sp)
811109c0:	dc803715 	stw	r18,220(sp)
811109c4:	dc403615 	stw	r17,216(sp)
811109c8:	dc003515 	stw	r16,212(sp)
811109cc:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
811109d0:	e03fd98d 	sth	zero,-154(fp)
811109d4:	e03fda0d 	sth	zero,-152(fp)
811109d8:	e0bfda84 	addi	r2,fp,-150
811109dc:	00c01f04 	movi	r3,124
811109e0:	180d883a 	mov	r6,r3
811109e4:	000b883a 	mov	r5,zero
811109e8:	1009883a 	mov	r4,r2
811109ec:	1117e1c0 	call	81117e1c <memset>
    unsigned char crc = 0;
811109f0:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811109f4:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
811109f8:	1110f600 	call	81110f60 <usiGetIdCMD>
811109fc:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a00:	e57fd90b 	ldhu	r21,-156(fp)
81110a04:	00a045b4 	movhi	r2,33046
81110a08:	10b20104 	addi	r2,r2,-14332
81110a0c:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81110a10:	00a045b4 	movhi	r2,33046
81110a14:	10b20104 	addi	r2,r2,-14332
81110a18:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a1c:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81110a20:	00a045b4 	movhi	r2,33046
81110a24:	10b20104 	addi	r2,r2,-14332
81110a28:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a2c:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81110a30:	00a045b4 	movhi	r2,33046
81110a34:	10b20104 	addi	r2,r2,-14332
81110a38:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a3c:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81110a40:	00a045b4 	movhi	r2,33046
81110a44:	10b20104 	addi	r2,r2,-14332
81110a48:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a4c:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81110a50:	00a045b4 	movhi	r2,33046
81110a54:	10b20104 	addi	r2,r2,-14332
81110a58:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a5c:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81110a60:	00a045b4 	movhi	r2,33046
81110a64:	10b20104 	addi	r2,r2,-14332
81110a68:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a6c:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81110a70:	00a045b4 	movhi	r2,33046
81110a74:	10b20104 	addi	r2,r2,-14332
81110a78:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a7c:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81110a80:	00a045b4 	movhi	r2,33046
81110a84:	10b20104 	addi	r2,r2,-14332
81110a88:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a8c:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81110a90:	00a045b4 	movhi	r2,33046
81110a94:	10b20104 	addi	r2,r2,-14332
81110a98:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110a9c:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81110aa0:	00a045b4 	movhi	r2,33046
81110aa4:	10b20104 	addi	r2,r2,-14332
81110aa8:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110aac:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81110ab0:	00a045b4 	movhi	r2,33046
81110ab4:	10b20104 	addi	r2,r2,-14332
81110ab8:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110abc:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81110ac0:	00a045b4 	movhi	r2,33046
81110ac4:	10b20104 	addi	r2,r2,-14332
81110ac8:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110acc:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81110ad0:	00a045b4 	movhi	r2,33046
81110ad4:	10b20104 	addi	r2,r2,-14332
81110ad8:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110adc:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81110ae0:	00a045b4 	movhi	r2,33046
81110ae4:	10b20104 	addi	r2,r2,-14332
81110ae8:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110aec:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81110af0:	00a045b4 	movhi	r2,33046
81110af4:	10b20104 	addi	r2,r2,-14332
81110af8:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110afc:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81110b00:	00a045b4 	movhi	r2,33046
81110b04:	10b20104 	addi	r2,r2,-14332
81110b08:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110b0c:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81110b10:	00a045b4 	movhi	r2,33046
81110b14:	10b20104 	addi	r2,r2,-14332
81110b18:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81110b1c:	10bfffcc 	andi	r2,r2,65535
81110b20:	e53fd984 	addi	r20,fp,-154
81110b24:	d8801115 	stw	r2,68(sp)
81110b28:	dcc01015 	stw	r19,64(sp)
81110b2c:	dc800f15 	stw	r18,60(sp)
81110b30:	dc400e15 	stw	r17,56(sp)
81110b34:	dc000d15 	stw	r16,52(sp)
81110b38:	dbc00c15 	stw	r15,48(sp)
81110b3c:	db800b15 	stw	r14,44(sp)
81110b40:	db400a15 	stw	r13,40(sp)
81110b44:	db000915 	stw	r12,36(sp)
81110b48:	dac00815 	stw	r11,32(sp)
81110b4c:	da800715 	stw	r10,28(sp)
81110b50:	da400615 	stw	r9,24(sp)
81110b54:	da000515 	stw	r8,20(sp)
81110b58:	d9c00415 	stw	r7,16(sp)
81110b5c:	d9800315 	stw	r6,12(sp)
81110b60:	d9400215 	stw	r5,8(sp)
81110b64:	d9000115 	stw	r4,4(sp)
81110b68:	d8c00015 	stw	r3,0(sp)
81110b6c:	a80f883a 	mov	r7,r21
81110b70:	018010c4 	movi	r6,67
81110b74:	01604534 	movhi	r5,33044
81110b78:	294fb704 	addi	r5,r5,16092
81110b7c:	a009883a 	mov	r4,r20
81110b80:	11185ac0 	call	811185ac <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81110b84:	e0bfd984 	addi	r2,fp,-154
81110b88:	1009883a 	mov	r4,r2
81110b8c:	11187c00 	call	811187c0 <strlen>
81110b90:	1007883a 	mov	r3,r2
81110b94:	e0bfd984 	addi	r2,fp,-154
81110b98:	180b883a 	mov	r5,r3
81110b9c:	1009883a 	mov	r4,r2
81110ba0:	11121d00 	call	811121d0 <ucCrc8wInit>
81110ba4:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81110ba8:	e13fd703 	ldbu	r4,-164(fp)
81110bac:	e0ffd984 	addi	r3,fp,-154
81110bb0:	e0bfd984 	addi	r2,fp,-154
81110bb4:	200f883a 	mov	r7,r4
81110bb8:	180d883a 	mov	r6,r3
81110bbc:	01604534 	movhi	r5,33044
81110bc0:	294fcf04 	addi	r5,r5,16188
81110bc4:	1009883a 	mov	r4,r2
81110bc8:	11185ac0 	call	811185ac <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81110bcc:	e0bfd90b 	ldhu	r2,-156(fp)
81110bd0:	10ffffcc 	andi	r3,r2,65535
81110bd4:	18e0001c 	xori	r3,r3,32768
81110bd8:	18e00004 	addi	r3,r3,-32768
81110bdc:	e0bfd984 	addi	r2,fp,-154
81110be0:	180b883a 	mov	r5,r3
81110be4:	1009883a 	mov	r4,r2
81110be8:	11100c00 	call	811100c0 <bSendUART128v2>
81110bec:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
81110bf0:	e0bfd817 	ldw	r2,-160(fp)
81110bf4:	10800060 	cmpeqi	r2,r2,1
81110bf8:	1000011e 	bne	r2,zero,81110c00 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81110bfc:	1112d500 	call	81112d50 <vCouldNotSendEthConfUART>
	}
}
81110c00:	0001883a 	nop
81110c04:	e6fffa04 	addi	sp,fp,-24
81110c08:	dfc00717 	ldw	ra,28(sp)
81110c0c:	df000617 	ldw	fp,24(sp)
81110c10:	dd400517 	ldw	r21,20(sp)
81110c14:	dd000417 	ldw	r20,16(sp)
81110c18:	dcc00317 	ldw	r19,12(sp)
81110c1c:	dc800217 	ldw	r18,8(sp)
81110c20:	dc400117 	ldw	r17,4(sp)
81110c24:	dc000017 	ldw	r16,0(sp)
81110c28:	dec00804 	addi	sp,sp,32
81110c2c:	f800283a 	ret

81110c30 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81110c30:	defff304 	addi	sp,sp,-52
81110c34:	de00012e 	bgeu	sp,et,81110c3c <vSendTurnOff+0xc>
81110c38:	003b68fa 	trap	3
81110c3c:	dfc00c15 	stw	ra,48(sp)
81110c40:	df000b15 	stw	fp,44(sp)
81110c44:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81110c48:	e03ff78d 	sth	zero,-34(fp)
81110c4c:	e03ff80d 	sth	zero,-32(fp)
81110c50:	e03ff88d 	sth	zero,-30(fp)
81110c54:	e03ff90d 	sth	zero,-28(fp)
81110c58:	e03ff98d 	sth	zero,-26(fp)
81110c5c:	e03ffa0d 	sth	zero,-24(fp)
81110c60:	e03ffa8d 	sth	zero,-22(fp)
81110c64:	e03ffb0d 	sth	zero,-20(fp)
81110c68:	e03ffb8d 	sth	zero,-18(fp)
81110c6c:	e03ffc0d 	sth	zero,-16(fp)
81110c70:	e03ffc8d 	sth	zero,-14(fp)
81110c74:	e03ffd0d 	sth	zero,-12(fp)
81110c78:	e03ffd8d 	sth	zero,-10(fp)
81110c7c:	e03ffe0d 	sth	zero,-8(fp)
81110c80:	e03ffe8d 	sth	zero,-6(fp)
81110c84:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81110c88:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81110c8c:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81110c90:	1110f600 	call	81110f60 <usiGetIdCMD>
81110c94:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81110c98:	e0fff70b 	ldhu	r3,-36(fp)
81110c9c:	e0bff784 	addi	r2,fp,-34
81110ca0:	180d883a 	mov	r6,r3
81110ca4:	01604534 	movhi	r5,33044
81110ca8:	294fd204 	addi	r5,r5,16200
81110cac:	1009883a 	mov	r4,r2
81110cb0:	11185ac0 	call	811185ac <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81110cb4:	e0bff784 	addi	r2,fp,-34
81110cb8:	1009883a 	mov	r4,r2
81110cbc:	11187c00 	call	811187c0 <strlen>
81110cc0:	1007883a 	mov	r3,r2
81110cc4:	e0bff784 	addi	r2,fp,-34
81110cc8:	180b883a 	mov	r5,r3
81110ccc:	1009883a 	mov	r4,r2
81110cd0:	11121d00 	call	811121d0 <ucCrc8wInit>
81110cd4:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81110cd8:	e13ff503 	ldbu	r4,-44(fp)
81110cdc:	e0fff784 	addi	r3,fp,-34
81110ce0:	e0bff784 	addi	r2,fp,-34
81110ce4:	200f883a 	mov	r7,r4
81110ce8:	180d883a 	mov	r6,r3
81110cec:	01604534 	movhi	r5,33044
81110cf0:	294fcf04 	addi	r5,r5,16188
81110cf4:	1009883a 	mov	r4,r2
81110cf8:	11185ac0 	call	811185ac <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81110cfc:	e0bff70b 	ldhu	r2,-36(fp)
81110d00:	10ffffcc 	andi	r3,r2,65535
81110d04:	18e0001c 	xori	r3,r3,32768
81110d08:	18e00004 	addi	r3,r3,-32768
81110d0c:	e0bff784 	addi	r2,fp,-34
81110d10:	180b883a 	mov	r5,r3
81110d14:	1009883a 	mov	r4,r2
81110d18:	11106a80 	call	811106a8 <bSendUART32v2>
81110d1c:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81110d20:	e0bff617 	ldw	r2,-40(fp)
81110d24:	10800060 	cmpeqi	r2,r2,1
81110d28:	1000011e 	bne	r2,zero,81110d30 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81110d2c:	11133f80 	call	811133f8 <vCouldNotSendTurnOff>
	}
}
81110d30:	0001883a 	nop
81110d34:	e037883a 	mov	sp,fp
81110d38:	dfc00117 	ldw	ra,4(sp)
81110d3c:	df000017 	ldw	fp,0(sp)
81110d40:	dec00204 	addi	sp,sp,8
81110d44:	f800283a 	ret

81110d48 <vSendReset>:

void vSendReset ( void ) {
81110d48:	defff304 	addi	sp,sp,-52
81110d4c:	de00012e 	bgeu	sp,et,81110d54 <vSendReset+0xc>
81110d50:	003b68fa 	trap	3
81110d54:	dfc00c15 	stw	ra,48(sp)
81110d58:	df000b15 	stw	fp,44(sp)
81110d5c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81110d60:	e03ff78d 	sth	zero,-34(fp)
81110d64:	e03ff80d 	sth	zero,-32(fp)
81110d68:	e03ff88d 	sth	zero,-30(fp)
81110d6c:	e03ff90d 	sth	zero,-28(fp)
81110d70:	e03ff98d 	sth	zero,-26(fp)
81110d74:	e03ffa0d 	sth	zero,-24(fp)
81110d78:	e03ffa8d 	sth	zero,-22(fp)
81110d7c:	e03ffb0d 	sth	zero,-20(fp)
81110d80:	e03ffb8d 	sth	zero,-18(fp)
81110d84:	e03ffc0d 	sth	zero,-16(fp)
81110d88:	e03ffc8d 	sth	zero,-14(fp)
81110d8c:	e03ffd0d 	sth	zero,-12(fp)
81110d90:	e03ffd8d 	sth	zero,-10(fp)
81110d94:	e03ffe0d 	sth	zero,-8(fp)
81110d98:	e03ffe8d 	sth	zero,-6(fp)
81110d9c:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81110da0:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81110da4:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81110da8:	1110f600 	call	81110f60 <usiGetIdCMD>
81110dac:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
81110db0:	e0fff70b 	ldhu	r3,-36(fp)
81110db4:	e0bff784 	addi	r2,fp,-34
81110db8:	180d883a 	mov	r6,r3
81110dbc:	01604534 	movhi	r5,33044
81110dc0:	294fd404 	addi	r5,r5,16208
81110dc4:	1009883a 	mov	r4,r2
81110dc8:	11185ac0 	call	811185ac <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81110dcc:	e0bff784 	addi	r2,fp,-34
81110dd0:	1009883a 	mov	r4,r2
81110dd4:	11187c00 	call	811187c0 <strlen>
81110dd8:	1007883a 	mov	r3,r2
81110ddc:	e0bff784 	addi	r2,fp,-34
81110de0:	180b883a 	mov	r5,r3
81110de4:	1009883a 	mov	r4,r2
81110de8:	11121d00 	call	811121d0 <ucCrc8wInit>
81110dec:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81110df0:	e13ff503 	ldbu	r4,-44(fp)
81110df4:	e0fff784 	addi	r3,fp,-34
81110df8:	e0bff784 	addi	r2,fp,-34
81110dfc:	200f883a 	mov	r7,r4
81110e00:	180d883a 	mov	r6,r3
81110e04:	01604534 	movhi	r5,33044
81110e08:	294fcf04 	addi	r5,r5,16188
81110e0c:	1009883a 	mov	r4,r2
81110e10:	11185ac0 	call	811185ac <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81110e14:	e0bff70b 	ldhu	r2,-36(fp)
81110e18:	10ffffcc 	andi	r3,r2,65535
81110e1c:	18e0001c 	xori	r3,r3,32768
81110e20:	18e00004 	addi	r3,r3,-32768
81110e24:	e0bff784 	addi	r2,fp,-34
81110e28:	180b883a 	mov	r5,r3
81110e2c:	1009883a 	mov	r4,r2
81110e30:	11106a80 	call	811106a8 <bSendUART32v2>
81110e34:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81110e38:	e0bff617 	ldw	r2,-40(fp)
81110e3c:	10800060 	cmpeqi	r2,r2,1
81110e40:	1000011e 	bne	r2,zero,81110e48 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81110e44:	11133f80 	call	811133f8 <vCouldNotSendTurnOff>
	}
}
81110e48:	0001883a 	nop
81110e4c:	e037883a 	mov	sp,fp
81110e50:	dfc00117 	ldw	ra,4(sp)
81110e54:	df000017 	ldw	fp,0(sp)
81110e58:	dec00204 	addi	sp,sp,8
81110e5c:	f800283a 	ret

81110e60 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
81110e60:	deffda04 	addi	sp,sp,-152
81110e64:	de00012e 	bgeu	sp,et,81110e6c <vSendLog+0xc>
81110e68:	003b68fa 	trap	3
81110e6c:	dfc02515 	stw	ra,148(sp)
81110e70:	df002415 	stw	fp,144(sp)
81110e74:	df002404 	addi	fp,sp,144
81110e78:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
81110e7c:	e03fde8d 	sth	zero,-134(fp)
81110e80:	e03fdf0d 	sth	zero,-132(fp)
81110e84:	e0bfdf84 	addi	r2,fp,-130
81110e88:	00c01f04 	movi	r3,124
81110e8c:	180d883a 	mov	r6,r3
81110e90:	000b883a 	mov	r5,zero
81110e94:	1009883a 	mov	r4,r2
81110e98:	1117e1c0 	call	81117e1c <memset>
    unsigned char crc = 0;
81110e9c:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81110ea0:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
81110ea4:	1110f600 	call	81110f60 <usiGetIdCMD>
81110ea8:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
81110eac:	e0ffde0b 	ldhu	r3,-136(fp)
81110eb0:	e0bfde84 	addi	r2,fp,-134
81110eb4:	e1ffff17 	ldw	r7,-4(fp)
81110eb8:	180d883a 	mov	r6,r3
81110ebc:	01604534 	movhi	r5,33044
81110ec0:	294fd604 	addi	r5,r5,16216
81110ec4:	1009883a 	mov	r4,r2
81110ec8:	11185ac0 	call	811185ac <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
81110ecc:	e0bfde84 	addi	r2,fp,-134
81110ed0:	1009883a 	mov	r4,r2
81110ed4:	11187c00 	call	811187c0 <strlen>
81110ed8:	1007883a 	mov	r3,r2
81110edc:	e0bfde84 	addi	r2,fp,-134
81110ee0:	180b883a 	mov	r5,r3
81110ee4:	1009883a 	mov	r4,r2
81110ee8:	11121d00 	call	811121d0 <ucCrc8wInit>
81110eec:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
81110ef0:	e13fdc03 	ldbu	r4,-144(fp)
81110ef4:	e0ffde84 	addi	r3,fp,-134
81110ef8:	e0bfde84 	addi	r2,fp,-134
81110efc:	200f883a 	mov	r7,r4
81110f00:	180d883a 	mov	r6,r3
81110f04:	01604534 	movhi	r5,33044
81110f08:	294fcf04 	addi	r5,r5,16188
81110f0c:	1009883a 	mov	r4,r2
81110f10:	11185ac0 	call	811185ac <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
81110f14:	e0bfde0b 	ldhu	r2,-136(fp)
81110f18:	10ffffcc 	andi	r3,r2,65535
81110f1c:	18e0001c 	xori	r3,r3,32768
81110f20:	18e00004 	addi	r3,r3,-32768
81110f24:	e0bfde84 	addi	r2,fp,-134
81110f28:	180b883a 	mov	r5,r3
81110f2c:	1009883a 	mov	r4,r2
81110f30:	11100c00 	call	811100c0 <bSendUART128v2>
81110f34:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
81110f38:	e0bfdd17 	ldw	r2,-140(fp)
81110f3c:	10800060 	cmpeqi	r2,r2,1
81110f40:	1000011e 	bne	r2,zero,81110f48 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
81110f44:	11134c80 	call	811134c8 <vCouldNotSendLog>
	}
}
81110f48:	0001883a 	nop
81110f4c:	e037883a 	mov	sp,fp
81110f50:	dfc00117 	ldw	ra,4(sp)
81110f54:	df000017 	ldw	fp,0(sp)
81110f58:	dec00204 	addi	sp,sp,8
81110f5c:	f800283a 	ret

81110f60 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
81110f60:	deffff04 	addi	sp,sp,-4
81110f64:	de00012e 	bgeu	sp,et,81110f6c <usiGetIdCMD+0xc>
81110f68:	003b68fa 	trap	3
81110f6c:	df000015 	stw	fp,0(sp)
81110f70:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
81110f74:	d0a05b0b 	ldhu	r2,-32404(gp)
81110f78:	10ffffcc 	andi	r3,r2,65535
81110f7c:	00bfffd4 	movui	r2,65535
81110f80:	1880031e 	bne	r3,r2,81110f90 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
81110f84:	00800084 	movi	r2,2
81110f88:	d0a05b0d 	sth	r2,-32404(gp)
81110f8c:	00000306 	br	81110f9c <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
81110f90:	d0a05b0b 	ldhu	r2,-32404(gp)
81110f94:	10800044 	addi	r2,r2,1
81110f98:	d0a05b0d 	sth	r2,-32404(gp)

    return usiIdCMD;
81110f9c:	d0a05b0b 	ldhu	r2,-32404(gp)
}
81110fa0:	e037883a 	mov	sp,fp
81110fa4:	df000017 	ldw	fp,0(sp)
81110fa8:	dec00104 	addi	sp,sp,4
81110fac:	f800283a 	ret

81110fb0 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
81110fb0:	defffb04 	addi	sp,sp,-20
81110fb4:	de00012e 	bgeu	sp,et,81110fbc <siPosStr+0xc>
81110fb8:	003b68fa 	trap	3
81110fbc:	dfc00415 	stw	ra,16(sp)
81110fc0:	df000315 	stw	fp,12(sp)
81110fc4:	df000304 	addi	fp,sp,12
81110fc8:	e13ffe15 	stw	r4,-8(fp)
81110fcc:	2805883a 	mov	r2,r5
81110fd0:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
81110fd4:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
81110fd8:	e0bfff03 	ldbu	r2,-4(fp)
81110fdc:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
81110fe0:	e17ffd04 	addi	r5,fp,-12
81110fe4:	e13ffe17 	ldw	r4,-8(fp)
81110fe8:	11187740 	call	81118774 <strcspn>
}
81110fec:	e037883a 	mov	sp,fp
81110ff0:	dfc00117 	ldw	ra,4(sp)
81110ff4:	df000017 	ldw	fp,0(sp)
81110ff8:	dec00204 	addi	sp,sp,8
81110ffc:	f800283a 	ret

81111000 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
81111000:	defffc04 	addi	sp,sp,-16
81111004:	de00012e 	bgeu	sp,et,8111100c <vTimeoutCheck+0xc>
81111008:	003b68fa 	trap	3
8111100c:	dfc00315 	stw	ra,12(sp)
81111010:	df000215 	stw	fp,8(sp)
81111014:	df000204 	addi	fp,sp,8
81111018:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
8111101c:	d0a05a17 	ldw	r2,-32408(gp)
81111020:	1009883a 	mov	r4,r2
81111024:	11350800 	call	81135080 <OSSemPost>
81111028:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8111102c:	e0bffe03 	ldbu	r2,-8(fp)
81111030:	10000126 	beq	r2,zero,81111038 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
81111034:	11131880 	call	81113188 <vFailPostBlockingSemTimeoutTask>
	}
}
81111038:	0001883a 	nop
8111103c:	e037883a 	mov	sp,fp
81111040:	dfc00117 	ldw	ra,4(sp)
81111044:	df000017 	ldw	fp,0(sp)
81111048:	dec00204 	addi	sp,sp,8
8111104c:	f800283a 	ret

81111050 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81111050:	deffe304 	addi	sp,sp,-116
81111054:	de00012e 	bgeu	sp,et,8111105c <vSendPusTM64+0xc>
81111058:	003b68fa 	trap	3
8111105c:	dfc01815 	stw	ra,96(sp)
81111060:	df001715 	stw	fp,92(sp)
81111064:	df001704 	addi	fp,sp,92
81111068:	e1000215 	stw	r4,8(fp)
8111106c:	e1400315 	stw	r5,12(fp)
81111070:	e1800415 	stw	r6,16(fp)
81111074:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81111078:	e03fef8d 	sth	zero,-66(fp)
8111107c:	e03ff00d 	sth	zero,-64(fp)
81111080:	e0bff084 	addi	r2,fp,-62
81111084:	00c00f04 	movi	r3,60
81111088:	180d883a 	mov	r6,r3
8111108c:	000b883a 	mov	r5,zero
81111090:	1009883a 	mov	r4,r2
81111094:	1117e1c0 	call	81117e1c <memset>
    unsigned char crc = 0;
81111098:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8111109c:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811110a0:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
811110a4:	1110f600 	call	81110f60 <usiGetIdCMD>
811110a8:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
811110ac:	e1bfef0b 	ldhu	r6,-68(fp)
811110b0:	e080040b 	ldhu	r2,16(fp)
811110b4:	11ffffcc 	andi	r7,r2,65535
811110b8:	e080048b 	ldhu	r2,18(fp)
811110bc:	10bfffcc 	andi	r2,r2,65535
811110c0:	e0c0050b 	ldhu	r3,20(fp)
811110c4:	18ffffcc 	andi	r3,r3,65535
811110c8:	e100058b 	ldhu	r4,22(fp)
811110cc:	213fffcc 	andi	r4,r4,65535
811110d0:	e140060b 	ldhu	r5,24(fp)
811110d4:	297fffcc 	andi	r5,r5,65535
811110d8:	e23fef84 	addi	r8,fp,-66
811110dc:	d9400315 	stw	r5,12(sp)
811110e0:	d9000215 	stw	r4,8(sp)
811110e4:	d8c00115 	stw	r3,4(sp)
811110e8:	d8800015 	stw	r2,0(sp)
811110ec:	01604534 	movhi	r5,33044
811110f0:	294fd904 	addi	r5,r5,16228
811110f4:	4009883a 	mov	r4,r8
811110f8:	11185ac0 	call	811185ac <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811110fc:	e03fed05 	stb	zero,-76(fp)
81111100:	00001206 	br	8111114c <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81111104:	e0bfed03 	ldbu	r2,-76(fp)
81111108:	10800284 	addi	r2,r2,10
8111110c:	1085883a 	add	r2,r2,r2
81111110:	e0c00204 	addi	r3,fp,8
81111114:	1885883a 	add	r2,r3,r2
81111118:	1080000b 	ldhu	r2,0(r2)
8111111c:	113fffcc 	andi	r4,r2,65535
81111120:	e0ffef84 	addi	r3,fp,-66
81111124:	e0bfef84 	addi	r2,fp,-66
81111128:	200f883a 	mov	r7,r4
8111112c:	180d883a 	mov	r6,r3
81111130:	01604534 	movhi	r5,33044
81111134:	294fe004 	addi	r5,r5,16256
81111138:	1009883a 	mov	r4,r2
8111113c:	11185ac0 	call	811185ac <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81111140:	e0bfed03 	ldbu	r2,-76(fp)
81111144:	10800044 	addi	r2,r2,1
81111148:	e0bfed05 	stb	r2,-76(fp)
8111114c:	e0800683 	ldbu	r2,26(fp)
81111150:	10803fcc 	andi	r2,r2,255
81111154:	e0ffed03 	ldbu	r3,-76(fp)
81111158:	18bfea36 	bltu	r3,r2,81111104 <__reset+0xfb0f1104>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111115c:	e0bfef84 	addi	r2,fp,-66
81111160:	1009883a 	mov	r4,r2
81111164:	11187c00 	call	811187c0 <strlen>
81111168:	1007883a 	mov	r3,r2
8111116c:	e0bfef84 	addi	r2,fp,-66
81111170:	180b883a 	mov	r5,r3
81111174:	1009883a 	mov	r4,r2
81111178:	11121d00 	call	811121d0 <ucCrc8wInit>
8111117c:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81111180:	e13fed43 	ldbu	r4,-75(fp)
81111184:	e0ffef84 	addi	r3,fp,-66
81111188:	e0bfef84 	addi	r2,fp,-66
8111118c:	200f883a 	mov	r7,r4
81111190:	180d883a 	mov	r6,r3
81111194:	01604534 	movhi	r5,33044
81111198:	294fcf04 	addi	r5,r5,16188
8111119c:	1009883a 	mov	r4,r2
811111a0:	11185ac0 	call	811185ac <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
811111a4:	e0bfef0b 	ldhu	r2,-68(fp)
811111a8:	10ffffcc 	andi	r3,r2,65535
811111ac:	18e0001c 	xori	r3,r3,32768
811111b0:	18e00004 	addi	r3,r3,-32768
811111b4:	e0bfef84 	addi	r2,fp,-66
811111b8:	180b883a 	mov	r5,r3
811111bc:	1009883a 	mov	r4,r2
811111c0:	11103b00 	call	811103b0 <bSendUART64v2>
811111c4:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
811111c8:	e0bfee17 	ldw	r2,-72(fp)
811111cc:	10800060 	cmpeqi	r2,r2,1
811111d0:	1000031e 	bne	r2,zero,811111e0 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
811111d4:	e0bfef84 	addi	r2,fp,-66
811111d8:	1009883a 	mov	r4,r2
811111dc:	11135300 	call	81113530 <vCouldNotSendTMPusCommand>
	}
}
811111e0:	0001883a 	nop
811111e4:	e037883a 	mov	sp,fp
811111e8:	dfc00117 	ldw	ra,4(sp)
811111ec:	df000017 	ldw	fp,0(sp)
811111f0:	dec00604 	addi	sp,sp,24
811111f4:	f800283a 	ret

811111f8 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
811111f8:	deffd304 	addi	sp,sp,-180
811111fc:	de00012e 	bgeu	sp,et,81111204 <vSendPusTM128+0xc>
81111200:	003b68fa 	trap	3
81111204:	dfc02815 	stw	ra,160(sp)
81111208:	df002715 	stw	fp,156(sp)
8111120c:	df002704 	addi	fp,sp,156
81111210:	e1000215 	stw	r4,8(fp)
81111214:	e1400315 	stw	r5,12(fp)
81111218:	e1800415 	stw	r6,16(fp)
8111121c:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81111220:	e03fdf8d 	sth	zero,-130(fp)
81111224:	e03fe00d 	sth	zero,-128(fp)
81111228:	e0bfe084 	addi	r2,fp,-126
8111122c:	00c01f04 	movi	r3,124
81111230:	180d883a 	mov	r6,r3
81111234:	000b883a 	mov	r5,zero
81111238:	1009883a 	mov	r4,r2
8111123c:	1117e1c0 	call	81117e1c <memset>
    unsigned char crc = 0;
81111240:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
81111244:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
81111248:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111124c:	1110f600 	call	81110f60 <usiGetIdCMD>
81111250:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81111254:	e1bfdf0b 	ldhu	r6,-132(fp)
81111258:	e080040b 	ldhu	r2,16(fp)
8111125c:	11ffffcc 	andi	r7,r2,65535
81111260:	e080048b 	ldhu	r2,18(fp)
81111264:	10bfffcc 	andi	r2,r2,65535
81111268:	e0c0050b 	ldhu	r3,20(fp)
8111126c:	18ffffcc 	andi	r3,r3,65535
81111270:	e100058b 	ldhu	r4,22(fp)
81111274:	213fffcc 	andi	r4,r4,65535
81111278:	e140060b 	ldhu	r5,24(fp)
8111127c:	297fffcc 	andi	r5,r5,65535
81111280:	e23fdf84 	addi	r8,fp,-130
81111284:	d9400315 	stw	r5,12(sp)
81111288:	d9000215 	stw	r4,8(sp)
8111128c:	d8c00115 	stw	r3,4(sp)
81111290:	d8800015 	stw	r2,0(sp)
81111294:	01604534 	movhi	r5,33044
81111298:	294fd904 	addi	r5,r5,16228
8111129c:	4009883a 	mov	r4,r8
811112a0:	11185ac0 	call	811185ac <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811112a4:	e03fdd05 	stb	zero,-140(fp)
811112a8:	00001206 	br	811112f4 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
811112ac:	e0bfdd03 	ldbu	r2,-140(fp)
811112b0:	10800284 	addi	r2,r2,10
811112b4:	1085883a 	add	r2,r2,r2
811112b8:	e0c00204 	addi	r3,fp,8
811112bc:	1885883a 	add	r2,r3,r2
811112c0:	1080000b 	ldhu	r2,0(r2)
811112c4:	113fffcc 	andi	r4,r2,65535
811112c8:	e0ffdf84 	addi	r3,fp,-130
811112cc:	e0bfdf84 	addi	r2,fp,-130
811112d0:	200f883a 	mov	r7,r4
811112d4:	180d883a 	mov	r6,r3
811112d8:	01604534 	movhi	r5,33044
811112dc:	294fe004 	addi	r5,r5,16256
811112e0:	1009883a 	mov	r4,r2
811112e4:	11185ac0 	call	811185ac <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811112e8:	e0bfdd03 	ldbu	r2,-140(fp)
811112ec:	10800044 	addi	r2,r2,1
811112f0:	e0bfdd05 	stb	r2,-140(fp)
811112f4:	e0800683 	ldbu	r2,26(fp)
811112f8:	10803fcc 	andi	r2,r2,255
811112fc:	e0ffdd03 	ldbu	r3,-140(fp)
81111300:	18bfea36 	bltu	r3,r2,811112ac <__reset+0xfb0f12ac>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81111304:	e0bfdf84 	addi	r2,fp,-130
81111308:	1009883a 	mov	r4,r2
8111130c:	11187c00 	call	811187c0 <strlen>
81111310:	1007883a 	mov	r3,r2
81111314:	e0bfdf84 	addi	r2,fp,-130
81111318:	180b883a 	mov	r5,r3
8111131c:	1009883a 	mov	r4,r2
81111320:	11121d00 	call	811121d0 <ucCrc8wInit>
81111324:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81111328:	e13fdd43 	ldbu	r4,-139(fp)
8111132c:	e0ffdf84 	addi	r3,fp,-130
81111330:	e0bfdf84 	addi	r2,fp,-130
81111334:	200f883a 	mov	r7,r4
81111338:	180d883a 	mov	r6,r3
8111133c:	01604534 	movhi	r5,33044
81111340:	294fcf04 	addi	r5,r5,16188
81111344:	1009883a 	mov	r4,r2
81111348:	11185ac0 	call	811185ac <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
8111134c:	e0bfdf0b 	ldhu	r2,-132(fp)
81111350:	10ffffcc 	andi	r3,r2,65535
81111354:	18e0001c 	xori	r3,r3,32768
81111358:	18e00004 	addi	r3,r3,-32768
8111135c:	e0bfdf84 	addi	r2,fp,-130
81111360:	180b883a 	mov	r5,r3
81111364:	1009883a 	mov	r4,r2
81111368:	11100c00 	call	811100c0 <bSendUART128v2>
8111136c:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81111370:	e0bfde17 	ldw	r2,-136(fp)
81111374:	10800060 	cmpeqi	r2,r2,1
81111378:	1000031e 	bne	r2,zero,81111388 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111137c:	e0bfdf84 	addi	r2,fp,-130
81111380:	1009883a 	mov	r4,r2
81111384:	11135300 	call	81113530 <vCouldNotSendTMPusCommand>
	}
}
81111388:	0001883a 	nop
8111138c:	e037883a 	mov	sp,fp
81111390:	dfc00117 	ldw	ra,4(sp)
81111394:	df000017 	ldw	fp,0(sp)
81111398:	dec00604 	addi	sp,sp,24
8111139c:	f800283a 	ret

811113a0 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
811113a0:	deffd704 	addi	sp,sp,-164
811113a4:	de00012e 	bgeu	sp,et,811113ac <vTMPusTestConnection+0xc>
811113a8:	003b68fa 	trap	3
811113ac:	dfc02815 	stw	ra,160(sp)
811113b0:	df002715 	stw	fp,156(sp)
811113b4:	df002704 	addi	fp,sp,156
811113b8:	2005883a 	mov	r2,r4
811113bc:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
811113c0:	e0bfff0b 	ldhu	r2,-4(fp)
811113c4:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
811113c8:	00801c04 	movi	r2,112
811113cc:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
811113d0:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
811113d4:	00800444 	movi	r2,17
811113d8:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
811113dc:	00800084 	movi	r2,2
811113e0:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
811113e4:	d809883a 	mov	r4,sp
811113e8:	e0bfee04 	addi	r2,fp,-72
811113ec:	00c01104 	movi	r3,68
811113f0:	180d883a 	mov	r6,r3
811113f4:	100b883a 	mov	r5,r2
811113f8:	1117ccc0 	call	81117ccc <memcpy>
811113fc:	e13fea17 	ldw	r4,-88(fp)
81111400:	e17feb17 	ldw	r5,-84(fp)
81111404:	e1bfec17 	ldw	r6,-80(fp)
81111408:	e1ffed17 	ldw	r7,-76(fp)
8111140c:	11110500 	call	81111050 <vSendPusTM64>
}
81111410:	0001883a 	nop
81111414:	e037883a 	mov	sp,fp
81111418:	dfc00117 	ldw	ra,4(sp)
8111141c:	df000017 	ldw	fp,0(sp)
81111420:	dec00204 	addi	sp,sp,8
81111424:	f800283a 	ret

81111428 <vLoadDefaultETHConf>:

/*Configuration related to the eth connection*/
TConfEth xConfEth;


bool vLoadDefaultETHConf( void ){
81111428:	defff504 	addi	sp,sp,-44
8111142c:	de00012e 	bgeu	sp,et,81111434 <vLoadDefaultETHConf+0xc>
81111430:	003b68fa 	trap	3
81111434:	dfc00a15 	stw	ra,40(sp)
81111438:	df000915 	stw	fp,36(sp)
8111143c:	dc000815 	stw	r16,32(sp)
81111440:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81111444:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81111448:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8111144c:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81111450:	d0a06717 	ldw	r2,-32356(gp)
81111454:	10800058 	cmpnei	r2,r2,1
81111458:	1002041e 	bne	r2,zero,81111c6c <vLoadDefaultETHConf+0x844>
8111145c:	1114f740 	call	81114f74 <bSDcardIsPresent>
81111460:	10020226 	beq	r2,zero,81111c6c <vLoadDefaultETHConf+0x844>
81111464:	1114fa40 	call	81114fa4 <bSDcardFAT16Check>
81111468:	10020026 	beq	r2,zero,81111c6c <vLoadDefaultETHConf+0x844>

		siFile = siOpenFile( ETH_FILE_NAME );
8111146c:	01204534 	movhi	r4,33044
81111470:	210fe204 	addi	r4,r4,16264
81111474:	11150cc0 	call	811150cc <siOpenFile>
81111478:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8111147c:	e0bffc0f 	ldh	r2,-16(fp)
81111480:	1001f216 	blt	r2,zero,81111c4c <vLoadDefaultETHConf+0x824>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81111484:	e0bffd04 	addi	r2,fp,-12
81111488:	01800204 	movi	r6,8
8111148c:	01400284 	movi	r5,10
81111490:	1009883a 	mov	r4,r2
81111494:	1117e1c0 	call	81117e1c <memset>
			p_inteiro = inteiro;
81111498:	e0bffd04 	addi	r2,fp,-12
8111149c:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
811114a0:	e0bffc0f 	ldh	r2,-16(fp)
811114a4:	1009883a 	mov	r4,r2
811114a8:	11151480 	call	81115148 <cGetNextChar>
811114ac:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
811114b0:	e0bff947 	ldb	r2,-27(fp)
811114b4:	10800084 	addi	r2,r2,2
811114b8:	10c015a8 	cmpgeui	r3,r2,86
811114bc:	1801d71e 	bne	r3,zero,81111c1c <vLoadDefaultETHConf+0x7f4>
811114c0:	100690ba 	slli	r3,r2,2
811114c4:	00a04474 	movhi	r2,33041
811114c8:	10853604 	addi	r2,r2,5336
811114cc:	1885883a 	add	r2,r3,r2
811114d0:	10800017 	ldw	r2,0(r2)
811114d4:	1000683a 	jmp	r2
811114d8:	81111670 	cmpltui	r4,r16,17497
811114dc:	81111664 	muli	r4,r16,17497
811114e0:	81111c1c 	xori	r4,r16,17520
811114e4:	81111c1c 	xori	r4,r16,17520
811114e8:	81111c1c 	xori	r4,r16,17520
811114ec:	81111c1c 	xori	r4,r16,17520
811114f0:	81111c1c 	xori	r4,r16,17520
811114f4:	81111c1c 	xori	r4,r16,17520
811114f8:	81111c1c 	xori	r4,r16,17520
811114fc:	81111c1c 	xori	r4,r16,17520
81111500:	81111c1c 	xori	r4,r16,17520
81111504:	81111c1c 	xori	r4,r16,17520
81111508:	81111c3c 	xorhi	r4,r16,17520
8111150c:	81111c1c 	xori	r4,r16,17520
81111510:	81111c1c 	xori	r4,r16,17520
81111514:	81111c3c 	xorhi	r4,r16,17520
81111518:	81111c1c 	xori	r4,r16,17520
8111151c:	81111c1c 	xori	r4,r16,17520
81111520:	81111c1c 	xori	r4,r16,17520
81111524:	81111c1c 	xori	r4,r16,17520
81111528:	81111c1c 	xori	r4,r16,17520
8111152c:	81111c1c 	xori	r4,r16,17520
81111530:	81111c1c 	xori	r4,r16,17520
81111534:	81111c1c 	xori	r4,r16,17520
81111538:	81111c1c 	xori	r4,r16,17520
8111153c:	81111c1c 	xori	r4,r16,17520
81111540:	81111c1c 	xori	r4,r16,17520
81111544:	81111c1c 	xori	r4,r16,17520
81111548:	81111c1c 	xori	r4,r16,17520
8111154c:	81111c1c 	xori	r4,r16,17520
81111550:	81111c1c 	xori	r4,r16,17520
81111554:	81111c1c 	xori	r4,r16,17520
81111558:	81111c1c 	xori	r4,r16,17520
8111155c:	81111c1c 	xori	r4,r16,17520
81111560:	81111c3c 	xorhi	r4,r16,17520
81111564:	81111c1c 	xori	r4,r16,17520
81111568:	81111c1c 	xori	r4,r16,17520
8111156c:	81111c1c 	xori	r4,r16,17520
81111570:	81111c1c 	xori	r4,r16,17520
81111574:	81111c1c 	xori	r4,r16,17520
81111578:	81111c1c 	xori	r4,r16,17520
8111157c:	81111630 	cmpltui	r4,r16,17496
81111580:	81111c1c 	xori	r4,r16,17520
81111584:	81111c1c 	xori	r4,r16,17520
81111588:	81111c1c 	xori	r4,r16,17520
8111158c:	81111c1c 	xori	r4,r16,17520
81111590:	81111c1c 	xori	r4,r16,17520
81111594:	81111c1c 	xori	r4,r16,17520
81111598:	81111c1c 	xori	r4,r16,17520
8111159c:	81111c1c 	xori	r4,r16,17520
811115a0:	81111c1c 	xori	r4,r16,17520
811115a4:	81111c1c 	xori	r4,r16,17520
811115a8:	81111c1c 	xori	r4,r16,17520
811115ac:	81111c1c 	xori	r4,r16,17520
811115b0:	81111c1c 	xori	r4,r16,17520
811115b4:	81111c1c 	xori	r4,r16,17520
811115b8:	81111c1c 	xori	r4,r16,17520
811115bc:	81111c1c 	xori	r4,r16,17520
811115c0:	81111c1c 	xori	r4,r16,17520
811115c4:	81111c1c 	xori	r4,r16,17520
811115c8:	81111c1c 	xori	r4,r16,17520
811115cc:	81111c1c 	xori	r4,r16,17520
811115d0:	81111bd4 	ori	r4,r16,17519
811115d4:	81111c1c 	xori	r4,r16,17520
811115d8:	81111c1c 	xori	r4,r16,17520
811115dc:	81111c1c 	xori	r4,r16,17520
811115e0:	81111c1c 	xori	r4,r16,17520
811115e4:	81111c1c 	xori	r4,r16,17520
811115e8:	81111c1c 	xori	r4,r16,17520
811115ec:	81111c1c 	xori	r4,r16,17520
811115f0:	811119d4 	ori	r4,r16,17511
811115f4:	81111c1c 	xori	r4,r16,17520
811115f8:	81111c1c 	xori	r4,r16,17520
811115fc:	81111834 	orhi	r4,r16,17504
81111600:	81111b2c 	andhi	r4,r16,17516
81111604:	81111768 	cmpgeui	r4,r16,17501
81111608:	81111c1c 	xori	r4,r16,17520
8111160c:	81111c1c 	xori	r4,r16,17520
81111610:	81111c1c 	xori	r4,r16,17520
81111614:	81111698 	cmpnei	r4,r16,17498
81111618:	81111c1c 	xori	r4,r16,17520
8111161c:	81111c1c 	xori	r4,r16,17520
81111620:	81111aa4 	muli	r4,r16,17514
81111624:	81111c1c 	xori	r4,r16,17520
81111628:	81111c1c 	xori	r4,r16,17520
8111162c:	81111904 	addi	r4,r16,17508
					case 39:// single quote '
						c = cGetNextChar(siFile);
81111630:	e0bffc0f 	ldh	r2,-16(fp)
81111634:	1009883a 	mov	r4,r2
81111638:	11151480 	call	81115148 <cGetNextChar>
8111163c:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81111640:	00000406 	br	81111654 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
81111644:	e0bffc0f 	ldh	r2,-16(fp)
81111648:	1009883a 	mov	r4,r2
8111164c:	11151480 	call	81115148 <cGetNextChar>
81111650:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81111654:	e0bff947 	ldb	r2,-27(fp)
81111658:	108009d8 	cmpnei	r2,r2,39
8111165c:	103ff91e 	bne	r2,zero,81111644 <__reset+0xfb0f1644>
							c = cGetNextChar(siFile);
						}
						break;
81111660:	00017706 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case -1: 	//EOF
						bEOF = TRUE;
81111664:	00800044 	movi	r2,1
81111668:	e0bff815 	stw	r2,-32(fp)
						break;
8111166c:	00017406 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81111670:	d0a05517 	ldw	r2,-32428(gp)
81111674:	100f883a 	mov	r7,r2
81111678:	018006c4 	movi	r6,27
8111167c:	01400044 	movi	r5,1
81111680:	01204534 	movhi	r4,33044
81111684:	210fe404 	addi	r4,r4,16272
81111688:	11172b80 	call	811172b8 <fwrite>
						#endif
						bEOF = TRUE;
8111168c:	00800044 	movi	r2,1
81111690:	e0bff815 	stw	r2,-32(fp)
						break;
81111694:	00016a06 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81111698:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111169c:	e0bffc0f 	ldh	r2,-16(fp)
811116a0:	1009883a 	mov	r4,r2
811116a4:	11151480 	call	81115148 <cGetNextChar>
811116a8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811116ac:	d0e00317 	ldw	r3,-32756(gp)
811116b0:	e0bff947 	ldb	r2,-27(fp)
811116b4:	10800044 	addi	r2,r2,1
811116b8:	1885883a 	add	r2,r3,r2
811116bc:	10800003 	ldbu	r2,0(r2)
811116c0:	10803fcc 	andi	r2,r2,255
811116c4:	1080010c 	andi	r2,r2,4
811116c8:	10000626 	beq	r2,zero,811116e4 <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
811116cc:	e0bffa17 	ldw	r2,-24(fp)
811116d0:	e0fff943 	ldbu	r3,-27(fp)
811116d4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811116d8:	e0bffa17 	ldw	r2,-24(fp)
811116dc:	10800044 	addi	r2,r2,1
811116e0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
811116e4:	e0bff947 	ldb	r2,-27(fp)
811116e8:	10800ea0 	cmpeqi	r2,r2,58
811116ec:	1000031e 	bne	r2,zero,811116fc <vLoadDefaultETHConf+0x2d4>
811116f0:	e0bff947 	ldb	r2,-27(fp)
811116f4:	10800ed8 	cmpnei	r2,r2,59
811116f8:	103fe81e 	bne	r2,zero,8111169c <__reset+0xfb0f169c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811116fc:	e0bffa17 	ldw	r2,-24(fp)
81111700:	00c00284 	movi	r3,10
81111704:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
81111708:	e0bff903 	ldbu	r2,-28(fp)
8111170c:	10800168 	cmpgeui	r2,r2,5
81111710:	1000021e 	bne	r2,zero,8111171c <vLoadDefaultETHConf+0x2f4>
81111714:	e43ff903 	ldbu	r16,-28(fp)
81111718:	00000106 	br	81111720 <vLoadDefaultETHConf+0x2f8>
8111171c:	04000144 	movi	r16,5
81111720:	e0bffd04 	addi	r2,fp,-12
81111724:	1009883a 	mov	r4,r2
81111728:	1116ac00 	call	81116ac0 <atoi>
8111172c:	1007883a 	mov	r3,r2
81111730:	00a045b4 	movhi	r2,33046
81111734:	10b20104 	addi	r2,r2,-14332
81111738:	1405883a 	add	r2,r2,r16
8111173c:	10800404 	addi	r2,r2,16
81111740:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81111744:	e0bffd04 	addi	r2,fp,-12
81111748:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111174c:	e0bff903 	ldbu	r2,-28(fp)
81111750:	10800044 	addi	r2,r2,1
81111754:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81111758:	e0bff947 	ldb	r2,-27(fp)
8111175c:	10800ed8 	cmpnei	r2,r2,59
81111760:	103fce1e 	bne	r2,zero,8111169c <__reset+0xfb0f169c>

						break;
81111764:	00013606 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case 'I':

						ucParser = 0;
81111768:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111176c:	e0bffc0f 	ldh	r2,-16(fp)
81111770:	1009883a 	mov	r4,r2
81111774:	11151480 	call	81115148 <cGetNextChar>
81111778:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111177c:	d0e00317 	ldw	r3,-32756(gp)
81111780:	e0bff947 	ldb	r2,-27(fp)
81111784:	10800044 	addi	r2,r2,1
81111788:	1885883a 	add	r2,r3,r2
8111178c:	10800003 	ldbu	r2,0(r2)
81111790:	10803fcc 	andi	r2,r2,255
81111794:	1080010c 	andi	r2,r2,4
81111798:	10000626 	beq	r2,zero,811117b4 <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
8111179c:	e0bffa17 	ldw	r2,-24(fp)
811117a0:	e0fff943 	ldbu	r3,-27(fp)
811117a4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811117a8:	e0bffa17 	ldw	r2,-24(fp)
811117ac:	10800044 	addi	r2,r2,1
811117b0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811117b4:	e0bff947 	ldb	r2,-27(fp)
811117b8:	10800ba0 	cmpeqi	r2,r2,46
811117bc:	1000031e 	bne	r2,zero,811117cc <vLoadDefaultETHConf+0x3a4>
811117c0:	e0bff947 	ldb	r2,-27(fp)
811117c4:	10800ed8 	cmpnei	r2,r2,59
811117c8:	103fe81e 	bne	r2,zero,8111176c <__reset+0xfb0f176c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811117cc:	e0bffa17 	ldw	r2,-24(fp)
811117d0:	00c00284 	movi	r3,10
811117d4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
811117d8:	e0bff903 	ldbu	r2,-28(fp)
811117dc:	108000e8 	cmpgeui	r2,r2,3
811117e0:	1000021e 	bne	r2,zero,811117ec <vLoadDefaultETHConf+0x3c4>
811117e4:	e43ff903 	ldbu	r16,-28(fp)
811117e8:	00000106 	br	811117f0 <vLoadDefaultETHConf+0x3c8>
811117ec:	040000c4 	movi	r16,3
811117f0:	e0bffd04 	addi	r2,fp,-12
811117f4:	1009883a 	mov	r4,r2
811117f8:	1116ac00 	call	81116ac0 <atoi>
811117fc:	1007883a 	mov	r3,r2
81111800:	00a045b4 	movhi	r2,33046
81111804:	10b20104 	addi	r2,r2,-14332
81111808:	1405883a 	add	r2,r2,r16
8111180c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81111810:	e0bffd04 	addi	r2,fp,-12
81111814:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81111818:	e0bff903 	ldbu	r2,-28(fp)
8111181c:	10800044 	addi	r2,r2,1
81111820:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81111824:	e0bff947 	ldb	r2,-27(fp)
81111828:	10800ed8 	cmpnei	r2,r2,59
8111182c:	103fcf1e 	bne	r2,zero,8111176c <__reset+0xfb0f176c>

						break;
81111830:	00010306 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case 'G':

						ucParser = 0;
81111834:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81111838:	e0bffc0f 	ldh	r2,-16(fp)
8111183c:	1009883a 	mov	r4,r2
81111840:	11151480 	call	81115148 <cGetNextChar>
81111844:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81111848:	d0e00317 	ldw	r3,-32756(gp)
8111184c:	e0bff947 	ldb	r2,-27(fp)
81111850:	10800044 	addi	r2,r2,1
81111854:	1885883a 	add	r2,r3,r2
81111858:	10800003 	ldbu	r2,0(r2)
8111185c:	10803fcc 	andi	r2,r2,255
81111860:	1080010c 	andi	r2,r2,4
81111864:	10000626 	beq	r2,zero,81111880 <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81111868:	e0bffa17 	ldw	r2,-24(fp)
8111186c:	e0fff943 	ldbu	r3,-27(fp)
81111870:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81111874:	e0bffa17 	ldw	r2,-24(fp)
81111878:	10800044 	addi	r2,r2,1
8111187c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81111880:	e0bff947 	ldb	r2,-27(fp)
81111884:	10800ba0 	cmpeqi	r2,r2,46
81111888:	1000031e 	bne	r2,zero,81111898 <vLoadDefaultETHConf+0x470>
8111188c:	e0bff947 	ldb	r2,-27(fp)
81111890:	10800ed8 	cmpnei	r2,r2,59
81111894:	103fe81e 	bne	r2,zero,81111838 <__reset+0xfb0f1838>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81111898:	e0bffa17 	ldw	r2,-24(fp)
8111189c:	00c00284 	movi	r3,10
811118a0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
811118a4:	e0bff903 	ldbu	r2,-28(fp)
811118a8:	108000e8 	cmpgeui	r2,r2,3
811118ac:	1000021e 	bne	r2,zero,811118b8 <vLoadDefaultETHConf+0x490>
811118b0:	e43ff903 	ldbu	r16,-28(fp)
811118b4:	00000106 	br	811118bc <vLoadDefaultETHConf+0x494>
811118b8:	040000c4 	movi	r16,3
811118bc:	e0bffd04 	addi	r2,fp,-12
811118c0:	1009883a 	mov	r4,r2
811118c4:	1116ac00 	call	81116ac0 <atoi>
811118c8:	1007883a 	mov	r3,r2
811118cc:	00a045b4 	movhi	r2,33046
811118d0:	10b20104 	addi	r2,r2,-14332
811118d4:	1405883a 	add	r2,r2,r16
811118d8:	10800104 	addi	r2,r2,4
811118dc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811118e0:	e0bffd04 	addi	r2,fp,-12
811118e4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811118e8:	e0bff903 	ldbu	r2,-28(fp)
811118ec:	10800044 	addi	r2,r2,1
811118f0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811118f4:	e0bff947 	ldb	r2,-27(fp)
811118f8:	10800ed8 	cmpnei	r2,r2,59
811118fc:	103fce1e 	bne	r2,zero,81111838 <__reset+0xfb0f1838>

						break;
81111900:	0000cf06 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case 'S':

						ucParser = 0;
81111904:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81111908:	e0bffc0f 	ldh	r2,-16(fp)
8111190c:	1009883a 	mov	r4,r2
81111910:	11151480 	call	81115148 <cGetNextChar>
81111914:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81111918:	d0e00317 	ldw	r3,-32756(gp)
8111191c:	e0bff947 	ldb	r2,-27(fp)
81111920:	10800044 	addi	r2,r2,1
81111924:	1885883a 	add	r2,r3,r2
81111928:	10800003 	ldbu	r2,0(r2)
8111192c:	10803fcc 	andi	r2,r2,255
81111930:	1080010c 	andi	r2,r2,4
81111934:	10000626 	beq	r2,zero,81111950 <vLoadDefaultETHConf+0x528>
									(*p_inteiro) = c;
81111938:	e0bffa17 	ldw	r2,-24(fp)
8111193c:	e0fff943 	ldbu	r3,-27(fp)
81111940:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81111944:	e0bffa17 	ldw	r2,-24(fp)
81111948:	10800044 	addi	r2,r2,1
8111194c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81111950:	e0bff947 	ldb	r2,-27(fp)
81111954:	10800ba0 	cmpeqi	r2,r2,46
81111958:	1000031e 	bne	r2,zero,81111968 <vLoadDefaultETHConf+0x540>
8111195c:	e0bff947 	ldb	r2,-27(fp)
81111960:	10800ed8 	cmpnei	r2,r2,59
81111964:	103fe81e 	bne	r2,zero,81111908 <__reset+0xfb0f1908>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81111968:	e0bffa17 	ldw	r2,-24(fp)
8111196c:	00c00284 	movi	r3,10
81111970:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81111974:	e0bff903 	ldbu	r2,-28(fp)
81111978:	108000e8 	cmpgeui	r2,r2,3
8111197c:	1000021e 	bne	r2,zero,81111988 <vLoadDefaultETHConf+0x560>
81111980:	e43ff903 	ldbu	r16,-28(fp)
81111984:	00000106 	br	8111198c <vLoadDefaultETHConf+0x564>
81111988:	040000c4 	movi	r16,3
8111198c:	e0bffd04 	addi	r2,fp,-12
81111990:	1009883a 	mov	r4,r2
81111994:	1116ac00 	call	81116ac0 <atoi>
81111998:	1007883a 	mov	r3,r2
8111199c:	00a045b4 	movhi	r2,33046
811119a0:	10b20104 	addi	r2,r2,-14332
811119a4:	1405883a 	add	r2,r2,r16
811119a8:	10800204 	addi	r2,r2,8
811119ac:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811119b0:	e0bffd04 	addi	r2,fp,-12
811119b4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811119b8:	e0bff903 	ldbu	r2,-28(fp)
811119bc:	10800044 	addi	r2,r2,1
811119c0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811119c4:	e0bff947 	ldb	r2,-27(fp)
811119c8:	10800ed8 	cmpnei	r2,r2,59
811119cc:	103fce1e 	bne	r2,zero,81111908 <__reset+0xfb0f1908>

						break;
811119d0:	00009b06 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case 'D':

						ucParser = 0;
811119d4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811119d8:	e0bffc0f 	ldh	r2,-16(fp)
811119dc:	1009883a 	mov	r4,r2
811119e0:	11151480 	call	81115148 <cGetNextChar>
811119e4:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811119e8:	d0e00317 	ldw	r3,-32756(gp)
811119ec:	e0bff947 	ldb	r2,-27(fp)
811119f0:	10800044 	addi	r2,r2,1
811119f4:	1885883a 	add	r2,r3,r2
811119f8:	10800003 	ldbu	r2,0(r2)
811119fc:	10803fcc 	andi	r2,r2,255
81111a00:	1080010c 	andi	r2,r2,4
81111a04:	10000626 	beq	r2,zero,81111a20 <vLoadDefaultETHConf+0x5f8>
									(*p_inteiro) = c;
81111a08:	e0bffa17 	ldw	r2,-24(fp)
81111a0c:	e0fff943 	ldbu	r3,-27(fp)
81111a10:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81111a14:	e0bffa17 	ldw	r2,-24(fp)
81111a18:	10800044 	addi	r2,r2,1
81111a1c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81111a20:	e0bff947 	ldb	r2,-27(fp)
81111a24:	10800ba0 	cmpeqi	r2,r2,46
81111a28:	1000031e 	bne	r2,zero,81111a38 <vLoadDefaultETHConf+0x610>
81111a2c:	e0bff947 	ldb	r2,-27(fp)
81111a30:	10800ed8 	cmpnei	r2,r2,59
81111a34:	103fe81e 	bne	r2,zero,811119d8 <__reset+0xfb0f19d8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81111a38:	e0bffa17 	ldw	r2,-24(fp)
81111a3c:	00c00284 	movi	r3,10
81111a40:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
81111a44:	e0bff903 	ldbu	r2,-28(fp)
81111a48:	108000e8 	cmpgeui	r2,r2,3
81111a4c:	1000021e 	bne	r2,zero,81111a58 <vLoadDefaultETHConf+0x630>
81111a50:	e43ff903 	ldbu	r16,-28(fp)
81111a54:	00000106 	br	81111a5c <vLoadDefaultETHConf+0x634>
81111a58:	040000c4 	movi	r16,3
81111a5c:	e0bffd04 	addi	r2,fp,-12
81111a60:	1009883a 	mov	r4,r2
81111a64:	1116ac00 	call	81116ac0 <atoi>
81111a68:	1007883a 	mov	r3,r2
81111a6c:	00a045b4 	movhi	r2,33046
81111a70:	10b20104 	addi	r2,r2,-14332
81111a74:	1405883a 	add	r2,r2,r16
81111a78:	10800304 	addi	r2,r2,12
81111a7c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81111a80:	e0bffd04 	addi	r2,fp,-12
81111a84:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81111a88:	e0bff903 	ldbu	r2,-28(fp)
81111a8c:	10800044 	addi	r2,r2,1
81111a90:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81111a94:	e0bff947 	ldb	r2,-27(fp)
81111a98:	10800ed8 	cmpnei	r2,r2,59
81111a9c:	103fce1e 	bne	r2,zero,811119d8 <__reset+0xfb0f19d8>

						break;						
81111aa0:	00006706 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case 'P':

						do {
							c = cGetNextChar(siFile);
81111aa4:	e0bffc0f 	ldh	r2,-16(fp)
81111aa8:	1009883a 	mov	r4,r2
81111aac:	11151480 	call	81115148 <cGetNextChar>
81111ab0:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81111ab4:	d0e00317 	ldw	r3,-32756(gp)
81111ab8:	e0bff947 	ldb	r2,-27(fp)
81111abc:	10800044 	addi	r2,r2,1
81111ac0:	1885883a 	add	r2,r3,r2
81111ac4:	10800003 	ldbu	r2,0(r2)
81111ac8:	10803fcc 	andi	r2,r2,255
81111acc:	1080010c 	andi	r2,r2,4
81111ad0:	10000626 	beq	r2,zero,81111aec <vLoadDefaultETHConf+0x6c4>
								(*p_inteiro) = c;
81111ad4:	e0bffa17 	ldw	r2,-24(fp)
81111ad8:	e0fff943 	ldbu	r3,-27(fp)
81111adc:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81111ae0:	e0bffa17 	ldw	r2,-24(fp)
81111ae4:	10800044 	addi	r2,r2,1
81111ae8:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81111aec:	e0bff947 	ldb	r2,-27(fp)
81111af0:	10800ed8 	cmpnei	r2,r2,59
81111af4:	103feb1e 	bne	r2,zero,81111aa4 <__reset+0xfb0f1aa4>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81111af8:	e0bffa17 	ldw	r2,-24(fp)
81111afc:	00c00284 	movi	r3,10
81111b00:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
81111b04:	e0bffd04 	addi	r2,fp,-12
81111b08:	1009883a 	mov	r4,r2
81111b0c:	1116ac00 	call	81116ac0 <atoi>
81111b10:	1007883a 	mov	r3,r2
81111b14:	00a045b4 	movhi	r2,33046
81111b18:	10b20104 	addi	r2,r2,-14332
81111b1c:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81111b20:	e0bffd04 	addi	r2,fp,-12
81111b24:	e0bffa15 	stw	r2,-24(fp)

						break;
81111b28:	00004506 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case 'H':

						do {
							c = cGetNextChar(siFile);
81111b2c:	e0bffc0f 	ldh	r2,-16(fp)
81111b30:	1009883a 	mov	r4,r2
81111b34:	11151480 	call	81115148 <cGetNextChar>
81111b38:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81111b3c:	d0e00317 	ldw	r3,-32756(gp)
81111b40:	e0bff947 	ldb	r2,-27(fp)
81111b44:	10800044 	addi	r2,r2,1
81111b48:	1885883a 	add	r2,r3,r2
81111b4c:	10800003 	ldbu	r2,0(r2)
81111b50:	10803fcc 	andi	r2,r2,255
81111b54:	1080010c 	andi	r2,r2,4
81111b58:	10000626 	beq	r2,zero,81111b74 <vLoadDefaultETHConf+0x74c>
								(*p_inteiro) = c;
81111b5c:	e0bffa17 	ldw	r2,-24(fp)
81111b60:	e0fff943 	ldbu	r3,-27(fp)
81111b64:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81111b68:	e0bffa17 	ldw	r2,-24(fp)
81111b6c:	10800044 	addi	r2,r2,1
81111b70:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81111b74:	e0bff947 	ldb	r2,-27(fp)
81111b78:	10800ed8 	cmpnei	r2,r2,59
81111b7c:	103feb1e 	bne	r2,zero,81111b2c <__reset+0xfb0f1b2c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81111b80:	e0bffa17 	ldw	r2,-24(fp)
81111b84:	00c00284 	movi	r3,10
81111b88:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81111b8c:	e0bffd04 	addi	r2,fp,-12
81111b90:	1009883a 	mov	r4,r2
81111b94:	1116ac00 	call	81116ac0 <atoi>
81111b98:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81111b9c:	e0bffc8f 	ldh	r2,-14(fp)
81111ba0:	10800058 	cmpnei	r2,r2,1
81111ba4:	1000051e 	bne	r2,zero,81111bbc <vLoadDefaultETHConf+0x794>
							xConfEth.bDHCP = TRUE;
81111ba8:	00a045b4 	movhi	r2,33046
81111bac:	10b20104 	addi	r2,r2,-14332
81111bb0:	00c00044 	movi	r3,1
81111bb4:	10c00615 	stw	r3,24(r2)
81111bb8:	00000306 	br	81111bc8 <vLoadDefaultETHConf+0x7a0>
						else
							xConfEth.bDHCP = FALSE;
81111bbc:	00a045b4 	movhi	r2,33046
81111bc0:	10b20104 	addi	r2,r2,-14332
81111bc4:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81111bc8:	e0bffd04 	addi	r2,fp,-12
81111bcc:	e0bffa15 	stw	r2,-24(fp)

						break;
81111bd0:	00001b06 	br	81111c40 <vLoadDefaultETHConf+0x818>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
81111bd4:	e0bffc0f 	ldh	r2,-16(fp)
81111bd8:	1009883a 	mov	r4,r2
81111bdc:	11151080 	call	81115108 <siCloseFile>
81111be0:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
81111be4:	e0bffb17 	ldw	r2,-20(fp)
81111be8:	1000071e 	bne	r2,zero,81111c08 <vLoadDefaultETHConf+0x7e0>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
81111bec:	d0a05517 	ldw	r2,-32428(gp)
81111bf0:	100f883a 	mov	r7,r2
81111bf4:	01800784 	movi	r6,30
81111bf8:	01400044 	movi	r5,1
81111bfc:	01204534 	movhi	r4,33044
81111c00:	210feb04 	addi	r4,r4,16300
81111c04:	11172b80 	call	811172b8 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81111c08:	00800044 	movi	r2,1
81111c0c:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81111c10:	00800044 	movi	r2,1
81111c14:	e0bff715 	stw	r2,-36(fp)
						break;
81111c18:	00000906 	br	81111c40 <vLoadDefaultETHConf+0x818>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
81111c1c:	d0a05517 	ldw	r2,-32428(gp)
81111c20:	100f883a 	mov	r7,r2
81111c24:	01800844 	movi	r6,33
81111c28:	01400044 	movi	r5,1
81111c2c:	01204534 	movhi	r4,33044
81111c30:	210ff304 	addi	r4,r4,16332
81111c34:	11172b80 	call	811172b8 <fwrite>
						#endif
						break;
81111c38:	00000106 	br	81111c40 <vLoadDefaultETHConf+0x818>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
81111c3c:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81111c40:	e0bff817 	ldw	r2,-32(fp)
81111c44:	103e1626 	beq	r2,zero,811114a0 <__reset+0xfb0f14a0>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81111c48:	00000f06 	br	81111c88 <vLoadDefaultETHConf+0x860>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
81111c4c:	d0a05517 	ldw	r2,-32428(gp)
81111c50:	100f883a 	mov	r7,r2
81111c54:	01800604 	movi	r6,24
81111c58:	01400044 	movi	r5,1
81111c5c:	01204534 	movhi	r4,33044
81111c60:	210ffc04 	addi	r4,r4,16368
81111c64:	11172b80 	call	811172b8 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81111c68:	00000706 	br	81111c88 <vLoadDefaultETHConf+0x860>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
81111c6c:	d0a05517 	ldw	r2,-32428(gp)
81111c70:	100f883a 	mov	r7,r2
81111c74:	018004c4 	movi	r6,19
81111c78:	01400044 	movi	r5,1
81111c7c:	01204534 	movhi	r4,33044
81111c80:	21100304 	addi	r4,r4,16396
81111c84:	11172b80 	call	811172b8 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81111c88:	e0bff717 	ldw	r2,-36(fp)
81111c8c:	1000541e 	bne	r2,zero,81111de0 <vLoadDefaultETHConf+0x9b8>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
81111c90:	01204534 	movhi	r4,33044
81111c94:	21100804 	addi	r4,r4,16416
81111c98:	11182680 	call	81118268 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
81111c9c:	01604534 	movhi	r5,33044
81111ca0:	294fe204 	addi	r5,r5,16264
81111ca4:	01204534 	movhi	r4,33044
81111ca8:	21101c04 	addi	r4,r4,16496
81111cac:	1117fe40 	call	81117fe4 <printf>


		xConfEth.siPortPUS = 17000;
81111cb0:	00a045b4 	movhi	r2,33046
81111cb4:	10b20104 	addi	r2,r2,-14332
81111cb8:	00d09a04 	movi	r3,17000
81111cbc:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
81111cc0:	00a045b4 	movhi	r2,33046
81111cc4:	10b20104 	addi	r2,r2,-14332
81111cc8:	00fff004 	movi	r3,-64
81111ccc:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
81111cd0:	00a045b4 	movhi	r2,33046
81111cd4:	10b20104 	addi	r2,r2,-14332
81111cd8:	00ffea04 	movi	r3,-88
81111cdc:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
81111ce0:	00a045b4 	movhi	r2,33046
81111ce4:	10b20104 	addi	r2,r2,-14332
81111ce8:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81111cec:	00a045b4 	movhi	r2,33046
81111cf0:	10b20104 	addi	r2,r2,-14332
81111cf4:	00c00144 	movi	r3,5
81111cf8:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81111cfc:	00a045b4 	movhi	r2,33046
81111d00:	10b20104 	addi	r2,r2,-14332
81111d04:	00fff004 	movi	r3,-64
81111d08:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81111d0c:	00a045b4 	movhi	r2,33046
81111d10:	10b20104 	addi	r2,r2,-14332
81111d14:	00ffea04 	movi	r3,-88
81111d18:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
81111d1c:	00a045b4 	movhi	r2,33046
81111d20:	10b20104 	addi	r2,r2,-14332
81111d24:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
81111d28:	00a045b4 	movhi	r2,33046
81111d2c:	10b20104 	addi	r2,r2,-14332
81111d30:	00c00044 	movi	r3,1
81111d34:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
81111d38:	00a045b4 	movhi	r2,33046
81111d3c:	10b20104 	addi	r2,r2,-14332
81111d40:	00ffffc4 	movi	r3,-1
81111d44:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
81111d48:	00a045b4 	movhi	r2,33046
81111d4c:	10b20104 	addi	r2,r2,-14332
81111d50:	00ffffc4 	movi	r3,-1
81111d54:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
81111d58:	00a045b4 	movhi	r2,33046
81111d5c:	10b20104 	addi	r2,r2,-14332
81111d60:	00ffffc4 	movi	r3,-1
81111d64:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
81111d68:	00a045b4 	movhi	r2,33046
81111d6c:	10b20104 	addi	r2,r2,-14332
81111d70:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
81111d74:	00a045b4 	movhi	r2,33046
81111d78:	10b20104 	addi	r2,r2,-14332
81111d7c:	00ffff04 	movi	r3,-4
81111d80:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
81111d84:	00a045b4 	movhi	r2,33046
81111d88:	10b20104 	addi	r2,r2,-14332
81111d8c:	00fffdc4 	movi	r3,-9
81111d90:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
81111d94:	00a045b4 	movhi	r2,33046
81111d98:	10b20104 	addi	r2,r2,-14332
81111d9c:	00c018c4 	movi	r3,99
81111da0:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
81111da4:	00a045b4 	movhi	r2,33046
81111da8:	10b20104 	addi	r2,r2,-14332
81111dac:	00c01344 	movi	r3,77
81111db0:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
81111db4:	00a045b4 	movhi	r2,33046
81111db8:	10b20104 	addi	r2,r2,-14332
81111dbc:	00c007c4 	movi	r3,31
81111dc0:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
81111dc4:	00a045b4 	movhi	r2,33046
81111dc8:	10b20104 	addi	r2,r2,-14332
81111dcc:	00c01084 	movi	r3,66
81111dd0:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
81111dd4:	00a045b4 	movhi	r2,33046
81111dd8:	10b20104 	addi	r2,r2,-14332
81111ddc:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
81111de0:	e0bff717 	ldw	r2,-36(fp)
}
81111de4:	e6ffff04 	addi	sp,fp,-4
81111de8:	dfc00217 	ldw	ra,8(sp)
81111dec:	df000117 	ldw	fp,4(sp)
81111df0:	dc000017 	ldw	r16,0(sp)
81111df4:	dec00304 	addi	sp,sp,12
81111df8:	f800283a 	ret

81111dfc <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
81111dfc:	defff004 	addi	sp,sp,-64
81111e00:	de00012e 	bgeu	sp,et,81111e08 <vShowEthConfig+0xc>
81111e04:	003b68fa 	trap	3
81111e08:	dfc00f15 	stw	ra,60(sp)
81111e0c:	df000e15 	stw	fp,56(sp)
81111e10:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
81111e14:	d0a05517 	ldw	r2,-32428(gp)
81111e18:	100f883a 	mov	r7,r2
81111e1c:	018007c4 	movi	r6,31
81111e20:	01400044 	movi	r5,1
81111e24:	01204534 	movhi	r4,33044
81111e28:	21102204 	addi	r4,r4,16520
81111e2c:	11172b80 	call	811172b8 <fwrite>

		memset(buffer,0,40);
81111e30:	01800a04 	movi	r6,40
81111e34:	000b883a 	mov	r5,zero
81111e38:	e13ff604 	addi	r4,fp,-40
81111e3c:	1117e1c0 	call	81117e1c <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
81111e40:	00a045b4 	movhi	r2,33046
81111e44:	10b20104 	addi	r2,r2,-14332
81111e48:	10800403 	ldbu	r2,16(r2)
81111e4c:	11803fcc 	andi	r6,r2,255
81111e50:	00a045b4 	movhi	r2,33046
81111e54:	10b20104 	addi	r2,r2,-14332
81111e58:	10800443 	ldbu	r2,17(r2)
81111e5c:	11c03fcc 	andi	r7,r2,255
81111e60:	00a045b4 	movhi	r2,33046
81111e64:	10b20104 	addi	r2,r2,-14332
81111e68:	10800483 	ldbu	r2,18(r2)
81111e6c:	10c03fcc 	andi	r3,r2,255
81111e70:	00a045b4 	movhi	r2,33046
81111e74:	10b20104 	addi	r2,r2,-14332
81111e78:	108004c3 	ldbu	r2,19(r2)
81111e7c:	11003fcc 	andi	r4,r2,255
81111e80:	00a045b4 	movhi	r2,33046
81111e84:	10b20104 	addi	r2,r2,-14332
81111e88:	10800503 	ldbu	r2,20(r2)
81111e8c:	11403fcc 	andi	r5,r2,255
81111e90:	00a045b4 	movhi	r2,33046
81111e94:	10b20104 	addi	r2,r2,-14332
81111e98:	10800543 	ldbu	r2,21(r2)
81111e9c:	10803fcc 	andi	r2,r2,255
81111ea0:	d8800315 	stw	r2,12(sp)
81111ea4:	d9400215 	stw	r5,8(sp)
81111ea8:	d9000115 	stw	r4,4(sp)
81111eac:	d8c00015 	stw	r3,0(sp)
81111eb0:	01604534 	movhi	r5,33044
81111eb4:	29502a04 	addi	r5,r5,16552
81111eb8:	e13ff604 	addi	r4,fp,-40
81111ebc:	11185ac0 	call	811185ac <sprintf>
		debug(fp, buffer );
81111ec0:	d0a05517 	ldw	r2,-32428(gp)
81111ec4:	e17ff604 	addi	r5,fp,-40
81111ec8:	1009883a 	mov	r4,r2
81111ecc:	1116c1c0 	call	81116c1c <fprintf>

		memset(buffer,0,40);
81111ed0:	01800a04 	movi	r6,40
81111ed4:	000b883a 	mov	r5,zero
81111ed8:	e13ff604 	addi	r4,fp,-40
81111edc:	1117e1c0 	call	81117e1c <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
81111ee0:	00a045b4 	movhi	r2,33046
81111ee4:	10b20104 	addi	r2,r2,-14332
81111ee8:	10800003 	ldbu	r2,0(r2)
81111eec:	11003fcc 	andi	r4,r2,255
81111ef0:	00a045b4 	movhi	r2,33046
81111ef4:	10b20104 	addi	r2,r2,-14332
81111ef8:	10800043 	ldbu	r2,1(r2)
81111efc:	11403fcc 	andi	r5,r2,255
81111f00:	00a045b4 	movhi	r2,33046
81111f04:	10b20104 	addi	r2,r2,-14332
81111f08:	10800083 	ldbu	r2,2(r2)
81111f0c:	10c03fcc 	andi	r3,r2,255
81111f10:	00a045b4 	movhi	r2,33046
81111f14:	10b20104 	addi	r2,r2,-14332
81111f18:	108000c3 	ldbu	r2,3(r2)
81111f1c:	10803fcc 	andi	r2,r2,255
81111f20:	d8800115 	stw	r2,4(sp)
81111f24:	d8c00015 	stw	r3,0(sp)
81111f28:	280f883a 	mov	r7,r5
81111f2c:	200d883a 	mov	r6,r4
81111f30:	01604534 	movhi	r5,33044
81111f34:	29503304 	addi	r5,r5,16588
81111f38:	e13ff604 	addi	r4,fp,-40
81111f3c:	11185ac0 	call	811185ac <sprintf>
		debug(fp, buffer );
81111f40:	d0a05517 	ldw	r2,-32428(gp)
81111f44:	e17ff604 	addi	r5,fp,-40
81111f48:	1009883a 	mov	r4,r2
81111f4c:	1116c1c0 	call	81116c1c <fprintf>

		memset(buffer,0,40);
81111f50:	01800a04 	movi	r6,40
81111f54:	000b883a 	mov	r5,zero
81111f58:	e13ff604 	addi	r4,fp,-40
81111f5c:	1117e1c0 	call	81117e1c <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
81111f60:	00a045b4 	movhi	r2,33046
81111f64:	10b20104 	addi	r2,r2,-14332
81111f68:	10800103 	ldbu	r2,4(r2)
81111f6c:	11003fcc 	andi	r4,r2,255
81111f70:	00a045b4 	movhi	r2,33046
81111f74:	10b20104 	addi	r2,r2,-14332
81111f78:	10800143 	ldbu	r2,5(r2)
81111f7c:	11403fcc 	andi	r5,r2,255
81111f80:	00a045b4 	movhi	r2,33046
81111f84:	10b20104 	addi	r2,r2,-14332
81111f88:	10800183 	ldbu	r2,6(r2)
81111f8c:	10c03fcc 	andi	r3,r2,255
81111f90:	00a045b4 	movhi	r2,33046
81111f94:	10b20104 	addi	r2,r2,-14332
81111f98:	108001c3 	ldbu	r2,7(r2)
81111f9c:	10803fcc 	andi	r2,r2,255
81111fa0:	d8800115 	stw	r2,4(sp)
81111fa4:	d8c00015 	stw	r3,0(sp)
81111fa8:	280f883a 	mov	r7,r5
81111fac:	200d883a 	mov	r6,r4
81111fb0:	01604534 	movhi	r5,33044
81111fb4:	29503904 	addi	r5,r5,16612
81111fb8:	e13ff604 	addi	r4,fp,-40
81111fbc:	11185ac0 	call	811185ac <sprintf>
		debug(fp, buffer );
81111fc0:	d0a05517 	ldw	r2,-32428(gp)
81111fc4:	e17ff604 	addi	r5,fp,-40
81111fc8:	1009883a 	mov	r4,r2
81111fcc:	1116c1c0 	call	81116c1c <fprintf>

		memset(buffer,0,40);
81111fd0:	01800a04 	movi	r6,40
81111fd4:	000b883a 	mov	r5,zero
81111fd8:	e13ff604 	addi	r4,fp,-40
81111fdc:	1117e1c0 	call	81117e1c <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
81111fe0:	00a045b4 	movhi	r2,33046
81111fe4:	10b20104 	addi	r2,r2,-14332
81111fe8:	10800203 	ldbu	r2,8(r2)
81111fec:	11003fcc 	andi	r4,r2,255
81111ff0:	00a045b4 	movhi	r2,33046
81111ff4:	10b20104 	addi	r2,r2,-14332
81111ff8:	10800243 	ldbu	r2,9(r2)
81111ffc:	11403fcc 	andi	r5,r2,255
81112000:	00a045b4 	movhi	r2,33046
81112004:	10b20104 	addi	r2,r2,-14332
81112008:	10800283 	ldbu	r2,10(r2)
8111200c:	10c03fcc 	andi	r3,r2,255
81112010:	00a045b4 	movhi	r2,33046
81112014:	10b20104 	addi	r2,r2,-14332
81112018:	108002c3 	ldbu	r2,11(r2)
8111201c:	10803fcc 	andi	r2,r2,255
81112020:	d8800115 	stw	r2,4(sp)
81112024:	d8c00015 	stw	r3,0(sp)
81112028:	280f883a 	mov	r7,r5
8111202c:	200d883a 	mov	r6,r4
81112030:	01604534 	movhi	r5,33044
81112034:	29504004 	addi	r5,r5,16640
81112038:	e13ff604 	addi	r4,fp,-40
8111203c:	11185ac0 	call	811185ac <sprintf>
		debug(fp, buffer );
81112040:	d0a05517 	ldw	r2,-32428(gp)
81112044:	e17ff604 	addi	r5,fp,-40
81112048:	1009883a 	mov	r4,r2
8111204c:	1116c1c0 	call	81116c1c <fprintf>

		memset(buffer,0,40);
81112050:	01800a04 	movi	r6,40
81112054:	000b883a 	mov	r5,zero
81112058:	e13ff604 	addi	r4,fp,-40
8111205c:	1117e1c0 	call	81117e1c <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
81112060:	00a045b4 	movhi	r2,33046
81112064:	10b20104 	addi	r2,r2,-14332
81112068:	10800303 	ldbu	r2,12(r2)
8111206c:	11003fcc 	andi	r4,r2,255
81112070:	00a045b4 	movhi	r2,33046
81112074:	10b20104 	addi	r2,r2,-14332
81112078:	10800343 	ldbu	r2,13(r2)
8111207c:	11403fcc 	andi	r5,r2,255
81112080:	00a045b4 	movhi	r2,33046
81112084:	10b20104 	addi	r2,r2,-14332
81112088:	10800383 	ldbu	r2,14(r2)
8111208c:	10c03fcc 	andi	r3,r2,255
81112090:	00a045b4 	movhi	r2,33046
81112094:	10b20104 	addi	r2,r2,-14332
81112098:	108003c3 	ldbu	r2,15(r2)
8111209c:	10803fcc 	andi	r2,r2,255
811120a0:	d8800115 	stw	r2,4(sp)
811120a4:	d8c00015 	stw	r3,0(sp)
811120a8:	280f883a 	mov	r7,r5
811120ac:	200d883a 	mov	r6,r4
811120b0:	01604534 	movhi	r5,33044
811120b4:	29504704 	addi	r5,r5,16668
811120b8:	e13ff604 	addi	r4,fp,-40
811120bc:	11185ac0 	call	811185ac <sprintf>
		debug(fp, buffer );
811120c0:	d0a05517 	ldw	r2,-32428(gp)
811120c4:	e17ff604 	addi	r5,fp,-40
811120c8:	1009883a 	mov	r4,r2
811120cc:	1116c1c0 	call	81116c1c <fprintf>

		memset(buffer,0,40);
811120d0:	01800a04 	movi	r6,40
811120d4:	000b883a 	mov	r5,zero
811120d8:	e13ff604 	addi	r4,fp,-40
811120dc:	1117e1c0 	call	81117e1c <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
811120e0:	00a045b4 	movhi	r2,33046
811120e4:	10b20104 	addi	r2,r2,-14332
811120e8:	1080058b 	ldhu	r2,22(r2)
811120ec:	10bfffcc 	andi	r2,r2,65535
811120f0:	100d883a 	mov	r6,r2
811120f4:	01604534 	movhi	r5,33044
811120f8:	29504e04 	addi	r5,r5,16696
811120fc:	e13ff604 	addi	r4,fp,-40
81112100:	11185ac0 	call	811185ac <sprintf>
		debug(fp, buffer );
81112104:	d0a05517 	ldw	r2,-32428(gp)
81112108:	e17ff604 	addi	r5,fp,-40
8111210c:	1009883a 	mov	r4,r2
81112110:	1116c1c0 	call	81116c1c <fprintf>

	}
81112114:	0001883a 	nop
81112118:	e037883a 	mov	sp,fp
8111211c:	dfc00117 	ldw	ra,4(sp)
81112120:	df000017 	ldw	fp,0(sp)
81112124:	dec00204 	addi	sp,sp,8
81112128:	f800283a 	ret

8111212c <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111212c:	defffb04 	addi	sp,sp,-20
81112130:	de00012e 	bgeu	sp,et,81112138 <ucCrc8+0xc>
81112134:	003b68fa 	trap	3
81112138:	df000415 	stw	fp,16(sp)
8111213c:	df000404 	addi	fp,sp,16
81112140:	e13ffd15 	stw	r4,-12(fp)
81112144:	e17ffe15 	stw	r5,-8(fp)
81112148:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111214c:	e0bffe17 	ldw	r2,-8(fp)
81112150:	1000021e 	bne	r2,zero,8111215c <ucCrc8+0x30>
        return 0;
81112154:	0005883a 	mov	r2,zero
81112158:	00001906 	br	811121c0 <ucCrc8+0x94>
    crc &= 0xff;
8111215c:	e0bffd17 	ldw	r2,-12(fp)
81112160:	10803fcc 	andi	r2,r2,255
81112164:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
81112168:	e0fffe17 	ldw	r3,-8(fp)
8111216c:	e0bfff17 	ldw	r2,-4(fp)
81112170:	1885883a 	add	r2,r3,r2
81112174:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
81112178:	00000d06 	br	811121b0 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111217c:	e0bffe17 	ldw	r2,-8(fp)
81112180:	10c00044 	addi	r3,r2,1
81112184:	e0fffe15 	stw	r3,-8(fp)
81112188:	10800003 	ldbu	r2,0(r2)
8111218c:	10c03fcc 	andi	r3,r2,255
81112190:	e0bffd17 	ldw	r2,-12(fp)
81112194:	1886f03a 	xor	r3,r3,r2
81112198:	00a04534 	movhi	r2,33044
8111219c:	109051c4 	addi	r2,r2,16711
811121a0:	10c5883a 	add	r2,r2,r3
811121a4:	10800003 	ldbu	r2,0(r2)
811121a8:	10803fcc 	andi	r2,r2,255
811121ac:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
811121b0:	e0fffe17 	ldw	r3,-8(fp)
811121b4:	e0bffc17 	ldw	r2,-16(fp)
811121b8:	18bff036 	bltu	r3,r2,8111217c <__reset+0xfb0f217c>
        crc = crc8_table[crc ^ *data++];
    return crc;
811121bc:	e0bffd17 	ldw	r2,-12(fp)
}
811121c0:	e037883a 	mov	sp,fp
811121c4:	df000017 	ldw	fp,0(sp)
811121c8:	dec00104 	addi	sp,sp,4
811121cc:	f800283a 	ret

811121d0 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
811121d0:	defffb04 	addi	sp,sp,-20
811121d4:	de00012e 	bgeu	sp,et,811121dc <ucCrc8wInit+0xc>
811121d8:	003b68fa 	trap	3
811121dc:	dfc00415 	stw	ra,16(sp)
811121e0:	df000315 	stw	fp,12(sp)
811121e4:	df000304 	addi	fp,sp,12
811121e8:	e13ffe15 	stw	r4,-8(fp)
811121ec:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
811121f0:	000d883a 	mov	r6,zero
811121f4:	000b883a 	mov	r5,zero
811121f8:	0009883a 	mov	r4,zero
811121fc:	111212c0 	call	8111212c <ucCrc8>
81112200:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
81112204:	e0bffd03 	ldbu	r2,-12(fp)
81112208:	e1bfff17 	ldw	r6,-4(fp)
8111220c:	e17ffe17 	ldw	r5,-8(fp)
81112210:	1009883a 	mov	r4,r2
81112214:	111212c0 	call	8111212c <ucCrc8>
}
81112218:	e037883a 	mov	sp,fp
8111221c:	dfc00117 	ldw	ra,4(sp)
81112220:	df000017 	ldw	fp,0(sp)
81112224:	dec00204 	addi	sp,sp,8
81112228:	f800283a 	ret

8111222c <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111222c:	defffc04 	addi	sp,sp,-16
81112230:	de00012e 	bgeu	sp,et,81112238 <vDataControllerInit+0xc>
81112234:	003b68fa 	trap	3
81112238:	df000315 	stw	fp,12(sp)
8111223c:	df000304 	addi	fp,sp,12
81112240:	e13ffe15 	stw	r4,-8(fp)
81112244:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81112248:	e03ffd05 	stb	zero,-12(fp)
8111224c:	00001c06 	br	811122c0 <vDataControllerInit+0x94>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
81112250:	e0bffd03 	ldbu	r2,-12(fp)
81112254:	e0fffd03 	ldbu	r3,-12(fp)
81112258:	18c08f24 	muli	r3,r3,572
8111225c:	e13fff17 	ldw	r4,-4(fp)
81112260:	20c7883a 	add	r3,r4,r3
81112264:	e13ffe17 	ldw	r4,-8(fp)
81112268:	10800204 	addi	r2,r2,8
8111226c:	1085883a 	add	r2,r2,r2
81112270:	1085883a 	add	r2,r2,r2
81112274:	2085883a 	add	r2,r4,r2
81112278:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111227c:	e17ffd03 	ldbu	r5,-12(fp)
81112280:	e0bffd03 	ldbu	r2,-12(fp)
81112284:	e0ffff17 	ldw	r3,-4(fp)
81112288:	1080d684 	addi	r2,r2,858
8111228c:	1085883a 	add	r2,r2,r2
81112290:	1085883a 	add	r2,r2,r2
81112294:	1885883a 	add	r2,r3,r2
81112298:	10c00017 	ldw	r3,0(r2)
8111229c:	e13ffe17 	ldw	r4,-8(fp)
811122a0:	28800384 	addi	r2,r5,14
811122a4:	1085883a 	add	r2,r2,r2
811122a8:	1085883a 	add	r2,r2,r2
811122ac:	2085883a 	add	r2,r4,r2
811122b0:	10c00015 	stw	r3,0(r2)


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
811122b4:	e0bffd03 	ldbu	r2,-12(fp)
811122b8:	10800044 	addi	r2,r2,1
811122bc:	e0bffd05 	stb	r2,-12(fp)
811122c0:	e0bffd03 	ldbu	r2,-12(fp)
811122c4:	108001b0 	cmpltui	r2,r2,6
811122c8:	103fe11e 	bne	r2,zero,81112250 <__reset+0xfb0f2250>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
811122cc:	e0bfff17 	ldw	r2,-4(fp)
811122d0:	10c36604 	addi	r3,r2,3480
811122d4:	e0bffe17 	ldw	r2,-8(fp)
811122d8:	10c01415 	stw	r3,80(r2)
	xDataControlL->bUpdateComplete = FALSE;
811122dc:	e0bffe17 	ldw	r2,-8(fp)
811122e0:	10001515 	stw	zero,84(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
811122e4:	e0bffe17 	ldw	r2,-8(fp)
811122e8:	10c01504 	addi	r3,r2,84
811122ec:	e0bfff17 	ldw	r2,-4(fp)
811122f0:	10c36815 	stw	r3,3488(r2)
}
811122f4:	0001883a 	nop
811122f8:	e037883a 	mov	sp,fp
811122fc:	df000017 	ldw	fp,0(sp)
81112300:	dec00104 	addi	sp,sp,4
81112304:	f800283a 	ret

81112308 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
81112308:	defff904 	addi	sp,sp,-28
8111230c:	de00012e 	bgeu	sp,et,81112314 <printErrorTask+0xc>
81112310:	003b68fa 	trap	3
81112314:	dfc00615 	stw	ra,24(sp)
81112318:	df000515 	stw	fp,20(sp)
8111231c:	df000504 	addi	fp,sp,20
81112320:	2005883a 	mov	r2,r4
81112324:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
81112328:	e03ffb15 	stw	zero,-20(fp)
8111232c:	e03ffc15 	stw	zero,-16(fp)
81112330:	e03ffd15 	stw	zero,-12(fp)
81112334:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
81112338:	e0bfff03 	ldbu	r2,-4(fp)
8111233c:	100d883a 	mov	r6,r2
81112340:	01604534 	movhi	r5,33044
81112344:	29509204 	addi	r5,r5,16968
81112348:	e13ffb04 	addi	r4,fp,-20
8111234c:	11185ac0 	call	811185ac <sprintf>
		debug(fp, buffer);
81112350:	d0a05517 	ldw	r2,-32428(gp)
81112354:	e17ffb04 	addi	r5,fp,-20
81112358:	1009883a 	mov	r4,r2
8111235c:	1116c1c0 	call	81116c1c <fprintf>
	}
81112360:	0001883a 	nop
81112364:	e037883a 	mov	sp,fp
81112368:	dfc00117 	ldw	ra,4(sp)
8111236c:	df000017 	ldw	fp,0(sp)
81112370:	dec00204 	addi	sp,sp,8
81112374:	f800283a 	ret

81112378 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
81112378:	defffd04 	addi	sp,sp,-12
8111237c:	de00012e 	bgeu	sp,et,81112384 <vFailCreateMutexSResources+0xc>
81112380:	003b68fa 	trap	3
81112384:	dfc00215 	stw	ra,8(sp)
81112388:	df000115 	stw	fp,4(sp)
8111238c:	df000104 	addi	fp,sp,4
81112390:	2005883a 	mov	r2,r4
81112394:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
81112398:	d0a05517 	ldw	r2,-32428(gp)
8111239c:	100f883a 	mov	r7,r2
811123a0:	018008c4 	movi	r6,35
811123a4:	01400044 	movi	r5,1
811123a8:	01204534 	movhi	r4,33044
811123ac:	21109504 	addi	r4,r4,16980
811123b0:	11172b80 	call	811172b8 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
811123b4:	e0bfff03 	ldbu	r2,-4(fp)
811123b8:	1009883a 	mov	r4,r2
811123bc:	11123080 	call	81112308 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811123c0:	0001883a 	nop
811123c4:	e037883a 	mov	sp,fp
811123c8:	dfc00117 	ldw	ra,4(sp)
811123cc:	df000017 	ldw	fp,0(sp)
811123d0:	dec00204 	addi	sp,sp,8
811123d4:	f800283a 	ret

811123d8 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
811123d8:	defffe04 	addi	sp,sp,-8
811123dc:	de00012e 	bgeu	sp,et,811123e4 <vFailCreateSemaphoreResources+0xc>
811123e0:	003b68fa 	trap	3
811123e4:	dfc00115 	stw	ra,4(sp)
811123e8:	df000015 	stw	fp,0(sp)
811123ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
811123f0:	d0a05517 	ldw	r2,-32428(gp)
811123f4:	100f883a 	mov	r7,r2
811123f8:	01800984 	movi	r6,38
811123fc:	01400044 	movi	r5,1
81112400:	01204534 	movhi	r4,33044
81112404:	21109e04 	addi	r4,r4,17016
81112408:	11172b80 	call	811172b8 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111240c:	0001883a 	nop
81112410:	e037883a 	mov	sp,fp
81112414:	dfc00117 	ldw	ra,4(sp)
81112418:	df000017 	ldw	fp,0(sp)
8111241c:	dec00204 	addi	sp,sp,8
81112420:	f800283a 	ret

81112424 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
81112424:	defffe04 	addi	sp,sp,-8
81112428:	de00012e 	bgeu	sp,et,81112430 <vFailTestCriticasParts+0xc>
8111242c:	003b68fa 	trap	3
81112430:	dfc00115 	stw	ra,4(sp)
81112434:	df000015 	stw	fp,0(sp)
81112438:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111243c:	d0a05517 	ldw	r2,-32428(gp)
81112440:	100f883a 	mov	r7,r2
81112444:	018007c4 	movi	r6,31
81112448:	01400044 	movi	r5,1
8111244c:	01204534 	movhi	r4,33044
81112450:	2110a804 	addi	r4,r4,17056
81112454:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112458:	0001883a 	nop
8111245c:	e037883a 	mov	sp,fp
81112460:	dfc00117 	ldw	ra,4(sp)
81112464:	df000017 	ldw	fp,0(sp)
81112468:	dec00204 	addi	sp,sp,8
8111246c:	f800283a 	ret

81112470 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
81112470:	defffe04 	addi	sp,sp,-8
81112474:	de00012e 	bgeu	sp,et,8111247c <vFailSendxSemCommInit+0xc>
81112478:	003b68fa 	trap	3
8111247c:	dfc00115 	stw	ra,4(sp)
81112480:	df000015 	stw	fp,0(sp)
81112484:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
81112488:	d0a05517 	ldw	r2,-32428(gp)
8111248c:	100f883a 	mov	r7,r2
81112490:	01800744 	movi	r6,29
81112494:	01400044 	movi	r5,1
81112498:	01204534 	movhi	r4,33044
8111249c:	2110b004 	addi	r4,r4,17088
811124a0:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
811124a4:	d0a05517 	ldw	r2,-32428(gp)
811124a8:	100f883a 	mov	r7,r2
811124ac:	01800a44 	movi	r6,41
811124b0:	01400044 	movi	r5,1
811124b4:	01204534 	movhi	r4,33044
811124b8:	2110b804 	addi	r4,r4,17120
811124bc:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811124c0:	0001883a 	nop
811124c4:	e037883a 	mov	sp,fp
811124c8:	dfc00117 	ldw	ra,4(sp)
811124cc:	df000017 	ldw	fp,0(sp)
811124d0:	dec00204 	addi	sp,sp,8
811124d4:	f800283a 	ret

811124d8 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
811124d8:	defffe04 	addi	sp,sp,-8
811124dc:	de00012e 	bgeu	sp,et,811124e4 <vFailSendPreParsedSemaphore+0xc>
811124e0:	003b68fa 	trap	3
811124e4:	dfc00115 	stw	ra,4(sp)
811124e8:	df000015 	stw	fp,0(sp)
811124ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
811124f0:	d0a05517 	ldw	r2,-32428(gp)
811124f4:	100f883a 	mov	r7,r2
811124f8:	01800904 	movi	r6,36
811124fc:	01400044 	movi	r5,1
81112500:	01204534 	movhi	r4,33044
81112504:	2110c304 	addi	r4,r4,17164
81112508:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111250c:	0001883a 	nop
81112510:	e037883a 	mov	sp,fp
81112514:	dfc00117 	ldw	ra,4(sp)
81112518:	df000017 	ldw	fp,0(sp)
8111251c:	dec00204 	addi	sp,sp,8
81112520:	f800283a 	ret

81112524 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
81112524:	defffe04 	addi	sp,sp,-8
81112528:	de00012e 	bgeu	sp,et,81112530 <vFailSendPreAckReceiverSemaphore+0xc>
8111252c:	003b68fa 	trap	3
81112530:	dfc00115 	stw	ra,4(sp)
81112534:	df000015 	stw	fp,0(sp)
81112538:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111253c:	d0a05517 	ldw	r2,-32428(gp)
81112540:	100f883a 	mov	r7,r2
81112544:	01800a44 	movi	r6,41
81112548:	01400044 	movi	r5,1
8111254c:	01204534 	movhi	r4,33044
81112550:	2110cd04 	addi	r4,r4,17204
81112554:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112558:	0001883a 	nop
8111255c:	e037883a 	mov	sp,fp
81112560:	dfc00117 	ldw	ra,4(sp)
81112564:	df000017 	ldw	fp,0(sp)
81112568:	dec00204 	addi	sp,sp,8
8111256c:	f800283a 	ret

81112570 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
81112570:	defffe04 	addi	sp,sp,-8
81112574:	de00012e 	bgeu	sp,et,8111257c <vFailSendPreAckSenderSemaphore+0xc>
81112578:	003b68fa 	trap	3
8111257c:	dfc00115 	stw	ra,4(sp)
81112580:	df000015 	stw	fp,0(sp)
81112584:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
81112588:	d0a05517 	ldw	r2,-32428(gp)
8111258c:	100f883a 	mov	r7,r2
81112590:	018009c4 	movi	r6,39
81112594:	01400044 	movi	r5,1
81112598:	01204534 	movhi	r4,33044
8111259c:	2110d804 	addi	r4,r4,17248
811125a0:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811125a4:	0001883a 	nop
811125a8:	e037883a 	mov	sp,fp
811125ac:	dfc00117 	ldw	ra,4(sp)
811125b0:	df000017 	ldw	fp,0(sp)
811125b4:	dec00204 	addi	sp,sp,8
811125b8:	f800283a 	ret

811125bc <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
811125bc:	defffe04 	addi	sp,sp,-8
811125c0:	de00012e 	bgeu	sp,et,811125c8 <vFailGetCountSemaphoreSenderTask+0xc>
811125c4:	003b68fa 	trap	3
811125c8:	dfc00115 	stw	ra,4(sp)
811125cc:	df000015 	stw	fp,0(sp)
811125d0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
811125d4:	d0a05517 	ldw	r2,-32428(gp)
811125d8:	100f883a 	mov	r7,r2
811125dc:	01800a44 	movi	r6,41
811125e0:	01400044 	movi	r5,1
811125e4:	01204534 	movhi	r4,33044
811125e8:	2110e204 	addi	r4,r4,17288
811125ec:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
811125f0:	d0a05517 	ldw	r2,-32428(gp)
811125f4:	100f883a 	mov	r7,r2
811125f8:	01801104 	movi	r6,68
811125fc:	01400044 	movi	r5,1
81112600:	01204534 	movhi	r4,33044
81112604:	2110ed04 	addi	r4,r4,17332
81112608:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111260c:	0001883a 	nop
81112610:	e037883a 	mov	sp,fp
81112614:	dfc00117 	ldw	ra,4(sp)
81112618:	df000017 	ldw	fp,0(sp)
8111261c:	dec00204 	addi	sp,sp,8
81112620:	f800283a 	ret

81112624 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
81112624:	defffe04 	addi	sp,sp,-8
81112628:	de00012e 	bgeu	sp,et,81112630 <vFailGetMutexSenderTask+0xc>
8111262c:	003b68fa 	trap	3
81112630:	dfc00115 	stw	ra,4(sp)
81112634:	df000015 	stw	fp,0(sp)
81112638:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111263c:	d0a05517 	ldw	r2,-32428(gp)
81112640:	100f883a 	mov	r7,r2
81112644:	01800804 	movi	r6,32
81112648:	01400044 	movi	r5,1
8111264c:	01204534 	movhi	r4,33044
81112650:	2110ff04 	addi	r4,r4,17404
81112654:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
81112658:	d0a05517 	ldw	r2,-32428(gp)
8111265c:	100f883a 	mov	r7,r2
81112660:	01801084 	movi	r6,66
81112664:	01400044 	movi	r5,1
81112668:	01204534 	movhi	r4,33044
8111266c:	21110804 	addi	r4,r4,17440
81112670:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112674:	0001883a 	nop
81112678:	e037883a 	mov	sp,fp
8111267c:	dfc00117 	ldw	ra,4(sp)
81112680:	df000017 	ldw	fp,0(sp)
81112684:	dec00204 	addi	sp,sp,8
81112688:	f800283a 	ret

8111268c <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8111268c:	defffe04 	addi	sp,sp,-8
81112690:	de00012e 	bgeu	sp,et,81112698 <vFailGetCountSemaphoreReceiverTask+0xc>
81112694:	003b68fa 	trap	3
81112698:	dfc00115 	stw	ra,4(sp)
8111269c:	df000015 	stw	fp,0(sp)
811126a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
811126a4:	d0a05517 	ldw	r2,-32428(gp)
811126a8:	100f883a 	mov	r7,r2
811126ac:	01800ac4 	movi	r6,43
811126b0:	01400044 	movi	r5,1
811126b4:	01204534 	movhi	r4,33044
811126b8:	21111904 	addi	r4,r4,17508
811126bc:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
811126c0:	d0a05517 	ldw	r2,-32428(gp)
811126c4:	100f883a 	mov	r7,r2
811126c8:	01801184 	movi	r6,70
811126cc:	01400044 	movi	r5,1
811126d0:	01204534 	movhi	r4,33044
811126d4:	21112404 	addi	r4,r4,17552
811126d8:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811126dc:	0001883a 	nop
811126e0:	e037883a 	mov	sp,fp
811126e4:	dfc00117 	ldw	ra,4(sp)
811126e8:	df000017 	ldw	fp,0(sp)
811126ec:	dec00204 	addi	sp,sp,8
811126f0:	f800283a 	ret

811126f4 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
811126f4:	defffe04 	addi	sp,sp,-8
811126f8:	de00012e 	bgeu	sp,et,81112700 <vFailGetMutexReceiverTask+0xc>
811126fc:	003b68fa 	trap	3
81112700:	dfc00115 	stw	ra,4(sp)
81112704:	df000015 	stw	fp,0(sp)
81112708:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111270c:	d0a05517 	ldw	r2,-32428(gp)
81112710:	100f883a 	mov	r7,r2
81112714:	01800884 	movi	r6,34
81112718:	01400044 	movi	r5,1
8111271c:	01204534 	movhi	r4,33044
81112720:	21113604 	addi	r4,r4,17624
81112724:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
81112728:	d0a05517 	ldw	r2,-32428(gp)
8111272c:	100f883a 	mov	r7,r2
81112730:	01801104 	movi	r6,68
81112734:	01400044 	movi	r5,1
81112738:	01204534 	movhi	r4,33044
8111273c:	21113f04 	addi	r4,r4,17660
81112740:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112744:	0001883a 	nop
81112748:	e037883a 	mov	sp,fp
8111274c:	dfc00117 	ldw	ra,4(sp)
81112750:	df000017 	ldw	fp,0(sp)
81112754:	dec00204 	addi	sp,sp,8
81112758:	f800283a 	ret

8111275c <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111275c:	defffe04 	addi	sp,sp,-8
81112760:	de00012e 	bgeu	sp,et,81112768 <vFailGetMutexTxUARTSenderTask+0xc>
81112764:	003b68fa 	trap	3
81112768:	dfc00115 	stw	ra,4(sp)
8111276c:	df000015 	stw	fp,0(sp)
81112770:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
81112774:	d0a05517 	ldw	r2,-32428(gp)
81112778:	100f883a 	mov	r7,r2
8111277c:	01800984 	movi	r6,38
81112780:	01400044 	movi	r5,1
81112784:	01204534 	movhi	r4,33044
81112788:	21115104 	addi	r4,r4,17732
8111278c:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
81112790:	d0a05517 	ldw	r2,-32428(gp)
81112794:	100f883a 	mov	r7,r2
81112798:	01801044 	movi	r6,65
8111279c:	01400044 	movi	r5,1
811127a0:	01204534 	movhi	r4,33044
811127a4:	21115b04 	addi	r4,r4,17772
811127a8:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811127ac:	0001883a 	nop
811127b0:	e037883a 	mov	sp,fp
811127b4:	dfc00117 	ldw	ra,4(sp)
811127b8:	df000017 	ldw	fp,0(sp)
811127bc:	dec00204 	addi	sp,sp,8
811127c0:	f800283a 	ret

811127c4 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
811127c4:	defffe04 	addi	sp,sp,-8
811127c8:	de00012e 	bgeu	sp,et,811127d0 <vFailGetMacRTC+0xc>
811127cc:	003b68fa 	trap	3
811127d0:	dfc00115 	stw	ra,4(sp)
811127d4:	df000015 	stw	fp,0(sp)
811127d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
811127dc:	d0a05517 	ldw	r2,-32428(gp)
811127e0:	100f883a 	mov	r7,r2
811127e4:	018003c4 	movi	r6,15
811127e8:	01400044 	movi	r5,1
811127ec:	01204534 	movhi	r4,33044
811127f0:	21116c04 	addi	r4,r4,17840
811127f4:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811127f8:	0001883a 	nop
811127fc:	e037883a 	mov	sp,fp
81112800:	dfc00117 	ldw	ra,4(sp)
81112804:	df000017 	ldw	fp,0(sp)
81112808:	dec00204 	addi	sp,sp,8
8111280c:	f800283a 	ret

81112810 <vFailInitialization>:


void vFailInitialization( void )
{
81112810:	defffe04 	addi	sp,sp,-8
81112814:	de00012e 	bgeu	sp,et,8111281c <vFailInitialization+0xc>
81112818:	003b68fa 	trap	3
8111281c:	dfc00115 	stw	ra,4(sp)
81112820:	df000015 	stw	fp,0(sp)
81112824:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
81112828:	d0a05517 	ldw	r2,-32428(gp)
8111282c:	100f883a 	mov	r7,r2
81112830:	01800504 	movi	r6,20
81112834:	01400044 	movi	r5,1
81112838:	01204534 	movhi	r4,33044
8111283c:	21117004 	addi	r4,r4,17856
81112840:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112844:	0001883a 	nop
81112848:	e037883a 	mov	sp,fp
8111284c:	dfc00117 	ldw	ra,4(sp)
81112850:	df000017 	ldw	fp,0(sp)
81112854:	dec00204 	addi	sp,sp,8
81112858:	f800283a 	ret

8111285c <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111285c:	defffe04 	addi	sp,sp,-8
81112860:	de00012e 	bgeu	sp,et,81112868 <vFailReceiverCreate+0xc>
81112864:	003b68fa 	trap	3
81112868:	dfc00115 	stw	ra,4(sp)
8111286c:	df000015 	stw	fp,0(sp)
81112870:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
81112874:	d0a05517 	ldw	r2,-32428(gp)
81112878:	100f883a 	mov	r7,r2
8111287c:	01800484 	movi	r6,18
81112880:	01400044 	movi	r5,1
81112884:	01204534 	movhi	r4,33044
81112888:	21117604 	addi	r4,r4,17880
8111288c:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112890:	0001883a 	nop
81112894:	e037883a 	mov	sp,fp
81112898:	dfc00117 	ldw	ra,4(sp)
8111289c:	df000017 	ldw	fp,0(sp)
811128a0:	dec00204 	addi	sp,sp,8
811128a4:	f800283a 	ret

811128a8 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
811128a8:	defffe04 	addi	sp,sp,-8
811128ac:	de00012e 	bgeu	sp,et,811128b4 <vFailSenderCreate+0xc>
811128b0:	003b68fa 	trap	3
811128b4:	dfc00115 	stw	ra,4(sp)
811128b8:	df000015 	stw	fp,0(sp)
811128bc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
811128c0:	d0a05517 	ldw	r2,-32428(gp)
811128c4:	100f883a 	mov	r7,r2
811128c8:	01800484 	movi	r6,18
811128cc:	01400044 	movi	r5,1
811128d0:	01204534 	movhi	r4,33044
811128d4:	21117b04 	addi	r4,r4,17900
811128d8:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811128dc:	0001883a 	nop
811128e0:	e037883a 	mov	sp,fp
811128e4:	dfc00117 	ldw	ra,4(sp)
811128e8:	df000017 	ldw	fp,0(sp)
811128ec:	dec00204 	addi	sp,sp,8
811128f0:	f800283a 	ret

811128f4 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
811128f4:	defffe04 	addi	sp,sp,-8
811128f8:	de00012e 	bgeu	sp,et,81112900 <vFailDeleteInitialization+0xc>
811128fc:	003b68fa 	trap	3
81112900:	dfc00115 	stw	ra,4(sp)
81112904:	df000015 	stw	fp,0(sp)
81112908:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
8111290c:	d0a05517 	ldw	r2,-32428(gp)
81112910:	100f883a 	mov	r7,r2
81112914:	01800684 	movi	r6,26
81112918:	01400044 	movi	r5,1
8111291c:	01204534 	movhi	r4,33044
81112920:	21118004 	addi	r4,r4,17920
81112924:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112928:	0001883a 	nop
8111292c:	e037883a 	mov	sp,fp
81112930:	dfc00117 	ldw	ra,4(sp)
81112934:	df000017 	ldw	fp,0(sp)
81112938:	dec00204 	addi	sp,sp,8
8111293c:	f800283a 	ret

81112940 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
81112940:	defffe04 	addi	sp,sp,-8
81112944:	de00012e 	bgeu	sp,et,8111294c <vFailSetCountSemaphorexBuffer32+0xc>
81112948:	003b68fa 	trap	3
8111294c:	dfc00115 	stw	ra,4(sp)
81112950:	df000015 	stw	fp,0(sp)
81112954:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
81112958:	d0a05517 	ldw	r2,-32428(gp)
8111295c:	100f883a 	mov	r7,r2
81112960:	01800a04 	movi	r6,40
81112964:	01400044 	movi	r5,1
81112968:	01204534 	movhi	r4,33044
8111296c:	21118704 	addi	r4,r4,17948
81112970:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81112974:	d0a05517 	ldw	r2,-32428(gp)
81112978:	100f883a 	mov	r7,r2
8111297c:	018008c4 	movi	r6,35
81112980:	01400044 	movi	r5,1
81112984:	01204534 	movhi	r4,33044
81112988:	21119204 	addi	r4,r4,17992
8111298c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112990:	0001883a 	nop
81112994:	e037883a 	mov	sp,fp
81112998:	dfc00117 	ldw	ra,4(sp)
8111299c:	df000017 	ldw	fp,0(sp)
811129a0:	dec00204 	addi	sp,sp,8
811129a4:	f800283a 	ret

811129a8 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
811129a8:	defffe04 	addi	sp,sp,-8
811129ac:	de00012e 	bgeu	sp,et,811129b4 <vFailSetCountSemaphorexBuffer64+0xc>
811129b0:	003b68fa 	trap	3
811129b4:	dfc00115 	stw	ra,4(sp)
811129b8:	df000015 	stw	fp,0(sp)
811129bc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
811129c0:	d0a05517 	ldw	r2,-32428(gp)
811129c4:	100f883a 	mov	r7,r2
811129c8:	01800a04 	movi	r6,40
811129cc:	01400044 	movi	r5,1
811129d0:	01204534 	movhi	r4,33044
811129d4:	21119b04 	addi	r4,r4,18028
811129d8:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
811129dc:	d0a05517 	ldw	r2,-32428(gp)
811129e0:	100f883a 	mov	r7,r2
811129e4:	018008c4 	movi	r6,35
811129e8:	01400044 	movi	r5,1
811129ec:	01204534 	movhi	r4,33044
811129f0:	21119204 	addi	r4,r4,17992
811129f4:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811129f8:	0001883a 	nop
811129fc:	e037883a 	mov	sp,fp
81112a00:	dfc00117 	ldw	ra,4(sp)
81112a04:	df000017 	ldw	fp,0(sp)
81112a08:	dec00204 	addi	sp,sp,8
81112a0c:	f800283a 	ret

81112a10 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
81112a10:	defffe04 	addi	sp,sp,-8
81112a14:	de00012e 	bgeu	sp,et,81112a1c <vFailSetCountSemaphorexBuffer128+0xc>
81112a18:	003b68fa 	trap	3
81112a1c:	dfc00115 	stw	ra,4(sp)
81112a20:	df000015 	stw	fp,0(sp)
81112a24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
81112a28:	d0a05517 	ldw	r2,-32428(gp)
81112a2c:	100f883a 	mov	r7,r2
81112a30:	01800a44 	movi	r6,41
81112a34:	01400044 	movi	r5,1
81112a38:	01204534 	movhi	r4,33044
81112a3c:	2111a604 	addi	r4,r4,18072
81112a40:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81112a44:	d0a05517 	ldw	r2,-32428(gp)
81112a48:	100f883a 	mov	r7,r2
81112a4c:	018008c4 	movi	r6,35
81112a50:	01400044 	movi	r5,1
81112a54:	01204534 	movhi	r4,33044
81112a58:	21119204 	addi	r4,r4,17992
81112a5c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112a60:	0001883a 	nop
81112a64:	e037883a 	mov	sp,fp
81112a68:	dfc00117 	ldw	ra,4(sp)
81112a6c:	df000017 	ldw	fp,0(sp)
81112a70:	dec00204 	addi	sp,sp,8
81112a74:	f800283a 	ret

81112a78 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
81112a78:	defffe04 	addi	sp,sp,-8
81112a7c:	de00012e 	bgeu	sp,et,81112a84 <vFailGetCountSemaphorexBuffer128+0xc>
81112a80:	003b68fa 	trap	3
81112a84:	dfc00115 	stw	ra,4(sp)
81112a88:	df000015 	stw	fp,0(sp)
81112a8c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
81112a90:	d0a05517 	ldw	r2,-32428(gp)
81112a94:	100f883a 	mov	r7,r2
81112a98:	01800a44 	movi	r6,41
81112a9c:	01400044 	movi	r5,1
81112aa0:	01204534 	movhi	r4,33044
81112aa4:	2111b104 	addi	r4,r4,18116
81112aa8:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81112aac:	d0a05517 	ldw	r2,-32428(gp)
81112ab0:	100f883a 	mov	r7,r2
81112ab4:	01800884 	movi	r6,34
81112ab8:	01400044 	movi	r5,1
81112abc:	01204534 	movhi	r4,33044
81112ac0:	2111bc04 	addi	r4,r4,18160
81112ac4:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112ac8:	0001883a 	nop
81112acc:	e037883a 	mov	sp,fp
81112ad0:	dfc00117 	ldw	ra,4(sp)
81112ad4:	df000017 	ldw	fp,0(sp)
81112ad8:	dec00204 	addi	sp,sp,8
81112adc:	f800283a 	ret

81112ae0 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
81112ae0:	defffe04 	addi	sp,sp,-8
81112ae4:	de00012e 	bgeu	sp,et,81112aec <vFailGetCountSemaphorexBuffer64+0xc>
81112ae8:	003b68fa 	trap	3
81112aec:	dfc00115 	stw	ra,4(sp)
81112af0:	df000015 	stw	fp,0(sp)
81112af4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
81112af8:	d0a05517 	ldw	r2,-32428(gp)
81112afc:	100f883a 	mov	r7,r2
81112b00:	01800a04 	movi	r6,40
81112b04:	01400044 	movi	r5,1
81112b08:	01204534 	movhi	r4,33044
81112b0c:	2111c504 	addi	r4,r4,18196
81112b10:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81112b14:	d0a05517 	ldw	r2,-32428(gp)
81112b18:	100f883a 	mov	r7,r2
81112b1c:	01800884 	movi	r6,34
81112b20:	01400044 	movi	r5,1
81112b24:	01204534 	movhi	r4,33044
81112b28:	2111bc04 	addi	r4,r4,18160
81112b2c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112b30:	0001883a 	nop
81112b34:	e037883a 	mov	sp,fp
81112b38:	dfc00117 	ldw	ra,4(sp)
81112b3c:	df000017 	ldw	fp,0(sp)
81112b40:	dec00204 	addi	sp,sp,8
81112b44:	f800283a 	ret

81112b48 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
81112b48:	defffe04 	addi	sp,sp,-8
81112b4c:	de00012e 	bgeu	sp,et,81112b54 <vFailGetCountSemaphorexBuffer32+0xc>
81112b50:	003b68fa 	trap	3
81112b54:	dfc00115 	stw	ra,4(sp)
81112b58:	df000015 	stw	fp,0(sp)
81112b5c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
81112b60:	d0a05517 	ldw	r2,-32428(gp)
81112b64:	100f883a 	mov	r7,r2
81112b68:	01800a04 	movi	r6,40
81112b6c:	01400044 	movi	r5,1
81112b70:	01204534 	movhi	r4,33044
81112b74:	2111d004 	addi	r4,r4,18240
81112b78:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81112b7c:	d0a05517 	ldw	r2,-32428(gp)
81112b80:	100f883a 	mov	r7,r2
81112b84:	01800884 	movi	r6,34
81112b88:	01400044 	movi	r5,1
81112b8c:	01204534 	movhi	r4,33044
81112b90:	2111bc04 	addi	r4,r4,18160
81112b94:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112b98:	0001883a 	nop
81112b9c:	e037883a 	mov	sp,fp
81112ba0:	dfc00117 	ldw	ra,4(sp)
81112ba4:	df000017 	ldw	fp,0(sp)
81112ba8:	dec00204 	addi	sp,sp,8
81112bac:	f800283a 	ret

81112bb0 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
81112bb0:	defffe04 	addi	sp,sp,-8
81112bb4:	de00012e 	bgeu	sp,et,81112bbc <vFailFoundBufferRetransmission+0xc>
81112bb8:	003b68fa 	trap	3
81112bbc:	dfc00115 	stw	ra,4(sp)
81112bc0:	df000015 	stw	fp,0(sp)
81112bc4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
81112bc8:	d0a05517 	ldw	r2,-32428(gp)
81112bcc:	100f883a 	mov	r7,r2
81112bd0:	01800a84 	movi	r6,42
81112bd4:	01400044 	movi	r5,1
81112bd8:	01204534 	movhi	r4,33044
81112bdc:	2111db04 	addi	r4,r4,18284
81112be0:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
81112be4:	d0a05517 	ldw	r2,-32428(gp)
81112be8:	100f883a 	mov	r7,r2
81112bec:	01801204 	movi	r6,72
81112bf0:	01400044 	movi	r5,1
81112bf4:	01204534 	movhi	r4,33044
81112bf8:	2111e604 	addi	r4,r4,18328
81112bfc:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112c00:	0001883a 	nop
81112c04:	e037883a 	mov	sp,fp
81112c08:	dfc00117 	ldw	ra,4(sp)
81112c0c:	df000017 	ldw	fp,0(sp)
81112c10:	dec00204 	addi	sp,sp,8
81112c14:	f800283a 	ret

81112c18 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
81112c18:	defffe04 	addi	sp,sp,-8
81112c1c:	de00012e 	bgeu	sp,et,81112c24 <vFailGetCountSemaphorePreParsedBuffer+0xc>
81112c20:	003b68fa 	trap	3
81112c24:	dfc00115 	stw	ra,4(sp)
81112c28:	df000015 	stw	fp,0(sp)
81112c2c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
81112c30:	d0a05517 	ldw	r2,-32428(gp)
81112c34:	100f883a 	mov	r7,r2
81112c38:	01800b84 	movi	r6,46
81112c3c:	01400044 	movi	r5,1
81112c40:	01204534 	movhi	r4,33044
81112c44:	2111f904 	addi	r4,r4,18404
81112c48:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
81112c4c:	d0a05517 	ldw	r2,-32428(gp)
81112c50:	100f883a 	mov	r7,r2
81112c54:	018010c4 	movi	r6,67
81112c58:	01400044 	movi	r5,1
81112c5c:	01204534 	movhi	r4,33044
81112c60:	21120504 	addi	r4,r4,18452
81112c64:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112c68:	0001883a 	nop
81112c6c:	e037883a 	mov	sp,fp
81112c70:	dfc00117 	ldw	ra,4(sp)
81112c74:	df000017 	ldw	fp,0(sp)
81112c78:	dec00204 	addi	sp,sp,8
81112c7c:	f800283a 	ret

81112c80 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
81112c80:	defffe04 	addi	sp,sp,-8
81112c84:	de00012e 	bgeu	sp,et,81112c8c <vFailGetxMutexPreParsedParserRxTask+0xc>
81112c88:	003b68fa 	trap	3
81112c8c:	dfc00115 	stw	ra,4(sp)
81112c90:	df000015 	stw	fp,0(sp)
81112c94:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
81112c98:	d0a05517 	ldw	r2,-32428(gp)
81112c9c:	100f883a 	mov	r7,r2
81112ca0:	01800b04 	movi	r6,44
81112ca4:	01400044 	movi	r5,1
81112ca8:	01204534 	movhi	r4,33044
81112cac:	21121604 	addi	r4,r4,18520
81112cb0:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
81112cb4:	d0a05517 	ldw	r2,-32428(gp)
81112cb8:	100f883a 	mov	r7,r2
81112cbc:	01800fc4 	movi	r6,63
81112cc0:	01400044 	movi	r5,1
81112cc4:	01204534 	movhi	r4,33044
81112cc8:	21122204 	addi	r4,r4,18568
81112ccc:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112cd0:	0001883a 	nop
81112cd4:	e037883a 	mov	sp,fp
81112cd8:	dfc00117 	ldw	ra,4(sp)
81112cdc:	df000017 	ldw	fp,0(sp)
81112ce0:	dec00204 	addi	sp,sp,8
81112ce4:	f800283a 	ret

81112ce8 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
81112ce8:	defffe04 	addi	sp,sp,-8
81112cec:	de00012e 	bgeu	sp,et,81112cf4 <vNoContentInPreParsedBuffer+0xc>
81112cf0:	003b68fa 	trap	3
81112cf4:	dfc00115 	stw	ra,4(sp)
81112cf8:	df000015 	stw	fp,0(sp)
81112cfc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
81112d00:	d0a05517 	ldw	r2,-32428(gp)
81112d04:	100f883a 	mov	r7,r2
81112d08:	01800904 	movi	r6,36
81112d0c:	01400044 	movi	r5,1
81112d10:	01204534 	movhi	r4,33044
81112d14:	21123204 	addi	r4,r4,18632
81112d18:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
81112d1c:	d0a05517 	ldw	r2,-32428(gp)
81112d20:	100f883a 	mov	r7,r2
81112d24:	01801684 	movi	r6,90
81112d28:	01400044 	movi	r5,1
81112d2c:	01204534 	movhi	r4,33044
81112d30:	21123c04 	addi	r4,r4,18672
81112d34:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112d38:	0001883a 	nop
81112d3c:	e037883a 	mov	sp,fp
81112d40:	dfc00117 	ldw	ra,4(sp)
81112d44:	df000017 	ldw	fp,0(sp)
81112d48:	dec00204 	addi	sp,sp,8
81112d4c:	f800283a 	ret

81112d50 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
81112d50:	defffe04 	addi	sp,sp,-8
81112d54:	de00012e 	bgeu	sp,et,81112d5c <vCouldNotSendEthConfUART+0xc>
81112d58:	003b68fa 	trap	3
81112d5c:	dfc00115 	stw	ra,4(sp)
81112d60:	df000015 	stw	fp,0(sp)
81112d64:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
81112d68:	d0a05517 	ldw	r2,-32428(gp)
81112d6c:	100f883a 	mov	r7,r2
81112d70:	01800844 	movi	r6,33
81112d74:	01400044 	movi	r5,1
81112d78:	01204534 	movhi	r4,33044
81112d7c:	21125304 	addi	r4,r4,18764
81112d80:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
81112d84:	d0a05517 	ldw	r2,-32428(gp)
81112d88:	100f883a 	mov	r7,r2
81112d8c:	01801784 	movi	r6,94
81112d90:	01400044 	movi	r5,1
81112d94:	01204534 	movhi	r4,33044
81112d98:	21125c04 	addi	r4,r4,18800
81112d9c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112da0:	0001883a 	nop
81112da4:	e037883a 	mov	sp,fp
81112da8:	dfc00117 	ldw	ra,4(sp)
81112dac:	df000017 	ldw	fp,0(sp)
81112db0:	dec00204 	addi	sp,sp,8
81112db4:	f800283a 	ret

81112db8 <vFailSendNack>:

void vFailSendNack( void )
{
81112db8:	defffe04 	addi	sp,sp,-8
81112dbc:	de00012e 	bgeu	sp,et,81112dc4 <vFailSendNack+0xc>
81112dc0:	003b68fa 	trap	3
81112dc4:	dfc00115 	stw	ra,4(sp)
81112dc8:	df000015 	stw	fp,0(sp)
81112dcc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
81112dd0:	d0a05517 	ldw	r2,-32428(gp)
81112dd4:	100f883a 	mov	r7,r2
81112dd8:	01800584 	movi	r6,22
81112ddc:	01400044 	movi	r5,1
81112de0:	01204534 	movhi	r4,33044
81112de4:	21127404 	addi	r4,r4,18896
81112de8:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
81112dec:	d0a05517 	ldw	r2,-32428(gp)
81112df0:	100f883a 	mov	r7,r2
81112df4:	01800a84 	movi	r6,42
81112df8:	01400044 	movi	r5,1
81112dfc:	01204534 	movhi	r4,33044
81112e00:	21127a04 	addi	r4,r4,18920
81112e04:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112e08:	0001883a 	nop
81112e0c:	e037883a 	mov	sp,fp
81112e10:	dfc00117 	ldw	ra,4(sp)
81112e14:	df000017 	ldw	fp,0(sp)
81112e18:	dec00204 	addi	sp,sp,8
81112e1c:	f800283a 	ret

81112e20 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
81112e20:	defffe04 	addi	sp,sp,-8
81112e24:	de00012e 	bgeu	sp,et,81112e2c <vFailSetPreAckSenderBuffer+0xc>
81112e28:	003b68fa 	trap	3
81112e2c:	dfc00115 	stw	ra,4(sp)
81112e30:	df000015 	stw	fp,0(sp)
81112e34:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
81112e38:	d0a05517 	ldw	r2,-32428(gp)
81112e3c:	100f883a 	mov	r7,r2
81112e40:	018008c4 	movi	r6,35
81112e44:	01400044 	movi	r5,1
81112e48:	01204534 	movhi	r4,33044
81112e4c:	21128504 	addi	r4,r4,18964
81112e50:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
81112e54:	d0a05517 	ldw	r2,-32428(gp)
81112e58:	100f883a 	mov	r7,r2
81112e5c:	01801584 	movi	r6,86
81112e60:	01400044 	movi	r5,1
81112e64:	01204534 	movhi	r4,33044
81112e68:	21128e04 	addi	r4,r4,19000
81112e6c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112e70:	0001883a 	nop
81112e74:	e037883a 	mov	sp,fp
81112e78:	dfc00117 	ldw	ra,4(sp)
81112e7c:	df000017 	ldw	fp,0(sp)
81112e80:	dec00204 	addi	sp,sp,8
81112e84:	f800283a 	ret

81112e88 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
81112e88:	defffe04 	addi	sp,sp,-8
81112e8c:	de00012e 	bgeu	sp,et,81112e94 <vFailSetPreParsedBuffer+0xc>
81112e90:	003b68fa 	trap	3
81112e94:	dfc00115 	stw	ra,4(sp)
81112e98:	df000015 	stw	fp,0(sp)
81112e9c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
81112ea0:	d0a05517 	ldw	r2,-32428(gp)
81112ea4:	100f883a 	mov	r7,r2
81112ea8:	01800804 	movi	r6,32
81112eac:	01400044 	movi	r5,1
81112eb0:	01204534 	movhi	r4,33044
81112eb4:	2112a404 	addi	r4,r4,19088
81112eb8:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
81112ebc:	d0a05517 	ldw	r2,-32428(gp)
81112ec0:	100f883a 	mov	r7,r2
81112ec4:	018013c4 	movi	r6,79
81112ec8:	01400044 	movi	r5,1
81112ecc:	01204534 	movhi	r4,33044
81112ed0:	2112ad04 	addi	r4,r4,19124
81112ed4:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112ed8:	0001883a 	nop
81112edc:	e037883a 	mov	sp,fp
81112ee0:	dfc00117 	ldw	ra,4(sp)
81112ee4:	df000017 	ldw	fp,0(sp)
81112ee8:	dec00204 	addi	sp,sp,8
81112eec:	f800283a 	ret

81112ef0 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
81112ef0:	defffe04 	addi	sp,sp,-8
81112ef4:	de00012e 	bgeu	sp,et,81112efc <vFailSetPreAckReceiverBuffer+0xc>
81112ef8:	003b68fa 	trap	3
81112efc:	dfc00115 	stw	ra,4(sp)
81112f00:	df000015 	stw	fp,0(sp)
81112f04:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
81112f08:	d0a05517 	ldw	r2,-32428(gp)
81112f0c:	100f883a 	mov	r7,r2
81112f10:	01800944 	movi	r6,37
81112f14:	01400044 	movi	r5,1
81112f18:	01204534 	movhi	r4,33044
81112f1c:	2112c104 	addi	r4,r4,19204
81112f20:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
81112f24:	d0a05517 	ldw	r2,-32428(gp)
81112f28:	100f883a 	mov	r7,r2
81112f2c:	018015c4 	movi	r6,87
81112f30:	01400044 	movi	r5,1
81112f34:	01204534 	movhi	r4,33044
81112f38:	2112cb04 	addi	r4,r4,19244
81112f3c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112f40:	0001883a 	nop
81112f44:	e037883a 	mov	sp,fp
81112f48:	dfc00117 	ldw	ra,4(sp)
81112f4c:	df000017 	ldw	fp,0(sp)
81112f50:	dec00204 	addi	sp,sp,8
81112f54:	f800283a 	ret

81112f58 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
81112f58:	defffe04 	addi	sp,sp,-8
81112f5c:	de00012e 	bgeu	sp,et,81112f64 <vFailParserCommTaskCreate+0xc>
81112f60:	003b68fa 	trap	3
81112f64:	dfc00115 	stw	ra,4(sp)
81112f68:	df000015 	stw	fp,0(sp)
81112f6c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
81112f70:	d0a05517 	ldw	r2,-32428(gp)
81112f74:	100f883a 	mov	r7,r2
81112f78:	01800684 	movi	r6,26
81112f7c:	01400044 	movi	r5,1
81112f80:	01204534 	movhi	r4,33044
81112f84:	2112e104 	addi	r4,r4,19332
81112f88:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112f8c:	0001883a 	nop
81112f90:	e037883a 	mov	sp,fp
81112f94:	dfc00117 	ldw	ra,4(sp)
81112f98:	df000017 	ldw	fp,0(sp)
81112f9c:	dec00204 	addi	sp,sp,8
81112fa0:	f800283a 	ret

81112fa4 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
81112fa4:	defffe04 	addi	sp,sp,-8
81112fa8:	de00012e 	bgeu	sp,et,81112fb0 <vFailInAckHandlerTaskCreate+0xc>
81112fac:	003b68fa 	trap	3
81112fb0:	dfc00115 	stw	ra,4(sp)
81112fb4:	df000015 	stw	fp,0(sp)
81112fb8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81112fbc:	d0a05517 	ldw	r2,-32428(gp)
81112fc0:	100f883a 	mov	r7,r2
81112fc4:	01800704 	movi	r6,28
81112fc8:	01400044 	movi	r5,1
81112fcc:	01204534 	movhi	r4,33044
81112fd0:	2112e804 	addi	r4,r4,19360
81112fd4:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81112fd8:	0001883a 	nop
81112fdc:	e037883a 	mov	sp,fp
81112fe0:	dfc00117 	ldw	ra,4(sp)
81112fe4:	df000017 	ldw	fp,0(sp)
81112fe8:	dec00204 	addi	sp,sp,8
81112fec:	f800283a 	ret

81112ff0 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
81112ff0:	defffe04 	addi	sp,sp,-8
81112ff4:	de00012e 	bgeu	sp,et,81112ffc <vFailOutAckHandlerTaskCreate+0xc>
81112ff8:	003b68fa 	trap	3
81112ffc:	dfc00115 	stw	ra,4(sp)
81113000:	df000015 	stw	fp,0(sp)
81113004:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81113008:	d0a05517 	ldw	r2,-32428(gp)
8111300c:	100f883a 	mov	r7,r2
81113010:	01800704 	movi	r6,28
81113014:	01400044 	movi	r5,1
81113018:	01204534 	movhi	r4,33044
8111301c:	2112e804 	addi	r4,r4,19360
81113020:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113024:	0001883a 	nop
81113028:	e037883a 	mov	sp,fp
8111302c:	dfc00117 	ldw	ra,4(sp)
81113030:	df000017 	ldw	fp,0(sp)
81113034:	dec00204 	addi	sp,sp,8
81113038:	f800283a 	ret

8111303c <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111303c:	defffe04 	addi	sp,sp,-8
81113040:	de00012e 	bgeu	sp,et,81113048 <vFailCreateTimerRetransmisison+0xc>
81113044:	003b68fa 	trap	3
81113048:	dfc00115 	stw	ra,4(sp)
8111304c:	df000015 	stw	fp,0(sp)
81113050:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
81113054:	d0a05517 	ldw	r2,-32428(gp)
81113058:	100f883a 	mov	r7,r2
8111305c:	018007c4 	movi	r6,31
81113060:	01400044 	movi	r5,1
81113064:	01204534 	movhi	r4,33044
81113068:	2112f004 	addi	r4,r4,19392
8111306c:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113070:	0001883a 	nop
81113074:	e037883a 	mov	sp,fp
81113078:	dfc00117 	ldw	ra,4(sp)
8111307c:	df000017 	ldw	fp,0(sp)
81113080:	dec00204 	addi	sp,sp,8
81113084:	f800283a 	ret

81113088 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
81113088:	defffe04 	addi	sp,sp,-8
8111308c:	de00012e 	bgeu	sp,et,81113094 <vCouldNotCheckBufferTimeOutFunction+0xc>
81113090:	003b68fa 	trap	3
81113094:	dfc00115 	stw	ra,4(sp)
81113098:	df000015 	stw	fp,0(sp)
8111309c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
811130a0:	d0a05517 	ldw	r2,-32428(gp)
811130a4:	100f883a 	mov	r7,r2
811130a8:	01800904 	movi	r6,36
811130ac:	01400044 	movi	r5,1
811130b0:	01204534 	movhi	r4,33044
811130b4:	2112f804 	addi	r4,r4,19424
811130b8:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811130bc:	0001883a 	nop
811130c0:	e037883a 	mov	sp,fp
811130c4:	dfc00117 	ldw	ra,4(sp)
811130c8:	df000017 	ldw	fp,0(sp)
811130cc:	dec00204 	addi	sp,sp,8
811130d0:	f800283a 	ret

811130d4 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
811130d4:	defffe04 	addi	sp,sp,-8
811130d8:	de00012e 	bgeu	sp,et,811130e0 <vFailTimeoutCheckerTaskCreate+0xc>
811130dc:	003b68fa 	trap	3
811130e0:	dfc00115 	stw	ra,4(sp)
811130e4:	df000015 	stw	fp,0(sp)
811130e8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
811130ec:	d0a05517 	ldw	r2,-32428(gp)
811130f0:	100f883a 	mov	r7,r2
811130f4:	01800a04 	movi	r6,40
811130f8:	01400044 	movi	r5,1
811130fc:	01204534 	movhi	r4,33044
81113100:	21130204 	addi	r4,r4,19464
81113104:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113108:	0001883a 	nop
8111310c:	e037883a 	mov	sp,fp
81113110:	dfc00117 	ldw	ra,4(sp)
81113114:	df000017 	ldw	fp,0(sp)
81113118:	dec00204 	addi	sp,sp,8
8111311c:	f800283a 	ret

81113120 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
81113120:	defffe04 	addi	sp,sp,-8
81113124:	de00012e 	bgeu	sp,et,8111312c <vFailGetBlockingSemTimeoutTask+0xc>
81113128:	003b68fa 	trap	3
8111312c:	dfc00115 	stw	ra,4(sp)
81113130:	df000015 	stw	fp,0(sp)
81113134:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
81113138:	d0a05517 	ldw	r2,-32428(gp)
8111313c:	100f883a 	mov	r7,r2
81113140:	018009c4 	movi	r6,39
81113144:	01400044 	movi	r5,1
81113148:	01204534 	movhi	r4,33044
8111314c:	21130d04 	addi	r4,r4,19508
81113150:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
81113154:	d0a05517 	ldw	r2,-32428(gp)
81113158:	100f883a 	mov	r7,r2
8111315c:	01800cc4 	movi	r6,51
81113160:	01400044 	movi	r5,1
81113164:	01204534 	movhi	r4,33044
81113168:	21131704 	addi	r4,r4,19548
8111316c:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113170:	0001883a 	nop
81113174:	e037883a 	mov	sp,fp
81113178:	dfc00117 	ldw	ra,4(sp)
8111317c:	df000017 	ldw	fp,0(sp)
81113180:	dec00204 	addi	sp,sp,8
81113184:	f800283a 	ret

81113188 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
81113188:	defffe04 	addi	sp,sp,-8
8111318c:	de00012e 	bgeu	sp,et,81113194 <vFailPostBlockingSemTimeoutTask+0xc>
81113190:	003b68fa 	trap	3
81113194:	dfc00115 	stw	ra,4(sp)
81113198:	df000015 	stw	fp,0(sp)
8111319c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
811131a0:	d0a05517 	ldw	r2,-32428(gp)
811131a4:	100f883a 	mov	r7,r2
811131a8:	01800a04 	movi	r6,40
811131ac:	01400044 	movi	r5,1
811131b0:	01204534 	movhi	r4,33044
811131b4:	21132404 	addi	r4,r4,19600
811131b8:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
811131bc:	d0a05517 	ldw	r2,-32428(gp)
811131c0:	100f883a 	mov	r7,r2
811131c4:	01800c84 	movi	r6,50
811131c8:	01400044 	movi	r5,1
811131cc:	01204534 	movhi	r4,33044
811131d0:	21132f04 	addi	r4,r4,19644
811131d4:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811131d8:	0001883a 	nop
811131dc:	e037883a 	mov	sp,fp
811131e0:	dfc00117 	ldw	ra,4(sp)
811131e4:	df000017 	ldw	fp,0(sp)
811131e8:	dec00204 	addi	sp,sp,8
811131ec:	f800283a 	ret

811131f0 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
811131f0:	defffe04 	addi	sp,sp,-8
811131f4:	de00012e 	bgeu	sp,et,811131fc <vFailCouldNotRetransmitTimeoutTask+0xc>
811131f8:	003b68fa 	trap	3
811131fc:	dfc00115 	stw	ra,4(sp)
81113200:	df000015 	stw	fp,0(sp)
81113204:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
81113208:	d0a05517 	ldw	r2,-32428(gp)
8111320c:	100f883a 	mov	r7,r2
81113210:	01800ac4 	movi	r6,43
81113214:	01400044 	movi	r5,1
81113218:	01204534 	movhi	r4,33044
8111321c:	21133c04 	addi	r4,r4,19696
81113220:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
81113224:	d0a05517 	ldw	r2,-32428(gp)
81113228:	100f883a 	mov	r7,r2
8111322c:	01801644 	movi	r6,89
81113230:	01400044 	movi	r5,1
81113234:	01204534 	movhi	r4,33044
81113238:	21134704 	addi	r4,r4,19740
8111323c:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113240:	0001883a 	nop
81113244:	e037883a 	mov	sp,fp
81113248:	dfc00117 	ldw	ra,4(sp)
8111324c:	df000017 	ldw	fp,0(sp)
81113250:	dec00204 	addi	sp,sp,8
81113254:	f800283a 	ret

81113258 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
81113258:	defffe04 	addi	sp,sp,-8
8111325c:	de00012e 	bgeu	sp,et,81113264 <vCouldNotRetransmitB32TimeoutTask+0xc>
81113260:	003b68fa 	trap	3
81113264:	dfc00115 	stw	ra,4(sp)
81113268:	df000015 	stw	fp,0(sp)
8111326c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
81113270:	d0a05517 	ldw	r2,-32428(gp)
81113274:	100f883a 	mov	r7,r2
81113278:	01800a84 	movi	r6,42
8111327c:	01400044 	movi	r5,1
81113280:	01204534 	movhi	r4,33044
81113284:	21135e04 	addi	r4,r4,19832
81113288:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111328c:	d0a05517 	ldw	r2,-32428(gp)
81113290:	100f883a 	mov	r7,r2
81113294:	01801444 	movi	r6,81
81113298:	01400044 	movi	r5,1
8111329c:	01204534 	movhi	r4,33044
811132a0:	21136904 	addi	r4,r4,19876
811132a4:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811132a8:	0001883a 	nop
811132ac:	e037883a 	mov	sp,fp
811132b0:	dfc00117 	ldw	ra,4(sp)
811132b4:	df000017 	ldw	fp,0(sp)
811132b8:	dec00204 	addi	sp,sp,8
811132bc:	f800283a 	ret

811132c0 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
811132c0:	defffe04 	addi	sp,sp,-8
811132c4:	de00012e 	bgeu	sp,et,811132cc <vCouldNotRetransmitB64TimeoutTask+0xc>
811132c8:	003b68fa 	trap	3
811132cc:	dfc00115 	stw	ra,4(sp)
811132d0:	df000015 	stw	fp,0(sp)
811132d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
811132d8:	d0a05517 	ldw	r2,-32428(gp)
811132dc:	100f883a 	mov	r7,r2
811132e0:	01800a84 	movi	r6,42
811132e4:	01400044 	movi	r5,1
811132e8:	01204534 	movhi	r4,33044
811132ec:	21137e04 	addi	r4,r4,19960
811132f0:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
811132f4:	d0a05517 	ldw	r2,-32428(gp)
811132f8:	100f883a 	mov	r7,r2
811132fc:	01801444 	movi	r6,81
81113300:	01400044 	movi	r5,1
81113304:	01204534 	movhi	r4,33044
81113308:	21138904 	addi	r4,r4,20004
8111330c:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113310:	0001883a 	nop
81113314:	e037883a 	mov	sp,fp
81113318:	dfc00117 	ldw	ra,4(sp)
8111331c:	df000017 	ldw	fp,0(sp)
81113320:	dec00204 	addi	sp,sp,8
81113324:	f800283a 	ret

81113328 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
81113328:	defffe04 	addi	sp,sp,-8
8111332c:	de00012e 	bgeu	sp,et,81113334 <vCouldNotRetransmitB128TimeoutTask+0xc>
81113330:	003b68fa 	trap	3
81113334:	dfc00115 	stw	ra,4(sp)
81113338:	df000015 	stw	fp,0(sp)
8111333c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
81113340:	d0a05517 	ldw	r2,-32428(gp)
81113344:	100f883a 	mov	r7,r2
81113348:	01800ac4 	movi	r6,43
8111334c:	01400044 	movi	r5,1
81113350:	01204534 	movhi	r4,33044
81113354:	21139e04 	addi	r4,r4,20088
81113358:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111335c:	d0a05517 	ldw	r2,-32428(gp)
81113360:	100f883a 	mov	r7,r2
81113364:	01801484 	movi	r6,82
81113368:	01400044 	movi	r5,1
8111336c:	01204534 	movhi	r4,33044
81113370:	2113a904 	addi	r4,r4,20132
81113374:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113378:	0001883a 	nop
8111337c:	e037883a 	mov	sp,fp
81113380:	dfc00117 	ldw	ra,4(sp)
81113384:	df000017 	ldw	fp,0(sp)
81113388:	dec00204 	addi	sp,sp,8
8111338c:	f800283a 	ret

81113390 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
81113390:	defffe04 	addi	sp,sp,-8
81113394:	de00012e 	bgeu	sp,et,8111339c <vFailStartTimerRetransmission+0xc>
81113398:	003b68fa 	trap	3
8111339c:	dfc00115 	stw	ra,4(sp)
811133a0:	df000015 	stw	fp,0(sp)
811133a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
811133a8:	d0a05517 	ldw	r2,-32428(gp)
811133ac:	100f883a 	mov	r7,r2
811133b0:	01800984 	movi	r6,38
811133b4:	01400044 	movi	r5,1
811133b8:	01204534 	movhi	r4,33044
811133bc:	2113be04 	addi	r4,r4,20216
811133c0:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
811133c4:	d0a05517 	ldw	r2,-32428(gp)
811133c8:	100f883a 	mov	r7,r2
811133cc:	01800d44 	movi	r6,53
811133d0:	01400044 	movi	r5,1
811133d4:	01204534 	movhi	r4,33044
811133d8:	2113c804 	addi	r4,r4,20256
811133dc:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811133e0:	0001883a 	nop
811133e4:	e037883a 	mov	sp,fp
811133e8:	dfc00117 	ldw	ra,4(sp)
811133ec:	df000017 	ldw	fp,0(sp)
811133f0:	dec00204 	addi	sp,sp,8
811133f4:	f800283a 	ret

811133f8 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
811133f8:	defffe04 	addi	sp,sp,-8
811133fc:	de00012e 	bgeu	sp,et,81113404 <vCouldNotSendTurnOff+0xc>
81113400:	003b68fa 	trap	3
81113404:	dfc00115 	stw	ra,4(sp)
81113408:	df000015 	stw	fp,0(sp)
8111340c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
81113410:	d0a05517 	ldw	r2,-32428(gp)
81113414:	100f883a 	mov	r7,r2
81113418:	01800744 	movi	r6,29
8111341c:	01400044 	movi	r5,1
81113420:	01204534 	movhi	r4,33044
81113424:	2113d604 	addi	r4,r4,20312
81113428:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
8111342c:	d0a05517 	ldw	r2,-32428(gp)
81113430:	100f883a 	mov	r7,r2
81113434:	01800984 	movi	r6,38
81113438:	01400044 	movi	r5,1
8111343c:	01204534 	movhi	r4,33044
81113440:	2113de04 	addi	r4,r4,20344
81113444:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113448:	0001883a 	nop
8111344c:	e037883a 	mov	sp,fp
81113450:	dfc00117 	ldw	ra,4(sp)
81113454:	df000017 	ldw	fp,0(sp)
81113458:	dec00204 	addi	sp,sp,8
8111345c:	f800283a 	ret

81113460 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
81113460:	defffe04 	addi	sp,sp,-8
81113464:	de00012e 	bgeu	sp,et,8111346c <vCouldNotSendReset+0xc>
81113468:	003b68fa 	trap	3
8111346c:	dfc00115 	stw	ra,4(sp)
81113470:	df000015 	stw	fp,0(sp)
81113474:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
81113478:	d0a05517 	ldw	r2,-32428(gp)
8111347c:	100f883a 	mov	r7,r2
81113480:	018006c4 	movi	r6,27
81113484:	01400044 	movi	r5,1
81113488:	01204534 	movhi	r4,33044
8111348c:	2113e804 	addi	r4,r4,20384
81113490:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
81113494:	d0a05517 	ldw	r2,-32428(gp)
81113498:	100f883a 	mov	r7,r2
8111349c:	018008c4 	movi	r6,35
811134a0:	01400044 	movi	r5,1
811134a4:	01204534 	movhi	r4,33044
811134a8:	2113ef04 	addi	r4,r4,20412
811134ac:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811134b0:	0001883a 	nop
811134b4:	e037883a 	mov	sp,fp
811134b8:	dfc00117 	ldw	ra,4(sp)
811134bc:	df000017 	ldw	fp,0(sp)
811134c0:	dec00204 	addi	sp,sp,8
811134c4:	f800283a 	ret

811134c8 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
811134c8:	defffe04 	addi	sp,sp,-8
811134cc:	de00012e 	bgeu	sp,et,811134d4 <vCouldNotSendLog+0xc>
811134d0:	003b68fa 	trap	3
811134d4:	dfc00115 	stw	ra,4(sp)
811134d8:	df000015 	stw	fp,0(sp)
811134dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
811134e0:	d0a05517 	ldw	r2,-32428(gp)
811134e4:	100f883a 	mov	r7,r2
811134e8:	01800644 	movi	r6,25
811134ec:	01400044 	movi	r5,1
811134f0:	01204534 	movhi	r4,33044
811134f4:	2113f804 	addi	r4,r4,20448
811134f8:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
811134fc:	d0a05517 	ldw	r2,-32428(gp)
81113500:	100f883a 	mov	r7,r2
81113504:	018008c4 	movi	r6,35
81113508:	01400044 	movi	r5,1
8111350c:	01204534 	movhi	r4,33044
81113510:	2113ff04 	addi	r4,r4,20476
81113514:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113518:	0001883a 	nop
8111351c:	e037883a 	mov	sp,fp
81113520:	dfc00117 	ldw	ra,4(sp)
81113524:	df000017 	ldw	fp,0(sp)
81113528:	dec00204 	addi	sp,sp,8
8111352c:	f800283a 	ret

81113530 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
81113530:	defffd04 	addi	sp,sp,-12
81113534:	de00012e 	bgeu	sp,et,8111353c <vCouldNotSendTMPusCommand+0xc>
81113538:	003b68fa 	trap	3
8111353c:	dfc00215 	stw	ra,8(sp)
81113540:	df000115 	stw	fp,4(sp)
81113544:	df000104 	addi	fp,sp,4
81113548:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111354c:	d0a05517 	ldw	r2,-32428(gp)
81113550:	100f883a 	mov	r7,r2
81113554:	01800884 	movi	r6,34
81113558:	01400044 	movi	r5,1
8111355c:	01204534 	movhi	r4,33044
81113560:	21140804 	addi	r4,r4,20512
81113564:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
81113568:	d0a05517 	ldw	r2,-32428(gp)
8111356c:	100f883a 	mov	r7,r2
81113570:	01800ac4 	movi	r6,43
81113574:	01400044 	movi	r5,1
81113578:	01204534 	movhi	r4,33044
8111357c:	21141104 	addi	r4,r4,20548
81113580:	11172b80 	call	811172b8 <fwrite>
		debug(fp,"cData");
81113584:	d0a05517 	ldw	r2,-32428(gp)
81113588:	100f883a 	mov	r7,r2
8111358c:	01800144 	movi	r6,5
81113590:	01400044 	movi	r5,1
81113594:	01204534 	movhi	r4,33044
81113598:	21141c04 	addi	r4,r4,20592
8111359c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811135a0:	0001883a 	nop
811135a4:	e037883a 	mov	sp,fp
811135a8:	dfc00117 	ldw	ra,4(sp)
811135ac:	df000017 	ldw	fp,0(sp)
811135b0:	dec00204 	addi	sp,sp,8
811135b4:	f800283a 	ret

811135b8 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
811135b8:	defffe04 	addi	sp,sp,-8
811135bc:	de00012e 	bgeu	sp,et,811135c4 <vWarnCouldNotgetMutexRetrans128+0xc>
811135c0:	003b68fa 	trap	3
811135c4:	dfc00115 	stw	ra,4(sp)
811135c8:	df000015 	stw	fp,0(sp)
811135cc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
811135d0:	d0a05517 	ldw	r2,-32428(gp)
811135d4:	100f883a 	mov	r7,r2
811135d8:	01800a04 	movi	r6,40
811135dc:	01400044 	movi	r5,1
811135e0:	01204534 	movhi	r4,33044
811135e4:	21141e04 	addi	r4,r4,20600
811135e8:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
811135ec:	d0a05517 	ldw	r2,-32428(gp)
811135f0:	100f883a 	mov	r7,r2
811135f4:	018014c4 	movi	r6,83
811135f8:	01400044 	movi	r5,1
811135fc:	01204534 	movhi	r4,33044
81113600:	21142904 	addi	r4,r4,20644
81113604:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113608:	0001883a 	nop
8111360c:	e037883a 	mov	sp,fp
81113610:	dfc00117 	ldw	ra,4(sp)
81113614:	df000017 	ldw	fp,0(sp)
81113618:	dec00204 	addi	sp,sp,8
8111361c:	f800283a 	ret

81113620 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
81113620:	defffe04 	addi	sp,sp,-8
81113624:	de00012e 	bgeu	sp,et,8111362c <vFailCreateScheduleQueue+0xc>
81113628:	003b68fa 	trap	3
8111362c:	dfc00115 	stw	ra,4(sp)
81113630:	df000015 	stw	fp,0(sp)
81113634:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
81113638:	d0a05517 	ldw	r2,-32428(gp)
8111363c:	100f883a 	mov	r7,r2
81113640:	01800844 	movi	r6,33
81113644:	01400044 	movi	r5,1
81113648:	01204534 	movhi	r4,33044
8111364c:	21143e04 	addi	r4,r4,20728
81113650:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
81113654:	d0a05517 	ldw	r2,-32428(gp)
81113658:	100f883a 	mov	r7,r2
8111365c:	01801204 	movi	r6,72
81113660:	01400044 	movi	r5,1
81113664:	01204534 	movhi	r4,33044
81113668:	21144704 	addi	r4,r4,20764
8111366c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113670:	0001883a 	nop
81113674:	e037883a 	mov	sp,fp
81113678:	dfc00117 	ldw	ra,4(sp)
8111367c:	df000017 	ldw	fp,0(sp)
81113680:	dec00204 	addi	sp,sp,8
81113684:	f800283a 	ret

81113688 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
81113688:	defffd04 	addi	sp,sp,-12
8111368c:	de00012e 	bgeu	sp,et,81113694 <vFailCreateNFEEQueue+0xc>
81113690:	003b68fa 	trap	3
81113694:	dfc00215 	stw	ra,8(sp)
81113698:	df000115 	stw	fp,4(sp)
8111369c:	df000104 	addi	fp,sp,4
811136a0:	2005883a 	mov	r2,r4
811136a4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
811136a8:	d0a05517 	ldw	r2,-32428(gp)
811136ac:	100f883a 	mov	r7,r2
811136b0:	01800744 	movi	r6,29
811136b4:	01400044 	movi	r5,1
811136b8:	01204534 	movhi	r4,33044
811136bc:	21145a04 	addi	r4,r4,20840
811136c0:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
811136c4:	d0a05517 	ldw	r2,-32428(gp)
811136c8:	e0ffff03 	ldbu	r3,-4(fp)
811136cc:	180d883a 	mov	r6,r3
811136d0:	01604534 	movhi	r5,33044
811136d4:	29546204 	addi	r5,r5,20872
811136d8:	1009883a 	mov	r4,r2
811136dc:	1117fe40 	call	81117fe4 <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811136e0:	0001883a 	nop
811136e4:	e037883a 	mov	sp,fp
811136e8:	dfc00117 	ldw	ra,4(sp)
811136ec:	df000017 	ldw	fp,0(sp)
811136f0:	dec00204 	addi	sp,sp,8
811136f4:	f800283a 	ret

811136f8 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
811136f8:	defffe04 	addi	sp,sp,-8
811136fc:	de00012e 	bgeu	sp,et,81113704 <vCoudlNotCreateNFee0Task+0xc>
81113700:	003b68fa 	trap	3
81113704:	dfc00115 	stw	ra,4(sp)
81113708:	df000015 	stw	fp,0(sp)
8111370c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
81113710:	d0a05517 	ldw	r2,-32428(gp)
81113714:	100f883a 	mov	r7,r2
81113718:	01800844 	movi	r6,33
8111371c:	01400044 	movi	r5,1
81113720:	01204534 	movhi	r4,33044
81113724:	21147004 	addi	r4,r4,20928
81113728:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
8111372c:	d0a05517 	ldw	r2,-32428(gp)
81113730:	100f883a 	mov	r7,r2
81113734:	01800784 	movi	r6,30
81113738:	01400044 	movi	r5,1
8111373c:	01204534 	movhi	r4,33044
81113740:	21147904 	addi	r4,r4,20964
81113744:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113748:	0001883a 	nop
8111374c:	e037883a 	mov	sp,fp
81113750:	dfc00117 	ldw	ra,4(sp)
81113754:	df000017 	ldw	fp,0(sp)
81113758:	dec00204 	addi	sp,sp,8
8111375c:	f800283a 	ret

81113760 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
81113760:	defffe04 	addi	sp,sp,-8
81113764:	de00012e 	bgeu	sp,et,8111376c <vCoudlNotCreateNFee1Task+0xc>
81113768:	003b68fa 	trap	3
8111376c:	dfc00115 	stw	ra,4(sp)
81113770:	df000015 	stw	fp,0(sp)
81113774:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
81113778:	d0a05517 	ldw	r2,-32428(gp)
8111377c:	100f883a 	mov	r7,r2
81113780:	01800844 	movi	r6,33
81113784:	01400044 	movi	r5,1
81113788:	01204534 	movhi	r4,33044
8111378c:	21148104 	addi	r4,r4,20996
81113790:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
81113794:	d0a05517 	ldw	r2,-32428(gp)
81113798:	100f883a 	mov	r7,r2
8111379c:	01800784 	movi	r6,30
811137a0:	01400044 	movi	r5,1
811137a4:	01204534 	movhi	r4,33044
811137a8:	21148a04 	addi	r4,r4,21032
811137ac:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811137b0:	0001883a 	nop
811137b4:	e037883a 	mov	sp,fp
811137b8:	dfc00117 	ldw	ra,4(sp)
811137bc:	df000017 	ldw	fp,0(sp)
811137c0:	dec00204 	addi	sp,sp,8
811137c4:	f800283a 	ret

811137c8 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
811137c8:	defffe04 	addi	sp,sp,-8
811137cc:	de00012e 	bgeu	sp,et,811137d4 <vCoudlNotCreateNFee2Task+0xc>
811137d0:	003b68fa 	trap	3
811137d4:	dfc00115 	stw	ra,4(sp)
811137d8:	df000015 	stw	fp,0(sp)
811137dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
811137e0:	d0a05517 	ldw	r2,-32428(gp)
811137e4:	100f883a 	mov	r7,r2
811137e8:	01800844 	movi	r6,33
811137ec:	01400044 	movi	r5,1
811137f0:	01204534 	movhi	r4,33044
811137f4:	21149204 	addi	r4,r4,21064
811137f8:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
811137fc:	d0a05517 	ldw	r2,-32428(gp)
81113800:	100f883a 	mov	r7,r2
81113804:	01800784 	movi	r6,30
81113808:	01400044 	movi	r5,1
8111380c:	01204534 	movhi	r4,33044
81113810:	21149b04 	addi	r4,r4,21100
81113814:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113818:	0001883a 	nop
8111381c:	e037883a 	mov	sp,fp
81113820:	dfc00117 	ldw	ra,4(sp)
81113824:	df000017 	ldw	fp,0(sp)
81113828:	dec00204 	addi	sp,sp,8
8111382c:	f800283a 	ret

81113830 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
81113830:	defffe04 	addi	sp,sp,-8
81113834:	de00012e 	bgeu	sp,et,8111383c <vCoudlNotCreateNFee3Task+0xc>
81113838:	003b68fa 	trap	3
8111383c:	dfc00115 	stw	ra,4(sp)
81113840:	df000015 	stw	fp,0(sp)
81113844:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
81113848:	d0a05517 	ldw	r2,-32428(gp)
8111384c:	100f883a 	mov	r7,r2
81113850:	01800844 	movi	r6,33
81113854:	01400044 	movi	r5,1
81113858:	01204534 	movhi	r4,33044
8111385c:	2114a304 	addi	r4,r4,21132
81113860:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
81113864:	d0a05517 	ldw	r2,-32428(gp)
81113868:	100f883a 	mov	r7,r2
8111386c:	01800784 	movi	r6,30
81113870:	01400044 	movi	r5,1
81113874:	01204534 	movhi	r4,33044
81113878:	2114ac04 	addi	r4,r4,21168
8111387c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113880:	0001883a 	nop
81113884:	e037883a 	mov	sp,fp
81113888:	dfc00117 	ldw	ra,4(sp)
8111388c:	df000017 	ldw	fp,0(sp)
81113890:	dec00204 	addi	sp,sp,8
81113894:	f800283a 	ret

81113898 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
81113898:	defffe04 	addi	sp,sp,-8
8111389c:	de00012e 	bgeu	sp,et,811138a4 <vCoudlNotCreateNFee4Task+0xc>
811138a0:	003b68fa 	trap	3
811138a4:	dfc00115 	stw	ra,4(sp)
811138a8:	df000015 	stw	fp,0(sp)
811138ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
811138b0:	d0a05517 	ldw	r2,-32428(gp)
811138b4:	100f883a 	mov	r7,r2
811138b8:	01800844 	movi	r6,33
811138bc:	01400044 	movi	r5,1
811138c0:	01204534 	movhi	r4,33044
811138c4:	2114b404 	addi	r4,r4,21200
811138c8:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
811138cc:	d0a05517 	ldw	r2,-32428(gp)
811138d0:	100f883a 	mov	r7,r2
811138d4:	01800784 	movi	r6,30
811138d8:	01400044 	movi	r5,1
811138dc:	01204534 	movhi	r4,33044
811138e0:	2114bd04 	addi	r4,r4,21236
811138e4:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811138e8:	0001883a 	nop
811138ec:	e037883a 	mov	sp,fp
811138f0:	dfc00117 	ldw	ra,4(sp)
811138f4:	df000017 	ldw	fp,0(sp)
811138f8:	dec00204 	addi	sp,sp,8
811138fc:	f800283a 	ret

81113900 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
81113900:	defffe04 	addi	sp,sp,-8
81113904:	de00012e 	bgeu	sp,et,8111390c <vCoudlNotCreateNFee5Task+0xc>
81113908:	003b68fa 	trap	3
8111390c:	dfc00115 	stw	ra,4(sp)
81113910:	df000015 	stw	fp,0(sp)
81113914:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
81113918:	d0a05517 	ldw	r2,-32428(gp)
8111391c:	100f883a 	mov	r7,r2
81113920:	01800844 	movi	r6,33
81113924:	01400044 	movi	r5,1
81113928:	01204534 	movhi	r4,33044
8111392c:	2114c504 	addi	r4,r4,21268
81113930:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
81113934:	d0a05517 	ldw	r2,-32428(gp)
81113938:	100f883a 	mov	r7,r2
8111393c:	01800784 	movi	r6,30
81113940:	01400044 	movi	r5,1
81113944:	01204534 	movhi	r4,33044
81113948:	2114ce04 	addi	r4,r4,21304
8111394c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113950:	0001883a 	nop
81113954:	e037883a 	mov	sp,fp
81113958:	dfc00117 	ldw	ra,4(sp)
8111395c:	df000017 	ldw	fp,0(sp)
81113960:	dec00204 	addi	sp,sp,8
81113964:	f800283a 	ret

81113968 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
81113968:	defffe04 	addi	sp,sp,-8
8111396c:	de00012e 	bgeu	sp,et,81113974 <vCoudlNotCreateNFeeControllerTask+0xc>
81113970:	003b68fa 	trap	3
81113974:	dfc00115 	stw	ra,4(sp)
81113978:	df000015 	stw	fp,0(sp)
8111397c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
81113980:	d0a05517 	ldw	r2,-32428(gp)
81113984:	100f883a 	mov	r7,r2
81113988:	01800a84 	movi	r6,42
8111398c:	01400044 	movi	r5,1
81113990:	01204534 	movhi	r4,33044
81113994:	2114d604 	addi	r4,r4,21336
81113998:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
8111399c:	d0a05517 	ldw	r2,-32428(gp)
811139a0:	100f883a 	mov	r7,r2
811139a4:	018009c4 	movi	r6,39
811139a8:	01400044 	movi	r5,1
811139ac:	01204534 	movhi	r4,33044
811139b0:	2114e104 	addi	r4,r4,21380
811139b4:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811139b8:	0001883a 	nop
811139bc:	e037883a 	mov	sp,fp
811139c0:	dfc00117 	ldw	ra,4(sp)
811139c4:	df000017 	ldw	fp,0(sp)
811139c8:	dec00204 	addi	sp,sp,8
811139cc:	f800283a 	ret

811139d0 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
811139d0:	defffe04 	addi	sp,sp,-8
811139d4:	de00012e 	bgeu	sp,et,811139dc <vCoudlNotCreateDataControllerTask+0xc>
811139d8:	003b68fa 	trap	3
811139dc:	dfc00115 	stw	ra,4(sp)
811139e0:	df000015 	stw	fp,0(sp)
811139e4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
811139e8:	d0a05517 	ldw	r2,-32428(gp)
811139ec:	100f883a 	mov	r7,r2
811139f0:	01800a84 	movi	r6,42
811139f4:	01400044 	movi	r5,1
811139f8:	01204534 	movhi	r4,33044
811139fc:	2114eb04 	addi	r4,r4,21420
81113a00:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
81113a04:	d0a05517 	ldw	r2,-32428(gp)
81113a08:	100f883a 	mov	r7,r2
81113a0c:	018009c4 	movi	r6,39
81113a10:	01400044 	movi	r5,1
81113a14:	01204534 	movhi	r4,33044
81113a18:	2114f604 	addi	r4,r4,21464
81113a1c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113a20:	0001883a 	nop
81113a24:	e037883a 	mov	sp,fp
81113a28:	dfc00117 	ldw	ra,4(sp)
81113a2c:	df000017 	ldw	fp,0(sp)
81113a30:	dec00204 	addi	sp,sp,8
81113a34:	f800283a 	ret

81113a38 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
81113a38:	defffe04 	addi	sp,sp,-8
81113a3c:	de00012e 	bgeu	sp,et,81113a44 <vCoudlNotCreateMebTask+0xc>
81113a40:	003b68fa 	trap	3
81113a44:	dfc00115 	stw	ra,4(sp)
81113a48:	df000015 	stw	fp,0(sp)
81113a4c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
81113a50:	d0a05517 	ldw	r2,-32428(gp)
81113a54:	100f883a 	mov	r7,r2
81113a58:	018007c4 	movi	r6,31
81113a5c:	01400044 	movi	r5,1
81113a60:	01204534 	movhi	r4,33044
81113a64:	21150004 	addi	r4,r4,21504
81113a68:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
81113a6c:	d0a05517 	ldw	r2,-32428(gp)
81113a70:	100f883a 	mov	r7,r2
81113a74:	018006c4 	movi	r6,27
81113a78:	01400044 	movi	r5,1
81113a7c:	01204534 	movhi	r4,33044
81113a80:	21150804 	addi	r4,r4,21536
81113a84:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113a88:	0001883a 	nop
81113a8c:	e037883a 	mov	sp,fp
81113a90:	dfc00117 	ldw	ra,4(sp)
81113a94:	df000017 	ldw	fp,0(sp)
81113a98:	dec00204 	addi	sp,sp,8
81113a9c:	f800283a 	ret

81113aa0 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
81113aa0:	defffd04 	addi	sp,sp,-12
81113aa4:	de00012e 	bgeu	sp,et,81113aac <vFailCreateMutexSPUSQueueMeb+0xc>
81113aa8:	003b68fa 	trap	3
81113aac:	dfc00215 	stw	ra,8(sp)
81113ab0:	df000115 	stw	fp,4(sp)
81113ab4:	df000104 	addi	fp,sp,4
81113ab8:	2005883a 	mov	r2,r4
81113abc:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
81113ac0:	d0a05517 	ldw	r2,-32428(gp)
81113ac4:	100f883a 	mov	r7,r2
81113ac8:	01800944 	movi	r6,37
81113acc:	01400044 	movi	r5,1
81113ad0:	01204534 	movhi	r4,33044
81113ad4:	21150f04 	addi	r4,r4,21564
81113ad8:	11172b80 	call	811172b8 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81113adc:	e0bfff03 	ldbu	r2,-4(fp)
81113ae0:	1009883a 	mov	r4,r2
81113ae4:	11123080 	call	81112308 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113ae8:	0001883a 	nop
81113aec:	e037883a 	mov	sp,fp
81113af0:	dfc00117 	ldw	ra,4(sp)
81113af4:	df000017 	ldw	fp,0(sp)
81113af8:	dec00204 	addi	sp,sp,8
81113afc:	f800283a 	ret

81113b00 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
81113b00:	defffe04 	addi	sp,sp,-8
81113b04:	de00012e 	bgeu	sp,et,81113b0c <vFailSendPUStoMebTask+0xc>
81113b08:	003b68fa 	trap	3
81113b0c:	dfc00115 	stw	ra,4(sp)
81113b10:	df000015 	stw	fp,0(sp)
81113b14:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
81113b18:	d0a05517 	ldw	r2,-32428(gp)
81113b1c:	100f883a 	mov	r7,r2
81113b20:	01800784 	movi	r6,30
81113b24:	01400044 	movi	r5,1
81113b28:	01204534 	movhi	r4,33044
81113b2c:	21151904 	addi	r4,r4,21604
81113b30:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113b34:	0001883a 	nop
81113b38:	e037883a 	mov	sp,fp
81113b3c:	dfc00117 	ldw	ra,4(sp)
81113b40:	df000017 	ldw	fp,0(sp)
81113b44:	dec00204 	addi	sp,sp,8
81113b48:	f800283a 	ret

81113b4c <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
81113b4c:	defffe04 	addi	sp,sp,-8
81113b50:	de00012e 	bgeu	sp,et,81113b58 <vCouldNotGetCmdQueueMeb+0xc>
81113b54:	003b68fa 	trap	3
81113b58:	dfc00115 	stw	ra,4(sp)
81113b5c:	df000015 	stw	fp,0(sp)
81113b60:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetCmdQueueMeb. (exit)\n");
81113b64:	d0a05517 	ldw	r2,-32428(gp)
81113b68:	100f883a 	mov	r7,r2
81113b6c:	01800804 	movi	r6,32
81113b70:	01400044 	movi	r5,1
81113b74:	01204534 	movhi	r4,33044
81113b78:	21152104 	addi	r4,r4,21636
81113b7c:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
81113b80:	d0a05517 	ldw	r2,-32428(gp)
81113b84:	100f883a 	mov	r7,r2
81113b88:	01800cc4 	movi	r6,51
81113b8c:	01400044 	movi	r5,1
81113b90:	01204534 	movhi	r4,33044
81113b94:	21152a04 	addi	r4,r4,21672
81113b98:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113b9c:	0001883a 	nop
81113ba0:	e037883a 	mov	sp,fp
81113ba4:	dfc00117 	ldw	ra,4(sp)
81113ba8:	df000017 	ldw	fp,0(sp)
81113bac:	dec00204 	addi	sp,sp,8
81113bb0:	f800283a 	ret

81113bb4 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
81113bb4:	defffe04 	addi	sp,sp,-8
81113bb8:	de00012e 	bgeu	sp,et,81113bc0 <vCouldNotGetMutexMebPus+0xc>
81113bbc:	003b68fa 	trap	3
81113bc0:	dfc00115 	stw	ra,4(sp)
81113bc4:	df000015 	stw	fp,0(sp)
81113bc8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
81113bcc:	d0a05517 	ldw	r2,-32428(gp)
81113bd0:	100f883a 	mov	r7,r2
81113bd4:	01800804 	movi	r6,32
81113bd8:	01400044 	movi	r5,1
81113bdc:	01204534 	movhi	r4,33044
81113be0:	21153704 	addi	r4,r4,21724
81113be4:	11172b80 	call	811172b8 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113be8:	0001883a 	nop
81113bec:	e037883a 	mov	sp,fp
81113bf0:	dfc00117 	ldw	ra,4(sp)
81113bf4:	df000017 	ldw	fp,0(sp)
81113bf8:	dec00204 	addi	sp,sp,8
81113bfc:	f800283a 	ret

81113c00 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
81113c00:	defffe04 	addi	sp,sp,-8
81113c04:	de00012e 	bgeu	sp,et,81113c0c <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
81113c08:	003b68fa 	trap	3
81113c0c:	dfc00115 	stw	ra,4(sp)
81113c10:	df000015 	stw	fp,0(sp)
81113c14:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
81113c18:	d0a05517 	ldw	r2,-32428(gp)
81113c1c:	100f883a 	mov	r7,r2
81113c20:	01800a44 	movi	r6,41
81113c24:	01400044 	movi	r5,1
81113c28:	01204534 	movhi	r4,33044
81113c2c:	21154004 	addi	r4,r4,21760
81113c30:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
81113c34:	d0a05517 	ldw	r2,-32428(gp)
81113c38:	100f883a 	mov	r7,r2
81113c3c:	01800c84 	movi	r6,50
81113c40:	01400044 	movi	r5,1
81113c44:	01204534 	movhi	r4,33044
81113c48:	21154b04 	addi	r4,r4,21804
81113c4c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113c50:	0001883a 	nop
81113c54:	e037883a 	mov	sp,fp
81113c58:	dfc00117 	ldw	ra,4(sp)
81113c5c:	df000017 	ldw	fp,0(sp)
81113c60:	dec00204 	addi	sp,sp,8
81113c64:	f800283a 	ret

81113c68 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
81113c68:	defffe04 	addi	sp,sp,-8
81113c6c:	de00012e 	bgeu	sp,et,81113c74 <vCouldNotCreateQueueMaskDataCtrl+0xc>
81113c70:	003b68fa 	trap	3
81113c74:	dfc00115 	stw	ra,4(sp)
81113c78:	df000015 	stw	fp,0(sp)
81113c7c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
81113c80:	d0a05517 	ldw	r2,-32428(gp)
81113c84:	100f883a 	mov	r7,r2
81113c88:	01800a44 	movi	r6,41
81113c8c:	01400044 	movi	r5,1
81113c90:	01204534 	movhi	r4,33044
81113c94:	21155804 	addi	r4,r4,21856
81113c98:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
81113c9c:	d0a05517 	ldw	r2,-32428(gp)
81113ca0:	100f883a 	mov	r7,r2
81113ca4:	01800c84 	movi	r6,50
81113ca8:	01400044 	movi	r5,1
81113cac:	01204534 	movhi	r4,33044
81113cb0:	21156304 	addi	r4,r4,21900
81113cb4:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113cb8:	0001883a 	nop
81113cbc:	e037883a 	mov	sp,fp
81113cc0:	dfc00117 	ldw	ra,4(sp)
81113cc4:	df000017 	ldw	fp,0(sp)
81113cc8:	dec00204 	addi	sp,sp,8
81113ccc:	f800283a 	ret

81113cd0 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
81113cd0:	defffe04 	addi	sp,sp,-8
81113cd4:	de00012e 	bgeu	sp,et,81113cdc <vCouldNotGetQueueMaskNfeeCtrl+0xc>
81113cd8:	003b68fa 	trap	3
81113cdc:	dfc00115 	stw	ra,4(sp)
81113ce0:	df000015 	stw	fp,0(sp)
81113ce4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
81113ce8:	d0a05517 	ldw	r2,-32428(gp)
81113cec:	100f883a 	mov	r7,r2
81113cf0:	01800984 	movi	r6,38
81113cf4:	01400044 	movi	r5,1
81113cf8:	01204534 	movhi	r4,33044
81113cfc:	21157004 	addi	r4,r4,21952
81113d00:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
81113d04:	d0a05517 	ldw	r2,-32428(gp)
81113d08:	100f883a 	mov	r7,r2
81113d0c:	01800bc4 	movi	r6,47
81113d10:	01400044 	movi	r5,1
81113d14:	01204534 	movhi	r4,33044
81113d18:	21157a04 	addi	r4,r4,21992
81113d1c:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113d20:	0001883a 	nop
81113d24:	e037883a 	mov	sp,fp
81113d28:	dfc00117 	ldw	ra,4(sp)
81113d2c:	df000017 	ldw	fp,0(sp)
81113d30:	dec00204 	addi	sp,sp,8
81113d34:	f800283a 	ret

81113d38 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
81113d38:	defffe04 	addi	sp,sp,-8
81113d3c:	de00012e 	bgeu	sp,et,81113d44 <vCouldNotGetQueueMaskDataCtrl+0xc>
81113d40:	003b68fa 	trap	3
81113d44:	dfc00115 	stw	ra,4(sp)
81113d48:	df000015 	stw	fp,0(sp)
81113d4c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
81113d50:	d0a05517 	ldw	r2,-32428(gp)
81113d54:	100f883a 	mov	r7,r2
81113d58:	01800984 	movi	r6,38
81113d5c:	01400044 	movi	r5,1
81113d60:	01204534 	movhi	r4,33044
81113d64:	21158604 	addi	r4,r4,22040
81113d68:	11172b80 	call	811172b8 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
81113d6c:	d0a05517 	ldw	r2,-32428(gp)
81113d70:	100f883a 	mov	r7,r2
81113d74:	01800bc4 	movi	r6,47
81113d78:	01400044 	movi	r5,1
81113d7c:	01204534 	movhi	r4,33044
81113d80:	21159004 	addi	r4,r4,22080
81113d84:	11172b80 	call	811172b8 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113d88:	0001883a 	nop
81113d8c:	e037883a 	mov	sp,fp
81113d90:	dfc00117 	ldw	ra,4(sp)
81113d94:	df000017 	ldw	fp,0(sp)
81113d98:	dec00204 	addi	sp,sp,8
81113d9c:	f800283a 	ret

81113da0 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
81113da0:	defffd04 	addi	sp,sp,-12
81113da4:	de00012e 	bgeu	sp,et,81113dac <vFailSendMsgAccessDMA+0xc>
81113da8:	003b68fa 	trap	3
81113dac:	dfc00215 	stw	ra,8(sp)
81113db0:	df000115 	stw	fp,4(sp)
81113db4:	df000104 	addi	fp,sp,4
81113db8:	2005883a 	mov	r2,r4
81113dbc:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
81113dc0:	d0a05517 	ldw	r2,-32428(gp)
81113dc4:	e0ffff03 	ldbu	r3,-4(fp)
81113dc8:	180d883a 	mov	r6,r3
81113dcc:	01604534 	movhi	r5,33044
81113dd0:	29559c04 	addi	r5,r5,22128
81113dd4:	1009883a 	mov	r4,r2
81113dd8:	1116c1c0 	call	81116c1c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113ddc:	0001883a 	nop
81113de0:	e037883a 	mov	sp,fp
81113de4:	dfc00117 	ldw	ra,4(sp)
81113de8:	df000017 	ldw	fp,0(sp)
81113dec:	dec00204 	addi	sp,sp,8
81113df0:	f800283a 	ret

81113df4 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
81113df4:	defffe04 	addi	sp,sp,-8
81113df8:	de00012e 	bgeu	sp,et,81113e00 <vFailSendMsgFeeCTRL+0xc>
81113dfc:	003b68fa 	trap	3
81113e00:	dfc00115 	stw	ra,4(sp)
81113e04:	df000015 	stw	fp,0(sp)
81113e08:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
81113e0c:	d0a05517 	ldw	r2,-32428(gp)
81113e10:	100f883a 	mov	r7,r2
81113e14:	018005c4 	movi	r6,23
81113e18:	01400044 	movi	r5,1
81113e1c:	01204534 	movhi	r4,33044
81113e20:	2115a404 	addi	r4,r4,22160
81113e24:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113e28:	0001883a 	nop
81113e2c:	e037883a 	mov	sp,fp
81113e30:	dfc00117 	ldw	ra,4(sp)
81113e34:	df000017 	ldw	fp,0(sp)
81113e38:	dec00204 	addi	sp,sp,8
81113e3c:	f800283a 	ret

81113e40 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
81113e40:	defffe04 	addi	sp,sp,-8
81113e44:	de00012e 	bgeu	sp,et,81113e4c <vFailSendMsgDataCTRL+0xc>
81113e48:	003b68fa 	trap	3
81113e4c:	dfc00115 	stw	ra,4(sp)
81113e50:	df000015 	stw	fp,0(sp)
81113e54:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
81113e58:	d0a05517 	ldw	r2,-32428(gp)
81113e5c:	100f883a 	mov	r7,r2
81113e60:	01800604 	movi	r6,24
81113e64:	01400044 	movi	r5,1
81113e68:	01204534 	movhi	r4,33044
81113e6c:	2115aa04 	addi	r4,r4,22184
81113e70:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113e74:	0001883a 	nop
81113e78:	e037883a 	mov	sp,fp
81113e7c:	dfc00117 	ldw	ra,4(sp)
81113e80:	df000017 	ldw	fp,0(sp)
81113e84:	dec00204 	addi	sp,sp,8
81113e88:	f800283a 	ret

81113e8c <vFailFlushQueue>:

void vFailFlushQueue( void )
{
81113e8c:	defffe04 	addi	sp,sp,-8
81113e90:	de00012e 	bgeu	sp,et,81113e98 <vFailFlushQueue+0xc>
81113e94:	003b68fa 	trap	3
81113e98:	dfc00115 	stw	ra,4(sp)
81113e9c:	df000015 	stw	fp,0(sp)
81113ea0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
81113ea4:	d0a05517 	ldw	r2,-32428(gp)
81113ea8:	100f883a 	mov	r7,r2
81113eac:	01800744 	movi	r6,29
81113eb0:	01400044 	movi	r5,1
81113eb4:	01204534 	movhi	r4,33044
81113eb8:	2115b104 	addi	r4,r4,22212
81113ebc:	11172b80 	call	811172b8 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81113ec0:	0001883a 	nop
81113ec4:	e037883a 	mov	sp,fp
81113ec8:	dfc00117 	ldw	ra,4(sp)
81113ecc:	df000017 	ldw	fp,0(sp)
81113ed0:	dec00204 	addi	sp,sp,8
81113ed4:	f800283a 	ret

81113ed8 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( tSimucamStates eOldState, tSimucamStates eNewState ) {
81113ed8:	defffc04 	addi	sp,sp,-16
81113edc:	de00012e 	bgeu	sp,et,81113ee4 <vEvtChangeMebMode+0xc>
81113ee0:	003b68fa 	trap	3
81113ee4:	dfc00315 	stw	ra,12(sp)
81113ee8:	df000215 	stw	fp,8(sp)
81113eec:	df000204 	addi	fp,sp,8
81113ef0:	e13ffe15 	stw	r4,-8(fp)
81113ef4:	e17fff15 	stw	r5,-4(fp)

	#ifdef DEBUG_ON
		fprintf(fp, "\nvEvtChangeMebMode ( sMebConfig = 0, sRun = 1 ) \n");
81113ef8:	d0a05517 	ldw	r2,-32428(gp)
81113efc:	100f883a 	mov	r7,r2
81113f00:	01800c44 	movi	r6,49
81113f04:	01400044 	movi	r5,1
81113f08:	01204534 	movhi	r4,33044
81113f0c:	2115b904 	addi	r4,r4,22244
81113f10:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp, "Meb State Change: %hu -> %hu \n\n", eOldState, eNewState );
81113f14:	d0a05517 	ldw	r2,-32428(gp)
81113f18:	e1ffff17 	ldw	r7,-4(fp)
81113f1c:	e1bffe17 	ldw	r6,-8(fp)
81113f20:	01604534 	movhi	r5,33044
81113f24:	2955c604 	addi	r5,r5,22296
81113f28:	1009883a 	mov	r4,r2
81113f2c:	1116c1c0 	call	81116c1c <fprintf>
	#endif

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81113f30:	0001883a 	nop
81113f34:	e037883a 	mov	sp,fp
81113f38:	dfc00117 	ldw	ra,4(sp)
81113f3c:	df000017 	ldw	fp,0(sp)
81113f40:	dec00204 	addi	sp,sp,8
81113f44:	f800283a 	ret

81113f48 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( tSimucamStates eOldState, tSimucamStates eNewState ) {
81113f48:	defffc04 	addi	sp,sp,-16
81113f4c:	de00012e 	bgeu	sp,et,81113f54 <vEvtChangeFeeControllerMode+0xc>
81113f50:	003b68fa 	trap	3
81113f54:	dfc00315 	stw	ra,12(sp)
81113f58:	df000215 	stw	fp,8(sp)
81113f5c:	df000204 	addi	fp,sp,8
81113f60:	e13ffe15 	stw	r4,-8(fp)
81113f64:	e17fff15 	stw	r5,-4(fp)

	#ifdef DEBUG_ON
		fprintf(fp, "\vEvtChangeFeeControllerMode ( sMebConfig = 0, sRun = 1 ) \n");
81113f68:	d0a05517 	ldw	r2,-32428(gp)
81113f6c:	100f883a 	mov	r7,r2
81113f70:	01800e84 	movi	r6,58
81113f74:	01400044 	movi	r5,1
81113f78:	01204534 	movhi	r4,33044
81113f7c:	2115ce04 	addi	r4,r4,22328
81113f80:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp, "NFEE Controller State Change: %hu -> %hu \n\n", eOldState, eNewState );
81113f84:	d0a05517 	ldw	r2,-32428(gp)
81113f88:	e1ffff17 	ldw	r7,-4(fp)
81113f8c:	e1bffe17 	ldw	r6,-8(fp)
81113f90:	01604534 	movhi	r5,33044
81113f94:	2955dd04 	addi	r5,r5,22388
81113f98:	1009883a 	mov	r4,r2
81113f9c:	1116c1c0 	call	81116c1c <fprintf>
	#endif

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81113fa0:	0001883a 	nop
81113fa4:	e037883a 	mov	sp,fp
81113fa8:	dfc00117 	ldw	ra,4(sp)
81113fac:	df000017 	ldw	fp,0(sp)
81113fb0:	dec00204 	addi	sp,sp,8
81113fb4:	f800283a 	ret

81113fb8 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( tSimucamStates eOldState, tSimucamStates eNewState ) {
81113fb8:	defffc04 	addi	sp,sp,-16
81113fbc:	de00012e 	bgeu	sp,et,81113fc4 <vEvtChangeDataControllerMode+0xc>
81113fc0:	003b68fa 	trap	3
81113fc4:	dfc00315 	stw	ra,12(sp)
81113fc8:	df000215 	stw	fp,8(sp)
81113fcc:	df000204 	addi	fp,sp,8
81113fd0:	e13ffe15 	stw	r4,-8(fp)
81113fd4:	e17fff15 	stw	r5,-4(fp)

	#ifdef DEBUG_ON
		fprintf(fp, "\vEvtChangeDataControllerMode ( sMebConfig = 0, sRun = 1 ) \n");
81113fd8:	d0a05517 	ldw	r2,-32428(gp)
81113fdc:	100f883a 	mov	r7,r2
81113fe0:	01800ec4 	movi	r6,59
81113fe4:	01400044 	movi	r5,1
81113fe8:	01204534 	movhi	r4,33044
81113fec:	2115e804 	addi	r4,r4,22432
81113ff0:	11172b80 	call	811172b8 <fwrite>
		fprintf(fp, "Data Controller State Change: %hu -> %hu \n\n", eOldState, eNewState );
81113ff4:	d0a05517 	ldw	r2,-32428(gp)
81113ff8:	e1ffff17 	ldw	r7,-4(fp)
81113ffc:	e1bffe17 	ldw	r6,-8(fp)
81114000:	01604534 	movhi	r5,33044
81114004:	2955f704 	addi	r5,r5,22492
81114008:	1009883a 	mov	r4,r2
8111400c:	1116c1c0 	call	81116c1c <fprintf>
	#endif

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
81114010:	0001883a 	nop
81114014:	e037883a 	mov	sp,fp
81114018:	dfc00117 	ldw	ra,4(sp)
8111401c:	df000017 	ldw	fp,0(sp)
81114020:	dec00204 	addi	sp,sp,8
81114024:	f800283a 	ret

81114028 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81114028:	defffd04 	addi	sp,sp,-12
8111402c:	de00012e 	bgeu	sp,et,81114034 <vNFeeNotInUse+0xc>
81114030:	003b68fa 	trap	3
81114034:	df000215 	stw	fp,8(sp)
81114038:	df000204 	addi	fp,sp,8
8111403c:	e13ffe15 	stw	r4,-8(fp)
81114040:	2805883a 	mov	r2,r5
81114044:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
81114048:	e0bffe17 	ldw	r2,-8(fp)
8111404c:	e0ffff03 	ldbu	r3,-4(fp)
81114050:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
81114054:	e0bffe17 	ldw	r2,-8(fp)
81114058:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111405c:	e0bffe17 	ldw	r2,-8(fp)
81114060:	10002215 	stw	zero,136(r2)
}
81114064:	0001883a 	nop
81114068:	e037883a 	mov	sp,fp
8111406c:	df000017 	ldw	fp,0(sp)
81114070:	dec00104 	addi	sp,sp,4
81114074:	f800283a 	ret

81114078 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81114078:	defffb04 	addi	sp,sp,-20
8111407c:	de00012e 	bgeu	sp,et,81114084 <vNFeeStructureInit+0xc>
81114080:	003b68fa 	trap	3
81114084:	dfc00415 	stw	ra,16(sp)
81114088:	df000315 	stw	fp,12(sp)
8111408c:	df000304 	addi	fp,sp,12
81114090:	e13ffe15 	stw	r4,-8(fp)
81114094:	2805883a 	mov	r2,r5
81114098:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111409c:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
811140a0:	e0bffe17 	ldw	r2,-8(fp)
811140a4:	e0ffff03 	ldbu	r3,-4(fp)
811140a8:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
811140ac:	e0bffe17 	ldw	r2,-8(fp)
811140b0:	10802a04 	addi	r2,r2,168
811140b4:	1009883a 	mov	r4,r2
811140b8:	110ffc80 	call	8110ffc8 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
811140bc:	e13ffe17 	ldw	r4,-8(fp)
811140c0:	11141600 	call	81114160 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
811140c4:	e0bffe17 	ldw	r2,-8(fp)
811140c8:	00c00044 	movi	r3,1
811140cc:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
811140d0:	e0bffe17 	ldw	r2,-8(fp)
811140d4:	10002215 	stw	zero,136(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
811140d8:	e0bffe17 	ldw	r2,-8(fp)
811140dc:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
811140e0:	e0bffe17 	ldw	r2,-8(fp)
811140e4:	10002615 	stw	zero,152(r2)
    
    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
811140e8:	e0bffe17 	ldw	r2,-8(fp)
811140ec:	10002815 	stw	zero,160(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
811140f0:	e03ffd05 	stb	zero,-12(fp)
811140f4:	00000906 	br	8111411c <vNFeeStructureInit+0xa4>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
811140f8:	e0bffd03 	ldbu	r2,-12(fp)
811140fc:	e0fffe17 	ldw	r3,-8(fp)
81114100:	1885883a 	add	r2,r3,r2
81114104:	10802704 	addi	r2,r2,156
81114108:	e0fffd03 	ldbu	r3,-12(fp)
8111410c:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
81114110:	e0bffd03 	ldbu	r2,-12(fp)
81114114:	10800044 	addi	r2,r2,1
81114118:	e0bffd05 	stb	r2,-12(fp)
8111411c:	e0bffd03 	ldbu	r2,-12(fp)
81114120:	10800130 	cmpltui	r2,r2,4
81114124:	103ff41e 	bne	r2,zero,811140f8 <__reset+0xfb0f40f8>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
81114128:	e0bffe17 	ldw	r2,-8(fp)
8111412c:	10002915 	stw	zero,164(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
81114130:	e0bffe17 	ldw	r2,-8(fp)
81114134:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bLogging = FALSE;
81114138:	e0bffe17 	ldw	r2,-8(fp)
8111413c:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
81114140:	e0bffe17 	ldw	r2,-8(fp)
81114144:	10002515 	stw	zero,148(r2)
		#endif
    }
	*/


}
81114148:	0001883a 	nop
8111414c:	e037883a 	mov	sp,fp
81114150:	dfc00117 	ldw	ra,4(sp)
81114154:	df000017 	ldw	fp,0(sp)
81114158:	dec00204 	addi	sp,sp,8
8111415c:	f800283a 	ret

81114160 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
81114160:	defff404 	addi	sp,sp,-48
81114164:	de00012e 	bgeu	sp,et,8111416c <vUpdateMemMapFEE+0xc>
81114168:	003b68fa 	trap	3
8111416c:	df000b15 	stw	fp,44(sp)
81114170:	df000b04 	addi	fp,sp,44
81114174:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
81114178:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111417c:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
81114180:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
81114184:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
81114188:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111418c:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
81114190:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
81114194:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
81114198:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111419c:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
811141a0:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
811141a4:	e17fff17 	ldw	r5,-4(fp)
811141a8:	01035a34 	movhi	r4,3432
811141ac:	21348c04 	addi	r4,r4,-11728
811141b0:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
811141b4:	e13fff17 	ldw	r4,-4(fp)
811141b8:	21000003 	ldbu	r4,0(r4)
811141bc:	21403fcc 	andi	r5,r4,255
811141c0:	01035a34 	movhi	r4,3432
811141c4:	21348c04 	addi	r4,r4,-11728
811141c8:	2909383a 	mul	r4,r5,r4
811141cc:	200b883a 	mov	r5,r4
811141d0:	e13fff17 	ldw	r4,-4(fp)
811141d4:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
811141d8:	e13fff17 	ldw	r4,-4(fp)
811141dc:	21400117 	ldw	r5,4(r4)
811141e0:	01033234 	movhi	r4,3272
811141e4:	21348c04 	addi	r4,r4,-11728
811141e8:	290b883a 	add	r5,r5,r4
811141ec:	e13fff17 	ldw	r4,-4(fp)
811141f0:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
811141f4:	e13fff17 	ldw	r4,-4(fp)
811141f8:	21002c0b 	ldhu	r4,176(r4)
811141fc:	217fffcc 	andi	r5,r4,65535
81114200:	e13fff17 	ldw	r4,-4(fp)
81114204:	21002b0b 	ldhu	r4,172(r4)
81114208:	213fffcc 	andi	r4,r4,65535
8111420c:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
81114210:	e13fff17 	ldw	r4,-4(fp)
81114214:	21002b8b 	ldhu	r4,174(r4)
81114218:	21bfffcc 	andi	r6,r4,65535
8111421c:	e13fff17 	ldw	r4,-4(fp)
81114220:	21002a8b 	ldhu	r4,170(r4)
81114224:	213fffcc 	andi	r4,r4,65535
81114228:	310d883a 	add	r6,r6,r4
8111422c:	e13fff17 	ldw	r4,-4(fp)
81114230:	21002a0b 	ldhu	r4,168(r4)
81114234:	213fffcc 	andi	r4,r4,65535
81114238:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111423c:	2909383a 	mul	r4,r5,r4
81114240:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
81114244:	e13ffa17 	ldw	r4,-24(fp)
81114248:	2109883a 	add	r4,r4,r4
8111424c:	200b883a 	mov	r5,r4
81114250:	e13fff17 	ldw	r4,-4(fp)
81114254:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
81114258:	e13fff17 	ldw	r4,-4(fp)
8111425c:	21000517 	ldw	r4,20(r4)
81114260:	2008d0fa 	srli	r4,r4,3
81114264:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
81114268:	e13fff17 	ldw	r4,-4(fp)
8111426c:	21000517 	ldw	r4,20(r4)
81114270:	210001cc 	andi	r4,r4,7
81114274:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
81114278:	e13ffb17 	ldw	r4,-20(fp)
8111427c:	20001226 	beq	r4,zero,811142c8 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
81114280:	e13ff517 	ldw	r4,-44(fp)
81114284:	21000044 	addi	r4,r4,1
81114288:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111428c:	e13fff17 	ldw	r4,-4(fp)
81114290:	21400517 	ldw	r5,20(r4)
81114294:	e13ffb17 	ldw	r4,-20(fp)
81114298:	2909c83a 	sub	r4,r5,r4
8111429c:	21400204 	addi	r5,r4,8
811142a0:	e13fff17 	ldw	r4,-4(fp)
811142a4:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
811142a8:	e13ffb17 	ldw	r4,-20(fp)
811142ac:	200b883a 	mov	r5,r4
811142b0:	01000204 	movi	r4,8
811142b4:	2149c83a 	sub	r4,r4,r5
811142b8:	200b883a 	mov	r5,r4
811142bc:	e13fff17 	ldw	r4,-4(fp)
811142c0:	21400605 	stb	r5,24(r4)
811142c4:	00000206 	br	811142d0 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
811142c8:	e13fff17 	ldw	r4,-4(fp)
811142cc:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
811142d0:	e13ff517 	ldw	r4,-44(fp)
811142d4:	2008d13a 	srli	r4,r4,4
811142d8:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
811142dc:	e13ff517 	ldw	r4,-44(fp)
811142e0:	210003cc 	andi	r4,r4,15
811142e4:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
811142e8:	e13ffc17 	ldw	r4,-16(fp)
811142ec:	20000b26 	beq	r4,zero,8111431c <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
811142f0:	e13ff717 	ldw	r4,-36(fp)
811142f4:	21000044 	addi	r4,r4,1
811142f8:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
811142fc:	e17ff517 	ldw	r5,-44(fp)
81114300:	e13ffc17 	ldw	r4,-16(fp)
81114304:	290bc83a 	sub	r5,r5,r4
81114308:	e13ff717 	ldw	r4,-36(fp)
8111430c:	2909883a 	add	r4,r5,r4
81114310:	21000404 	addi	r4,r4,16
81114314:	e13ff615 	stw	r4,-40(fp)
81114318:	00000406 	br	8111432c <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111431c:	e17ff517 	ldw	r5,-44(fp)
81114320:	e13ff717 	ldw	r4,-36(fp)
81114324:	2909883a 	add	r4,r5,r4
81114328:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111432c:	e13ff617 	ldw	r4,-40(fp)
81114330:	200a90fa 	slli	r5,r4,3
81114334:	e13fff17 	ldw	r4,-4(fp)
81114338:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111433c:	e13ffb17 	ldw	r4,-20(fp)
81114340:	20000926 	beq	r4,zero,81114368 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
81114344:	e13ffc17 	ldw	r4,-16(fp)
81114348:	2109883a 	add	r4,r4,r4
8111434c:	2109883a 	add	r4,r4,r4
81114350:	200b883a 	mov	r5,r4
81114354:	e13ffb17 	ldw	r4,-20(fp)
81114358:	2008d07a 	srli	r4,r4,1
8111435c:	2909883a 	add	r4,r5,r4
81114360:	e13ff805 	stb	r4,-32(fp)
81114364:	00000406 	br	81114378 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
81114368:	e13ffc17 	ldw	r4,-16(fp)
8111436c:	2109883a 	add	r4,r4,r4
81114370:	2109883a 	add	r4,r4,r4
81114374:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
81114378:	e13ff803 	ldbu	r4,-32(fp)
8111437c:	01401004 	movi	r5,64
81114380:	2909c83a 	sub	r4,r5,r4
81114384:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
81114388:	e13ffd03 	ldbu	r4,-12(fp)
8111438c:	217ff804 	addi	r5,r4,-32
81114390:	28000416 	blt	r5,zero,811143a4 <vUpdateMemMapFEE+0x244>
81114394:	013fffc4 	movi	r4,-1
81114398:	2144d83a 	srl	r2,r4,r5
8111439c:	0007883a 	mov	r3,zero
811143a0:	00000a06 	br	811143cc <vUpdateMemMapFEE+0x26c>
811143a4:	017fffc4 	movi	r5,-1
811143a8:	280c907a 	slli	r6,r5,1
811143ac:	014007c4 	movi	r5,31
811143b0:	290bc83a 	sub	r5,r5,r4
811143b4:	314a983a 	sll	r5,r6,r5
811143b8:	01bfffc4 	movi	r6,-1
811143bc:	3104d83a 	srl	r2,r6,r4
811143c0:	2884b03a 	or	r2,r5,r2
811143c4:	017fffc4 	movi	r5,-1
811143c8:	2906d83a 	srl	r3,r5,r4
811143cc:	e13fff17 	ldw	r4,-4(fp)
811143d0:	20800715 	stw	r2,28(r4)
811143d4:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
811143d8:	e0bfff17 	ldw	r2,-4(fp)
811143dc:	e0fff717 	ldw	r3,-36(fp)
811143e0:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
811143e4:	e0bfff17 	ldw	r2,-4(fp)
811143e8:	10c00117 	ldw	r3,4(r2)
811143ec:	008004b4 	movhi	r2,18
811143f0:	10a40004 	addi	r2,r2,-28672
811143f4:	1885883a 	add	r2,r3,r2
811143f8:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
811143fc:	e0bfff17 	ldw	r2,-4(fp)
81114400:	10c00517 	ldw	r3,20(r2)
81114404:	008000b4 	movhi	r2,2
81114408:	10a40004 	addi	r2,r2,-28672
8111440c:	1885883a 	add	r2,r3,r2
81114410:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81114414:	e03ff845 	stb	zero,-31(fp)
81114418:	00001906 	br	81114480 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111441c:	e0bff843 	ldbu	r2,-31(fp)
81114420:	e0ffff17 	ldw	r3,-4(fp)
81114424:	10800624 	muli	r2,r2,24
81114428:	1885883a 	add	r2,r3,r2
8111442c:	10800904 	addi	r2,r2,36
81114430:	e0fff917 	ldw	r3,-28(fp)
81114434:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81114438:	e0fff917 	ldw	r3,-28(fp)
8111443c:	e0bffe17 	ldw	r2,-8(fp)
81114440:	1885883a 	add	r2,r3,r2
81114444:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
81114448:	e0bff843 	ldbu	r2,-31(fp)
8111444c:	e0ffff17 	ldw	r3,-4(fp)
81114450:	10800624 	muli	r2,r2,24
81114454:	1885883a 	add	r2,r3,r2
81114458:	10800c04 	addi	r2,r2,48
8111445c:	e0fff917 	ldw	r3,-28(fp)
81114460:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81114464:	e0fff917 	ldw	r3,-28(fp)
81114468:	e0bffe17 	ldw	r2,-8(fp)
8111446c:	1885883a 	add	r2,r3,r2
81114470:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81114474:	e0bff843 	ldbu	r2,-31(fp)
81114478:	10800044 	addi	r2,r2,1
8111447c:	e0bff845 	stb	r2,-31(fp)
81114480:	e0bff843 	ldbu	r2,-31(fp)
81114484:	10800130 	cmpltui	r2,r2,4
81114488:	103fe41e 	bne	r2,zero,8111441c <__reset+0xfb0f441c>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
8111448c:	0001883a 	nop
81114490:	e037883a 	mov	sp,fp
81114494:	df000017 	ldw	fp,0(sp)
81114498:	dec00104 	addi	sp,sp,4
8111449c:	f800283a 	ret

811144a0 <vFeeSpwRMAPLoadDefault>:

/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
811144a0:	defffe04 	addi	sp,sp,-8
811144a4:	de00012e 	bgeu	sp,et,811144ac <vFeeSpwRMAPLoadDefault+0xc>
811144a8:	003b68fa 	trap	3
811144ac:	df000115 	stw	fp,4(sp)
811144b0:	df000104 	addi	fp,sp,4
811144b4:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
811144b8:	0001883a 	nop
811144bc:	e037883a 	mov	sp,fp
811144c0:	df000017 	ldw	fp,0(sp)
811144c4:	dec00104 	addi	sp,sp,4
811144c8:	f800283a 	ret

811144cc <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
811144cc:	defffe04 	addi	sp,sp,-8
811144d0:	de00012e 	bgeu	sp,et,811144d8 <vFeeSpwRMAPChangeConfig+0xc>
811144d4:	003b68fa 	trap	3
811144d8:	df000115 	stw	fp,4(sp)
811144dc:	df000104 	addi	fp,sp,4
811144e0:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
811144e4:	0001883a 	nop
811144e8:	e037883a 	mov	sp,fp
811144ec:	df000017 	ldw	fp,0(sp)
811144f0:	dec00104 	addi	sp,sp,4
811144f4:	f800283a 	ret

811144f8 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
811144f8:	defffe04 	addi	sp,sp,-8
811144fc:	de00012e 	bgeu	sp,et,81114504 <vFeeSpwRMAPChangeDefault+0xc>
81114500:	003b68fa 	trap	3
81114504:	df000115 	stw	fp,4(sp)
81114508:	df000104 	addi	fp,sp,4
8111450c:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
81114510:	0001883a 	nop
81114514:	e037883a 	mov	sp,fp
81114518:	df000017 	ldw	fp,0(sp)
8111451c:	dec00104 	addi	sp,sp,4
81114520:	f800283a 	ret

81114524 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
81114524:	defffe04 	addi	sp,sp,-8
81114528:	de00012e 	bgeu	sp,et,81114530 <cFeeSpwChannelEnable+0xc>
8111452c:	003b68fa 	trap	3
81114530:	df000115 	stw	fp,4(sp)
81114534:	df000104 	addi	fp,sp,4
81114538:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111453c:	0001883a 	nop
81114540:	e037883a 	mov	sp,fp
81114544:	df000017 	ldw	fp,0(sp)
81114548:	dec00104 	addi	sp,sp,4
8111454c:	f800283a 	ret

81114550 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
81114550:	defffe04 	addi	sp,sp,-8
81114554:	de00012e 	bgeu	sp,et,8111455c <cFeeSpwChannelDisable+0xc>
81114558:	003b68fa 	trap	3
8111455c:	df000115 	stw	fp,4(sp)
81114560:	df000104 	addi	fp,sp,4
81114564:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81114568:	0001883a 	nop
8111456c:	e037883a 	mov	sp,fp
81114570:	df000017 	ldw	fp,0(sp)
81114574:	dec00104 	addi	sp,sp,4
81114578:	f800283a 	ret

8111457c <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111457c:	defffe04 	addi	sp,sp,-8
81114580:	de00012e 	bgeu	sp,et,81114588 <cFeeRMAPDump+0xc>
81114584:	003b68fa 	trap	3
81114588:	df000115 	stw	fp,4(sp)
8111458c:	df000104 	addi	fp,sp,4
81114590:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
81114594:	0001883a 	nop
81114598:	e037883a 	mov	sp,fp
8111459c:	df000017 	ldw	fp,0(sp)
811145a0:	dec00104 	addi	sp,sp,4
811145a4:	f800283a 	ret

811145a8 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
811145a8:	defffe04 	addi	sp,sp,-8
811145ac:	de00012e 	bgeu	sp,et,811145b4 <cFeeRMAPEchoingEnable+0xc>
811145b0:	003b68fa 	trap	3
811145b4:	df000115 	stw	fp,4(sp)
811145b8:	df000104 	addi	fp,sp,4
811145bc:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
811145c0:	e0bfff17 	ldw	r2,-4(fp)
811145c4:	00c00044 	movi	r3,1
811145c8:	10c02415 	stw	r3,144(r2)
}
811145cc:	0001883a 	nop
811145d0:	e037883a 	mov	sp,fp
811145d4:	df000017 	ldw	fp,0(sp)
811145d8:	dec00104 	addi	sp,sp,4
811145dc:	f800283a 	ret

811145e0 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
811145e0:	defffe04 	addi	sp,sp,-8
811145e4:	de00012e 	bgeu	sp,et,811145ec <cFeeRMAPEchoingDisable+0xc>
811145e8:	003b68fa 	trap	3
811145ec:	df000115 	stw	fp,4(sp)
811145f0:	df000104 	addi	fp,sp,4
811145f4:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
811145f8:	e0bfff17 	ldw	r2,-4(fp)
811145fc:	10002415 	stw	zero,144(r2)
}
81114600:	0001883a 	nop
81114604:	e037883a 	mov	sp,fp
81114608:	df000017 	ldw	fp,0(sp)
8111460c:	dec00104 	addi	sp,sp,4
81114610:	f800283a 	ret

81114614 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
81114614:	defffe04 	addi	sp,sp,-8
81114618:	de00012e 	bgeu	sp,et,81114620 <cFeeRMAPLogEnable+0xc>
8111461c:	003b68fa 	trap	3
81114620:	df000115 	stw	fp,4(sp)
81114624:	df000104 	addi	fp,sp,4
81114628:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111462c:	e0bfff17 	ldw	r2,-4(fp)
81114630:	00c00044 	movi	r3,1
81114634:	10c02315 	stw	r3,140(r2)
}
81114638:	0001883a 	nop
8111463c:	e037883a 	mov	sp,fp
81114640:	df000017 	ldw	fp,0(sp)
81114644:	dec00104 	addi	sp,sp,4
81114648:	f800283a 	ret

8111464c <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111464c:	defffe04 	addi	sp,sp,-8
81114650:	de00012e 	bgeu	sp,et,81114658 <cFeeRMAPLogDisable+0xc>
81114654:	003b68fa 	trap	3
81114658:	df000115 	stw	fp,4(sp)
8111465c:	df000104 	addi	fp,sp,4
81114660:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
81114664:	e0bfff17 	ldw	r2,-4(fp)
81114668:	10002315 	stw	zero,140(r2)
}
8111466c:	0001883a 	nop
81114670:	e037883a 	mov	sp,fp
81114674:	df000017 	ldw	fp,0(sp)
81114678:	dec00104 	addi	sp,sp,4
8111467c:	f800283a 	ret

81114680 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
81114680:	defffc04 	addi	sp,sp,-16
81114684:	de00012e 	bgeu	sp,et,8111468c <vNFeeControlInit+0xc>
81114688:	003b68fa 	trap	3
8111468c:	dfc00315 	stw	ra,12(sp)
81114690:	df000215 	stw	fp,8(sp)
81114694:	df000204 	addi	fp,sp,8
81114698:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111469c:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
811146a0:	e13fff17 	ldw	r4,-4(fp)
811146a4:	11147b00 	call	811147b0 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
811146a8:	e13fff17 	ldw	r4,-4(fp)
811146ac:	11147e40 	call	811147e4 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebConfig;
811146b0:	e0bfff17 	ldw	r2,-4(fp)
811146b4:	10036715 	stw	zero,3484(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
811146b8:	e03ffe05 	stb	zero,-8(fp)
811146bc:	00002306 	br	8111474c <vNFeeControlInit+0xcc>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
811146c0:	e0bffe03 	ldbu	r2,-8(fp)
811146c4:	10808f24 	muli	r2,r2,572
811146c8:	e0ffff17 	ldw	r3,-4(fp)
811146cc:	1885883a 	add	r2,r3,r2
811146d0:	e0fffe03 	ldbu	r3,-8(fp)
811146d4:	180b883a 	mov	r5,r3
811146d8:	1009883a 	mov	r4,r2
811146dc:	11140780 	call	81114078 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
811146e0:	e0bffe03 	ldbu	r2,-8(fp)
811146e4:	e0fffe03 	ldbu	r3,-8(fp)
811146e8:	18c08f24 	muli	r3,r3,572
811146ec:	18c02104 	addi	r3,r3,132
811146f0:	e13fff17 	ldw	r4,-4(fp)
811146f4:	20c7883a 	add	r3,r4,r3
811146f8:	e13fff17 	ldw	r4,-4(fp)
811146fc:	1080d684 	addi	r2,r2,858
81114700:	1085883a 	add	r2,r2,r2
81114704:	1085883a 	add	r2,r2,r2
81114708:	2085883a 	add	r2,r4,r2
8111470c:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
81114710:	e0bffe03 	ldbu	r2,-8(fp)
81114714:	e0fffe03 	ldbu	r3,-8(fp)
81114718:	18c08f24 	muli	r3,r3,572
8111471c:	18c02604 	addi	r3,r3,152
81114720:	e13fff17 	ldw	r4,-4(fp)
81114724:	20c7883a 	add	r3,r4,r3
81114728:	e13fff17 	ldw	r4,-4(fp)
8111472c:	1080d804 	addi	r2,r2,864
81114730:	1085883a 	add	r2,r2,r2
81114734:	1085883a 	add	r2,r2,r2
81114738:	2085883a 	add	r2,r4,r2
8111473c:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebConfig;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
81114740:	e0bffe03 	ldbu	r2,-8(fp)
81114744:	10800044 	addi	r2,r2,1
81114748:	e0bffe05 	stb	r2,-8(fp)
8111474c:	e0bffe03 	ldbu	r2,-8(fp)
81114750:	108001b0 	cmpltui	r2,r2,6
81114754:	103fda1e 	bne	r2,zero,811146c0 <__reset+0xfb0f46c0>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
    }

}
81114758:	0001883a 	nop
8111475c:	e037883a 	mov	sp,fp
81114760:	dfc00117 	ldw	ra,4(sp)
81114764:	df000017 	ldw	fp,0(sp)
81114768:	dec00204 	addi	sp,sp,8
8111476c:	f800283a 	ret

81114770 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
81114770:	defffd04 	addi	sp,sp,-12
81114774:	de00012e 	bgeu	sp,et,8111477c <vSetTimeCode+0xc>
81114778:	003b68fa 	trap	3
8111477c:	df000215 	stw	fp,8(sp)
81114780:	df000204 	addi	fp,sp,8
81114784:	e13ffe15 	stw	r4,-8(fp)
81114788:	2805883a 	mov	r2,r5
8111478c:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
81114790:	e0bffe17 	ldw	r2,-8(fp)
81114794:	e0ffff03 	ldbu	r3,-4(fp)
81114798:	10c36605 	stb	r3,3480(r2)
}
8111479c:	0001883a 	nop
811147a0:	e037883a 	mov	sp,fp
811147a4:	df000017 	ldw	fp,0(sp)
811147a8:	dec00104 	addi	sp,sp,4
811147ac:	f800283a 	ret

811147b0 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
811147b0:	defffe04 	addi	sp,sp,-8
811147b4:	de00012e 	bgeu	sp,et,811147bc <vResetTimeCode+0xc>
811147b8:	003b68fa 	trap	3
811147bc:	df000115 	stw	fp,4(sp)
811147c0:	df000104 	addi	fp,sp,4
811147c4:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
811147c8:	e0bfff17 	ldw	r2,-4(fp)
811147cc:	10036605 	stb	zero,3480(r2)
}
811147d0:	0001883a 	nop
811147d4:	e037883a 	mov	sp,fp
811147d8:	df000017 	ldw	fp,0(sp)
811147dc:	dec00104 	addi	sp,sp,4
811147e0:	f800283a 	ret

811147e4 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
811147e4:	defffe04 	addi	sp,sp,-8
811147e8:	de00012e 	bgeu	sp,et,811147f0 <vLoadDefaultIdNFEEMaster+0xc>
811147ec:	003b68fa 	trap	3
811147f0:	df000115 	stw	fp,4(sp)
811147f4:	df000104 	addi	fp,sp,4
811147f8:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
811147fc:	e0bfff17 	ldw	r2,-4(fp)
81114800:	10036645 	stb	zero,3481(r2)
}
81114804:	0001883a 	nop
81114808:	e037883a 	mov	sp,fp
8111480c:	df000017 	ldw	fp,0(sp)
81114810:	dec00104 	addi	sp,sp,4
81114814:	f800283a 	ret

81114818 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
81114818:	defffd04 	addi	sp,sp,-12
8111481c:	de00012e 	bgeu	sp,et,81114824 <vChangeIdNFEEMaster+0xc>
81114820:	003b68fa 	trap	3
81114824:	df000215 	stw	fp,8(sp)
81114828:	df000204 	addi	fp,sp,8
8111482c:	e13ffe15 	stw	r4,-8(fp)
81114830:	2805883a 	mov	r2,r5
81114834:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
81114838:	e0bffe17 	ldw	r2,-8(fp)
8111483c:	e0ffff03 	ldbu	r3,-4(fp)
81114840:	10c36645 	stb	r3,3481(r2)
}
81114844:	0001883a 	nop
81114848:	e037883a 	mov	sp,fp
8111484c:	df000017 	ldw	fp,0(sp)
81114850:	dec00104 	addi	sp,sp,4
81114854:	f800283a 	ret

81114858 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
81114858:	defffd04 	addi	sp,sp,-12
8111485c:	de00012e 	bgeu	sp,et,81114864 <vChangeDefaultIdNFEEMaster+0xc>
81114860:	003b68fa 	trap	3
81114864:	df000215 	stw	fp,8(sp)
81114868:	df000204 	addi	fp,sp,8
8111486c:	e13ffe15 	stw	r4,-8(fp)
81114870:	2805883a 	mov	r2,r5
81114874:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
81114878:	0001883a 	nop
8111487c:	e037883a 	mov	sp,fp
81114880:	df000017 	ldw	fp,0(sp)
81114884:	dec00104 	addi	sp,sp,4
81114888:	f800283a 	ret

8111488c <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111488c:	defffe04 	addi	sp,sp,-8
81114890:	de00012e 	bgeu	sp,et,81114898 <vInitSimucamBasicHW+0xc>
81114894:	003b68fa 	trap	3
81114898:	dfc00115 	stw	ra,4(sp)
8111489c:	df000015 	stw	fp,0(sp)
811148a0:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
811148a4:	01403fc4 	movi	r5,255
811148a8:	0009883a 	mov	r4,zero
811148ac:	11061200 	call	81106120 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
811148b0:	01400834 	movhi	r5,32
811148b4:	297fffc4 	addi	r5,r5,-1
811148b8:	0009883a 	mov	r4,zero
811148bc:	11061a00 	call	811061a0 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
811148c0:	01400074 	movhi	r5,1
811148c4:	01000044 	movi	r4,1
811148c8:	11061a00 	call	811061a0 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
811148cc:	0009883a 	mov	r4,zero
811148d0:	110777c0 	call	8110777c <bSSDisplayConfig>
	bSSDisplayUpdate(0);
811148d4:	0009883a 	mov	r4,zero
811148d8:	110784c0 	call	8110784c <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
811148dc:	01008004 	movi	r4,512
811148e0:	11072dc0 	call	811072dc <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
811148e4:	01008004 	movi	r4,512
811148e8:	11072680 	call	81107268 <vRstcReleaseDeviceReset>

}
811148ec:	0001883a 	nop
811148f0:	e037883a 	mov	sp,fp
811148f4:	dfc00117 	ldw	ra,4(sp)
811148f8:	df000017 	ldw	fp,0(sp)
811148fc:	dec00204 	addi	sp,sp,8
81114900:	f800283a 	ret

81114904 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
81114904:	defffd04 	addi	sp,sp,-12
81114908:	de00012e 	bgeu	sp,et,81114910 <bLogWriteSDCard+0xc>
8111490c:	003b68fa 	trap	3
81114910:	df000215 	stw	fp,8(sp)
81114914:	df000204 	addi	fp,sp,8
81114918:	e13ffe15 	stw	r4,-8(fp)
8111491c:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
81114920:	00800044 	movi	r2,1
}
81114924:	e037883a 	mov	sp,fp
81114928:	df000017 	ldw	fp,0(sp)
8111492c:	dec00104 	addi	sp,sp,4
81114930:	f800283a 	ret

81114934 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
81114934:	deffe004 	addi	sp,sp,-128
81114938:	de00012e 	bgeu	sp,et,81114940 <vLogWriteNUC+0xc>
8111493c:	003b68fa 	trap	3
81114940:	dfc01f15 	stw	ra,124(sp)
81114944:	df001e15 	stw	fp,120(sp)
81114948:	df001e04 	addi	fp,sp,120
8111494c:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
81114950:	e03fe215 	stw	zero,-120(fp)
81114954:	e0bfe304 	addi	r2,fp,-116
81114958:	00c01b84 	movi	r3,110
8111495c:	180d883a 	mov	r6,r3
81114960:	000b883a 	mov	r5,zero
81114964:	1009883a 	mov	r4,r2
81114968:	1117e1c0 	call	81117e1c <memset>
	memset(cTemp,0,114);
8111496c:	01801c84 	movi	r6,114
81114970:	000b883a 	mov	r5,zero
81114974:	e13fe204 	addi	r4,fp,-120
81114978:	1117e1c0 	call	81117e1c <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111497c:	e13fff17 	ldw	r4,-4(fp)
81114980:	11187c00 	call	811187c0 <strlen>
81114984:	10801c68 	cmpgeui	r2,r2,113
81114988:	1000031e 	bne	r2,zero,81114998 <vLogWriteNUC+0x64>
8111498c:	e13fff17 	ldw	r4,-4(fp)
81114990:	11187c00 	call	811187c0 <strlen>
81114994:	00000106 	br	8111499c <vLogWriteNUC+0x68>
81114998:	00801c44 	movi	r2,113
8111499c:	100d883a 	mov	r6,r2
811149a0:	e17fff17 	ldw	r5,-4(fp)
811149a4:	e13fe204 	addi	r4,fp,-120
811149a8:	1117ccc0 	call	81117ccc <memcpy>
	vSendLog ( cDataIn );
811149ac:	e13fff17 	ldw	r4,-4(fp)
811149b0:	1110e600 	call	81110e60 <vSendLog>
}
811149b4:	0001883a 	nop
811149b8:	e037883a 	mov	sp,fp
811149bc:	dfc00117 	ldw	ra,4(sp)
811149c0:	df000017 	ldw	fp,0(sp)
811149c4:	dec00204 	addi	sp,sp,8
811149c8:	f800283a 	ret

811149cc <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
811149cc:	defffd04 	addi	sp,sp,-12
811149d0:	de00012e 	bgeu	sp,et,811149d8 <vSimucamStructureInit+0xc>
811149d4:	003b68fa 	trap	3
811149d8:	dfc00215 	stw	ra,8(sp)
811149dc:	df000115 	stw	fp,4(sp)
811149e0:	df000104 	addi	fp,sp,4
811149e4:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
811149e8:	e0bfff17 	ldw	r2,-4(fp)
811149ec:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebConfig;
811149f0:	e0bfff17 	ldw	r2,-4(fp)
811149f4:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
811149f8:	e13fff17 	ldw	r4,-4(fp)
811149fc:	1114a800 	call	81114a80 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
81114a00:	e13fff17 	ldw	r4,-4(fp)
81114a04:	1114b240 	call	81114b24 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
81114a08:	e13fff17 	ldw	r4,-4(fp)
81114a0c:	1114bcc0 	call	81114bcc <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
81114a10:	e13fff17 	ldw	r4,-4(fp)
81114a14:	1114c6c0 	call	81114c6c <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
81114a18:	e0bfff17 	ldw	r2,-4(fp)
81114a1c:	10000515 	stw	zero,20(r2)
    xMeb->fPixelTransferTime = 0;
81114a20:	e0bfff17 	ldw	r2,-4(fp)
81114a24:	10000615 	stw	zero,24(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
81114a28:	e0bfff17 	ldw	r2,-4(fp)
81114a2c:	10800017 	ldw	r2,0(r2)
81114a30:	10000b1e 	bne	r2,zero,81114a60 <vSimucamStructureInit+0x94>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
81114a34:	e0bfff17 	ldw	r2,-4(fp)
81114a38:	10801f04 	addi	r2,r2,124
81114a3c:	1009883a 	mov	r4,r2
81114a40:	11146800 	call	81114680 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
81114a44:	e0bfff17 	ldw	r2,-4(fp)
81114a48:	10c00904 	addi	r3,r2,36
81114a4c:	e0bfff17 	ldw	r2,-4(fp)
81114a50:	10801f04 	addi	r2,r2,124
81114a54:	100b883a 	mov	r5,r2
81114a58:	1809883a 	mov	r4,r3
81114a5c:	111222c0 	call	8111222c <vDataControllerInit>
        /* todo: Not in use yet */
    }


    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
81114a60:	e0bfff17 	ldw	r2,-4(fp)
81114a64:	10000205 	stb	zero,8(r2)

    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
81114a68:	0001883a 	nop
81114a6c:	e037883a 	mov	sp,fp
81114a70:	dfc00117 	ldw	ra,4(sp)
81114a74:	df000017 	ldw	fp,0(sp)
81114a78:	dec00204 	addi	sp,sp,8
81114a7c:	f800283a 	ret

81114a80 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
81114a80:	defffe04 	addi	sp,sp,-8
81114a84:	de00012e 	bgeu	sp,et,81114a8c <vLoadDefaultEPValue+0xc>
81114a88:	003b68fa 	trap	3
81114a8c:	df000115 	stw	fp,4(sp)
81114a90:	df000104 	addi	fp,sp,4
81114a94:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
81114a98:	e0bfff17 	ldw	r2,-4(fp)
81114a9c:	00d07234 	movhi	r3,16840
81114aa0:	10c00315 	stw	r3,12(r2)
}
81114aa4:	0001883a 	nop
81114aa8:	e037883a 	mov	sp,fp
81114aac:	df000017 	ldw	fp,0(sp)
81114ab0:	dec00104 	addi	sp,sp,4
81114ab4:	f800283a 	ret

81114ab8 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81114ab8:	defffd04 	addi	sp,sp,-12
81114abc:	de00012e 	bgeu	sp,et,81114ac4 <vChangeEPValue+0xc>
81114ac0:	003b68fa 	trap	3
81114ac4:	df000215 	stw	fp,8(sp)
81114ac8:	df000204 	addi	fp,sp,8
81114acc:	e13ffe15 	stw	r4,-8(fp)
81114ad0:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
81114ad4:	e0bffe17 	ldw	r2,-8(fp)
81114ad8:	e0ffff17 	ldw	r3,-4(fp)
81114adc:	10c00315 	stw	r3,12(r2)
}
81114ae0:	0001883a 	nop
81114ae4:	e037883a 	mov	sp,fp
81114ae8:	df000017 	ldw	fp,0(sp)
81114aec:	dec00104 	addi	sp,sp,4
81114af0:	f800283a 	ret

81114af4 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81114af4:	defffd04 	addi	sp,sp,-12
81114af8:	de00012e 	bgeu	sp,et,81114b00 <vChangeDefaultEPValue+0xc>
81114afc:	003b68fa 	trap	3
81114b00:	df000215 	stw	fp,8(sp)
81114b04:	df000204 	addi	fp,sp,8
81114b08:	e13ffe15 	stw	r4,-8(fp)
81114b0c:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
81114b10:	0001883a 	nop
81114b14:	e037883a 	mov	sp,fp
81114b18:	df000017 	ldw	fp,0(sp)
81114b1c:	dec00104 	addi	sp,sp,4
81114b20:	f800283a 	ret

81114b24 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
81114b24:	defffe04 	addi	sp,sp,-8
81114b28:	de00012e 	bgeu	sp,et,81114b30 <vLoadDefaultRTValue+0xc>
81114b2c:	003b68fa 	trap	3
81114b30:	df000115 	stw	fp,4(sp)
81114b34:	df000104 	addi	fp,sp,4
81114b38:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
81114b3c:	e0ffff17 	ldw	r3,-4(fp)
81114b40:	00901eb4 	movhi	r2,16506
81114b44:	10a66684 	addi	r2,r2,-26214
81114b48:	18800415 	stw	r2,16(r3)
}
81114b4c:	0001883a 	nop
81114b50:	e037883a 	mov	sp,fp
81114b54:	df000017 	ldw	fp,0(sp)
81114b58:	dec00104 	addi	sp,sp,4
81114b5c:	f800283a 	ret

81114b60 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81114b60:	defffd04 	addi	sp,sp,-12
81114b64:	de00012e 	bgeu	sp,et,81114b6c <vChangeRTValue+0xc>
81114b68:	003b68fa 	trap	3
81114b6c:	df000215 	stw	fp,8(sp)
81114b70:	df000204 	addi	fp,sp,8
81114b74:	e13ffe15 	stw	r4,-8(fp)
81114b78:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
81114b7c:	e0bffe17 	ldw	r2,-8(fp)
81114b80:	e0ffff17 	ldw	r3,-4(fp)
81114b84:	10c00415 	stw	r3,16(r2)
}
81114b88:	0001883a 	nop
81114b8c:	e037883a 	mov	sp,fp
81114b90:	df000017 	ldw	fp,0(sp)
81114b94:	dec00104 	addi	sp,sp,4
81114b98:	f800283a 	ret

81114b9c <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81114b9c:	defffd04 	addi	sp,sp,-12
81114ba0:	de00012e 	bgeu	sp,et,81114ba8 <vChangeDefaultRTValue+0xc>
81114ba4:	003b68fa 	trap	3
81114ba8:	df000215 	stw	fp,8(sp)
81114bac:	df000204 	addi	fp,sp,8
81114bb0:	e13ffe15 	stw	r4,-8(fp)
81114bb4:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
81114bb8:	0001883a 	nop
81114bbc:	e037883a 	mov	sp,fp
81114bc0:	df000017 	ldw	fp,0(sp)
81114bc4:	dec00104 	addi	sp,sp,4
81114bc8:	f800283a 	ret

81114bcc <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
81114bcc:	defffe04 	addi	sp,sp,-8
81114bd0:	de00012e 	bgeu	sp,et,81114bd8 <vLoadDefaultSyncSource+0xc>
81114bd4:	003b68fa 	trap	3
81114bd8:	df000115 	stw	fp,4(sp)
81114bdc:	df000104 	addi	fp,sp,4
81114be0:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
81114be4:	e0bfff17 	ldw	r2,-4(fp)
81114be8:	10000715 	stw	zero,28(r2)
}
81114bec:	0001883a 	nop
81114bf0:	e037883a 	mov	sp,fp
81114bf4:	df000017 	ldw	fp,0(sp)
81114bf8:	dec00104 	addi	sp,sp,4
81114bfc:	f800283a 	ret

81114c00 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
81114c00:	defffd04 	addi	sp,sp,-12
81114c04:	de00012e 	bgeu	sp,et,81114c0c <vChangeSyncSource+0xc>
81114c08:	003b68fa 	trap	3
81114c0c:	df000215 	stw	fp,8(sp)
81114c10:	df000204 	addi	fp,sp,8
81114c14:	e13ffe15 	stw	r4,-8(fp)
81114c18:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
81114c1c:	e0bffe17 	ldw	r2,-8(fp)
81114c20:	e0ffff17 	ldw	r3,-4(fp)
81114c24:	10c00715 	stw	r3,28(r2)
}
81114c28:	0001883a 	nop
81114c2c:	e037883a 	mov	sp,fp
81114c30:	df000017 	ldw	fp,0(sp)
81114c34:	dec00104 	addi	sp,sp,4
81114c38:	f800283a 	ret

81114c3c <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
81114c3c:	defffd04 	addi	sp,sp,-12
81114c40:	de00012e 	bgeu	sp,et,81114c48 <vChangeDefaultSyncSource+0xc>
81114c44:	003b68fa 	trap	3
81114c48:	df000215 	stw	fp,8(sp)
81114c4c:	df000204 	addi	fp,sp,8
81114c50:	e13ffe15 	stw	r4,-8(fp)
81114c54:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
81114c58:	0001883a 	nop
81114c5c:	e037883a 	mov	sp,fp
81114c60:	df000017 	ldw	fp,0(sp)
81114c64:	dec00104 	addi	sp,sp,4
81114c68:	f800283a 	ret

81114c6c <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
81114c6c:	defffe04 	addi	sp,sp,-8
81114c70:	de00012e 	bgeu	sp,et,81114c78 <vLoadDefaultAutoResetSync+0xc>
81114c74:	003b68fa 	trap	3
81114c78:	df000115 	stw	fp,4(sp)
81114c7c:	df000104 	addi	fp,sp,4
81114c80:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoRestSyncMode = TRUE;
81114c84:	e0bfff17 	ldw	r2,-4(fp)
81114c88:	00c00044 	movi	r3,1
81114c8c:	10c00815 	stw	r3,32(r2)
}
81114c90:	0001883a 	nop
81114c94:	e037883a 	mov	sp,fp
81114c98:	df000017 	ldw	fp,0(sp)
81114c9c:	dec00104 	addi	sp,sp,4
81114ca0:	f800283a 	ret

81114ca4 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81114ca4:	defffd04 	addi	sp,sp,-12
81114ca8:	de00012e 	bgeu	sp,et,81114cb0 <vChangeAutoResetSync+0xc>
81114cac:	003b68fa 	trap	3
81114cb0:	df000215 	stw	fp,8(sp)
81114cb4:	df000204 	addi	fp,sp,8
81114cb8:	e13ffe15 	stw	r4,-8(fp)
81114cbc:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoRestSyncMode = bAutoReset;
81114cc0:	e0bffe17 	ldw	r2,-8(fp)
81114cc4:	e0ffff17 	ldw	r3,-4(fp)
81114cc8:	10c00815 	stw	r3,32(r2)
}
81114ccc:	0001883a 	nop
81114cd0:	e037883a 	mov	sp,fp
81114cd4:	df000017 	ldw	fp,0(sp)
81114cd8:	dec00104 	addi	sp,sp,4
81114cdc:	f800283a 	ret

81114ce0 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81114ce0:	defffd04 	addi	sp,sp,-12
81114ce4:	de00012e 	bgeu	sp,et,81114cec <vChangeDefaultAutoResetSync+0xc>
81114ce8:	003b68fa 	trap	3
81114cec:	df000215 	stw	fp,8(sp)
81114cf0:	df000204 	addi	fp,sp,8
81114cf4:	e13ffe15 	stw	r4,-8(fp)
81114cf8:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
81114cfc:	0001883a 	nop
81114d00:	e037883a 	mov	sp,fp
81114d04:	df000017 	ldw	fp,0(sp)
81114d08:	dec00104 	addi	sp,sp,4
81114d0c:	f800283a 	ret

81114d10 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
81114d10:	defffc04 	addi	sp,sp,-16
81114d14:	de00012e 	bgeu	sp,et,81114d1c <vSyncReset+0xc>
81114d18:	003b68fa 	trap	3
81114d1c:	dfc00315 	stw	ra,12(sp)
81114d20:	df000215 	stw	fp,8(sp)
81114d24:	df000204 	addi	fp,sp,8
81114d28:	e13ffe15 	stw	r4,-8(fp)
81114d2c:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
81114d30:	e0bffe17 	ldw	r2,-8(fp)
81114d34:	10801f04 	addi	r2,r2,124
81114d38:	1009883a 	mov	r4,r2
81114d3c:	11147b00 	call	811147b0 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
81114d40:	0001883a 	nop
81114d44:	e037883a 	mov	sp,fp
81114d48:	dfc00117 	ldw	ra,4(sp)
81114d4c:	df000017 	ldw	fp,0(sp)
81114d50:	dec00204 	addi	sp,sp,8
81114d54:	f800283a 	ret

81114d58 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
81114d58:	defff004 	addi	sp,sp,-64
81114d5c:	de00012e 	bgeu	sp,et,81114d64 <pattern_createPattern+0xc>
81114d60:	003b68fa 	trap	3
81114d64:	dfc00f15 	stw	ra,60(sp)
81114d68:	df000e15 	stw	fp,56(sp)
81114d6c:	dcc00d15 	stw	r19,52(sp)
81114d70:	dc800c15 	stw	r18,48(sp)
81114d74:	dc400b15 	stw	r17,44(sp)
81114d78:	dc000a15 	stw	r16,40(sp)
81114d7c:	df000e04 	addi	fp,sp,56
81114d80:	e17ff915 	stw	r5,-28(fp)
81114d84:	3007883a 	mov	r3,r6
81114d88:	3805883a 	mov	r2,r7
81114d8c:	e13ff805 	stb	r4,-32(fp)
81114d90:	e0fffa05 	stb	r3,-24(fp)
81114d94:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
81114d98:	e0bff803 	ldbu	r2,-32(fp)
81114d9c:	1009883a 	mov	r4,r2
81114da0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
81114da4:	e0bff917 	ldw	r2,-28(fp)
81114da8:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
81114dac:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
81114db0:	e0bff217 	ldw	r2,-56(fp)
81114db4:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
81114db8:	e03ff515 	stw	zero,-44(fp)
81114dbc:	00003606 	br	81114e98 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81114dc0:	e03ff615 	stw	zero,-40(fp)
81114dc4:	00002e06 	br	81114e80 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
81114dc8:	e0bff303 	ldbu	r2,-52(fp)
81114dcc:	10801018 	cmpnei	r2,r2,64
81114dd0:	10000b1e 	bne	r2,zero,81114e00 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
81114dd4:	e0bff417 	ldw	r2,-48(fp)
81114dd8:	00ffffc4 	movi	r3,-1
81114ddc:	10c02015 	stw	r3,128(r2)
81114de0:	00ffffc4 	movi	r3,-1
81114de4:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
81114de8:	e0bff217 	ldw	r2,-56(fp)
81114dec:	10802204 	addi	r2,r2,136
81114df0:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
81114df4:	e0bff217 	ldw	r2,-56(fp)
81114df8:	e0bff415 	stw	r2,-48(fp)
				i = 0;
81114dfc:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
81114e00:	e0bff303 	ldbu	r2,-52(fp)
81114e04:	10c00044 	addi	r3,r2,1
81114e08:	e0fff305 	stb	r3,-52(fp)
81114e0c:	10803fcc 	andi	r2,r2,255
81114e10:	e0fffa03 	ldbu	r3,-24(fp)
81114e14:	18c000cc 	andi	r3,r3,3
81114e18:	180692fa 	slli	r3,r3,11
81114e1c:	1809883a 	mov	r4,r3
81114e20:	00f80004 	movi	r3,-8192
81114e24:	20c6b03a 	or	r3,r4,r3
81114e28:	1809883a 	mov	r4,r3
81114e2c:	e0fffb03 	ldbu	r3,-20(fp)
81114e30:	18c0004c 	andi	r3,r3,1
81114e34:	180692ba 	slli	r3,r3,10
81114e38:	20c6b03a 	or	r3,r4,r3
81114e3c:	1809883a 	mov	r4,r3
81114e40:	e0fff517 	ldw	r3,-44(fp)
81114e44:	18c007cc 	andi	r3,r3,31
81114e48:	1806917a 	slli	r3,r3,5
81114e4c:	20c6b03a 	or	r3,r4,r3
81114e50:	1809883a 	mov	r4,r3
81114e54:	e0fff617 	ldw	r3,-40(fp)
81114e58:	18c007cc 	andi	r3,r3,31
81114e5c:	20c6b03a 	or	r3,r4,r3
81114e60:	1809883a 	mov	r4,r3
81114e64:	e0fff417 	ldw	r3,-48(fp)
81114e68:	1085883a 	add	r2,r2,r2
81114e6c:	1885883a 	add	r2,r3,r2
81114e70:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81114e74:	e0bff617 	ldw	r2,-40(fp)
81114e78:	10800044 	addi	r2,r2,1
81114e7c:	e0bff615 	stw	r2,-40(fp)
81114e80:	e0fff617 	ldw	r3,-40(fp)
81114e84:	e0800217 	ldw	r2,8(fp)
81114e88:	18bfcf36 	bltu	r3,r2,81114dc8 <__reset+0xfb0f4dc8>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
81114e8c:	e0bff517 	ldw	r2,-44(fp)
81114e90:	10800044 	addi	r2,r2,1
81114e94:	e0bff515 	stw	r2,-44(fp)
81114e98:	e0fff517 	ldw	r3,-44(fp)
81114e9c:	e0800317 	ldw	r2,12(fp)
81114ea0:	18bfc736 	bltu	r3,r2,81114dc0 <__reset+0xfb0f4dc0>
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
81114ea4:	e0bff303 	ldbu	r2,-52(fp)
81114ea8:	e0bff705 	stb	r2,-36(fp)
81114eac:	00000806 	br	81114ed0 <pattern_createPattern+0x178>
	{
		pxPixelData->usiPixel[j] = 0;
81114eb0:	e0bff703 	ldbu	r2,-36(fp)
81114eb4:	e0fff417 	ldw	r3,-48(fp)
81114eb8:	1085883a 	add	r2,r2,r2
81114ebc:	1885883a 	add	r2,r3,r2
81114ec0:	1000000d 	sth	zero,0(r2)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
81114ec4:	e0bff703 	ldbu	r2,-36(fp)
81114ec8:	10800044 	addi	r2,r2,1
81114ecc:	e0bff705 	stb	r2,-36(fp)
81114ed0:	e0bff703 	ldbu	r2,-36(fp)
81114ed4:	10801030 	cmpltui	r2,r2,64
81114ed8:	103ff51e 	bne	r2,zero,81114eb0 <__reset+0xfb0f4eb0>
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
81114edc:	e0bff417 	ldw	r2,-48(fp)
81114ee0:	10002015 	stw	zero,128(r2)
81114ee4:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
81114ee8:	e03ff745 	stb	zero,-35(fp)
81114eec:	00001106 	br	81114f34 <pattern_createPattern+0x1dc>
	{
		pxPixelData->ulliMask |= 1 << j;
81114ef0:	e13ff417 	ldw	r4,-48(fp)
81114ef4:	20802017 	ldw	r2,128(r4)
81114ef8:	20c02117 	ldw	r3,132(r4)
81114efc:	e13ff743 	ldbu	r4,-35(fp)
81114f00:	01400044 	movi	r5,1
81114f04:	2908983a 	sll	r4,r5,r4
81114f08:	2025883a 	mov	r18,r4
81114f0c:	2009d7fa 	srai	r4,r4,31
81114f10:	2027883a 	mov	r19,r4
81114f14:	14a0b03a 	or	r16,r2,r18
81114f18:	1ce2b03a 	or	r17,r3,r19
81114f1c:	e0bff417 	ldw	r2,-48(fp)
81114f20:	14002015 	stw	r16,128(r2)
81114f24:	14402115 	stw	r17,132(r2)
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
81114f28:	e0bff743 	ldbu	r2,-35(fp)
81114f2c:	10800044 	addi	r2,r2,1
81114f30:	e0bff745 	stb	r2,-35(fp)
81114f34:	e0fff743 	ldbu	r3,-35(fp)
81114f38:	e0bff303 	ldbu	r2,-52(fp)
81114f3c:	18bfec36 	bltu	r3,r2,81114ef0 <__reset+0xfb0f4ef0>
	{
		pxPixelData->ulliMask |= 1 << j;
	}
	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
81114f40:	e0bff217 	ldw	r2,-56(fp)
81114f44:	10802204 	addi	r2,r2,136
81114f48:	e0bff215 	stw	r2,-56(fp)
	return offset;
81114f4c:	e0bff217 	ldw	r2,-56(fp)
}
81114f50:	e6fffc04 	addi	sp,fp,-16
81114f54:	dfc00517 	ldw	ra,20(sp)
81114f58:	df000417 	ldw	fp,16(sp)
81114f5c:	dcc00317 	ldw	r19,12(sp)
81114f60:	dc800217 	ldw	r18,8(sp)
81114f64:	dc400117 	ldw	r17,4(sp)
81114f68:	dc000017 	ldw	r16,0(sp)
81114f6c:	dec00604 	addi	sp,sp,24
81114f70:	f800283a 	ret

81114f74 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
81114f74:	defffe04 	addi	sp,sp,-8
81114f78:	de00012e 	bgeu	sp,et,81114f80 <bSDcardIsPresent+0xc>
81114f7c:	003b68fa 	trap	3
81114f80:	dfc00115 	stw	ra,4(sp)
81114f84:	df000015 	stw	fp,0(sp)
81114f88:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
81114f8c:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
}
81114f90:	e037883a 	mov	sp,fp
81114f94:	dfc00117 	ldw	ra,4(sp)
81114f98:	df000017 	ldw	fp,0(sp)
81114f9c:	dec00204 	addi	sp,sp,8
81114fa0:	f800283a 	ret

81114fa4 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
81114fa4:	defffe04 	addi	sp,sp,-8
81114fa8:	de00012e 	bgeu	sp,et,81114fb0 <bSDcardFAT16Check+0xc>
81114fac:	003b68fa 	trap	3
81114fb0:	dfc00115 	stw	ra,4(sp)
81114fb4:	df000015 	stw	fp,0(sp)
81114fb8:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
81114fbc:	113b0500 	call	8113b050 <alt_up_sd_card_is_FAT16>
}
81114fc0:	e037883a 	mov	sp,fp
81114fc4:	dfc00117 	ldw	ra,4(sp)
81114fc8:	df000017 	ldw	fp,0(sp)
81114fcc:	dec00204 	addi	sp,sp,8
81114fd0:	f800283a 	ret

81114fd4 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
81114fd4:	defffd04 	addi	sp,sp,-12
81114fd8:	de00012e 	bgeu	sp,et,81114fe0 <bInitializeSDCard+0xc>
81114fdc:	003b68fa 	trap	3
81114fe0:	dfc00215 	stw	ra,8(sp)
81114fe4:	df000115 	stw	fp,4(sp)
81114fe8:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
81114fec:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
81114ff0:	d0206815 	stw	zero,-32352(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
81114ff4:	01204534 	movhi	r4,33044
81114ff8:	21160204 	addi	r4,r4,22536
81114ffc:	113aec00 	call	8113aec0 <alt_up_sd_card_open_dev>
81115000:	d0a06815 	stw	r2,-32352(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
81115004:	d0a06817 	ldw	r2,-32352(gp)
81115008:	10002226 	beq	r2,zero,81115094 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111500c:	1114f740 	call	81114f74 <bSDcardIsPresent>
81115010:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
81115014:	e0bfff17 	ldw	r2,-4(fp)
81115018:	10001626 	beq	r2,zero,81115074 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111501c:	1114fa40 	call	81114fa4 <bSDcardFAT16Check>
81115020:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
81115024:	e0bfff17 	ldw	r2,-4(fp)
81115028:	10000a26 	beq	r2,zero,81115054 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111502c:	00800044 	movi	r2,1
81115030:	d0a06715 	stw	r2,-32356(gp)
				debug(fp, "SD is up.\r\n");
81115034:	d0a05517 	ldw	r2,-32428(gp)
81115038:	100f883a 	mov	r7,r2
8111503c:	018002c4 	movi	r6,11
81115040:	01400044 	movi	r5,1
81115044:	01204534 	movhi	r4,33044
81115048:	21160d04 	addi	r4,r4,22580
8111504c:	11172b80 	call	811172b8 <fwrite>
81115050:	00001806 	br	811150b4 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
81115054:	d0a05517 	ldw	r2,-32428(gp)
81115058:	100f883a 	mov	r7,r2
8111505c:	01800984 	movi	r6,38
81115060:	01400044 	movi	r5,1
81115064:	01204534 	movhi	r4,33044
81115068:	21161004 	addi	r4,r4,22592
8111506c:	11172b80 	call	811172b8 <fwrite>
81115070:	00001006 	br	811150b4 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
81115074:	d0a05517 	ldw	r2,-32428(gp)
81115078:	100f883a 	mov	r7,r2
8111507c:	01800744 	movi	r6,29
81115080:	01400044 	movi	r5,1
81115084:	01204534 	movhi	r4,33044
81115088:	21161a04 	addi	r4,r4,22632
8111508c:	11172b80 	call	811172b8 <fwrite>
81115090:	00000806 	br	811150b4 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
81115094:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
81115098:	d0a05517 	ldw	r2,-32428(gp)
8111509c:	100f883a 	mov	r7,r2
811150a0:	018008c4 	movi	r6,35
811150a4:	01400044 	movi	r5,1
811150a8:	01204534 	movhi	r4,33044
811150ac:	21162204 	addi	r4,r4,22664
811150b0:	11172b80 	call	811172b8 <fwrite>
	}

	return bSucess;
811150b4:	e0bfff17 	ldw	r2,-4(fp)
}
811150b8:	e037883a 	mov	sp,fp
811150bc:	dfc00117 	ldw	ra,4(sp)
811150c0:	df000017 	ldw	fp,0(sp)
811150c4:	dec00204 	addi	sp,sp,8
811150c8:	f800283a 	ret

811150cc <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
811150cc:	defffd04 	addi	sp,sp,-12
811150d0:	de00012e 	bgeu	sp,et,811150d8 <siOpenFile+0xc>
811150d4:	003b68fa 	trap	3
811150d8:	dfc00215 	stw	ra,8(sp)
811150dc:	df000115 	stw	fp,4(sp)
811150e0:	df000104 	addi	fp,sp,4
811150e4:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
811150e8:	000b883a 	mov	r5,zero
811150ec:	e13fff17 	ldw	r4,-4(fp)
811150f0:	113b55c0 	call	8113b55c <alt_up_sd_card_fopen>
}
811150f4:	e037883a 	mov	sp,fp
811150f8:	dfc00117 	ldw	ra,4(sp)
811150fc:	df000017 	ldw	fp,0(sp)
81115100:	dec00204 	addi	sp,sp,8
81115104:	f800283a 	ret

81115108 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
81115108:	defffd04 	addi	sp,sp,-12
8111510c:	de00012e 	bgeu	sp,et,81115114 <siCloseFile+0xc>
81115110:	003b68fa 	trap	3
81115114:	dfc00215 	stw	ra,8(sp)
81115118:	df000115 	stw	fp,4(sp)
8111511c:	df000104 	addi	fp,sp,4
81115120:	2005883a 	mov	r2,r4
81115124:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
81115128:	e0bfff0f 	ldh	r2,-4(fp)
8111512c:	1009883a 	mov	r4,r2
81115130:	113c3a80 	call	8113c3a8 <alt_up_sd_card_fclose>
}
81115134:	e037883a 	mov	sp,fp
81115138:	dfc00117 	ldw	ra,4(sp)
8111513c:	df000017 	ldw	fp,0(sp)
81115140:	dec00204 	addi	sp,sp,8
81115144:	f800283a 	ret

81115148 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
81115148:	defffd04 	addi	sp,sp,-12
8111514c:	de00012e 	bgeu	sp,et,81115154 <cGetNextChar+0xc>
81115150:	003b68fa 	trap	3
81115154:	dfc00215 	stw	ra,8(sp)
81115158:	df000115 	stw	fp,4(sp)
8111515c:	df000104 	addi	fp,sp,4
81115160:	2005883a 	mov	r2,r4
81115164:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
81115168:	e0bfff0f 	ldh	r2,-4(fp)
8111516c:	1009883a 	mov	r4,r2
81115170:	113ba000 	call	8113ba00 <alt_up_sd_card_read>
}
81115174:	e037883a 	mov	sp,fp
81115178:	dfc00117 	ldw	ra,4(sp)
8111517c:	df000017 	ldw	fp,0(sp)
81115180:	dec00204 	addi	sp,sp,8
81115184:	f800283a 	ret

81115188 <bTestSimucamCriticalHW>:


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void )
{
81115188:	deffff04 	addi	sp,sp,-4
8111518c:	de00012e 	bgeu	sp,et,81115194 <bTestSimucamCriticalHW+0xc>
81115190:	003b68fa 	trap	3
81115194:	df000015 	stw	fp,0(sp)
81115198:	d839883a 	mov	fp,sp
	 * SDcard para criar logs e pegar defaults
	 */



	return TRUE;
8111519c:	00800044 	movi	r2,1
}
811151a0:	e037883a 	mov	sp,fp
811151a4:	df000017 	ldw	fp,0(sp)
811151a8:	dec00104 	addi	sp,sp,4
811151ac:	f800283a 	ret

811151b0 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
811151b0:	defffc04 	addi	sp,sp,-16
811151b4:	de00012e 	bgeu	sp,et,811151bc <_reg_write+0xc>
811151b8:	003b68fa 	trap	3
811151bc:	df000315 	stw	fp,12(sp)
811151c0:	df000304 	addi	fp,sp,12
811151c4:	e13ffd15 	stw	r4,-12(fp)
811151c8:	e17ffe15 	stw	r5,-8(fp)
811151cc:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
811151d0:	e0bffe17 	ldw	r2,-8(fp)
811151d4:	1085883a 	add	r2,r2,r2
811151d8:	1085883a 	add	r2,r2,r2
811151dc:	1007883a 	mov	r3,r2
811151e0:	e0bffd17 	ldw	r2,-12(fp)
811151e4:	1885883a 	add	r2,r3,r2
811151e8:	1007883a 	mov	r3,r2
811151ec:	e0bfff17 	ldw	r2,-4(fp)
811151f0:	18800035 	stwio	r2,0(r3)
	return 1;
811151f4:	00800044 	movi	r2,1

}
811151f8:	e037883a 	mov	sp,fp
811151fc:	df000017 	ldw	fp,0(sp)
81115200:	dec00104 	addi	sp,sp,4
81115204:	f800283a 	ret

81115208 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
81115208:	defffc04 	addi	sp,sp,-16
8111520c:	de00012e 	bgeu	sp,et,81115214 <_reg_read+0xc>
81115210:	003b68fa 	trap	3
81115214:	df000315 	stw	fp,12(sp)
81115218:	df000304 	addi	fp,sp,12
8111521c:	e13ffd15 	stw	r4,-12(fp)
81115220:	e17ffe15 	stw	r5,-8(fp)
81115224:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
81115228:	e0bffe17 	ldw	r2,-8(fp)
8111522c:	1085883a 	add	r2,r2,r2
81115230:	1085883a 	add	r2,r2,r2
81115234:	1007883a 	mov	r3,r2
81115238:	e0bffd17 	ldw	r2,-12(fp)
8111523c:	1885883a 	add	r2,r3,r2
81115240:	10c00037 	ldwio	r3,0(r2)
81115244:	e0bfff17 	ldw	r2,-4(fp)
81115248:	10c00015 	stw	r3,0(r2)
	return 1;
8111524c:	00800044 	movi	r2,1

}
81115250:	e037883a 	mov	sp,fp
81115254:	df000017 	ldw	fp,0(sp)
81115258:	dec00104 	addi	sp,sp,4
8111525c:	f800283a 	ret

81115260 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
81115260:	defffa04 	addi	sp,sp,-24
81115264:	de00012e 	bgeu	sp,et,8111526c <_print_codec_status+0xc>
81115268:	003b68fa 	trap	3
8111526c:	dfc00515 	stw	ra,20(sp)
81115270:	df000415 	stw	fp,16(sp)
81115274:	df000404 	addi	fp,sp,16
81115278:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111527c:	e0bfff17 	ldw	r2,-4(fp)
81115280:	1005d1ba 	srai	r2,r2,6
81115284:	1080004c 	andi	r2,r2,1
81115288:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111528c:	e0bfff17 	ldw	r2,-4(fp)
81115290:	1005d17a 	srai	r2,r2,5
81115294:	1080004c 	andi	r2,r2,1
81115298:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111529c:	e0bfff17 	ldw	r2,-4(fp)
811152a0:	1005d13a 	srai	r2,r2,4
811152a4:	1080004c 	andi	r2,r2,1
811152a8:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
811152ac:	00e04574 	movhi	r3,33045
811152b0:	18e21504 	addi	r3,r3,-30636
811152b4:	00a04534 	movhi	r2,33044
811152b8:	10962b04 	addi	r2,r2,22700
811152bc:	1009883a 	mov	r4,r2
811152c0:	008005c4 	movi	r2,23
811152c4:	100d883a 	mov	r6,r2
811152c8:	200b883a 	mov	r5,r4
811152cc:	1809883a 	mov	r4,r3
811152d0:	1117ccc0 	call	81117ccc <memcpy>
	debug(fp, cDebugBuffer);
811152d4:	d0a05517 	ldw	r2,-32428(gp)
811152d8:	01604574 	movhi	r5,33045
811152dc:	29621504 	addi	r5,r5,-30636
811152e0:	1009883a 	mov	r4,r2
811152e4:	1116c1c0 	call	81116c1c <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
811152e8:	e0bffc17 	ldw	r2,-16(fp)
811152ec:	10800058 	cmpnei	r2,r2,1
811152f0:	1000031e 	bne	r2,zero,81115300 <_print_codec_status+0xa0>
811152f4:	00a04534 	movhi	r2,33044
811152f8:	10963104 	addi	r2,r2,22724
811152fc:	00000206 	br	81115308 <_print_codec_status+0xa8>
81115300:	00a04534 	movhi	r2,33044
81115304:	10963204 	addi	r2,r2,22728
81115308:	100d883a 	mov	r6,r2
8111530c:	01604534 	movhi	r5,33044
81115310:	29563304 	addi	r5,r5,22732
81115314:	01204574 	movhi	r4,33045
81115318:	21221504 	addi	r4,r4,-30636
8111531c:	11185ac0 	call	811185ac <sprintf>
	debug(fp, cDebugBuffer);
81115320:	d0a05517 	ldw	r2,-32428(gp)
81115324:	01604574 	movhi	r5,33045
81115328:	29621504 	addi	r5,r5,-30636
8111532c:	1009883a 	mov	r4,r2
81115330:	1116c1c0 	call	81116c1c <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
81115334:	e0bffd17 	ldw	r2,-12(fp)
81115338:	10800058 	cmpnei	r2,r2,1
8111533c:	1000031e 	bne	r2,zero,8111534c <_print_codec_status+0xec>
81115340:	00a04534 	movhi	r2,33044
81115344:	10963104 	addi	r2,r2,22724
81115348:	00000206 	br	81115354 <_print_codec_status+0xf4>
8111534c:	00a04534 	movhi	r2,33044
81115350:	10963204 	addi	r2,r2,22728
81115354:	100d883a 	mov	r6,r2
81115358:	01604534 	movhi	r5,33044
8111535c:	29563904 	addi	r5,r5,22756
81115360:	01204574 	movhi	r4,33045
81115364:	21221504 	addi	r4,r4,-30636
81115368:	11185ac0 	call	811185ac <sprintf>
	debug(fp, cDebugBuffer);
8111536c:	d0a05517 	ldw	r2,-32428(gp)
81115370:	01604574 	movhi	r5,33045
81115374:	29621504 	addi	r5,r5,-30636
81115378:	1009883a 	mov	r4,r2
8111537c:	1116c1c0 	call	81116c1c <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
81115380:	e0bffe17 	ldw	r2,-8(fp)
81115384:	10800058 	cmpnei	r2,r2,1
81115388:	1000031e 	bne	r2,zero,81115398 <_print_codec_status+0x138>
8111538c:	00a04534 	movhi	r2,33044
81115390:	10963104 	addi	r2,r2,22724
81115394:	00000206 	br	811153a0 <_print_codec_status+0x140>
81115398:	00a04534 	movhi	r2,33044
8111539c:	10963204 	addi	r2,r2,22728
811153a0:	100d883a 	mov	r6,r2
811153a4:	01604534 	movhi	r5,33044
811153a8:	29563f04 	addi	r5,r5,22780
811153ac:	01204574 	movhi	r4,33045
811153b0:	21221504 	addi	r4,r4,-30636
811153b4:	11185ac0 	call	811185ac <sprintf>
	debug(fp, cDebugBuffer);
811153b8:	d0a05517 	ldw	r2,-32428(gp)
811153bc:	01604574 	movhi	r5,33045
811153c0:	29621504 	addi	r5,r5,-30636
811153c4:	1009883a 	mov	r4,r2
811153c8:	1116c1c0 	call	81116c1c <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
811153cc:	00a04574 	movhi	r2,33045
811153d0:	10a21504 	addi	r2,r2,-30636
811153d4:	00c00b44 	movi	r3,45
811153d8:	10c00005 	stb	r3,0(r2)
811153dc:	00c00b44 	movi	r3,45
811153e0:	10c00045 	stb	r3,1(r2)
811153e4:	00c00b44 	movi	r3,45
811153e8:	10c00085 	stb	r3,2(r2)
811153ec:	00c00b44 	movi	r3,45
811153f0:	10c000c5 	stb	r3,3(r2)
811153f4:	00c00b44 	movi	r3,45
811153f8:	10c00105 	stb	r3,4(r2)
811153fc:	00c00b44 	movi	r3,45
81115400:	10c00145 	stb	r3,5(r2)
81115404:	00c00b44 	movi	r3,45
81115408:	10c00185 	stb	r3,6(r2)
8111540c:	00c00b44 	movi	r3,45
81115410:	10c001c5 	stb	r3,7(r2)
81115414:	00c00804 	movi	r3,32
81115418:	10c00205 	stb	r3,8(r2)
8111541c:	00c00804 	movi	r3,32
81115420:	10c00245 	stb	r3,9(r2)
81115424:	00c00284 	movi	r3,10
81115428:	10c00285 	stb	r3,10(r2)
8111542c:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
81115430:	d0a05517 	ldw	r2,-32428(gp)
81115434:	01604574 	movhi	r5,33045
81115438:	29621504 	addi	r5,r5,-30636
8111543c:	1009883a 	mov	r4,r2
81115440:	1116c1c0 	call	81116c1c <fprintf>
#endif
}
81115444:	0001883a 	nop
81115448:	e037883a 	mov	sp,fp
8111544c:	dfc00117 	ldw	ra,4(sp)
81115450:	df000017 	ldw	fp,0(sp)
81115454:	dec00204 	addi	sp,sp,8
81115458:	f800283a 	ret

8111545c <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111545c:	defffb04 	addi	sp,sp,-20
81115460:	de00012e 	bgeu	sp,et,81115468 <_split_codec_status+0xc>
81115464:	003b68fa 	trap	3
81115468:	df000415 	stw	fp,16(sp)
8111546c:	df000404 	addi	fp,sp,16
81115470:	e13ffc15 	stw	r4,-16(fp)
81115474:	e17ffd15 	stw	r5,-12(fp)
81115478:	e1bffe15 	stw	r6,-8(fp)
8111547c:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
81115480:	e0bffc17 	ldw	r2,-16(fp)
81115484:	1005d1ba 	srai	r2,r2,6
81115488:	10c0004c 	andi	r3,r2,1
8111548c:	e0bffd17 	ldw	r2,-12(fp)
81115490:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
81115494:	e0bffc17 	ldw	r2,-16(fp)
81115498:	1005d17a 	srai	r2,r2,5
8111549c:	10c0004c 	andi	r3,r2,1
811154a0:	e0bffe17 	ldw	r2,-8(fp)
811154a4:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
811154a8:	e0bffc17 	ldw	r2,-16(fp)
811154ac:	1005d13a 	srai	r2,r2,4
811154b0:	10c0004c 	andi	r3,r2,1
811154b4:	e0bfff17 	ldw	r2,-4(fp)
811154b8:	10c00015 	stw	r3,0(r2)
}
811154bc:	0001883a 	nop
811154c0:	e037883a 	mov	sp,fp
811154c4:	df000017 	ldw	fp,0(sp)
811154c8:	dec00104 	addi	sp,sp,4
811154cc:	f800283a 	ret

811154d0 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
811154d0:	defffc04 	addi	sp,sp,-16
811154d4:	de00012e 	bgeu	sp,et,811154dc <aatoh+0xc>
811154d8:	003b68fa 	trap	3
811154dc:	df000315 	stw	fp,12(sp)
811154e0:	df000304 	addi	fp,sp,12
811154e4:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
811154e8:	e0bfff17 	ldw	r2,-4(fp)
811154ec:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
811154f0:	e0bffd17 	ldw	r2,-12(fp)
811154f4:	10c00003 	ldbu	r3,0(r2)
811154f8:	e0bffd17 	ldw	r2,-12(fp)
811154fc:	10800003 	ldbu	r2,0(r2)
81115500:	10803fcc 	andi	r2,r2,255
81115504:	10800eb0 	cmpltui	r2,r2,58
81115508:	1000021e 	bne	r2,zero,81115514 <aatoh+0x44>
8111550c:	00800dc4 	movi	r2,55
81115510:	00000106 	br	81115518 <aatoh+0x48>
81115514:	00800c04 	movi	r2,48
81115518:	1885c83a 	sub	r2,r3,r2
8111551c:	1004913a 	slli	r2,r2,4
81115520:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
81115524:	e0bffd17 	ldw	r2,-12(fp)
81115528:	10800044 	addi	r2,r2,1
8111552c:	10c00003 	ldbu	r3,0(r2)
81115530:	e0bffd17 	ldw	r2,-12(fp)
81115534:	10800044 	addi	r2,r2,1
81115538:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111553c:	10803fcc 	andi	r2,r2,255
81115540:	10800eb0 	cmpltui	r2,r2,58
81115544:	1000021e 	bne	r2,zero,81115550 <aatoh+0x80>
81115548:	00800dc4 	movi	r2,55
8111554c:	00000106 	br	81115554 <aatoh+0x84>
81115550:	00800c04 	movi	r2,48
81115554:	1885c83a 	sub	r2,r3,r2
81115558:	2085883a 	add	r2,r4,r2
8111555c:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
81115560:	e0bffe03 	ldbu	r2,-8(fp)
}
81115564:	e037883a 	mov	sp,fp
81115568:	df000017 	ldw	fp,0(sp)
8111556c:	dec00104 	addi	sp,sp,4
81115570:	f800283a 	ret

81115574 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
81115574:	defffd04 	addi	sp,sp,-12
81115578:	de00012e 	bgeu	sp,et,81115580 <Verif_Error+0xc>
8111557c:	003b68fa 	trap	3
81115580:	dfc00215 	stw	ra,8(sp)
81115584:	df000115 	stw	fp,4(sp)
81115588:	df000104 	addi	fp,sp,4
8111558c:	2005883a 	mov	r2,r4
81115590:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
81115594:	e0bfff03 	ldbu	r2,-4(fp)
81115598:	1000091e 	bne	r2,zero,811155c0 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111559c:	d0a05517 	ldw	r2,-32428(gp)
811155a0:	100f883a 	mov	r7,r2
811155a4:	018001c4 	movi	r6,7
811155a8:	01400044 	movi	r5,1
811155ac:	01204534 	movhi	r4,33044
811155b0:	21164504 	addi	r4,r4,22804
811155b4:	11172b80 	call	811172b8 <fwrite>
#endif
		return 0;
811155b8:	0005883a 	mov	r2,zero
811155bc:	00000106 	br	811155c4 <Verif_Error+0x50>
	} else
		return 1;
811155c0:	00800044 	movi	r2,1
}
811155c4:	e037883a 	mov	sp,fp
811155c8:	dfc00117 	ldw	ra,4(sp)
811155cc:	df000017 	ldw	fp,0(sp)
811155d0:	dec00204 	addi	sp,sp,8
811155d4:	f800283a 	ret

811155d8 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
811155d8:	defffe04 	addi	sp,sp,-8
811155dc:	de00012e 	bgeu	sp,et,811155e4 <toInt+0xc>
811155e0:	003b68fa 	trap	3
811155e4:	df000115 	stw	fp,4(sp)
811155e8:	df000104 	addi	fp,sp,4
811155ec:	2005883a 	mov	r2,r4
811155f0:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
811155f4:	e0bfff03 	ldbu	r2,-4(fp)
811155f8:	10bff404 	addi	r2,r2,-48
}
811155fc:	e037883a 	mov	sp,fp
81115600:	df000017 	ldw	fp,0(sp)
81115604:	dec00104 	addi	sp,sp,4
81115608:	f800283a 	ret

8111560c <__divsf3>:
8111560c:	defff504 	addi	sp,sp,-44
81115610:	200cd5fa 	srli	r6,r4,23
81115614:	de00012e 	bgeu	sp,et,8111561c <__divsf3+0x10>
81115618:	003b68fa 	trap	3
8111561c:	dcc00415 	stw	r19,16(sp)
81115620:	2026d7fa 	srli	r19,r4,31
81115624:	00c02034 	movhi	r3,128
81115628:	dd800715 	stw	r22,28(sp)
8111562c:	dd000515 	stw	r20,20(sp)
81115630:	dc800315 	stw	r18,12(sp)
81115634:	18ffffc4 	addi	r3,r3,-1
81115638:	dfc00a15 	stw	ra,40(sp)
8111563c:	df000915 	stw	fp,36(sp)
81115640:	ddc00815 	stw	r23,32(sp)
81115644:	dd400615 	stw	r21,24(sp)
81115648:	dc400215 	stw	r17,8(sp)
8111564c:	dc000115 	stw	r16,4(sp)
81115650:	35003fcc 	andi	r20,r6,255
81115654:	1924703a 	and	r18,r3,r4
81115658:	9d803fcc 	andi	r22,r19,255
8111565c:	a0005226 	beq	r20,zero,811157a8 <__divsf3+0x19c>
81115660:	00803fc4 	movi	r2,255
81115664:	a0802e26 	beq	r20,r2,81115720 <__divsf3+0x114>
81115668:	91002034 	orhi	r4,r18,128
8111566c:	202490fa 	slli	r18,r4,3
81115670:	a53fe044 	addi	r20,r20,-127
81115674:	0021883a 	mov	r16,zero
81115678:	002f883a 	mov	r23,zero
8111567c:	280cd5fa 	srli	r6,r5,23
81115680:	282ad7fa 	srli	r21,r5,31
81115684:	00c02034 	movhi	r3,128
81115688:	18ffffc4 	addi	r3,r3,-1
8111568c:	31803fcc 	andi	r6,r6,255
81115690:	1962703a 	and	r17,r3,r5
81115694:	af003fcc 	andi	fp,r21,255
81115698:	30004a26 	beq	r6,zero,811157c4 <__divsf3+0x1b8>
8111569c:	00803fc4 	movi	r2,255
811156a0:	30804526 	beq	r6,r2,811157b8 <__divsf3+0x1ac>
811156a4:	89402034 	orhi	r5,r17,128
811156a8:	282290fa 	slli	r17,r5,3
811156ac:	31bfe044 	addi	r6,r6,-127
811156b0:	000b883a 	mov	r5,zero
811156b4:	2c20b03a 	or	r16,r5,r16
811156b8:	802090ba 	slli	r16,r16,2
811156bc:	00a04474 	movhi	r2,33041
811156c0:	1095b804 	addi	r2,r2,22240
811156c4:	80a1883a 	add	r16,r16,r2
811156c8:	81000017 	ldw	r4,0(r16)
811156cc:	9d46f03a 	xor	r3,r19,r21
811156d0:	180f883a 	mov	r7,r3
811156d4:	18803fcc 	andi	r2,r3,255
811156d8:	a18dc83a 	sub	r6,r20,r6
811156dc:	2000683a 	jmp	r4
811156e0:	811158c4 	addi	r4,r16,17763
811156e4:	81115748 	cmpgei	r4,r16,17757
811156e8:	811158b8 	rdprs	r4,r16,17762
811156ec:	81115734 	orhi	r4,r16,17756
811156f0:	811158b8 	rdprs	r4,r16,17762
811156f4:	81115890 	cmplti	r4,r16,17762
811156f8:	811158b8 	rdprs	r4,r16,17762
811156fc:	81115734 	orhi	r4,r16,17756
81115700:	81115748 	cmpgei	r4,r16,17757
81115704:	81115748 	cmpgei	r4,r16,17757
81115708:	81115890 	cmplti	r4,r16,17762
8111570c:	81115734 	orhi	r4,r16,17756
81115710:	811159a4 	muli	r4,r16,17766
81115714:	811159a4 	muli	r4,r16,17766
81115718:	811159a4 	muli	r4,r16,17766
8111571c:	81115958 	cmpnei	r4,r16,17765
81115720:	9000581e 	bne	r18,zero,81115884 <__divsf3+0x278>
81115724:	04000204 	movi	r16,8
81115728:	05c00084 	movi	r23,2
8111572c:	003fd306 	br	8111567c <__reset+0xfb0f567c>
81115730:	0023883a 	mov	r17,zero
81115734:	e02d883a 	mov	r22,fp
81115738:	282f883a 	mov	r23,r5
8111573c:	00800084 	movi	r2,2
81115740:	b8808f1e 	bne	r23,r2,81115980 <__divsf3+0x374>
81115744:	b005883a 	mov	r2,r22
81115748:	11c0004c 	andi	r7,r2,1
8111574c:	013fffc4 	movi	r4,-1
81115750:	000d883a 	mov	r6,zero
81115754:	21003fcc 	andi	r4,r4,255
81115758:	200895fa 	slli	r4,r4,23
8111575c:	38803fcc 	andi	r2,r7,255
81115760:	00c02034 	movhi	r3,128
81115764:	100497fa 	slli	r2,r2,31
81115768:	18ffffc4 	addi	r3,r3,-1
8111576c:	30c6703a 	and	r3,r6,r3
81115770:	1906b03a 	or	r3,r3,r4
81115774:	1884b03a 	or	r2,r3,r2
81115778:	dfc00a17 	ldw	ra,40(sp)
8111577c:	df000917 	ldw	fp,36(sp)
81115780:	ddc00817 	ldw	r23,32(sp)
81115784:	dd800717 	ldw	r22,28(sp)
81115788:	dd400617 	ldw	r21,24(sp)
8111578c:	dd000517 	ldw	r20,20(sp)
81115790:	dcc00417 	ldw	r19,16(sp)
81115794:	dc800317 	ldw	r18,12(sp)
81115798:	dc400217 	ldw	r17,8(sp)
8111579c:	dc000117 	ldw	r16,4(sp)
811157a0:	dec00b04 	addi	sp,sp,44
811157a4:	f800283a 	ret
811157a8:	90002b1e 	bne	r18,zero,81115858 <__divsf3+0x24c>
811157ac:	04000104 	movi	r16,4
811157b0:	05c00044 	movi	r23,1
811157b4:	003fb106 	br	8111567c <__reset+0xfb0f567c>
811157b8:	8800251e 	bne	r17,zero,81115850 <__divsf3+0x244>
811157bc:	01400084 	movi	r5,2
811157c0:	00000206 	br	811157cc <__divsf3+0x1c0>
811157c4:	88001a1e 	bne	r17,zero,81115830 <__divsf3+0x224>
811157c8:	01400044 	movi	r5,1
811157cc:	8160b03a 	or	r16,r16,r5
811157d0:	802090ba 	slli	r16,r16,2
811157d4:	00e04474 	movhi	r3,33041
811157d8:	18d5fc04 	addi	r3,r3,22512
811157dc:	80e1883a 	add	r16,r16,r3
811157e0:	80c00017 	ldw	r3,0(r16)
811157e4:	9d44f03a 	xor	r2,r19,r21
811157e8:	a18dc83a 	sub	r6,r20,r6
811157ec:	1800683a 	jmp	r3
811157f0:	81115748 	cmpgei	r4,r16,17757
811157f4:	81115748 	cmpgei	r4,r16,17757
811157f8:	81115994 	ori	r4,r16,17766
811157fc:	81115730 	cmpltui	r4,r16,17756
81115800:	81115994 	ori	r4,r16,17766
81115804:	81115890 	cmplti	r4,r16,17762
81115808:	81115994 	ori	r4,r16,17766
8111580c:	81115730 	cmpltui	r4,r16,17756
81115810:	81115748 	cmpgei	r4,r16,17757
81115814:	81115748 	cmpgei	r4,r16,17757
81115818:	81115890 	cmplti	r4,r16,17762
8111581c:	81115730 	cmpltui	r4,r16,17756
81115820:	811159a4 	muli	r4,r16,17766
81115824:	811159a4 	muli	r4,r16,17766
81115828:	811159a4 	muli	r4,r16,17766
8111582c:	811159bc 	xorhi	r4,r16,17766
81115830:	8809883a 	mov	r4,r17
81115834:	1116a5c0 	call	81116a5c <__clzsi2>
81115838:	10fffec4 	addi	r3,r2,-5
8111583c:	10801d84 	addi	r2,r2,118
81115840:	88e2983a 	sll	r17,r17,r3
81115844:	008dc83a 	sub	r6,zero,r2
81115848:	000b883a 	mov	r5,zero
8111584c:	003f9906 	br	811156b4 <__reset+0xfb0f56b4>
81115850:	014000c4 	movi	r5,3
81115854:	003f9706 	br	811156b4 <__reset+0xfb0f56b4>
81115858:	9009883a 	mov	r4,r18
8111585c:	d9400015 	stw	r5,0(sp)
81115860:	1116a5c0 	call	81116a5c <__clzsi2>
81115864:	10fffec4 	addi	r3,r2,-5
81115868:	11801d84 	addi	r6,r2,118
8111586c:	90e4983a 	sll	r18,r18,r3
81115870:	01a9c83a 	sub	r20,zero,r6
81115874:	0021883a 	mov	r16,zero
81115878:	002f883a 	mov	r23,zero
8111587c:	d9400017 	ldw	r5,0(sp)
81115880:	003f7e06 	br	8111567c <__reset+0xfb0f567c>
81115884:	04000304 	movi	r16,12
81115888:	05c000c4 	movi	r23,3
8111588c:	003f7b06 	br	8111567c <__reset+0xfb0f567c>
81115890:	01802034 	movhi	r6,128
81115894:	000f883a 	mov	r7,zero
81115898:	31bfffc4 	addi	r6,r6,-1
8111589c:	013fffc4 	movi	r4,-1
811158a0:	003fac06 	br	81115754 <__reset+0xfb0f5754>
811158a4:	01400044 	movi	r5,1
811158a8:	2909c83a 	sub	r4,r5,r4
811158ac:	00c006c4 	movi	r3,27
811158b0:	19004b0e 	bge	r3,r4,811159e0 <__divsf3+0x3d4>
811158b4:	114e703a 	and	r7,r2,r5
811158b8:	0009883a 	mov	r4,zero
811158bc:	000d883a 	mov	r6,zero
811158c0:	003fa406 	br	81115754 <__reset+0xfb0f5754>
811158c4:	9006917a 	slli	r3,r18,5
811158c8:	8822917a 	slli	r17,r17,5
811158cc:	1c40372e 	bgeu	r3,r17,811159ac <__divsf3+0x3a0>
811158d0:	31bfffc4 	addi	r6,r6,-1
811158d4:	010006c4 	movi	r4,27
811158d8:	000b883a 	mov	r5,zero
811158dc:	180f883a 	mov	r7,r3
811158e0:	294b883a 	add	r5,r5,r5
811158e4:	18c7883a 	add	r3,r3,r3
811158e8:	38000116 	blt	r7,zero,811158f0 <__divsf3+0x2e4>
811158ec:	1c400236 	bltu	r3,r17,811158f8 <__divsf3+0x2ec>
811158f0:	1c47c83a 	sub	r3,r3,r17
811158f4:	29400054 	ori	r5,r5,1
811158f8:	213fffc4 	addi	r4,r4,-1
811158fc:	203ff71e 	bne	r4,zero,811158dc <__reset+0xfb0f58dc>
81115900:	1806c03a 	cmpne	r3,r3,zero
81115904:	1962b03a 	or	r17,r3,r5
81115908:	31001fc4 	addi	r4,r6,127
8111590c:	013fe50e 	bge	zero,r4,811158a4 <__reset+0xfb0f58a4>
81115910:	88c001cc 	andi	r3,r17,7
81115914:	18000426 	beq	r3,zero,81115928 <__divsf3+0x31c>
81115918:	88c003cc 	andi	r3,r17,15
8111591c:	01400104 	movi	r5,4
81115920:	19400126 	beq	r3,r5,81115928 <__divsf3+0x31c>
81115924:	8963883a 	add	r17,r17,r5
81115928:	88c2002c 	andhi	r3,r17,2048
8111592c:	18000426 	beq	r3,zero,81115940 <__divsf3+0x334>
81115930:	00fe0034 	movhi	r3,63488
81115934:	18ffffc4 	addi	r3,r3,-1
81115938:	31002004 	addi	r4,r6,128
8111593c:	88e2703a 	and	r17,r17,r3
81115940:	00c03f84 	movi	r3,254
81115944:	193f8016 	blt	r3,r4,81115748 <__reset+0xfb0f5748>
81115948:	880c91ba 	slli	r6,r17,6
8111594c:	11c0004c 	andi	r7,r2,1
81115950:	300cd27a 	srli	r6,r6,9
81115954:	003f7f06 	br	81115754 <__reset+0xfb0f5754>
81115958:	9080102c 	andhi	r2,r18,64
8111595c:	10000226 	beq	r2,zero,81115968 <__divsf3+0x35c>
81115960:	8880102c 	andhi	r2,r17,64
81115964:	10001826 	beq	r2,zero,811159c8 <__divsf3+0x3bc>
81115968:	00802034 	movhi	r2,128
8111596c:	91801034 	orhi	r6,r18,64
81115970:	10bfffc4 	addi	r2,r2,-1
81115974:	980f883a 	mov	r7,r19
81115978:	308c703a 	and	r6,r6,r2
8111597c:	003fc706 	br	8111589c <__reset+0xfb0f589c>
81115980:	008000c4 	movi	r2,3
81115984:	b8802d26 	beq	r23,r2,81115a3c <__divsf3+0x430>
81115988:	00c00044 	movi	r3,1
8111598c:	b005883a 	mov	r2,r22
81115990:	b8ffdd1e 	bne	r23,r3,81115908 <__reset+0xfb0f5908>
81115994:	11c0004c 	andi	r7,r2,1
81115998:	0009883a 	mov	r4,zero
8111599c:	000d883a 	mov	r6,zero
811159a0:	003f6c06 	br	81115754 <__reset+0xfb0f5754>
811159a4:	9023883a 	mov	r17,r18
811159a8:	003f6406 	br	8111573c <__reset+0xfb0f573c>
811159ac:	1c47c83a 	sub	r3,r3,r17
811159b0:	01000684 	movi	r4,26
811159b4:	01400044 	movi	r5,1
811159b8:	003fc806 	br	811158dc <__reset+0xfb0f58dc>
811159bc:	9080102c 	andhi	r2,r18,64
811159c0:	103fe926 	beq	r2,zero,81115968 <__reset+0xfb0f5968>
811159c4:	0023883a 	mov	r17,zero
811159c8:	00802034 	movhi	r2,128
811159cc:	89801034 	orhi	r6,r17,64
811159d0:	10bfffc4 	addi	r2,r2,-1
811159d4:	a80f883a 	mov	r7,r21
811159d8:	308c703a 	and	r6,r6,r2
811159dc:	003faf06 	br	8111589c <__reset+0xfb0f589c>
811159e0:	01c00804 	movi	r7,32
811159e4:	390fc83a 	sub	r7,r7,r4
811159e8:	89ce983a 	sll	r7,r17,r7
811159ec:	890ad83a 	srl	r5,r17,r4
811159f0:	380ec03a 	cmpne	r7,r7,zero
811159f4:	29cab03a 	or	r5,r5,r7
811159f8:	28c001cc 	andi	r3,r5,7
811159fc:	18000426 	beq	r3,zero,81115a10 <__divsf3+0x404>
81115a00:	28c003cc 	andi	r3,r5,15
81115a04:	01000104 	movi	r4,4
81115a08:	19000126 	beq	r3,r4,81115a10 <__divsf3+0x404>
81115a0c:	290b883a 	add	r5,r5,r4
81115a10:	28c1002c 	andhi	r3,r5,1024
81115a14:	18000426 	beq	r3,zero,81115a28 <__divsf3+0x41c>
81115a18:	11c0004c 	andi	r7,r2,1
81115a1c:	01000044 	movi	r4,1
81115a20:	000d883a 	mov	r6,zero
81115a24:	003f4b06 	br	81115754 <__reset+0xfb0f5754>
81115a28:	280a91ba 	slli	r5,r5,6
81115a2c:	11c0004c 	andi	r7,r2,1
81115a30:	0009883a 	mov	r4,zero
81115a34:	280cd27a 	srli	r6,r5,9
81115a38:	003f4606 	br	81115754 <__reset+0xfb0f5754>
81115a3c:	00802034 	movhi	r2,128
81115a40:	89801034 	orhi	r6,r17,64
81115a44:	10bfffc4 	addi	r2,r2,-1
81115a48:	b00f883a 	mov	r7,r22
81115a4c:	308c703a 	and	r6,r6,r2
81115a50:	003f9206 	br	8111589c <__reset+0xfb0f589c>

81115a54 <__mulsf3>:
81115a54:	defff504 	addi	sp,sp,-44
81115a58:	de00012e 	bgeu	sp,et,81115a60 <__mulsf3+0xc>
81115a5c:	003b68fa 	trap	3
81115a60:	dc000115 	stw	r16,4(sp)
81115a64:	2020d5fa 	srli	r16,r4,23
81115a68:	dd400615 	stw	r21,24(sp)
81115a6c:	202ad7fa 	srli	r21,r4,31
81115a70:	dc800315 	stw	r18,12(sp)
81115a74:	04802034 	movhi	r18,128
81115a78:	df000915 	stw	fp,36(sp)
81115a7c:	dd000515 	stw	r20,20(sp)
81115a80:	94bfffc4 	addi	r18,r18,-1
81115a84:	dfc00a15 	stw	ra,40(sp)
81115a88:	ddc00815 	stw	r23,32(sp)
81115a8c:	dd800715 	stw	r22,28(sp)
81115a90:	dcc00415 	stw	r19,16(sp)
81115a94:	dc400215 	stw	r17,8(sp)
81115a98:	84003fcc 	andi	r16,r16,255
81115a9c:	9124703a 	and	r18,r18,r4
81115aa0:	a829883a 	mov	r20,r21
81115aa4:	af003fcc 	andi	fp,r21,255
81115aa8:	80005426 	beq	r16,zero,81115bfc <__mulsf3+0x1a8>
81115aac:	00803fc4 	movi	r2,255
81115ab0:	80802f26 	beq	r16,r2,81115b70 <__mulsf3+0x11c>
81115ab4:	91002034 	orhi	r4,r18,128
81115ab8:	202490fa 	slli	r18,r4,3
81115abc:	843fe044 	addi	r16,r16,-127
81115ac0:	0023883a 	mov	r17,zero
81115ac4:	002f883a 	mov	r23,zero
81115ac8:	2804d5fa 	srli	r2,r5,23
81115acc:	282cd7fa 	srli	r22,r5,31
81115ad0:	01002034 	movhi	r4,128
81115ad4:	213fffc4 	addi	r4,r4,-1
81115ad8:	10803fcc 	andi	r2,r2,255
81115adc:	2166703a 	and	r19,r4,r5
81115ae0:	b1803fcc 	andi	r6,r22,255
81115ae4:	10004c26 	beq	r2,zero,81115c18 <__mulsf3+0x1c4>
81115ae8:	00c03fc4 	movi	r3,255
81115aec:	10c04726 	beq	r2,r3,81115c0c <__mulsf3+0x1b8>
81115af0:	99002034 	orhi	r4,r19,128
81115af4:	202690fa 	slli	r19,r4,3
81115af8:	10bfe044 	addi	r2,r2,-127
81115afc:	0007883a 	mov	r3,zero
81115b00:	80a1883a 	add	r16,r16,r2
81115b04:	010003c4 	movi	r4,15
81115b08:	1c44b03a 	or	r2,r3,r17
81115b0c:	b56af03a 	xor	r21,r22,r21
81115b10:	81c00044 	addi	r7,r16,1
81115b14:	20806b36 	bltu	r4,r2,81115cc4 <__mulsf3+0x270>
81115b18:	100490ba 	slli	r2,r2,2
81115b1c:	01204474 	movhi	r4,33041
81115b20:	2116cc04 	addi	r4,r4,23344
81115b24:	1105883a 	add	r2,r2,r4
81115b28:	10800017 	ldw	r2,0(r2)
81115b2c:	1000683a 	jmp	r2
81115b30:	81115cc4 	addi	r4,r16,17779
81115b34:	81115b84 	addi	r4,r16,17774
81115b38:	81115b84 	addi	r4,r16,17774
81115b3c:	81115b80 	call	881115b8 <__reset+0x20f15b8>
81115b40:	81115ca8 	cmpgeui	r4,r16,17778
81115b44:	81115ca8 	cmpgeui	r4,r16,17778
81115b48:	81115c94 	ori	r4,r16,17778
81115b4c:	81115b80 	call	881115b8 <__reset+0x20f15b8>
81115b50:	81115ca8 	cmpgeui	r4,r16,17778
81115b54:	81115c94 	ori	r4,r16,17778
81115b58:	81115ca8 	cmpgeui	r4,r16,17778
81115b5c:	81115b80 	call	881115b8 <__reset+0x20f15b8>
81115b60:	81115cb4 	orhi	r4,r16,17778
81115b64:	81115cb4 	orhi	r4,r16,17778
81115b68:	81115cb4 	orhi	r4,r16,17778
81115b6c:	81115d90 	cmplti	r4,r16,17782
81115b70:	90003b1e 	bne	r18,zero,81115c60 <__mulsf3+0x20c>
81115b74:	04400204 	movi	r17,8
81115b78:	05c00084 	movi	r23,2
81115b7c:	003fd206 	br	81115ac8 <__reset+0xfb0f5ac8>
81115b80:	302b883a 	mov	r21,r6
81115b84:	00800084 	movi	r2,2
81115b88:	18802626 	beq	r3,r2,81115c24 <__mulsf3+0x1d0>
81115b8c:	008000c4 	movi	r2,3
81115b90:	1880ab26 	beq	r3,r2,81115e40 <__mulsf3+0x3ec>
81115b94:	00800044 	movi	r2,1
81115b98:	1880a21e 	bne	r3,r2,81115e24 <__mulsf3+0x3d0>
81115b9c:	a829883a 	mov	r20,r21
81115ba0:	0007883a 	mov	r3,zero
81115ba4:	0009883a 	mov	r4,zero
81115ba8:	18803fcc 	andi	r2,r3,255
81115bac:	100695fa 	slli	r3,r2,23
81115bb0:	a0803fcc 	andi	r2,r20,255
81115bb4:	100a97fa 	slli	r5,r2,31
81115bb8:	00802034 	movhi	r2,128
81115bbc:	10bfffc4 	addi	r2,r2,-1
81115bc0:	2084703a 	and	r2,r4,r2
81115bc4:	10c4b03a 	or	r2,r2,r3
81115bc8:	1144b03a 	or	r2,r2,r5
81115bcc:	dfc00a17 	ldw	ra,40(sp)
81115bd0:	df000917 	ldw	fp,36(sp)
81115bd4:	ddc00817 	ldw	r23,32(sp)
81115bd8:	dd800717 	ldw	r22,28(sp)
81115bdc:	dd400617 	ldw	r21,24(sp)
81115be0:	dd000517 	ldw	r20,20(sp)
81115be4:	dcc00417 	ldw	r19,16(sp)
81115be8:	dc800317 	ldw	r18,12(sp)
81115bec:	dc400217 	ldw	r17,8(sp)
81115bf0:	dc000117 	ldw	r16,4(sp)
81115bf4:	dec00b04 	addi	sp,sp,44
81115bf8:	f800283a 	ret
81115bfc:	90000d1e 	bne	r18,zero,81115c34 <__mulsf3+0x1e0>
81115c00:	04400104 	movi	r17,4
81115c04:	05c00044 	movi	r23,1
81115c08:	003faf06 	br	81115ac8 <__reset+0xfb0f5ac8>
81115c0c:	9806c03a 	cmpne	r3,r19,zero
81115c10:	18c00084 	addi	r3,r3,2
81115c14:	003fba06 	br	81115b00 <__reset+0xfb0f5b00>
81115c18:	9800141e 	bne	r19,zero,81115c6c <__mulsf3+0x218>
81115c1c:	00c00044 	movi	r3,1
81115c20:	003fb706 	br	81115b00 <__reset+0xfb0f5b00>
81115c24:	a829883a 	mov	r20,r21
81115c28:	00ffffc4 	movi	r3,-1
81115c2c:	0009883a 	mov	r4,zero
81115c30:	003fdd06 	br	81115ba8 <__reset+0xfb0f5ba8>
81115c34:	9009883a 	mov	r4,r18
81115c38:	d9400015 	stw	r5,0(sp)
81115c3c:	1116a5c0 	call	81116a5c <__clzsi2>
81115c40:	10fffec4 	addi	r3,r2,-5
81115c44:	10801d84 	addi	r2,r2,118
81115c48:	90e4983a 	sll	r18,r18,r3
81115c4c:	00a1c83a 	sub	r16,zero,r2
81115c50:	0023883a 	mov	r17,zero
81115c54:	002f883a 	mov	r23,zero
81115c58:	d9400017 	ldw	r5,0(sp)
81115c5c:	003f9a06 	br	81115ac8 <__reset+0xfb0f5ac8>
81115c60:	04400304 	movi	r17,12
81115c64:	05c000c4 	movi	r23,3
81115c68:	003f9706 	br	81115ac8 <__reset+0xfb0f5ac8>
81115c6c:	9809883a 	mov	r4,r19
81115c70:	d9800015 	stw	r6,0(sp)
81115c74:	1116a5c0 	call	81116a5c <__clzsi2>
81115c78:	10fffec4 	addi	r3,r2,-5
81115c7c:	10801d84 	addi	r2,r2,118
81115c80:	98e6983a 	sll	r19,r19,r3
81115c84:	0085c83a 	sub	r2,zero,r2
81115c88:	0007883a 	mov	r3,zero
81115c8c:	d9800017 	ldw	r6,0(sp)
81115c90:	003f9b06 	br	81115b00 <__reset+0xfb0f5b00>
81115c94:	01002034 	movhi	r4,128
81115c98:	0029883a 	mov	r20,zero
81115c9c:	213fffc4 	addi	r4,r4,-1
81115ca0:	00ffffc4 	movi	r3,-1
81115ca4:	003fc006 	br	81115ba8 <__reset+0xfb0f5ba8>
81115ca8:	9027883a 	mov	r19,r18
81115cac:	b807883a 	mov	r3,r23
81115cb0:	003fb406 	br	81115b84 <__reset+0xfb0f5b84>
81115cb4:	9027883a 	mov	r19,r18
81115cb8:	e02b883a 	mov	r21,fp
81115cbc:	b807883a 	mov	r3,r23
81115cc0:	003fb006 	br	81115b84 <__reset+0xfb0f5b84>
81115cc4:	9004d43a 	srli	r2,r18,16
81115cc8:	9810d43a 	srli	r8,r19,16
81115ccc:	94bfffcc 	andi	r18,r18,65535
81115cd0:	993fffcc 	andi	r4,r19,65535
81115cd4:	910d383a 	mul	r6,r18,r4
81115cd8:	20a7383a 	mul	r19,r4,r2
81115cdc:	9225383a 	mul	r18,r18,r8
81115ce0:	3006d43a 	srli	r3,r6,16
81115ce4:	1211383a 	mul	r8,r2,r8
81115ce8:	94e5883a 	add	r18,r18,r19
81115cec:	1c87883a 	add	r3,r3,r18
81115cf0:	1cc0022e 	bgeu	r3,r19,81115cfc <__mulsf3+0x2a8>
81115cf4:	00800074 	movhi	r2,1
81115cf8:	4091883a 	add	r8,r8,r2
81115cfc:	1804943a 	slli	r2,r3,16
81115d00:	31bfffcc 	andi	r6,r6,65535
81115d04:	1806d43a 	srli	r3,r3,16
81115d08:	1185883a 	add	r2,r2,r6
81115d0c:	102691ba 	slli	r19,r2,6
81115d10:	1a07883a 	add	r3,r3,r8
81115d14:	1004d6ba 	srli	r2,r2,26
81115d18:	180891ba 	slli	r4,r3,6
81115d1c:	9826c03a 	cmpne	r19,r19,zero
81115d20:	9884b03a 	or	r2,r19,r2
81115d24:	1126b03a 	or	r19,r2,r4
81115d28:	9882002c 	andhi	r2,r19,2048
81115d2c:	10000426 	beq	r2,zero,81115d40 <__mulsf3+0x2ec>
81115d30:	9804d07a 	srli	r2,r19,1
81115d34:	9900004c 	andi	r4,r19,1
81115d38:	3821883a 	mov	r16,r7
81115d3c:	1126b03a 	or	r19,r2,r4
81115d40:	80c01fc4 	addi	r3,r16,127
81115d44:	00c0210e 	bge	zero,r3,81115dcc <__mulsf3+0x378>
81115d48:	988001cc 	andi	r2,r19,7
81115d4c:	10000426 	beq	r2,zero,81115d60 <__mulsf3+0x30c>
81115d50:	988003cc 	andi	r2,r19,15
81115d54:	01000104 	movi	r4,4
81115d58:	11000126 	beq	r2,r4,81115d60 <__mulsf3+0x30c>
81115d5c:	9927883a 	add	r19,r19,r4
81115d60:	9882002c 	andhi	r2,r19,2048
81115d64:	10000426 	beq	r2,zero,81115d78 <__mulsf3+0x324>
81115d68:	00be0034 	movhi	r2,63488
81115d6c:	10bfffc4 	addi	r2,r2,-1
81115d70:	80c02004 	addi	r3,r16,128
81115d74:	98a6703a 	and	r19,r19,r2
81115d78:	00803f84 	movi	r2,254
81115d7c:	10ffa916 	blt	r2,r3,81115c24 <__reset+0xfb0f5c24>
81115d80:	980891ba 	slli	r4,r19,6
81115d84:	a829883a 	mov	r20,r21
81115d88:	2008d27a 	srli	r4,r4,9
81115d8c:	003f8606 	br	81115ba8 <__reset+0xfb0f5ba8>
81115d90:	9080102c 	andhi	r2,r18,64
81115d94:	10000826 	beq	r2,zero,81115db8 <__mulsf3+0x364>
81115d98:	9880102c 	andhi	r2,r19,64
81115d9c:	1000061e 	bne	r2,zero,81115db8 <__mulsf3+0x364>
81115da0:	00802034 	movhi	r2,128
81115da4:	99001034 	orhi	r4,r19,64
81115da8:	10bfffc4 	addi	r2,r2,-1
81115dac:	b029883a 	mov	r20,r22
81115db0:	2088703a 	and	r4,r4,r2
81115db4:	003fba06 	br	81115ca0 <__reset+0xfb0f5ca0>
81115db8:	00802034 	movhi	r2,128
81115dbc:	91001034 	orhi	r4,r18,64
81115dc0:	10bfffc4 	addi	r2,r2,-1
81115dc4:	2088703a 	and	r4,r4,r2
81115dc8:	003fb506 	br	81115ca0 <__reset+0xfb0f5ca0>
81115dcc:	00800044 	movi	r2,1
81115dd0:	10c7c83a 	sub	r3,r2,r3
81115dd4:	008006c4 	movi	r2,27
81115dd8:	10ff7016 	blt	r2,r3,81115b9c <__reset+0xfb0f5b9c>
81115ddc:	00800804 	movi	r2,32
81115de0:	10c5c83a 	sub	r2,r2,r3
81115de4:	9884983a 	sll	r2,r19,r2
81115de8:	98c6d83a 	srl	r3,r19,r3
81115dec:	1004c03a 	cmpne	r2,r2,zero
81115df0:	1884b03a 	or	r2,r3,r2
81115df4:	10c001cc 	andi	r3,r2,7
81115df8:	18000426 	beq	r3,zero,81115e0c <__mulsf3+0x3b8>
81115dfc:	10c003cc 	andi	r3,r2,15
81115e00:	01000104 	movi	r4,4
81115e04:	19000126 	beq	r3,r4,81115e0c <__mulsf3+0x3b8>
81115e08:	1105883a 	add	r2,r2,r4
81115e0c:	10c1002c 	andhi	r3,r2,1024
81115e10:	18000626 	beq	r3,zero,81115e2c <__mulsf3+0x3d8>
81115e14:	a829883a 	mov	r20,r21
81115e18:	00c00044 	movi	r3,1
81115e1c:	0009883a 	mov	r4,zero
81115e20:	003f6106 	br	81115ba8 <__reset+0xfb0f5ba8>
81115e24:	3821883a 	mov	r16,r7
81115e28:	003fc506 	br	81115d40 <__reset+0xfb0f5d40>
81115e2c:	100491ba 	slli	r2,r2,6
81115e30:	a829883a 	mov	r20,r21
81115e34:	0007883a 	mov	r3,zero
81115e38:	1008d27a 	srli	r4,r2,9
81115e3c:	003f5a06 	br	81115ba8 <__reset+0xfb0f5ba8>
81115e40:	00802034 	movhi	r2,128
81115e44:	99001034 	orhi	r4,r19,64
81115e48:	10bfffc4 	addi	r2,r2,-1
81115e4c:	a829883a 	mov	r20,r21
81115e50:	2088703a 	and	r4,r4,r2
81115e54:	003f9206 	br	81115ca0 <__reset+0xfb0f5ca0>

81115e58 <__floatsisf>:
81115e58:	defffd04 	addi	sp,sp,-12
81115e5c:	de00012e 	bgeu	sp,et,81115e64 <__floatsisf+0xc>
81115e60:	003b68fa 	trap	3
81115e64:	dfc00215 	stw	ra,8(sp)
81115e68:	dc400115 	stw	r17,4(sp)
81115e6c:	dc000015 	stw	r16,0(sp)
81115e70:	20003526 	beq	r4,zero,81115f48 <__floatsisf+0xf0>
81115e74:	2021883a 	mov	r16,r4
81115e78:	2022d7fa 	srli	r17,r4,31
81115e7c:	20003616 	blt	r4,zero,81115f58 <__floatsisf+0x100>
81115e80:	8009883a 	mov	r4,r16
81115e84:	1116a5c0 	call	81116a5c <__clzsi2>
81115e88:	00c02784 	movi	r3,158
81115e8c:	1887c83a 	sub	r3,r3,r2
81115e90:	01002584 	movi	r4,150
81115e94:	20c01416 	blt	r4,r3,81115ee8 <__floatsisf+0x90>
81115e98:	20c9c83a 	sub	r4,r4,r3
81115e9c:	8120983a 	sll	r16,r16,r4
81115ea0:	00802034 	movhi	r2,128
81115ea4:	10bfffc4 	addi	r2,r2,-1
81115ea8:	8809883a 	mov	r4,r17
81115eac:	80a0703a 	and	r16,r16,r2
81115eb0:	18803fcc 	andi	r2,r3,255
81115eb4:	100695fa 	slli	r3,r2,23
81115eb8:	20803fcc 	andi	r2,r4,255
81115ebc:	100897fa 	slli	r4,r2,31
81115ec0:	00802034 	movhi	r2,128
81115ec4:	10bfffc4 	addi	r2,r2,-1
81115ec8:	8084703a 	and	r2,r16,r2
81115ecc:	10c4b03a 	or	r2,r2,r3
81115ed0:	1104b03a 	or	r2,r2,r4
81115ed4:	dfc00217 	ldw	ra,8(sp)
81115ed8:	dc400117 	ldw	r17,4(sp)
81115edc:	dc000017 	ldw	r16,0(sp)
81115ee0:	dec00304 	addi	sp,sp,12
81115ee4:	f800283a 	ret
81115ee8:	01002644 	movi	r4,153
81115eec:	20c01c16 	blt	r4,r3,81115f60 <__floatsisf+0x108>
81115ef0:	20c9c83a 	sub	r4,r4,r3
81115ef4:	8120983a 	sll	r16,r16,r4
81115ef8:	013f0034 	movhi	r4,64512
81115efc:	213fffc4 	addi	r4,r4,-1
81115f00:	814001cc 	andi	r5,r16,7
81115f04:	8108703a 	and	r4,r16,r4
81115f08:	28000426 	beq	r5,zero,81115f1c <__floatsisf+0xc4>
81115f0c:	840003cc 	andi	r16,r16,15
81115f10:	01400104 	movi	r5,4
81115f14:	81400126 	beq	r16,r5,81115f1c <__floatsisf+0xc4>
81115f18:	2149883a 	add	r4,r4,r5
81115f1c:	2141002c 	andhi	r5,r4,1024
81115f20:	28000526 	beq	r5,zero,81115f38 <__floatsisf+0xe0>
81115f24:	00c027c4 	movi	r3,159
81115f28:	1887c83a 	sub	r3,r3,r2
81115f2c:	00bf0034 	movhi	r2,64512
81115f30:	10bfffc4 	addi	r2,r2,-1
81115f34:	2088703a 	and	r4,r4,r2
81115f38:	202091ba 	slli	r16,r4,6
81115f3c:	8809883a 	mov	r4,r17
81115f40:	8020d27a 	srli	r16,r16,9
81115f44:	003fda06 	br	81115eb0 <__reset+0xfb0f5eb0>
81115f48:	0009883a 	mov	r4,zero
81115f4c:	0007883a 	mov	r3,zero
81115f50:	0021883a 	mov	r16,zero
81115f54:	003fd606 	br	81115eb0 <__reset+0xfb0f5eb0>
81115f58:	0121c83a 	sub	r16,zero,r4
81115f5c:	003fc806 	br	81115e80 <__reset+0xfb0f5e80>
81115f60:	01002e44 	movi	r4,185
81115f64:	20c9c83a 	sub	r4,r4,r3
81115f68:	01400144 	movi	r5,5
81115f6c:	8108983a 	sll	r4,r16,r4
81115f70:	288bc83a 	sub	r5,r5,r2
81115f74:	8160d83a 	srl	r16,r16,r5
81115f78:	2008c03a 	cmpne	r4,r4,zero
81115f7c:	8120b03a 	or	r16,r16,r4
81115f80:	003fdd06 	br	81115ef8 <__reset+0xfb0f5ef8>

81115f84 <__floatunsisf>:
81115f84:	defffe04 	addi	sp,sp,-8
81115f88:	de00012e 	bgeu	sp,et,81115f90 <__floatunsisf+0xc>
81115f8c:	003b68fa 	trap	3
81115f90:	dfc00115 	stw	ra,4(sp)
81115f94:	dc000015 	stw	r16,0(sp)
81115f98:	20002c26 	beq	r4,zero,8111604c <__floatunsisf+0xc8>
81115f9c:	2021883a 	mov	r16,r4
81115fa0:	1116a5c0 	call	81116a5c <__clzsi2>
81115fa4:	00c02784 	movi	r3,158
81115fa8:	1887c83a 	sub	r3,r3,r2
81115fac:	01002584 	movi	r4,150
81115fb0:	20c00f16 	blt	r4,r3,81115ff0 <__floatunsisf+0x6c>
81115fb4:	20c9c83a 	sub	r4,r4,r3
81115fb8:	8108983a 	sll	r4,r16,r4
81115fbc:	00802034 	movhi	r2,128
81115fc0:	10bfffc4 	addi	r2,r2,-1
81115fc4:	2088703a 	and	r4,r4,r2
81115fc8:	18803fcc 	andi	r2,r3,255
81115fcc:	100695fa 	slli	r3,r2,23
81115fd0:	00802034 	movhi	r2,128
81115fd4:	10bfffc4 	addi	r2,r2,-1
81115fd8:	2084703a 	and	r2,r4,r2
81115fdc:	10c4b03a 	or	r2,r2,r3
81115fe0:	dfc00117 	ldw	ra,4(sp)
81115fe4:	dc000017 	ldw	r16,0(sp)
81115fe8:	dec00204 	addi	sp,sp,8
81115fec:	f800283a 	ret
81115ff0:	01002644 	movi	r4,153
81115ff4:	20c01816 	blt	r4,r3,81116058 <__floatunsisf+0xd4>
81115ff8:	20c9c83a 	sub	r4,r4,r3
81115ffc:	8108983a 	sll	r4,r16,r4
81116000:	017f0034 	movhi	r5,64512
81116004:	297fffc4 	addi	r5,r5,-1
81116008:	218001cc 	andi	r6,r4,7
8111600c:	214a703a 	and	r5,r4,r5
81116010:	30000426 	beq	r6,zero,81116024 <__floatunsisf+0xa0>
81116014:	210003cc 	andi	r4,r4,15
81116018:	01800104 	movi	r6,4
8111601c:	21800126 	beq	r4,r6,81116024 <__floatunsisf+0xa0>
81116020:	298b883a 	add	r5,r5,r6
81116024:	2901002c 	andhi	r4,r5,1024
81116028:	20000526 	beq	r4,zero,81116040 <__floatunsisf+0xbc>
8111602c:	00c027c4 	movi	r3,159
81116030:	1887c83a 	sub	r3,r3,r2
81116034:	00bf0034 	movhi	r2,64512
81116038:	10bfffc4 	addi	r2,r2,-1
8111603c:	288a703a 	and	r5,r5,r2
81116040:	280891ba 	slli	r4,r5,6
81116044:	2008d27a 	srli	r4,r4,9
81116048:	003fdf06 	br	81115fc8 <__reset+0xfb0f5fc8>
8111604c:	0007883a 	mov	r3,zero
81116050:	0009883a 	mov	r4,zero
81116054:	003fdc06 	br	81115fc8 <__reset+0xfb0f5fc8>
81116058:	01402e44 	movi	r5,185
8111605c:	28cbc83a 	sub	r5,r5,r3
81116060:	01000144 	movi	r4,5
81116064:	2089c83a 	sub	r4,r4,r2
81116068:	814a983a 	sll	r5,r16,r5
8111606c:	8108d83a 	srl	r4,r16,r4
81116070:	2820c03a 	cmpne	r16,r5,zero
81116074:	2408b03a 	or	r4,r4,r16
81116078:	003fe106 	br	81116000 <__reset+0xfb0f6000>

8111607c <__muldf3>:
8111607c:	defff304 	addi	sp,sp,-52
81116080:	2804d53a 	srli	r2,r5,20
81116084:	de00012e 	bgeu	sp,et,8111608c <__muldf3+0x10>
81116088:	003b68fa 	trap	3
8111608c:	dd800915 	stw	r22,36(sp)
81116090:	282cd7fa 	srli	r22,r5,31
81116094:	dc000315 	stw	r16,12(sp)
81116098:	04000434 	movhi	r16,16
8111609c:	dd400815 	stw	r21,32(sp)
811160a0:	dc800515 	stw	r18,20(sp)
811160a4:	843fffc4 	addi	r16,r16,-1
811160a8:	dfc00c15 	stw	ra,48(sp)
811160ac:	df000b15 	stw	fp,44(sp)
811160b0:	ddc00a15 	stw	r23,40(sp)
811160b4:	dd000715 	stw	r20,28(sp)
811160b8:	dcc00615 	stw	r19,24(sp)
811160bc:	dc400415 	stw	r17,16(sp)
811160c0:	1481ffcc 	andi	r18,r2,2047
811160c4:	2c20703a 	and	r16,r5,r16
811160c8:	b02b883a 	mov	r21,r22
811160cc:	b2403fcc 	andi	r9,r22,255
811160d0:	90006026 	beq	r18,zero,81116254 <__muldf3+0x1d8>
811160d4:	0081ffc4 	movi	r2,2047
811160d8:	2029883a 	mov	r20,r4
811160dc:	90803626 	beq	r18,r2,811161b8 <__muldf3+0x13c>
811160e0:	80800434 	orhi	r2,r16,16
811160e4:	100490fa 	slli	r2,r2,3
811160e8:	2020d77a 	srli	r16,r4,29
811160ec:	202890fa 	slli	r20,r4,3
811160f0:	94bf0044 	addi	r18,r18,-1023
811160f4:	80a0b03a 	or	r16,r16,r2
811160f8:	0027883a 	mov	r19,zero
811160fc:	0039883a 	mov	fp,zero
81116100:	3804d53a 	srli	r2,r7,20
81116104:	382ed7fa 	srli	r23,r7,31
81116108:	04400434 	movhi	r17,16
8111610c:	8c7fffc4 	addi	r17,r17,-1
81116110:	1081ffcc 	andi	r2,r2,2047
81116114:	3011883a 	mov	r8,r6
81116118:	3c62703a 	and	r17,r7,r17
8111611c:	ba803fcc 	andi	r10,r23,255
81116120:	10006d26 	beq	r2,zero,811162d8 <__muldf3+0x25c>
81116124:	00c1ffc4 	movi	r3,2047
81116128:	10c06526 	beq	r2,r3,811162c0 <__muldf3+0x244>
8111612c:	88c00434 	orhi	r3,r17,16
81116130:	180690fa 	slli	r3,r3,3
81116134:	3022d77a 	srli	r17,r6,29
81116138:	301090fa 	slli	r8,r6,3
8111613c:	10bf0044 	addi	r2,r2,-1023
81116140:	88e2b03a 	or	r17,r17,r3
81116144:	000b883a 	mov	r5,zero
81116148:	9085883a 	add	r2,r18,r2
8111614c:	2cc8b03a 	or	r4,r5,r19
81116150:	00c003c4 	movi	r3,15
81116154:	bdacf03a 	xor	r22,r23,r22
81116158:	12c00044 	addi	r11,r2,1
8111615c:	19009936 	bltu	r3,r4,811163c4 <__muldf3+0x348>
81116160:	200890ba 	slli	r4,r4,2
81116164:	00e04474 	movhi	r3,33041
81116168:	18d85e04 	addi	r3,r3,24952
8111616c:	20c9883a 	add	r4,r4,r3
81116170:	20c00017 	ldw	r3,0(r4)
81116174:	1800683a 	jmp	r3
81116178:	811163c4 	addi	r4,r16,17807
8111617c:	811161d8 	cmpnei	r4,r16,17799
81116180:	811161d8 	cmpnei	r4,r16,17799
81116184:	811161d4 	ori	r4,r16,17799
81116188:	811163a0 	cmpeqi	r4,r16,17806
8111618c:	811163a0 	cmpeqi	r4,r16,17806
81116190:	81116388 	cmpgei	r4,r16,17806
81116194:	811161d4 	ori	r4,r16,17799
81116198:	811163a0 	cmpeqi	r4,r16,17806
8111619c:	81116388 	cmpgei	r4,r16,17806
811161a0:	811163a0 	cmpeqi	r4,r16,17806
811161a4:	811161d4 	ori	r4,r16,17799
811161a8:	811163b0 	cmpltui	r4,r16,17806
811161ac:	811163b0 	cmpltui	r4,r16,17806
811161b0:	811163b0 	cmpltui	r4,r16,17806
811161b4:	811165cc 	andi	r4,r16,17815
811161b8:	2404b03a 	or	r2,r4,r16
811161bc:	10006f1e 	bne	r2,zero,8111637c <__muldf3+0x300>
811161c0:	04c00204 	movi	r19,8
811161c4:	0021883a 	mov	r16,zero
811161c8:	0029883a 	mov	r20,zero
811161cc:	07000084 	movi	fp,2
811161d0:	003fcb06 	br	81116100 <__reset+0xfb0f6100>
811161d4:	502d883a 	mov	r22,r10
811161d8:	00800084 	movi	r2,2
811161dc:	28805726 	beq	r5,r2,8111633c <__muldf3+0x2c0>
811161e0:	008000c4 	movi	r2,3
811161e4:	28816626 	beq	r5,r2,81116780 <__muldf3+0x704>
811161e8:	00800044 	movi	r2,1
811161ec:	2881411e 	bne	r5,r2,811166f4 <__muldf3+0x678>
811161f0:	b02b883a 	mov	r21,r22
811161f4:	0005883a 	mov	r2,zero
811161f8:	000b883a 	mov	r5,zero
811161fc:	0029883a 	mov	r20,zero
81116200:	1004953a 	slli	r2,r2,20
81116204:	a8c03fcc 	andi	r3,r21,255
81116208:	04400434 	movhi	r17,16
8111620c:	8c7fffc4 	addi	r17,r17,-1
81116210:	180697fa 	slli	r3,r3,31
81116214:	2c4a703a 	and	r5,r5,r17
81116218:	288ab03a 	or	r5,r5,r2
8111621c:	28c6b03a 	or	r3,r5,r3
81116220:	a005883a 	mov	r2,r20
81116224:	dfc00c17 	ldw	ra,48(sp)
81116228:	df000b17 	ldw	fp,44(sp)
8111622c:	ddc00a17 	ldw	r23,40(sp)
81116230:	dd800917 	ldw	r22,36(sp)
81116234:	dd400817 	ldw	r21,32(sp)
81116238:	dd000717 	ldw	r20,28(sp)
8111623c:	dcc00617 	ldw	r19,24(sp)
81116240:	dc800517 	ldw	r18,20(sp)
81116244:	dc400417 	ldw	r17,16(sp)
81116248:	dc000317 	ldw	r16,12(sp)
8111624c:	dec00d04 	addi	sp,sp,52
81116250:	f800283a 	ret
81116254:	2404b03a 	or	r2,r4,r16
81116258:	2027883a 	mov	r19,r4
8111625c:	10004226 	beq	r2,zero,81116368 <__muldf3+0x2ec>
81116260:	8000fc26 	beq	r16,zero,81116654 <__muldf3+0x5d8>
81116264:	8009883a 	mov	r4,r16
81116268:	d9800215 	stw	r6,8(sp)
8111626c:	d9c00015 	stw	r7,0(sp)
81116270:	da400115 	stw	r9,4(sp)
81116274:	1116a5c0 	call	81116a5c <__clzsi2>
81116278:	d9800217 	ldw	r6,8(sp)
8111627c:	d9c00017 	ldw	r7,0(sp)
81116280:	da400117 	ldw	r9,4(sp)
81116284:	113ffd44 	addi	r4,r2,-11
81116288:	00c00704 	movi	r3,28
8111628c:	1900ed16 	blt	r3,r4,81116644 <__muldf3+0x5c8>
81116290:	00c00744 	movi	r3,29
81116294:	147ffe04 	addi	r17,r2,-8
81116298:	1907c83a 	sub	r3,r3,r4
8111629c:	8460983a 	sll	r16,r16,r17
811162a0:	98c6d83a 	srl	r3,r19,r3
811162a4:	9c68983a 	sll	r20,r19,r17
811162a8:	1c20b03a 	or	r16,r3,r16
811162ac:	1080fcc4 	addi	r2,r2,1011
811162b0:	00a5c83a 	sub	r18,zero,r2
811162b4:	0027883a 	mov	r19,zero
811162b8:	0039883a 	mov	fp,zero
811162bc:	003f9006 	br	81116100 <__reset+0xfb0f6100>
811162c0:	3446b03a 	or	r3,r6,r17
811162c4:	1800261e 	bne	r3,zero,81116360 <__muldf3+0x2e4>
811162c8:	0023883a 	mov	r17,zero
811162cc:	0011883a 	mov	r8,zero
811162d0:	01400084 	movi	r5,2
811162d4:	003f9c06 	br	81116148 <__reset+0xfb0f6148>
811162d8:	3446b03a 	or	r3,r6,r17
811162dc:	18001c26 	beq	r3,zero,81116350 <__muldf3+0x2d4>
811162e0:	8800ce26 	beq	r17,zero,8111661c <__muldf3+0x5a0>
811162e4:	8809883a 	mov	r4,r17
811162e8:	d9800215 	stw	r6,8(sp)
811162ec:	da400115 	stw	r9,4(sp)
811162f0:	da800015 	stw	r10,0(sp)
811162f4:	1116a5c0 	call	81116a5c <__clzsi2>
811162f8:	d9800217 	ldw	r6,8(sp)
811162fc:	da400117 	ldw	r9,4(sp)
81116300:	da800017 	ldw	r10,0(sp)
81116304:	113ffd44 	addi	r4,r2,-11
81116308:	00c00704 	movi	r3,28
8111630c:	1900bf16 	blt	r3,r4,8111660c <__muldf3+0x590>
81116310:	00c00744 	movi	r3,29
81116314:	123ffe04 	addi	r8,r2,-8
81116318:	1907c83a 	sub	r3,r3,r4
8111631c:	8a22983a 	sll	r17,r17,r8
81116320:	30c6d83a 	srl	r3,r6,r3
81116324:	3210983a 	sll	r8,r6,r8
81116328:	1c62b03a 	or	r17,r3,r17
8111632c:	1080fcc4 	addi	r2,r2,1011
81116330:	0085c83a 	sub	r2,zero,r2
81116334:	000b883a 	mov	r5,zero
81116338:	003f8306 	br	81116148 <__reset+0xfb0f6148>
8111633c:	b02b883a 	mov	r21,r22
81116340:	0081ffc4 	movi	r2,2047
81116344:	000b883a 	mov	r5,zero
81116348:	0029883a 	mov	r20,zero
8111634c:	003fac06 	br	81116200 <__reset+0xfb0f6200>
81116350:	0023883a 	mov	r17,zero
81116354:	0011883a 	mov	r8,zero
81116358:	01400044 	movi	r5,1
8111635c:	003f7a06 	br	81116148 <__reset+0xfb0f6148>
81116360:	014000c4 	movi	r5,3
81116364:	003f7806 	br	81116148 <__reset+0xfb0f6148>
81116368:	04c00104 	movi	r19,4
8111636c:	0021883a 	mov	r16,zero
81116370:	0029883a 	mov	r20,zero
81116374:	07000044 	movi	fp,1
81116378:	003f6106 	br	81116100 <__reset+0xfb0f6100>
8111637c:	04c00304 	movi	r19,12
81116380:	070000c4 	movi	fp,3
81116384:	003f5e06 	br	81116100 <__reset+0xfb0f6100>
81116388:	01400434 	movhi	r5,16
8111638c:	002b883a 	mov	r21,zero
81116390:	297fffc4 	addi	r5,r5,-1
81116394:	053fffc4 	movi	r20,-1
81116398:	0081ffc4 	movi	r2,2047
8111639c:	003f9806 	br	81116200 <__reset+0xfb0f6200>
811163a0:	8023883a 	mov	r17,r16
811163a4:	a011883a 	mov	r8,r20
811163a8:	e00b883a 	mov	r5,fp
811163ac:	003f8a06 	br	811161d8 <__reset+0xfb0f61d8>
811163b0:	8023883a 	mov	r17,r16
811163b4:	a011883a 	mov	r8,r20
811163b8:	482d883a 	mov	r22,r9
811163bc:	e00b883a 	mov	r5,fp
811163c0:	003f8506 	br	811161d8 <__reset+0xfb0f61d8>
811163c4:	a00ad43a 	srli	r5,r20,16
811163c8:	401ad43a 	srli	r13,r8,16
811163cc:	a53fffcc 	andi	r20,r20,65535
811163d0:	423fffcc 	andi	r8,r8,65535
811163d4:	4519383a 	mul	r12,r8,r20
811163d8:	4147383a 	mul	r3,r8,r5
811163dc:	6d09383a 	mul	r4,r13,r20
811163e0:	600cd43a 	srli	r6,r12,16
811163e4:	2b5d383a 	mul	r14,r5,r13
811163e8:	20c9883a 	add	r4,r4,r3
811163ec:	310d883a 	add	r6,r6,r4
811163f0:	30c0022e 	bgeu	r6,r3,811163fc <__muldf3+0x380>
811163f4:	00c00074 	movhi	r3,1
811163f8:	70dd883a 	add	r14,r14,r3
811163fc:	8826d43a 	srli	r19,r17,16
81116400:	8bffffcc 	andi	r15,r17,65535
81116404:	7d23383a 	mul	r17,r15,r20
81116408:	7949383a 	mul	r4,r15,r5
8111640c:	9d29383a 	mul	r20,r19,r20
81116410:	8814d43a 	srli	r10,r17,16
81116414:	3012943a 	slli	r9,r6,16
81116418:	a129883a 	add	r20,r20,r4
8111641c:	633fffcc 	andi	r12,r12,65535
81116420:	5515883a 	add	r10,r10,r20
81116424:	3006d43a 	srli	r3,r6,16
81116428:	4b13883a 	add	r9,r9,r12
8111642c:	2ccb383a 	mul	r5,r5,r19
81116430:	5100022e 	bgeu	r10,r4,8111643c <__muldf3+0x3c0>
81116434:	01000074 	movhi	r4,1
81116438:	290b883a 	add	r5,r5,r4
8111643c:	802ad43a 	srli	r21,r16,16
81116440:	843fffcc 	andi	r16,r16,65535
81116444:	440d383a 	mul	r6,r8,r16
81116448:	4565383a 	mul	r18,r8,r21
8111644c:	8349383a 	mul	r4,r16,r13
81116450:	500e943a 	slli	r7,r10,16
81116454:	3010d43a 	srli	r8,r6,16
81116458:	5028d43a 	srli	r20,r10,16
8111645c:	2489883a 	add	r4,r4,r18
81116460:	8abfffcc 	andi	r10,r17,65535
81116464:	3a95883a 	add	r10,r7,r10
81116468:	4119883a 	add	r12,r8,r4
8111646c:	a169883a 	add	r20,r20,r5
81116470:	1a87883a 	add	r3,r3,r10
81116474:	6d5b383a 	mul	r13,r13,r21
81116478:	6480022e 	bgeu	r12,r18,81116484 <__muldf3+0x408>
8111647c:	01000074 	movhi	r4,1
81116480:	691b883a 	add	r13,r13,r4
81116484:	7c25383a 	mul	r18,r15,r16
81116488:	7d4b383a 	mul	r5,r15,r21
8111648c:	84cf383a 	mul	r7,r16,r19
81116490:	901ed43a 	srli	r15,r18,16
81116494:	6008d43a 	srli	r4,r12,16
81116498:	6010943a 	slli	r8,r12,16
8111649c:	394f883a 	add	r7,r7,r5
811164a0:	333fffcc 	andi	r12,r6,65535
811164a4:	79df883a 	add	r15,r15,r7
811164a8:	235b883a 	add	r13,r4,r13
811164ac:	9d63383a 	mul	r17,r19,r21
811164b0:	4309883a 	add	r4,r8,r12
811164b4:	7940022e 	bgeu	r15,r5,811164c0 <__muldf3+0x444>
811164b8:	01400074 	movhi	r5,1
811164bc:	8963883a 	add	r17,r17,r5
811164c0:	780a943a 	slli	r5,r15,16
811164c4:	91bfffcc 	andi	r6,r18,65535
811164c8:	70c7883a 	add	r3,r14,r3
811164cc:	298d883a 	add	r6,r5,r6
811164d0:	1a8f803a 	cmpltu	r7,r3,r10
811164d4:	350b883a 	add	r5,r6,r20
811164d8:	20c7883a 	add	r3,r4,r3
811164dc:	3955883a 	add	r10,r7,r5
811164e0:	1909803a 	cmpltu	r4,r3,r4
811164e4:	6a91883a 	add	r8,r13,r10
811164e8:	780cd43a 	srli	r6,r15,16
811164ec:	2219883a 	add	r12,r4,r8
811164f0:	2d0b803a 	cmpltu	r5,r5,r20
811164f4:	51cf803a 	cmpltu	r7,r10,r7
811164f8:	29ceb03a 	or	r7,r5,r7
811164fc:	4351803a 	cmpltu	r8,r8,r13
81116500:	610b803a 	cmpltu	r5,r12,r4
81116504:	4148b03a 	or	r4,r8,r5
81116508:	398f883a 	add	r7,r7,r6
8111650c:	3909883a 	add	r4,r7,r4
81116510:	1810927a 	slli	r8,r3,9
81116514:	2449883a 	add	r4,r4,r17
81116518:	2008927a 	slli	r4,r4,9
8111651c:	6022d5fa 	srli	r17,r12,23
81116520:	1806d5fa 	srli	r3,r3,23
81116524:	4252b03a 	or	r9,r8,r9
81116528:	600a927a 	slli	r5,r12,9
8111652c:	4810c03a 	cmpne	r8,r9,zero
81116530:	2462b03a 	or	r17,r4,r17
81116534:	40c6b03a 	or	r3,r8,r3
81116538:	8900402c 	andhi	r4,r17,256
8111653c:	1950b03a 	or	r8,r3,r5
81116540:	20000726 	beq	r4,zero,81116560 <__muldf3+0x4e4>
81116544:	4006d07a 	srli	r3,r8,1
81116548:	880497fa 	slli	r2,r17,31
8111654c:	4200004c 	andi	r8,r8,1
81116550:	8822d07a 	srli	r17,r17,1
81116554:	1a10b03a 	or	r8,r3,r8
81116558:	1210b03a 	or	r8,r2,r8
8111655c:	5805883a 	mov	r2,r11
81116560:	1140ffc4 	addi	r5,r2,1023
81116564:	0140440e 	bge	zero,r5,81116678 <__muldf3+0x5fc>
81116568:	40c001cc 	andi	r3,r8,7
8111656c:	18000726 	beq	r3,zero,8111658c <__muldf3+0x510>
81116570:	40c003cc 	andi	r3,r8,15
81116574:	01000104 	movi	r4,4
81116578:	19000426 	beq	r3,r4,8111658c <__muldf3+0x510>
8111657c:	4107883a 	add	r3,r8,r4
81116580:	1a11803a 	cmpltu	r8,r3,r8
81116584:	8a23883a 	add	r17,r17,r8
81116588:	1811883a 	mov	r8,r3
8111658c:	88c0402c 	andhi	r3,r17,256
81116590:	18000426 	beq	r3,zero,811165a4 <__muldf3+0x528>
81116594:	11410004 	addi	r5,r2,1024
81116598:	00bfc034 	movhi	r2,65280
8111659c:	10bfffc4 	addi	r2,r2,-1
811165a0:	88a2703a 	and	r17,r17,r2
811165a4:	0081ff84 	movi	r2,2046
811165a8:	117f6416 	blt	r2,r5,8111633c <__reset+0xfb0f633c>
811165ac:	8828977a 	slli	r20,r17,29
811165b0:	4010d0fa 	srli	r8,r8,3
811165b4:	8822927a 	slli	r17,r17,9
811165b8:	2881ffcc 	andi	r2,r5,2047
811165bc:	a228b03a 	or	r20,r20,r8
811165c0:	880ad33a 	srli	r5,r17,12
811165c4:	b02b883a 	mov	r21,r22
811165c8:	003f0d06 	br	81116200 <__reset+0xfb0f6200>
811165cc:	8080022c 	andhi	r2,r16,8
811165d0:	10000926 	beq	r2,zero,811165f8 <__muldf3+0x57c>
811165d4:	8880022c 	andhi	r2,r17,8
811165d8:	1000071e 	bne	r2,zero,811165f8 <__muldf3+0x57c>
811165dc:	00800434 	movhi	r2,16
811165e0:	89400234 	orhi	r5,r17,8
811165e4:	10bfffc4 	addi	r2,r2,-1
811165e8:	b82b883a 	mov	r21,r23
811165ec:	288a703a 	and	r5,r5,r2
811165f0:	4029883a 	mov	r20,r8
811165f4:	003f6806 	br	81116398 <__reset+0xfb0f6398>
811165f8:	00800434 	movhi	r2,16
811165fc:	81400234 	orhi	r5,r16,8
81116600:	10bfffc4 	addi	r2,r2,-1
81116604:	288a703a 	and	r5,r5,r2
81116608:	003f6306 	br	81116398 <__reset+0xfb0f6398>
8111660c:	147ff604 	addi	r17,r2,-40
81116610:	3462983a 	sll	r17,r6,r17
81116614:	0011883a 	mov	r8,zero
81116618:	003f4406 	br	8111632c <__reset+0xfb0f632c>
8111661c:	3009883a 	mov	r4,r6
81116620:	d9800215 	stw	r6,8(sp)
81116624:	da400115 	stw	r9,4(sp)
81116628:	da800015 	stw	r10,0(sp)
8111662c:	1116a5c0 	call	81116a5c <__clzsi2>
81116630:	10800804 	addi	r2,r2,32
81116634:	da800017 	ldw	r10,0(sp)
81116638:	da400117 	ldw	r9,4(sp)
8111663c:	d9800217 	ldw	r6,8(sp)
81116640:	003f3006 	br	81116304 <__reset+0xfb0f6304>
81116644:	143ff604 	addi	r16,r2,-40
81116648:	9c20983a 	sll	r16,r19,r16
8111664c:	0029883a 	mov	r20,zero
81116650:	003f1606 	br	811162ac <__reset+0xfb0f62ac>
81116654:	d9800215 	stw	r6,8(sp)
81116658:	d9c00015 	stw	r7,0(sp)
8111665c:	da400115 	stw	r9,4(sp)
81116660:	1116a5c0 	call	81116a5c <__clzsi2>
81116664:	10800804 	addi	r2,r2,32
81116668:	da400117 	ldw	r9,4(sp)
8111666c:	d9c00017 	ldw	r7,0(sp)
81116670:	d9800217 	ldw	r6,8(sp)
81116674:	003f0306 	br	81116284 <__reset+0xfb0f6284>
81116678:	00c00044 	movi	r3,1
8111667c:	1947c83a 	sub	r3,r3,r5
81116680:	00800e04 	movi	r2,56
81116684:	10feda16 	blt	r2,r3,811161f0 <__reset+0xfb0f61f0>
81116688:	008007c4 	movi	r2,31
8111668c:	10c01b16 	blt	r2,r3,811166fc <__muldf3+0x680>
81116690:	00800804 	movi	r2,32
81116694:	10c5c83a 	sub	r2,r2,r3
81116698:	888a983a 	sll	r5,r17,r2
8111669c:	40c8d83a 	srl	r4,r8,r3
811166a0:	4084983a 	sll	r2,r8,r2
811166a4:	88e2d83a 	srl	r17,r17,r3
811166a8:	2906b03a 	or	r3,r5,r4
811166ac:	1004c03a 	cmpne	r2,r2,zero
811166b0:	1886b03a 	or	r3,r3,r2
811166b4:	188001cc 	andi	r2,r3,7
811166b8:	10000726 	beq	r2,zero,811166d8 <__muldf3+0x65c>
811166bc:	188003cc 	andi	r2,r3,15
811166c0:	01000104 	movi	r4,4
811166c4:	11000426 	beq	r2,r4,811166d8 <__muldf3+0x65c>
811166c8:	1805883a 	mov	r2,r3
811166cc:	10c00104 	addi	r3,r2,4
811166d0:	1885803a 	cmpltu	r2,r3,r2
811166d4:	88a3883a 	add	r17,r17,r2
811166d8:	8880202c 	andhi	r2,r17,128
811166dc:	10001c26 	beq	r2,zero,81116750 <__muldf3+0x6d4>
811166e0:	b02b883a 	mov	r21,r22
811166e4:	00800044 	movi	r2,1
811166e8:	000b883a 	mov	r5,zero
811166ec:	0029883a 	mov	r20,zero
811166f0:	003ec306 	br	81116200 <__reset+0xfb0f6200>
811166f4:	5805883a 	mov	r2,r11
811166f8:	003f9906 	br	81116560 <__reset+0xfb0f6560>
811166fc:	00bff844 	movi	r2,-31
81116700:	1145c83a 	sub	r2,r2,r5
81116704:	8888d83a 	srl	r4,r17,r2
81116708:	00800804 	movi	r2,32
8111670c:	18801a26 	beq	r3,r2,81116778 <__muldf3+0x6fc>
81116710:	00801004 	movi	r2,64
81116714:	10c5c83a 	sub	r2,r2,r3
81116718:	8884983a 	sll	r2,r17,r2
8111671c:	1204b03a 	or	r2,r2,r8
81116720:	1004c03a 	cmpne	r2,r2,zero
81116724:	2084b03a 	or	r2,r4,r2
81116728:	144001cc 	andi	r17,r2,7
8111672c:	88000d1e 	bne	r17,zero,81116764 <__muldf3+0x6e8>
81116730:	000b883a 	mov	r5,zero
81116734:	1028d0fa 	srli	r20,r2,3
81116738:	b02b883a 	mov	r21,r22
8111673c:	0005883a 	mov	r2,zero
81116740:	a468b03a 	or	r20,r20,r17
81116744:	003eae06 	br	81116200 <__reset+0xfb0f6200>
81116748:	1007883a 	mov	r3,r2
8111674c:	0023883a 	mov	r17,zero
81116750:	880a927a 	slli	r5,r17,9
81116754:	1805883a 	mov	r2,r3
81116758:	8822977a 	slli	r17,r17,29
8111675c:	280ad33a 	srli	r5,r5,12
81116760:	003ff406 	br	81116734 <__reset+0xfb0f6734>
81116764:	10c003cc 	andi	r3,r2,15
81116768:	01000104 	movi	r4,4
8111676c:	193ff626 	beq	r3,r4,81116748 <__reset+0xfb0f6748>
81116770:	0023883a 	mov	r17,zero
81116774:	003fd506 	br	811166cc <__reset+0xfb0f66cc>
81116778:	0005883a 	mov	r2,zero
8111677c:	003fe706 	br	8111671c <__reset+0xfb0f671c>
81116780:	00800434 	movhi	r2,16
81116784:	89400234 	orhi	r5,r17,8
81116788:	10bfffc4 	addi	r2,r2,-1
8111678c:	b02b883a 	mov	r21,r22
81116790:	288a703a 	and	r5,r5,r2
81116794:	4029883a 	mov	r20,r8
81116798:	003eff06 	br	81116398 <__reset+0xfb0f6398>

8111679c <__extendsfdf2>:
8111679c:	200ad5fa 	srli	r5,r4,23
811167a0:	defffd04 	addi	sp,sp,-12
811167a4:	de00012e 	bgeu	sp,et,811167ac <__extendsfdf2+0x10>
811167a8:	003b68fa 	trap	3
811167ac:	29403fcc 	andi	r5,r5,255
811167b0:	dc400115 	stw	r17,4(sp)
811167b4:	29800044 	addi	r6,r5,1
811167b8:	04402034 	movhi	r17,128
811167bc:	dc000015 	stw	r16,0(sp)
811167c0:	8c7fffc4 	addi	r17,r17,-1
811167c4:	dfc00215 	stw	ra,8(sp)
811167c8:	31803fcc 	andi	r6,r6,255
811167cc:	00800044 	movi	r2,1
811167d0:	8922703a 	and	r17,r17,r4
811167d4:	2020d7fa 	srli	r16,r4,31
811167d8:	1180110e 	bge	r2,r6,81116820 <__extendsfdf2+0x84>
811167dc:	880cd0fa 	srli	r6,r17,3
811167e0:	8822977a 	slli	r17,r17,29
811167e4:	2940e004 	addi	r5,r5,896
811167e8:	2941ffcc 	andi	r5,r5,2047
811167ec:	2804953a 	slli	r2,r5,20
811167f0:	01400434 	movhi	r5,16
811167f4:	800697fa 	slli	r3,r16,31
811167f8:	297fffc4 	addi	r5,r5,-1
811167fc:	314a703a 	and	r5,r6,r5
81116800:	288ab03a 	or	r5,r5,r2
81116804:	28c6b03a 	or	r3,r5,r3
81116808:	8805883a 	mov	r2,r17
8111680c:	dfc00217 	ldw	ra,8(sp)
81116810:	dc400117 	ldw	r17,4(sp)
81116814:	dc000017 	ldw	r16,0(sp)
81116818:	dec00304 	addi	sp,sp,12
8111681c:	f800283a 	ret
81116820:	2800111e 	bne	r5,zero,81116868 <__extendsfdf2+0xcc>
81116824:	88001c26 	beq	r17,zero,81116898 <__extendsfdf2+0xfc>
81116828:	8809883a 	mov	r4,r17
8111682c:	1116a5c0 	call	81116a5c <__clzsi2>
81116830:	00c00284 	movi	r3,10
81116834:	18801b16 	blt	r3,r2,811168a4 <__extendsfdf2+0x108>
81116838:	018002c4 	movi	r6,11
8111683c:	308dc83a 	sub	r6,r6,r2
81116840:	11000544 	addi	r4,r2,21
81116844:	8986d83a 	srl	r3,r17,r6
81116848:	8922983a 	sll	r17,r17,r4
8111684c:	0180e244 	movi	r6,905
81116850:	01400434 	movhi	r5,16
81116854:	3085c83a 	sub	r2,r6,r2
81116858:	297fffc4 	addi	r5,r5,-1
8111685c:	194c703a 	and	r6,r3,r5
81116860:	1141ffcc 	andi	r5,r2,2047
81116864:	003fe006 	br	811167e8 <__reset+0xfb0f67e8>
81116868:	88000826 	beq	r17,zero,8111688c <__extendsfdf2+0xf0>
8111686c:	880cd0fa 	srli	r6,r17,3
81116870:	00800434 	movhi	r2,16
81116874:	10bfffc4 	addi	r2,r2,-1
81116878:	31800234 	orhi	r6,r6,8
8111687c:	8822977a 	slli	r17,r17,29
81116880:	308c703a 	and	r6,r6,r2
81116884:	0141ffc4 	movi	r5,2047
81116888:	003fd706 	br	811167e8 <__reset+0xfb0f67e8>
8111688c:	0141ffc4 	movi	r5,2047
81116890:	000d883a 	mov	r6,zero
81116894:	003fd406 	br	811167e8 <__reset+0xfb0f67e8>
81116898:	000b883a 	mov	r5,zero
8111689c:	000d883a 	mov	r6,zero
811168a0:	003fd106 	br	811167e8 <__reset+0xfb0f67e8>
811168a4:	11bffd44 	addi	r6,r2,-11
811168a8:	8986983a 	sll	r3,r17,r6
811168ac:	0023883a 	mov	r17,zero
811168b0:	003fe606 	br	8111684c <__reset+0xfb0f684c>

811168b4 <__truncdfsf2>:
811168b4:	2810d53a 	srli	r8,r5,20
811168b8:	01c00434 	movhi	r7,16
811168bc:	39ffffc4 	addi	r7,r7,-1
811168c0:	29ce703a 	and	r7,r5,r7
811168c4:	4201ffcc 	andi	r8,r8,2047
811168c8:	380e90fa 	slli	r7,r7,3
811168cc:	200cd77a 	srli	r6,r4,29
811168d0:	42400044 	addi	r9,r8,1
811168d4:	4a41ffcc 	andi	r9,r9,2047
811168d8:	00c00044 	movi	r3,1
811168dc:	280ad7fa 	srli	r5,r5,31
811168e0:	31ceb03a 	or	r7,r6,r7
811168e4:	200490fa 	slli	r2,r4,3
811168e8:	1a40230e 	bge	r3,r9,81116978 <__truncdfsf2+0xc4>
811168ec:	40ff2004 	addi	r3,r8,-896
811168f0:	01803f84 	movi	r6,254
811168f4:	30c01516 	blt	r6,r3,8111694c <__truncdfsf2+0x98>
811168f8:	00c0380e 	bge	zero,r3,811169dc <__truncdfsf2+0x128>
811168fc:	200c91ba 	slli	r6,r4,6
81116900:	380e90fa 	slli	r7,r7,3
81116904:	1004d77a 	srli	r2,r2,29
81116908:	300cc03a 	cmpne	r6,r6,zero
8111690c:	31ccb03a 	or	r6,r6,r7
81116910:	308cb03a 	or	r6,r6,r2
81116914:	308001cc 	andi	r2,r6,7
81116918:	10000426 	beq	r2,zero,8111692c <__truncdfsf2+0x78>
8111691c:	308003cc 	andi	r2,r6,15
81116920:	01000104 	movi	r4,4
81116924:	11000126 	beq	r2,r4,8111692c <__truncdfsf2+0x78>
81116928:	31800104 	addi	r6,r6,4
8111692c:	3081002c 	andhi	r2,r6,1024
81116930:	10001626 	beq	r2,zero,8111698c <__truncdfsf2+0xd8>
81116934:	18c00044 	addi	r3,r3,1
81116938:	00803fc4 	movi	r2,255
8111693c:	18800326 	beq	r3,r2,8111694c <__truncdfsf2+0x98>
81116940:	300c91ba 	slli	r6,r6,6
81116944:	300cd27a 	srli	r6,r6,9
81116948:	00000206 	br	81116954 <__truncdfsf2+0xa0>
8111694c:	00ffffc4 	movi	r3,-1
81116950:	000d883a 	mov	r6,zero
81116954:	18c03fcc 	andi	r3,r3,255
81116958:	180895fa 	slli	r4,r3,23
8111695c:	00c02034 	movhi	r3,128
81116960:	280a97fa 	slli	r5,r5,31
81116964:	18ffffc4 	addi	r3,r3,-1
81116968:	30c6703a 	and	r3,r6,r3
8111696c:	1906b03a 	or	r3,r3,r4
81116970:	1944b03a 	or	r2,r3,r5
81116974:	f800283a 	ret
81116978:	40000b1e 	bne	r8,zero,811169a8 <__truncdfsf2+0xf4>
8111697c:	388cb03a 	or	r6,r7,r2
81116980:	0007883a 	mov	r3,zero
81116984:	30000426 	beq	r6,zero,81116998 <__truncdfsf2+0xe4>
81116988:	01800144 	movi	r6,5
8111698c:	00803fc4 	movi	r2,255
81116990:	300cd0fa 	srli	r6,r6,3
81116994:	18800a26 	beq	r3,r2,811169c0 <__truncdfsf2+0x10c>
81116998:	00802034 	movhi	r2,128
8111699c:	10bfffc4 	addi	r2,r2,-1
811169a0:	308c703a 	and	r6,r6,r2
811169a4:	003feb06 	br	81116954 <__reset+0xfb0f6954>
811169a8:	3888b03a 	or	r4,r7,r2
811169ac:	203fe726 	beq	r4,zero,8111694c <__reset+0xfb0f694c>
811169b0:	380c90fa 	slli	r6,r7,3
811169b4:	00c03fc4 	movi	r3,255
811169b8:	31808034 	orhi	r6,r6,512
811169bc:	003fd506 	br	81116914 <__reset+0xfb0f6914>
811169c0:	303fe226 	beq	r6,zero,8111694c <__reset+0xfb0f694c>
811169c4:	00802034 	movhi	r2,128
811169c8:	31801034 	orhi	r6,r6,64
811169cc:	10bfffc4 	addi	r2,r2,-1
811169d0:	00ffffc4 	movi	r3,-1
811169d4:	308c703a 	and	r6,r6,r2
811169d8:	003fde06 	br	81116954 <__reset+0xfb0f6954>
811169dc:	013ffa44 	movi	r4,-23
811169e0:	19000e16 	blt	r3,r4,81116a1c <__truncdfsf2+0x168>
811169e4:	01000784 	movi	r4,30
811169e8:	20c9c83a 	sub	r4,r4,r3
811169ec:	018007c4 	movi	r6,31
811169f0:	39c02034 	orhi	r7,r7,128
811169f4:	31000b16 	blt	r6,r4,81116a24 <__truncdfsf2+0x170>
811169f8:	423f2084 	addi	r8,r8,-894
811169fc:	120c983a 	sll	r6,r2,r8
81116a00:	3a0e983a 	sll	r7,r7,r8
81116a04:	1104d83a 	srl	r2,r2,r4
81116a08:	300cc03a 	cmpne	r6,r6,zero
81116a0c:	31ceb03a 	or	r7,r6,r7
81116a10:	388cb03a 	or	r6,r7,r2
81116a14:	0007883a 	mov	r3,zero
81116a18:	003fbe06 	br	81116914 <__reset+0xfb0f6914>
81116a1c:	0007883a 	mov	r3,zero
81116a20:	003fd906 	br	81116988 <__reset+0xfb0f6988>
81116a24:	01bfff84 	movi	r6,-2
81116a28:	30cdc83a 	sub	r6,r6,r3
81116a2c:	00c00804 	movi	r3,32
81116a30:	398cd83a 	srl	r6,r7,r6
81116a34:	20c00726 	beq	r4,r3,81116a54 <__truncdfsf2+0x1a0>
81116a38:	423f2884 	addi	r8,r8,-862
81116a3c:	3a0e983a 	sll	r7,r7,r8
81116a40:	3884b03a 	or	r2,r7,r2
81116a44:	1004c03a 	cmpne	r2,r2,zero
81116a48:	118cb03a 	or	r6,r2,r6
81116a4c:	0007883a 	mov	r3,zero
81116a50:	003fb006 	br	81116914 <__reset+0xfb0f6914>
81116a54:	000f883a 	mov	r7,zero
81116a58:	003ff906 	br	81116a40 <__reset+0xfb0f6a40>

81116a5c <__clzsi2>:
81116a5c:	00bfffd4 	movui	r2,65535
81116a60:	11000536 	bltu	r2,r4,81116a78 <__clzsi2+0x1c>
81116a64:	00803fc4 	movi	r2,255
81116a68:	11000f36 	bltu	r2,r4,81116aa8 <__clzsi2+0x4c>
81116a6c:	00800804 	movi	r2,32
81116a70:	0007883a 	mov	r3,zero
81116a74:	00000506 	br	81116a8c <__clzsi2+0x30>
81116a78:	00804034 	movhi	r2,256
81116a7c:	10bfffc4 	addi	r2,r2,-1
81116a80:	11000c2e 	bgeu	r2,r4,81116ab4 <__clzsi2+0x58>
81116a84:	00800204 	movi	r2,8
81116a88:	00c00604 	movi	r3,24
81116a8c:	20c8d83a 	srl	r4,r4,r3
81116a90:	00e04534 	movhi	r3,33044
81116a94:	18d64704 	addi	r3,r3,22812
81116a98:	1909883a 	add	r4,r3,r4
81116a9c:	20c00003 	ldbu	r3,0(r4)
81116aa0:	10c5c83a 	sub	r2,r2,r3
81116aa4:	f800283a 	ret
81116aa8:	00800604 	movi	r2,24
81116aac:	00c00204 	movi	r3,8
81116ab0:	003ff606 	br	81116a8c <__reset+0xfb0f6a8c>
81116ab4:	00800404 	movi	r2,16
81116ab8:	1007883a 	mov	r3,r2
81116abc:	003ff306 	br	81116a8c <__reset+0xfb0f6a8c>

81116ac0 <atoi>:
81116ac0:	01800284 	movi	r6,10
81116ac4:	000b883a 	mov	r5,zero
81116ac8:	1118adc1 	jmpi	81118adc <strtol>

81116acc <_atoi_r>:
81116acc:	01c00284 	movi	r7,10
81116ad0:	000d883a 	mov	r6,zero
81116ad4:	111889c1 	jmpi	8111889c <_strtol_r>

81116ad8 <_fopen_r>:
81116ad8:	defffa04 	addi	sp,sp,-24
81116adc:	3005883a 	mov	r2,r6
81116ae0:	de00012e 	bgeu	sp,et,81116ae8 <_fopen_r+0x10>
81116ae4:	003b68fa 	trap	3
81116ae8:	d80d883a 	mov	r6,sp
81116aec:	dcc00415 	stw	r19,16(sp)
81116af0:	2827883a 	mov	r19,r5
81116af4:	100b883a 	mov	r5,r2
81116af8:	dc800315 	stw	r18,12(sp)
81116afc:	dfc00515 	stw	ra,20(sp)
81116b00:	dc400215 	stw	r17,8(sp)
81116b04:	dc000115 	stw	r16,4(sp)
81116b08:	2025883a 	mov	r18,r4
81116b0c:	1120ae40 	call	81120ae4 <__sflags>
81116b10:	10002726 	beq	r2,zero,81116bb0 <_fopen_r+0xd8>
81116b14:	9009883a 	mov	r4,r18
81116b18:	1023883a 	mov	r17,r2
81116b1c:	112095c0 	call	8112095c <__sfp>
81116b20:	1021883a 	mov	r16,r2
81116b24:	10002226 	beq	r2,zero,81116bb0 <_fopen_r+0xd8>
81116b28:	d9800017 	ldw	r6,0(sp)
81116b2c:	01c06d84 	movi	r7,438
81116b30:	980b883a 	mov	r5,r19
81116b34:	9009883a 	mov	r4,r18
81116b38:	1117f440 	call	81117f44 <_open_r>
81116b3c:	10001916 	blt	r2,zero,81116ba4 <_fopen_r+0xcc>
81116b40:	8080038d 	sth	r2,14(r16)
81116b44:	00a044b4 	movhi	r2,33042
81116b48:	10a18804 	addi	r2,r2,-31200
81116b4c:	80800815 	stw	r2,32(r16)
81116b50:	00a044b4 	movhi	r2,33042
81116b54:	10a1a104 	addi	r2,r2,-31100
81116b58:	80800915 	stw	r2,36(r16)
81116b5c:	00a044b4 	movhi	r2,33042
81116b60:	10a1c204 	addi	r2,r2,-30968
81116b64:	80800a15 	stw	r2,40(r16)
81116b68:	00a044b4 	movhi	r2,33042
81116b6c:	10a1db04 	addi	r2,r2,-30868
81116b70:	8440030d 	sth	r17,12(r16)
81116b74:	84000715 	stw	r16,28(r16)
81116b78:	80800b15 	stw	r2,44(r16)
81116b7c:	8c40400c 	andi	r17,r17,256
81116b80:	88000d1e 	bne	r17,zero,81116bb8 <_fopen_r+0xe0>
81116b84:	8005883a 	mov	r2,r16
81116b88:	dfc00517 	ldw	ra,20(sp)
81116b8c:	dcc00417 	ldw	r19,16(sp)
81116b90:	dc800317 	ldw	r18,12(sp)
81116b94:	dc400217 	ldw	r17,8(sp)
81116b98:	dc000117 	ldw	r16,4(sp)
81116b9c:	dec00604 	addi	sp,sp,24
81116ba0:	f800283a 	ret
81116ba4:	1120aa40 	call	81120aa4 <__sfp_lock_acquire>
81116ba8:	8000030d 	sth	zero,12(r16)
81116bac:	1120aa80 	call	81120aa8 <__sfp_lock_release>
81116bb0:	0005883a 	mov	r2,zero
81116bb4:	003ff406 	br	81116b88 <__reset+0xfb0f6b88>
81116bb8:	01c00084 	movi	r7,2
81116bbc:	000d883a 	mov	r6,zero
81116bc0:	800b883a 	mov	r5,r16
81116bc4:	9009883a 	mov	r4,r18
81116bc8:	1116cf80 	call	81116cf8 <_fseek_r>
81116bcc:	8005883a 	mov	r2,r16
81116bd0:	003fed06 	br	81116b88 <__reset+0xfb0f6b88>

81116bd4 <fopen>:
81116bd4:	00a04574 	movhi	r2,33045
81116bd8:	10a10204 	addi	r2,r2,-31736
81116bdc:	280d883a 	mov	r6,r5
81116be0:	200b883a 	mov	r5,r4
81116be4:	11000017 	ldw	r4,0(r2)
81116be8:	1116ad81 	jmpi	81116ad8 <_fopen_r>

81116bec <_fprintf_r>:
81116bec:	defffe04 	addi	sp,sp,-8
81116bf0:	2809883a 	mov	r4,r5
81116bf4:	300b883a 	mov	r5,r6
81116bf8:	de00012e 	bgeu	sp,et,81116c00 <_fprintf_r+0x14>
81116bfc:	003b68fa 	trap	3
81116c00:	dfc00015 	stw	ra,0(sp)
81116c04:	d9c00115 	stw	r7,4(sp)
81116c08:	d9800104 	addi	r6,sp,4
81116c0c:	111ced80 	call	8111ced8 <__vfprintf_internal>
81116c10:	dfc00017 	ldw	ra,0(sp)
81116c14:	dec00204 	addi	sp,sp,8
81116c18:	f800283a 	ret

81116c1c <fprintf>:
81116c1c:	defffd04 	addi	sp,sp,-12
81116c20:	de00012e 	bgeu	sp,et,81116c28 <fprintf+0xc>
81116c24:	003b68fa 	trap	3
81116c28:	dfc00015 	stw	ra,0(sp)
81116c2c:	d9800115 	stw	r6,4(sp)
81116c30:	d9c00215 	stw	r7,8(sp)
81116c34:	d9800104 	addi	r6,sp,4
81116c38:	111ced80 	call	8111ced8 <__vfprintf_internal>
81116c3c:	dfc00017 	ldw	ra,0(sp)
81116c40:	dec00304 	addi	sp,sp,12
81116c44:	f800283a 	ret

81116c48 <_fputc_r>:
81116c48:	defffc04 	addi	sp,sp,-16
81116c4c:	de00012e 	bgeu	sp,et,81116c54 <_fputc_r+0xc>
81116c50:	003b68fa 	trap	3
81116c54:	dc000215 	stw	r16,8(sp)
81116c58:	dfc00315 	stw	ra,12(sp)
81116c5c:	2021883a 	mov	r16,r4
81116c60:	20000726 	beq	r4,zero,81116c80 <_fputc_r+0x38>
81116c64:	20800e17 	ldw	r2,56(r4)
81116c68:	1000051e 	bne	r2,zero,81116c80 <_fputc_r+0x38>
81116c6c:	d9400015 	stw	r5,0(sp)
81116c70:	d9800115 	stw	r6,4(sp)
81116c74:	1120a940 	call	81120a94 <__sinit>
81116c78:	d9800117 	ldw	r6,4(sp)
81116c7c:	d9400017 	ldw	r5,0(sp)
81116c80:	8009883a 	mov	r4,r16
81116c84:	dfc00317 	ldw	ra,12(sp)
81116c88:	dc000217 	ldw	r16,8(sp)
81116c8c:	dec00404 	addi	sp,sp,16
81116c90:	11180281 	jmpi	81118028 <_putc_r>

81116c94 <fputc>:
81116c94:	00a04574 	movhi	r2,33045
81116c98:	defffc04 	addi	sp,sp,-16
81116c9c:	10a10204 	addi	r2,r2,-31736
81116ca0:	de00012e 	bgeu	sp,et,81116ca8 <fputc+0x14>
81116ca4:	003b68fa 	trap	3
81116ca8:	dc000115 	stw	r16,4(sp)
81116cac:	14000017 	ldw	r16,0(r2)
81116cb0:	dc400215 	stw	r17,8(sp)
81116cb4:	dfc00315 	stw	ra,12(sp)
81116cb8:	2023883a 	mov	r17,r4
81116cbc:	80000626 	beq	r16,zero,81116cd8 <fputc+0x44>
81116cc0:	80800e17 	ldw	r2,56(r16)
81116cc4:	1000041e 	bne	r2,zero,81116cd8 <fputc+0x44>
81116cc8:	8009883a 	mov	r4,r16
81116ccc:	d9400015 	stw	r5,0(sp)
81116cd0:	1120a940 	call	81120a94 <__sinit>
81116cd4:	d9400017 	ldw	r5,0(sp)
81116cd8:	280d883a 	mov	r6,r5
81116cdc:	8009883a 	mov	r4,r16
81116ce0:	880b883a 	mov	r5,r17
81116ce4:	dfc00317 	ldw	ra,12(sp)
81116ce8:	dc400217 	ldw	r17,8(sp)
81116cec:	dc000117 	ldw	r16,4(sp)
81116cf0:	dec00404 	addi	sp,sp,16
81116cf4:	11180281 	jmpi	81118028 <_putc_r>

81116cf8 <_fseek_r>:
81116cf8:	1116d181 	jmpi	81116d18 <_fseeko_r>

81116cfc <fseek>:
81116cfc:	00a04574 	movhi	r2,33045
81116d00:	10a10204 	addi	r2,r2,-31736
81116d04:	300f883a 	mov	r7,r6
81116d08:	280d883a 	mov	r6,r5
81116d0c:	200b883a 	mov	r5,r4
81116d10:	11000017 	ldw	r4,0(r2)
81116d14:	1116d181 	jmpi	81116d18 <_fseeko_r>

81116d18 <_fseeko_r>:
81116d18:	deffe804 	addi	sp,sp,-96
81116d1c:	de00012e 	bgeu	sp,et,81116d24 <_fseeko_r+0xc>
81116d20:	003b68fa 	trap	3
81116d24:	dd401415 	stw	r21,80(sp)
81116d28:	dc801115 	stw	r18,68(sp)
81116d2c:	dc401015 	stw	r17,64(sp)
81116d30:	dc000f15 	stw	r16,60(sp)
81116d34:	dfc01715 	stw	ra,92(sp)
81116d38:	ddc01615 	stw	r23,88(sp)
81116d3c:	dd801515 	stw	r22,84(sp)
81116d40:	dd001315 	stw	r20,76(sp)
81116d44:	dcc01215 	stw	r19,72(sp)
81116d48:	2023883a 	mov	r17,r4
81116d4c:	2821883a 	mov	r16,r5
81116d50:	302b883a 	mov	r21,r6
81116d54:	3825883a 	mov	r18,r7
81116d58:	20000226 	beq	r4,zero,81116d64 <_fseeko_r+0x4c>
81116d5c:	20800e17 	ldw	r2,56(r4)
81116d60:	10005a26 	beq	r2,zero,81116ecc <_fseeko_r+0x1b4>
81116d64:	8080030b 	ldhu	r2,12(r16)
81116d68:	00c04204 	movi	r3,264
81116d6c:	1080420c 	andi	r2,r2,264
81116d70:	10c05b26 	beq	r2,r3,81116ee0 <_fseeko_r+0x1c8>
81116d74:	85000a17 	ldw	r20,40(r16)
81116d78:	a000f626 	beq	r20,zero,81117154 <_fseeko_r+0x43c>
81116d7c:	00800044 	movi	r2,1
81116d80:	90803e26 	beq	r18,r2,81116e7c <_fseeko_r+0x164>
81116d84:	00800084 	movi	r2,2
81116d88:	90801026 	beq	r18,r2,81116dcc <_fseeko_r+0xb4>
81116d8c:	90000f26 	beq	r18,zero,81116dcc <_fseeko_r+0xb4>
81116d90:	00800584 	movi	r2,22
81116d94:	88800015 	stw	r2,0(r17)
81116d98:	04ffffc4 	movi	r19,-1
81116d9c:	9805883a 	mov	r2,r19
81116da0:	dfc01717 	ldw	ra,92(sp)
81116da4:	ddc01617 	ldw	r23,88(sp)
81116da8:	dd801517 	ldw	r22,84(sp)
81116dac:	dd401417 	ldw	r21,80(sp)
81116db0:	dd001317 	ldw	r20,76(sp)
81116db4:	dcc01217 	ldw	r19,72(sp)
81116db8:	dc801117 	ldw	r18,68(sp)
81116dbc:	dc401017 	ldw	r17,64(sp)
81116dc0:	dc000f17 	ldw	r16,60(sp)
81116dc4:	dec01804 	addi	sp,sp,96
81116dc8:	f800283a 	ret
81116dcc:	80800417 	ldw	r2,16(r16)
81116dd0:	002f883a 	mov	r23,zero
81116dd4:	0027883a 	mov	r19,zero
81116dd8:	1000cb26 	beq	r2,zero,81117108 <_fseeko_r+0x3f0>
81116ddc:	8080030b 	ldhu	r2,12(r16)
81116de0:	10c2068c 	andi	r3,r2,2074
81116de4:	1800071e 	bne	r3,zero,81116e04 <_fseeko_r+0xec>
81116de8:	10c1000c 	andi	r3,r2,1024
81116dec:	1800451e 	bne	r3,zero,81116f04 <_fseeko_r+0x1ec>
81116df0:	00e044b4 	movhi	r3,33042
81116df4:	18e1c204 	addi	r3,r3,-30968
81116df8:	a0c0b726 	beq	r20,r3,811170d8 <_fseeko_r+0x3c0>
81116dfc:	10820014 	ori	r2,r2,2048
81116e00:	8080030d 	sth	r2,12(r16)
81116e04:	800b883a 	mov	r5,r16
81116e08:	8809883a 	mov	r4,r17
81116e0c:	11206980 	call	81120698 <_fflush_r>
81116e10:	1027883a 	mov	r19,r2
81116e14:	103fe01e 	bne	r2,zero,81116d98 <__reset+0xfb0f6d98>
81116e18:	81400717 	ldw	r5,28(r16)
81116e1c:	900f883a 	mov	r7,r18
81116e20:	a80d883a 	mov	r6,r21
81116e24:	8809883a 	mov	r4,r17
81116e28:	a03ee83a 	callr	r20
81116e2c:	00ffffc4 	movi	r3,-1
81116e30:	10ffd926 	beq	r2,r3,81116d98 <__reset+0xfb0f6d98>
81116e34:	81400c17 	ldw	r5,48(r16)
81116e38:	28000526 	beq	r5,zero,81116e50 <_fseeko_r+0x138>
81116e3c:	80801004 	addi	r2,r16,64
81116e40:	28800226 	beq	r5,r2,81116e4c <_fseeko_r+0x134>
81116e44:	8809883a 	mov	r4,r17
81116e48:	1120f2c0 	call	81120f2c <_free_r>
81116e4c:	80000c15 	stw	zero,48(r16)
81116e50:	8080030b 	ldhu	r2,12(r16)
81116e54:	80c00417 	ldw	r3,16(r16)
81116e58:	80000115 	stw	zero,4(r16)
81116e5c:	10bdf7cc 	andi	r2,r2,63455
81116e60:	80c00015 	stw	r3,0(r16)
81116e64:	8080030d 	sth	r2,12(r16)
81116e68:	01800204 	movi	r6,8
81116e6c:	000b883a 	mov	r5,zero
81116e70:	81001704 	addi	r4,r16,92
81116e74:	1117e1c0 	call	81117e1c <memset>
81116e78:	003fc806 	br	81116d9c <__reset+0xfb0f6d9c>
81116e7c:	800b883a 	mov	r5,r16
81116e80:	8809883a 	mov	r4,r17
81116e84:	11206980 	call	81120698 <_fflush_r>
81116e88:	8080030b 	ldhu	r2,12(r16)
81116e8c:	10c4000c 	andi	r3,r2,4096
81116e90:	18008726 	beq	r3,zero,811170b0 <_fseeko_r+0x398>
81116e94:	84c01417 	ldw	r19,80(r16)
81116e98:	10c0010c 	andi	r3,r2,4
81116e9c:	1800431e 	bne	r3,zero,81116fac <_fseeko_r+0x294>
81116ea0:	1080020c 	andi	r2,r2,8
81116ea4:	10008026 	beq	r2,zero,811170a8 <_fseeko_r+0x390>
81116ea8:	80c00017 	ldw	r3,0(r16)
81116eac:	80800417 	ldw	r2,16(r16)
81116eb0:	18000226 	beq	r3,zero,81116ebc <_fseeko_r+0x1a4>
81116eb4:	1887c83a 	sub	r3,r3,r2
81116eb8:	98e7883a 	add	r19,r19,r3
81116ebc:	aceb883a 	add	r21,r21,r19
81116ec0:	05c00044 	movi	r23,1
81116ec4:	0025883a 	mov	r18,zero
81116ec8:	003fc306 	br	81116dd8 <__reset+0xfb0f6dd8>
81116ecc:	1120a940 	call	81120a94 <__sinit>
81116ed0:	8080030b 	ldhu	r2,12(r16)
81116ed4:	00c04204 	movi	r3,264
81116ed8:	1080420c 	andi	r2,r2,264
81116edc:	10ffa51e 	bne	r2,r3,81116d74 <__reset+0xfb0f6d74>
81116ee0:	800b883a 	mov	r5,r16
81116ee4:	8809883a 	mov	r4,r17
81116ee8:	11206980 	call	81120698 <_fflush_r>
81116eec:	003fa106 	br	81116d74 <__reset+0xfb0f6d74>
81116ef0:	8080030b 	ldhu	r2,12(r16)
81116ef4:	00c10004 	movi	r3,1024
81116ef8:	80c01315 	stw	r3,76(r16)
81116efc:	10c4b03a 	or	r2,r2,r3
81116f00:	8080030d 	sth	r2,12(r16)
81116f04:	9000311e 	bne	r18,zero,81116fcc <_fseeko_r+0x2b4>
81116f08:	a82d883a 	mov	r22,r21
81116f0c:	b800371e 	bne	r23,zero,81116fec <_fseeko_r+0x2d4>
81116f10:	8080030b 	ldhu	r2,12(r16)
81116f14:	1084000c 	andi	r2,r2,4096
81116f18:	10007f26 	beq	r2,zero,81117118 <_fseeko_r+0x400>
81116f1c:	80801417 	ldw	r2,80(r16)
81116f20:	81800117 	ldw	r6,4(r16)
81116f24:	81400c17 	ldw	r5,48(r16)
81116f28:	11a7c83a 	sub	r19,r2,r6
81116f2c:	28008226 	beq	r5,zero,81117138 <_fseeko_r+0x420>
81116f30:	81c00f17 	ldw	r7,60(r16)
81116f34:	99e7c83a 	sub	r19,r19,r7
81116f38:	81000e17 	ldw	r4,56(r16)
81116f3c:	80800417 	ldw	r2,16(r16)
81116f40:	99a7883a 	add	r19,r19,r6
81116f44:	2087c83a 	sub	r3,r4,r2
81116f48:	98e7c83a 	sub	r19,r19,r3
81116f4c:	38c7883a 	add	r3,r7,r3
81116f50:	b4c02b16 	blt	r22,r19,81117000 <_fseeko_r+0x2e8>
81116f54:	98c9883a 	add	r4,r19,r3
81116f58:	b100292e 	bgeu	r22,r4,81117000 <_fseeko_r+0x2e8>
81116f5c:	b4e7c83a 	sub	r19,r22,r19
81116f60:	14c5883a 	add	r2,r2,r19
81116f64:	1ce7c83a 	sub	r19,r3,r19
81116f68:	80800015 	stw	r2,0(r16)
81116f6c:	84c00115 	stw	r19,4(r16)
81116f70:	28000526 	beq	r5,zero,81116f88 <_fseeko_r+0x270>
81116f74:	80801004 	addi	r2,r16,64
81116f78:	28800226 	beq	r5,r2,81116f84 <_fseeko_r+0x26c>
81116f7c:	8809883a 	mov	r4,r17
81116f80:	1120f2c0 	call	81120f2c <_free_r>
81116f84:	80000c15 	stw	zero,48(r16)
81116f88:	8080030b 	ldhu	r2,12(r16)
81116f8c:	01800204 	movi	r6,8
81116f90:	000b883a 	mov	r5,zero
81116f94:	10bff7cc 	andi	r2,r2,65503
81116f98:	8080030d 	sth	r2,12(r16)
81116f9c:	81001704 	addi	r4,r16,92
81116fa0:	1117e1c0 	call	81117e1c <memset>
81116fa4:	0027883a 	mov	r19,zero
81116fa8:	003f7c06 	br	81116d9c <__reset+0xfb0f6d9c>
81116fac:	80c00117 	ldw	r3,4(r16)
81116fb0:	80800c17 	ldw	r2,48(r16)
81116fb4:	98e7c83a 	sub	r19,r19,r3
81116fb8:	10003b26 	beq	r2,zero,811170a8 <_fseeko_r+0x390>
81116fbc:	80c00f17 	ldw	r3,60(r16)
81116fc0:	80800417 	ldw	r2,16(r16)
81116fc4:	98e7c83a 	sub	r19,r19,r3
81116fc8:	003fbc06 	br	81116ebc <__reset+0xfb0f6ebc>
81116fcc:	8140038f 	ldh	r5,14(r16)
81116fd0:	d80d883a 	mov	r6,sp
81116fd4:	8809883a 	mov	r4,r17
81116fd8:	11171800 	call	81117180 <_fstat_r>
81116fdc:	103f891e 	bne	r2,zero,81116e04 <__reset+0xfb0f6e04>
81116fe0:	dd800417 	ldw	r22,16(sp)
81116fe4:	adad883a 	add	r22,r21,r22
81116fe8:	b83fc926 	beq	r23,zero,81116f10 <__reset+0xfb0f6f10>
81116fec:	81400c17 	ldw	r5,48(r16)
81116ff0:	81800117 	ldw	r6,4(r16)
81116ff4:	28005026 	beq	r5,zero,81117138 <_fseeko_r+0x420>
81116ff8:	81c00f17 	ldw	r7,60(r16)
81116ffc:	003fce06 	br	81116f38 <__reset+0xfb0f6f38>
81117000:	84c01317 	ldw	r19,76(r16)
81117004:	81400717 	ldw	r5,28(r16)
81117008:	000f883a 	mov	r7,zero
8111700c:	04e7c83a 	sub	r19,zero,r19
81117010:	9da6703a 	and	r19,r19,r22
81117014:	980d883a 	mov	r6,r19
81117018:	8809883a 	mov	r4,r17
8111701c:	a03ee83a 	callr	r20
81117020:	00ffffc4 	movi	r3,-1
81117024:	10ff7726 	beq	r2,r3,81116e04 <__reset+0xfb0f6e04>
81117028:	80800417 	ldw	r2,16(r16)
8111702c:	81400c17 	ldw	r5,48(r16)
81117030:	80000115 	stw	zero,4(r16)
81117034:	80800015 	stw	r2,0(r16)
81117038:	28000526 	beq	r5,zero,81117050 <_fseeko_r+0x338>
8111703c:	80801004 	addi	r2,r16,64
81117040:	28800226 	beq	r5,r2,8111704c <_fseeko_r+0x334>
81117044:	8809883a 	mov	r4,r17
81117048:	1120f2c0 	call	81120f2c <_free_r>
8111704c:	80000c15 	stw	zero,48(r16)
81117050:	8080030b 	ldhu	r2,12(r16)
81117054:	b4e7c83a 	sub	r19,r22,r19
81117058:	10bff7cc 	andi	r2,r2,65503
8111705c:	8080030d 	sth	r2,12(r16)
81117060:	98000b26 	beq	r19,zero,81117090 <_fseeko_r+0x378>
81117064:	800b883a 	mov	r5,r16
81117068:	8809883a 	mov	r4,r17
8111706c:	11182980 	call	81118298 <__srefill_r>
81117070:	103f641e 	bne	r2,zero,81116e04 <__reset+0xfb0f6e04>
81117074:	80800117 	ldw	r2,4(r16)
81117078:	14ff6236 	bltu	r2,r19,81116e04 <__reset+0xfb0f6e04>
8111707c:	80c00017 	ldw	r3,0(r16)
81117080:	14c5c83a 	sub	r2,r2,r19
81117084:	80800115 	stw	r2,4(r16)
81117088:	1ce7883a 	add	r19,r3,r19
8111708c:	84c00015 	stw	r19,0(r16)
81117090:	01800204 	movi	r6,8
81117094:	000b883a 	mov	r5,zero
81117098:	81001704 	addi	r4,r16,92
8111709c:	1117e1c0 	call	81117e1c <memset>
811170a0:	0027883a 	mov	r19,zero
811170a4:	003f3d06 	br	81116d9c <__reset+0xfb0f6d9c>
811170a8:	80800417 	ldw	r2,16(r16)
811170ac:	003f8306 	br	81116ebc <__reset+0xfb0f6ebc>
811170b0:	81400717 	ldw	r5,28(r16)
811170b4:	900f883a 	mov	r7,r18
811170b8:	000d883a 	mov	r6,zero
811170bc:	8809883a 	mov	r4,r17
811170c0:	a03ee83a 	callr	r20
811170c4:	1027883a 	mov	r19,r2
811170c8:	00bfffc4 	movi	r2,-1
811170cc:	98bf3226 	beq	r19,r2,81116d98 <__reset+0xfb0f6d98>
811170d0:	8080030b 	ldhu	r2,12(r16)
811170d4:	003f7006 	br	81116e98 <__reset+0xfb0f6e98>
811170d8:	8140038f 	ldh	r5,14(r16)
811170dc:	283f4716 	blt	r5,zero,81116dfc <__reset+0xfb0f6dfc>
811170e0:	d80d883a 	mov	r6,sp
811170e4:	8809883a 	mov	r4,r17
811170e8:	11171800 	call	81117180 <_fstat_r>
811170ec:	1000041e 	bne	r2,zero,81117100 <_fseeko_r+0x3e8>
811170f0:	d8800117 	ldw	r2,4(sp)
811170f4:	00e00014 	movui	r3,32768
811170f8:	10bc000c 	andi	r2,r2,61440
811170fc:	10ff7c26 	beq	r2,r3,81116ef0 <__reset+0xfb0f6ef0>
81117100:	8080030b 	ldhu	r2,12(r16)
81117104:	003f3d06 	br	81116dfc <__reset+0xfb0f6dfc>
81117108:	800b883a 	mov	r5,r16
8111710c:	8809883a 	mov	r4,r17
81117110:	11172f40 	call	811172f4 <__smakebuf_r>
81117114:	003f3106 	br	81116ddc <__reset+0xfb0f6ddc>
81117118:	81400717 	ldw	r5,28(r16)
8111711c:	01c00044 	movi	r7,1
81117120:	000d883a 	mov	r6,zero
81117124:	8809883a 	mov	r4,r17
81117128:	a03ee83a 	callr	r20
8111712c:	00ffffc4 	movi	r3,-1
81117130:	10ff7b1e 	bne	r2,r3,81116f20 <__reset+0xfb0f6f20>
81117134:	003f3306 	br	81116e04 <__reset+0xfb0f6e04>
81117138:	80c00017 	ldw	r3,0(r16)
8111713c:	80800417 	ldw	r2,16(r16)
81117140:	000b883a 	mov	r5,zero
81117144:	1887c83a 	sub	r3,r3,r2
81117148:	98e7c83a 	sub	r19,r19,r3
8111714c:	30c7883a 	add	r3,r6,r3
81117150:	003f7f06 	br	81116f50 <__reset+0xfb0f6f50>
81117154:	00800744 	movi	r2,29
81117158:	88800015 	stw	r2,0(r17)
8111715c:	04ffffc4 	movi	r19,-1
81117160:	003f0e06 	br	81116d9c <__reset+0xfb0f6d9c>

81117164 <fseeko>:
81117164:	00a04574 	movhi	r2,33045
81117168:	10a10204 	addi	r2,r2,-31736
8111716c:	300f883a 	mov	r7,r6
81117170:	280d883a 	mov	r6,r5
81117174:	200b883a 	mov	r5,r4
81117178:	11000017 	ldw	r4,0(r2)
8111717c:	1116d181 	jmpi	81116d18 <_fseeko_r>

81117180 <_fstat_r>:
81117180:	defffd04 	addi	sp,sp,-12
81117184:	de00012e 	bgeu	sp,et,8111718c <_fstat_r+0xc>
81117188:	003b68fa 	trap	3
8111718c:	2805883a 	mov	r2,r5
81117190:	dc000015 	stw	r16,0(sp)
81117194:	04204574 	movhi	r16,33045
81117198:	dc400115 	stw	r17,4(sp)
8111719c:	84216604 	addi	r16,r16,-31336
811171a0:	2023883a 	mov	r17,r4
811171a4:	300b883a 	mov	r5,r6
811171a8:	1009883a 	mov	r4,r2
811171ac:	dfc00215 	stw	ra,8(sp)
811171b0:	80000015 	stw	zero,0(r16)
811171b4:	112c76c0 	call	8112c76c <fstat>
811171b8:	00ffffc4 	movi	r3,-1
811171bc:	10c00526 	beq	r2,r3,811171d4 <_fstat_r+0x54>
811171c0:	dfc00217 	ldw	ra,8(sp)
811171c4:	dc400117 	ldw	r17,4(sp)
811171c8:	dc000017 	ldw	r16,0(sp)
811171cc:	dec00304 	addi	sp,sp,12
811171d0:	f800283a 	ret
811171d4:	80c00017 	ldw	r3,0(r16)
811171d8:	183ff926 	beq	r3,zero,811171c0 <__reset+0xfb0f71c0>
811171dc:	88c00015 	stw	r3,0(r17)
811171e0:	003ff706 	br	811171c0 <__reset+0xfb0f71c0>

811171e4 <_fwrite_r>:
811171e4:	defff504 	addi	sp,sp,-44
811171e8:	de00012e 	bgeu	sp,et,811171f0 <_fwrite_r+0xc>
811171ec:	003b68fa 	trap	3
811171f0:	dc800815 	stw	r18,32(sp)
811171f4:	39a5383a 	mul	r18,r7,r6
811171f8:	d8800304 	addi	r2,sp,12
811171fc:	d8800015 	stw	r2,0(sp)
81117200:	00800044 	movi	r2,1
81117204:	dcc00915 	stw	r19,36(sp)
81117208:	dc400715 	stw	r17,28(sp)
8111720c:	dc000615 	stw	r16,24(sp)
81117210:	d9400315 	stw	r5,12(sp)
81117214:	dfc00a15 	stw	ra,40(sp)
81117218:	dc800415 	stw	r18,16(sp)
8111721c:	dc800215 	stw	r18,8(sp)
81117220:	d8800115 	stw	r2,4(sp)
81117224:	3027883a 	mov	r19,r6
81117228:	3821883a 	mov	r16,r7
8111722c:	2023883a 	mov	r17,r4
81117230:	d9400b17 	ldw	r5,44(sp)
81117234:	20000226 	beq	r4,zero,81117240 <_fwrite_r+0x5c>
81117238:	20800e17 	ldw	r2,56(r4)
8111723c:	10001a26 	beq	r2,zero,811172a8 <_fwrite_r+0xc4>
81117240:	2880030b 	ldhu	r2,12(r5)
81117244:	10c8000c 	andi	r3,r2,8192
81117248:	1800061e 	bne	r3,zero,81117264 <_fwrite_r+0x80>
8111724c:	29001917 	ldw	r4,100(r5)
81117250:	00f7ffc4 	movi	r3,-8193
81117254:	10880014 	ori	r2,r2,8192
81117258:	20c6703a 	and	r3,r4,r3
8111725c:	2880030d 	sth	r2,12(r5)
81117260:	28c01915 	stw	r3,100(r5)
81117264:	d80d883a 	mov	r6,sp
81117268:	8809883a 	mov	r4,r17
8111726c:	11212440 	call	81121244 <__sfvwrite_r>
81117270:	10000b26 	beq	r2,zero,811172a0 <_fwrite_r+0xbc>
81117274:	d9000217 	ldw	r4,8(sp)
81117278:	980b883a 	mov	r5,r19
8111727c:	9109c83a 	sub	r4,r18,r4
81117280:	112a2b40 	call	8112a2b4 <__udivsi3>
81117284:	dfc00a17 	ldw	ra,40(sp)
81117288:	dcc00917 	ldw	r19,36(sp)
8111728c:	dc800817 	ldw	r18,32(sp)
81117290:	dc400717 	ldw	r17,28(sp)
81117294:	dc000617 	ldw	r16,24(sp)
81117298:	dec00b04 	addi	sp,sp,44
8111729c:	f800283a 	ret
811172a0:	8005883a 	mov	r2,r16
811172a4:	003ff706 	br	81117284 <__reset+0xfb0f7284>
811172a8:	d9400515 	stw	r5,20(sp)
811172ac:	1120a940 	call	81120a94 <__sinit>
811172b0:	d9400517 	ldw	r5,20(sp)
811172b4:	003fe206 	br	81117240 <__reset+0xfb0f7240>

811172b8 <fwrite>:
811172b8:	defffe04 	addi	sp,sp,-8
811172bc:	00a04574 	movhi	r2,33045
811172c0:	de00012e 	bgeu	sp,et,811172c8 <fwrite+0x10>
811172c4:	003b68fa 	trap	3
811172c8:	10a10204 	addi	r2,r2,-31736
811172cc:	d9c00015 	stw	r7,0(sp)
811172d0:	300f883a 	mov	r7,r6
811172d4:	280d883a 	mov	r6,r5
811172d8:	200b883a 	mov	r5,r4
811172dc:	11000017 	ldw	r4,0(r2)
811172e0:	dfc00115 	stw	ra,4(sp)
811172e4:	11171e40 	call	811171e4 <_fwrite_r>
811172e8:	dfc00117 	ldw	ra,4(sp)
811172ec:	dec00204 	addi	sp,sp,8
811172f0:	f800283a 	ret

811172f4 <__smakebuf_r>:
811172f4:	2880030b 	ldhu	r2,12(r5)
811172f8:	10c0008c 	andi	r3,r2,2
811172fc:	1800431e 	bne	r3,zero,8111740c <__smakebuf_r+0x118>
81117300:	deffec04 	addi	sp,sp,-80
81117304:	de00012e 	bgeu	sp,et,8111730c <__smakebuf_r+0x18>
81117308:	003b68fa 	trap	3
8111730c:	dc000f15 	stw	r16,60(sp)
81117310:	2821883a 	mov	r16,r5
81117314:	2940038f 	ldh	r5,14(r5)
81117318:	dc401015 	stw	r17,64(sp)
8111731c:	dfc01315 	stw	ra,76(sp)
81117320:	dcc01215 	stw	r19,72(sp)
81117324:	dc801115 	stw	r18,68(sp)
81117328:	2023883a 	mov	r17,r4
8111732c:	28001c16 	blt	r5,zero,811173a0 <__smakebuf_r+0xac>
81117330:	d80d883a 	mov	r6,sp
81117334:	11171800 	call	81117180 <_fstat_r>
81117338:	10001816 	blt	r2,zero,8111739c <__smakebuf_r+0xa8>
8111733c:	d8800117 	ldw	r2,4(sp)
81117340:	00e00014 	movui	r3,32768
81117344:	10bc000c 	andi	r2,r2,61440
81117348:	14c80020 	cmpeqi	r19,r2,8192
8111734c:	10c03726 	beq	r2,r3,8111742c <__smakebuf_r+0x138>
81117350:	80c0030b 	ldhu	r3,12(r16)
81117354:	18c20014 	ori	r3,r3,2048
81117358:	80c0030d 	sth	r3,12(r16)
8111735c:	00c80004 	movi	r3,8192
81117360:	10c0521e 	bne	r2,r3,811174ac <__smakebuf_r+0x1b8>
81117364:	8140038f 	ldh	r5,14(r16)
81117368:	8809883a 	mov	r4,r17
8111736c:	11218a00 	call	811218a0 <_isatty_r>
81117370:	10004c26 	beq	r2,zero,811174a4 <__smakebuf_r+0x1b0>
81117374:	8080030b 	ldhu	r2,12(r16)
81117378:	80c010c4 	addi	r3,r16,67
8111737c:	80c00015 	stw	r3,0(r16)
81117380:	10800054 	ori	r2,r2,1
81117384:	8080030d 	sth	r2,12(r16)
81117388:	00800044 	movi	r2,1
8111738c:	80c00415 	stw	r3,16(r16)
81117390:	80800515 	stw	r2,20(r16)
81117394:	04810004 	movi	r18,1024
81117398:	00000706 	br	811173b8 <__smakebuf_r+0xc4>
8111739c:	8080030b 	ldhu	r2,12(r16)
811173a0:	10c0200c 	andi	r3,r2,128
811173a4:	18001f1e 	bne	r3,zero,81117424 <__smakebuf_r+0x130>
811173a8:	04810004 	movi	r18,1024
811173ac:	10820014 	ori	r2,r2,2048
811173b0:	8080030d 	sth	r2,12(r16)
811173b4:	0027883a 	mov	r19,zero
811173b8:	900b883a 	mov	r5,r18
811173bc:	8809883a 	mov	r4,r17
811173c0:	11174b80 	call	811174b8 <_malloc_r>
811173c4:	10002c26 	beq	r2,zero,81117478 <__smakebuf_r+0x184>
811173c8:	80c0030b 	ldhu	r3,12(r16)
811173cc:	012044b4 	movhi	r4,33042
811173d0:	2101cd04 	addi	r4,r4,1844
811173d4:	89000f15 	stw	r4,60(r17)
811173d8:	18c02014 	ori	r3,r3,128
811173dc:	80c0030d 	sth	r3,12(r16)
811173e0:	80800015 	stw	r2,0(r16)
811173e4:	80800415 	stw	r2,16(r16)
811173e8:	84800515 	stw	r18,20(r16)
811173ec:	98001a1e 	bne	r19,zero,81117458 <__smakebuf_r+0x164>
811173f0:	dfc01317 	ldw	ra,76(sp)
811173f4:	dcc01217 	ldw	r19,72(sp)
811173f8:	dc801117 	ldw	r18,68(sp)
811173fc:	dc401017 	ldw	r17,64(sp)
81117400:	dc000f17 	ldw	r16,60(sp)
81117404:	dec01404 	addi	sp,sp,80
81117408:	f800283a 	ret
8111740c:	288010c4 	addi	r2,r5,67
81117410:	28800015 	stw	r2,0(r5)
81117414:	28800415 	stw	r2,16(r5)
81117418:	00800044 	movi	r2,1
8111741c:	28800515 	stw	r2,20(r5)
81117420:	f800283a 	ret
81117424:	04801004 	movi	r18,64
81117428:	003fe006 	br	811173ac <__reset+0xfb0f73ac>
8111742c:	81000a17 	ldw	r4,40(r16)
81117430:	00e044b4 	movhi	r3,33042
81117434:	18e1c204 	addi	r3,r3,-30968
81117438:	20ffc51e 	bne	r4,r3,81117350 <__reset+0xfb0f7350>
8111743c:	8080030b 	ldhu	r2,12(r16)
81117440:	04810004 	movi	r18,1024
81117444:	84801315 	stw	r18,76(r16)
81117448:	1484b03a 	or	r2,r2,r18
8111744c:	8080030d 	sth	r2,12(r16)
81117450:	0027883a 	mov	r19,zero
81117454:	003fd806 	br	811173b8 <__reset+0xfb0f73b8>
81117458:	8140038f 	ldh	r5,14(r16)
8111745c:	8809883a 	mov	r4,r17
81117460:	11218a00 	call	811218a0 <_isatty_r>
81117464:	103fe226 	beq	r2,zero,811173f0 <__reset+0xfb0f73f0>
81117468:	8080030b 	ldhu	r2,12(r16)
8111746c:	10800054 	ori	r2,r2,1
81117470:	8080030d 	sth	r2,12(r16)
81117474:	003fde06 	br	811173f0 <__reset+0xfb0f73f0>
81117478:	8080030b 	ldhu	r2,12(r16)
8111747c:	10c0800c 	andi	r3,r2,512
81117480:	183fdb1e 	bne	r3,zero,811173f0 <__reset+0xfb0f73f0>
81117484:	10800094 	ori	r2,r2,2
81117488:	80c010c4 	addi	r3,r16,67
8111748c:	8080030d 	sth	r2,12(r16)
81117490:	00800044 	movi	r2,1
81117494:	80c00015 	stw	r3,0(r16)
81117498:	80c00415 	stw	r3,16(r16)
8111749c:	80800515 	stw	r2,20(r16)
811174a0:	003fd306 	br	811173f0 <__reset+0xfb0f73f0>
811174a4:	04810004 	movi	r18,1024
811174a8:	003fc306 	br	811173b8 <__reset+0xfb0f73b8>
811174ac:	0027883a 	mov	r19,zero
811174b0:	04810004 	movi	r18,1024
811174b4:	003fc006 	br	811173b8 <__reset+0xfb0f73b8>

811174b8 <_malloc_r>:
811174b8:	defff504 	addi	sp,sp,-44
811174bc:	de00012e 	bgeu	sp,et,811174c4 <_malloc_r+0xc>
811174c0:	003b68fa 	trap	3
811174c4:	288002c4 	addi	r2,r5,11
811174c8:	dc800315 	stw	r18,12(sp)
811174cc:	dfc00a15 	stw	ra,40(sp)
811174d0:	df000915 	stw	fp,36(sp)
811174d4:	ddc00815 	stw	r23,32(sp)
811174d8:	dd800715 	stw	r22,28(sp)
811174dc:	dd400615 	stw	r21,24(sp)
811174e0:	dd000515 	stw	r20,20(sp)
811174e4:	dcc00415 	stw	r19,16(sp)
811174e8:	dc400215 	stw	r17,8(sp)
811174ec:	dc000115 	stw	r16,4(sp)
811174f0:	00c00584 	movi	r3,22
811174f4:	2025883a 	mov	r18,r4
811174f8:	18807f2e 	bgeu	r3,r2,811176f8 <_malloc_r+0x240>
811174fc:	047ffe04 	movi	r17,-8
81117500:	1462703a 	and	r17,r2,r17
81117504:	8800a316 	blt	r17,zero,81117794 <_malloc_r+0x2dc>
81117508:	8940a236 	bltu	r17,r5,81117794 <_malloc_r+0x2dc>
8111750c:	112e2b40 	call	8112e2b4 <__malloc_lock>
81117510:	00807dc4 	movi	r2,503
81117514:	1441e92e 	bgeu	r2,r17,81117cbc <_malloc_r+0x804>
81117518:	8804d27a 	srli	r2,r17,9
8111751c:	1000a126 	beq	r2,zero,811177a4 <_malloc_r+0x2ec>
81117520:	00c00104 	movi	r3,4
81117524:	18811e36 	bltu	r3,r2,811179a0 <_malloc_r+0x4e8>
81117528:	8804d1ba 	srli	r2,r17,6
8111752c:	12000e44 	addi	r8,r2,57
81117530:	11c00e04 	addi	r7,r2,56
81117534:	4209883a 	add	r4,r8,r8
81117538:	04e04534 	movhi	r19,33044
8111753c:	2109883a 	add	r4,r4,r4
81117540:	9cdac004 	addi	r19,r19,27392
81117544:	2109883a 	add	r4,r4,r4
81117548:	9909883a 	add	r4,r19,r4
8111754c:	24000117 	ldw	r16,4(r4)
81117550:	213ffe04 	addi	r4,r4,-8
81117554:	24009726 	beq	r4,r16,811177b4 <_malloc_r+0x2fc>
81117558:	80800117 	ldw	r2,4(r16)
8111755c:	01bfff04 	movi	r6,-4
81117560:	014003c4 	movi	r5,15
81117564:	1184703a 	and	r2,r2,r6
81117568:	1447c83a 	sub	r3,r2,r17
8111756c:	28c00716 	blt	r5,r3,8111758c <_malloc_r+0xd4>
81117570:	1800920e 	bge	r3,zero,811177bc <_malloc_r+0x304>
81117574:	84000317 	ldw	r16,12(r16)
81117578:	24008e26 	beq	r4,r16,811177b4 <_malloc_r+0x2fc>
8111757c:	80800117 	ldw	r2,4(r16)
81117580:	1184703a 	and	r2,r2,r6
81117584:	1447c83a 	sub	r3,r2,r17
81117588:	28fff90e 	bge	r5,r3,81117570 <__reset+0xfb0f7570>
8111758c:	3809883a 	mov	r4,r7
81117590:	01a04534 	movhi	r6,33044
81117594:	9c000417 	ldw	r16,16(r19)
81117598:	319ac004 	addi	r6,r6,27392
8111759c:	32000204 	addi	r8,r6,8
811175a0:	82013426 	beq	r16,r8,81117a74 <_malloc_r+0x5bc>
811175a4:	80c00117 	ldw	r3,4(r16)
811175a8:	00bfff04 	movi	r2,-4
811175ac:	188e703a 	and	r7,r3,r2
811175b0:	3c45c83a 	sub	r2,r7,r17
811175b4:	00c003c4 	movi	r3,15
811175b8:	18811f16 	blt	r3,r2,81117a38 <_malloc_r+0x580>
811175bc:	32000515 	stw	r8,20(r6)
811175c0:	32000415 	stw	r8,16(r6)
811175c4:	10007f0e 	bge	r2,zero,811177c4 <_malloc_r+0x30c>
811175c8:	00807fc4 	movi	r2,511
811175cc:	11c0fd36 	bltu	r2,r7,811179c4 <_malloc_r+0x50c>
811175d0:	3806d0fa 	srli	r3,r7,3
811175d4:	01c00044 	movi	r7,1
811175d8:	30800117 	ldw	r2,4(r6)
811175dc:	19400044 	addi	r5,r3,1
811175e0:	294b883a 	add	r5,r5,r5
811175e4:	1807d0ba 	srai	r3,r3,2
811175e8:	294b883a 	add	r5,r5,r5
811175ec:	294b883a 	add	r5,r5,r5
811175f0:	298b883a 	add	r5,r5,r6
811175f4:	38c6983a 	sll	r3,r7,r3
811175f8:	29c00017 	ldw	r7,0(r5)
811175fc:	2a7ffe04 	addi	r9,r5,-8
81117600:	1886b03a 	or	r3,r3,r2
81117604:	82400315 	stw	r9,12(r16)
81117608:	81c00215 	stw	r7,8(r16)
8111760c:	30c00115 	stw	r3,4(r6)
81117610:	2c000015 	stw	r16,0(r5)
81117614:	3c000315 	stw	r16,12(r7)
81117618:	2005d0ba 	srai	r2,r4,2
8111761c:	01400044 	movi	r5,1
81117620:	288a983a 	sll	r5,r5,r2
81117624:	19406f36 	bltu	r3,r5,811177e4 <_malloc_r+0x32c>
81117628:	28c4703a 	and	r2,r5,r3
8111762c:	10000a1e 	bne	r2,zero,81117658 <_malloc_r+0x1a0>
81117630:	00bfff04 	movi	r2,-4
81117634:	294b883a 	add	r5,r5,r5
81117638:	2088703a 	and	r4,r4,r2
8111763c:	28c4703a 	and	r2,r5,r3
81117640:	21000104 	addi	r4,r4,4
81117644:	1000041e 	bne	r2,zero,81117658 <_malloc_r+0x1a0>
81117648:	294b883a 	add	r5,r5,r5
8111764c:	28c4703a 	and	r2,r5,r3
81117650:	21000104 	addi	r4,r4,4
81117654:	103ffc26 	beq	r2,zero,81117648 <__reset+0xfb0f7648>
81117658:	02bfff04 	movi	r10,-4
8111765c:	024003c4 	movi	r9,15
81117660:	21800044 	addi	r6,r4,1
81117664:	318d883a 	add	r6,r6,r6
81117668:	318d883a 	add	r6,r6,r6
8111766c:	318d883a 	add	r6,r6,r6
81117670:	998d883a 	add	r6,r19,r6
81117674:	333ffe04 	addi	r12,r6,-8
81117678:	2017883a 	mov	r11,r4
8111767c:	31800104 	addi	r6,r6,4
81117680:	34000017 	ldw	r16,0(r6)
81117684:	31fffd04 	addi	r7,r6,-12
81117688:	81c0041e 	bne	r16,r7,8111769c <_malloc_r+0x1e4>
8111768c:	0000fb06 	br	81117a7c <_malloc_r+0x5c4>
81117690:	1801030e 	bge	r3,zero,81117aa0 <_malloc_r+0x5e8>
81117694:	84000317 	ldw	r16,12(r16)
81117698:	81c0f826 	beq	r16,r7,81117a7c <_malloc_r+0x5c4>
8111769c:	80800117 	ldw	r2,4(r16)
811176a0:	1284703a 	and	r2,r2,r10
811176a4:	1447c83a 	sub	r3,r2,r17
811176a8:	48fff90e 	bge	r9,r3,81117690 <__reset+0xfb0f7690>
811176ac:	80800317 	ldw	r2,12(r16)
811176b0:	81000217 	ldw	r4,8(r16)
811176b4:	89400054 	ori	r5,r17,1
811176b8:	81400115 	stw	r5,4(r16)
811176bc:	20800315 	stw	r2,12(r4)
811176c0:	11000215 	stw	r4,8(r2)
811176c4:	8463883a 	add	r17,r16,r17
811176c8:	9c400515 	stw	r17,20(r19)
811176cc:	9c400415 	stw	r17,16(r19)
811176d0:	18800054 	ori	r2,r3,1
811176d4:	88800115 	stw	r2,4(r17)
811176d8:	8a000315 	stw	r8,12(r17)
811176dc:	8a000215 	stw	r8,8(r17)
811176e0:	88e3883a 	add	r17,r17,r3
811176e4:	88c00015 	stw	r3,0(r17)
811176e8:	9009883a 	mov	r4,r18
811176ec:	112e3dc0 	call	8112e3dc <__malloc_unlock>
811176f0:	80800204 	addi	r2,r16,8
811176f4:	00001b06 	br	81117764 <_malloc_r+0x2ac>
811176f8:	04400404 	movi	r17,16
811176fc:	89402536 	bltu	r17,r5,81117794 <_malloc_r+0x2dc>
81117700:	112e2b40 	call	8112e2b4 <__malloc_lock>
81117704:	00800184 	movi	r2,6
81117708:	01000084 	movi	r4,2
8111770c:	04e04534 	movhi	r19,33044
81117710:	1085883a 	add	r2,r2,r2
81117714:	9cdac004 	addi	r19,r19,27392
81117718:	1085883a 	add	r2,r2,r2
8111771c:	9885883a 	add	r2,r19,r2
81117720:	14000117 	ldw	r16,4(r2)
81117724:	10fffe04 	addi	r3,r2,-8
81117728:	80c0d926 	beq	r16,r3,81117a90 <_malloc_r+0x5d8>
8111772c:	80c00117 	ldw	r3,4(r16)
81117730:	81000317 	ldw	r4,12(r16)
81117734:	00bfff04 	movi	r2,-4
81117738:	1884703a 	and	r2,r3,r2
8111773c:	81400217 	ldw	r5,8(r16)
81117740:	8085883a 	add	r2,r16,r2
81117744:	10c00117 	ldw	r3,4(r2)
81117748:	29000315 	stw	r4,12(r5)
8111774c:	21400215 	stw	r5,8(r4)
81117750:	18c00054 	ori	r3,r3,1
81117754:	10c00115 	stw	r3,4(r2)
81117758:	9009883a 	mov	r4,r18
8111775c:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81117760:	80800204 	addi	r2,r16,8
81117764:	dfc00a17 	ldw	ra,40(sp)
81117768:	df000917 	ldw	fp,36(sp)
8111776c:	ddc00817 	ldw	r23,32(sp)
81117770:	dd800717 	ldw	r22,28(sp)
81117774:	dd400617 	ldw	r21,24(sp)
81117778:	dd000517 	ldw	r20,20(sp)
8111777c:	dcc00417 	ldw	r19,16(sp)
81117780:	dc800317 	ldw	r18,12(sp)
81117784:	dc400217 	ldw	r17,8(sp)
81117788:	dc000117 	ldw	r16,4(sp)
8111778c:	dec00b04 	addi	sp,sp,44
81117790:	f800283a 	ret
81117794:	00800304 	movi	r2,12
81117798:	90800015 	stw	r2,0(r18)
8111779c:	0005883a 	mov	r2,zero
811177a0:	003ff006 	br	81117764 <__reset+0xfb0f7764>
811177a4:	01002004 	movi	r4,128
811177a8:	02001004 	movi	r8,64
811177ac:	01c00fc4 	movi	r7,63
811177b0:	003f6106 	br	81117538 <__reset+0xfb0f7538>
811177b4:	4009883a 	mov	r4,r8
811177b8:	003f7506 	br	81117590 <__reset+0xfb0f7590>
811177bc:	81000317 	ldw	r4,12(r16)
811177c0:	003fde06 	br	8111773c <__reset+0xfb0f773c>
811177c4:	81c5883a 	add	r2,r16,r7
811177c8:	11400117 	ldw	r5,4(r2)
811177cc:	9009883a 	mov	r4,r18
811177d0:	29400054 	ori	r5,r5,1
811177d4:	11400115 	stw	r5,4(r2)
811177d8:	112e3dc0 	call	8112e3dc <__malloc_unlock>
811177dc:	80800204 	addi	r2,r16,8
811177e0:	003fe006 	br	81117764 <__reset+0xfb0f7764>
811177e4:	9c000217 	ldw	r16,8(r19)
811177e8:	00bfff04 	movi	r2,-4
811177ec:	85800117 	ldw	r22,4(r16)
811177f0:	b0ac703a 	and	r22,r22,r2
811177f4:	b4400336 	bltu	r22,r17,81117804 <_malloc_r+0x34c>
811177f8:	b445c83a 	sub	r2,r22,r17
811177fc:	00c003c4 	movi	r3,15
81117800:	18805d16 	blt	r3,r2,81117978 <_malloc_r+0x4c0>
81117804:	05e04574 	movhi	r23,33045
81117808:	00a04574 	movhi	r2,33045
8111780c:	10a16904 	addi	r2,r2,-31324
81117810:	bde10304 	addi	r23,r23,-31732
81117814:	15400017 	ldw	r21,0(r2)
81117818:	b8c00017 	ldw	r3,0(r23)
8111781c:	00bfffc4 	movi	r2,-1
81117820:	858d883a 	add	r6,r16,r22
81117824:	8d6b883a 	add	r21,r17,r21
81117828:	1880ea26 	beq	r3,r2,81117bd4 <_malloc_r+0x71c>
8111782c:	ad4403c4 	addi	r21,r21,4111
81117830:	00bc0004 	movi	r2,-4096
81117834:	a8aa703a 	and	r21,r21,r2
81117838:	a80b883a 	mov	r5,r21
8111783c:	9009883a 	mov	r4,r18
81117840:	d9800015 	stw	r6,0(sp)
81117844:	11184740 	call	81118474 <_sbrk_r>
81117848:	1029883a 	mov	r20,r2
8111784c:	00bfffc4 	movi	r2,-1
81117850:	d9800017 	ldw	r6,0(sp)
81117854:	a080e826 	beq	r20,r2,81117bf8 <_malloc_r+0x740>
81117858:	a180a636 	bltu	r20,r6,81117af4 <_malloc_r+0x63c>
8111785c:	07204574 	movhi	fp,33045
81117860:	e7220b04 	addi	fp,fp,-30676
81117864:	e0800017 	ldw	r2,0(fp)
81117868:	a887883a 	add	r3,r21,r2
8111786c:	e0c00015 	stw	r3,0(fp)
81117870:	3500e626 	beq	r6,r20,81117c0c <_malloc_r+0x754>
81117874:	b9000017 	ldw	r4,0(r23)
81117878:	00bfffc4 	movi	r2,-1
8111787c:	2080ee26 	beq	r4,r2,81117c38 <_malloc_r+0x780>
81117880:	a185c83a 	sub	r2,r20,r6
81117884:	10c5883a 	add	r2,r2,r3
81117888:	e0800015 	stw	r2,0(fp)
8111788c:	a0c001cc 	andi	r3,r20,7
81117890:	1800bc26 	beq	r3,zero,81117b84 <_malloc_r+0x6cc>
81117894:	a0e9c83a 	sub	r20,r20,r3
81117898:	00840204 	movi	r2,4104
8111789c:	a5000204 	addi	r20,r20,8
811178a0:	10c7c83a 	sub	r3,r2,r3
811178a4:	a545883a 	add	r2,r20,r21
811178a8:	1083ffcc 	andi	r2,r2,4095
811178ac:	18abc83a 	sub	r21,r3,r2
811178b0:	a80b883a 	mov	r5,r21
811178b4:	9009883a 	mov	r4,r18
811178b8:	11184740 	call	81118474 <_sbrk_r>
811178bc:	00ffffc4 	movi	r3,-1
811178c0:	10c0e126 	beq	r2,r3,81117c48 <_malloc_r+0x790>
811178c4:	1505c83a 	sub	r2,r2,r20
811178c8:	1545883a 	add	r2,r2,r21
811178cc:	10800054 	ori	r2,r2,1
811178d0:	e0c00017 	ldw	r3,0(fp)
811178d4:	9d000215 	stw	r20,8(r19)
811178d8:	a0800115 	stw	r2,4(r20)
811178dc:	a8c7883a 	add	r3,r21,r3
811178e0:	e0c00015 	stw	r3,0(fp)
811178e4:	84c00e26 	beq	r16,r19,81117920 <_malloc_r+0x468>
811178e8:	018003c4 	movi	r6,15
811178ec:	3580a72e 	bgeu	r6,r22,81117b8c <_malloc_r+0x6d4>
811178f0:	81400117 	ldw	r5,4(r16)
811178f4:	013ffe04 	movi	r4,-8
811178f8:	b0bffd04 	addi	r2,r22,-12
811178fc:	1104703a 	and	r2,r2,r4
81117900:	2900004c 	andi	r4,r5,1
81117904:	2088b03a 	or	r4,r4,r2
81117908:	81000115 	stw	r4,4(r16)
8111790c:	01400144 	movi	r5,5
81117910:	8089883a 	add	r4,r16,r2
81117914:	21400115 	stw	r5,4(r4)
81117918:	21400215 	stw	r5,8(r4)
8111791c:	3080cd36 	bltu	r6,r2,81117c54 <_malloc_r+0x79c>
81117920:	00a04574 	movhi	r2,33045
81117924:	10a16804 	addi	r2,r2,-31328
81117928:	11000017 	ldw	r4,0(r2)
8111792c:	20c0012e 	bgeu	r4,r3,81117934 <_malloc_r+0x47c>
81117930:	10c00015 	stw	r3,0(r2)
81117934:	00a04574 	movhi	r2,33045
81117938:	10a16704 	addi	r2,r2,-31332
8111793c:	11000017 	ldw	r4,0(r2)
81117940:	9c000217 	ldw	r16,8(r19)
81117944:	20c0012e 	bgeu	r4,r3,8111794c <_malloc_r+0x494>
81117948:	10c00015 	stw	r3,0(r2)
8111794c:	80c00117 	ldw	r3,4(r16)
81117950:	00bfff04 	movi	r2,-4
81117954:	1886703a 	and	r3,r3,r2
81117958:	1c45c83a 	sub	r2,r3,r17
8111795c:	1c400236 	bltu	r3,r17,81117968 <_malloc_r+0x4b0>
81117960:	00c003c4 	movi	r3,15
81117964:	18800416 	blt	r3,r2,81117978 <_malloc_r+0x4c0>
81117968:	9009883a 	mov	r4,r18
8111796c:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81117970:	0005883a 	mov	r2,zero
81117974:	003f7b06 	br	81117764 <__reset+0xfb0f7764>
81117978:	88c00054 	ori	r3,r17,1
8111797c:	80c00115 	stw	r3,4(r16)
81117980:	8463883a 	add	r17,r16,r17
81117984:	10800054 	ori	r2,r2,1
81117988:	9c400215 	stw	r17,8(r19)
8111798c:	88800115 	stw	r2,4(r17)
81117990:	9009883a 	mov	r4,r18
81117994:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81117998:	80800204 	addi	r2,r16,8
8111799c:	003f7106 	br	81117764 <__reset+0xfb0f7764>
811179a0:	00c00504 	movi	r3,20
811179a4:	18804a2e 	bgeu	r3,r2,81117ad0 <_malloc_r+0x618>
811179a8:	00c01504 	movi	r3,84
811179ac:	18806e36 	bltu	r3,r2,81117b68 <_malloc_r+0x6b0>
811179b0:	8804d33a 	srli	r2,r17,12
811179b4:	12001bc4 	addi	r8,r2,111
811179b8:	11c01b84 	addi	r7,r2,110
811179bc:	4209883a 	add	r4,r8,r8
811179c0:	003edd06 	br	81117538 <__reset+0xfb0f7538>
811179c4:	3804d27a 	srli	r2,r7,9
811179c8:	00c00104 	movi	r3,4
811179cc:	1880442e 	bgeu	r3,r2,81117ae0 <_malloc_r+0x628>
811179d0:	00c00504 	movi	r3,20
811179d4:	18808136 	bltu	r3,r2,81117bdc <_malloc_r+0x724>
811179d8:	11401704 	addi	r5,r2,92
811179dc:	10c016c4 	addi	r3,r2,91
811179e0:	294b883a 	add	r5,r5,r5
811179e4:	294b883a 	add	r5,r5,r5
811179e8:	294b883a 	add	r5,r5,r5
811179ec:	994b883a 	add	r5,r19,r5
811179f0:	28800017 	ldw	r2,0(r5)
811179f4:	01a04534 	movhi	r6,33044
811179f8:	297ffe04 	addi	r5,r5,-8
811179fc:	319ac004 	addi	r6,r6,27392
81117a00:	28806526 	beq	r5,r2,81117b98 <_malloc_r+0x6e0>
81117a04:	01bfff04 	movi	r6,-4
81117a08:	10c00117 	ldw	r3,4(r2)
81117a0c:	1986703a 	and	r3,r3,r6
81117a10:	38c0022e 	bgeu	r7,r3,81117a1c <_malloc_r+0x564>
81117a14:	10800217 	ldw	r2,8(r2)
81117a18:	28bffb1e 	bne	r5,r2,81117a08 <__reset+0xfb0f7a08>
81117a1c:	11400317 	ldw	r5,12(r2)
81117a20:	98c00117 	ldw	r3,4(r19)
81117a24:	81400315 	stw	r5,12(r16)
81117a28:	80800215 	stw	r2,8(r16)
81117a2c:	2c000215 	stw	r16,8(r5)
81117a30:	14000315 	stw	r16,12(r2)
81117a34:	003ef806 	br	81117618 <__reset+0xfb0f7618>
81117a38:	88c00054 	ori	r3,r17,1
81117a3c:	80c00115 	stw	r3,4(r16)
81117a40:	8463883a 	add	r17,r16,r17
81117a44:	34400515 	stw	r17,20(r6)
81117a48:	34400415 	stw	r17,16(r6)
81117a4c:	10c00054 	ori	r3,r2,1
81117a50:	8a000315 	stw	r8,12(r17)
81117a54:	8a000215 	stw	r8,8(r17)
81117a58:	88c00115 	stw	r3,4(r17)
81117a5c:	88a3883a 	add	r17,r17,r2
81117a60:	88800015 	stw	r2,0(r17)
81117a64:	9009883a 	mov	r4,r18
81117a68:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81117a6c:	80800204 	addi	r2,r16,8
81117a70:	003f3c06 	br	81117764 <__reset+0xfb0f7764>
81117a74:	30c00117 	ldw	r3,4(r6)
81117a78:	003ee706 	br	81117618 <__reset+0xfb0f7618>
81117a7c:	5ac00044 	addi	r11,r11,1
81117a80:	588000cc 	andi	r2,r11,3
81117a84:	31800204 	addi	r6,r6,8
81117a88:	103efd1e 	bne	r2,zero,81117680 <__reset+0xfb0f7680>
81117a8c:	00002406 	br	81117b20 <_malloc_r+0x668>
81117a90:	14000317 	ldw	r16,12(r2)
81117a94:	143f251e 	bne	r2,r16,8111772c <__reset+0xfb0f772c>
81117a98:	21000084 	addi	r4,r4,2
81117a9c:	003ebc06 	br	81117590 <__reset+0xfb0f7590>
81117aa0:	8085883a 	add	r2,r16,r2
81117aa4:	10c00117 	ldw	r3,4(r2)
81117aa8:	81000317 	ldw	r4,12(r16)
81117aac:	81400217 	ldw	r5,8(r16)
81117ab0:	18c00054 	ori	r3,r3,1
81117ab4:	10c00115 	stw	r3,4(r2)
81117ab8:	29000315 	stw	r4,12(r5)
81117abc:	21400215 	stw	r5,8(r4)
81117ac0:	9009883a 	mov	r4,r18
81117ac4:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81117ac8:	80800204 	addi	r2,r16,8
81117acc:	003f2506 	br	81117764 <__reset+0xfb0f7764>
81117ad0:	12001704 	addi	r8,r2,92
81117ad4:	11c016c4 	addi	r7,r2,91
81117ad8:	4209883a 	add	r4,r8,r8
81117adc:	003e9606 	br	81117538 <__reset+0xfb0f7538>
81117ae0:	3804d1ba 	srli	r2,r7,6
81117ae4:	11400e44 	addi	r5,r2,57
81117ae8:	10c00e04 	addi	r3,r2,56
81117aec:	294b883a 	add	r5,r5,r5
81117af0:	003fbc06 	br	811179e4 <__reset+0xfb0f79e4>
81117af4:	84ff5926 	beq	r16,r19,8111785c <__reset+0xfb0f785c>
81117af8:	00a04534 	movhi	r2,33044
81117afc:	109ac004 	addi	r2,r2,27392
81117b00:	14000217 	ldw	r16,8(r2)
81117b04:	00bfff04 	movi	r2,-4
81117b08:	80c00117 	ldw	r3,4(r16)
81117b0c:	1886703a 	and	r3,r3,r2
81117b10:	003f9106 	br	81117958 <__reset+0xfb0f7958>
81117b14:	60800217 	ldw	r2,8(r12)
81117b18:	213fffc4 	addi	r4,r4,-1
81117b1c:	1300651e 	bne	r2,r12,81117cb4 <_malloc_r+0x7fc>
81117b20:	208000cc 	andi	r2,r4,3
81117b24:	633ffe04 	addi	r12,r12,-8
81117b28:	103ffa1e 	bne	r2,zero,81117b14 <__reset+0xfb0f7b14>
81117b2c:	98800117 	ldw	r2,4(r19)
81117b30:	0146303a 	nor	r3,zero,r5
81117b34:	1884703a 	and	r2,r3,r2
81117b38:	98800115 	stw	r2,4(r19)
81117b3c:	294b883a 	add	r5,r5,r5
81117b40:	117f2836 	bltu	r2,r5,811177e4 <__reset+0xfb0f77e4>
81117b44:	283f2726 	beq	r5,zero,811177e4 <__reset+0xfb0f77e4>
81117b48:	2886703a 	and	r3,r5,r2
81117b4c:	5809883a 	mov	r4,r11
81117b50:	183ec31e 	bne	r3,zero,81117660 <__reset+0xfb0f7660>
81117b54:	294b883a 	add	r5,r5,r5
81117b58:	2886703a 	and	r3,r5,r2
81117b5c:	21000104 	addi	r4,r4,4
81117b60:	183ffc26 	beq	r3,zero,81117b54 <__reset+0xfb0f7b54>
81117b64:	003ebe06 	br	81117660 <__reset+0xfb0f7660>
81117b68:	00c05504 	movi	r3,340
81117b6c:	18801236 	bltu	r3,r2,81117bb8 <_malloc_r+0x700>
81117b70:	8804d3fa 	srli	r2,r17,15
81117b74:	12001e04 	addi	r8,r2,120
81117b78:	11c01dc4 	addi	r7,r2,119
81117b7c:	4209883a 	add	r4,r8,r8
81117b80:	003e6d06 	br	81117538 <__reset+0xfb0f7538>
81117b84:	00c40004 	movi	r3,4096
81117b88:	003f4606 	br	811178a4 <__reset+0xfb0f78a4>
81117b8c:	00800044 	movi	r2,1
81117b90:	a0800115 	stw	r2,4(r20)
81117b94:	003f7406 	br	81117968 <__reset+0xfb0f7968>
81117b98:	1805d0ba 	srai	r2,r3,2
81117b9c:	01c00044 	movi	r7,1
81117ba0:	30c00117 	ldw	r3,4(r6)
81117ba4:	388e983a 	sll	r7,r7,r2
81117ba8:	2805883a 	mov	r2,r5
81117bac:	38c6b03a 	or	r3,r7,r3
81117bb0:	30c00115 	stw	r3,4(r6)
81117bb4:	003f9b06 	br	81117a24 <__reset+0xfb0f7a24>
81117bb8:	00c15504 	movi	r3,1364
81117bbc:	18801a36 	bltu	r3,r2,81117c28 <_malloc_r+0x770>
81117bc0:	8804d4ba 	srli	r2,r17,18
81117bc4:	12001f44 	addi	r8,r2,125
81117bc8:	11c01f04 	addi	r7,r2,124
81117bcc:	4209883a 	add	r4,r8,r8
81117bd0:	003e5906 	br	81117538 <__reset+0xfb0f7538>
81117bd4:	ad400404 	addi	r21,r21,16
81117bd8:	003f1706 	br	81117838 <__reset+0xfb0f7838>
81117bdc:	00c01504 	movi	r3,84
81117be0:	18802336 	bltu	r3,r2,81117c70 <_malloc_r+0x7b8>
81117be4:	3804d33a 	srli	r2,r7,12
81117be8:	11401bc4 	addi	r5,r2,111
81117bec:	10c01b84 	addi	r3,r2,110
81117bf0:	294b883a 	add	r5,r5,r5
81117bf4:	003f7b06 	br	811179e4 <__reset+0xfb0f79e4>
81117bf8:	9c000217 	ldw	r16,8(r19)
81117bfc:	00bfff04 	movi	r2,-4
81117c00:	80c00117 	ldw	r3,4(r16)
81117c04:	1886703a 	and	r3,r3,r2
81117c08:	003f5306 	br	81117958 <__reset+0xfb0f7958>
81117c0c:	3083ffcc 	andi	r2,r6,4095
81117c10:	103f181e 	bne	r2,zero,81117874 <__reset+0xfb0f7874>
81117c14:	99000217 	ldw	r4,8(r19)
81117c18:	b545883a 	add	r2,r22,r21
81117c1c:	10800054 	ori	r2,r2,1
81117c20:	20800115 	stw	r2,4(r4)
81117c24:	003f3e06 	br	81117920 <__reset+0xfb0f7920>
81117c28:	01003f84 	movi	r4,254
81117c2c:	02001fc4 	movi	r8,127
81117c30:	01c01f84 	movi	r7,126
81117c34:	003e4006 	br	81117538 <__reset+0xfb0f7538>
81117c38:	00a04574 	movhi	r2,33045
81117c3c:	10a10304 	addi	r2,r2,-31732
81117c40:	15000015 	stw	r20,0(r2)
81117c44:	003f1106 	br	8111788c <__reset+0xfb0f788c>
81117c48:	00800044 	movi	r2,1
81117c4c:	002b883a 	mov	r21,zero
81117c50:	003f1f06 	br	811178d0 <__reset+0xfb0f78d0>
81117c54:	81400204 	addi	r5,r16,8
81117c58:	9009883a 	mov	r4,r18
81117c5c:	1120f2c0 	call	81120f2c <_free_r>
81117c60:	00a04574 	movhi	r2,33045
81117c64:	10a20b04 	addi	r2,r2,-30676
81117c68:	10c00017 	ldw	r3,0(r2)
81117c6c:	003f2c06 	br	81117920 <__reset+0xfb0f7920>
81117c70:	00c05504 	movi	r3,340
81117c74:	18800536 	bltu	r3,r2,81117c8c <_malloc_r+0x7d4>
81117c78:	3804d3fa 	srli	r2,r7,15
81117c7c:	11401e04 	addi	r5,r2,120
81117c80:	10c01dc4 	addi	r3,r2,119
81117c84:	294b883a 	add	r5,r5,r5
81117c88:	003f5606 	br	811179e4 <__reset+0xfb0f79e4>
81117c8c:	00c15504 	movi	r3,1364
81117c90:	18800536 	bltu	r3,r2,81117ca8 <_malloc_r+0x7f0>
81117c94:	3804d4ba 	srli	r2,r7,18
81117c98:	11401f44 	addi	r5,r2,125
81117c9c:	10c01f04 	addi	r3,r2,124
81117ca0:	294b883a 	add	r5,r5,r5
81117ca4:	003f4f06 	br	811179e4 <__reset+0xfb0f79e4>
81117ca8:	01403f84 	movi	r5,254
81117cac:	00c01f84 	movi	r3,126
81117cb0:	003f4c06 	br	811179e4 <__reset+0xfb0f79e4>
81117cb4:	98800117 	ldw	r2,4(r19)
81117cb8:	003fa006 	br	81117b3c <__reset+0xfb0f7b3c>
81117cbc:	8808d0fa 	srli	r4,r17,3
81117cc0:	20800044 	addi	r2,r4,1
81117cc4:	1085883a 	add	r2,r2,r2
81117cc8:	003e9006 	br	8111770c <__reset+0xfb0f770c>

81117ccc <memcpy>:
81117ccc:	defffd04 	addi	sp,sp,-12
81117cd0:	de00012e 	bgeu	sp,et,81117cd8 <memcpy+0xc>
81117cd4:	003b68fa 	trap	3
81117cd8:	00c003c4 	movi	r3,15
81117cdc:	dfc00215 	stw	ra,8(sp)
81117ce0:	dc400115 	stw	r17,4(sp)
81117ce4:	dc000015 	stw	r16,0(sp)
81117ce8:	2005883a 	mov	r2,r4
81117cec:	1980452e 	bgeu	r3,r6,81117e04 <memcpy+0x138>
81117cf0:	2906b03a 	or	r3,r5,r4
81117cf4:	18c000cc 	andi	r3,r3,3
81117cf8:	1800441e 	bne	r3,zero,81117e0c <memcpy+0x140>
81117cfc:	347ffc04 	addi	r17,r6,-16
81117d00:	8822d13a 	srli	r17,r17,4
81117d04:	28c00104 	addi	r3,r5,4
81117d08:	23400104 	addi	r13,r4,4
81117d0c:	8820913a 	slli	r16,r17,4
81117d10:	2b000204 	addi	r12,r5,8
81117d14:	22c00204 	addi	r11,r4,8
81117d18:	84000504 	addi	r16,r16,20
81117d1c:	2a800304 	addi	r10,r5,12
81117d20:	22400304 	addi	r9,r4,12
81117d24:	2c21883a 	add	r16,r5,r16
81117d28:	2811883a 	mov	r8,r5
81117d2c:	200f883a 	mov	r7,r4
81117d30:	41000017 	ldw	r4,0(r8)
81117d34:	1fc00017 	ldw	ra,0(r3)
81117d38:	63c00017 	ldw	r15,0(r12)
81117d3c:	39000015 	stw	r4,0(r7)
81117d40:	53800017 	ldw	r14,0(r10)
81117d44:	6fc00015 	stw	ra,0(r13)
81117d48:	5bc00015 	stw	r15,0(r11)
81117d4c:	4b800015 	stw	r14,0(r9)
81117d50:	18c00404 	addi	r3,r3,16
81117d54:	39c00404 	addi	r7,r7,16
81117d58:	42000404 	addi	r8,r8,16
81117d5c:	6b400404 	addi	r13,r13,16
81117d60:	63000404 	addi	r12,r12,16
81117d64:	5ac00404 	addi	r11,r11,16
81117d68:	52800404 	addi	r10,r10,16
81117d6c:	4a400404 	addi	r9,r9,16
81117d70:	1c3fef1e 	bne	r3,r16,81117d30 <__reset+0xfb0f7d30>
81117d74:	89c00044 	addi	r7,r17,1
81117d78:	380e913a 	slli	r7,r7,4
81117d7c:	310003cc 	andi	r4,r6,15
81117d80:	02c000c4 	movi	r11,3
81117d84:	11c7883a 	add	r3,r2,r7
81117d88:	29cb883a 	add	r5,r5,r7
81117d8c:	5900212e 	bgeu	r11,r4,81117e14 <memcpy+0x148>
81117d90:	1813883a 	mov	r9,r3
81117d94:	2811883a 	mov	r8,r5
81117d98:	200f883a 	mov	r7,r4
81117d9c:	42800017 	ldw	r10,0(r8)
81117da0:	4a400104 	addi	r9,r9,4
81117da4:	39ffff04 	addi	r7,r7,-4
81117da8:	4abfff15 	stw	r10,-4(r9)
81117dac:	42000104 	addi	r8,r8,4
81117db0:	59fffa36 	bltu	r11,r7,81117d9c <__reset+0xfb0f7d9c>
81117db4:	213fff04 	addi	r4,r4,-4
81117db8:	2008d0ba 	srli	r4,r4,2
81117dbc:	318000cc 	andi	r6,r6,3
81117dc0:	21000044 	addi	r4,r4,1
81117dc4:	2109883a 	add	r4,r4,r4
81117dc8:	2109883a 	add	r4,r4,r4
81117dcc:	1907883a 	add	r3,r3,r4
81117dd0:	290b883a 	add	r5,r5,r4
81117dd4:	30000626 	beq	r6,zero,81117df0 <memcpy+0x124>
81117dd8:	198d883a 	add	r6,r3,r6
81117ddc:	29c00003 	ldbu	r7,0(r5)
81117de0:	18c00044 	addi	r3,r3,1
81117de4:	29400044 	addi	r5,r5,1
81117de8:	19ffffc5 	stb	r7,-1(r3)
81117dec:	19bffb1e 	bne	r3,r6,81117ddc <__reset+0xfb0f7ddc>
81117df0:	dfc00217 	ldw	ra,8(sp)
81117df4:	dc400117 	ldw	r17,4(sp)
81117df8:	dc000017 	ldw	r16,0(sp)
81117dfc:	dec00304 	addi	sp,sp,12
81117e00:	f800283a 	ret
81117e04:	2007883a 	mov	r3,r4
81117e08:	003ff206 	br	81117dd4 <__reset+0xfb0f7dd4>
81117e0c:	2007883a 	mov	r3,r4
81117e10:	003ff106 	br	81117dd8 <__reset+0xfb0f7dd8>
81117e14:	200d883a 	mov	r6,r4
81117e18:	003fee06 	br	81117dd4 <__reset+0xfb0f7dd4>

81117e1c <memset>:
81117e1c:	20c000cc 	andi	r3,r4,3
81117e20:	2005883a 	mov	r2,r4
81117e24:	18004426 	beq	r3,zero,81117f38 <memset+0x11c>
81117e28:	31ffffc4 	addi	r7,r6,-1
81117e2c:	30004026 	beq	r6,zero,81117f30 <memset+0x114>
81117e30:	2813883a 	mov	r9,r5
81117e34:	200d883a 	mov	r6,r4
81117e38:	2007883a 	mov	r3,r4
81117e3c:	00000406 	br	81117e50 <memset+0x34>
81117e40:	3a3fffc4 	addi	r8,r7,-1
81117e44:	31800044 	addi	r6,r6,1
81117e48:	38003926 	beq	r7,zero,81117f30 <memset+0x114>
81117e4c:	400f883a 	mov	r7,r8
81117e50:	18c00044 	addi	r3,r3,1
81117e54:	32400005 	stb	r9,0(r6)
81117e58:	1a0000cc 	andi	r8,r3,3
81117e5c:	403ff81e 	bne	r8,zero,81117e40 <__reset+0xfb0f7e40>
81117e60:	010000c4 	movi	r4,3
81117e64:	21c02d2e 	bgeu	r4,r7,81117f1c <memset+0x100>
81117e68:	29003fcc 	andi	r4,r5,255
81117e6c:	200c923a 	slli	r6,r4,8
81117e70:	3108b03a 	or	r4,r6,r4
81117e74:	200c943a 	slli	r6,r4,16
81117e78:	218cb03a 	or	r6,r4,r6
81117e7c:	010003c4 	movi	r4,15
81117e80:	21c0182e 	bgeu	r4,r7,81117ee4 <memset+0xc8>
81117e84:	3b3ffc04 	addi	r12,r7,-16
81117e88:	6018d13a 	srli	r12,r12,4
81117e8c:	1a000104 	addi	r8,r3,4
81117e90:	1ac00204 	addi	r11,r3,8
81117e94:	6008913a 	slli	r4,r12,4
81117e98:	1a800304 	addi	r10,r3,12
81117e9c:	1813883a 	mov	r9,r3
81117ea0:	21000504 	addi	r4,r4,20
81117ea4:	1909883a 	add	r4,r3,r4
81117ea8:	49800015 	stw	r6,0(r9)
81117eac:	41800015 	stw	r6,0(r8)
81117eb0:	59800015 	stw	r6,0(r11)
81117eb4:	51800015 	stw	r6,0(r10)
81117eb8:	42000404 	addi	r8,r8,16
81117ebc:	4a400404 	addi	r9,r9,16
81117ec0:	5ac00404 	addi	r11,r11,16
81117ec4:	52800404 	addi	r10,r10,16
81117ec8:	413ff71e 	bne	r8,r4,81117ea8 <__reset+0xfb0f7ea8>
81117ecc:	63000044 	addi	r12,r12,1
81117ed0:	6018913a 	slli	r12,r12,4
81117ed4:	39c003cc 	andi	r7,r7,15
81117ed8:	010000c4 	movi	r4,3
81117edc:	1b07883a 	add	r3,r3,r12
81117ee0:	21c00e2e 	bgeu	r4,r7,81117f1c <memset+0x100>
81117ee4:	1813883a 	mov	r9,r3
81117ee8:	3811883a 	mov	r8,r7
81117eec:	010000c4 	movi	r4,3
81117ef0:	49800015 	stw	r6,0(r9)
81117ef4:	423fff04 	addi	r8,r8,-4
81117ef8:	4a400104 	addi	r9,r9,4
81117efc:	223ffc36 	bltu	r4,r8,81117ef0 <__reset+0xfb0f7ef0>
81117f00:	393fff04 	addi	r4,r7,-4
81117f04:	2008d0ba 	srli	r4,r4,2
81117f08:	39c000cc 	andi	r7,r7,3
81117f0c:	21000044 	addi	r4,r4,1
81117f10:	2109883a 	add	r4,r4,r4
81117f14:	2109883a 	add	r4,r4,r4
81117f18:	1907883a 	add	r3,r3,r4
81117f1c:	38000526 	beq	r7,zero,81117f34 <memset+0x118>
81117f20:	19cf883a 	add	r7,r3,r7
81117f24:	19400005 	stb	r5,0(r3)
81117f28:	18c00044 	addi	r3,r3,1
81117f2c:	38fffd1e 	bne	r7,r3,81117f24 <__reset+0xfb0f7f24>
81117f30:	f800283a 	ret
81117f34:	f800283a 	ret
81117f38:	2007883a 	mov	r3,r4
81117f3c:	300f883a 	mov	r7,r6
81117f40:	003fc706 	br	81117e60 <__reset+0xfb0f7e60>

81117f44 <_open_r>:
81117f44:	defffd04 	addi	sp,sp,-12
81117f48:	de00012e 	bgeu	sp,et,81117f50 <_open_r+0xc>
81117f4c:	003b68fa 	trap	3
81117f50:	2805883a 	mov	r2,r5
81117f54:	dc000015 	stw	r16,0(sp)
81117f58:	04204574 	movhi	r16,33045
81117f5c:	dc400115 	stw	r17,4(sp)
81117f60:	300b883a 	mov	r5,r6
81117f64:	84216604 	addi	r16,r16,-31336
81117f68:	2023883a 	mov	r17,r4
81117f6c:	380d883a 	mov	r6,r7
81117f70:	1009883a 	mov	r4,r2
81117f74:	dfc00215 	stw	ra,8(sp)
81117f78:	80000015 	stw	zero,0(r16)
81117f7c:	112d9340 	call	8112d934 <open>
81117f80:	00ffffc4 	movi	r3,-1
81117f84:	10c00526 	beq	r2,r3,81117f9c <_open_r+0x58>
81117f88:	dfc00217 	ldw	ra,8(sp)
81117f8c:	dc400117 	ldw	r17,4(sp)
81117f90:	dc000017 	ldw	r16,0(sp)
81117f94:	dec00304 	addi	sp,sp,12
81117f98:	f800283a 	ret
81117f9c:	80c00017 	ldw	r3,0(r16)
81117fa0:	183ff926 	beq	r3,zero,81117f88 <__reset+0xfb0f7f88>
81117fa4:	88c00015 	stw	r3,0(r17)
81117fa8:	003ff706 	br	81117f88 <__reset+0xfb0f7f88>

81117fac <_printf_r>:
81117fac:	defffd04 	addi	sp,sp,-12
81117fb0:	2805883a 	mov	r2,r5
81117fb4:	de00012e 	bgeu	sp,et,81117fbc <_printf_r+0x10>
81117fb8:	003b68fa 	trap	3
81117fbc:	dfc00015 	stw	ra,0(sp)
81117fc0:	d9800115 	stw	r6,4(sp)
81117fc4:	d9c00215 	stw	r7,8(sp)
81117fc8:	21400217 	ldw	r5,8(r4)
81117fcc:	d9c00104 	addi	r7,sp,4
81117fd0:	100d883a 	mov	r6,r2
81117fd4:	111acd80 	call	8111acd8 <___vfprintf_internal_r>
81117fd8:	dfc00017 	ldw	ra,0(sp)
81117fdc:	dec00304 	addi	sp,sp,12
81117fe0:	f800283a 	ret

81117fe4 <printf>:
81117fe4:	defffc04 	addi	sp,sp,-16
81117fe8:	de00012e 	bgeu	sp,et,81117ff0 <printf+0xc>
81117fec:	003b68fa 	trap	3
81117ff0:	dfc00015 	stw	ra,0(sp)
81117ff4:	d9400115 	stw	r5,4(sp)
81117ff8:	d9800215 	stw	r6,8(sp)
81117ffc:	d9c00315 	stw	r7,12(sp)
81118000:	00a04574 	movhi	r2,33045
81118004:	10a10204 	addi	r2,r2,-31736
81118008:	10800017 	ldw	r2,0(r2)
8111800c:	200b883a 	mov	r5,r4
81118010:	d9800104 	addi	r6,sp,4
81118014:	11000217 	ldw	r4,8(r2)
81118018:	111ced80 	call	8111ced8 <__vfprintf_internal>
8111801c:	dfc00017 	ldw	ra,0(sp)
81118020:	dec00404 	addi	sp,sp,16
81118024:	f800283a 	ret

81118028 <_putc_r>:
81118028:	defffc04 	addi	sp,sp,-16
8111802c:	de00012e 	bgeu	sp,et,81118034 <_putc_r+0xc>
81118030:	003b68fa 	trap	3
81118034:	dc000215 	stw	r16,8(sp)
81118038:	dfc00315 	stw	ra,12(sp)
8111803c:	2021883a 	mov	r16,r4
81118040:	20000226 	beq	r4,zero,8111804c <_putc_r+0x24>
81118044:	20800e17 	ldw	r2,56(r4)
81118048:	10001b26 	beq	r2,zero,811180b8 <_putc_r+0x90>
8111804c:	30800217 	ldw	r2,8(r6)
81118050:	10bfffc4 	addi	r2,r2,-1
81118054:	30800215 	stw	r2,8(r6)
81118058:	10000a16 	blt	r2,zero,81118084 <_putc_r+0x5c>
8111805c:	30800017 	ldw	r2,0(r6)
81118060:	11400005 	stb	r5,0(r2)
81118064:	30800017 	ldw	r2,0(r6)
81118068:	10c00044 	addi	r3,r2,1
8111806c:	30c00015 	stw	r3,0(r6)
81118070:	10800003 	ldbu	r2,0(r2)
81118074:	dfc00317 	ldw	ra,12(sp)
81118078:	dc000217 	ldw	r16,8(sp)
8111807c:	dec00404 	addi	sp,sp,16
81118080:	f800283a 	ret
81118084:	30c00617 	ldw	r3,24(r6)
81118088:	10c00616 	blt	r2,r3,811180a4 <_putc_r+0x7c>
8111808c:	30800017 	ldw	r2,0(r6)
81118090:	00c00284 	movi	r3,10
81118094:	11400005 	stb	r5,0(r2)
81118098:	30800017 	ldw	r2,0(r6)
8111809c:	11400003 	ldbu	r5,0(r2)
811180a0:	28fff11e 	bne	r5,r3,81118068 <__reset+0xfb0f8068>
811180a4:	8009883a 	mov	r4,r16
811180a8:	dfc00317 	ldw	ra,12(sp)
811180ac:	dc000217 	ldw	r16,8(sp)
811180b0:	dec00404 	addi	sp,sp,16
811180b4:	111e85c1 	jmpi	8111e85c <__swbuf_r>
811180b8:	d9400015 	stw	r5,0(sp)
811180bc:	d9800115 	stw	r6,4(sp)
811180c0:	1120a940 	call	81120a94 <__sinit>
811180c4:	d9800117 	ldw	r6,4(sp)
811180c8:	d9400017 	ldw	r5,0(sp)
811180cc:	003fdf06 	br	8111804c <__reset+0xfb0f804c>

811180d0 <putc>:
811180d0:	00a04574 	movhi	r2,33045
811180d4:	defffc04 	addi	sp,sp,-16
811180d8:	10a10204 	addi	r2,r2,-31736
811180dc:	de00012e 	bgeu	sp,et,811180e4 <putc+0x14>
811180e0:	003b68fa 	trap	3
811180e4:	dc000115 	stw	r16,4(sp)
811180e8:	14000017 	ldw	r16,0(r2)
811180ec:	dc400215 	stw	r17,8(sp)
811180f0:	dfc00315 	stw	ra,12(sp)
811180f4:	2023883a 	mov	r17,r4
811180f8:	80000226 	beq	r16,zero,81118104 <putc+0x34>
811180fc:	80800e17 	ldw	r2,56(r16)
81118100:	10001a26 	beq	r2,zero,8111816c <putc+0x9c>
81118104:	28800217 	ldw	r2,8(r5)
81118108:	10bfffc4 	addi	r2,r2,-1
8111810c:	28800215 	stw	r2,8(r5)
81118110:	10000b16 	blt	r2,zero,81118140 <putc+0x70>
81118114:	28800017 	ldw	r2,0(r5)
81118118:	14400005 	stb	r17,0(r2)
8111811c:	28800017 	ldw	r2,0(r5)
81118120:	10c00044 	addi	r3,r2,1
81118124:	28c00015 	stw	r3,0(r5)
81118128:	10800003 	ldbu	r2,0(r2)
8111812c:	dfc00317 	ldw	ra,12(sp)
81118130:	dc400217 	ldw	r17,8(sp)
81118134:	dc000117 	ldw	r16,4(sp)
81118138:	dec00404 	addi	sp,sp,16
8111813c:	f800283a 	ret
81118140:	28c00617 	ldw	r3,24(r5)
81118144:	10c00e16 	blt	r2,r3,81118180 <putc+0xb0>
81118148:	28800017 	ldw	r2,0(r5)
8111814c:	01000284 	movi	r4,10
81118150:	14400005 	stb	r17,0(r2)
81118154:	28800017 	ldw	r2,0(r5)
81118158:	10c00003 	ldbu	r3,0(r2)
8111815c:	193ff01e 	bne	r3,r4,81118120 <__reset+0xfb0f8120>
81118160:	280d883a 	mov	r6,r5
81118164:	180b883a 	mov	r5,r3
81118168:	00000706 	br	81118188 <putc+0xb8>
8111816c:	8009883a 	mov	r4,r16
81118170:	d9400015 	stw	r5,0(sp)
81118174:	1120a940 	call	81120a94 <__sinit>
81118178:	d9400017 	ldw	r5,0(sp)
8111817c:	003fe106 	br	81118104 <__reset+0xfb0f8104>
81118180:	280d883a 	mov	r6,r5
81118184:	880b883a 	mov	r5,r17
81118188:	8009883a 	mov	r4,r16
8111818c:	dfc00317 	ldw	ra,12(sp)
81118190:	dc400217 	ldw	r17,8(sp)
81118194:	dc000117 	ldw	r16,4(sp)
81118198:	dec00404 	addi	sp,sp,16
8111819c:	111e85c1 	jmpi	8111e85c <__swbuf_r>

811181a0 <_puts_r>:
811181a0:	defff604 	addi	sp,sp,-40
811181a4:	de00012e 	bgeu	sp,et,811181ac <_puts_r+0xc>
811181a8:	003b68fa 	trap	3
811181ac:	dc000715 	stw	r16,28(sp)
811181b0:	2021883a 	mov	r16,r4
811181b4:	2809883a 	mov	r4,r5
811181b8:	dc400815 	stw	r17,32(sp)
811181bc:	dfc00915 	stw	ra,36(sp)
811181c0:	2823883a 	mov	r17,r5
811181c4:	11187c00 	call	811187c0 <strlen>
811181c8:	10c00044 	addi	r3,r2,1
811181cc:	d8800115 	stw	r2,4(sp)
811181d0:	00a04534 	movhi	r2,33044
811181d4:	10972904 	addi	r2,r2,23716
811181d8:	d8800215 	stw	r2,8(sp)
811181dc:	00800044 	movi	r2,1
811181e0:	d8800315 	stw	r2,12(sp)
811181e4:	00800084 	movi	r2,2
811181e8:	dc400015 	stw	r17,0(sp)
811181ec:	d8c00615 	stw	r3,24(sp)
811181f0:	dec00415 	stw	sp,16(sp)
811181f4:	d8800515 	stw	r2,20(sp)
811181f8:	80000226 	beq	r16,zero,81118204 <_puts_r+0x64>
811181fc:	80800e17 	ldw	r2,56(r16)
81118200:	10001426 	beq	r2,zero,81118254 <_puts_r+0xb4>
81118204:	81400217 	ldw	r5,8(r16)
81118208:	2880030b 	ldhu	r2,12(r5)
8111820c:	10c8000c 	andi	r3,r2,8192
81118210:	1800061e 	bne	r3,zero,8111822c <_puts_r+0x8c>
81118214:	29001917 	ldw	r4,100(r5)
81118218:	00f7ffc4 	movi	r3,-8193
8111821c:	10880014 	ori	r2,r2,8192
81118220:	20c6703a 	and	r3,r4,r3
81118224:	2880030d 	sth	r2,12(r5)
81118228:	28c01915 	stw	r3,100(r5)
8111822c:	d9800404 	addi	r6,sp,16
81118230:	8009883a 	mov	r4,r16
81118234:	11212440 	call	81121244 <__sfvwrite_r>
81118238:	1000091e 	bne	r2,zero,81118260 <_puts_r+0xc0>
8111823c:	00800284 	movi	r2,10
81118240:	dfc00917 	ldw	ra,36(sp)
81118244:	dc400817 	ldw	r17,32(sp)
81118248:	dc000717 	ldw	r16,28(sp)
8111824c:	dec00a04 	addi	sp,sp,40
81118250:	f800283a 	ret
81118254:	8009883a 	mov	r4,r16
81118258:	1120a940 	call	81120a94 <__sinit>
8111825c:	003fe906 	br	81118204 <__reset+0xfb0f8204>
81118260:	00bfffc4 	movi	r2,-1
81118264:	003ff606 	br	81118240 <__reset+0xfb0f8240>

81118268 <puts>:
81118268:	00a04574 	movhi	r2,33045
8111826c:	10a10204 	addi	r2,r2,-31736
81118270:	200b883a 	mov	r5,r4
81118274:	11000017 	ldw	r4,0(r2)
81118278:	11181a01 	jmpi	811181a0 <_puts_r>

8111827c <lflush>:
8111827c:	2080030b 	ldhu	r2,12(r4)
81118280:	00c00244 	movi	r3,9
81118284:	1080024c 	andi	r2,r2,9
81118288:	10c00226 	beq	r2,r3,81118294 <lflush+0x18>
8111828c:	0005883a 	mov	r2,zero
81118290:	f800283a 	ret
81118294:	11206fc1 	jmpi	811206fc <fflush>

81118298 <__srefill_r>:
81118298:	defffc04 	addi	sp,sp,-16
8111829c:	de00012e 	bgeu	sp,et,811182a4 <__srefill_r+0xc>
811182a0:	003b68fa 	trap	3
811182a4:	dc400115 	stw	r17,4(sp)
811182a8:	dc000015 	stw	r16,0(sp)
811182ac:	dfc00315 	stw	ra,12(sp)
811182b0:	dc800215 	stw	r18,8(sp)
811182b4:	2023883a 	mov	r17,r4
811182b8:	2821883a 	mov	r16,r5
811182bc:	20000226 	beq	r4,zero,811182c8 <__srefill_r+0x30>
811182c0:	20800e17 	ldw	r2,56(r4)
811182c4:	10003c26 	beq	r2,zero,811183b8 <__srefill_r+0x120>
811182c8:	80c0030b 	ldhu	r3,12(r16)
811182cc:	1908000c 	andi	r4,r3,8192
811182d0:	1805883a 	mov	r2,r3
811182d4:	2000071e 	bne	r4,zero,811182f4 <__srefill_r+0x5c>
811182d8:	81001917 	ldw	r4,100(r16)
811182dc:	18880014 	ori	r2,r3,8192
811182e0:	00f7ffc4 	movi	r3,-8193
811182e4:	20c8703a 	and	r4,r4,r3
811182e8:	8080030d 	sth	r2,12(r16)
811182ec:	1007883a 	mov	r3,r2
811182f0:	81001915 	stw	r4,100(r16)
811182f4:	80000115 	stw	zero,4(r16)
811182f8:	1100080c 	andi	r4,r2,32
811182fc:	2000571e 	bne	r4,zero,8111845c <__srefill_r+0x1c4>
81118300:	1100010c 	andi	r4,r2,4
81118304:	20001f26 	beq	r4,zero,81118384 <__srefill_r+0xec>
81118308:	81400c17 	ldw	r5,48(r16)
8111830c:	28000826 	beq	r5,zero,81118330 <__srefill_r+0x98>
81118310:	80801004 	addi	r2,r16,64
81118314:	28800226 	beq	r5,r2,81118320 <__srefill_r+0x88>
81118318:	8809883a 	mov	r4,r17
8111831c:	1120f2c0 	call	81120f2c <_free_r>
81118320:	80800f17 	ldw	r2,60(r16)
81118324:	80000c15 	stw	zero,48(r16)
81118328:	80800115 	stw	r2,4(r16)
8111832c:	1000391e 	bne	r2,zero,81118414 <__srefill_r+0x17c>
81118330:	80800417 	ldw	r2,16(r16)
81118334:	10004b26 	beq	r2,zero,81118464 <__srefill_r+0x1cc>
81118338:	8480030b 	ldhu	r18,12(r16)
8111833c:	908000cc 	andi	r2,r18,3
81118340:	10001f1e 	bne	r2,zero,811183c0 <__srefill_r+0x128>
81118344:	81800417 	ldw	r6,16(r16)
81118348:	80800817 	ldw	r2,32(r16)
8111834c:	81c00517 	ldw	r7,20(r16)
81118350:	81400717 	ldw	r5,28(r16)
81118354:	81800015 	stw	r6,0(r16)
81118358:	8809883a 	mov	r4,r17
8111835c:	103ee83a 	callr	r2
81118360:	80800115 	stw	r2,4(r16)
81118364:	00800e0e 	bge	zero,r2,811183a0 <__srefill_r+0x108>
81118368:	0005883a 	mov	r2,zero
8111836c:	dfc00317 	ldw	ra,12(sp)
81118370:	dc800217 	ldw	r18,8(sp)
81118374:	dc400117 	ldw	r17,4(sp)
81118378:	dc000017 	ldw	r16,0(sp)
8111837c:	dec00404 	addi	sp,sp,16
81118380:	f800283a 	ret
81118384:	1100040c 	andi	r4,r2,16
81118388:	20003026 	beq	r4,zero,8111844c <__srefill_r+0x1b4>
8111838c:	1080020c 	andi	r2,r2,8
81118390:	1000241e 	bne	r2,zero,81118424 <__srefill_r+0x18c>
81118394:	18c00114 	ori	r3,r3,4
81118398:	80c0030d 	sth	r3,12(r16)
8111839c:	003fe406 	br	81118330 <__reset+0xfb0f8330>
811183a0:	80c0030b 	ldhu	r3,12(r16)
811183a4:	1000161e 	bne	r2,zero,81118400 <__srefill_r+0x168>
811183a8:	18c00814 	ori	r3,r3,32
811183ac:	00bfffc4 	movi	r2,-1
811183b0:	80c0030d 	sth	r3,12(r16)
811183b4:	003fed06 	br	8111836c <__reset+0xfb0f836c>
811183b8:	1120a940 	call	81120a94 <__sinit>
811183bc:	003fc206 	br	811182c8 <__reset+0xfb0f82c8>
811183c0:	00a04574 	movhi	r2,33045
811183c4:	10a10104 	addi	r2,r2,-31740
811183c8:	11000017 	ldw	r4,0(r2)
811183cc:	016044b4 	movhi	r5,33042
811183d0:	00800044 	movi	r2,1
811183d4:	29609f04 	addi	r5,r5,-32132
811183d8:	8080030d 	sth	r2,12(r16)
811183dc:	11217080 	call	81121708 <_fwalk>
811183e0:	00800244 	movi	r2,9
811183e4:	8480030d 	sth	r18,12(r16)
811183e8:	9480024c 	andi	r18,r18,9
811183ec:	90bfd51e 	bne	r18,r2,81118344 <__reset+0xfb0f8344>
811183f0:	800b883a 	mov	r5,r16
811183f4:	8809883a 	mov	r4,r17
811183f8:	11204740 	call	81120474 <__sflush_r>
811183fc:	003fd106 	br	81118344 <__reset+0xfb0f8344>
81118400:	18c01014 	ori	r3,r3,64
81118404:	80000115 	stw	zero,4(r16)
81118408:	00bfffc4 	movi	r2,-1
8111840c:	80c0030d 	sth	r3,12(r16)
81118410:	003fd606 	br	8111836c <__reset+0xfb0f836c>
81118414:	80c00e17 	ldw	r3,56(r16)
81118418:	0005883a 	mov	r2,zero
8111841c:	80c00015 	stw	r3,0(r16)
81118420:	003fd206 	br	8111836c <__reset+0xfb0f836c>
81118424:	800b883a 	mov	r5,r16
81118428:	8809883a 	mov	r4,r17
8111842c:	11206980 	call	81120698 <_fflush_r>
81118430:	10000a1e 	bne	r2,zero,8111845c <__srefill_r+0x1c4>
81118434:	8080030b 	ldhu	r2,12(r16)
81118438:	00fffdc4 	movi	r3,-9
8111843c:	80000215 	stw	zero,8(r16)
81118440:	1886703a 	and	r3,r3,r2
81118444:	80000615 	stw	zero,24(r16)
81118448:	003fd206 	br	81118394 <__reset+0xfb0f8394>
8111844c:	00800244 	movi	r2,9
81118450:	88800015 	stw	r2,0(r17)
81118454:	18c01014 	ori	r3,r3,64
81118458:	80c0030d 	sth	r3,12(r16)
8111845c:	00bfffc4 	movi	r2,-1
81118460:	003fc206 	br	8111836c <__reset+0xfb0f836c>
81118464:	800b883a 	mov	r5,r16
81118468:	8809883a 	mov	r4,r17
8111846c:	11172f40 	call	811172f4 <__smakebuf_r>
81118470:	003fb106 	br	81118338 <__reset+0xfb0f8338>

81118474 <_sbrk_r>:
81118474:	defffd04 	addi	sp,sp,-12
81118478:	de00012e 	bgeu	sp,et,81118480 <_sbrk_r+0xc>
8111847c:	003b68fa 	trap	3
81118480:	dc000015 	stw	r16,0(sp)
81118484:	04204574 	movhi	r16,33045
81118488:	dc400115 	stw	r17,4(sp)
8111848c:	84216604 	addi	r16,r16,-31336
81118490:	2023883a 	mov	r17,r4
81118494:	2809883a 	mov	r4,r5
81118498:	dfc00215 	stw	ra,8(sp)
8111849c:	80000015 	stw	zero,0(r16)
811184a0:	112dc440 	call	8112dc44 <sbrk>
811184a4:	00ffffc4 	movi	r3,-1
811184a8:	10c00526 	beq	r2,r3,811184c0 <_sbrk_r+0x4c>
811184ac:	dfc00217 	ldw	ra,8(sp)
811184b0:	dc400117 	ldw	r17,4(sp)
811184b4:	dc000017 	ldw	r16,0(sp)
811184b8:	dec00304 	addi	sp,sp,12
811184bc:	f800283a 	ret
811184c0:	80c00017 	ldw	r3,0(r16)
811184c4:	183ff926 	beq	r3,zero,811184ac <__reset+0xfb0f84ac>
811184c8:	88c00015 	stw	r3,0(r17)
811184cc:	003ff706 	br	811184ac <__reset+0xfb0f84ac>

811184d0 <scanf>:
811184d0:	defffc04 	addi	sp,sp,-16
811184d4:	de00012e 	bgeu	sp,et,811184dc <scanf+0xc>
811184d8:	003b68fa 	trap	3
811184dc:	dfc00015 	stw	ra,0(sp)
811184e0:	d9400115 	stw	r5,4(sp)
811184e4:	d9800215 	stw	r6,8(sp)
811184e8:	d9c00315 	stw	r7,12(sp)
811184ec:	00a04574 	movhi	r2,33045
811184f0:	10a10204 	addi	r2,r2,-31736
811184f4:	200d883a 	mov	r6,r4
811184f8:	11000017 	ldw	r4,0(r2)
811184fc:	d9c00104 	addi	r7,sp,4
81118500:	21400117 	ldw	r5,4(r4)
81118504:	111e8080 	call	8111e808 <_vfscanf_r>
81118508:	dfc00017 	ldw	ra,0(sp)
8111850c:	dec00404 	addi	sp,sp,16
81118510:	f800283a 	ret

81118514 <_scanf_r>:
81118514:	defffd04 	addi	sp,sp,-12
81118518:	2805883a 	mov	r2,r5
8111851c:	de00012e 	bgeu	sp,et,81118524 <_scanf_r+0x10>
81118520:	003b68fa 	trap	3
81118524:	dfc00015 	stw	ra,0(sp)
81118528:	d9800115 	stw	r6,4(sp)
8111852c:	d9c00215 	stw	r7,8(sp)
81118530:	21400117 	ldw	r5,4(r4)
81118534:	d9c00104 	addi	r7,sp,4
81118538:	100d883a 	mov	r6,r2
8111853c:	111e8080 	call	8111e808 <_vfscanf_r>
81118540:	dfc00017 	ldw	ra,0(sp)
81118544:	dec00304 	addi	sp,sp,12
81118548:	f800283a 	ret

8111854c <_sprintf_r>:
8111854c:	deffe404 	addi	sp,sp,-112
81118550:	2807883a 	mov	r3,r5
81118554:	de00012e 	bgeu	sp,et,8111855c <_sprintf_r+0x10>
81118558:	003b68fa 	trap	3
8111855c:	dfc01a15 	stw	ra,104(sp)
81118560:	d9c01b15 	stw	r7,108(sp)
81118564:	00a00034 	movhi	r2,32768
81118568:	10bfffc4 	addi	r2,r2,-1
8111856c:	02008204 	movi	r8,520
81118570:	d8800215 	stw	r2,8(sp)
81118574:	d8800515 	stw	r2,20(sp)
81118578:	d9c01b04 	addi	r7,sp,108
8111857c:	d80b883a 	mov	r5,sp
81118580:	00bfffc4 	movi	r2,-1
81118584:	d8c00015 	stw	r3,0(sp)
81118588:	d8c00415 	stw	r3,16(sp)
8111858c:	da00030d 	sth	r8,12(sp)
81118590:	d880038d 	sth	r2,14(sp)
81118594:	1118af80 	call	81118af8 <___svfprintf_internal_r>
81118598:	d8c00017 	ldw	r3,0(sp)
8111859c:	18000005 	stb	zero,0(r3)
811185a0:	dfc01a17 	ldw	ra,104(sp)
811185a4:	dec01c04 	addi	sp,sp,112
811185a8:	f800283a 	ret

811185ac <sprintf>:
811185ac:	deffe304 	addi	sp,sp,-116
811185b0:	2007883a 	mov	r3,r4
811185b4:	de00012e 	bgeu	sp,et,811185bc <sprintf+0x10>
811185b8:	003b68fa 	trap	3
811185bc:	dfc01a15 	stw	ra,104(sp)
811185c0:	d9801b15 	stw	r6,108(sp)
811185c4:	d9c01c15 	stw	r7,112(sp)
811185c8:	01204574 	movhi	r4,33045
811185cc:	21210204 	addi	r4,r4,-31736
811185d0:	21000017 	ldw	r4,0(r4)
811185d4:	00a00034 	movhi	r2,32768
811185d8:	10bfffc4 	addi	r2,r2,-1
811185dc:	280d883a 	mov	r6,r5
811185e0:	02008204 	movi	r8,520
811185e4:	d8800215 	stw	r2,8(sp)
811185e8:	d8800515 	stw	r2,20(sp)
811185ec:	d9c01b04 	addi	r7,sp,108
811185f0:	d80b883a 	mov	r5,sp
811185f4:	00bfffc4 	movi	r2,-1
811185f8:	d8c00015 	stw	r3,0(sp)
811185fc:	d8c00415 	stw	r3,16(sp)
81118600:	da00030d 	sth	r8,12(sp)
81118604:	d880038d 	sth	r2,14(sp)
81118608:	1118af80 	call	81118af8 <___svfprintf_internal_r>
8111860c:	d8c00017 	ldw	r3,0(sp)
81118610:	18000005 	stb	zero,0(r3)
81118614:	dfc01a17 	ldw	ra,104(sp)
81118618:	dec01d04 	addi	sp,sp,116
8111861c:	f800283a 	ret

81118620 <__sread>:
81118620:	defffe04 	addi	sp,sp,-8
81118624:	de00012e 	bgeu	sp,et,8111862c <__sread+0xc>
81118628:	003b68fa 	trap	3
8111862c:	dc000015 	stw	r16,0(sp)
81118630:	2821883a 	mov	r16,r5
81118634:	2940038f 	ldh	r5,14(r5)
81118638:	dfc00115 	stw	ra,4(sp)
8111863c:	1122f580 	call	81122f58 <_read_r>
81118640:	10000716 	blt	r2,zero,81118660 <__sread+0x40>
81118644:	80c01417 	ldw	r3,80(r16)
81118648:	1887883a 	add	r3,r3,r2
8111864c:	80c01415 	stw	r3,80(r16)
81118650:	dfc00117 	ldw	ra,4(sp)
81118654:	dc000017 	ldw	r16,0(sp)
81118658:	dec00204 	addi	sp,sp,8
8111865c:	f800283a 	ret
81118660:	80c0030b 	ldhu	r3,12(r16)
81118664:	18fbffcc 	andi	r3,r3,61439
81118668:	80c0030d 	sth	r3,12(r16)
8111866c:	dfc00117 	ldw	ra,4(sp)
81118670:	dc000017 	ldw	r16,0(sp)
81118674:	dec00204 	addi	sp,sp,8
81118678:	f800283a 	ret

8111867c <__seofread>:
8111867c:	0005883a 	mov	r2,zero
81118680:	f800283a 	ret

81118684 <__swrite>:
81118684:	defffb04 	addi	sp,sp,-20
81118688:	de00012e 	bgeu	sp,et,81118690 <__swrite+0xc>
8111868c:	003b68fa 	trap	3
81118690:	2880030b 	ldhu	r2,12(r5)
81118694:	dcc00315 	stw	r19,12(sp)
81118698:	dc800215 	stw	r18,8(sp)
8111869c:	dc400115 	stw	r17,4(sp)
811186a0:	dc000015 	stw	r16,0(sp)
811186a4:	dfc00415 	stw	ra,16(sp)
811186a8:	10c0400c 	andi	r3,r2,256
811186ac:	2821883a 	mov	r16,r5
811186b0:	2023883a 	mov	r17,r4
811186b4:	3025883a 	mov	r18,r6
811186b8:	3827883a 	mov	r19,r7
811186bc:	18000526 	beq	r3,zero,811186d4 <__swrite+0x50>
811186c0:	2940038f 	ldh	r5,14(r5)
811186c4:	01c00084 	movi	r7,2
811186c8:	000d883a 	mov	r6,zero
811186cc:	1121a100 	call	81121a10 <_lseek_r>
811186d0:	8080030b 	ldhu	r2,12(r16)
811186d4:	8140038f 	ldh	r5,14(r16)
811186d8:	10bbffcc 	andi	r2,r2,61439
811186dc:	980f883a 	mov	r7,r19
811186e0:	900d883a 	mov	r6,r18
811186e4:	8809883a 	mov	r4,r17
811186e8:	8080030d 	sth	r2,12(r16)
811186ec:	dfc00417 	ldw	ra,16(sp)
811186f0:	dcc00317 	ldw	r19,12(sp)
811186f4:	dc800217 	ldw	r18,8(sp)
811186f8:	dc400117 	ldw	r17,4(sp)
811186fc:	dc000017 	ldw	r16,0(sp)
81118700:	dec00504 	addi	sp,sp,20
81118704:	111e9bc1 	jmpi	8111e9bc <_write_r>

81118708 <__sseek>:
81118708:	defffe04 	addi	sp,sp,-8
8111870c:	de00012e 	bgeu	sp,et,81118714 <__sseek+0xc>
81118710:	003b68fa 	trap	3
81118714:	dc000015 	stw	r16,0(sp)
81118718:	2821883a 	mov	r16,r5
8111871c:	2940038f 	ldh	r5,14(r5)
81118720:	dfc00115 	stw	ra,4(sp)
81118724:	1121a100 	call	81121a10 <_lseek_r>
81118728:	00ffffc4 	movi	r3,-1
8111872c:	10c00826 	beq	r2,r3,81118750 <__sseek+0x48>
81118730:	80c0030b 	ldhu	r3,12(r16)
81118734:	80801415 	stw	r2,80(r16)
81118738:	18c40014 	ori	r3,r3,4096
8111873c:	80c0030d 	sth	r3,12(r16)
81118740:	dfc00117 	ldw	ra,4(sp)
81118744:	dc000017 	ldw	r16,0(sp)
81118748:	dec00204 	addi	sp,sp,8
8111874c:	f800283a 	ret
81118750:	80c0030b 	ldhu	r3,12(r16)
81118754:	18fbffcc 	andi	r3,r3,61439
81118758:	80c0030d 	sth	r3,12(r16)
8111875c:	dfc00117 	ldw	ra,4(sp)
81118760:	dc000017 	ldw	r16,0(sp)
81118764:	dec00204 	addi	sp,sp,8
81118768:	f800283a 	ret

8111876c <__sclose>:
8111876c:	2940038f 	ldh	r5,14(r5)
81118770:	111eb801 	jmpi	8111eb80 <_close_r>

81118774 <strcspn>:
81118774:	21c00007 	ldb	r7,0(r4)
81118778:	38000f26 	beq	r7,zero,811187b8 <strcspn+0x44>
8111877c:	2a000007 	ldb	r8,0(r5)
81118780:	2005883a 	mov	r2,r4
81118784:	40000726 	beq	r8,zero,811187a4 <strcspn+0x30>
81118788:	3a000926 	beq	r7,r8,811187b0 <strcspn+0x3c>
8111878c:	2807883a 	mov	r3,r5
81118790:	00000106 	br	81118798 <strcspn+0x24>
81118794:	31c00626 	beq	r6,r7,811187b0 <strcspn+0x3c>
81118798:	18c00044 	addi	r3,r3,1
8111879c:	19800007 	ldb	r6,0(r3)
811187a0:	303ffc1e 	bne	r6,zero,81118794 <__reset+0xfb0f8794>
811187a4:	10800044 	addi	r2,r2,1
811187a8:	11c00007 	ldb	r7,0(r2)
811187ac:	383ff51e 	bne	r7,zero,81118784 <__reset+0xfb0f8784>
811187b0:	1105c83a 	sub	r2,r2,r4
811187b4:	f800283a 	ret
811187b8:	0005883a 	mov	r2,zero
811187bc:	f800283a 	ret

811187c0 <strlen>:
811187c0:	208000cc 	andi	r2,r4,3
811187c4:	10002026 	beq	r2,zero,81118848 <strlen+0x88>
811187c8:	20800007 	ldb	r2,0(r4)
811187cc:	10002026 	beq	r2,zero,81118850 <strlen+0x90>
811187d0:	2005883a 	mov	r2,r4
811187d4:	00000206 	br	811187e0 <strlen+0x20>
811187d8:	10c00007 	ldb	r3,0(r2)
811187dc:	18001826 	beq	r3,zero,81118840 <strlen+0x80>
811187e0:	10800044 	addi	r2,r2,1
811187e4:	10c000cc 	andi	r3,r2,3
811187e8:	183ffb1e 	bne	r3,zero,811187d8 <__reset+0xfb0f87d8>
811187ec:	10c00017 	ldw	r3,0(r2)
811187f0:	01ffbff4 	movhi	r7,65279
811187f4:	39ffbfc4 	addi	r7,r7,-257
811187f8:	00ca303a 	nor	r5,zero,r3
811187fc:	01a02074 	movhi	r6,32897
81118800:	19c7883a 	add	r3,r3,r7
81118804:	31a02004 	addi	r6,r6,-32640
81118808:	1946703a 	and	r3,r3,r5
8111880c:	1986703a 	and	r3,r3,r6
81118810:	1800091e 	bne	r3,zero,81118838 <strlen+0x78>
81118814:	10800104 	addi	r2,r2,4
81118818:	10c00017 	ldw	r3,0(r2)
8111881c:	19cb883a 	add	r5,r3,r7
81118820:	00c6303a 	nor	r3,zero,r3
81118824:	28c6703a 	and	r3,r5,r3
81118828:	1986703a 	and	r3,r3,r6
8111882c:	183ff926 	beq	r3,zero,81118814 <__reset+0xfb0f8814>
81118830:	00000106 	br	81118838 <strlen+0x78>
81118834:	10800044 	addi	r2,r2,1
81118838:	10c00007 	ldb	r3,0(r2)
8111883c:	183ffd1e 	bne	r3,zero,81118834 <__reset+0xfb0f8834>
81118840:	1105c83a 	sub	r2,r2,r4
81118844:	f800283a 	ret
81118848:	2005883a 	mov	r2,r4
8111884c:	003fe706 	br	811187ec <__reset+0xfb0f87ec>
81118850:	0005883a 	mov	r2,zero
81118854:	f800283a 	ret

81118858 <strnlen>:
81118858:	28000e26 	beq	r5,zero,81118894 <strnlen+0x3c>
8111885c:	20800007 	ldb	r2,0(r4)
81118860:	10000c26 	beq	r2,zero,81118894 <strnlen+0x3c>
81118864:	20c00044 	addi	r3,r4,1
81118868:	214b883a 	add	r5,r4,r5
8111886c:	28c00526 	beq	r5,r3,81118884 <strnlen+0x2c>
81118870:	19800007 	ldb	r6,0(r3)
81118874:	19c00044 	addi	r7,r3,1
81118878:	30000426 	beq	r6,zero,8111888c <strnlen+0x34>
8111887c:	3807883a 	mov	r3,r7
81118880:	28fffb1e 	bne	r5,r3,81118870 <__reset+0xfb0f8870>
81118884:	2905c83a 	sub	r2,r5,r4
81118888:	f800283a 	ret
8111888c:	1905c83a 	sub	r2,r3,r4
81118890:	f800283a 	ret
81118894:	0005883a 	mov	r2,zero
81118898:	f800283a 	ret

8111889c <_strtol_r>:
8111889c:	00a04574 	movhi	r2,33045
811188a0:	defff404 	addi	sp,sp,-48
811188a4:	10a10004 	addi	r2,r2,-31744
811188a8:	de00012e 	bgeu	sp,et,811188b0 <_strtol_r+0x14>
811188ac:	003b68fa 	trap	3
811188b0:	dd400715 	stw	r21,28(sp)
811188b4:	15400017 	ldw	r21,0(r2)
811188b8:	dd800815 	stw	r22,32(sp)
811188bc:	dd000615 	stw	r20,24(sp)
811188c0:	dcc00515 	stw	r19,20(sp)
811188c4:	d9000015 	stw	r4,0(sp)
811188c8:	dfc00b15 	stw	ra,44(sp)
811188cc:	df000a15 	stw	fp,40(sp)
811188d0:	ddc00915 	stw	r23,36(sp)
811188d4:	dc800415 	stw	r18,16(sp)
811188d8:	dc400315 	stw	r17,12(sp)
811188dc:	dc000215 	stw	r16,8(sp)
811188e0:	2829883a 	mov	r20,r5
811188e4:	3027883a 	mov	r19,r6
811188e8:	382d883a 	mov	r22,r7
811188ec:	2809883a 	mov	r4,r5
811188f0:	24000003 	ldbu	r16,0(r4)
811188f4:	24400044 	addi	r17,r4,1
811188f8:	2007883a 	mov	r3,r4
811188fc:	ac05883a 	add	r2,r21,r16
81118900:	10800043 	ldbu	r2,1(r2)
81118904:	8809883a 	mov	r4,r17
81118908:	1080020c 	andi	r2,r2,8
8111890c:	103ff81e 	bne	r2,zero,811188f0 <__reset+0xfb0f88f0>
81118910:	00800b44 	movi	r2,45
81118914:	80805826 	beq	r16,r2,81118a78 <_strtol_r+0x1dc>
81118918:	00800ac4 	movi	r2,43
8111891c:	80805a26 	beq	r16,r2,81118a88 <_strtol_r+0x1ec>
81118920:	0039883a 	mov	fp,zero
81118924:	b0004426 	beq	r22,zero,81118a38 <_strtol_r+0x19c>
81118928:	00800404 	movi	r2,16
8111892c:	b0806026 	beq	r22,r2,81118ab0 <_strtol_r+0x214>
81118930:	b02f883a 	mov	r23,r22
81118934:	00a00034 	movhi	r2,32768
81118938:	e025003a 	cmpeq	r18,fp,zero
8111893c:	14a5c83a 	sub	r18,r2,r18
81118940:	b80b883a 	mov	r5,r23
81118944:	9009883a 	mov	r4,r18
81118948:	112a3180 	call	8112a318 <__umodsi3>
8111894c:	b80b883a 	mov	r5,r23
81118950:	9009883a 	mov	r4,r18
81118954:	d8800115 	stw	r2,4(sp)
81118958:	112a2b40 	call	8112a2b4 <__udivsi3>
8111895c:	ac07883a 	add	r3,r21,r16
81118960:	18c00043 	ldbu	r3,1(r3)
81118964:	880b883a 	mov	r5,r17
81118968:	000d883a 	mov	r6,zero
8111896c:	1a00010c 	andi	r8,r3,4
81118970:	0009883a 	mov	r4,zero
81118974:	02800044 	movi	r10,1
81118978:	027fffc4 	movi	r9,-1
8111897c:	d9c00117 	ldw	r7,4(sp)
81118980:	40000e26 	beq	r8,zero,811189bc <_strtol_r+0x120>
81118984:	843ff404 	addi	r16,r16,-48
81118988:	8580120e 	bge	r16,r22,811189d4 <_strtol_r+0x138>
8111898c:	32400526 	beq	r6,r9,811189a4 <_strtol_r+0x108>
81118990:	11002536 	bltu	r2,r4,81118a28 <_strtol_r+0x18c>
81118994:	20802326 	beq	r4,r2,81118a24 <_strtol_r+0x188>
81118998:	25c9383a 	mul	r4,r4,r23
8111899c:	01800044 	movi	r6,1
811189a0:	8109883a 	add	r4,r16,r4
811189a4:	2c000003 	ldbu	r16,0(r5)
811189a8:	29400044 	addi	r5,r5,1
811189ac:	ac07883a 	add	r3,r21,r16
811189b0:	18c00043 	ldbu	r3,1(r3)
811189b4:	1a00010c 	andi	r8,r3,4
811189b8:	403ff21e 	bne	r8,zero,81118984 <__reset+0xfb0f8984>
811189bc:	18c000cc 	andi	r3,r3,3
811189c0:	18000426 	beq	r3,zero,811189d4 <_strtol_r+0x138>
811189c4:	1a801a26 	beq	r3,r10,81118a30 <_strtol_r+0x194>
811189c8:	00c015c4 	movi	r3,87
811189cc:	80e1c83a 	sub	r16,r16,r3
811189d0:	85bfee16 	blt	r16,r22,8111898c <__reset+0xfb0f898c>
811189d4:	00bfffc4 	movi	r2,-1
811189d8:	30801e26 	beq	r6,r2,81118a54 <_strtol_r+0x1b8>
811189dc:	e0001b1e 	bne	fp,zero,81118a4c <_strtol_r+0x1b0>
811189e0:	2005883a 	mov	r2,r4
811189e4:	98000326 	beq	r19,zero,811189f4 <_strtol_r+0x158>
811189e8:	3000211e 	bne	r6,zero,81118a70 <_strtol_r+0x1d4>
811189ec:	a00b883a 	mov	r5,r20
811189f0:	99400015 	stw	r5,0(r19)
811189f4:	dfc00b17 	ldw	ra,44(sp)
811189f8:	df000a17 	ldw	fp,40(sp)
811189fc:	ddc00917 	ldw	r23,36(sp)
81118a00:	dd800817 	ldw	r22,32(sp)
81118a04:	dd400717 	ldw	r21,28(sp)
81118a08:	dd000617 	ldw	r20,24(sp)
81118a0c:	dcc00517 	ldw	r19,20(sp)
81118a10:	dc800417 	ldw	r18,16(sp)
81118a14:	dc400317 	ldw	r17,12(sp)
81118a18:	dc000217 	ldw	r16,8(sp)
81118a1c:	dec00c04 	addi	sp,sp,48
81118a20:	f800283a 	ret
81118a24:	3c3fdc0e 	bge	r7,r16,81118998 <__reset+0xfb0f8998>
81118a28:	01bfffc4 	movi	r6,-1
81118a2c:	003fdd06 	br	811189a4 <__reset+0xfb0f89a4>
81118a30:	00c00dc4 	movi	r3,55
81118a34:	003fe506 	br	811189cc <__reset+0xfb0f89cc>
81118a38:	00800c04 	movi	r2,48
81118a3c:	80801626 	beq	r16,r2,81118a98 <_strtol_r+0x1fc>
81118a40:	05800284 	movi	r22,10
81118a44:	b02f883a 	mov	r23,r22
81118a48:	003fba06 	br	81118934 <__reset+0xfb0f8934>
81118a4c:	0109c83a 	sub	r4,zero,r4
81118a50:	003fe306 	br	811189e0 <__reset+0xfb0f89e0>
81118a54:	d9000017 	ldw	r4,0(sp)
81118a58:	00c00884 	movi	r3,34
81118a5c:	e005003a 	cmpeq	r2,fp,zero
81118a60:	20c00015 	stw	r3,0(r4)
81118a64:	00e00034 	movhi	r3,32768
81118a68:	1885c83a 	sub	r2,r3,r2
81118a6c:	983fe126 	beq	r19,zero,811189f4 <__reset+0xfb0f89f4>
81118a70:	297fffc4 	addi	r5,r5,-1
81118a74:	003fde06 	br	811189f0 <__reset+0xfb0f89f0>
81118a78:	1c400084 	addi	r17,r3,2
81118a7c:	1c000043 	ldbu	r16,1(r3)
81118a80:	07000044 	movi	fp,1
81118a84:	003fa706 	br	81118924 <__reset+0xfb0f8924>
81118a88:	1c400084 	addi	r17,r3,2
81118a8c:	1c000043 	ldbu	r16,1(r3)
81118a90:	0039883a 	mov	fp,zero
81118a94:	003fa306 	br	81118924 <__reset+0xfb0f8924>
81118a98:	88800003 	ldbu	r2,0(r17)
81118a9c:	00c01604 	movi	r3,88
81118aa0:	108037cc 	andi	r2,r2,223
81118aa4:	10c00826 	beq	r2,r3,81118ac8 <_strtol_r+0x22c>
81118aa8:	05800204 	movi	r22,8
81118aac:	003fa006 	br	81118930 <__reset+0xfb0f8930>
81118ab0:	00800c04 	movi	r2,48
81118ab4:	80bf9e1e 	bne	r16,r2,81118930 <__reset+0xfb0f8930>
81118ab8:	88800003 	ldbu	r2,0(r17)
81118abc:	00c01604 	movi	r3,88
81118ac0:	108037cc 	andi	r2,r2,223
81118ac4:	10ff9a1e 	bne	r2,r3,81118930 <__reset+0xfb0f8930>
81118ac8:	05c00404 	movi	r23,16
81118acc:	8c000043 	ldbu	r16,1(r17)
81118ad0:	b82d883a 	mov	r22,r23
81118ad4:	8c400084 	addi	r17,r17,2
81118ad8:	003f9606 	br	81118934 <__reset+0xfb0f8934>

81118adc <strtol>:
81118adc:	00a04574 	movhi	r2,33045
81118ae0:	10a10204 	addi	r2,r2,-31736
81118ae4:	300f883a 	mov	r7,r6
81118ae8:	280d883a 	mov	r6,r5
81118aec:	200b883a 	mov	r5,r4
81118af0:	11000017 	ldw	r4,0(r2)
81118af4:	111889c1 	jmpi	8111889c <_strtol_r>

81118af8 <___svfprintf_internal_r>:
81118af8:	deffb704 	addi	sp,sp,-292
81118afc:	de00012e 	bgeu	sp,et,81118b04 <___svfprintf_internal_r+0xc>
81118b00:	003b68fa 	trap	3
81118b04:	dfc04815 	stw	ra,288(sp)
81118b08:	ddc04615 	stw	r23,280(sp)
81118b0c:	d9402c15 	stw	r5,176(sp)
81118b10:	d9003915 	stw	r4,228(sp)
81118b14:	302f883a 	mov	r23,r6
81118b18:	d9c02d15 	stw	r7,180(sp)
81118b1c:	df004715 	stw	fp,284(sp)
81118b20:	dd804515 	stw	r22,276(sp)
81118b24:	dd404415 	stw	r21,272(sp)
81118b28:	dd004315 	stw	r20,268(sp)
81118b2c:	dcc04215 	stw	r19,264(sp)
81118b30:	dc804115 	stw	r18,260(sp)
81118b34:	dc404015 	stw	r17,256(sp)
81118b38:	dc003f15 	stw	r16,252(sp)
81118b3c:	11219e00 	call	811219e0 <_localeconv_r>
81118b40:	10800017 	ldw	r2,0(r2)
81118b44:	1009883a 	mov	r4,r2
81118b48:	d8803415 	stw	r2,208(sp)
81118b4c:	11187c00 	call	811187c0 <strlen>
81118b50:	d8c02c17 	ldw	r3,176(sp)
81118b54:	d8803815 	stw	r2,224(sp)
81118b58:	1880030b 	ldhu	r2,12(r3)
81118b5c:	1080200c 	andi	r2,r2,128
81118b60:	10000226 	beq	r2,zero,81118b6c <___svfprintf_internal_r+0x74>
81118b64:	18800417 	ldw	r2,16(r3)
81118b68:	10067f26 	beq	r2,zero,8111a568 <___svfprintf_internal_r+0x1a70>
81118b6c:	dcc03917 	ldw	r19,228(sp)
81118b70:	d8c00404 	addi	r3,sp,16
81118b74:	05604534 	movhi	r21,33044
81118b78:	d9001e04 	addi	r4,sp,120
81118b7c:	ad573a84 	addi	r21,r21,23786
81118b80:	d8c01e15 	stw	r3,120(sp)
81118b84:	d8002015 	stw	zero,128(sp)
81118b88:	d8001f15 	stw	zero,124(sp)
81118b8c:	d8003315 	stw	zero,204(sp)
81118b90:	d8003615 	stw	zero,216(sp)
81118b94:	d8003715 	stw	zero,220(sp)
81118b98:	1811883a 	mov	r8,r3
81118b9c:	d8003a15 	stw	zero,232(sp)
81118ba0:	d8003b15 	stw	zero,236(sp)
81118ba4:	d8002f15 	stw	zero,188(sp)
81118ba8:	d9002815 	stw	r4,160(sp)
81118bac:	b8800007 	ldb	r2,0(r23)
81118bb0:	10026726 	beq	r2,zero,81119550 <___svfprintf_internal_r+0xa58>
81118bb4:	00c00944 	movi	r3,37
81118bb8:	b821883a 	mov	r16,r23
81118bbc:	10c0021e 	bne	r2,r3,81118bc8 <___svfprintf_internal_r+0xd0>
81118bc0:	00001406 	br	81118c14 <___svfprintf_internal_r+0x11c>
81118bc4:	10c00326 	beq	r2,r3,81118bd4 <___svfprintf_internal_r+0xdc>
81118bc8:	84000044 	addi	r16,r16,1
81118bcc:	80800007 	ldb	r2,0(r16)
81118bd0:	103ffc1e 	bne	r2,zero,81118bc4 <__reset+0xfb0f8bc4>
81118bd4:	85e3c83a 	sub	r17,r16,r23
81118bd8:	88000e26 	beq	r17,zero,81118c14 <___svfprintf_internal_r+0x11c>
81118bdc:	d8c02017 	ldw	r3,128(sp)
81118be0:	d8801f17 	ldw	r2,124(sp)
81118be4:	45c00015 	stw	r23,0(r8)
81118be8:	1c47883a 	add	r3,r3,r17
81118bec:	10800044 	addi	r2,r2,1
81118bf0:	d8c02015 	stw	r3,128(sp)
81118bf4:	44400115 	stw	r17,4(r8)
81118bf8:	d8801f15 	stw	r2,124(sp)
81118bfc:	00c001c4 	movi	r3,7
81118c00:	18809716 	blt	r3,r2,81118e60 <___svfprintf_internal_r+0x368>
81118c04:	42000204 	addi	r8,r8,8
81118c08:	d9402f17 	ldw	r5,188(sp)
81118c0c:	2c4b883a 	add	r5,r5,r17
81118c10:	d9402f15 	stw	r5,188(sp)
81118c14:	80800007 	ldb	r2,0(r16)
81118c18:	10009826 	beq	r2,zero,81118e7c <___svfprintf_internal_r+0x384>
81118c1c:	84400047 	ldb	r17,1(r16)
81118c20:	00bfffc4 	movi	r2,-1
81118c24:	85c00044 	addi	r23,r16,1
81118c28:	d8002785 	stb	zero,158(sp)
81118c2c:	0007883a 	mov	r3,zero
81118c30:	000f883a 	mov	r7,zero
81118c34:	d8802915 	stw	r2,164(sp)
81118c38:	d8003115 	stw	zero,196(sp)
81118c3c:	0025883a 	mov	r18,zero
81118c40:	01401604 	movi	r5,88
81118c44:	01800244 	movi	r6,9
81118c48:	02800a84 	movi	r10,42
81118c4c:	02401b04 	movi	r9,108
81118c50:	bdc00044 	addi	r23,r23,1
81118c54:	88bff804 	addi	r2,r17,-32
81118c58:	2882f036 	bltu	r5,r2,8111981c <___svfprintf_internal_r+0xd24>
81118c5c:	100490ba 	slli	r2,r2,2
81118c60:	012044b4 	movhi	r4,33042
81118c64:	21231d04 	addi	r4,r4,-29580
81118c68:	1105883a 	add	r2,r2,r4
81118c6c:	10800017 	ldw	r2,0(r2)
81118c70:	1000683a 	jmp	r2
81118c74:	81119784 	addi	r4,r16,18014
81118c78:	8111981c 	xori	r4,r16,18016
81118c7c:	8111981c 	xori	r4,r16,18016
81118c80:	81119778 	rdprs	r4,r16,18013
81118c84:	8111981c 	xori	r4,r16,18016
81118c88:	8111981c 	xori	r4,r16,18016
81118c8c:	8111981c 	xori	r4,r16,18016
81118c90:	8111981c 	xori	r4,r16,18016
81118c94:	8111981c 	xori	r4,r16,18016
81118c98:	8111981c 	xori	r4,r16,18016
81118c9c:	81118ed8 	cmpnei	r4,r16,17979
81118ca0:	811196b4 	orhi	r4,r16,18010
81118ca4:	8111981c 	xori	r4,r16,18016
81118ca8:	81118de8 	cmpgeui	r4,r16,17975
81118cac:	81118f00 	call	881118f0 <__reset+0x20f18f0>
81118cb0:	8111981c 	xori	r4,r16,18016
81118cb4:	81118f74 	orhi	r4,r16,17981
81118cb8:	81118f40 	call	881118f4 <__reset+0x20f18f4>
81118cbc:	81118f40 	call	881118f4 <__reset+0x20f18f4>
81118cc0:	81118f40 	call	881118f4 <__reset+0x20f18f4>
81118cc4:	81118f40 	call	881118f4 <__reset+0x20f18f4>
81118cc8:	81118f40 	call	881118f4 <__reset+0x20f18f4>
81118ccc:	81118f40 	call	881118f4 <__reset+0x20f18f4>
81118cd0:	81118f40 	call	881118f4 <__reset+0x20f18f4>
81118cd4:	81118f40 	call	881118f4 <__reset+0x20f18f4>
81118cd8:	81118f40 	call	881118f4 <__reset+0x20f18f4>
81118cdc:	8111981c 	xori	r4,r16,18016
81118ce0:	8111981c 	xori	r4,r16,18016
81118ce4:	8111981c 	xori	r4,r16,18016
81118ce8:	8111981c 	xori	r4,r16,18016
81118cec:	8111981c 	xori	r4,r16,18016
81118cf0:	8111981c 	xori	r4,r16,18016
81118cf4:	8111981c 	xori	r4,r16,18016
81118cf8:	8111981c 	xori	r4,r16,18016
81118cfc:	8111981c 	xori	r4,r16,18016
81118d00:	8111981c 	xori	r4,r16,18016
81118d04:	8111902c 	andhi	r4,r16,17984
81118d08:	81118f80 	call	881118f8 <__reset+0x20f18f8>
81118d0c:	8111981c 	xori	r4,r16,18016
81118d10:	81118f80 	call	881118f8 <__reset+0x20f18f8>
81118d14:	8111981c 	xori	r4,r16,18016
81118d18:	8111981c 	xori	r4,r16,18016
81118d1c:	8111981c 	xori	r4,r16,18016
81118d20:	8111981c 	xori	r4,r16,18016
81118d24:	81119020 	cmpeqi	r4,r16,17984
81118d28:	8111981c 	xori	r4,r16,18016
81118d2c:	8111981c 	xori	r4,r16,18016
81118d30:	811190e8 	cmpgeui	r4,r16,17987
81118d34:	8111981c 	xori	r4,r16,18016
81118d38:	8111981c 	xori	r4,r16,18016
81118d3c:	8111981c 	xori	r4,r16,18016
81118d40:	8111981c 	xori	r4,r16,18016
81118d44:	8111981c 	xori	r4,r16,18016
81118d48:	81119558 	cmpnei	r4,r16,18005
81118d4c:	8111981c 	xori	r4,r16,18016
81118d50:	8111981c 	xori	r4,r16,18016
81118d54:	811195b8 	rdprs	r4,r16,18006
81118d58:	8111981c 	xori	r4,r16,18016
81118d5c:	8111981c 	xori	r4,r16,18016
81118d60:	8111981c 	xori	r4,r16,18016
81118d64:	8111981c 	xori	r4,r16,18016
81118d68:	8111981c 	xori	r4,r16,18016
81118d6c:	8111981c 	xori	r4,r16,18016
81118d70:	8111981c 	xori	r4,r16,18016
81118d74:	8111981c 	xori	r4,r16,18016
81118d78:	8111981c 	xori	r4,r16,18016
81118d7c:	8111981c 	xori	r4,r16,18016
81118d80:	81119668 	cmpgeui	r4,r16,18009
81118d84:	811197a4 	muli	r4,r16,18014
81118d88:	81118f80 	call	881118f8 <__reset+0x20f18f8>
81118d8c:	81118f80 	call	881118f8 <__reset+0x20f18f8>
81118d90:	81118f80 	call	881118f8 <__reset+0x20f18f8>
81118d94:	811197f8 	rdprs	r4,r16,18015
81118d98:	811197a4 	muli	r4,r16,18014
81118d9c:	8111981c 	xori	r4,r16,18016
81118da0:	8111981c 	xori	r4,r16,18016
81118da4:	811197b4 	orhi	r4,r16,18014
81118da8:	8111981c 	xori	r4,r16,18016
81118dac:	811197c4 	addi	r4,r16,18015
81118db0:	811196a4 	muli	r4,r16,18010
81118db4:	81118df4 	orhi	r4,r16,17975
81118db8:	811196c4 	addi	r4,r16,18011
81118dbc:	8111981c 	xori	r4,r16,18016
81118dc0:	811196d0 	cmplti	r4,r16,18011
81118dc4:	8111981c 	xori	r4,r16,18016
81118dc8:	8111972c 	andhi	r4,r16,18012
81118dcc:	8111981c 	xori	r4,r16,18016
81118dd0:	8111981c 	xori	r4,r16,18016
81118dd4:	8111973c 	xorhi	r4,r16,18012
81118dd8:	d9003117 	ldw	r4,196(sp)
81118ddc:	d8802d15 	stw	r2,180(sp)
81118de0:	0109c83a 	sub	r4,zero,r4
81118de4:	d9003115 	stw	r4,196(sp)
81118de8:	94800114 	ori	r18,r18,4
81118dec:	bc400007 	ldb	r17,0(r23)
81118df0:	003f9706 	br	81118c50 <__reset+0xfb0f8c50>
81118df4:	00800c04 	movi	r2,48
81118df8:	d9002d17 	ldw	r4,180(sp)
81118dfc:	d9402917 	ldw	r5,164(sp)
81118e00:	d8802705 	stb	r2,156(sp)
81118e04:	00801e04 	movi	r2,120
81118e08:	d8802745 	stb	r2,157(sp)
81118e0c:	d8002785 	stb	zero,158(sp)
81118e10:	20c00104 	addi	r3,r4,4
81118e14:	25000017 	ldw	r20,0(r4)
81118e18:	002d883a 	mov	r22,zero
81118e1c:	90800094 	ori	r2,r18,2
81118e20:	28028616 	blt	r5,zero,8111983c <___svfprintf_internal_r+0xd44>
81118e24:	00bfdfc4 	movi	r2,-129
81118e28:	90a4703a 	and	r18,r18,r2
81118e2c:	d8c02d15 	stw	r3,180(sp)
81118e30:	94800094 	ori	r18,r18,2
81118e34:	a002731e 	bne	r20,zero,81119804 <___svfprintf_internal_r+0xd0c>
81118e38:	00a04534 	movhi	r2,33044
81118e3c:	10973304 	addi	r2,r2,23756
81118e40:	d8803a15 	stw	r2,232(sp)
81118e44:	04401e04 	movi	r17,120
81118e48:	d8c02917 	ldw	r3,164(sp)
81118e4c:	0039883a 	mov	fp,zero
81118e50:	1801d526 	beq	r3,zero,811195a8 <___svfprintf_internal_r+0xab0>
81118e54:	0029883a 	mov	r20,zero
81118e58:	002d883a 	mov	r22,zero
81118e5c:	0001f106 	br	81119624 <___svfprintf_internal_r+0xb2c>
81118e60:	d9402c17 	ldw	r5,176(sp)
81118e64:	d9801e04 	addi	r6,sp,120
81118e68:	9809883a 	mov	r4,r19
81118e6c:	11257180 	call	81125718 <__ssprint_r>
81118e70:	1000081e 	bne	r2,zero,81118e94 <___svfprintf_internal_r+0x39c>
81118e74:	da000404 	addi	r8,sp,16
81118e78:	003f6306 	br	81118c08 <__reset+0xfb0f8c08>
81118e7c:	d8802017 	ldw	r2,128(sp)
81118e80:	10000426 	beq	r2,zero,81118e94 <___svfprintf_internal_r+0x39c>
81118e84:	d9402c17 	ldw	r5,176(sp)
81118e88:	d9003917 	ldw	r4,228(sp)
81118e8c:	d9801e04 	addi	r6,sp,120
81118e90:	11257180 	call	81125718 <__ssprint_r>
81118e94:	d8802c17 	ldw	r2,176(sp)
81118e98:	10c0030b 	ldhu	r3,12(r2)
81118e9c:	d8802f17 	ldw	r2,188(sp)
81118ea0:	18c0100c 	andi	r3,r3,64
81118ea4:	1805f51e 	bne	r3,zero,8111a67c <___svfprintf_internal_r+0x1b84>
81118ea8:	dfc04817 	ldw	ra,288(sp)
81118eac:	df004717 	ldw	fp,284(sp)
81118eb0:	ddc04617 	ldw	r23,280(sp)
81118eb4:	dd804517 	ldw	r22,276(sp)
81118eb8:	dd404417 	ldw	r21,272(sp)
81118ebc:	dd004317 	ldw	r20,268(sp)
81118ec0:	dcc04217 	ldw	r19,264(sp)
81118ec4:	dc804117 	ldw	r18,260(sp)
81118ec8:	dc404017 	ldw	r17,256(sp)
81118ecc:	dc003f17 	ldw	r16,252(sp)
81118ed0:	dec04904 	addi	sp,sp,292
81118ed4:	f800283a 	ret
81118ed8:	d8802d17 	ldw	r2,180(sp)
81118edc:	d9002d17 	ldw	r4,180(sp)
81118ee0:	10800017 	ldw	r2,0(r2)
81118ee4:	d8803115 	stw	r2,196(sp)
81118ee8:	20800104 	addi	r2,r4,4
81118eec:	d9003117 	ldw	r4,196(sp)
81118ef0:	203fb916 	blt	r4,zero,81118dd8 <__reset+0xfb0f8dd8>
81118ef4:	d8802d15 	stw	r2,180(sp)
81118ef8:	bc400007 	ldb	r17,0(r23)
81118efc:	003f5406 	br	81118c50 <__reset+0xfb0f8c50>
81118f00:	bc400007 	ldb	r17,0(r23)
81118f04:	bac00044 	addi	r11,r23,1
81118f08:	8a873926 	beq	r17,r10,8111abf0 <___svfprintf_internal_r+0x20f8>
81118f0c:	88bff404 	addi	r2,r17,-48
81118f10:	0009883a 	mov	r4,zero
81118f14:	30868836 	bltu	r6,r2,8111a938 <___svfprintf_internal_r+0x1e40>
81118f18:	5c400007 	ldb	r17,0(r11)
81118f1c:	210002a4 	muli	r4,r4,10
81118f20:	5dc00044 	addi	r23,r11,1
81118f24:	b817883a 	mov	r11,r23
81118f28:	2089883a 	add	r4,r4,r2
81118f2c:	88bff404 	addi	r2,r17,-48
81118f30:	30bff92e 	bgeu	r6,r2,81118f18 <__reset+0xfb0f8f18>
81118f34:	2005d716 	blt	r4,zero,8111a694 <___svfprintf_internal_r+0x1b9c>
81118f38:	d9002915 	stw	r4,164(sp)
81118f3c:	003f4506 	br	81118c54 <__reset+0xfb0f8c54>
81118f40:	b809883a 	mov	r4,r23
81118f44:	d8003115 	stw	zero,196(sp)
81118f48:	88bff404 	addi	r2,r17,-48
81118f4c:	0017883a 	mov	r11,zero
81118f50:	24400007 	ldb	r17,0(r4)
81118f54:	5ac002a4 	muli	r11,r11,10
81118f58:	bdc00044 	addi	r23,r23,1
81118f5c:	b809883a 	mov	r4,r23
81118f60:	12d7883a 	add	r11,r2,r11
81118f64:	88bff404 	addi	r2,r17,-48
81118f68:	30bff92e 	bgeu	r6,r2,81118f50 <__reset+0xfb0f8f50>
81118f6c:	dac03115 	stw	r11,196(sp)
81118f70:	003f3806 	br	81118c54 <__reset+0xfb0f8c54>
81118f74:	94802014 	ori	r18,r18,128
81118f78:	bc400007 	ldb	r17,0(r23)
81118f7c:	003f3406 	br	81118c50 <__reset+0xfb0f8c50>
81118f80:	18c03fcc 	andi	r3,r3,255
81118f84:	1807471e 	bne	r3,zero,8111aca4 <___svfprintf_internal_r+0x21ac>
81118f88:	9080020c 	andi	r2,r18,8
81118f8c:	10047d26 	beq	r2,zero,8111a184 <___svfprintf_internal_r+0x168c>
81118f90:	d8c02d17 	ldw	r3,180(sp)
81118f94:	d9002d17 	ldw	r4,180(sp)
81118f98:	d9402d17 	ldw	r5,180(sp)
81118f9c:	18c00017 	ldw	r3,0(r3)
81118fa0:	21000117 	ldw	r4,4(r4)
81118fa4:	29400204 	addi	r5,r5,8
81118fa8:	d8c03615 	stw	r3,216(sp)
81118fac:	d9003715 	stw	r4,220(sp)
81118fb0:	d9402d15 	stw	r5,180(sp)
81118fb4:	d9003617 	ldw	r4,216(sp)
81118fb8:	d9403717 	ldw	r5,220(sp)
81118fbc:	da003e15 	stw	r8,248(sp)
81118fc0:	04000044 	movi	r16,1
81118fc4:	112352c0 	call	8112352c <__fpclassifyd>
81118fc8:	da003e17 	ldw	r8,248(sp)
81118fcc:	14044b1e 	bne	r2,r16,8111a0fc <___svfprintf_internal_r+0x1604>
81118fd0:	d9003617 	ldw	r4,216(sp)
81118fd4:	d9403717 	ldw	r5,220(sp)
81118fd8:	000d883a 	mov	r6,zero
81118fdc:	000f883a 	mov	r7,zero
81118fe0:	112b8740 	call	8112b874 <__ledf2>
81118fe4:	da003e17 	ldw	r8,248(sp)
81118fe8:	1005f316 	blt	r2,zero,8111a7b8 <___svfprintf_internal_r+0x1cc0>
81118fec:	df002783 	ldbu	fp,158(sp)
81118ff0:	008011c4 	movi	r2,71
81118ff4:	1445590e 	bge	r2,r17,8111a55c <___svfprintf_internal_r+0x1a64>
81118ff8:	04204534 	movhi	r16,33044
81118ffc:	84172b04 	addi	r16,r16,23724
81119000:	00c000c4 	movi	r3,3
81119004:	00bfdfc4 	movi	r2,-129
81119008:	d8c02a15 	stw	r3,168(sp)
8111900c:	90a4703a 	and	r18,r18,r2
81119010:	d8c02e15 	stw	r3,184(sp)
81119014:	d8002915 	stw	zero,164(sp)
81119018:	d8003215 	stw	zero,200(sp)
8111901c:	00006606 	br	811191b8 <___svfprintf_internal_r+0x6c0>
81119020:	94800214 	ori	r18,r18,8
81119024:	bc400007 	ldb	r17,0(r23)
81119028:	003f0906 	br	81118c50 <__reset+0xfb0f8c50>
8111902c:	18c03fcc 	andi	r3,r3,255
81119030:	1807181e 	bne	r3,zero,8111ac94 <___svfprintf_internal_r+0x219c>
81119034:	94800414 	ori	r18,r18,16
81119038:	9080080c 	andi	r2,r18,32
8111903c:	10039626 	beq	r2,zero,81119e98 <___svfprintf_internal_r+0x13a0>
81119040:	d9402d17 	ldw	r5,180(sp)
81119044:	28800117 	ldw	r2,4(r5)
81119048:	2d000017 	ldw	r20,0(r5)
8111904c:	29400204 	addi	r5,r5,8
81119050:	d9402d15 	stw	r5,180(sp)
81119054:	102d883a 	mov	r22,r2
81119058:	10039816 	blt	r2,zero,81119ebc <___svfprintf_internal_r+0x13c4>
8111905c:	d9402917 	ldw	r5,164(sp)
81119060:	df002783 	ldbu	fp,158(sp)
81119064:	2803ab16 	blt	r5,zero,81119f14 <___svfprintf_internal_r+0x141c>
81119068:	00ffdfc4 	movi	r3,-129
8111906c:	a584b03a 	or	r2,r20,r22
81119070:	90e4703a 	and	r18,r18,r3
81119074:	10014a26 	beq	r2,zero,811195a0 <___svfprintf_internal_r+0xaa8>
81119078:	b0034b26 	beq	r22,zero,81119da8 <___svfprintf_internal_r+0x12b0>
8111907c:	dc402a15 	stw	r17,168(sp)
81119080:	dc001e04 	addi	r16,sp,120
81119084:	b023883a 	mov	r17,r22
81119088:	402d883a 	mov	r22,r8
8111908c:	a009883a 	mov	r4,r20
81119090:	880b883a 	mov	r5,r17
81119094:	01800284 	movi	r6,10
81119098:	000f883a 	mov	r7,zero
8111909c:	1129c7c0 	call	81129c7c <__umoddi3>
811190a0:	10800c04 	addi	r2,r2,48
811190a4:	843fffc4 	addi	r16,r16,-1
811190a8:	a009883a 	mov	r4,r20
811190ac:	880b883a 	mov	r5,r17
811190b0:	80800005 	stb	r2,0(r16)
811190b4:	01800284 	movi	r6,10
811190b8:	000f883a 	mov	r7,zero
811190bc:	11296fc0 	call	811296fc <__udivdi3>
811190c0:	1029883a 	mov	r20,r2
811190c4:	10c4b03a 	or	r2,r2,r3
811190c8:	1823883a 	mov	r17,r3
811190cc:	103fef1e 	bne	r2,zero,8111908c <__reset+0xfb0f908c>
811190d0:	d8c02817 	ldw	r3,160(sp)
811190d4:	dc402a17 	ldw	r17,168(sp)
811190d8:	b011883a 	mov	r8,r22
811190dc:	1c07c83a 	sub	r3,r3,r16
811190e0:	d8c02e15 	stw	r3,184(sp)
811190e4:	00002e06 	br	811191a0 <___svfprintf_internal_r+0x6a8>
811190e8:	18c03fcc 	andi	r3,r3,255
811190ec:	1806e71e 	bne	r3,zero,8111ac8c <___svfprintf_internal_r+0x2194>
811190f0:	94800414 	ori	r18,r18,16
811190f4:	9080080c 	andi	r2,r18,32
811190f8:	1002d426 	beq	r2,zero,81119c4c <___svfprintf_internal_r+0x1154>
811190fc:	d9402d17 	ldw	r5,180(sp)
81119100:	d8c02917 	ldw	r3,164(sp)
81119104:	d8002785 	stb	zero,158(sp)
81119108:	28800204 	addi	r2,r5,8
8111910c:	2d000017 	ldw	r20,0(r5)
81119110:	2d800117 	ldw	r22,4(r5)
81119114:	18041516 	blt	r3,zero,8111a16c <___svfprintf_internal_r+0x1674>
81119118:	013fdfc4 	movi	r4,-129
8111911c:	a586b03a 	or	r3,r20,r22
81119120:	d8802d15 	stw	r2,180(sp)
81119124:	9124703a 	and	r18,r18,r4
81119128:	1802d51e 	bne	r3,zero,81119c80 <___svfprintf_internal_r+0x1188>
8111912c:	d9402917 	ldw	r5,164(sp)
81119130:	0039883a 	mov	fp,zero
81119134:	2806be26 	beq	r5,zero,8111ac30 <___svfprintf_internal_r+0x2138>
81119138:	0029883a 	mov	r20,zero
8111913c:	002d883a 	mov	r22,zero
81119140:	dc001e04 	addi	r16,sp,120
81119144:	a006d0fa 	srli	r3,r20,3
81119148:	b008977a 	slli	r4,r22,29
8111914c:	b02cd0fa 	srli	r22,r22,3
81119150:	a50001cc 	andi	r20,r20,7
81119154:	a0800c04 	addi	r2,r20,48
81119158:	843fffc4 	addi	r16,r16,-1
8111915c:	20e8b03a 	or	r20,r4,r3
81119160:	80800005 	stb	r2,0(r16)
81119164:	a586b03a 	or	r3,r20,r22
81119168:	183ff61e 	bne	r3,zero,81119144 <__reset+0xfb0f9144>
8111916c:	90c0004c 	andi	r3,r18,1
81119170:	18013926 	beq	r3,zero,81119658 <___svfprintf_internal_r+0xb60>
81119174:	10803fcc 	andi	r2,r2,255
81119178:	1080201c 	xori	r2,r2,128
8111917c:	10bfe004 	addi	r2,r2,-128
81119180:	00c00c04 	movi	r3,48
81119184:	10c13426 	beq	r2,r3,81119658 <___svfprintf_internal_r+0xb60>
81119188:	80ffffc5 	stb	r3,-1(r16)
8111918c:	d8c02817 	ldw	r3,160(sp)
81119190:	80bfffc4 	addi	r2,r16,-1
81119194:	1021883a 	mov	r16,r2
81119198:	1887c83a 	sub	r3,r3,r2
8111919c:	d8c02e15 	stw	r3,184(sp)
811191a0:	d8802e17 	ldw	r2,184(sp)
811191a4:	d9002917 	ldw	r4,164(sp)
811191a8:	1100010e 	bge	r2,r4,811191b0 <___svfprintf_internal_r+0x6b8>
811191ac:	2005883a 	mov	r2,r4
811191b0:	d8802a15 	stw	r2,168(sp)
811191b4:	d8003215 	stw	zero,200(sp)
811191b8:	e7003fcc 	andi	fp,fp,255
811191bc:	e700201c 	xori	fp,fp,128
811191c0:	e73fe004 	addi	fp,fp,-128
811191c4:	e0000326 	beq	fp,zero,811191d4 <___svfprintf_internal_r+0x6dc>
811191c8:	d8c02a17 	ldw	r3,168(sp)
811191cc:	18c00044 	addi	r3,r3,1
811191d0:	d8c02a15 	stw	r3,168(sp)
811191d4:	90c0008c 	andi	r3,r18,2
811191d8:	d8c02b15 	stw	r3,172(sp)
811191dc:	18000326 	beq	r3,zero,811191ec <___svfprintf_internal_r+0x6f4>
811191e0:	d8c02a17 	ldw	r3,168(sp)
811191e4:	18c00084 	addi	r3,r3,2
811191e8:	d8c02a15 	stw	r3,168(sp)
811191ec:	90c0210c 	andi	r3,r18,132
811191f0:	d8c03015 	stw	r3,192(sp)
811191f4:	1801a11e 	bne	r3,zero,8111987c <___svfprintf_internal_r+0xd84>
811191f8:	d9003117 	ldw	r4,196(sp)
811191fc:	d8c02a17 	ldw	r3,168(sp)
81119200:	20e9c83a 	sub	r20,r4,r3
81119204:	05019d0e 	bge	zero,r20,8111987c <___svfprintf_internal_r+0xd84>
81119208:	02400404 	movi	r9,16
8111920c:	d8c02017 	ldw	r3,128(sp)
81119210:	d8801f17 	ldw	r2,124(sp)
81119214:	4d051b0e 	bge	r9,r20,8111a684 <___svfprintf_internal_r+0x1b8c>
81119218:	01604534 	movhi	r5,33044
8111921c:	29573e84 	addi	r5,r5,23802
81119220:	dc403c15 	stw	r17,240(sp)
81119224:	d9403515 	stw	r5,212(sp)
81119228:	a023883a 	mov	r17,r20
8111922c:	482d883a 	mov	r22,r9
81119230:	9029883a 	mov	r20,r18
81119234:	070001c4 	movi	fp,7
81119238:	8025883a 	mov	r18,r16
8111923c:	dc002c17 	ldw	r16,176(sp)
81119240:	00000306 	br	81119250 <___svfprintf_internal_r+0x758>
81119244:	8c7ffc04 	addi	r17,r17,-16
81119248:	42000204 	addi	r8,r8,8
8111924c:	b440130e 	bge	r22,r17,8111929c <___svfprintf_internal_r+0x7a4>
81119250:	01204534 	movhi	r4,33044
81119254:	18c00404 	addi	r3,r3,16
81119258:	10800044 	addi	r2,r2,1
8111925c:	21173e84 	addi	r4,r4,23802
81119260:	41000015 	stw	r4,0(r8)
81119264:	45800115 	stw	r22,4(r8)
81119268:	d8c02015 	stw	r3,128(sp)
8111926c:	d8801f15 	stw	r2,124(sp)
81119270:	e0bff40e 	bge	fp,r2,81119244 <__reset+0xfb0f9244>
81119274:	d9801e04 	addi	r6,sp,120
81119278:	800b883a 	mov	r5,r16
8111927c:	9809883a 	mov	r4,r19
81119280:	11257180 	call	81125718 <__ssprint_r>
81119284:	103f031e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119288:	8c7ffc04 	addi	r17,r17,-16
8111928c:	d8c02017 	ldw	r3,128(sp)
81119290:	d8801f17 	ldw	r2,124(sp)
81119294:	da000404 	addi	r8,sp,16
81119298:	b47fed16 	blt	r22,r17,81119250 <__reset+0xfb0f9250>
8111929c:	9021883a 	mov	r16,r18
811192a0:	a025883a 	mov	r18,r20
811192a4:	8829883a 	mov	r20,r17
811192a8:	dc403c17 	ldw	r17,240(sp)
811192ac:	d9403517 	ldw	r5,212(sp)
811192b0:	a0c7883a 	add	r3,r20,r3
811192b4:	10800044 	addi	r2,r2,1
811192b8:	41400015 	stw	r5,0(r8)
811192bc:	45000115 	stw	r20,4(r8)
811192c0:	d8c02015 	stw	r3,128(sp)
811192c4:	d8801f15 	stw	r2,124(sp)
811192c8:	010001c4 	movi	r4,7
811192cc:	20829f16 	blt	r4,r2,81119d4c <___svfprintf_internal_r+0x1254>
811192d0:	df002787 	ldb	fp,158(sp)
811192d4:	42000204 	addi	r8,r8,8
811192d8:	e0000c26 	beq	fp,zero,8111930c <___svfprintf_internal_r+0x814>
811192dc:	d8801f17 	ldw	r2,124(sp)
811192e0:	d9002784 	addi	r4,sp,158
811192e4:	18c00044 	addi	r3,r3,1
811192e8:	10800044 	addi	r2,r2,1
811192ec:	41000015 	stw	r4,0(r8)
811192f0:	01000044 	movi	r4,1
811192f4:	41000115 	stw	r4,4(r8)
811192f8:	d8c02015 	stw	r3,128(sp)
811192fc:	d8801f15 	stw	r2,124(sp)
81119300:	010001c4 	movi	r4,7
81119304:	20823816 	blt	r4,r2,81119be8 <___svfprintf_internal_r+0x10f0>
81119308:	42000204 	addi	r8,r8,8
8111930c:	d8802b17 	ldw	r2,172(sp)
81119310:	10000c26 	beq	r2,zero,81119344 <___svfprintf_internal_r+0x84c>
81119314:	d8801f17 	ldw	r2,124(sp)
81119318:	d9002704 	addi	r4,sp,156
8111931c:	18c00084 	addi	r3,r3,2
81119320:	10800044 	addi	r2,r2,1
81119324:	41000015 	stw	r4,0(r8)
81119328:	01000084 	movi	r4,2
8111932c:	41000115 	stw	r4,4(r8)
81119330:	d8c02015 	stw	r3,128(sp)
81119334:	d8801f15 	stw	r2,124(sp)
81119338:	010001c4 	movi	r4,7
8111933c:	20823216 	blt	r4,r2,81119c08 <___svfprintf_internal_r+0x1110>
81119340:	42000204 	addi	r8,r8,8
81119344:	d9003017 	ldw	r4,192(sp)
81119348:	00802004 	movi	r2,128
8111934c:	20819726 	beq	r4,r2,811199ac <___svfprintf_internal_r+0xeb4>
81119350:	d9402917 	ldw	r5,164(sp)
81119354:	d8802e17 	ldw	r2,184(sp)
81119358:	28adc83a 	sub	r22,r5,r2
8111935c:	05802f0e 	bge	zero,r22,8111941c <___svfprintf_internal_r+0x924>
81119360:	07000404 	movi	fp,16
81119364:	d8801f17 	ldw	r2,124(sp)
81119368:	e583c00e 	bge	fp,r22,8111a26c <___svfprintf_internal_r+0x1774>
8111936c:	01604534 	movhi	r5,33044
81119370:	29573a84 	addi	r5,r5,23786
81119374:	dc402915 	stw	r17,164(sp)
81119378:	d9402b15 	stw	r5,172(sp)
8111937c:	b023883a 	mov	r17,r22
81119380:	050001c4 	movi	r20,7
81119384:	902d883a 	mov	r22,r18
81119388:	8025883a 	mov	r18,r16
8111938c:	dc002c17 	ldw	r16,176(sp)
81119390:	00000306 	br	811193a0 <___svfprintf_internal_r+0x8a8>
81119394:	8c7ffc04 	addi	r17,r17,-16
81119398:	42000204 	addi	r8,r8,8
8111939c:	e440110e 	bge	fp,r17,811193e4 <___svfprintf_internal_r+0x8ec>
811193a0:	18c00404 	addi	r3,r3,16
811193a4:	10800044 	addi	r2,r2,1
811193a8:	45400015 	stw	r21,0(r8)
811193ac:	47000115 	stw	fp,4(r8)
811193b0:	d8c02015 	stw	r3,128(sp)
811193b4:	d8801f15 	stw	r2,124(sp)
811193b8:	a0bff60e 	bge	r20,r2,81119394 <__reset+0xfb0f9394>
811193bc:	d9801e04 	addi	r6,sp,120
811193c0:	800b883a 	mov	r5,r16
811193c4:	9809883a 	mov	r4,r19
811193c8:	11257180 	call	81125718 <__ssprint_r>
811193cc:	103eb11e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
811193d0:	8c7ffc04 	addi	r17,r17,-16
811193d4:	d8c02017 	ldw	r3,128(sp)
811193d8:	d8801f17 	ldw	r2,124(sp)
811193dc:	da000404 	addi	r8,sp,16
811193e0:	e47fef16 	blt	fp,r17,811193a0 <__reset+0xfb0f93a0>
811193e4:	9021883a 	mov	r16,r18
811193e8:	b025883a 	mov	r18,r22
811193ec:	882d883a 	mov	r22,r17
811193f0:	dc402917 	ldw	r17,164(sp)
811193f4:	d9002b17 	ldw	r4,172(sp)
811193f8:	1d87883a 	add	r3,r3,r22
811193fc:	10800044 	addi	r2,r2,1
81119400:	41000015 	stw	r4,0(r8)
81119404:	45800115 	stw	r22,4(r8)
81119408:	d8c02015 	stw	r3,128(sp)
8111940c:	d8801f15 	stw	r2,124(sp)
81119410:	010001c4 	movi	r4,7
81119414:	2081ec16 	blt	r4,r2,81119bc8 <___svfprintf_internal_r+0x10d0>
81119418:	42000204 	addi	r8,r8,8
8111941c:	9080400c 	andi	r2,r18,256
81119420:	1001181e 	bne	r2,zero,81119884 <___svfprintf_internal_r+0xd8c>
81119424:	d9402e17 	ldw	r5,184(sp)
81119428:	d8801f17 	ldw	r2,124(sp)
8111942c:	44000015 	stw	r16,0(r8)
81119430:	1947883a 	add	r3,r3,r5
81119434:	10800044 	addi	r2,r2,1
81119438:	41400115 	stw	r5,4(r8)
8111943c:	d8c02015 	stw	r3,128(sp)
81119440:	d8801f15 	stw	r2,124(sp)
81119444:	010001c4 	movi	r4,7
81119448:	2081d116 	blt	r4,r2,81119b90 <___svfprintf_internal_r+0x1098>
8111944c:	42000204 	addi	r8,r8,8
81119450:	9480010c 	andi	r18,r18,4
81119454:	90003226 	beq	r18,zero,81119520 <___svfprintf_internal_r+0xa28>
81119458:	d9403117 	ldw	r5,196(sp)
8111945c:	d8802a17 	ldw	r2,168(sp)
81119460:	28a1c83a 	sub	r16,r5,r2
81119464:	04002e0e 	bge	zero,r16,81119520 <___svfprintf_internal_r+0xa28>
81119468:	04400404 	movi	r17,16
8111946c:	d8801f17 	ldw	r2,124(sp)
81119470:	8c04b90e 	bge	r17,r16,8111a758 <___svfprintf_internal_r+0x1c60>
81119474:	01604534 	movhi	r5,33044
81119478:	29573e84 	addi	r5,r5,23802
8111947c:	d9403515 	stw	r5,212(sp)
81119480:	048001c4 	movi	r18,7
81119484:	dd002c17 	ldw	r20,176(sp)
81119488:	00000306 	br	81119498 <___svfprintf_internal_r+0x9a0>
8111948c:	843ffc04 	addi	r16,r16,-16
81119490:	42000204 	addi	r8,r8,8
81119494:	8c00130e 	bge	r17,r16,811194e4 <___svfprintf_internal_r+0x9ec>
81119498:	01204534 	movhi	r4,33044
8111949c:	18c00404 	addi	r3,r3,16
811194a0:	10800044 	addi	r2,r2,1
811194a4:	21173e84 	addi	r4,r4,23802
811194a8:	41000015 	stw	r4,0(r8)
811194ac:	44400115 	stw	r17,4(r8)
811194b0:	d8c02015 	stw	r3,128(sp)
811194b4:	d8801f15 	stw	r2,124(sp)
811194b8:	90bff40e 	bge	r18,r2,8111948c <__reset+0xfb0f948c>
811194bc:	d9801e04 	addi	r6,sp,120
811194c0:	a00b883a 	mov	r5,r20
811194c4:	9809883a 	mov	r4,r19
811194c8:	11257180 	call	81125718 <__ssprint_r>
811194cc:	103e711e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
811194d0:	843ffc04 	addi	r16,r16,-16
811194d4:	d8c02017 	ldw	r3,128(sp)
811194d8:	d8801f17 	ldw	r2,124(sp)
811194dc:	da000404 	addi	r8,sp,16
811194e0:	8c3fed16 	blt	r17,r16,81119498 <__reset+0xfb0f9498>
811194e4:	d9403517 	ldw	r5,212(sp)
811194e8:	1c07883a 	add	r3,r3,r16
811194ec:	10800044 	addi	r2,r2,1
811194f0:	41400015 	stw	r5,0(r8)
811194f4:	44000115 	stw	r16,4(r8)
811194f8:	d8c02015 	stw	r3,128(sp)
811194fc:	d8801f15 	stw	r2,124(sp)
81119500:	010001c4 	movi	r4,7
81119504:	2080060e 	bge	r4,r2,81119520 <___svfprintf_internal_r+0xa28>
81119508:	d9402c17 	ldw	r5,176(sp)
8111950c:	d9801e04 	addi	r6,sp,120
81119510:	9809883a 	mov	r4,r19
81119514:	11257180 	call	81125718 <__ssprint_r>
81119518:	103e5e1e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111951c:	d8c02017 	ldw	r3,128(sp)
81119520:	d8803117 	ldw	r2,196(sp)
81119524:	d9002a17 	ldw	r4,168(sp)
81119528:	1100010e 	bge	r2,r4,81119530 <___svfprintf_internal_r+0xa38>
8111952c:	2005883a 	mov	r2,r4
81119530:	d9402f17 	ldw	r5,188(sp)
81119534:	288b883a 	add	r5,r5,r2
81119538:	d9402f15 	stw	r5,188(sp)
8111953c:	18019c1e 	bne	r3,zero,81119bb0 <___svfprintf_internal_r+0x10b8>
81119540:	b8800007 	ldb	r2,0(r23)
81119544:	d8001f15 	stw	zero,124(sp)
81119548:	da000404 	addi	r8,sp,16
8111954c:	103d991e 	bne	r2,zero,81118bb4 <__reset+0xfb0f8bb4>
81119550:	b821883a 	mov	r16,r23
81119554:	003daf06 	br	81118c14 <__reset+0xfb0f8c14>
81119558:	18c03fcc 	andi	r3,r3,255
8111955c:	1805c71e 	bne	r3,zero,8111ac7c <___svfprintf_internal_r+0x2184>
81119560:	94800414 	ori	r18,r18,16
81119564:	9080080c 	andi	r2,r18,32
81119568:	10020126 	beq	r2,zero,81119d70 <___svfprintf_internal_r+0x1278>
8111956c:	d8802d17 	ldw	r2,180(sp)
81119570:	d9002917 	ldw	r4,164(sp)
81119574:	d8002785 	stb	zero,158(sp)
81119578:	10c00204 	addi	r3,r2,8
8111957c:	15000017 	ldw	r20,0(r2)
81119580:	15800117 	ldw	r22,4(r2)
81119584:	20038e16 	blt	r4,zero,8111a3c0 <___svfprintf_internal_r+0x18c8>
81119588:	013fdfc4 	movi	r4,-129
8111958c:	a584b03a 	or	r2,r20,r22
81119590:	d8c02d15 	stw	r3,180(sp)
81119594:	9124703a 	and	r18,r18,r4
81119598:	0039883a 	mov	fp,zero
8111959c:	103eb61e 	bne	r2,zero,81119078 <__reset+0xfb0f9078>
811195a0:	d8802917 	ldw	r2,164(sp)
811195a4:	1002c81e 	bne	r2,zero,8111a0c8 <___svfprintf_internal_r+0x15d0>
811195a8:	d8002915 	stw	zero,164(sp)
811195ac:	d8002e15 	stw	zero,184(sp)
811195b0:	dc001e04 	addi	r16,sp,120
811195b4:	003efa06 	br	811191a0 <__reset+0xfb0f91a0>
811195b8:	18c03fcc 	andi	r3,r3,255
811195bc:	1805ad1e 	bne	r3,zero,8111ac74 <___svfprintf_internal_r+0x217c>
811195c0:	01604534 	movhi	r5,33044
811195c4:	29572e04 	addi	r5,r5,23736
811195c8:	d9403a15 	stw	r5,232(sp)
811195cc:	9080080c 	andi	r2,r18,32
811195d0:	10006126 	beq	r2,zero,81119758 <___svfprintf_internal_r+0xc60>
811195d4:	d8802d17 	ldw	r2,180(sp)
811195d8:	15000017 	ldw	r20,0(r2)
811195dc:	15800117 	ldw	r22,4(r2)
811195e0:	10800204 	addi	r2,r2,8
811195e4:	d8802d15 	stw	r2,180(sp)
811195e8:	9080004c 	andi	r2,r18,1
811195ec:	10018e26 	beq	r2,zero,81119c28 <___svfprintf_internal_r+0x1130>
811195f0:	a584b03a 	or	r2,r20,r22
811195f4:	10030926 	beq	r2,zero,8111a21c <___svfprintf_internal_r+0x1724>
811195f8:	d8c02917 	ldw	r3,164(sp)
811195fc:	00800c04 	movi	r2,48
81119600:	d8802705 	stb	r2,156(sp)
81119604:	dc402745 	stb	r17,157(sp)
81119608:	d8002785 	stb	zero,158(sp)
8111960c:	90800094 	ori	r2,r18,2
81119610:	18048716 	blt	r3,zero,8111a830 <___svfprintf_internal_r+0x1d38>
81119614:	00bfdfc4 	movi	r2,-129
81119618:	90a4703a 	and	r18,r18,r2
8111961c:	94800094 	ori	r18,r18,2
81119620:	0039883a 	mov	fp,zero
81119624:	d9003a17 	ldw	r4,232(sp)
81119628:	dc001e04 	addi	r16,sp,120
8111962c:	a08003cc 	andi	r2,r20,15
81119630:	b006973a 	slli	r3,r22,28
81119634:	2085883a 	add	r2,r4,r2
81119638:	a028d13a 	srli	r20,r20,4
8111963c:	10800003 	ldbu	r2,0(r2)
81119640:	b02cd13a 	srli	r22,r22,4
81119644:	843fffc4 	addi	r16,r16,-1
81119648:	1d28b03a 	or	r20,r3,r20
8111964c:	80800005 	stb	r2,0(r16)
81119650:	a584b03a 	or	r2,r20,r22
81119654:	103ff51e 	bne	r2,zero,8111962c <__reset+0xfb0f962c>
81119658:	d8c02817 	ldw	r3,160(sp)
8111965c:	1c07c83a 	sub	r3,r3,r16
81119660:	d8c02e15 	stw	r3,184(sp)
81119664:	003ece06 	br	811191a0 <__reset+0xfb0f91a0>
81119668:	d8c02d17 	ldw	r3,180(sp)
8111966c:	d9002d17 	ldw	r4,180(sp)
81119670:	d8002785 	stb	zero,158(sp)
81119674:	18800017 	ldw	r2,0(r3)
81119678:	21000104 	addi	r4,r4,4
8111967c:	00c00044 	movi	r3,1
81119680:	d8c02a15 	stw	r3,168(sp)
81119684:	d8801405 	stb	r2,80(sp)
81119688:	d9002d15 	stw	r4,180(sp)
8111968c:	d8c02e15 	stw	r3,184(sp)
81119690:	d8002915 	stw	zero,164(sp)
81119694:	d8003215 	stw	zero,200(sp)
81119698:	dc001404 	addi	r16,sp,80
8111969c:	0039883a 	mov	fp,zero
811196a0:	003ecc06 	br	811191d4 <__reset+0xfb0f91d4>
811196a4:	18c03fcc 	andi	r3,r3,255
811196a8:	183e9226 	beq	r3,zero,811190f4 <__reset+0xfb0f90f4>
811196ac:	d9c02785 	stb	r7,158(sp)
811196b0:	003e9006 	br	811190f4 <__reset+0xfb0f90f4>
811196b4:	00c00044 	movi	r3,1
811196b8:	01c00ac4 	movi	r7,43
811196bc:	bc400007 	ldb	r17,0(r23)
811196c0:	003d6306 	br	81118c50 <__reset+0xfb0f8c50>
811196c4:	94800814 	ori	r18,r18,32
811196c8:	bc400007 	ldb	r17,0(r23)
811196cc:	003d6006 	br	81118c50 <__reset+0xfb0f8c50>
811196d0:	d8c02d17 	ldw	r3,180(sp)
811196d4:	d8002785 	stb	zero,158(sp)
811196d8:	1c000017 	ldw	r16,0(r3)
811196dc:	1d000104 	addi	r20,r3,4
811196e0:	80040f26 	beq	r16,zero,8111a720 <___svfprintf_internal_r+0x1c28>
811196e4:	d9002917 	ldw	r4,164(sp)
811196e8:	2003dc16 	blt	r4,zero,8111a65c <___svfprintf_internal_r+0x1b64>
811196ec:	200d883a 	mov	r6,r4
811196f0:	000b883a 	mov	r5,zero
811196f4:	8009883a 	mov	r4,r16
811196f8:	da003e15 	stw	r8,248(sp)
811196fc:	1121cbc0 	call	81121cbc <memchr>
81119700:	da003e17 	ldw	r8,248(sp)
81119704:	10045826 	beq	r2,zero,8111a868 <___svfprintf_internal_r+0x1d70>
81119708:	1405c83a 	sub	r2,r2,r16
8111970c:	d8802e15 	stw	r2,184(sp)
81119710:	1003d816 	blt	r2,zero,8111a674 <___svfprintf_internal_r+0x1b7c>
81119714:	df002783 	ldbu	fp,158(sp)
81119718:	d8802a15 	stw	r2,168(sp)
8111971c:	dd002d15 	stw	r20,180(sp)
81119720:	d8002915 	stw	zero,164(sp)
81119724:	d8003215 	stw	zero,200(sp)
81119728:	003ea306 	br	811191b8 <__reset+0xfb0f91b8>
8111972c:	18c03fcc 	andi	r3,r3,255
81119730:	183f8c26 	beq	r3,zero,81119564 <__reset+0xfb0f9564>
81119734:	d9c02785 	stb	r7,158(sp)
81119738:	003f8a06 	br	81119564 <__reset+0xfb0f9564>
8111973c:	18c03fcc 	andi	r3,r3,255
81119740:	1805631e 	bne	r3,zero,8111acd0 <___svfprintf_internal_r+0x21d8>
81119744:	01604534 	movhi	r5,33044
81119748:	29573304 	addi	r5,r5,23756
8111974c:	d9403a15 	stw	r5,232(sp)
81119750:	9080080c 	andi	r2,r18,32
81119754:	103f9f1e 	bne	r2,zero,811195d4 <__reset+0xfb0f95d4>
81119758:	9080040c 	andi	r2,r18,16
8111975c:	10029c26 	beq	r2,zero,8111a1d0 <___svfprintf_internal_r+0x16d8>
81119760:	d8c02d17 	ldw	r3,180(sp)
81119764:	002d883a 	mov	r22,zero
81119768:	1d000017 	ldw	r20,0(r3)
8111976c:	18c00104 	addi	r3,r3,4
81119770:	d8c02d15 	stw	r3,180(sp)
81119774:	003f9c06 	br	811195e8 <__reset+0xfb0f95e8>
81119778:	94800054 	ori	r18,r18,1
8111977c:	bc400007 	ldb	r17,0(r23)
81119780:	003d3306 	br	81118c50 <__reset+0xfb0f8c50>
81119784:	38803fcc 	andi	r2,r7,255
81119788:	1080201c 	xori	r2,r2,128
8111978c:	10bfe004 	addi	r2,r2,-128
81119790:	1002971e 	bne	r2,zero,8111a1f0 <___svfprintf_internal_r+0x16f8>
81119794:	00c00044 	movi	r3,1
81119798:	01c00804 	movi	r7,32
8111979c:	bc400007 	ldb	r17,0(r23)
811197a0:	003d2b06 	br	81118c50 <__reset+0xfb0f8c50>
811197a4:	18c03fcc 	andi	r3,r3,255
811197a8:	183e2326 	beq	r3,zero,81119038 <__reset+0xfb0f9038>
811197ac:	d9c02785 	stb	r7,158(sp)
811197b0:	003e2106 	br	81119038 <__reset+0xfb0f9038>
811197b4:	bc400007 	ldb	r17,0(r23)
811197b8:	8a430426 	beq	r17,r9,8111a3cc <___svfprintf_internal_r+0x18d4>
811197bc:	94800414 	ori	r18,r18,16
811197c0:	003d2306 	br	81118c50 <__reset+0xfb0f8c50>
811197c4:	18c03fcc 	andi	r3,r3,255
811197c8:	18053f1e 	bne	r3,zero,8111acc8 <___svfprintf_internal_r+0x21d0>
811197cc:	9080080c 	andi	r2,r18,32
811197d0:	10028926 	beq	r2,zero,8111a1f8 <___svfprintf_internal_r+0x1700>
811197d4:	d9402d17 	ldw	r5,180(sp)
811197d8:	d9002f17 	ldw	r4,188(sp)
811197dc:	28800017 	ldw	r2,0(r5)
811197e0:	2007d7fa 	srai	r3,r4,31
811197e4:	29400104 	addi	r5,r5,4
811197e8:	d9402d15 	stw	r5,180(sp)
811197ec:	11000015 	stw	r4,0(r2)
811197f0:	10c00115 	stw	r3,4(r2)
811197f4:	003ced06 	br	81118bac <__reset+0xfb0f8bac>
811197f8:	94801014 	ori	r18,r18,64
811197fc:	bc400007 	ldb	r17,0(r23)
81119800:	003d1306 	br	81118c50 <__reset+0xfb0f8c50>
81119804:	01204534 	movhi	r4,33044
81119808:	21173304 	addi	r4,r4,23756
8111980c:	0039883a 	mov	fp,zero
81119810:	d9003a15 	stw	r4,232(sp)
81119814:	04401e04 	movi	r17,120
81119818:	003f8206 	br	81119624 <__reset+0xfb0f9624>
8111981c:	18c03fcc 	andi	r3,r3,255
81119820:	1805221e 	bne	r3,zero,8111acac <___svfprintf_internal_r+0x21b4>
81119824:	883d9526 	beq	r17,zero,81118e7c <__reset+0xfb0f8e7c>
81119828:	00c00044 	movi	r3,1
8111982c:	d8c02a15 	stw	r3,168(sp)
81119830:	dc401405 	stb	r17,80(sp)
81119834:	d8002785 	stb	zero,158(sp)
81119838:	003f9406 	br	8111968c <__reset+0xfb0f968c>
8111983c:	01204534 	movhi	r4,33044
81119840:	21173304 	addi	r4,r4,23756
81119844:	d9003a15 	stw	r4,232(sp)
81119848:	d8c02d15 	stw	r3,180(sp)
8111984c:	1025883a 	mov	r18,r2
81119850:	04401e04 	movi	r17,120
81119854:	a584b03a 	or	r2,r20,r22
81119858:	1000fa1e 	bne	r2,zero,81119c44 <___svfprintf_internal_r+0x114c>
8111985c:	0039883a 	mov	fp,zero
81119860:	00800084 	movi	r2,2
81119864:	10803fcc 	andi	r2,r2,255
81119868:	00c00044 	movi	r3,1
8111986c:	10c21626 	beq	r2,r3,8111a0c8 <___svfprintf_internal_r+0x15d0>
81119870:	00c00084 	movi	r3,2
81119874:	10fe301e 	bne	r2,r3,81119138 <__reset+0xfb0f9138>
81119878:	003d7606 	br	81118e54 <__reset+0xfb0f8e54>
8111987c:	d8c02017 	ldw	r3,128(sp)
81119880:	003e9506 	br	811192d8 <__reset+0xfb0f92d8>
81119884:	00801944 	movi	r2,101
81119888:	14407c0e 	bge	r2,r17,81119a7c <___svfprintf_internal_r+0xf84>
8111988c:	d9003617 	ldw	r4,216(sp)
81119890:	d9403717 	ldw	r5,220(sp)
81119894:	000d883a 	mov	r6,zero
81119898:	000f883a 	mov	r7,zero
8111989c:	d8c03d15 	stw	r3,244(sp)
811198a0:	da003e15 	stw	r8,248(sp)
811198a4:	112b7100 	call	8112b710 <__eqdf2>
811198a8:	d8c03d17 	ldw	r3,244(sp)
811198ac:	da003e17 	ldw	r8,248(sp)
811198b0:	1000f51e 	bne	r2,zero,81119c88 <___svfprintf_internal_r+0x1190>
811198b4:	d8801f17 	ldw	r2,124(sp)
811198b8:	01204534 	movhi	r4,33044
811198bc:	21173a04 	addi	r4,r4,23784
811198c0:	18c00044 	addi	r3,r3,1
811198c4:	10800044 	addi	r2,r2,1
811198c8:	41000015 	stw	r4,0(r8)
811198cc:	01000044 	movi	r4,1
811198d0:	41000115 	stw	r4,4(r8)
811198d4:	d8c02015 	stw	r3,128(sp)
811198d8:	d8801f15 	stw	r2,124(sp)
811198dc:	010001c4 	movi	r4,7
811198e0:	20826616 	blt	r4,r2,8111a27c <___svfprintf_internal_r+0x1784>
811198e4:	42000204 	addi	r8,r8,8
811198e8:	d8802617 	ldw	r2,152(sp)
811198ec:	d9403317 	ldw	r5,204(sp)
811198f0:	11400216 	blt	r2,r5,811198fc <___svfprintf_internal_r+0xe04>
811198f4:	9080004c 	andi	r2,r18,1
811198f8:	103ed526 	beq	r2,zero,81119450 <__reset+0xfb0f9450>
811198fc:	d8803817 	ldw	r2,224(sp)
81119900:	d9003417 	ldw	r4,208(sp)
81119904:	d9403817 	ldw	r5,224(sp)
81119908:	1887883a 	add	r3,r3,r2
8111990c:	d8801f17 	ldw	r2,124(sp)
81119910:	41000015 	stw	r4,0(r8)
81119914:	41400115 	stw	r5,4(r8)
81119918:	10800044 	addi	r2,r2,1
8111991c:	d8c02015 	stw	r3,128(sp)
81119920:	d8801f15 	stw	r2,124(sp)
81119924:	010001c4 	movi	r4,7
81119928:	2082af16 	blt	r4,r2,8111a3e8 <___svfprintf_internal_r+0x18f0>
8111992c:	42000204 	addi	r8,r8,8
81119930:	d8803317 	ldw	r2,204(sp)
81119934:	143fffc4 	addi	r16,r2,-1
81119938:	043ec50e 	bge	zero,r16,81119450 <__reset+0xfb0f9450>
8111993c:	04400404 	movi	r17,16
81119940:	d8801f17 	ldw	r2,124(sp)
81119944:	8c00860e 	bge	r17,r16,81119b60 <___svfprintf_internal_r+0x1068>
81119948:	01604534 	movhi	r5,33044
8111994c:	29573a84 	addi	r5,r5,23786
81119950:	d9402b15 	stw	r5,172(sp)
81119954:	058001c4 	movi	r22,7
81119958:	dd002c17 	ldw	r20,176(sp)
8111995c:	00000306 	br	8111996c <___svfprintf_internal_r+0xe74>
81119960:	42000204 	addi	r8,r8,8
81119964:	843ffc04 	addi	r16,r16,-16
81119968:	8c00800e 	bge	r17,r16,81119b6c <___svfprintf_internal_r+0x1074>
8111996c:	18c00404 	addi	r3,r3,16
81119970:	10800044 	addi	r2,r2,1
81119974:	45400015 	stw	r21,0(r8)
81119978:	44400115 	stw	r17,4(r8)
8111997c:	d8c02015 	stw	r3,128(sp)
81119980:	d8801f15 	stw	r2,124(sp)
81119984:	b0bff60e 	bge	r22,r2,81119960 <__reset+0xfb0f9960>
81119988:	d9801e04 	addi	r6,sp,120
8111998c:	a00b883a 	mov	r5,r20
81119990:	9809883a 	mov	r4,r19
81119994:	11257180 	call	81125718 <__ssprint_r>
81119998:	103d3e1e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111999c:	d8c02017 	ldw	r3,128(sp)
811199a0:	d8801f17 	ldw	r2,124(sp)
811199a4:	da000404 	addi	r8,sp,16
811199a8:	003fee06 	br	81119964 <__reset+0xfb0f9964>
811199ac:	d9403117 	ldw	r5,196(sp)
811199b0:	d8802a17 	ldw	r2,168(sp)
811199b4:	28adc83a 	sub	r22,r5,r2
811199b8:	05be650e 	bge	zero,r22,81119350 <__reset+0xfb0f9350>
811199bc:	07000404 	movi	fp,16
811199c0:	d8801f17 	ldw	r2,124(sp)
811199c4:	e583a20e 	bge	fp,r22,8111a850 <___svfprintf_internal_r+0x1d58>
811199c8:	01604534 	movhi	r5,33044
811199cc:	29573a84 	addi	r5,r5,23786
811199d0:	dc403015 	stw	r17,192(sp)
811199d4:	d9402b15 	stw	r5,172(sp)
811199d8:	b023883a 	mov	r17,r22
811199dc:	050001c4 	movi	r20,7
811199e0:	902d883a 	mov	r22,r18
811199e4:	8025883a 	mov	r18,r16
811199e8:	dc002c17 	ldw	r16,176(sp)
811199ec:	00000306 	br	811199fc <___svfprintf_internal_r+0xf04>
811199f0:	8c7ffc04 	addi	r17,r17,-16
811199f4:	42000204 	addi	r8,r8,8
811199f8:	e440110e 	bge	fp,r17,81119a40 <___svfprintf_internal_r+0xf48>
811199fc:	18c00404 	addi	r3,r3,16
81119a00:	10800044 	addi	r2,r2,1
81119a04:	45400015 	stw	r21,0(r8)
81119a08:	47000115 	stw	fp,4(r8)
81119a0c:	d8c02015 	stw	r3,128(sp)
81119a10:	d8801f15 	stw	r2,124(sp)
81119a14:	a0bff60e 	bge	r20,r2,811199f0 <__reset+0xfb0f99f0>
81119a18:	d9801e04 	addi	r6,sp,120
81119a1c:	800b883a 	mov	r5,r16
81119a20:	9809883a 	mov	r4,r19
81119a24:	11257180 	call	81125718 <__ssprint_r>
81119a28:	103d1a1e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119a2c:	8c7ffc04 	addi	r17,r17,-16
81119a30:	d8c02017 	ldw	r3,128(sp)
81119a34:	d8801f17 	ldw	r2,124(sp)
81119a38:	da000404 	addi	r8,sp,16
81119a3c:	e47fef16 	blt	fp,r17,811199fc <__reset+0xfb0f99fc>
81119a40:	9021883a 	mov	r16,r18
81119a44:	b025883a 	mov	r18,r22
81119a48:	882d883a 	mov	r22,r17
81119a4c:	dc403017 	ldw	r17,192(sp)
81119a50:	d9002b17 	ldw	r4,172(sp)
81119a54:	1d87883a 	add	r3,r3,r22
81119a58:	10800044 	addi	r2,r2,1
81119a5c:	41000015 	stw	r4,0(r8)
81119a60:	45800115 	stw	r22,4(r8)
81119a64:	d8c02015 	stw	r3,128(sp)
81119a68:	d8801f15 	stw	r2,124(sp)
81119a6c:	010001c4 	movi	r4,7
81119a70:	20819a16 	blt	r4,r2,8111a0dc <___svfprintf_internal_r+0x15e4>
81119a74:	42000204 	addi	r8,r8,8
81119a78:	003e3506 	br	81119350 <__reset+0xfb0f9350>
81119a7c:	d9403317 	ldw	r5,204(sp)
81119a80:	00800044 	movi	r2,1
81119a84:	18c00044 	addi	r3,r3,1
81119a88:	1141710e 	bge	r2,r5,8111a050 <___svfprintf_internal_r+0x1558>
81119a8c:	dc401f17 	ldw	r17,124(sp)
81119a90:	00800044 	movi	r2,1
81119a94:	40800115 	stw	r2,4(r8)
81119a98:	8c400044 	addi	r17,r17,1
81119a9c:	44000015 	stw	r16,0(r8)
81119aa0:	d8c02015 	stw	r3,128(sp)
81119aa4:	dc401f15 	stw	r17,124(sp)
81119aa8:	008001c4 	movi	r2,7
81119aac:	14417416 	blt	r2,r17,8111a080 <___svfprintf_internal_r+0x1588>
81119ab0:	42000204 	addi	r8,r8,8
81119ab4:	d8803817 	ldw	r2,224(sp)
81119ab8:	d9003417 	ldw	r4,208(sp)
81119abc:	8c400044 	addi	r17,r17,1
81119ac0:	10c7883a 	add	r3,r2,r3
81119ac4:	40800115 	stw	r2,4(r8)
81119ac8:	41000015 	stw	r4,0(r8)
81119acc:	d8c02015 	stw	r3,128(sp)
81119ad0:	dc401f15 	stw	r17,124(sp)
81119ad4:	008001c4 	movi	r2,7
81119ad8:	14417216 	blt	r2,r17,8111a0a4 <___svfprintf_internal_r+0x15ac>
81119adc:	45800204 	addi	r22,r8,8
81119ae0:	d9003617 	ldw	r4,216(sp)
81119ae4:	d9403717 	ldw	r5,220(sp)
81119ae8:	000d883a 	mov	r6,zero
81119aec:	000f883a 	mov	r7,zero
81119af0:	d8c03d15 	stw	r3,244(sp)
81119af4:	112b7100 	call	8112b710 <__eqdf2>
81119af8:	d8c03d17 	ldw	r3,244(sp)
81119afc:	1000b326 	beq	r2,zero,81119dcc <___svfprintf_internal_r+0x12d4>
81119b00:	d9403317 	ldw	r5,204(sp)
81119b04:	84000044 	addi	r16,r16,1
81119b08:	8c400044 	addi	r17,r17,1
81119b0c:	28bfffc4 	addi	r2,r5,-1
81119b10:	1887883a 	add	r3,r3,r2
81119b14:	b0800115 	stw	r2,4(r22)
81119b18:	b4000015 	stw	r16,0(r22)
81119b1c:	d8c02015 	stw	r3,128(sp)
81119b20:	dc401f15 	stw	r17,124(sp)
81119b24:	008001c4 	movi	r2,7
81119b28:	1440d216 	blt	r2,r17,81119e74 <___svfprintf_internal_r+0x137c>
81119b2c:	b5800204 	addi	r22,r22,8
81119b30:	d9003b17 	ldw	r4,236(sp)
81119b34:	df0022c4 	addi	fp,sp,139
81119b38:	8c400044 	addi	r17,r17,1
81119b3c:	20c7883a 	add	r3,r4,r3
81119b40:	b7000015 	stw	fp,0(r22)
81119b44:	b1000115 	stw	r4,4(r22)
81119b48:	d8c02015 	stw	r3,128(sp)
81119b4c:	dc401f15 	stw	r17,124(sp)
81119b50:	008001c4 	movi	r2,7
81119b54:	14400e16 	blt	r2,r17,81119b90 <___svfprintf_internal_r+0x1098>
81119b58:	b2000204 	addi	r8,r22,8
81119b5c:	003e3c06 	br	81119450 <__reset+0xfb0f9450>
81119b60:	01204534 	movhi	r4,33044
81119b64:	21173a84 	addi	r4,r4,23786
81119b68:	d9002b15 	stw	r4,172(sp)
81119b6c:	d9002b17 	ldw	r4,172(sp)
81119b70:	1c07883a 	add	r3,r3,r16
81119b74:	44000115 	stw	r16,4(r8)
81119b78:	41000015 	stw	r4,0(r8)
81119b7c:	10800044 	addi	r2,r2,1
81119b80:	d8c02015 	stw	r3,128(sp)
81119b84:	d8801f15 	stw	r2,124(sp)
81119b88:	010001c4 	movi	r4,7
81119b8c:	20be2f0e 	bge	r4,r2,8111944c <__reset+0xfb0f944c>
81119b90:	d9402c17 	ldw	r5,176(sp)
81119b94:	d9801e04 	addi	r6,sp,120
81119b98:	9809883a 	mov	r4,r19
81119b9c:	11257180 	call	81125718 <__ssprint_r>
81119ba0:	103cbc1e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119ba4:	d8c02017 	ldw	r3,128(sp)
81119ba8:	da000404 	addi	r8,sp,16
81119bac:	003e2806 	br	81119450 <__reset+0xfb0f9450>
81119bb0:	d9402c17 	ldw	r5,176(sp)
81119bb4:	d9801e04 	addi	r6,sp,120
81119bb8:	9809883a 	mov	r4,r19
81119bbc:	11257180 	call	81125718 <__ssprint_r>
81119bc0:	103e5f26 	beq	r2,zero,81119540 <__reset+0xfb0f9540>
81119bc4:	003cb306 	br	81118e94 <__reset+0xfb0f8e94>
81119bc8:	d9402c17 	ldw	r5,176(sp)
81119bcc:	d9801e04 	addi	r6,sp,120
81119bd0:	9809883a 	mov	r4,r19
81119bd4:	11257180 	call	81125718 <__ssprint_r>
81119bd8:	103cae1e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119bdc:	d8c02017 	ldw	r3,128(sp)
81119be0:	da000404 	addi	r8,sp,16
81119be4:	003e0d06 	br	8111941c <__reset+0xfb0f941c>
81119be8:	d9402c17 	ldw	r5,176(sp)
81119bec:	d9801e04 	addi	r6,sp,120
81119bf0:	9809883a 	mov	r4,r19
81119bf4:	11257180 	call	81125718 <__ssprint_r>
81119bf8:	103ca61e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119bfc:	d8c02017 	ldw	r3,128(sp)
81119c00:	da000404 	addi	r8,sp,16
81119c04:	003dc106 	br	8111930c <__reset+0xfb0f930c>
81119c08:	d9402c17 	ldw	r5,176(sp)
81119c0c:	d9801e04 	addi	r6,sp,120
81119c10:	9809883a 	mov	r4,r19
81119c14:	11257180 	call	81125718 <__ssprint_r>
81119c18:	103c9e1e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119c1c:	d8c02017 	ldw	r3,128(sp)
81119c20:	da000404 	addi	r8,sp,16
81119c24:	003dc706 	br	81119344 <__reset+0xfb0f9344>
81119c28:	d8802917 	ldw	r2,164(sp)
81119c2c:	d8002785 	stb	zero,158(sp)
81119c30:	103f0816 	blt	r2,zero,81119854 <__reset+0xfb0f9854>
81119c34:	00ffdfc4 	movi	r3,-129
81119c38:	a584b03a 	or	r2,r20,r22
81119c3c:	90e4703a 	and	r18,r18,r3
81119c40:	103c8126 	beq	r2,zero,81118e48 <__reset+0xfb0f8e48>
81119c44:	0039883a 	mov	fp,zero
81119c48:	003e7606 	br	81119624 <__reset+0xfb0f9624>
81119c4c:	9080040c 	andi	r2,r18,16
81119c50:	10013d26 	beq	r2,zero,8111a148 <___svfprintf_internal_r+0x1650>
81119c54:	d9002d17 	ldw	r4,180(sp)
81119c58:	d9402917 	ldw	r5,164(sp)
81119c5c:	d8002785 	stb	zero,158(sp)
81119c60:	20800104 	addi	r2,r4,4
81119c64:	25000017 	ldw	r20,0(r4)
81119c68:	002d883a 	mov	r22,zero
81119c6c:	28013f16 	blt	r5,zero,8111a16c <___svfprintf_internal_r+0x1674>
81119c70:	00ffdfc4 	movi	r3,-129
81119c74:	d8802d15 	stw	r2,180(sp)
81119c78:	90e4703a 	and	r18,r18,r3
81119c7c:	a03d2b26 	beq	r20,zero,8111912c <__reset+0xfb0f912c>
81119c80:	0039883a 	mov	fp,zero
81119c84:	003d2e06 	br	81119140 <__reset+0xfb0f9140>
81119c88:	dc402617 	ldw	r17,152(sp)
81119c8c:	0441830e 	bge	zero,r17,8111a29c <___svfprintf_internal_r+0x17a4>
81119c90:	dc403217 	ldw	r17,200(sp)
81119c94:	d8803317 	ldw	r2,204(sp)
81119c98:	1440010e 	bge	r2,r17,81119ca0 <___svfprintf_internal_r+0x11a8>
81119c9c:	1023883a 	mov	r17,r2
81119ca0:	04400a0e 	bge	zero,r17,81119ccc <___svfprintf_internal_r+0x11d4>
81119ca4:	d8801f17 	ldw	r2,124(sp)
81119ca8:	1c47883a 	add	r3,r3,r17
81119cac:	44000015 	stw	r16,0(r8)
81119cb0:	10800044 	addi	r2,r2,1
81119cb4:	44400115 	stw	r17,4(r8)
81119cb8:	d8c02015 	stw	r3,128(sp)
81119cbc:	d8801f15 	stw	r2,124(sp)
81119cc0:	010001c4 	movi	r4,7
81119cc4:	20827516 	blt	r4,r2,8111a69c <___svfprintf_internal_r+0x1ba4>
81119cc8:	42000204 	addi	r8,r8,8
81119ccc:	88027b16 	blt	r17,zero,8111a6bc <___svfprintf_internal_r+0x1bc4>
81119cd0:	d9003217 	ldw	r4,200(sp)
81119cd4:	2463c83a 	sub	r17,r4,r17
81119cd8:	0440990e 	bge	zero,r17,81119f40 <___svfprintf_internal_r+0x1448>
81119cdc:	05800404 	movi	r22,16
81119ce0:	d8801f17 	ldw	r2,124(sp)
81119ce4:	b441530e 	bge	r22,r17,8111a234 <___svfprintf_internal_r+0x173c>
81119ce8:	01204534 	movhi	r4,33044
81119cec:	21173a84 	addi	r4,r4,23786
81119cf0:	d9002b15 	stw	r4,172(sp)
81119cf4:	070001c4 	movi	fp,7
81119cf8:	dd002c17 	ldw	r20,176(sp)
81119cfc:	00000306 	br	81119d0c <___svfprintf_internal_r+0x1214>
81119d00:	42000204 	addi	r8,r8,8
81119d04:	8c7ffc04 	addi	r17,r17,-16
81119d08:	b4414d0e 	bge	r22,r17,8111a240 <___svfprintf_internal_r+0x1748>
81119d0c:	18c00404 	addi	r3,r3,16
81119d10:	10800044 	addi	r2,r2,1
81119d14:	45400015 	stw	r21,0(r8)
81119d18:	45800115 	stw	r22,4(r8)
81119d1c:	d8c02015 	stw	r3,128(sp)
81119d20:	d8801f15 	stw	r2,124(sp)
81119d24:	e0bff60e 	bge	fp,r2,81119d00 <__reset+0xfb0f9d00>
81119d28:	d9801e04 	addi	r6,sp,120
81119d2c:	a00b883a 	mov	r5,r20
81119d30:	9809883a 	mov	r4,r19
81119d34:	11257180 	call	81125718 <__ssprint_r>
81119d38:	103c561e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119d3c:	d8c02017 	ldw	r3,128(sp)
81119d40:	d8801f17 	ldw	r2,124(sp)
81119d44:	da000404 	addi	r8,sp,16
81119d48:	003fee06 	br	81119d04 <__reset+0xfb0f9d04>
81119d4c:	d9402c17 	ldw	r5,176(sp)
81119d50:	d9801e04 	addi	r6,sp,120
81119d54:	9809883a 	mov	r4,r19
81119d58:	11257180 	call	81125718 <__ssprint_r>
81119d5c:	103c4d1e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119d60:	d8c02017 	ldw	r3,128(sp)
81119d64:	df002787 	ldb	fp,158(sp)
81119d68:	da000404 	addi	r8,sp,16
81119d6c:	003d5a06 	br	811192d8 <__reset+0xfb0f92d8>
81119d70:	9080040c 	andi	r2,r18,16
81119d74:	10005c26 	beq	r2,zero,81119ee8 <___svfprintf_internal_r+0x13f0>
81119d78:	d9402d17 	ldw	r5,180(sp)
81119d7c:	d8c02917 	ldw	r3,164(sp)
81119d80:	d8002785 	stb	zero,158(sp)
81119d84:	28800104 	addi	r2,r5,4
81119d88:	2d000017 	ldw	r20,0(r5)
81119d8c:	002d883a 	mov	r22,zero
81119d90:	18005e16 	blt	r3,zero,81119f0c <___svfprintf_internal_r+0x1414>
81119d94:	00ffdfc4 	movi	r3,-129
81119d98:	d8802d15 	stw	r2,180(sp)
81119d9c:	90e4703a 	and	r18,r18,r3
81119da0:	0039883a 	mov	fp,zero
81119da4:	a03dfe26 	beq	r20,zero,811195a0 <__reset+0xfb0f95a0>
81119da8:	00800244 	movi	r2,9
81119dac:	153cb336 	bltu	r2,r20,8111907c <__reset+0xfb0f907c>
81119db0:	a5000c04 	addi	r20,r20,48
81119db4:	dc001dc4 	addi	r16,sp,119
81119db8:	dd001dc5 	stb	r20,119(sp)
81119dbc:	d8c02817 	ldw	r3,160(sp)
81119dc0:	1c07c83a 	sub	r3,r3,r16
81119dc4:	d8c02e15 	stw	r3,184(sp)
81119dc8:	003cf506 	br	811191a0 <__reset+0xfb0f91a0>
81119dcc:	d8803317 	ldw	r2,204(sp)
81119dd0:	143fffc4 	addi	r16,r2,-1
81119dd4:	043f560e 	bge	zero,r16,81119b30 <__reset+0xfb0f9b30>
81119dd8:	07000404 	movi	fp,16
81119ddc:	e403530e 	bge	fp,r16,8111ab2c <___svfprintf_internal_r+0x2034>
81119de0:	01604534 	movhi	r5,33044
81119de4:	29573a84 	addi	r5,r5,23786
81119de8:	d9402b15 	stw	r5,172(sp)
81119dec:	01c001c4 	movi	r7,7
81119df0:	dd002c17 	ldw	r20,176(sp)
81119df4:	00000306 	br	81119e04 <___svfprintf_internal_r+0x130c>
81119df8:	843ffc04 	addi	r16,r16,-16
81119dfc:	b5800204 	addi	r22,r22,8
81119e00:	e400130e 	bge	fp,r16,81119e50 <___svfprintf_internal_r+0x1358>
81119e04:	18c00404 	addi	r3,r3,16
81119e08:	8c400044 	addi	r17,r17,1
81119e0c:	b5400015 	stw	r21,0(r22)
81119e10:	b7000115 	stw	fp,4(r22)
81119e14:	d8c02015 	stw	r3,128(sp)
81119e18:	dc401f15 	stw	r17,124(sp)
81119e1c:	3c7ff60e 	bge	r7,r17,81119df8 <__reset+0xfb0f9df8>
81119e20:	d9801e04 	addi	r6,sp,120
81119e24:	a00b883a 	mov	r5,r20
81119e28:	9809883a 	mov	r4,r19
81119e2c:	d9c03d15 	stw	r7,244(sp)
81119e30:	11257180 	call	81125718 <__ssprint_r>
81119e34:	d9c03d17 	ldw	r7,244(sp)
81119e38:	103c161e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119e3c:	843ffc04 	addi	r16,r16,-16
81119e40:	d8c02017 	ldw	r3,128(sp)
81119e44:	dc401f17 	ldw	r17,124(sp)
81119e48:	dd800404 	addi	r22,sp,16
81119e4c:	e43fed16 	blt	fp,r16,81119e04 <__reset+0xfb0f9e04>
81119e50:	d8802b17 	ldw	r2,172(sp)
81119e54:	1c07883a 	add	r3,r3,r16
81119e58:	8c400044 	addi	r17,r17,1
81119e5c:	b0800015 	stw	r2,0(r22)
81119e60:	b4000115 	stw	r16,4(r22)
81119e64:	d8c02015 	stw	r3,128(sp)
81119e68:	dc401f15 	stw	r17,124(sp)
81119e6c:	008001c4 	movi	r2,7
81119e70:	147f2e0e 	bge	r2,r17,81119b2c <__reset+0xfb0f9b2c>
81119e74:	d9402c17 	ldw	r5,176(sp)
81119e78:	d9801e04 	addi	r6,sp,120
81119e7c:	9809883a 	mov	r4,r19
81119e80:	11257180 	call	81125718 <__ssprint_r>
81119e84:	103c031e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119e88:	d8c02017 	ldw	r3,128(sp)
81119e8c:	dc401f17 	ldw	r17,124(sp)
81119e90:	dd800404 	addi	r22,sp,16
81119e94:	003f2606 	br	81119b30 <__reset+0xfb0f9b30>
81119e98:	9080040c 	andi	r2,r18,16
81119e9c:	1000c326 	beq	r2,zero,8111a1ac <___svfprintf_internal_r+0x16b4>
81119ea0:	d8802d17 	ldw	r2,180(sp)
81119ea4:	15000017 	ldw	r20,0(r2)
81119ea8:	10800104 	addi	r2,r2,4
81119eac:	d8802d15 	stw	r2,180(sp)
81119eb0:	a02dd7fa 	srai	r22,r20,31
81119eb4:	b005883a 	mov	r2,r22
81119eb8:	103c680e 	bge	r2,zero,8111905c <__reset+0xfb0f905c>
81119ebc:	0529c83a 	sub	r20,zero,r20
81119ec0:	a004c03a 	cmpne	r2,r20,zero
81119ec4:	05adc83a 	sub	r22,zero,r22
81119ec8:	b0adc83a 	sub	r22,r22,r2
81119ecc:	d8802917 	ldw	r2,164(sp)
81119ed0:	07000b44 	movi	fp,45
81119ed4:	df002785 	stb	fp,158(sp)
81119ed8:	10022e16 	blt	r2,zero,8111a794 <___svfprintf_internal_r+0x1c9c>
81119edc:	00bfdfc4 	movi	r2,-129
81119ee0:	90a4703a 	and	r18,r18,r2
81119ee4:	003c6406 	br	81119078 <__reset+0xfb0f9078>
81119ee8:	9080100c 	andi	r2,r18,64
81119eec:	d8002785 	stb	zero,158(sp)
81119ef0:	10012526 	beq	r2,zero,8111a388 <___svfprintf_internal_r+0x1890>
81119ef4:	d9002d17 	ldw	r4,180(sp)
81119ef8:	d9402917 	ldw	r5,164(sp)
81119efc:	002d883a 	mov	r22,zero
81119f00:	20800104 	addi	r2,r4,4
81119f04:	2500000b 	ldhu	r20,0(r4)
81119f08:	283fa20e 	bge	r5,zero,81119d94 <__reset+0xfb0f9d94>
81119f0c:	d8802d15 	stw	r2,180(sp)
81119f10:	0039883a 	mov	fp,zero
81119f14:	a584b03a 	or	r2,r20,r22
81119f18:	103c571e 	bne	r2,zero,81119078 <__reset+0xfb0f9078>
81119f1c:	00800044 	movi	r2,1
81119f20:	003e5006 	br	81119864 <__reset+0xfb0f9864>
81119f24:	d9402c17 	ldw	r5,176(sp)
81119f28:	d9801e04 	addi	r6,sp,120
81119f2c:	9809883a 	mov	r4,r19
81119f30:	11257180 	call	81125718 <__ssprint_r>
81119f34:	103bd71e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
81119f38:	d8c02017 	ldw	r3,128(sp)
81119f3c:	da000404 	addi	r8,sp,16
81119f40:	d9003217 	ldw	r4,200(sp)
81119f44:	d8802617 	ldw	r2,152(sp)
81119f48:	d9403317 	ldw	r5,204(sp)
81119f4c:	8123883a 	add	r17,r16,r4
81119f50:	11400216 	blt	r2,r5,81119f5c <___svfprintf_internal_r+0x1464>
81119f54:	9100004c 	andi	r4,r18,1
81119f58:	20000d26 	beq	r4,zero,81119f90 <___svfprintf_internal_r+0x1498>
81119f5c:	d9003817 	ldw	r4,224(sp)
81119f60:	d9403417 	ldw	r5,208(sp)
81119f64:	1907883a 	add	r3,r3,r4
81119f68:	d9001f17 	ldw	r4,124(sp)
81119f6c:	41400015 	stw	r5,0(r8)
81119f70:	d9403817 	ldw	r5,224(sp)
81119f74:	21000044 	addi	r4,r4,1
81119f78:	d8c02015 	stw	r3,128(sp)
81119f7c:	41400115 	stw	r5,4(r8)
81119f80:	d9001f15 	stw	r4,124(sp)
81119f84:	014001c4 	movi	r5,7
81119f88:	2901dc16 	blt	r5,r4,8111a6fc <___svfprintf_internal_r+0x1c04>
81119f8c:	42000204 	addi	r8,r8,8
81119f90:	d9003317 	ldw	r4,204(sp)
81119f94:	8121883a 	add	r16,r16,r4
81119f98:	2085c83a 	sub	r2,r4,r2
81119f9c:	8461c83a 	sub	r16,r16,r17
81119fa0:	1400010e 	bge	r2,r16,81119fa8 <___svfprintf_internal_r+0x14b0>
81119fa4:	1021883a 	mov	r16,r2
81119fa8:	04000a0e 	bge	zero,r16,81119fd4 <___svfprintf_internal_r+0x14dc>
81119fac:	d9001f17 	ldw	r4,124(sp)
81119fb0:	1c07883a 	add	r3,r3,r16
81119fb4:	44400015 	stw	r17,0(r8)
81119fb8:	21000044 	addi	r4,r4,1
81119fbc:	44000115 	stw	r16,4(r8)
81119fc0:	d8c02015 	stw	r3,128(sp)
81119fc4:	d9001f15 	stw	r4,124(sp)
81119fc8:	014001c4 	movi	r5,7
81119fcc:	2901e616 	blt	r5,r4,8111a768 <___svfprintf_internal_r+0x1c70>
81119fd0:	42000204 	addi	r8,r8,8
81119fd4:	8001f616 	blt	r16,zero,8111a7b0 <___svfprintf_internal_r+0x1cb8>
81119fd8:	1421c83a 	sub	r16,r2,r16
81119fdc:	043d1c0e 	bge	zero,r16,81119450 <__reset+0xfb0f9450>
81119fe0:	04400404 	movi	r17,16
81119fe4:	d8801f17 	ldw	r2,124(sp)
81119fe8:	8c3edd0e 	bge	r17,r16,81119b60 <__reset+0xfb0f9b60>
81119fec:	01604534 	movhi	r5,33044
81119ff0:	29573a84 	addi	r5,r5,23786
81119ff4:	d9402b15 	stw	r5,172(sp)
81119ff8:	058001c4 	movi	r22,7
81119ffc:	dd002c17 	ldw	r20,176(sp)
8111a000:	00000306 	br	8111a010 <___svfprintf_internal_r+0x1518>
8111a004:	42000204 	addi	r8,r8,8
8111a008:	843ffc04 	addi	r16,r16,-16
8111a00c:	8c3ed70e 	bge	r17,r16,81119b6c <__reset+0xfb0f9b6c>
8111a010:	18c00404 	addi	r3,r3,16
8111a014:	10800044 	addi	r2,r2,1
8111a018:	45400015 	stw	r21,0(r8)
8111a01c:	44400115 	stw	r17,4(r8)
8111a020:	d8c02015 	stw	r3,128(sp)
8111a024:	d8801f15 	stw	r2,124(sp)
8111a028:	b0bff60e 	bge	r22,r2,8111a004 <__reset+0xfb0fa004>
8111a02c:	d9801e04 	addi	r6,sp,120
8111a030:	a00b883a 	mov	r5,r20
8111a034:	9809883a 	mov	r4,r19
8111a038:	11257180 	call	81125718 <__ssprint_r>
8111a03c:	103b951e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a040:	d8c02017 	ldw	r3,128(sp)
8111a044:	d8801f17 	ldw	r2,124(sp)
8111a048:	da000404 	addi	r8,sp,16
8111a04c:	003fee06 	br	8111a008 <__reset+0xfb0fa008>
8111a050:	9088703a 	and	r4,r18,r2
8111a054:	203e8d1e 	bne	r4,zero,81119a8c <__reset+0xfb0f9a8c>
8111a058:	dc401f17 	ldw	r17,124(sp)
8111a05c:	40800115 	stw	r2,4(r8)
8111a060:	44000015 	stw	r16,0(r8)
8111a064:	8c400044 	addi	r17,r17,1
8111a068:	d8c02015 	stw	r3,128(sp)
8111a06c:	dc401f15 	stw	r17,124(sp)
8111a070:	008001c4 	movi	r2,7
8111a074:	147f7f16 	blt	r2,r17,81119e74 <__reset+0xfb0f9e74>
8111a078:	45800204 	addi	r22,r8,8
8111a07c:	003eac06 	br	81119b30 <__reset+0xfb0f9b30>
8111a080:	d9402c17 	ldw	r5,176(sp)
8111a084:	d9801e04 	addi	r6,sp,120
8111a088:	9809883a 	mov	r4,r19
8111a08c:	11257180 	call	81125718 <__ssprint_r>
8111a090:	103b801e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a094:	d8c02017 	ldw	r3,128(sp)
8111a098:	dc401f17 	ldw	r17,124(sp)
8111a09c:	da000404 	addi	r8,sp,16
8111a0a0:	003e8406 	br	81119ab4 <__reset+0xfb0f9ab4>
8111a0a4:	d9402c17 	ldw	r5,176(sp)
8111a0a8:	d9801e04 	addi	r6,sp,120
8111a0ac:	9809883a 	mov	r4,r19
8111a0b0:	11257180 	call	81125718 <__ssprint_r>
8111a0b4:	103b771e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a0b8:	d8c02017 	ldw	r3,128(sp)
8111a0bc:	dc401f17 	ldw	r17,124(sp)
8111a0c0:	dd800404 	addi	r22,sp,16
8111a0c4:	003e8606 	br	81119ae0 <__reset+0xfb0f9ae0>
8111a0c8:	0029883a 	mov	r20,zero
8111a0cc:	a5000c04 	addi	r20,r20,48
8111a0d0:	dc001dc4 	addi	r16,sp,119
8111a0d4:	dd001dc5 	stb	r20,119(sp)
8111a0d8:	003f3806 	br	81119dbc <__reset+0xfb0f9dbc>
8111a0dc:	d9402c17 	ldw	r5,176(sp)
8111a0e0:	d9801e04 	addi	r6,sp,120
8111a0e4:	9809883a 	mov	r4,r19
8111a0e8:	11257180 	call	81125718 <__ssprint_r>
8111a0ec:	103b691e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a0f0:	d8c02017 	ldw	r3,128(sp)
8111a0f4:	da000404 	addi	r8,sp,16
8111a0f8:	003c9506 	br	81119350 <__reset+0xfb0f9350>
8111a0fc:	d9003617 	ldw	r4,216(sp)
8111a100:	d9403717 	ldw	r5,220(sp)
8111a104:	da003e15 	stw	r8,248(sp)
8111a108:	112352c0 	call	8112352c <__fpclassifyd>
8111a10c:	da003e17 	ldw	r8,248(sp)
8111a110:	1000bd1e 	bne	r2,zero,8111a408 <___svfprintf_internal_r+0x1910>
8111a114:	008011c4 	movi	r2,71
8111a118:	14411e0e 	bge	r2,r17,8111a594 <___svfprintf_internal_r+0x1a9c>
8111a11c:	04204534 	movhi	r16,33044
8111a120:	84172d04 	addi	r16,r16,23732
8111a124:	00c000c4 	movi	r3,3
8111a128:	00bfdfc4 	movi	r2,-129
8111a12c:	d8c02a15 	stw	r3,168(sp)
8111a130:	90a4703a 	and	r18,r18,r2
8111a134:	df002783 	ldbu	fp,158(sp)
8111a138:	d8c02e15 	stw	r3,184(sp)
8111a13c:	d8002915 	stw	zero,164(sp)
8111a140:	d8003215 	stw	zero,200(sp)
8111a144:	003c1c06 	br	811191b8 <__reset+0xfb0f91b8>
8111a148:	9080100c 	andi	r2,r18,64
8111a14c:	d8002785 	stb	zero,158(sp)
8111a150:	10009426 	beq	r2,zero,8111a3a4 <___svfprintf_internal_r+0x18ac>
8111a154:	d8c02d17 	ldw	r3,180(sp)
8111a158:	d9002917 	ldw	r4,164(sp)
8111a15c:	002d883a 	mov	r22,zero
8111a160:	18800104 	addi	r2,r3,4
8111a164:	1d00000b 	ldhu	r20,0(r3)
8111a168:	203ec10e 	bge	r4,zero,81119c70 <__reset+0xfb0f9c70>
8111a16c:	a586b03a 	or	r3,r20,r22
8111a170:	d8802d15 	stw	r2,180(sp)
8111a174:	183ec21e 	bne	r3,zero,81119c80 <__reset+0xfb0f9c80>
8111a178:	0039883a 	mov	fp,zero
8111a17c:	0005883a 	mov	r2,zero
8111a180:	003db806 	br	81119864 <__reset+0xfb0f9864>
8111a184:	d8802d17 	ldw	r2,180(sp)
8111a188:	d8c02d17 	ldw	r3,180(sp)
8111a18c:	d9002d17 	ldw	r4,180(sp)
8111a190:	10800017 	ldw	r2,0(r2)
8111a194:	18c00117 	ldw	r3,4(r3)
8111a198:	21000204 	addi	r4,r4,8
8111a19c:	d8803615 	stw	r2,216(sp)
8111a1a0:	d8c03715 	stw	r3,220(sp)
8111a1a4:	d9002d15 	stw	r4,180(sp)
8111a1a8:	003b8206 	br	81118fb4 <__reset+0xfb0f8fb4>
8111a1ac:	9080100c 	andi	r2,r18,64
8111a1b0:	10010726 	beq	r2,zero,8111a5d0 <___svfprintf_internal_r+0x1ad8>
8111a1b4:	d8c02d17 	ldw	r3,180(sp)
8111a1b8:	1d00000f 	ldh	r20,0(r3)
8111a1bc:	18c00104 	addi	r3,r3,4
8111a1c0:	d8c02d15 	stw	r3,180(sp)
8111a1c4:	a02dd7fa 	srai	r22,r20,31
8111a1c8:	b005883a 	mov	r2,r22
8111a1cc:	003ba206 	br	81119058 <__reset+0xfb0f9058>
8111a1d0:	9080100c 	andi	r2,r18,64
8111a1d4:	10010526 	beq	r2,zero,8111a5ec <___svfprintf_internal_r+0x1af4>
8111a1d8:	d9002d17 	ldw	r4,180(sp)
8111a1dc:	002d883a 	mov	r22,zero
8111a1e0:	2500000b 	ldhu	r20,0(r4)
8111a1e4:	21000104 	addi	r4,r4,4
8111a1e8:	d9002d15 	stw	r4,180(sp)
8111a1ec:	003cfe06 	br	811195e8 <__reset+0xfb0f95e8>
8111a1f0:	bc400007 	ldb	r17,0(r23)
8111a1f4:	003a9606 	br	81118c50 <__reset+0xfb0f8c50>
8111a1f8:	9080040c 	andi	r2,r18,16
8111a1fc:	10010126 	beq	r2,zero,8111a604 <___svfprintf_internal_r+0x1b0c>
8111a200:	d9402d17 	ldw	r5,180(sp)
8111a204:	d8c02f17 	ldw	r3,188(sp)
8111a208:	28800017 	ldw	r2,0(r5)
8111a20c:	29400104 	addi	r5,r5,4
8111a210:	d9402d15 	stw	r5,180(sp)
8111a214:	10c00015 	stw	r3,0(r2)
8111a218:	003a6406 	br	81118bac <__reset+0xfb0f8bac>
8111a21c:	d9002917 	ldw	r4,164(sp)
8111a220:	d8002785 	stb	zero,158(sp)
8111a224:	203d8d16 	blt	r4,zero,8111985c <__reset+0xfb0f985c>
8111a228:	00bfdfc4 	movi	r2,-129
8111a22c:	90a4703a 	and	r18,r18,r2
8111a230:	003b0506 	br	81118e48 <__reset+0xfb0f8e48>
8111a234:	01604534 	movhi	r5,33044
8111a238:	29573a84 	addi	r5,r5,23786
8111a23c:	d9402b15 	stw	r5,172(sp)
8111a240:	d9402b17 	ldw	r5,172(sp)
8111a244:	1c47883a 	add	r3,r3,r17
8111a248:	10800044 	addi	r2,r2,1
8111a24c:	41400015 	stw	r5,0(r8)
8111a250:	44400115 	stw	r17,4(r8)
8111a254:	d8c02015 	stw	r3,128(sp)
8111a258:	d8801f15 	stw	r2,124(sp)
8111a25c:	010001c4 	movi	r4,7
8111a260:	20bf3016 	blt	r4,r2,81119f24 <__reset+0xfb0f9f24>
8111a264:	42000204 	addi	r8,r8,8
8111a268:	003f3506 	br	81119f40 <__reset+0xfb0f9f40>
8111a26c:	01204534 	movhi	r4,33044
8111a270:	21173a84 	addi	r4,r4,23786
8111a274:	d9002b15 	stw	r4,172(sp)
8111a278:	003c5e06 	br	811193f4 <__reset+0xfb0f93f4>
8111a27c:	d9402c17 	ldw	r5,176(sp)
8111a280:	d9801e04 	addi	r6,sp,120
8111a284:	9809883a 	mov	r4,r19
8111a288:	11257180 	call	81125718 <__ssprint_r>
8111a28c:	103b011e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a290:	d8c02017 	ldw	r3,128(sp)
8111a294:	da000404 	addi	r8,sp,16
8111a298:	003d9306 	br	811198e8 <__reset+0xfb0f98e8>
8111a29c:	d8801f17 	ldw	r2,124(sp)
8111a2a0:	01604534 	movhi	r5,33044
8111a2a4:	01000044 	movi	r4,1
8111a2a8:	18c00044 	addi	r3,r3,1
8111a2ac:	10800044 	addi	r2,r2,1
8111a2b0:	29573a04 	addi	r5,r5,23784
8111a2b4:	41000115 	stw	r4,4(r8)
8111a2b8:	41400015 	stw	r5,0(r8)
8111a2bc:	d8c02015 	stw	r3,128(sp)
8111a2c0:	d8801f15 	stw	r2,124(sp)
8111a2c4:	010001c4 	movi	r4,7
8111a2c8:	2080b516 	blt	r4,r2,8111a5a0 <___svfprintf_internal_r+0x1aa8>
8111a2cc:	42000204 	addi	r8,r8,8
8111a2d0:	8800041e 	bne	r17,zero,8111a2e4 <___svfprintf_internal_r+0x17ec>
8111a2d4:	d8803317 	ldw	r2,204(sp)
8111a2d8:	1000021e 	bne	r2,zero,8111a2e4 <___svfprintf_internal_r+0x17ec>
8111a2dc:	9080004c 	andi	r2,r18,1
8111a2e0:	103c5b26 	beq	r2,zero,81119450 <__reset+0xfb0f9450>
8111a2e4:	d9003817 	ldw	r4,224(sp)
8111a2e8:	d8801f17 	ldw	r2,124(sp)
8111a2ec:	d9403417 	ldw	r5,208(sp)
8111a2f0:	20c7883a 	add	r3,r4,r3
8111a2f4:	10800044 	addi	r2,r2,1
8111a2f8:	41000115 	stw	r4,4(r8)
8111a2fc:	41400015 	stw	r5,0(r8)
8111a300:	d8c02015 	stw	r3,128(sp)
8111a304:	d8801f15 	stw	r2,124(sp)
8111a308:	010001c4 	movi	r4,7
8111a30c:	20818016 	blt	r4,r2,8111a910 <___svfprintf_internal_r+0x1e18>
8111a310:	42000204 	addi	r8,r8,8
8111a314:	0463c83a 	sub	r17,zero,r17
8111a318:	0440cb0e 	bge	zero,r17,8111a648 <___svfprintf_internal_r+0x1b50>
8111a31c:	05800404 	movi	r22,16
8111a320:	b440e80e 	bge	r22,r17,8111a6c4 <___svfprintf_internal_r+0x1bcc>
8111a324:	01604534 	movhi	r5,33044
8111a328:	29573a84 	addi	r5,r5,23786
8111a32c:	d9402b15 	stw	r5,172(sp)
8111a330:	070001c4 	movi	fp,7
8111a334:	dd002c17 	ldw	r20,176(sp)
8111a338:	00000306 	br	8111a348 <___svfprintf_internal_r+0x1850>
8111a33c:	42000204 	addi	r8,r8,8
8111a340:	8c7ffc04 	addi	r17,r17,-16
8111a344:	b440e20e 	bge	r22,r17,8111a6d0 <___svfprintf_internal_r+0x1bd8>
8111a348:	18c00404 	addi	r3,r3,16
8111a34c:	10800044 	addi	r2,r2,1
8111a350:	45400015 	stw	r21,0(r8)
8111a354:	45800115 	stw	r22,4(r8)
8111a358:	d8c02015 	stw	r3,128(sp)
8111a35c:	d8801f15 	stw	r2,124(sp)
8111a360:	e0bff60e 	bge	fp,r2,8111a33c <__reset+0xfb0fa33c>
8111a364:	d9801e04 	addi	r6,sp,120
8111a368:	a00b883a 	mov	r5,r20
8111a36c:	9809883a 	mov	r4,r19
8111a370:	11257180 	call	81125718 <__ssprint_r>
8111a374:	103ac71e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a378:	d8c02017 	ldw	r3,128(sp)
8111a37c:	d8801f17 	ldw	r2,124(sp)
8111a380:	da000404 	addi	r8,sp,16
8111a384:	003fee06 	br	8111a340 <__reset+0xfb0fa340>
8111a388:	d8c02d17 	ldw	r3,180(sp)
8111a38c:	d9002917 	ldw	r4,164(sp)
8111a390:	002d883a 	mov	r22,zero
8111a394:	18800104 	addi	r2,r3,4
8111a398:	1d000017 	ldw	r20,0(r3)
8111a39c:	203e7d0e 	bge	r4,zero,81119d94 <__reset+0xfb0f9d94>
8111a3a0:	003eda06 	br	81119f0c <__reset+0xfb0f9f0c>
8111a3a4:	d9402d17 	ldw	r5,180(sp)
8111a3a8:	d8c02917 	ldw	r3,164(sp)
8111a3ac:	002d883a 	mov	r22,zero
8111a3b0:	28800104 	addi	r2,r5,4
8111a3b4:	2d000017 	ldw	r20,0(r5)
8111a3b8:	183e2d0e 	bge	r3,zero,81119c70 <__reset+0xfb0f9c70>
8111a3bc:	003f6b06 	br	8111a16c <__reset+0xfb0fa16c>
8111a3c0:	d8c02d15 	stw	r3,180(sp)
8111a3c4:	0039883a 	mov	fp,zero
8111a3c8:	003ed206 	br	81119f14 <__reset+0xfb0f9f14>
8111a3cc:	bc400043 	ldbu	r17,1(r23)
8111a3d0:	94800814 	ori	r18,r18,32
8111a3d4:	bdc00044 	addi	r23,r23,1
8111a3d8:	8c403fcc 	andi	r17,r17,255
8111a3dc:	8c40201c 	xori	r17,r17,128
8111a3e0:	8c7fe004 	addi	r17,r17,-128
8111a3e4:	003a1a06 	br	81118c50 <__reset+0xfb0f8c50>
8111a3e8:	d9402c17 	ldw	r5,176(sp)
8111a3ec:	d9801e04 	addi	r6,sp,120
8111a3f0:	9809883a 	mov	r4,r19
8111a3f4:	11257180 	call	81125718 <__ssprint_r>
8111a3f8:	103aa61e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a3fc:	d8c02017 	ldw	r3,128(sp)
8111a400:	da000404 	addi	r8,sp,16
8111a404:	003d4a06 	br	81119930 <__reset+0xfb0f9930>
8111a408:	d9002917 	ldw	r4,164(sp)
8111a40c:	05bff7c4 	movi	r22,-33
8111a410:	00bfffc4 	movi	r2,-1
8111a414:	8dac703a 	and	r22,r17,r22
8111a418:	20806a26 	beq	r4,r2,8111a5c4 <___svfprintf_internal_r+0x1acc>
8111a41c:	008011c4 	movi	r2,71
8111a420:	b0813726 	beq	r22,r2,8111a900 <___svfprintf_internal_r+0x1e08>
8111a424:	d9003717 	ldw	r4,220(sp)
8111a428:	90c04014 	ori	r3,r18,256
8111a42c:	d8c02b15 	stw	r3,172(sp)
8111a430:	20015d16 	blt	r4,zero,8111a9a8 <___svfprintf_internal_r+0x1eb0>
8111a434:	dd003717 	ldw	r20,220(sp)
8111a438:	d8002a05 	stb	zero,168(sp)
8111a43c:	00801984 	movi	r2,102
8111a440:	88814026 	beq	r17,r2,8111a944 <___svfprintf_internal_r+0x1e4c>
8111a444:	00801184 	movi	r2,70
8111a448:	88817126 	beq	r17,r2,8111aa10 <___svfprintf_internal_r+0x1f18>
8111a44c:	00801144 	movi	r2,69
8111a450:	b0816226 	beq	r22,r2,8111a9dc <___svfprintf_internal_r+0x1ee4>
8111a454:	d8c02917 	ldw	r3,164(sp)
8111a458:	d8802104 	addi	r2,sp,132
8111a45c:	d8800315 	stw	r2,12(sp)
8111a460:	d9403617 	ldw	r5,216(sp)
8111a464:	d8802504 	addi	r2,sp,148
8111a468:	d8800215 	stw	r2,8(sp)
8111a46c:	d8802604 	addi	r2,sp,152
8111a470:	d8c00015 	stw	r3,0(sp)
8111a474:	d8800115 	stw	r2,4(sp)
8111a478:	01c00084 	movi	r7,2
8111a47c:	a00d883a 	mov	r6,r20
8111a480:	9809883a 	mov	r4,r19
8111a484:	d8c03d15 	stw	r3,244(sp)
8111a488:	da003e15 	stw	r8,248(sp)
8111a48c:	111ede40 	call	8111ede4 <_dtoa_r>
8111a490:	1021883a 	mov	r16,r2
8111a494:	008019c4 	movi	r2,103
8111a498:	d8c03d17 	ldw	r3,244(sp)
8111a49c:	da003e17 	ldw	r8,248(sp)
8111a4a0:	8880e726 	beq	r17,r2,8111a840 <___svfprintf_internal_r+0x1d48>
8111a4a4:	008011c4 	movi	r2,71
8111a4a8:	8880d426 	beq	r17,r2,8111a7fc <___svfprintf_internal_r+0x1d04>
8111a4ac:	80f9883a 	add	fp,r16,r3
8111a4b0:	d9003617 	ldw	r4,216(sp)
8111a4b4:	000d883a 	mov	r6,zero
8111a4b8:	000f883a 	mov	r7,zero
8111a4bc:	a00b883a 	mov	r5,r20
8111a4c0:	da003e15 	stw	r8,248(sp)
8111a4c4:	112b7100 	call	8112b710 <__eqdf2>
8111a4c8:	da003e17 	ldw	r8,248(sp)
8111a4cc:	1000e426 	beq	r2,zero,8111a860 <___svfprintf_internal_r+0x1d68>
8111a4d0:	d8802117 	ldw	r2,132(sp)
8111a4d4:	1700062e 	bgeu	r2,fp,8111a4f0 <___svfprintf_internal_r+0x19f8>
8111a4d8:	01000c04 	movi	r4,48
8111a4dc:	10c00044 	addi	r3,r2,1
8111a4e0:	d8c02115 	stw	r3,132(sp)
8111a4e4:	11000005 	stb	r4,0(r2)
8111a4e8:	d8802117 	ldw	r2,132(sp)
8111a4ec:	173ffb36 	bltu	r2,fp,8111a4dc <__reset+0xfb0fa4dc>
8111a4f0:	1405c83a 	sub	r2,r2,r16
8111a4f4:	d8803315 	stw	r2,204(sp)
8111a4f8:	008011c4 	movi	r2,71
8111a4fc:	b080c526 	beq	r22,r2,8111a814 <___svfprintf_internal_r+0x1d1c>
8111a500:	00801944 	movi	r2,101
8111a504:	1441d90e 	bge	r2,r17,8111ac6c <___svfprintf_internal_r+0x2174>
8111a508:	d8c02617 	ldw	r3,152(sp)
8111a50c:	00801984 	movi	r2,102
8111a510:	d8c03215 	stw	r3,200(sp)
8111a514:	88813426 	beq	r17,r2,8111a9e8 <___svfprintf_internal_r+0x1ef0>
8111a518:	d8c03217 	ldw	r3,200(sp)
8111a51c:	d9003317 	ldw	r4,204(sp)
8111a520:	19012516 	blt	r3,r4,8111a9b8 <___svfprintf_internal_r+0x1ec0>
8111a524:	9480004c 	andi	r18,r18,1
8111a528:	9001841e 	bne	r18,zero,8111ab3c <___svfprintf_internal_r+0x2044>
8111a52c:	1805883a 	mov	r2,r3
8111a530:	1801cc16 	blt	r3,zero,8111ac64 <___svfprintf_internal_r+0x216c>
8111a534:	d8c03217 	ldw	r3,200(sp)
8111a538:	044019c4 	movi	r17,103
8111a53c:	d8c02e15 	stw	r3,184(sp)
8111a540:	df002a07 	ldb	fp,168(sp)
8111a544:	e000a61e 	bne	fp,zero,8111a7e0 <___svfprintf_internal_r+0x1ce8>
8111a548:	df002783 	ldbu	fp,158(sp)
8111a54c:	d8802a15 	stw	r2,168(sp)
8111a550:	dc802b17 	ldw	r18,172(sp)
8111a554:	d8002915 	stw	zero,164(sp)
8111a558:	003b1706 	br	811191b8 <__reset+0xfb0f91b8>
8111a55c:	04204534 	movhi	r16,33044
8111a560:	84172a04 	addi	r16,r16,23720
8111a564:	003aa606 	br	81119000 <__reset+0xfb0f9000>
8111a568:	d9003917 	ldw	r4,228(sp)
8111a56c:	04001004 	movi	r16,64
8111a570:	800b883a 	mov	r5,r16
8111a574:	11174b80 	call	811174b8 <_malloc_r>
8111a578:	d9002c17 	ldw	r4,176(sp)
8111a57c:	20800015 	stw	r2,0(r4)
8111a580:	20800415 	stw	r2,16(r4)
8111a584:	1001cb26 	beq	r2,zero,8111acb4 <___svfprintf_internal_r+0x21bc>
8111a588:	d8802c17 	ldw	r2,176(sp)
8111a58c:	14000515 	stw	r16,20(r2)
8111a590:	00397606 	br	81118b6c <__reset+0xfb0f8b6c>
8111a594:	04204534 	movhi	r16,33044
8111a598:	84172c04 	addi	r16,r16,23728
8111a59c:	003ee106 	br	8111a124 <__reset+0xfb0fa124>
8111a5a0:	d9402c17 	ldw	r5,176(sp)
8111a5a4:	d9801e04 	addi	r6,sp,120
8111a5a8:	9809883a 	mov	r4,r19
8111a5ac:	11257180 	call	81125718 <__ssprint_r>
8111a5b0:	103a381e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a5b4:	dc402617 	ldw	r17,152(sp)
8111a5b8:	d8c02017 	ldw	r3,128(sp)
8111a5bc:	da000404 	addi	r8,sp,16
8111a5c0:	003f4306 	br	8111a2d0 <__reset+0xfb0fa2d0>
8111a5c4:	01400184 	movi	r5,6
8111a5c8:	d9402915 	stw	r5,164(sp)
8111a5cc:	003f9506 	br	8111a424 <__reset+0xfb0fa424>
8111a5d0:	d9002d17 	ldw	r4,180(sp)
8111a5d4:	25000017 	ldw	r20,0(r4)
8111a5d8:	21000104 	addi	r4,r4,4
8111a5dc:	d9002d15 	stw	r4,180(sp)
8111a5e0:	a02dd7fa 	srai	r22,r20,31
8111a5e4:	b005883a 	mov	r2,r22
8111a5e8:	003a9b06 	br	81119058 <__reset+0xfb0f9058>
8111a5ec:	d9402d17 	ldw	r5,180(sp)
8111a5f0:	002d883a 	mov	r22,zero
8111a5f4:	2d000017 	ldw	r20,0(r5)
8111a5f8:	29400104 	addi	r5,r5,4
8111a5fc:	d9402d15 	stw	r5,180(sp)
8111a600:	003bf906 	br	811195e8 <__reset+0xfb0f95e8>
8111a604:	9480100c 	andi	r18,r18,64
8111a608:	90006e26 	beq	r18,zero,8111a7c4 <___svfprintf_internal_r+0x1ccc>
8111a60c:	d9002d17 	ldw	r4,180(sp)
8111a610:	d9402f17 	ldw	r5,188(sp)
8111a614:	20800017 	ldw	r2,0(r4)
8111a618:	21000104 	addi	r4,r4,4
8111a61c:	d9002d15 	stw	r4,180(sp)
8111a620:	1140000d 	sth	r5,0(r2)
8111a624:	00396106 	br	81118bac <__reset+0xfb0f8bac>
8111a628:	d9402c17 	ldw	r5,176(sp)
8111a62c:	d9801e04 	addi	r6,sp,120
8111a630:	9809883a 	mov	r4,r19
8111a634:	11257180 	call	81125718 <__ssprint_r>
8111a638:	103a161e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a63c:	d8c02017 	ldw	r3,128(sp)
8111a640:	d8801f17 	ldw	r2,124(sp)
8111a644:	da000404 	addi	r8,sp,16
8111a648:	d9403317 	ldw	r5,204(sp)
8111a64c:	10800044 	addi	r2,r2,1
8111a650:	44000015 	stw	r16,0(r8)
8111a654:	28c7883a 	add	r3,r5,r3
8111a658:	003b7706 	br	81119438 <__reset+0xfb0f9438>
8111a65c:	8009883a 	mov	r4,r16
8111a660:	da003e15 	stw	r8,248(sp)
8111a664:	11187c00 	call	811187c0 <strlen>
8111a668:	d8802e15 	stw	r2,184(sp)
8111a66c:	da003e17 	ldw	r8,248(sp)
8111a670:	103c280e 	bge	r2,zero,81119714 <__reset+0xfb0f9714>
8111a674:	0005883a 	mov	r2,zero
8111a678:	003c2606 	br	81119714 <__reset+0xfb0f9714>
8111a67c:	00bfffc4 	movi	r2,-1
8111a680:	003a0906 	br	81118ea8 <__reset+0xfb0f8ea8>
8111a684:	01204534 	movhi	r4,33044
8111a688:	21173e84 	addi	r4,r4,23802
8111a68c:	d9003515 	stw	r4,212(sp)
8111a690:	003b0606 	br	811192ac <__reset+0xfb0f92ac>
8111a694:	013fffc4 	movi	r4,-1
8111a698:	003a2706 	br	81118f38 <__reset+0xfb0f8f38>
8111a69c:	d9402c17 	ldw	r5,176(sp)
8111a6a0:	d9801e04 	addi	r6,sp,120
8111a6a4:	9809883a 	mov	r4,r19
8111a6a8:	11257180 	call	81125718 <__ssprint_r>
8111a6ac:	1039f91e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a6b0:	d8c02017 	ldw	r3,128(sp)
8111a6b4:	da000404 	addi	r8,sp,16
8111a6b8:	003d8406 	br	81119ccc <__reset+0xfb0f9ccc>
8111a6bc:	0023883a 	mov	r17,zero
8111a6c0:	003d8306 	br	81119cd0 <__reset+0xfb0f9cd0>
8111a6c4:	01204534 	movhi	r4,33044
8111a6c8:	21173a84 	addi	r4,r4,23786
8111a6cc:	d9002b15 	stw	r4,172(sp)
8111a6d0:	d9002b17 	ldw	r4,172(sp)
8111a6d4:	1c47883a 	add	r3,r3,r17
8111a6d8:	10800044 	addi	r2,r2,1
8111a6dc:	41000015 	stw	r4,0(r8)
8111a6e0:	44400115 	stw	r17,4(r8)
8111a6e4:	d8c02015 	stw	r3,128(sp)
8111a6e8:	d8801f15 	stw	r2,124(sp)
8111a6ec:	010001c4 	movi	r4,7
8111a6f0:	20bfcd16 	blt	r4,r2,8111a628 <__reset+0xfb0fa628>
8111a6f4:	42000204 	addi	r8,r8,8
8111a6f8:	003fd306 	br	8111a648 <__reset+0xfb0fa648>
8111a6fc:	d9402c17 	ldw	r5,176(sp)
8111a700:	d9801e04 	addi	r6,sp,120
8111a704:	9809883a 	mov	r4,r19
8111a708:	11257180 	call	81125718 <__ssprint_r>
8111a70c:	1039e11e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a710:	d8802617 	ldw	r2,152(sp)
8111a714:	d8c02017 	ldw	r3,128(sp)
8111a718:	da000404 	addi	r8,sp,16
8111a71c:	003e1c06 	br	81119f90 <__reset+0xfb0f9f90>
8111a720:	d8802917 	ldw	r2,164(sp)
8111a724:	00c00184 	movi	r3,6
8111a728:	1880012e 	bgeu	r3,r2,8111a730 <___svfprintf_internal_r+0x1c38>
8111a72c:	1805883a 	mov	r2,r3
8111a730:	d8802e15 	stw	r2,184(sp)
8111a734:	1000f316 	blt	r2,zero,8111ab04 <___svfprintf_internal_r+0x200c>
8111a738:	04204534 	movhi	r16,33044
8111a73c:	d8802a15 	stw	r2,168(sp)
8111a740:	dd002d15 	stw	r20,180(sp)
8111a744:	d8002915 	stw	zero,164(sp)
8111a748:	d8003215 	stw	zero,200(sp)
8111a74c:	84173804 	addi	r16,r16,23776
8111a750:	0039883a 	mov	fp,zero
8111a754:	003a9f06 	br	811191d4 <__reset+0xfb0f91d4>
8111a758:	01204534 	movhi	r4,33044
8111a75c:	21173e84 	addi	r4,r4,23802
8111a760:	d9003515 	stw	r4,212(sp)
8111a764:	003b5f06 	br	811194e4 <__reset+0xfb0f94e4>
8111a768:	d9402c17 	ldw	r5,176(sp)
8111a76c:	d9801e04 	addi	r6,sp,120
8111a770:	9809883a 	mov	r4,r19
8111a774:	11257180 	call	81125718 <__ssprint_r>
8111a778:	1039c61e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a77c:	d8802617 	ldw	r2,152(sp)
8111a780:	d9403317 	ldw	r5,204(sp)
8111a784:	d8c02017 	ldw	r3,128(sp)
8111a788:	da000404 	addi	r8,sp,16
8111a78c:	2885c83a 	sub	r2,r5,r2
8111a790:	003e1006 	br	81119fd4 <__reset+0xfb0f9fd4>
8111a794:	00800044 	movi	r2,1
8111a798:	10803fcc 	andi	r2,r2,255
8111a79c:	00c00044 	movi	r3,1
8111a7a0:	10fa3526 	beq	r2,r3,81119078 <__reset+0xfb0f9078>
8111a7a4:	00c00084 	movi	r3,2
8111a7a8:	10fb9e26 	beq	r2,r3,81119624 <__reset+0xfb0f9624>
8111a7ac:	003a6406 	br	81119140 <__reset+0xfb0f9140>
8111a7b0:	0021883a 	mov	r16,zero
8111a7b4:	003e0806 	br	81119fd8 <__reset+0xfb0f9fd8>
8111a7b8:	07000b44 	movi	fp,45
8111a7bc:	df002785 	stb	fp,158(sp)
8111a7c0:	003a0b06 	br	81118ff0 <__reset+0xfb0f8ff0>
8111a7c4:	d8c02d17 	ldw	r3,180(sp)
8111a7c8:	d9002f17 	ldw	r4,188(sp)
8111a7cc:	18800017 	ldw	r2,0(r3)
8111a7d0:	18c00104 	addi	r3,r3,4
8111a7d4:	d8c02d15 	stw	r3,180(sp)
8111a7d8:	11000015 	stw	r4,0(r2)
8111a7dc:	0038f306 	br	81118bac <__reset+0xfb0f8bac>
8111a7e0:	00c00b44 	movi	r3,45
8111a7e4:	d8c02785 	stb	r3,158(sp)
8111a7e8:	d8802a15 	stw	r2,168(sp)
8111a7ec:	dc802b17 	ldw	r18,172(sp)
8111a7f0:	d8002915 	stw	zero,164(sp)
8111a7f4:	07000b44 	movi	fp,45
8111a7f8:	003a7306 	br	811191c8 <__reset+0xfb0f91c8>
8111a7fc:	9080004c 	andi	r2,r18,1
8111a800:	1000941e 	bne	r2,zero,8111aa54 <___svfprintf_internal_r+0x1f5c>
8111a804:	d8802117 	ldw	r2,132(sp)
8111a808:	1405c83a 	sub	r2,r2,r16
8111a80c:	d8803315 	stw	r2,204(sp)
8111a810:	b441161e 	bne	r22,r17,8111ac6c <___svfprintf_internal_r+0x2174>
8111a814:	dd802617 	ldw	r22,152(sp)
8111a818:	00bfff44 	movi	r2,-3
8111a81c:	b0801a16 	blt	r22,r2,8111a888 <___svfprintf_internal_r+0x1d90>
8111a820:	d9402917 	ldw	r5,164(sp)
8111a824:	2d801816 	blt	r5,r22,8111a888 <___svfprintf_internal_r+0x1d90>
8111a828:	dd803215 	stw	r22,200(sp)
8111a82c:	003f3a06 	br	8111a518 <__reset+0xfb0fa518>
8111a830:	1025883a 	mov	r18,r2
8111a834:	0039883a 	mov	fp,zero
8111a838:	00800084 	movi	r2,2
8111a83c:	003fd606 	br	8111a798 <__reset+0xfb0fa798>
8111a840:	9080004c 	andi	r2,r18,1
8111a844:	103f191e 	bne	r2,zero,8111a4ac <__reset+0xfb0fa4ac>
8111a848:	d8802117 	ldw	r2,132(sp)
8111a84c:	003f2806 	br	8111a4f0 <__reset+0xfb0fa4f0>
8111a850:	01204534 	movhi	r4,33044
8111a854:	21173a84 	addi	r4,r4,23786
8111a858:	d9002b15 	stw	r4,172(sp)
8111a85c:	003c7c06 	br	81119a50 <__reset+0xfb0f9a50>
8111a860:	e005883a 	mov	r2,fp
8111a864:	003f2206 	br	8111a4f0 <__reset+0xfb0fa4f0>
8111a868:	d9402917 	ldw	r5,164(sp)
8111a86c:	df002783 	ldbu	fp,158(sp)
8111a870:	dd002d15 	stw	r20,180(sp)
8111a874:	d9402a15 	stw	r5,168(sp)
8111a878:	d9402e15 	stw	r5,184(sp)
8111a87c:	d8002915 	stw	zero,164(sp)
8111a880:	d8003215 	stw	zero,200(sp)
8111a884:	003a4c06 	br	811191b8 <__reset+0xfb0f91b8>
8111a888:	8c7fff84 	addi	r17,r17,-2
8111a88c:	b5bfffc4 	addi	r22,r22,-1
8111a890:	dd802615 	stw	r22,152(sp)
8111a894:	dc4022c5 	stb	r17,139(sp)
8111a898:	b000c316 	blt	r22,zero,8111aba8 <___svfprintf_internal_r+0x20b0>
8111a89c:	00800ac4 	movi	r2,43
8111a8a0:	d8802305 	stb	r2,140(sp)
8111a8a4:	00800244 	movi	r2,9
8111a8a8:	15806e16 	blt	r2,r22,8111aa64 <___svfprintf_internal_r+0x1f6c>
8111a8ac:	00800c04 	movi	r2,48
8111a8b0:	b5800c04 	addi	r22,r22,48
8111a8b4:	d8802345 	stb	r2,141(sp)
8111a8b8:	dd802385 	stb	r22,142(sp)
8111a8bc:	d88023c4 	addi	r2,sp,143
8111a8c0:	df0022c4 	addi	fp,sp,139
8111a8c4:	d8c03317 	ldw	r3,204(sp)
8111a8c8:	1739c83a 	sub	fp,r2,fp
8111a8cc:	d9003317 	ldw	r4,204(sp)
8111a8d0:	e0c7883a 	add	r3,fp,r3
8111a8d4:	df003b15 	stw	fp,236(sp)
8111a8d8:	d8c02e15 	stw	r3,184(sp)
8111a8dc:	00800044 	movi	r2,1
8111a8e0:	1100b70e 	bge	r2,r4,8111abc0 <___svfprintf_internal_r+0x20c8>
8111a8e4:	d8c02e17 	ldw	r3,184(sp)
8111a8e8:	18c00044 	addi	r3,r3,1
8111a8ec:	d8c02e15 	stw	r3,184(sp)
8111a8f0:	1805883a 	mov	r2,r3
8111a8f4:	1800b016 	blt	r3,zero,8111abb8 <___svfprintf_internal_r+0x20c0>
8111a8f8:	d8003215 	stw	zero,200(sp)
8111a8fc:	003f1006 	br	8111a540 <__reset+0xfb0fa540>
8111a900:	d8802917 	ldw	r2,164(sp)
8111a904:	103ec71e 	bne	r2,zero,8111a424 <__reset+0xfb0fa424>
8111a908:	dc002915 	stw	r16,164(sp)
8111a90c:	003ec506 	br	8111a424 <__reset+0xfb0fa424>
8111a910:	d9402c17 	ldw	r5,176(sp)
8111a914:	d9801e04 	addi	r6,sp,120
8111a918:	9809883a 	mov	r4,r19
8111a91c:	11257180 	call	81125718 <__ssprint_r>
8111a920:	10395c1e 	bne	r2,zero,81118e94 <__reset+0xfb0f8e94>
8111a924:	dc402617 	ldw	r17,152(sp)
8111a928:	d8c02017 	ldw	r3,128(sp)
8111a92c:	d8801f17 	ldw	r2,124(sp)
8111a930:	da000404 	addi	r8,sp,16
8111a934:	003e7706 	br	8111a314 <__reset+0xfb0fa314>
8111a938:	582f883a 	mov	r23,r11
8111a93c:	d8002915 	stw	zero,164(sp)
8111a940:	0038c406 	br	81118c54 <__reset+0xfb0f8c54>
8111a944:	d8c02917 	ldw	r3,164(sp)
8111a948:	d8802104 	addi	r2,sp,132
8111a94c:	d8800315 	stw	r2,12(sp)
8111a950:	d9403617 	ldw	r5,216(sp)
8111a954:	d8802504 	addi	r2,sp,148
8111a958:	d8800215 	stw	r2,8(sp)
8111a95c:	d8802604 	addi	r2,sp,152
8111a960:	d8c00015 	stw	r3,0(sp)
8111a964:	9809883a 	mov	r4,r19
8111a968:	d8800115 	stw	r2,4(sp)
8111a96c:	01c000c4 	movi	r7,3
8111a970:	a00d883a 	mov	r6,r20
8111a974:	da003e15 	stw	r8,248(sp)
8111a978:	111ede40 	call	8111ede4 <_dtoa_r>
8111a97c:	d9002917 	ldw	r4,164(sp)
8111a980:	da003e17 	ldw	r8,248(sp)
8111a984:	1021883a 	mov	r16,r2
8111a988:	1139883a 	add	fp,r2,r4
8111a98c:	2007883a 	mov	r3,r4
8111a990:	81000007 	ldb	r4,0(r16)
8111a994:	00800c04 	movi	r2,48
8111a998:	20806f26 	beq	r4,r2,8111ab58 <___svfprintf_internal_r+0x2060>
8111a99c:	d8c02617 	ldw	r3,152(sp)
8111a9a0:	e0f9883a 	add	fp,fp,r3
8111a9a4:	003ec206 	br	8111a4b0 <__reset+0xfb0fa4b0>
8111a9a8:	00c00b44 	movi	r3,45
8111a9ac:	2520003c 	xorhi	r20,r4,32768
8111a9b0:	d8c02a05 	stb	r3,168(sp)
8111a9b4:	003ea106 	br	8111a43c <__reset+0xfb0fa43c>
8111a9b8:	d8c03217 	ldw	r3,200(sp)
8111a9bc:	00c0890e 	bge	zero,r3,8111abe4 <___svfprintf_internal_r+0x20ec>
8111a9c0:	00800044 	movi	r2,1
8111a9c4:	d9003317 	ldw	r4,204(sp)
8111a9c8:	1105883a 	add	r2,r2,r4
8111a9cc:	d8802e15 	stw	r2,184(sp)
8111a9d0:	10005f16 	blt	r2,zero,8111ab50 <___svfprintf_internal_r+0x2058>
8111a9d4:	044019c4 	movi	r17,103
8111a9d8:	003ed906 	br	8111a540 <__reset+0xfb0fa540>
8111a9dc:	d9002917 	ldw	r4,164(sp)
8111a9e0:	20c00044 	addi	r3,r4,1
8111a9e4:	003e9c06 	br	8111a458 <__reset+0xfb0fa458>
8111a9e8:	d9002917 	ldw	r4,164(sp)
8111a9ec:	00c0680e 	bge	zero,r3,8111ab90 <___svfprintf_internal_r+0x2098>
8111a9f0:	2000461e 	bne	r4,zero,8111ab0c <___svfprintf_internal_r+0x2014>
8111a9f4:	9480004c 	andi	r18,r18,1
8111a9f8:	9000441e 	bne	r18,zero,8111ab0c <___svfprintf_internal_r+0x2014>
8111a9fc:	1805883a 	mov	r2,r3
8111aa00:	1800a016 	blt	r3,zero,8111ac84 <___svfprintf_internal_r+0x218c>
8111aa04:	d8c03217 	ldw	r3,200(sp)
8111aa08:	d8c02e15 	stw	r3,184(sp)
8111aa0c:	003ecc06 	br	8111a540 <__reset+0xfb0fa540>
8111aa10:	d9402917 	ldw	r5,164(sp)
8111aa14:	d8802104 	addi	r2,sp,132
8111aa18:	d8800315 	stw	r2,12(sp)
8111aa1c:	d9400015 	stw	r5,0(sp)
8111aa20:	d8802504 	addi	r2,sp,148
8111aa24:	d9403617 	ldw	r5,216(sp)
8111aa28:	d8800215 	stw	r2,8(sp)
8111aa2c:	d8802604 	addi	r2,sp,152
8111aa30:	d8800115 	stw	r2,4(sp)
8111aa34:	01c000c4 	movi	r7,3
8111aa38:	a00d883a 	mov	r6,r20
8111aa3c:	9809883a 	mov	r4,r19
8111aa40:	da003e15 	stw	r8,248(sp)
8111aa44:	111ede40 	call	8111ede4 <_dtoa_r>
8111aa48:	d8c02917 	ldw	r3,164(sp)
8111aa4c:	da003e17 	ldw	r8,248(sp)
8111aa50:	1021883a 	mov	r16,r2
8111aa54:	00801184 	movi	r2,70
8111aa58:	80f9883a 	add	fp,r16,r3
8111aa5c:	88bfcc26 	beq	r17,r2,8111a990 <__reset+0xfb0fa990>
8111aa60:	003e9306 	br	8111a4b0 <__reset+0xfb0fa4b0>
8111aa64:	df0022c4 	addi	fp,sp,139
8111aa68:	dc002915 	stw	r16,164(sp)
8111aa6c:	9829883a 	mov	r20,r19
8111aa70:	e021883a 	mov	r16,fp
8111aa74:	4027883a 	mov	r19,r8
8111aa78:	b009883a 	mov	r4,r22
8111aa7c:	01400284 	movi	r5,10
8111aa80:	112a2400 	call	8112a240 <__modsi3>
8111aa84:	10800c04 	addi	r2,r2,48
8111aa88:	843fffc4 	addi	r16,r16,-1
8111aa8c:	b009883a 	mov	r4,r22
8111aa90:	01400284 	movi	r5,10
8111aa94:	80800005 	stb	r2,0(r16)
8111aa98:	112a1bc0 	call	8112a1bc <__divsi3>
8111aa9c:	102d883a 	mov	r22,r2
8111aaa0:	00800244 	movi	r2,9
8111aaa4:	15bff416 	blt	r2,r22,8111aa78 <__reset+0xfb0faa78>
8111aaa8:	9811883a 	mov	r8,r19
8111aaac:	b0800c04 	addi	r2,r22,48
8111aab0:	a027883a 	mov	r19,r20
8111aab4:	8029883a 	mov	r20,r16
8111aab8:	a17fffc4 	addi	r5,r20,-1
8111aabc:	a0bfffc5 	stb	r2,-1(r20)
8111aac0:	dc002917 	ldw	r16,164(sp)
8111aac4:	2f00752e 	bgeu	r5,fp,8111ac9c <___svfprintf_internal_r+0x21a4>
8111aac8:	d9c02384 	addi	r7,sp,142
8111aacc:	3d0fc83a 	sub	r7,r7,r20
8111aad0:	d9002344 	addi	r4,sp,141
8111aad4:	e1cf883a 	add	r7,fp,r7
8111aad8:	00000106 	br	8111aae0 <___svfprintf_internal_r+0x1fe8>
8111aadc:	28800003 	ldbu	r2,0(r5)
8111aae0:	20800005 	stb	r2,0(r4)
8111aae4:	21000044 	addi	r4,r4,1
8111aae8:	29400044 	addi	r5,r5,1
8111aaec:	21fffb1e 	bne	r4,r7,8111aadc <__reset+0xfb0faadc>
8111aaf0:	d8802304 	addi	r2,sp,140
8111aaf4:	1505c83a 	sub	r2,r2,r20
8111aaf8:	d8c02344 	addi	r3,sp,141
8111aafc:	1885883a 	add	r2,r3,r2
8111ab00:	003f7006 	br	8111a8c4 <__reset+0xfb0fa8c4>
8111ab04:	0005883a 	mov	r2,zero
8111ab08:	003f0b06 	br	8111a738 <__reset+0xfb0fa738>
8111ab0c:	d9002917 	ldw	r4,164(sp)
8111ab10:	d8c03217 	ldw	r3,200(sp)
8111ab14:	20800044 	addi	r2,r4,1
8111ab18:	1885883a 	add	r2,r3,r2
8111ab1c:	d8802e15 	stw	r2,184(sp)
8111ab20:	103e870e 	bge	r2,zero,8111a540 <__reset+0xfb0fa540>
8111ab24:	0005883a 	mov	r2,zero
8111ab28:	003e8506 	br	8111a540 <__reset+0xfb0fa540>
8111ab2c:	01204534 	movhi	r4,33044
8111ab30:	21173a84 	addi	r4,r4,23786
8111ab34:	d9002b15 	stw	r4,172(sp)
8111ab38:	003cc506 	br	81119e50 <__reset+0xfb0f9e50>
8111ab3c:	d8c03217 	ldw	r3,200(sp)
8111ab40:	18c00044 	addi	r3,r3,1
8111ab44:	d8c02e15 	stw	r3,184(sp)
8111ab48:	1805883a 	mov	r2,r3
8111ab4c:	183fa10e 	bge	r3,zero,8111a9d4 <__reset+0xfb0fa9d4>
8111ab50:	0005883a 	mov	r2,zero
8111ab54:	003f9f06 	br	8111a9d4 <__reset+0xfb0fa9d4>
8111ab58:	d9003617 	ldw	r4,216(sp)
8111ab5c:	000d883a 	mov	r6,zero
8111ab60:	000f883a 	mov	r7,zero
8111ab64:	a00b883a 	mov	r5,r20
8111ab68:	d8c03d15 	stw	r3,244(sp)
8111ab6c:	da003e15 	stw	r8,248(sp)
8111ab70:	112b7100 	call	8112b710 <__eqdf2>
8111ab74:	d8c03d17 	ldw	r3,244(sp)
8111ab78:	da003e17 	ldw	r8,248(sp)
8111ab7c:	103f8726 	beq	r2,zero,8111a99c <__reset+0xfb0fa99c>
8111ab80:	00800044 	movi	r2,1
8111ab84:	10c7c83a 	sub	r3,r2,r3
8111ab88:	d8c02615 	stw	r3,152(sp)
8111ab8c:	003f8406 	br	8111a9a0 <__reset+0xfb0fa9a0>
8111ab90:	20000e1e 	bne	r4,zero,8111abcc <___svfprintf_internal_r+0x20d4>
8111ab94:	9480004c 	andi	r18,r18,1
8111ab98:	90000c1e 	bne	r18,zero,8111abcc <___svfprintf_internal_r+0x20d4>
8111ab9c:	00800044 	movi	r2,1
8111aba0:	d8802e15 	stw	r2,184(sp)
8111aba4:	003e6606 	br	8111a540 <__reset+0xfb0fa540>
8111aba8:	00800b44 	movi	r2,45
8111abac:	05adc83a 	sub	r22,zero,r22
8111abb0:	d8802305 	stb	r2,140(sp)
8111abb4:	003f3b06 	br	8111a8a4 <__reset+0xfb0fa8a4>
8111abb8:	0005883a 	mov	r2,zero
8111abbc:	003f4e06 	br	8111a8f8 <__reset+0xfb0fa8f8>
8111abc0:	90a4703a 	and	r18,r18,r2
8111abc4:	903f4a26 	beq	r18,zero,8111a8f0 <__reset+0xfb0fa8f0>
8111abc8:	003f4606 	br	8111a8e4 <__reset+0xfb0fa8e4>
8111abcc:	d8c02917 	ldw	r3,164(sp)
8111abd0:	18c00084 	addi	r3,r3,2
8111abd4:	d8c02e15 	stw	r3,184(sp)
8111abd8:	1805883a 	mov	r2,r3
8111abdc:	183e580e 	bge	r3,zero,8111a540 <__reset+0xfb0fa540>
8111abe0:	003fd006 	br	8111ab24 <__reset+0xfb0fab24>
8111abe4:	00800084 	movi	r2,2
8111abe8:	10c5c83a 	sub	r2,r2,r3
8111abec:	003f7506 	br	8111a9c4 <__reset+0xfb0fa9c4>
8111abf0:	d8802d17 	ldw	r2,180(sp)
8111abf4:	d9002d17 	ldw	r4,180(sp)
8111abf8:	bc400043 	ldbu	r17,1(r23)
8111abfc:	10800017 	ldw	r2,0(r2)
8111ac00:	582f883a 	mov	r23,r11
8111ac04:	d8802915 	stw	r2,164(sp)
8111ac08:	20800104 	addi	r2,r4,4
8111ac0c:	d9002917 	ldw	r4,164(sp)
8111ac10:	d8802d15 	stw	r2,180(sp)
8111ac14:	203df00e 	bge	r4,zero,8111a3d8 <__reset+0xfb0fa3d8>
8111ac18:	8c403fcc 	andi	r17,r17,255
8111ac1c:	00bfffc4 	movi	r2,-1
8111ac20:	8c40201c 	xori	r17,r17,128
8111ac24:	d8802915 	stw	r2,164(sp)
8111ac28:	8c7fe004 	addi	r17,r17,-128
8111ac2c:	00380806 	br	81118c50 <__reset+0xfb0f8c50>
8111ac30:	9080004c 	andi	r2,r18,1
8111ac34:	0039883a 	mov	fp,zero
8111ac38:	10000726 	beq	r2,zero,8111ac58 <___svfprintf_internal_r+0x2160>
8111ac3c:	d8c02817 	ldw	r3,160(sp)
8111ac40:	dc001dc4 	addi	r16,sp,119
8111ac44:	00800c04 	movi	r2,48
8111ac48:	1c07c83a 	sub	r3,r3,r16
8111ac4c:	d8801dc5 	stb	r2,119(sp)
8111ac50:	d8c02e15 	stw	r3,184(sp)
8111ac54:	00395206 	br	811191a0 <__reset+0xfb0f91a0>
8111ac58:	d8002e15 	stw	zero,184(sp)
8111ac5c:	dc001e04 	addi	r16,sp,120
8111ac60:	00394f06 	br	811191a0 <__reset+0xfb0f91a0>
8111ac64:	0005883a 	mov	r2,zero
8111ac68:	003e3206 	br	8111a534 <__reset+0xfb0fa534>
8111ac6c:	dd802617 	ldw	r22,152(sp)
8111ac70:	003f0606 	br	8111a88c <__reset+0xfb0fa88c>
8111ac74:	d9c02785 	stb	r7,158(sp)
8111ac78:	003a5106 	br	811195c0 <__reset+0xfb0f95c0>
8111ac7c:	d9c02785 	stb	r7,158(sp)
8111ac80:	003a3706 	br	81119560 <__reset+0xfb0f9560>
8111ac84:	0005883a 	mov	r2,zero
8111ac88:	003f5e06 	br	8111aa04 <__reset+0xfb0faa04>
8111ac8c:	d9c02785 	stb	r7,158(sp)
8111ac90:	00391706 	br	811190f0 <__reset+0xfb0f90f0>
8111ac94:	d9c02785 	stb	r7,158(sp)
8111ac98:	0038e606 	br	81119034 <__reset+0xfb0f9034>
8111ac9c:	d8802344 	addi	r2,sp,141
8111aca0:	003f0806 	br	8111a8c4 <__reset+0xfb0fa8c4>
8111aca4:	d9c02785 	stb	r7,158(sp)
8111aca8:	0038b706 	br	81118f88 <__reset+0xfb0f8f88>
8111acac:	d9c02785 	stb	r7,158(sp)
8111acb0:	003adc06 	br	81119824 <__reset+0xfb0f9824>
8111acb4:	d9403917 	ldw	r5,228(sp)
8111acb8:	00800304 	movi	r2,12
8111acbc:	28800015 	stw	r2,0(r5)
8111acc0:	00bfffc4 	movi	r2,-1
8111acc4:	00387806 	br	81118ea8 <__reset+0xfb0f8ea8>
8111acc8:	d9c02785 	stb	r7,158(sp)
8111accc:	003abf06 	br	811197cc <__reset+0xfb0f97cc>
8111acd0:	d9c02785 	stb	r7,158(sp)
8111acd4:	003a9b06 	br	81119744 <__reset+0xfb0f9744>

8111acd8 <___vfprintf_internal_r>:
8111acd8:	deffb804 	addi	sp,sp,-288
8111acdc:	de00012e 	bgeu	sp,et,8111ace4 <___vfprintf_internal_r+0xc>
8111ace0:	003b68fa 	trap	3
8111ace4:	dfc04715 	stw	ra,284(sp)
8111ace8:	ddc04515 	stw	r23,276(sp)
8111acec:	dd404315 	stw	r21,268(sp)
8111acf0:	d9002c15 	stw	r4,176(sp)
8111acf4:	282f883a 	mov	r23,r5
8111acf8:	302b883a 	mov	r21,r6
8111acfc:	d9c02d15 	stw	r7,180(sp)
8111ad00:	df004615 	stw	fp,280(sp)
8111ad04:	dd804415 	stw	r22,272(sp)
8111ad08:	dd004215 	stw	r20,264(sp)
8111ad0c:	dcc04115 	stw	r19,260(sp)
8111ad10:	dc804015 	stw	r18,256(sp)
8111ad14:	dc403f15 	stw	r17,252(sp)
8111ad18:	dc003e15 	stw	r16,248(sp)
8111ad1c:	11219e00 	call	811219e0 <_localeconv_r>
8111ad20:	10800017 	ldw	r2,0(r2)
8111ad24:	1009883a 	mov	r4,r2
8111ad28:	d8803415 	stw	r2,208(sp)
8111ad2c:	11187c00 	call	811187c0 <strlen>
8111ad30:	d8803715 	stw	r2,220(sp)
8111ad34:	d8802c17 	ldw	r2,176(sp)
8111ad38:	10000226 	beq	r2,zero,8111ad44 <___vfprintf_internal_r+0x6c>
8111ad3c:	10800e17 	ldw	r2,56(r2)
8111ad40:	1000f926 	beq	r2,zero,8111b128 <___vfprintf_internal_r+0x450>
8111ad44:	b880030b 	ldhu	r2,12(r23)
8111ad48:	10c8000c 	andi	r3,r2,8192
8111ad4c:	1800061e 	bne	r3,zero,8111ad68 <___vfprintf_internal_r+0x90>
8111ad50:	b9001917 	ldw	r4,100(r23)
8111ad54:	00f7ffc4 	movi	r3,-8193
8111ad58:	10880014 	ori	r2,r2,8192
8111ad5c:	20c6703a 	and	r3,r4,r3
8111ad60:	b880030d 	sth	r2,12(r23)
8111ad64:	b8c01915 	stw	r3,100(r23)
8111ad68:	10c0020c 	andi	r3,r2,8
8111ad6c:	1800c126 	beq	r3,zero,8111b074 <___vfprintf_internal_r+0x39c>
8111ad70:	b8c00417 	ldw	r3,16(r23)
8111ad74:	1800bf26 	beq	r3,zero,8111b074 <___vfprintf_internal_r+0x39c>
8111ad78:	1080068c 	andi	r2,r2,26
8111ad7c:	00c00284 	movi	r3,10
8111ad80:	10c0c426 	beq	r2,r3,8111b094 <___vfprintf_internal_r+0x3bc>
8111ad84:	d8c00404 	addi	r3,sp,16
8111ad88:	05204534 	movhi	r20,33044
8111ad8c:	d9001e04 	addi	r4,sp,120
8111ad90:	a5174284 	addi	r20,r20,23818
8111ad94:	d8c01e15 	stw	r3,120(sp)
8111ad98:	d8002015 	stw	zero,128(sp)
8111ad9c:	d8001f15 	stw	zero,124(sp)
8111ada0:	d8003315 	stw	zero,204(sp)
8111ada4:	d8003615 	stw	zero,216(sp)
8111ada8:	d8003815 	stw	zero,224(sp)
8111adac:	1811883a 	mov	r8,r3
8111adb0:	d8003915 	stw	zero,228(sp)
8111adb4:	d8003a15 	stw	zero,232(sp)
8111adb8:	d8002f15 	stw	zero,188(sp)
8111adbc:	d9002815 	stw	r4,160(sp)
8111adc0:	a8800007 	ldb	r2,0(r21)
8111adc4:	10027b26 	beq	r2,zero,8111b7b4 <___vfprintf_internal_r+0xadc>
8111adc8:	00c00944 	movi	r3,37
8111adcc:	a821883a 	mov	r16,r21
8111add0:	10c0021e 	bne	r2,r3,8111addc <___vfprintf_internal_r+0x104>
8111add4:	00001406 	br	8111ae28 <___vfprintf_internal_r+0x150>
8111add8:	10c00326 	beq	r2,r3,8111ade8 <___vfprintf_internal_r+0x110>
8111addc:	84000044 	addi	r16,r16,1
8111ade0:	80800007 	ldb	r2,0(r16)
8111ade4:	103ffc1e 	bne	r2,zero,8111add8 <__reset+0xfb0fadd8>
8111ade8:	8563c83a 	sub	r17,r16,r21
8111adec:	88000e26 	beq	r17,zero,8111ae28 <___vfprintf_internal_r+0x150>
8111adf0:	d8c02017 	ldw	r3,128(sp)
8111adf4:	d8801f17 	ldw	r2,124(sp)
8111adf8:	45400015 	stw	r21,0(r8)
8111adfc:	1c47883a 	add	r3,r3,r17
8111ae00:	10800044 	addi	r2,r2,1
8111ae04:	d8c02015 	stw	r3,128(sp)
8111ae08:	44400115 	stw	r17,4(r8)
8111ae0c:	d8801f15 	stw	r2,124(sp)
8111ae10:	00c001c4 	movi	r3,7
8111ae14:	1880a716 	blt	r3,r2,8111b0b4 <___vfprintf_internal_r+0x3dc>
8111ae18:	42000204 	addi	r8,r8,8
8111ae1c:	d9402f17 	ldw	r5,188(sp)
8111ae20:	2c4b883a 	add	r5,r5,r17
8111ae24:	d9402f15 	stw	r5,188(sp)
8111ae28:	80800007 	ldb	r2,0(r16)
8111ae2c:	1000a826 	beq	r2,zero,8111b0d0 <___vfprintf_internal_r+0x3f8>
8111ae30:	84400047 	ldb	r17,1(r16)
8111ae34:	00bfffc4 	movi	r2,-1
8111ae38:	85400044 	addi	r21,r16,1
8111ae3c:	d8002785 	stb	zero,158(sp)
8111ae40:	0007883a 	mov	r3,zero
8111ae44:	000f883a 	mov	r7,zero
8111ae48:	d8802915 	stw	r2,164(sp)
8111ae4c:	d8003115 	stw	zero,196(sp)
8111ae50:	0025883a 	mov	r18,zero
8111ae54:	01401604 	movi	r5,88
8111ae58:	01800244 	movi	r6,9
8111ae5c:	02800a84 	movi	r10,42
8111ae60:	02401b04 	movi	r9,108
8111ae64:	ad400044 	addi	r21,r21,1
8111ae68:	88bff804 	addi	r2,r17,-32
8111ae6c:	28830436 	bltu	r5,r2,8111ba80 <___vfprintf_internal_r+0xda8>
8111ae70:	100490ba 	slli	r2,r2,2
8111ae74:	012044b4 	movhi	r4,33042
8111ae78:	212ba204 	addi	r4,r4,-20856
8111ae7c:	1105883a 	add	r2,r2,r4
8111ae80:	10800017 	ldw	r2,0(r2)
8111ae84:	1000683a 	jmp	r2
8111ae88:	8111b9a0 	cmpeqi	r4,r16,18150
8111ae8c:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111ae90:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111ae94:	8111b9c0 	call	88111b9c <__reset+0x20f1b9c>
8111ae98:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111ae9c:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aea0:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aea4:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aea8:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aeac:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aeb0:	8111b134 	orhi	r4,r16,18116
8111aeb4:	8111b8dc 	xori	r4,r16,18147
8111aeb8:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aebc:	8111affc 	xorhi	r4,r16,18111
8111aec0:	8111b15c 	xori	r4,r16,18117
8111aec4:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aec8:	8111b19c 	xori	r4,r16,18118
8111aecc:	8111b1a8 	cmpgeui	r4,r16,18118
8111aed0:	8111b1a8 	cmpgeui	r4,r16,18118
8111aed4:	8111b1a8 	cmpgeui	r4,r16,18118
8111aed8:	8111b1a8 	cmpgeui	r4,r16,18118
8111aedc:	8111b1a8 	cmpgeui	r4,r16,18118
8111aee0:	8111b1a8 	cmpgeui	r4,r16,18118
8111aee4:	8111b1a8 	cmpgeui	r4,r16,18118
8111aee8:	8111b1a8 	cmpgeui	r4,r16,18118
8111aeec:	8111b1a8 	cmpgeui	r4,r16,18118
8111aef0:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aef4:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aef8:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111aefc:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af00:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af04:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af08:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af0c:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af10:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af14:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af18:	8111b1dc 	xori	r4,r16,18119
8111af1c:	8111b298 	cmpnei	r4,r16,18122
8111af20:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af24:	8111b298 	cmpnei	r4,r16,18122
8111af28:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af2c:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af30:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af34:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af38:	8111b338 	rdprs	r4,r16,18124
8111af3c:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af40:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af44:	8111b344 	addi	r4,r16,18125
8111af48:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af4c:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af50:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af54:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af58:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af5c:	8111b7bc 	xorhi	r4,r16,18142
8111af60:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af64:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af68:	8111b81c 	xori	r4,r16,18144
8111af6c:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af70:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af74:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af78:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af7c:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af80:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af84:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af88:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af8c:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af90:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111af94:	8111ba2c 	andhi	r4,r16,18152
8111af98:	8111b9cc 	andi	r4,r16,18151
8111af9c:	8111b298 	cmpnei	r4,r16,18122
8111afa0:	8111b298 	cmpnei	r4,r16,18122
8111afa4:	8111b298 	cmpnei	r4,r16,18122
8111afa8:	8111b9dc 	xori	r4,r16,18151
8111afac:	8111b9cc 	andi	r4,r16,18151
8111afb0:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111afb4:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111afb8:	8111b9e8 	cmpgeui	r4,r16,18151
8111afbc:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111afc0:	8111b9f8 	rdprs	r4,r16,18151
8111afc4:	8111b8cc 	andi	r4,r16,18147
8111afc8:	8111b008 	cmpgei	r4,r16,18112
8111afcc:	8111b8ec 	andhi	r4,r16,18147
8111afd0:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111afd4:	8111b8f8 	rdprs	r4,r16,18147
8111afd8:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111afdc:	8111b954 	ori	r4,r16,18149
8111afe0:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111afe4:	8111ba80 	call	88111ba8 <__reset+0x20f1ba8>
8111afe8:	8111b964 	muli	r4,r16,18149
8111afec:	d9003117 	ldw	r4,196(sp)
8111aff0:	d8802d15 	stw	r2,180(sp)
8111aff4:	0109c83a 	sub	r4,zero,r4
8111aff8:	d9003115 	stw	r4,196(sp)
8111affc:	94800114 	ori	r18,r18,4
8111b000:	ac400007 	ldb	r17,0(r21)
8111b004:	003f9706 	br	8111ae64 <__reset+0xfb0fae64>
8111b008:	00800c04 	movi	r2,48
8111b00c:	d9002d17 	ldw	r4,180(sp)
8111b010:	d9402917 	ldw	r5,164(sp)
8111b014:	d8802705 	stb	r2,156(sp)
8111b018:	00801e04 	movi	r2,120
8111b01c:	d8802745 	stb	r2,157(sp)
8111b020:	d8002785 	stb	zero,158(sp)
8111b024:	20c00104 	addi	r3,r4,4
8111b028:	24c00017 	ldw	r19,0(r4)
8111b02c:	002d883a 	mov	r22,zero
8111b030:	90800094 	ori	r2,r18,2
8111b034:	28029a16 	blt	r5,zero,8111baa0 <___vfprintf_internal_r+0xdc8>
8111b038:	00bfdfc4 	movi	r2,-129
8111b03c:	90a4703a 	and	r18,r18,r2
8111b040:	d8c02d15 	stw	r3,180(sp)
8111b044:	94800094 	ori	r18,r18,2
8111b048:	9802871e 	bne	r19,zero,8111ba68 <___vfprintf_internal_r+0xd90>
8111b04c:	00a04534 	movhi	r2,33044
8111b050:	10973304 	addi	r2,r2,23756
8111b054:	d8803915 	stw	r2,228(sp)
8111b058:	04401e04 	movi	r17,120
8111b05c:	d8802917 	ldw	r2,164(sp)
8111b060:	0039883a 	mov	fp,zero
8111b064:	1001e926 	beq	r2,zero,8111b80c <___vfprintf_internal_r+0xb34>
8111b068:	0027883a 	mov	r19,zero
8111b06c:	002d883a 	mov	r22,zero
8111b070:	00020506 	br	8111b888 <___vfprintf_internal_r+0xbb0>
8111b074:	d9002c17 	ldw	r4,176(sp)
8111b078:	b80b883a 	mov	r5,r23
8111b07c:	111ea240 	call	8111ea24 <__swsetup_r>
8111b080:	1005ac1e 	bne	r2,zero,8111c734 <___vfprintf_internal_r+0x1a5c>
8111b084:	b880030b 	ldhu	r2,12(r23)
8111b088:	00c00284 	movi	r3,10
8111b08c:	1080068c 	andi	r2,r2,26
8111b090:	10ff3c1e 	bne	r2,r3,8111ad84 <__reset+0xfb0fad84>
8111b094:	b880038f 	ldh	r2,14(r23)
8111b098:	103f3a16 	blt	r2,zero,8111ad84 <__reset+0xfb0fad84>
8111b09c:	d9c02d17 	ldw	r7,180(sp)
8111b0a0:	d9002c17 	ldw	r4,176(sp)
8111b0a4:	a80d883a 	mov	r6,r21
8111b0a8:	b80b883a 	mov	r5,r23
8111b0ac:	111cef40 	call	8111cef4 <__sbprintf>
8111b0b0:	00001106 	br	8111b0f8 <___vfprintf_internal_r+0x420>
8111b0b4:	d9002c17 	ldw	r4,176(sp)
8111b0b8:	d9801e04 	addi	r6,sp,120
8111b0bc:	b80b883a 	mov	r5,r23
8111b0c0:	1126ec80 	call	81126ec8 <__sprint_r>
8111b0c4:	1000081e 	bne	r2,zero,8111b0e8 <___vfprintf_internal_r+0x410>
8111b0c8:	da000404 	addi	r8,sp,16
8111b0cc:	003f5306 	br	8111ae1c <__reset+0xfb0fae1c>
8111b0d0:	d8802017 	ldw	r2,128(sp)
8111b0d4:	10000426 	beq	r2,zero,8111b0e8 <___vfprintf_internal_r+0x410>
8111b0d8:	d9002c17 	ldw	r4,176(sp)
8111b0dc:	d9801e04 	addi	r6,sp,120
8111b0e0:	b80b883a 	mov	r5,r23
8111b0e4:	1126ec80 	call	81126ec8 <__sprint_r>
8111b0e8:	b880030b 	ldhu	r2,12(r23)
8111b0ec:	1080100c 	andi	r2,r2,64
8111b0f0:	1005901e 	bne	r2,zero,8111c734 <___vfprintf_internal_r+0x1a5c>
8111b0f4:	d8802f17 	ldw	r2,188(sp)
8111b0f8:	dfc04717 	ldw	ra,284(sp)
8111b0fc:	df004617 	ldw	fp,280(sp)
8111b100:	ddc04517 	ldw	r23,276(sp)
8111b104:	dd804417 	ldw	r22,272(sp)
8111b108:	dd404317 	ldw	r21,268(sp)
8111b10c:	dd004217 	ldw	r20,264(sp)
8111b110:	dcc04117 	ldw	r19,260(sp)
8111b114:	dc804017 	ldw	r18,256(sp)
8111b118:	dc403f17 	ldw	r17,252(sp)
8111b11c:	dc003e17 	ldw	r16,248(sp)
8111b120:	dec04804 	addi	sp,sp,288
8111b124:	f800283a 	ret
8111b128:	d9002c17 	ldw	r4,176(sp)
8111b12c:	1120a940 	call	81120a94 <__sinit>
8111b130:	003f0406 	br	8111ad44 <__reset+0xfb0fad44>
8111b134:	d8802d17 	ldw	r2,180(sp)
8111b138:	d9002d17 	ldw	r4,180(sp)
8111b13c:	10800017 	ldw	r2,0(r2)
8111b140:	d8803115 	stw	r2,196(sp)
8111b144:	20800104 	addi	r2,r4,4
8111b148:	d9003117 	ldw	r4,196(sp)
8111b14c:	203fa716 	blt	r4,zero,8111afec <__reset+0xfb0fafec>
8111b150:	d8802d15 	stw	r2,180(sp)
8111b154:	ac400007 	ldb	r17,0(r21)
8111b158:	003f4206 	br	8111ae64 <__reset+0xfb0fae64>
8111b15c:	ac400007 	ldb	r17,0(r21)
8111b160:	aac00044 	addi	r11,r21,1
8111b164:	8a872826 	beq	r17,r10,8111ce08 <___vfprintf_internal_r+0x2130>
8111b168:	88bff404 	addi	r2,r17,-48
8111b16c:	0009883a 	mov	r4,zero
8111b170:	30867d36 	bltu	r6,r2,8111cb68 <___vfprintf_internal_r+0x1e90>
8111b174:	5c400007 	ldb	r17,0(r11)
8111b178:	210002a4 	muli	r4,r4,10
8111b17c:	5d400044 	addi	r21,r11,1
8111b180:	a817883a 	mov	r11,r21
8111b184:	2089883a 	add	r4,r4,r2
8111b188:	88bff404 	addi	r2,r17,-48
8111b18c:	30bff92e 	bgeu	r6,r2,8111b174 <__reset+0xfb0fb174>
8111b190:	2005c916 	blt	r4,zero,8111c8b8 <___vfprintf_internal_r+0x1be0>
8111b194:	d9002915 	stw	r4,164(sp)
8111b198:	003f3306 	br	8111ae68 <__reset+0xfb0fae68>
8111b19c:	94802014 	ori	r18,r18,128
8111b1a0:	ac400007 	ldb	r17,0(r21)
8111b1a4:	003f2f06 	br	8111ae64 <__reset+0xfb0fae64>
8111b1a8:	a809883a 	mov	r4,r21
8111b1ac:	d8003115 	stw	zero,196(sp)
8111b1b0:	88bff404 	addi	r2,r17,-48
8111b1b4:	0017883a 	mov	r11,zero
8111b1b8:	24400007 	ldb	r17,0(r4)
8111b1bc:	5ac002a4 	muli	r11,r11,10
8111b1c0:	ad400044 	addi	r21,r21,1
8111b1c4:	a809883a 	mov	r4,r21
8111b1c8:	12d7883a 	add	r11,r2,r11
8111b1cc:	88bff404 	addi	r2,r17,-48
8111b1d0:	30bff92e 	bgeu	r6,r2,8111b1b8 <__reset+0xfb0fb1b8>
8111b1d4:	dac03115 	stw	r11,196(sp)
8111b1d8:	003f2306 	br	8111ae68 <__reset+0xfb0fae68>
8111b1dc:	18c03fcc 	andi	r3,r3,255
8111b1e0:	18072b1e 	bne	r3,zero,8111ce90 <___vfprintf_internal_r+0x21b8>
8111b1e4:	94800414 	ori	r18,r18,16
8111b1e8:	9080080c 	andi	r2,r18,32
8111b1ec:	10037b26 	beq	r2,zero,8111bfdc <___vfprintf_internal_r+0x1304>
8111b1f0:	d9402d17 	ldw	r5,180(sp)
8111b1f4:	28800117 	ldw	r2,4(r5)
8111b1f8:	2cc00017 	ldw	r19,0(r5)
8111b1fc:	29400204 	addi	r5,r5,8
8111b200:	d9402d15 	stw	r5,180(sp)
8111b204:	102d883a 	mov	r22,r2
8111b208:	10044b16 	blt	r2,zero,8111c338 <___vfprintf_internal_r+0x1660>
8111b20c:	d9402917 	ldw	r5,164(sp)
8111b210:	df002783 	ldbu	fp,158(sp)
8111b214:	2803bc16 	blt	r5,zero,8111c108 <___vfprintf_internal_r+0x1430>
8111b218:	00ffdfc4 	movi	r3,-129
8111b21c:	9d84b03a 	or	r2,r19,r22
8111b220:	90e4703a 	and	r18,r18,r3
8111b224:	10017726 	beq	r2,zero,8111b804 <___vfprintf_internal_r+0xb2c>
8111b228:	b0038326 	beq	r22,zero,8111c038 <___vfprintf_internal_r+0x1360>
8111b22c:	dc402a15 	stw	r17,168(sp)
8111b230:	dc001e04 	addi	r16,sp,120
8111b234:	b023883a 	mov	r17,r22
8111b238:	402d883a 	mov	r22,r8
8111b23c:	9809883a 	mov	r4,r19
8111b240:	880b883a 	mov	r5,r17
8111b244:	01800284 	movi	r6,10
8111b248:	000f883a 	mov	r7,zero
8111b24c:	1129c7c0 	call	81129c7c <__umoddi3>
8111b250:	10800c04 	addi	r2,r2,48
8111b254:	843fffc4 	addi	r16,r16,-1
8111b258:	9809883a 	mov	r4,r19
8111b25c:	880b883a 	mov	r5,r17
8111b260:	80800005 	stb	r2,0(r16)
8111b264:	01800284 	movi	r6,10
8111b268:	000f883a 	mov	r7,zero
8111b26c:	11296fc0 	call	811296fc <__udivdi3>
8111b270:	1027883a 	mov	r19,r2
8111b274:	10c4b03a 	or	r2,r2,r3
8111b278:	1823883a 	mov	r17,r3
8111b27c:	103fef1e 	bne	r2,zero,8111b23c <__reset+0xfb0fb23c>
8111b280:	d8c02817 	ldw	r3,160(sp)
8111b284:	dc402a17 	ldw	r17,168(sp)
8111b288:	b011883a 	mov	r8,r22
8111b28c:	1c07c83a 	sub	r3,r3,r16
8111b290:	d8c02e15 	stw	r3,184(sp)
8111b294:	00005906 	br	8111b3fc <___vfprintf_internal_r+0x724>
8111b298:	18c03fcc 	andi	r3,r3,255
8111b29c:	1806fa1e 	bne	r3,zero,8111ce88 <___vfprintf_internal_r+0x21b0>
8111b2a0:	9080020c 	andi	r2,r18,8
8111b2a4:	10048a26 	beq	r2,zero,8111c4d0 <___vfprintf_internal_r+0x17f8>
8111b2a8:	d8c02d17 	ldw	r3,180(sp)
8111b2ac:	d9002d17 	ldw	r4,180(sp)
8111b2b0:	d9402d17 	ldw	r5,180(sp)
8111b2b4:	18c00017 	ldw	r3,0(r3)
8111b2b8:	21000117 	ldw	r4,4(r4)
8111b2bc:	29400204 	addi	r5,r5,8
8111b2c0:	d8c03615 	stw	r3,216(sp)
8111b2c4:	d9003815 	stw	r4,224(sp)
8111b2c8:	d9402d15 	stw	r5,180(sp)
8111b2cc:	d9003617 	ldw	r4,216(sp)
8111b2d0:	d9403817 	ldw	r5,224(sp)
8111b2d4:	da003d15 	stw	r8,244(sp)
8111b2d8:	04000044 	movi	r16,1
8111b2dc:	112352c0 	call	8112352c <__fpclassifyd>
8111b2e0:	da003d17 	ldw	r8,244(sp)
8111b2e4:	14041f1e 	bne	r2,r16,8111c364 <___vfprintf_internal_r+0x168c>
8111b2e8:	d9003617 	ldw	r4,216(sp)
8111b2ec:	d9403817 	ldw	r5,224(sp)
8111b2f0:	000d883a 	mov	r6,zero
8111b2f4:	000f883a 	mov	r7,zero
8111b2f8:	112b8740 	call	8112b874 <__ledf2>
8111b2fc:	da003d17 	ldw	r8,244(sp)
8111b300:	1005be16 	blt	r2,zero,8111c9fc <___vfprintf_internal_r+0x1d24>
8111b304:	df002783 	ldbu	fp,158(sp)
8111b308:	008011c4 	movi	r2,71
8111b30c:	1445330e 	bge	r2,r17,8111c7dc <___vfprintf_internal_r+0x1b04>
8111b310:	04204534 	movhi	r16,33044
8111b314:	84172b04 	addi	r16,r16,23724
8111b318:	00c000c4 	movi	r3,3
8111b31c:	00bfdfc4 	movi	r2,-129
8111b320:	d8c02a15 	stw	r3,168(sp)
8111b324:	90a4703a 	and	r18,r18,r2
8111b328:	d8c02e15 	stw	r3,184(sp)
8111b32c:	d8002915 	stw	zero,164(sp)
8111b330:	d8003215 	stw	zero,200(sp)
8111b334:	00003706 	br	8111b414 <___vfprintf_internal_r+0x73c>
8111b338:	94800214 	ori	r18,r18,8
8111b33c:	ac400007 	ldb	r17,0(r21)
8111b340:	003ec806 	br	8111ae64 <__reset+0xfb0fae64>
8111b344:	18c03fcc 	andi	r3,r3,255
8111b348:	1806db1e 	bne	r3,zero,8111ceb8 <___vfprintf_internal_r+0x21e0>
8111b34c:	94800414 	ori	r18,r18,16
8111b350:	9080080c 	andi	r2,r18,32
8111b354:	1002d826 	beq	r2,zero,8111beb8 <___vfprintf_internal_r+0x11e0>
8111b358:	d9402d17 	ldw	r5,180(sp)
8111b35c:	d8c02917 	ldw	r3,164(sp)
8111b360:	d8002785 	stb	zero,158(sp)
8111b364:	28800204 	addi	r2,r5,8
8111b368:	2cc00017 	ldw	r19,0(r5)
8111b36c:	2d800117 	ldw	r22,4(r5)
8111b370:	18048f16 	blt	r3,zero,8111c5b0 <___vfprintf_internal_r+0x18d8>
8111b374:	013fdfc4 	movi	r4,-129
8111b378:	9d86b03a 	or	r3,r19,r22
8111b37c:	d8802d15 	stw	r2,180(sp)
8111b380:	9124703a 	and	r18,r18,r4
8111b384:	1802d91e 	bne	r3,zero,8111beec <___vfprintf_internal_r+0x1214>
8111b388:	d8c02917 	ldw	r3,164(sp)
8111b38c:	0039883a 	mov	fp,zero
8111b390:	1805c326 	beq	r3,zero,8111caa0 <___vfprintf_internal_r+0x1dc8>
8111b394:	0027883a 	mov	r19,zero
8111b398:	002d883a 	mov	r22,zero
8111b39c:	dc001e04 	addi	r16,sp,120
8111b3a0:	9806d0fa 	srli	r3,r19,3
8111b3a4:	b008977a 	slli	r4,r22,29
8111b3a8:	b02cd0fa 	srli	r22,r22,3
8111b3ac:	9cc001cc 	andi	r19,r19,7
8111b3b0:	98800c04 	addi	r2,r19,48
8111b3b4:	843fffc4 	addi	r16,r16,-1
8111b3b8:	20e6b03a 	or	r19,r4,r3
8111b3bc:	80800005 	stb	r2,0(r16)
8111b3c0:	9d86b03a 	or	r3,r19,r22
8111b3c4:	183ff61e 	bne	r3,zero,8111b3a0 <__reset+0xfb0fb3a0>
8111b3c8:	90c0004c 	andi	r3,r18,1
8111b3cc:	18013b26 	beq	r3,zero,8111b8bc <___vfprintf_internal_r+0xbe4>
8111b3d0:	10803fcc 	andi	r2,r2,255
8111b3d4:	1080201c 	xori	r2,r2,128
8111b3d8:	10bfe004 	addi	r2,r2,-128
8111b3dc:	00c00c04 	movi	r3,48
8111b3e0:	10c13626 	beq	r2,r3,8111b8bc <___vfprintf_internal_r+0xbe4>
8111b3e4:	80ffffc5 	stb	r3,-1(r16)
8111b3e8:	d8c02817 	ldw	r3,160(sp)
8111b3ec:	80bfffc4 	addi	r2,r16,-1
8111b3f0:	1021883a 	mov	r16,r2
8111b3f4:	1887c83a 	sub	r3,r3,r2
8111b3f8:	d8c02e15 	stw	r3,184(sp)
8111b3fc:	d8802e17 	ldw	r2,184(sp)
8111b400:	d9002917 	ldw	r4,164(sp)
8111b404:	1100010e 	bge	r2,r4,8111b40c <___vfprintf_internal_r+0x734>
8111b408:	2005883a 	mov	r2,r4
8111b40c:	d8802a15 	stw	r2,168(sp)
8111b410:	d8003215 	stw	zero,200(sp)
8111b414:	e7003fcc 	andi	fp,fp,255
8111b418:	e700201c 	xori	fp,fp,128
8111b41c:	e73fe004 	addi	fp,fp,-128
8111b420:	e0000326 	beq	fp,zero,8111b430 <___vfprintf_internal_r+0x758>
8111b424:	d8c02a17 	ldw	r3,168(sp)
8111b428:	18c00044 	addi	r3,r3,1
8111b42c:	d8c02a15 	stw	r3,168(sp)
8111b430:	90c0008c 	andi	r3,r18,2
8111b434:	d8c02b15 	stw	r3,172(sp)
8111b438:	18000326 	beq	r3,zero,8111b448 <___vfprintf_internal_r+0x770>
8111b43c:	d8c02a17 	ldw	r3,168(sp)
8111b440:	18c00084 	addi	r3,r3,2
8111b444:	d8c02a15 	stw	r3,168(sp)
8111b448:	90c0210c 	andi	r3,r18,132
8111b44c:	d8c03015 	stw	r3,192(sp)
8111b450:	1801a31e 	bne	r3,zero,8111bae0 <___vfprintf_internal_r+0xe08>
8111b454:	d9003117 	ldw	r4,196(sp)
8111b458:	d8c02a17 	ldw	r3,168(sp)
8111b45c:	20e7c83a 	sub	r19,r4,r3
8111b460:	04c19f0e 	bge	zero,r19,8111bae0 <___vfprintf_internal_r+0xe08>
8111b464:	02400404 	movi	r9,16
8111b468:	d8c02017 	ldw	r3,128(sp)
8111b46c:	d8801f17 	ldw	r2,124(sp)
8111b470:	4cc50d0e 	bge	r9,r19,8111c8a8 <___vfprintf_internal_r+0x1bd0>
8111b474:	01604534 	movhi	r5,33044
8111b478:	29574684 	addi	r5,r5,23834
8111b47c:	dc403b15 	stw	r17,236(sp)
8111b480:	d9403515 	stw	r5,212(sp)
8111b484:	9823883a 	mov	r17,r19
8111b488:	482d883a 	mov	r22,r9
8111b48c:	9027883a 	mov	r19,r18
8111b490:	070001c4 	movi	fp,7
8111b494:	8025883a 	mov	r18,r16
8111b498:	dc002c17 	ldw	r16,176(sp)
8111b49c:	00000306 	br	8111b4ac <___vfprintf_internal_r+0x7d4>
8111b4a0:	8c7ffc04 	addi	r17,r17,-16
8111b4a4:	42000204 	addi	r8,r8,8
8111b4a8:	b440130e 	bge	r22,r17,8111b4f8 <___vfprintf_internal_r+0x820>
8111b4ac:	01204534 	movhi	r4,33044
8111b4b0:	18c00404 	addi	r3,r3,16
8111b4b4:	10800044 	addi	r2,r2,1
8111b4b8:	21174684 	addi	r4,r4,23834
8111b4bc:	41000015 	stw	r4,0(r8)
8111b4c0:	45800115 	stw	r22,4(r8)
8111b4c4:	d8c02015 	stw	r3,128(sp)
8111b4c8:	d8801f15 	stw	r2,124(sp)
8111b4cc:	e0bff40e 	bge	fp,r2,8111b4a0 <__reset+0xfb0fb4a0>
8111b4d0:	d9801e04 	addi	r6,sp,120
8111b4d4:	b80b883a 	mov	r5,r23
8111b4d8:	8009883a 	mov	r4,r16
8111b4dc:	1126ec80 	call	81126ec8 <__sprint_r>
8111b4e0:	103f011e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111b4e4:	8c7ffc04 	addi	r17,r17,-16
8111b4e8:	d8c02017 	ldw	r3,128(sp)
8111b4ec:	d8801f17 	ldw	r2,124(sp)
8111b4f0:	da000404 	addi	r8,sp,16
8111b4f4:	b47fed16 	blt	r22,r17,8111b4ac <__reset+0xfb0fb4ac>
8111b4f8:	9021883a 	mov	r16,r18
8111b4fc:	9825883a 	mov	r18,r19
8111b500:	8827883a 	mov	r19,r17
8111b504:	dc403b17 	ldw	r17,236(sp)
8111b508:	d9403517 	ldw	r5,212(sp)
8111b50c:	98c7883a 	add	r3,r19,r3
8111b510:	10800044 	addi	r2,r2,1
8111b514:	41400015 	stw	r5,0(r8)
8111b518:	44c00115 	stw	r19,4(r8)
8111b51c:	d8c02015 	stw	r3,128(sp)
8111b520:	d8801f15 	stw	r2,124(sp)
8111b524:	010001c4 	movi	r4,7
8111b528:	2082a316 	blt	r4,r2,8111bfb8 <___vfprintf_internal_r+0x12e0>
8111b52c:	df002787 	ldb	fp,158(sp)
8111b530:	42000204 	addi	r8,r8,8
8111b534:	e0000c26 	beq	fp,zero,8111b568 <___vfprintf_internal_r+0x890>
8111b538:	d8801f17 	ldw	r2,124(sp)
8111b53c:	d9002784 	addi	r4,sp,158
8111b540:	18c00044 	addi	r3,r3,1
8111b544:	10800044 	addi	r2,r2,1
8111b548:	41000015 	stw	r4,0(r8)
8111b54c:	01000044 	movi	r4,1
8111b550:	41000115 	stw	r4,4(r8)
8111b554:	d8c02015 	stw	r3,128(sp)
8111b558:	d8801f15 	stw	r2,124(sp)
8111b55c:	010001c4 	movi	r4,7
8111b560:	20823c16 	blt	r4,r2,8111be54 <___vfprintf_internal_r+0x117c>
8111b564:	42000204 	addi	r8,r8,8
8111b568:	d8802b17 	ldw	r2,172(sp)
8111b56c:	10000c26 	beq	r2,zero,8111b5a0 <___vfprintf_internal_r+0x8c8>
8111b570:	d8801f17 	ldw	r2,124(sp)
8111b574:	d9002704 	addi	r4,sp,156
8111b578:	18c00084 	addi	r3,r3,2
8111b57c:	10800044 	addi	r2,r2,1
8111b580:	41000015 	stw	r4,0(r8)
8111b584:	01000084 	movi	r4,2
8111b588:	41000115 	stw	r4,4(r8)
8111b58c:	d8c02015 	stw	r3,128(sp)
8111b590:	d8801f15 	stw	r2,124(sp)
8111b594:	010001c4 	movi	r4,7
8111b598:	20823616 	blt	r4,r2,8111be74 <___vfprintf_internal_r+0x119c>
8111b59c:	42000204 	addi	r8,r8,8
8111b5a0:	d9003017 	ldw	r4,192(sp)
8111b5a4:	00802004 	movi	r2,128
8111b5a8:	20819926 	beq	r4,r2,8111bc10 <___vfprintf_internal_r+0xf38>
8111b5ac:	d9402917 	ldw	r5,164(sp)
8111b5b0:	d8802e17 	ldw	r2,184(sp)
8111b5b4:	28adc83a 	sub	r22,r5,r2
8111b5b8:	0580310e 	bge	zero,r22,8111b680 <___vfprintf_internal_r+0x9a8>
8111b5bc:	07000404 	movi	fp,16
8111b5c0:	d8801f17 	ldw	r2,124(sp)
8111b5c4:	e584140e 	bge	fp,r22,8111c618 <___vfprintf_internal_r+0x1940>
8111b5c8:	01604534 	movhi	r5,33044
8111b5cc:	29574284 	addi	r5,r5,23818
8111b5d0:	dc402915 	stw	r17,164(sp)
8111b5d4:	d9402b15 	stw	r5,172(sp)
8111b5d8:	b023883a 	mov	r17,r22
8111b5dc:	04c001c4 	movi	r19,7
8111b5e0:	a82d883a 	mov	r22,r21
8111b5e4:	902b883a 	mov	r21,r18
8111b5e8:	8025883a 	mov	r18,r16
8111b5ec:	dc002c17 	ldw	r16,176(sp)
8111b5f0:	00000306 	br	8111b600 <___vfprintf_internal_r+0x928>
8111b5f4:	8c7ffc04 	addi	r17,r17,-16
8111b5f8:	42000204 	addi	r8,r8,8
8111b5fc:	e440110e 	bge	fp,r17,8111b644 <___vfprintf_internal_r+0x96c>
8111b600:	18c00404 	addi	r3,r3,16
8111b604:	10800044 	addi	r2,r2,1
8111b608:	45000015 	stw	r20,0(r8)
8111b60c:	47000115 	stw	fp,4(r8)
8111b610:	d8c02015 	stw	r3,128(sp)
8111b614:	d8801f15 	stw	r2,124(sp)
8111b618:	98bff60e 	bge	r19,r2,8111b5f4 <__reset+0xfb0fb5f4>
8111b61c:	d9801e04 	addi	r6,sp,120
8111b620:	b80b883a 	mov	r5,r23
8111b624:	8009883a 	mov	r4,r16
8111b628:	1126ec80 	call	81126ec8 <__sprint_r>
8111b62c:	103eae1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111b630:	8c7ffc04 	addi	r17,r17,-16
8111b634:	d8c02017 	ldw	r3,128(sp)
8111b638:	d8801f17 	ldw	r2,124(sp)
8111b63c:	da000404 	addi	r8,sp,16
8111b640:	e47fef16 	blt	fp,r17,8111b600 <__reset+0xfb0fb600>
8111b644:	9021883a 	mov	r16,r18
8111b648:	a825883a 	mov	r18,r21
8111b64c:	b02b883a 	mov	r21,r22
8111b650:	882d883a 	mov	r22,r17
8111b654:	dc402917 	ldw	r17,164(sp)
8111b658:	d9002b17 	ldw	r4,172(sp)
8111b65c:	1d87883a 	add	r3,r3,r22
8111b660:	10800044 	addi	r2,r2,1
8111b664:	41000015 	stw	r4,0(r8)
8111b668:	45800115 	stw	r22,4(r8)
8111b66c:	d8c02015 	stw	r3,128(sp)
8111b670:	d8801f15 	stw	r2,124(sp)
8111b674:	010001c4 	movi	r4,7
8111b678:	2081ee16 	blt	r4,r2,8111be34 <___vfprintf_internal_r+0x115c>
8111b67c:	42000204 	addi	r8,r8,8
8111b680:	9080400c 	andi	r2,r18,256
8111b684:	1001181e 	bne	r2,zero,8111bae8 <___vfprintf_internal_r+0xe10>
8111b688:	d9402e17 	ldw	r5,184(sp)
8111b68c:	d8801f17 	ldw	r2,124(sp)
8111b690:	44000015 	stw	r16,0(r8)
8111b694:	1947883a 	add	r3,r3,r5
8111b698:	10800044 	addi	r2,r2,1
8111b69c:	41400115 	stw	r5,4(r8)
8111b6a0:	d8c02015 	stw	r3,128(sp)
8111b6a4:	d8801f15 	stw	r2,124(sp)
8111b6a8:	010001c4 	movi	r4,7
8111b6ac:	2081d316 	blt	r4,r2,8111bdfc <___vfprintf_internal_r+0x1124>
8111b6b0:	42000204 	addi	r8,r8,8
8111b6b4:	9480010c 	andi	r18,r18,4
8111b6b8:	90003226 	beq	r18,zero,8111b784 <___vfprintf_internal_r+0xaac>
8111b6bc:	d9403117 	ldw	r5,196(sp)
8111b6c0:	d8802a17 	ldw	r2,168(sp)
8111b6c4:	28a1c83a 	sub	r16,r5,r2
8111b6c8:	04002e0e 	bge	zero,r16,8111b784 <___vfprintf_internal_r+0xaac>
8111b6cc:	04400404 	movi	r17,16
8111b6d0:	d8801f17 	ldw	r2,124(sp)
8111b6d4:	8c04a20e 	bge	r17,r16,8111c960 <___vfprintf_internal_r+0x1c88>
8111b6d8:	01604534 	movhi	r5,33044
8111b6dc:	29574684 	addi	r5,r5,23834
8111b6e0:	d9403515 	stw	r5,212(sp)
8111b6e4:	048001c4 	movi	r18,7
8111b6e8:	dcc02c17 	ldw	r19,176(sp)
8111b6ec:	00000306 	br	8111b6fc <___vfprintf_internal_r+0xa24>
8111b6f0:	843ffc04 	addi	r16,r16,-16
8111b6f4:	42000204 	addi	r8,r8,8
8111b6f8:	8c00130e 	bge	r17,r16,8111b748 <___vfprintf_internal_r+0xa70>
8111b6fc:	01204534 	movhi	r4,33044
8111b700:	18c00404 	addi	r3,r3,16
8111b704:	10800044 	addi	r2,r2,1
8111b708:	21174684 	addi	r4,r4,23834
8111b70c:	41000015 	stw	r4,0(r8)
8111b710:	44400115 	stw	r17,4(r8)
8111b714:	d8c02015 	stw	r3,128(sp)
8111b718:	d8801f15 	stw	r2,124(sp)
8111b71c:	90bff40e 	bge	r18,r2,8111b6f0 <__reset+0xfb0fb6f0>
8111b720:	d9801e04 	addi	r6,sp,120
8111b724:	b80b883a 	mov	r5,r23
8111b728:	9809883a 	mov	r4,r19
8111b72c:	1126ec80 	call	81126ec8 <__sprint_r>
8111b730:	103e6d1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111b734:	843ffc04 	addi	r16,r16,-16
8111b738:	d8c02017 	ldw	r3,128(sp)
8111b73c:	d8801f17 	ldw	r2,124(sp)
8111b740:	da000404 	addi	r8,sp,16
8111b744:	8c3fed16 	blt	r17,r16,8111b6fc <__reset+0xfb0fb6fc>
8111b748:	d9403517 	ldw	r5,212(sp)
8111b74c:	1c07883a 	add	r3,r3,r16
8111b750:	10800044 	addi	r2,r2,1
8111b754:	41400015 	stw	r5,0(r8)
8111b758:	44000115 	stw	r16,4(r8)
8111b75c:	d8c02015 	stw	r3,128(sp)
8111b760:	d8801f15 	stw	r2,124(sp)
8111b764:	010001c4 	movi	r4,7
8111b768:	2080060e 	bge	r4,r2,8111b784 <___vfprintf_internal_r+0xaac>
8111b76c:	d9002c17 	ldw	r4,176(sp)
8111b770:	d9801e04 	addi	r6,sp,120
8111b774:	b80b883a 	mov	r5,r23
8111b778:	1126ec80 	call	81126ec8 <__sprint_r>
8111b77c:	103e5a1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111b780:	d8c02017 	ldw	r3,128(sp)
8111b784:	d8803117 	ldw	r2,196(sp)
8111b788:	d9002a17 	ldw	r4,168(sp)
8111b78c:	1100010e 	bge	r2,r4,8111b794 <___vfprintf_internal_r+0xabc>
8111b790:	2005883a 	mov	r2,r4
8111b794:	d9402f17 	ldw	r5,188(sp)
8111b798:	288b883a 	add	r5,r5,r2
8111b79c:	d9402f15 	stw	r5,188(sp)
8111b7a0:	18019e1e 	bne	r3,zero,8111be1c <___vfprintf_internal_r+0x1144>
8111b7a4:	a8800007 	ldb	r2,0(r21)
8111b7a8:	d8001f15 	stw	zero,124(sp)
8111b7ac:	da000404 	addi	r8,sp,16
8111b7b0:	103d851e 	bne	r2,zero,8111adc8 <__reset+0xfb0fadc8>
8111b7b4:	a821883a 	mov	r16,r21
8111b7b8:	003d9b06 	br	8111ae28 <__reset+0xfb0fae28>
8111b7bc:	18c03fcc 	andi	r3,r3,255
8111b7c0:	1805c11e 	bne	r3,zero,8111cec8 <___vfprintf_internal_r+0x21f0>
8111b7c4:	94800414 	ori	r18,r18,16
8111b7c8:	9080080c 	andi	r2,r18,32
8111b7cc:	10020c26 	beq	r2,zero,8111c000 <___vfprintf_internal_r+0x1328>
8111b7d0:	d8802d17 	ldw	r2,180(sp)
8111b7d4:	d9002917 	ldw	r4,164(sp)
8111b7d8:	d8002785 	stb	zero,158(sp)
8111b7dc:	10c00204 	addi	r3,r2,8
8111b7e0:	14c00017 	ldw	r19,0(r2)
8111b7e4:	15800117 	ldw	r22,4(r2)
8111b7e8:	20040f16 	blt	r4,zero,8111c828 <___vfprintf_internal_r+0x1b50>
8111b7ec:	013fdfc4 	movi	r4,-129
8111b7f0:	9d84b03a 	or	r2,r19,r22
8111b7f4:	d8c02d15 	stw	r3,180(sp)
8111b7f8:	9124703a 	and	r18,r18,r4
8111b7fc:	0039883a 	mov	fp,zero
8111b800:	103e891e 	bne	r2,zero,8111b228 <__reset+0xfb0fb228>
8111b804:	d9002917 	ldw	r4,164(sp)
8111b808:	2002c11e 	bne	r4,zero,8111c310 <___vfprintf_internal_r+0x1638>
8111b80c:	d8002915 	stw	zero,164(sp)
8111b810:	d8002e15 	stw	zero,184(sp)
8111b814:	dc001e04 	addi	r16,sp,120
8111b818:	003ef806 	br	8111b3fc <__reset+0xfb0fb3fc>
8111b81c:	18c03fcc 	andi	r3,r3,255
8111b820:	18059d1e 	bne	r3,zero,8111ce98 <___vfprintf_internal_r+0x21c0>
8111b824:	01604534 	movhi	r5,33044
8111b828:	29572e04 	addi	r5,r5,23736
8111b82c:	d9403915 	stw	r5,228(sp)
8111b830:	9080080c 	andi	r2,r18,32
8111b834:	10005226 	beq	r2,zero,8111b980 <___vfprintf_internal_r+0xca8>
8111b838:	d8802d17 	ldw	r2,180(sp)
8111b83c:	14c00017 	ldw	r19,0(r2)
8111b840:	15800117 	ldw	r22,4(r2)
8111b844:	10800204 	addi	r2,r2,8
8111b848:	d8802d15 	stw	r2,180(sp)
8111b84c:	9080004c 	andi	r2,r18,1
8111b850:	10019026 	beq	r2,zero,8111be94 <___vfprintf_internal_r+0x11bc>
8111b854:	9d84b03a 	or	r2,r19,r22
8111b858:	10036926 	beq	r2,zero,8111c600 <___vfprintf_internal_r+0x1928>
8111b85c:	d8c02917 	ldw	r3,164(sp)
8111b860:	00800c04 	movi	r2,48
8111b864:	d8802705 	stb	r2,156(sp)
8111b868:	dc402745 	stb	r17,157(sp)
8111b86c:	d8002785 	stb	zero,158(sp)
8111b870:	90800094 	ori	r2,r18,2
8111b874:	18045d16 	blt	r3,zero,8111c9ec <___vfprintf_internal_r+0x1d14>
8111b878:	00bfdfc4 	movi	r2,-129
8111b87c:	90a4703a 	and	r18,r18,r2
8111b880:	94800094 	ori	r18,r18,2
8111b884:	0039883a 	mov	fp,zero
8111b888:	d9003917 	ldw	r4,228(sp)
8111b88c:	dc001e04 	addi	r16,sp,120
8111b890:	988003cc 	andi	r2,r19,15
8111b894:	b006973a 	slli	r3,r22,28
8111b898:	2085883a 	add	r2,r4,r2
8111b89c:	9826d13a 	srli	r19,r19,4
8111b8a0:	10800003 	ldbu	r2,0(r2)
8111b8a4:	b02cd13a 	srli	r22,r22,4
8111b8a8:	843fffc4 	addi	r16,r16,-1
8111b8ac:	1ce6b03a 	or	r19,r3,r19
8111b8b0:	80800005 	stb	r2,0(r16)
8111b8b4:	9d84b03a 	or	r2,r19,r22
8111b8b8:	103ff51e 	bne	r2,zero,8111b890 <__reset+0xfb0fb890>
8111b8bc:	d8c02817 	ldw	r3,160(sp)
8111b8c0:	1c07c83a 	sub	r3,r3,r16
8111b8c4:	d8c02e15 	stw	r3,184(sp)
8111b8c8:	003ecc06 	br	8111b3fc <__reset+0xfb0fb3fc>
8111b8cc:	18c03fcc 	andi	r3,r3,255
8111b8d0:	183e9f26 	beq	r3,zero,8111b350 <__reset+0xfb0fb350>
8111b8d4:	d9c02785 	stb	r7,158(sp)
8111b8d8:	003e9d06 	br	8111b350 <__reset+0xfb0fb350>
8111b8dc:	00c00044 	movi	r3,1
8111b8e0:	01c00ac4 	movi	r7,43
8111b8e4:	ac400007 	ldb	r17,0(r21)
8111b8e8:	003d5e06 	br	8111ae64 <__reset+0xfb0fae64>
8111b8ec:	94800814 	ori	r18,r18,32
8111b8f0:	ac400007 	ldb	r17,0(r21)
8111b8f4:	003d5b06 	br	8111ae64 <__reset+0xfb0fae64>
8111b8f8:	d8c02d17 	ldw	r3,180(sp)
8111b8fc:	d8002785 	stb	zero,158(sp)
8111b900:	1c000017 	ldw	r16,0(r3)
8111b904:	1cc00104 	addi	r19,r3,4
8111b908:	80041926 	beq	r16,zero,8111c970 <___vfprintf_internal_r+0x1c98>
8111b90c:	d9002917 	ldw	r4,164(sp)
8111b910:	2003d016 	blt	r4,zero,8111c854 <___vfprintf_internal_r+0x1b7c>
8111b914:	200d883a 	mov	r6,r4
8111b918:	000b883a 	mov	r5,zero
8111b91c:	8009883a 	mov	r4,r16
8111b920:	da003d15 	stw	r8,244(sp)
8111b924:	1121cbc0 	call	81121cbc <memchr>
8111b928:	da003d17 	ldw	r8,244(sp)
8111b92c:	10045426 	beq	r2,zero,8111ca80 <___vfprintf_internal_r+0x1da8>
8111b930:	1405c83a 	sub	r2,r2,r16
8111b934:	d8802e15 	stw	r2,184(sp)
8111b938:	1003cc16 	blt	r2,zero,8111c86c <___vfprintf_internal_r+0x1b94>
8111b93c:	df002783 	ldbu	fp,158(sp)
8111b940:	d8802a15 	stw	r2,168(sp)
8111b944:	dcc02d15 	stw	r19,180(sp)
8111b948:	d8002915 	stw	zero,164(sp)
8111b94c:	d8003215 	stw	zero,200(sp)
8111b950:	003eb006 	br	8111b414 <__reset+0xfb0fb414>
8111b954:	18c03fcc 	andi	r3,r3,255
8111b958:	183f9b26 	beq	r3,zero,8111b7c8 <__reset+0xfb0fb7c8>
8111b95c:	d9c02785 	stb	r7,158(sp)
8111b960:	003f9906 	br	8111b7c8 <__reset+0xfb0fb7c8>
8111b964:	18c03fcc 	andi	r3,r3,255
8111b968:	1805551e 	bne	r3,zero,8111cec0 <___vfprintf_internal_r+0x21e8>
8111b96c:	01604534 	movhi	r5,33044
8111b970:	29573304 	addi	r5,r5,23756
8111b974:	d9403915 	stw	r5,228(sp)
8111b978:	9080080c 	andi	r2,r18,32
8111b97c:	103fae1e 	bne	r2,zero,8111b838 <__reset+0xfb0fb838>
8111b980:	9080040c 	andi	r2,r18,16
8111b984:	1002de26 	beq	r2,zero,8111c500 <___vfprintf_internal_r+0x1828>
8111b988:	d8c02d17 	ldw	r3,180(sp)
8111b98c:	002d883a 	mov	r22,zero
8111b990:	1cc00017 	ldw	r19,0(r3)
8111b994:	18c00104 	addi	r3,r3,4
8111b998:	d8c02d15 	stw	r3,180(sp)
8111b99c:	003fab06 	br	8111b84c <__reset+0xfb0fb84c>
8111b9a0:	38803fcc 	andi	r2,r7,255
8111b9a4:	1080201c 	xori	r2,r2,128
8111b9a8:	10bfe004 	addi	r2,r2,-128
8111b9ac:	1002d21e 	bne	r2,zero,8111c4f8 <___vfprintf_internal_r+0x1820>
8111b9b0:	00c00044 	movi	r3,1
8111b9b4:	01c00804 	movi	r7,32
8111b9b8:	ac400007 	ldb	r17,0(r21)
8111b9bc:	003d2906 	br	8111ae64 <__reset+0xfb0fae64>
8111b9c0:	94800054 	ori	r18,r18,1
8111b9c4:	ac400007 	ldb	r17,0(r21)
8111b9c8:	003d2606 	br	8111ae64 <__reset+0xfb0fae64>
8111b9cc:	18c03fcc 	andi	r3,r3,255
8111b9d0:	183e0526 	beq	r3,zero,8111b1e8 <__reset+0xfb0fb1e8>
8111b9d4:	d9c02785 	stb	r7,158(sp)
8111b9d8:	003e0306 	br	8111b1e8 <__reset+0xfb0fb1e8>
8111b9dc:	94801014 	ori	r18,r18,64
8111b9e0:	ac400007 	ldb	r17,0(r21)
8111b9e4:	003d1f06 	br	8111ae64 <__reset+0xfb0fae64>
8111b9e8:	ac400007 	ldb	r17,0(r21)
8111b9ec:	8a438726 	beq	r17,r9,8111c80c <___vfprintf_internal_r+0x1b34>
8111b9f0:	94800414 	ori	r18,r18,16
8111b9f4:	003d1b06 	br	8111ae64 <__reset+0xfb0fae64>
8111b9f8:	18c03fcc 	andi	r3,r3,255
8111b9fc:	1805341e 	bne	r3,zero,8111ced0 <___vfprintf_internal_r+0x21f8>
8111ba00:	9080080c 	andi	r2,r18,32
8111ba04:	1002cd26 	beq	r2,zero,8111c53c <___vfprintf_internal_r+0x1864>
8111ba08:	d9402d17 	ldw	r5,180(sp)
8111ba0c:	d9002f17 	ldw	r4,188(sp)
8111ba10:	28800017 	ldw	r2,0(r5)
8111ba14:	2007d7fa 	srai	r3,r4,31
8111ba18:	29400104 	addi	r5,r5,4
8111ba1c:	d9402d15 	stw	r5,180(sp)
8111ba20:	11000015 	stw	r4,0(r2)
8111ba24:	10c00115 	stw	r3,4(r2)
8111ba28:	003ce506 	br	8111adc0 <__reset+0xfb0fadc0>
8111ba2c:	d8c02d17 	ldw	r3,180(sp)
8111ba30:	d9002d17 	ldw	r4,180(sp)
8111ba34:	d8002785 	stb	zero,158(sp)
8111ba38:	18800017 	ldw	r2,0(r3)
8111ba3c:	21000104 	addi	r4,r4,4
8111ba40:	00c00044 	movi	r3,1
8111ba44:	d8c02a15 	stw	r3,168(sp)
8111ba48:	d8801405 	stb	r2,80(sp)
8111ba4c:	d9002d15 	stw	r4,180(sp)
8111ba50:	d8c02e15 	stw	r3,184(sp)
8111ba54:	d8002915 	stw	zero,164(sp)
8111ba58:	d8003215 	stw	zero,200(sp)
8111ba5c:	dc001404 	addi	r16,sp,80
8111ba60:	0039883a 	mov	fp,zero
8111ba64:	003e7206 	br	8111b430 <__reset+0xfb0fb430>
8111ba68:	01204534 	movhi	r4,33044
8111ba6c:	21173304 	addi	r4,r4,23756
8111ba70:	0039883a 	mov	fp,zero
8111ba74:	d9003915 	stw	r4,228(sp)
8111ba78:	04401e04 	movi	r17,120
8111ba7c:	003f8206 	br	8111b888 <__reset+0xfb0fb888>
8111ba80:	18c03fcc 	andi	r3,r3,255
8111ba84:	1805061e 	bne	r3,zero,8111cea0 <___vfprintf_internal_r+0x21c8>
8111ba88:	883d9126 	beq	r17,zero,8111b0d0 <__reset+0xfb0fb0d0>
8111ba8c:	00c00044 	movi	r3,1
8111ba90:	d8c02a15 	stw	r3,168(sp)
8111ba94:	dc401405 	stb	r17,80(sp)
8111ba98:	d8002785 	stb	zero,158(sp)
8111ba9c:	003fec06 	br	8111ba50 <__reset+0xfb0fba50>
8111baa0:	01604534 	movhi	r5,33044
8111baa4:	29573304 	addi	r5,r5,23756
8111baa8:	d9403915 	stw	r5,228(sp)
8111baac:	d8c02d15 	stw	r3,180(sp)
8111bab0:	1025883a 	mov	r18,r2
8111bab4:	04401e04 	movi	r17,120
8111bab8:	9d84b03a 	or	r2,r19,r22
8111babc:	1000fc1e 	bne	r2,zero,8111beb0 <___vfprintf_internal_r+0x11d8>
8111bac0:	0039883a 	mov	fp,zero
8111bac4:	00800084 	movi	r2,2
8111bac8:	10803fcc 	andi	r2,r2,255
8111bacc:	00c00044 	movi	r3,1
8111bad0:	10c20f26 	beq	r2,r3,8111c310 <___vfprintf_internal_r+0x1638>
8111bad4:	00c00084 	movi	r3,2
8111bad8:	10fd6326 	beq	r2,r3,8111b068 <__reset+0xfb0fb068>
8111badc:	003e2d06 	br	8111b394 <__reset+0xfb0fb394>
8111bae0:	d8c02017 	ldw	r3,128(sp)
8111bae4:	003e9306 	br	8111b534 <__reset+0xfb0fb534>
8111bae8:	00801944 	movi	r2,101
8111baec:	14407e0e 	bge	r2,r17,8111bce8 <___vfprintf_internal_r+0x1010>
8111baf0:	d9003617 	ldw	r4,216(sp)
8111baf4:	d9403817 	ldw	r5,224(sp)
8111baf8:	000d883a 	mov	r6,zero
8111bafc:	000f883a 	mov	r7,zero
8111bb00:	d8c03c15 	stw	r3,240(sp)
8111bb04:	da003d15 	stw	r8,244(sp)
8111bb08:	112b7100 	call	8112b710 <__eqdf2>
8111bb0c:	d8c03c17 	ldw	r3,240(sp)
8111bb10:	da003d17 	ldw	r8,244(sp)
8111bb14:	1000f71e 	bne	r2,zero,8111bef4 <___vfprintf_internal_r+0x121c>
8111bb18:	d8801f17 	ldw	r2,124(sp)
8111bb1c:	01204534 	movhi	r4,33044
8111bb20:	21173a04 	addi	r4,r4,23784
8111bb24:	18c00044 	addi	r3,r3,1
8111bb28:	10800044 	addi	r2,r2,1
8111bb2c:	41000015 	stw	r4,0(r8)
8111bb30:	01000044 	movi	r4,1
8111bb34:	41000115 	stw	r4,4(r8)
8111bb38:	d8c02015 	stw	r3,128(sp)
8111bb3c:	d8801f15 	stw	r2,124(sp)
8111bb40:	010001c4 	movi	r4,7
8111bb44:	2082b816 	blt	r4,r2,8111c628 <___vfprintf_internal_r+0x1950>
8111bb48:	42000204 	addi	r8,r8,8
8111bb4c:	d8802617 	ldw	r2,152(sp)
8111bb50:	d9403317 	ldw	r5,204(sp)
8111bb54:	11400216 	blt	r2,r5,8111bb60 <___vfprintf_internal_r+0xe88>
8111bb58:	9080004c 	andi	r2,r18,1
8111bb5c:	103ed526 	beq	r2,zero,8111b6b4 <__reset+0xfb0fb6b4>
8111bb60:	d8803717 	ldw	r2,220(sp)
8111bb64:	d9003417 	ldw	r4,208(sp)
8111bb68:	d9403717 	ldw	r5,220(sp)
8111bb6c:	1887883a 	add	r3,r3,r2
8111bb70:	d8801f17 	ldw	r2,124(sp)
8111bb74:	41000015 	stw	r4,0(r8)
8111bb78:	41400115 	stw	r5,4(r8)
8111bb7c:	10800044 	addi	r2,r2,1
8111bb80:	d8c02015 	stw	r3,128(sp)
8111bb84:	d8801f15 	stw	r2,124(sp)
8111bb88:	010001c4 	movi	r4,7
8111bb8c:	20832916 	blt	r4,r2,8111c834 <___vfprintf_internal_r+0x1b5c>
8111bb90:	42000204 	addi	r8,r8,8
8111bb94:	d8803317 	ldw	r2,204(sp)
8111bb98:	143fffc4 	addi	r16,r2,-1
8111bb9c:	043ec50e 	bge	zero,r16,8111b6b4 <__reset+0xfb0fb6b4>
8111bba0:	04400404 	movi	r17,16
8111bba4:	d8801f17 	ldw	r2,124(sp)
8111bba8:	8c00880e 	bge	r17,r16,8111bdcc <___vfprintf_internal_r+0x10f4>
8111bbac:	01604534 	movhi	r5,33044
8111bbb0:	29574284 	addi	r5,r5,23818
8111bbb4:	d9402b15 	stw	r5,172(sp)
8111bbb8:	058001c4 	movi	r22,7
8111bbbc:	dcc02c17 	ldw	r19,176(sp)
8111bbc0:	00000306 	br	8111bbd0 <___vfprintf_internal_r+0xef8>
8111bbc4:	42000204 	addi	r8,r8,8
8111bbc8:	843ffc04 	addi	r16,r16,-16
8111bbcc:	8c00820e 	bge	r17,r16,8111bdd8 <___vfprintf_internal_r+0x1100>
8111bbd0:	18c00404 	addi	r3,r3,16
8111bbd4:	10800044 	addi	r2,r2,1
8111bbd8:	45000015 	stw	r20,0(r8)
8111bbdc:	44400115 	stw	r17,4(r8)
8111bbe0:	d8c02015 	stw	r3,128(sp)
8111bbe4:	d8801f15 	stw	r2,124(sp)
8111bbe8:	b0bff60e 	bge	r22,r2,8111bbc4 <__reset+0xfb0fbbc4>
8111bbec:	d9801e04 	addi	r6,sp,120
8111bbf0:	b80b883a 	mov	r5,r23
8111bbf4:	9809883a 	mov	r4,r19
8111bbf8:	1126ec80 	call	81126ec8 <__sprint_r>
8111bbfc:	103d3a1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111bc00:	d8c02017 	ldw	r3,128(sp)
8111bc04:	d8801f17 	ldw	r2,124(sp)
8111bc08:	da000404 	addi	r8,sp,16
8111bc0c:	003fee06 	br	8111bbc8 <__reset+0xfb0fbbc8>
8111bc10:	d9403117 	ldw	r5,196(sp)
8111bc14:	d8802a17 	ldw	r2,168(sp)
8111bc18:	28adc83a 	sub	r22,r5,r2
8111bc1c:	05be630e 	bge	zero,r22,8111b5ac <__reset+0xfb0fb5ac>
8111bc20:	07000404 	movi	fp,16
8111bc24:	d8801f17 	ldw	r2,124(sp)
8111bc28:	e5838f0e 	bge	fp,r22,8111ca68 <___vfprintf_internal_r+0x1d90>
8111bc2c:	01604534 	movhi	r5,33044
8111bc30:	29574284 	addi	r5,r5,23818
8111bc34:	dc403015 	stw	r17,192(sp)
8111bc38:	d9402b15 	stw	r5,172(sp)
8111bc3c:	b023883a 	mov	r17,r22
8111bc40:	04c001c4 	movi	r19,7
8111bc44:	a82d883a 	mov	r22,r21
8111bc48:	902b883a 	mov	r21,r18
8111bc4c:	8025883a 	mov	r18,r16
8111bc50:	dc002c17 	ldw	r16,176(sp)
8111bc54:	00000306 	br	8111bc64 <___vfprintf_internal_r+0xf8c>
8111bc58:	8c7ffc04 	addi	r17,r17,-16
8111bc5c:	42000204 	addi	r8,r8,8
8111bc60:	e440110e 	bge	fp,r17,8111bca8 <___vfprintf_internal_r+0xfd0>
8111bc64:	18c00404 	addi	r3,r3,16
8111bc68:	10800044 	addi	r2,r2,1
8111bc6c:	45000015 	stw	r20,0(r8)
8111bc70:	47000115 	stw	fp,4(r8)
8111bc74:	d8c02015 	stw	r3,128(sp)
8111bc78:	d8801f15 	stw	r2,124(sp)
8111bc7c:	98bff60e 	bge	r19,r2,8111bc58 <__reset+0xfb0fbc58>
8111bc80:	d9801e04 	addi	r6,sp,120
8111bc84:	b80b883a 	mov	r5,r23
8111bc88:	8009883a 	mov	r4,r16
8111bc8c:	1126ec80 	call	81126ec8 <__sprint_r>
8111bc90:	103d151e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111bc94:	8c7ffc04 	addi	r17,r17,-16
8111bc98:	d8c02017 	ldw	r3,128(sp)
8111bc9c:	d8801f17 	ldw	r2,124(sp)
8111bca0:	da000404 	addi	r8,sp,16
8111bca4:	e47fef16 	blt	fp,r17,8111bc64 <__reset+0xfb0fbc64>
8111bca8:	9021883a 	mov	r16,r18
8111bcac:	a825883a 	mov	r18,r21
8111bcb0:	b02b883a 	mov	r21,r22
8111bcb4:	882d883a 	mov	r22,r17
8111bcb8:	dc403017 	ldw	r17,192(sp)
8111bcbc:	d9002b17 	ldw	r4,172(sp)
8111bcc0:	1d87883a 	add	r3,r3,r22
8111bcc4:	10800044 	addi	r2,r2,1
8111bcc8:	41000015 	stw	r4,0(r8)
8111bccc:	45800115 	stw	r22,4(r8)
8111bcd0:	d8c02015 	stw	r3,128(sp)
8111bcd4:	d8801f15 	stw	r2,124(sp)
8111bcd8:	010001c4 	movi	r4,7
8111bcdc:	20818e16 	blt	r4,r2,8111c318 <___vfprintf_internal_r+0x1640>
8111bce0:	42000204 	addi	r8,r8,8
8111bce4:	003e3106 	br	8111b5ac <__reset+0xfb0fb5ac>
8111bce8:	d9403317 	ldw	r5,204(sp)
8111bcec:	00800044 	movi	r2,1
8111bcf0:	18c00044 	addi	r3,r3,1
8111bcf4:	1141530e 	bge	r2,r5,8111c244 <___vfprintf_internal_r+0x156c>
8111bcf8:	dc401f17 	ldw	r17,124(sp)
8111bcfc:	00800044 	movi	r2,1
8111bd00:	40800115 	stw	r2,4(r8)
8111bd04:	8c400044 	addi	r17,r17,1
8111bd08:	44000015 	stw	r16,0(r8)
8111bd0c:	d8c02015 	stw	r3,128(sp)
8111bd10:	dc401f15 	stw	r17,124(sp)
8111bd14:	008001c4 	movi	r2,7
8111bd18:	14416b16 	blt	r2,r17,8111c2c8 <___vfprintf_internal_r+0x15f0>
8111bd1c:	42000204 	addi	r8,r8,8
8111bd20:	d8803717 	ldw	r2,220(sp)
8111bd24:	d9003417 	ldw	r4,208(sp)
8111bd28:	8c400044 	addi	r17,r17,1
8111bd2c:	10c7883a 	add	r3,r2,r3
8111bd30:	40800115 	stw	r2,4(r8)
8111bd34:	41000015 	stw	r4,0(r8)
8111bd38:	d8c02015 	stw	r3,128(sp)
8111bd3c:	dc401f15 	stw	r17,124(sp)
8111bd40:	008001c4 	movi	r2,7
8111bd44:	14416916 	blt	r2,r17,8111c2ec <___vfprintf_internal_r+0x1614>
8111bd48:	45800204 	addi	r22,r8,8
8111bd4c:	d9003617 	ldw	r4,216(sp)
8111bd50:	d9403817 	ldw	r5,224(sp)
8111bd54:	000d883a 	mov	r6,zero
8111bd58:	000f883a 	mov	r7,zero
8111bd5c:	d8c03c15 	stw	r3,240(sp)
8111bd60:	112b7100 	call	8112b710 <__eqdf2>
8111bd64:	d8c03c17 	ldw	r3,240(sp)
8111bd68:	1000bc26 	beq	r2,zero,8111c05c <___vfprintf_internal_r+0x1384>
8111bd6c:	d9403317 	ldw	r5,204(sp)
8111bd70:	84000044 	addi	r16,r16,1
8111bd74:	8c400044 	addi	r17,r17,1
8111bd78:	28bfffc4 	addi	r2,r5,-1
8111bd7c:	1887883a 	add	r3,r3,r2
8111bd80:	b0800115 	stw	r2,4(r22)
8111bd84:	b4000015 	stw	r16,0(r22)
8111bd88:	d8c02015 	stw	r3,128(sp)
8111bd8c:	dc401f15 	stw	r17,124(sp)
8111bd90:	008001c4 	movi	r2,7
8111bd94:	14414316 	blt	r2,r17,8111c2a4 <___vfprintf_internal_r+0x15cc>
8111bd98:	b5800204 	addi	r22,r22,8
8111bd9c:	d9003a17 	ldw	r4,232(sp)
8111bda0:	df0022c4 	addi	fp,sp,139
8111bda4:	8c400044 	addi	r17,r17,1
8111bda8:	20c7883a 	add	r3,r4,r3
8111bdac:	b7000015 	stw	fp,0(r22)
8111bdb0:	b1000115 	stw	r4,4(r22)
8111bdb4:	d8c02015 	stw	r3,128(sp)
8111bdb8:	dc401f15 	stw	r17,124(sp)
8111bdbc:	008001c4 	movi	r2,7
8111bdc0:	14400e16 	blt	r2,r17,8111bdfc <___vfprintf_internal_r+0x1124>
8111bdc4:	b2000204 	addi	r8,r22,8
8111bdc8:	003e3a06 	br	8111b6b4 <__reset+0xfb0fb6b4>
8111bdcc:	01204534 	movhi	r4,33044
8111bdd0:	21174284 	addi	r4,r4,23818
8111bdd4:	d9002b15 	stw	r4,172(sp)
8111bdd8:	d9002b17 	ldw	r4,172(sp)
8111bddc:	1c07883a 	add	r3,r3,r16
8111bde0:	44000115 	stw	r16,4(r8)
8111bde4:	41000015 	stw	r4,0(r8)
8111bde8:	10800044 	addi	r2,r2,1
8111bdec:	d8c02015 	stw	r3,128(sp)
8111bdf0:	d8801f15 	stw	r2,124(sp)
8111bdf4:	010001c4 	movi	r4,7
8111bdf8:	20be2d0e 	bge	r4,r2,8111b6b0 <__reset+0xfb0fb6b0>
8111bdfc:	d9002c17 	ldw	r4,176(sp)
8111be00:	d9801e04 	addi	r6,sp,120
8111be04:	b80b883a 	mov	r5,r23
8111be08:	1126ec80 	call	81126ec8 <__sprint_r>
8111be0c:	103cb61e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111be10:	d8c02017 	ldw	r3,128(sp)
8111be14:	da000404 	addi	r8,sp,16
8111be18:	003e2606 	br	8111b6b4 <__reset+0xfb0fb6b4>
8111be1c:	d9002c17 	ldw	r4,176(sp)
8111be20:	d9801e04 	addi	r6,sp,120
8111be24:	b80b883a 	mov	r5,r23
8111be28:	1126ec80 	call	81126ec8 <__sprint_r>
8111be2c:	103e5d26 	beq	r2,zero,8111b7a4 <__reset+0xfb0fb7a4>
8111be30:	003cad06 	br	8111b0e8 <__reset+0xfb0fb0e8>
8111be34:	d9002c17 	ldw	r4,176(sp)
8111be38:	d9801e04 	addi	r6,sp,120
8111be3c:	b80b883a 	mov	r5,r23
8111be40:	1126ec80 	call	81126ec8 <__sprint_r>
8111be44:	103ca81e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111be48:	d8c02017 	ldw	r3,128(sp)
8111be4c:	da000404 	addi	r8,sp,16
8111be50:	003e0b06 	br	8111b680 <__reset+0xfb0fb680>
8111be54:	d9002c17 	ldw	r4,176(sp)
8111be58:	d9801e04 	addi	r6,sp,120
8111be5c:	b80b883a 	mov	r5,r23
8111be60:	1126ec80 	call	81126ec8 <__sprint_r>
8111be64:	103ca01e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111be68:	d8c02017 	ldw	r3,128(sp)
8111be6c:	da000404 	addi	r8,sp,16
8111be70:	003dbd06 	br	8111b568 <__reset+0xfb0fb568>
8111be74:	d9002c17 	ldw	r4,176(sp)
8111be78:	d9801e04 	addi	r6,sp,120
8111be7c:	b80b883a 	mov	r5,r23
8111be80:	1126ec80 	call	81126ec8 <__sprint_r>
8111be84:	103c981e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111be88:	d8c02017 	ldw	r3,128(sp)
8111be8c:	da000404 	addi	r8,sp,16
8111be90:	003dc306 	br	8111b5a0 <__reset+0xfb0fb5a0>
8111be94:	d8802917 	ldw	r2,164(sp)
8111be98:	d8002785 	stb	zero,158(sp)
8111be9c:	103f0616 	blt	r2,zero,8111bab8 <__reset+0xfb0fbab8>
8111bea0:	00ffdfc4 	movi	r3,-129
8111bea4:	9d84b03a 	or	r2,r19,r22
8111bea8:	90e4703a 	and	r18,r18,r3
8111beac:	103c6b26 	beq	r2,zero,8111b05c <__reset+0xfb0fb05c>
8111beb0:	0039883a 	mov	fp,zero
8111beb4:	003e7406 	br	8111b888 <__reset+0xfb0fb888>
8111beb8:	9080040c 	andi	r2,r18,16
8111bebc:	1001b326 	beq	r2,zero,8111c58c <___vfprintf_internal_r+0x18b4>
8111bec0:	d9002d17 	ldw	r4,180(sp)
8111bec4:	d9402917 	ldw	r5,164(sp)
8111bec8:	d8002785 	stb	zero,158(sp)
8111becc:	20800104 	addi	r2,r4,4
8111bed0:	24c00017 	ldw	r19,0(r4)
8111bed4:	002d883a 	mov	r22,zero
8111bed8:	2801b516 	blt	r5,zero,8111c5b0 <___vfprintf_internal_r+0x18d8>
8111bedc:	00ffdfc4 	movi	r3,-129
8111bee0:	d8802d15 	stw	r2,180(sp)
8111bee4:	90e4703a 	and	r18,r18,r3
8111bee8:	983d2726 	beq	r19,zero,8111b388 <__reset+0xfb0fb388>
8111beec:	0039883a 	mov	fp,zero
8111bef0:	003d2a06 	br	8111b39c <__reset+0xfb0fb39c>
8111bef4:	dc402617 	ldw	r17,152(sp)
8111bef8:	0441d30e 	bge	zero,r17,8111c648 <___vfprintf_internal_r+0x1970>
8111befc:	dc403217 	ldw	r17,200(sp)
8111bf00:	d8803317 	ldw	r2,204(sp)
8111bf04:	1440010e 	bge	r2,r17,8111bf0c <___vfprintf_internal_r+0x1234>
8111bf08:	1023883a 	mov	r17,r2
8111bf0c:	04400a0e 	bge	zero,r17,8111bf38 <___vfprintf_internal_r+0x1260>
8111bf10:	d8801f17 	ldw	r2,124(sp)
8111bf14:	1c47883a 	add	r3,r3,r17
8111bf18:	44000015 	stw	r16,0(r8)
8111bf1c:	10800044 	addi	r2,r2,1
8111bf20:	44400115 	stw	r17,4(r8)
8111bf24:	d8c02015 	stw	r3,128(sp)
8111bf28:	d8801f15 	stw	r2,124(sp)
8111bf2c:	010001c4 	movi	r4,7
8111bf30:	20826516 	blt	r4,r2,8111c8c8 <___vfprintf_internal_r+0x1bf0>
8111bf34:	42000204 	addi	r8,r8,8
8111bf38:	88026116 	blt	r17,zero,8111c8c0 <___vfprintf_internal_r+0x1be8>
8111bf3c:	d9003217 	ldw	r4,200(sp)
8111bf40:	2463c83a 	sub	r17,r4,r17
8111bf44:	04407b0e 	bge	zero,r17,8111c134 <___vfprintf_internal_r+0x145c>
8111bf48:	05800404 	movi	r22,16
8111bf4c:	d8801f17 	ldw	r2,124(sp)
8111bf50:	b4419d0e 	bge	r22,r17,8111c5c8 <___vfprintf_internal_r+0x18f0>
8111bf54:	01204534 	movhi	r4,33044
8111bf58:	21174284 	addi	r4,r4,23818
8111bf5c:	d9002b15 	stw	r4,172(sp)
8111bf60:	070001c4 	movi	fp,7
8111bf64:	dcc02c17 	ldw	r19,176(sp)
8111bf68:	00000306 	br	8111bf78 <___vfprintf_internal_r+0x12a0>
8111bf6c:	42000204 	addi	r8,r8,8
8111bf70:	8c7ffc04 	addi	r17,r17,-16
8111bf74:	b441970e 	bge	r22,r17,8111c5d4 <___vfprintf_internal_r+0x18fc>
8111bf78:	18c00404 	addi	r3,r3,16
8111bf7c:	10800044 	addi	r2,r2,1
8111bf80:	45000015 	stw	r20,0(r8)
8111bf84:	45800115 	stw	r22,4(r8)
8111bf88:	d8c02015 	stw	r3,128(sp)
8111bf8c:	d8801f15 	stw	r2,124(sp)
8111bf90:	e0bff60e 	bge	fp,r2,8111bf6c <__reset+0xfb0fbf6c>
8111bf94:	d9801e04 	addi	r6,sp,120
8111bf98:	b80b883a 	mov	r5,r23
8111bf9c:	9809883a 	mov	r4,r19
8111bfa0:	1126ec80 	call	81126ec8 <__sprint_r>
8111bfa4:	103c501e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111bfa8:	d8c02017 	ldw	r3,128(sp)
8111bfac:	d8801f17 	ldw	r2,124(sp)
8111bfb0:	da000404 	addi	r8,sp,16
8111bfb4:	003fee06 	br	8111bf70 <__reset+0xfb0fbf70>
8111bfb8:	d9002c17 	ldw	r4,176(sp)
8111bfbc:	d9801e04 	addi	r6,sp,120
8111bfc0:	b80b883a 	mov	r5,r23
8111bfc4:	1126ec80 	call	81126ec8 <__sprint_r>
8111bfc8:	103c471e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111bfcc:	d8c02017 	ldw	r3,128(sp)
8111bfd0:	df002787 	ldb	fp,158(sp)
8111bfd4:	da000404 	addi	r8,sp,16
8111bfd8:	003d5606 	br	8111b534 <__reset+0xfb0fb534>
8111bfdc:	9080040c 	andi	r2,r18,16
8111bfe0:	10016126 	beq	r2,zero,8111c568 <___vfprintf_internal_r+0x1890>
8111bfe4:	d8802d17 	ldw	r2,180(sp)
8111bfe8:	14c00017 	ldw	r19,0(r2)
8111bfec:	10800104 	addi	r2,r2,4
8111bff0:	d8802d15 	stw	r2,180(sp)
8111bff4:	982dd7fa 	srai	r22,r19,31
8111bff8:	b005883a 	mov	r2,r22
8111bffc:	003c8206 	br	8111b208 <__reset+0xfb0fb208>
8111c000:	9080040c 	andi	r2,r18,16
8111c004:	10003526 	beq	r2,zero,8111c0dc <___vfprintf_internal_r+0x1404>
8111c008:	d9402d17 	ldw	r5,180(sp)
8111c00c:	d8c02917 	ldw	r3,164(sp)
8111c010:	d8002785 	stb	zero,158(sp)
8111c014:	28800104 	addi	r2,r5,4
8111c018:	2cc00017 	ldw	r19,0(r5)
8111c01c:	002d883a 	mov	r22,zero
8111c020:	18003716 	blt	r3,zero,8111c100 <___vfprintf_internal_r+0x1428>
8111c024:	00ffdfc4 	movi	r3,-129
8111c028:	d8802d15 	stw	r2,180(sp)
8111c02c:	90e4703a 	and	r18,r18,r3
8111c030:	0039883a 	mov	fp,zero
8111c034:	983df326 	beq	r19,zero,8111b804 <__reset+0xfb0fb804>
8111c038:	00800244 	movi	r2,9
8111c03c:	14fc7b36 	bltu	r2,r19,8111b22c <__reset+0xfb0fb22c>
8111c040:	d8c02817 	ldw	r3,160(sp)
8111c044:	dc001dc4 	addi	r16,sp,119
8111c048:	9cc00c04 	addi	r19,r19,48
8111c04c:	1c07c83a 	sub	r3,r3,r16
8111c050:	dcc01dc5 	stb	r19,119(sp)
8111c054:	d8c02e15 	stw	r3,184(sp)
8111c058:	003ce806 	br	8111b3fc <__reset+0xfb0fb3fc>
8111c05c:	d8803317 	ldw	r2,204(sp)
8111c060:	143fffc4 	addi	r16,r2,-1
8111c064:	043f4d0e 	bge	zero,r16,8111bd9c <__reset+0xfb0fbd9c>
8111c068:	07000404 	movi	fp,16
8111c06c:	e400810e 	bge	fp,r16,8111c274 <___vfprintf_internal_r+0x159c>
8111c070:	01604534 	movhi	r5,33044
8111c074:	29574284 	addi	r5,r5,23818
8111c078:	d9402b15 	stw	r5,172(sp)
8111c07c:	01c001c4 	movi	r7,7
8111c080:	dcc02c17 	ldw	r19,176(sp)
8111c084:	00000306 	br	8111c094 <___vfprintf_internal_r+0x13bc>
8111c088:	b5800204 	addi	r22,r22,8
8111c08c:	843ffc04 	addi	r16,r16,-16
8111c090:	e4007b0e 	bge	fp,r16,8111c280 <___vfprintf_internal_r+0x15a8>
8111c094:	18c00404 	addi	r3,r3,16
8111c098:	8c400044 	addi	r17,r17,1
8111c09c:	b5000015 	stw	r20,0(r22)
8111c0a0:	b7000115 	stw	fp,4(r22)
8111c0a4:	d8c02015 	stw	r3,128(sp)
8111c0a8:	dc401f15 	stw	r17,124(sp)
8111c0ac:	3c7ff60e 	bge	r7,r17,8111c088 <__reset+0xfb0fc088>
8111c0b0:	d9801e04 	addi	r6,sp,120
8111c0b4:	b80b883a 	mov	r5,r23
8111c0b8:	9809883a 	mov	r4,r19
8111c0bc:	d9c03c15 	stw	r7,240(sp)
8111c0c0:	1126ec80 	call	81126ec8 <__sprint_r>
8111c0c4:	d9c03c17 	ldw	r7,240(sp)
8111c0c8:	103c071e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c0cc:	d8c02017 	ldw	r3,128(sp)
8111c0d0:	dc401f17 	ldw	r17,124(sp)
8111c0d4:	dd800404 	addi	r22,sp,16
8111c0d8:	003fec06 	br	8111c08c <__reset+0xfb0fc08c>
8111c0dc:	9080100c 	andi	r2,r18,64
8111c0e0:	d8002785 	stb	zero,158(sp)
8111c0e4:	10010e26 	beq	r2,zero,8111c520 <___vfprintf_internal_r+0x1848>
8111c0e8:	d9002d17 	ldw	r4,180(sp)
8111c0ec:	d9402917 	ldw	r5,164(sp)
8111c0f0:	002d883a 	mov	r22,zero
8111c0f4:	20800104 	addi	r2,r4,4
8111c0f8:	24c0000b 	ldhu	r19,0(r4)
8111c0fc:	283fc90e 	bge	r5,zero,8111c024 <__reset+0xfb0fc024>
8111c100:	d8802d15 	stw	r2,180(sp)
8111c104:	0039883a 	mov	fp,zero
8111c108:	9d84b03a 	or	r2,r19,r22
8111c10c:	103c461e 	bne	r2,zero,8111b228 <__reset+0xfb0fb228>
8111c110:	00800044 	movi	r2,1
8111c114:	003e6c06 	br	8111bac8 <__reset+0xfb0fbac8>
8111c118:	d9002c17 	ldw	r4,176(sp)
8111c11c:	d9801e04 	addi	r6,sp,120
8111c120:	b80b883a 	mov	r5,r23
8111c124:	1126ec80 	call	81126ec8 <__sprint_r>
8111c128:	103bef1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c12c:	d8c02017 	ldw	r3,128(sp)
8111c130:	da000404 	addi	r8,sp,16
8111c134:	d9003217 	ldw	r4,200(sp)
8111c138:	d8802617 	ldw	r2,152(sp)
8111c13c:	d9403317 	ldw	r5,204(sp)
8111c140:	8123883a 	add	r17,r16,r4
8111c144:	11400216 	blt	r2,r5,8111c150 <___vfprintf_internal_r+0x1478>
8111c148:	9100004c 	andi	r4,r18,1
8111c14c:	20000d26 	beq	r4,zero,8111c184 <___vfprintf_internal_r+0x14ac>
8111c150:	d9003717 	ldw	r4,220(sp)
8111c154:	d9403417 	ldw	r5,208(sp)
8111c158:	1907883a 	add	r3,r3,r4
8111c15c:	d9001f17 	ldw	r4,124(sp)
8111c160:	41400015 	stw	r5,0(r8)
8111c164:	d9403717 	ldw	r5,220(sp)
8111c168:	21000044 	addi	r4,r4,1
8111c16c:	d8c02015 	stw	r3,128(sp)
8111c170:	41400115 	stw	r5,4(r8)
8111c174:	d9001f15 	stw	r4,124(sp)
8111c178:	014001c4 	movi	r5,7
8111c17c:	2901e816 	blt	r5,r4,8111c920 <___vfprintf_internal_r+0x1c48>
8111c180:	42000204 	addi	r8,r8,8
8111c184:	d9003317 	ldw	r4,204(sp)
8111c188:	8121883a 	add	r16,r16,r4
8111c18c:	2085c83a 	sub	r2,r4,r2
8111c190:	8461c83a 	sub	r16,r16,r17
8111c194:	1400010e 	bge	r2,r16,8111c19c <___vfprintf_internal_r+0x14c4>
8111c198:	1021883a 	mov	r16,r2
8111c19c:	04000a0e 	bge	zero,r16,8111c1c8 <___vfprintf_internal_r+0x14f0>
8111c1a0:	d9001f17 	ldw	r4,124(sp)
8111c1a4:	1c07883a 	add	r3,r3,r16
8111c1a8:	44400015 	stw	r17,0(r8)
8111c1ac:	21000044 	addi	r4,r4,1
8111c1b0:	44000115 	stw	r16,4(r8)
8111c1b4:	d8c02015 	stw	r3,128(sp)
8111c1b8:	d9001f15 	stw	r4,124(sp)
8111c1bc:	014001c4 	movi	r5,7
8111c1c0:	2901fb16 	blt	r5,r4,8111c9b0 <___vfprintf_internal_r+0x1cd8>
8111c1c4:	42000204 	addi	r8,r8,8
8111c1c8:	8001f716 	blt	r16,zero,8111c9a8 <___vfprintf_internal_r+0x1cd0>
8111c1cc:	1421c83a 	sub	r16,r2,r16
8111c1d0:	043d380e 	bge	zero,r16,8111b6b4 <__reset+0xfb0fb6b4>
8111c1d4:	04400404 	movi	r17,16
8111c1d8:	d8801f17 	ldw	r2,124(sp)
8111c1dc:	8c3efb0e 	bge	r17,r16,8111bdcc <__reset+0xfb0fbdcc>
8111c1e0:	01604534 	movhi	r5,33044
8111c1e4:	29574284 	addi	r5,r5,23818
8111c1e8:	d9402b15 	stw	r5,172(sp)
8111c1ec:	058001c4 	movi	r22,7
8111c1f0:	dcc02c17 	ldw	r19,176(sp)
8111c1f4:	00000306 	br	8111c204 <___vfprintf_internal_r+0x152c>
8111c1f8:	42000204 	addi	r8,r8,8
8111c1fc:	843ffc04 	addi	r16,r16,-16
8111c200:	8c3ef50e 	bge	r17,r16,8111bdd8 <__reset+0xfb0fbdd8>
8111c204:	18c00404 	addi	r3,r3,16
8111c208:	10800044 	addi	r2,r2,1
8111c20c:	45000015 	stw	r20,0(r8)
8111c210:	44400115 	stw	r17,4(r8)
8111c214:	d8c02015 	stw	r3,128(sp)
8111c218:	d8801f15 	stw	r2,124(sp)
8111c21c:	b0bff60e 	bge	r22,r2,8111c1f8 <__reset+0xfb0fc1f8>
8111c220:	d9801e04 	addi	r6,sp,120
8111c224:	b80b883a 	mov	r5,r23
8111c228:	9809883a 	mov	r4,r19
8111c22c:	1126ec80 	call	81126ec8 <__sprint_r>
8111c230:	103bad1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c234:	d8c02017 	ldw	r3,128(sp)
8111c238:	d8801f17 	ldw	r2,124(sp)
8111c23c:	da000404 	addi	r8,sp,16
8111c240:	003fee06 	br	8111c1fc <__reset+0xfb0fc1fc>
8111c244:	9088703a 	and	r4,r18,r2
8111c248:	203eab1e 	bne	r4,zero,8111bcf8 <__reset+0xfb0fbcf8>
8111c24c:	dc401f17 	ldw	r17,124(sp)
8111c250:	40800115 	stw	r2,4(r8)
8111c254:	44000015 	stw	r16,0(r8)
8111c258:	8c400044 	addi	r17,r17,1
8111c25c:	d8c02015 	stw	r3,128(sp)
8111c260:	dc401f15 	stw	r17,124(sp)
8111c264:	008001c4 	movi	r2,7
8111c268:	14400e16 	blt	r2,r17,8111c2a4 <___vfprintf_internal_r+0x15cc>
8111c26c:	45800204 	addi	r22,r8,8
8111c270:	003eca06 	br	8111bd9c <__reset+0xfb0fbd9c>
8111c274:	01204534 	movhi	r4,33044
8111c278:	21174284 	addi	r4,r4,23818
8111c27c:	d9002b15 	stw	r4,172(sp)
8111c280:	d8802b17 	ldw	r2,172(sp)
8111c284:	1c07883a 	add	r3,r3,r16
8111c288:	8c400044 	addi	r17,r17,1
8111c28c:	b0800015 	stw	r2,0(r22)
8111c290:	b4000115 	stw	r16,4(r22)
8111c294:	d8c02015 	stw	r3,128(sp)
8111c298:	dc401f15 	stw	r17,124(sp)
8111c29c:	008001c4 	movi	r2,7
8111c2a0:	147ebd0e 	bge	r2,r17,8111bd98 <__reset+0xfb0fbd98>
8111c2a4:	d9002c17 	ldw	r4,176(sp)
8111c2a8:	d9801e04 	addi	r6,sp,120
8111c2ac:	b80b883a 	mov	r5,r23
8111c2b0:	1126ec80 	call	81126ec8 <__sprint_r>
8111c2b4:	103b8c1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c2b8:	d8c02017 	ldw	r3,128(sp)
8111c2bc:	dc401f17 	ldw	r17,124(sp)
8111c2c0:	dd800404 	addi	r22,sp,16
8111c2c4:	003eb506 	br	8111bd9c <__reset+0xfb0fbd9c>
8111c2c8:	d9002c17 	ldw	r4,176(sp)
8111c2cc:	d9801e04 	addi	r6,sp,120
8111c2d0:	b80b883a 	mov	r5,r23
8111c2d4:	1126ec80 	call	81126ec8 <__sprint_r>
8111c2d8:	103b831e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c2dc:	d8c02017 	ldw	r3,128(sp)
8111c2e0:	dc401f17 	ldw	r17,124(sp)
8111c2e4:	da000404 	addi	r8,sp,16
8111c2e8:	003e8d06 	br	8111bd20 <__reset+0xfb0fbd20>
8111c2ec:	d9002c17 	ldw	r4,176(sp)
8111c2f0:	d9801e04 	addi	r6,sp,120
8111c2f4:	b80b883a 	mov	r5,r23
8111c2f8:	1126ec80 	call	81126ec8 <__sprint_r>
8111c2fc:	103b7a1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c300:	d8c02017 	ldw	r3,128(sp)
8111c304:	dc401f17 	ldw	r17,124(sp)
8111c308:	dd800404 	addi	r22,sp,16
8111c30c:	003e8f06 	br	8111bd4c <__reset+0xfb0fbd4c>
8111c310:	0027883a 	mov	r19,zero
8111c314:	003f4a06 	br	8111c040 <__reset+0xfb0fc040>
8111c318:	d9002c17 	ldw	r4,176(sp)
8111c31c:	d9801e04 	addi	r6,sp,120
8111c320:	b80b883a 	mov	r5,r23
8111c324:	1126ec80 	call	81126ec8 <__sprint_r>
8111c328:	103b6f1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c32c:	d8c02017 	ldw	r3,128(sp)
8111c330:	da000404 	addi	r8,sp,16
8111c334:	003c9d06 	br	8111b5ac <__reset+0xfb0fb5ac>
8111c338:	04e7c83a 	sub	r19,zero,r19
8111c33c:	9804c03a 	cmpne	r2,r19,zero
8111c340:	05adc83a 	sub	r22,zero,r22
8111c344:	b0adc83a 	sub	r22,r22,r2
8111c348:	d8802917 	ldw	r2,164(sp)
8111c34c:	07000b44 	movi	fp,45
8111c350:	df002785 	stb	fp,158(sp)
8111c354:	10017b16 	blt	r2,zero,8111c944 <___vfprintf_internal_r+0x1c6c>
8111c358:	00bfdfc4 	movi	r2,-129
8111c35c:	90a4703a 	and	r18,r18,r2
8111c360:	003bb106 	br	8111b228 <__reset+0xfb0fb228>
8111c364:	d9003617 	ldw	r4,216(sp)
8111c368:	d9403817 	ldw	r5,224(sp)
8111c36c:	da003d15 	stw	r8,244(sp)
8111c370:	112352c0 	call	8112352c <__fpclassifyd>
8111c374:	da003d17 	ldw	r8,244(sp)
8111c378:	1000f026 	beq	r2,zero,8111c73c <___vfprintf_internal_r+0x1a64>
8111c37c:	d9002917 	ldw	r4,164(sp)
8111c380:	05bff7c4 	movi	r22,-33
8111c384:	00bfffc4 	movi	r2,-1
8111c388:	8dac703a 	and	r22,r17,r22
8111c38c:	20820026 	beq	r4,r2,8111cb90 <___vfprintf_internal_r+0x1eb8>
8111c390:	008011c4 	movi	r2,71
8111c394:	b081f726 	beq	r22,r2,8111cb74 <___vfprintf_internal_r+0x1e9c>
8111c398:	d9003817 	ldw	r4,224(sp)
8111c39c:	90c04014 	ori	r3,r18,256
8111c3a0:	d8c02b15 	stw	r3,172(sp)
8111c3a4:	20021516 	blt	r4,zero,8111cbfc <___vfprintf_internal_r+0x1f24>
8111c3a8:	dcc03817 	ldw	r19,224(sp)
8111c3ac:	d8002a05 	stb	zero,168(sp)
8111c3b0:	00801984 	movi	r2,102
8111c3b4:	8881f926 	beq	r17,r2,8111cb9c <___vfprintf_internal_r+0x1ec4>
8111c3b8:	00801184 	movi	r2,70
8111c3bc:	88821c26 	beq	r17,r2,8111cc30 <___vfprintf_internal_r+0x1f58>
8111c3c0:	00801144 	movi	r2,69
8111c3c4:	b081ef26 	beq	r22,r2,8111cb84 <___vfprintf_internal_r+0x1eac>
8111c3c8:	d8c02917 	ldw	r3,164(sp)
8111c3cc:	d8802104 	addi	r2,sp,132
8111c3d0:	d8800315 	stw	r2,12(sp)
8111c3d4:	d9403617 	ldw	r5,216(sp)
8111c3d8:	d8802504 	addi	r2,sp,148
8111c3dc:	d9002c17 	ldw	r4,176(sp)
8111c3e0:	d8800215 	stw	r2,8(sp)
8111c3e4:	d8802604 	addi	r2,sp,152
8111c3e8:	d8c00015 	stw	r3,0(sp)
8111c3ec:	d8800115 	stw	r2,4(sp)
8111c3f0:	01c00084 	movi	r7,2
8111c3f4:	980d883a 	mov	r6,r19
8111c3f8:	d8c03c15 	stw	r3,240(sp)
8111c3fc:	da003d15 	stw	r8,244(sp)
8111c400:	111ede40 	call	8111ede4 <_dtoa_r>
8111c404:	1021883a 	mov	r16,r2
8111c408:	008019c4 	movi	r2,103
8111c40c:	d8c03c17 	ldw	r3,240(sp)
8111c410:	da003d17 	ldw	r8,244(sp)
8111c414:	88817126 	beq	r17,r2,8111c9dc <___vfprintf_internal_r+0x1d04>
8111c418:	008011c4 	movi	r2,71
8111c41c:	88829226 	beq	r17,r2,8111ce68 <___vfprintf_internal_r+0x2190>
8111c420:	80f9883a 	add	fp,r16,r3
8111c424:	d9003617 	ldw	r4,216(sp)
8111c428:	000d883a 	mov	r6,zero
8111c42c:	000f883a 	mov	r7,zero
8111c430:	980b883a 	mov	r5,r19
8111c434:	da003d15 	stw	r8,244(sp)
8111c438:	112b7100 	call	8112b710 <__eqdf2>
8111c43c:	da003d17 	ldw	r8,244(sp)
8111c440:	10018d26 	beq	r2,zero,8111ca78 <___vfprintf_internal_r+0x1da0>
8111c444:	d8802117 	ldw	r2,132(sp)
8111c448:	1700062e 	bgeu	r2,fp,8111c464 <___vfprintf_internal_r+0x178c>
8111c44c:	01000c04 	movi	r4,48
8111c450:	10c00044 	addi	r3,r2,1
8111c454:	d8c02115 	stw	r3,132(sp)
8111c458:	11000005 	stb	r4,0(r2)
8111c45c:	d8802117 	ldw	r2,132(sp)
8111c460:	173ffb36 	bltu	r2,fp,8111c450 <__reset+0xfb0fc450>
8111c464:	1405c83a 	sub	r2,r2,r16
8111c468:	d8803315 	stw	r2,204(sp)
8111c46c:	008011c4 	movi	r2,71
8111c470:	b0817626 	beq	r22,r2,8111ca4c <___vfprintf_internal_r+0x1d74>
8111c474:	00801944 	movi	r2,101
8111c478:	1442810e 	bge	r2,r17,8111ce80 <___vfprintf_internal_r+0x21a8>
8111c47c:	d8c02617 	ldw	r3,152(sp)
8111c480:	00801984 	movi	r2,102
8111c484:	d8c03215 	stw	r3,200(sp)
8111c488:	8881fe26 	beq	r17,r2,8111cc84 <___vfprintf_internal_r+0x1fac>
8111c48c:	d8c03217 	ldw	r3,200(sp)
8111c490:	d9003317 	ldw	r4,204(sp)
8111c494:	1901dd16 	blt	r3,r4,8111cc0c <___vfprintf_internal_r+0x1f34>
8111c498:	9480004c 	andi	r18,r18,1
8111c49c:	90022b1e 	bne	r18,zero,8111cd4c <___vfprintf_internal_r+0x2074>
8111c4a0:	1805883a 	mov	r2,r3
8111c4a4:	18028016 	blt	r3,zero,8111cea8 <___vfprintf_internal_r+0x21d0>
8111c4a8:	d8c03217 	ldw	r3,200(sp)
8111c4ac:	044019c4 	movi	r17,103
8111c4b0:	d8c02e15 	stw	r3,184(sp)
8111c4b4:	df002a07 	ldb	fp,168(sp)
8111c4b8:	e001531e 	bne	fp,zero,8111ca08 <___vfprintf_internal_r+0x1d30>
8111c4bc:	df002783 	ldbu	fp,158(sp)
8111c4c0:	d8802a15 	stw	r2,168(sp)
8111c4c4:	dc802b17 	ldw	r18,172(sp)
8111c4c8:	d8002915 	stw	zero,164(sp)
8111c4cc:	003bd106 	br	8111b414 <__reset+0xfb0fb414>
8111c4d0:	d8802d17 	ldw	r2,180(sp)
8111c4d4:	d8c02d17 	ldw	r3,180(sp)
8111c4d8:	d9002d17 	ldw	r4,180(sp)
8111c4dc:	10800017 	ldw	r2,0(r2)
8111c4e0:	18c00117 	ldw	r3,4(r3)
8111c4e4:	21000204 	addi	r4,r4,8
8111c4e8:	d8803615 	stw	r2,216(sp)
8111c4ec:	d8c03815 	stw	r3,224(sp)
8111c4f0:	d9002d15 	stw	r4,180(sp)
8111c4f4:	003b7506 	br	8111b2cc <__reset+0xfb0fb2cc>
8111c4f8:	ac400007 	ldb	r17,0(r21)
8111c4fc:	003a5906 	br	8111ae64 <__reset+0xfb0fae64>
8111c500:	9080100c 	andi	r2,r18,64
8111c504:	1000a826 	beq	r2,zero,8111c7a8 <___vfprintf_internal_r+0x1ad0>
8111c508:	d9002d17 	ldw	r4,180(sp)
8111c50c:	002d883a 	mov	r22,zero
8111c510:	24c0000b 	ldhu	r19,0(r4)
8111c514:	21000104 	addi	r4,r4,4
8111c518:	d9002d15 	stw	r4,180(sp)
8111c51c:	003ccb06 	br	8111b84c <__reset+0xfb0fb84c>
8111c520:	d8c02d17 	ldw	r3,180(sp)
8111c524:	d9002917 	ldw	r4,164(sp)
8111c528:	002d883a 	mov	r22,zero
8111c52c:	18800104 	addi	r2,r3,4
8111c530:	1cc00017 	ldw	r19,0(r3)
8111c534:	203ebb0e 	bge	r4,zero,8111c024 <__reset+0xfb0fc024>
8111c538:	003ef106 	br	8111c100 <__reset+0xfb0fc100>
8111c53c:	9080040c 	andi	r2,r18,16
8111c540:	1000921e 	bne	r2,zero,8111c78c <___vfprintf_internal_r+0x1ab4>
8111c544:	9480100c 	andi	r18,r18,64
8111c548:	90013926 	beq	r18,zero,8111ca30 <___vfprintf_internal_r+0x1d58>
8111c54c:	d9002d17 	ldw	r4,180(sp)
8111c550:	d9402f17 	ldw	r5,188(sp)
8111c554:	20800017 	ldw	r2,0(r4)
8111c558:	21000104 	addi	r4,r4,4
8111c55c:	d9002d15 	stw	r4,180(sp)
8111c560:	1140000d 	sth	r5,0(r2)
8111c564:	003a1606 	br	8111adc0 <__reset+0xfb0fadc0>
8111c568:	9080100c 	andi	r2,r18,64
8111c56c:	10008026 	beq	r2,zero,8111c770 <___vfprintf_internal_r+0x1a98>
8111c570:	d8c02d17 	ldw	r3,180(sp)
8111c574:	1cc0000f 	ldh	r19,0(r3)
8111c578:	18c00104 	addi	r3,r3,4
8111c57c:	d8c02d15 	stw	r3,180(sp)
8111c580:	982dd7fa 	srai	r22,r19,31
8111c584:	b005883a 	mov	r2,r22
8111c588:	003b1f06 	br	8111b208 <__reset+0xfb0fb208>
8111c58c:	9080100c 	andi	r2,r18,64
8111c590:	d8002785 	stb	zero,158(sp)
8111c594:	10008a1e 	bne	r2,zero,8111c7c0 <___vfprintf_internal_r+0x1ae8>
8111c598:	d9402d17 	ldw	r5,180(sp)
8111c59c:	d8c02917 	ldw	r3,164(sp)
8111c5a0:	002d883a 	mov	r22,zero
8111c5a4:	28800104 	addi	r2,r5,4
8111c5a8:	2cc00017 	ldw	r19,0(r5)
8111c5ac:	183e4b0e 	bge	r3,zero,8111bedc <__reset+0xfb0fbedc>
8111c5b0:	9d86b03a 	or	r3,r19,r22
8111c5b4:	d8802d15 	stw	r2,180(sp)
8111c5b8:	183e4c1e 	bne	r3,zero,8111beec <__reset+0xfb0fbeec>
8111c5bc:	0039883a 	mov	fp,zero
8111c5c0:	0005883a 	mov	r2,zero
8111c5c4:	003d4006 	br	8111bac8 <__reset+0xfb0fbac8>
8111c5c8:	01604534 	movhi	r5,33044
8111c5cc:	29574284 	addi	r5,r5,23818
8111c5d0:	d9402b15 	stw	r5,172(sp)
8111c5d4:	d9402b17 	ldw	r5,172(sp)
8111c5d8:	1c47883a 	add	r3,r3,r17
8111c5dc:	10800044 	addi	r2,r2,1
8111c5e0:	41400015 	stw	r5,0(r8)
8111c5e4:	44400115 	stw	r17,4(r8)
8111c5e8:	d8c02015 	stw	r3,128(sp)
8111c5ec:	d8801f15 	stw	r2,124(sp)
8111c5f0:	010001c4 	movi	r4,7
8111c5f4:	20bec816 	blt	r4,r2,8111c118 <__reset+0xfb0fc118>
8111c5f8:	42000204 	addi	r8,r8,8
8111c5fc:	003ecd06 	br	8111c134 <__reset+0xfb0fc134>
8111c600:	d9002917 	ldw	r4,164(sp)
8111c604:	d8002785 	stb	zero,158(sp)
8111c608:	203d2d16 	blt	r4,zero,8111bac0 <__reset+0xfb0fbac0>
8111c60c:	00bfdfc4 	movi	r2,-129
8111c610:	90a4703a 	and	r18,r18,r2
8111c614:	003a9106 	br	8111b05c <__reset+0xfb0fb05c>
8111c618:	01204534 	movhi	r4,33044
8111c61c:	21174284 	addi	r4,r4,23818
8111c620:	d9002b15 	stw	r4,172(sp)
8111c624:	003c0c06 	br	8111b658 <__reset+0xfb0fb658>
8111c628:	d9002c17 	ldw	r4,176(sp)
8111c62c:	d9801e04 	addi	r6,sp,120
8111c630:	b80b883a 	mov	r5,r23
8111c634:	1126ec80 	call	81126ec8 <__sprint_r>
8111c638:	103aab1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c63c:	d8c02017 	ldw	r3,128(sp)
8111c640:	da000404 	addi	r8,sp,16
8111c644:	003d4106 	br	8111bb4c <__reset+0xfb0fbb4c>
8111c648:	d8801f17 	ldw	r2,124(sp)
8111c64c:	01604534 	movhi	r5,33044
8111c650:	01000044 	movi	r4,1
8111c654:	18c00044 	addi	r3,r3,1
8111c658:	10800044 	addi	r2,r2,1
8111c65c:	29573a04 	addi	r5,r5,23784
8111c660:	41000115 	stw	r4,4(r8)
8111c664:	41400015 	stw	r5,0(r8)
8111c668:	d8c02015 	stw	r3,128(sp)
8111c66c:	d8801f15 	stw	r2,124(sp)
8111c670:	010001c4 	movi	r4,7
8111c674:	20805c16 	blt	r4,r2,8111c7e8 <___vfprintf_internal_r+0x1b10>
8111c678:	42000204 	addi	r8,r8,8
8111c67c:	8800041e 	bne	r17,zero,8111c690 <___vfprintf_internal_r+0x19b8>
8111c680:	d8803317 	ldw	r2,204(sp)
8111c684:	1000021e 	bne	r2,zero,8111c690 <___vfprintf_internal_r+0x19b8>
8111c688:	9080004c 	andi	r2,r18,1
8111c68c:	103c0926 	beq	r2,zero,8111b6b4 <__reset+0xfb0fb6b4>
8111c690:	d9003717 	ldw	r4,220(sp)
8111c694:	d8801f17 	ldw	r2,124(sp)
8111c698:	d9403417 	ldw	r5,208(sp)
8111c69c:	20c7883a 	add	r3,r4,r3
8111c6a0:	10800044 	addi	r2,r2,1
8111c6a4:	41000115 	stw	r4,4(r8)
8111c6a8:	41400015 	stw	r5,0(r8)
8111c6ac:	d8c02015 	stw	r3,128(sp)
8111c6b0:	d8801f15 	stw	r2,124(sp)
8111c6b4:	010001c4 	movi	r4,7
8111c6b8:	20812116 	blt	r4,r2,8111cb40 <___vfprintf_internal_r+0x1e68>
8111c6bc:	42000204 	addi	r8,r8,8
8111c6c0:	0463c83a 	sub	r17,zero,r17
8111c6c4:	0440730e 	bge	zero,r17,8111c894 <___vfprintf_internal_r+0x1bbc>
8111c6c8:	05800404 	movi	r22,16
8111c6cc:	b440860e 	bge	r22,r17,8111c8e8 <___vfprintf_internal_r+0x1c10>
8111c6d0:	01604534 	movhi	r5,33044
8111c6d4:	29574284 	addi	r5,r5,23818
8111c6d8:	d9402b15 	stw	r5,172(sp)
8111c6dc:	070001c4 	movi	fp,7
8111c6e0:	dcc02c17 	ldw	r19,176(sp)
8111c6e4:	00000306 	br	8111c6f4 <___vfprintf_internal_r+0x1a1c>
8111c6e8:	42000204 	addi	r8,r8,8
8111c6ec:	8c7ffc04 	addi	r17,r17,-16
8111c6f0:	b440800e 	bge	r22,r17,8111c8f4 <___vfprintf_internal_r+0x1c1c>
8111c6f4:	18c00404 	addi	r3,r3,16
8111c6f8:	10800044 	addi	r2,r2,1
8111c6fc:	45000015 	stw	r20,0(r8)
8111c700:	45800115 	stw	r22,4(r8)
8111c704:	d8c02015 	stw	r3,128(sp)
8111c708:	d8801f15 	stw	r2,124(sp)
8111c70c:	e0bff60e 	bge	fp,r2,8111c6e8 <__reset+0xfb0fc6e8>
8111c710:	d9801e04 	addi	r6,sp,120
8111c714:	b80b883a 	mov	r5,r23
8111c718:	9809883a 	mov	r4,r19
8111c71c:	1126ec80 	call	81126ec8 <__sprint_r>
8111c720:	103a711e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c724:	d8c02017 	ldw	r3,128(sp)
8111c728:	d8801f17 	ldw	r2,124(sp)
8111c72c:	da000404 	addi	r8,sp,16
8111c730:	003fee06 	br	8111c6ec <__reset+0xfb0fc6ec>
8111c734:	00bfffc4 	movi	r2,-1
8111c738:	003a6f06 	br	8111b0f8 <__reset+0xfb0fb0f8>
8111c73c:	008011c4 	movi	r2,71
8111c740:	1440b816 	blt	r2,r17,8111ca24 <___vfprintf_internal_r+0x1d4c>
8111c744:	04204534 	movhi	r16,33044
8111c748:	84172c04 	addi	r16,r16,23728
8111c74c:	00c000c4 	movi	r3,3
8111c750:	00bfdfc4 	movi	r2,-129
8111c754:	d8c02a15 	stw	r3,168(sp)
8111c758:	90a4703a 	and	r18,r18,r2
8111c75c:	df002783 	ldbu	fp,158(sp)
8111c760:	d8c02e15 	stw	r3,184(sp)
8111c764:	d8002915 	stw	zero,164(sp)
8111c768:	d8003215 	stw	zero,200(sp)
8111c76c:	003b2906 	br	8111b414 <__reset+0xfb0fb414>
8111c770:	d9002d17 	ldw	r4,180(sp)
8111c774:	24c00017 	ldw	r19,0(r4)
8111c778:	21000104 	addi	r4,r4,4
8111c77c:	d9002d15 	stw	r4,180(sp)
8111c780:	982dd7fa 	srai	r22,r19,31
8111c784:	b005883a 	mov	r2,r22
8111c788:	003a9f06 	br	8111b208 <__reset+0xfb0fb208>
8111c78c:	d9402d17 	ldw	r5,180(sp)
8111c790:	d8c02f17 	ldw	r3,188(sp)
8111c794:	28800017 	ldw	r2,0(r5)
8111c798:	29400104 	addi	r5,r5,4
8111c79c:	d9402d15 	stw	r5,180(sp)
8111c7a0:	10c00015 	stw	r3,0(r2)
8111c7a4:	00398606 	br	8111adc0 <__reset+0xfb0fadc0>
8111c7a8:	d9402d17 	ldw	r5,180(sp)
8111c7ac:	002d883a 	mov	r22,zero
8111c7b0:	2cc00017 	ldw	r19,0(r5)
8111c7b4:	29400104 	addi	r5,r5,4
8111c7b8:	d9402d15 	stw	r5,180(sp)
8111c7bc:	003c2306 	br	8111b84c <__reset+0xfb0fb84c>
8111c7c0:	d8c02d17 	ldw	r3,180(sp)
8111c7c4:	d9002917 	ldw	r4,164(sp)
8111c7c8:	002d883a 	mov	r22,zero
8111c7cc:	18800104 	addi	r2,r3,4
8111c7d0:	1cc0000b 	ldhu	r19,0(r3)
8111c7d4:	203dc10e 	bge	r4,zero,8111bedc <__reset+0xfb0fbedc>
8111c7d8:	003f7506 	br	8111c5b0 <__reset+0xfb0fc5b0>
8111c7dc:	04204534 	movhi	r16,33044
8111c7e0:	84172a04 	addi	r16,r16,23720
8111c7e4:	003acc06 	br	8111b318 <__reset+0xfb0fb318>
8111c7e8:	d9002c17 	ldw	r4,176(sp)
8111c7ec:	d9801e04 	addi	r6,sp,120
8111c7f0:	b80b883a 	mov	r5,r23
8111c7f4:	1126ec80 	call	81126ec8 <__sprint_r>
8111c7f8:	103a3b1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c7fc:	dc402617 	ldw	r17,152(sp)
8111c800:	d8c02017 	ldw	r3,128(sp)
8111c804:	da000404 	addi	r8,sp,16
8111c808:	003f9c06 	br	8111c67c <__reset+0xfb0fc67c>
8111c80c:	ac400043 	ldbu	r17,1(r21)
8111c810:	94800814 	ori	r18,r18,32
8111c814:	ad400044 	addi	r21,r21,1
8111c818:	8c403fcc 	andi	r17,r17,255
8111c81c:	8c40201c 	xori	r17,r17,128
8111c820:	8c7fe004 	addi	r17,r17,-128
8111c824:	00398f06 	br	8111ae64 <__reset+0xfb0fae64>
8111c828:	d8c02d15 	stw	r3,180(sp)
8111c82c:	0039883a 	mov	fp,zero
8111c830:	003e3506 	br	8111c108 <__reset+0xfb0fc108>
8111c834:	d9002c17 	ldw	r4,176(sp)
8111c838:	d9801e04 	addi	r6,sp,120
8111c83c:	b80b883a 	mov	r5,r23
8111c840:	1126ec80 	call	81126ec8 <__sprint_r>
8111c844:	103a281e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c848:	d8c02017 	ldw	r3,128(sp)
8111c84c:	da000404 	addi	r8,sp,16
8111c850:	003cd006 	br	8111bb94 <__reset+0xfb0fbb94>
8111c854:	8009883a 	mov	r4,r16
8111c858:	da003d15 	stw	r8,244(sp)
8111c85c:	11187c00 	call	811187c0 <strlen>
8111c860:	d8802e15 	stw	r2,184(sp)
8111c864:	da003d17 	ldw	r8,244(sp)
8111c868:	103c340e 	bge	r2,zero,8111b93c <__reset+0xfb0fb93c>
8111c86c:	0005883a 	mov	r2,zero
8111c870:	003c3206 	br	8111b93c <__reset+0xfb0fb93c>
8111c874:	d9002c17 	ldw	r4,176(sp)
8111c878:	d9801e04 	addi	r6,sp,120
8111c87c:	b80b883a 	mov	r5,r23
8111c880:	1126ec80 	call	81126ec8 <__sprint_r>
8111c884:	103a181e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c888:	d8c02017 	ldw	r3,128(sp)
8111c88c:	d8801f17 	ldw	r2,124(sp)
8111c890:	da000404 	addi	r8,sp,16
8111c894:	d9403317 	ldw	r5,204(sp)
8111c898:	10800044 	addi	r2,r2,1
8111c89c:	44000015 	stw	r16,0(r8)
8111c8a0:	28c7883a 	add	r3,r5,r3
8111c8a4:	003b7d06 	br	8111b69c <__reset+0xfb0fb69c>
8111c8a8:	01204534 	movhi	r4,33044
8111c8ac:	21174684 	addi	r4,r4,23834
8111c8b0:	d9003515 	stw	r4,212(sp)
8111c8b4:	003b1406 	br	8111b508 <__reset+0xfb0fb508>
8111c8b8:	013fffc4 	movi	r4,-1
8111c8bc:	003a3506 	br	8111b194 <__reset+0xfb0fb194>
8111c8c0:	0023883a 	mov	r17,zero
8111c8c4:	003d9d06 	br	8111bf3c <__reset+0xfb0fbf3c>
8111c8c8:	d9002c17 	ldw	r4,176(sp)
8111c8cc:	d9801e04 	addi	r6,sp,120
8111c8d0:	b80b883a 	mov	r5,r23
8111c8d4:	1126ec80 	call	81126ec8 <__sprint_r>
8111c8d8:	103a031e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c8dc:	d8c02017 	ldw	r3,128(sp)
8111c8e0:	da000404 	addi	r8,sp,16
8111c8e4:	003d9406 	br	8111bf38 <__reset+0xfb0fbf38>
8111c8e8:	01204534 	movhi	r4,33044
8111c8ec:	21174284 	addi	r4,r4,23818
8111c8f0:	d9002b15 	stw	r4,172(sp)
8111c8f4:	d9002b17 	ldw	r4,172(sp)
8111c8f8:	1c47883a 	add	r3,r3,r17
8111c8fc:	10800044 	addi	r2,r2,1
8111c900:	41000015 	stw	r4,0(r8)
8111c904:	44400115 	stw	r17,4(r8)
8111c908:	d8c02015 	stw	r3,128(sp)
8111c90c:	d8801f15 	stw	r2,124(sp)
8111c910:	010001c4 	movi	r4,7
8111c914:	20bfd716 	blt	r4,r2,8111c874 <__reset+0xfb0fc874>
8111c918:	42000204 	addi	r8,r8,8
8111c91c:	003fdd06 	br	8111c894 <__reset+0xfb0fc894>
8111c920:	d9002c17 	ldw	r4,176(sp)
8111c924:	d9801e04 	addi	r6,sp,120
8111c928:	b80b883a 	mov	r5,r23
8111c92c:	1126ec80 	call	81126ec8 <__sprint_r>
8111c930:	1039ed1e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c934:	d8802617 	ldw	r2,152(sp)
8111c938:	d8c02017 	ldw	r3,128(sp)
8111c93c:	da000404 	addi	r8,sp,16
8111c940:	003e1006 	br	8111c184 <__reset+0xfb0fc184>
8111c944:	00800044 	movi	r2,1
8111c948:	10803fcc 	andi	r2,r2,255
8111c94c:	00c00044 	movi	r3,1
8111c950:	10fa3526 	beq	r2,r3,8111b228 <__reset+0xfb0fb228>
8111c954:	00c00084 	movi	r3,2
8111c958:	10fbcb26 	beq	r2,r3,8111b888 <__reset+0xfb0fb888>
8111c95c:	003a8f06 	br	8111b39c <__reset+0xfb0fb39c>
8111c960:	01204534 	movhi	r4,33044
8111c964:	21174684 	addi	r4,r4,23834
8111c968:	d9003515 	stw	r4,212(sp)
8111c96c:	003b7606 	br	8111b748 <__reset+0xfb0fb748>
8111c970:	d8802917 	ldw	r2,164(sp)
8111c974:	00c00184 	movi	r3,6
8111c978:	1880012e 	bgeu	r3,r2,8111c980 <___vfprintf_internal_r+0x1ca8>
8111c97c:	1805883a 	mov	r2,r3
8111c980:	d8802e15 	stw	r2,184(sp)
8111c984:	1000ef16 	blt	r2,zero,8111cd44 <___vfprintf_internal_r+0x206c>
8111c988:	04204534 	movhi	r16,33044
8111c98c:	d8802a15 	stw	r2,168(sp)
8111c990:	dcc02d15 	stw	r19,180(sp)
8111c994:	d8002915 	stw	zero,164(sp)
8111c998:	d8003215 	stw	zero,200(sp)
8111c99c:	84173804 	addi	r16,r16,23776
8111c9a0:	0039883a 	mov	fp,zero
8111c9a4:	003aa206 	br	8111b430 <__reset+0xfb0fb430>
8111c9a8:	0021883a 	mov	r16,zero
8111c9ac:	003e0706 	br	8111c1cc <__reset+0xfb0fc1cc>
8111c9b0:	d9002c17 	ldw	r4,176(sp)
8111c9b4:	d9801e04 	addi	r6,sp,120
8111c9b8:	b80b883a 	mov	r5,r23
8111c9bc:	1126ec80 	call	81126ec8 <__sprint_r>
8111c9c0:	1039c91e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111c9c4:	d8802617 	ldw	r2,152(sp)
8111c9c8:	d9403317 	ldw	r5,204(sp)
8111c9cc:	d8c02017 	ldw	r3,128(sp)
8111c9d0:	da000404 	addi	r8,sp,16
8111c9d4:	2885c83a 	sub	r2,r5,r2
8111c9d8:	003dfb06 	br	8111c1c8 <__reset+0xfb0fc1c8>
8111c9dc:	9080004c 	andi	r2,r18,1
8111c9e0:	103e8f1e 	bne	r2,zero,8111c420 <__reset+0xfb0fc420>
8111c9e4:	d8802117 	ldw	r2,132(sp)
8111c9e8:	003e9e06 	br	8111c464 <__reset+0xfb0fc464>
8111c9ec:	1025883a 	mov	r18,r2
8111c9f0:	0039883a 	mov	fp,zero
8111c9f4:	00800084 	movi	r2,2
8111c9f8:	003fd306 	br	8111c948 <__reset+0xfb0fc948>
8111c9fc:	07000b44 	movi	fp,45
8111ca00:	df002785 	stb	fp,158(sp)
8111ca04:	003a4006 	br	8111b308 <__reset+0xfb0fb308>
8111ca08:	00c00b44 	movi	r3,45
8111ca0c:	d8c02785 	stb	r3,158(sp)
8111ca10:	d8802a15 	stw	r2,168(sp)
8111ca14:	dc802b17 	ldw	r18,172(sp)
8111ca18:	d8002915 	stw	zero,164(sp)
8111ca1c:	07000b44 	movi	fp,45
8111ca20:	003a8006 	br	8111b424 <__reset+0xfb0fb424>
8111ca24:	04204534 	movhi	r16,33044
8111ca28:	84172d04 	addi	r16,r16,23732
8111ca2c:	003f4706 	br	8111c74c <__reset+0xfb0fc74c>
8111ca30:	d8c02d17 	ldw	r3,180(sp)
8111ca34:	d9002f17 	ldw	r4,188(sp)
8111ca38:	18800017 	ldw	r2,0(r3)
8111ca3c:	18c00104 	addi	r3,r3,4
8111ca40:	d8c02d15 	stw	r3,180(sp)
8111ca44:	11000015 	stw	r4,0(r2)
8111ca48:	0038dd06 	br	8111adc0 <__reset+0xfb0fadc0>
8111ca4c:	dd802617 	ldw	r22,152(sp)
8111ca50:	00bfff44 	movi	r2,-3
8111ca54:	b0801c16 	blt	r22,r2,8111cac8 <___vfprintf_internal_r+0x1df0>
8111ca58:	d9402917 	ldw	r5,164(sp)
8111ca5c:	2d801a16 	blt	r5,r22,8111cac8 <___vfprintf_internal_r+0x1df0>
8111ca60:	dd803215 	stw	r22,200(sp)
8111ca64:	003e8906 	br	8111c48c <__reset+0xfb0fc48c>
8111ca68:	01204534 	movhi	r4,33044
8111ca6c:	21174284 	addi	r4,r4,23818
8111ca70:	d9002b15 	stw	r4,172(sp)
8111ca74:	003c9106 	br	8111bcbc <__reset+0xfb0fbcbc>
8111ca78:	e005883a 	mov	r2,fp
8111ca7c:	003e7906 	br	8111c464 <__reset+0xfb0fc464>
8111ca80:	d9402917 	ldw	r5,164(sp)
8111ca84:	df002783 	ldbu	fp,158(sp)
8111ca88:	dcc02d15 	stw	r19,180(sp)
8111ca8c:	d9402a15 	stw	r5,168(sp)
8111ca90:	d9402e15 	stw	r5,184(sp)
8111ca94:	d8002915 	stw	zero,164(sp)
8111ca98:	d8003215 	stw	zero,200(sp)
8111ca9c:	003a5d06 	br	8111b414 <__reset+0xfb0fb414>
8111caa0:	9080004c 	andi	r2,r18,1
8111caa4:	0039883a 	mov	fp,zero
8111caa8:	10000426 	beq	r2,zero,8111cabc <___vfprintf_internal_r+0x1de4>
8111caac:	00800c04 	movi	r2,48
8111cab0:	dc001dc4 	addi	r16,sp,119
8111cab4:	d8801dc5 	stb	r2,119(sp)
8111cab8:	003b8006 	br	8111b8bc <__reset+0xfb0fb8bc>
8111cabc:	d8002e15 	stw	zero,184(sp)
8111cac0:	dc001e04 	addi	r16,sp,120
8111cac4:	003a4d06 	br	8111b3fc <__reset+0xfb0fb3fc>
8111cac8:	8c7fff84 	addi	r17,r17,-2
8111cacc:	b5bfffc4 	addi	r22,r22,-1
8111cad0:	dd802615 	stw	r22,152(sp)
8111cad4:	dc4022c5 	stb	r17,139(sp)
8111cad8:	b000bf16 	blt	r22,zero,8111cdd8 <___vfprintf_internal_r+0x2100>
8111cadc:	00800ac4 	movi	r2,43
8111cae0:	d8802305 	stb	r2,140(sp)
8111cae4:	00800244 	movi	r2,9
8111cae8:	15807016 	blt	r2,r22,8111ccac <___vfprintf_internal_r+0x1fd4>
8111caec:	00800c04 	movi	r2,48
8111caf0:	b5800c04 	addi	r22,r22,48
8111caf4:	d8802345 	stb	r2,141(sp)
8111caf8:	dd802385 	stb	r22,142(sp)
8111cafc:	d88023c4 	addi	r2,sp,143
8111cb00:	df0022c4 	addi	fp,sp,139
8111cb04:	d8c03317 	ldw	r3,204(sp)
8111cb08:	1739c83a 	sub	fp,r2,fp
8111cb0c:	d9003317 	ldw	r4,204(sp)
8111cb10:	e0c7883a 	add	r3,fp,r3
8111cb14:	df003a15 	stw	fp,232(sp)
8111cb18:	d8c02e15 	stw	r3,184(sp)
8111cb1c:	00800044 	movi	r2,1
8111cb20:	1100b30e 	bge	r2,r4,8111cdf0 <___vfprintf_internal_r+0x2118>
8111cb24:	d8c02e17 	ldw	r3,184(sp)
8111cb28:	18c00044 	addi	r3,r3,1
8111cb2c:	d8c02e15 	stw	r3,184(sp)
8111cb30:	1805883a 	mov	r2,r3
8111cb34:	1800ac16 	blt	r3,zero,8111cde8 <___vfprintf_internal_r+0x2110>
8111cb38:	d8003215 	stw	zero,200(sp)
8111cb3c:	003e5d06 	br	8111c4b4 <__reset+0xfb0fc4b4>
8111cb40:	d9002c17 	ldw	r4,176(sp)
8111cb44:	d9801e04 	addi	r6,sp,120
8111cb48:	b80b883a 	mov	r5,r23
8111cb4c:	1126ec80 	call	81126ec8 <__sprint_r>
8111cb50:	1039651e 	bne	r2,zero,8111b0e8 <__reset+0xfb0fb0e8>
8111cb54:	dc402617 	ldw	r17,152(sp)
8111cb58:	d8c02017 	ldw	r3,128(sp)
8111cb5c:	d8801f17 	ldw	r2,124(sp)
8111cb60:	da000404 	addi	r8,sp,16
8111cb64:	003ed606 	br	8111c6c0 <__reset+0xfb0fc6c0>
8111cb68:	582b883a 	mov	r21,r11
8111cb6c:	d8002915 	stw	zero,164(sp)
8111cb70:	0038bd06 	br	8111ae68 <__reset+0xfb0fae68>
8111cb74:	d8802917 	ldw	r2,164(sp)
8111cb78:	103e071e 	bne	r2,zero,8111c398 <__reset+0xfb0fc398>
8111cb7c:	dc002915 	stw	r16,164(sp)
8111cb80:	003e0506 	br	8111c398 <__reset+0xfb0fc398>
8111cb84:	d9002917 	ldw	r4,164(sp)
8111cb88:	20c00044 	addi	r3,r4,1
8111cb8c:	003e0f06 	br	8111c3cc <__reset+0xfb0fc3cc>
8111cb90:	01400184 	movi	r5,6
8111cb94:	d9402915 	stw	r5,164(sp)
8111cb98:	003dff06 	br	8111c398 <__reset+0xfb0fc398>
8111cb9c:	d8802104 	addi	r2,sp,132
8111cba0:	d8800315 	stw	r2,12(sp)
8111cba4:	d8802504 	addi	r2,sp,148
8111cba8:	d8800215 	stw	r2,8(sp)
8111cbac:	d8802604 	addi	r2,sp,152
8111cbb0:	d8800115 	stw	r2,4(sp)
8111cbb4:	d8802917 	ldw	r2,164(sp)
8111cbb8:	d9403617 	ldw	r5,216(sp)
8111cbbc:	d9002c17 	ldw	r4,176(sp)
8111cbc0:	d8800015 	stw	r2,0(sp)
8111cbc4:	01c000c4 	movi	r7,3
8111cbc8:	980d883a 	mov	r6,r19
8111cbcc:	da003d15 	stw	r8,244(sp)
8111cbd0:	111ede40 	call	8111ede4 <_dtoa_r>
8111cbd4:	d8c02917 	ldw	r3,164(sp)
8111cbd8:	da003d17 	ldw	r8,244(sp)
8111cbdc:	1021883a 	mov	r16,r2
8111cbe0:	10f9883a 	add	fp,r2,r3
8111cbe4:	81000007 	ldb	r4,0(r16)
8111cbe8:	00800c04 	movi	r2,48
8111cbec:	20805e26 	beq	r4,r2,8111cd68 <___vfprintf_internal_r+0x2090>
8111cbf0:	d8c02617 	ldw	r3,152(sp)
8111cbf4:	e0f9883a 	add	fp,fp,r3
8111cbf8:	003e0a06 	br	8111c424 <__reset+0xfb0fc424>
8111cbfc:	00c00b44 	movi	r3,45
8111cc00:	24e0003c 	xorhi	r19,r4,32768
8111cc04:	d8c02a05 	stb	r3,168(sp)
8111cc08:	003de906 	br	8111c3b0 <__reset+0xfb0fc3b0>
8111cc0c:	d8c03217 	ldw	r3,200(sp)
8111cc10:	00c07a0e 	bge	zero,r3,8111cdfc <___vfprintf_internal_r+0x2124>
8111cc14:	00800044 	movi	r2,1
8111cc18:	d9003317 	ldw	r4,204(sp)
8111cc1c:	1105883a 	add	r2,r2,r4
8111cc20:	d8802e15 	stw	r2,184(sp)
8111cc24:	10004e16 	blt	r2,zero,8111cd60 <___vfprintf_internal_r+0x2088>
8111cc28:	044019c4 	movi	r17,103
8111cc2c:	003e2106 	br	8111c4b4 <__reset+0xfb0fc4b4>
8111cc30:	d9002917 	ldw	r4,164(sp)
8111cc34:	d8802104 	addi	r2,sp,132
8111cc38:	d8800315 	stw	r2,12(sp)
8111cc3c:	d9000015 	stw	r4,0(sp)
8111cc40:	d8802504 	addi	r2,sp,148
8111cc44:	d9403617 	ldw	r5,216(sp)
8111cc48:	d9002c17 	ldw	r4,176(sp)
8111cc4c:	d8800215 	stw	r2,8(sp)
8111cc50:	d8802604 	addi	r2,sp,152
8111cc54:	d8800115 	stw	r2,4(sp)
8111cc58:	01c000c4 	movi	r7,3
8111cc5c:	980d883a 	mov	r6,r19
8111cc60:	da003d15 	stw	r8,244(sp)
8111cc64:	111ede40 	call	8111ede4 <_dtoa_r>
8111cc68:	d8c02917 	ldw	r3,164(sp)
8111cc6c:	da003d17 	ldw	r8,244(sp)
8111cc70:	1021883a 	mov	r16,r2
8111cc74:	00801184 	movi	r2,70
8111cc78:	80f9883a 	add	fp,r16,r3
8111cc7c:	88bfd926 	beq	r17,r2,8111cbe4 <__reset+0xfb0fcbe4>
8111cc80:	003de806 	br	8111c424 <__reset+0xfb0fc424>
8111cc84:	d9002917 	ldw	r4,164(sp)
8111cc88:	00c04d0e 	bge	zero,r3,8111cdc0 <___vfprintf_internal_r+0x20e8>
8111cc8c:	2000441e 	bne	r4,zero,8111cda0 <___vfprintf_internal_r+0x20c8>
8111cc90:	9480004c 	andi	r18,r18,1
8111cc94:	9000421e 	bne	r18,zero,8111cda0 <___vfprintf_internal_r+0x20c8>
8111cc98:	1805883a 	mov	r2,r3
8111cc9c:	18007016 	blt	r3,zero,8111ce60 <___vfprintf_internal_r+0x2188>
8111cca0:	d8c03217 	ldw	r3,200(sp)
8111cca4:	d8c02e15 	stw	r3,184(sp)
8111cca8:	003e0206 	br	8111c4b4 <__reset+0xfb0fc4b4>
8111ccac:	df0022c4 	addi	fp,sp,139
8111ccb0:	dc002915 	stw	r16,164(sp)
8111ccb4:	4027883a 	mov	r19,r8
8111ccb8:	e021883a 	mov	r16,fp
8111ccbc:	b009883a 	mov	r4,r22
8111ccc0:	01400284 	movi	r5,10
8111ccc4:	112a2400 	call	8112a240 <__modsi3>
8111ccc8:	10800c04 	addi	r2,r2,48
8111cccc:	843fffc4 	addi	r16,r16,-1
8111ccd0:	b009883a 	mov	r4,r22
8111ccd4:	01400284 	movi	r5,10
8111ccd8:	80800005 	stb	r2,0(r16)
8111ccdc:	112a1bc0 	call	8112a1bc <__divsi3>
8111cce0:	102d883a 	mov	r22,r2
8111cce4:	00800244 	movi	r2,9
8111cce8:	15bff416 	blt	r2,r22,8111ccbc <__reset+0xfb0fccbc>
8111ccec:	9811883a 	mov	r8,r19
8111ccf0:	b0800c04 	addi	r2,r22,48
8111ccf4:	8027883a 	mov	r19,r16
8111ccf8:	997fffc4 	addi	r5,r19,-1
8111ccfc:	98bfffc5 	stb	r2,-1(r19)
8111cd00:	dc002917 	ldw	r16,164(sp)
8111cd04:	2f006a2e 	bgeu	r5,fp,8111ceb0 <___vfprintf_internal_r+0x21d8>
8111cd08:	d9c02384 	addi	r7,sp,142
8111cd0c:	3ccfc83a 	sub	r7,r7,r19
8111cd10:	d9002344 	addi	r4,sp,141
8111cd14:	e1cf883a 	add	r7,fp,r7
8111cd18:	00000106 	br	8111cd20 <___vfprintf_internal_r+0x2048>
8111cd1c:	28800003 	ldbu	r2,0(r5)
8111cd20:	20800005 	stb	r2,0(r4)
8111cd24:	21000044 	addi	r4,r4,1
8111cd28:	29400044 	addi	r5,r5,1
8111cd2c:	393ffb1e 	bne	r7,r4,8111cd1c <__reset+0xfb0fcd1c>
8111cd30:	d8802304 	addi	r2,sp,140
8111cd34:	14c5c83a 	sub	r2,r2,r19
8111cd38:	d8c02344 	addi	r3,sp,141
8111cd3c:	1885883a 	add	r2,r3,r2
8111cd40:	003f7006 	br	8111cb04 <__reset+0xfb0fcb04>
8111cd44:	0005883a 	mov	r2,zero
8111cd48:	003f0f06 	br	8111c988 <__reset+0xfb0fc988>
8111cd4c:	d8c03217 	ldw	r3,200(sp)
8111cd50:	18c00044 	addi	r3,r3,1
8111cd54:	d8c02e15 	stw	r3,184(sp)
8111cd58:	1805883a 	mov	r2,r3
8111cd5c:	183fb20e 	bge	r3,zero,8111cc28 <__reset+0xfb0fcc28>
8111cd60:	0005883a 	mov	r2,zero
8111cd64:	003fb006 	br	8111cc28 <__reset+0xfb0fcc28>
8111cd68:	d9003617 	ldw	r4,216(sp)
8111cd6c:	000d883a 	mov	r6,zero
8111cd70:	000f883a 	mov	r7,zero
8111cd74:	980b883a 	mov	r5,r19
8111cd78:	d8c03c15 	stw	r3,240(sp)
8111cd7c:	da003d15 	stw	r8,244(sp)
8111cd80:	112b7100 	call	8112b710 <__eqdf2>
8111cd84:	d8c03c17 	ldw	r3,240(sp)
8111cd88:	da003d17 	ldw	r8,244(sp)
8111cd8c:	103f9826 	beq	r2,zero,8111cbf0 <__reset+0xfb0fcbf0>
8111cd90:	00800044 	movi	r2,1
8111cd94:	10c7c83a 	sub	r3,r2,r3
8111cd98:	d8c02615 	stw	r3,152(sp)
8111cd9c:	003f9506 	br	8111cbf4 <__reset+0xfb0fcbf4>
8111cda0:	d9002917 	ldw	r4,164(sp)
8111cda4:	d8c03217 	ldw	r3,200(sp)
8111cda8:	20800044 	addi	r2,r4,1
8111cdac:	1885883a 	add	r2,r3,r2
8111cdb0:	d8802e15 	stw	r2,184(sp)
8111cdb4:	103dbf0e 	bge	r2,zero,8111c4b4 <__reset+0xfb0fc4b4>
8111cdb8:	0005883a 	mov	r2,zero
8111cdbc:	003dbd06 	br	8111c4b4 <__reset+0xfb0fc4b4>
8111cdc0:	2000211e 	bne	r4,zero,8111ce48 <___vfprintf_internal_r+0x2170>
8111cdc4:	9480004c 	andi	r18,r18,1
8111cdc8:	90001f1e 	bne	r18,zero,8111ce48 <___vfprintf_internal_r+0x2170>
8111cdcc:	00800044 	movi	r2,1
8111cdd0:	d8802e15 	stw	r2,184(sp)
8111cdd4:	003db706 	br	8111c4b4 <__reset+0xfb0fc4b4>
8111cdd8:	00800b44 	movi	r2,45
8111cddc:	05adc83a 	sub	r22,zero,r22
8111cde0:	d8802305 	stb	r2,140(sp)
8111cde4:	003f3f06 	br	8111cae4 <__reset+0xfb0fcae4>
8111cde8:	0005883a 	mov	r2,zero
8111cdec:	003f5206 	br	8111cb38 <__reset+0xfb0fcb38>
8111cdf0:	90a4703a 	and	r18,r18,r2
8111cdf4:	903f4e26 	beq	r18,zero,8111cb30 <__reset+0xfb0fcb30>
8111cdf8:	003f4a06 	br	8111cb24 <__reset+0xfb0fcb24>
8111cdfc:	00800084 	movi	r2,2
8111ce00:	10c5c83a 	sub	r2,r2,r3
8111ce04:	003f8406 	br	8111cc18 <__reset+0xfb0fcc18>
8111ce08:	d8802d17 	ldw	r2,180(sp)
8111ce0c:	d9002d17 	ldw	r4,180(sp)
8111ce10:	ac400043 	ldbu	r17,1(r21)
8111ce14:	10800017 	ldw	r2,0(r2)
8111ce18:	582b883a 	mov	r21,r11
8111ce1c:	d8802915 	stw	r2,164(sp)
8111ce20:	20800104 	addi	r2,r4,4
8111ce24:	d9002917 	ldw	r4,164(sp)
8111ce28:	d8802d15 	stw	r2,180(sp)
8111ce2c:	203e7a0e 	bge	r4,zero,8111c818 <__reset+0xfb0fc818>
8111ce30:	8c403fcc 	andi	r17,r17,255
8111ce34:	00bfffc4 	movi	r2,-1
8111ce38:	8c40201c 	xori	r17,r17,128
8111ce3c:	d8802915 	stw	r2,164(sp)
8111ce40:	8c7fe004 	addi	r17,r17,-128
8111ce44:	00380706 	br	8111ae64 <__reset+0xfb0fae64>
8111ce48:	d8c02917 	ldw	r3,164(sp)
8111ce4c:	18c00084 	addi	r3,r3,2
8111ce50:	d8c02e15 	stw	r3,184(sp)
8111ce54:	1805883a 	mov	r2,r3
8111ce58:	183d960e 	bge	r3,zero,8111c4b4 <__reset+0xfb0fc4b4>
8111ce5c:	003fd606 	br	8111cdb8 <__reset+0xfb0fcdb8>
8111ce60:	0005883a 	mov	r2,zero
8111ce64:	003f8e06 	br	8111cca0 <__reset+0xfb0fcca0>
8111ce68:	9080004c 	andi	r2,r18,1
8111ce6c:	103f811e 	bne	r2,zero,8111cc74 <__reset+0xfb0fcc74>
8111ce70:	d8802117 	ldw	r2,132(sp)
8111ce74:	1405c83a 	sub	r2,r2,r16
8111ce78:	d8803315 	stw	r2,204(sp)
8111ce7c:	b47ef326 	beq	r22,r17,8111ca4c <__reset+0xfb0fca4c>
8111ce80:	dd802617 	ldw	r22,152(sp)
8111ce84:	003f1106 	br	8111cacc <__reset+0xfb0fcacc>
8111ce88:	d9c02785 	stb	r7,158(sp)
8111ce8c:	00390406 	br	8111b2a0 <__reset+0xfb0fb2a0>
8111ce90:	d9c02785 	stb	r7,158(sp)
8111ce94:	0038d306 	br	8111b1e4 <__reset+0xfb0fb1e4>
8111ce98:	d9c02785 	stb	r7,158(sp)
8111ce9c:	003a6106 	br	8111b824 <__reset+0xfb0fb824>
8111cea0:	d9c02785 	stb	r7,158(sp)
8111cea4:	003af806 	br	8111ba88 <__reset+0xfb0fba88>
8111cea8:	0005883a 	mov	r2,zero
8111ceac:	003d7e06 	br	8111c4a8 <__reset+0xfb0fc4a8>
8111ceb0:	d8802344 	addi	r2,sp,141
8111ceb4:	003f1306 	br	8111cb04 <__reset+0xfb0fcb04>
8111ceb8:	d9c02785 	stb	r7,158(sp)
8111cebc:	00392306 	br	8111b34c <__reset+0xfb0fb34c>
8111cec0:	d9c02785 	stb	r7,158(sp)
8111cec4:	003aa906 	br	8111b96c <__reset+0xfb0fb96c>
8111cec8:	d9c02785 	stb	r7,158(sp)
8111cecc:	003a3d06 	br	8111b7c4 <__reset+0xfb0fb7c4>
8111ced0:	d9c02785 	stb	r7,158(sp)
8111ced4:	003aca06 	br	8111ba00 <__reset+0xfb0fba00>

8111ced8 <__vfprintf_internal>:
8111ced8:	00a04574 	movhi	r2,33045
8111cedc:	10a10204 	addi	r2,r2,-31736
8111cee0:	300f883a 	mov	r7,r6
8111cee4:	280d883a 	mov	r6,r5
8111cee8:	200b883a 	mov	r5,r4
8111ceec:	11000017 	ldw	r4,0(r2)
8111cef0:	111acd81 	jmpi	8111acd8 <___vfprintf_internal_r>

8111cef4 <__sbprintf>:
8111cef4:	defee204 	addi	sp,sp,-1144
8111cef8:	de00012e 	bgeu	sp,et,8111cf00 <__sbprintf+0xc>
8111cefc:	003b68fa 	trap	3
8111cf00:	2880030b 	ldhu	r2,12(r5)
8111cf04:	2ac01917 	ldw	r11,100(r5)
8111cf08:	2a80038b 	ldhu	r10,14(r5)
8111cf0c:	2a400717 	ldw	r9,28(r5)
8111cf10:	2a000917 	ldw	r8,36(r5)
8111cf14:	00c10004 	movi	r3,1024
8111cf18:	dc011a15 	stw	r16,1128(sp)
8111cf1c:	10bfff4c 	andi	r2,r2,65533
8111cf20:	2821883a 	mov	r16,r5
8111cf24:	d8cb883a 	add	r5,sp,r3
8111cf28:	dc811c15 	stw	r18,1136(sp)
8111cf2c:	dc411b15 	stw	r17,1132(sp)
8111cf30:	dfc11d15 	stw	ra,1140(sp)
8111cf34:	2025883a 	mov	r18,r4
8111cf38:	d881030d 	sth	r2,1036(sp)
8111cf3c:	dac11915 	stw	r11,1124(sp)
8111cf40:	da81038d 	sth	r10,1038(sp)
8111cf44:	da410715 	stw	r9,1052(sp)
8111cf48:	da010915 	stw	r8,1060(sp)
8111cf4c:	dec10015 	stw	sp,1024(sp)
8111cf50:	dec10415 	stw	sp,1040(sp)
8111cf54:	d8c10215 	stw	r3,1032(sp)
8111cf58:	d8c10515 	stw	r3,1044(sp)
8111cf5c:	d8010615 	stw	zero,1048(sp)
8111cf60:	111acd80 	call	8111acd8 <___vfprintf_internal_r>
8111cf64:	1023883a 	mov	r17,r2
8111cf68:	10000416 	blt	r2,zero,8111cf7c <__sbprintf+0x88>
8111cf6c:	d9410004 	addi	r5,sp,1024
8111cf70:	9009883a 	mov	r4,r18
8111cf74:	11206980 	call	81120698 <_fflush_r>
8111cf78:	10000d1e 	bne	r2,zero,8111cfb0 <__sbprintf+0xbc>
8111cf7c:	d881030b 	ldhu	r2,1036(sp)
8111cf80:	1080100c 	andi	r2,r2,64
8111cf84:	10000326 	beq	r2,zero,8111cf94 <__sbprintf+0xa0>
8111cf88:	8080030b 	ldhu	r2,12(r16)
8111cf8c:	10801014 	ori	r2,r2,64
8111cf90:	8080030d 	sth	r2,12(r16)
8111cf94:	8805883a 	mov	r2,r17
8111cf98:	dfc11d17 	ldw	ra,1140(sp)
8111cf9c:	dc811c17 	ldw	r18,1136(sp)
8111cfa0:	dc411b17 	ldw	r17,1132(sp)
8111cfa4:	dc011a17 	ldw	r16,1128(sp)
8111cfa8:	dec11e04 	addi	sp,sp,1144
8111cfac:	f800283a 	ret
8111cfb0:	047fffc4 	movi	r17,-1
8111cfb4:	003ff106 	br	8111cf7c <__reset+0xfb0fcf7c>

8111cfb8 <__svfscanf_r>:
8111cfb8:	deff4b04 	addi	sp,sp,-724
8111cfbc:	de00012e 	bgeu	sp,et,8111cfc4 <__svfscanf_r+0xc>
8111cfc0:	003b68fa 	trap	3
8111cfc4:	2880030b 	ldhu	r2,12(r5)
8111cfc8:	df00b315 	stw	fp,716(sp)
8111cfcc:	dd80b115 	stw	r22,708(sp)
8111cfd0:	dfc0b415 	stw	ra,720(sp)
8111cfd4:	ddc0b215 	stw	r23,712(sp)
8111cfd8:	dd40b015 	stw	r21,704(sp)
8111cfdc:	dd00af15 	stw	r20,700(sp)
8111cfe0:	dcc0ae15 	stw	r19,696(sp)
8111cfe4:	dc80ad15 	stw	r18,692(sp)
8111cfe8:	dc40ac15 	stw	r17,688(sp)
8111cfec:	dc00ab15 	stw	r16,684(sp)
8111cff0:	10c8000c 	andi	r3,r2,8192
8111cff4:	d9c09c15 	stw	r7,624(sp)
8111cff8:	2839883a 	mov	fp,r5
8111cffc:	202d883a 	mov	r22,r4
8111d000:	1800061e 	bne	r3,zero,8111d01c <__svfscanf_r+0x64>
8111d004:	29001917 	ldw	r4,100(r5)
8111d008:	00f7ffc4 	movi	r3,-8193
8111d00c:	10880014 	ori	r2,r2,8192
8111d010:	20c6703a 	and	r3,r4,r3
8111d014:	2880030d 	sth	r2,12(r5)
8111d018:	28c01915 	stw	r3,100(r5)
8111d01c:	30800003 	ldbu	r2,0(r6)
8111d020:	0021883a 	mov	r16,zero
8111d024:	05e04574 	movhi	r23,33045
8111d028:	d800a115 	stw	zero,644(sp)
8111d02c:	d8009e15 	stw	zero,632(sp)
8111d030:	d800a015 	stw	zero,640(sp)
8111d034:	d8809b15 	stw	r2,620(sp)
8111d038:	bde10004 	addi	r23,r23,-31744
8111d03c:	8025883a 	mov	r18,r16
8111d040:	35000044 	addi	r20,r6,1
8111d044:	10001e26 	beq	r2,zero,8111d0c0 <__svfscanf_r+0x108>
8111d048:	b9c00017 	ldw	r7,0(r23)
8111d04c:	3887883a 	add	r3,r7,r2
8111d050:	18c00043 	ldbu	r3,1(r3)
8111d054:	18c0020c 	andi	r3,r3,8
8111d058:	18001b26 	beq	r3,zero,8111d0c8 <__svfscanf_r+0x110>
8111d05c:	e0800117 	ldw	r2,4(fp)
8111d060:	00800e0e 	bge	zero,r2,8111d09c <__svfscanf_r+0xe4>
8111d064:	e0c00017 	ldw	r3,0(fp)
8111d068:	b9000017 	ldw	r4,0(r23)
8111d06c:	18800003 	ldbu	r2,0(r3)
8111d070:	2085883a 	add	r2,r4,r2
8111d074:	10800043 	ldbu	r2,1(r2)
8111d078:	1080020c 	andi	r2,r2,8
8111d07c:	10000b26 	beq	r2,zero,8111d0ac <__svfscanf_r+0xf4>
8111d080:	e0800117 	ldw	r2,4(fp)
8111d084:	18c00044 	addi	r3,r3,1
8111d088:	e0c00015 	stw	r3,0(fp)
8111d08c:	10bfffc4 	addi	r2,r2,-1
8111d090:	e0800115 	stw	r2,4(fp)
8111d094:	94800044 	addi	r18,r18,1
8111d098:	00bff216 	blt	zero,r2,8111d064 <__reset+0xfb0fd064>
8111d09c:	e00b883a 	mov	r5,fp
8111d0a0:	b009883a 	mov	r4,r22
8111d0a4:	11182980 	call	81118298 <__srefill_r>
8111d0a8:	103fee26 	beq	r2,zero,8111d064 <__reset+0xfb0fd064>
8111d0ac:	a00d883a 	mov	r6,r20
8111d0b0:	30800003 	ldbu	r2,0(r6)
8111d0b4:	35000044 	addi	r20,r6,1
8111d0b8:	d8809b15 	stw	r2,620(sp)
8111d0bc:	103fe21e 	bne	r2,zero,8111d048 <__reset+0xfb0fd048>
8111d0c0:	d880a017 	ldw	r2,640(sp)
8111d0c4:	00009906 	br	8111d32c <__svfscanf_r+0x374>
8111d0c8:	00c00944 	movi	r3,37
8111d0cc:	10c0881e 	bne	r2,r3,8111d2f0 <__svfscanf_r+0x338>
8111d0d0:	30c00043 	ldbu	r3,1(r6)
8111d0d4:	0023883a 	mov	r17,zero
8111d0d8:	0027883a 	mov	r19,zero
8111d0dc:	01001e04 	movi	r4,120
8111d0e0:	01401b04 	movi	r5,108
8111d0e4:	a1800044 	addi	r6,r20,1
8111d0e8:	20c0a236 	bltu	r4,r3,8111d374 <__svfscanf_r+0x3bc>
8111d0ec:	180490ba 	slli	r2,r3,2
8111d0f0:	022044b4 	movhi	r8,33042
8111d0f4:	42344104 	addi	r8,r8,-12028
8111d0f8:	1205883a 	add	r2,r2,r8
8111d0fc:	10800017 	ldw	r2,0(r2)
8111d100:	1000683a 	jmp	r2
8111d104:	8111d328 	cmpgeui	r4,r16,18252
8111d108:	8111d374 	orhi	r4,r16,18253
8111d10c:	8111d374 	orhi	r4,r16,18253
8111d110:	8111d374 	orhi	r4,r16,18253
8111d114:	8111d374 	orhi	r4,r16,18253
8111d118:	8111d374 	orhi	r4,r16,18253
8111d11c:	8111d374 	orhi	r4,r16,18253
8111d120:	8111d374 	orhi	r4,r16,18253
8111d124:	8111d374 	orhi	r4,r16,18253
8111d128:	8111d374 	orhi	r4,r16,18253
8111d12c:	8111d374 	orhi	r4,r16,18253
8111d130:	8111d374 	orhi	r4,r16,18253
8111d134:	8111d374 	orhi	r4,r16,18253
8111d138:	8111d374 	orhi	r4,r16,18253
8111d13c:	8111d374 	orhi	r4,r16,18253
8111d140:	8111d374 	orhi	r4,r16,18253
8111d144:	8111d374 	orhi	r4,r16,18253
8111d148:	8111d374 	orhi	r4,r16,18253
8111d14c:	8111d374 	orhi	r4,r16,18253
8111d150:	8111d374 	orhi	r4,r16,18253
8111d154:	8111d374 	orhi	r4,r16,18253
8111d158:	8111d374 	orhi	r4,r16,18253
8111d15c:	8111d374 	orhi	r4,r16,18253
8111d160:	8111d374 	orhi	r4,r16,18253
8111d164:	8111d374 	orhi	r4,r16,18253
8111d168:	8111d374 	orhi	r4,r16,18253
8111d16c:	8111d374 	orhi	r4,r16,18253
8111d170:	8111d374 	orhi	r4,r16,18253
8111d174:	8111d374 	orhi	r4,r16,18253
8111d178:	8111d374 	orhi	r4,r16,18253
8111d17c:	8111d374 	orhi	r4,r16,18253
8111d180:	8111d374 	orhi	r4,r16,18253
8111d184:	8111d374 	orhi	r4,r16,18253
8111d188:	8111d374 	orhi	r4,r16,18253
8111d18c:	8111d374 	orhi	r4,r16,18253
8111d190:	8111d374 	orhi	r4,r16,18253
8111d194:	8111d374 	orhi	r4,r16,18253
8111d198:	8111d2e8 	cmpgeui	r4,r16,18251
8111d19c:	8111d374 	orhi	r4,r16,18253
8111d1a0:	8111d374 	orhi	r4,r16,18253
8111d1a4:	8111d374 	orhi	r4,r16,18253
8111d1a8:	8111d374 	orhi	r4,r16,18253
8111d1ac:	8111d35c 	xori	r4,r16,18253
8111d1b0:	8111d374 	orhi	r4,r16,18253
8111d1b4:	8111d374 	orhi	r4,r16,18253
8111d1b8:	8111d374 	orhi	r4,r16,18253
8111d1bc:	8111d374 	orhi	r4,r16,18253
8111d1c0:	8111d374 	orhi	r4,r16,18253
8111d1c4:	8111d490 	cmplti	r4,r16,18258
8111d1c8:	8111d490 	cmplti	r4,r16,18258
8111d1cc:	8111d490 	cmplti	r4,r16,18258
8111d1d0:	8111d490 	cmplti	r4,r16,18258
8111d1d4:	8111d490 	cmplti	r4,r16,18258
8111d1d8:	8111d490 	cmplti	r4,r16,18258
8111d1dc:	8111d490 	cmplti	r4,r16,18258
8111d1e0:	8111d490 	cmplti	r4,r16,18258
8111d1e4:	8111d490 	cmplti	r4,r16,18258
8111d1e8:	8111d490 	cmplti	r4,r16,18258
8111d1ec:	8111d374 	orhi	r4,r16,18253
8111d1f0:	8111d374 	orhi	r4,r16,18253
8111d1f4:	8111d374 	orhi	r4,r16,18253
8111d1f8:	8111d374 	orhi	r4,r16,18253
8111d1fc:	8111d374 	orhi	r4,r16,18253
8111d200:	8111d374 	orhi	r4,r16,18253
8111d204:	8111d374 	orhi	r4,r16,18253
8111d208:	8111d374 	orhi	r4,r16,18253
8111d20c:	8111d374 	orhi	r4,r16,18253
8111d210:	8111d374 	orhi	r4,r16,18253
8111d214:	8111d464 	muli	r4,r16,18257
8111d218:	8111d514 	ori	r4,r16,18260
8111d21c:	8111d374 	orhi	r4,r16,18253
8111d220:	8111d514 	ori	r4,r16,18260
8111d224:	8111d374 	orhi	r4,r16,18253
8111d228:	8111d374 	orhi	r4,r16,18253
8111d22c:	8111d374 	orhi	r4,r16,18253
8111d230:	8111d374 	orhi	r4,r16,18253
8111d234:	8111d500 	call	88111d50 <__reset+0x20f1d50>
8111d238:	8111d374 	orhi	r4,r16,18253
8111d23c:	8111d374 	orhi	r4,r16,18253
8111d240:	8111d4d4 	ori	r4,r16,18259
8111d244:	8111d374 	orhi	r4,r16,18253
8111d248:	8111d374 	orhi	r4,r16,18253
8111d24c:	8111d374 	orhi	r4,r16,18253
8111d250:	8111d374 	orhi	r4,r16,18253
8111d254:	8111d374 	orhi	r4,r16,18253
8111d258:	8111d374 	orhi	r4,r16,18253
8111d25c:	8111d374 	orhi	r4,r16,18253
8111d260:	8111d374 	orhi	r4,r16,18253
8111d264:	8111d4ac 	andhi	r4,r16,18258
8111d268:	8111d374 	orhi	r4,r16,18253
8111d26c:	8111d374 	orhi	r4,r16,18253
8111d270:	8111d648 	cmpgei	r4,r16,18265
8111d274:	8111d374 	orhi	r4,r16,18253
8111d278:	8111d374 	orhi	r4,r16,18253
8111d27c:	8111d374 	orhi	r4,r16,18253
8111d280:	8111d374 	orhi	r4,r16,18253
8111d284:	8111d374 	orhi	r4,r16,18253
8111d288:	8111d374 	orhi	r4,r16,18253
8111d28c:	8111d374 	orhi	r4,r16,18253
8111d290:	8111d5cc 	andi	r4,r16,18263
8111d294:	8111d5a4 	muli	r4,r16,18262
8111d298:	8111d514 	ori	r4,r16,18260
8111d29c:	8111d514 	ori	r4,r16,18260
8111d2a0:	8111d514 	ori	r4,r16,18260
8111d2a4:	8111d590 	cmplti	r4,r16,18262
8111d2a8:	8111d6d4 	ori	r4,r16,18267
8111d2ac:	8111d374 	orhi	r4,r16,18253
8111d2b0:	8111d374 	orhi	r4,r16,18253
8111d2b4:	8111d57c 	xorhi	r4,r16,18261
8111d2b8:	8111d374 	orhi	r4,r16,18253
8111d2bc:	8111d54c 	andi	r4,r16,18261
8111d2c0:	8111d528 	cmpgeui	r4,r16,18260
8111d2c4:	8111d438 	rdprs	r4,r16,18256
8111d2c8:	8111d374 	orhi	r4,r16,18253
8111d2cc:	8111d374 	orhi	r4,r16,18253
8111d2d0:	8111d424 	muli	r4,r16,18256
8111d2d4:	8111d374 	orhi	r4,r16,18253
8111d2d8:	8111d3ac 	andhi	r4,r16,18254
8111d2dc:	8111d374 	orhi	r4,r16,18253
8111d2e0:	8111d374 	orhi	r4,r16,18253
8111d2e4:	8111d4ac 	andhi	r4,r16,18258
8111d2e8:	d9809d15 	stw	r6,628(sp)
8111d2ec:	3029883a 	mov	r20,r6
8111d2f0:	e0800117 	ldw	r2,4(fp)
8111d2f4:	0081aa0e 	bge	zero,r2,8111d9a0 <__svfscanf_r+0x9e8>
8111d2f8:	e0800017 	ldw	r2,0(fp)
8111d2fc:	a0ffffc3 	ldbu	r3,-1(r20)
8111d300:	11000003 	ldbu	r4,0(r2)
8111d304:	20ff6e1e 	bne	r4,r3,8111d0c0 <__reset+0xfb0fd0c0>
8111d308:	e0c00117 	ldw	r3,4(fp)
8111d30c:	10800044 	addi	r2,r2,1
8111d310:	e0800015 	stw	r2,0(fp)
8111d314:	18bfffc4 	addi	r2,r3,-1
8111d318:	e0800115 	stw	r2,4(fp)
8111d31c:	94800044 	addi	r18,r18,1
8111d320:	a00d883a 	mov	r6,r20
8111d324:	003f6206 	br	8111d0b0 <__reset+0xfb0fd0b0>
8111d328:	00bfffc4 	movi	r2,-1
8111d32c:	dfc0b417 	ldw	ra,720(sp)
8111d330:	df00b317 	ldw	fp,716(sp)
8111d334:	ddc0b217 	ldw	r23,712(sp)
8111d338:	dd80b117 	ldw	r22,708(sp)
8111d33c:	dd40b017 	ldw	r21,704(sp)
8111d340:	dd00af17 	ldw	r20,700(sp)
8111d344:	dcc0ae17 	ldw	r19,696(sp)
8111d348:	dc80ad17 	ldw	r18,692(sp)
8111d34c:	dc40ac17 	ldw	r17,688(sp)
8111d350:	dc00ab17 	ldw	r16,684(sp)
8111d354:	dec0b504 	addi	sp,sp,724
8111d358:	f800283a 	ret
8111d35c:	a0800043 	ldbu	r2,1(r20)
8111d360:	3029883a 	mov	r20,r6
8111d364:	8c400414 	ori	r17,r17,16
8111d368:	10c03fcc 	andi	r3,r2,255
8111d36c:	a1800044 	addi	r6,r20,1
8111d370:	20ff5e2e 	bgeu	r4,r3,8111d0ec <__reset+0xfb0fd0ec>
8111d374:	38c7883a 	add	r3,r7,r3
8111d378:	18800043 	ldbu	r2,1(r3)
8111d37c:	d9809d15 	stw	r6,628(sp)
8111d380:	00c00044 	movi	r3,1
8111d384:	108000cc 	andi	r2,r2,3
8111d388:	10c18f26 	beq	r2,r3,8111d9c8 <__svfscanf_r+0xa10>
8111d38c:	e0800117 	ldw	r2,4(fp)
8111d390:	00808716 	blt	zero,r2,8111d5b0 <__svfscanf_r+0x5f8>
8111d394:	e00b883a 	mov	r5,fp
8111d398:	b009883a 	mov	r4,r22
8111d39c:	11182980 	call	81118298 <__srefill_r>
8111d3a0:	1001431e 	bne	r2,zero,8111d8b0 <__svfscanf_r+0x8f8>
8111d3a4:	b9c00017 	ldw	r7,0(r23)
8111d3a8:	00008106 	br	8111d5b0 <__svfscanf_r+0x5f8>
8111d3ac:	e0800117 	ldw	r2,4(fp)
8111d3b0:	d9809d15 	stw	r6,628(sp)
8111d3b4:	0081a30e 	bge	zero,r2,8111da44 <__svfscanf_r+0xa8c>
8111d3b8:	00a044b4 	movhi	r2,33042
8111d3bc:	10947204 	addi	r2,r2,20936
8111d3c0:	02000284 	movi	r8,10
8111d3c4:	d880a115 	stw	r2,644(sp)
8111d3c8:	da009e15 	stw	r8,632(sp)
8111d3cc:	050000c4 	movi	r20,3
8111d3d0:	e0c00017 	ldw	r3,0(fp)
8111d3d4:	00000206 	br	8111d3e0 <__svfscanf_r+0x428>
8111d3d8:	18c00044 	addi	r3,r3,1
8111d3dc:	e0c00015 	stw	r3,0(fp)
8111d3e0:	19000003 	ldbu	r4,0(r3)
8111d3e4:	20803fcc 	andi	r2,r4,255
8111d3e8:	3885883a 	add	r2,r7,r2
8111d3ec:	10800043 	ldbu	r2,1(r2)
8111d3f0:	1140020c 	andi	r5,r2,8
8111d3f4:	2801ab26 	beq	r5,zero,8111daa4 <__svfscanf_r+0xaec>
8111d3f8:	e0800117 	ldw	r2,4(fp)
8111d3fc:	94800044 	addi	r18,r18,1
8111d400:	10bfffc4 	addi	r2,r2,-1
8111d404:	e0800115 	stw	r2,4(fp)
8111d408:	00bff316 	blt	zero,r2,8111d3d8 <__reset+0xfb0fd3d8>
8111d40c:	e00b883a 	mov	r5,fp
8111d410:	b009883a 	mov	r4,r22
8111d414:	11182980 	call	81118298 <__srefill_r>
8111d418:	1001251e 	bne	r2,zero,8111d8b0 <__svfscanf_r+0x8f8>
8111d41c:	b9c00017 	ldw	r7,0(r23)
8111d420:	003feb06 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111d424:	e0800117 	ldw	r2,4(fp)
8111d428:	d9809d15 	stw	r6,628(sp)
8111d42c:	00818b0e 	bge	zero,r2,8111da5c <__svfscanf_r+0xaa4>
8111d430:	05000084 	movi	r20,2
8111d434:	003fe606 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111d438:	e0800117 	ldw	r2,4(fp)
8111d43c:	d9809d15 	stw	r6,628(sp)
8111d440:	8c408814 	ori	r17,r17,544
8111d444:	00801d0e 	bge	zero,r2,8111d4bc <__svfscanf_r+0x504>
8111d448:	00a044b4 	movhi	r2,33042
8111d44c:	10947204 	addi	r2,r2,20936
8111d450:	02000404 	movi	r8,16
8111d454:	d880a115 	stw	r2,644(sp)
8111d458:	da009e15 	stw	r8,632(sp)
8111d45c:	050000c4 	movi	r20,3
8111d460:	003fdb06 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111d464:	e0800117 	ldw	r2,4(fp)
8111d468:	d9809d15 	stw	r6,628(sp)
8111d46c:	8c400054 	ori	r17,r17,1
8111d470:	00bfc80e 	bge	zero,r2,8111d394 <__reset+0xfb0fd394>
8111d474:	00e044b4 	movhi	r3,33042
8111d478:	18e22704 	addi	r3,r3,-30564
8111d47c:	02000284 	movi	r8,10
8111d480:	d8c0a115 	stw	r3,644(sp)
8111d484:	da009e15 	stw	r8,632(sp)
8111d488:	050000c4 	movi	r20,3
8111d48c:	003fd006 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111d490:	9cc002a4 	muli	r19,r19,10
8111d494:	a0800043 	ldbu	r2,1(r20)
8111d498:	3029883a 	mov	r20,r6
8111d49c:	98e7883a 	add	r19,r19,r3
8111d4a0:	9cfff404 	addi	r19,r19,-48
8111d4a4:	10c03fcc 	andi	r3,r2,255
8111d4a8:	003f0e06 	br	8111d0e4 <__reset+0xfb0fd0e4>
8111d4ac:	e0800117 	ldw	r2,4(fp)
8111d4b0:	d9809d15 	stw	r6,628(sp)
8111d4b4:	8c408014 	ori	r17,r17,512
8111d4b8:	00bfe316 	blt	zero,r2,8111d448 <__reset+0xfb0fd448>
8111d4bc:	e00b883a 	mov	r5,fp
8111d4c0:	b009883a 	mov	r4,r22
8111d4c4:	11182980 	call	81118298 <__srefill_r>
8111d4c8:	1000f91e 	bne	r2,zero,8111d8b0 <__svfscanf_r+0x8f8>
8111d4cc:	b9c00017 	ldw	r7,0(r23)
8111d4d0:	003fdd06 	br	8111d448 <__reset+0xfb0fd448>
8111d4d4:	e0800117 	ldw	r2,4(fp)
8111d4d8:	d9809d15 	stw	r6,628(sp)
8111d4dc:	8c400054 	ori	r17,r17,1
8111d4e0:	0080140e 	bge	zero,r2,8111d534 <__svfscanf_r+0x57c>
8111d4e4:	00a044b4 	movhi	r2,33042
8111d4e8:	10947204 	addi	r2,r2,20936
8111d4ec:	02000204 	movi	r8,8
8111d4f0:	d880a115 	stw	r2,644(sp)
8111d4f4:	da009e15 	stw	r8,632(sp)
8111d4f8:	050000c4 	movi	r20,3
8111d4fc:	003fb406 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111d500:	a0800043 	ldbu	r2,1(r20)
8111d504:	8c400094 	ori	r17,r17,2
8111d508:	3029883a 	mov	r20,r6
8111d50c:	10c03fcc 	andi	r3,r2,255
8111d510:	003ef406 	br	8111d0e4 <__reset+0xfb0fd0e4>
8111d514:	e0800117 	ldw	r2,4(fp)
8111d518:	d9809d15 	stw	r6,628(sp)
8111d51c:	0081420e 	bge	zero,r2,8111da28 <__svfscanf_r+0xa70>
8111d520:	05000104 	movi	r20,4
8111d524:	003faa06 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111d528:	e0800117 	ldw	r2,4(fp)
8111d52c:	d9809d15 	stw	r6,628(sp)
8111d530:	00bfec16 	blt	zero,r2,8111d4e4 <__reset+0xfb0fd4e4>
8111d534:	e00b883a 	mov	r5,fp
8111d538:	b009883a 	mov	r4,r22
8111d53c:	11182980 	call	81118298 <__srefill_r>
8111d540:	1000db1e 	bne	r2,zero,8111d8b0 <__svfscanf_r+0x8f8>
8111d544:	b9c00017 	ldw	r7,0(r23)
8111d548:	003fe606 	br	8111d4e4 <__reset+0xfb0fd4e4>
8111d54c:	d9809d15 	stw	r6,628(sp)
8111d550:	8880040c 	andi	r2,r17,16
8111d554:	10009c1e 	bne	r2,zero,8111d7c8 <__svfscanf_r+0x810>
8111d558:	8880010c 	andi	r2,r17,4
8111d55c:	10011e26 	beq	r2,zero,8111d9d8 <__svfscanf_r+0xa20>
8111d560:	da009c17 	ldw	r8,624(sp)
8111d564:	3029883a 	mov	r20,r6
8111d568:	40800017 	ldw	r2,0(r8)
8111d56c:	42000104 	addi	r8,r8,4
8111d570:	da009c15 	stw	r8,624(sp)
8111d574:	1480000d 	sth	r18,0(r2)
8111d578:	003ecc06 	br	8111d0ac <__reset+0xfb0fd0ac>
8111d57c:	a0c00043 	ldbu	r3,1(r20)
8111d580:	19410c26 	beq	r3,r5,8111d9b4 <__svfscanf_r+0x9fc>
8111d584:	8c400054 	ori	r17,r17,1
8111d588:	3029883a 	mov	r20,r6
8111d58c:	003ed506 	br	8111d0e4 <__reset+0xfb0fd0e4>
8111d590:	a0800043 	ldbu	r2,1(r20)
8111d594:	8c400114 	ori	r17,r17,4
8111d598:	3029883a 	mov	r20,r6
8111d59c:	10c03fcc 	andi	r3,r2,255
8111d5a0:	003ed006 	br	8111d0e4 <__reset+0xfb0fd0e4>
8111d5a4:	e0800117 	ldw	r2,4(fp)
8111d5a8:	d9809d15 	stw	r6,628(sp)
8111d5ac:	00bf790e 	bge	zero,r2,8111d394 <__reset+0xfb0fd394>
8111d5b0:	00a044b4 	movhi	r2,33042
8111d5b4:	10a22704 	addi	r2,r2,-30564
8111d5b8:	02000284 	movi	r8,10
8111d5bc:	d880a115 	stw	r2,644(sp)
8111d5c0:	da009e15 	stw	r8,632(sp)
8111d5c4:	050000c4 	movi	r20,3
8111d5c8:	003f8106 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111d5cc:	e0800117 	ldw	r2,4(fp)
8111d5d0:	d9809d15 	stw	r6,628(sp)
8111d5d4:	0080c40e 	bge	zero,r2,8111d8e8 <__svfscanf_r+0x930>
8111d5d8:	9800011e 	bne	r19,zero,8111d5e0 <__svfscanf_r+0x628>
8111d5dc:	04c00044 	movi	r19,1
8111d5e0:	8880004c 	andi	r2,r17,1
8111d5e4:	1000441e 	bne	r2,zero,8111d6f8 <__svfscanf_r+0x740>
8111d5e8:	8c40040c 	andi	r17,r17,16
8111d5ec:	8800da26 	beq	r17,zero,8111d958 <__svfscanf_r+0x9a0>
8111d5f0:	0021883a 	mov	r16,zero
8111d5f4:	00000806 	br	8111d618 <__svfscanf_r+0x660>
8111d5f8:	1887883a 	add	r3,r3,r2
8111d5fc:	e00b883a 	mov	r5,fp
8111d600:	b009883a 	mov	r4,r22
8111d604:	e0c00015 	stw	r3,0(fp)
8111d608:	80a1883a 	add	r16,r16,r2
8111d60c:	98a7c83a 	sub	r19,r19,r2
8111d610:	11182980 	call	81118298 <__srefill_r>
8111d614:	1000ca1e 	bne	r2,zero,8111d940 <__svfscanf_r+0x988>
8111d618:	e0800117 	ldw	r2,4(fp)
8111d61c:	e0c00017 	ldw	r3,0(fp)
8111d620:	14fff516 	blt	r2,r19,8111d5f8 <__reset+0xfb0fd5f8>
8111d624:	14c5c83a 	sub	r2,r2,r19
8111d628:	1cd5883a 	add	r10,r3,r19
8111d62c:	84e1883a 	add	r16,r16,r19
8111d630:	e0800115 	stw	r2,4(fp)
8111d634:	e2800015 	stw	r10,0(fp)
8111d638:	dd009d17 	ldw	r20,628(sp)
8111d63c:	9425883a 	add	r18,r18,r16
8111d640:	a00d883a 	mov	r6,r20
8111d644:	003e9a06 	br	8111d0b0 <__reset+0xfb0fd0b0>
8111d648:	300b883a 	mov	r5,r6
8111d64c:	d9005884 	addi	r4,sp,354
8111d650:	d9809d15 	stw	r6,628(sp)
8111d654:	11235a00 	call	811235a0 <__sccl>
8111d658:	1029883a 	mov	r20,r2
8111d65c:	e0800117 	ldw	r2,4(fp)
8111d660:	0081050e 	bge	zero,r2,8111da78 <__svfscanf_r+0xac0>
8111d664:	e1000017 	ldw	r4,0(fp)
8111d668:	20800003 	ldbu	r2,0(r4)
8111d66c:	98005926 	beq	r19,zero,8111d7d4 <__svfscanf_r+0x81c>
8111d670:	8c40040c 	andi	r17,r17,16
8111d674:	88005a26 	beq	r17,zero,8111d7e0 <__svfscanf_r+0x828>
8111d678:	9823883a 	mov	r17,r19
8111d67c:	0021883a 	mov	r16,zero
8111d680:	00000106 	br	8111d688 <__svfscanf_r+0x6d0>
8111d684:	20800003 	ldbu	r2,0(r4)
8111d688:	10803fcc 	andi	r2,r2,255
8111d68c:	d8c05884 	addi	r3,sp,354
8111d690:	1885883a 	add	r2,r3,r2
8111d694:	10800007 	ldb	r2,0(r2)
8111d698:	1000ad26 	beq	r2,zero,8111d950 <__svfscanf_r+0x998>
8111d69c:	e0800117 	ldw	r2,4(fp)
8111d6a0:	21000044 	addi	r4,r4,1
8111d6a4:	84000044 	addi	r16,r16,1
8111d6a8:	10bfffc4 	addi	r2,r2,-1
8111d6ac:	e0800115 	stw	r2,4(fp)
8111d6b0:	e1000015 	stw	r4,0(fp)
8111d6b4:	84c0a026 	beq	r16,r19,8111d938 <__svfscanf_r+0x980>
8111d6b8:	00bff216 	blt	zero,r2,8111d684 <__reset+0xfb0fd684>
8111d6bc:	e00b883a 	mov	r5,fp
8111d6c0:	b009883a 	mov	r4,r22
8111d6c4:	11182980 	call	81118298 <__srefill_r>
8111d6c8:	10009a1e 	bne	r2,zero,8111d934 <__svfscanf_r+0x97c>
8111d6cc:	e1000017 	ldw	r4,0(fp)
8111d6d0:	003fec06 	br	8111d684 <__reset+0xfb0fd684>
8111d6d4:	e0800117 	ldw	r2,4(fp)
8111d6d8:	d9809d15 	stw	r6,628(sp)
8111d6dc:	0080eb0e 	bge	zero,r2,8111da8c <__svfscanf_r+0xad4>
8111d6e0:	00a044b4 	movhi	r2,33042
8111d6e4:	10a22704 	addi	r2,r2,-30564
8111d6e8:	d880a115 	stw	r2,644(sp)
8111d6ec:	d8009e15 	stw	zero,632(sp)
8111d6f0:	050000c4 	movi	r20,3
8111d6f4:	003f3606 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111d6f8:	dd409904 	addi	r21,sp,612
8111d6fc:	8c40040c 	andi	r17,r17,16
8111d700:	01800204 	movi	r6,8
8111d704:	000b883a 	mov	r5,zero
8111d708:	a809883a 	mov	r4,r21
8111d70c:	dc409f15 	stw	r17,636(sp)
8111d710:	1117e1c0 	call	81117e1c <memset>
8111d714:	dc409f17 	ldw	r17,636(sp)
8111d718:	88006e26 	beq	r17,zero,8111d8d4 <__svfscanf_r+0x91c>
8111d71c:	0029883a 	mov	r20,zero
8111d720:	0023883a 	mov	r17,zero
8111d724:	11219bc0 	call	811219bc <__locale_mb_cur_max>
8111d728:	14406126 	beq	r2,r17,8111d8b0 <__svfscanf_r+0x8f8>
8111d72c:	e0800017 	ldw	r2,0(fp)
8111d730:	e0c00117 	ldw	r3,4(fp)
8111d734:	d9000104 	addi	r4,sp,4
8111d738:	12000003 	ldbu	r8,0(r2)
8111d73c:	18ffffc4 	addi	r3,r3,-1
8111d740:	10800044 	addi	r2,r2,1
8111d744:	e0c00115 	stw	r3,4(fp)
8111d748:	e0800015 	stw	r2,0(fp)
8111d74c:	8c000044 	addi	r16,r17,1
8111d750:	dd400015 	stw	r21,0(sp)
8111d754:	2463883a 	add	r17,r4,r17
8111d758:	200d883a 	mov	r6,r4
8111d75c:	a00b883a 	mov	r5,r20
8111d760:	800f883a 	mov	r7,r16
8111d764:	b009883a 	mov	r4,r22
8111d768:	8a000005 	stb	r8,0(r17)
8111d76c:	1121a780 	call	81121a78 <_mbrtowc_r>
8111d770:	017fffc4 	movi	r5,-1
8111d774:	11404e26 	beq	r2,r5,8111d8b0 <__svfscanf_r+0x8f8>
8111d778:	1000601e 	bne	r2,zero,8111d8fc <__svfscanf_r+0x944>
8111d77c:	da009f17 	ldw	r8,636(sp)
8111d780:	4000641e 	bne	r8,zero,8111d914 <__svfscanf_r+0x95c>
8111d784:	a0000015 	stw	zero,0(r20)
8111d788:	9425883a 	add	r18,r18,r16
8111d78c:	9967883a 	add	r19,r19,r5
8111d790:	a5000104 	addi	r20,r20,4
8111d794:	e0800117 	ldw	r2,4(fp)
8111d798:	0023883a 	mov	r17,zero
8111d79c:	00804b16 	blt	zero,r2,8111d8cc <__svfscanf_r+0x914>
8111d7a0:	e00b883a 	mov	r5,fp
8111d7a4:	b009883a 	mov	r4,r22
8111d7a8:	11182980 	call	81118298 <__srefill_r>
8111d7ac:	10004726 	beq	r2,zero,8111d8cc <__svfscanf_r+0x914>
8111d7b0:	88003f1e 	bne	r17,zero,8111d8b0 <__svfscanf_r+0x8f8>
8111d7b4:	d8c09f17 	ldw	r3,636(sp)
8111d7b8:	1800031e 	bne	r3,zero,8111d7c8 <__svfscanf_r+0x810>
8111d7bc:	da00a017 	ldw	r8,640(sp)
8111d7c0:	42000044 	addi	r8,r8,1
8111d7c4:	da00a015 	stw	r8,640(sp)
8111d7c8:	dd009d17 	ldw	r20,628(sp)
8111d7cc:	a00d883a 	mov	r6,r20
8111d7d0:	003e3706 	br	8111d0b0 <__reset+0xfb0fd0b0>
8111d7d4:	8c40040c 	andi	r17,r17,16
8111d7d8:	04ffffc4 	movi	r19,-1
8111d7dc:	883fa61e 	bne	r17,zero,8111d678 <__reset+0xfb0fd678>
8111d7e0:	da009c17 	ldw	r8,624(sp)
8111d7e4:	9abfffc4 	addi	r10,r19,-1
8111d7e8:	44000017 	ldw	r16,0(r8)
8111d7ec:	44400104 	addi	r17,r8,4
8111d7f0:	8007883a 	mov	r3,r16
8111d7f4:	82ab883a 	add	r21,r16,r10
8111d7f8:	00000306 	br	8111d808 <__svfscanf_r+0x850>
8111d7fc:	e1000017 	ldw	r4,0(fp)
8111d800:	9807883a 	mov	r3,r19
8111d804:	20800003 	ldbu	r2,0(r4)
8111d808:	10803fcc 	andi	r2,r2,255
8111d80c:	d9405884 	addi	r5,sp,354
8111d810:	2885883a 	add	r2,r5,r2
8111d814:	10800007 	ldb	r2,0(r2)
8111d818:	10004b26 	beq	r2,zero,8111d948 <__svfscanf_r+0x990>
8111d81c:	e0800117 	ldw	r2,4(fp)
8111d820:	21400044 	addi	r5,r4,1
8111d824:	e1400015 	stw	r5,0(fp)
8111d828:	10bfffc4 	addi	r2,r2,-1
8111d82c:	e0800115 	stw	r2,4(fp)
8111d830:	20800003 	ldbu	r2,0(r4)
8111d834:	1cc00044 	addi	r19,r3,1
8111d838:	18800005 	stb	r2,0(r3)
8111d83c:	1d400726 	beq	r3,r21,8111d85c <__svfscanf_r+0x8a4>
8111d840:	e0800117 	ldw	r2,4(fp)
8111d844:	00bfed16 	blt	zero,r2,8111d7fc <__reset+0xfb0fd7fc>
8111d848:	e00b883a 	mov	r5,fp
8111d84c:	b009883a 	mov	r4,r22
8111d850:	11182980 	call	81118298 <__srefill_r>
8111d854:	103fe926 	beq	r2,zero,8111d7fc <__reset+0xfb0fd7fc>
8111d858:	84c01526 	beq	r16,r19,8111d8b0 <__svfscanf_r+0x8f8>
8111d85c:	9c21c83a 	sub	r16,r19,r16
8111d860:	803e1726 	beq	r16,zero,8111d0c0 <__reset+0xfb0fd0c0>
8111d864:	da00a017 	ldw	r8,640(sp)
8111d868:	98000005 	stb	zero,0(r19)
8111d86c:	dc409c15 	stw	r17,624(sp)
8111d870:	42000044 	addi	r8,r8,1
8111d874:	da00a015 	stw	r8,640(sp)
8111d878:	9425883a 	add	r18,r18,r16
8111d87c:	a00d883a 	mov	r6,r20
8111d880:	003e0b06 	br	8111d0b0 <__reset+0xfb0fd0b0>
8111d884:	017fff84 	movi	r5,-2
8111d888:	11439b1e 	bne	r2,r5,8111e6f8 <__svfscanf_r+0x1740>
8111d88c:	8821883a 	mov	r16,r17
8111d890:	e0800117 	ldw	r2,4(fp)
8111d894:	0082e516 	blt	zero,r2,8111e42c <__svfscanf_r+0x1474>
8111d898:	e00b883a 	mov	r5,fp
8111d89c:	b009883a 	mov	r4,r22
8111d8a0:	11182980 	call	81118298 <__srefill_r>
8111d8a4:	1002e126 	beq	r2,zero,8111e42c <__svfscanf_r+0x1474>
8111d8a8:	dc409f17 	ldw	r17,636(sp)
8111d8ac:	8002e826 	beq	r16,zero,8111e450 <__svfscanf_r+0x1498>
8111d8b0:	da00a017 	ldw	r8,640(sp)
8111d8b4:	403e9c26 	beq	r8,zero,8111d328 <__reset+0xfb0fd328>
8111d8b8:	e080030b 	ldhu	r2,12(fp)
8111d8bc:	1080100c 	andi	r2,r2,64
8111d8c0:	103e991e 	bne	r2,zero,8111d328 <__reset+0xfb0fd328>
8111d8c4:	4005883a 	mov	r2,r8
8111d8c8:	003e9806 	br	8111d32c <__reset+0xfb0fd32c>
8111d8cc:	983f951e 	bne	r19,zero,8111d724 <__reset+0xfb0fd724>
8111d8d0:	003fb806 	br	8111d7b4 <__reset+0xfb0fd7b4>
8111d8d4:	da009c17 	ldw	r8,624(sp)
8111d8d8:	45000017 	ldw	r20,0(r8)
8111d8dc:	42000104 	addi	r8,r8,4
8111d8e0:	da009c15 	stw	r8,624(sp)
8111d8e4:	003f8e06 	br	8111d720 <__reset+0xfb0fd720>
8111d8e8:	e00b883a 	mov	r5,fp
8111d8ec:	b009883a 	mov	r4,r22
8111d8f0:	11182980 	call	81118298 <__srefill_r>
8111d8f4:	103f3826 	beq	r2,zero,8111d5d8 <__reset+0xfb0fd5d8>
8111d8f8:	003fed06 	br	8111d8b0 <__reset+0xfb0fd8b0>
8111d8fc:	00ffff84 	movi	r3,-2
8111d900:	10c0071e 	bne	r2,r3,8111d920 <__svfscanf_r+0x968>
8111d904:	e0800117 	ldw	r2,4(fp)
8111d908:	8023883a 	mov	r17,r16
8111d90c:	00bf8516 	blt	zero,r2,8111d724 <__reset+0xfb0fd724>
8111d910:	003fa306 	br	8111d7a0 <__reset+0xfb0fd7a0>
8111d914:	9425883a 	add	r18,r18,r16
8111d918:	9cffffc4 	addi	r19,r19,-1
8111d91c:	003f9d06 	br	8111d794 <__reset+0xfb0fd794>
8111d920:	da009f17 	ldw	r8,636(sp)
8111d924:	9425883a 	add	r18,r18,r16
8111d928:	9cffffc4 	addi	r19,r19,-1
8111d92c:	403f9826 	beq	r8,zero,8111d790 <__reset+0xfb0fd790>
8111d930:	003f9806 	br	8111d794 <__reset+0xfb0fd794>
8111d934:	8023883a 	mov	r17,r16
8111d938:	8821883a 	mov	r16,r17
8111d93c:	003fce06 	br	8111d878 <__reset+0xfb0fd878>
8111d940:	803f3d1e 	bne	r16,zero,8111d638 <__reset+0xfb0fd638>
8111d944:	003fda06 	br	8111d8b0 <__reset+0xfb0fd8b0>
8111d948:	1827883a 	mov	r19,r3
8111d94c:	003fc306 	br	8111d85c <__reset+0xfb0fd85c>
8111d950:	803fc91e 	bne	r16,zero,8111d878 <__reset+0xfb0fd878>
8111d954:	003dda06 	br	8111d0c0 <__reset+0xfb0fd0c0>
8111d958:	da009c17 	ldw	r8,624(sp)
8111d95c:	df000015 	stw	fp,0(sp)
8111d960:	980f883a 	mov	r7,r19
8111d964:	41400017 	ldw	r5,0(r8)
8111d968:	01800044 	movi	r6,1
8111d96c:	b009883a 	mov	r4,r22
8111d970:	1120b900 	call	81120b90 <_fread_r>
8111d974:	da009c17 	ldw	r8,624(sp)
8111d978:	40c00104 	addi	r3,r8,4
8111d97c:	103fcc26 	beq	r2,zero,8111d8b0 <__reset+0xfb0fd8b0>
8111d980:	da00a017 	ldw	r8,640(sp)
8111d984:	dd009d17 	ldw	r20,628(sp)
8111d988:	90a5883a 	add	r18,r18,r2
8111d98c:	42000044 	addi	r8,r8,1
8111d990:	da00a015 	stw	r8,640(sp)
8111d994:	d8c09c15 	stw	r3,624(sp)
8111d998:	a00d883a 	mov	r6,r20
8111d99c:	003dc406 	br	8111d0b0 <__reset+0xfb0fd0b0>
8111d9a0:	e00b883a 	mov	r5,fp
8111d9a4:	b009883a 	mov	r4,r22
8111d9a8:	11182980 	call	81118298 <__srefill_r>
8111d9ac:	103e5226 	beq	r2,zero,8111d2f8 <__reset+0xfb0fd2f8>
8111d9b0:	003fbf06 	br	8111d8b0 <__reset+0xfb0fd8b0>
8111d9b4:	a0800083 	ldbu	r2,2(r20)
8111d9b8:	8c400094 	ori	r17,r17,2
8111d9bc:	a5000084 	addi	r20,r20,2
8111d9c0:	10c03fcc 	andi	r3,r2,255
8111d9c4:	003dc706 	br	8111d0e4 <__reset+0xfb0fd0e4>
8111d9c8:	e0800117 	ldw	r2,4(fp)
8111d9cc:	88e2b03a 	or	r17,r17,r3
8111d9d0:	00bef716 	blt	zero,r2,8111d5b0 <__reset+0xfb0fd5b0>
8111d9d4:	003e6f06 	br	8111d394 <__reset+0xfb0fd394>
8111d9d8:	8880004c 	andi	r2,r17,1
8111d9dc:	10000b1e 	bne	r2,zero,8111da0c <__svfscanf_r+0xa54>
8111d9e0:	8c40008c 	andi	r17,r17,2
8111d9e4:	88000926 	beq	r17,zero,8111da0c <__svfscanf_r+0xa54>
8111d9e8:	da009c17 	ldw	r8,624(sp)
8111d9ec:	9007d7fa 	srai	r3,r18,31
8111d9f0:	dd009d17 	ldw	r20,628(sp)
8111d9f4:	40800017 	ldw	r2,0(r8)
8111d9f8:	42000104 	addi	r8,r8,4
8111d9fc:	da009c15 	stw	r8,624(sp)
8111da00:	14800015 	stw	r18,0(r2)
8111da04:	10c00115 	stw	r3,4(r2)
8111da08:	003da806 	br	8111d0ac <__reset+0xfb0fd0ac>
8111da0c:	da009c17 	ldw	r8,624(sp)
8111da10:	dd009d17 	ldw	r20,628(sp)
8111da14:	40800017 	ldw	r2,0(r8)
8111da18:	42000104 	addi	r8,r8,4
8111da1c:	da009c15 	stw	r8,624(sp)
8111da20:	14800015 	stw	r18,0(r2)
8111da24:	003da106 	br	8111d0ac <__reset+0xfb0fd0ac>
8111da28:	e00b883a 	mov	r5,fp
8111da2c:	b009883a 	mov	r4,r22
8111da30:	11182980 	call	81118298 <__srefill_r>
8111da34:	103f9e1e 	bne	r2,zero,8111d8b0 <__reset+0xfb0fd8b0>
8111da38:	b9c00017 	ldw	r7,0(r23)
8111da3c:	05000104 	movi	r20,4
8111da40:	003e6306 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111da44:	e00b883a 	mov	r5,fp
8111da48:	b009883a 	mov	r4,r22
8111da4c:	11182980 	call	81118298 <__srefill_r>
8111da50:	103f971e 	bne	r2,zero,8111d8b0 <__reset+0xfb0fd8b0>
8111da54:	b9c00017 	ldw	r7,0(r23)
8111da58:	003e5706 	br	8111d3b8 <__reset+0xfb0fd3b8>
8111da5c:	e00b883a 	mov	r5,fp
8111da60:	b009883a 	mov	r4,r22
8111da64:	11182980 	call	81118298 <__srefill_r>
8111da68:	103f911e 	bne	r2,zero,8111d8b0 <__reset+0xfb0fd8b0>
8111da6c:	b9c00017 	ldw	r7,0(r23)
8111da70:	05000084 	movi	r20,2
8111da74:	003e5606 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111da78:	e00b883a 	mov	r5,fp
8111da7c:	b009883a 	mov	r4,r22
8111da80:	11182980 	call	81118298 <__srefill_r>
8111da84:	103ef726 	beq	r2,zero,8111d664 <__reset+0xfb0fd664>
8111da88:	003f8906 	br	8111d8b0 <__reset+0xfb0fd8b0>
8111da8c:	e00b883a 	mov	r5,fp
8111da90:	b009883a 	mov	r4,r22
8111da94:	11182980 	call	81118298 <__srefill_r>
8111da98:	103f851e 	bne	r2,zero,8111d8b0 <__reset+0xfb0fd8b0>
8111da9c:	b9c00017 	ldw	r7,0(r23)
8111daa0:	003f0f06 	br	8111d6e0 <__reset+0xfb0fd6e0>
8111daa4:	014000c4 	movi	r5,3
8111daa8:	a1414a26 	beq	r20,r5,8111dfd4 <__svfscanf_r+0x101c>
8111daac:	01000104 	movi	r4,4
8111dab0:	a101f11e 	bne	r20,r4,8111e278 <__svfscanf_r+0x12c0>
8111dab4:	b009883a 	mov	r4,r22
8111dab8:	11219e00 	call	811219e0 <_localeconv_r>
8111dabc:	10800017 	ldw	r2,0(r2)
8111dac0:	98ffffc4 	addi	r3,r19,-1
8111dac4:	d880a315 	stw	r2,652(sp)
8111dac8:	00805704 	movi	r2,348
8111dacc:	10c21e2e 	bgeu	r2,r3,8111e348 <__svfscanf_r+0x1390>
8111dad0:	9cffa8c4 	addi	r19,r19,-349
8111dad4:	dcc0a215 	stw	r19,648(sp)
8111dad8:	04c05744 	movi	r19,349
8111dadc:	8d01e014 	ori	r20,r17,1920
8111dae0:	0023883a 	mov	r17,zero
8111dae4:	dc000104 	addi	r16,sp,4
8111dae8:	8805883a 	mov	r2,r17
8111daec:	0019883a 	mov	r12,zero
8111daf0:	8023883a 	mov	r17,r16
8111daf4:	b007883a 	mov	r3,r22
8111daf8:	9821883a 	mov	r16,r19
8111dafc:	002b883a 	mov	r21,zero
8111db00:	d800a515 	stw	zero,660(sp)
8111db04:	d800a415 	stw	zero,656(sp)
8111db08:	d8009f15 	stw	zero,636(sp)
8111db0c:	01c01384 	movi	r7,78
8111db10:	602d883a 	mov	r22,r12
8111db14:	1027883a 	mov	r19,r2
8111db18:	e1000017 	ldw	r4,0(fp)
8111db1c:	21400003 	ldbu	r5,0(r4)
8111db20:	28bff544 	addi	r2,r5,-43
8111db24:	10803fcc 	andi	r2,r2,255
8111db28:	38810e36 	bltu	r7,r2,8111df64 <__svfscanf_r+0xfac>
8111db2c:	100490ba 	slli	r2,r2,2
8111db30:	01a044b4 	movhi	r6,33042
8111db34:	31b6d104 	addi	r6,r6,-9404
8111db38:	1185883a 	add	r2,r2,r6
8111db3c:	10800017 	ldw	r2,0(r2)
8111db40:	1000683a 	jmp	r2
8111db44:	8111de3c 	xorhi	r4,r16,18296
8111db48:	8111df64 	muli	r4,r16,18301
8111db4c:	8111de3c 	xorhi	r4,r16,18296
8111db50:	8111df64 	muli	r4,r16,18301
8111db54:	8111df64 	muli	r4,r16,18301
8111db58:	8111de10 	cmplti	r4,r16,18296
8111db5c:	8111dc80 	call	88111dc8 <__reset+0x20f1dc8>
8111db60:	8111dc80 	call	88111dc8 <__reset+0x20f1dc8>
8111db64:	8111dc80 	call	88111dc8 <__reset+0x20f1dc8>
8111db68:	8111dc80 	call	88111dc8 <__reset+0x20f1dc8>
8111db6c:	8111dc80 	call	88111dc8 <__reset+0x20f1dc8>
8111db70:	8111dc80 	call	88111dc8 <__reset+0x20f1dc8>
8111db74:	8111dc80 	call	88111dc8 <__reset+0x20f1dc8>
8111db78:	8111dc80 	call	88111dc8 <__reset+0x20f1dc8>
8111db7c:	8111dc80 	call	88111dc8 <__reset+0x20f1dc8>
8111db80:	8111df64 	muli	r4,r16,18301
8111db84:	8111df64 	muli	r4,r16,18301
8111db88:	8111df64 	muli	r4,r16,18301
8111db8c:	8111df64 	muli	r4,r16,18301
8111db90:	8111df64 	muli	r4,r16,18301
8111db94:	8111df64 	muli	r4,r16,18301
8111db98:	8111df64 	muli	r4,r16,18301
8111db9c:	8111df54 	ori	r4,r16,18301
8111dba0:	8111df64 	muli	r4,r16,18301
8111dba4:	8111df64 	muli	r4,r16,18301
8111dba8:	8111df64 	muli	r4,r16,18301
8111dbac:	8111df10 	cmplti	r4,r16,18300
8111dbb0:	8111def4 	orhi	r4,r16,18299
8111dbb4:	8111df64 	muli	r4,r16,18301
8111dbb8:	8111df64 	muli	r4,r16,18301
8111dbbc:	8111dec0 	call	88111dec <__reset+0x20f1dec>
8111dbc0:	8111df64 	muli	r4,r16,18301
8111dbc4:	8111df64 	muli	r4,r16,18301
8111dbc8:	8111df64 	muli	r4,r16,18301
8111dbcc:	8111df64 	muli	r4,r16,18301
8111dbd0:	8111de88 	cmpgei	r4,r16,18298
8111dbd4:	8111df64 	muli	r4,r16,18301
8111dbd8:	8111df64 	muli	r4,r16,18301
8111dbdc:	8111df64 	muli	r4,r16,18301
8111dbe0:	8111df64 	muli	r4,r16,18301
8111dbe4:	8111df64 	muli	r4,r16,18301
8111dbe8:	8111de6c 	andhi	r4,r16,18297
8111dbec:	8111df64 	muli	r4,r16,18301
8111dbf0:	8111df64 	muli	r4,r16,18301
8111dbf4:	8111df64 	muli	r4,r16,18301
8111dbf8:	8111df64 	muli	r4,r16,18301
8111dbfc:	8111de50 	cmplti	r4,r16,18297
8111dc00:	8111df64 	muli	r4,r16,18301
8111dc04:	8111df64 	muli	r4,r16,18301
8111dc08:	8111df64 	muli	r4,r16,18301
8111dc0c:	8111df64 	muli	r4,r16,18301
8111dc10:	8111df64 	muli	r4,r16,18301
8111dc14:	8111df64 	muli	r4,r16,18301
8111dc18:	8111df64 	muli	r4,r16,18301
8111dc1c:	8111df54 	ori	r4,r16,18301
8111dc20:	8111df64 	muli	r4,r16,18301
8111dc24:	8111df64 	muli	r4,r16,18301
8111dc28:	8111df64 	muli	r4,r16,18301
8111dc2c:	8111df10 	cmplti	r4,r16,18300
8111dc30:	8111def4 	orhi	r4,r16,18299
8111dc34:	8111df64 	muli	r4,r16,18301
8111dc38:	8111df64 	muli	r4,r16,18301
8111dc3c:	8111dec0 	call	88111dec <__reset+0x20f1dec>
8111dc40:	8111df64 	muli	r4,r16,18301
8111dc44:	8111df64 	muli	r4,r16,18301
8111dc48:	8111df64 	muli	r4,r16,18301
8111dc4c:	8111df64 	muli	r4,r16,18301
8111dc50:	8111de88 	cmpgei	r4,r16,18298
8111dc54:	8111df64 	muli	r4,r16,18301
8111dc58:	8111df64 	muli	r4,r16,18301
8111dc5c:	8111df64 	muli	r4,r16,18301
8111dc60:	8111df64 	muli	r4,r16,18301
8111dc64:	8111df64 	muli	r4,r16,18301
8111dc68:	8111de6c 	andhi	r4,r16,18297
8111dc6c:	8111df64 	muli	r4,r16,18301
8111dc70:	8111df64 	muli	r4,r16,18301
8111dc74:	8111df64 	muli	r4,r16,18301
8111dc78:	8111df64 	muli	r4,r16,18301
8111dc7c:	8111de50 	cmplti	r4,r16,18297
8111dc80:	a8803fcc 	andi	r2,r21,255
8111dc84:	1080201c 	xori	r2,r2,128
8111dc88:	10bfe004 	addi	r2,r2,-128
8111dc8c:	b085883a 	add	r2,r22,r2
8111dc90:	10000d1e 	bne	r2,zero,8111dcc8 <__svfscanf_r+0xd10>
8111dc94:	00bf9fc4 	movi	r2,-385
8111dc98:	a0a8703a 	and	r20,r20,r2
8111dc9c:	89400005 	stb	r5,0(r17)
8111dca0:	8c400044 	addi	r17,r17,1
8111dca4:	e0800117 	ldw	r2,4(fp)
8111dca8:	843fffc4 	addi	r16,r16,-1
8111dcac:	94800044 	addi	r18,r18,1
8111dcb0:	10bfffc4 	addi	r2,r2,-1
8111dcb4:	e0800115 	stw	r2,4(fp)
8111dcb8:	0080b40e 	bge	zero,r2,8111df8c <__svfscanf_r+0xfd4>
8111dcbc:	21000044 	addi	r4,r4,1
8111dcc0:	e1000015 	stw	r4,0(fp)
8111dcc4:	803f941e 	bne	r16,zero,8111db18 <__reset+0xfb0fdb18>
8111dcc8:	8821883a 	mov	r16,r17
8111dccc:	b019883a 	mov	r12,r22
8111dcd0:	9823883a 	mov	r17,r19
8111dcd4:	182d883a 	mov	r22,r3
8111dcd8:	9801961e 	bne	r19,zero,8111e334 <__svfscanf_r+0x137c>
8111dcdc:	633fffc4 	addi	r12,r12,-1
8111dce0:	00800044 	movi	r2,1
8111dce4:	1302882e 	bgeu	r2,r12,8111e708 <__svfscanf_r+0x1750>
8111dce8:	a8803fcc 	andi	r2,r21,255
8111dcec:	1080201c 	xori	r2,r2,128
8111dcf0:	10bfe004 	addi	r2,r2,-128
8111dcf4:	113fffc4 	addi	r4,r2,-1
8111dcf8:	01400184 	movi	r5,6
8111dcfc:	29001136 	bltu	r5,r4,8111dd44 <__svfscanf_r+0xd8c>
8111dd00:	01000084 	movi	r4,2
8111dd04:	2082900e 	bge	r4,r2,8111e748 <__svfscanf_r+0x1790>
8111dd08:	00c000c4 	movi	r3,3
8111dd0c:	10c00d26 	beq	r2,r3,8111dd44 <__svfscanf_r+0xd8c>
8111dd10:	9425c83a 	sub	r18,r18,r16
8111dd14:	1827883a 	mov	r19,r3
8111dd18:	843fffc4 	addi	r16,r16,-1
8111dd1c:	81400007 	ldb	r5,0(r16)
8111dd20:	e00d883a 	mov	r6,fp
8111dd24:	b009883a 	mov	r4,r22
8111dd28:	1126c100 	call	81126c10 <_ungetc_r>
8111dd2c:	a8bfffc4 	addi	r2,r21,-1
8111dd30:	10c03fcc 	andi	r3,r2,255
8111dd34:	8493883a 	add	r9,r16,r18
8111dd38:	102b883a 	mov	r21,r2
8111dd3c:	98fff636 	bltu	r19,r3,8111dd18 <__reset+0xfb0fdd18>
8111dd40:	4825883a 	mov	r18,r9
8111dd44:	a080400c 	andi	r2,r20,256
8111dd48:	10001426 	beq	r2,zero,8111dd9c <__svfscanf_r+0xde4>
8111dd4c:	a081000c 	andi	r2,r20,1024
8111dd50:	1002571e 	bne	r2,zero,8111e6b0 <__svfscanf_r+0x16f8>
8111dd54:	817fffc7 	ldb	r5,-1(r16)
8111dd58:	00801944 	movi	r2,101
8111dd5c:	84ffffc4 	addi	r19,r16,-1
8111dd60:	957fffc4 	addi	r21,r18,-1
8111dd64:	28800826 	beq	r5,r2,8111dd88 <__svfscanf_r+0xdd0>
8111dd68:	00801144 	movi	r2,69
8111dd6c:	28800626 	beq	r5,r2,8111dd88 <__svfscanf_r+0xdd0>
8111dd70:	e00d883a 	mov	r6,fp
8111dd74:	b009883a 	mov	r4,r22
8111dd78:	1126c100 	call	81126c10 <_ungetc_r>
8111dd7c:	817fff87 	ldb	r5,-2(r16)
8111dd80:	84ffff84 	addi	r19,r16,-2
8111dd84:	957fff84 	addi	r21,r18,-2
8111dd88:	e00d883a 	mov	r6,fp
8111dd8c:	b009883a 	mov	r4,r22
8111dd90:	1126c100 	call	81126c10 <_ungetc_r>
8111dd94:	a825883a 	mov	r18,r21
8111dd98:	9821883a 	mov	r16,r19
8111dd9c:	a080040c 	andi	r2,r20,16
8111dda0:	103e891e 	bne	r2,zero,8111d7c8 <__reset+0xfb0fd7c8>
8111dda4:	80000005 	stb	zero,0(r16)
8111dda8:	a081800c 	andi	r2,r20,1536
8111ddac:	01010004 	movi	r4,1024
8111ddb0:	1101dd26 	beq	r2,r4,8111e528 <__svfscanf_r+0x1570>
8111ddb4:	da00a417 	ldw	r8,656(sp)
8111ddb8:	4001e71e 	bne	r8,zero,8111e558 <__svfscanf_r+0x15a0>
8111ddbc:	000d883a 	mov	r6,zero
8111ddc0:	d9400104 	addi	r5,sp,4
8111ddc4:	b009883a 	mov	r4,r22
8111ddc8:	11237c00 	call	811237c0 <_strtod_r>
8111ddcc:	1021883a 	mov	r16,r2
8111ddd0:	a080004c 	andi	r2,r20,1
8111ddd4:	1000021e 	bne	r2,zero,8111dde0 <__svfscanf_r+0xe28>
8111ddd8:	a2c0008c 	andi	r11,r20,2
8111dddc:	5801e826 	beq	r11,zero,8111e580 <__svfscanf_r+0x15c8>
8111dde0:	da009c17 	ldw	r8,624(sp)
8111dde4:	40800017 	ldw	r2,0(r8)
8111dde8:	42000104 	addi	r8,r8,4
8111ddec:	da009c15 	stw	r8,624(sp)
8111ddf0:	14000015 	stw	r16,0(r2)
8111ddf4:	10c00115 	stw	r3,4(r2)
8111ddf8:	da00a017 	ldw	r8,640(sp)
8111ddfc:	dd009d17 	ldw	r20,628(sp)
8111de00:	42000044 	addi	r8,r8,1
8111de04:	da00a015 	stw	r8,640(sp)
8111de08:	a00d883a 	mov	r6,r20
8111de0c:	003ca806 	br	8111d0b0 <__reset+0xfb0fd0b0>
8111de10:	a080400c 	andi	r2,r20,256
8111de14:	103f9a26 	beq	r2,zero,8111dc80 <__reset+0xfb0fdc80>
8111de18:	da00a217 	ldw	r8,648(sp)
8111de1c:	00bfdfc4 	movi	r2,-129
8111de20:	a0a8703a 	and	r20,r20,r2
8111de24:	9cc00044 	addi	r19,r19,1
8111de28:	403f9e26 	beq	r8,zero,8111dca4 <__reset+0xfb0fdca4>
8111de2c:	423fffc4 	addi	r8,r8,-1
8111de30:	da00a215 	stw	r8,648(sp)
8111de34:	84000044 	addi	r16,r16,1
8111de38:	003f9a06 	br	8111dca4 <__reset+0xfb0fdca4>
8111de3c:	a080200c 	andi	r2,r20,128
8111de40:	103fa126 	beq	r2,zero,8111dcc8 <__reset+0xfb0fdcc8>
8111de44:	00bfdfc4 	movi	r2,-129
8111de48:	a0a8703a 	and	r20,r20,r2
8111de4c:	003f9306 	br	8111dc9c <__reset+0xfb0fdc9c>
8111de50:	a8803fcc 	andi	r2,r21,255
8111de54:	1080201c 	xori	r2,r2,128
8111de58:	10bfe004 	addi	r2,r2,-128
8111de5c:	020001c4 	movi	r8,7
8111de60:	123f991e 	bne	r2,r8,8111dcc8 <__reset+0xfb0fdcc8>
8111de64:	05400204 	movi	r21,8
8111de68:	003f8c06 	br	8111dc9c <__reset+0xfb0fdc9c>
8111de6c:	a8803fcc 	andi	r2,r21,255
8111de70:	1080201c 	xori	r2,r2,128
8111de74:	10bfe004 	addi	r2,r2,-128
8111de78:	01800184 	movi	r6,6
8111de7c:	11bf921e 	bne	r2,r6,8111dcc8 <__reset+0xfb0fdcc8>
8111de80:	054001c4 	movi	r21,7
8111de84:	003f8506 	br	8111dc9c <__reset+0xfb0fdc9c>
8111de88:	b000491e 	bne	r22,zero,8111dfb0 <__svfscanf_r+0xff8>
8111de8c:	9800031e 	bne	r19,zero,8111de9c <__svfscanf_r+0xee4>
8111de90:	a081c00c 	andi	r2,r20,1792
8111de94:	0181c004 	movi	r6,1792
8111de98:	11819f26 	beq	r2,r6,8111e518 <__svfscanf_r+0x1560>
8111de9c:	a8803fcc 	andi	r2,r21,255
8111dea0:	1080201c 	xori	r2,r2,128
8111dea4:	10bfe004 	addi	r2,r2,-128
8111dea8:	01800044 	movi	r6,1
8111deac:	11800226 	beq	r2,r6,8111deb8 <__svfscanf_r+0xf00>
8111deb0:	01800104 	movi	r6,4
8111deb4:	11bf841e 	bne	r2,r6,8111dcc8 <__reset+0xfb0fdcc8>
8111deb8:	ad400044 	addi	r21,r21,1
8111debc:	003f7706 	br	8111dc9c <__reset+0xfb0fdc9c>
8111dec0:	a8803fcc 	andi	r2,r21,255
8111dec4:	1080201c 	xori	r2,r2,128
8111dec8:	10bfe004 	addi	r2,r2,-128
8111decc:	10003c1e 	bne	r2,zero,8111dfc0 <__svfscanf_r+0x1008>
8111ded0:	9801141e 	bne	r19,zero,8111e324 <__svfscanf_r+0x136c>
8111ded4:	a081c00c 	andi	r2,r20,1792
8111ded8:	0181c004 	movi	r6,1792
8111dedc:	11818226 	beq	r2,r6,8111e4e8 <__svfscanf_r+0x1530>
8111dee0:	8821883a 	mov	r16,r17
8111dee4:	b019883a 	mov	r12,r22
8111dee8:	9823883a 	mov	r17,r19
8111deec:	182d883a 	mov	r22,r3
8111def0:	003f7a06 	br	8111dcdc <__reset+0xfb0fdcdc>
8111def4:	a8803fcc 	andi	r2,r21,255
8111def8:	1080201c 	xori	r2,r2,128
8111defc:	10bfe004 	addi	r2,r2,-128
8111df00:	01800084 	movi	r6,2
8111df04:	11bf701e 	bne	r2,r6,8111dcc8 <__reset+0xfb0fdcc8>
8111df08:	054000c4 	movi	r21,3
8111df0c:	003f6306 	br	8111dc9c <__reset+0xfb0fdc9c>
8111df10:	a081400c 	andi	r2,r20,1280
8111df14:	01810004 	movi	r6,1024
8111df18:	11800326 	beq	r2,r6,8111df28 <__svfscanf_r+0xf70>
8111df1c:	a184703a 	and	r2,r20,r6
8111df20:	103f6926 	beq	r2,zero,8111dcc8 <__reset+0xfb0fdcc8>
8111df24:	983fee26 	beq	r19,zero,8111dee0 <__reset+0xfb0fdee0>
8111df28:	a080800c 	andi	r2,r20,512
8111df2c:	1000041e 	bne	r2,zero,8111df40 <__svfscanf_r+0xf88>
8111df30:	da009f17 	ldw	r8,636(sp)
8111df34:	dc40a515 	stw	r17,660(sp)
8111df38:	9a27c83a 	sub	r19,r19,r8
8111df3c:	dcc0a415 	stw	r19,656(sp)
8111df40:	00be1fc4 	movi	r2,-1921
8111df44:	a0a8703a 	and	r20,r20,r2
8111df48:	a5006014 	ori	r20,r20,384
8111df4c:	0027883a 	mov	r19,zero
8111df50:	003f5206 	br	8111dc9c <__reset+0xfb0fdc9c>
8111df54:	00800044 	movi	r2,1
8111df58:	b0bf5b1e 	bne	r22,r2,8111dcc8 <__reset+0xfb0fdcc8>
8111df5c:	05800084 	movi	r22,2
8111df60:	003f4e06 	br	8111dc9c <__reset+0xfb0fdc9c>
8111df64:	d980a317 	ldw	r6,652(sp)
8111df68:	30800003 	ldbu	r2,0(r6)
8111df6c:	29803fcc 	andi	r6,r5,255
8111df70:	30bf551e 	bne	r6,r2,8111dcc8 <__reset+0xfb0fdcc8>
8111df74:	a080800c 	andi	r2,r20,512
8111df78:	103f5326 	beq	r2,zero,8111dcc8 <__reset+0xfb0fdcc8>
8111df7c:	023f5fc4 	movi	r8,-641
8111df80:	a228703a 	and	r20,r20,r8
8111df84:	dcc09f15 	stw	r19,636(sp)
8111df88:	003f4406 	br	8111dc9c <__reset+0xfb0fdc9c>
8111df8c:	1809883a 	mov	r4,r3
8111df90:	e00b883a 	mov	r5,fp
8111df94:	d8c0a615 	stw	r3,664(sp)
8111df98:	d9c0aa15 	stw	r7,680(sp)
8111df9c:	11182980 	call	81118298 <__srefill_r>
8111dfa0:	d8c0a617 	ldw	r3,664(sp)
8111dfa4:	d9c0aa17 	ldw	r7,680(sp)
8111dfa8:	103f4626 	beq	r2,zero,8111dcc4 <__reset+0xfb0fdcc4>
8111dfac:	003f4606 	br	8111dcc8 <__reset+0xfb0fdcc8>
8111dfb0:	00800084 	movi	r2,2
8111dfb4:	b0bfb91e 	bne	r22,r2,8111de9c <__reset+0xfb0fde9c>
8111dfb8:	058000c4 	movi	r22,3
8111dfbc:	003f3706 	br	8111dc9c <__reset+0xfb0fdc9c>
8111dfc0:	018000c4 	movi	r6,3
8111dfc4:	11bfbc26 	beq	r2,r6,8111deb8 <__reset+0xfb0fdeb8>
8111dfc8:	01800144 	movi	r6,5
8111dfcc:	11bfba26 	beq	r2,r6,8111deb8 <__reset+0xfb0fdeb8>
8111dfd0:	003f3d06 	br	8111dcc8 <__reset+0xfb0fdcc8>
8111dfd4:	98bfffc4 	addi	r2,r19,-1
8111dfd8:	01405704 	movi	r5,348
8111dfdc:	2880d82e 	bgeu	r5,r2,8111e340 <__svfscanf_r+0x1388>
8111dfe0:	99ffa8c4 	addi	r7,r19,-349
8111dfe4:	04c05744 	movi	r19,349
8111dfe8:	8c436014 	ori	r17,r17,3456
8111dfec:	9013883a 	mov	r9,r18
8111dff0:	8825883a 	mov	r18,r17
8111dff4:	dc409e17 	ldw	r17,632(sp)
8111dff8:	0029883a 	mov	r20,zero
8111dffc:	dc000104 	addi	r16,sp,4
8111e000:	05401344 	movi	r21,77
8111e004:	02c08004 	movi	r11,512
8111e008:	01bf7fc4 	movi	r6,-513
8111e00c:	023fdfc4 	movi	r8,-129
8111e010:	20bff544 	addi	r2,r4,-43
8111e014:	10803fcc 	andi	r2,r2,255
8111e018:	a8807236 	bltu	r21,r2,8111e1e4 <__svfscanf_r+0x122c>
8111e01c:	100490ba 	slli	r2,r2,2
8111e020:	016044b4 	movhi	r5,33042
8111e024:	29780d04 	addi	r5,r5,-8140
8111e028:	1145883a 	add	r2,r2,r5
8111e02c:	10800017 	ldw	r2,0(r2)
8111e030:	1000683a 	jmp	r2
8111e034:	8111e268 	cmpgeui	r4,r16,18313
8111e038:	8111e1e4 	muli	r4,r16,18311
8111e03c:	8111e268 	cmpgeui	r4,r16,18313
8111e040:	8111e1e4 	muli	r4,r16,18311
8111e044:	8111e1e4 	muli	r4,r16,18311
8111e048:	8111e240 	call	88111e24 <__reset+0x20f1e24>
8111e04c:	8111e220 	cmpeqi	r4,r16,18312
8111e050:	8111e220 	cmpeqi	r4,r16,18312
8111e054:	8111e220 	cmpeqi	r4,r16,18312
8111e058:	8111e220 	cmpeqi	r4,r16,18312
8111e05c:	8111e220 	cmpeqi	r4,r16,18312
8111e060:	8111e220 	cmpeqi	r4,r16,18312
8111e064:	8111e220 	cmpeqi	r4,r16,18312
8111e068:	8111e1c8 	cmpgei	r4,r16,18311
8111e06c:	8111e1c8 	cmpgei	r4,r16,18311
8111e070:	8111e1e4 	muli	r4,r16,18311
8111e074:	8111e1e4 	muli	r4,r16,18311
8111e078:	8111e1e4 	muli	r4,r16,18311
8111e07c:	8111e1e4 	muli	r4,r16,18311
8111e080:	8111e1e4 	muli	r4,r16,18311
8111e084:	8111e1e4 	muli	r4,r16,18311
8111e088:	8111e1e4 	muli	r4,r16,18311
8111e08c:	8111e1b4 	orhi	r4,r16,18310
8111e090:	8111e1b4 	orhi	r4,r16,18310
8111e094:	8111e1b4 	orhi	r4,r16,18310
8111e098:	8111e1b4 	orhi	r4,r16,18310
8111e09c:	8111e1b4 	orhi	r4,r16,18310
8111e0a0:	8111e1b4 	orhi	r4,r16,18310
8111e0a4:	8111e1e4 	muli	r4,r16,18311
8111e0a8:	8111e1e4 	muli	r4,r16,18311
8111e0ac:	8111e1e4 	muli	r4,r16,18311
8111e0b0:	8111e1e4 	muli	r4,r16,18311
8111e0b4:	8111e1e4 	muli	r4,r16,18311
8111e0b8:	8111e1e4 	muli	r4,r16,18311
8111e0bc:	8111e1e4 	muli	r4,r16,18311
8111e0c0:	8111e1e4 	muli	r4,r16,18311
8111e0c4:	8111e1e4 	muli	r4,r16,18311
8111e0c8:	8111e1e4 	muli	r4,r16,18311
8111e0cc:	8111e1e4 	muli	r4,r16,18311
8111e0d0:	8111e1e4 	muli	r4,r16,18311
8111e0d4:	8111e1e4 	muli	r4,r16,18311
8111e0d8:	8111e1e4 	muli	r4,r16,18311
8111e0dc:	8111e1e4 	muli	r4,r16,18311
8111e0e0:	8111e1e4 	muli	r4,r16,18311
8111e0e4:	8111e1e4 	muli	r4,r16,18311
8111e0e8:	8111e16c 	andhi	r4,r16,18309
8111e0ec:	8111e1e4 	muli	r4,r16,18311
8111e0f0:	8111e1e4 	muli	r4,r16,18311
8111e0f4:	8111e1e4 	muli	r4,r16,18311
8111e0f8:	8111e1e4 	muli	r4,r16,18311
8111e0fc:	8111e1e4 	muli	r4,r16,18311
8111e100:	8111e1e4 	muli	r4,r16,18311
8111e104:	8111e1e4 	muli	r4,r16,18311
8111e108:	8111e1e4 	muli	r4,r16,18311
8111e10c:	8111e1b4 	orhi	r4,r16,18310
8111e110:	8111e1b4 	orhi	r4,r16,18310
8111e114:	8111e1b4 	orhi	r4,r16,18310
8111e118:	8111e1b4 	orhi	r4,r16,18310
8111e11c:	8111e1b4 	orhi	r4,r16,18310
8111e120:	8111e1b4 	orhi	r4,r16,18310
8111e124:	8111e1e4 	muli	r4,r16,18311
8111e128:	8111e1e4 	muli	r4,r16,18311
8111e12c:	8111e1e4 	muli	r4,r16,18311
8111e130:	8111e1e4 	muli	r4,r16,18311
8111e134:	8111e1e4 	muli	r4,r16,18311
8111e138:	8111e1e4 	muli	r4,r16,18311
8111e13c:	8111e1e4 	muli	r4,r16,18311
8111e140:	8111e1e4 	muli	r4,r16,18311
8111e144:	8111e1e4 	muli	r4,r16,18311
8111e148:	8111e1e4 	muli	r4,r16,18311
8111e14c:	8111e1e4 	muli	r4,r16,18311
8111e150:	8111e1e4 	muli	r4,r16,18311
8111e154:	8111e1e4 	muli	r4,r16,18311
8111e158:	8111e1e4 	muli	r4,r16,18311
8111e15c:	8111e1e4 	muli	r4,r16,18311
8111e160:	8111e1e4 	muli	r4,r16,18311
8111e164:	8111e1e4 	muli	r4,r16,18311
8111e168:	8111e16c 	andhi	r4,r16,18309
8111e16c:	9081800c 	andi	r2,r18,1536
8111e170:	12c01c1e 	bne	r2,r11,8111e1e4 <__svfscanf_r+0x122c>
8111e174:	91a4703a 	and	r18,r18,r6
8111e178:	94814014 	ori	r18,r18,1280
8111e17c:	04400404 	movi	r17,16
8111e180:	81000005 	stb	r4,0(r16)
8111e184:	84000044 	addi	r16,r16,1
8111e188:	e0800117 	ldw	r2,4(fp)
8111e18c:	10bfffc4 	addi	r2,r2,-1
8111e190:	e0800115 	stw	r2,4(fp)
8111e194:	0080540e 	bge	zero,r2,8111e2e8 <__svfscanf_r+0x1330>
8111e198:	18c00044 	addi	r3,r3,1
8111e19c:	e0c00015 	stw	r3,0(fp)
8111e1a0:	9cffffc4 	addi	r19,r19,-1
8111e1a4:	98000f26 	beq	r19,zero,8111e1e4 <__svfscanf_r+0x122c>
8111e1a8:	e0c00017 	ldw	r3,0(fp)
8111e1ac:	19000003 	ldbu	r4,0(r3)
8111e1b0:	003f9706 	br	8111e010 <__reset+0xfb0fe010>
8111e1b4:	00800284 	movi	r2,10
8111e1b8:	14400a0e 	bge	r2,r17,8111e1e4 <__svfscanf_r+0x122c>
8111e1bc:	00bd1fc4 	movi	r2,-2945
8111e1c0:	90a4703a 	and	r18,r18,r2
8111e1c4:	003fee06 	br	8111e180 <__reset+0xfb0fe180>
8111e1c8:	01604534 	movhi	r5,33044
8111e1cc:	8c63883a 	add	r17,r17,r17
8111e1d0:	29574c84 	addi	r5,r5,23858
8111e1d4:	2c45883a 	add	r2,r5,r17
8111e1d8:	1440000f 	ldh	r17,0(r2)
8111e1dc:	00800204 	movi	r2,8
8111e1e0:	147ff616 	blt	r2,r17,8111e1bc <__reset+0xfb0fe1bc>
8111e1e4:	dc409e15 	stw	r17,632(sp)
8111e1e8:	9023883a 	mov	r17,r18
8111e1ec:	8880400c 	andi	r2,r17,256
8111e1f0:	4825883a 	mov	r18,r9
8111e1f4:	10000426 	beq	r2,zero,8111e208 <__svfscanf_r+0x1250>
8111e1f8:	d9800104 	addi	r6,sp,4
8111e1fc:	3400be36 	bltu	r6,r16,8111e4f8 <__svfscanf_r+0x1540>
8111e200:	da000104 	addi	r8,sp,4
8111e204:	443bae26 	beq	r8,r16,8111d0c0 <__reset+0xfb0fd0c0>
8111e208:	8880040c 	andi	r2,r17,16
8111e20c:	10009326 	beq	r2,zero,8111e45c <__svfscanf_r+0x14a4>
8111e210:	d8800104 	addi	r2,sp,4
8111e214:	80a1c83a 	sub	r16,r16,r2
8111e218:	8521883a 	add	r16,r16,r20
8111e21c:	003d0606 	br	8111d638 <__reset+0xfb0fd638>
8111e220:	01604534 	movhi	r5,33044
8111e224:	8c63883a 	add	r17,r17,r17
8111e228:	29574c84 	addi	r5,r5,23858
8111e22c:	2c45883a 	add	r2,r5,r17
8111e230:	1440000f 	ldh	r17,0(r2)
8111e234:	00bd1fc4 	movi	r2,-2945
8111e238:	90a4703a 	and	r18,r18,r2
8111e23c:	003fd006 	br	8111e180 <__reset+0xfb0fe180>
8111e240:	9082000c 	andi	r2,r18,2048
8111e244:	103fce26 	beq	r2,zero,8111e180 <__reset+0xfb0fe180>
8111e248:	8800021e 	bne	r17,zero,8111e254 <__svfscanf_r+0x129c>
8111e24c:	94808014 	ori	r18,r18,512
8111e250:	04400204 	movi	r17,8
8111e254:	9081000c 	andi	r2,r18,1024
8111e258:	10009426 	beq	r2,zero,8111e4ac <__svfscanf_r+0x14f4>
8111e25c:	00be9fc4 	movi	r2,-1409
8111e260:	90a4703a 	and	r18,r18,r2
8111e264:	003fc606 	br	8111e180 <__reset+0xfb0fe180>
8111e268:	9080200c 	andi	r2,r18,128
8111e26c:	103fdd26 	beq	r2,zero,8111e1e4 <__reset+0xfb0fe1e4>
8111e270:	9224703a 	and	r18,r18,r8
8111e274:	003fc206 	br	8111e180 <__reset+0xfb0fe180>
8111e278:	9800011e 	bne	r19,zero,8111e280 <__svfscanf_r+0x12c8>
8111e27c:	04ffffc4 	movi	r19,-1
8111e280:	8900004c 	andi	r4,r17,1
8111e284:	20005b1e 	bne	r4,zero,8111e3f4 <__svfscanf_r+0x143c>
8111e288:	8c40040c 	andi	r17,r17,16
8111e28c:	88003026 	beq	r17,zero,8111e350 <__svfscanf_r+0x1398>
8111e290:	0021883a 	mov	r16,zero
8111e294:	00000306 	br	8111e2a4 <__svfscanf_r+0x12ec>
8111e298:	18800003 	ldbu	r2,0(r3)
8111e29c:	3885883a 	add	r2,r7,r2
8111e2a0:	10800043 	ldbu	r2,1(r2)
8111e2a4:	1080020c 	andi	r2,r2,8
8111e2a8:	103ce31e 	bne	r2,zero,8111d638 <__reset+0xfb0fd638>
8111e2ac:	e0800117 	ldw	r2,4(fp)
8111e2b0:	18c00044 	addi	r3,r3,1
8111e2b4:	84000044 	addi	r16,r16,1
8111e2b8:	10bfffc4 	addi	r2,r2,-1
8111e2bc:	e0800115 	stw	r2,4(fp)
8111e2c0:	e0c00015 	stw	r3,0(fp)
8111e2c4:	84fcdc26 	beq	r16,r19,8111d638 <__reset+0xfb0fd638>
8111e2c8:	00bff316 	blt	zero,r2,8111e298 <__reset+0xfb0fe298>
8111e2cc:	e00b883a 	mov	r5,fp
8111e2d0:	b009883a 	mov	r4,r22
8111e2d4:	11182980 	call	81118298 <__srefill_r>
8111e2d8:	103cd71e 	bne	r2,zero,8111d638 <__reset+0xfb0fd638>
8111e2dc:	b9c00017 	ldw	r7,0(r23)
8111e2e0:	e0c00017 	ldw	r3,0(fp)
8111e2e4:	003fec06 	br	8111e298 <__reset+0xfb0fe298>
8111e2e8:	e00b883a 	mov	r5,fp
8111e2ec:	b009883a 	mov	r4,r22
8111e2f0:	d980a715 	stw	r6,668(sp)
8111e2f4:	d9c0aa15 	stw	r7,680(sp)
8111e2f8:	da00a815 	stw	r8,672(sp)
8111e2fc:	da40a915 	stw	r9,676(sp)
8111e300:	dac0a615 	stw	r11,664(sp)
8111e304:	11182980 	call	81118298 <__srefill_r>
8111e308:	d980a717 	ldw	r6,668(sp)
8111e30c:	d9c0aa17 	ldw	r7,680(sp)
8111e310:	da00a817 	ldw	r8,672(sp)
8111e314:	da40a917 	ldw	r9,676(sp)
8111e318:	dac0a617 	ldw	r11,664(sp)
8111e31c:	103fa026 	beq	r2,zero,8111e1a0 <__reset+0xfb0fe1a0>
8111e320:	003fb006 	br	8111e1e4 <__reset+0xfb0fe1e4>
8111e324:	8821883a 	mov	r16,r17
8111e328:	b019883a 	mov	r12,r22
8111e32c:	9823883a 	mov	r17,r19
8111e330:	182d883a 	mov	r22,r3
8111e334:	00bfbfc4 	movi	r2,-257
8111e338:	a0a8703a 	and	r20,r20,r2
8111e33c:	003e6706 	br	8111dcdc <__reset+0xfb0fdcdc>
8111e340:	000f883a 	mov	r7,zero
8111e344:	003f2806 	br	8111dfe8 <__reset+0xfb0fdfe8>
8111e348:	d800a215 	stw	zero,648(sp)
8111e34c:	003de306 	br	8111dadc <__reset+0xfb0fdadc>
8111e350:	da009c17 	ldw	r8,624(sp)
8111e354:	9abfffc4 	addi	r10,r19,-1
8111e358:	44400017 	ldw	r17,0(r8)
8111e35c:	44000104 	addi	r16,r8,4
8111e360:	880b883a 	mov	r5,r17
8111e364:	8aa9883a 	add	r20,r17,r10
8111e368:	00000606 	br	8111e384 <__svfscanf_r+0x13cc>
8111e36c:	e0c00017 	ldw	r3,0(fp)
8111e370:	b9000017 	ldw	r4,0(r23)
8111e374:	a80b883a 	mov	r5,r21
8111e378:	18800003 	ldbu	r2,0(r3)
8111e37c:	2085883a 	add	r2,r4,r2
8111e380:	10800043 	ldbu	r2,1(r2)
8111e384:	1080020c 	andi	r2,r2,8
8111e388:	1000551e 	bne	r2,zero,8111e4e0 <__svfscanf_r+0x1528>
8111e38c:	e0800117 	ldw	r2,4(fp)
8111e390:	19000044 	addi	r4,r3,1
8111e394:	e1000015 	stw	r4,0(fp)
8111e398:	10bfffc4 	addi	r2,r2,-1
8111e39c:	e0800115 	stw	r2,4(fp)
8111e3a0:	18800003 	ldbu	r2,0(r3)
8111e3a4:	2d400044 	addi	r21,r5,1
8111e3a8:	a827883a 	mov	r19,r21
8111e3ac:	28800005 	stb	r2,0(r5)
8111e3b0:	2d000626 	beq	r5,r20,8111e3cc <__svfscanf_r+0x1414>
8111e3b4:	e0800117 	ldw	r2,4(fp)
8111e3b8:	00bfec16 	blt	zero,r2,8111e36c <__reset+0xfb0fe36c>
8111e3bc:	e00b883a 	mov	r5,fp
8111e3c0:	b009883a 	mov	r4,r22
8111e3c4:	11182980 	call	81118298 <__srefill_r>
8111e3c8:	103fe826 	beq	r2,zero,8111e36c <__reset+0xfb0fe36c>
8111e3cc:	da00a017 	ldw	r8,640(sp)
8111e3d0:	dd009d17 	ldw	r20,628(sp)
8111e3d4:	9c63c83a 	sub	r17,r19,r17
8111e3d8:	42000044 	addi	r8,r8,1
8111e3dc:	98000005 	stb	zero,0(r19)
8111e3e0:	9465883a 	add	r18,r18,r17
8111e3e4:	da00a015 	stw	r8,640(sp)
8111e3e8:	dc009c15 	stw	r16,624(sp)
8111e3ec:	a00d883a 	mov	r6,r20
8111e3f0:	003b2f06 	br	8111d0b0 <__reset+0xfb0fd0b0>
8111e3f4:	dd409904 	addi	r21,sp,612
8111e3f8:	8c40040c 	andi	r17,r17,16
8111e3fc:	01800204 	movi	r6,8
8111e400:	000b883a 	mov	r5,zero
8111e404:	a809883a 	mov	r4,r21
8111e408:	1117e1c0 	call	81117e1c <memset>
8111e40c:	8800401e 	bne	r17,zero,8111e510 <__svfscanf_r+0x1558>
8111e410:	da009c17 	ldw	r8,624(sp)
8111e414:	45000017 	ldw	r20,0(r8)
8111e418:	42000104 	addi	r8,r8,4
8111e41c:	da009c15 	stw	r8,624(sp)
8111e420:	000d883a 	mov	r6,zero
8111e424:	3021883a 	mov	r16,r6
8111e428:	dc409f15 	stw	r17,636(sp)
8111e42c:	e0800017 	ldw	r2,0(fp)
8111e430:	b8c00017 	ldw	r3,0(r23)
8111e434:	10800003 	ldbu	r2,0(r2)
8111e438:	1885883a 	add	r2,r3,r2
8111e43c:	10800043 	ldbu	r2,1(r2)
8111e440:	1080020c 	andi	r2,r2,8
8111e444:	1000011e 	bne	r2,zero,8111e44c <__svfscanf_r+0x1494>
8111e448:	9800701e 	bne	r19,zero,8111e60c <__svfscanf_r+0x1654>
8111e44c:	dc409f17 	ldw	r17,636(sp)
8111e450:	883cdd1e 	bne	r17,zero,8111d7c8 <__reset+0xfb0fd7c8>
8111e454:	a0000015 	stw	zero,0(r20)
8111e458:	003cd806 	br	8111d7bc <__reset+0xfb0fd7bc>
8111e45c:	d9c09e17 	ldw	r7,632(sp)
8111e460:	da00a117 	ldw	r8,644(sp)
8111e464:	000d883a 	mov	r6,zero
8111e468:	d9400104 	addi	r5,sp,4
8111e46c:	b009883a 	mov	r4,r22
8111e470:	80000005 	stb	zero,0(r16)
8111e474:	403ee83a 	callr	r8
8111e478:	88c0080c 	andi	r3,r17,32
8111e47c:	1800121e 	bne	r3,zero,8111e4c8 <__svfscanf_r+0x1510>
8111e480:	88c0010c 	andi	r3,r17,4
8111e484:	18004d26 	beq	r3,zero,8111e5bc <__svfscanf_r+0x1604>
8111e488:	da009c17 	ldw	r8,624(sp)
8111e48c:	40c00017 	ldw	r3,0(r8)
8111e490:	42000104 	addi	r8,r8,4
8111e494:	da009c15 	stw	r8,624(sp)
8111e498:	1880000d 	sth	r2,0(r3)
8111e49c:	da00a017 	ldw	r8,640(sp)
8111e4a0:	42000044 	addi	r8,r8,1
8111e4a4:	da00a015 	stw	r8,640(sp)
8111e4a8:	003f5906 	br	8111e210 <__reset+0xfb0fe210>
8111e4ac:	00bf1fc4 	movi	r2,-897
8111e4b0:	90a4703a 	and	r18,r18,r2
8111e4b4:	38000226 	beq	r7,zero,8111e4c0 <__svfscanf_r+0x1508>
8111e4b8:	39ffffc4 	addi	r7,r7,-1
8111e4bc:	9cc00044 	addi	r19,r19,1
8111e4c0:	a5000044 	addi	r20,r20,1
8111e4c4:	003f3006 	br	8111e188 <__reset+0xfb0fe188>
8111e4c8:	da009c17 	ldw	r8,624(sp)
8111e4cc:	40c00017 	ldw	r3,0(r8)
8111e4d0:	42000104 	addi	r8,r8,4
8111e4d4:	da009c15 	stw	r8,624(sp)
8111e4d8:	18800015 	stw	r2,0(r3)
8111e4dc:	003fef06 	br	8111e49c <__reset+0xfb0fe49c>
8111e4e0:	2827883a 	mov	r19,r5
8111e4e4:	003fb906 	br	8111e3cc <__reset+0xfb0fe3cc>
8111e4e8:	01be1fc4 	movi	r6,-1921
8111e4ec:	a1a8703a 	and	r20,r20,r6
8111e4f0:	05400044 	movi	r21,1
8111e4f4:	003de906 	br	8111dc9c <__reset+0xfb0fdc9c>
8111e4f8:	817fffc7 	ldb	r5,-1(r16)
8111e4fc:	e00d883a 	mov	r6,fp
8111e500:	b009883a 	mov	r4,r22
8111e504:	843fffc4 	addi	r16,r16,-1
8111e508:	1126c100 	call	81126c10 <_ungetc_r>
8111e50c:	003f3c06 	br	8111e200 <__reset+0xfb0fe200>
8111e510:	dd009b04 	addi	r20,sp,620
8111e514:	003fc206 	br	8111e420 <__reset+0xfb0fe420>
8111e518:	00be1fc4 	movi	r2,-1921
8111e51c:	a0a8703a 	and	r20,r20,r2
8111e520:	05800044 	movi	r22,1
8111e524:	003ddd06 	br	8111dc9c <__reset+0xfb0fdc9c>
8111e528:	d8c09f17 	ldw	r3,636(sp)
8111e52c:	88e3c83a 	sub	r17,r17,r3
8111e530:	044dc83a 	sub	r6,zero,r17
8111e534:	883e2126 	beq	r17,zero,8111ddbc <__reset+0xfb0fddbc>
8111e538:	d88055c4 	addi	r2,sp,343
8111e53c:	80800136 	bltu	r16,r2,8111e544 <__svfscanf_r+0x158c>
8111e540:	dc005584 	addi	r16,sp,342
8111e544:	01604534 	movhi	r5,33044
8111e548:	29574b04 	addi	r5,r5,23852
8111e54c:	8009883a 	mov	r4,r16
8111e550:	11185ac0 	call	811185ac <sprintf>
8111e554:	003e1906 	br	8111ddbc <__reset+0xfb0fddbc>
8111e558:	d8c0a517 	ldw	r3,660(sp)
8111e55c:	000d883a 	mov	r6,zero
8111e560:	01c00284 	movi	r7,10
8111e564:	19400044 	addi	r5,r3,1
8111e568:	b009883a 	mov	r4,r22
8111e56c:	111889c0 	call	8111889c <_strtol_r>
8111e570:	da00a417 	ldw	r8,656(sp)
8111e574:	dc00a517 	ldw	r16,660(sp)
8111e578:	120dc83a 	sub	r6,r2,r8
8111e57c:	003fee06 	br	8111e538 <__reset+0xfb0fe538>
8111e580:	da009c17 	ldw	r8,624(sp)
8111e584:	180b883a 	mov	r5,r3
8111e588:	8009883a 	mov	r4,r16
8111e58c:	45000017 	ldw	r20,0(r8)
8111e590:	44400104 	addi	r17,r8,4
8111e594:	d8c0a615 	stw	r3,664(sp)
8111e598:	112352c0 	call	8112352c <__fpclassifyd>
8111e59c:	d8c0a617 	ldw	r3,664(sp)
8111e5a0:	10006426 	beq	r2,zero,8111e734 <__svfscanf_r+0x177c>
8111e5a4:	8009883a 	mov	r4,r16
8111e5a8:	180b883a 	mov	r5,r3
8111e5ac:	11168b40 	call	811168b4 <__truncdfsf2>
8111e5b0:	a0800015 	stw	r2,0(r20)
8111e5b4:	dc409c15 	stw	r17,624(sp)
8111e5b8:	003e0f06 	br	8111ddf8 <__reset+0xfb0fddf8>
8111e5bc:	88c0004c 	andi	r3,r17,1
8111e5c0:	183fc11e 	bne	r3,zero,8111e4c8 <__reset+0xfb0fe4c8>
8111e5c4:	8c40008c 	andi	r17,r17,2
8111e5c8:	883fbf26 	beq	r17,zero,8111e4c8 <__reset+0xfb0fe4c8>
8111e5cc:	da00a117 	ldw	r8,644(sp)
8111e5d0:	00a044b4 	movhi	r2,33042
8111e5d4:	10947204 	addi	r2,r2,20936
8111e5d8:	d9c09e17 	ldw	r7,632(sp)
8111e5dc:	000d883a 	mov	r6,zero
8111e5e0:	d9400104 	addi	r5,sp,4
8111e5e4:	b009883a 	mov	r4,r22
8111e5e8:	40806226 	beq	r8,r2,8111e774 <__svfscanf_r+0x17bc>
8111e5ec:	1124ee00 	call	81124ee0 <_strtoll_r>
8111e5f0:	da009c17 	ldw	r8,624(sp)
8111e5f4:	41000017 	ldw	r4,0(r8)
8111e5f8:	42000104 	addi	r8,r8,4
8111e5fc:	da009c15 	stw	r8,624(sp)
8111e600:	20800015 	stw	r2,0(r4)
8111e604:	20c00115 	stw	r3,4(r4)
8111e608:	003fa406 	br	8111e49c <__reset+0xfb0fe49c>
8111e60c:	11219bc0 	call	811219bc <__locale_mb_cur_max>
8111e610:	80bca726 	beq	r16,r2,8111d8b0 <__reset+0xfb0fd8b0>
8111e614:	e0800017 	ldw	r2,0(fp)
8111e618:	e1000117 	ldw	r4,4(fp)
8111e61c:	d8c00104 	addi	r3,sp,4
8111e620:	12000003 	ldbu	r8,0(r2)
8111e624:	213fffc4 	addi	r4,r4,-1
8111e628:	10800044 	addi	r2,r2,1
8111e62c:	e1000115 	stw	r4,4(fp)
8111e630:	e0800015 	stw	r2,0(fp)
8111e634:	84400044 	addi	r17,r16,1
8111e638:	dd400015 	stw	r21,0(sp)
8111e63c:	1c21883a 	add	r16,r3,r16
8111e640:	b009883a 	mov	r4,r22
8111e644:	880f883a 	mov	r7,r17
8111e648:	180d883a 	mov	r6,r3
8111e64c:	a00b883a 	mov	r5,r20
8111e650:	82000005 	stb	r8,0(r16)
8111e654:	1121a780 	call	81121a78 <_mbrtowc_r>
8111e658:	013fffc4 	movi	r4,-1
8111e65c:	113c9426 	beq	r2,r4,8111d8b0 <__reset+0xfb0fd8b0>
8111e660:	103c881e 	bne	r2,zero,8111d884 <__reset+0xfb0fd884>
8111e664:	a0000015 	stw	zero,0(r20)
8111e668:	0009883a 	mov	r4,zero
8111e66c:	11218fc0 	call	811218fc <iswspace>
8111e670:	10001a26 	beq	r2,zero,8111e6dc <__svfscanf_r+0x1724>
8111e674:	8821883a 	mov	r16,r17
8111e678:	dc409f17 	ldw	r17,636(sp)
8111e67c:	803f7426 	beq	r16,zero,8111e450 <__reset+0xfb0fe450>
8111e680:	843fffc4 	addi	r16,r16,-1
8111e684:	d9800104 	addi	r6,sp,4
8111e688:	342b883a 	add	r21,r6,r16
8111e68c:	00000106 	br	8111e694 <__svfscanf_r+0x16dc>
8111e690:	843fffc4 	addi	r16,r16,-1
8111e694:	a9400003 	ldbu	r5,0(r21)
8111e698:	e00d883a 	mov	r6,fp
8111e69c:	b009883a 	mov	r4,r22
8111e6a0:	1126c100 	call	81126c10 <_ungetc_r>
8111e6a4:	ad7fffc4 	addi	r21,r21,-1
8111e6a8:	803ff91e 	bne	r16,zero,8111e690 <__reset+0xfb0fe690>
8111e6ac:	003f6806 	br	8111e450 <__reset+0xfb0fe450>
8111e6b0:	d9800104 	addi	r6,sp,4
8111e6b4:	802b883a 	mov	r21,r16
8111e6b8:	343a812e 	bgeu	r6,r16,8111d0c0 <__reset+0xfb0fd0c0>
8111e6bc:	ad7fffc4 	addi	r21,r21,-1
8111e6c0:	a9400007 	ldb	r5,0(r21)
8111e6c4:	e00d883a 	mov	r6,fp
8111e6c8:	b009883a 	mov	r4,r22
8111e6cc:	1126c100 	call	81126c10 <_ungetc_r>
8111e6d0:	da000104 	addi	r8,sp,4
8111e6d4:	457ff91e 	bne	r8,r21,8111e6bc <__reset+0xfb0fe6bc>
8111e6d8:	003a7906 	br	8111d0c0 <__reset+0xfb0fd0c0>
8111e6dc:	da009f17 	ldw	r8,636(sp)
8111e6e0:	9465883a 	add	r18,r18,r17
8111e6e4:	9cffffc4 	addi	r19,r19,-1
8111e6e8:	4000051e 	bne	r8,zero,8111e700 <__svfscanf_r+0x1748>
8111e6ec:	a5000104 	addi	r20,r20,4
8111e6f0:	0021883a 	mov	r16,zero
8111e6f4:	003c6606 	br	8111d890 <__reset+0xfb0fd890>
8111e6f8:	a1000017 	ldw	r4,0(r20)
8111e6fc:	003fdb06 	br	8111e66c <__reset+0xfb0fe66c>
8111e700:	0021883a 	mov	r16,zero
8111e704:	003c6206 	br	8111d890 <__reset+0xfb0fd890>
8111e708:	d8800104 	addi	r2,sp,4
8111e70c:	802b883a 	mov	r21,r16
8111e710:	143a6b2e 	bgeu	r2,r16,8111d0c0 <__reset+0xfb0fd0c0>
8111e714:	ad7fffc4 	addi	r21,r21,-1
8111e718:	a9400007 	ldb	r5,0(r21)
8111e71c:	e00d883a 	mov	r6,fp
8111e720:	b009883a 	mov	r4,r22
8111e724:	1126c100 	call	81126c10 <_ungetc_r>
8111e728:	d8c00104 	addi	r3,sp,4
8111e72c:	1d7ff91e 	bne	r3,r21,8111e714 <__reset+0xfb0fe714>
8111e730:	003a6306 	br	8111d0c0 <__reset+0xfb0fd0c0>
8111e734:	0009883a 	mov	r4,zero
8111e738:	11236700 	call	81123670 <nanf>
8111e73c:	a0800015 	stw	r2,0(r20)
8111e740:	dc409c15 	stw	r17,624(sp)
8111e744:	003dac06 	br	8111ddf8 <__reset+0xfb0fddf8>
8111e748:	d9000104 	addi	r4,sp,4
8111e74c:	802b883a 	mov	r21,r16
8111e750:	243a5b2e 	bgeu	r4,r16,8111d0c0 <__reset+0xfb0fd0c0>
8111e754:	ad7fffc4 	addi	r21,r21,-1
8111e758:	a9400007 	ldb	r5,0(r21)
8111e75c:	e00d883a 	mov	r6,fp
8111e760:	b009883a 	mov	r4,r22
8111e764:	1126c100 	call	81126c10 <_ungetc_r>
8111e768:	d9400104 	addi	r5,sp,4
8111e76c:	2d7ff91e 	bne	r5,r21,8111e754 <__reset+0xfb0fe754>
8111e770:	003a5306 	br	8111d0c0 <__reset+0xfb0fd0c0>
8111e774:	11254380 	call	81125438 <_strtoull_r>
8111e778:	003f9d06 	br	8111e5f0 <__reset+0xfb0fe5f0>

8111e77c <vfscanf>:
8111e77c:	00a04574 	movhi	r2,33045
8111e780:	defffb04 	addi	sp,sp,-20
8111e784:	10a10204 	addi	r2,r2,-31736
8111e788:	de00012e 	bgeu	sp,et,8111e790 <vfscanf+0x14>
8111e78c:	003b68fa 	trap	3
8111e790:	dc000215 	stw	r16,8(sp)
8111e794:	14000017 	ldw	r16,0(r2)
8111e798:	dc400315 	stw	r17,12(sp)
8111e79c:	dfc00415 	stw	ra,16(sp)
8111e7a0:	2023883a 	mov	r17,r4
8111e7a4:	80000826 	beq	r16,zero,8111e7c8 <vfscanf+0x4c>
8111e7a8:	80800e17 	ldw	r2,56(r16)
8111e7ac:	1000061e 	bne	r2,zero,8111e7c8 <vfscanf+0x4c>
8111e7b0:	8009883a 	mov	r4,r16
8111e7b4:	d9400015 	stw	r5,0(sp)
8111e7b8:	d9800115 	stw	r6,4(sp)
8111e7bc:	1120a940 	call	81120a94 <__sinit>
8111e7c0:	d9800117 	ldw	r6,4(sp)
8111e7c4:	d9400017 	ldw	r5,0(sp)
8111e7c8:	300f883a 	mov	r7,r6
8111e7cc:	8009883a 	mov	r4,r16
8111e7d0:	280d883a 	mov	r6,r5
8111e7d4:	880b883a 	mov	r5,r17
8111e7d8:	dfc00417 	ldw	ra,16(sp)
8111e7dc:	dc400317 	ldw	r17,12(sp)
8111e7e0:	dc000217 	ldw	r16,8(sp)
8111e7e4:	dec00504 	addi	sp,sp,20
8111e7e8:	111cfb81 	jmpi	8111cfb8 <__svfscanf_r>

8111e7ec <__svfscanf>:
8111e7ec:	00a04574 	movhi	r2,33045
8111e7f0:	10a10204 	addi	r2,r2,-31736
8111e7f4:	300f883a 	mov	r7,r6
8111e7f8:	280d883a 	mov	r6,r5
8111e7fc:	200b883a 	mov	r5,r4
8111e800:	11000017 	ldw	r4,0(r2)
8111e804:	111cfb81 	jmpi	8111cfb8 <__svfscanf_r>

8111e808 <_vfscanf_r>:
8111e808:	defffb04 	addi	sp,sp,-20
8111e80c:	de00012e 	bgeu	sp,et,8111e814 <_vfscanf_r+0xc>
8111e810:	003b68fa 	trap	3
8111e814:	dc000315 	stw	r16,12(sp)
8111e818:	dfc00415 	stw	ra,16(sp)
8111e81c:	2021883a 	mov	r16,r4
8111e820:	20000926 	beq	r4,zero,8111e848 <_vfscanf_r+0x40>
8111e824:	20800e17 	ldw	r2,56(r4)
8111e828:	1000071e 	bne	r2,zero,8111e848 <_vfscanf_r+0x40>
8111e82c:	d9400015 	stw	r5,0(sp)
8111e830:	d9800115 	stw	r6,4(sp)
8111e834:	d9c00215 	stw	r7,8(sp)
8111e838:	1120a940 	call	81120a94 <__sinit>
8111e83c:	d9c00217 	ldw	r7,8(sp)
8111e840:	d9800117 	ldw	r6,4(sp)
8111e844:	d9400017 	ldw	r5,0(sp)
8111e848:	8009883a 	mov	r4,r16
8111e84c:	dfc00417 	ldw	ra,16(sp)
8111e850:	dc000317 	ldw	r16,12(sp)
8111e854:	dec00504 	addi	sp,sp,20
8111e858:	111cfb81 	jmpi	8111cfb8 <__svfscanf_r>

8111e85c <__swbuf_r>:
8111e85c:	defffb04 	addi	sp,sp,-20
8111e860:	de00012e 	bgeu	sp,et,8111e868 <__swbuf_r+0xc>
8111e864:	003b68fa 	trap	3
8111e868:	dcc00315 	stw	r19,12(sp)
8111e86c:	dc800215 	stw	r18,8(sp)
8111e870:	dc000015 	stw	r16,0(sp)
8111e874:	dfc00415 	stw	ra,16(sp)
8111e878:	dc400115 	stw	r17,4(sp)
8111e87c:	2025883a 	mov	r18,r4
8111e880:	2827883a 	mov	r19,r5
8111e884:	3021883a 	mov	r16,r6
8111e888:	20000226 	beq	r4,zero,8111e894 <__swbuf_r+0x38>
8111e88c:	20800e17 	ldw	r2,56(r4)
8111e890:	10004226 	beq	r2,zero,8111e99c <__swbuf_r+0x140>
8111e894:	80800617 	ldw	r2,24(r16)
8111e898:	8100030b 	ldhu	r4,12(r16)
8111e89c:	80800215 	stw	r2,8(r16)
8111e8a0:	2080020c 	andi	r2,r4,8
8111e8a4:	10003626 	beq	r2,zero,8111e980 <__swbuf_r+0x124>
8111e8a8:	80c00417 	ldw	r3,16(r16)
8111e8ac:	18003426 	beq	r3,zero,8111e980 <__swbuf_r+0x124>
8111e8b0:	2088000c 	andi	r2,r4,8192
8111e8b4:	9c403fcc 	andi	r17,r19,255
8111e8b8:	10001a26 	beq	r2,zero,8111e924 <__swbuf_r+0xc8>
8111e8bc:	80800017 	ldw	r2,0(r16)
8111e8c0:	81000517 	ldw	r4,20(r16)
8111e8c4:	10c7c83a 	sub	r3,r2,r3
8111e8c8:	1900200e 	bge	r3,r4,8111e94c <__swbuf_r+0xf0>
8111e8cc:	18c00044 	addi	r3,r3,1
8111e8d0:	81000217 	ldw	r4,8(r16)
8111e8d4:	11400044 	addi	r5,r2,1
8111e8d8:	81400015 	stw	r5,0(r16)
8111e8dc:	213fffc4 	addi	r4,r4,-1
8111e8e0:	81000215 	stw	r4,8(r16)
8111e8e4:	14c00005 	stb	r19,0(r2)
8111e8e8:	80800517 	ldw	r2,20(r16)
8111e8ec:	10c01e26 	beq	r2,r3,8111e968 <__swbuf_r+0x10c>
8111e8f0:	8080030b 	ldhu	r2,12(r16)
8111e8f4:	1080004c 	andi	r2,r2,1
8111e8f8:	10000226 	beq	r2,zero,8111e904 <__swbuf_r+0xa8>
8111e8fc:	00800284 	movi	r2,10
8111e900:	88801926 	beq	r17,r2,8111e968 <__swbuf_r+0x10c>
8111e904:	8805883a 	mov	r2,r17
8111e908:	dfc00417 	ldw	ra,16(sp)
8111e90c:	dcc00317 	ldw	r19,12(sp)
8111e910:	dc800217 	ldw	r18,8(sp)
8111e914:	dc400117 	ldw	r17,4(sp)
8111e918:	dc000017 	ldw	r16,0(sp)
8111e91c:	dec00504 	addi	sp,sp,20
8111e920:	f800283a 	ret
8111e924:	81401917 	ldw	r5,100(r16)
8111e928:	00b7ffc4 	movi	r2,-8193
8111e92c:	21080014 	ori	r4,r4,8192
8111e930:	2884703a 	and	r2,r5,r2
8111e934:	80801915 	stw	r2,100(r16)
8111e938:	80800017 	ldw	r2,0(r16)
8111e93c:	8100030d 	sth	r4,12(r16)
8111e940:	81000517 	ldw	r4,20(r16)
8111e944:	10c7c83a 	sub	r3,r2,r3
8111e948:	193fe016 	blt	r3,r4,8111e8cc <__reset+0xfb0fe8cc>
8111e94c:	800b883a 	mov	r5,r16
8111e950:	9009883a 	mov	r4,r18
8111e954:	11206980 	call	81120698 <_fflush_r>
8111e958:	1000071e 	bne	r2,zero,8111e978 <__swbuf_r+0x11c>
8111e95c:	80800017 	ldw	r2,0(r16)
8111e960:	00c00044 	movi	r3,1
8111e964:	003fda06 	br	8111e8d0 <__reset+0xfb0fe8d0>
8111e968:	800b883a 	mov	r5,r16
8111e96c:	9009883a 	mov	r4,r18
8111e970:	11206980 	call	81120698 <_fflush_r>
8111e974:	103fe326 	beq	r2,zero,8111e904 <__reset+0xfb0fe904>
8111e978:	00bfffc4 	movi	r2,-1
8111e97c:	003fe206 	br	8111e908 <__reset+0xfb0fe908>
8111e980:	800b883a 	mov	r5,r16
8111e984:	9009883a 	mov	r4,r18
8111e988:	111ea240 	call	8111ea24 <__swsetup_r>
8111e98c:	103ffa1e 	bne	r2,zero,8111e978 <__reset+0xfb0fe978>
8111e990:	8100030b 	ldhu	r4,12(r16)
8111e994:	80c00417 	ldw	r3,16(r16)
8111e998:	003fc506 	br	8111e8b0 <__reset+0xfb0fe8b0>
8111e99c:	1120a940 	call	81120a94 <__sinit>
8111e9a0:	003fbc06 	br	8111e894 <__reset+0xfb0fe894>

8111e9a4 <__swbuf>:
8111e9a4:	00a04574 	movhi	r2,33045
8111e9a8:	10a10204 	addi	r2,r2,-31736
8111e9ac:	280d883a 	mov	r6,r5
8111e9b0:	200b883a 	mov	r5,r4
8111e9b4:	11000017 	ldw	r4,0(r2)
8111e9b8:	111e85c1 	jmpi	8111e85c <__swbuf_r>

8111e9bc <_write_r>:
8111e9bc:	defffd04 	addi	sp,sp,-12
8111e9c0:	de00012e 	bgeu	sp,et,8111e9c8 <_write_r+0xc>
8111e9c4:	003b68fa 	trap	3
8111e9c8:	2805883a 	mov	r2,r5
8111e9cc:	dc000015 	stw	r16,0(sp)
8111e9d0:	04204574 	movhi	r16,33045
8111e9d4:	dc400115 	stw	r17,4(sp)
8111e9d8:	300b883a 	mov	r5,r6
8111e9dc:	84216604 	addi	r16,r16,-31336
8111e9e0:	2023883a 	mov	r17,r4
8111e9e4:	380d883a 	mov	r6,r7
8111e9e8:	1009883a 	mov	r4,r2
8111e9ec:	dfc00215 	stw	ra,8(sp)
8111e9f0:	80000015 	stw	zero,0(r16)
8111e9f4:	112e0740 	call	8112e074 <write>
8111e9f8:	00ffffc4 	movi	r3,-1
8111e9fc:	10c00526 	beq	r2,r3,8111ea14 <_write_r+0x58>
8111ea00:	dfc00217 	ldw	ra,8(sp)
8111ea04:	dc400117 	ldw	r17,4(sp)
8111ea08:	dc000017 	ldw	r16,0(sp)
8111ea0c:	dec00304 	addi	sp,sp,12
8111ea10:	f800283a 	ret
8111ea14:	80c00017 	ldw	r3,0(r16)
8111ea18:	183ff926 	beq	r3,zero,8111ea00 <__reset+0xfb0fea00>
8111ea1c:	88c00015 	stw	r3,0(r17)
8111ea20:	003ff706 	br	8111ea00 <__reset+0xfb0fea00>

8111ea24 <__swsetup_r>:
8111ea24:	00a04574 	movhi	r2,33045
8111ea28:	defffd04 	addi	sp,sp,-12
8111ea2c:	10a10204 	addi	r2,r2,-31736
8111ea30:	de00012e 	bgeu	sp,et,8111ea38 <__swsetup_r+0x14>
8111ea34:	003b68fa 	trap	3
8111ea38:	dc400115 	stw	r17,4(sp)
8111ea3c:	2023883a 	mov	r17,r4
8111ea40:	11000017 	ldw	r4,0(r2)
8111ea44:	dc000015 	stw	r16,0(sp)
8111ea48:	dfc00215 	stw	ra,8(sp)
8111ea4c:	2821883a 	mov	r16,r5
8111ea50:	20000226 	beq	r4,zero,8111ea5c <__swsetup_r+0x38>
8111ea54:	20800e17 	ldw	r2,56(r4)
8111ea58:	10003126 	beq	r2,zero,8111eb20 <__swsetup_r+0xfc>
8111ea5c:	8080030b 	ldhu	r2,12(r16)
8111ea60:	10c0020c 	andi	r3,r2,8
8111ea64:	1009883a 	mov	r4,r2
8111ea68:	18000f26 	beq	r3,zero,8111eaa8 <__swsetup_r+0x84>
8111ea6c:	80c00417 	ldw	r3,16(r16)
8111ea70:	18001526 	beq	r3,zero,8111eac8 <__swsetup_r+0xa4>
8111ea74:	1100004c 	andi	r4,r2,1
8111ea78:	20001c1e 	bne	r4,zero,8111eaec <__swsetup_r+0xc8>
8111ea7c:	1080008c 	andi	r2,r2,2
8111ea80:	1000291e 	bne	r2,zero,8111eb28 <__swsetup_r+0x104>
8111ea84:	80800517 	ldw	r2,20(r16)
8111ea88:	80800215 	stw	r2,8(r16)
8111ea8c:	18001c26 	beq	r3,zero,8111eb00 <__swsetup_r+0xdc>
8111ea90:	0005883a 	mov	r2,zero
8111ea94:	dfc00217 	ldw	ra,8(sp)
8111ea98:	dc400117 	ldw	r17,4(sp)
8111ea9c:	dc000017 	ldw	r16,0(sp)
8111eaa0:	dec00304 	addi	sp,sp,12
8111eaa4:	f800283a 	ret
8111eaa8:	2080040c 	andi	r2,r4,16
8111eaac:	10002e26 	beq	r2,zero,8111eb68 <__swsetup_r+0x144>
8111eab0:	2080010c 	andi	r2,r4,4
8111eab4:	10001e1e 	bne	r2,zero,8111eb30 <__swsetup_r+0x10c>
8111eab8:	80c00417 	ldw	r3,16(r16)
8111eabc:	20800214 	ori	r2,r4,8
8111eac0:	8080030d 	sth	r2,12(r16)
8111eac4:	183feb1e 	bne	r3,zero,8111ea74 <__reset+0xfb0fea74>
8111eac8:	1100a00c 	andi	r4,r2,640
8111eacc:	01408004 	movi	r5,512
8111ead0:	217fe826 	beq	r4,r5,8111ea74 <__reset+0xfb0fea74>
8111ead4:	800b883a 	mov	r5,r16
8111ead8:	8809883a 	mov	r4,r17
8111eadc:	11172f40 	call	811172f4 <__smakebuf_r>
8111eae0:	8080030b 	ldhu	r2,12(r16)
8111eae4:	80c00417 	ldw	r3,16(r16)
8111eae8:	003fe206 	br	8111ea74 <__reset+0xfb0fea74>
8111eaec:	80800517 	ldw	r2,20(r16)
8111eaf0:	80000215 	stw	zero,8(r16)
8111eaf4:	0085c83a 	sub	r2,zero,r2
8111eaf8:	80800615 	stw	r2,24(r16)
8111eafc:	183fe41e 	bne	r3,zero,8111ea90 <__reset+0xfb0fea90>
8111eb00:	80c0030b 	ldhu	r3,12(r16)
8111eb04:	0005883a 	mov	r2,zero
8111eb08:	1900200c 	andi	r4,r3,128
8111eb0c:	203fe126 	beq	r4,zero,8111ea94 <__reset+0xfb0fea94>
8111eb10:	18c01014 	ori	r3,r3,64
8111eb14:	80c0030d 	sth	r3,12(r16)
8111eb18:	00bfffc4 	movi	r2,-1
8111eb1c:	003fdd06 	br	8111ea94 <__reset+0xfb0fea94>
8111eb20:	1120a940 	call	81120a94 <__sinit>
8111eb24:	003fcd06 	br	8111ea5c <__reset+0xfb0fea5c>
8111eb28:	0005883a 	mov	r2,zero
8111eb2c:	003fd606 	br	8111ea88 <__reset+0xfb0fea88>
8111eb30:	81400c17 	ldw	r5,48(r16)
8111eb34:	28000626 	beq	r5,zero,8111eb50 <__swsetup_r+0x12c>
8111eb38:	80801004 	addi	r2,r16,64
8111eb3c:	28800326 	beq	r5,r2,8111eb4c <__swsetup_r+0x128>
8111eb40:	8809883a 	mov	r4,r17
8111eb44:	1120f2c0 	call	81120f2c <_free_r>
8111eb48:	8100030b 	ldhu	r4,12(r16)
8111eb4c:	80000c15 	stw	zero,48(r16)
8111eb50:	80c00417 	ldw	r3,16(r16)
8111eb54:	00bff6c4 	movi	r2,-37
8111eb58:	1108703a 	and	r4,r2,r4
8111eb5c:	80000115 	stw	zero,4(r16)
8111eb60:	80c00015 	stw	r3,0(r16)
8111eb64:	003fd506 	br	8111eabc <__reset+0xfb0feabc>
8111eb68:	00800244 	movi	r2,9
8111eb6c:	88800015 	stw	r2,0(r17)
8111eb70:	20801014 	ori	r2,r4,64
8111eb74:	8080030d 	sth	r2,12(r16)
8111eb78:	00bfffc4 	movi	r2,-1
8111eb7c:	003fc506 	br	8111ea94 <__reset+0xfb0fea94>

8111eb80 <_close_r>:
8111eb80:	defffd04 	addi	sp,sp,-12
8111eb84:	de00012e 	bgeu	sp,et,8111eb8c <_close_r+0xc>
8111eb88:	003b68fa 	trap	3
8111eb8c:	dc000015 	stw	r16,0(sp)
8111eb90:	04204574 	movhi	r16,33045
8111eb94:	dc400115 	stw	r17,4(sp)
8111eb98:	84216604 	addi	r16,r16,-31336
8111eb9c:	2023883a 	mov	r17,r4
8111eba0:	2809883a 	mov	r4,r5
8111eba4:	dfc00215 	stw	ra,8(sp)
8111eba8:	80000015 	stw	zero,0(r16)
8111ebac:	112c5f40 	call	8112c5f4 <close>
8111ebb0:	00ffffc4 	movi	r3,-1
8111ebb4:	10c00526 	beq	r2,r3,8111ebcc <_close_r+0x4c>
8111ebb8:	dfc00217 	ldw	ra,8(sp)
8111ebbc:	dc400117 	ldw	r17,4(sp)
8111ebc0:	dc000017 	ldw	r16,0(sp)
8111ebc4:	dec00304 	addi	sp,sp,12
8111ebc8:	f800283a 	ret
8111ebcc:	80c00017 	ldw	r3,0(r16)
8111ebd0:	183ff926 	beq	r3,zero,8111ebb8 <__reset+0xfb0febb8>
8111ebd4:	88c00015 	stw	r3,0(r17)
8111ebd8:	003ff706 	br	8111ebb8 <__reset+0xfb0febb8>

8111ebdc <quorem>:
8111ebdc:	defff704 	addi	sp,sp,-36
8111ebe0:	de00012e 	bgeu	sp,et,8111ebe8 <quorem+0xc>
8111ebe4:	003b68fa 	trap	3
8111ebe8:	dc800215 	stw	r18,8(sp)
8111ebec:	20800417 	ldw	r2,16(r4)
8111ebf0:	2c800417 	ldw	r18,16(r5)
8111ebf4:	dfc00815 	stw	ra,32(sp)
8111ebf8:	ddc00715 	stw	r23,28(sp)
8111ebfc:	dd800615 	stw	r22,24(sp)
8111ec00:	dd400515 	stw	r21,20(sp)
8111ec04:	dd000415 	stw	r20,16(sp)
8111ec08:	dcc00315 	stw	r19,12(sp)
8111ec0c:	dc400115 	stw	r17,4(sp)
8111ec10:	dc000015 	stw	r16,0(sp)
8111ec14:	14807116 	blt	r2,r18,8111eddc <quorem+0x200>
8111ec18:	94bfffc4 	addi	r18,r18,-1
8111ec1c:	94ad883a 	add	r22,r18,r18
8111ec20:	b5ad883a 	add	r22,r22,r22
8111ec24:	2c400504 	addi	r17,r5,20
8111ec28:	8da9883a 	add	r20,r17,r22
8111ec2c:	25400504 	addi	r21,r4,20
8111ec30:	282f883a 	mov	r23,r5
8111ec34:	adad883a 	add	r22,r21,r22
8111ec38:	a1400017 	ldw	r5,0(r20)
8111ec3c:	2021883a 	mov	r16,r4
8111ec40:	b1000017 	ldw	r4,0(r22)
8111ec44:	29400044 	addi	r5,r5,1
8111ec48:	112a2b40 	call	8112a2b4 <__udivsi3>
8111ec4c:	1027883a 	mov	r19,r2
8111ec50:	10002c26 	beq	r2,zero,8111ed04 <quorem+0x128>
8111ec54:	a813883a 	mov	r9,r21
8111ec58:	880b883a 	mov	r5,r17
8111ec5c:	0009883a 	mov	r4,zero
8111ec60:	000d883a 	mov	r6,zero
8111ec64:	2a000017 	ldw	r8,0(r5)
8111ec68:	49c00017 	ldw	r7,0(r9)
8111ec6c:	29400104 	addi	r5,r5,4
8111ec70:	40bfffcc 	andi	r2,r8,65535
8111ec74:	14c5383a 	mul	r2,r2,r19
8111ec78:	4010d43a 	srli	r8,r8,16
8111ec7c:	38ffffcc 	andi	r3,r7,65535
8111ec80:	1105883a 	add	r2,r2,r4
8111ec84:	1008d43a 	srli	r4,r2,16
8111ec88:	44d1383a 	mul	r8,r8,r19
8111ec8c:	198d883a 	add	r6,r3,r6
8111ec90:	10ffffcc 	andi	r3,r2,65535
8111ec94:	30c7c83a 	sub	r3,r6,r3
8111ec98:	380ed43a 	srli	r7,r7,16
8111ec9c:	4105883a 	add	r2,r8,r4
8111eca0:	180dd43a 	srai	r6,r3,16
8111eca4:	113fffcc 	andi	r4,r2,65535
8111eca8:	390fc83a 	sub	r7,r7,r4
8111ecac:	398d883a 	add	r6,r7,r6
8111ecb0:	300e943a 	slli	r7,r6,16
8111ecb4:	18ffffcc 	andi	r3,r3,65535
8111ecb8:	1008d43a 	srli	r4,r2,16
8111ecbc:	38ceb03a 	or	r7,r7,r3
8111ecc0:	49c00015 	stw	r7,0(r9)
8111ecc4:	300dd43a 	srai	r6,r6,16
8111ecc8:	4a400104 	addi	r9,r9,4
8111eccc:	a17fe52e 	bgeu	r20,r5,8111ec64 <__reset+0xfb0fec64>
8111ecd0:	b0800017 	ldw	r2,0(r22)
8111ecd4:	10000b1e 	bne	r2,zero,8111ed04 <quorem+0x128>
8111ecd8:	b0bfff04 	addi	r2,r22,-4
8111ecdc:	a880082e 	bgeu	r21,r2,8111ed00 <quorem+0x124>
8111ece0:	b0ffff17 	ldw	r3,-4(r22)
8111ece4:	18000326 	beq	r3,zero,8111ecf4 <quorem+0x118>
8111ece8:	00000506 	br	8111ed00 <quorem+0x124>
8111ecec:	10c00017 	ldw	r3,0(r2)
8111ecf0:	1800031e 	bne	r3,zero,8111ed00 <quorem+0x124>
8111ecf4:	10bfff04 	addi	r2,r2,-4
8111ecf8:	94bfffc4 	addi	r18,r18,-1
8111ecfc:	a8bffb36 	bltu	r21,r2,8111ecec <__reset+0xfb0fecec>
8111ed00:	84800415 	stw	r18,16(r16)
8111ed04:	b80b883a 	mov	r5,r23
8111ed08:	8009883a 	mov	r4,r16
8111ed0c:	11227fc0 	call	811227fc <__mcmp>
8111ed10:	10002616 	blt	r2,zero,8111edac <quorem+0x1d0>
8111ed14:	9cc00044 	addi	r19,r19,1
8111ed18:	a805883a 	mov	r2,r21
8111ed1c:	000b883a 	mov	r5,zero
8111ed20:	11000017 	ldw	r4,0(r2)
8111ed24:	89800017 	ldw	r6,0(r17)
8111ed28:	10800104 	addi	r2,r2,4
8111ed2c:	20ffffcc 	andi	r3,r4,65535
8111ed30:	194b883a 	add	r5,r3,r5
8111ed34:	30ffffcc 	andi	r3,r6,65535
8111ed38:	28c7c83a 	sub	r3,r5,r3
8111ed3c:	300cd43a 	srli	r6,r6,16
8111ed40:	2008d43a 	srli	r4,r4,16
8111ed44:	180bd43a 	srai	r5,r3,16
8111ed48:	18ffffcc 	andi	r3,r3,65535
8111ed4c:	2189c83a 	sub	r4,r4,r6
8111ed50:	2149883a 	add	r4,r4,r5
8111ed54:	200c943a 	slli	r6,r4,16
8111ed58:	8c400104 	addi	r17,r17,4
8111ed5c:	200bd43a 	srai	r5,r4,16
8111ed60:	30c6b03a 	or	r3,r6,r3
8111ed64:	10ffff15 	stw	r3,-4(r2)
8111ed68:	a47fed2e 	bgeu	r20,r17,8111ed20 <__reset+0xfb0fed20>
8111ed6c:	9485883a 	add	r2,r18,r18
8111ed70:	1085883a 	add	r2,r2,r2
8111ed74:	a887883a 	add	r3,r21,r2
8111ed78:	18800017 	ldw	r2,0(r3)
8111ed7c:	10000b1e 	bne	r2,zero,8111edac <quorem+0x1d0>
8111ed80:	18bfff04 	addi	r2,r3,-4
8111ed84:	a880082e 	bgeu	r21,r2,8111eda8 <quorem+0x1cc>
8111ed88:	18ffff17 	ldw	r3,-4(r3)
8111ed8c:	18000326 	beq	r3,zero,8111ed9c <quorem+0x1c0>
8111ed90:	00000506 	br	8111eda8 <quorem+0x1cc>
8111ed94:	10c00017 	ldw	r3,0(r2)
8111ed98:	1800031e 	bne	r3,zero,8111eda8 <quorem+0x1cc>
8111ed9c:	10bfff04 	addi	r2,r2,-4
8111eda0:	94bfffc4 	addi	r18,r18,-1
8111eda4:	a8bffb36 	bltu	r21,r2,8111ed94 <__reset+0xfb0fed94>
8111eda8:	84800415 	stw	r18,16(r16)
8111edac:	9805883a 	mov	r2,r19
8111edb0:	dfc00817 	ldw	ra,32(sp)
8111edb4:	ddc00717 	ldw	r23,28(sp)
8111edb8:	dd800617 	ldw	r22,24(sp)
8111edbc:	dd400517 	ldw	r21,20(sp)
8111edc0:	dd000417 	ldw	r20,16(sp)
8111edc4:	dcc00317 	ldw	r19,12(sp)
8111edc8:	dc800217 	ldw	r18,8(sp)
8111edcc:	dc400117 	ldw	r17,4(sp)
8111edd0:	dc000017 	ldw	r16,0(sp)
8111edd4:	dec00904 	addi	sp,sp,36
8111edd8:	f800283a 	ret
8111eddc:	0005883a 	mov	r2,zero
8111ede0:	003ff306 	br	8111edb0 <__reset+0xfb0fedb0>

8111ede4 <_dtoa_r>:
8111ede4:	deffde04 	addi	sp,sp,-136
8111ede8:	de00012e 	bgeu	sp,et,8111edf0 <_dtoa_r+0xc>
8111edec:	003b68fa 	trap	3
8111edf0:	20801017 	ldw	r2,64(r4)
8111edf4:	df002015 	stw	fp,128(sp)
8111edf8:	dcc01b15 	stw	r19,108(sp)
8111edfc:	dc801a15 	stw	r18,104(sp)
8111ee00:	dc401915 	stw	r17,100(sp)
8111ee04:	dc001815 	stw	r16,96(sp)
8111ee08:	dfc02115 	stw	ra,132(sp)
8111ee0c:	ddc01f15 	stw	r23,124(sp)
8111ee10:	dd801e15 	stw	r22,120(sp)
8111ee14:	dd401d15 	stw	r21,116(sp)
8111ee18:	dd001c15 	stw	r20,112(sp)
8111ee1c:	d9c00315 	stw	r7,12(sp)
8111ee20:	2039883a 	mov	fp,r4
8111ee24:	3023883a 	mov	r17,r6
8111ee28:	2825883a 	mov	r18,r5
8111ee2c:	dc002417 	ldw	r16,144(sp)
8111ee30:	3027883a 	mov	r19,r6
8111ee34:	10000826 	beq	r2,zero,8111ee58 <_dtoa_r+0x74>
8111ee38:	21801117 	ldw	r6,68(r4)
8111ee3c:	00c00044 	movi	r3,1
8111ee40:	100b883a 	mov	r5,r2
8111ee44:	1986983a 	sll	r3,r3,r6
8111ee48:	11800115 	stw	r6,4(r2)
8111ee4c:	10c00215 	stw	r3,8(r2)
8111ee50:	1121fac0 	call	81121fac <_Bfree>
8111ee54:	e0001015 	stw	zero,64(fp)
8111ee58:	88002e16 	blt	r17,zero,8111ef14 <_dtoa_r+0x130>
8111ee5c:	80000015 	stw	zero,0(r16)
8111ee60:	889ffc2c 	andhi	r2,r17,32752
8111ee64:	00dffc34 	movhi	r3,32752
8111ee68:	10c01c26 	beq	r2,r3,8111eedc <_dtoa_r+0xf8>
8111ee6c:	000d883a 	mov	r6,zero
8111ee70:	000f883a 	mov	r7,zero
8111ee74:	9009883a 	mov	r4,r18
8111ee78:	980b883a 	mov	r5,r19
8111ee7c:	112b7100 	call	8112b710 <__eqdf2>
8111ee80:	10002b1e 	bne	r2,zero,8111ef30 <_dtoa_r+0x14c>
8111ee84:	d9c02317 	ldw	r7,140(sp)
8111ee88:	00800044 	movi	r2,1
8111ee8c:	38800015 	stw	r2,0(r7)
8111ee90:	d8802517 	ldw	r2,148(sp)
8111ee94:	10019e26 	beq	r2,zero,8111f510 <_dtoa_r+0x72c>
8111ee98:	d8c02517 	ldw	r3,148(sp)
8111ee9c:	00a04534 	movhi	r2,33044
8111eea0:	10973a44 	addi	r2,r2,23785
8111eea4:	18800015 	stw	r2,0(r3)
8111eea8:	10bfffc4 	addi	r2,r2,-1
8111eeac:	dfc02117 	ldw	ra,132(sp)
8111eeb0:	df002017 	ldw	fp,128(sp)
8111eeb4:	ddc01f17 	ldw	r23,124(sp)
8111eeb8:	dd801e17 	ldw	r22,120(sp)
8111eebc:	dd401d17 	ldw	r21,116(sp)
8111eec0:	dd001c17 	ldw	r20,112(sp)
8111eec4:	dcc01b17 	ldw	r19,108(sp)
8111eec8:	dc801a17 	ldw	r18,104(sp)
8111eecc:	dc401917 	ldw	r17,100(sp)
8111eed0:	dc001817 	ldw	r16,96(sp)
8111eed4:	dec02204 	addi	sp,sp,136
8111eed8:	f800283a 	ret
8111eedc:	d8c02317 	ldw	r3,140(sp)
8111eee0:	0089c3c4 	movi	r2,9999
8111eee4:	18800015 	stw	r2,0(r3)
8111eee8:	90017726 	beq	r18,zero,8111f4c8 <_dtoa_r+0x6e4>
8111eeec:	00a04534 	movhi	r2,33044
8111eef0:	10975804 	addi	r2,r2,23904
8111eef4:	d9002517 	ldw	r4,148(sp)
8111eef8:	203fec26 	beq	r4,zero,8111eeac <__reset+0xfb0feeac>
8111eefc:	10c000c7 	ldb	r3,3(r2)
8111ef00:	1801781e 	bne	r3,zero,8111f4e4 <_dtoa_r+0x700>
8111ef04:	10c000c4 	addi	r3,r2,3
8111ef08:	d9802517 	ldw	r6,148(sp)
8111ef0c:	30c00015 	stw	r3,0(r6)
8111ef10:	003fe606 	br	8111eeac <__reset+0xfb0feeac>
8111ef14:	04e00034 	movhi	r19,32768
8111ef18:	9cffffc4 	addi	r19,r19,-1
8111ef1c:	00800044 	movi	r2,1
8111ef20:	8ce6703a 	and	r19,r17,r19
8111ef24:	80800015 	stw	r2,0(r16)
8111ef28:	9823883a 	mov	r17,r19
8111ef2c:	003fcc06 	br	8111ee60 <__reset+0xfb0fee60>
8111ef30:	d8800204 	addi	r2,sp,8
8111ef34:	d8800015 	stw	r2,0(sp)
8111ef38:	d9c00104 	addi	r7,sp,4
8111ef3c:	900b883a 	mov	r5,r18
8111ef40:	980d883a 	mov	r6,r19
8111ef44:	e009883a 	mov	r4,fp
8111ef48:	8820d53a 	srli	r16,r17,20
8111ef4c:	1122bd80 	call	81122bd8 <__d2b>
8111ef50:	d8800915 	stw	r2,36(sp)
8111ef54:	8001651e 	bne	r16,zero,8111f4ec <_dtoa_r+0x708>
8111ef58:	dd800217 	ldw	r22,8(sp)
8111ef5c:	dc000117 	ldw	r16,4(sp)
8111ef60:	00800804 	movi	r2,32
8111ef64:	b421883a 	add	r16,r22,r16
8111ef68:	80c10c84 	addi	r3,r16,1074
8111ef6c:	10c2d10e 	bge	r2,r3,8111fab4 <_dtoa_r+0xcd0>
8111ef70:	00801004 	movi	r2,64
8111ef74:	81010484 	addi	r4,r16,1042
8111ef78:	10c7c83a 	sub	r3,r2,r3
8111ef7c:	9108d83a 	srl	r4,r18,r4
8111ef80:	88e2983a 	sll	r17,r17,r3
8111ef84:	2448b03a 	or	r4,r4,r17
8111ef88:	112c3d00 	call	8112c3d0 <__floatunsidf>
8111ef8c:	017f8434 	movhi	r5,65040
8111ef90:	01800044 	movi	r6,1
8111ef94:	1009883a 	mov	r4,r2
8111ef98:	194b883a 	add	r5,r3,r5
8111ef9c:	843fffc4 	addi	r16,r16,-1
8111efa0:	d9801115 	stw	r6,68(sp)
8111efa4:	000d883a 	mov	r6,zero
8111efa8:	01cffe34 	movhi	r7,16376
8111efac:	112b9680 	call	8112b968 <__subdf3>
8111efb0:	0198dbf4 	movhi	r6,25455
8111efb4:	01cff4f4 	movhi	r7,16339
8111efb8:	3190d844 	addi	r6,r6,17249
8111efbc:	39e1e9c4 	addi	r7,r7,-30809
8111efc0:	1009883a 	mov	r4,r2
8111efc4:	180b883a 	mov	r5,r3
8111efc8:	111607c0 	call	8111607c <__muldf3>
8111efcc:	01a2d874 	movhi	r6,35681
8111efd0:	01cff1f4 	movhi	r7,16327
8111efd4:	31b22cc4 	addi	r6,r6,-14157
8111efd8:	39e28a04 	addi	r7,r7,-30168
8111efdc:	180b883a 	mov	r5,r3
8111efe0:	1009883a 	mov	r4,r2
8111efe4:	112a56c0 	call	8112a56c <__adddf3>
8111efe8:	8009883a 	mov	r4,r16
8111efec:	1029883a 	mov	r20,r2
8111eff0:	1823883a 	mov	r17,r3
8111eff4:	112c2ec0 	call	8112c2ec <__floatsidf>
8111eff8:	019427f4 	movhi	r6,20639
8111effc:	01cff4f4 	movhi	r7,16339
8111f000:	319e7ec4 	addi	r6,r6,31227
8111f004:	39d104c4 	addi	r7,r7,17427
8111f008:	1009883a 	mov	r4,r2
8111f00c:	180b883a 	mov	r5,r3
8111f010:	111607c0 	call	8111607c <__muldf3>
8111f014:	100d883a 	mov	r6,r2
8111f018:	180f883a 	mov	r7,r3
8111f01c:	a009883a 	mov	r4,r20
8111f020:	880b883a 	mov	r5,r17
8111f024:	112a56c0 	call	8112a56c <__adddf3>
8111f028:	1009883a 	mov	r4,r2
8111f02c:	180b883a 	mov	r5,r3
8111f030:	1029883a 	mov	r20,r2
8111f034:	1823883a 	mov	r17,r3
8111f038:	112c26c0 	call	8112c26c <__fixdfsi>
8111f03c:	000d883a 	mov	r6,zero
8111f040:	000f883a 	mov	r7,zero
8111f044:	a009883a 	mov	r4,r20
8111f048:	880b883a 	mov	r5,r17
8111f04c:	d8800515 	stw	r2,20(sp)
8111f050:	112b8740 	call	8112b874 <__ledf2>
8111f054:	10028716 	blt	r2,zero,8111fa74 <_dtoa_r+0xc90>
8111f058:	d8c00517 	ldw	r3,20(sp)
8111f05c:	00800584 	movi	r2,22
8111f060:	10c27536 	bltu	r2,r3,8111fa38 <_dtoa_r+0xc54>
8111f064:	180490fa 	slli	r2,r3,3
8111f068:	00e04534 	movhi	r3,33044
8111f06c:	18d77304 	addi	r3,r3,24012
8111f070:	1885883a 	add	r2,r3,r2
8111f074:	11000017 	ldw	r4,0(r2)
8111f078:	11400117 	ldw	r5,4(r2)
8111f07c:	900d883a 	mov	r6,r18
8111f080:	980f883a 	mov	r7,r19
8111f084:	112b7980 	call	8112b798 <__gedf2>
8111f088:	00828d0e 	bge	zero,r2,8111fac0 <_dtoa_r+0xcdc>
8111f08c:	d9000517 	ldw	r4,20(sp)
8111f090:	d8000e15 	stw	zero,56(sp)
8111f094:	213fffc4 	addi	r4,r4,-1
8111f098:	d9000515 	stw	r4,20(sp)
8111f09c:	b42dc83a 	sub	r22,r22,r16
8111f0a0:	b5bfffc4 	addi	r22,r22,-1
8111f0a4:	b0026f16 	blt	r22,zero,8111fa64 <_dtoa_r+0xc80>
8111f0a8:	d8000815 	stw	zero,32(sp)
8111f0ac:	d9c00517 	ldw	r7,20(sp)
8111f0b0:	38026416 	blt	r7,zero,8111fa44 <_dtoa_r+0xc60>
8111f0b4:	b1ed883a 	add	r22,r22,r7
8111f0b8:	d9c00d15 	stw	r7,52(sp)
8111f0bc:	d8000a15 	stw	zero,40(sp)
8111f0c0:	d9800317 	ldw	r6,12(sp)
8111f0c4:	00800244 	movi	r2,9
8111f0c8:	11811436 	bltu	r2,r6,8111f51c <_dtoa_r+0x738>
8111f0cc:	00800144 	movi	r2,5
8111f0d0:	1184e10e 	bge	r2,r6,81120458 <_dtoa_r+0x1674>
8111f0d4:	31bfff04 	addi	r6,r6,-4
8111f0d8:	d9800315 	stw	r6,12(sp)
8111f0dc:	0023883a 	mov	r17,zero
8111f0e0:	d9800317 	ldw	r6,12(sp)
8111f0e4:	008000c4 	movi	r2,3
8111f0e8:	30836726 	beq	r6,r2,8111fe88 <_dtoa_r+0x10a4>
8111f0ec:	1183410e 	bge	r2,r6,8111fdf4 <_dtoa_r+0x1010>
8111f0f0:	d9c00317 	ldw	r7,12(sp)
8111f0f4:	00800104 	movi	r2,4
8111f0f8:	38827c26 	beq	r7,r2,8111faec <_dtoa_r+0xd08>
8111f0fc:	00800144 	movi	r2,5
8111f100:	3884c41e 	bne	r7,r2,81120414 <_dtoa_r+0x1630>
8111f104:	00800044 	movi	r2,1
8111f108:	d8800b15 	stw	r2,44(sp)
8111f10c:	d8c00517 	ldw	r3,20(sp)
8111f110:	d9002217 	ldw	r4,136(sp)
8111f114:	1907883a 	add	r3,r3,r4
8111f118:	19800044 	addi	r6,r3,1
8111f11c:	d8c00c15 	stw	r3,48(sp)
8111f120:	d9800615 	stw	r6,24(sp)
8111f124:	0183a40e 	bge	zero,r6,8111ffb8 <_dtoa_r+0x11d4>
8111f128:	d9800617 	ldw	r6,24(sp)
8111f12c:	3021883a 	mov	r16,r6
8111f130:	e0001115 	stw	zero,68(fp)
8111f134:	008005c4 	movi	r2,23
8111f138:	1184c92e 	bgeu	r2,r6,81120460 <_dtoa_r+0x167c>
8111f13c:	00c00044 	movi	r3,1
8111f140:	00800104 	movi	r2,4
8111f144:	1085883a 	add	r2,r2,r2
8111f148:	11000504 	addi	r4,r2,20
8111f14c:	180b883a 	mov	r5,r3
8111f150:	18c00044 	addi	r3,r3,1
8111f154:	313ffb2e 	bgeu	r6,r4,8111f144 <__reset+0xfb0ff144>
8111f158:	e1401115 	stw	r5,68(fp)
8111f15c:	e009883a 	mov	r4,fp
8111f160:	1121efc0 	call	81121efc <_Balloc>
8111f164:	d8800715 	stw	r2,28(sp)
8111f168:	e0801015 	stw	r2,64(fp)
8111f16c:	00800384 	movi	r2,14
8111f170:	1400f736 	bltu	r2,r16,8111f550 <_dtoa_r+0x76c>
8111f174:	8800f626 	beq	r17,zero,8111f550 <_dtoa_r+0x76c>
8111f178:	d9c00517 	ldw	r7,20(sp)
8111f17c:	01c39a0e 	bge	zero,r7,8111ffe8 <_dtoa_r+0x1204>
8111f180:	388003cc 	andi	r2,r7,15
8111f184:	100490fa 	slli	r2,r2,3
8111f188:	382bd13a 	srai	r21,r7,4
8111f18c:	00e04534 	movhi	r3,33044
8111f190:	18d77304 	addi	r3,r3,24012
8111f194:	1885883a 	add	r2,r3,r2
8111f198:	a8c0040c 	andi	r3,r21,16
8111f19c:	12400017 	ldw	r9,0(r2)
8111f1a0:	12000117 	ldw	r8,4(r2)
8111f1a4:	18037926 	beq	r3,zero,8111ff8c <_dtoa_r+0x11a8>
8111f1a8:	00a04534 	movhi	r2,33044
8111f1ac:	10976904 	addi	r2,r2,23972
8111f1b0:	11800817 	ldw	r6,32(r2)
8111f1b4:	11c00917 	ldw	r7,36(r2)
8111f1b8:	9009883a 	mov	r4,r18
8111f1bc:	980b883a 	mov	r5,r19
8111f1c0:	da001715 	stw	r8,92(sp)
8111f1c4:	da401615 	stw	r9,88(sp)
8111f1c8:	112ae200 	call	8112ae20 <__divdf3>
8111f1cc:	da001717 	ldw	r8,92(sp)
8111f1d0:	da401617 	ldw	r9,88(sp)
8111f1d4:	ad4003cc 	andi	r21,r21,15
8111f1d8:	040000c4 	movi	r16,3
8111f1dc:	1023883a 	mov	r17,r2
8111f1e0:	1829883a 	mov	r20,r3
8111f1e4:	a8001126 	beq	r21,zero,8111f22c <_dtoa_r+0x448>
8111f1e8:	05e04534 	movhi	r23,33044
8111f1ec:	bdd76904 	addi	r23,r23,23972
8111f1f0:	4805883a 	mov	r2,r9
8111f1f4:	4007883a 	mov	r3,r8
8111f1f8:	a980004c 	andi	r6,r21,1
8111f1fc:	1009883a 	mov	r4,r2
8111f200:	a82bd07a 	srai	r21,r21,1
8111f204:	180b883a 	mov	r5,r3
8111f208:	30000426 	beq	r6,zero,8111f21c <_dtoa_r+0x438>
8111f20c:	b9800017 	ldw	r6,0(r23)
8111f210:	b9c00117 	ldw	r7,4(r23)
8111f214:	84000044 	addi	r16,r16,1
8111f218:	111607c0 	call	8111607c <__muldf3>
8111f21c:	bdc00204 	addi	r23,r23,8
8111f220:	a83ff51e 	bne	r21,zero,8111f1f8 <__reset+0xfb0ff1f8>
8111f224:	1013883a 	mov	r9,r2
8111f228:	1811883a 	mov	r8,r3
8111f22c:	480d883a 	mov	r6,r9
8111f230:	400f883a 	mov	r7,r8
8111f234:	8809883a 	mov	r4,r17
8111f238:	a00b883a 	mov	r5,r20
8111f23c:	112ae200 	call	8112ae20 <__divdf3>
8111f240:	d8800f15 	stw	r2,60(sp)
8111f244:	d8c01015 	stw	r3,64(sp)
8111f248:	d8c00e17 	ldw	r3,56(sp)
8111f24c:	18000626 	beq	r3,zero,8111f268 <_dtoa_r+0x484>
8111f250:	d9000f17 	ldw	r4,60(sp)
8111f254:	d9401017 	ldw	r5,64(sp)
8111f258:	000d883a 	mov	r6,zero
8111f25c:	01cffc34 	movhi	r7,16368
8111f260:	112b8740 	call	8112b874 <__ledf2>
8111f264:	10040b16 	blt	r2,zero,81120294 <_dtoa_r+0x14b0>
8111f268:	8009883a 	mov	r4,r16
8111f26c:	112c2ec0 	call	8112c2ec <__floatsidf>
8111f270:	d9800f17 	ldw	r6,60(sp)
8111f274:	d9c01017 	ldw	r7,64(sp)
8111f278:	1009883a 	mov	r4,r2
8111f27c:	180b883a 	mov	r5,r3
8111f280:	111607c0 	call	8111607c <__muldf3>
8111f284:	000d883a 	mov	r6,zero
8111f288:	01d00734 	movhi	r7,16412
8111f28c:	1009883a 	mov	r4,r2
8111f290:	180b883a 	mov	r5,r3
8111f294:	112a56c0 	call	8112a56c <__adddf3>
8111f298:	1021883a 	mov	r16,r2
8111f29c:	d8800617 	ldw	r2,24(sp)
8111f2a0:	047f3034 	movhi	r17,64704
8111f2a4:	1c63883a 	add	r17,r3,r17
8111f2a8:	10031826 	beq	r2,zero,8111ff0c <_dtoa_r+0x1128>
8111f2ac:	d8c00517 	ldw	r3,20(sp)
8111f2b0:	db000617 	ldw	r12,24(sp)
8111f2b4:	d8c01315 	stw	r3,76(sp)
8111f2b8:	d9000b17 	ldw	r4,44(sp)
8111f2bc:	20038f26 	beq	r4,zero,811200fc <_dtoa_r+0x1318>
8111f2c0:	60bfffc4 	addi	r2,r12,-1
8111f2c4:	100490fa 	slli	r2,r2,3
8111f2c8:	00e04534 	movhi	r3,33044
8111f2cc:	18d77304 	addi	r3,r3,24012
8111f2d0:	1885883a 	add	r2,r3,r2
8111f2d4:	11800017 	ldw	r6,0(r2)
8111f2d8:	11c00117 	ldw	r7,4(r2)
8111f2dc:	d8800717 	ldw	r2,28(sp)
8111f2e0:	0009883a 	mov	r4,zero
8111f2e4:	014ff834 	movhi	r5,16352
8111f2e8:	db001615 	stw	r12,88(sp)
8111f2ec:	15c00044 	addi	r23,r2,1
8111f2f0:	112ae200 	call	8112ae20 <__divdf3>
8111f2f4:	800d883a 	mov	r6,r16
8111f2f8:	880f883a 	mov	r7,r17
8111f2fc:	1009883a 	mov	r4,r2
8111f300:	180b883a 	mov	r5,r3
8111f304:	112b9680 	call	8112b968 <__subdf3>
8111f308:	d9401017 	ldw	r5,64(sp)
8111f30c:	d9000f17 	ldw	r4,60(sp)
8111f310:	102b883a 	mov	r21,r2
8111f314:	d8c01215 	stw	r3,72(sp)
8111f318:	112c26c0 	call	8112c26c <__fixdfsi>
8111f31c:	1009883a 	mov	r4,r2
8111f320:	1029883a 	mov	r20,r2
8111f324:	112c2ec0 	call	8112c2ec <__floatsidf>
8111f328:	d9000f17 	ldw	r4,60(sp)
8111f32c:	d9401017 	ldw	r5,64(sp)
8111f330:	100d883a 	mov	r6,r2
8111f334:	180f883a 	mov	r7,r3
8111f338:	112b9680 	call	8112b968 <__subdf3>
8111f33c:	1823883a 	mov	r17,r3
8111f340:	d8c00717 	ldw	r3,28(sp)
8111f344:	d9401217 	ldw	r5,72(sp)
8111f348:	a2000c04 	addi	r8,r20,48
8111f34c:	1021883a 	mov	r16,r2
8111f350:	1a000005 	stb	r8,0(r3)
8111f354:	800d883a 	mov	r6,r16
8111f358:	880f883a 	mov	r7,r17
8111f35c:	a809883a 	mov	r4,r21
8111f360:	4029883a 	mov	r20,r8
8111f364:	112b7980 	call	8112b798 <__gedf2>
8111f368:	00841d16 	blt	zero,r2,811203e0 <_dtoa_r+0x15fc>
8111f36c:	800d883a 	mov	r6,r16
8111f370:	880f883a 	mov	r7,r17
8111f374:	0009883a 	mov	r4,zero
8111f378:	014ffc34 	movhi	r5,16368
8111f37c:	112b9680 	call	8112b968 <__subdf3>
8111f380:	d9401217 	ldw	r5,72(sp)
8111f384:	100d883a 	mov	r6,r2
8111f388:	180f883a 	mov	r7,r3
8111f38c:	a809883a 	mov	r4,r21
8111f390:	112b7980 	call	8112b798 <__gedf2>
8111f394:	db001617 	ldw	r12,88(sp)
8111f398:	00840e16 	blt	zero,r2,811203d4 <_dtoa_r+0x15f0>
8111f39c:	00800044 	movi	r2,1
8111f3a0:	13006b0e 	bge	r2,r12,8111f550 <_dtoa_r+0x76c>
8111f3a4:	d9000717 	ldw	r4,28(sp)
8111f3a8:	dd800f15 	stw	r22,60(sp)
8111f3ac:	dcc01015 	stw	r19,64(sp)
8111f3b0:	2319883a 	add	r12,r4,r12
8111f3b4:	dcc01217 	ldw	r19,72(sp)
8111f3b8:	602d883a 	mov	r22,r12
8111f3bc:	dc801215 	stw	r18,72(sp)
8111f3c0:	b825883a 	mov	r18,r23
8111f3c4:	00000906 	br	8111f3ec <_dtoa_r+0x608>
8111f3c8:	112b9680 	call	8112b968 <__subdf3>
8111f3cc:	a80d883a 	mov	r6,r21
8111f3d0:	980f883a 	mov	r7,r19
8111f3d4:	1009883a 	mov	r4,r2
8111f3d8:	180b883a 	mov	r5,r3
8111f3dc:	112b8740 	call	8112b874 <__ledf2>
8111f3e0:	1003e816 	blt	r2,zero,81120384 <_dtoa_r+0x15a0>
8111f3e4:	b825883a 	mov	r18,r23
8111f3e8:	bd83e926 	beq	r23,r22,81120390 <_dtoa_r+0x15ac>
8111f3ec:	a809883a 	mov	r4,r21
8111f3f0:	980b883a 	mov	r5,r19
8111f3f4:	000d883a 	mov	r6,zero
8111f3f8:	01d00934 	movhi	r7,16420
8111f3fc:	111607c0 	call	8111607c <__muldf3>
8111f400:	000d883a 	mov	r6,zero
8111f404:	01d00934 	movhi	r7,16420
8111f408:	8009883a 	mov	r4,r16
8111f40c:	880b883a 	mov	r5,r17
8111f410:	102b883a 	mov	r21,r2
8111f414:	1827883a 	mov	r19,r3
8111f418:	111607c0 	call	8111607c <__muldf3>
8111f41c:	180b883a 	mov	r5,r3
8111f420:	1009883a 	mov	r4,r2
8111f424:	1821883a 	mov	r16,r3
8111f428:	1023883a 	mov	r17,r2
8111f42c:	112c26c0 	call	8112c26c <__fixdfsi>
8111f430:	1009883a 	mov	r4,r2
8111f434:	1029883a 	mov	r20,r2
8111f438:	112c2ec0 	call	8112c2ec <__floatsidf>
8111f43c:	8809883a 	mov	r4,r17
8111f440:	800b883a 	mov	r5,r16
8111f444:	100d883a 	mov	r6,r2
8111f448:	180f883a 	mov	r7,r3
8111f44c:	112b9680 	call	8112b968 <__subdf3>
8111f450:	a5000c04 	addi	r20,r20,48
8111f454:	a80d883a 	mov	r6,r21
8111f458:	980f883a 	mov	r7,r19
8111f45c:	1009883a 	mov	r4,r2
8111f460:	180b883a 	mov	r5,r3
8111f464:	95000005 	stb	r20,0(r18)
8111f468:	1021883a 	mov	r16,r2
8111f46c:	1823883a 	mov	r17,r3
8111f470:	112b8740 	call	8112b874 <__ledf2>
8111f474:	bdc00044 	addi	r23,r23,1
8111f478:	800d883a 	mov	r6,r16
8111f47c:	880f883a 	mov	r7,r17
8111f480:	0009883a 	mov	r4,zero
8111f484:	014ffc34 	movhi	r5,16368
8111f488:	103fcf0e 	bge	r2,zero,8111f3c8 <__reset+0xfb0ff3c8>
8111f48c:	d8c01317 	ldw	r3,76(sp)
8111f490:	d8c00515 	stw	r3,20(sp)
8111f494:	d9400917 	ldw	r5,36(sp)
8111f498:	e009883a 	mov	r4,fp
8111f49c:	1121fac0 	call	81121fac <_Bfree>
8111f4a0:	d9000517 	ldw	r4,20(sp)
8111f4a4:	d9802317 	ldw	r6,140(sp)
8111f4a8:	d9c02517 	ldw	r7,148(sp)
8111f4ac:	b8000005 	stb	zero,0(r23)
8111f4b0:	20800044 	addi	r2,r4,1
8111f4b4:	30800015 	stw	r2,0(r6)
8111f4b8:	3802aa26 	beq	r7,zero,8111ff64 <_dtoa_r+0x1180>
8111f4bc:	3dc00015 	stw	r23,0(r7)
8111f4c0:	d8800717 	ldw	r2,28(sp)
8111f4c4:	003e7906 	br	8111eeac <__reset+0xfb0feeac>
8111f4c8:	00800434 	movhi	r2,16
8111f4cc:	10bfffc4 	addi	r2,r2,-1
8111f4d0:	88a2703a 	and	r17,r17,r2
8111f4d4:	883e851e 	bne	r17,zero,8111eeec <__reset+0xfb0feeec>
8111f4d8:	00a04534 	movhi	r2,33044
8111f4dc:	10975504 	addi	r2,r2,23892
8111f4e0:	003e8406 	br	8111eef4 <__reset+0xfb0feef4>
8111f4e4:	10c00204 	addi	r3,r2,8
8111f4e8:	003e8706 	br	8111ef08 <__reset+0xfb0fef08>
8111f4ec:	01400434 	movhi	r5,16
8111f4f0:	297fffc4 	addi	r5,r5,-1
8111f4f4:	994a703a 	and	r5,r19,r5
8111f4f8:	9009883a 	mov	r4,r18
8111f4fc:	843f0044 	addi	r16,r16,-1023
8111f500:	294ffc34 	orhi	r5,r5,16368
8111f504:	dd800217 	ldw	r22,8(sp)
8111f508:	d8001115 	stw	zero,68(sp)
8111f50c:	003ea506 	br	8111efa4 <__reset+0xfb0fefa4>
8111f510:	00a04534 	movhi	r2,33044
8111f514:	10973a04 	addi	r2,r2,23784
8111f518:	003e6406 	br	8111eeac <__reset+0xfb0feeac>
8111f51c:	e0001115 	stw	zero,68(fp)
8111f520:	000b883a 	mov	r5,zero
8111f524:	e009883a 	mov	r4,fp
8111f528:	1121efc0 	call	81121efc <_Balloc>
8111f52c:	01bfffc4 	movi	r6,-1
8111f530:	01c00044 	movi	r7,1
8111f534:	d8800715 	stw	r2,28(sp)
8111f538:	d9800c15 	stw	r6,48(sp)
8111f53c:	e0801015 	stw	r2,64(fp)
8111f540:	d8000315 	stw	zero,12(sp)
8111f544:	d9c00b15 	stw	r7,44(sp)
8111f548:	d9800615 	stw	r6,24(sp)
8111f54c:	d8002215 	stw	zero,136(sp)
8111f550:	d8800117 	ldw	r2,4(sp)
8111f554:	10008916 	blt	r2,zero,8111f77c <_dtoa_r+0x998>
8111f558:	d9000517 	ldw	r4,20(sp)
8111f55c:	00c00384 	movi	r3,14
8111f560:	19008616 	blt	r3,r4,8111f77c <_dtoa_r+0x998>
8111f564:	200490fa 	slli	r2,r4,3
8111f568:	00e04534 	movhi	r3,33044
8111f56c:	d9802217 	ldw	r6,136(sp)
8111f570:	18d77304 	addi	r3,r3,24012
8111f574:	1885883a 	add	r2,r3,r2
8111f578:	14000017 	ldw	r16,0(r2)
8111f57c:	14400117 	ldw	r17,4(r2)
8111f580:	30016316 	blt	r6,zero,8111fb10 <_dtoa_r+0xd2c>
8111f584:	800d883a 	mov	r6,r16
8111f588:	880f883a 	mov	r7,r17
8111f58c:	9009883a 	mov	r4,r18
8111f590:	980b883a 	mov	r5,r19
8111f594:	112ae200 	call	8112ae20 <__divdf3>
8111f598:	180b883a 	mov	r5,r3
8111f59c:	1009883a 	mov	r4,r2
8111f5a0:	112c26c0 	call	8112c26c <__fixdfsi>
8111f5a4:	1009883a 	mov	r4,r2
8111f5a8:	102b883a 	mov	r21,r2
8111f5ac:	112c2ec0 	call	8112c2ec <__floatsidf>
8111f5b0:	800d883a 	mov	r6,r16
8111f5b4:	880f883a 	mov	r7,r17
8111f5b8:	1009883a 	mov	r4,r2
8111f5bc:	180b883a 	mov	r5,r3
8111f5c0:	111607c0 	call	8111607c <__muldf3>
8111f5c4:	100d883a 	mov	r6,r2
8111f5c8:	180f883a 	mov	r7,r3
8111f5cc:	9009883a 	mov	r4,r18
8111f5d0:	980b883a 	mov	r5,r19
8111f5d4:	112b9680 	call	8112b968 <__subdf3>
8111f5d8:	d9c00717 	ldw	r7,28(sp)
8111f5dc:	1009883a 	mov	r4,r2
8111f5e0:	a8800c04 	addi	r2,r21,48
8111f5e4:	38800005 	stb	r2,0(r7)
8111f5e8:	3dc00044 	addi	r23,r7,1
8111f5ec:	d9c00617 	ldw	r7,24(sp)
8111f5f0:	01800044 	movi	r6,1
8111f5f4:	180b883a 	mov	r5,r3
8111f5f8:	2005883a 	mov	r2,r4
8111f5fc:	39803826 	beq	r7,r6,8111f6e0 <_dtoa_r+0x8fc>
8111f600:	000d883a 	mov	r6,zero
8111f604:	01d00934 	movhi	r7,16420
8111f608:	111607c0 	call	8111607c <__muldf3>
8111f60c:	000d883a 	mov	r6,zero
8111f610:	000f883a 	mov	r7,zero
8111f614:	1009883a 	mov	r4,r2
8111f618:	180b883a 	mov	r5,r3
8111f61c:	1025883a 	mov	r18,r2
8111f620:	1827883a 	mov	r19,r3
8111f624:	112b7100 	call	8112b710 <__eqdf2>
8111f628:	103f9a26 	beq	r2,zero,8111f494 <__reset+0xfb0ff494>
8111f62c:	d9c00617 	ldw	r7,24(sp)
8111f630:	d8c00717 	ldw	r3,28(sp)
8111f634:	b829883a 	mov	r20,r23
8111f638:	38bfffc4 	addi	r2,r7,-1
8111f63c:	18ad883a 	add	r22,r3,r2
8111f640:	00000a06 	br	8111f66c <_dtoa_r+0x888>
8111f644:	111607c0 	call	8111607c <__muldf3>
8111f648:	000d883a 	mov	r6,zero
8111f64c:	000f883a 	mov	r7,zero
8111f650:	1009883a 	mov	r4,r2
8111f654:	180b883a 	mov	r5,r3
8111f658:	1025883a 	mov	r18,r2
8111f65c:	1827883a 	mov	r19,r3
8111f660:	b829883a 	mov	r20,r23
8111f664:	112b7100 	call	8112b710 <__eqdf2>
8111f668:	103f8a26 	beq	r2,zero,8111f494 <__reset+0xfb0ff494>
8111f66c:	800d883a 	mov	r6,r16
8111f670:	880f883a 	mov	r7,r17
8111f674:	9009883a 	mov	r4,r18
8111f678:	980b883a 	mov	r5,r19
8111f67c:	112ae200 	call	8112ae20 <__divdf3>
8111f680:	180b883a 	mov	r5,r3
8111f684:	1009883a 	mov	r4,r2
8111f688:	112c26c0 	call	8112c26c <__fixdfsi>
8111f68c:	1009883a 	mov	r4,r2
8111f690:	102b883a 	mov	r21,r2
8111f694:	112c2ec0 	call	8112c2ec <__floatsidf>
8111f698:	800d883a 	mov	r6,r16
8111f69c:	880f883a 	mov	r7,r17
8111f6a0:	1009883a 	mov	r4,r2
8111f6a4:	180b883a 	mov	r5,r3
8111f6a8:	111607c0 	call	8111607c <__muldf3>
8111f6ac:	100d883a 	mov	r6,r2
8111f6b0:	180f883a 	mov	r7,r3
8111f6b4:	9009883a 	mov	r4,r18
8111f6b8:	980b883a 	mov	r5,r19
8111f6bc:	112b9680 	call	8112b968 <__subdf3>
8111f6c0:	aa000c04 	addi	r8,r21,48
8111f6c4:	a2000005 	stb	r8,0(r20)
8111f6c8:	000d883a 	mov	r6,zero
8111f6cc:	01d00934 	movhi	r7,16420
8111f6d0:	1009883a 	mov	r4,r2
8111f6d4:	180b883a 	mov	r5,r3
8111f6d8:	a5c00044 	addi	r23,r20,1
8111f6dc:	b53fd91e 	bne	r22,r20,8111f644 <__reset+0xfb0ff644>
8111f6e0:	100d883a 	mov	r6,r2
8111f6e4:	180f883a 	mov	r7,r3
8111f6e8:	1009883a 	mov	r4,r2
8111f6ec:	180b883a 	mov	r5,r3
8111f6f0:	112a56c0 	call	8112a56c <__adddf3>
8111f6f4:	100d883a 	mov	r6,r2
8111f6f8:	180f883a 	mov	r7,r3
8111f6fc:	8009883a 	mov	r4,r16
8111f700:	880b883a 	mov	r5,r17
8111f704:	1027883a 	mov	r19,r2
8111f708:	1825883a 	mov	r18,r3
8111f70c:	112b8740 	call	8112b874 <__ledf2>
8111f710:	10000816 	blt	r2,zero,8111f734 <_dtoa_r+0x950>
8111f714:	980d883a 	mov	r6,r19
8111f718:	900f883a 	mov	r7,r18
8111f71c:	8009883a 	mov	r4,r16
8111f720:	880b883a 	mov	r5,r17
8111f724:	112b7100 	call	8112b710 <__eqdf2>
8111f728:	103f5a1e 	bne	r2,zero,8111f494 <__reset+0xfb0ff494>
8111f72c:	ad40004c 	andi	r21,r21,1
8111f730:	a83f5826 	beq	r21,zero,8111f494 <__reset+0xfb0ff494>
8111f734:	bd3fffc3 	ldbu	r20,-1(r23)
8111f738:	b8bfffc4 	addi	r2,r23,-1
8111f73c:	1007883a 	mov	r3,r2
8111f740:	01400e44 	movi	r5,57
8111f744:	d9800717 	ldw	r6,28(sp)
8111f748:	00000506 	br	8111f760 <_dtoa_r+0x97c>
8111f74c:	18ffffc4 	addi	r3,r3,-1
8111f750:	11824726 	beq	r2,r6,81120070 <_dtoa_r+0x128c>
8111f754:	1d000003 	ldbu	r20,0(r3)
8111f758:	102f883a 	mov	r23,r2
8111f75c:	10bfffc4 	addi	r2,r2,-1
8111f760:	a1003fcc 	andi	r4,r20,255
8111f764:	2100201c 	xori	r4,r4,128
8111f768:	213fe004 	addi	r4,r4,-128
8111f76c:	217ff726 	beq	r4,r5,8111f74c <__reset+0xfb0ff74c>
8111f770:	a2000044 	addi	r8,r20,1
8111f774:	12000005 	stb	r8,0(r2)
8111f778:	003f4606 	br	8111f494 <__reset+0xfb0ff494>
8111f77c:	d9000b17 	ldw	r4,44(sp)
8111f780:	2000c826 	beq	r4,zero,8111faa4 <_dtoa_r+0xcc0>
8111f784:	d9800317 	ldw	r6,12(sp)
8111f788:	00c00044 	movi	r3,1
8111f78c:	1980f90e 	bge	r3,r6,8111fb74 <_dtoa_r+0xd90>
8111f790:	d8800617 	ldw	r2,24(sp)
8111f794:	d8c00a17 	ldw	r3,40(sp)
8111f798:	157fffc4 	addi	r21,r2,-1
8111f79c:	1d41f316 	blt	r3,r21,8111ff6c <_dtoa_r+0x1188>
8111f7a0:	1d6bc83a 	sub	r21,r3,r21
8111f7a4:	d9c00617 	ldw	r7,24(sp)
8111f7a8:	3802aa16 	blt	r7,zero,81120254 <_dtoa_r+0x1470>
8111f7ac:	dd000817 	ldw	r20,32(sp)
8111f7b0:	d8800617 	ldw	r2,24(sp)
8111f7b4:	d8c00817 	ldw	r3,32(sp)
8111f7b8:	01400044 	movi	r5,1
8111f7bc:	e009883a 	mov	r4,fp
8111f7c0:	1887883a 	add	r3,r3,r2
8111f7c4:	d8c00815 	stw	r3,32(sp)
8111f7c8:	b0ad883a 	add	r22,r22,r2
8111f7cc:	11223200 	call	81122320 <__i2b>
8111f7d0:	1023883a 	mov	r17,r2
8111f7d4:	a0000826 	beq	r20,zero,8111f7f8 <_dtoa_r+0xa14>
8111f7d8:	0580070e 	bge	zero,r22,8111f7f8 <_dtoa_r+0xa14>
8111f7dc:	a005883a 	mov	r2,r20
8111f7e0:	b500b916 	blt	r22,r20,8111fac8 <_dtoa_r+0xce4>
8111f7e4:	d9000817 	ldw	r4,32(sp)
8111f7e8:	a0a9c83a 	sub	r20,r20,r2
8111f7ec:	b0adc83a 	sub	r22,r22,r2
8111f7f0:	2089c83a 	sub	r4,r4,r2
8111f7f4:	d9000815 	stw	r4,32(sp)
8111f7f8:	d9800a17 	ldw	r6,40(sp)
8111f7fc:	0181810e 	bge	zero,r6,8111fe04 <_dtoa_r+0x1020>
8111f800:	d9c00b17 	ldw	r7,44(sp)
8111f804:	3800b326 	beq	r7,zero,8111fad4 <_dtoa_r+0xcf0>
8111f808:	a800b226 	beq	r21,zero,8111fad4 <_dtoa_r+0xcf0>
8111f80c:	880b883a 	mov	r5,r17
8111f810:	a80d883a 	mov	r6,r21
8111f814:	e009883a 	mov	r4,fp
8111f818:	11225640 	call	81122564 <__pow5mult>
8111f81c:	d9800917 	ldw	r6,36(sp)
8111f820:	100b883a 	mov	r5,r2
8111f824:	e009883a 	mov	r4,fp
8111f828:	1023883a 	mov	r17,r2
8111f82c:	11223640 	call	81122364 <__multiply>
8111f830:	1021883a 	mov	r16,r2
8111f834:	d8800a17 	ldw	r2,40(sp)
8111f838:	d9400917 	ldw	r5,36(sp)
8111f83c:	e009883a 	mov	r4,fp
8111f840:	1545c83a 	sub	r2,r2,r21
8111f844:	d8800a15 	stw	r2,40(sp)
8111f848:	1121fac0 	call	81121fac <_Bfree>
8111f84c:	d8c00a17 	ldw	r3,40(sp)
8111f850:	18009f1e 	bne	r3,zero,8111fad0 <_dtoa_r+0xcec>
8111f854:	05c00044 	movi	r23,1
8111f858:	e009883a 	mov	r4,fp
8111f85c:	b80b883a 	mov	r5,r23
8111f860:	11223200 	call	81122320 <__i2b>
8111f864:	d9000d17 	ldw	r4,52(sp)
8111f868:	102b883a 	mov	r21,r2
8111f86c:	2000ce26 	beq	r4,zero,8111fba8 <_dtoa_r+0xdc4>
8111f870:	200d883a 	mov	r6,r4
8111f874:	100b883a 	mov	r5,r2
8111f878:	e009883a 	mov	r4,fp
8111f87c:	11225640 	call	81122564 <__pow5mult>
8111f880:	d9800317 	ldw	r6,12(sp)
8111f884:	102b883a 	mov	r21,r2
8111f888:	b981810e 	bge	r23,r6,8111fe90 <_dtoa_r+0x10ac>
8111f88c:	0027883a 	mov	r19,zero
8111f890:	a8800417 	ldw	r2,16(r21)
8111f894:	05c00804 	movi	r23,32
8111f898:	10800104 	addi	r2,r2,4
8111f89c:	1085883a 	add	r2,r2,r2
8111f8a0:	1085883a 	add	r2,r2,r2
8111f8a4:	a885883a 	add	r2,r21,r2
8111f8a8:	11000017 	ldw	r4,0(r2)
8111f8ac:	11222080 	call	81122208 <__hi0bits>
8111f8b0:	b885c83a 	sub	r2,r23,r2
8111f8b4:	1585883a 	add	r2,r2,r22
8111f8b8:	108007cc 	andi	r2,r2,31
8111f8bc:	1000b326 	beq	r2,zero,8111fb8c <_dtoa_r+0xda8>
8111f8c0:	00c00804 	movi	r3,32
8111f8c4:	1887c83a 	sub	r3,r3,r2
8111f8c8:	01000104 	movi	r4,4
8111f8cc:	20c2cd0e 	bge	r4,r3,81120404 <_dtoa_r+0x1620>
8111f8d0:	00c00704 	movi	r3,28
8111f8d4:	1885c83a 	sub	r2,r3,r2
8111f8d8:	d8c00817 	ldw	r3,32(sp)
8111f8dc:	a0a9883a 	add	r20,r20,r2
8111f8e0:	b0ad883a 	add	r22,r22,r2
8111f8e4:	1887883a 	add	r3,r3,r2
8111f8e8:	d8c00815 	stw	r3,32(sp)
8111f8ec:	d9800817 	ldw	r6,32(sp)
8111f8f0:	0180040e 	bge	zero,r6,8111f904 <_dtoa_r+0xb20>
8111f8f4:	800b883a 	mov	r5,r16
8111f8f8:	e009883a 	mov	r4,fp
8111f8fc:	11226ac0 	call	811226ac <__lshift>
8111f900:	1021883a 	mov	r16,r2
8111f904:	0580050e 	bge	zero,r22,8111f91c <_dtoa_r+0xb38>
8111f908:	a80b883a 	mov	r5,r21
8111f90c:	b00d883a 	mov	r6,r22
8111f910:	e009883a 	mov	r4,fp
8111f914:	11226ac0 	call	811226ac <__lshift>
8111f918:	102b883a 	mov	r21,r2
8111f91c:	d9c00e17 	ldw	r7,56(sp)
8111f920:	3801211e 	bne	r7,zero,8111fda8 <_dtoa_r+0xfc4>
8111f924:	d9800617 	ldw	r6,24(sp)
8111f928:	0181380e 	bge	zero,r6,8111fe0c <_dtoa_r+0x1028>
8111f92c:	d8c00b17 	ldw	r3,44(sp)
8111f930:	1800ab1e 	bne	r3,zero,8111fbe0 <_dtoa_r+0xdfc>
8111f934:	dc800717 	ldw	r18,28(sp)
8111f938:	dcc00617 	ldw	r19,24(sp)
8111f93c:	9029883a 	mov	r20,r18
8111f940:	00000206 	br	8111f94c <_dtoa_r+0xb68>
8111f944:	1121fd40 	call	81121fd4 <__multadd>
8111f948:	1021883a 	mov	r16,r2
8111f94c:	a80b883a 	mov	r5,r21
8111f950:	8009883a 	mov	r4,r16
8111f954:	111ebdc0 	call	8111ebdc <quorem>
8111f958:	10800c04 	addi	r2,r2,48
8111f95c:	90800005 	stb	r2,0(r18)
8111f960:	94800044 	addi	r18,r18,1
8111f964:	9507c83a 	sub	r3,r18,r20
8111f968:	000f883a 	mov	r7,zero
8111f96c:	01800284 	movi	r6,10
8111f970:	800b883a 	mov	r5,r16
8111f974:	e009883a 	mov	r4,fp
8111f978:	1cfff216 	blt	r3,r19,8111f944 <__reset+0xfb0ff944>
8111f97c:	1011883a 	mov	r8,r2
8111f980:	d8800617 	ldw	r2,24(sp)
8111f984:	0082370e 	bge	zero,r2,81120264 <_dtoa_r+0x1480>
8111f988:	d9000717 	ldw	r4,28(sp)
8111f98c:	0025883a 	mov	r18,zero
8111f990:	20af883a 	add	r23,r4,r2
8111f994:	01800044 	movi	r6,1
8111f998:	800b883a 	mov	r5,r16
8111f99c:	e009883a 	mov	r4,fp
8111f9a0:	da001715 	stw	r8,92(sp)
8111f9a4:	11226ac0 	call	811226ac <__lshift>
8111f9a8:	a80b883a 	mov	r5,r21
8111f9ac:	1009883a 	mov	r4,r2
8111f9b0:	d8800915 	stw	r2,36(sp)
8111f9b4:	11227fc0 	call	811227fc <__mcmp>
8111f9b8:	da001717 	ldw	r8,92(sp)
8111f9bc:	0081800e 	bge	zero,r2,8111ffc0 <_dtoa_r+0x11dc>
8111f9c0:	b93fffc3 	ldbu	r4,-1(r23)
8111f9c4:	b8bfffc4 	addi	r2,r23,-1
8111f9c8:	1007883a 	mov	r3,r2
8111f9cc:	01800e44 	movi	r6,57
8111f9d0:	d9c00717 	ldw	r7,28(sp)
8111f9d4:	00000506 	br	8111f9ec <_dtoa_r+0xc08>
8111f9d8:	18ffffc4 	addi	r3,r3,-1
8111f9dc:	11c12326 	beq	r2,r7,8111fe6c <_dtoa_r+0x1088>
8111f9e0:	19000003 	ldbu	r4,0(r3)
8111f9e4:	102f883a 	mov	r23,r2
8111f9e8:	10bfffc4 	addi	r2,r2,-1
8111f9ec:	21403fcc 	andi	r5,r4,255
8111f9f0:	2940201c 	xori	r5,r5,128
8111f9f4:	297fe004 	addi	r5,r5,-128
8111f9f8:	29bff726 	beq	r5,r6,8111f9d8 <__reset+0xfb0ff9d8>
8111f9fc:	21000044 	addi	r4,r4,1
8111fa00:	11000005 	stb	r4,0(r2)
8111fa04:	a80b883a 	mov	r5,r21
8111fa08:	e009883a 	mov	r4,fp
8111fa0c:	1121fac0 	call	81121fac <_Bfree>
8111fa10:	883ea026 	beq	r17,zero,8111f494 <__reset+0xfb0ff494>
8111fa14:	90000426 	beq	r18,zero,8111fa28 <_dtoa_r+0xc44>
8111fa18:	94400326 	beq	r18,r17,8111fa28 <_dtoa_r+0xc44>
8111fa1c:	900b883a 	mov	r5,r18
8111fa20:	e009883a 	mov	r4,fp
8111fa24:	1121fac0 	call	81121fac <_Bfree>
8111fa28:	880b883a 	mov	r5,r17
8111fa2c:	e009883a 	mov	r4,fp
8111fa30:	1121fac0 	call	81121fac <_Bfree>
8111fa34:	003e9706 	br	8111f494 <__reset+0xfb0ff494>
8111fa38:	01800044 	movi	r6,1
8111fa3c:	d9800e15 	stw	r6,56(sp)
8111fa40:	003d9606 	br	8111f09c <__reset+0xfb0ff09c>
8111fa44:	d8800817 	ldw	r2,32(sp)
8111fa48:	d8c00517 	ldw	r3,20(sp)
8111fa4c:	d8000d15 	stw	zero,52(sp)
8111fa50:	10c5c83a 	sub	r2,r2,r3
8111fa54:	00c9c83a 	sub	r4,zero,r3
8111fa58:	d8800815 	stw	r2,32(sp)
8111fa5c:	d9000a15 	stw	r4,40(sp)
8111fa60:	003d9706 	br	8111f0c0 <__reset+0xfb0ff0c0>
8111fa64:	05adc83a 	sub	r22,zero,r22
8111fa68:	dd800815 	stw	r22,32(sp)
8111fa6c:	002d883a 	mov	r22,zero
8111fa70:	003d8e06 	br	8111f0ac <__reset+0xfb0ff0ac>
8111fa74:	d9000517 	ldw	r4,20(sp)
8111fa78:	112c2ec0 	call	8112c2ec <__floatsidf>
8111fa7c:	100d883a 	mov	r6,r2
8111fa80:	180f883a 	mov	r7,r3
8111fa84:	a009883a 	mov	r4,r20
8111fa88:	880b883a 	mov	r5,r17
8111fa8c:	112b7100 	call	8112b710 <__eqdf2>
8111fa90:	103d7126 	beq	r2,zero,8111f058 <__reset+0xfb0ff058>
8111fa94:	d9c00517 	ldw	r7,20(sp)
8111fa98:	39ffffc4 	addi	r7,r7,-1
8111fa9c:	d9c00515 	stw	r7,20(sp)
8111faa0:	003d6d06 	br	8111f058 <__reset+0xfb0ff058>
8111faa4:	dd400a17 	ldw	r21,40(sp)
8111faa8:	dd000817 	ldw	r20,32(sp)
8111faac:	0023883a 	mov	r17,zero
8111fab0:	003f4806 	br	8111f7d4 <__reset+0xfb0ff7d4>
8111fab4:	10e3c83a 	sub	r17,r2,r3
8111fab8:	9448983a 	sll	r4,r18,r17
8111fabc:	003d3206 	br	8111ef88 <__reset+0xfb0fef88>
8111fac0:	d8000e15 	stw	zero,56(sp)
8111fac4:	003d7506 	br	8111f09c <__reset+0xfb0ff09c>
8111fac8:	b005883a 	mov	r2,r22
8111facc:	003f4506 	br	8111f7e4 <__reset+0xfb0ff7e4>
8111fad0:	dc000915 	stw	r16,36(sp)
8111fad4:	d9800a17 	ldw	r6,40(sp)
8111fad8:	d9400917 	ldw	r5,36(sp)
8111fadc:	e009883a 	mov	r4,fp
8111fae0:	11225640 	call	81122564 <__pow5mult>
8111fae4:	1021883a 	mov	r16,r2
8111fae8:	003f5a06 	br	8111f854 <__reset+0xfb0ff854>
8111faec:	01c00044 	movi	r7,1
8111faf0:	d9c00b15 	stw	r7,44(sp)
8111faf4:	d8802217 	ldw	r2,136(sp)
8111faf8:	0081280e 	bge	zero,r2,8111ff9c <_dtoa_r+0x11b8>
8111fafc:	100d883a 	mov	r6,r2
8111fb00:	1021883a 	mov	r16,r2
8111fb04:	d8800c15 	stw	r2,48(sp)
8111fb08:	d8800615 	stw	r2,24(sp)
8111fb0c:	003d8806 	br	8111f130 <__reset+0xfb0ff130>
8111fb10:	d8800617 	ldw	r2,24(sp)
8111fb14:	00be9b16 	blt	zero,r2,8111f584 <__reset+0xfb0ff584>
8111fb18:	10010f1e 	bne	r2,zero,8111ff58 <_dtoa_r+0x1174>
8111fb1c:	880b883a 	mov	r5,r17
8111fb20:	000d883a 	mov	r6,zero
8111fb24:	01d00534 	movhi	r7,16404
8111fb28:	8009883a 	mov	r4,r16
8111fb2c:	111607c0 	call	8111607c <__muldf3>
8111fb30:	900d883a 	mov	r6,r18
8111fb34:	980f883a 	mov	r7,r19
8111fb38:	1009883a 	mov	r4,r2
8111fb3c:	180b883a 	mov	r5,r3
8111fb40:	112b7980 	call	8112b798 <__gedf2>
8111fb44:	002b883a 	mov	r21,zero
8111fb48:	0023883a 	mov	r17,zero
8111fb4c:	1000bf16 	blt	r2,zero,8111fe4c <_dtoa_r+0x1068>
8111fb50:	d9802217 	ldw	r6,136(sp)
8111fb54:	ddc00717 	ldw	r23,28(sp)
8111fb58:	018c303a 	nor	r6,zero,r6
8111fb5c:	d9800515 	stw	r6,20(sp)
8111fb60:	a80b883a 	mov	r5,r21
8111fb64:	e009883a 	mov	r4,fp
8111fb68:	1121fac0 	call	81121fac <_Bfree>
8111fb6c:	883e4926 	beq	r17,zero,8111f494 <__reset+0xfb0ff494>
8111fb70:	003fad06 	br	8111fa28 <__reset+0xfb0ffa28>
8111fb74:	d9c01117 	ldw	r7,68(sp)
8111fb78:	3801bc26 	beq	r7,zero,8112026c <_dtoa_r+0x1488>
8111fb7c:	10810cc4 	addi	r2,r2,1075
8111fb80:	dd400a17 	ldw	r21,40(sp)
8111fb84:	dd000817 	ldw	r20,32(sp)
8111fb88:	003f0a06 	br	8111f7b4 <__reset+0xfb0ff7b4>
8111fb8c:	00800704 	movi	r2,28
8111fb90:	d9000817 	ldw	r4,32(sp)
8111fb94:	a0a9883a 	add	r20,r20,r2
8111fb98:	b0ad883a 	add	r22,r22,r2
8111fb9c:	2089883a 	add	r4,r4,r2
8111fba0:	d9000815 	stw	r4,32(sp)
8111fba4:	003f5106 	br	8111f8ec <__reset+0xfb0ff8ec>
8111fba8:	d8c00317 	ldw	r3,12(sp)
8111fbac:	b8c1fc0e 	bge	r23,r3,811203a0 <_dtoa_r+0x15bc>
8111fbb0:	0027883a 	mov	r19,zero
8111fbb4:	b805883a 	mov	r2,r23
8111fbb8:	003f3e06 	br	8111f8b4 <__reset+0xfb0ff8b4>
8111fbbc:	880b883a 	mov	r5,r17
8111fbc0:	e009883a 	mov	r4,fp
8111fbc4:	000f883a 	mov	r7,zero
8111fbc8:	01800284 	movi	r6,10
8111fbcc:	1121fd40 	call	81121fd4 <__multadd>
8111fbd0:	d9000c17 	ldw	r4,48(sp)
8111fbd4:	1023883a 	mov	r17,r2
8111fbd8:	0102040e 	bge	zero,r4,811203ec <_dtoa_r+0x1608>
8111fbdc:	d9000615 	stw	r4,24(sp)
8111fbe0:	0500050e 	bge	zero,r20,8111fbf8 <_dtoa_r+0xe14>
8111fbe4:	880b883a 	mov	r5,r17
8111fbe8:	a00d883a 	mov	r6,r20
8111fbec:	e009883a 	mov	r4,fp
8111fbf0:	11226ac0 	call	811226ac <__lshift>
8111fbf4:	1023883a 	mov	r17,r2
8111fbf8:	9801241e 	bne	r19,zero,8112008c <_dtoa_r+0x12a8>
8111fbfc:	8829883a 	mov	r20,r17
8111fc00:	d9000617 	ldw	r4,24(sp)
8111fc04:	dcc00717 	ldw	r19,28(sp)
8111fc08:	9480004c 	andi	r18,r18,1
8111fc0c:	20bfffc4 	addi	r2,r4,-1
8111fc10:	9885883a 	add	r2,r19,r2
8111fc14:	d8800415 	stw	r2,16(sp)
8111fc18:	dc800615 	stw	r18,24(sp)
8111fc1c:	a80b883a 	mov	r5,r21
8111fc20:	8009883a 	mov	r4,r16
8111fc24:	111ebdc0 	call	8111ebdc <quorem>
8111fc28:	880b883a 	mov	r5,r17
8111fc2c:	8009883a 	mov	r4,r16
8111fc30:	102f883a 	mov	r23,r2
8111fc34:	11227fc0 	call	811227fc <__mcmp>
8111fc38:	a80b883a 	mov	r5,r21
8111fc3c:	a00d883a 	mov	r6,r20
8111fc40:	e009883a 	mov	r4,fp
8111fc44:	102d883a 	mov	r22,r2
8111fc48:	112285c0 	call	8112285c <__mdiff>
8111fc4c:	1007883a 	mov	r3,r2
8111fc50:	10800317 	ldw	r2,12(r2)
8111fc54:	bc800c04 	addi	r18,r23,48
8111fc58:	180b883a 	mov	r5,r3
8111fc5c:	10004e1e 	bne	r2,zero,8111fd98 <_dtoa_r+0xfb4>
8111fc60:	8009883a 	mov	r4,r16
8111fc64:	d8c01615 	stw	r3,88(sp)
8111fc68:	11227fc0 	call	811227fc <__mcmp>
8111fc6c:	d8c01617 	ldw	r3,88(sp)
8111fc70:	e009883a 	mov	r4,fp
8111fc74:	d8801615 	stw	r2,88(sp)
8111fc78:	180b883a 	mov	r5,r3
8111fc7c:	1121fac0 	call	81121fac <_Bfree>
8111fc80:	d8801617 	ldw	r2,88(sp)
8111fc84:	1000041e 	bne	r2,zero,8111fc98 <_dtoa_r+0xeb4>
8111fc88:	d9800317 	ldw	r6,12(sp)
8111fc8c:	3000021e 	bne	r6,zero,8111fc98 <_dtoa_r+0xeb4>
8111fc90:	d8c00617 	ldw	r3,24(sp)
8111fc94:	18003726 	beq	r3,zero,8111fd74 <_dtoa_r+0xf90>
8111fc98:	b0002016 	blt	r22,zero,8111fd1c <_dtoa_r+0xf38>
8111fc9c:	b000041e 	bne	r22,zero,8111fcb0 <_dtoa_r+0xecc>
8111fca0:	d9000317 	ldw	r4,12(sp)
8111fca4:	2000021e 	bne	r4,zero,8111fcb0 <_dtoa_r+0xecc>
8111fca8:	d8c00617 	ldw	r3,24(sp)
8111fcac:	18001b26 	beq	r3,zero,8111fd1c <_dtoa_r+0xf38>
8111fcb0:	00810716 	blt	zero,r2,811200d0 <_dtoa_r+0x12ec>
8111fcb4:	d8c00417 	ldw	r3,16(sp)
8111fcb8:	9d800044 	addi	r22,r19,1
8111fcbc:	9c800005 	stb	r18,0(r19)
8111fcc0:	b02f883a 	mov	r23,r22
8111fcc4:	98c10626 	beq	r19,r3,811200e0 <_dtoa_r+0x12fc>
8111fcc8:	800b883a 	mov	r5,r16
8111fccc:	000f883a 	mov	r7,zero
8111fcd0:	01800284 	movi	r6,10
8111fcd4:	e009883a 	mov	r4,fp
8111fcd8:	1121fd40 	call	81121fd4 <__multadd>
8111fcdc:	1021883a 	mov	r16,r2
8111fce0:	000f883a 	mov	r7,zero
8111fce4:	01800284 	movi	r6,10
8111fce8:	880b883a 	mov	r5,r17
8111fcec:	e009883a 	mov	r4,fp
8111fcf0:	8d002526 	beq	r17,r20,8111fd88 <_dtoa_r+0xfa4>
8111fcf4:	1121fd40 	call	81121fd4 <__multadd>
8111fcf8:	a00b883a 	mov	r5,r20
8111fcfc:	000f883a 	mov	r7,zero
8111fd00:	01800284 	movi	r6,10
8111fd04:	e009883a 	mov	r4,fp
8111fd08:	1023883a 	mov	r17,r2
8111fd0c:	1121fd40 	call	81121fd4 <__multadd>
8111fd10:	1029883a 	mov	r20,r2
8111fd14:	b027883a 	mov	r19,r22
8111fd18:	003fc006 	br	8111fc1c <__reset+0xfb0ffc1c>
8111fd1c:	9011883a 	mov	r8,r18
8111fd20:	00800e0e 	bge	zero,r2,8111fd5c <_dtoa_r+0xf78>
8111fd24:	800b883a 	mov	r5,r16
8111fd28:	01800044 	movi	r6,1
8111fd2c:	e009883a 	mov	r4,fp
8111fd30:	da001715 	stw	r8,92(sp)
8111fd34:	11226ac0 	call	811226ac <__lshift>
8111fd38:	a80b883a 	mov	r5,r21
8111fd3c:	1009883a 	mov	r4,r2
8111fd40:	1021883a 	mov	r16,r2
8111fd44:	11227fc0 	call	811227fc <__mcmp>
8111fd48:	da001717 	ldw	r8,92(sp)
8111fd4c:	0081960e 	bge	zero,r2,811203a8 <_dtoa_r+0x15c4>
8111fd50:	00800e44 	movi	r2,57
8111fd54:	40817026 	beq	r8,r2,81120318 <_dtoa_r+0x1534>
8111fd58:	ba000c44 	addi	r8,r23,49
8111fd5c:	8825883a 	mov	r18,r17
8111fd60:	9dc00044 	addi	r23,r19,1
8111fd64:	9a000005 	stb	r8,0(r19)
8111fd68:	a023883a 	mov	r17,r20
8111fd6c:	dc000915 	stw	r16,36(sp)
8111fd70:	003f2406 	br	8111fa04 <__reset+0xfb0ffa04>
8111fd74:	00800e44 	movi	r2,57
8111fd78:	9011883a 	mov	r8,r18
8111fd7c:	90816626 	beq	r18,r2,81120318 <_dtoa_r+0x1534>
8111fd80:	05bff516 	blt	zero,r22,8111fd58 <__reset+0xfb0ffd58>
8111fd84:	003ff506 	br	8111fd5c <__reset+0xfb0ffd5c>
8111fd88:	1121fd40 	call	81121fd4 <__multadd>
8111fd8c:	1023883a 	mov	r17,r2
8111fd90:	1029883a 	mov	r20,r2
8111fd94:	003fdf06 	br	8111fd14 <__reset+0xfb0ffd14>
8111fd98:	e009883a 	mov	r4,fp
8111fd9c:	1121fac0 	call	81121fac <_Bfree>
8111fda0:	00800044 	movi	r2,1
8111fda4:	003fbc06 	br	8111fc98 <__reset+0xfb0ffc98>
8111fda8:	a80b883a 	mov	r5,r21
8111fdac:	8009883a 	mov	r4,r16
8111fdb0:	11227fc0 	call	811227fc <__mcmp>
8111fdb4:	103edb0e 	bge	r2,zero,8111f924 <__reset+0xfb0ff924>
8111fdb8:	800b883a 	mov	r5,r16
8111fdbc:	000f883a 	mov	r7,zero
8111fdc0:	01800284 	movi	r6,10
8111fdc4:	e009883a 	mov	r4,fp
8111fdc8:	1121fd40 	call	81121fd4 <__multadd>
8111fdcc:	1021883a 	mov	r16,r2
8111fdd0:	d8800517 	ldw	r2,20(sp)
8111fdd4:	d8c00b17 	ldw	r3,44(sp)
8111fdd8:	10bfffc4 	addi	r2,r2,-1
8111fddc:	d8800515 	stw	r2,20(sp)
8111fde0:	183f761e 	bne	r3,zero,8111fbbc <__reset+0xfb0ffbbc>
8111fde4:	d9000c17 	ldw	r4,48(sp)
8111fde8:	0101730e 	bge	zero,r4,811203b8 <_dtoa_r+0x15d4>
8111fdec:	d9000615 	stw	r4,24(sp)
8111fdf0:	003ed006 	br	8111f934 <__reset+0xfb0ff934>
8111fdf4:	00800084 	movi	r2,2
8111fdf8:	3081861e 	bne	r6,r2,81120414 <_dtoa_r+0x1630>
8111fdfc:	d8000b15 	stw	zero,44(sp)
8111fe00:	003f3c06 	br	8111faf4 <__reset+0xfb0ffaf4>
8111fe04:	dc000917 	ldw	r16,36(sp)
8111fe08:	003e9206 	br	8111f854 <__reset+0xfb0ff854>
8111fe0c:	d9c00317 	ldw	r7,12(sp)
8111fe10:	00800084 	movi	r2,2
8111fe14:	11fec50e 	bge	r2,r7,8111f92c <__reset+0xfb0ff92c>
8111fe18:	d9000617 	ldw	r4,24(sp)
8111fe1c:	20013c1e 	bne	r4,zero,81120310 <_dtoa_r+0x152c>
8111fe20:	a80b883a 	mov	r5,r21
8111fe24:	000f883a 	mov	r7,zero
8111fe28:	01800144 	movi	r6,5
8111fe2c:	e009883a 	mov	r4,fp
8111fe30:	1121fd40 	call	81121fd4 <__multadd>
8111fe34:	100b883a 	mov	r5,r2
8111fe38:	8009883a 	mov	r4,r16
8111fe3c:	102b883a 	mov	r21,r2
8111fe40:	11227fc0 	call	811227fc <__mcmp>
8111fe44:	dc000915 	stw	r16,36(sp)
8111fe48:	00bf410e 	bge	zero,r2,8111fb50 <__reset+0xfb0ffb50>
8111fe4c:	d9c00717 	ldw	r7,28(sp)
8111fe50:	00800c44 	movi	r2,49
8111fe54:	38800005 	stb	r2,0(r7)
8111fe58:	d8800517 	ldw	r2,20(sp)
8111fe5c:	3dc00044 	addi	r23,r7,1
8111fe60:	10800044 	addi	r2,r2,1
8111fe64:	d8800515 	stw	r2,20(sp)
8111fe68:	003f3d06 	br	8111fb60 <__reset+0xfb0ffb60>
8111fe6c:	d9800517 	ldw	r6,20(sp)
8111fe70:	d9c00717 	ldw	r7,28(sp)
8111fe74:	00800c44 	movi	r2,49
8111fe78:	31800044 	addi	r6,r6,1
8111fe7c:	d9800515 	stw	r6,20(sp)
8111fe80:	38800005 	stb	r2,0(r7)
8111fe84:	003edf06 	br	8111fa04 <__reset+0xfb0ffa04>
8111fe88:	d8000b15 	stw	zero,44(sp)
8111fe8c:	003c9f06 	br	8111f10c <__reset+0xfb0ff10c>
8111fe90:	903e7e1e 	bne	r18,zero,8111f88c <__reset+0xfb0ff88c>
8111fe94:	00800434 	movhi	r2,16
8111fe98:	10bfffc4 	addi	r2,r2,-1
8111fe9c:	9884703a 	and	r2,r19,r2
8111fea0:	1000ea1e 	bne	r2,zero,8112024c <_dtoa_r+0x1468>
8111fea4:	9cdffc2c 	andhi	r19,r19,32752
8111fea8:	9800e826 	beq	r19,zero,8112024c <_dtoa_r+0x1468>
8111feac:	d9c00817 	ldw	r7,32(sp)
8111feb0:	b5800044 	addi	r22,r22,1
8111feb4:	04c00044 	movi	r19,1
8111feb8:	39c00044 	addi	r7,r7,1
8111febc:	d9c00815 	stw	r7,32(sp)
8111fec0:	d8800d17 	ldw	r2,52(sp)
8111fec4:	103e721e 	bne	r2,zero,8111f890 <__reset+0xfb0ff890>
8111fec8:	00800044 	movi	r2,1
8111fecc:	003e7906 	br	8111f8b4 <__reset+0xfb0ff8b4>
8111fed0:	8009883a 	mov	r4,r16
8111fed4:	112c2ec0 	call	8112c2ec <__floatsidf>
8111fed8:	d9800f17 	ldw	r6,60(sp)
8111fedc:	d9c01017 	ldw	r7,64(sp)
8111fee0:	1009883a 	mov	r4,r2
8111fee4:	180b883a 	mov	r5,r3
8111fee8:	111607c0 	call	8111607c <__muldf3>
8111feec:	000d883a 	mov	r6,zero
8111fef0:	01d00734 	movhi	r7,16412
8111fef4:	1009883a 	mov	r4,r2
8111fef8:	180b883a 	mov	r5,r3
8111fefc:	112a56c0 	call	8112a56c <__adddf3>
8111ff00:	047f3034 	movhi	r17,64704
8111ff04:	1021883a 	mov	r16,r2
8111ff08:	1c63883a 	add	r17,r3,r17
8111ff0c:	d9000f17 	ldw	r4,60(sp)
8111ff10:	d9401017 	ldw	r5,64(sp)
8111ff14:	000d883a 	mov	r6,zero
8111ff18:	01d00534 	movhi	r7,16404
8111ff1c:	112b9680 	call	8112b968 <__subdf3>
8111ff20:	800d883a 	mov	r6,r16
8111ff24:	880f883a 	mov	r7,r17
8111ff28:	1009883a 	mov	r4,r2
8111ff2c:	180b883a 	mov	r5,r3
8111ff30:	102b883a 	mov	r21,r2
8111ff34:	1829883a 	mov	r20,r3
8111ff38:	112b7980 	call	8112b798 <__gedf2>
8111ff3c:	00806c16 	blt	zero,r2,811200f0 <_dtoa_r+0x130c>
8111ff40:	89e0003c 	xorhi	r7,r17,32768
8111ff44:	800d883a 	mov	r6,r16
8111ff48:	a809883a 	mov	r4,r21
8111ff4c:	a00b883a 	mov	r5,r20
8111ff50:	112b8740 	call	8112b874 <__ledf2>
8111ff54:	103d7e0e 	bge	r2,zero,8111f550 <__reset+0xfb0ff550>
8111ff58:	002b883a 	mov	r21,zero
8111ff5c:	0023883a 	mov	r17,zero
8111ff60:	003efb06 	br	8111fb50 <__reset+0xfb0ffb50>
8111ff64:	d8800717 	ldw	r2,28(sp)
8111ff68:	003bd006 	br	8111eeac <__reset+0xfb0feeac>
8111ff6c:	d9000a17 	ldw	r4,40(sp)
8111ff70:	d9800d17 	ldw	r6,52(sp)
8111ff74:	dd400a15 	stw	r21,40(sp)
8111ff78:	a905c83a 	sub	r2,r21,r4
8111ff7c:	308d883a 	add	r6,r6,r2
8111ff80:	d9800d15 	stw	r6,52(sp)
8111ff84:	002b883a 	mov	r21,zero
8111ff88:	003e0606 	br	8111f7a4 <__reset+0xfb0ff7a4>
8111ff8c:	9023883a 	mov	r17,r18
8111ff90:	9829883a 	mov	r20,r19
8111ff94:	04000084 	movi	r16,2
8111ff98:	003c9206 	br	8111f1e4 <__reset+0xfb0ff1e4>
8111ff9c:	04000044 	movi	r16,1
8111ffa0:	dc000c15 	stw	r16,48(sp)
8111ffa4:	dc000615 	stw	r16,24(sp)
8111ffa8:	dc002215 	stw	r16,136(sp)
8111ffac:	e0001115 	stw	zero,68(fp)
8111ffb0:	000b883a 	mov	r5,zero
8111ffb4:	003c6906 	br	8111f15c <__reset+0xfb0ff15c>
8111ffb8:	3021883a 	mov	r16,r6
8111ffbc:	003ffb06 	br	8111ffac <__reset+0xfb0fffac>
8111ffc0:	1000021e 	bne	r2,zero,8111ffcc <_dtoa_r+0x11e8>
8111ffc4:	4200004c 	andi	r8,r8,1
8111ffc8:	403e7d1e 	bne	r8,zero,8111f9c0 <__reset+0xfb0ff9c0>
8111ffcc:	01000c04 	movi	r4,48
8111ffd0:	00000106 	br	8111ffd8 <_dtoa_r+0x11f4>
8111ffd4:	102f883a 	mov	r23,r2
8111ffd8:	b8bfffc4 	addi	r2,r23,-1
8111ffdc:	10c00007 	ldb	r3,0(r2)
8111ffe0:	193ffc26 	beq	r3,r4,8111ffd4 <__reset+0xfb0fffd4>
8111ffe4:	003e8706 	br	8111fa04 <__reset+0xfb0ffa04>
8111ffe8:	d8800517 	ldw	r2,20(sp)
8111ffec:	00a3c83a 	sub	r17,zero,r2
8111fff0:	8800a426 	beq	r17,zero,81120284 <_dtoa_r+0x14a0>
8111fff4:	888003cc 	andi	r2,r17,15
8111fff8:	100490fa 	slli	r2,r2,3
8111fffc:	00e04534 	movhi	r3,33044
81120000:	18d77304 	addi	r3,r3,24012
81120004:	1885883a 	add	r2,r3,r2
81120008:	11800017 	ldw	r6,0(r2)
8112000c:	11c00117 	ldw	r7,4(r2)
81120010:	9009883a 	mov	r4,r18
81120014:	980b883a 	mov	r5,r19
81120018:	8823d13a 	srai	r17,r17,4
8112001c:	111607c0 	call	8111607c <__muldf3>
81120020:	d8800f15 	stw	r2,60(sp)
81120024:	d8c01015 	stw	r3,64(sp)
81120028:	8800e826 	beq	r17,zero,811203cc <_dtoa_r+0x15e8>
8112002c:	05204534 	movhi	r20,33044
81120030:	a5176904 	addi	r20,r20,23972
81120034:	04000084 	movi	r16,2
81120038:	8980004c 	andi	r6,r17,1
8112003c:	1009883a 	mov	r4,r2
81120040:	8823d07a 	srai	r17,r17,1
81120044:	180b883a 	mov	r5,r3
81120048:	30000426 	beq	r6,zero,8112005c <_dtoa_r+0x1278>
8112004c:	a1800017 	ldw	r6,0(r20)
81120050:	a1c00117 	ldw	r7,4(r20)
81120054:	84000044 	addi	r16,r16,1
81120058:	111607c0 	call	8111607c <__muldf3>
8112005c:	a5000204 	addi	r20,r20,8
81120060:	883ff51e 	bne	r17,zero,81120038 <__reset+0xfb100038>
81120064:	d8800f15 	stw	r2,60(sp)
81120068:	d8c01015 	stw	r3,64(sp)
8112006c:	003c7606 	br	8111f248 <__reset+0xfb0ff248>
81120070:	00c00c04 	movi	r3,48
81120074:	10c00005 	stb	r3,0(r2)
81120078:	d8c00517 	ldw	r3,20(sp)
8112007c:	bd3fffc3 	ldbu	r20,-1(r23)
81120080:	18c00044 	addi	r3,r3,1
81120084:	d8c00515 	stw	r3,20(sp)
81120088:	003db906 	br	8111f770 <__reset+0xfb0ff770>
8112008c:	89400117 	ldw	r5,4(r17)
81120090:	e009883a 	mov	r4,fp
81120094:	1121efc0 	call	81121efc <_Balloc>
81120098:	89800417 	ldw	r6,16(r17)
8112009c:	89400304 	addi	r5,r17,12
811200a0:	11000304 	addi	r4,r2,12
811200a4:	31800084 	addi	r6,r6,2
811200a8:	318d883a 	add	r6,r6,r6
811200ac:	318d883a 	add	r6,r6,r6
811200b0:	1027883a 	mov	r19,r2
811200b4:	1117ccc0 	call	81117ccc <memcpy>
811200b8:	01800044 	movi	r6,1
811200bc:	980b883a 	mov	r5,r19
811200c0:	e009883a 	mov	r4,fp
811200c4:	11226ac0 	call	811226ac <__lshift>
811200c8:	1029883a 	mov	r20,r2
811200cc:	003ecc06 	br	8111fc00 <__reset+0xfb0ffc00>
811200d0:	00800e44 	movi	r2,57
811200d4:	90809026 	beq	r18,r2,81120318 <_dtoa_r+0x1534>
811200d8:	92000044 	addi	r8,r18,1
811200dc:	003f1f06 	br	8111fd5c <__reset+0xfb0ffd5c>
811200e0:	9011883a 	mov	r8,r18
811200e4:	8825883a 	mov	r18,r17
811200e8:	a023883a 	mov	r17,r20
811200ec:	003e2906 	br	8111f994 <__reset+0xfb0ff994>
811200f0:	002b883a 	mov	r21,zero
811200f4:	0023883a 	mov	r17,zero
811200f8:	003f5406 	br	8111fe4c <__reset+0xfb0ffe4c>
811200fc:	61bfffc4 	addi	r6,r12,-1
81120100:	300490fa 	slli	r2,r6,3
81120104:	00e04534 	movhi	r3,33044
81120108:	18d77304 	addi	r3,r3,24012
8112010c:	1885883a 	add	r2,r3,r2
81120110:	11000017 	ldw	r4,0(r2)
81120114:	11400117 	ldw	r5,4(r2)
81120118:	d8800717 	ldw	r2,28(sp)
8112011c:	880f883a 	mov	r7,r17
81120120:	d9801215 	stw	r6,72(sp)
81120124:	800d883a 	mov	r6,r16
81120128:	db001615 	stw	r12,88(sp)
8112012c:	15c00044 	addi	r23,r2,1
81120130:	111607c0 	call	8111607c <__muldf3>
81120134:	d9401017 	ldw	r5,64(sp)
81120138:	d9000f17 	ldw	r4,60(sp)
8112013c:	d8c01515 	stw	r3,84(sp)
81120140:	d8801415 	stw	r2,80(sp)
81120144:	112c26c0 	call	8112c26c <__fixdfsi>
81120148:	1009883a 	mov	r4,r2
8112014c:	1021883a 	mov	r16,r2
81120150:	112c2ec0 	call	8112c2ec <__floatsidf>
81120154:	d9000f17 	ldw	r4,60(sp)
81120158:	d9401017 	ldw	r5,64(sp)
8112015c:	100d883a 	mov	r6,r2
81120160:	180f883a 	mov	r7,r3
81120164:	112b9680 	call	8112b968 <__subdf3>
81120168:	1829883a 	mov	r20,r3
8112016c:	d8c00717 	ldw	r3,28(sp)
81120170:	84000c04 	addi	r16,r16,48
81120174:	1023883a 	mov	r17,r2
81120178:	1c000005 	stb	r16,0(r3)
8112017c:	db001617 	ldw	r12,88(sp)
81120180:	00800044 	movi	r2,1
81120184:	60802226 	beq	r12,r2,81120210 <_dtoa_r+0x142c>
81120188:	d9c00717 	ldw	r7,28(sp)
8112018c:	8805883a 	mov	r2,r17
81120190:	b82b883a 	mov	r21,r23
81120194:	3b19883a 	add	r12,r7,r12
81120198:	6023883a 	mov	r17,r12
8112019c:	a007883a 	mov	r3,r20
811201a0:	dc800f15 	stw	r18,60(sp)
811201a4:	000d883a 	mov	r6,zero
811201a8:	01d00934 	movhi	r7,16420
811201ac:	1009883a 	mov	r4,r2
811201b0:	180b883a 	mov	r5,r3
811201b4:	111607c0 	call	8111607c <__muldf3>
811201b8:	180b883a 	mov	r5,r3
811201bc:	1009883a 	mov	r4,r2
811201c0:	1829883a 	mov	r20,r3
811201c4:	1025883a 	mov	r18,r2
811201c8:	112c26c0 	call	8112c26c <__fixdfsi>
811201cc:	1009883a 	mov	r4,r2
811201d0:	1021883a 	mov	r16,r2
811201d4:	112c2ec0 	call	8112c2ec <__floatsidf>
811201d8:	100d883a 	mov	r6,r2
811201dc:	180f883a 	mov	r7,r3
811201e0:	9009883a 	mov	r4,r18
811201e4:	a00b883a 	mov	r5,r20
811201e8:	84000c04 	addi	r16,r16,48
811201ec:	112b9680 	call	8112b968 <__subdf3>
811201f0:	ad400044 	addi	r21,r21,1
811201f4:	ac3fffc5 	stb	r16,-1(r21)
811201f8:	ac7fea1e 	bne	r21,r17,811201a4 <__reset+0xfb1001a4>
811201fc:	1023883a 	mov	r17,r2
81120200:	d8801217 	ldw	r2,72(sp)
81120204:	dc800f17 	ldw	r18,60(sp)
81120208:	1829883a 	mov	r20,r3
8112020c:	b8af883a 	add	r23,r23,r2
81120210:	d9001417 	ldw	r4,80(sp)
81120214:	d9401517 	ldw	r5,84(sp)
81120218:	000d883a 	mov	r6,zero
8112021c:	01cff834 	movhi	r7,16352
81120220:	112a56c0 	call	8112a56c <__adddf3>
81120224:	880d883a 	mov	r6,r17
81120228:	a00f883a 	mov	r7,r20
8112022c:	1009883a 	mov	r4,r2
81120230:	180b883a 	mov	r5,r3
81120234:	112b8740 	call	8112b874 <__ledf2>
81120238:	10003e0e 	bge	r2,zero,81120334 <_dtoa_r+0x1550>
8112023c:	d9001317 	ldw	r4,76(sp)
81120240:	bd3fffc3 	ldbu	r20,-1(r23)
81120244:	d9000515 	stw	r4,20(sp)
81120248:	003d3b06 	br	8111f738 <__reset+0xfb0ff738>
8112024c:	0027883a 	mov	r19,zero
81120250:	003f1b06 	br	8111fec0 <__reset+0xfb0ffec0>
81120254:	d8800817 	ldw	r2,32(sp)
81120258:	11e9c83a 	sub	r20,r2,r7
8112025c:	0005883a 	mov	r2,zero
81120260:	003d5406 	br	8111f7b4 <__reset+0xfb0ff7b4>
81120264:	00800044 	movi	r2,1
81120268:	003dc706 	br	8111f988 <__reset+0xfb0ff988>
8112026c:	d8c00217 	ldw	r3,8(sp)
81120270:	00800d84 	movi	r2,54
81120274:	dd400a17 	ldw	r21,40(sp)
81120278:	10c5c83a 	sub	r2,r2,r3
8112027c:	dd000817 	ldw	r20,32(sp)
81120280:	003d4c06 	br	8111f7b4 <__reset+0xfb0ff7b4>
81120284:	dc800f15 	stw	r18,60(sp)
81120288:	dcc01015 	stw	r19,64(sp)
8112028c:	04000084 	movi	r16,2
81120290:	003bed06 	br	8111f248 <__reset+0xfb0ff248>
81120294:	d9000617 	ldw	r4,24(sp)
81120298:	203f0d26 	beq	r4,zero,8111fed0 <__reset+0xfb0ffed0>
8112029c:	d9800c17 	ldw	r6,48(sp)
811202a0:	01bcab0e 	bge	zero,r6,8111f550 <__reset+0xfb0ff550>
811202a4:	d9401017 	ldw	r5,64(sp)
811202a8:	d9000f17 	ldw	r4,60(sp)
811202ac:	000d883a 	mov	r6,zero
811202b0:	01d00934 	movhi	r7,16420
811202b4:	111607c0 	call	8111607c <__muldf3>
811202b8:	81000044 	addi	r4,r16,1
811202bc:	d8800f15 	stw	r2,60(sp)
811202c0:	d8c01015 	stw	r3,64(sp)
811202c4:	112c2ec0 	call	8112c2ec <__floatsidf>
811202c8:	d9800f17 	ldw	r6,60(sp)
811202cc:	d9c01017 	ldw	r7,64(sp)
811202d0:	1009883a 	mov	r4,r2
811202d4:	180b883a 	mov	r5,r3
811202d8:	111607c0 	call	8111607c <__muldf3>
811202dc:	01d00734 	movhi	r7,16412
811202e0:	000d883a 	mov	r6,zero
811202e4:	1009883a 	mov	r4,r2
811202e8:	180b883a 	mov	r5,r3
811202ec:	112a56c0 	call	8112a56c <__adddf3>
811202f0:	d9c00517 	ldw	r7,20(sp)
811202f4:	047f3034 	movhi	r17,64704
811202f8:	1021883a 	mov	r16,r2
811202fc:	39ffffc4 	addi	r7,r7,-1
81120300:	d9c01315 	stw	r7,76(sp)
81120304:	1c63883a 	add	r17,r3,r17
81120308:	db000c17 	ldw	r12,48(sp)
8112030c:	003bea06 	br	8111f2b8 <__reset+0xfb0ff2b8>
81120310:	dc000915 	stw	r16,36(sp)
81120314:	003e0e06 	br	8111fb50 <__reset+0xfb0ffb50>
81120318:	01000e44 	movi	r4,57
8112031c:	8825883a 	mov	r18,r17
81120320:	9dc00044 	addi	r23,r19,1
81120324:	99000005 	stb	r4,0(r19)
81120328:	a023883a 	mov	r17,r20
8112032c:	dc000915 	stw	r16,36(sp)
81120330:	003da406 	br	8111f9c4 <__reset+0xfb0ff9c4>
81120334:	d9801417 	ldw	r6,80(sp)
81120338:	d9c01517 	ldw	r7,84(sp)
8112033c:	0009883a 	mov	r4,zero
81120340:	014ff834 	movhi	r5,16352
81120344:	112b9680 	call	8112b968 <__subdf3>
81120348:	880d883a 	mov	r6,r17
8112034c:	a00f883a 	mov	r7,r20
81120350:	1009883a 	mov	r4,r2
81120354:	180b883a 	mov	r5,r3
81120358:	112b7980 	call	8112b798 <__gedf2>
8112035c:	00bc7c0e 	bge	zero,r2,8111f550 <__reset+0xfb0ff550>
81120360:	01000c04 	movi	r4,48
81120364:	00000106 	br	8112036c <_dtoa_r+0x1588>
81120368:	102f883a 	mov	r23,r2
8112036c:	b8bfffc4 	addi	r2,r23,-1
81120370:	10c00007 	ldb	r3,0(r2)
81120374:	193ffc26 	beq	r3,r4,81120368 <__reset+0xfb100368>
81120378:	d9801317 	ldw	r6,76(sp)
8112037c:	d9800515 	stw	r6,20(sp)
81120380:	003c4406 	br	8111f494 <__reset+0xfb0ff494>
81120384:	d9801317 	ldw	r6,76(sp)
81120388:	d9800515 	stw	r6,20(sp)
8112038c:	003cea06 	br	8111f738 <__reset+0xfb0ff738>
81120390:	dd800f17 	ldw	r22,60(sp)
81120394:	dcc01017 	ldw	r19,64(sp)
81120398:	dc801217 	ldw	r18,72(sp)
8112039c:	003c6c06 	br	8111f550 <__reset+0xfb0ff550>
811203a0:	903e031e 	bne	r18,zero,8111fbb0 <__reset+0xfb0ffbb0>
811203a4:	003ebb06 	br	8111fe94 <__reset+0xfb0ffe94>
811203a8:	103e6c1e 	bne	r2,zero,8111fd5c <__reset+0xfb0ffd5c>
811203ac:	4080004c 	andi	r2,r8,1
811203b0:	103e6a26 	beq	r2,zero,8111fd5c <__reset+0xfb0ffd5c>
811203b4:	003e6606 	br	8111fd50 <__reset+0xfb0ffd50>
811203b8:	d8c00317 	ldw	r3,12(sp)
811203bc:	00800084 	movi	r2,2
811203c0:	10c02916 	blt	r2,r3,81120468 <_dtoa_r+0x1684>
811203c4:	d9000c17 	ldw	r4,48(sp)
811203c8:	003e8806 	br	8111fdec <__reset+0xfb0ffdec>
811203cc:	04000084 	movi	r16,2
811203d0:	003b9d06 	br	8111f248 <__reset+0xfb0ff248>
811203d4:	d9001317 	ldw	r4,76(sp)
811203d8:	d9000515 	stw	r4,20(sp)
811203dc:	003cd606 	br	8111f738 <__reset+0xfb0ff738>
811203e0:	d8801317 	ldw	r2,76(sp)
811203e4:	d8800515 	stw	r2,20(sp)
811203e8:	003c2a06 	br	8111f494 <__reset+0xfb0ff494>
811203ec:	d9800317 	ldw	r6,12(sp)
811203f0:	00800084 	movi	r2,2
811203f4:	11801516 	blt	r2,r6,8112044c <_dtoa_r+0x1668>
811203f8:	d9c00c17 	ldw	r7,48(sp)
811203fc:	d9c00615 	stw	r7,24(sp)
81120400:	003df706 	br	8111fbe0 <__reset+0xfb0ffbe0>
81120404:	193d3926 	beq	r3,r4,8111f8ec <__reset+0xfb0ff8ec>
81120408:	00c00f04 	movi	r3,60
8112040c:	1885c83a 	sub	r2,r3,r2
81120410:	003ddf06 	br	8111fb90 <__reset+0xfb0ffb90>
81120414:	e009883a 	mov	r4,fp
81120418:	e0001115 	stw	zero,68(fp)
8112041c:	000b883a 	mov	r5,zero
81120420:	1121efc0 	call	81121efc <_Balloc>
81120424:	d8800715 	stw	r2,28(sp)
81120428:	d8c00717 	ldw	r3,28(sp)
8112042c:	00bfffc4 	movi	r2,-1
81120430:	01000044 	movi	r4,1
81120434:	d8800c15 	stw	r2,48(sp)
81120438:	e0c01015 	stw	r3,64(fp)
8112043c:	d9000b15 	stw	r4,44(sp)
81120440:	d8800615 	stw	r2,24(sp)
81120444:	d8002215 	stw	zero,136(sp)
81120448:	003c4106 	br	8111f550 <__reset+0xfb0ff550>
8112044c:	d8c00c17 	ldw	r3,48(sp)
81120450:	d8c00615 	stw	r3,24(sp)
81120454:	003e7006 	br	8111fe18 <__reset+0xfb0ffe18>
81120458:	04400044 	movi	r17,1
8112045c:	003b2006 	br	8111f0e0 <__reset+0xfb0ff0e0>
81120460:	000b883a 	mov	r5,zero
81120464:	003b3d06 	br	8111f15c <__reset+0xfb0ff15c>
81120468:	d8800c17 	ldw	r2,48(sp)
8112046c:	d8800615 	stw	r2,24(sp)
81120470:	003e6906 	br	8111fe18 <__reset+0xfb0ffe18>

81120474 <__sflush_r>:
81120474:	defffb04 	addi	sp,sp,-20
81120478:	de00012e 	bgeu	sp,et,81120480 <__sflush_r+0xc>
8112047c:	003b68fa 	trap	3
81120480:	2880030b 	ldhu	r2,12(r5)
81120484:	dcc00315 	stw	r19,12(sp)
81120488:	dc400115 	stw	r17,4(sp)
8112048c:	dfc00415 	stw	ra,16(sp)
81120490:	dc800215 	stw	r18,8(sp)
81120494:	dc000015 	stw	r16,0(sp)
81120498:	10c0020c 	andi	r3,r2,8
8112049c:	2823883a 	mov	r17,r5
811204a0:	2027883a 	mov	r19,r4
811204a4:	1800311e 	bne	r3,zero,8112056c <__sflush_r+0xf8>
811204a8:	28c00117 	ldw	r3,4(r5)
811204ac:	10820014 	ori	r2,r2,2048
811204b0:	2880030d 	sth	r2,12(r5)
811204b4:	00c04b0e 	bge	zero,r3,811205e4 <__sflush_r+0x170>
811204b8:	8a000a17 	ldw	r8,40(r17)
811204bc:	40002326 	beq	r8,zero,8112054c <__sflush_r+0xd8>
811204c0:	9c000017 	ldw	r16,0(r19)
811204c4:	10c4000c 	andi	r3,r2,4096
811204c8:	98000015 	stw	zero,0(r19)
811204cc:	18004826 	beq	r3,zero,811205f0 <__sflush_r+0x17c>
811204d0:	89801417 	ldw	r6,80(r17)
811204d4:	10c0010c 	andi	r3,r2,4
811204d8:	18000626 	beq	r3,zero,811204f4 <__sflush_r+0x80>
811204dc:	88c00117 	ldw	r3,4(r17)
811204e0:	88800c17 	ldw	r2,48(r17)
811204e4:	30cdc83a 	sub	r6,r6,r3
811204e8:	10000226 	beq	r2,zero,811204f4 <__sflush_r+0x80>
811204ec:	88800f17 	ldw	r2,60(r17)
811204f0:	308dc83a 	sub	r6,r6,r2
811204f4:	89400717 	ldw	r5,28(r17)
811204f8:	000f883a 	mov	r7,zero
811204fc:	9809883a 	mov	r4,r19
81120500:	403ee83a 	callr	r8
81120504:	00ffffc4 	movi	r3,-1
81120508:	10c04426 	beq	r2,r3,8112061c <__sflush_r+0x1a8>
8112050c:	88c0030b 	ldhu	r3,12(r17)
81120510:	89000417 	ldw	r4,16(r17)
81120514:	88000115 	stw	zero,4(r17)
81120518:	197dffcc 	andi	r5,r3,63487
8112051c:	8940030d 	sth	r5,12(r17)
81120520:	89000015 	stw	r4,0(r17)
81120524:	18c4000c 	andi	r3,r3,4096
81120528:	18002c1e 	bne	r3,zero,811205dc <__sflush_r+0x168>
8112052c:	89400c17 	ldw	r5,48(r17)
81120530:	9c000015 	stw	r16,0(r19)
81120534:	28000526 	beq	r5,zero,8112054c <__sflush_r+0xd8>
81120538:	88801004 	addi	r2,r17,64
8112053c:	28800226 	beq	r5,r2,81120548 <__sflush_r+0xd4>
81120540:	9809883a 	mov	r4,r19
81120544:	1120f2c0 	call	81120f2c <_free_r>
81120548:	88000c15 	stw	zero,48(r17)
8112054c:	0005883a 	mov	r2,zero
81120550:	dfc00417 	ldw	ra,16(sp)
81120554:	dcc00317 	ldw	r19,12(sp)
81120558:	dc800217 	ldw	r18,8(sp)
8112055c:	dc400117 	ldw	r17,4(sp)
81120560:	dc000017 	ldw	r16,0(sp)
81120564:	dec00504 	addi	sp,sp,20
81120568:	f800283a 	ret
8112056c:	2c800417 	ldw	r18,16(r5)
81120570:	903ff626 	beq	r18,zero,8112054c <__reset+0xfb10054c>
81120574:	2c000017 	ldw	r16,0(r5)
81120578:	108000cc 	andi	r2,r2,3
8112057c:	2c800015 	stw	r18,0(r5)
81120580:	84a1c83a 	sub	r16,r16,r18
81120584:	1000131e 	bne	r2,zero,811205d4 <__sflush_r+0x160>
81120588:	28800517 	ldw	r2,20(r5)
8112058c:	88800215 	stw	r2,8(r17)
81120590:	04000316 	blt	zero,r16,811205a0 <__sflush_r+0x12c>
81120594:	003fed06 	br	8112054c <__reset+0xfb10054c>
81120598:	90a5883a 	add	r18,r18,r2
8112059c:	043feb0e 	bge	zero,r16,8112054c <__reset+0xfb10054c>
811205a0:	88800917 	ldw	r2,36(r17)
811205a4:	89400717 	ldw	r5,28(r17)
811205a8:	800f883a 	mov	r7,r16
811205ac:	900d883a 	mov	r6,r18
811205b0:	9809883a 	mov	r4,r19
811205b4:	103ee83a 	callr	r2
811205b8:	80a1c83a 	sub	r16,r16,r2
811205bc:	00bff616 	blt	zero,r2,81120598 <__reset+0xfb100598>
811205c0:	88c0030b 	ldhu	r3,12(r17)
811205c4:	00bfffc4 	movi	r2,-1
811205c8:	18c01014 	ori	r3,r3,64
811205cc:	88c0030d 	sth	r3,12(r17)
811205d0:	003fdf06 	br	81120550 <__reset+0xfb100550>
811205d4:	0005883a 	mov	r2,zero
811205d8:	003fec06 	br	8112058c <__reset+0xfb10058c>
811205dc:	88801415 	stw	r2,80(r17)
811205e0:	003fd206 	br	8112052c <__reset+0xfb10052c>
811205e4:	28c00f17 	ldw	r3,60(r5)
811205e8:	00ffb316 	blt	zero,r3,811204b8 <__reset+0xfb1004b8>
811205ec:	003fd706 	br	8112054c <__reset+0xfb10054c>
811205f0:	89400717 	ldw	r5,28(r17)
811205f4:	000d883a 	mov	r6,zero
811205f8:	01c00044 	movi	r7,1
811205fc:	9809883a 	mov	r4,r19
81120600:	403ee83a 	callr	r8
81120604:	100d883a 	mov	r6,r2
81120608:	00bfffc4 	movi	r2,-1
8112060c:	30801426 	beq	r6,r2,81120660 <__sflush_r+0x1ec>
81120610:	8880030b 	ldhu	r2,12(r17)
81120614:	8a000a17 	ldw	r8,40(r17)
81120618:	003fae06 	br	811204d4 <__reset+0xfb1004d4>
8112061c:	98c00017 	ldw	r3,0(r19)
81120620:	183fba26 	beq	r3,zero,8112050c <__reset+0xfb10050c>
81120624:	01000744 	movi	r4,29
81120628:	19000626 	beq	r3,r4,81120644 <__sflush_r+0x1d0>
8112062c:	01000584 	movi	r4,22
81120630:	19000426 	beq	r3,r4,81120644 <__sflush_r+0x1d0>
81120634:	88c0030b 	ldhu	r3,12(r17)
81120638:	18c01014 	ori	r3,r3,64
8112063c:	88c0030d 	sth	r3,12(r17)
81120640:	003fc306 	br	81120550 <__reset+0xfb100550>
81120644:	8880030b 	ldhu	r2,12(r17)
81120648:	88c00417 	ldw	r3,16(r17)
8112064c:	88000115 	stw	zero,4(r17)
81120650:	10bdffcc 	andi	r2,r2,63487
81120654:	8880030d 	sth	r2,12(r17)
81120658:	88c00015 	stw	r3,0(r17)
8112065c:	003fb306 	br	8112052c <__reset+0xfb10052c>
81120660:	98800017 	ldw	r2,0(r19)
81120664:	103fea26 	beq	r2,zero,81120610 <__reset+0xfb100610>
81120668:	00c00744 	movi	r3,29
8112066c:	10c00226 	beq	r2,r3,81120678 <__sflush_r+0x204>
81120670:	00c00584 	movi	r3,22
81120674:	10c0031e 	bne	r2,r3,81120684 <__sflush_r+0x210>
81120678:	9c000015 	stw	r16,0(r19)
8112067c:	0005883a 	mov	r2,zero
81120680:	003fb306 	br	81120550 <__reset+0xfb100550>
81120684:	88c0030b 	ldhu	r3,12(r17)
81120688:	3005883a 	mov	r2,r6
8112068c:	18c01014 	ori	r3,r3,64
81120690:	88c0030d 	sth	r3,12(r17)
81120694:	003fae06 	br	81120550 <__reset+0xfb100550>

81120698 <_fflush_r>:
81120698:	defffd04 	addi	sp,sp,-12
8112069c:	de00012e 	bgeu	sp,et,811206a4 <_fflush_r+0xc>
811206a0:	003b68fa 	trap	3
811206a4:	dc000115 	stw	r16,4(sp)
811206a8:	dfc00215 	stw	ra,8(sp)
811206ac:	2021883a 	mov	r16,r4
811206b0:	20000226 	beq	r4,zero,811206bc <_fflush_r+0x24>
811206b4:	20800e17 	ldw	r2,56(r4)
811206b8:	10000c26 	beq	r2,zero,811206ec <_fflush_r+0x54>
811206bc:	2880030f 	ldh	r2,12(r5)
811206c0:	1000051e 	bne	r2,zero,811206d8 <_fflush_r+0x40>
811206c4:	0005883a 	mov	r2,zero
811206c8:	dfc00217 	ldw	ra,8(sp)
811206cc:	dc000117 	ldw	r16,4(sp)
811206d0:	dec00304 	addi	sp,sp,12
811206d4:	f800283a 	ret
811206d8:	8009883a 	mov	r4,r16
811206dc:	dfc00217 	ldw	ra,8(sp)
811206e0:	dc000117 	ldw	r16,4(sp)
811206e4:	dec00304 	addi	sp,sp,12
811206e8:	11204741 	jmpi	81120474 <__sflush_r>
811206ec:	d9400015 	stw	r5,0(sp)
811206f0:	1120a940 	call	81120a94 <__sinit>
811206f4:	d9400017 	ldw	r5,0(sp)
811206f8:	003ff006 	br	811206bc <__reset+0xfb1006bc>

811206fc <fflush>:
811206fc:	20000526 	beq	r4,zero,81120714 <fflush+0x18>
81120700:	00a04574 	movhi	r2,33045
81120704:	10a10204 	addi	r2,r2,-31736
81120708:	200b883a 	mov	r5,r4
8112070c:	11000017 	ldw	r4,0(r2)
81120710:	11206981 	jmpi	81120698 <_fflush_r>
81120714:	00a04574 	movhi	r2,33045
81120718:	10a10104 	addi	r2,r2,-31740
8112071c:	11000017 	ldw	r4,0(r2)
81120720:	016044b4 	movhi	r5,33042
81120724:	2941a604 	addi	r5,r5,1688
81120728:	11217d41 	jmpi	811217d4 <_fwalk_reent>

8112072c <__fp_unlock>:
8112072c:	0005883a 	mov	r2,zero
81120730:	f800283a 	ret

81120734 <_cleanup_r>:
81120734:	016044f4 	movhi	r5,33043
81120738:	29613c04 	addi	r5,r5,-31504
8112073c:	11217d41 	jmpi	811217d4 <_fwalk_reent>

81120740 <__sinit.part.1>:
81120740:	defff704 	addi	sp,sp,-36
81120744:	00e044b4 	movhi	r3,33042
81120748:	de00012e 	bgeu	sp,et,81120750 <__sinit.part.1+0x10>
8112074c:	003b68fa 	trap	3
81120750:	18c1cd04 	addi	r3,r3,1844
81120754:	dfc00815 	stw	ra,32(sp)
81120758:	ddc00715 	stw	r23,28(sp)
8112075c:	dd800615 	stw	r22,24(sp)
81120760:	dd400515 	stw	r21,20(sp)
81120764:	dd000415 	stw	r20,16(sp)
81120768:	dcc00315 	stw	r19,12(sp)
8112076c:	dc800215 	stw	r18,8(sp)
81120770:	dc400115 	stw	r17,4(sp)
81120774:	dc000015 	stw	r16,0(sp)
81120778:	24000117 	ldw	r16,4(r4)
8112077c:	20c00f15 	stw	r3,60(r4)
81120780:	2080bb04 	addi	r2,r4,748
81120784:	00c000c4 	movi	r3,3
81120788:	20c0b915 	stw	r3,740(r4)
8112078c:	2080ba15 	stw	r2,744(r4)
81120790:	2000b815 	stw	zero,736(r4)
81120794:	05c00204 	movi	r23,8
81120798:	00800104 	movi	r2,4
8112079c:	2025883a 	mov	r18,r4
811207a0:	b80d883a 	mov	r6,r23
811207a4:	81001704 	addi	r4,r16,92
811207a8:	000b883a 	mov	r5,zero
811207ac:	80000015 	stw	zero,0(r16)
811207b0:	80000115 	stw	zero,4(r16)
811207b4:	80000215 	stw	zero,8(r16)
811207b8:	8080030d 	sth	r2,12(r16)
811207bc:	80001915 	stw	zero,100(r16)
811207c0:	8000038d 	sth	zero,14(r16)
811207c4:	80000415 	stw	zero,16(r16)
811207c8:	80000515 	stw	zero,20(r16)
811207cc:	80000615 	stw	zero,24(r16)
811207d0:	1117e1c0 	call	81117e1c <memset>
811207d4:	05a044b4 	movhi	r22,33042
811207d8:	94400217 	ldw	r17,8(r18)
811207dc:	056044b4 	movhi	r21,33042
811207e0:	052044b4 	movhi	r20,33042
811207e4:	04e044b4 	movhi	r19,33042
811207e8:	b5a18804 	addi	r22,r22,-31200
811207ec:	ad61a104 	addi	r21,r21,-31100
811207f0:	a521c204 	addi	r20,r20,-30968
811207f4:	9ce1db04 	addi	r19,r19,-30868
811207f8:	85800815 	stw	r22,32(r16)
811207fc:	85400915 	stw	r21,36(r16)
81120800:	85000a15 	stw	r20,40(r16)
81120804:	84c00b15 	stw	r19,44(r16)
81120808:	84000715 	stw	r16,28(r16)
8112080c:	00800284 	movi	r2,10
81120810:	8880030d 	sth	r2,12(r17)
81120814:	00800044 	movi	r2,1
81120818:	b80d883a 	mov	r6,r23
8112081c:	89001704 	addi	r4,r17,92
81120820:	000b883a 	mov	r5,zero
81120824:	88000015 	stw	zero,0(r17)
81120828:	88000115 	stw	zero,4(r17)
8112082c:	88000215 	stw	zero,8(r17)
81120830:	88001915 	stw	zero,100(r17)
81120834:	8880038d 	sth	r2,14(r17)
81120838:	88000415 	stw	zero,16(r17)
8112083c:	88000515 	stw	zero,20(r17)
81120840:	88000615 	stw	zero,24(r17)
81120844:	1117e1c0 	call	81117e1c <memset>
81120848:	94000317 	ldw	r16,12(r18)
8112084c:	00800484 	movi	r2,18
81120850:	8c400715 	stw	r17,28(r17)
81120854:	8d800815 	stw	r22,32(r17)
81120858:	8d400915 	stw	r21,36(r17)
8112085c:	8d000a15 	stw	r20,40(r17)
81120860:	8cc00b15 	stw	r19,44(r17)
81120864:	8080030d 	sth	r2,12(r16)
81120868:	00800084 	movi	r2,2
8112086c:	80000015 	stw	zero,0(r16)
81120870:	80000115 	stw	zero,4(r16)
81120874:	80000215 	stw	zero,8(r16)
81120878:	80001915 	stw	zero,100(r16)
8112087c:	8080038d 	sth	r2,14(r16)
81120880:	80000415 	stw	zero,16(r16)
81120884:	80000515 	stw	zero,20(r16)
81120888:	80000615 	stw	zero,24(r16)
8112088c:	b80d883a 	mov	r6,r23
81120890:	000b883a 	mov	r5,zero
81120894:	81001704 	addi	r4,r16,92
81120898:	1117e1c0 	call	81117e1c <memset>
8112089c:	00800044 	movi	r2,1
811208a0:	84000715 	stw	r16,28(r16)
811208a4:	85800815 	stw	r22,32(r16)
811208a8:	85400915 	stw	r21,36(r16)
811208ac:	85000a15 	stw	r20,40(r16)
811208b0:	84c00b15 	stw	r19,44(r16)
811208b4:	90800e15 	stw	r2,56(r18)
811208b8:	dfc00817 	ldw	ra,32(sp)
811208bc:	ddc00717 	ldw	r23,28(sp)
811208c0:	dd800617 	ldw	r22,24(sp)
811208c4:	dd400517 	ldw	r21,20(sp)
811208c8:	dd000417 	ldw	r20,16(sp)
811208cc:	dcc00317 	ldw	r19,12(sp)
811208d0:	dc800217 	ldw	r18,8(sp)
811208d4:	dc400117 	ldw	r17,4(sp)
811208d8:	dc000017 	ldw	r16,0(sp)
811208dc:	dec00904 	addi	sp,sp,36
811208e0:	f800283a 	ret

811208e4 <__fp_lock>:
811208e4:	0005883a 	mov	r2,zero
811208e8:	f800283a 	ret

811208ec <__sfmoreglue>:
811208ec:	defffc04 	addi	sp,sp,-16
811208f0:	de00012e 	bgeu	sp,et,811208f8 <__sfmoreglue+0xc>
811208f4:	003b68fa 	trap	3
811208f8:	dc400115 	stw	r17,4(sp)
811208fc:	2c7fffc4 	addi	r17,r5,-1
81120900:	8c401a24 	muli	r17,r17,104
81120904:	dc800215 	stw	r18,8(sp)
81120908:	2825883a 	mov	r18,r5
8112090c:	89401d04 	addi	r5,r17,116
81120910:	dc000015 	stw	r16,0(sp)
81120914:	dfc00315 	stw	ra,12(sp)
81120918:	11174b80 	call	811174b8 <_malloc_r>
8112091c:	1021883a 	mov	r16,r2
81120920:	10000726 	beq	r2,zero,81120940 <__sfmoreglue+0x54>
81120924:	11000304 	addi	r4,r2,12
81120928:	10000015 	stw	zero,0(r2)
8112092c:	14800115 	stw	r18,4(r2)
81120930:	11000215 	stw	r4,8(r2)
81120934:	89801a04 	addi	r6,r17,104
81120938:	000b883a 	mov	r5,zero
8112093c:	1117e1c0 	call	81117e1c <memset>
81120940:	8005883a 	mov	r2,r16
81120944:	dfc00317 	ldw	ra,12(sp)
81120948:	dc800217 	ldw	r18,8(sp)
8112094c:	dc400117 	ldw	r17,4(sp)
81120950:	dc000017 	ldw	r16,0(sp)
81120954:	dec00404 	addi	sp,sp,16
81120958:	f800283a 	ret

8112095c <__sfp>:
8112095c:	defffb04 	addi	sp,sp,-20
81120960:	de00012e 	bgeu	sp,et,81120968 <__sfp+0xc>
81120964:	003b68fa 	trap	3
81120968:	dc000015 	stw	r16,0(sp)
8112096c:	04204574 	movhi	r16,33045
81120970:	84210104 	addi	r16,r16,-31740
81120974:	dcc00315 	stw	r19,12(sp)
81120978:	2027883a 	mov	r19,r4
8112097c:	81000017 	ldw	r4,0(r16)
81120980:	dfc00415 	stw	ra,16(sp)
81120984:	dc800215 	stw	r18,8(sp)
81120988:	20800e17 	ldw	r2,56(r4)
8112098c:	dc400115 	stw	r17,4(sp)
81120990:	1000021e 	bne	r2,zero,8112099c <__sfp+0x40>
81120994:	11207400 	call	81120740 <__sinit.part.1>
81120998:	81000017 	ldw	r4,0(r16)
8112099c:	2480b804 	addi	r18,r4,736
811209a0:	047fffc4 	movi	r17,-1
811209a4:	91000117 	ldw	r4,4(r18)
811209a8:	94000217 	ldw	r16,8(r18)
811209ac:	213fffc4 	addi	r4,r4,-1
811209b0:	20000a16 	blt	r4,zero,811209dc <__sfp+0x80>
811209b4:	8080030f 	ldh	r2,12(r16)
811209b8:	10000c26 	beq	r2,zero,811209ec <__sfp+0x90>
811209bc:	80c01d04 	addi	r3,r16,116
811209c0:	00000206 	br	811209cc <__sfp+0x70>
811209c4:	18bfe60f 	ldh	r2,-104(r3)
811209c8:	10000826 	beq	r2,zero,811209ec <__sfp+0x90>
811209cc:	213fffc4 	addi	r4,r4,-1
811209d0:	1c3ffd04 	addi	r16,r3,-12
811209d4:	18c01a04 	addi	r3,r3,104
811209d8:	247ffa1e 	bne	r4,r17,811209c4 <__reset+0xfb1009c4>
811209dc:	90800017 	ldw	r2,0(r18)
811209e0:	10001d26 	beq	r2,zero,81120a58 <__sfp+0xfc>
811209e4:	1025883a 	mov	r18,r2
811209e8:	003fee06 	br	811209a4 <__reset+0xfb1009a4>
811209ec:	00bfffc4 	movi	r2,-1
811209f0:	8080038d 	sth	r2,14(r16)
811209f4:	00800044 	movi	r2,1
811209f8:	8080030d 	sth	r2,12(r16)
811209fc:	80001915 	stw	zero,100(r16)
81120a00:	80000015 	stw	zero,0(r16)
81120a04:	80000215 	stw	zero,8(r16)
81120a08:	80000115 	stw	zero,4(r16)
81120a0c:	80000415 	stw	zero,16(r16)
81120a10:	80000515 	stw	zero,20(r16)
81120a14:	80000615 	stw	zero,24(r16)
81120a18:	01800204 	movi	r6,8
81120a1c:	000b883a 	mov	r5,zero
81120a20:	81001704 	addi	r4,r16,92
81120a24:	1117e1c0 	call	81117e1c <memset>
81120a28:	8005883a 	mov	r2,r16
81120a2c:	80000c15 	stw	zero,48(r16)
81120a30:	80000d15 	stw	zero,52(r16)
81120a34:	80001115 	stw	zero,68(r16)
81120a38:	80001215 	stw	zero,72(r16)
81120a3c:	dfc00417 	ldw	ra,16(sp)
81120a40:	dcc00317 	ldw	r19,12(sp)
81120a44:	dc800217 	ldw	r18,8(sp)
81120a48:	dc400117 	ldw	r17,4(sp)
81120a4c:	dc000017 	ldw	r16,0(sp)
81120a50:	dec00504 	addi	sp,sp,20
81120a54:	f800283a 	ret
81120a58:	01400104 	movi	r5,4
81120a5c:	9809883a 	mov	r4,r19
81120a60:	11208ec0 	call	811208ec <__sfmoreglue>
81120a64:	90800015 	stw	r2,0(r18)
81120a68:	103fde1e 	bne	r2,zero,811209e4 <__reset+0xfb1009e4>
81120a6c:	00800304 	movi	r2,12
81120a70:	98800015 	stw	r2,0(r19)
81120a74:	0005883a 	mov	r2,zero
81120a78:	003ff006 	br	81120a3c <__reset+0xfb100a3c>

81120a7c <_cleanup>:
81120a7c:	00a04574 	movhi	r2,33045
81120a80:	10a10104 	addi	r2,r2,-31740
81120a84:	11000017 	ldw	r4,0(r2)
81120a88:	016044f4 	movhi	r5,33043
81120a8c:	29613c04 	addi	r5,r5,-31504
81120a90:	11217d41 	jmpi	811217d4 <_fwalk_reent>

81120a94 <__sinit>:
81120a94:	20800e17 	ldw	r2,56(r4)
81120a98:	10000126 	beq	r2,zero,81120aa0 <__sinit+0xc>
81120a9c:	f800283a 	ret
81120aa0:	11207401 	jmpi	81120740 <__sinit.part.1>

81120aa4 <__sfp_lock_acquire>:
81120aa4:	f800283a 	ret

81120aa8 <__sfp_lock_release>:
81120aa8:	f800283a 	ret

81120aac <__sinit_lock_acquire>:
81120aac:	f800283a 	ret

81120ab0 <__sinit_lock_release>:
81120ab0:	f800283a 	ret

81120ab4 <__fp_lock_all>:
81120ab4:	00a04574 	movhi	r2,33045
81120ab8:	10a10204 	addi	r2,r2,-31736
81120abc:	11000017 	ldw	r4,0(r2)
81120ac0:	016044b4 	movhi	r5,33042
81120ac4:	29423904 	addi	r5,r5,2276
81120ac8:	11217081 	jmpi	81121708 <_fwalk>

81120acc <__fp_unlock_all>:
81120acc:	00a04574 	movhi	r2,33045
81120ad0:	10a10204 	addi	r2,r2,-31736
81120ad4:	11000017 	ldw	r4,0(r2)
81120ad8:	016044b4 	movhi	r5,33042
81120adc:	2941cb04 	addi	r5,r5,1836
81120ae0:	11217081 	jmpi	81121708 <_fwalk>

81120ae4 <__sflags>:
81120ae4:	28800007 	ldb	r2,0(r5)
81120ae8:	00c01c84 	movi	r3,114
81120aec:	10c02426 	beq	r2,r3,81120b80 <__sflags+0x9c>
81120af0:	00c01dc4 	movi	r3,119
81120af4:	10c01e26 	beq	r2,r3,81120b70 <__sflags+0x8c>
81120af8:	00c01844 	movi	r3,97
81120afc:	10c00426 	beq	r2,r3,81120b10 <__sflags+0x2c>
81120b00:	00800584 	movi	r2,22
81120b04:	20800015 	stw	r2,0(r4)
81120b08:	0005883a 	mov	r2,zero
81120b0c:	f800283a 	ret
81120b10:	02c08204 	movi	r11,520
81120b14:	01000044 	movi	r4,1
81120b18:	00804204 	movi	r2,264
81120b1c:	01c00ac4 	movi	r7,43
81120b20:	02bff8c4 	movi	r10,-29
81120b24:	027fff04 	movi	r9,-4
81120b28:	02001e04 	movi	r8,120
81120b2c:	29400044 	addi	r5,r5,1
81120b30:	28c00007 	ldb	r3,0(r5)
81120b34:	18000626 	beq	r3,zero,81120b50 <__sflags+0x6c>
81120b38:	19c00826 	beq	r3,r7,81120b5c <__sflags+0x78>
81120b3c:	1a3ffb1e 	bne	r3,r8,81120b2c <__reset+0xfb100b2c>
81120b40:	29400044 	addi	r5,r5,1
81120b44:	28c00007 	ldb	r3,0(r5)
81120b48:	21020014 	ori	r4,r4,2048
81120b4c:	183ffa1e 	bne	r3,zero,81120b38 <__reset+0xfb100b38>
81120b50:	22c8b03a 	or	r4,r4,r11
81120b54:	31000015 	stw	r4,0(r6)
81120b58:	f800283a 	ret
81120b5c:	1284703a 	and	r2,r2,r10
81120b60:	2248703a 	and	r4,r4,r9
81120b64:	10800414 	ori	r2,r2,16
81120b68:	21000094 	ori	r4,r4,2
81120b6c:	003fef06 	br	81120b2c <__reset+0xfb100b2c>
81120b70:	02c18004 	movi	r11,1536
81120b74:	01000044 	movi	r4,1
81120b78:	00800204 	movi	r2,8
81120b7c:	003fe706 	br	81120b1c <__reset+0xfb100b1c>
81120b80:	0017883a 	mov	r11,zero
81120b84:	0009883a 	mov	r4,zero
81120b88:	00800104 	movi	r2,4
81120b8c:	003fe306 	br	81120b1c <__reset+0xfb100b1c>

81120b90 <_fread_r>:
81120b90:	defff404 	addi	sp,sp,-48
81120b94:	de00012e 	bgeu	sp,et,81120b9c <_fread_r+0xc>
81120b98:	003b68fa 	trap	3
81120b9c:	dd800815 	stw	r22,32(sp)
81120ba0:	39ad383a 	mul	r22,r7,r6
81120ba4:	dc000215 	stw	r16,8(sp)
81120ba8:	dfc00b15 	stw	ra,44(sp)
81120bac:	df000a15 	stw	fp,40(sp)
81120bb0:	ddc00915 	stw	r23,36(sp)
81120bb4:	dd400715 	stw	r21,28(sp)
81120bb8:	dd000615 	stw	r20,24(sp)
81120bbc:	dcc00515 	stw	r19,20(sp)
81120bc0:	dc800415 	stw	r18,16(sp)
81120bc4:	dc400315 	stw	r17,12(sp)
81120bc8:	dc000c17 	ldw	r16,48(sp)
81120bcc:	b0003b26 	beq	r22,zero,81120cbc <_fread_r+0x12c>
81120bd0:	302f883a 	mov	r23,r6
81120bd4:	382b883a 	mov	r21,r7
81120bd8:	2029883a 	mov	r20,r4
81120bdc:	2827883a 	mov	r19,r5
81120be0:	20000226 	beq	r4,zero,81120bec <_fread_r+0x5c>
81120be4:	20800e17 	ldw	r2,56(r4)
81120be8:	10006e26 	beq	r2,zero,81120da4 <_fread_r+0x214>
81120bec:	8080030b 	ldhu	r2,12(r16)
81120bf0:	10c8000c 	andi	r3,r2,8192
81120bf4:	1800061e 	bne	r3,zero,81120c10 <_fread_r+0x80>
81120bf8:	81001917 	ldw	r4,100(r16)
81120bfc:	00f7ffc4 	movi	r3,-8193
81120c00:	10880014 	ori	r2,r2,8192
81120c04:	20c6703a 	and	r3,r4,r3
81120c08:	8080030d 	sth	r2,12(r16)
81120c0c:	80c01915 	stw	r3,100(r16)
81120c10:	84400117 	ldw	r17,4(r16)
81120c14:	88005f16 	blt	r17,zero,81120d94 <_fread_r+0x204>
81120c18:	8809883a 	mov	r4,r17
81120c1c:	1080008c 	andi	r2,r2,2
81120c20:	1000281e 	bne	r2,zero,81120cc4 <_fread_r+0x134>
81120c24:	b025883a 	mov	r18,r22
81120c28:	00000b06 	br	81120c58 <_fread_r+0xc8>
81120c2c:	1117ccc0 	call	81117ccc <memcpy>
81120c30:	80800017 	ldw	r2,0(r16)
81120c34:	9c67883a 	add	r19,r19,r17
81120c38:	9465c83a 	sub	r18,r18,r17
81120c3c:	1463883a 	add	r17,r2,r17
81120c40:	800b883a 	mov	r5,r16
81120c44:	a009883a 	mov	r4,r20
81120c48:	84400015 	stw	r17,0(r16)
81120c4c:	11182980 	call	81118298 <__srefill_r>
81120c50:	10004c1e 	bne	r2,zero,81120d84 <_fread_r+0x1f4>
81120c54:	84400117 	ldw	r17,4(r16)
81120c58:	880d883a 	mov	r6,r17
81120c5c:	9809883a 	mov	r4,r19
81120c60:	81400017 	ldw	r5,0(r16)
81120c64:	8cbff136 	bltu	r17,r18,81120c2c <__reset+0xfb100c2c>
81120c68:	900d883a 	mov	r6,r18
81120c6c:	1117ccc0 	call	81117ccc <memcpy>
81120c70:	80c00117 	ldw	r3,4(r16)
81120c74:	81000017 	ldw	r4,0(r16)
81120c78:	a805883a 	mov	r2,r21
81120c7c:	1c87c83a 	sub	r3,r3,r18
81120c80:	24a5883a 	add	r18,r4,r18
81120c84:	80c00115 	stw	r3,4(r16)
81120c88:	84800015 	stw	r18,0(r16)
81120c8c:	dfc00b17 	ldw	ra,44(sp)
81120c90:	df000a17 	ldw	fp,40(sp)
81120c94:	ddc00917 	ldw	r23,36(sp)
81120c98:	dd800817 	ldw	r22,32(sp)
81120c9c:	dd400717 	ldw	r21,28(sp)
81120ca0:	dd000617 	ldw	r20,24(sp)
81120ca4:	dcc00517 	ldw	r19,20(sp)
81120ca8:	dc800417 	ldw	r18,16(sp)
81120cac:	dc400317 	ldw	r17,12(sp)
81120cb0:	dc000217 	ldw	r16,8(sp)
81120cb4:	dec00c04 	addi	sp,sp,48
81120cb8:	f800283a 	ret
81120cbc:	0005883a 	mov	r2,zero
81120cc0:	003ff206 	br	81120c8c <__reset+0xfb100c8c>
81120cc4:	b007883a 	mov	r3,r22
81120cc8:	2580012e 	bgeu	r4,r22,81120cd0 <_fread_r+0x140>
81120ccc:	2007883a 	mov	r3,r4
81120cd0:	81400017 	ldw	r5,0(r16)
81120cd4:	180d883a 	mov	r6,r3
81120cd8:	9809883a 	mov	r4,r19
81120cdc:	d8c00115 	stw	r3,4(sp)
81120ce0:	1117ccc0 	call	81117ccc <memcpy>
81120ce4:	d8c00117 	ldw	r3,4(sp)
81120ce8:	84400017 	ldw	r17,0(r16)
81120cec:	80800117 	ldw	r2,4(r16)
81120cf0:	81400c17 	ldw	r5,48(r16)
81120cf4:	88e3883a 	add	r17,r17,r3
81120cf8:	10c5c83a 	sub	r2,r2,r3
81120cfc:	84400015 	stw	r17,0(r16)
81120d00:	80800115 	stw	r2,4(r16)
81120d04:	b0e5c83a 	sub	r18,r22,r3
81120d08:	28002b26 	beq	r5,zero,81120db8 <_fread_r+0x228>
81120d0c:	90002b26 	beq	r18,zero,81120dbc <_fread_r+0x22c>
81120d10:	80801004 	addi	r2,r16,64
81120d14:	28800526 	beq	r5,r2,81120d2c <_fread_r+0x19c>
81120d18:	a009883a 	mov	r4,r20
81120d1c:	d8c00115 	stw	r3,4(sp)
81120d20:	1120f2c0 	call	81120f2c <_free_r>
81120d24:	d8c00117 	ldw	r3,4(sp)
81120d28:	84400017 	ldw	r17,0(r16)
81120d2c:	80000c15 	stw	zero,48(r16)
81120d30:	80800517 	ldw	r2,20(r16)
81120d34:	87000417 	ldw	fp,16(r16)
81120d38:	98e7883a 	add	r19,r19,r3
81120d3c:	d8800015 	stw	r2,0(sp)
81120d40:	00000106 	br	81120d48 <_fread_r+0x1b8>
81120d44:	90001d26 	beq	r18,zero,81120dbc <_fread_r+0x22c>
81120d48:	84c00415 	stw	r19,16(r16)
81120d4c:	84800515 	stw	r18,20(r16)
81120d50:	84c00015 	stw	r19,0(r16)
81120d54:	a009883a 	mov	r4,r20
81120d58:	800b883a 	mov	r5,r16
81120d5c:	11182980 	call	81118298 <__srefill_r>
81120d60:	d9000017 	ldw	r4,0(sp)
81120d64:	80c00117 	ldw	r3,4(r16)
81120d68:	87000415 	stw	fp,16(r16)
81120d6c:	81000515 	stw	r4,20(r16)
81120d70:	84400015 	stw	r17,0(r16)
81120d74:	80000115 	stw	zero,4(r16)
81120d78:	90e5c83a 	sub	r18,r18,r3
81120d7c:	98e7883a 	add	r19,r19,r3
81120d80:	103ff026 	beq	r2,zero,81120d44 <__reset+0xfb100d44>
81120d84:	b80b883a 	mov	r5,r23
81120d88:	b489c83a 	sub	r4,r22,r18
81120d8c:	112a2b40 	call	8112a2b4 <__udivsi3>
81120d90:	003fbe06 	br	81120c8c <__reset+0xfb100c8c>
81120d94:	80000115 	stw	zero,4(r16)
81120d98:	0009883a 	mov	r4,zero
81120d9c:	0023883a 	mov	r17,zero
81120da0:	003f9e06 	br	81120c1c <__reset+0xfb100c1c>
81120da4:	1120a940 	call	81120a94 <__sinit>
81120da8:	8080030b 	ldhu	r2,12(r16)
81120dac:	10c8000c 	andi	r3,r2,8192
81120db0:	183f971e 	bne	r3,zero,81120c10 <__reset+0xfb100c10>
81120db4:	003f9006 	br	81120bf8 <__reset+0xfb100bf8>
81120db8:	903fdd1e 	bne	r18,zero,81120d30 <__reset+0xfb100d30>
81120dbc:	a805883a 	mov	r2,r21
81120dc0:	003fb206 	br	81120c8c <__reset+0xfb100c8c>

81120dc4 <fread>:
81120dc4:	defffe04 	addi	sp,sp,-8
81120dc8:	00a04574 	movhi	r2,33045
81120dcc:	de00012e 	bgeu	sp,et,81120dd4 <fread+0x10>
81120dd0:	003b68fa 	trap	3
81120dd4:	10a10204 	addi	r2,r2,-31736
81120dd8:	d9c00015 	stw	r7,0(sp)
81120ddc:	300f883a 	mov	r7,r6
81120de0:	280d883a 	mov	r6,r5
81120de4:	200b883a 	mov	r5,r4
81120de8:	11000017 	ldw	r4,0(r2)
81120dec:	dfc00115 	stw	ra,4(sp)
81120df0:	1120b900 	call	81120b90 <_fread_r>
81120df4:	dfc00117 	ldw	ra,4(sp)
81120df8:	dec00204 	addi	sp,sp,8
81120dfc:	f800283a 	ret

81120e00 <_malloc_trim_r>:
81120e00:	defffb04 	addi	sp,sp,-20
81120e04:	de00012e 	bgeu	sp,et,81120e0c <_malloc_trim_r+0xc>
81120e08:	003b68fa 	trap	3
81120e0c:	dcc00315 	stw	r19,12(sp)
81120e10:	04e04534 	movhi	r19,33044
81120e14:	dc800215 	stw	r18,8(sp)
81120e18:	dc400115 	stw	r17,4(sp)
81120e1c:	dc000015 	stw	r16,0(sp)
81120e20:	dfc00415 	stw	ra,16(sp)
81120e24:	2821883a 	mov	r16,r5
81120e28:	9cdac004 	addi	r19,r19,27392
81120e2c:	2025883a 	mov	r18,r4
81120e30:	112e2b40 	call	8112e2b4 <__malloc_lock>
81120e34:	98800217 	ldw	r2,8(r19)
81120e38:	14400117 	ldw	r17,4(r2)
81120e3c:	00bfff04 	movi	r2,-4
81120e40:	88a2703a 	and	r17,r17,r2
81120e44:	8c21c83a 	sub	r16,r17,r16
81120e48:	8403fbc4 	addi	r16,r16,4079
81120e4c:	8020d33a 	srli	r16,r16,12
81120e50:	0083ffc4 	movi	r2,4095
81120e54:	843fffc4 	addi	r16,r16,-1
81120e58:	8020933a 	slli	r16,r16,12
81120e5c:	1400060e 	bge	r2,r16,81120e78 <_malloc_trim_r+0x78>
81120e60:	000b883a 	mov	r5,zero
81120e64:	9009883a 	mov	r4,r18
81120e68:	11184740 	call	81118474 <_sbrk_r>
81120e6c:	98c00217 	ldw	r3,8(r19)
81120e70:	1c47883a 	add	r3,r3,r17
81120e74:	10c00a26 	beq	r2,r3,81120ea0 <_malloc_trim_r+0xa0>
81120e78:	9009883a 	mov	r4,r18
81120e7c:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81120e80:	0005883a 	mov	r2,zero
81120e84:	dfc00417 	ldw	ra,16(sp)
81120e88:	dcc00317 	ldw	r19,12(sp)
81120e8c:	dc800217 	ldw	r18,8(sp)
81120e90:	dc400117 	ldw	r17,4(sp)
81120e94:	dc000017 	ldw	r16,0(sp)
81120e98:	dec00504 	addi	sp,sp,20
81120e9c:	f800283a 	ret
81120ea0:	040bc83a 	sub	r5,zero,r16
81120ea4:	9009883a 	mov	r4,r18
81120ea8:	11184740 	call	81118474 <_sbrk_r>
81120eac:	00ffffc4 	movi	r3,-1
81120eb0:	10c00d26 	beq	r2,r3,81120ee8 <_malloc_trim_r+0xe8>
81120eb4:	00e04574 	movhi	r3,33045
81120eb8:	18e20b04 	addi	r3,r3,-30676
81120ebc:	18800017 	ldw	r2,0(r3)
81120ec0:	99000217 	ldw	r4,8(r19)
81120ec4:	8c23c83a 	sub	r17,r17,r16
81120ec8:	8c400054 	ori	r17,r17,1
81120ecc:	1421c83a 	sub	r16,r2,r16
81120ed0:	24400115 	stw	r17,4(r4)
81120ed4:	9009883a 	mov	r4,r18
81120ed8:	1c000015 	stw	r16,0(r3)
81120edc:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81120ee0:	00800044 	movi	r2,1
81120ee4:	003fe706 	br	81120e84 <__reset+0xfb100e84>
81120ee8:	000b883a 	mov	r5,zero
81120eec:	9009883a 	mov	r4,r18
81120ef0:	11184740 	call	81118474 <_sbrk_r>
81120ef4:	99000217 	ldw	r4,8(r19)
81120ef8:	014003c4 	movi	r5,15
81120efc:	1107c83a 	sub	r3,r2,r4
81120f00:	28ffdd0e 	bge	r5,r3,81120e78 <__reset+0xfb100e78>
81120f04:	01604574 	movhi	r5,33045
81120f08:	29610304 	addi	r5,r5,-31732
81120f0c:	29400017 	ldw	r5,0(r5)
81120f10:	18c00054 	ori	r3,r3,1
81120f14:	20c00115 	stw	r3,4(r4)
81120f18:	00e04574 	movhi	r3,33045
81120f1c:	1145c83a 	sub	r2,r2,r5
81120f20:	18e20b04 	addi	r3,r3,-30676
81120f24:	18800015 	stw	r2,0(r3)
81120f28:	003fd306 	br	81120e78 <__reset+0xfb100e78>

81120f2c <_free_r>:
81120f2c:	28004326 	beq	r5,zero,8112103c <_free_r+0x110>
81120f30:	defffd04 	addi	sp,sp,-12
81120f34:	de00012e 	bgeu	sp,et,81120f3c <_free_r+0x10>
81120f38:	003b68fa 	trap	3
81120f3c:	dc400115 	stw	r17,4(sp)
81120f40:	dc000015 	stw	r16,0(sp)
81120f44:	2023883a 	mov	r17,r4
81120f48:	2821883a 	mov	r16,r5
81120f4c:	dfc00215 	stw	ra,8(sp)
81120f50:	112e2b40 	call	8112e2b4 <__malloc_lock>
81120f54:	81ffff17 	ldw	r7,-4(r16)
81120f58:	00bfff84 	movi	r2,-2
81120f5c:	01204534 	movhi	r4,33044
81120f60:	81bffe04 	addi	r6,r16,-8
81120f64:	3884703a 	and	r2,r7,r2
81120f68:	211ac004 	addi	r4,r4,27392
81120f6c:	308b883a 	add	r5,r6,r2
81120f70:	2a400117 	ldw	r9,4(r5)
81120f74:	22000217 	ldw	r8,8(r4)
81120f78:	00ffff04 	movi	r3,-4
81120f7c:	48c6703a 	and	r3,r9,r3
81120f80:	2a005726 	beq	r5,r8,811210e0 <_free_r+0x1b4>
81120f84:	28c00115 	stw	r3,4(r5)
81120f88:	39c0004c 	andi	r7,r7,1
81120f8c:	3800091e 	bne	r7,zero,81120fb4 <_free_r+0x88>
81120f90:	823ffe17 	ldw	r8,-8(r16)
81120f94:	22400204 	addi	r9,r4,8
81120f98:	320dc83a 	sub	r6,r6,r8
81120f9c:	31c00217 	ldw	r7,8(r6)
81120fa0:	1205883a 	add	r2,r2,r8
81120fa4:	3a406526 	beq	r7,r9,8112113c <_free_r+0x210>
81120fa8:	32000317 	ldw	r8,12(r6)
81120fac:	3a000315 	stw	r8,12(r7)
81120fb0:	41c00215 	stw	r7,8(r8)
81120fb4:	28cf883a 	add	r7,r5,r3
81120fb8:	39c00117 	ldw	r7,4(r7)
81120fbc:	39c0004c 	andi	r7,r7,1
81120fc0:	38003a26 	beq	r7,zero,811210ac <_free_r+0x180>
81120fc4:	10c00054 	ori	r3,r2,1
81120fc8:	30c00115 	stw	r3,4(r6)
81120fcc:	3087883a 	add	r3,r6,r2
81120fd0:	18800015 	stw	r2,0(r3)
81120fd4:	00c07fc4 	movi	r3,511
81120fd8:	18801936 	bltu	r3,r2,81121040 <_free_r+0x114>
81120fdc:	1004d0fa 	srli	r2,r2,3
81120fe0:	01c00044 	movi	r7,1
81120fe4:	21400117 	ldw	r5,4(r4)
81120fe8:	10c00044 	addi	r3,r2,1
81120fec:	18c7883a 	add	r3,r3,r3
81120ff0:	1005d0ba 	srai	r2,r2,2
81120ff4:	18c7883a 	add	r3,r3,r3
81120ff8:	18c7883a 	add	r3,r3,r3
81120ffc:	1907883a 	add	r3,r3,r4
81121000:	3884983a 	sll	r2,r7,r2
81121004:	19c00017 	ldw	r7,0(r3)
81121008:	1a3ffe04 	addi	r8,r3,-8
8112100c:	1144b03a 	or	r2,r2,r5
81121010:	32000315 	stw	r8,12(r6)
81121014:	31c00215 	stw	r7,8(r6)
81121018:	20800115 	stw	r2,4(r4)
8112101c:	19800015 	stw	r6,0(r3)
81121020:	39800315 	stw	r6,12(r7)
81121024:	8809883a 	mov	r4,r17
81121028:	dfc00217 	ldw	ra,8(sp)
8112102c:	dc400117 	ldw	r17,4(sp)
81121030:	dc000017 	ldw	r16,0(sp)
81121034:	dec00304 	addi	sp,sp,12
81121038:	112e3dc1 	jmpi	8112e3dc <__malloc_unlock>
8112103c:	f800283a 	ret
81121040:	100ad27a 	srli	r5,r2,9
81121044:	00c00104 	movi	r3,4
81121048:	19404a36 	bltu	r3,r5,81121174 <_free_r+0x248>
8112104c:	100ad1ba 	srli	r5,r2,6
81121050:	28c00e44 	addi	r3,r5,57
81121054:	18c7883a 	add	r3,r3,r3
81121058:	29400e04 	addi	r5,r5,56
8112105c:	18c7883a 	add	r3,r3,r3
81121060:	18c7883a 	add	r3,r3,r3
81121064:	1909883a 	add	r4,r3,r4
81121068:	20c00017 	ldw	r3,0(r4)
8112106c:	01e04534 	movhi	r7,33044
81121070:	213ffe04 	addi	r4,r4,-8
81121074:	39dac004 	addi	r7,r7,27392
81121078:	20c04426 	beq	r4,r3,8112118c <_free_r+0x260>
8112107c:	01ffff04 	movi	r7,-4
81121080:	19400117 	ldw	r5,4(r3)
81121084:	29ca703a 	and	r5,r5,r7
81121088:	1140022e 	bgeu	r2,r5,81121094 <_free_r+0x168>
8112108c:	18c00217 	ldw	r3,8(r3)
81121090:	20fffb1e 	bne	r4,r3,81121080 <__reset+0xfb101080>
81121094:	19000317 	ldw	r4,12(r3)
81121098:	31000315 	stw	r4,12(r6)
8112109c:	30c00215 	stw	r3,8(r6)
811210a0:	21800215 	stw	r6,8(r4)
811210a4:	19800315 	stw	r6,12(r3)
811210a8:	003fde06 	br	81121024 <__reset+0xfb101024>
811210ac:	29c00217 	ldw	r7,8(r5)
811210b0:	10c5883a 	add	r2,r2,r3
811210b4:	00e04534 	movhi	r3,33044
811210b8:	18dac204 	addi	r3,r3,27400
811210bc:	38c03b26 	beq	r7,r3,811211ac <_free_r+0x280>
811210c0:	2a000317 	ldw	r8,12(r5)
811210c4:	11400054 	ori	r5,r2,1
811210c8:	3087883a 	add	r3,r6,r2
811210cc:	3a000315 	stw	r8,12(r7)
811210d0:	41c00215 	stw	r7,8(r8)
811210d4:	31400115 	stw	r5,4(r6)
811210d8:	18800015 	stw	r2,0(r3)
811210dc:	003fbd06 	br	81120fd4 <__reset+0xfb100fd4>
811210e0:	39c0004c 	andi	r7,r7,1
811210e4:	10c5883a 	add	r2,r2,r3
811210e8:	3800071e 	bne	r7,zero,81121108 <_free_r+0x1dc>
811210ec:	81fffe17 	ldw	r7,-8(r16)
811210f0:	31cdc83a 	sub	r6,r6,r7
811210f4:	30c00317 	ldw	r3,12(r6)
811210f8:	31400217 	ldw	r5,8(r6)
811210fc:	11c5883a 	add	r2,r2,r7
81121100:	28c00315 	stw	r3,12(r5)
81121104:	19400215 	stw	r5,8(r3)
81121108:	10c00054 	ori	r3,r2,1
8112110c:	30c00115 	stw	r3,4(r6)
81121110:	00e04574 	movhi	r3,33045
81121114:	18e10404 	addi	r3,r3,-31728
81121118:	18c00017 	ldw	r3,0(r3)
8112111c:	21800215 	stw	r6,8(r4)
81121120:	10ffc036 	bltu	r2,r3,81121024 <__reset+0xfb101024>
81121124:	00a04574 	movhi	r2,33045
81121128:	10a16904 	addi	r2,r2,-31324
8112112c:	11400017 	ldw	r5,0(r2)
81121130:	8809883a 	mov	r4,r17
81121134:	1120e000 	call	81120e00 <_malloc_trim_r>
81121138:	003fba06 	br	81121024 <__reset+0xfb101024>
8112113c:	28c9883a 	add	r4,r5,r3
81121140:	21000117 	ldw	r4,4(r4)
81121144:	2100004c 	andi	r4,r4,1
81121148:	2000391e 	bne	r4,zero,81121230 <_free_r+0x304>
8112114c:	29c00217 	ldw	r7,8(r5)
81121150:	29000317 	ldw	r4,12(r5)
81121154:	1885883a 	add	r2,r3,r2
81121158:	10c00054 	ori	r3,r2,1
8112115c:	39000315 	stw	r4,12(r7)
81121160:	21c00215 	stw	r7,8(r4)
81121164:	30c00115 	stw	r3,4(r6)
81121168:	308d883a 	add	r6,r6,r2
8112116c:	30800015 	stw	r2,0(r6)
81121170:	003fac06 	br	81121024 <__reset+0xfb101024>
81121174:	00c00504 	movi	r3,20
81121178:	19401536 	bltu	r3,r5,811211d0 <_free_r+0x2a4>
8112117c:	28c01704 	addi	r3,r5,92
81121180:	18c7883a 	add	r3,r3,r3
81121184:	294016c4 	addi	r5,r5,91
81121188:	003fb406 	br	8112105c <__reset+0xfb10105c>
8112118c:	280bd0ba 	srai	r5,r5,2
81121190:	00c00044 	movi	r3,1
81121194:	38800117 	ldw	r2,4(r7)
81121198:	194a983a 	sll	r5,r3,r5
8112119c:	2007883a 	mov	r3,r4
811211a0:	2884b03a 	or	r2,r5,r2
811211a4:	38800115 	stw	r2,4(r7)
811211a8:	003fbb06 	br	81121098 <__reset+0xfb101098>
811211ac:	21800515 	stw	r6,20(r4)
811211b0:	21800415 	stw	r6,16(r4)
811211b4:	10c00054 	ori	r3,r2,1
811211b8:	31c00315 	stw	r7,12(r6)
811211bc:	31c00215 	stw	r7,8(r6)
811211c0:	30c00115 	stw	r3,4(r6)
811211c4:	308d883a 	add	r6,r6,r2
811211c8:	30800015 	stw	r2,0(r6)
811211cc:	003f9506 	br	81121024 <__reset+0xfb101024>
811211d0:	00c01504 	movi	r3,84
811211d4:	19400536 	bltu	r3,r5,811211ec <_free_r+0x2c0>
811211d8:	100ad33a 	srli	r5,r2,12
811211dc:	28c01bc4 	addi	r3,r5,111
811211e0:	18c7883a 	add	r3,r3,r3
811211e4:	29401b84 	addi	r5,r5,110
811211e8:	003f9c06 	br	8112105c <__reset+0xfb10105c>
811211ec:	00c05504 	movi	r3,340
811211f0:	19400536 	bltu	r3,r5,81121208 <_free_r+0x2dc>
811211f4:	100ad3fa 	srli	r5,r2,15
811211f8:	28c01e04 	addi	r3,r5,120
811211fc:	18c7883a 	add	r3,r3,r3
81121200:	29401dc4 	addi	r5,r5,119
81121204:	003f9506 	br	8112105c <__reset+0xfb10105c>
81121208:	00c15504 	movi	r3,1364
8112120c:	19400536 	bltu	r3,r5,81121224 <_free_r+0x2f8>
81121210:	100ad4ba 	srli	r5,r2,18
81121214:	28c01f44 	addi	r3,r5,125
81121218:	18c7883a 	add	r3,r3,r3
8112121c:	29401f04 	addi	r5,r5,124
81121220:	003f8e06 	br	8112105c <__reset+0xfb10105c>
81121224:	00c03f84 	movi	r3,254
81121228:	01401f84 	movi	r5,126
8112122c:	003f8b06 	br	8112105c <__reset+0xfb10105c>
81121230:	10c00054 	ori	r3,r2,1
81121234:	30c00115 	stw	r3,4(r6)
81121238:	308d883a 	add	r6,r6,r2
8112123c:	30800015 	stw	r2,0(r6)
81121240:	003f7806 	br	81121024 <__reset+0xfb101024>

81121244 <__sfvwrite_r>:
81121244:	30800217 	ldw	r2,8(r6)
81121248:	10006926 	beq	r2,zero,811213f0 <__sfvwrite_r+0x1ac>
8112124c:	defff404 	addi	sp,sp,-48
81121250:	de00012e 	bgeu	sp,et,81121258 <__sfvwrite_r+0x14>
81121254:	003b68fa 	trap	3
81121258:	28c0030b 	ldhu	r3,12(r5)
8112125c:	dd400715 	stw	r21,28(sp)
81121260:	dd000615 	stw	r20,24(sp)
81121264:	dc000215 	stw	r16,8(sp)
81121268:	dfc00b15 	stw	ra,44(sp)
8112126c:	df000a15 	stw	fp,40(sp)
81121270:	ddc00915 	stw	r23,36(sp)
81121274:	dd800815 	stw	r22,32(sp)
81121278:	dcc00515 	stw	r19,20(sp)
8112127c:	dc800415 	stw	r18,16(sp)
81121280:	dc400315 	stw	r17,12(sp)
81121284:	1880020c 	andi	r2,r3,8
81121288:	2821883a 	mov	r16,r5
8112128c:	202b883a 	mov	r21,r4
81121290:	3029883a 	mov	r20,r6
81121294:	10002726 	beq	r2,zero,81121334 <__sfvwrite_r+0xf0>
81121298:	28800417 	ldw	r2,16(r5)
8112129c:	10002526 	beq	r2,zero,81121334 <__sfvwrite_r+0xf0>
811212a0:	1880008c 	andi	r2,r3,2
811212a4:	a4400017 	ldw	r17,0(r20)
811212a8:	10002a26 	beq	r2,zero,81121354 <__sfvwrite_r+0x110>
811212ac:	05a00034 	movhi	r22,32768
811212b0:	0027883a 	mov	r19,zero
811212b4:	0025883a 	mov	r18,zero
811212b8:	b5bf0004 	addi	r22,r22,-1024
811212bc:	980d883a 	mov	r6,r19
811212c0:	a809883a 	mov	r4,r21
811212c4:	90004626 	beq	r18,zero,811213e0 <__sfvwrite_r+0x19c>
811212c8:	900f883a 	mov	r7,r18
811212cc:	b480022e 	bgeu	r22,r18,811212d8 <__sfvwrite_r+0x94>
811212d0:	01e00034 	movhi	r7,32768
811212d4:	39ff0004 	addi	r7,r7,-1024
811212d8:	80800917 	ldw	r2,36(r16)
811212dc:	81400717 	ldw	r5,28(r16)
811212e0:	103ee83a 	callr	r2
811212e4:	0080570e 	bge	zero,r2,81121444 <__sfvwrite_r+0x200>
811212e8:	a0c00217 	ldw	r3,8(r20)
811212ec:	98a7883a 	add	r19,r19,r2
811212f0:	90a5c83a 	sub	r18,r18,r2
811212f4:	1885c83a 	sub	r2,r3,r2
811212f8:	a0800215 	stw	r2,8(r20)
811212fc:	103fef1e 	bne	r2,zero,811212bc <__reset+0xfb1012bc>
81121300:	0005883a 	mov	r2,zero
81121304:	dfc00b17 	ldw	ra,44(sp)
81121308:	df000a17 	ldw	fp,40(sp)
8112130c:	ddc00917 	ldw	r23,36(sp)
81121310:	dd800817 	ldw	r22,32(sp)
81121314:	dd400717 	ldw	r21,28(sp)
81121318:	dd000617 	ldw	r20,24(sp)
8112131c:	dcc00517 	ldw	r19,20(sp)
81121320:	dc800417 	ldw	r18,16(sp)
81121324:	dc400317 	ldw	r17,12(sp)
81121328:	dc000217 	ldw	r16,8(sp)
8112132c:	dec00c04 	addi	sp,sp,48
81121330:	f800283a 	ret
81121334:	800b883a 	mov	r5,r16
81121338:	a809883a 	mov	r4,r21
8112133c:	111ea240 	call	8111ea24 <__swsetup_r>
81121340:	1000eb1e 	bne	r2,zero,811216f0 <__sfvwrite_r+0x4ac>
81121344:	80c0030b 	ldhu	r3,12(r16)
81121348:	a4400017 	ldw	r17,0(r20)
8112134c:	1880008c 	andi	r2,r3,2
81121350:	103fd61e 	bne	r2,zero,811212ac <__reset+0xfb1012ac>
81121354:	1880004c 	andi	r2,r3,1
81121358:	10003f1e 	bne	r2,zero,81121458 <__sfvwrite_r+0x214>
8112135c:	0039883a 	mov	fp,zero
81121360:	0025883a 	mov	r18,zero
81121364:	90001a26 	beq	r18,zero,811213d0 <__sfvwrite_r+0x18c>
81121368:	1880800c 	andi	r2,r3,512
8112136c:	84c00217 	ldw	r19,8(r16)
81121370:	10002126 	beq	r2,zero,811213f8 <__sfvwrite_r+0x1b4>
81121374:	982f883a 	mov	r23,r19
81121378:	94c09336 	bltu	r18,r19,811215c8 <__sfvwrite_r+0x384>
8112137c:	1881200c 	andi	r2,r3,1152
81121380:	10009e1e 	bne	r2,zero,811215fc <__sfvwrite_r+0x3b8>
81121384:	81000017 	ldw	r4,0(r16)
81121388:	b80d883a 	mov	r6,r23
8112138c:	e00b883a 	mov	r5,fp
81121390:	1121da00 	call	81121da0 <memmove>
81121394:	80c00217 	ldw	r3,8(r16)
81121398:	81000017 	ldw	r4,0(r16)
8112139c:	9005883a 	mov	r2,r18
811213a0:	1ce7c83a 	sub	r19,r3,r19
811213a4:	25cf883a 	add	r7,r4,r23
811213a8:	84c00215 	stw	r19,8(r16)
811213ac:	81c00015 	stw	r7,0(r16)
811213b0:	a0c00217 	ldw	r3,8(r20)
811213b4:	e0b9883a 	add	fp,fp,r2
811213b8:	90a5c83a 	sub	r18,r18,r2
811213bc:	18a7c83a 	sub	r19,r3,r2
811213c0:	a4c00215 	stw	r19,8(r20)
811213c4:	983fce26 	beq	r19,zero,81121300 <__reset+0xfb101300>
811213c8:	80c0030b 	ldhu	r3,12(r16)
811213cc:	903fe61e 	bne	r18,zero,81121368 <__reset+0xfb101368>
811213d0:	8f000017 	ldw	fp,0(r17)
811213d4:	8c800117 	ldw	r18,4(r17)
811213d8:	8c400204 	addi	r17,r17,8
811213dc:	003fe106 	br	81121364 <__reset+0xfb101364>
811213e0:	8cc00017 	ldw	r19,0(r17)
811213e4:	8c800117 	ldw	r18,4(r17)
811213e8:	8c400204 	addi	r17,r17,8
811213ec:	003fb306 	br	811212bc <__reset+0xfb1012bc>
811213f0:	0005883a 	mov	r2,zero
811213f4:	f800283a 	ret
811213f8:	81000017 	ldw	r4,0(r16)
811213fc:	80800417 	ldw	r2,16(r16)
81121400:	11005736 	bltu	r2,r4,81121560 <__sfvwrite_r+0x31c>
81121404:	85c00517 	ldw	r23,20(r16)
81121408:	95c05536 	bltu	r18,r23,81121560 <__sfvwrite_r+0x31c>
8112140c:	00a00034 	movhi	r2,32768
81121410:	10bfffc4 	addi	r2,r2,-1
81121414:	9009883a 	mov	r4,r18
81121418:	1480012e 	bgeu	r2,r18,81121420 <__sfvwrite_r+0x1dc>
8112141c:	1009883a 	mov	r4,r2
81121420:	b80b883a 	mov	r5,r23
81121424:	112a1bc0 	call	8112a1bc <__divsi3>
81121428:	15cf383a 	mul	r7,r2,r23
8112142c:	81400717 	ldw	r5,28(r16)
81121430:	80800917 	ldw	r2,36(r16)
81121434:	e00d883a 	mov	r6,fp
81121438:	a809883a 	mov	r4,r21
8112143c:	103ee83a 	callr	r2
81121440:	00bfdb16 	blt	zero,r2,811213b0 <__reset+0xfb1013b0>
81121444:	8080030b 	ldhu	r2,12(r16)
81121448:	10801014 	ori	r2,r2,64
8112144c:	8080030d 	sth	r2,12(r16)
81121450:	00bfffc4 	movi	r2,-1
81121454:	003fab06 	br	81121304 <__reset+0xfb101304>
81121458:	0027883a 	mov	r19,zero
8112145c:	0011883a 	mov	r8,zero
81121460:	0039883a 	mov	fp,zero
81121464:	0025883a 	mov	r18,zero
81121468:	90001f26 	beq	r18,zero,811214e8 <__sfvwrite_r+0x2a4>
8112146c:	40005a26 	beq	r8,zero,811215d8 <__sfvwrite_r+0x394>
81121470:	982d883a 	mov	r22,r19
81121474:	94c0012e 	bgeu	r18,r19,8112147c <__sfvwrite_r+0x238>
81121478:	902d883a 	mov	r22,r18
8112147c:	81000017 	ldw	r4,0(r16)
81121480:	80800417 	ldw	r2,16(r16)
81121484:	b02f883a 	mov	r23,r22
81121488:	81c00517 	ldw	r7,20(r16)
8112148c:	1100032e 	bgeu	r2,r4,8112149c <__sfvwrite_r+0x258>
81121490:	80c00217 	ldw	r3,8(r16)
81121494:	38c7883a 	add	r3,r7,r3
81121498:	1d801816 	blt	r3,r22,811214fc <__sfvwrite_r+0x2b8>
8112149c:	b1c03e16 	blt	r22,r7,81121598 <__sfvwrite_r+0x354>
811214a0:	80800917 	ldw	r2,36(r16)
811214a4:	81400717 	ldw	r5,28(r16)
811214a8:	e00d883a 	mov	r6,fp
811214ac:	da000115 	stw	r8,4(sp)
811214b0:	a809883a 	mov	r4,r21
811214b4:	103ee83a 	callr	r2
811214b8:	102f883a 	mov	r23,r2
811214bc:	da000117 	ldw	r8,4(sp)
811214c0:	00bfe00e 	bge	zero,r2,81121444 <__reset+0xfb101444>
811214c4:	9de7c83a 	sub	r19,r19,r23
811214c8:	98001f26 	beq	r19,zero,81121548 <__sfvwrite_r+0x304>
811214cc:	a0800217 	ldw	r2,8(r20)
811214d0:	e5f9883a 	add	fp,fp,r23
811214d4:	95e5c83a 	sub	r18,r18,r23
811214d8:	15efc83a 	sub	r23,r2,r23
811214dc:	a5c00215 	stw	r23,8(r20)
811214e0:	b83f8726 	beq	r23,zero,81121300 <__reset+0xfb101300>
811214e4:	903fe11e 	bne	r18,zero,8112146c <__reset+0xfb10146c>
811214e8:	8f000017 	ldw	fp,0(r17)
811214ec:	8c800117 	ldw	r18,4(r17)
811214f0:	0011883a 	mov	r8,zero
811214f4:	8c400204 	addi	r17,r17,8
811214f8:	003fdb06 	br	81121468 <__reset+0xfb101468>
811214fc:	180d883a 	mov	r6,r3
81121500:	e00b883a 	mov	r5,fp
81121504:	da000115 	stw	r8,4(sp)
81121508:	d8c00015 	stw	r3,0(sp)
8112150c:	1121da00 	call	81121da0 <memmove>
81121510:	d8c00017 	ldw	r3,0(sp)
81121514:	80800017 	ldw	r2,0(r16)
81121518:	800b883a 	mov	r5,r16
8112151c:	a809883a 	mov	r4,r21
81121520:	10c5883a 	add	r2,r2,r3
81121524:	80800015 	stw	r2,0(r16)
81121528:	d8c00015 	stw	r3,0(sp)
8112152c:	11206980 	call	81120698 <_fflush_r>
81121530:	d8c00017 	ldw	r3,0(sp)
81121534:	da000117 	ldw	r8,4(sp)
81121538:	103fc21e 	bne	r2,zero,81121444 <__reset+0xfb101444>
8112153c:	182f883a 	mov	r23,r3
81121540:	9de7c83a 	sub	r19,r19,r23
81121544:	983fe11e 	bne	r19,zero,811214cc <__reset+0xfb1014cc>
81121548:	800b883a 	mov	r5,r16
8112154c:	a809883a 	mov	r4,r21
81121550:	11206980 	call	81120698 <_fflush_r>
81121554:	103fbb1e 	bne	r2,zero,81121444 <__reset+0xfb101444>
81121558:	0011883a 	mov	r8,zero
8112155c:	003fdb06 	br	811214cc <__reset+0xfb1014cc>
81121560:	94c0012e 	bgeu	r18,r19,81121568 <__sfvwrite_r+0x324>
81121564:	9027883a 	mov	r19,r18
81121568:	980d883a 	mov	r6,r19
8112156c:	e00b883a 	mov	r5,fp
81121570:	1121da00 	call	81121da0 <memmove>
81121574:	80800217 	ldw	r2,8(r16)
81121578:	80c00017 	ldw	r3,0(r16)
8112157c:	14c5c83a 	sub	r2,r2,r19
81121580:	1cc7883a 	add	r3,r3,r19
81121584:	80800215 	stw	r2,8(r16)
81121588:	80c00015 	stw	r3,0(r16)
8112158c:	10004326 	beq	r2,zero,8112169c <__sfvwrite_r+0x458>
81121590:	9805883a 	mov	r2,r19
81121594:	003f8606 	br	811213b0 <__reset+0xfb1013b0>
81121598:	b00d883a 	mov	r6,r22
8112159c:	e00b883a 	mov	r5,fp
811215a0:	da000115 	stw	r8,4(sp)
811215a4:	1121da00 	call	81121da0 <memmove>
811215a8:	80800217 	ldw	r2,8(r16)
811215ac:	80c00017 	ldw	r3,0(r16)
811215b0:	da000117 	ldw	r8,4(sp)
811215b4:	1585c83a 	sub	r2,r2,r22
811215b8:	1dad883a 	add	r22,r3,r22
811215bc:	80800215 	stw	r2,8(r16)
811215c0:	85800015 	stw	r22,0(r16)
811215c4:	003fbf06 	br	811214c4 <__reset+0xfb1014c4>
811215c8:	81000017 	ldw	r4,0(r16)
811215cc:	9027883a 	mov	r19,r18
811215d0:	902f883a 	mov	r23,r18
811215d4:	003f6c06 	br	81121388 <__reset+0xfb101388>
811215d8:	900d883a 	mov	r6,r18
811215dc:	01400284 	movi	r5,10
811215e0:	e009883a 	mov	r4,fp
811215e4:	1121cbc0 	call	81121cbc <memchr>
811215e8:	10003e26 	beq	r2,zero,811216e4 <__sfvwrite_r+0x4a0>
811215ec:	10800044 	addi	r2,r2,1
811215f0:	1727c83a 	sub	r19,r2,fp
811215f4:	02000044 	movi	r8,1
811215f8:	003f9d06 	br	81121470 <__reset+0xfb101470>
811215fc:	80800517 	ldw	r2,20(r16)
81121600:	81400417 	ldw	r5,16(r16)
81121604:	81c00017 	ldw	r7,0(r16)
81121608:	10a7883a 	add	r19,r2,r2
8112160c:	9885883a 	add	r2,r19,r2
81121610:	1026d7fa 	srli	r19,r2,31
81121614:	396dc83a 	sub	r22,r7,r5
81121618:	b1000044 	addi	r4,r22,1
8112161c:	9885883a 	add	r2,r19,r2
81121620:	1027d07a 	srai	r19,r2,1
81121624:	2485883a 	add	r2,r4,r18
81121628:	980d883a 	mov	r6,r19
8112162c:	9880022e 	bgeu	r19,r2,81121638 <__sfvwrite_r+0x3f4>
81121630:	1027883a 	mov	r19,r2
81121634:	100d883a 	mov	r6,r2
81121638:	18c1000c 	andi	r3,r3,1024
8112163c:	18001c26 	beq	r3,zero,811216b0 <__sfvwrite_r+0x46c>
81121640:	300b883a 	mov	r5,r6
81121644:	a809883a 	mov	r4,r21
81121648:	11174b80 	call	811174b8 <_malloc_r>
8112164c:	102f883a 	mov	r23,r2
81121650:	10002926 	beq	r2,zero,811216f8 <__sfvwrite_r+0x4b4>
81121654:	81400417 	ldw	r5,16(r16)
81121658:	b00d883a 	mov	r6,r22
8112165c:	1009883a 	mov	r4,r2
81121660:	1117ccc0 	call	81117ccc <memcpy>
81121664:	8080030b 	ldhu	r2,12(r16)
81121668:	00fedfc4 	movi	r3,-1153
8112166c:	10c4703a 	and	r2,r2,r3
81121670:	10802014 	ori	r2,r2,128
81121674:	8080030d 	sth	r2,12(r16)
81121678:	bd89883a 	add	r4,r23,r22
8112167c:	9d8fc83a 	sub	r7,r19,r22
81121680:	85c00415 	stw	r23,16(r16)
81121684:	84c00515 	stw	r19,20(r16)
81121688:	81000015 	stw	r4,0(r16)
8112168c:	9027883a 	mov	r19,r18
81121690:	81c00215 	stw	r7,8(r16)
81121694:	902f883a 	mov	r23,r18
81121698:	003f3b06 	br	81121388 <__reset+0xfb101388>
8112169c:	800b883a 	mov	r5,r16
811216a0:	a809883a 	mov	r4,r21
811216a4:	11206980 	call	81120698 <_fflush_r>
811216a8:	103fb926 	beq	r2,zero,81121590 <__reset+0xfb101590>
811216ac:	003f6506 	br	81121444 <__reset+0xfb101444>
811216b0:	a809883a 	mov	r4,r21
811216b4:	1122fc00 	call	81122fc0 <_realloc_r>
811216b8:	102f883a 	mov	r23,r2
811216bc:	103fee1e 	bne	r2,zero,81121678 <__reset+0xfb101678>
811216c0:	81400417 	ldw	r5,16(r16)
811216c4:	a809883a 	mov	r4,r21
811216c8:	1120f2c0 	call	81120f2c <_free_r>
811216cc:	8080030b 	ldhu	r2,12(r16)
811216d0:	00ffdfc4 	movi	r3,-129
811216d4:	1884703a 	and	r2,r3,r2
811216d8:	00c00304 	movi	r3,12
811216dc:	a8c00015 	stw	r3,0(r21)
811216e0:	003f5906 	br	81121448 <__reset+0xfb101448>
811216e4:	94c00044 	addi	r19,r18,1
811216e8:	02000044 	movi	r8,1
811216ec:	003f6006 	br	81121470 <__reset+0xfb101470>
811216f0:	00bfffc4 	movi	r2,-1
811216f4:	003f0306 	br	81121304 <__reset+0xfb101304>
811216f8:	00800304 	movi	r2,12
811216fc:	a8800015 	stw	r2,0(r21)
81121700:	8080030b 	ldhu	r2,12(r16)
81121704:	003f5006 	br	81121448 <__reset+0xfb101448>

81121708 <_fwalk>:
81121708:	defff704 	addi	sp,sp,-36
8112170c:	de00012e 	bgeu	sp,et,81121714 <_fwalk+0xc>
81121710:	003b68fa 	trap	3
81121714:	dd000415 	stw	r20,16(sp)
81121718:	dfc00815 	stw	ra,32(sp)
8112171c:	ddc00715 	stw	r23,28(sp)
81121720:	dd800615 	stw	r22,24(sp)
81121724:	dd400515 	stw	r21,20(sp)
81121728:	dcc00315 	stw	r19,12(sp)
8112172c:	dc800215 	stw	r18,8(sp)
81121730:	dc400115 	stw	r17,4(sp)
81121734:	dc000015 	stw	r16,0(sp)
81121738:	2500b804 	addi	r20,r4,736
8112173c:	a0002326 	beq	r20,zero,811217cc <_fwalk+0xc4>
81121740:	282b883a 	mov	r21,r5
81121744:	002f883a 	mov	r23,zero
81121748:	05800044 	movi	r22,1
8112174c:	04ffffc4 	movi	r19,-1
81121750:	a4400117 	ldw	r17,4(r20)
81121754:	a4800217 	ldw	r18,8(r20)
81121758:	8c7fffc4 	addi	r17,r17,-1
8112175c:	88000d16 	blt	r17,zero,81121794 <_fwalk+0x8c>
81121760:	94000304 	addi	r16,r18,12
81121764:	94800384 	addi	r18,r18,14
81121768:	8080000b 	ldhu	r2,0(r16)
8112176c:	8c7fffc4 	addi	r17,r17,-1
81121770:	813ffd04 	addi	r4,r16,-12
81121774:	b080042e 	bgeu	r22,r2,81121788 <_fwalk+0x80>
81121778:	9080000f 	ldh	r2,0(r18)
8112177c:	14c00226 	beq	r2,r19,81121788 <_fwalk+0x80>
81121780:	a83ee83a 	callr	r21
81121784:	b8aeb03a 	or	r23,r23,r2
81121788:	84001a04 	addi	r16,r16,104
8112178c:	94801a04 	addi	r18,r18,104
81121790:	8cfff51e 	bne	r17,r19,81121768 <__reset+0xfb101768>
81121794:	a5000017 	ldw	r20,0(r20)
81121798:	a03fed1e 	bne	r20,zero,81121750 <__reset+0xfb101750>
8112179c:	b805883a 	mov	r2,r23
811217a0:	dfc00817 	ldw	ra,32(sp)
811217a4:	ddc00717 	ldw	r23,28(sp)
811217a8:	dd800617 	ldw	r22,24(sp)
811217ac:	dd400517 	ldw	r21,20(sp)
811217b0:	dd000417 	ldw	r20,16(sp)
811217b4:	dcc00317 	ldw	r19,12(sp)
811217b8:	dc800217 	ldw	r18,8(sp)
811217bc:	dc400117 	ldw	r17,4(sp)
811217c0:	dc000017 	ldw	r16,0(sp)
811217c4:	dec00904 	addi	sp,sp,36
811217c8:	f800283a 	ret
811217cc:	002f883a 	mov	r23,zero
811217d0:	003ff206 	br	8112179c <__reset+0xfb10179c>

811217d4 <_fwalk_reent>:
811217d4:	defff704 	addi	sp,sp,-36
811217d8:	de00012e 	bgeu	sp,et,811217e0 <_fwalk_reent+0xc>
811217dc:	003b68fa 	trap	3
811217e0:	dd000415 	stw	r20,16(sp)
811217e4:	dfc00815 	stw	ra,32(sp)
811217e8:	ddc00715 	stw	r23,28(sp)
811217ec:	dd800615 	stw	r22,24(sp)
811217f0:	dd400515 	stw	r21,20(sp)
811217f4:	dcc00315 	stw	r19,12(sp)
811217f8:	dc800215 	stw	r18,8(sp)
811217fc:	dc400115 	stw	r17,4(sp)
81121800:	dc000015 	stw	r16,0(sp)
81121804:	2500b804 	addi	r20,r4,736
81121808:	a0002326 	beq	r20,zero,81121898 <_fwalk_reent+0xc4>
8112180c:	282b883a 	mov	r21,r5
81121810:	2027883a 	mov	r19,r4
81121814:	002f883a 	mov	r23,zero
81121818:	05800044 	movi	r22,1
8112181c:	04bfffc4 	movi	r18,-1
81121820:	a4400117 	ldw	r17,4(r20)
81121824:	a4000217 	ldw	r16,8(r20)
81121828:	8c7fffc4 	addi	r17,r17,-1
8112182c:	88000c16 	blt	r17,zero,81121860 <_fwalk_reent+0x8c>
81121830:	84000304 	addi	r16,r16,12
81121834:	8080000b 	ldhu	r2,0(r16)
81121838:	8c7fffc4 	addi	r17,r17,-1
8112183c:	817ffd04 	addi	r5,r16,-12
81121840:	b080052e 	bgeu	r22,r2,81121858 <_fwalk_reent+0x84>
81121844:	8080008f 	ldh	r2,2(r16)
81121848:	9809883a 	mov	r4,r19
8112184c:	14800226 	beq	r2,r18,81121858 <_fwalk_reent+0x84>
81121850:	a83ee83a 	callr	r21
81121854:	b8aeb03a 	or	r23,r23,r2
81121858:	84001a04 	addi	r16,r16,104
8112185c:	8cbff51e 	bne	r17,r18,81121834 <__reset+0xfb101834>
81121860:	a5000017 	ldw	r20,0(r20)
81121864:	a03fee1e 	bne	r20,zero,81121820 <__reset+0xfb101820>
81121868:	b805883a 	mov	r2,r23
8112186c:	dfc00817 	ldw	ra,32(sp)
81121870:	ddc00717 	ldw	r23,28(sp)
81121874:	dd800617 	ldw	r22,24(sp)
81121878:	dd400517 	ldw	r21,20(sp)
8112187c:	dd000417 	ldw	r20,16(sp)
81121880:	dcc00317 	ldw	r19,12(sp)
81121884:	dc800217 	ldw	r18,8(sp)
81121888:	dc400117 	ldw	r17,4(sp)
8112188c:	dc000017 	ldw	r16,0(sp)
81121890:	dec00904 	addi	sp,sp,36
81121894:	f800283a 	ret
81121898:	002f883a 	mov	r23,zero
8112189c:	003ff206 	br	81121868 <__reset+0xfb101868>

811218a0 <_isatty_r>:
811218a0:	defffd04 	addi	sp,sp,-12
811218a4:	de00012e 	bgeu	sp,et,811218ac <_isatty_r+0xc>
811218a8:	003b68fa 	trap	3
811218ac:	dc000015 	stw	r16,0(sp)
811218b0:	04204574 	movhi	r16,33045
811218b4:	dc400115 	stw	r17,4(sp)
811218b8:	84216604 	addi	r16,r16,-31336
811218bc:	2023883a 	mov	r17,r4
811218c0:	2809883a 	mov	r4,r5
811218c4:	dfc00215 	stw	ra,8(sp)
811218c8:	80000015 	stw	zero,0(r16)
811218cc:	112c9f00 	call	8112c9f0 <isatty>
811218d0:	00ffffc4 	movi	r3,-1
811218d4:	10c00526 	beq	r2,r3,811218ec <_isatty_r+0x4c>
811218d8:	dfc00217 	ldw	ra,8(sp)
811218dc:	dc400117 	ldw	r17,4(sp)
811218e0:	dc000017 	ldw	r16,0(sp)
811218e4:	dec00304 	addi	sp,sp,12
811218e8:	f800283a 	ret
811218ec:	80c00017 	ldw	r3,0(r16)
811218f0:	183ff926 	beq	r3,zero,811218d8 <__reset+0xfb1018d8>
811218f4:	88c00015 	stw	r3,0(r17)
811218f8:	003ff706 	br	811218d8 <__reset+0xfb1018d8>

811218fc <iswspace>:
811218fc:	00803fc4 	movi	r2,255
81121900:	11000836 	bltu	r2,r4,81121924 <iswspace+0x28>
81121904:	00a04574 	movhi	r2,33045
81121908:	10a10004 	addi	r2,r2,-31744
8112190c:	10800017 	ldw	r2,0(r2)
81121910:	1109883a 	add	r4,r2,r4
81121914:	20800043 	ldbu	r2,1(r4)
81121918:	1080020c 	andi	r2,r2,8
8112191c:	10803fcc 	andi	r2,r2,255
81121920:	f800283a 	ret
81121924:	0005883a 	mov	r2,zero
81121928:	f800283a 	ret

8112192c <_setlocale_r>:
8112192c:	30001d26 	beq	r6,zero,811219a4 <_setlocale_r+0x78>
81121930:	01604534 	movhi	r5,33044
81121934:	defffe04 	addi	sp,sp,-8
81121938:	29575904 	addi	r5,r5,23908
8112193c:	3009883a 	mov	r4,r6
81121940:	de00012e 	bgeu	sp,et,81121948 <_setlocale_r+0x1c>
81121944:	003b68fa 	trap	3
81121948:	dc000015 	stw	r16,0(sp)
8112194c:	dfc00115 	stw	ra,4(sp)
81121950:	3021883a 	mov	r16,r6
81121954:	11236780 	call	81123678 <strcmp>
81121958:	1000061e 	bne	r2,zero,81121974 <_setlocale_r+0x48>
8112195c:	00a04534 	movhi	r2,33044
81121960:	10972804 	addi	r2,r2,23712
81121964:	dfc00117 	ldw	ra,4(sp)
81121968:	dc000017 	ldw	r16,0(sp)
8112196c:	dec00204 	addi	sp,sp,8
81121970:	f800283a 	ret
81121974:	01604534 	movhi	r5,33044
81121978:	29572804 	addi	r5,r5,23712
8112197c:	8009883a 	mov	r4,r16
81121980:	11236780 	call	81123678 <strcmp>
81121984:	103ff526 	beq	r2,zero,8112195c <__reset+0xfb10195c>
81121988:	01604534 	movhi	r5,33044
8112198c:	29573204 	addi	r5,r5,23752
81121990:	8009883a 	mov	r4,r16
81121994:	11236780 	call	81123678 <strcmp>
81121998:	103ff026 	beq	r2,zero,8112195c <__reset+0xfb10195c>
8112199c:	0005883a 	mov	r2,zero
811219a0:	003ff006 	br	81121964 <__reset+0xfb101964>
811219a4:	00a04534 	movhi	r2,33044
811219a8:	10972804 	addi	r2,r2,23712
811219ac:	f800283a 	ret

811219b0 <__locale_charset>:
811219b0:	00a04534 	movhi	r2,33044
811219b4:	109bca04 	addi	r2,r2,28456
811219b8:	f800283a 	ret

811219bc <__locale_mb_cur_max>:
811219bc:	00a04574 	movhi	r2,33045
811219c0:	10a10504 	addi	r2,r2,-31724
811219c4:	10800017 	ldw	r2,0(r2)
811219c8:	f800283a 	ret

811219cc <__locale_msgcharset>:
811219cc:	00a04534 	movhi	r2,33044
811219d0:	109bc204 	addi	r2,r2,28424
811219d4:	f800283a 	ret

811219d8 <__locale_cjk_lang>:
811219d8:	0005883a 	mov	r2,zero
811219dc:	f800283a 	ret

811219e0 <_localeconv_r>:
811219e0:	00a04534 	movhi	r2,33044
811219e4:	109bd204 	addi	r2,r2,28488
811219e8:	f800283a 	ret

811219ec <setlocale>:
811219ec:	00a04574 	movhi	r2,33045
811219f0:	10a10204 	addi	r2,r2,-31736
811219f4:	280d883a 	mov	r6,r5
811219f8:	200b883a 	mov	r5,r4
811219fc:	11000017 	ldw	r4,0(r2)
81121a00:	112192c1 	jmpi	8112192c <_setlocale_r>

81121a04 <localeconv>:
81121a04:	00a04534 	movhi	r2,33044
81121a08:	109bd204 	addi	r2,r2,28488
81121a0c:	f800283a 	ret

81121a10 <_lseek_r>:
81121a10:	defffd04 	addi	sp,sp,-12
81121a14:	de00012e 	bgeu	sp,et,81121a1c <_lseek_r+0xc>
81121a18:	003b68fa 	trap	3
81121a1c:	2805883a 	mov	r2,r5
81121a20:	dc000015 	stw	r16,0(sp)
81121a24:	04204574 	movhi	r16,33045
81121a28:	dc400115 	stw	r17,4(sp)
81121a2c:	300b883a 	mov	r5,r6
81121a30:	84216604 	addi	r16,r16,-31336
81121a34:	2023883a 	mov	r17,r4
81121a38:	380d883a 	mov	r6,r7
81121a3c:	1009883a 	mov	r4,r2
81121a40:	dfc00215 	stw	ra,8(sp)
81121a44:	80000015 	stw	zero,0(r16)
81121a48:	112d5ec0 	call	8112d5ec <lseek>
81121a4c:	00ffffc4 	movi	r3,-1
81121a50:	10c00526 	beq	r2,r3,81121a68 <_lseek_r+0x58>
81121a54:	dfc00217 	ldw	ra,8(sp)
81121a58:	dc400117 	ldw	r17,4(sp)
81121a5c:	dc000017 	ldw	r16,0(sp)
81121a60:	dec00304 	addi	sp,sp,12
81121a64:	f800283a 	ret
81121a68:	80c00017 	ldw	r3,0(r16)
81121a6c:	183ff926 	beq	r3,zero,81121a54 <__reset+0xfb101a54>
81121a70:	88c00015 	stw	r3,0(r17)
81121a74:	003ff706 	br	81121a54 <__reset+0xfb101a54>

81121a78 <_mbrtowc_r>:
81121a78:	defff704 	addi	sp,sp,-36
81121a7c:	00a04574 	movhi	r2,33045
81121a80:	de00012e 	bgeu	sp,et,81121a88 <_mbrtowc_r+0x10>
81121a84:	003b68fa 	trap	3
81121a88:	10a10604 	addi	r2,r2,-31720
81121a8c:	dc800715 	stw	r18,28(sp)
81121a90:	dc400615 	stw	r17,24(sp)
81121a94:	dc000515 	stw	r16,20(sp)
81121a98:	dfc00815 	stw	ra,32(sp)
81121a9c:	2021883a 	mov	r16,r4
81121aa0:	dc400917 	ldw	r17,36(sp)
81121aa4:	14800017 	ldw	r18,0(r2)
81121aa8:	30001626 	beq	r6,zero,81121b04 <_mbrtowc_r+0x8c>
81121aac:	d9400215 	stw	r5,8(sp)
81121ab0:	d9800315 	stw	r6,12(sp)
81121ab4:	d9c00415 	stw	r7,16(sp)
81121ab8:	11219b00 	call	811219b0 <__locale_charset>
81121abc:	d9c00417 	ldw	r7,16(sp)
81121ac0:	d9800317 	ldw	r6,12(sp)
81121ac4:	d9400217 	ldw	r5,8(sp)
81121ac8:	d8800015 	stw	r2,0(sp)
81121acc:	dc400115 	stw	r17,4(sp)
81121ad0:	8009883a 	mov	r4,r16
81121ad4:	903ee83a 	callr	r18
81121ad8:	00ffffc4 	movi	r3,-1
81121adc:	10c0031e 	bne	r2,r3,81121aec <_mbrtowc_r+0x74>
81121ae0:	88000015 	stw	zero,0(r17)
81121ae4:	00c02284 	movi	r3,138
81121ae8:	80c00015 	stw	r3,0(r16)
81121aec:	dfc00817 	ldw	ra,32(sp)
81121af0:	dc800717 	ldw	r18,28(sp)
81121af4:	dc400617 	ldw	r17,24(sp)
81121af8:	dc000517 	ldw	r16,20(sp)
81121afc:	dec00904 	addi	sp,sp,36
81121b00:	f800283a 	ret
81121b04:	11219b00 	call	811219b0 <__locale_charset>
81121b08:	01a04534 	movhi	r6,33044
81121b0c:	31973204 	addi	r6,r6,23752
81121b10:	dc400115 	stw	r17,4(sp)
81121b14:	d8800015 	stw	r2,0(sp)
81121b18:	01c00044 	movi	r7,1
81121b1c:	000b883a 	mov	r5,zero
81121b20:	8009883a 	mov	r4,r16
81121b24:	903ee83a 	callr	r18
81121b28:	003feb06 	br	81121ad8 <__reset+0xfb101ad8>

81121b2c <mbrtowc>:
81121b2c:	defff704 	addi	sp,sp,-36
81121b30:	00a04574 	movhi	r2,33045
81121b34:	de00012e 	bgeu	sp,et,81121b3c <mbrtowc+0x10>
81121b38:	003b68fa 	trap	3
81121b3c:	10a10204 	addi	r2,r2,-31736
81121b40:	dc800415 	stw	r18,16(sp)
81121b44:	dc400315 	stw	r17,12(sp)
81121b48:	dfc00815 	stw	ra,32(sp)
81121b4c:	dd400715 	stw	r21,28(sp)
81121b50:	dd000615 	stw	r20,24(sp)
81121b54:	dcc00515 	stw	r19,20(sp)
81121b58:	dc000215 	stw	r16,8(sp)
81121b5c:	3825883a 	mov	r18,r7
81121b60:	14400017 	ldw	r17,0(r2)
81121b64:	28001c26 	beq	r5,zero,81121bd8 <mbrtowc+0xac>
81121b68:	00a04574 	movhi	r2,33045
81121b6c:	10a10604 	addi	r2,r2,-31720
81121b70:	15400017 	ldw	r21,0(r2)
81121b74:	2821883a 	mov	r16,r5
81121b78:	2027883a 	mov	r19,r4
81121b7c:	3029883a 	mov	r20,r6
81121b80:	11219b00 	call	811219b0 <__locale_charset>
81121b84:	d8800015 	stw	r2,0(sp)
81121b88:	dc800115 	stw	r18,4(sp)
81121b8c:	a00f883a 	mov	r7,r20
81121b90:	800d883a 	mov	r6,r16
81121b94:	980b883a 	mov	r5,r19
81121b98:	8809883a 	mov	r4,r17
81121b9c:	a83ee83a 	callr	r21
81121ba0:	00ffffc4 	movi	r3,-1
81121ba4:	10c0031e 	bne	r2,r3,81121bb4 <mbrtowc+0x88>
81121ba8:	90000015 	stw	zero,0(r18)
81121bac:	00c02284 	movi	r3,138
81121bb0:	88c00015 	stw	r3,0(r17)
81121bb4:	dfc00817 	ldw	ra,32(sp)
81121bb8:	dd400717 	ldw	r21,28(sp)
81121bbc:	dd000617 	ldw	r20,24(sp)
81121bc0:	dcc00517 	ldw	r19,20(sp)
81121bc4:	dc800417 	ldw	r18,16(sp)
81121bc8:	dc400317 	ldw	r17,12(sp)
81121bcc:	dc000217 	ldw	r16,8(sp)
81121bd0:	dec00904 	addi	sp,sp,36
81121bd4:	f800283a 	ret
81121bd8:	00a04574 	movhi	r2,33045
81121bdc:	10a10604 	addi	r2,r2,-31720
81121be0:	14000017 	ldw	r16,0(r2)
81121be4:	11219b00 	call	811219b0 <__locale_charset>
81121be8:	01a04534 	movhi	r6,33044
81121bec:	31973204 	addi	r6,r6,23752
81121bf0:	dc800115 	stw	r18,4(sp)
81121bf4:	d8800015 	stw	r2,0(sp)
81121bf8:	01c00044 	movi	r7,1
81121bfc:	000b883a 	mov	r5,zero
81121c00:	8809883a 	mov	r4,r17
81121c04:	803ee83a 	callr	r16
81121c08:	003fe506 	br	81121ba0 <__reset+0xfb101ba0>

81121c0c <__ascii_mbtowc>:
81121c0c:	deffff04 	addi	sp,sp,-4
81121c10:	de00012e 	bgeu	sp,et,81121c18 <__ascii_mbtowc+0xc>
81121c14:	003b68fa 	trap	3
81121c18:	28000826 	beq	r5,zero,81121c3c <__ascii_mbtowc+0x30>
81121c1c:	30000926 	beq	r6,zero,81121c44 <__ascii_mbtowc+0x38>
81121c20:	38000b26 	beq	r7,zero,81121c50 <__ascii_mbtowc+0x44>
81121c24:	30800003 	ldbu	r2,0(r6)
81121c28:	28800015 	stw	r2,0(r5)
81121c2c:	30800003 	ldbu	r2,0(r6)
81121c30:	1004c03a 	cmpne	r2,r2,zero
81121c34:	dec00104 	addi	sp,sp,4
81121c38:	f800283a 	ret
81121c3c:	d80b883a 	mov	r5,sp
81121c40:	303ff71e 	bne	r6,zero,81121c20 <__reset+0xfb101c20>
81121c44:	0005883a 	mov	r2,zero
81121c48:	dec00104 	addi	sp,sp,4
81121c4c:	f800283a 	ret
81121c50:	00bfff84 	movi	r2,-2
81121c54:	003ff706 	br	81121c34 <__reset+0xfb101c34>

81121c58 <_mbtowc_r>:
81121c58:	00a04574 	movhi	r2,33045
81121c5c:	defff804 	addi	sp,sp,-32
81121c60:	10a10604 	addi	r2,r2,-31720
81121c64:	de00012e 	bgeu	sp,et,81121c6c <_mbtowc_r+0x14>
81121c68:	003b68fa 	trap	3
81121c6c:	dfc00715 	stw	ra,28(sp)
81121c70:	dc000615 	stw	r16,24(sp)
81121c74:	14000017 	ldw	r16,0(r2)
81121c78:	d9000215 	stw	r4,8(sp)
81121c7c:	d9400315 	stw	r5,12(sp)
81121c80:	d9800415 	stw	r6,16(sp)
81121c84:	d9c00515 	stw	r7,20(sp)
81121c88:	11219b00 	call	811219b0 <__locale_charset>
81121c8c:	d8800015 	stw	r2,0(sp)
81121c90:	d8800817 	ldw	r2,32(sp)
81121c94:	d9c00517 	ldw	r7,20(sp)
81121c98:	d9800417 	ldw	r6,16(sp)
81121c9c:	d9400317 	ldw	r5,12(sp)
81121ca0:	d9000217 	ldw	r4,8(sp)
81121ca4:	d8800115 	stw	r2,4(sp)
81121ca8:	803ee83a 	callr	r16
81121cac:	dfc00717 	ldw	ra,28(sp)
81121cb0:	dc000617 	ldw	r16,24(sp)
81121cb4:	dec00804 	addi	sp,sp,32
81121cb8:	f800283a 	ret

81121cbc <memchr>:
81121cbc:	208000cc 	andi	r2,r4,3
81121cc0:	280f883a 	mov	r7,r5
81121cc4:	10003426 	beq	r2,zero,81121d98 <memchr+0xdc>
81121cc8:	30bfffc4 	addi	r2,r6,-1
81121ccc:	30001a26 	beq	r6,zero,81121d38 <memchr+0x7c>
81121cd0:	20c00003 	ldbu	r3,0(r4)
81121cd4:	29803fcc 	andi	r6,r5,255
81121cd8:	30c0051e 	bne	r6,r3,81121cf0 <memchr+0x34>
81121cdc:	00001806 	br	81121d40 <memchr+0x84>
81121ce0:	10001526 	beq	r2,zero,81121d38 <memchr+0x7c>
81121ce4:	20c00003 	ldbu	r3,0(r4)
81121ce8:	10bfffc4 	addi	r2,r2,-1
81121cec:	30c01426 	beq	r6,r3,81121d40 <memchr+0x84>
81121cf0:	21000044 	addi	r4,r4,1
81121cf4:	20c000cc 	andi	r3,r4,3
81121cf8:	183ff91e 	bne	r3,zero,81121ce0 <__reset+0xfb101ce0>
81121cfc:	020000c4 	movi	r8,3
81121d00:	40801136 	bltu	r8,r2,81121d48 <memchr+0x8c>
81121d04:	10000c26 	beq	r2,zero,81121d38 <memchr+0x7c>
81121d08:	20c00003 	ldbu	r3,0(r4)
81121d0c:	29403fcc 	andi	r5,r5,255
81121d10:	28c00b26 	beq	r5,r3,81121d40 <memchr+0x84>
81121d14:	20c00044 	addi	r3,r4,1
81121d18:	39803fcc 	andi	r6,r7,255
81121d1c:	2089883a 	add	r4,r4,r2
81121d20:	00000306 	br	81121d30 <memchr+0x74>
81121d24:	18c00044 	addi	r3,r3,1
81121d28:	197fffc3 	ldbu	r5,-1(r3)
81121d2c:	31400526 	beq	r6,r5,81121d44 <memchr+0x88>
81121d30:	1805883a 	mov	r2,r3
81121d34:	20fffb1e 	bne	r4,r3,81121d24 <__reset+0xfb101d24>
81121d38:	0005883a 	mov	r2,zero
81121d3c:	f800283a 	ret
81121d40:	2005883a 	mov	r2,r4
81121d44:	f800283a 	ret
81121d48:	28c03fcc 	andi	r3,r5,255
81121d4c:	1812923a 	slli	r9,r3,8
81121d50:	02ffbff4 	movhi	r11,65279
81121d54:	02a02074 	movhi	r10,32897
81121d58:	48d2b03a 	or	r9,r9,r3
81121d5c:	4806943a 	slli	r3,r9,16
81121d60:	5affbfc4 	addi	r11,r11,-257
81121d64:	52a02004 	addi	r10,r10,-32640
81121d68:	48d2b03a 	or	r9,r9,r3
81121d6c:	20c00017 	ldw	r3,0(r4)
81121d70:	48c6f03a 	xor	r3,r9,r3
81121d74:	1acd883a 	add	r6,r3,r11
81121d78:	00c6303a 	nor	r3,zero,r3
81121d7c:	30c6703a 	and	r3,r6,r3
81121d80:	1a86703a 	and	r3,r3,r10
81121d84:	183fe01e 	bne	r3,zero,81121d08 <__reset+0xfb101d08>
81121d88:	10bfff04 	addi	r2,r2,-4
81121d8c:	21000104 	addi	r4,r4,4
81121d90:	40bff636 	bltu	r8,r2,81121d6c <__reset+0xfb101d6c>
81121d94:	003fdb06 	br	81121d04 <__reset+0xfb101d04>
81121d98:	3005883a 	mov	r2,r6
81121d9c:	003fd706 	br	81121cfc <__reset+0xfb101cfc>

81121da0 <memmove>:
81121da0:	2005883a 	mov	r2,r4
81121da4:	29000b2e 	bgeu	r5,r4,81121dd4 <memmove+0x34>
81121da8:	298f883a 	add	r7,r5,r6
81121dac:	21c0092e 	bgeu	r4,r7,81121dd4 <memmove+0x34>
81121db0:	2187883a 	add	r3,r4,r6
81121db4:	198bc83a 	sub	r5,r3,r6
81121db8:	30004826 	beq	r6,zero,81121edc <memmove+0x13c>
81121dbc:	39ffffc4 	addi	r7,r7,-1
81121dc0:	39000003 	ldbu	r4,0(r7)
81121dc4:	18ffffc4 	addi	r3,r3,-1
81121dc8:	19000005 	stb	r4,0(r3)
81121dcc:	28fffb1e 	bne	r5,r3,81121dbc <__reset+0xfb101dbc>
81121dd0:	f800283a 	ret
81121dd4:	00c003c4 	movi	r3,15
81121dd8:	1980412e 	bgeu	r3,r6,81121ee0 <memmove+0x140>
81121ddc:	2886b03a 	or	r3,r5,r2
81121de0:	18c000cc 	andi	r3,r3,3
81121de4:	1800401e 	bne	r3,zero,81121ee8 <memmove+0x148>
81121de8:	33fffc04 	addi	r15,r6,-16
81121dec:	781ed13a 	srli	r15,r15,4
81121df0:	28c00104 	addi	r3,r5,4
81121df4:	13400104 	addi	r13,r2,4
81121df8:	781c913a 	slli	r14,r15,4
81121dfc:	2b000204 	addi	r12,r5,8
81121e00:	12c00204 	addi	r11,r2,8
81121e04:	73800504 	addi	r14,r14,20
81121e08:	2a800304 	addi	r10,r5,12
81121e0c:	12400304 	addi	r9,r2,12
81121e10:	2b9d883a 	add	r14,r5,r14
81121e14:	2811883a 	mov	r8,r5
81121e18:	100f883a 	mov	r7,r2
81121e1c:	41000017 	ldw	r4,0(r8)
81121e20:	39c00404 	addi	r7,r7,16
81121e24:	18c00404 	addi	r3,r3,16
81121e28:	393ffc15 	stw	r4,-16(r7)
81121e2c:	193ffc17 	ldw	r4,-16(r3)
81121e30:	6b400404 	addi	r13,r13,16
81121e34:	5ac00404 	addi	r11,r11,16
81121e38:	693ffc15 	stw	r4,-16(r13)
81121e3c:	61000017 	ldw	r4,0(r12)
81121e40:	4a400404 	addi	r9,r9,16
81121e44:	42000404 	addi	r8,r8,16
81121e48:	593ffc15 	stw	r4,-16(r11)
81121e4c:	51000017 	ldw	r4,0(r10)
81121e50:	63000404 	addi	r12,r12,16
81121e54:	52800404 	addi	r10,r10,16
81121e58:	493ffc15 	stw	r4,-16(r9)
81121e5c:	1bbfef1e 	bne	r3,r14,81121e1c <__reset+0xfb101e1c>
81121e60:	79000044 	addi	r4,r15,1
81121e64:	2008913a 	slli	r4,r4,4
81121e68:	328003cc 	andi	r10,r6,15
81121e6c:	02c000c4 	movi	r11,3
81121e70:	1107883a 	add	r3,r2,r4
81121e74:	290b883a 	add	r5,r5,r4
81121e78:	5a801e2e 	bgeu	r11,r10,81121ef4 <memmove+0x154>
81121e7c:	1813883a 	mov	r9,r3
81121e80:	2811883a 	mov	r8,r5
81121e84:	500f883a 	mov	r7,r10
81121e88:	41000017 	ldw	r4,0(r8)
81121e8c:	4a400104 	addi	r9,r9,4
81121e90:	39ffff04 	addi	r7,r7,-4
81121e94:	493fff15 	stw	r4,-4(r9)
81121e98:	42000104 	addi	r8,r8,4
81121e9c:	59fffa36 	bltu	r11,r7,81121e88 <__reset+0xfb101e88>
81121ea0:	513fff04 	addi	r4,r10,-4
81121ea4:	2008d0ba 	srli	r4,r4,2
81121ea8:	318000cc 	andi	r6,r6,3
81121eac:	21000044 	addi	r4,r4,1
81121eb0:	2109883a 	add	r4,r4,r4
81121eb4:	2109883a 	add	r4,r4,r4
81121eb8:	1907883a 	add	r3,r3,r4
81121ebc:	290b883a 	add	r5,r5,r4
81121ec0:	30000b26 	beq	r6,zero,81121ef0 <memmove+0x150>
81121ec4:	198d883a 	add	r6,r3,r6
81121ec8:	29c00003 	ldbu	r7,0(r5)
81121ecc:	18c00044 	addi	r3,r3,1
81121ed0:	29400044 	addi	r5,r5,1
81121ed4:	19ffffc5 	stb	r7,-1(r3)
81121ed8:	19bffb1e 	bne	r3,r6,81121ec8 <__reset+0xfb101ec8>
81121edc:	f800283a 	ret
81121ee0:	1007883a 	mov	r3,r2
81121ee4:	003ff606 	br	81121ec0 <__reset+0xfb101ec0>
81121ee8:	1007883a 	mov	r3,r2
81121eec:	003ff506 	br	81121ec4 <__reset+0xfb101ec4>
81121ef0:	f800283a 	ret
81121ef4:	500d883a 	mov	r6,r10
81121ef8:	003ff106 	br	81121ec0 <__reset+0xfb101ec0>

81121efc <_Balloc>:
81121efc:	defffc04 	addi	sp,sp,-16
81121f00:	de00012e 	bgeu	sp,et,81121f08 <_Balloc+0xc>
81121f04:	003b68fa 	trap	3
81121f08:	20801317 	ldw	r2,76(r4)
81121f0c:	dc400115 	stw	r17,4(sp)
81121f10:	dc000015 	stw	r16,0(sp)
81121f14:	dfc00315 	stw	ra,12(sp)
81121f18:	dc800215 	stw	r18,8(sp)
81121f1c:	2023883a 	mov	r17,r4
81121f20:	2821883a 	mov	r16,r5
81121f24:	10000f26 	beq	r2,zero,81121f64 <_Balloc+0x68>
81121f28:	8407883a 	add	r3,r16,r16
81121f2c:	18c7883a 	add	r3,r3,r3
81121f30:	10c7883a 	add	r3,r2,r3
81121f34:	18800017 	ldw	r2,0(r3)
81121f38:	10001126 	beq	r2,zero,81121f80 <_Balloc+0x84>
81121f3c:	11000017 	ldw	r4,0(r2)
81121f40:	19000015 	stw	r4,0(r3)
81121f44:	10000415 	stw	zero,16(r2)
81121f48:	10000315 	stw	zero,12(r2)
81121f4c:	dfc00317 	ldw	ra,12(sp)
81121f50:	dc800217 	ldw	r18,8(sp)
81121f54:	dc400117 	ldw	r17,4(sp)
81121f58:	dc000017 	ldw	r16,0(sp)
81121f5c:	dec00404 	addi	sp,sp,16
81121f60:	f800283a 	ret
81121f64:	01800844 	movi	r6,33
81121f68:	01400104 	movi	r5,4
81121f6c:	11284240 	call	81128424 <_calloc_r>
81121f70:	88801315 	stw	r2,76(r17)
81121f74:	103fec1e 	bne	r2,zero,81121f28 <__reset+0xfb101f28>
81121f78:	0005883a 	mov	r2,zero
81121f7c:	003ff306 	br	81121f4c <__reset+0xfb101f4c>
81121f80:	01400044 	movi	r5,1
81121f84:	2c24983a 	sll	r18,r5,r16
81121f88:	8809883a 	mov	r4,r17
81121f8c:	91800144 	addi	r6,r18,5
81121f90:	318d883a 	add	r6,r6,r6
81121f94:	318d883a 	add	r6,r6,r6
81121f98:	11284240 	call	81128424 <_calloc_r>
81121f9c:	103ff626 	beq	r2,zero,81121f78 <__reset+0xfb101f78>
81121fa0:	14000115 	stw	r16,4(r2)
81121fa4:	14800215 	stw	r18,8(r2)
81121fa8:	003fe606 	br	81121f44 <__reset+0xfb101f44>

81121fac <_Bfree>:
81121fac:	28000826 	beq	r5,zero,81121fd0 <_Bfree+0x24>
81121fb0:	28c00117 	ldw	r3,4(r5)
81121fb4:	20801317 	ldw	r2,76(r4)
81121fb8:	18c7883a 	add	r3,r3,r3
81121fbc:	18c7883a 	add	r3,r3,r3
81121fc0:	10c5883a 	add	r2,r2,r3
81121fc4:	10c00017 	ldw	r3,0(r2)
81121fc8:	28c00015 	stw	r3,0(r5)
81121fcc:	11400015 	stw	r5,0(r2)
81121fd0:	f800283a 	ret

81121fd4 <__multadd>:
81121fd4:	defffa04 	addi	sp,sp,-24
81121fd8:	de00012e 	bgeu	sp,et,81121fe0 <__multadd+0xc>
81121fdc:	003b68fa 	trap	3
81121fe0:	0011883a 	mov	r8,zero
81121fe4:	dc800315 	stw	r18,12(sp)
81121fe8:	dc400215 	stw	r17,8(sp)
81121fec:	dc000115 	stw	r16,4(sp)
81121ff0:	2823883a 	mov	r17,r5
81121ff4:	2c000417 	ldw	r16,16(r5)
81121ff8:	dfc00515 	stw	ra,20(sp)
81121ffc:	dcc00415 	stw	r19,16(sp)
81122000:	2025883a 	mov	r18,r4
81122004:	29400504 	addi	r5,r5,20
81122008:	28c00017 	ldw	r3,0(r5)
8112200c:	29400104 	addi	r5,r5,4
81122010:	42000044 	addi	r8,r8,1
81122014:	18bfffcc 	andi	r2,r3,65535
81122018:	1185383a 	mul	r2,r2,r6
8112201c:	1806d43a 	srli	r3,r3,16
81122020:	11cf883a 	add	r7,r2,r7
81122024:	3808d43a 	srli	r4,r7,16
81122028:	1987383a 	mul	r3,r3,r6
8112202c:	38bfffcc 	andi	r2,r7,65535
81122030:	1907883a 	add	r3,r3,r4
81122034:	1808943a 	slli	r4,r3,16
81122038:	180ed43a 	srli	r7,r3,16
8112203c:	2085883a 	add	r2,r4,r2
81122040:	28bfff15 	stw	r2,-4(r5)
81122044:	443ff016 	blt	r8,r16,81122008 <__reset+0xfb102008>
81122048:	38000926 	beq	r7,zero,81122070 <__multadd+0x9c>
8112204c:	88800217 	ldw	r2,8(r17)
81122050:	80800f0e 	bge	r16,r2,81122090 <__multadd+0xbc>
81122054:	80800144 	addi	r2,r16,5
81122058:	1085883a 	add	r2,r2,r2
8112205c:	1085883a 	add	r2,r2,r2
81122060:	8885883a 	add	r2,r17,r2
81122064:	11c00015 	stw	r7,0(r2)
81122068:	84000044 	addi	r16,r16,1
8112206c:	8c000415 	stw	r16,16(r17)
81122070:	8805883a 	mov	r2,r17
81122074:	dfc00517 	ldw	ra,20(sp)
81122078:	dcc00417 	ldw	r19,16(sp)
8112207c:	dc800317 	ldw	r18,12(sp)
81122080:	dc400217 	ldw	r17,8(sp)
81122084:	dc000117 	ldw	r16,4(sp)
81122088:	dec00604 	addi	sp,sp,24
8112208c:	f800283a 	ret
81122090:	89400117 	ldw	r5,4(r17)
81122094:	9009883a 	mov	r4,r18
81122098:	d9c00015 	stw	r7,0(sp)
8112209c:	29400044 	addi	r5,r5,1
811220a0:	1121efc0 	call	81121efc <_Balloc>
811220a4:	89800417 	ldw	r6,16(r17)
811220a8:	89400304 	addi	r5,r17,12
811220ac:	11000304 	addi	r4,r2,12
811220b0:	31800084 	addi	r6,r6,2
811220b4:	318d883a 	add	r6,r6,r6
811220b8:	318d883a 	add	r6,r6,r6
811220bc:	1027883a 	mov	r19,r2
811220c0:	1117ccc0 	call	81117ccc <memcpy>
811220c4:	d9c00017 	ldw	r7,0(sp)
811220c8:	88000a26 	beq	r17,zero,811220f4 <__multadd+0x120>
811220cc:	88c00117 	ldw	r3,4(r17)
811220d0:	90801317 	ldw	r2,76(r18)
811220d4:	18c7883a 	add	r3,r3,r3
811220d8:	18c7883a 	add	r3,r3,r3
811220dc:	10c5883a 	add	r2,r2,r3
811220e0:	10c00017 	ldw	r3,0(r2)
811220e4:	88c00015 	stw	r3,0(r17)
811220e8:	14400015 	stw	r17,0(r2)
811220ec:	9823883a 	mov	r17,r19
811220f0:	003fd806 	br	81122054 <__reset+0xfb102054>
811220f4:	9823883a 	mov	r17,r19
811220f8:	003fd606 	br	81122054 <__reset+0xfb102054>

811220fc <__s2b>:
811220fc:	defff904 	addi	sp,sp,-28
81122100:	de00012e 	bgeu	sp,et,81122108 <__s2b+0xc>
81122104:	003b68fa 	trap	3
81122108:	dc400115 	stw	r17,4(sp)
8112210c:	dc000015 	stw	r16,0(sp)
81122110:	2023883a 	mov	r17,r4
81122114:	2821883a 	mov	r16,r5
81122118:	39000204 	addi	r4,r7,8
8112211c:	01400244 	movi	r5,9
81122120:	dcc00315 	stw	r19,12(sp)
81122124:	dc800215 	stw	r18,8(sp)
81122128:	dfc00615 	stw	ra,24(sp)
8112212c:	dd400515 	stw	r21,20(sp)
81122130:	dd000415 	stw	r20,16(sp)
81122134:	3825883a 	mov	r18,r7
81122138:	3027883a 	mov	r19,r6
8112213c:	112a1bc0 	call	8112a1bc <__divsi3>
81122140:	00c00044 	movi	r3,1
81122144:	000b883a 	mov	r5,zero
81122148:	1880030e 	bge	r3,r2,81122158 <__s2b+0x5c>
8112214c:	18c7883a 	add	r3,r3,r3
81122150:	29400044 	addi	r5,r5,1
81122154:	18bffd16 	blt	r3,r2,8112214c <__reset+0xfb10214c>
81122158:	8809883a 	mov	r4,r17
8112215c:	1121efc0 	call	81121efc <_Balloc>
81122160:	d8c00717 	ldw	r3,28(sp)
81122164:	10c00515 	stw	r3,20(r2)
81122168:	00c00044 	movi	r3,1
8112216c:	10c00415 	stw	r3,16(r2)
81122170:	00c00244 	movi	r3,9
81122174:	1cc0210e 	bge	r3,r19,811221fc <__s2b+0x100>
81122178:	80eb883a 	add	r21,r16,r3
8112217c:	a829883a 	mov	r20,r21
81122180:	84e1883a 	add	r16,r16,r19
81122184:	a1c00007 	ldb	r7,0(r20)
81122188:	01800284 	movi	r6,10
8112218c:	a5000044 	addi	r20,r20,1
81122190:	100b883a 	mov	r5,r2
81122194:	39fff404 	addi	r7,r7,-48
81122198:	8809883a 	mov	r4,r17
8112219c:	1121fd40 	call	81121fd4 <__multadd>
811221a0:	a43ff81e 	bne	r20,r16,81122184 <__reset+0xfb102184>
811221a4:	ace1883a 	add	r16,r21,r19
811221a8:	843ffe04 	addi	r16,r16,-8
811221ac:	9c800a0e 	bge	r19,r18,811221d8 <__s2b+0xdc>
811221b0:	94e5c83a 	sub	r18,r18,r19
811221b4:	84a5883a 	add	r18,r16,r18
811221b8:	81c00007 	ldb	r7,0(r16)
811221bc:	01800284 	movi	r6,10
811221c0:	84000044 	addi	r16,r16,1
811221c4:	100b883a 	mov	r5,r2
811221c8:	39fff404 	addi	r7,r7,-48
811221cc:	8809883a 	mov	r4,r17
811221d0:	1121fd40 	call	81121fd4 <__multadd>
811221d4:	84bff81e 	bne	r16,r18,811221b8 <__reset+0xfb1021b8>
811221d8:	dfc00617 	ldw	ra,24(sp)
811221dc:	dd400517 	ldw	r21,20(sp)
811221e0:	dd000417 	ldw	r20,16(sp)
811221e4:	dcc00317 	ldw	r19,12(sp)
811221e8:	dc800217 	ldw	r18,8(sp)
811221ec:	dc400117 	ldw	r17,4(sp)
811221f0:	dc000017 	ldw	r16,0(sp)
811221f4:	dec00704 	addi	sp,sp,28
811221f8:	f800283a 	ret
811221fc:	84000284 	addi	r16,r16,10
81122200:	1827883a 	mov	r19,r3
81122204:	003fe906 	br	811221ac <__reset+0xfb1021ac>

81122208 <__hi0bits>:
81122208:	20bfffec 	andhi	r2,r4,65535
8112220c:	1000141e 	bne	r2,zero,81122260 <__hi0bits+0x58>
81122210:	2008943a 	slli	r4,r4,16
81122214:	00800404 	movi	r2,16
81122218:	20ffc02c 	andhi	r3,r4,65280
8112221c:	1800021e 	bne	r3,zero,81122228 <__hi0bits+0x20>
81122220:	2008923a 	slli	r4,r4,8
81122224:	10800204 	addi	r2,r2,8
81122228:	20fc002c 	andhi	r3,r4,61440
8112222c:	1800021e 	bne	r3,zero,81122238 <__hi0bits+0x30>
81122230:	2008913a 	slli	r4,r4,4
81122234:	10800104 	addi	r2,r2,4
81122238:	20f0002c 	andhi	r3,r4,49152
8112223c:	1800031e 	bne	r3,zero,8112224c <__hi0bits+0x44>
81122240:	2109883a 	add	r4,r4,r4
81122244:	10800084 	addi	r2,r2,2
81122248:	2109883a 	add	r4,r4,r4
8112224c:	20000316 	blt	r4,zero,8112225c <__hi0bits+0x54>
81122250:	2110002c 	andhi	r4,r4,16384
81122254:	2000041e 	bne	r4,zero,81122268 <__hi0bits+0x60>
81122258:	00800804 	movi	r2,32
8112225c:	f800283a 	ret
81122260:	0005883a 	mov	r2,zero
81122264:	003fec06 	br	81122218 <__reset+0xfb102218>
81122268:	10800044 	addi	r2,r2,1
8112226c:	f800283a 	ret

81122270 <__lo0bits>:
81122270:	20c00017 	ldw	r3,0(r4)
81122274:	188001cc 	andi	r2,r3,7
81122278:	10000826 	beq	r2,zero,8112229c <__lo0bits+0x2c>
8112227c:	1880004c 	andi	r2,r3,1
81122280:	1000211e 	bne	r2,zero,81122308 <__lo0bits+0x98>
81122284:	1880008c 	andi	r2,r3,2
81122288:	1000211e 	bne	r2,zero,81122310 <__lo0bits+0xa0>
8112228c:	1806d0ba 	srli	r3,r3,2
81122290:	00800084 	movi	r2,2
81122294:	20c00015 	stw	r3,0(r4)
81122298:	f800283a 	ret
8112229c:	18bfffcc 	andi	r2,r3,65535
811222a0:	10001326 	beq	r2,zero,811222f0 <__lo0bits+0x80>
811222a4:	0005883a 	mov	r2,zero
811222a8:	19403fcc 	andi	r5,r3,255
811222ac:	2800021e 	bne	r5,zero,811222b8 <__lo0bits+0x48>
811222b0:	1806d23a 	srli	r3,r3,8
811222b4:	10800204 	addi	r2,r2,8
811222b8:	194003cc 	andi	r5,r3,15
811222bc:	2800021e 	bne	r5,zero,811222c8 <__lo0bits+0x58>
811222c0:	1806d13a 	srli	r3,r3,4
811222c4:	10800104 	addi	r2,r2,4
811222c8:	194000cc 	andi	r5,r3,3
811222cc:	2800021e 	bne	r5,zero,811222d8 <__lo0bits+0x68>
811222d0:	1806d0ba 	srli	r3,r3,2
811222d4:	10800084 	addi	r2,r2,2
811222d8:	1940004c 	andi	r5,r3,1
811222dc:	2800081e 	bne	r5,zero,81122300 <__lo0bits+0x90>
811222e0:	1806d07a 	srli	r3,r3,1
811222e4:	1800051e 	bne	r3,zero,811222fc <__lo0bits+0x8c>
811222e8:	00800804 	movi	r2,32
811222ec:	f800283a 	ret
811222f0:	1806d43a 	srli	r3,r3,16
811222f4:	00800404 	movi	r2,16
811222f8:	003feb06 	br	811222a8 <__reset+0xfb1022a8>
811222fc:	10800044 	addi	r2,r2,1
81122300:	20c00015 	stw	r3,0(r4)
81122304:	f800283a 	ret
81122308:	0005883a 	mov	r2,zero
8112230c:	f800283a 	ret
81122310:	1806d07a 	srli	r3,r3,1
81122314:	00800044 	movi	r2,1
81122318:	20c00015 	stw	r3,0(r4)
8112231c:	f800283a 	ret

81122320 <__i2b>:
81122320:	defffd04 	addi	sp,sp,-12
81122324:	de00012e 	bgeu	sp,et,8112232c <__i2b+0xc>
81122328:	003b68fa 	trap	3
8112232c:	dc000015 	stw	r16,0(sp)
81122330:	04000044 	movi	r16,1
81122334:	dc400115 	stw	r17,4(sp)
81122338:	2823883a 	mov	r17,r5
8112233c:	800b883a 	mov	r5,r16
81122340:	dfc00215 	stw	ra,8(sp)
81122344:	1121efc0 	call	81121efc <_Balloc>
81122348:	14400515 	stw	r17,20(r2)
8112234c:	14000415 	stw	r16,16(r2)
81122350:	dfc00217 	ldw	ra,8(sp)
81122354:	dc400117 	ldw	r17,4(sp)
81122358:	dc000017 	ldw	r16,0(sp)
8112235c:	dec00304 	addi	sp,sp,12
81122360:	f800283a 	ret

81122364 <__multiply>:
81122364:	defffa04 	addi	sp,sp,-24
81122368:	de00012e 	bgeu	sp,et,81122370 <__multiply+0xc>
8112236c:	003b68fa 	trap	3
81122370:	dcc00315 	stw	r19,12(sp)
81122374:	dc800215 	stw	r18,8(sp)
81122378:	34c00417 	ldw	r19,16(r6)
8112237c:	2c800417 	ldw	r18,16(r5)
81122380:	dd000415 	stw	r20,16(sp)
81122384:	dc400115 	stw	r17,4(sp)
81122388:	dfc00515 	stw	ra,20(sp)
8112238c:	dc000015 	stw	r16,0(sp)
81122390:	2829883a 	mov	r20,r5
81122394:	3023883a 	mov	r17,r6
81122398:	94c0050e 	bge	r18,r19,811223b0 <__multiply+0x4c>
8112239c:	9007883a 	mov	r3,r18
811223a0:	3029883a 	mov	r20,r6
811223a4:	9825883a 	mov	r18,r19
811223a8:	2823883a 	mov	r17,r5
811223ac:	1827883a 	mov	r19,r3
811223b0:	a0800217 	ldw	r2,8(r20)
811223b4:	94e1883a 	add	r16,r18,r19
811223b8:	a1400117 	ldw	r5,4(r20)
811223bc:	1400010e 	bge	r2,r16,811223c4 <__multiply+0x60>
811223c0:	29400044 	addi	r5,r5,1
811223c4:	1121efc0 	call	81121efc <_Balloc>
811223c8:	8415883a 	add	r10,r16,r16
811223cc:	12c00504 	addi	r11,r2,20
811223d0:	5295883a 	add	r10,r10,r10
811223d4:	5a95883a 	add	r10,r11,r10
811223d8:	5807883a 	mov	r3,r11
811223dc:	5a80032e 	bgeu	r11,r10,811223ec <__multiply+0x88>
811223e0:	18000015 	stw	zero,0(r3)
811223e4:	18c00104 	addi	r3,r3,4
811223e8:	1abffd36 	bltu	r3,r10,811223e0 <__reset+0xfb1023e0>
811223ec:	9ce7883a 	add	r19,r19,r19
811223f0:	94a5883a 	add	r18,r18,r18
811223f4:	89800504 	addi	r6,r17,20
811223f8:	9ce7883a 	add	r19,r19,r19
811223fc:	a3400504 	addi	r13,r20,20
81122400:	94a5883a 	add	r18,r18,r18
81122404:	34d9883a 	add	r12,r6,r19
81122408:	6c93883a 	add	r9,r13,r18
8112240c:	3300422e 	bgeu	r6,r12,81122518 <__multiply+0x1b4>
81122410:	37c00017 	ldw	ra,0(r6)
81122414:	fbffffcc 	andi	r15,ra,65535
81122418:	78001b26 	beq	r15,zero,81122488 <__multiply+0x124>
8112241c:	5811883a 	mov	r8,r11
81122420:	681d883a 	mov	r14,r13
81122424:	000f883a 	mov	r7,zero
81122428:	71000017 	ldw	r4,0(r14)
8112242c:	40c00017 	ldw	r3,0(r8)
81122430:	73800104 	addi	r14,r14,4
81122434:	217fffcc 	andi	r5,r4,65535
81122438:	2bcb383a 	mul	r5,r5,r15
8112243c:	2008d43a 	srli	r4,r4,16
81122440:	1c7fffcc 	andi	r17,r3,65535
81122444:	2c4b883a 	add	r5,r5,r17
81122448:	29cb883a 	add	r5,r5,r7
8112244c:	23c9383a 	mul	r4,r4,r15
81122450:	1806d43a 	srli	r3,r3,16
81122454:	280ed43a 	srli	r7,r5,16
81122458:	297fffcc 	andi	r5,r5,65535
8112245c:	20c7883a 	add	r3,r4,r3
81122460:	19c7883a 	add	r3,r3,r7
81122464:	1808943a 	slli	r4,r3,16
81122468:	4023883a 	mov	r17,r8
8112246c:	180ed43a 	srli	r7,r3,16
81122470:	214ab03a 	or	r5,r4,r5
81122474:	41400015 	stw	r5,0(r8)
81122478:	42000104 	addi	r8,r8,4
8112247c:	727fea36 	bltu	r14,r9,81122428 <__reset+0xfb102428>
81122480:	89c00115 	stw	r7,4(r17)
81122484:	37c00017 	ldw	ra,0(r6)
81122488:	f83ed43a 	srli	ra,ra,16
8112248c:	f8001f26 	beq	ra,zero,8112250c <__multiply+0x1a8>
81122490:	58c00017 	ldw	r3,0(r11)
81122494:	681d883a 	mov	r14,r13
81122498:	581f883a 	mov	r15,r11
8112249c:	1811883a 	mov	r8,r3
811224a0:	5825883a 	mov	r18,r11
811224a4:	000f883a 	mov	r7,zero
811224a8:	00000106 	br	811224b0 <__multiply+0x14c>
811224ac:	8825883a 	mov	r18,r17
811224b0:	7140000b 	ldhu	r5,0(r14)
811224b4:	4010d43a 	srli	r8,r8,16
811224b8:	193fffcc 	andi	r4,r3,65535
811224bc:	2fcb383a 	mul	r5,r5,ra
811224c0:	7bc00104 	addi	r15,r15,4
811224c4:	73800104 	addi	r14,r14,4
811224c8:	2a0b883a 	add	r5,r5,r8
811224cc:	29cb883a 	add	r5,r5,r7
811224d0:	2806943a 	slli	r3,r5,16
811224d4:	94400104 	addi	r17,r18,4
811224d8:	280ad43a 	srli	r5,r5,16
811224dc:	1908b03a 	or	r4,r3,r4
811224e0:	793fff15 	stw	r4,-4(r15)
811224e4:	70ffff17 	ldw	r3,-4(r14)
811224e8:	8a000017 	ldw	r8,0(r17)
811224ec:	1806d43a 	srli	r3,r3,16
811224f0:	413fffcc 	andi	r4,r8,65535
811224f4:	1fc7383a 	mul	r3,r3,ra
811224f8:	1907883a 	add	r3,r3,r4
811224fc:	1947883a 	add	r3,r3,r5
81122500:	180ed43a 	srli	r7,r3,16
81122504:	727fe936 	bltu	r14,r9,811224ac <__reset+0xfb1024ac>
81122508:	90c00115 	stw	r3,4(r18)
8112250c:	31800104 	addi	r6,r6,4
81122510:	5ac00104 	addi	r11,r11,4
81122514:	333fbe36 	bltu	r6,r12,81122410 <__reset+0xfb102410>
81122518:	0400090e 	bge	zero,r16,81122540 <__multiply+0x1dc>
8112251c:	50ffff17 	ldw	r3,-4(r10)
81122520:	52bfff04 	addi	r10,r10,-4
81122524:	18000326 	beq	r3,zero,81122534 <__multiply+0x1d0>
81122528:	00000506 	br	81122540 <__multiply+0x1dc>
8112252c:	50c00017 	ldw	r3,0(r10)
81122530:	1800031e 	bne	r3,zero,81122540 <__multiply+0x1dc>
81122534:	843fffc4 	addi	r16,r16,-1
81122538:	52bfff04 	addi	r10,r10,-4
8112253c:	803ffb1e 	bne	r16,zero,8112252c <__reset+0xfb10252c>
81122540:	14000415 	stw	r16,16(r2)
81122544:	dfc00517 	ldw	ra,20(sp)
81122548:	dd000417 	ldw	r20,16(sp)
8112254c:	dcc00317 	ldw	r19,12(sp)
81122550:	dc800217 	ldw	r18,8(sp)
81122554:	dc400117 	ldw	r17,4(sp)
81122558:	dc000017 	ldw	r16,0(sp)
8112255c:	dec00604 	addi	sp,sp,24
81122560:	f800283a 	ret

81122564 <__pow5mult>:
81122564:	defffa04 	addi	sp,sp,-24
81122568:	de00012e 	bgeu	sp,et,81122570 <__pow5mult+0xc>
8112256c:	003b68fa 	trap	3
81122570:	308000cc 	andi	r2,r6,3
81122574:	dcc00315 	stw	r19,12(sp)
81122578:	dc000015 	stw	r16,0(sp)
8112257c:	dfc00515 	stw	ra,20(sp)
81122580:	dd000415 	stw	r20,16(sp)
81122584:	dc800215 	stw	r18,8(sp)
81122588:	dc400115 	stw	r17,4(sp)
8112258c:	3021883a 	mov	r16,r6
81122590:	2027883a 	mov	r19,r4
81122594:	10002f1e 	bne	r2,zero,81122654 <__pow5mult+0xf0>
81122598:	2825883a 	mov	r18,r5
8112259c:	8021d0ba 	srai	r16,r16,2
811225a0:	80001a26 	beq	r16,zero,8112260c <__pow5mult+0xa8>
811225a4:	9c401217 	ldw	r17,72(r19)
811225a8:	8800061e 	bne	r17,zero,811225c4 <__pow5mult+0x60>
811225ac:	00003406 	br	81122680 <__pow5mult+0x11c>
811225b0:	8021d07a 	srai	r16,r16,1
811225b4:	80001526 	beq	r16,zero,8112260c <__pow5mult+0xa8>
811225b8:	88800017 	ldw	r2,0(r17)
811225bc:	10001c26 	beq	r2,zero,81122630 <__pow5mult+0xcc>
811225c0:	1023883a 	mov	r17,r2
811225c4:	8080004c 	andi	r2,r16,1
811225c8:	103ff926 	beq	r2,zero,811225b0 <__reset+0xfb1025b0>
811225cc:	880d883a 	mov	r6,r17
811225d0:	900b883a 	mov	r5,r18
811225d4:	9809883a 	mov	r4,r19
811225d8:	11223640 	call	81122364 <__multiply>
811225dc:	90001b26 	beq	r18,zero,8112264c <__pow5mult+0xe8>
811225e0:	91000117 	ldw	r4,4(r18)
811225e4:	98c01317 	ldw	r3,76(r19)
811225e8:	8021d07a 	srai	r16,r16,1
811225ec:	2109883a 	add	r4,r4,r4
811225f0:	2109883a 	add	r4,r4,r4
811225f4:	1907883a 	add	r3,r3,r4
811225f8:	19000017 	ldw	r4,0(r3)
811225fc:	91000015 	stw	r4,0(r18)
81122600:	1c800015 	stw	r18,0(r3)
81122604:	1025883a 	mov	r18,r2
81122608:	803feb1e 	bne	r16,zero,811225b8 <__reset+0xfb1025b8>
8112260c:	9005883a 	mov	r2,r18
81122610:	dfc00517 	ldw	ra,20(sp)
81122614:	dd000417 	ldw	r20,16(sp)
81122618:	dcc00317 	ldw	r19,12(sp)
8112261c:	dc800217 	ldw	r18,8(sp)
81122620:	dc400117 	ldw	r17,4(sp)
81122624:	dc000017 	ldw	r16,0(sp)
81122628:	dec00604 	addi	sp,sp,24
8112262c:	f800283a 	ret
81122630:	880d883a 	mov	r6,r17
81122634:	880b883a 	mov	r5,r17
81122638:	9809883a 	mov	r4,r19
8112263c:	11223640 	call	81122364 <__multiply>
81122640:	88800015 	stw	r2,0(r17)
81122644:	10000015 	stw	zero,0(r2)
81122648:	003fdd06 	br	811225c0 <__reset+0xfb1025c0>
8112264c:	1025883a 	mov	r18,r2
81122650:	003fd706 	br	811225b0 <__reset+0xfb1025b0>
81122654:	10bfffc4 	addi	r2,r2,-1
81122658:	1085883a 	add	r2,r2,r2
8112265c:	00e04534 	movhi	r3,33044
81122660:	18d75c04 	addi	r3,r3,23920
81122664:	1085883a 	add	r2,r2,r2
81122668:	1885883a 	add	r2,r3,r2
8112266c:	11800017 	ldw	r6,0(r2)
81122670:	000f883a 	mov	r7,zero
81122674:	1121fd40 	call	81121fd4 <__multadd>
81122678:	1025883a 	mov	r18,r2
8112267c:	003fc706 	br	8112259c <__reset+0xfb10259c>
81122680:	05000044 	movi	r20,1
81122684:	a00b883a 	mov	r5,r20
81122688:	9809883a 	mov	r4,r19
8112268c:	1121efc0 	call	81121efc <_Balloc>
81122690:	1023883a 	mov	r17,r2
81122694:	00809c44 	movi	r2,625
81122698:	88800515 	stw	r2,20(r17)
8112269c:	8d000415 	stw	r20,16(r17)
811226a0:	9c401215 	stw	r17,72(r19)
811226a4:	88000015 	stw	zero,0(r17)
811226a8:	003fc606 	br	811225c4 <__reset+0xfb1025c4>

811226ac <__lshift>:
811226ac:	defff904 	addi	sp,sp,-28
811226b0:	de00012e 	bgeu	sp,et,811226b8 <__lshift+0xc>
811226b4:	003b68fa 	trap	3
811226b8:	dd400515 	stw	r21,20(sp)
811226bc:	dcc00315 	stw	r19,12(sp)
811226c0:	302bd17a 	srai	r21,r6,5
811226c4:	2cc00417 	ldw	r19,16(r5)
811226c8:	28800217 	ldw	r2,8(r5)
811226cc:	dd000415 	stw	r20,16(sp)
811226d0:	ace7883a 	add	r19,r21,r19
811226d4:	dc800215 	stw	r18,8(sp)
811226d8:	dc400115 	stw	r17,4(sp)
811226dc:	dc000015 	stw	r16,0(sp)
811226e0:	dfc00615 	stw	ra,24(sp)
811226e4:	9c000044 	addi	r16,r19,1
811226e8:	2823883a 	mov	r17,r5
811226ec:	3029883a 	mov	r20,r6
811226f0:	2025883a 	mov	r18,r4
811226f4:	29400117 	ldw	r5,4(r5)
811226f8:	1400030e 	bge	r2,r16,81122708 <__lshift+0x5c>
811226fc:	1085883a 	add	r2,r2,r2
81122700:	29400044 	addi	r5,r5,1
81122704:	143ffd16 	blt	r2,r16,811226fc <__reset+0xfb1026fc>
81122708:	9009883a 	mov	r4,r18
8112270c:	1121efc0 	call	81121efc <_Balloc>
81122710:	10c00504 	addi	r3,r2,20
81122714:	0540070e 	bge	zero,r21,81122734 <__lshift+0x88>
81122718:	ad6b883a 	add	r21,r21,r21
8112271c:	ad6b883a 	add	r21,r21,r21
81122720:	1809883a 	mov	r4,r3
81122724:	1d47883a 	add	r3,r3,r21
81122728:	20000015 	stw	zero,0(r4)
8112272c:	21000104 	addi	r4,r4,4
81122730:	193ffd1e 	bne	r3,r4,81122728 <__reset+0xfb102728>
81122734:	8a000417 	ldw	r8,16(r17)
81122738:	89000504 	addi	r4,r17,20
8112273c:	a18007cc 	andi	r6,r20,31
81122740:	4211883a 	add	r8,r8,r8
81122744:	4211883a 	add	r8,r8,r8
81122748:	2211883a 	add	r8,r4,r8
8112274c:	30002326 	beq	r6,zero,811227dc <__lshift+0x130>
81122750:	02400804 	movi	r9,32
81122754:	4993c83a 	sub	r9,r9,r6
81122758:	000b883a 	mov	r5,zero
8112275c:	21c00017 	ldw	r7,0(r4)
81122760:	1815883a 	mov	r10,r3
81122764:	18c00104 	addi	r3,r3,4
81122768:	398e983a 	sll	r7,r7,r6
8112276c:	21000104 	addi	r4,r4,4
81122770:	394ab03a 	or	r5,r7,r5
81122774:	197fff15 	stw	r5,-4(r3)
81122778:	217fff17 	ldw	r5,-4(r4)
8112277c:	2a4ad83a 	srl	r5,r5,r9
81122780:	223ff636 	bltu	r4,r8,8112275c <__reset+0xfb10275c>
81122784:	51400115 	stw	r5,4(r10)
81122788:	28001a1e 	bne	r5,zero,811227f4 <__lshift+0x148>
8112278c:	843fffc4 	addi	r16,r16,-1
81122790:	14000415 	stw	r16,16(r2)
81122794:	88000826 	beq	r17,zero,811227b8 <__lshift+0x10c>
81122798:	89000117 	ldw	r4,4(r17)
8112279c:	90c01317 	ldw	r3,76(r18)
811227a0:	2109883a 	add	r4,r4,r4
811227a4:	2109883a 	add	r4,r4,r4
811227a8:	1907883a 	add	r3,r3,r4
811227ac:	19000017 	ldw	r4,0(r3)
811227b0:	89000015 	stw	r4,0(r17)
811227b4:	1c400015 	stw	r17,0(r3)
811227b8:	dfc00617 	ldw	ra,24(sp)
811227bc:	dd400517 	ldw	r21,20(sp)
811227c0:	dd000417 	ldw	r20,16(sp)
811227c4:	dcc00317 	ldw	r19,12(sp)
811227c8:	dc800217 	ldw	r18,8(sp)
811227cc:	dc400117 	ldw	r17,4(sp)
811227d0:	dc000017 	ldw	r16,0(sp)
811227d4:	dec00704 	addi	sp,sp,28
811227d8:	f800283a 	ret
811227dc:	21400017 	ldw	r5,0(r4)
811227e0:	18c00104 	addi	r3,r3,4
811227e4:	21000104 	addi	r4,r4,4
811227e8:	197fff15 	stw	r5,-4(r3)
811227ec:	223ffb36 	bltu	r4,r8,811227dc <__reset+0xfb1027dc>
811227f0:	003fe606 	br	8112278c <__reset+0xfb10278c>
811227f4:	9c000084 	addi	r16,r19,2
811227f8:	003fe406 	br	8112278c <__reset+0xfb10278c>

811227fc <__mcmp>:
811227fc:	20800417 	ldw	r2,16(r4)
81122800:	28c00417 	ldw	r3,16(r5)
81122804:	10c5c83a 	sub	r2,r2,r3
81122808:	1000111e 	bne	r2,zero,81122850 <__mcmp+0x54>
8112280c:	18c7883a 	add	r3,r3,r3
81122810:	18c7883a 	add	r3,r3,r3
81122814:	21000504 	addi	r4,r4,20
81122818:	29400504 	addi	r5,r5,20
8112281c:	20c5883a 	add	r2,r4,r3
81122820:	28cb883a 	add	r5,r5,r3
81122824:	00000106 	br	8112282c <__mcmp+0x30>
81122828:	20800a2e 	bgeu	r4,r2,81122854 <__mcmp+0x58>
8112282c:	10bfff04 	addi	r2,r2,-4
81122830:	297fff04 	addi	r5,r5,-4
81122834:	11800017 	ldw	r6,0(r2)
81122838:	28c00017 	ldw	r3,0(r5)
8112283c:	30fffa26 	beq	r6,r3,81122828 <__reset+0xfb102828>
81122840:	30c00236 	bltu	r6,r3,8112284c <__mcmp+0x50>
81122844:	00800044 	movi	r2,1
81122848:	f800283a 	ret
8112284c:	00bfffc4 	movi	r2,-1
81122850:	f800283a 	ret
81122854:	0005883a 	mov	r2,zero
81122858:	f800283a 	ret

8112285c <__mdiff>:
8112285c:	defffa04 	addi	sp,sp,-24
81122860:	de00012e 	bgeu	sp,et,81122868 <__mdiff+0xc>
81122864:	003b68fa 	trap	3
81122868:	28c00417 	ldw	r3,16(r5)
8112286c:	30800417 	ldw	r2,16(r6)
81122870:	dcc00315 	stw	r19,12(sp)
81122874:	dc800215 	stw	r18,8(sp)
81122878:	dfc00515 	stw	ra,20(sp)
8112287c:	dd000415 	stw	r20,16(sp)
81122880:	dc400115 	stw	r17,4(sp)
81122884:	dc000015 	stw	r16,0(sp)
81122888:	1887c83a 	sub	r3,r3,r2
8112288c:	2825883a 	mov	r18,r5
81122890:	3027883a 	mov	r19,r6
81122894:	1800141e 	bne	r3,zero,811228e8 <__mdiff+0x8c>
81122898:	1085883a 	add	r2,r2,r2
8112289c:	1085883a 	add	r2,r2,r2
811228a0:	2a000504 	addi	r8,r5,20
811228a4:	34000504 	addi	r16,r6,20
811228a8:	4087883a 	add	r3,r8,r2
811228ac:	8085883a 	add	r2,r16,r2
811228b0:	00000106 	br	811228b8 <__mdiff+0x5c>
811228b4:	40c0592e 	bgeu	r8,r3,81122a1c <__mdiff+0x1c0>
811228b8:	18ffff04 	addi	r3,r3,-4
811228bc:	10bfff04 	addi	r2,r2,-4
811228c0:	19c00017 	ldw	r7,0(r3)
811228c4:	11400017 	ldw	r5,0(r2)
811228c8:	397ffa26 	beq	r7,r5,811228b4 <__reset+0xfb1028b4>
811228cc:	3940592e 	bgeu	r7,r5,81122a34 <__mdiff+0x1d8>
811228d0:	9005883a 	mov	r2,r18
811228d4:	4023883a 	mov	r17,r8
811228d8:	9825883a 	mov	r18,r19
811228dc:	05000044 	movi	r20,1
811228e0:	1027883a 	mov	r19,r2
811228e4:	00000406 	br	811228f8 <__mdiff+0x9c>
811228e8:	18005616 	blt	r3,zero,81122a44 <__mdiff+0x1e8>
811228ec:	34400504 	addi	r17,r6,20
811228f0:	2c000504 	addi	r16,r5,20
811228f4:	0029883a 	mov	r20,zero
811228f8:	91400117 	ldw	r5,4(r18)
811228fc:	1121efc0 	call	81121efc <_Balloc>
81122900:	92400417 	ldw	r9,16(r18)
81122904:	9b000417 	ldw	r12,16(r19)
81122908:	12c00504 	addi	r11,r2,20
8112290c:	4a51883a 	add	r8,r9,r9
81122910:	6319883a 	add	r12,r12,r12
81122914:	4211883a 	add	r8,r8,r8
81122918:	6319883a 	add	r12,r12,r12
8112291c:	15000315 	stw	r20,12(r2)
81122920:	8211883a 	add	r8,r16,r8
81122924:	8b19883a 	add	r12,r17,r12
81122928:	0007883a 	mov	r3,zero
8112292c:	81400017 	ldw	r5,0(r16)
81122930:	89c00017 	ldw	r7,0(r17)
81122934:	59800104 	addi	r6,r11,4
81122938:	293fffcc 	andi	r4,r5,65535
8112293c:	20c7883a 	add	r3,r4,r3
81122940:	393fffcc 	andi	r4,r7,65535
81122944:	1909c83a 	sub	r4,r3,r4
81122948:	280ad43a 	srli	r5,r5,16
8112294c:	380ed43a 	srli	r7,r7,16
81122950:	2007d43a 	srai	r3,r4,16
81122954:	213fffcc 	andi	r4,r4,65535
81122958:	29cbc83a 	sub	r5,r5,r7
8112295c:	28c7883a 	add	r3,r5,r3
81122960:	180a943a 	slli	r5,r3,16
81122964:	8c400104 	addi	r17,r17,4
81122968:	84000104 	addi	r16,r16,4
8112296c:	2908b03a 	or	r4,r5,r4
81122970:	59000015 	stw	r4,0(r11)
81122974:	1807d43a 	srai	r3,r3,16
81122978:	3015883a 	mov	r10,r6
8112297c:	3017883a 	mov	r11,r6
81122980:	8b3fea36 	bltu	r17,r12,8112292c <__reset+0xfb10292c>
81122984:	8200162e 	bgeu	r16,r8,811229e0 <__mdiff+0x184>
81122988:	8017883a 	mov	r11,r16
8112298c:	59400017 	ldw	r5,0(r11)
81122990:	31800104 	addi	r6,r6,4
81122994:	5ac00104 	addi	r11,r11,4
81122998:	293fffcc 	andi	r4,r5,65535
8112299c:	20c7883a 	add	r3,r4,r3
811229a0:	280ed43a 	srli	r7,r5,16
811229a4:	180bd43a 	srai	r5,r3,16
811229a8:	193fffcc 	andi	r4,r3,65535
811229ac:	3947883a 	add	r3,r7,r5
811229b0:	180a943a 	slli	r5,r3,16
811229b4:	1807d43a 	srai	r3,r3,16
811229b8:	2908b03a 	or	r4,r5,r4
811229bc:	313fff15 	stw	r4,-4(r6)
811229c0:	5a3ff236 	bltu	r11,r8,8112298c <__reset+0xfb10298c>
811229c4:	0406303a 	nor	r3,zero,r16
811229c8:	1a07883a 	add	r3,r3,r8
811229cc:	1806d0ba 	srli	r3,r3,2
811229d0:	18c00044 	addi	r3,r3,1
811229d4:	18c7883a 	add	r3,r3,r3
811229d8:	18c7883a 	add	r3,r3,r3
811229dc:	50d5883a 	add	r10,r10,r3
811229e0:	50ffff04 	addi	r3,r10,-4
811229e4:	2000041e 	bne	r4,zero,811229f8 <__mdiff+0x19c>
811229e8:	18ffff04 	addi	r3,r3,-4
811229ec:	19000017 	ldw	r4,0(r3)
811229f0:	4a7fffc4 	addi	r9,r9,-1
811229f4:	203ffc26 	beq	r4,zero,811229e8 <__reset+0xfb1029e8>
811229f8:	12400415 	stw	r9,16(r2)
811229fc:	dfc00517 	ldw	ra,20(sp)
81122a00:	dd000417 	ldw	r20,16(sp)
81122a04:	dcc00317 	ldw	r19,12(sp)
81122a08:	dc800217 	ldw	r18,8(sp)
81122a0c:	dc400117 	ldw	r17,4(sp)
81122a10:	dc000017 	ldw	r16,0(sp)
81122a14:	dec00604 	addi	sp,sp,24
81122a18:	f800283a 	ret
81122a1c:	000b883a 	mov	r5,zero
81122a20:	1121efc0 	call	81121efc <_Balloc>
81122a24:	00c00044 	movi	r3,1
81122a28:	10c00415 	stw	r3,16(r2)
81122a2c:	10000515 	stw	zero,20(r2)
81122a30:	003ff206 	br	811229fc <__reset+0xfb1029fc>
81122a34:	8023883a 	mov	r17,r16
81122a38:	0029883a 	mov	r20,zero
81122a3c:	4021883a 	mov	r16,r8
81122a40:	003fad06 	br	811228f8 <__reset+0xfb1028f8>
81122a44:	9005883a 	mov	r2,r18
81122a48:	94400504 	addi	r17,r18,20
81122a4c:	9c000504 	addi	r16,r19,20
81122a50:	9825883a 	mov	r18,r19
81122a54:	05000044 	movi	r20,1
81122a58:	1027883a 	mov	r19,r2
81122a5c:	003fa606 	br	811228f8 <__reset+0xfb1028f8>

81122a60 <__ulp>:
81122a60:	295ffc2c 	andhi	r5,r5,32752
81122a64:	00bf3034 	movhi	r2,64704
81122a68:	2887883a 	add	r3,r5,r2
81122a6c:	00c0020e 	bge	zero,r3,81122a78 <__ulp+0x18>
81122a70:	0005883a 	mov	r2,zero
81122a74:	f800283a 	ret
81122a78:	00c7c83a 	sub	r3,zero,r3
81122a7c:	1807d53a 	srai	r3,r3,20
81122a80:	008004c4 	movi	r2,19
81122a84:	10c00b0e 	bge	r2,r3,81122ab4 <__ulp+0x54>
81122a88:	18bffb04 	addi	r2,r3,-20
81122a8c:	01000784 	movi	r4,30
81122a90:	0007883a 	mov	r3,zero
81122a94:	20800516 	blt	r4,r2,81122aac <__ulp+0x4c>
81122a98:	010007c4 	movi	r4,31
81122a9c:	2089c83a 	sub	r4,r4,r2
81122aa0:	00800044 	movi	r2,1
81122aa4:	1104983a 	sll	r2,r2,r4
81122aa8:	f800283a 	ret
81122aac:	00800044 	movi	r2,1
81122ab0:	f800283a 	ret
81122ab4:	01400234 	movhi	r5,8
81122ab8:	28c7d83a 	sra	r3,r5,r3
81122abc:	0005883a 	mov	r2,zero
81122ac0:	f800283a 	ret

81122ac4 <__b2d>:
81122ac4:	defffa04 	addi	sp,sp,-24
81122ac8:	de00012e 	bgeu	sp,et,81122ad0 <__b2d+0xc>
81122acc:	003b68fa 	trap	3
81122ad0:	dc000015 	stw	r16,0(sp)
81122ad4:	24000417 	ldw	r16,16(r4)
81122ad8:	dc400115 	stw	r17,4(sp)
81122adc:	24400504 	addi	r17,r4,20
81122ae0:	8421883a 	add	r16,r16,r16
81122ae4:	8421883a 	add	r16,r16,r16
81122ae8:	8c21883a 	add	r16,r17,r16
81122aec:	dc800215 	stw	r18,8(sp)
81122af0:	84bfff17 	ldw	r18,-4(r16)
81122af4:	dd000415 	stw	r20,16(sp)
81122af8:	dcc00315 	stw	r19,12(sp)
81122afc:	9009883a 	mov	r4,r18
81122b00:	2829883a 	mov	r20,r5
81122b04:	dfc00515 	stw	ra,20(sp)
81122b08:	11222080 	call	81122208 <__hi0bits>
81122b0c:	00c00804 	movi	r3,32
81122b10:	1889c83a 	sub	r4,r3,r2
81122b14:	a1000015 	stw	r4,0(r20)
81122b18:	01000284 	movi	r4,10
81122b1c:	84ffff04 	addi	r19,r16,-4
81122b20:	20801216 	blt	r4,r2,81122b6c <__b2d+0xa8>
81122b24:	018002c4 	movi	r6,11
81122b28:	308dc83a 	sub	r6,r6,r2
81122b2c:	9186d83a 	srl	r3,r18,r6
81122b30:	18cffc34 	orhi	r3,r3,16368
81122b34:	8cc0212e 	bgeu	r17,r19,81122bbc <__b2d+0xf8>
81122b38:	813ffe17 	ldw	r4,-8(r16)
81122b3c:	218cd83a 	srl	r6,r4,r6
81122b40:	10800544 	addi	r2,r2,21
81122b44:	9084983a 	sll	r2,r18,r2
81122b48:	1184b03a 	or	r2,r2,r6
81122b4c:	dfc00517 	ldw	ra,20(sp)
81122b50:	dd000417 	ldw	r20,16(sp)
81122b54:	dcc00317 	ldw	r19,12(sp)
81122b58:	dc800217 	ldw	r18,8(sp)
81122b5c:	dc400117 	ldw	r17,4(sp)
81122b60:	dc000017 	ldw	r16,0(sp)
81122b64:	dec00604 	addi	sp,sp,24
81122b68:	f800283a 	ret
81122b6c:	8cc00f2e 	bgeu	r17,r19,81122bac <__b2d+0xe8>
81122b70:	117ffd44 	addi	r5,r2,-11
81122b74:	80bffe17 	ldw	r2,-8(r16)
81122b78:	28000e26 	beq	r5,zero,81122bb4 <__b2d+0xf0>
81122b7c:	1949c83a 	sub	r4,r3,r5
81122b80:	9164983a 	sll	r18,r18,r5
81122b84:	1106d83a 	srl	r3,r2,r4
81122b88:	81bffe04 	addi	r6,r16,-8
81122b8c:	948ffc34 	orhi	r18,r18,16368
81122b90:	90c6b03a 	or	r3,r18,r3
81122b94:	89800e2e 	bgeu	r17,r6,81122bd0 <__b2d+0x10c>
81122b98:	81bffd17 	ldw	r6,-12(r16)
81122b9c:	1144983a 	sll	r2,r2,r5
81122ba0:	310ad83a 	srl	r5,r6,r4
81122ba4:	2884b03a 	or	r2,r5,r2
81122ba8:	003fe806 	br	81122b4c <__reset+0xfb102b4c>
81122bac:	10bffd44 	addi	r2,r2,-11
81122bb0:	1000041e 	bne	r2,zero,81122bc4 <__b2d+0x100>
81122bb4:	90cffc34 	orhi	r3,r18,16368
81122bb8:	003fe406 	br	81122b4c <__reset+0xfb102b4c>
81122bbc:	000d883a 	mov	r6,zero
81122bc0:	003fdf06 	br	81122b40 <__reset+0xfb102b40>
81122bc4:	90a4983a 	sll	r18,r18,r2
81122bc8:	0005883a 	mov	r2,zero
81122bcc:	003ff906 	br	81122bb4 <__reset+0xfb102bb4>
81122bd0:	1144983a 	sll	r2,r2,r5
81122bd4:	003fdd06 	br	81122b4c <__reset+0xfb102b4c>

81122bd8 <__d2b>:
81122bd8:	defff804 	addi	sp,sp,-32
81122bdc:	de00012e 	bgeu	sp,et,81122be4 <__d2b+0xc>
81122be0:	003b68fa 	trap	3
81122be4:	dc000215 	stw	r16,8(sp)
81122be8:	3021883a 	mov	r16,r6
81122bec:	dc400315 	stw	r17,12(sp)
81122bf0:	8022907a 	slli	r17,r16,1
81122bf4:	dd000615 	stw	r20,24(sp)
81122bf8:	2829883a 	mov	r20,r5
81122bfc:	01400044 	movi	r5,1
81122c00:	dcc00515 	stw	r19,20(sp)
81122c04:	dc800415 	stw	r18,16(sp)
81122c08:	dfc00715 	stw	ra,28(sp)
81122c0c:	3825883a 	mov	r18,r7
81122c10:	8822d57a 	srli	r17,r17,21
81122c14:	1121efc0 	call	81121efc <_Balloc>
81122c18:	1027883a 	mov	r19,r2
81122c1c:	00800434 	movhi	r2,16
81122c20:	10bfffc4 	addi	r2,r2,-1
81122c24:	808c703a 	and	r6,r16,r2
81122c28:	88000126 	beq	r17,zero,81122c30 <__d2b+0x58>
81122c2c:	31800434 	orhi	r6,r6,16
81122c30:	d9800015 	stw	r6,0(sp)
81122c34:	a0002426 	beq	r20,zero,81122cc8 <__d2b+0xf0>
81122c38:	d9000104 	addi	r4,sp,4
81122c3c:	dd000115 	stw	r20,4(sp)
81122c40:	11222700 	call	81122270 <__lo0bits>
81122c44:	d8c00017 	ldw	r3,0(sp)
81122c48:	10002f1e 	bne	r2,zero,81122d08 <__d2b+0x130>
81122c4c:	d9000117 	ldw	r4,4(sp)
81122c50:	99000515 	stw	r4,20(r19)
81122c54:	1821003a 	cmpeq	r16,r3,zero
81122c58:	01000084 	movi	r4,2
81122c5c:	2421c83a 	sub	r16,r4,r16
81122c60:	98c00615 	stw	r3,24(r19)
81122c64:	9c000415 	stw	r16,16(r19)
81122c68:	88001f1e 	bne	r17,zero,81122ce8 <__d2b+0x110>
81122c6c:	10bef384 	addi	r2,r2,-1074
81122c70:	90800015 	stw	r2,0(r18)
81122c74:	00900034 	movhi	r2,16384
81122c78:	10bfffc4 	addi	r2,r2,-1
81122c7c:	8085883a 	add	r2,r16,r2
81122c80:	1085883a 	add	r2,r2,r2
81122c84:	1085883a 	add	r2,r2,r2
81122c88:	9885883a 	add	r2,r19,r2
81122c8c:	11000517 	ldw	r4,20(r2)
81122c90:	8020917a 	slli	r16,r16,5
81122c94:	11222080 	call	81122208 <__hi0bits>
81122c98:	d8c00817 	ldw	r3,32(sp)
81122c9c:	8085c83a 	sub	r2,r16,r2
81122ca0:	18800015 	stw	r2,0(r3)
81122ca4:	9805883a 	mov	r2,r19
81122ca8:	dfc00717 	ldw	ra,28(sp)
81122cac:	dd000617 	ldw	r20,24(sp)
81122cb0:	dcc00517 	ldw	r19,20(sp)
81122cb4:	dc800417 	ldw	r18,16(sp)
81122cb8:	dc400317 	ldw	r17,12(sp)
81122cbc:	dc000217 	ldw	r16,8(sp)
81122cc0:	dec00804 	addi	sp,sp,32
81122cc4:	f800283a 	ret
81122cc8:	d809883a 	mov	r4,sp
81122ccc:	11222700 	call	81122270 <__lo0bits>
81122cd0:	d8c00017 	ldw	r3,0(sp)
81122cd4:	04000044 	movi	r16,1
81122cd8:	9c000415 	stw	r16,16(r19)
81122cdc:	98c00515 	stw	r3,20(r19)
81122ce0:	10800804 	addi	r2,r2,32
81122ce4:	883fe126 	beq	r17,zero,81122c6c <__reset+0xfb102c6c>
81122ce8:	00c00d44 	movi	r3,53
81122cec:	8c7ef344 	addi	r17,r17,-1075
81122cf0:	88a3883a 	add	r17,r17,r2
81122cf4:	1885c83a 	sub	r2,r3,r2
81122cf8:	d8c00817 	ldw	r3,32(sp)
81122cfc:	94400015 	stw	r17,0(r18)
81122d00:	18800015 	stw	r2,0(r3)
81122d04:	003fe706 	br	81122ca4 <__reset+0xfb102ca4>
81122d08:	01000804 	movi	r4,32
81122d0c:	2089c83a 	sub	r4,r4,r2
81122d10:	1908983a 	sll	r4,r3,r4
81122d14:	d9400117 	ldw	r5,4(sp)
81122d18:	1886d83a 	srl	r3,r3,r2
81122d1c:	2148b03a 	or	r4,r4,r5
81122d20:	99000515 	stw	r4,20(r19)
81122d24:	d8c00015 	stw	r3,0(sp)
81122d28:	003fca06 	br	81122c54 <__reset+0xfb102c54>

81122d2c <__ratio>:
81122d2c:	defff904 	addi	sp,sp,-28
81122d30:	de00012e 	bgeu	sp,et,81122d38 <__ratio+0xc>
81122d34:	003b68fa 	trap	3
81122d38:	dc400315 	stw	r17,12(sp)
81122d3c:	2823883a 	mov	r17,r5
81122d40:	d9400104 	addi	r5,sp,4
81122d44:	dfc00615 	stw	ra,24(sp)
81122d48:	dcc00515 	stw	r19,20(sp)
81122d4c:	dc800415 	stw	r18,16(sp)
81122d50:	2027883a 	mov	r19,r4
81122d54:	dc000215 	stw	r16,8(sp)
81122d58:	1122ac40 	call	81122ac4 <__b2d>
81122d5c:	d80b883a 	mov	r5,sp
81122d60:	8809883a 	mov	r4,r17
81122d64:	1025883a 	mov	r18,r2
81122d68:	1821883a 	mov	r16,r3
81122d6c:	1122ac40 	call	81122ac4 <__b2d>
81122d70:	8a000417 	ldw	r8,16(r17)
81122d74:	99000417 	ldw	r4,16(r19)
81122d78:	d9400117 	ldw	r5,4(sp)
81122d7c:	2209c83a 	sub	r4,r4,r8
81122d80:	2010917a 	slli	r8,r4,5
81122d84:	d9000017 	ldw	r4,0(sp)
81122d88:	2909c83a 	sub	r4,r5,r4
81122d8c:	4109883a 	add	r4,r8,r4
81122d90:	01000e0e 	bge	zero,r4,81122dcc <__ratio+0xa0>
81122d94:	2008953a 	slli	r4,r4,20
81122d98:	2421883a 	add	r16,r4,r16
81122d9c:	100d883a 	mov	r6,r2
81122da0:	180f883a 	mov	r7,r3
81122da4:	9009883a 	mov	r4,r18
81122da8:	800b883a 	mov	r5,r16
81122dac:	112ae200 	call	8112ae20 <__divdf3>
81122db0:	dfc00617 	ldw	ra,24(sp)
81122db4:	dcc00517 	ldw	r19,20(sp)
81122db8:	dc800417 	ldw	r18,16(sp)
81122dbc:	dc400317 	ldw	r17,12(sp)
81122dc0:	dc000217 	ldw	r16,8(sp)
81122dc4:	dec00704 	addi	sp,sp,28
81122dc8:	f800283a 	ret
81122dcc:	2008953a 	slli	r4,r4,20
81122dd0:	1907c83a 	sub	r3,r3,r4
81122dd4:	003ff106 	br	81122d9c <__reset+0xfb102d9c>

81122dd8 <_mprec_log10>:
81122dd8:	defffe04 	addi	sp,sp,-8
81122ddc:	de00012e 	bgeu	sp,et,81122de4 <_mprec_log10+0xc>
81122de0:	003b68fa 	trap	3
81122de4:	008005c4 	movi	r2,23
81122de8:	dc000015 	stw	r16,0(sp)
81122dec:	dfc00115 	stw	ra,4(sp)
81122df0:	2021883a 	mov	r16,r4
81122df4:	11000d0e 	bge	r2,r4,81122e2c <_mprec_log10+0x54>
81122df8:	0005883a 	mov	r2,zero
81122dfc:	00cffc34 	movhi	r3,16368
81122e00:	843fffc4 	addi	r16,r16,-1
81122e04:	000d883a 	mov	r6,zero
81122e08:	01d00934 	movhi	r7,16420
81122e0c:	1009883a 	mov	r4,r2
81122e10:	180b883a 	mov	r5,r3
81122e14:	111607c0 	call	8111607c <__muldf3>
81122e18:	803ff91e 	bne	r16,zero,81122e00 <__reset+0xfb102e00>
81122e1c:	dfc00117 	ldw	ra,4(sp)
81122e20:	dc000017 	ldw	r16,0(sp)
81122e24:	dec00204 	addi	sp,sp,8
81122e28:	f800283a 	ret
81122e2c:	202090fa 	slli	r16,r4,3
81122e30:	00a04534 	movhi	r2,33044
81122e34:	10977304 	addi	r2,r2,24012
81122e38:	1421883a 	add	r16,r2,r16
81122e3c:	80800017 	ldw	r2,0(r16)
81122e40:	80c00117 	ldw	r3,4(r16)
81122e44:	dfc00117 	ldw	ra,4(sp)
81122e48:	dc000017 	ldw	r16,0(sp)
81122e4c:	dec00204 	addi	sp,sp,8
81122e50:	f800283a 	ret

81122e54 <__copybits>:
81122e54:	297fffc4 	addi	r5,r5,-1
81122e58:	280fd17a 	srai	r7,r5,5
81122e5c:	30c00417 	ldw	r3,16(r6)
81122e60:	30800504 	addi	r2,r6,20
81122e64:	39c00044 	addi	r7,r7,1
81122e68:	18c7883a 	add	r3,r3,r3
81122e6c:	39cf883a 	add	r7,r7,r7
81122e70:	18c7883a 	add	r3,r3,r3
81122e74:	39cf883a 	add	r7,r7,r7
81122e78:	10c7883a 	add	r3,r2,r3
81122e7c:	21cf883a 	add	r7,r4,r7
81122e80:	10c00d2e 	bgeu	r2,r3,81122eb8 <__copybits+0x64>
81122e84:	200b883a 	mov	r5,r4
81122e88:	12000017 	ldw	r8,0(r2)
81122e8c:	29400104 	addi	r5,r5,4
81122e90:	10800104 	addi	r2,r2,4
81122e94:	2a3fff15 	stw	r8,-4(r5)
81122e98:	10fffb36 	bltu	r2,r3,81122e88 <__reset+0xfb102e88>
81122e9c:	1985c83a 	sub	r2,r3,r6
81122ea0:	10bffac4 	addi	r2,r2,-21
81122ea4:	1004d0ba 	srli	r2,r2,2
81122ea8:	10800044 	addi	r2,r2,1
81122eac:	1085883a 	add	r2,r2,r2
81122eb0:	1085883a 	add	r2,r2,r2
81122eb4:	2089883a 	add	r4,r4,r2
81122eb8:	21c0032e 	bgeu	r4,r7,81122ec8 <__copybits+0x74>
81122ebc:	20000015 	stw	zero,0(r4)
81122ec0:	21000104 	addi	r4,r4,4
81122ec4:	21fffd36 	bltu	r4,r7,81122ebc <__reset+0xfb102ebc>
81122ec8:	f800283a 	ret

81122ecc <__any_on>:
81122ecc:	20c00417 	ldw	r3,16(r4)
81122ed0:	2805d17a 	srai	r2,r5,5
81122ed4:	21000504 	addi	r4,r4,20
81122ed8:	18800d0e 	bge	r3,r2,81122f10 <__any_on+0x44>
81122edc:	18c7883a 	add	r3,r3,r3
81122ee0:	18c7883a 	add	r3,r3,r3
81122ee4:	20c7883a 	add	r3,r4,r3
81122ee8:	20c0192e 	bgeu	r4,r3,81122f50 <__any_on+0x84>
81122eec:	18bfff17 	ldw	r2,-4(r3)
81122ef0:	18ffff04 	addi	r3,r3,-4
81122ef4:	1000041e 	bne	r2,zero,81122f08 <__any_on+0x3c>
81122ef8:	20c0142e 	bgeu	r4,r3,81122f4c <__any_on+0x80>
81122efc:	18ffff04 	addi	r3,r3,-4
81122f00:	19400017 	ldw	r5,0(r3)
81122f04:	283ffc26 	beq	r5,zero,81122ef8 <__reset+0xfb102ef8>
81122f08:	00800044 	movi	r2,1
81122f0c:	f800283a 	ret
81122f10:	10c00a0e 	bge	r2,r3,81122f3c <__any_on+0x70>
81122f14:	1085883a 	add	r2,r2,r2
81122f18:	1085883a 	add	r2,r2,r2
81122f1c:	294007cc 	andi	r5,r5,31
81122f20:	2087883a 	add	r3,r4,r2
81122f24:	283ff026 	beq	r5,zero,81122ee8 <__reset+0xfb102ee8>
81122f28:	19800017 	ldw	r6,0(r3)
81122f2c:	3144d83a 	srl	r2,r6,r5
81122f30:	114a983a 	sll	r5,r2,r5
81122f34:	317ff41e 	bne	r6,r5,81122f08 <__reset+0xfb102f08>
81122f38:	003feb06 	br	81122ee8 <__reset+0xfb102ee8>
81122f3c:	1085883a 	add	r2,r2,r2
81122f40:	1085883a 	add	r2,r2,r2
81122f44:	2087883a 	add	r3,r4,r2
81122f48:	003fe706 	br	81122ee8 <__reset+0xfb102ee8>
81122f4c:	f800283a 	ret
81122f50:	0005883a 	mov	r2,zero
81122f54:	f800283a 	ret

81122f58 <_read_r>:
81122f58:	defffd04 	addi	sp,sp,-12
81122f5c:	de00012e 	bgeu	sp,et,81122f64 <_read_r+0xc>
81122f60:	003b68fa 	trap	3
81122f64:	2805883a 	mov	r2,r5
81122f68:	dc000015 	stw	r16,0(sp)
81122f6c:	04204574 	movhi	r16,33045
81122f70:	dc400115 	stw	r17,4(sp)
81122f74:	300b883a 	mov	r5,r6
81122f78:	84216604 	addi	r16,r16,-31336
81122f7c:	2023883a 	mov	r17,r4
81122f80:	380d883a 	mov	r6,r7
81122f84:	1009883a 	mov	r4,r2
81122f88:	dfc00215 	stw	ra,8(sp)
81122f8c:	80000015 	stw	zero,0(r16)
81122f90:	112dad40 	call	8112dad4 <read>
81122f94:	00ffffc4 	movi	r3,-1
81122f98:	10c00526 	beq	r2,r3,81122fb0 <_read_r+0x58>
81122f9c:	dfc00217 	ldw	ra,8(sp)
81122fa0:	dc400117 	ldw	r17,4(sp)
81122fa4:	dc000017 	ldw	r16,0(sp)
81122fa8:	dec00304 	addi	sp,sp,12
81122fac:	f800283a 	ret
81122fb0:	80c00017 	ldw	r3,0(r16)
81122fb4:	183ff926 	beq	r3,zero,81122f9c <__reset+0xfb102f9c>
81122fb8:	88c00015 	stw	r3,0(r17)
81122fbc:	003ff706 	br	81122f9c <__reset+0xfb102f9c>

81122fc0 <_realloc_r>:
81122fc0:	defff604 	addi	sp,sp,-40
81122fc4:	de00012e 	bgeu	sp,et,81122fcc <_realloc_r+0xc>
81122fc8:	003b68fa 	trap	3
81122fcc:	dc800215 	stw	r18,8(sp)
81122fd0:	dfc00915 	stw	ra,36(sp)
81122fd4:	df000815 	stw	fp,32(sp)
81122fd8:	ddc00715 	stw	r23,28(sp)
81122fdc:	dd800615 	stw	r22,24(sp)
81122fe0:	dd400515 	stw	r21,20(sp)
81122fe4:	dd000415 	stw	r20,16(sp)
81122fe8:	dcc00315 	stw	r19,12(sp)
81122fec:	dc400115 	stw	r17,4(sp)
81122ff0:	dc000015 	stw	r16,0(sp)
81122ff4:	3025883a 	mov	r18,r6
81122ff8:	2800b726 	beq	r5,zero,811232d8 <_realloc_r+0x318>
81122ffc:	282b883a 	mov	r21,r5
81123000:	2029883a 	mov	r20,r4
81123004:	112e2b40 	call	8112e2b4 <__malloc_lock>
81123008:	a8bfff17 	ldw	r2,-4(r21)
8112300c:	043fff04 	movi	r16,-4
81123010:	90c002c4 	addi	r3,r18,11
81123014:	01000584 	movi	r4,22
81123018:	acfffe04 	addi	r19,r21,-8
8112301c:	1420703a 	and	r16,r2,r16
81123020:	20c0332e 	bgeu	r4,r3,811230f0 <_realloc_r+0x130>
81123024:	047ffe04 	movi	r17,-8
81123028:	1c62703a 	and	r17,r3,r17
8112302c:	8807883a 	mov	r3,r17
81123030:	88005816 	blt	r17,zero,81123194 <_realloc_r+0x1d4>
81123034:	8c805736 	bltu	r17,r18,81123194 <_realloc_r+0x1d4>
81123038:	80c0300e 	bge	r16,r3,811230fc <_realloc_r+0x13c>
8112303c:	07204534 	movhi	fp,33044
81123040:	e71ac004 	addi	fp,fp,27392
81123044:	e1c00217 	ldw	r7,8(fp)
81123048:	9c09883a 	add	r4,r19,r16
8112304c:	22000117 	ldw	r8,4(r4)
81123050:	21c06326 	beq	r4,r7,811231e0 <_realloc_r+0x220>
81123054:	017fff84 	movi	r5,-2
81123058:	414a703a 	and	r5,r8,r5
8112305c:	214b883a 	add	r5,r4,r5
81123060:	29800117 	ldw	r6,4(r5)
81123064:	3180004c 	andi	r6,r6,1
81123068:	30003f26 	beq	r6,zero,81123168 <_realloc_r+0x1a8>
8112306c:	1080004c 	andi	r2,r2,1
81123070:	10008326 	beq	r2,zero,81123280 <_realloc_r+0x2c0>
81123074:	900b883a 	mov	r5,r18
81123078:	a009883a 	mov	r4,r20
8112307c:	11174b80 	call	811174b8 <_malloc_r>
81123080:	1025883a 	mov	r18,r2
81123084:	10011e26 	beq	r2,zero,81123500 <_realloc_r+0x540>
81123088:	a93fff17 	ldw	r4,-4(r21)
8112308c:	10fffe04 	addi	r3,r2,-8
81123090:	00bfff84 	movi	r2,-2
81123094:	2084703a 	and	r2,r4,r2
81123098:	9885883a 	add	r2,r19,r2
8112309c:	1880ee26 	beq	r3,r2,81123458 <_realloc_r+0x498>
811230a0:	81bfff04 	addi	r6,r16,-4
811230a4:	00800904 	movi	r2,36
811230a8:	1180b836 	bltu	r2,r6,8112338c <_realloc_r+0x3cc>
811230ac:	00c004c4 	movi	r3,19
811230b0:	19809636 	bltu	r3,r6,8112330c <_realloc_r+0x34c>
811230b4:	9005883a 	mov	r2,r18
811230b8:	a807883a 	mov	r3,r21
811230bc:	19000017 	ldw	r4,0(r3)
811230c0:	11000015 	stw	r4,0(r2)
811230c4:	19000117 	ldw	r4,4(r3)
811230c8:	11000115 	stw	r4,4(r2)
811230cc:	18c00217 	ldw	r3,8(r3)
811230d0:	10c00215 	stw	r3,8(r2)
811230d4:	a80b883a 	mov	r5,r21
811230d8:	a009883a 	mov	r4,r20
811230dc:	1120f2c0 	call	81120f2c <_free_r>
811230e0:	a009883a 	mov	r4,r20
811230e4:	112e3dc0 	call	8112e3dc <__malloc_unlock>
811230e8:	9005883a 	mov	r2,r18
811230ec:	00001206 	br	81123138 <_realloc_r+0x178>
811230f0:	00c00404 	movi	r3,16
811230f4:	1823883a 	mov	r17,r3
811230f8:	003fce06 	br	81123034 <__reset+0xfb103034>
811230fc:	a825883a 	mov	r18,r21
81123100:	8445c83a 	sub	r2,r16,r17
81123104:	00c003c4 	movi	r3,15
81123108:	18802636 	bltu	r3,r2,811231a4 <_realloc_r+0x1e4>
8112310c:	99800117 	ldw	r6,4(r19)
81123110:	9c07883a 	add	r3,r19,r16
81123114:	3180004c 	andi	r6,r6,1
81123118:	3420b03a 	or	r16,r6,r16
8112311c:	9c000115 	stw	r16,4(r19)
81123120:	18800117 	ldw	r2,4(r3)
81123124:	10800054 	ori	r2,r2,1
81123128:	18800115 	stw	r2,4(r3)
8112312c:	a009883a 	mov	r4,r20
81123130:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81123134:	9005883a 	mov	r2,r18
81123138:	dfc00917 	ldw	ra,36(sp)
8112313c:	df000817 	ldw	fp,32(sp)
81123140:	ddc00717 	ldw	r23,28(sp)
81123144:	dd800617 	ldw	r22,24(sp)
81123148:	dd400517 	ldw	r21,20(sp)
8112314c:	dd000417 	ldw	r20,16(sp)
81123150:	dcc00317 	ldw	r19,12(sp)
81123154:	dc800217 	ldw	r18,8(sp)
81123158:	dc400117 	ldw	r17,4(sp)
8112315c:	dc000017 	ldw	r16,0(sp)
81123160:	dec00a04 	addi	sp,sp,40
81123164:	f800283a 	ret
81123168:	017fff04 	movi	r5,-4
8112316c:	414a703a 	and	r5,r8,r5
81123170:	814d883a 	add	r6,r16,r5
81123174:	30c01f16 	blt	r6,r3,811231f4 <_realloc_r+0x234>
81123178:	20800317 	ldw	r2,12(r4)
8112317c:	20c00217 	ldw	r3,8(r4)
81123180:	a825883a 	mov	r18,r21
81123184:	3021883a 	mov	r16,r6
81123188:	18800315 	stw	r2,12(r3)
8112318c:	10c00215 	stw	r3,8(r2)
81123190:	003fdb06 	br	81123100 <__reset+0xfb103100>
81123194:	00800304 	movi	r2,12
81123198:	a0800015 	stw	r2,0(r20)
8112319c:	0005883a 	mov	r2,zero
811231a0:	003fe506 	br	81123138 <__reset+0xfb103138>
811231a4:	98c00117 	ldw	r3,4(r19)
811231a8:	9c4b883a 	add	r5,r19,r17
811231ac:	11000054 	ori	r4,r2,1
811231b0:	18c0004c 	andi	r3,r3,1
811231b4:	1c62b03a 	or	r17,r3,r17
811231b8:	9c400115 	stw	r17,4(r19)
811231bc:	29000115 	stw	r4,4(r5)
811231c0:	2885883a 	add	r2,r5,r2
811231c4:	10c00117 	ldw	r3,4(r2)
811231c8:	29400204 	addi	r5,r5,8
811231cc:	a009883a 	mov	r4,r20
811231d0:	18c00054 	ori	r3,r3,1
811231d4:	10c00115 	stw	r3,4(r2)
811231d8:	1120f2c0 	call	81120f2c <_free_r>
811231dc:	003fd306 	br	8112312c <__reset+0xfb10312c>
811231e0:	017fff04 	movi	r5,-4
811231e4:	414a703a 	and	r5,r8,r5
811231e8:	89800404 	addi	r6,r17,16
811231ec:	8151883a 	add	r8,r16,r5
811231f0:	4180590e 	bge	r8,r6,81123358 <_realloc_r+0x398>
811231f4:	1080004c 	andi	r2,r2,1
811231f8:	103f9e1e 	bne	r2,zero,81123074 <__reset+0xfb103074>
811231fc:	adbffe17 	ldw	r22,-8(r21)
81123200:	00bfff04 	movi	r2,-4
81123204:	9dadc83a 	sub	r22,r19,r22
81123208:	b1800117 	ldw	r6,4(r22)
8112320c:	3084703a 	and	r2,r6,r2
81123210:	20002026 	beq	r4,zero,81123294 <_realloc_r+0x2d4>
81123214:	80af883a 	add	r23,r16,r2
81123218:	b96f883a 	add	r23,r23,r5
8112321c:	21c05f26 	beq	r4,r7,8112339c <_realloc_r+0x3dc>
81123220:	b8c01c16 	blt	r23,r3,81123294 <_realloc_r+0x2d4>
81123224:	20800317 	ldw	r2,12(r4)
81123228:	20c00217 	ldw	r3,8(r4)
8112322c:	81bfff04 	addi	r6,r16,-4
81123230:	01000904 	movi	r4,36
81123234:	18800315 	stw	r2,12(r3)
81123238:	10c00215 	stw	r3,8(r2)
8112323c:	b0c00217 	ldw	r3,8(r22)
81123240:	b0800317 	ldw	r2,12(r22)
81123244:	b4800204 	addi	r18,r22,8
81123248:	18800315 	stw	r2,12(r3)
8112324c:	10c00215 	stw	r3,8(r2)
81123250:	21801b36 	bltu	r4,r6,811232c0 <_realloc_r+0x300>
81123254:	008004c4 	movi	r2,19
81123258:	1180352e 	bgeu	r2,r6,81123330 <_realloc_r+0x370>
8112325c:	a8800017 	ldw	r2,0(r21)
81123260:	b0800215 	stw	r2,8(r22)
81123264:	a8800117 	ldw	r2,4(r21)
81123268:	b0800315 	stw	r2,12(r22)
8112326c:	008006c4 	movi	r2,27
81123270:	11807f36 	bltu	r2,r6,81123470 <_realloc_r+0x4b0>
81123274:	b0800404 	addi	r2,r22,16
81123278:	ad400204 	addi	r21,r21,8
8112327c:	00002d06 	br	81123334 <_realloc_r+0x374>
81123280:	adbffe17 	ldw	r22,-8(r21)
81123284:	00bfff04 	movi	r2,-4
81123288:	9dadc83a 	sub	r22,r19,r22
8112328c:	b1000117 	ldw	r4,4(r22)
81123290:	2084703a 	and	r2,r4,r2
81123294:	b03f7726 	beq	r22,zero,81123074 <__reset+0xfb103074>
81123298:	80af883a 	add	r23,r16,r2
8112329c:	b8ff7516 	blt	r23,r3,81123074 <__reset+0xfb103074>
811232a0:	b0800317 	ldw	r2,12(r22)
811232a4:	b0c00217 	ldw	r3,8(r22)
811232a8:	81bfff04 	addi	r6,r16,-4
811232ac:	01000904 	movi	r4,36
811232b0:	18800315 	stw	r2,12(r3)
811232b4:	10c00215 	stw	r3,8(r2)
811232b8:	b4800204 	addi	r18,r22,8
811232bc:	21bfe52e 	bgeu	r4,r6,81123254 <__reset+0xfb103254>
811232c0:	a80b883a 	mov	r5,r21
811232c4:	9009883a 	mov	r4,r18
811232c8:	1121da00 	call	81121da0 <memmove>
811232cc:	b821883a 	mov	r16,r23
811232d0:	b027883a 	mov	r19,r22
811232d4:	003f8a06 	br	81123100 <__reset+0xfb103100>
811232d8:	300b883a 	mov	r5,r6
811232dc:	dfc00917 	ldw	ra,36(sp)
811232e0:	df000817 	ldw	fp,32(sp)
811232e4:	ddc00717 	ldw	r23,28(sp)
811232e8:	dd800617 	ldw	r22,24(sp)
811232ec:	dd400517 	ldw	r21,20(sp)
811232f0:	dd000417 	ldw	r20,16(sp)
811232f4:	dcc00317 	ldw	r19,12(sp)
811232f8:	dc800217 	ldw	r18,8(sp)
811232fc:	dc400117 	ldw	r17,4(sp)
81123300:	dc000017 	ldw	r16,0(sp)
81123304:	dec00a04 	addi	sp,sp,40
81123308:	11174b81 	jmpi	811174b8 <_malloc_r>
8112330c:	a8c00017 	ldw	r3,0(r21)
81123310:	90c00015 	stw	r3,0(r18)
81123314:	a8c00117 	ldw	r3,4(r21)
81123318:	90c00115 	stw	r3,4(r18)
8112331c:	00c006c4 	movi	r3,27
81123320:	19804536 	bltu	r3,r6,81123438 <_realloc_r+0x478>
81123324:	90800204 	addi	r2,r18,8
81123328:	a8c00204 	addi	r3,r21,8
8112332c:	003f6306 	br	811230bc <__reset+0xfb1030bc>
81123330:	9005883a 	mov	r2,r18
81123334:	a8c00017 	ldw	r3,0(r21)
81123338:	b821883a 	mov	r16,r23
8112333c:	b027883a 	mov	r19,r22
81123340:	10c00015 	stw	r3,0(r2)
81123344:	a8c00117 	ldw	r3,4(r21)
81123348:	10c00115 	stw	r3,4(r2)
8112334c:	a8c00217 	ldw	r3,8(r21)
81123350:	10c00215 	stw	r3,8(r2)
81123354:	003f6a06 	br	81123100 <__reset+0xfb103100>
81123358:	9c67883a 	add	r19,r19,r17
8112335c:	4445c83a 	sub	r2,r8,r17
81123360:	e4c00215 	stw	r19,8(fp)
81123364:	10800054 	ori	r2,r2,1
81123368:	98800115 	stw	r2,4(r19)
8112336c:	a8bfff17 	ldw	r2,-4(r21)
81123370:	a009883a 	mov	r4,r20
81123374:	1080004c 	andi	r2,r2,1
81123378:	1462b03a 	or	r17,r2,r17
8112337c:	ac7fff15 	stw	r17,-4(r21)
81123380:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81123384:	a805883a 	mov	r2,r21
81123388:	003f6b06 	br	81123138 <__reset+0xfb103138>
8112338c:	a80b883a 	mov	r5,r21
81123390:	9009883a 	mov	r4,r18
81123394:	1121da00 	call	81121da0 <memmove>
81123398:	003f4e06 	br	811230d4 <__reset+0xfb1030d4>
8112339c:	89000404 	addi	r4,r17,16
811233a0:	b93fbc16 	blt	r23,r4,81123294 <__reset+0xfb103294>
811233a4:	b0800317 	ldw	r2,12(r22)
811233a8:	b0c00217 	ldw	r3,8(r22)
811233ac:	81bfff04 	addi	r6,r16,-4
811233b0:	01000904 	movi	r4,36
811233b4:	18800315 	stw	r2,12(r3)
811233b8:	10c00215 	stw	r3,8(r2)
811233bc:	b4800204 	addi	r18,r22,8
811233c0:	21804336 	bltu	r4,r6,811234d0 <_realloc_r+0x510>
811233c4:	008004c4 	movi	r2,19
811233c8:	11803f2e 	bgeu	r2,r6,811234c8 <_realloc_r+0x508>
811233cc:	a8800017 	ldw	r2,0(r21)
811233d0:	b0800215 	stw	r2,8(r22)
811233d4:	a8800117 	ldw	r2,4(r21)
811233d8:	b0800315 	stw	r2,12(r22)
811233dc:	008006c4 	movi	r2,27
811233e0:	11803f36 	bltu	r2,r6,811234e0 <_realloc_r+0x520>
811233e4:	b0800404 	addi	r2,r22,16
811233e8:	ad400204 	addi	r21,r21,8
811233ec:	a8c00017 	ldw	r3,0(r21)
811233f0:	10c00015 	stw	r3,0(r2)
811233f4:	a8c00117 	ldw	r3,4(r21)
811233f8:	10c00115 	stw	r3,4(r2)
811233fc:	a8c00217 	ldw	r3,8(r21)
81123400:	10c00215 	stw	r3,8(r2)
81123404:	b447883a 	add	r3,r22,r17
81123408:	bc45c83a 	sub	r2,r23,r17
8112340c:	e0c00215 	stw	r3,8(fp)
81123410:	10800054 	ori	r2,r2,1
81123414:	18800115 	stw	r2,4(r3)
81123418:	b0800117 	ldw	r2,4(r22)
8112341c:	a009883a 	mov	r4,r20
81123420:	1080004c 	andi	r2,r2,1
81123424:	1462b03a 	or	r17,r2,r17
81123428:	b4400115 	stw	r17,4(r22)
8112342c:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81123430:	9005883a 	mov	r2,r18
81123434:	003f4006 	br	81123138 <__reset+0xfb103138>
81123438:	a8c00217 	ldw	r3,8(r21)
8112343c:	90c00215 	stw	r3,8(r18)
81123440:	a8c00317 	ldw	r3,12(r21)
81123444:	90c00315 	stw	r3,12(r18)
81123448:	30801126 	beq	r6,r2,81123490 <_realloc_r+0x4d0>
8112344c:	90800404 	addi	r2,r18,16
81123450:	a8c00404 	addi	r3,r21,16
81123454:	003f1906 	br	811230bc <__reset+0xfb1030bc>
81123458:	90ffff17 	ldw	r3,-4(r18)
8112345c:	00bfff04 	movi	r2,-4
81123460:	a825883a 	mov	r18,r21
81123464:	1884703a 	and	r2,r3,r2
81123468:	80a1883a 	add	r16,r16,r2
8112346c:	003f2406 	br	81123100 <__reset+0xfb103100>
81123470:	a8800217 	ldw	r2,8(r21)
81123474:	b0800415 	stw	r2,16(r22)
81123478:	a8800317 	ldw	r2,12(r21)
8112347c:	b0800515 	stw	r2,20(r22)
81123480:	31000a26 	beq	r6,r4,811234ac <_realloc_r+0x4ec>
81123484:	b0800604 	addi	r2,r22,24
81123488:	ad400404 	addi	r21,r21,16
8112348c:	003fa906 	br	81123334 <__reset+0xfb103334>
81123490:	a9000417 	ldw	r4,16(r21)
81123494:	90800604 	addi	r2,r18,24
81123498:	a8c00604 	addi	r3,r21,24
8112349c:	91000415 	stw	r4,16(r18)
811234a0:	a9000517 	ldw	r4,20(r21)
811234a4:	91000515 	stw	r4,20(r18)
811234a8:	003f0406 	br	811230bc <__reset+0xfb1030bc>
811234ac:	a8c00417 	ldw	r3,16(r21)
811234b0:	ad400604 	addi	r21,r21,24
811234b4:	b0800804 	addi	r2,r22,32
811234b8:	b0c00615 	stw	r3,24(r22)
811234bc:	a8ffff17 	ldw	r3,-4(r21)
811234c0:	b0c00715 	stw	r3,28(r22)
811234c4:	003f9b06 	br	81123334 <__reset+0xfb103334>
811234c8:	9005883a 	mov	r2,r18
811234cc:	003fc706 	br	811233ec <__reset+0xfb1033ec>
811234d0:	a80b883a 	mov	r5,r21
811234d4:	9009883a 	mov	r4,r18
811234d8:	1121da00 	call	81121da0 <memmove>
811234dc:	003fc906 	br	81123404 <__reset+0xfb103404>
811234e0:	a8800217 	ldw	r2,8(r21)
811234e4:	b0800415 	stw	r2,16(r22)
811234e8:	a8800317 	ldw	r2,12(r21)
811234ec:	b0800515 	stw	r2,20(r22)
811234f0:	31000726 	beq	r6,r4,81123510 <_realloc_r+0x550>
811234f4:	b0800604 	addi	r2,r22,24
811234f8:	ad400404 	addi	r21,r21,16
811234fc:	003fbb06 	br	811233ec <__reset+0xfb1033ec>
81123500:	a009883a 	mov	r4,r20
81123504:	112e3dc0 	call	8112e3dc <__malloc_unlock>
81123508:	0005883a 	mov	r2,zero
8112350c:	003f0a06 	br	81123138 <__reset+0xfb103138>
81123510:	a8c00417 	ldw	r3,16(r21)
81123514:	ad400604 	addi	r21,r21,24
81123518:	b0800804 	addi	r2,r22,32
8112351c:	b0c00615 	stw	r3,24(r22)
81123520:	a8ffff17 	ldw	r3,-4(r21)
81123524:	b0c00715 	stw	r3,28(r22)
81123528:	003fb006 	br	811233ec <__reset+0xfb1033ec>

8112352c <__fpclassifyd>:
8112352c:	00a00034 	movhi	r2,32768
81123530:	10bfffc4 	addi	r2,r2,-1
81123534:	2884703a 	and	r2,r5,r2
81123538:	10000726 	beq	r2,zero,81123558 <__fpclassifyd+0x2c>
8112353c:	00fffc34 	movhi	r3,65520
81123540:	019ff834 	movhi	r6,32736
81123544:	28c7883a 	add	r3,r5,r3
81123548:	31bfffc4 	addi	r6,r6,-1
8112354c:	30c00536 	bltu	r6,r3,81123564 <__fpclassifyd+0x38>
81123550:	00800104 	movi	r2,4
81123554:	f800283a 	ret
81123558:	2000021e 	bne	r4,zero,81123564 <__fpclassifyd+0x38>
8112355c:	00800084 	movi	r2,2
81123560:	f800283a 	ret
81123564:	00dffc34 	movhi	r3,32752
81123568:	019ff834 	movhi	r6,32736
8112356c:	28cb883a 	add	r5,r5,r3
81123570:	31bfffc4 	addi	r6,r6,-1
81123574:	317ff62e 	bgeu	r6,r5,81123550 <__reset+0xfb103550>
81123578:	01400434 	movhi	r5,16
8112357c:	297fffc4 	addi	r5,r5,-1
81123580:	28800236 	bltu	r5,r2,8112358c <__fpclassifyd+0x60>
81123584:	008000c4 	movi	r2,3
81123588:	f800283a 	ret
8112358c:	10c00226 	beq	r2,r3,81123598 <__fpclassifyd+0x6c>
81123590:	0005883a 	mov	r2,zero
81123594:	f800283a 	ret
81123598:	2005003a 	cmpeq	r2,r4,zero
8112359c:	f800283a 	ret

811235a0 <__sccl>:
811235a0:	2a000003 	ldbu	r8,0(r5)
811235a4:	00801784 	movi	r2,94
811235a8:	40802a26 	beq	r8,r2,81123654 <__sccl+0xb4>
811235ac:	29400044 	addi	r5,r5,1
811235b0:	000f883a 	mov	r7,zero
811235b4:	0013883a 	mov	r9,zero
811235b8:	2007883a 	mov	r3,r4
811235bc:	21804004 	addi	r6,r4,256
811235c0:	19c00005 	stb	r7,0(r3)
811235c4:	18c00044 	addi	r3,r3,1
811235c8:	19bffd1e 	bne	r3,r6,811235c0 <__reset+0xfb1035c0>
811235cc:	40001126 	beq	r8,zero,81123614 <__sccl+0x74>
811235d0:	00800044 	movi	r2,1
811235d4:	124fc83a 	sub	r7,r2,r9
811235d8:	02800b44 	movi	r10,45
811235dc:	02c01744 	movi	r11,93
811235e0:	2205883a 	add	r2,r4,r8
811235e4:	11c00005 	stb	r7,0(r2)
811235e8:	28800044 	addi	r2,r5,1
811235ec:	28c00003 	ldbu	r3,0(r5)
811235f0:	1a800a26 	beq	r3,r10,8112361c <__sccl+0x7c>
811235f4:	1ac00426 	beq	r3,r11,81123608 <__sccl+0x68>
811235f8:	18000426 	beq	r3,zero,8112360c <__sccl+0x6c>
811235fc:	1811883a 	mov	r8,r3
81123600:	100b883a 	mov	r5,r2
81123604:	003ff606 	br	811235e0 <__reset+0xfb1035e0>
81123608:	f800283a 	ret
8112360c:	2805883a 	mov	r2,r5
81123610:	f800283a 	ret
81123614:	28bfffc4 	addi	r2,r5,-1
81123618:	f800283a 	ret
8112361c:	12400003 	ldbu	r9,0(r2)
81123620:	4ac01126 	beq	r9,r11,81123668 <__sccl+0xc8>
81123624:	4a001016 	blt	r9,r8,81123668 <__sccl+0xc8>
81123628:	41800044 	addi	r6,r8,1
8112362c:	29400084 	addi	r5,r5,2
81123630:	2187883a 	add	r3,r4,r6
81123634:	00000106 	br	8112363c <__sccl+0x9c>
81123638:	31800044 	addi	r6,r6,1
8112363c:	19c00005 	stb	r7,0(r3)
81123640:	3011883a 	mov	r8,r6
81123644:	18c00044 	addi	r3,r3,1
81123648:	327ffb16 	blt	r6,r9,81123638 <__reset+0xfb103638>
8112364c:	10800084 	addi	r2,r2,2
81123650:	003fe606 	br	811235ec <__reset+0xfb1035ec>
81123654:	2a000043 	ldbu	r8,1(r5)
81123658:	01c00044 	movi	r7,1
8112365c:	29400084 	addi	r5,r5,2
81123660:	02400044 	movi	r9,1
81123664:	003fd406 	br	811235b8 <__reset+0xfb1035b8>
81123668:	5011883a 	mov	r8,r10
8112366c:	003fe406 	br	81123600 <__reset+0xfb103600>

81123670 <nanf>:
81123670:	009ff034 	movhi	r2,32704
81123674:	f800283a 	ret

81123678 <strcmp>:
81123678:	2144b03a 	or	r2,r4,r5
8112367c:	108000cc 	andi	r2,r2,3
81123680:	1000171e 	bne	r2,zero,811236e0 <strcmp+0x68>
81123684:	20800017 	ldw	r2,0(r4)
81123688:	28c00017 	ldw	r3,0(r5)
8112368c:	10c0141e 	bne	r2,r3,811236e0 <strcmp+0x68>
81123690:	027fbff4 	movhi	r9,65279
81123694:	4a7fbfc4 	addi	r9,r9,-257
81123698:	0086303a 	nor	r3,zero,r2
8112369c:	02202074 	movhi	r8,32897
811236a0:	1245883a 	add	r2,r2,r9
811236a4:	42202004 	addi	r8,r8,-32640
811236a8:	10c4703a 	and	r2,r2,r3
811236ac:	1204703a 	and	r2,r2,r8
811236b0:	10000226 	beq	r2,zero,811236bc <strcmp+0x44>
811236b4:	00002306 	br	81123744 <strcmp+0xcc>
811236b8:	1000221e 	bne	r2,zero,81123744 <strcmp+0xcc>
811236bc:	21000104 	addi	r4,r4,4
811236c0:	20c00017 	ldw	r3,0(r4)
811236c4:	29400104 	addi	r5,r5,4
811236c8:	29800017 	ldw	r6,0(r5)
811236cc:	1a4f883a 	add	r7,r3,r9
811236d0:	00c4303a 	nor	r2,zero,r3
811236d4:	3884703a 	and	r2,r7,r2
811236d8:	1204703a 	and	r2,r2,r8
811236dc:	19bff626 	beq	r3,r6,811236b8 <__reset+0xfb1036b8>
811236e0:	20800003 	ldbu	r2,0(r4)
811236e4:	10c03fcc 	andi	r3,r2,255
811236e8:	18c0201c 	xori	r3,r3,128
811236ec:	18ffe004 	addi	r3,r3,-128
811236f0:	18000c26 	beq	r3,zero,81123724 <strcmp+0xac>
811236f4:	29800007 	ldb	r6,0(r5)
811236f8:	19800326 	beq	r3,r6,81123708 <strcmp+0x90>
811236fc:	00001306 	br	8112374c <strcmp+0xd4>
81123700:	29800007 	ldb	r6,0(r5)
81123704:	11800b1e 	bne	r2,r6,81123734 <strcmp+0xbc>
81123708:	21000044 	addi	r4,r4,1
8112370c:	20c00003 	ldbu	r3,0(r4)
81123710:	29400044 	addi	r5,r5,1
81123714:	18803fcc 	andi	r2,r3,255
81123718:	1080201c 	xori	r2,r2,128
8112371c:	10bfe004 	addi	r2,r2,-128
81123720:	103ff71e 	bne	r2,zero,81123700 <__reset+0xfb103700>
81123724:	0007883a 	mov	r3,zero
81123728:	28800003 	ldbu	r2,0(r5)
8112372c:	1885c83a 	sub	r2,r3,r2
81123730:	f800283a 	ret
81123734:	28800003 	ldbu	r2,0(r5)
81123738:	18c03fcc 	andi	r3,r3,255
8112373c:	1885c83a 	sub	r2,r3,r2
81123740:	f800283a 	ret
81123744:	0005883a 	mov	r2,zero
81123748:	f800283a 	ret
8112374c:	10c03fcc 	andi	r3,r2,255
81123750:	003ff506 	br	81123728 <__reset+0xfb103728>

81123754 <sulp>:
81123754:	defffd04 	addi	sp,sp,-12
81123758:	de00012e 	bgeu	sp,et,81123760 <sulp+0xc>
8112375c:	003b68fa 	trap	3
81123760:	dc400115 	stw	r17,4(sp)
81123764:	3023883a 	mov	r17,r6
81123768:	dc000015 	stw	r16,0(sp)
8112376c:	dfc00215 	stw	ra,8(sp)
81123770:	2821883a 	mov	r16,r5
81123774:	1122a600 	call	81122a60 <__ulp>
81123778:	88000c26 	beq	r17,zero,811237ac <sulp+0x58>
8112377c:	841ffc2c 	andhi	r16,r16,32752
81123780:	8020d53a 	srli	r16,r16,20
81123784:	01c01ac4 	movi	r7,107
81123788:	3c21c83a 	sub	r16,r7,r16
8112378c:	0400070e 	bge	zero,r16,811237ac <sulp+0x58>
81123790:	8020953a 	slli	r16,r16,20
81123794:	01cffc34 	movhi	r7,16368
81123798:	000d883a 	mov	r6,zero
8112379c:	81cf883a 	add	r7,r16,r7
811237a0:	1009883a 	mov	r4,r2
811237a4:	180b883a 	mov	r5,r3
811237a8:	111607c0 	call	8111607c <__muldf3>
811237ac:	dfc00217 	ldw	ra,8(sp)
811237b0:	dc400117 	ldw	r17,4(sp)
811237b4:	dc000017 	ldw	r16,0(sp)
811237b8:	dec00304 	addi	sp,sp,12
811237bc:	f800283a 	ret

811237c0 <_strtod_r>:
811237c0:	deffe204 	addi	sp,sp,-120
811237c4:	de00012e 	bgeu	sp,et,811237cc <_strtod_r+0xc>
811237c8:	003b68fa 	trap	3
811237cc:	ddc01b15 	stw	r23,108(sp)
811237d0:	dd001815 	stw	r20,96(sp)
811237d4:	dc801615 	stw	r18,88(sp)
811237d8:	dc401515 	stw	r17,84(sp)
811237dc:	dc001415 	stw	r16,80(sp)
811237e0:	d9400615 	stw	r5,24(sp)
811237e4:	dfc01d15 	stw	ra,116(sp)
811237e8:	df001c15 	stw	fp,112(sp)
811237ec:	dd801a15 	stw	r22,104(sp)
811237f0:	dd401915 	stw	r21,100(sp)
811237f4:	dcc01715 	stw	r19,92(sp)
811237f8:	2021883a 	mov	r16,r4
811237fc:	d8000515 	stw	zero,20(sp)
81123800:	2809883a 	mov	r4,r5
81123804:	20800003 	ldbu	r2,0(r4)
81123808:	01e044b4 	movhi	r7,33042
8112380c:	282f883a 	mov	r23,r5
81123810:	10c03fcc 	andi	r3,r2,255
81123814:	01400b44 	movi	r5,45
81123818:	39ce0f04 	addi	r7,r7,14396
8112381c:	3029883a 	mov	r20,r6
81123820:	0025883a 	mov	r18,zero
81123824:	0023883a 	mov	r17,zero
81123828:	28c0ba36 	bltu	r5,r3,81123b14 <_strtod_r+0x354>
8112382c:	180690ba 	slli	r3,r3,2
81123830:	19c7883a 	add	r3,r3,r7
81123834:	18c00017 	ldw	r3,0(r3)
81123838:	1800683a 	jmp	r3
8112383c:	811238fc 	xorhi	r4,r16,18659
81123840:	81123b14 	ori	r4,r16,18668
81123844:	81123b14 	ori	r4,r16,18668
81123848:	81123b14 	ori	r4,r16,18668
8112384c:	81123b14 	ori	r4,r16,18668
81123850:	81123b14 	ori	r4,r16,18668
81123854:	81123b14 	ori	r4,r16,18668
81123858:	81123b14 	ori	r4,r16,18668
8112385c:	81123b14 	ori	r4,r16,18668
81123860:	81123b00 	call	881123b0 <__reset+0x20f23b0>
81123864:	81123b00 	call	881123b0 <__reset+0x20f23b0>
81123868:	81123b00 	call	881123b0 <__reset+0x20f23b0>
8112386c:	81123b00 	call	881123b0 <__reset+0x20f23b0>
81123870:	81123b00 	call	881123b0 <__reset+0x20f23b0>
81123874:	81123b14 	ori	r4,r16,18668
81123878:	81123b14 	ori	r4,r16,18668
8112387c:	81123b14 	ori	r4,r16,18668
81123880:	81123b14 	ori	r4,r16,18668
81123884:	81123b14 	ori	r4,r16,18668
81123888:	81123b14 	ori	r4,r16,18668
8112388c:	81123b14 	ori	r4,r16,18668
81123890:	81123b14 	ori	r4,r16,18668
81123894:	81123b14 	ori	r4,r16,18668
81123898:	81123b14 	ori	r4,r16,18668
8112389c:	81123b14 	ori	r4,r16,18668
811238a0:	81123b14 	ori	r4,r16,18668
811238a4:	81123b14 	ori	r4,r16,18668
811238a8:	81123b14 	ori	r4,r16,18668
811238ac:	81123b14 	ori	r4,r16,18668
811238b0:	81123b14 	ori	r4,r16,18668
811238b4:	81123b14 	ori	r4,r16,18668
811238b8:	81123b14 	ori	r4,r16,18668
811238bc:	81123b00 	call	881123b0 <__reset+0x20f23b0>
811238c0:	81123b14 	ori	r4,r16,18668
811238c4:	81123b14 	ori	r4,r16,18668
811238c8:	81123b14 	ori	r4,r16,18668
811238cc:	81123b14 	ori	r4,r16,18668
811238d0:	81123b14 	ori	r4,r16,18668
811238d4:	81123b14 	ori	r4,r16,18668
811238d8:	81123b14 	ori	r4,r16,18668
811238dc:	81123b14 	ori	r4,r16,18668
811238e0:	81123b14 	ori	r4,r16,18668
811238e4:	81123b14 	ori	r4,r16,18668
811238e8:	81123954 	ori	r4,r16,18661
811238ec:	81123b14 	ori	r4,r16,18668
811238f0:	81123af4 	orhi	r4,r16,18667
811238f4:	00801244 	movi	r2,73
811238f8:	88843526 	beq	r17,r2,811249d0 <_strtod_r+0x1210>
811238fc:	002b883a 	mov	r21,zero
81123900:	002d883a 	mov	r22,zero
81123904:	a0000526 	beq	r20,zero,8112391c <_strtod_r+0x15c>
81123908:	d8000715 	stw	zero,28(sp)
8112390c:	a5c00015 	stw	r23,0(r20)
81123910:	d9000717 	ldw	r4,28(sp)
81123914:	20000126 	beq	r4,zero,8112391c <_strtod_r+0x15c>
81123918:	b5a0003c 	xorhi	r22,r22,32768
8112391c:	a805883a 	mov	r2,r21
81123920:	b007883a 	mov	r3,r22
81123924:	dfc01d17 	ldw	ra,116(sp)
81123928:	df001c17 	ldw	fp,112(sp)
8112392c:	ddc01b17 	ldw	r23,108(sp)
81123930:	dd801a17 	ldw	r22,104(sp)
81123934:	dd401917 	ldw	r21,100(sp)
81123938:	dd001817 	ldw	r20,96(sp)
8112393c:	dcc01717 	ldw	r19,92(sp)
81123940:	dc801617 	ldw	r18,88(sp)
81123944:	dc401517 	ldw	r17,84(sp)
81123948:	dc001417 	ldw	r16,80(sp)
8112394c:	dec01e04 	addi	sp,sp,120
81123950:	f800283a 	ret
81123954:	d8000715 	stw	zero,28(sp)
81123958:	24c00044 	addi	r19,r4,1
8112395c:	dcc00615 	stw	r19,24(sp)
81123960:	20800043 	ldbu	r2,1(r4)
81123964:	10c03fcc 	andi	r3,r2,255
81123968:	18c0201c 	xori	r3,r3,128
8112396c:	18ffe004 	addi	r3,r3,-128
81123970:	183fe226 	beq	r3,zero,811238fc <__reset+0xfb1038fc>
81123974:	11403fcc 	andi	r5,r2,255
81123978:	2940201c 	xori	r5,r5,128
8112397c:	297fe004 	addi	r5,r5,-128
81123980:	00c00c04 	movi	r3,48
81123984:	28c0e526 	beq	r5,r3,81123d1c <_strtod_r+0x55c>
81123988:	dcc00815 	stw	r19,32(sp)
8112398c:	0025883a 	mov	r18,zero
81123990:	10fff404 	addi	r3,r2,-48
81123994:	18c03fcc 	andi	r3,r3,255
81123998:	01000244 	movi	r4,9
8112399c:	20c37536 	bltu	r4,r3,81124774 <_strtod_r+0xfb4>
811239a0:	dd400817 	ldw	r21,32(sp)
811239a4:	0027883a 	mov	r19,zero
811239a8:	0039883a 	mov	fp,zero
811239ac:	002d883a 	mov	r22,zero
811239b0:	01400204 	movi	r5,8
811239b4:	2d805a16 	blt	r5,r22,81123b20 <_strtod_r+0x360>
811239b8:	e70002a4 	muli	fp,fp,10
811239bc:	10c03fcc 	andi	r3,r2,255
811239c0:	18c0201c 	xori	r3,r3,128
811239c4:	18ffe004 	addi	r3,r3,-128
811239c8:	e0f9883a 	add	fp,fp,r3
811239cc:	e73ff404 	addi	fp,fp,-48
811239d0:	ad400044 	addi	r21,r21,1
811239d4:	dd400615 	stw	r21,24(sp)
811239d8:	a8800003 	ldbu	r2,0(r21)
811239dc:	b5800044 	addi	r22,r22,1
811239e0:	10fff404 	addi	r3,r2,-48
811239e4:	18c03fcc 	andi	r3,r3,255
811239e8:	20fff22e 	bgeu	r4,r3,811239b4 <__reset+0xfb1039b4>
811239ec:	14403fcc 	andi	r17,r2,255
811239f0:	8c40201c 	xori	r17,r17,128
811239f4:	8c7fe004 	addi	r17,r17,-128
811239f8:	8009883a 	mov	r4,r16
811239fc:	11219e00 	call	811219e0 <_localeconv_r>
81123a00:	11400017 	ldw	r5,0(r2)
81123a04:	8009883a 	mov	r4,r16
81123a08:	d9401315 	stw	r5,76(sp)
81123a0c:	11219e00 	call	811219e0 <_localeconv_r>
81123a10:	11000017 	ldw	r4,0(r2)
81123a14:	11187c00 	call	811187c0 <strlen>
81123a18:	d9401317 	ldw	r5,76(sp)
81123a1c:	100d883a 	mov	r6,r2
81123a20:	a809883a 	mov	r4,r21
81123a24:	11293b00 	call	811293b0 <strncmp>
81123a28:	1000ce26 	beq	r2,zero,81123d64 <_strtod_r+0x5a4>
81123a2c:	b013883a 	mov	r9,r22
81123a30:	000b883a 	mov	r5,zero
81123a34:	0015883a 	mov	r10,zero
81123a38:	0017883a 	mov	r11,zero
81123a3c:	00801944 	movi	r2,101
81123a40:	88807826 	beq	r17,r2,81123c24 <_strtod_r+0x464>
81123a44:	00801144 	movi	r2,69
81123a48:	88807626 	beq	r17,r2,81123c24 <_strtod_r+0x464>
81123a4c:	002b883a 	mov	r21,zero
81123a50:	48003d1e 	bne	r9,zero,81123b48 <_strtod_r+0x388>
81123a54:	2800391e 	bne	r5,zero,81123b3c <_strtod_r+0x37c>
81123a58:	9000381e 	bne	r18,zero,81123b3c <_strtod_r+0x37c>
81123a5c:	583fa71e 	bne	r11,zero,811238fc <__reset+0xfb1038fc>
81123a60:	00801384 	movi	r2,78
81123a64:	88800526 	beq	r17,r2,81123a7c <_strtod_r+0x2bc>
81123a68:	147fa20e 	bge	r2,r17,811238f4 <__reset+0xfb1038f4>
81123a6c:	00801a44 	movi	r2,105
81123a70:	8883d726 	beq	r17,r2,811249d0 <_strtod_r+0x1210>
81123a74:	00801b84 	movi	r2,110
81123a78:	88bfa01e 	bne	r17,r2,811238fc <__reset+0xfb1038fc>
81123a7c:	01604534 	movhi	r5,33044
81123a80:	d9000617 	ldw	r4,24(sp)
81123a84:	2957a804 	addi	r5,r5,24224
81123a88:	01c00644 	movi	r7,25
81123a8c:	00000b06 	br	81123abc <_strtod_r+0x2fc>
81123a90:	21000044 	addi	r4,r4,1
81123a94:	20800003 	ldbu	r2,0(r4)
81123a98:	10ffefc4 	addi	r3,r2,-65
81123a9c:	10803fcc 	andi	r2,r2,255
81123aa0:	1080201c 	xori	r2,r2,128
81123aa4:	18c03fcc 	andi	r3,r3,255
81123aa8:	10bfe004 	addi	r2,r2,-128
81123aac:	38c00136 	bltu	r7,r3,81123ab4 <_strtod_r+0x2f4>
81123ab0:	10800804 	addi	r2,r2,32
81123ab4:	29400044 	addi	r5,r5,1
81123ab8:	11bf901e 	bne	r2,r6,811238fc <__reset+0xfb1038fc>
81123abc:	29800007 	ldb	r6,0(r5)
81123ac0:	303ff31e 	bne	r6,zero,81123a90 <__reset+0xfb103a90>
81123ac4:	20800044 	addi	r2,r4,1
81123ac8:	d8800615 	stw	r2,24(sp)
81123acc:	20c00047 	ldb	r3,1(r4)
81123ad0:	00800a04 	movi	r2,40
81123ad4:	18849d26 	beq	r3,r2,81124d4c <_strtod_r+0x158c>
81123ad8:	047ffe34 	movhi	r17,65528
81123adc:	0025883a 	mov	r18,zero
81123ae0:	902b883a 	mov	r21,r18
81123ae4:	882d883a 	mov	r22,r17
81123ae8:	a03f8926 	beq	r20,zero,81123910 <__reset+0xfb103910>
81123aec:	ddc00617 	ldw	r23,24(sp)
81123af0:	003f8606 	br	8112390c <__reset+0xfb10390c>
81123af4:	00800044 	movi	r2,1
81123af8:	d8800715 	stw	r2,28(sp)
81123afc:	003f9606 	br	81123958 <__reset+0xfb103958>
81123b00:	21000044 	addi	r4,r4,1
81123b04:	d9000615 	stw	r4,24(sp)
81123b08:	20800003 	ldbu	r2,0(r4)
81123b0c:	10c03fcc 	andi	r3,r2,255
81123b10:	28ff462e 	bgeu	r5,r3,8112382c <__reset+0xfb10382c>
81123b14:	2027883a 	mov	r19,r4
81123b18:	d8000715 	stw	zero,28(sp)
81123b1c:	003f9506 	br	81123974 <__reset+0xfb103974>
81123b20:	9cc002a4 	muli	r19,r19,10
81123b24:	10803fcc 	andi	r2,r2,255
81123b28:	1080201c 	xori	r2,r2,128
81123b2c:	10bfe004 	addi	r2,r2,-128
81123b30:	9885883a 	add	r2,r19,r2
81123b34:	14fff404 	addi	r19,r2,-48
81123b38:	003fa506 	br	811239d0 <__reset+0xfb1039d0>
81123b3c:	002b883a 	mov	r21,zero
81123b40:	002d883a 	mov	r22,zero
81123b44:	003fe806 	br	81123ae8 <__reset+0xfb103ae8>
81123b48:	aaabc83a 	sub	r21,r21,r10
81123b4c:	b000011e 	bne	r22,zero,81123b54 <_strtod_r+0x394>
81123b50:	482d883a 	mov	r22,r9
81123b54:	00800404 	movi	r2,16
81123b58:	482f883a 	mov	r23,r9
81123b5c:	1240010e 	bge	r2,r9,81123b64 <_strtod_r+0x3a4>
81123b60:	102f883a 	mov	r23,r2
81123b64:	e009883a 	mov	r4,fp
81123b68:	da401315 	stw	r9,76(sp)
81123b6c:	112c3d00 	call	8112c3d0 <__floatunsidf>
81123b70:	1025883a 	mov	r18,r2
81123b74:	00800244 	movi	r2,9
81123b78:	1823883a 	mov	r17,r3
81123b7c:	da401317 	ldw	r9,76(sp)
81123b80:	15c0160e 	bge	r2,r23,81123bdc <_strtod_r+0x41c>
81123b84:	b8bffdc4 	addi	r2,r23,-9
81123b88:	100490fa 	slli	r2,r2,3
81123b8c:	180b883a 	mov	r5,r3
81123b90:	00e04534 	movhi	r3,33044
81123b94:	18d77304 	addi	r3,r3,24012
81123b98:	1885883a 	add	r2,r3,r2
81123b9c:	11800017 	ldw	r6,0(r2)
81123ba0:	11c00117 	ldw	r7,4(r2)
81123ba4:	9009883a 	mov	r4,r18
81123ba8:	111607c0 	call	8111607c <__muldf3>
81123bac:	9809883a 	mov	r4,r19
81123bb0:	1025883a 	mov	r18,r2
81123bb4:	1823883a 	mov	r17,r3
81123bb8:	112c3d00 	call	8112c3d0 <__floatunsidf>
81123bbc:	9009883a 	mov	r4,r18
81123bc0:	880b883a 	mov	r5,r17
81123bc4:	100d883a 	mov	r6,r2
81123bc8:	180f883a 	mov	r7,r3
81123bcc:	112a56c0 	call	8112a56c <__adddf3>
81123bd0:	da401317 	ldw	r9,76(sp)
81123bd4:	1025883a 	mov	r18,r2
81123bd8:	1823883a 	mov	r17,r3
81123bdc:	008003c4 	movi	r2,15
81123be0:	12407b16 	blt	r2,r9,81123dd0 <_strtod_r+0x610>
81123be4:	a83fbe26 	beq	r21,zero,81123ae0 <__reset+0xfb103ae0>
81123be8:	0543670e 	bge	zero,r21,81124988 <_strtod_r+0x11c8>
81123bec:	00c00584 	movi	r3,22
81123bf0:	1d42e816 	blt	r3,r21,81124794 <_strtod_r+0xfd4>
81123bf4:	a82a90fa 	slli	r21,r21,3
81123bf8:	00a04534 	movhi	r2,33044
81123bfc:	10977304 	addi	r2,r2,24012
81123c00:	1545883a 	add	r2,r2,r21
81123c04:	11000017 	ldw	r4,0(r2)
81123c08:	11400117 	ldw	r5,4(r2)
81123c0c:	900d883a 	mov	r6,r18
81123c10:	880f883a 	mov	r7,r17
81123c14:	111607c0 	call	8111607c <__muldf3>
81123c18:	102b883a 	mov	r21,r2
81123c1c:	182d883a 	mov	r22,r3
81123c20:	003fb106 	br	81123ae8 <__reset+0xfb103ae8>
81123c24:	4801b526 	beq	r9,zero,811242fc <_strtod_r+0xb3c>
81123c28:	ddc00617 	ldw	r23,24(sp)
81123c2c:	00c00ac4 	movi	r3,43
81123c30:	b8800044 	addi	r2,r23,1
81123c34:	d8800615 	stw	r2,24(sp)
81123c38:	b8800047 	ldb	r2,1(r23)
81123c3c:	10c1e926 	beq	r2,r3,811243e4 <_strtod_r+0xc24>
81123c40:	00c00b44 	movi	r3,45
81123c44:	10c1ec26 	beq	r2,r3,811243f8 <_strtod_r+0xc38>
81123c48:	1023883a 	mov	r17,r2
81123c4c:	0019883a 	mov	r12,zero
81123c50:	88bff404 	addi	r2,r17,-48
81123c54:	00c00244 	movi	r3,9
81123c58:	1881b736 	bltu	r3,r2,81124338 <_strtod_r+0xb78>
81123c5c:	00800c04 	movi	r2,48
81123c60:	8880071e 	bne	r17,r2,81123c80 <_strtod_r+0x4c0>
81123c64:	d8800617 	ldw	r2,24(sp)
81123c68:	8807883a 	mov	r3,r17
81123c6c:	10800044 	addi	r2,r2,1
81123c70:	d8800615 	stw	r2,24(sp)
81123c74:	14400007 	ldb	r17,0(r2)
81123c78:	10800044 	addi	r2,r2,1
81123c7c:	88fffc26 	beq	r17,r3,81123c70 <__reset+0xfb103c70>
81123c80:	88bff3c4 	addi	r2,r17,-49
81123c84:	00c00204 	movi	r3,8
81123c88:	18bf7036 	bltu	r3,r2,81123a4c <__reset+0xfb103a4c>
81123c8c:	db800617 	ldw	r14,24(sp)
81123c90:	88bff404 	addi	r2,r17,-48
81123c94:	03400244 	movi	r13,9
81123c98:	71c00044 	addi	r7,r14,1
81123c9c:	d9c00615 	stw	r7,24(sp)
81123ca0:	74400043 	ldbu	r17,1(r14)
81123ca4:	88fff404 	addi	r3,r17,-48
81123ca8:	8c403fcc 	andi	r17,r17,255
81123cac:	8c40201c 	xori	r17,r17,128
81123cb0:	18c03fcc 	andi	r3,r3,255
81123cb4:	8c7fe004 	addi	r17,r17,-128
81123cb8:	68c00e36 	bltu	r13,r3,81123cf4 <_strtod_r+0x534>
81123cbc:	71000084 	addi	r4,r14,2
81123cc0:	d9000615 	stw	r4,24(sp)
81123cc4:	108002a4 	muli	r2,r2,10
81123cc8:	21800003 	ldbu	r6,0(r4)
81123ccc:	200f883a 	mov	r7,r4
81123cd0:	1463883a 	add	r17,r2,r17
81123cd4:	30fff404 	addi	r3,r6,-48
81123cd8:	88bff404 	addi	r2,r17,-48
81123cdc:	34403fcc 	andi	r17,r6,255
81123ce0:	8c40201c 	xori	r17,r17,128
81123ce4:	18c03fcc 	andi	r3,r3,255
81123ce8:	8c7fe004 	addi	r17,r17,-128
81123cec:	21000044 	addi	r4,r4,1
81123cf0:	68fff32e 	bgeu	r13,r3,81123cc0 <__reset+0xfb103cc0>
81123cf4:	3b8fc83a 	sub	r7,r7,r14
81123cf8:	00c00204 	movi	r3,8
81123cfc:	19c29716 	blt	r3,r7,8112475c <_strtod_r+0xf9c>
81123d00:	102b883a 	mov	r21,r2
81123d04:	009387c4 	movi	r2,19999
81123d08:	1540010e 	bge	r2,r21,81123d10 <_strtod_r+0x550>
81123d0c:	102b883a 	mov	r21,r2
81123d10:	603f4f26 	beq	r12,zero,81123a50 <__reset+0xfb103a50>
81123d14:	056bc83a 	sub	r21,zero,r21
81123d18:	003f4d06 	br	81123a50 <__reset+0xfb103a50>
81123d1c:	98800047 	ldb	r2,1(r19)
81123d20:	00c01604 	movi	r3,88
81123d24:	10c1de26 	beq	r2,r3,811244a0 <_strtod_r+0xce0>
81123d28:	00c01e04 	movi	r3,120
81123d2c:	10c1dc26 	beq	r2,r3,811244a0 <_strtod_r+0xce0>
81123d30:	98c00044 	addi	r3,r19,1
81123d34:	1827883a 	mov	r19,r3
81123d38:	d8c00615 	stw	r3,24(sp)
81123d3c:	18c00044 	addi	r3,r3,1
81123d40:	18bfffc3 	ldbu	r2,-1(r3)
81123d44:	11003fcc 	andi	r4,r2,255
81123d48:	2100201c 	xori	r4,r4,128
81123d4c:	213fe004 	addi	r4,r4,-128
81123d50:	217ff826 	beq	r4,r5,81123d34 <__reset+0xfb103d34>
81123d54:	203f7926 	beq	r4,zero,81123b3c <__reset+0xfb103b3c>
81123d58:	dcc00815 	stw	r19,32(sp)
81123d5c:	04800044 	movi	r18,1
81123d60:	003f0b06 	br	81123990 <__reset+0xfb103990>
81123d64:	8009883a 	mov	r4,r16
81123d68:	11219e00 	call	811219e0 <_localeconv_r>
81123d6c:	11000017 	ldw	r4,0(r2)
81123d70:	11187c00 	call	811187c0 <strlen>
81123d74:	d8c00617 	ldw	r3,24(sp)
81123d78:	1885883a 	add	r2,r3,r2
81123d7c:	d8800615 	stw	r2,24(sp)
81123d80:	14400007 	ldb	r17,0(r2)
81123d84:	b001881e 	bne	r22,zero,811243a8 <_strtod_r+0xbe8>
81123d88:	00c00c04 	movi	r3,48
81123d8c:	88c3391e 	bne	r17,r3,81124a74 <_strtod_r+0x12b4>
81123d90:	10c00044 	addi	r3,r2,1
81123d94:	8809883a 	mov	r4,r17
81123d98:	d8c00615 	stw	r3,24(sp)
81123d9c:	1c400007 	ldb	r17,0(r3)
81123da0:	188bc83a 	sub	r5,r3,r2
81123da4:	18c00044 	addi	r3,r3,1
81123da8:	893ffb26 	beq	r17,r4,81123d98 <__reset+0xfb103d98>
81123dac:	88bff3c4 	addi	r2,r17,-49
81123db0:	00c00204 	movi	r3,8
81123db4:	1882e72e 	bgeu	r3,r2,81124954 <_strtod_r+0x1194>
81123db8:	00801944 	movi	r2,101
81123dbc:	88814d26 	beq	r17,r2,811242f4 <_strtod_r+0xb34>
81123dc0:	0013883a 	mov	r9,zero
81123dc4:	0015883a 	mov	r10,zero
81123dc8:	02c00044 	movi	r11,1
81123dcc:	003f1d06 	br	81123a44 <__reset+0xfb103a44>
81123dd0:	4defc83a 	sub	r23,r9,r23
81123dd4:	bd6f883a 	add	r23,r23,r21
81123dd8:	05c21e0e 	bge	zero,r23,81124654 <_strtod_r+0xe94>
81123ddc:	b88003cc 	andi	r2,r23,15
81123de0:	10000d26 	beq	r2,zero,81123e18 <_strtod_r+0x658>
81123de4:	100490fa 	slli	r2,r2,3
81123de8:	00e04534 	movhi	r3,33044
81123dec:	18d77304 	addi	r3,r3,24012
81123df0:	1885883a 	add	r2,r3,r2
81123df4:	11000017 	ldw	r4,0(r2)
81123df8:	11400117 	ldw	r5,4(r2)
81123dfc:	900d883a 	mov	r6,r18
81123e00:	880f883a 	mov	r7,r17
81123e04:	da401315 	stw	r9,76(sp)
81123e08:	111607c0 	call	8111607c <__muldf3>
81123e0c:	da401317 	ldw	r9,76(sp)
81123e10:	1025883a 	mov	r18,r2
81123e14:	1823883a 	mov	r17,r3
81123e18:	023ffc04 	movi	r8,-16
81123e1c:	ba10703a 	and	r8,r23,r8
81123e20:	40003c26 	beq	r8,zero,81123f14 <_strtod_r+0x754>
81123e24:	00804d04 	movi	r2,308
81123e28:	1201cd16 	blt	r2,r8,81124560 <_strtod_r+0xda0>
81123e2c:	4011d13a 	srai	r8,r8,4
81123e30:	03000044 	movi	r12,1
81123e34:	62037c0e 	bge	r12,r8,81124c28 <_strtod_r+0x1468>
81123e38:	01204534 	movhi	r4,33044
81123e3c:	21176904 	addi	r4,r4,23972
81123e40:	2015883a 	mov	r10,r4
81123e44:	0027883a 	mov	r19,zero
81123e48:	d9000915 	stw	r4,36(sp)
81123e4c:	9005883a 	mov	r2,r18
81123e50:	8807883a 	mov	r3,r17
81123e54:	dc000c15 	stw	r16,48(sp)
81123e58:	dc800e15 	stw	r18,56(sp)
81123e5c:	9821883a 	mov	r16,r19
81123e60:	0009883a 	mov	r4,zero
81123e64:	8827883a 	mov	r19,r17
81123e68:	602f883a 	mov	r23,r12
81123e6c:	da400a15 	stw	r9,40(sp)
81123e70:	5025883a 	mov	r18,r10
81123e74:	4023883a 	mov	r17,r8
81123e78:	8980004c 	andi	r6,r17,1
81123e7c:	30000626 	beq	r6,zero,81123e98 <_strtod_r+0x6d8>
81123e80:	91800017 	ldw	r6,0(r18)
81123e84:	91c00117 	ldw	r7,4(r18)
81123e88:	1009883a 	mov	r4,r2
81123e8c:	180b883a 	mov	r5,r3
81123e90:	111607c0 	call	8111607c <__muldf3>
81123e94:	01000044 	movi	r4,1
81123e98:	8823d07a 	srai	r17,r17,1
81123e9c:	84000044 	addi	r16,r16,1
81123ea0:	94800204 	addi	r18,r18,8
81123ea4:	8dfff41e 	bne	r17,r23,81123e78 <__reset+0xfb103e78>
81123ea8:	21003fcc 	andi	r4,r4,255
81123eac:	9823883a 	mov	r17,r19
81123eb0:	da400a17 	ldw	r9,40(sp)
81123eb4:	8027883a 	mov	r19,r16
81123eb8:	dc800e17 	ldw	r18,56(sp)
81123ebc:	dc000c17 	ldw	r16,48(sp)
81123ec0:	2003b11e 	bne	r4,zero,81124d88 <_strtod_r+0x15c8>
81123ec4:	981690fa 	slli	r11,r19,3
81123ec8:	d8800917 	ldw	r2,36(sp)
81123ecc:	01ff2c34 	movhi	r7,64688
81123ed0:	900d883a 	mov	r6,r18
81123ed4:	12ef883a 	add	r23,r2,r11
81123ed8:	b9000017 	ldw	r4,0(r23)
81123edc:	b9400117 	ldw	r5,4(r23)
81123ee0:	89cf883a 	add	r7,r17,r7
81123ee4:	da401315 	stw	r9,76(sp)
81123ee8:	111607c0 	call	8111607c <__muldf3>
81123eec:	1025883a 	mov	r18,r2
81123ef0:	011f2834 	movhi	r4,31904
81123ef4:	189ffc2c 	andhi	r2,r3,32752
81123ef8:	da401317 	ldw	r9,76(sp)
81123efc:	20819836 	bltu	r4,r2,81124560 <_strtod_r+0xda0>
81123f00:	011f2434 	movhi	r4,31888
81123f04:	2083382e 	bgeu	r4,r2,81124be8 <_strtod_r+0x1428>
81123f08:	045ffc34 	movhi	r17,32752
81123f0c:	8c7fffc4 	addi	r17,r17,-1
81123f10:	04bfffc4 	movi	r18,-1
81123f14:	d8000915 	stw	zero,36(sp)
81123f18:	d9400817 	ldw	r5,32(sp)
81123f1c:	df000015 	stw	fp,0(sp)
81123f20:	480f883a 	mov	r7,r9
81123f24:	b00d883a 	mov	r6,r22
81123f28:	8009883a 	mov	r4,r16
81123f2c:	11220fc0 	call	811220fc <__s2b>
81123f30:	d8800815 	stw	r2,32(sp)
81123f34:	10018a26 	beq	r2,zero,81124560 <_strtod_r+0xda0>
81123f38:	a807d7fa 	srai	r3,r21,31
81123f3c:	0545c83a 	sub	r2,zero,r21
81123f40:	dd400a15 	stw	r21,40(sp)
81123f44:	1886703a 	and	r3,r3,r2
81123f48:	d8c00c15 	stw	r3,48(sp)
81123f4c:	a8013516 	blt	r21,zero,81124424 <_strtod_r+0xc64>
81123f50:	d9400817 	ldw	r5,32(sp)
81123f54:	0011883a 	mov	r8,zero
81123f58:	0027883a 	mov	r19,zero
81123f5c:	29400304 	addi	r5,r5,12
81123f60:	d9400f15 	stw	r5,60(sp)
81123f64:	402b883a 	mov	r21,r8
81123f68:	dd001215 	stw	r20,72(sp)
81123f6c:	d8800817 	ldw	r2,32(sp)
81123f70:	8009883a 	mov	r4,r16
81123f74:	11400117 	ldw	r5,4(r2)
81123f78:	1121efc0 	call	81121efc <_Balloc>
81123f7c:	1029883a 	mov	r20,r2
81123f80:	10012d26 	beq	r2,zero,81124438 <_strtod_r+0xc78>
81123f84:	d8c00817 	ldw	r3,32(sp)
81123f88:	d9400f17 	ldw	r5,60(sp)
81123f8c:	11000304 	addi	r4,r2,12
81123f90:	19800417 	ldw	r6,16(r3)
81123f94:	31800084 	addi	r6,r6,2
81123f98:	318d883a 	add	r6,r6,r6
81123f9c:	318d883a 	add	r6,r6,r6
81123fa0:	1117ccc0 	call	81117ccc <memcpy>
81123fa4:	d9000204 	addi	r4,sp,8
81123fa8:	d9000015 	stw	r4,0(sp)
81123fac:	d9c00404 	addi	r7,sp,16
81123fb0:	900b883a 	mov	r5,r18
81123fb4:	880d883a 	mov	r6,r17
81123fb8:	8009883a 	mov	r4,r16
81123fbc:	1122bd80 	call	81122bd8 <__d2b>
81123fc0:	d8800515 	stw	r2,20(sp)
81123fc4:	dc801115 	stw	r18,68(sp)
81123fc8:	dc401015 	stw	r17,64(sp)
81123fcc:	10027c26 	beq	r2,zero,811249c0 <_strtod_r+0x1200>
81123fd0:	01400044 	movi	r5,1
81123fd4:	8009883a 	mov	r4,r16
81123fd8:	11223200 	call	81122320 <__i2b>
81123fdc:	1027883a 	mov	r19,r2
81123fe0:	10011526 	beq	r2,zero,81124438 <_strtod_r+0xc78>
81123fe4:	d8800417 	ldw	r2,16(sp)
81123fe8:	1000c816 	blt	r2,zero,8112430c <_strtod_r+0xb4c>
81123fec:	d9400c17 	ldw	r5,48(sp)
81123ff0:	d9000a17 	ldw	r4,40(sp)
81123ff4:	28ad883a 	add	r22,r5,r2
81123ff8:	d9400917 	ldw	r5,36(sp)
81123ffc:	df000217 	ldw	fp,8(sp)
81124000:	05ff0084 	movi	r23,-1022
81124004:	1147c83a 	sub	r3,r2,r5
81124008:	1f07883a 	add	r3,r3,fp
8112400c:	00800d84 	movi	r2,54
81124010:	18ffffc4 	addi	r3,r3,-1
81124014:	1739c83a 	sub	fp,r2,fp
81124018:	1dc0a50e 	bge	r3,r23,811242b0 <_strtod_r+0xaf0>
8112401c:	b8efc83a 	sub	r23,r23,r3
81124020:	008007c4 	movi	r2,31
81124024:	e5f9c83a 	sub	fp,fp,r23
81124028:	15c0bc16 	blt	r2,r23,8112431c <_strtod_r+0xb5c>
8112402c:	00800044 	movi	r2,1
81124030:	15c4983a 	sll	r2,r2,r23
81124034:	d8000b15 	stw	zero,44(sp)
81124038:	d8800d15 	stw	r2,52(sp)
8112403c:	2707883a 	add	r3,r4,fp
81124040:	d9000917 	ldw	r4,36(sp)
81124044:	b739883a 	add	fp,r22,fp
81124048:	20ef883a 	add	r23,r4,r3
8112404c:	b009883a 	mov	r4,r22
81124050:	e580010e 	bge	fp,r22,81124058 <_strtod_r+0x898>
81124054:	e009883a 	mov	r4,fp
81124058:	b805883a 	mov	r2,r23
8112405c:	25c0010e 	bge	r4,r23,81124064 <_strtod_r+0x8a4>
81124060:	2005883a 	mov	r2,r4
81124064:	0080030e 	bge	zero,r2,81124074 <_strtod_r+0x8b4>
81124068:	e0b9c83a 	sub	fp,fp,r2
8112406c:	b8afc83a 	sub	r23,r23,r2
81124070:	b0adc83a 	sub	r22,r22,r2
81124074:	d9400c17 	ldw	r5,48(sp)
81124078:	28001126 	beq	r5,zero,811240c0 <_strtod_r+0x900>
8112407c:	280d883a 	mov	r6,r5
81124080:	8009883a 	mov	r4,r16
81124084:	980b883a 	mov	r5,r19
81124088:	11225640 	call	81122564 <__pow5mult>
8112408c:	1027883a 	mov	r19,r2
81124090:	1000e926 	beq	r2,zero,81124438 <_strtod_r+0xc78>
81124094:	d9800517 	ldw	r6,20(sp)
81124098:	100b883a 	mov	r5,r2
8112409c:	8009883a 	mov	r4,r16
811240a0:	11223640 	call	81122364 <__multiply>
811240a4:	1000e426 	beq	r2,zero,81124438 <_strtod_r+0xc78>
811240a8:	d9400517 	ldw	r5,20(sp)
811240ac:	8009883a 	mov	r4,r16
811240b0:	d8801315 	stw	r2,76(sp)
811240b4:	1121fac0 	call	81121fac <_Bfree>
811240b8:	d8801317 	ldw	r2,76(sp)
811240bc:	d8800515 	stw	r2,20(sp)
811240c0:	0700060e 	bge	zero,fp,811240dc <_strtod_r+0x91c>
811240c4:	d9400517 	ldw	r5,20(sp)
811240c8:	e00d883a 	mov	r6,fp
811240cc:	8009883a 	mov	r4,r16
811240d0:	11226ac0 	call	811226ac <__lshift>
811240d4:	d8800515 	stw	r2,20(sp)
811240d8:	10023926 	beq	r2,zero,811249c0 <_strtod_r+0x1200>
811240dc:	d8800a17 	ldw	r2,40(sp)
811240e0:	10000626 	beq	r2,zero,811240fc <_strtod_r+0x93c>
811240e4:	d9800a17 	ldw	r6,40(sp)
811240e8:	a00b883a 	mov	r5,r20
811240ec:	8009883a 	mov	r4,r16
811240f0:	11225640 	call	81122564 <__pow5mult>
811240f4:	1029883a 	mov	r20,r2
811240f8:	1000cf26 	beq	r2,zero,81124438 <_strtod_r+0xc78>
811240fc:	05c0060e 	bge	zero,r23,81124118 <_strtod_r+0x958>
81124100:	a00b883a 	mov	r5,r20
81124104:	b80d883a 	mov	r6,r23
81124108:	8009883a 	mov	r4,r16
8112410c:	11226ac0 	call	811226ac <__lshift>
81124110:	1029883a 	mov	r20,r2
81124114:	1000c826 	beq	r2,zero,81124438 <_strtod_r+0xc78>
81124118:	0580060e 	bge	zero,r22,81124134 <_strtod_r+0x974>
8112411c:	980b883a 	mov	r5,r19
81124120:	b00d883a 	mov	r6,r22
81124124:	8009883a 	mov	r4,r16
81124128:	11226ac0 	call	811226ac <__lshift>
8112412c:	1027883a 	mov	r19,r2
81124130:	1000c126 	beq	r2,zero,81124438 <_strtod_r+0xc78>
81124134:	d9400517 	ldw	r5,20(sp)
81124138:	a00d883a 	mov	r6,r20
8112413c:	8009883a 	mov	r4,r16
81124140:	112285c0 	call	8112285c <__mdiff>
81124144:	102b883a 	mov	r21,r2
81124148:	1000bb26 	beq	r2,zero,81124438 <_strtod_r+0xc78>
8112414c:	10c00317 	ldw	r3,12(r2)
81124150:	980b883a 	mov	r5,r19
81124154:	10000315 	stw	zero,12(r2)
81124158:	1009883a 	mov	r4,r2
8112415c:	d8c00e15 	stw	r3,56(sp)
81124160:	11227fc0 	call	811227fc <__mcmp>
81124164:	10027616 	blt	r2,zero,81124b40 <_strtod_r+0x1380>
81124168:	10024426 	beq	r2,zero,81124a7c <_strtod_r+0x12bc>
8112416c:	980b883a 	mov	r5,r19
81124170:	a809883a 	mov	r4,r21
81124174:	1122d2c0 	call	81122d2c <__ratio>
81124178:	000d883a 	mov	r6,zero
8112417c:	01d00034 	movhi	r7,16384
81124180:	1009883a 	mov	r4,r2
81124184:	180b883a 	mov	r5,r3
81124188:	102f883a 	mov	r23,r2
8112418c:	182d883a 	mov	r22,r3
81124190:	112b8740 	call	8112b874 <__ledf2>
81124194:	00804a16 	blt	zero,r2,811242c0 <_strtod_r+0xb00>
81124198:	d9400e17 	ldw	r5,56(sp)
8112419c:	28006b26 	beq	r5,zero,8112434c <_strtod_r+0xb8c>
811241a0:	058ffc34 	movhi	r22,16368
811241a4:	d8000b15 	stw	zero,44(sp)
811241a8:	d8000d15 	stw	zero,52(sp)
811241ac:	b02f883a 	mov	r23,r22
811241b0:	8f1ffc2c 	andhi	fp,r17,32752
811241b4:	009ff834 	movhi	r2,32736
811241b8:	e080cd26 	beq	fp,r2,811244f0 <_strtod_r+0xd30>
811241bc:	d9400917 	ldw	r5,36(sp)
811241c0:	28001a26 	beq	r5,zero,8112422c <_strtod_r+0xa6c>
811241c4:	0081a834 	movhi	r2,1696
811241c8:	17001836 	bltu	r2,fp,8112422c <_strtod_r+0xa6c>
811241cc:	d9000d17 	ldw	r4,52(sp)
811241d0:	01d07834 	movhi	r7,16864
811241d4:	39ffffc4 	addi	r7,r7,-1
811241d8:	01bff034 	movhi	r6,65472
811241dc:	b80b883a 	mov	r5,r23
811241e0:	112b8740 	call	8112b874 <__ledf2>
811241e4:	00800e16 	blt	zero,r2,81124220 <_strtod_r+0xa60>
811241e8:	d9000d17 	ldw	r4,52(sp)
811241ec:	b80b883a 	mov	r5,r23
811241f0:	11296800 	call	81129680 <__fixunsdfsi>
811241f4:	10018126 	beq	r2,zero,811247fc <_strtod_r+0x103c>
811241f8:	1009883a 	mov	r4,r2
811241fc:	112c3d00 	call	8112c3d0 <__floatunsidf>
81124200:	d8800d15 	stw	r2,52(sp)
81124204:	182f883a 	mov	r23,r3
81124208:	d8800e17 	ldw	r2,56(sp)
8112420c:	1001791e 	bne	r2,zero,811247f4 <_strtod_r+0x1034>
81124210:	ba20003c 	xorhi	r8,r23,32768
81124214:	d8c00d17 	ldw	r3,52(sp)
81124218:	402d883a 	mov	r22,r8
8112421c:	d8c00b15 	stw	r3,44(sp)
81124220:	0081ac34 	movhi	r2,1712
81124224:	b091883a 	add	r8,r22,r2
81124228:	472dc83a 	sub	r22,r8,fp
8112422c:	9009883a 	mov	r4,r18
81124230:	880b883a 	mov	r5,r17
81124234:	1122a600 	call	81122a60 <__ulp>
81124238:	d9000b17 	ldw	r4,44(sp)
8112423c:	b00b883a 	mov	r5,r22
81124240:	100d883a 	mov	r6,r2
81124244:	180f883a 	mov	r7,r3
81124248:	111607c0 	call	8111607c <__muldf3>
8112424c:	900d883a 	mov	r6,r18
81124250:	880f883a 	mov	r7,r17
81124254:	1009883a 	mov	r4,r2
81124258:	180b883a 	mov	r5,r3
8112425c:	112a56c0 	call	8112a56c <__adddf3>
81124260:	1025883a 	mov	r18,r2
81124264:	1823883a 	mov	r17,r3
81124268:	182d883a 	mov	r22,r3
8112426c:	d9000917 	ldw	r4,36(sp)
81124270:	2000021e 	bne	r4,zero,8112427c <_strtod_r+0xabc>
81124274:	b09ffc2c 	andhi	r2,r22,32752
81124278:	e080be26 	beq	fp,r2,81124574 <_strtod_r+0xdb4>
8112427c:	d9400517 	ldw	r5,20(sp)
81124280:	8009883a 	mov	r4,r16
81124284:	1121fac0 	call	81121fac <_Bfree>
81124288:	a00b883a 	mov	r5,r20
8112428c:	8009883a 	mov	r4,r16
81124290:	1121fac0 	call	81121fac <_Bfree>
81124294:	980b883a 	mov	r5,r19
81124298:	8009883a 	mov	r4,r16
8112429c:	1121fac0 	call	81121fac <_Bfree>
811242a0:	a80b883a 	mov	r5,r21
811242a4:	8009883a 	mov	r4,r16
811242a8:	1121fac0 	call	81121fac <_Bfree>
811242ac:	003f2f06 	br	81123f6c <__reset+0xfb103f6c>
811242b0:	00c00044 	movi	r3,1
811242b4:	d8000b15 	stw	zero,44(sp)
811242b8:	d8c00d15 	stw	r3,52(sp)
811242bc:	003f5f06 	br	8112403c <__reset+0xfb10403c>
811242c0:	b809883a 	mov	r4,r23
811242c4:	000d883a 	mov	r6,zero
811242c8:	01cff834 	movhi	r7,16352
811242cc:	b00b883a 	mov	r5,r22
811242d0:	111607c0 	call	8111607c <__muldf3>
811242d4:	d9000e17 	ldw	r4,56(sp)
811242d8:	d8800d15 	stw	r2,52(sp)
811242dc:	182f883a 	mov	r23,r3
811242e0:	2000181e 	bne	r4,zero,81124344 <_strtod_r+0xb84>
811242e4:	1a20003c 	xorhi	r8,r3,32768
811242e8:	d8800b15 	stw	r2,44(sp)
811242ec:	402d883a 	mov	r22,r8
811242f0:	003faf06 	br	811241b0 <__reset+0xfb1041b0>
811242f4:	0015883a 	mov	r10,zero
811242f8:	02c00044 	movi	r11,1
811242fc:	2800011e 	bne	r5,zero,81124304 <_strtod_r+0xb44>
81124300:	903d7e26 	beq	r18,zero,811238fc <__reset+0xfb1038fc>
81124304:	0013883a 	mov	r9,zero
81124308:	003e4706 	br	81123c28 <__reset+0xfb103c28>
8112430c:	d8c00a17 	ldw	r3,40(sp)
81124310:	dd800c17 	ldw	r22,48(sp)
81124314:	1889c83a 	sub	r4,r3,r2
81124318:	003f3706 	br	81123ff8 <__reset+0xfb103ff8>
8112431c:	00bef884 	movi	r2,-1054
81124320:	05c00044 	movi	r23,1
81124324:	10c5c83a 	sub	r2,r2,r3
81124328:	b884983a 	sll	r2,r23,r2
8112432c:	ddc00d15 	stw	r23,52(sp)
81124330:	d8800b15 	stw	r2,44(sp)
81124334:	003f4106 	br	8112403c <__reset+0xfb10403c>
81124338:	ddc00615 	stw	r23,24(sp)
8112433c:	002b883a 	mov	r21,zero
81124340:	003dc306 	br	81123a50 <__reset+0xfb103a50>
81124344:	1811883a 	mov	r8,r3
81124348:	003fe706 	br	811242e8 <__reset+0xfb1042e8>
8112434c:	90002e1e 	bne	r18,zero,81124408 <_strtod_r+0xc48>
81124350:	00c00434 	movhi	r3,16
81124354:	18ffffc4 	addi	r3,r3,-1
81124358:	88c4703a 	and	r2,r17,r3
8112435c:	10002c1e 	bne	r2,zero,81124410 <_strtod_r+0xc50>
81124360:	000d883a 	mov	r6,zero
81124364:	01cffc34 	movhi	r7,16368
81124368:	b809883a 	mov	r4,r23
8112436c:	b00b883a 	mov	r5,r22
81124370:	112b8740 	call	8112b874 <__ledf2>
81124374:	10021716 	blt	r2,zero,81124bd4 <_strtod_r+0x1414>
81124378:	b809883a 	mov	r4,r23
8112437c:	b00b883a 	mov	r5,r22
81124380:	000d883a 	mov	r6,zero
81124384:	01cff834 	movhi	r7,16352
81124388:	111607c0 	call	8111607c <__muldf3>
8112438c:	d8800d15 	stw	r2,52(sp)
81124390:	182f883a 	mov	r23,r3
81124394:	102d883a 	mov	r22,r2
81124398:	1a20003c 	xorhi	r8,r3,32768
8112439c:	dd800b15 	stw	r22,44(sp)
811243a0:	402d883a 	mov	r22,r8
811243a4:	003f8206 	br	811241b0 <__reset+0xfb1041b0>
811243a8:	b013883a 	mov	r9,r22
811243ac:	000b883a 	mov	r5,zero
811243b0:	0015883a 	mov	r10,zero
811243b4:	893ff404 	addi	r4,r17,-48
811243b8:	00800244 	movi	r2,9
811243bc:	11001036 	bltu	r2,r4,81124400 <_strtod_r+0xc40>
811243c0:	28c00044 	addi	r3,r5,1
811243c4:	2023883a 	mov	r17,r4
811243c8:	20014d1e 	bne	r4,zero,81124900 <_strtod_r+0x1140>
811243cc:	d9800617 	ldw	r6,24(sp)
811243d0:	180b883a 	mov	r5,r3
811243d4:	30800044 	addi	r2,r6,1
811243d8:	d8800615 	stw	r2,24(sp)
811243dc:	34400047 	ldb	r17,1(r6)
811243e0:	003ff406 	br	811243b4 <__reset+0xfb1043b4>
811243e4:	0019883a 	mov	r12,zero
811243e8:	b8800084 	addi	r2,r23,2
811243ec:	d8800615 	stw	r2,24(sp)
811243f0:	bc400087 	ldb	r17,2(r23)
811243f4:	003e1606 	br	81123c50 <__reset+0xfb103c50>
811243f8:	03000044 	movi	r12,1
811243fc:	003ffa06 	br	811243e8 <__reset+0xfb1043e8>
81124400:	02c00044 	movi	r11,1
81124404:	003d8d06 	br	81123a3c <__reset+0xfb103a3c>
81124408:	00800044 	movi	r2,1
8112440c:	9080fe26 	beq	r18,r2,81124808 <_strtod_r+0x1048>
81124410:	d8000b15 	stw	zero,44(sp)
81124414:	05affc34 	movhi	r22,49136
81124418:	d8000d15 	stw	zero,52(sp)
8112441c:	05cffc34 	movhi	r23,16368
81124420:	003f6306 	br	811241b0 <__reset+0xfb1041b0>
81124424:	d8000a15 	stw	zero,40(sp)
81124428:	003ec906 	br	81123f50 <__reset+0xfb103f50>
8112442c:	d9001117 	ldw	r4,68(sp)
81124430:	00bfffc4 	movi	r2,-1
81124434:	2080461e 	bne	r4,r2,81124550 <_strtod_r+0xd90>
81124438:	dd000a15 	stw	r20,40(sp)
8112443c:	dd001217 	ldw	r20,72(sp)
81124440:	a811883a 	mov	r8,r21
81124444:	d8800517 	ldw	r2,20(sp)
81124448:	00c00884 	movi	r3,34
8112444c:	80c00015 	stw	r3,0(r16)
81124450:	002b883a 	mov	r21,zero
81124454:	059ffc34 	movhi	r22,32752
81124458:	100b883a 	mov	r5,r2
8112445c:	8009883a 	mov	r4,r16
81124460:	da001315 	stw	r8,76(sp)
81124464:	1121fac0 	call	81121fac <_Bfree>
81124468:	d9400a17 	ldw	r5,40(sp)
8112446c:	8009883a 	mov	r4,r16
81124470:	1121fac0 	call	81121fac <_Bfree>
81124474:	980b883a 	mov	r5,r19
81124478:	8009883a 	mov	r4,r16
8112447c:	1121fac0 	call	81121fac <_Bfree>
81124480:	d9400817 	ldw	r5,32(sp)
81124484:	8009883a 	mov	r4,r16
81124488:	1121fac0 	call	81121fac <_Bfree>
8112448c:	da001317 	ldw	r8,76(sp)
81124490:	8009883a 	mov	r4,r16
81124494:	400b883a 	mov	r5,r8
81124498:	1121fac0 	call	81121fac <_Bfree>
8112449c:	003d9206 	br	81123ae8 <__reset+0xfb103ae8>
811244a0:	d8c00717 	ldw	r3,28(sp)
811244a4:	d8800504 	addi	r2,sp,20
811244a8:	01a04534 	movhi	r6,33044
811244ac:	3197ae04 	addi	r6,r6,24248
811244b0:	d8c00115 	stw	r3,4(sp)
811244b4:	d8800015 	stw	r2,0(sp)
811244b8:	d9c00404 	addi	r7,sp,16
811244bc:	d9400604 	addi	r5,sp,24
811244c0:	8009883a 	mov	r4,r16
811244c4:	11289140 	call	81128914 <__gethex>
811244c8:	154001cc 	andi	r21,r2,7
811244cc:	a83d9b26 	beq	r21,zero,81123b3c <__reset+0xfb103b3c>
811244d0:	00c00184 	movi	r3,6
811244d4:	a8c0d61e 	bne	r21,r3,81124830 <_strtod_r+0x1070>
811244d8:	9cc00044 	addi	r19,r19,1
811244dc:	dcc00615 	stw	r19,24(sp)
811244e0:	002b883a 	mov	r21,zero
811244e4:	002d883a 	mov	r22,zero
811244e8:	d8000715 	stw	zero,28(sp)
811244ec:	003d7e06 	br	81123ae8 <__reset+0xfb103ae8>
811244f0:	00bf2c34 	movhi	r2,64688
811244f4:	88a3883a 	add	r17,r17,r2
811244f8:	9009883a 	mov	r4,r18
811244fc:	880b883a 	mov	r5,r17
81124500:	1122a600 	call	81122a60 <__ulp>
81124504:	d9000b17 	ldw	r4,44(sp)
81124508:	100d883a 	mov	r6,r2
8112450c:	180f883a 	mov	r7,r3
81124510:	b00b883a 	mov	r5,r22
81124514:	111607c0 	call	8111607c <__muldf3>
81124518:	900d883a 	mov	r6,r18
8112451c:	180b883a 	mov	r5,r3
81124520:	880f883a 	mov	r7,r17
81124524:	1009883a 	mov	r4,r2
81124528:	112a56c0 	call	8112a56c <__adddf3>
8112452c:	015f2834 	movhi	r5,31904
81124530:	1025883a 	mov	r18,r2
81124534:	297fffc4 	addi	r5,r5,-1
81124538:	189ffc2c 	andhi	r2,r3,32752
8112453c:	2880892e 	bgeu	r5,r2,81124764 <_strtod_r+0xfa4>
81124540:	d8801017 	ldw	r2,64(sp)
81124544:	00dffc34 	movhi	r3,32752
81124548:	18ffffc4 	addi	r3,r3,-1
8112454c:	10ffb726 	beq	r2,r3,8112442c <__reset+0xfb10442c>
81124550:	045ffc34 	movhi	r17,32752
81124554:	8c7fffc4 	addi	r17,r17,-1
81124558:	04bfffc4 	movi	r18,-1
8112455c:	003f4706 	br	8112427c <__reset+0xfb10427c>
81124560:	00800884 	movi	r2,34
81124564:	80800015 	stw	r2,0(r16)
81124568:	002b883a 	mov	r21,zero
8112456c:	059ffc34 	movhi	r22,32752
81124570:	003d5d06 	br	81123ae8 <__reset+0xfb103ae8>
81124574:	d9000d17 	ldw	r4,52(sp)
81124578:	b80b883a 	mov	r5,r23
8112457c:	112c26c0 	call	8112c26c <__fixdfsi>
81124580:	1009883a 	mov	r4,r2
81124584:	112c2ec0 	call	8112c2ec <__floatsidf>
81124588:	d9000d17 	ldw	r4,52(sp)
8112458c:	b80b883a 	mov	r5,r23
81124590:	100d883a 	mov	r6,r2
81124594:	180f883a 	mov	r7,r3
81124598:	112b9680 	call	8112b968 <__subdf3>
8112459c:	d9400e17 	ldw	r5,56(sp)
811245a0:	1039883a 	mov	fp,r2
811245a4:	182f883a 	mov	r23,r3
811245a8:	2800141e 	bne	r5,zero,811245fc <_strtod_r+0xe3c>
811245ac:	9000131e 	bne	r18,zero,811245fc <_strtod_r+0xe3c>
811245b0:	00800434 	movhi	r2,16
811245b4:	10bfffc4 	addi	r2,r2,-1
811245b8:	b0ac703a 	and	r22,r22,r2
811245bc:	b0000f1e 	bne	r22,zero,811245fc <_strtod_r+0xe3c>
811245c0:	01a52834 	movhi	r6,38048
811245c4:	01cff434 	movhi	r7,16336
811245c8:	318d6544 	addi	r6,r6,13717
811245cc:	39ffffc4 	addi	r7,r7,-1
811245d0:	e009883a 	mov	r4,fp
811245d4:	180b883a 	mov	r5,r3
811245d8:	112b8740 	call	8112b874 <__ledf2>
811245dc:	103f270e 	bge	r2,zero,8112427c <__reset+0xfb10427c>
811245e0:	dd000a15 	stw	r20,40(sp)
811245e4:	a811883a 	mov	r8,r21
811245e8:	dd001217 	ldw	r20,72(sp)
811245ec:	d8800517 	ldw	r2,20(sp)
811245f0:	002b883a 	mov	r21,zero
811245f4:	882d883a 	mov	r22,r17
811245f8:	003f9706 	br	81124458 <__reset+0xfb104458>
811245fc:	01a52834 	movhi	r6,38048
81124600:	01cff834 	movhi	r7,16352
81124604:	318d6544 	addi	r6,r6,13717
81124608:	39ffffc4 	addi	r7,r7,-1
8112460c:	e009883a 	mov	r4,fp
81124610:	b80b883a 	mov	r5,r23
81124614:	112b8740 	call	8112b874 <__ledf2>
81124618:	10000716 	blt	r2,zero,81124638 <_strtod_r+0xe78>
8112461c:	018d6c34 	movhi	r6,13744
81124620:	31b94d44 	addi	r6,r6,-6859
81124624:	01cff834 	movhi	r7,16352
81124628:	e009883a 	mov	r4,fp
8112462c:	b80b883a 	mov	r5,r23
81124630:	112b7980 	call	8112b798 <__gedf2>
81124634:	00bf110e 	bge	zero,r2,8112427c <__reset+0xfb10427c>
81124638:	dd000a15 	stw	r20,40(sp)
8112463c:	a811883a 	mov	r8,r21
81124640:	dd001217 	ldw	r20,72(sp)
81124644:	d8800517 	ldw	r2,20(sp)
81124648:	902b883a 	mov	r21,r18
8112464c:	882d883a 	mov	r22,r17
81124650:	003f8106 	br	81124458 <__reset+0xfb104458>
81124654:	b83e2f26 	beq	r23,zero,81123f14 <__reset+0xfb103f14>
81124658:	05efc83a 	sub	r23,zero,r23
8112465c:	b88003cc 	andi	r2,r23,15
81124660:	10000d26 	beq	r2,zero,81124698 <_strtod_r+0xed8>
81124664:	100490fa 	slli	r2,r2,3
81124668:	00e04534 	movhi	r3,33044
8112466c:	18d77304 	addi	r3,r3,24012
81124670:	1885883a 	add	r2,r3,r2
81124674:	11800017 	ldw	r6,0(r2)
81124678:	11c00117 	ldw	r7,4(r2)
8112467c:	9009883a 	mov	r4,r18
81124680:	880b883a 	mov	r5,r17
81124684:	da401315 	stw	r9,76(sp)
81124688:	112ae200 	call	8112ae20 <__divdf3>
8112468c:	da401317 	ldw	r9,76(sp)
81124690:	1025883a 	mov	r18,r2
81124694:	1823883a 	mov	r17,r3
81124698:	b82fd13a 	srai	r23,r23,4
8112469c:	b83e1d26 	beq	r23,zero,81123f14 <__reset+0xfb103f14>
811246a0:	008007c4 	movi	r2,31
811246a4:	15c02816 	blt	r2,r23,81124748 <_strtod_r+0xf88>
811246a8:	b880040c 	andi	r2,r23,16
811246ac:	10019726 	beq	r2,zero,81124d0c <_strtod_r+0x154c>
811246b0:	05c1880e 	bge	zero,r23,81124cd4 <_strtod_r+0x1514>
811246b4:	00c01a84 	movi	r3,106
811246b8:	d8c00915 	stw	r3,36(sp)
811246bc:	04e04534 	movhi	r19,33044
811246c0:	9cd7b304 	addi	r19,r19,24268
811246c4:	8807883a 	mov	r3,r17
811246c8:	9005883a 	mov	r2,r18
811246cc:	8023883a 	mov	r17,r16
811246d0:	0009883a 	mov	r4,zero
811246d4:	9821883a 	mov	r16,r19
811246d8:	da400a15 	stw	r9,40(sp)
811246dc:	1827883a 	mov	r19,r3
811246e0:	b980004c 	andi	r6,r23,1
811246e4:	30000626 	beq	r6,zero,81124700 <_strtod_r+0xf40>
811246e8:	81800017 	ldw	r6,0(r16)
811246ec:	81c00117 	ldw	r7,4(r16)
811246f0:	1009883a 	mov	r4,r2
811246f4:	180b883a 	mov	r5,r3
811246f8:	111607c0 	call	8111607c <__muldf3>
811246fc:	01000044 	movi	r4,1
81124700:	b82fd07a 	srai	r23,r23,1
81124704:	84000204 	addi	r16,r16,8
81124708:	b83ff51e 	bne	r23,zero,811246e0 <__reset+0xfb1046e0>
8112470c:	21003fcc 	andi	r4,r4,255
81124710:	8821883a 	mov	r16,r17
81124714:	da400a17 	ldw	r9,40(sp)
81124718:	9823883a 	mov	r17,r19
8112471c:	2001a51e 	bne	r4,zero,81124db4 <_strtod_r+0x15f4>
81124720:	d9000917 	ldw	r4,36(sp)
81124724:	20016d1e 	bne	r4,zero,81124cdc <_strtod_r+0x151c>
81124728:	000d883a 	mov	r6,zero
8112472c:	000f883a 	mov	r7,zero
81124730:	9009883a 	mov	r4,r18
81124734:	880b883a 	mov	r5,r17
81124738:	da401315 	stw	r9,76(sp)
8112473c:	112b7100 	call	8112b710 <__eqdf2>
81124740:	da401317 	ldw	r9,76(sp)
81124744:	103df41e 	bne	r2,zero,81123f18 <__reset+0xfb103f18>
81124748:	00800884 	movi	r2,34
8112474c:	80800015 	stw	r2,0(r16)
81124750:	002b883a 	mov	r21,zero
81124754:	002d883a 	mov	r22,zero
81124758:	003ce306 	br	81123ae8 <__reset+0xfb103ae8>
8112475c:	055387c4 	movi	r21,19999
81124760:	003d6b06 	br	81123d10 <__reset+0xfb103d10>
81124764:	0440d434 	movhi	r17,848
81124768:	1c63883a 	add	r17,r3,r17
8112476c:	882d883a 	mov	r22,r17
81124770:	003ebe06 	br	8112426c <__reset+0xfb10426c>
81124774:	14403fcc 	andi	r17,r2,255
81124778:	8c40201c 	xori	r17,r17,128
8112477c:	8c7fe004 	addi	r17,r17,-128
81124780:	dd400817 	ldw	r21,32(sp)
81124784:	0027883a 	mov	r19,zero
81124788:	0039883a 	mov	fp,zero
8112478c:	002d883a 	mov	r22,zero
81124790:	003c9906 	br	811239f8 <__reset+0xfb1039f8>
81124794:	00c00944 	movi	r3,37
81124798:	1a47c83a 	sub	r3,r3,r9
8112479c:	1d7d8c16 	blt	r3,r21,81123dd0 <__reset+0xfb103dd0>
811247a0:	1261c83a 	sub	r16,r2,r9
811247a4:	800490fa 	slli	r2,r16,3
811247a8:	04e04534 	movhi	r19,33044
811247ac:	9cd77304 	addi	r19,r19,24012
811247b0:	9885883a 	add	r2,r19,r2
811247b4:	11000017 	ldw	r4,0(r2)
811247b8:	11400117 	ldw	r5,4(r2)
811247bc:	900d883a 	mov	r6,r18
811247c0:	880f883a 	mov	r7,r17
811247c4:	111607c0 	call	8111607c <__muldf3>
811247c8:	ac0dc83a 	sub	r6,r21,r16
811247cc:	300c90fa 	slli	r6,r6,3
811247d0:	1009883a 	mov	r4,r2
811247d4:	180b883a 	mov	r5,r3
811247d8:	9985883a 	add	r2,r19,r6
811247dc:	11800017 	ldw	r6,0(r2)
811247e0:	11c00117 	ldw	r7,4(r2)
811247e4:	111607c0 	call	8111607c <__muldf3>
811247e8:	102b883a 	mov	r21,r2
811247ec:	182d883a 	mov	r22,r3
811247f0:	003cbd06 	br	81123ae8 <__reset+0xfb103ae8>
811247f4:	b811883a 	mov	r8,r23
811247f8:	003e8606 	br	81124214 <__reset+0xfb104214>
811247fc:	d8000d15 	stw	zero,52(sp)
81124800:	05cffc34 	movhi	r23,16368
81124804:	003e8006 	br	81124208 <__reset+0xfb104208>
81124808:	883f011e 	bne	r17,zero,81124410 <__reset+0xfb104410>
8112480c:	dd000a15 	stw	r20,40(sp)
81124810:	dd001217 	ldw	r20,72(sp)
81124814:	a811883a 	mov	r8,r21
81124818:	00800884 	movi	r2,34
8112481c:	80800015 	stw	r2,0(r16)
81124820:	002b883a 	mov	r21,zero
81124824:	d8800517 	ldw	r2,20(sp)
81124828:	002d883a 	mov	r22,zero
8112482c:	003f0a06 	br	81124458 <__reset+0xfb104458>
81124830:	d9800517 	ldw	r6,20(sp)
81124834:	30000826 	beq	r6,zero,81124858 <_strtod_r+0x1098>
81124838:	01400d44 	movi	r5,53
8112483c:	d9000204 	addi	r4,sp,8
81124840:	d8801315 	stw	r2,76(sp)
81124844:	1122e540 	call	81122e54 <__copybits>
81124848:	d9400517 	ldw	r5,20(sp)
8112484c:	8009883a 	mov	r4,r16
81124850:	1121fac0 	call	81121fac <_Bfree>
81124854:	d8801317 	ldw	r2,76(sp)
81124858:	00c00184 	movi	r3,6
8112485c:	1d400f36 	bltu	r3,r21,8112489c <_strtod_r+0x10dc>
81124860:	a82a90ba 	slli	r21,r21,2
81124864:	00e044b4 	movhi	r3,33042
81124868:	18d21e04 	addi	r3,r3,18552
8112486c:	a8eb883a 	add	r21,r21,r3
81124870:	a8c00017 	ldw	r3,0(r21)
81124874:	1800683a 	jmp	r3
81124878:	811248f4 	orhi	r4,r16,18723
8112487c:	811248cc 	andi	r4,r16,18723
81124880:	811248b0 	cmpltui	r4,r16,18722
81124884:	81124894 	ori	r4,r16,18722
81124888:	811248bc 	xorhi	r4,r16,18722
8112488c:	811248cc 	andi	r4,r16,18723
81124890:	811248f4 	orhi	r4,r16,18723
81124894:	045ffc34 	movhi	r17,32752
81124898:	0025883a 	mov	r18,zero
8112489c:	1080020c 	andi	r2,r2,8
811248a0:	902b883a 	mov	r21,r18
811248a4:	103c8f26 	beq	r2,zero,81123ae4 <__reset+0xfb103ae4>
811248a8:	8da00034 	orhi	r22,r17,32768
811248ac:	003c8e06 	br	81123ae8 <__reset+0xfb103ae8>
811248b0:	dc800217 	ldw	r18,8(sp)
811248b4:	dc400317 	ldw	r17,12(sp)
811248b8:	003ff806 	br	8112489c <__reset+0xfb10489c>
811248bc:	04600034 	movhi	r17,32768
811248c0:	8c7fffc4 	addi	r17,r17,-1
811248c4:	04bfffc4 	movi	r18,-1
811248c8:	003ff406 	br	8112489c <__reset+0xfb10489c>
811248cc:	d8c00417 	ldw	r3,16(sp)
811248d0:	dc400317 	ldw	r17,12(sp)
811248d4:	013ffc34 	movhi	r4,65520
811248d8:	18c10cc4 	addi	r3,r3,1075
811248dc:	1806953a 	slli	r3,r3,20
811248e0:	213fffc4 	addi	r4,r4,-1
811248e4:	8922703a 	and	r17,r17,r4
811248e8:	dc800217 	ldw	r18,8(sp)
811248ec:	88e2b03a 	or	r17,r17,r3
811248f0:	003fea06 	br	8112489c <__reset+0xfb10489c>
811248f4:	0023883a 	mov	r17,zero
811248f8:	0025883a 	mov	r18,zero
811248fc:	003fe706 	br	8112489c <__reset+0xfb10489c>
81124900:	01800044 	movi	r6,1
81124904:	50d5883a 	add	r10,r10,r3
81124908:	2a4b883a 	add	r5,r5,r9
8112490c:	19811a26 	beq	r3,r6,81124d78 <_strtod_r+0x15b8>
81124910:	01800204 	movi	r6,8
81124914:	01c00404 	movi	r7,16
81124918:	4a400044 	addi	r9,r9,1
8112491c:	48bfffc4 	addi	r2,r9,-1
81124920:	30801616 	blt	r6,r2,8112497c <_strtod_r+0x11bc>
81124924:	e70002a4 	muli	fp,fp,10
81124928:	497ffb1e 	bne	r9,r5,81124918 <__reset+0xfb104918>
8112492c:	d9800617 	ldw	r6,24(sp)
81124930:	4a400044 	addi	r9,r9,1
81124934:	00c00204 	movi	r3,8
81124938:	19400c0e 	bge	r3,r5,8112496c <_strtod_r+0x11ac>
8112493c:	00800404 	movi	r2,16
81124940:	000b883a 	mov	r5,zero
81124944:	127ea316 	blt	r2,r9,811243d4 <__reset+0xfb1043d4>
81124948:	988002a4 	muli	r2,r19,10
8112494c:	20a7883a 	add	r19,r4,r2
81124950:	003ea006 	br	811243d4 <__reset+0xfb1043d4>
81124954:	d8800617 	ldw	r2,24(sp)
81124958:	8c7ff404 	addi	r17,r17,-48
8112495c:	2a800044 	addi	r10,r5,1
81124960:	d8800815 	stw	r2,32(sp)
81124964:	100d883a 	mov	r6,r2
81124968:	02400044 	movi	r9,1
8112496c:	e08002a4 	muli	r2,fp,10
81124970:	000b883a 	mov	r5,zero
81124974:	88b9883a 	add	fp,r17,r2
81124978:	003e9606 	br	811243d4 <__reset+0xfb1043d4>
8112497c:	3a7fea16 	blt	r7,r9,81124928 <__reset+0xfb104928>
81124980:	9cc002a4 	muli	r19,r19,10
81124984:	003fe806 	br	81124928 <__reset+0xfb104928>
81124988:	00bffa84 	movi	r2,-22
8112498c:	a8bd1016 	blt	r21,r2,81123dd0 <__reset+0xfb103dd0>
81124990:	a82a90fa 	slli	r21,r21,3
81124994:	00a04534 	movhi	r2,33044
81124998:	10977304 	addi	r2,r2,24012
8112499c:	1545c83a 	sub	r2,r2,r21
811249a0:	11800017 	ldw	r6,0(r2)
811249a4:	11c00117 	ldw	r7,4(r2)
811249a8:	9009883a 	mov	r4,r18
811249ac:	880b883a 	mov	r5,r17
811249b0:	112ae200 	call	8112ae20 <__divdf3>
811249b4:	102b883a 	mov	r21,r2
811249b8:	182d883a 	mov	r22,r3
811249bc:	003c4a06 	br	81123ae8 <__reset+0xfb103ae8>
811249c0:	dd000a15 	stw	r20,40(sp)
811249c4:	a811883a 	mov	r8,r21
811249c8:	dd001217 	ldw	r20,72(sp)
811249cc:	003e9e06 	br	81124448 <__reset+0xfb104448>
811249d0:	01604534 	movhi	r5,33044
811249d4:	d9000617 	ldw	r4,24(sp)
811249d8:	2957a504 	addi	r5,r5,24212
811249dc:	01c00644 	movi	r7,25
811249e0:	00000b06 	br	81124a10 <_strtod_r+0x1250>
811249e4:	21000044 	addi	r4,r4,1
811249e8:	20800003 	ldbu	r2,0(r4)
811249ec:	10ffefc4 	addi	r3,r2,-65
811249f0:	10803fcc 	andi	r2,r2,255
811249f4:	1080201c 	xori	r2,r2,128
811249f8:	18c03fcc 	andi	r3,r3,255
811249fc:	10bfe004 	addi	r2,r2,-128
81124a00:	38c00136 	bltu	r7,r3,81124a08 <_strtod_r+0x1248>
81124a04:	10800804 	addi	r2,r2,32
81124a08:	29400044 	addi	r5,r5,1
81124a0c:	11bbbb1e 	bne	r2,r6,811238fc <__reset+0xfb1038fc>
81124a10:	29800007 	ldb	r6,0(r5)
81124a14:	303ff31e 	bne	r6,zero,811249e4 <__reset+0xfb1049e4>
81124a18:	01a04534 	movhi	r6,33044
81124a1c:	d9000615 	stw	r4,24(sp)
81124a20:	3197a604 	addi	r6,r6,24216
81124a24:	200b883a 	mov	r5,r4
81124a28:	02000644 	movi	r8,25
81124a2c:	00000a06 	br	81124a58 <_strtod_r+0x1298>
81124a30:	28800003 	ldbu	r2,0(r5)
81124a34:	10ffefc4 	addi	r3,r2,-65
81124a38:	10803fcc 	andi	r2,r2,255
81124a3c:	1080201c 	xori	r2,r2,128
81124a40:	18c03fcc 	andi	r3,r3,255
81124a44:	10bfe004 	addi	r2,r2,-128
81124a48:	40c00136 	bltu	r8,r3,81124a50 <_strtod_r+0x1290>
81124a4c:	10800804 	addi	r2,r2,32
81124a50:	31800044 	addi	r6,r6,1
81124a54:	11c0711e 	bne	r2,r7,81124c1c <_strtod_r+0x145c>
81124a58:	31c00007 	ldb	r7,0(r6)
81124a5c:	29400044 	addi	r5,r5,1
81124a60:	383ff31e 	bne	r7,zero,81124a30 <__reset+0xfb104a30>
81124a64:	d9400615 	stw	r5,24(sp)
81124a68:	045ffc34 	movhi	r17,32752
81124a6c:	0025883a 	mov	r18,zero
81124a70:	003c1b06 	br	81123ae0 <__reset+0xfb103ae0>
81124a74:	000b883a 	mov	r5,zero
81124a78:	003ccc06 	br	81123dac <__reset+0xfb103dac>
81124a7c:	d9400e17 	ldw	r5,56(sp)
81124a80:	dd000a15 	stw	r20,40(sp)
81124a84:	00800434 	movhi	r2,16
81124a88:	a811883a 	mov	r8,r21
81124a8c:	dd001217 	ldw	r20,72(sp)
81124a90:	dd401117 	ldw	r21,68(sp)
81124a94:	dd801017 	ldw	r22,64(sp)
81124a98:	10bfffc4 	addi	r2,r2,-1
81124a9c:	28005626 	beq	r5,zero,81124bf8 <_strtod_r+0x1438>
81124aa0:	8886703a 	and	r3,r17,r2
81124aa4:	18807826 	beq	r3,r2,81124c88 <_strtod_r+0x14c8>
81124aa8:	d8c00b17 	ldw	r3,44(sp)
81124aac:	18005726 	beq	r3,zero,81124c0c <_strtod_r+0x144c>
81124ab0:	1c44703a 	and	r2,r3,r17
81124ab4:	10000f26 	beq	r2,zero,81124af4 <_strtod_r+0x1334>
81124ab8:	d9000e17 	ldw	r4,56(sp)
81124abc:	d9800917 	ldw	r6,36(sp)
81124ac0:	20005e26 	beq	r4,zero,81124c3c <_strtod_r+0x147c>
81124ac4:	9009883a 	mov	r4,r18
81124ac8:	880b883a 	mov	r5,r17
81124acc:	da001315 	stw	r8,76(sp)
81124ad0:	11237540 	call	81123754 <sulp>
81124ad4:	100d883a 	mov	r6,r2
81124ad8:	180f883a 	mov	r7,r3
81124adc:	9009883a 	mov	r4,r18
81124ae0:	880b883a 	mov	r5,r17
81124ae4:	112a56c0 	call	8112a56c <__adddf3>
81124ae8:	da001317 	ldw	r8,76(sp)
81124aec:	102b883a 	mov	r21,r2
81124af0:	182d883a 	mov	r22,r3
81124af4:	d8c00917 	ldw	r3,36(sp)
81124af8:	18000f26 	beq	r3,zero,81124b38 <_strtod_r+0x1378>
81124afc:	a809883a 	mov	r4,r21
81124b00:	b00b883a 	mov	r5,r22
81124b04:	000d883a 	mov	r6,zero
81124b08:	01ce5434 	movhi	r7,14672
81124b0c:	da001315 	stw	r8,76(sp)
81124b10:	111607c0 	call	8111607c <__muldf3>
81124b14:	102b883a 	mov	r21,r2
81124b18:	182d883a 	mov	r22,r3
81124b1c:	da001317 	ldw	r8,76(sp)
81124b20:	1800051e 	bne	r3,zero,81124b38 <_strtod_r+0x1378>
81124b24:	d8800517 	ldw	r2,20(sp)
81124b28:	a83e4b1e 	bne	r21,zero,81124458 <__reset+0xfb104458>
81124b2c:	00c00884 	movi	r3,34
81124b30:	80c00015 	stw	r3,0(r16)
81124b34:	003e4806 	br	81124458 <__reset+0xfb104458>
81124b38:	d8800517 	ldw	r2,20(sp)
81124b3c:	003e4606 	br	81124458 <__reset+0xfb104458>
81124b40:	d9000e17 	ldw	r4,56(sp)
81124b44:	dd000a15 	stw	r20,40(sp)
81124b48:	a811883a 	mov	r8,r21
81124b4c:	dd001217 	ldw	r20,72(sp)
81124b50:	dd401117 	ldw	r21,68(sp)
81124b54:	dd801017 	ldw	r22,64(sp)
81124b58:	203fe61e 	bne	r4,zero,81124af4 <__reset+0xfb104af4>
81124b5c:	903fe51e 	bne	r18,zero,81124af4 <__reset+0xfb104af4>
81124b60:	00800434 	movhi	r2,16
81124b64:	10bfffc4 	addi	r2,r2,-1
81124b68:	8884703a 	and	r2,r17,r2
81124b6c:	103fe11e 	bne	r2,zero,81124af4 <__reset+0xfb104af4>
81124b70:	8ddffc2c 	andhi	r23,r17,32752
81124b74:	0081ac34 	movhi	r2,1712
81124b78:	15ffde2e 	bgeu	r2,r23,81124af4 <__reset+0xfb104af4>
81124b7c:	40800517 	ldw	r2,20(r8)
81124b80:	1000031e 	bne	r2,zero,81124b90 <_strtod_r+0x13d0>
81124b84:	40800417 	ldw	r2,16(r8)
81124b88:	00c00044 	movi	r3,1
81124b8c:	18bfd90e 	bge	r3,r2,81124af4 <__reset+0xfb104af4>
81124b90:	400b883a 	mov	r5,r8
81124b94:	01800044 	movi	r6,1
81124b98:	8009883a 	mov	r4,r16
81124b9c:	11226ac0 	call	811226ac <__lshift>
81124ba0:	980b883a 	mov	r5,r19
81124ba4:	1009883a 	mov	r4,r2
81124ba8:	d8801315 	stw	r2,76(sp)
81124bac:	11227fc0 	call	811227fc <__mcmp>
81124bb0:	da001317 	ldw	r8,76(sp)
81124bb4:	00bfcf0e 	bge	zero,r2,81124af4 <__reset+0xfb104af4>
81124bb8:	d8c00917 	ldw	r3,36(sp)
81124bbc:	18005c26 	beq	r3,zero,81124d30 <_strtod_r+0x1570>
81124bc0:	0081ac34 	movhi	r2,1712
81124bc4:	15c05a16 	blt	r2,r23,81124d30 <_strtod_r+0x1570>
81124bc8:	0080dc34 	movhi	r2,880
81124bcc:	15ffcb16 	blt	r2,r23,81124afc <__reset+0xfb104afc>
81124bd0:	003f1106 	br	81124818 <__reset+0xfb104818>
81124bd4:	002d883a 	mov	r22,zero
81124bd8:	022ff834 	movhi	r8,49120
81124bdc:	d8000d15 	stw	zero,52(sp)
81124be0:	05cff834 	movhi	r23,16352
81124be4:	003ded06 	br	8112439c <__reset+0xfb10439c>
81124be8:	0440d434 	movhi	r17,848
81124bec:	1c63883a 	add	r17,r3,r17
81124bf0:	d8000915 	stw	zero,36(sp)
81124bf4:	003cc806 	br	81123f18 <__reset+0xfb103f18>
81124bf8:	8884703a 	and	r2,r17,r2
81124bfc:	103faa1e 	bne	r2,zero,81124aa8 <__reset+0xfb104aa8>
81124c00:	903fa91e 	bne	r18,zero,81124aa8 <__reset+0xfb104aa8>
81124c04:	8ddffc2c 	andhi	r23,r17,32752
81124c08:	003feb06 	br	81124bb8 <__reset+0xfb104bb8>
81124c0c:	d8c00d17 	ldw	r3,52(sp)
81124c10:	1cae703a 	and	r23,r3,r18
81124c14:	b83fb726 	beq	r23,zero,81124af4 <__reset+0xfb104af4>
81124c18:	003fa706 	br	81124ab8 <__reset+0xfb104ab8>
81124c1c:	21000044 	addi	r4,r4,1
81124c20:	d9000615 	stw	r4,24(sp)
81124c24:	003f9006 	br	81124a68 <__reset+0xfb104a68>
81124c28:	01604534 	movhi	r5,33044
81124c2c:	29576904 	addi	r5,r5,23972
81124c30:	d9400915 	stw	r5,36(sp)
81124c34:	0027883a 	mov	r19,zero
81124c38:	003ca206 	br	81123ec4 <__reset+0xfb103ec4>
81124c3c:	9009883a 	mov	r4,r18
81124c40:	880b883a 	mov	r5,r17
81124c44:	da001315 	stw	r8,76(sp)
81124c48:	11237540 	call	81123754 <sulp>
81124c4c:	100d883a 	mov	r6,r2
81124c50:	180f883a 	mov	r7,r3
81124c54:	9009883a 	mov	r4,r18
81124c58:	880b883a 	mov	r5,r17
81124c5c:	112b9680 	call	8112b968 <__subdf3>
81124c60:	000d883a 	mov	r6,zero
81124c64:	000f883a 	mov	r7,zero
81124c68:	1009883a 	mov	r4,r2
81124c6c:	180b883a 	mov	r5,r3
81124c70:	102b883a 	mov	r21,r2
81124c74:	182d883a 	mov	r22,r3
81124c78:	112b7100 	call	8112b710 <__eqdf2>
81124c7c:	da001317 	ldw	r8,76(sp)
81124c80:	103ee526 	beq	r2,zero,81124818 <__reset+0xfb104818>
81124c84:	003f9b06 	br	81124af4 <__reset+0xfb104af4>
81124c88:	d8800917 	ldw	r2,36(sp)
81124c8c:	10002226 	beq	r2,zero,81124d18 <_strtod_r+0x1558>
81124c90:	889ffc2c 	andhi	r2,r17,32752
81124c94:	00c1a834 	movhi	r3,1696
81124c98:	18801f36 	bltu	r3,r2,81124d18 <_strtod_r+0x1558>
81124c9c:	1004d53a 	srli	r2,r2,20
81124ca0:	00c01ac4 	movi	r3,107
81124ca4:	1887c83a 	sub	r3,r3,r2
81124ca8:	00bfffc4 	movi	r2,-1
81124cac:	10c4983a 	sll	r2,r2,r3
81124cb0:	14bf7d1e 	bne	r2,r18,81124aa8 <__reset+0xfb104aa8>
81124cb4:	00dffc34 	movhi	r3,32752
81124cb8:	18ffffc4 	addi	r3,r3,-1
81124cbc:	88c03526 	beq	r17,r3,81124d94 <_strtod_r+0x15d4>
81124cc0:	8c5ffc2c 	andhi	r17,r17,32752
81124cc4:	00800434 	movhi	r2,16
81124cc8:	002b883a 	mov	r21,zero
81124ccc:	88ad883a 	add	r22,r17,r2
81124cd0:	003f8806 	br	81124af4 <__reset+0xfb104af4>
81124cd4:	01401a84 	movi	r5,106
81124cd8:	d9400915 	stw	r5,36(sp)
81124cdc:	8ddffc2c 	andhi	r23,r17,32752
81124ce0:	b82ed53a 	srli	r23,r23,20
81124ce4:	00801ac4 	movi	r2,107
81124ce8:	15c5c83a 	sub	r2,r2,r23
81124cec:	00be8e0e 	bge	zero,r2,81124728 <__reset+0xfb104728>
81124cf0:	00c007c4 	movi	r3,31
81124cf4:	18800a0e 	bge	r3,r2,81124d20 <_strtod_r+0x1560>
81124cf8:	00c00d04 	movi	r3,52
81124cfc:	0025883a 	mov	r18,zero
81124d00:	1880270e 	bge	r3,r2,81124da0 <_strtod_r+0x15e0>
81124d04:	0440dc34 	movhi	r17,880
81124d08:	003e8706 	br	81124728 <__reset+0xfb104728>
81124d0c:	d8000915 	stw	zero,36(sp)
81124d10:	05fe6a16 	blt	zero,r23,811246bc <__reset+0xfb1046bc>
81124d14:	003e8406 	br	81124728 <__reset+0xfb104728>
81124d18:	00bfffc4 	movi	r2,-1
81124d1c:	003fe406 	br	81124cb0 <__reset+0xfb104cb0>
81124d20:	00ffffc4 	movi	r3,-1
81124d24:	1884983a 	sll	r2,r3,r2
81124d28:	14a4703a 	and	r18,r2,r18
81124d2c:	003e7e06 	br	81124728 <__reset+0xfb104728>
81124d30:	00bffc34 	movhi	r2,65520
81124d34:	b8af883a 	add	r23,r23,r2
81124d38:	057fffc4 	movi	r21,-1
81124d3c:	00800434 	movhi	r2,16
81124d40:	1545883a 	add	r2,r2,r21
81124d44:	b8acb03a 	or	r22,r23,r2
81124d48:	003f6a06 	br	81124af4 <__reset+0xfb104af4>
81124d4c:	01604534 	movhi	r5,33044
81124d50:	2957a904 	addi	r5,r5,24228
81124d54:	d9800204 	addi	r6,sp,8
81124d58:	d9000604 	addi	r4,sp,24
81124d5c:	112914c0 	call	8112914c <__hexnan>
81124d60:	00c00144 	movi	r3,5
81124d64:	10fb5c1e 	bne	r2,r3,81123ad8 <__reset+0xfb103ad8>
81124d68:	dc400317 	ldw	r17,12(sp)
81124d6c:	dc800217 	ldw	r18,8(sp)
81124d70:	8c5ffc34 	orhi	r17,r17,32752
81124d74:	003b5a06 	br	81123ae0 <__reset+0xfb103ae0>
81124d78:	480b883a 	mov	r5,r9
81124d7c:	d9800617 	ldw	r6,24(sp)
81124d80:	4a400044 	addi	r9,r9,1
81124d84:	003eeb06 	br	81124934 <__reset+0xfb104934>
81124d88:	1025883a 	mov	r18,r2
81124d8c:	1823883a 	mov	r17,r3
81124d90:	003c4c06 	br	81123ec4 <__reset+0xfb103ec4>
81124d94:	00ffffc4 	movi	r3,-1
81124d98:	10ffc91e 	bne	r2,r3,81124cc0 <__reset+0xfb104cc0>
81124d9c:	003da906 	br	81124444 <__reset+0xfb104444>
81124da0:	10bff804 	addi	r2,r2,-32
81124da4:	00ffffc4 	movi	r3,-1
81124da8:	1884983a 	sll	r2,r3,r2
81124dac:	1462703a 	and	r17,r2,r17
81124db0:	003e5d06 	br	81124728 <__reset+0xfb104728>
81124db4:	1025883a 	mov	r18,r2
81124db8:	1823883a 	mov	r17,r3
81124dbc:	003e5806 	br	81124720 <__reset+0xfb104720>

81124dc0 <strtod>:
81124dc0:	00a04574 	movhi	r2,33045
81124dc4:	10a10204 	addi	r2,r2,-31736
81124dc8:	280d883a 	mov	r6,r5
81124dcc:	200b883a 	mov	r5,r4
81124dd0:	11000017 	ldw	r4,0(r2)
81124dd4:	11237c01 	jmpi	811237c0 <_strtod_r>

81124dd8 <strtof>:
81124dd8:	defffb04 	addi	sp,sp,-20
81124ddc:	de00012e 	bgeu	sp,et,81124de4 <strtof+0xc>
81124de0:	003b68fa 	trap	3
81124de4:	dcc00315 	stw	r19,12(sp)
81124de8:	04e04574 	movhi	r19,33045
81124dec:	9ce10204 	addi	r19,r19,-31736
81124df0:	280d883a 	mov	r6,r5
81124df4:	200b883a 	mov	r5,r4
81124df8:	99000017 	ldw	r4,0(r19)
81124dfc:	dfc00415 	stw	ra,16(sp)
81124e00:	dc800215 	stw	r18,8(sp)
81124e04:	dc400115 	stw	r17,4(sp)
81124e08:	dc000015 	stw	r16,0(sp)
81124e0c:	11237c00 	call	811237c0 <_strtod_r>
81124e10:	1009883a 	mov	r4,r2
81124e14:	180b883a 	mov	r5,r3
81124e18:	1025883a 	mov	r18,r2
81124e1c:	1823883a 	mov	r17,r3
81124e20:	11168b40 	call	811168b4 <__truncdfsf2>
81124e24:	000b883a 	mov	r5,zero
81124e28:	1009883a 	mov	r4,r2
81124e2c:	1021883a 	mov	r16,r2
81124e30:	112a3700 	call	8112a370 <__eqsf2>
81124e34:	1000111e 	bne	r2,zero,81124e7c <strtof+0xa4>
81124e38:	000d883a 	mov	r6,zero
81124e3c:	000f883a 	mov	r7,zero
81124e40:	9009883a 	mov	r4,r18
81124e44:	880b883a 	mov	r5,r17
81124e48:	112b7100 	call	8112b710 <__eqdf2>
81124e4c:	10000b26 	beq	r2,zero,81124e7c <strtof+0xa4>
81124e50:	98800017 	ldw	r2,0(r19)
81124e54:	00c00884 	movi	r3,34
81124e58:	10c00015 	stw	r3,0(r2)
81124e5c:	8005883a 	mov	r2,r16
81124e60:	dfc00417 	ldw	ra,16(sp)
81124e64:	dcc00317 	ldw	r19,12(sp)
81124e68:	dc800217 	ldw	r18,8(sp)
81124e6c:	dc400117 	ldw	r17,4(sp)
81124e70:	dc000017 	ldw	r16,0(sp)
81124e74:	dec00504 	addi	sp,sp,20
81124e78:	f800283a 	ret
81124e7c:	015fe034 	movhi	r5,32640
81124e80:	297fffc4 	addi	r5,r5,-1
81124e84:	8009883a 	mov	r4,r16
81124e88:	112a3e80 	call	8112a3e8 <__gesf2>
81124e8c:	0080070e 	bge	zero,r2,81124eac <strtof+0xd4>
81124e90:	01dffc34 	movhi	r7,32752
81124e94:	39ffffc4 	addi	r7,r7,-1
81124e98:	01bfffc4 	movi	r6,-1
81124e9c:	9009883a 	mov	r4,r18
81124ea0:	880b883a 	mov	r5,r17
81124ea4:	112b7980 	call	8112b798 <__gedf2>
81124ea8:	00bfe90e 	bge	zero,r2,81124e50 <__reset+0xfb104e50>
81124eac:	017fe034 	movhi	r5,65408
81124eb0:	297fffc4 	addi	r5,r5,-1
81124eb4:	8009883a 	mov	r4,r16
81124eb8:	112a4a40 	call	8112a4a4 <__lesf2>
81124ebc:	103fe70e 	bge	r2,zero,81124e5c <__reset+0xfb104e5c>
81124ec0:	01fffc34 	movhi	r7,65520
81124ec4:	39ffffc4 	addi	r7,r7,-1
81124ec8:	01bfffc4 	movi	r6,-1
81124ecc:	9009883a 	mov	r4,r18
81124ed0:	880b883a 	mov	r5,r17
81124ed4:	112b8740 	call	8112b874 <__ledf2>
81124ed8:	103fdd0e 	bge	r2,zero,81124e50 <__reset+0xfb104e50>
81124edc:	003fdf06 	br	81124e5c <__reset+0xfb104e5c>

81124ee0 <_strtoll_r>:
81124ee0:	00a04574 	movhi	r2,33045
81124ee4:	defff304 	addi	sp,sp,-52
81124ee8:	10a10004 	addi	r2,r2,-31744
81124eec:	de00012e 	bgeu	sp,et,81124ef4 <_strtoll_r+0x14>
81124ef0:	003b68fa 	trap	3
81124ef4:	dc800515 	stw	r18,20(sp)
81124ef8:	14800017 	ldw	r18,0(r2)
81124efc:	dd800915 	stw	r22,36(sp)
81124f00:	dd400815 	stw	r21,32(sp)
81124f04:	dcc00615 	stw	r19,24(sp)
81124f08:	d9000015 	stw	r4,0(sp)
81124f0c:	dfc00c15 	stw	ra,48(sp)
81124f10:	df000b15 	stw	fp,44(sp)
81124f14:	ddc00a15 	stw	r23,40(sp)
81124f18:	dd000715 	stw	r20,28(sp)
81124f1c:	dc400415 	stw	r17,16(sp)
81124f20:	dc000315 	stw	r16,12(sp)
81124f24:	282d883a 	mov	r22,r5
81124f28:	302b883a 	mov	r21,r6
81124f2c:	3827883a 	mov	r19,r7
81124f30:	2809883a 	mov	r4,r5
81124f34:	24000003 	ldbu	r16,0(r4)
81124f38:	24400044 	addi	r17,r4,1
81124f3c:	2007883a 	mov	r3,r4
81124f40:	9405883a 	add	r2,r18,r16
81124f44:	10800043 	ldbu	r2,1(r2)
81124f48:	8809883a 	mov	r4,r17
81124f4c:	1080020c 	andi	r2,r2,8
81124f50:	103ff81e 	bne	r2,zero,81124f34 <__reset+0xfb104f34>
81124f54:	00800b44 	movi	r2,45
81124f58:	80807826 	beq	r16,r2,8112513c <_strtoll_r+0x25c>
81124f5c:	00800ac4 	movi	r2,43
81124f60:	80807a26 	beq	r16,r2,8112514c <_strtoll_r+0x26c>
81124f64:	0039883a 	mov	fp,zero
81124f68:	98004e26 	beq	r19,zero,811250a4 <_strtoll_r+0x1c4>
81124f6c:	00800404 	movi	r2,16
81124f70:	98808226 	beq	r19,r2,8112517c <_strtoll_r+0x29c>
81124f74:	982fd7fa 	srai	r23,r19,31
81124f78:	9829883a 	mov	r20,r19
81124f7c:	e0004f26 	beq	fp,zero,811250bc <_strtoll_r+0x1dc>
81124f80:	0017883a 	mov	r11,zero
81124f84:	02a00034 	movhi	r10,32768
81124f88:	5809883a 	mov	r4,r11
81124f8c:	500b883a 	mov	r5,r10
81124f90:	a00d883a 	mov	r6,r20
81124f94:	b80f883a 	mov	r7,r23
81124f98:	da800215 	stw	r10,8(sp)
81124f9c:	dac00115 	stw	r11,4(sp)
81124fa0:	1129c7c0 	call	81129c7c <__umoddi3>
81124fa4:	dac00117 	ldw	r11,4(sp)
81124fa8:	da800217 	ldw	r10,8(sp)
81124fac:	a00d883a 	mov	r6,r20
81124fb0:	5809883a 	mov	r4,r11
81124fb4:	500b883a 	mov	r5,r10
81124fb8:	b80f883a 	mov	r7,r23
81124fbc:	d8800115 	stw	r2,4(sp)
81124fc0:	11296fc0 	call	811296fc <__udivdi3>
81124fc4:	9409883a 	add	r4,r18,r16
81124fc8:	21000043 	ldbu	r4,1(r4)
81124fcc:	1019883a 	mov	r12,r2
81124fd0:	880b883a 	mov	r5,r17
81124fd4:	2240010c 	andi	r9,r4,4
81124fd8:	0015883a 	mov	r10,zero
81124fdc:	000d883a 	mov	r6,zero
81124fe0:	000f883a 	mov	r7,zero
81124fe4:	03400044 	movi	r13,1
81124fe8:	02ffffc4 	movi	r11,-1
81124fec:	da000117 	ldw	r8,4(sp)
81124ff0:	48000d26 	beq	r9,zero,81125028 <_strtoll_r+0x148>
81124ff4:	843ff404 	addi	r16,r16,-48
81124ff8:	84c0110e 	bge	r16,r19,81125040 <_strtoll_r+0x160>
81124ffc:	52c00426 	beq	r10,r11,81125010 <_strtoll_r+0x130>
81125000:	19c00236 	bltu	r3,r7,8112500c <_strtoll_r+0x12c>
81125004:	38c0311e 	bne	r7,r3,811250cc <_strtoll_r+0x1ec>
81125008:	6180302e 	bgeu	r12,r6,811250cc <_strtoll_r+0x1ec>
8112500c:	02bfffc4 	movi	r10,-1
81125010:	2c000003 	ldbu	r16,0(r5)
81125014:	29400044 	addi	r5,r5,1
81125018:	9409883a 	add	r4,r18,r16
8112501c:	21000043 	ldbu	r4,1(r4)
81125020:	2240010c 	andi	r9,r4,4
81125024:	483ff31e 	bne	r9,zero,81124ff4 <__reset+0xfb104ff4>
81125028:	210000cc 	andi	r4,r4,3
8112502c:	20000426 	beq	r4,zero,81125040 <_strtoll_r+0x160>
81125030:	23403426 	beq	r4,r13,81125104 <_strtoll_r+0x224>
81125034:	008015c4 	movi	r2,87
81125038:	80a1c83a 	sub	r16,r16,r2
8112503c:	84ffef16 	blt	r16,r19,81124ffc <__reset+0xfb104ffc>
81125040:	00bfffc4 	movi	r2,-1
81125044:	50803426 	beq	r10,r2,81125118 <_strtoll_r+0x238>
81125048:	e0000426 	beq	fp,zero,8112505c <_strtoll_r+0x17c>
8112504c:	018dc83a 	sub	r6,zero,r6
81125050:	3004c03a 	cmpne	r2,r6,zero
81125054:	01e1c83a 	sub	r16,zero,r7
81125058:	808fc83a 	sub	r7,r16,r2
8112505c:	3005883a 	mov	r2,r6
81125060:	3807883a 	mov	r3,r7
81125064:	a8000326 	beq	r21,zero,81125074 <_strtoll_r+0x194>
81125068:	5000321e 	bne	r10,zero,81125134 <_strtoll_r+0x254>
8112506c:	b00b883a 	mov	r5,r22
81125070:	a9400015 	stw	r5,0(r21)
81125074:	dfc00c17 	ldw	ra,48(sp)
81125078:	df000b17 	ldw	fp,44(sp)
8112507c:	ddc00a17 	ldw	r23,40(sp)
81125080:	dd800917 	ldw	r22,36(sp)
81125084:	dd400817 	ldw	r21,32(sp)
81125088:	dd000717 	ldw	r20,28(sp)
8112508c:	dcc00617 	ldw	r19,24(sp)
81125090:	dc800517 	ldw	r18,20(sp)
81125094:	dc400417 	ldw	r17,16(sp)
81125098:	dc000317 	ldw	r16,12(sp)
8112509c:	dec00d04 	addi	sp,sp,52
811250a0:	f800283a 	ret
811250a4:	00800c04 	movi	r2,48
811250a8:	80802c26 	beq	r16,r2,8112515c <_strtoll_r+0x27c>
811250ac:	05000284 	movi	r20,10
811250b0:	002f883a 	mov	r23,zero
811250b4:	a027883a 	mov	r19,r20
811250b8:	e03fb11e 	bne	fp,zero,81124f80 <__reset+0xfb104f80>
811250bc:	02a00034 	movhi	r10,32768
811250c0:	52bfffc4 	addi	r10,r10,-1
811250c4:	02ffffc4 	movi	r11,-1
811250c8:	003faf06 	br	81124f88 <__reset+0xfb104f88>
811250cc:	33000f26 	beq	r6,r12,8112510c <_strtoll_r+0x22c>
811250d0:	b985383a 	mul	r2,r23,r6
811250d4:	3d0f383a 	mul	r7,r7,r20
811250d8:	3508383a 	mulxuu	r4,r6,r20
811250dc:	350d383a 	mul	r6,r6,r20
811250e0:	8013d7fa 	srai	r9,r16,31
811250e4:	388f883a 	add	r7,r7,r2
811250e8:	818d883a 	add	r6,r16,r6
811250ec:	390f883a 	add	r7,r7,r4
811250f0:	3421803a 	cmpltu	r16,r6,r16
811250f4:	49cf883a 	add	r7,r9,r7
811250f8:	81cf883a 	add	r7,r16,r7
811250fc:	02800044 	movi	r10,1
81125100:	003fc306 	br	81125010 <__reset+0xfb105010>
81125104:	00800dc4 	movi	r2,55
81125108:	003fcb06 	br	81125038 <__reset+0xfb105038>
8112510c:	38fff01e 	bne	r7,r3,811250d0 <__reset+0xfb1050d0>
81125110:	443fbe16 	blt	r8,r16,8112500c <__reset+0xfb10500c>
81125114:	003fee06 	br	811250d0 <__reset+0xfb1050d0>
81125118:	e0002426 	beq	fp,zero,811251ac <_strtoll_r+0x2cc>
8112511c:	0005883a 	mov	r2,zero
81125120:	00e00034 	movhi	r3,32768
81125124:	d9800017 	ldw	r6,0(sp)
81125128:	01000884 	movi	r4,34
8112512c:	31000015 	stw	r4,0(r6)
81125130:	a83fd026 	beq	r21,zero,81125074 <__reset+0xfb105074>
81125134:	297fffc4 	addi	r5,r5,-1
81125138:	003fcd06 	br	81125070 <__reset+0xfb105070>
8112513c:	1c400084 	addi	r17,r3,2
81125140:	1c000043 	ldbu	r16,1(r3)
81125144:	07000044 	movi	fp,1
81125148:	003f8706 	br	81124f68 <__reset+0xfb104f68>
8112514c:	1c400084 	addi	r17,r3,2
81125150:	1c000043 	ldbu	r16,1(r3)
81125154:	0039883a 	mov	fp,zero
81125158:	003f8306 	br	81124f68 <__reset+0xfb104f68>
8112515c:	88800003 	ldbu	r2,0(r17)
81125160:	00c01604 	movi	r3,88
81125164:	108037cc 	andi	r2,r2,223
81125168:	10c00a26 	beq	r2,r3,81125194 <_strtoll_r+0x2b4>
8112516c:	05000204 	movi	r20,8
81125170:	002f883a 	mov	r23,zero
81125174:	a027883a 	mov	r19,r20
81125178:	003f8006 	br	81124f7c <__reset+0xfb104f7c>
8112517c:	00800c04 	movi	r2,48
81125180:	80800e1e 	bne	r16,r2,811251bc <_strtoll_r+0x2dc>
81125184:	88800003 	ldbu	r2,0(r17)
81125188:	00c01604 	movi	r3,88
8112518c:	108037cc 	andi	r2,r2,223
81125190:	10c00a1e 	bne	r2,r3,811251bc <_strtoll_r+0x2dc>
81125194:	05000404 	movi	r20,16
81125198:	8c000043 	ldbu	r16,1(r17)
8112519c:	002f883a 	mov	r23,zero
811251a0:	8c400084 	addi	r17,r17,2
811251a4:	a027883a 	mov	r19,r20
811251a8:	003f7406 	br	81124f7c <__reset+0xfb104f7c>
811251ac:	00e00034 	movhi	r3,32768
811251b0:	18ffffc4 	addi	r3,r3,-1
811251b4:	5005883a 	mov	r2,r10
811251b8:	003fda06 	br	81125124 <__reset+0xfb105124>
811251bc:	9829883a 	mov	r20,r19
811251c0:	002f883a 	mov	r23,zero
811251c4:	003f6d06 	br	81124f7c <__reset+0xfb104f7c>

811251c8 <_strtoul_r>:
811251c8:	00a04574 	movhi	r2,33045
811251cc:	defff604 	addi	sp,sp,-40
811251d0:	10a10004 	addi	r2,r2,-31744
811251d4:	de00012e 	bgeu	sp,et,811251dc <_strtoul_r+0x14>
811251d8:	003b68fa 	trap	3
811251dc:	dc800315 	stw	r18,12(sp)
811251e0:	14800017 	ldw	r18,0(r2)
811251e4:	dd400615 	stw	r21,24(sp)
811251e8:	dd000515 	stw	r20,20(sp)
811251ec:	dcc00415 	stw	r19,16(sp)
811251f0:	2029883a 	mov	r20,r4
811251f4:	dfc00915 	stw	ra,36(sp)
811251f8:	ddc00815 	stw	r23,32(sp)
811251fc:	dd800715 	stw	r22,28(sp)
81125200:	dc400215 	stw	r17,8(sp)
81125204:	dc000115 	stw	r16,4(sp)
81125208:	2827883a 	mov	r19,r5
8112520c:	382b883a 	mov	r21,r7
81125210:	2809883a 	mov	r4,r5
81125214:	24000003 	ldbu	r16,0(r4)
81125218:	24400044 	addi	r17,r4,1
8112521c:	2007883a 	mov	r3,r4
81125220:	9405883a 	add	r2,r18,r16
81125224:	10800043 	ldbu	r2,1(r2)
81125228:	8809883a 	mov	r4,r17
8112522c:	1080020c 	andi	r2,r2,8
81125230:	103ff81e 	bne	r2,zero,81125214 <__reset+0xfb105214>
81125234:	00800b44 	movi	r2,45
81125238:	80805326 	beq	r16,r2,81125388 <_strtoul_r+0x1c0>
8112523c:	00800ac4 	movi	r2,43
81125240:	80805526 	beq	r16,r2,81125398 <_strtoul_r+0x1d0>
81125244:	002f883a 	mov	r23,zero
81125248:	a8000f26 	beq	r21,zero,81125288 <_strtoul_r+0xc0>
8112524c:	00800404 	movi	r2,16
81125250:	a8805f26 	beq	r21,r2,811253d0 <_strtoul_r+0x208>
81125254:	013fffc4 	movi	r4,-1
81125258:	a80b883a 	mov	r5,r21
8112525c:	d9800015 	stw	r6,0(sp)
81125260:	112a2b40 	call	8112a2b4 <__udivsi3>
81125264:	a80b883a 	mov	r5,r21
81125268:	013fffc4 	movi	r4,-1
8112526c:	102d883a 	mov	r22,r2
81125270:	112a3180 	call	8112a318 <__umodsi3>
81125274:	d9800017 	ldw	r6,0(sp)
81125278:	1019883a 	mov	r12,r2
8112527c:	a817883a 	mov	r11,r21
81125280:	b00f883a 	mov	r7,r22
81125284:	00000706 	br	811252a4 <_strtoul_r+0xdc>
81125288:	00800c04 	movi	r2,48
8112528c:	80804626 	beq	r16,r2,811253a8 <_strtoul_r+0x1e0>
81125290:	05400284 	movi	r21,10
81125294:	01c666b4 	movhi	r7,6554
81125298:	03000144 	movi	r12,5
8112529c:	39e66644 	addi	r7,r7,-26215
811252a0:	a817883a 	mov	r11,r21
811252a4:	9407883a 	add	r3,r18,r16
811252a8:	18c00043 	ldbu	r3,1(r3)
811252ac:	8809883a 	mov	r4,r17
811252b0:	0011883a 	mov	r8,zero
811252b4:	1940010c 	andi	r5,r3,4
811252b8:	0005883a 	mov	r2,zero
811252bc:	02800044 	movi	r10,1
811252c0:	027fffc4 	movi	r9,-1
811252c4:	28000e26 	beq	r5,zero,81125300 <_strtoul_r+0x138>
811252c8:	843ff404 	addi	r16,r16,-48
811252cc:	8540120e 	bge	r16,r21,81125318 <_strtoul_r+0x150>
811252d0:	42400526 	beq	r8,r9,811252e8 <_strtoul_r+0x120>
811252d4:	38802236 	bltu	r7,r2,81125360 <_strtoul_r+0x198>
811252d8:	11c02026 	beq	r2,r7,8112535c <_strtoul_r+0x194>
811252dc:	12c5383a 	mul	r2,r2,r11
811252e0:	02000044 	movi	r8,1
811252e4:	8085883a 	add	r2,r16,r2
811252e8:	24000003 	ldbu	r16,0(r4)
811252ec:	21000044 	addi	r4,r4,1
811252f0:	9407883a 	add	r3,r18,r16
811252f4:	18c00043 	ldbu	r3,1(r3)
811252f8:	1940010c 	andi	r5,r3,4
811252fc:	283ff21e 	bne	r5,zero,811252c8 <__reset+0xfb1052c8>
81125300:	18c000cc 	andi	r3,r3,3
81125304:	18000426 	beq	r3,zero,81125318 <_strtoul_r+0x150>
81125308:	1a801726 	beq	r3,r10,81125368 <_strtoul_r+0x1a0>
8112530c:	00c015c4 	movi	r3,87
81125310:	80e1c83a 	sub	r16,r16,r3
81125314:	857fee16 	blt	r16,r21,811252d0 <__reset+0xfb1052d0>
81125318:	40001516 	blt	r8,zero,81125370 <_strtoul_r+0x1a8>
8112531c:	b8000126 	beq	r23,zero,81125324 <_strtoul_r+0x15c>
81125320:	0085c83a 	sub	r2,zero,r2
81125324:	30000226 	beq	r6,zero,81125330 <_strtoul_r+0x168>
81125328:	4000151e 	bne	r8,zero,81125380 <_strtoul_r+0x1b8>
8112532c:	34c00015 	stw	r19,0(r6)
81125330:	dfc00917 	ldw	ra,36(sp)
81125334:	ddc00817 	ldw	r23,32(sp)
81125338:	dd800717 	ldw	r22,28(sp)
8112533c:	dd400617 	ldw	r21,24(sp)
81125340:	dd000517 	ldw	r20,20(sp)
81125344:	dcc00417 	ldw	r19,16(sp)
81125348:	dc800317 	ldw	r18,12(sp)
8112534c:	dc400217 	ldw	r17,8(sp)
81125350:	dc000117 	ldw	r16,4(sp)
81125354:	dec00a04 	addi	sp,sp,40
81125358:	f800283a 	ret
8112535c:	643fdf0e 	bge	r12,r16,811252dc <__reset+0xfb1052dc>
81125360:	023fffc4 	movi	r8,-1
81125364:	003fe006 	br	811252e8 <__reset+0xfb1052e8>
81125368:	00c00dc4 	movi	r3,55
8112536c:	003fe806 	br	81125310 <__reset+0xfb105310>
81125370:	00800884 	movi	r2,34
81125374:	a0800015 	stw	r2,0(r20)
81125378:	00bfffc4 	movi	r2,-1
8112537c:	303fec26 	beq	r6,zero,81125330 <__reset+0xfb105330>
81125380:	24ffffc4 	addi	r19,r4,-1
81125384:	003fe906 	br	8112532c <__reset+0xfb10532c>
81125388:	1c400084 	addi	r17,r3,2
8112538c:	1c000043 	ldbu	r16,1(r3)
81125390:	05c00044 	movi	r23,1
81125394:	003fac06 	br	81125248 <__reset+0xfb105248>
81125398:	1c400084 	addi	r17,r3,2
8112539c:	1c000043 	ldbu	r16,1(r3)
811253a0:	002f883a 	mov	r23,zero
811253a4:	003fa806 	br	81125248 <__reset+0xfb105248>
811253a8:	88800003 	ldbu	r2,0(r17)
811253ac:	00c01604 	movi	r3,88
811253b0:	108037cc 	andi	r2,r2,223
811253b4:	10c00c26 	beq	r2,r3,811253e8 <_strtoul_r+0x220>
811253b8:	05400204 	movi	r21,8
811253bc:	01c80034 	movhi	r7,8192
811253c0:	030001c4 	movi	r12,7
811253c4:	39ffffc4 	addi	r7,r7,-1
811253c8:	a817883a 	mov	r11,r21
811253cc:	003fb506 	br	811252a4 <__reset+0xfb1052a4>
811253d0:	00800c04 	movi	r2,48
811253d4:	80800c1e 	bne	r16,r2,81125408 <_strtoul_r+0x240>
811253d8:	88800003 	ldbu	r2,0(r17)
811253dc:	00c01604 	movi	r3,88
811253e0:	108037cc 	andi	r2,r2,223
811253e4:	10c0081e 	bne	r2,r3,81125408 <_strtoul_r+0x240>
811253e8:	02c00404 	movi	r11,16
811253ec:	05840034 	movhi	r22,4096
811253f0:	8c000043 	ldbu	r16,1(r17)
811253f4:	030003c4 	movi	r12,15
811253f8:	8c400084 	addi	r17,r17,2
811253fc:	b5bfffc4 	addi	r22,r22,-1
81125400:	582b883a 	mov	r21,r11
81125404:	003f9e06 	br	81125280 <__reset+0xfb105280>
81125408:	01c40034 	movhi	r7,4096
8112540c:	030003c4 	movi	r12,15
81125410:	39ffffc4 	addi	r7,r7,-1
81125414:	a817883a 	mov	r11,r21
81125418:	003fa206 	br	811252a4 <__reset+0xfb1052a4>

8112541c <strtoul>:
8112541c:	00a04574 	movhi	r2,33045
81125420:	10a10204 	addi	r2,r2,-31736
81125424:	300f883a 	mov	r7,r6
81125428:	280d883a 	mov	r6,r5
8112542c:	200b883a 	mov	r5,r4
81125430:	11000017 	ldw	r4,0(r2)
81125434:	11251c81 	jmpi	811251c8 <_strtoul_r>

81125438 <_strtoull_r>:
81125438:	00a04574 	movhi	r2,33045
8112543c:	defff404 	addi	sp,sp,-48
81125440:	10a10004 	addi	r2,r2,-31744
81125444:	de00012e 	bgeu	sp,et,8112544c <_strtoull_r+0x14>
81125448:	003b68fa 	trap	3
8112544c:	dc400315 	stw	r17,12(sp)
81125450:	14400017 	ldw	r17,0(r2)
81125454:	dd400715 	stw	r21,28(sp)
81125458:	dd000615 	stw	r20,24(sp)
8112545c:	dcc00515 	stw	r19,20(sp)
81125460:	dc800415 	stw	r18,16(sp)
81125464:	dfc00b15 	stw	ra,44(sp)
81125468:	df000a15 	stw	fp,40(sp)
8112546c:	ddc00915 	stw	r23,36(sp)
81125470:	dd800815 	stw	r22,32(sp)
81125474:	dc000215 	stw	r16,8(sp)
81125478:	2827883a 	mov	r19,r5
8112547c:	202b883a 	mov	r21,r4
81125480:	3029883a 	mov	r20,r6
81125484:	3825883a 	mov	r18,r7
81125488:	2807883a 	mov	r3,r5
8112548c:	1c000003 	ldbu	r16,0(r3)
81125490:	1f000044 	addi	fp,r3,1
81125494:	1809883a 	mov	r4,r3
81125498:	8c05883a 	add	r2,r17,r16
8112549c:	10800043 	ldbu	r2,1(r2)
811254a0:	e007883a 	mov	r3,fp
811254a4:	1080020c 	andi	r2,r2,8
811254a8:	103ff81e 	bne	r2,zero,8112548c <__reset+0xfb10548c>
811254ac:	00800b44 	movi	r2,45
811254b0:	80806e26 	beq	r16,r2,8112566c <_strtoull_r+0x234>
811254b4:	00800ac4 	movi	r2,43
811254b8:	80807026 	beq	r16,r2,8112567c <_strtoull_r+0x244>
811254bc:	002f883a 	mov	r23,zero
811254c0:	90001426 	beq	r18,zero,81125514 <_strtoull_r+0xdc>
811254c4:	00800404 	movi	r2,16
811254c8:	90807c26 	beq	r18,r2,811256bc <_strtoull_r+0x284>
811254cc:	902dd7fa 	srai	r22,r18,31
811254d0:	013fffc4 	movi	r4,-1
811254d4:	200b883a 	mov	r5,r4
811254d8:	900d883a 	mov	r6,r18
811254dc:	b00f883a 	mov	r7,r22
811254e0:	11296fc0 	call	811296fc <__udivdi3>
811254e4:	013fffc4 	movi	r4,-1
811254e8:	900d883a 	mov	r6,r18
811254ec:	b00f883a 	mov	r7,r22
811254f0:	200b883a 	mov	r5,r4
811254f4:	d8c00115 	stw	r3,4(sp)
811254f8:	d8800015 	stw	r2,0(sp)
811254fc:	1129c7c0 	call	81129c7c <__umoddi3>
81125500:	101b883a 	mov	r13,r2
81125504:	9015883a 	mov	r10,r18
81125508:	dac00017 	ldw	r11,0(sp)
8112550c:	da000117 	ldw	r8,4(sp)
81125510:	00000a06 	br	8112553c <_strtoull_r+0x104>
81125514:	00800c04 	movi	r2,48
81125518:	80805c26 	beq	r16,r2,8112568c <_strtoull_r+0x254>
8112551c:	02800284 	movi	r10,10
81125520:	02e666b4 	movhi	r11,39322
81125524:	020666b4 	movhi	r8,6554
81125528:	03400144 	movi	r13,5
8112552c:	5ae66644 	addi	r11,r11,-26215
81125530:	42266644 	addi	r8,r8,-26215
81125534:	002d883a 	mov	r22,zero
81125538:	5025883a 	mov	r18,r10
8112553c:	8c0b883a 	add	r5,r17,r16
81125540:	29400043 	ldbu	r5,1(r5)
81125544:	e009883a 	mov	r4,fp
81125548:	000f883a 	mov	r7,zero
8112554c:	2980010c 	andi	r6,r5,4
81125550:	0005883a 	mov	r2,zero
81125554:	0007883a 	mov	r3,zero
81125558:	03000044 	movi	r12,1
8112555c:	027fffc4 	movi	r9,-1
81125560:	30000d26 	beq	r6,zero,81125598 <_strtoull_r+0x160>
81125564:	843ff404 	addi	r16,r16,-48
81125568:	8480110e 	bge	r16,r18,811255b0 <_strtoull_r+0x178>
8112556c:	3a400426 	beq	r7,r9,81125580 <_strtoull_r+0x148>
81125570:	40c00236 	bltu	r8,r3,8112557c <_strtoull_r+0x144>
81125574:	1a00231e 	bne	r3,r8,81125604 <_strtoull_r+0x1cc>
81125578:	5880222e 	bgeu	r11,r2,81125604 <_strtoull_r+0x1cc>
8112557c:	01ffffc4 	movi	r7,-1
81125580:	24000003 	ldbu	r16,0(r4)
81125584:	21000044 	addi	r4,r4,1
81125588:	8c0b883a 	add	r5,r17,r16
8112558c:	29400043 	ldbu	r5,1(r5)
81125590:	2980010c 	andi	r6,r5,4
81125594:	303ff31e 	bne	r6,zero,81125564 <__reset+0xfb105564>
81125598:	294000cc 	andi	r5,r5,3
8112559c:	28000426 	beq	r5,zero,811255b0 <_strtoull_r+0x178>
811255a0:	2b002626 	beq	r5,r12,8112563c <_strtoull_r+0x204>
811255a4:	014015c4 	movi	r5,87
811255a8:	8161c83a 	sub	r16,r16,r5
811255ac:	84bfef16 	blt	r16,r18,8112556c <__reset+0xfb10556c>
811255b0:	38002716 	blt	r7,zero,81125650 <_strtoull_r+0x218>
811255b4:	b8000426 	beq	r23,zero,811255c8 <_strtoull_r+0x190>
811255b8:	0085c83a 	sub	r2,zero,r2
811255bc:	100ac03a 	cmpne	r5,r2,zero
811255c0:	00e1c83a 	sub	r16,zero,r3
811255c4:	8147c83a 	sub	r3,r16,r5
811255c8:	a0000226 	beq	r20,zero,811255d4 <_strtoull_r+0x19c>
811255cc:	3800251e 	bne	r7,zero,81125664 <_strtoull_r+0x22c>
811255d0:	a4c00015 	stw	r19,0(r20)
811255d4:	dfc00b17 	ldw	ra,44(sp)
811255d8:	df000a17 	ldw	fp,40(sp)
811255dc:	ddc00917 	ldw	r23,36(sp)
811255e0:	dd800817 	ldw	r22,32(sp)
811255e4:	dd400717 	ldw	r21,28(sp)
811255e8:	dd000617 	ldw	r20,24(sp)
811255ec:	dcc00517 	ldw	r19,20(sp)
811255f0:	dc800417 	ldw	r18,16(sp)
811255f4:	dc400317 	ldw	r17,12(sp)
811255f8:	dc000217 	ldw	r16,8(sp)
811255fc:	dec00c04 	addi	sp,sp,48
81125600:	f800283a 	ret
81125604:	12c00f26 	beq	r2,r11,81125644 <_strtoull_r+0x20c>
81125608:	b08d383a 	mul	r6,r22,r2
8112560c:	1a87383a 	mul	r3,r3,r10
81125610:	128a383a 	mulxuu	r5,r2,r10
81125614:	1285383a 	mul	r2,r2,r10
81125618:	800fd7fa 	srai	r7,r16,31
8112561c:	1987883a 	add	r3,r3,r6
81125620:	8085883a 	add	r2,r16,r2
81125624:	1947883a 	add	r3,r3,r5
81125628:	38c7883a 	add	r3,r7,r3
8112562c:	1421803a 	cmpltu	r16,r2,r16
81125630:	80c7883a 	add	r3,r16,r3
81125634:	01c00044 	movi	r7,1
81125638:	003fd106 	br	81125580 <__reset+0xfb105580>
8112563c:	01400dc4 	movi	r5,55
81125640:	003fd906 	br	811255a8 <__reset+0xfb1055a8>
81125644:	1a3ff01e 	bne	r3,r8,81125608 <__reset+0xfb105608>
81125648:	6c3fcc16 	blt	r13,r16,8112557c <__reset+0xfb10557c>
8112564c:	003fee06 	br	81125608 <__reset+0xfb105608>
81125650:	00800884 	movi	r2,34
81125654:	a8800015 	stw	r2,0(r21)
81125658:	00bfffc4 	movi	r2,-1
8112565c:	1007883a 	mov	r3,r2
81125660:	a03fdc26 	beq	r20,zero,811255d4 <__reset+0xfb1055d4>
81125664:	24ffffc4 	addi	r19,r4,-1
81125668:	003fd906 	br	811255d0 <__reset+0xfb1055d0>
8112566c:	27000084 	addi	fp,r4,2
81125670:	24000043 	ldbu	r16,1(r4)
81125674:	05c00044 	movi	r23,1
81125678:	003f9106 	br	811254c0 <__reset+0xfb1054c0>
8112567c:	27000084 	addi	fp,r4,2
81125680:	24000043 	ldbu	r16,1(r4)
81125684:	002f883a 	mov	r23,zero
81125688:	003f8d06 	br	811254c0 <__reset+0xfb1054c0>
8112568c:	e0800003 	ldbu	r2,0(fp)
81125690:	00c01604 	movi	r3,88
81125694:	108037cc 	andi	r2,r2,223
81125698:	10c00e26 	beq	r2,r3,811256d4 <_strtoull_r+0x29c>
8112569c:	02800204 	movi	r10,8
811256a0:	02ffffc4 	movi	r11,-1
811256a4:	02080034 	movhi	r8,8192
811256a8:	034001c4 	movi	r13,7
811256ac:	42d1883a 	add	r8,r8,r11
811256b0:	002d883a 	mov	r22,zero
811256b4:	5025883a 	mov	r18,r10
811256b8:	003fa006 	br	8112553c <__reset+0xfb10553c>
811256bc:	00800c04 	movi	r2,48
811256c0:	80800e1e 	bne	r16,r2,811256fc <_strtoull_r+0x2c4>
811256c4:	e0800003 	ldbu	r2,0(fp)
811256c8:	00c01604 	movi	r3,88
811256cc:	108037cc 	andi	r2,r2,223
811256d0:	10c00a1e 	bne	r2,r3,811256fc <_strtoull_r+0x2c4>
811256d4:	02800404 	movi	r10,16
811256d8:	02ffffc4 	movi	r11,-1
811256dc:	02040034 	movhi	r8,4096
811256e0:	e4000043 	ldbu	r16,1(fp)
811256e4:	034003c4 	movi	r13,15
811256e8:	e7000084 	addi	fp,fp,2
811256ec:	42d1883a 	add	r8,r8,r11
811256f0:	002d883a 	mov	r22,zero
811256f4:	5025883a 	mov	r18,r10
811256f8:	003f9006 	br	8112553c <__reset+0xfb10553c>
811256fc:	02ffffc4 	movi	r11,-1
81125700:	02040034 	movhi	r8,4096
81125704:	034003c4 	movi	r13,15
81125708:	42d1883a 	add	r8,r8,r11
8112570c:	9015883a 	mov	r10,r18
81125710:	002d883a 	mov	r22,zero
81125714:	003f8906 	br	8112553c <__reset+0xfb10553c>

81125718 <__ssprint_r>:
81125718:	defff604 	addi	sp,sp,-40
8112571c:	de00012e 	bgeu	sp,et,81125724 <__ssprint_r+0xc>
81125720:	003b68fa 	trap	3
81125724:	30800217 	ldw	r2,8(r6)
81125728:	dc800215 	stw	r18,8(sp)
8112572c:	dfc00915 	stw	ra,36(sp)
81125730:	df000815 	stw	fp,32(sp)
81125734:	ddc00715 	stw	r23,28(sp)
81125738:	dd800615 	stw	r22,24(sp)
8112573c:	dd400515 	stw	r21,20(sp)
81125740:	dd000415 	stw	r20,16(sp)
81125744:	dcc00315 	stw	r19,12(sp)
81125748:	dc400115 	stw	r17,4(sp)
8112574c:	dc000015 	stw	r16,0(sp)
81125750:	3025883a 	mov	r18,r6
81125754:	10005826 	beq	r2,zero,811258b8 <__ssprint_r+0x1a0>
81125758:	2027883a 	mov	r19,r4
8112575c:	35c00017 	ldw	r23,0(r6)
81125760:	29000017 	ldw	r4,0(r5)
81125764:	28800217 	ldw	r2,8(r5)
81125768:	2823883a 	mov	r17,r5
8112576c:	0039883a 	mov	fp,zero
81125770:	0021883a 	mov	r16,zero
81125774:	80003926 	beq	r16,zero,8112585c <__ssprint_r+0x144>
81125778:	102b883a 	mov	r21,r2
8112577c:	102d883a 	mov	r22,r2
81125780:	80803a36 	bltu	r16,r2,8112586c <__ssprint_r+0x154>
81125784:	88c0030b 	ldhu	r3,12(r17)
81125788:	1881200c 	andi	r2,r3,1152
8112578c:	10002626 	beq	r2,zero,81125828 <__ssprint_r+0x110>
81125790:	88800517 	ldw	r2,20(r17)
81125794:	89400417 	ldw	r5,16(r17)
81125798:	81800044 	addi	r6,r16,1
8112579c:	108f883a 	add	r7,r2,r2
811257a0:	3885883a 	add	r2,r7,r2
811257a4:	100ed7fa 	srli	r7,r2,31
811257a8:	216dc83a 	sub	r22,r4,r5
811257ac:	3589883a 	add	r4,r6,r22
811257b0:	3885883a 	add	r2,r7,r2
811257b4:	102bd07a 	srai	r21,r2,1
811257b8:	a80d883a 	mov	r6,r21
811257bc:	a900022e 	bgeu	r21,r4,811257c8 <__ssprint_r+0xb0>
811257c0:	202b883a 	mov	r21,r4
811257c4:	200d883a 	mov	r6,r4
811257c8:	18c1000c 	andi	r3,r3,1024
811257cc:	18002a26 	beq	r3,zero,81125878 <__ssprint_r+0x160>
811257d0:	300b883a 	mov	r5,r6
811257d4:	9809883a 	mov	r4,r19
811257d8:	11174b80 	call	811174b8 <_malloc_r>
811257dc:	1029883a 	mov	r20,r2
811257e0:	10002c26 	beq	r2,zero,81125894 <__ssprint_r+0x17c>
811257e4:	89400417 	ldw	r5,16(r17)
811257e8:	b00d883a 	mov	r6,r22
811257ec:	1009883a 	mov	r4,r2
811257f0:	1117ccc0 	call	81117ccc <memcpy>
811257f4:	8880030b 	ldhu	r2,12(r17)
811257f8:	00fedfc4 	movi	r3,-1153
811257fc:	10c4703a 	and	r2,r2,r3
81125800:	10802014 	ori	r2,r2,128
81125804:	8880030d 	sth	r2,12(r17)
81125808:	a589883a 	add	r4,r20,r22
8112580c:	adadc83a 	sub	r22,r21,r22
81125810:	8d400515 	stw	r21,20(r17)
81125814:	8d800215 	stw	r22,8(r17)
81125818:	8d000415 	stw	r20,16(r17)
8112581c:	89000015 	stw	r4,0(r17)
81125820:	802b883a 	mov	r21,r16
81125824:	802d883a 	mov	r22,r16
81125828:	b00d883a 	mov	r6,r22
8112582c:	e00b883a 	mov	r5,fp
81125830:	1121da00 	call	81121da0 <memmove>
81125834:	88800217 	ldw	r2,8(r17)
81125838:	89000017 	ldw	r4,0(r17)
8112583c:	90c00217 	ldw	r3,8(r18)
81125840:	1545c83a 	sub	r2,r2,r21
81125844:	2589883a 	add	r4,r4,r22
81125848:	88800215 	stw	r2,8(r17)
8112584c:	89000015 	stw	r4,0(r17)
81125850:	1c21c83a 	sub	r16,r3,r16
81125854:	94000215 	stw	r16,8(r18)
81125858:	80001726 	beq	r16,zero,811258b8 <__ssprint_r+0x1a0>
8112585c:	bf000017 	ldw	fp,0(r23)
81125860:	bc000117 	ldw	r16,4(r23)
81125864:	bdc00204 	addi	r23,r23,8
81125868:	003fc206 	br	81125774 <__reset+0xfb105774>
8112586c:	802b883a 	mov	r21,r16
81125870:	802d883a 	mov	r22,r16
81125874:	003fec06 	br	81125828 <__reset+0xfb105828>
81125878:	9809883a 	mov	r4,r19
8112587c:	1122fc00 	call	81122fc0 <_realloc_r>
81125880:	1029883a 	mov	r20,r2
81125884:	103fe01e 	bne	r2,zero,81125808 <__reset+0xfb105808>
81125888:	89400417 	ldw	r5,16(r17)
8112588c:	9809883a 	mov	r4,r19
81125890:	1120f2c0 	call	81120f2c <_free_r>
81125894:	88c0030b 	ldhu	r3,12(r17)
81125898:	00800304 	movi	r2,12
8112589c:	98800015 	stw	r2,0(r19)
811258a0:	18c01014 	ori	r3,r3,64
811258a4:	88c0030d 	sth	r3,12(r17)
811258a8:	00bfffc4 	movi	r2,-1
811258ac:	90000215 	stw	zero,8(r18)
811258b0:	90000115 	stw	zero,4(r18)
811258b4:	00000206 	br	811258c0 <__ssprint_r+0x1a8>
811258b8:	90000115 	stw	zero,4(r18)
811258bc:	0005883a 	mov	r2,zero
811258c0:	dfc00917 	ldw	ra,36(sp)
811258c4:	df000817 	ldw	fp,32(sp)
811258c8:	ddc00717 	ldw	r23,28(sp)
811258cc:	dd800617 	ldw	r22,24(sp)
811258d0:	dd400517 	ldw	r21,20(sp)
811258d4:	dd000417 	ldw	r20,16(sp)
811258d8:	dcc00317 	ldw	r19,12(sp)
811258dc:	dc800217 	ldw	r18,8(sp)
811258e0:	dc400117 	ldw	r17,4(sp)
811258e4:	dc000017 	ldw	r16,0(sp)
811258e8:	dec00a04 	addi	sp,sp,40
811258ec:	f800283a 	ret

811258f0 <___svfiprintf_internal_r>:
811258f0:	deffc804 	addi	sp,sp,-224
811258f4:	de00012e 	bgeu	sp,et,811258fc <___svfiprintf_internal_r+0xc>
811258f8:	003b68fa 	trap	3
811258fc:	2880030b 	ldhu	r2,12(r5)
81125900:	dcc03115 	stw	r19,196(sp)
81125904:	dfc03715 	stw	ra,220(sp)
81125908:	df003615 	stw	fp,216(sp)
8112590c:	ddc03515 	stw	r23,212(sp)
81125910:	dd803415 	stw	r22,208(sp)
81125914:	dd403315 	stw	r21,204(sp)
81125918:	dd003215 	stw	r20,200(sp)
8112591c:	dc803015 	stw	r18,192(sp)
81125920:	dc402f15 	stw	r17,188(sp)
81125924:	dc002e15 	stw	r16,184(sp)
81125928:	d9402715 	stw	r5,156(sp)
8112592c:	d9002a15 	stw	r4,168(sp)
81125930:	1080200c 	andi	r2,r2,128
81125934:	d9c02315 	stw	r7,140(sp)
81125938:	3027883a 	mov	r19,r6
8112593c:	10000226 	beq	r2,zero,81125948 <___svfiprintf_internal_r+0x58>
81125940:	28800417 	ldw	r2,16(r5)
81125944:	10041d26 	beq	r2,zero,811269bc <___svfiprintf_internal_r+0x10cc>
81125948:	dac01a04 	addi	r11,sp,104
8112594c:	dac01e15 	stw	r11,120(sp)
81125950:	d8801e17 	ldw	r2,120(sp)
81125954:	dac019c4 	addi	r11,sp,103
81125958:	dd402a17 	ldw	r21,168(sp)
8112595c:	ddc02717 	ldw	r23,156(sp)
81125960:	05a04534 	movhi	r22,33044
81125964:	05204534 	movhi	r20,33044
81125968:	dac01f15 	stw	r11,124(sp)
8112596c:	12d7c83a 	sub	r11,r2,r11
81125970:	b597c104 	addi	r22,r22,24324
81125974:	a517bd04 	addi	r20,r20,24308
81125978:	dec01a15 	stw	sp,104(sp)
8112597c:	d8001c15 	stw	zero,112(sp)
81125980:	d8001b15 	stw	zero,108(sp)
81125984:	d811883a 	mov	r8,sp
81125988:	d8002915 	stw	zero,164(sp)
8112598c:	d8002515 	stw	zero,148(sp)
81125990:	dac02b15 	stw	r11,172(sp)
81125994:	98800007 	ldb	r2,0(r19)
81125998:	1002dd26 	beq	r2,zero,81126510 <___svfiprintf_internal_r+0xc20>
8112599c:	00c00944 	movi	r3,37
811259a0:	9823883a 	mov	r17,r19
811259a4:	10c0021e 	bne	r2,r3,811259b0 <___svfiprintf_internal_r+0xc0>
811259a8:	00001406 	br	811259fc <___svfiprintf_internal_r+0x10c>
811259ac:	10c00326 	beq	r2,r3,811259bc <___svfiprintf_internal_r+0xcc>
811259b0:	8c400044 	addi	r17,r17,1
811259b4:	88800007 	ldb	r2,0(r17)
811259b8:	103ffc1e 	bne	r2,zero,811259ac <__reset+0xfb1059ac>
811259bc:	8ce1c83a 	sub	r16,r17,r19
811259c0:	80000e26 	beq	r16,zero,811259fc <___svfiprintf_internal_r+0x10c>
811259c4:	d8c01c17 	ldw	r3,112(sp)
811259c8:	d8801b17 	ldw	r2,108(sp)
811259cc:	44c00015 	stw	r19,0(r8)
811259d0:	1c07883a 	add	r3,r3,r16
811259d4:	10800044 	addi	r2,r2,1
811259d8:	d8c01c15 	stw	r3,112(sp)
811259dc:	44000115 	stw	r16,4(r8)
811259e0:	d8801b15 	stw	r2,108(sp)
811259e4:	00c001c4 	movi	r3,7
811259e8:	18831e16 	blt	r3,r2,81126664 <___svfiprintf_internal_r+0xd74>
811259ec:	42000204 	addi	r8,r8,8
811259f0:	dac02517 	ldw	r11,148(sp)
811259f4:	5c17883a 	add	r11,r11,r16
811259f8:	dac02515 	stw	r11,148(sp)
811259fc:	88800007 	ldb	r2,0(r17)
81125a00:	1002c526 	beq	r2,zero,81126518 <___svfiprintf_internal_r+0xc28>
81125a04:	88c00047 	ldb	r3,1(r17)
81125a08:	8cc00044 	addi	r19,r17,1
81125a0c:	d8001d85 	stb	zero,118(sp)
81125a10:	0009883a 	mov	r4,zero
81125a14:	000f883a 	mov	r7,zero
81125a18:	043fffc4 	movi	r16,-1
81125a1c:	d8002415 	stw	zero,144(sp)
81125a20:	0025883a 	mov	r18,zero
81125a24:	01401604 	movi	r5,88
81125a28:	01800244 	movi	r6,9
81125a2c:	02800a84 	movi	r10,42
81125a30:	02401b04 	movi	r9,108
81125a34:	9cc00044 	addi	r19,r19,1
81125a38:	18bff804 	addi	r2,r3,-32
81125a3c:	2881dd36 	bltu	r5,r2,811261b4 <___svfiprintf_internal_r+0x8c4>
81125a40:	100490ba 	slli	r2,r2,2
81125a44:	02e044b4 	movhi	r11,33042
81125a48:	5ad69604 	addi	r11,r11,23128
81125a4c:	12c5883a 	add	r2,r2,r11
81125a50:	10800017 	ldw	r2,0(r2)
81125a54:	1000683a 	jmp	r2
81125a58:	81125c54 	ori	r4,r16,18801
81125a5c:	811261b4 	orhi	r4,r16,18822
81125a60:	811261b4 	orhi	r4,r16,18822
81125a64:	81125c48 	cmpgei	r4,r16,18801
81125a68:	811261b4 	orhi	r4,r16,18822
81125a6c:	811261b4 	orhi	r4,r16,18822
81125a70:	811261b4 	orhi	r4,r16,18822
81125a74:	811261b4 	orhi	r4,r16,18822
81125a78:	811261b4 	orhi	r4,r16,18822
81125a7c:	811261b4 	orhi	r4,r16,18822
81125a80:	81125bbc 	xorhi	r4,r16,18798
81125a84:	81125d98 	cmpnei	r4,r16,18806
81125a88:	811261b4 	orhi	r4,r16,18822
81125a8c:	81125be8 	cmpgeui	r4,r16,18799
81125a90:	811261e8 	cmpgeui	r4,r16,18823
81125a94:	811261b4 	orhi	r4,r16,18822
81125a98:	811261dc 	xori	r4,r16,18823
81125a9c:	8112617c 	xorhi	r4,r16,18821
81125aa0:	8112617c 	xorhi	r4,r16,18821
81125aa4:	8112617c 	xorhi	r4,r16,18821
81125aa8:	8112617c 	xorhi	r4,r16,18821
81125aac:	8112617c 	xorhi	r4,r16,18821
81125ab0:	8112617c 	xorhi	r4,r16,18821
81125ab4:	8112617c 	xorhi	r4,r16,18821
81125ab8:	8112617c 	xorhi	r4,r16,18821
81125abc:	8112617c 	xorhi	r4,r16,18821
81125ac0:	811261b4 	orhi	r4,r16,18822
81125ac4:	811261b4 	orhi	r4,r16,18822
81125ac8:	811261b4 	orhi	r4,r16,18822
81125acc:	811261b4 	orhi	r4,r16,18822
81125ad0:	811261b4 	orhi	r4,r16,18822
81125ad4:	811261b4 	orhi	r4,r16,18822
81125ad8:	811261b4 	orhi	r4,r16,18822
81125adc:	811261b4 	orhi	r4,r16,18822
81125ae0:	811261b4 	orhi	r4,r16,18822
81125ae4:	811261b4 	orhi	r4,r16,18822
81125ae8:	81126118 	cmpnei	r4,r16,18820
81125aec:	811261b4 	orhi	r4,r16,18822
81125af0:	811261b4 	orhi	r4,r16,18822
81125af4:	811261b4 	orhi	r4,r16,18822
81125af8:	811261b4 	orhi	r4,r16,18822
81125afc:	811261b4 	orhi	r4,r16,18822
81125b00:	811261b4 	orhi	r4,r16,18822
81125b04:	811261b4 	orhi	r4,r16,18822
81125b08:	811261b4 	orhi	r4,r16,18822
81125b0c:	811261b4 	orhi	r4,r16,18822
81125b10:	811261b4 	orhi	r4,r16,18822
81125b14:	81126290 	cmplti	r4,r16,18826
81125b18:	811261b4 	orhi	r4,r16,18822
81125b1c:	811261b4 	orhi	r4,r16,18822
81125b20:	811261b4 	orhi	r4,r16,18822
81125b24:	811261b4 	orhi	r4,r16,18822
81125b28:	811261b4 	orhi	r4,r16,18822
81125b2c:	81126228 	cmpgeui	r4,r16,18824
81125b30:	811261b4 	orhi	r4,r16,18822
81125b34:	811261b4 	orhi	r4,r16,18822
81125b38:	81125f5c 	xori	r4,r16,18813
81125b3c:	811261b4 	orhi	r4,r16,18822
81125b40:	811261b4 	orhi	r4,r16,18822
81125b44:	811261b4 	orhi	r4,r16,18822
81125b48:	811261b4 	orhi	r4,r16,18822
81125b4c:	811261b4 	orhi	r4,r16,18822
81125b50:	811261b4 	orhi	r4,r16,18822
81125b54:	811261b4 	orhi	r4,r16,18822
81125b58:	811261b4 	orhi	r4,r16,18822
81125b5c:	811261b4 	orhi	r4,r16,18822
81125b60:	811261b4 	orhi	r4,r16,18822
81125b64:	81125e4c 	andi	r4,r16,18809
81125b68:	81125ff8 	rdprs	r4,r16,18815
81125b6c:	811261b4 	orhi	r4,r16,18822
81125b70:	811261b4 	orhi	r4,r16,18822
81125b74:	811261b4 	orhi	r4,r16,18822
81125b78:	81125fec 	andhi	r4,r16,18815
81125b7c:	81125ff8 	rdprs	r4,r16,18815
81125b80:	811261b4 	orhi	r4,r16,18822
81125b84:	811261b4 	orhi	r4,r16,18822
81125b88:	81125fdc 	xori	r4,r16,18815
81125b8c:	811261b4 	orhi	r4,r16,18822
81125b90:	81125fa0 	cmpeqi	r4,r16,18814
81125b94:	81125da8 	cmpgeui	r4,r16,18806
81125b98:	81125bf4 	orhi	r4,r16,18799
81125b9c:	8112610c 	andi	r4,r16,18820
81125ba0:	811261b4 	orhi	r4,r16,18822
81125ba4:	811260c0 	call	8811260c <__reset+0x20f260c>
81125ba8:	811261b4 	orhi	r4,r16,18822
81125bac:	81125d18 	cmpnei	r4,r16,18804
81125bb0:	811261b4 	orhi	r4,r16,18822
81125bb4:	811261b4 	orhi	r4,r16,18822
81125bb8:	81125c74 	orhi	r4,r16,18801
81125bbc:	dac02317 	ldw	r11,140(sp)
81125bc0:	5ac00017 	ldw	r11,0(r11)
81125bc4:	dac02415 	stw	r11,144(sp)
81125bc8:	dac02317 	ldw	r11,140(sp)
81125bcc:	58800104 	addi	r2,r11,4
81125bd0:	dac02417 	ldw	r11,144(sp)
81125bd4:	5802e90e 	bge	r11,zero,8112677c <___svfiprintf_internal_r+0xe8c>
81125bd8:	dac02417 	ldw	r11,144(sp)
81125bdc:	d8802315 	stw	r2,140(sp)
81125be0:	02d7c83a 	sub	r11,zero,r11
81125be4:	dac02415 	stw	r11,144(sp)
81125be8:	94800114 	ori	r18,r18,4
81125bec:	98c00007 	ldb	r3,0(r19)
81125bf0:	003f9006 	br	81125a34 <__reset+0xfb105a34>
81125bf4:	00800c04 	movi	r2,48
81125bf8:	dac02317 	ldw	r11,140(sp)
81125bfc:	d8801d05 	stb	r2,116(sp)
81125c00:	00801e04 	movi	r2,120
81125c04:	d8801d45 	stb	r2,117(sp)
81125c08:	d8001d85 	stb	zero,118(sp)
81125c0c:	58c00104 	addi	r3,r11,4
81125c10:	5f000017 	ldw	fp,0(r11)
81125c14:	0013883a 	mov	r9,zero
81125c18:	90800094 	ori	r2,r18,2
81125c1c:	80032b16 	blt	r16,zero,811268cc <___svfiprintf_internal_r+0xfdc>
81125c20:	00bfdfc4 	movi	r2,-129
81125c24:	90a4703a 	and	r18,r18,r2
81125c28:	d8c02315 	stw	r3,140(sp)
81125c2c:	94800094 	ori	r18,r18,2
81125c30:	e002dc26 	beq	fp,zero,811267a4 <___svfiprintf_internal_r+0xeb4>
81125c34:	01204534 	movhi	r4,33044
81125c38:	21173304 	addi	r4,r4,23756
81125c3c:	0015883a 	mov	r10,zero
81125c40:	d9002915 	stw	r4,164(sp)
81125c44:	00002306 	br	81125cd4 <___svfiprintf_internal_r+0x3e4>
81125c48:	94800054 	ori	r18,r18,1
81125c4c:	98c00007 	ldb	r3,0(r19)
81125c50:	003f7806 	br	81125a34 <__reset+0xfb105a34>
81125c54:	38803fcc 	andi	r2,r7,255
81125c58:	1080201c 	xori	r2,r2,128
81125c5c:	10bfe004 	addi	r2,r2,-128
81125c60:	1002f31e 	bne	r2,zero,81126830 <___svfiprintf_internal_r+0xf40>
81125c64:	01000044 	movi	r4,1
81125c68:	01c00804 	movi	r7,32
81125c6c:	98c00007 	ldb	r3,0(r19)
81125c70:	003f7006 	br	81125a34 <__reset+0xfb105a34>
81125c74:	21003fcc 	andi	r4,r4,255
81125c78:	2003aa1e 	bne	r4,zero,81126b24 <___svfiprintf_internal_r+0x1234>
81125c7c:	00a04534 	movhi	r2,33044
81125c80:	10973304 	addi	r2,r2,23756
81125c84:	d8802915 	stw	r2,164(sp)
81125c88:	9080080c 	andi	r2,r18,32
81125c8c:	1000ba26 	beq	r2,zero,81125f78 <___svfiprintf_internal_r+0x688>
81125c90:	dac02317 	ldw	r11,140(sp)
81125c94:	5f000017 	ldw	fp,0(r11)
81125c98:	5a400117 	ldw	r9,4(r11)
81125c9c:	5ac00204 	addi	r11,r11,8
81125ca0:	dac02315 	stw	r11,140(sp)
81125ca4:	9080004c 	andi	r2,r18,1
81125ca8:	10029026 	beq	r2,zero,811266ec <___svfiprintf_internal_r+0xdfc>
81125cac:	e244b03a 	or	r2,fp,r9
81125cb0:	1002d41e 	bne	r2,zero,81126804 <___svfiprintf_internal_r+0xf14>
81125cb4:	d8001d85 	stb	zero,118(sp)
81125cb8:	80030b16 	blt	r16,zero,811268e8 <___svfiprintf_internal_r+0xff8>
81125cbc:	00bfdfc4 	movi	r2,-129
81125cc0:	90a4703a 	and	r18,r18,r2
81125cc4:	0015883a 	mov	r10,zero
81125cc8:	80002426 	beq	r16,zero,81125d5c <___svfiprintf_internal_r+0x46c>
81125ccc:	0039883a 	mov	fp,zero
81125cd0:	0013883a 	mov	r9,zero
81125cd4:	d9002917 	ldw	r4,164(sp)
81125cd8:	dc401a04 	addi	r17,sp,104
81125cdc:	e08003cc 	andi	r2,fp,15
81125ce0:	4806973a 	slli	r3,r9,28
81125ce4:	2085883a 	add	r2,r4,r2
81125ce8:	e038d13a 	srli	fp,fp,4
81125cec:	10800003 	ldbu	r2,0(r2)
81125cf0:	4812d13a 	srli	r9,r9,4
81125cf4:	8c7fffc4 	addi	r17,r17,-1
81125cf8:	1f38b03a 	or	fp,r3,fp
81125cfc:	88800005 	stb	r2,0(r17)
81125d00:	e244b03a 	or	r2,fp,r9
81125d04:	103ff51e 	bne	r2,zero,81125cdc <__reset+0xfb105cdc>
81125d08:	dac01e17 	ldw	r11,120(sp)
81125d0c:	5c57c83a 	sub	r11,r11,r17
81125d10:	dac02115 	stw	r11,132(sp)
81125d14:	00001406 	br	81125d68 <___svfiprintf_internal_r+0x478>
81125d18:	21003fcc 	andi	r4,r4,255
81125d1c:	2003741e 	bne	r4,zero,81126af0 <___svfiprintf_internal_r+0x1200>
81125d20:	9080080c 	andi	r2,r18,32
81125d24:	10014526 	beq	r2,zero,8112623c <___svfiprintf_internal_r+0x94c>
81125d28:	dac02317 	ldw	r11,140(sp)
81125d2c:	d8001d85 	stb	zero,118(sp)
81125d30:	58c00204 	addi	r3,r11,8
81125d34:	5f000017 	ldw	fp,0(r11)
81125d38:	5a400117 	ldw	r9,4(r11)
81125d3c:	8002d916 	blt	r16,zero,811268a4 <___svfiprintf_internal_r+0xfb4>
81125d40:	013fdfc4 	movi	r4,-129
81125d44:	e244b03a 	or	r2,fp,r9
81125d48:	d8c02315 	stw	r3,140(sp)
81125d4c:	9124703a 	and	r18,r18,r4
81125d50:	0015883a 	mov	r10,zero
81125d54:	1000b91e 	bne	r2,zero,8112603c <___svfiprintf_internal_r+0x74c>
81125d58:	8002e61e 	bne	r16,zero,811268f4 <___svfiprintf_internal_r+0x1004>
81125d5c:	0021883a 	mov	r16,zero
81125d60:	d8002115 	stw	zero,132(sp)
81125d64:	dc401a04 	addi	r17,sp,104
81125d68:	d8c02117 	ldw	r3,132(sp)
81125d6c:	dc002015 	stw	r16,128(sp)
81125d70:	80c0010e 	bge	r16,r3,81125d78 <___svfiprintf_internal_r+0x488>
81125d74:	d8c02015 	stw	r3,128(sp)
81125d78:	52803fcc 	andi	r10,r10,255
81125d7c:	5280201c 	xori	r10,r10,128
81125d80:	52bfe004 	addi	r10,r10,-128
81125d84:	50003c26 	beq	r10,zero,81125e78 <___svfiprintf_internal_r+0x588>
81125d88:	dac02017 	ldw	r11,128(sp)
81125d8c:	5ac00044 	addi	r11,r11,1
81125d90:	dac02015 	stw	r11,128(sp)
81125d94:	00003806 	br	81125e78 <___svfiprintf_internal_r+0x588>
81125d98:	01000044 	movi	r4,1
81125d9c:	01c00ac4 	movi	r7,43
81125da0:	98c00007 	ldb	r3,0(r19)
81125da4:	003f2306 	br	81125a34 <__reset+0xfb105a34>
81125da8:	21003fcc 	andi	r4,r4,255
81125dac:	2003481e 	bne	r4,zero,81126ad0 <___svfiprintf_internal_r+0x11e0>
81125db0:	9080080c 	andi	r2,r18,32
81125db4:	10013b26 	beq	r2,zero,811262a4 <___svfiprintf_internal_r+0x9b4>
81125db8:	dac02317 	ldw	r11,140(sp)
81125dbc:	d8001d85 	stb	zero,118(sp)
81125dc0:	58800204 	addi	r2,r11,8
81125dc4:	5f000017 	ldw	fp,0(r11)
81125dc8:	5a400117 	ldw	r9,4(r11)
81125dcc:	8002a816 	blt	r16,zero,81126870 <___svfiprintf_internal_r+0xf80>
81125dd0:	013fdfc4 	movi	r4,-129
81125dd4:	e246b03a 	or	r3,fp,r9
81125dd8:	d8802315 	stw	r2,140(sp)
81125ddc:	9124703a 	and	r18,r18,r4
81125de0:	18013c26 	beq	r3,zero,811262d4 <___svfiprintf_internal_r+0x9e4>
81125de4:	0015883a 	mov	r10,zero
81125de8:	dc401a04 	addi	r17,sp,104
81125dec:	e006d0fa 	srli	r3,fp,3
81125df0:	4808977a 	slli	r4,r9,29
81125df4:	4812d0fa 	srli	r9,r9,3
81125df8:	e70001cc 	andi	fp,fp,7
81125dfc:	e0800c04 	addi	r2,fp,48
81125e00:	8c7fffc4 	addi	r17,r17,-1
81125e04:	20f8b03a 	or	fp,r4,r3
81125e08:	88800005 	stb	r2,0(r17)
81125e0c:	e246b03a 	or	r3,fp,r9
81125e10:	183ff61e 	bne	r3,zero,81125dec <__reset+0xfb105dec>
81125e14:	90c0004c 	andi	r3,r18,1
81125e18:	1800a526 	beq	r3,zero,811260b0 <___svfiprintf_internal_r+0x7c0>
81125e1c:	10803fcc 	andi	r2,r2,255
81125e20:	1080201c 	xori	r2,r2,128
81125e24:	10bfe004 	addi	r2,r2,-128
81125e28:	00c00c04 	movi	r3,48
81125e2c:	10ffb626 	beq	r2,r3,81125d08 <__reset+0xfb105d08>
81125e30:	88ffffc5 	stb	r3,-1(r17)
81125e34:	d8c01e17 	ldw	r3,120(sp)
81125e38:	88bfffc4 	addi	r2,r17,-1
81125e3c:	1023883a 	mov	r17,r2
81125e40:	1887c83a 	sub	r3,r3,r2
81125e44:	d8c02115 	stw	r3,132(sp)
81125e48:	003fc706 	br	81125d68 <__reset+0xfb105d68>
81125e4c:	dac02317 	ldw	r11,140(sp)
81125e50:	00c00044 	movi	r3,1
81125e54:	d8c02015 	stw	r3,128(sp)
81125e58:	58800017 	ldw	r2,0(r11)
81125e5c:	5ac00104 	addi	r11,r11,4
81125e60:	d8001d85 	stb	zero,118(sp)
81125e64:	d8801005 	stb	r2,64(sp)
81125e68:	dac02315 	stw	r11,140(sp)
81125e6c:	d8c02115 	stw	r3,132(sp)
81125e70:	dc401004 	addi	r17,sp,64
81125e74:	0021883a 	mov	r16,zero
81125e78:	90c0008c 	andi	r3,r18,2
81125e7c:	d8c02215 	stw	r3,136(sp)
81125e80:	18000326 	beq	r3,zero,81125e90 <___svfiprintf_internal_r+0x5a0>
81125e84:	dac02017 	ldw	r11,128(sp)
81125e88:	5ac00084 	addi	r11,r11,2
81125e8c:	dac02015 	stw	r11,128(sp)
81125e90:	90c0210c 	andi	r3,r18,132
81125e94:	d8c02615 	stw	r3,152(sp)
81125e98:	1801131e 	bne	r3,zero,811262e8 <___svfiprintf_internal_r+0x9f8>
81125e9c:	dac02417 	ldw	r11,144(sp)
81125ea0:	d8c02017 	ldw	r3,128(sp)
81125ea4:	58f9c83a 	sub	fp,r11,r3
81125ea8:	07010f0e 	bge	zero,fp,811262e8 <___svfiprintf_internal_r+0x9f8>
81125eac:	02400404 	movi	r9,16
81125eb0:	d8c01c17 	ldw	r3,112(sp)
81125eb4:	d8801b17 	ldw	r2,108(sp)
81125eb8:	4f02d60e 	bge	r9,fp,81126a14 <___svfiprintf_internal_r+0x1124>
81125ebc:	01604534 	movhi	r5,33044
81125ec0:	2957c104 	addi	r5,r5,24324
81125ec4:	d9402815 	stw	r5,160(sp)
81125ec8:	028001c4 	movi	r10,7
81125ecc:	00000306 	br	81125edc <___svfiprintf_internal_r+0x5ec>
81125ed0:	e73ffc04 	addi	fp,fp,-16
81125ed4:	42000204 	addi	r8,r8,8
81125ed8:	4f00150e 	bge	r9,fp,81125f30 <___svfiprintf_internal_r+0x640>
81125edc:	18c00404 	addi	r3,r3,16
81125ee0:	10800044 	addi	r2,r2,1
81125ee4:	45800015 	stw	r22,0(r8)
81125ee8:	42400115 	stw	r9,4(r8)
81125eec:	d8c01c15 	stw	r3,112(sp)
81125ef0:	d8801b15 	stw	r2,108(sp)
81125ef4:	50bff60e 	bge	r10,r2,81125ed0 <__reset+0xfb105ed0>
81125ef8:	d9801a04 	addi	r6,sp,104
81125efc:	b80b883a 	mov	r5,r23
81125f00:	a809883a 	mov	r4,r21
81125f04:	da402c15 	stw	r9,176(sp)
81125f08:	da802d15 	stw	r10,180(sp)
81125f0c:	11257180 	call	81125718 <__ssprint_r>
81125f10:	da402c17 	ldw	r9,176(sp)
81125f14:	da802d17 	ldw	r10,180(sp)
81125f18:	1001851e 	bne	r2,zero,81126530 <___svfiprintf_internal_r+0xc40>
81125f1c:	e73ffc04 	addi	fp,fp,-16
81125f20:	d8c01c17 	ldw	r3,112(sp)
81125f24:	d8801b17 	ldw	r2,108(sp)
81125f28:	d811883a 	mov	r8,sp
81125f2c:	4f3feb16 	blt	r9,fp,81125edc <__reset+0xfb105edc>
81125f30:	dac02817 	ldw	r11,160(sp)
81125f34:	e0c7883a 	add	r3,fp,r3
81125f38:	10800044 	addi	r2,r2,1
81125f3c:	42c00015 	stw	r11,0(r8)
81125f40:	47000115 	stw	fp,4(r8)
81125f44:	d8c01c15 	stw	r3,112(sp)
81125f48:	d8801b15 	stw	r2,108(sp)
81125f4c:	010001c4 	movi	r4,7
81125f50:	2081ee16 	blt	r4,r2,8112670c <___svfiprintf_internal_r+0xe1c>
81125f54:	42000204 	addi	r8,r8,8
81125f58:	0000e506 	br	811262f0 <___svfiprintf_internal_r+0xa00>
81125f5c:	21003fcc 	andi	r4,r4,255
81125f60:	2002dd1e 	bne	r4,zero,81126ad8 <___svfiprintf_internal_r+0x11e8>
81125f64:	00a04534 	movhi	r2,33044
81125f68:	10972e04 	addi	r2,r2,23736
81125f6c:	d8802915 	stw	r2,164(sp)
81125f70:	9080080c 	andi	r2,r18,32
81125f74:	103f461e 	bne	r2,zero,81125c90 <__reset+0xfb105c90>
81125f78:	9080040c 	andi	r2,r18,16
81125f7c:	10022e1e 	bne	r2,zero,81126838 <___svfiprintf_internal_r+0xf48>
81125f80:	9080100c 	andi	r2,r18,64
81125f84:	dac02317 	ldw	r11,140(sp)
81125f88:	10027326 	beq	r2,zero,81126958 <___svfiprintf_internal_r+0x1068>
81125f8c:	5f00000b 	ldhu	fp,0(r11)
81125f90:	5ac00104 	addi	r11,r11,4
81125f94:	0013883a 	mov	r9,zero
81125f98:	dac02315 	stw	r11,140(sp)
81125f9c:	003f4106 	br	81125ca4 <__reset+0xfb105ca4>
81125fa0:	21003fcc 	andi	r4,r4,255
81125fa4:	2002e11e 	bne	r4,zero,81126b2c <___svfiprintf_internal_r+0x123c>
81125fa8:	9080080c 	andi	r2,r18,32
81125fac:	1002011e 	bne	r2,zero,811267b4 <___svfiprintf_internal_r+0xec4>
81125fb0:	9080040c 	andi	r2,r18,16
81125fb4:	10023e1e 	bne	r2,zero,811268b0 <___svfiprintf_internal_r+0xfc0>
81125fb8:	9480100c 	andi	r18,r18,64
81125fbc:	90023c26 	beq	r18,zero,811268b0 <___svfiprintf_internal_r+0xfc0>
81125fc0:	dac02317 	ldw	r11,140(sp)
81125fc4:	58800017 	ldw	r2,0(r11)
81125fc8:	5ac00104 	addi	r11,r11,4
81125fcc:	dac02315 	stw	r11,140(sp)
81125fd0:	dac02517 	ldw	r11,148(sp)
81125fd4:	12c0000d 	sth	r11,0(r2)
81125fd8:	003e6e06 	br	81125994 <__reset+0xfb105994>
81125fdc:	98c00007 	ldb	r3,0(r19)
81125fe0:	1a422926 	beq	r3,r9,81126888 <___svfiprintf_internal_r+0xf98>
81125fe4:	94800414 	ori	r18,r18,16
81125fe8:	003e9206 	br	81125a34 <__reset+0xfb105a34>
81125fec:	94801014 	ori	r18,r18,64
81125ff0:	98c00007 	ldb	r3,0(r19)
81125ff4:	003e8f06 	br	81125a34 <__reset+0xfb105a34>
81125ff8:	21003fcc 	andi	r4,r4,255
81125ffc:	2002c71e 	bne	r4,zero,81126b1c <___svfiprintf_internal_r+0x122c>
81126000:	9080080c 	andi	r2,r18,32
81126004:	10004926 	beq	r2,zero,8112612c <___svfiprintf_internal_r+0x83c>
81126008:	dac02317 	ldw	r11,140(sp)
8112600c:	58800117 	ldw	r2,4(r11)
81126010:	5f000017 	ldw	fp,0(r11)
81126014:	5ac00204 	addi	r11,r11,8
81126018:	dac02315 	stw	r11,140(sp)
8112601c:	1013883a 	mov	r9,r2
81126020:	10004b16 	blt	r2,zero,81126150 <___svfiprintf_internal_r+0x860>
81126024:	da801d83 	ldbu	r10,118(sp)
81126028:	8001cb16 	blt	r16,zero,81126758 <___svfiprintf_internal_r+0xe68>
8112602c:	00ffdfc4 	movi	r3,-129
81126030:	e244b03a 	or	r2,fp,r9
81126034:	90e4703a 	and	r18,r18,r3
81126038:	103f4726 	beq	r2,zero,81125d58 <__reset+0xfb105d58>
8112603c:	48008c26 	beq	r9,zero,81126270 <___svfiprintf_internal_r+0x980>
81126040:	dc802015 	stw	r18,128(sp)
81126044:	dc002115 	stw	r16,132(sp)
81126048:	dc401a04 	addi	r17,sp,104
8112604c:	e021883a 	mov	r16,fp
81126050:	da002215 	stw	r8,136(sp)
81126054:	5039883a 	mov	fp,r10
81126058:	4825883a 	mov	r18,r9
8112605c:	8009883a 	mov	r4,r16
81126060:	900b883a 	mov	r5,r18
81126064:	01800284 	movi	r6,10
81126068:	000f883a 	mov	r7,zero
8112606c:	1129c7c0 	call	81129c7c <__umoddi3>
81126070:	10800c04 	addi	r2,r2,48
81126074:	8c7fffc4 	addi	r17,r17,-1
81126078:	8009883a 	mov	r4,r16
8112607c:	900b883a 	mov	r5,r18
81126080:	88800005 	stb	r2,0(r17)
81126084:	01800284 	movi	r6,10
81126088:	000f883a 	mov	r7,zero
8112608c:	11296fc0 	call	811296fc <__udivdi3>
81126090:	1021883a 	mov	r16,r2
81126094:	10c4b03a 	or	r2,r2,r3
81126098:	1825883a 	mov	r18,r3
8112609c:	103fef1e 	bne	r2,zero,8112605c <__reset+0xfb10605c>
811260a0:	dc802017 	ldw	r18,128(sp)
811260a4:	dc002117 	ldw	r16,132(sp)
811260a8:	da002217 	ldw	r8,136(sp)
811260ac:	e015883a 	mov	r10,fp
811260b0:	d8c01e17 	ldw	r3,120(sp)
811260b4:	1c47c83a 	sub	r3,r3,r17
811260b8:	d8c02115 	stw	r3,132(sp)
811260bc:	003f2a06 	br	81125d68 <__reset+0xfb105d68>
811260c0:	dac02317 	ldw	r11,140(sp)
811260c4:	d8001d85 	stb	zero,118(sp)
811260c8:	5c400017 	ldw	r17,0(r11)
811260cc:	5f000104 	addi	fp,r11,4
811260d0:	88022f26 	beq	r17,zero,81126990 <___svfiprintf_internal_r+0x10a0>
811260d4:	80022516 	blt	r16,zero,8112696c <___svfiprintf_internal_r+0x107c>
811260d8:	800d883a 	mov	r6,r16
811260dc:	000b883a 	mov	r5,zero
811260e0:	8809883a 	mov	r4,r17
811260e4:	da002c15 	stw	r8,176(sp)
811260e8:	1121cbc0 	call	81121cbc <memchr>
811260ec:	da002c17 	ldw	r8,176(sp)
811260f0:	10026426 	beq	r2,zero,81126a84 <___svfiprintf_internal_r+0x1194>
811260f4:	1445c83a 	sub	r2,r2,r17
811260f8:	d8802115 	stw	r2,132(sp)
811260fc:	da801d83 	ldbu	r10,118(sp)
81126100:	df002315 	stw	fp,140(sp)
81126104:	0021883a 	mov	r16,zero
81126108:	003f1706 	br	81125d68 <__reset+0xfb105d68>
8112610c:	94800814 	ori	r18,r18,32
81126110:	98c00007 	ldb	r3,0(r19)
81126114:	003e4706 	br	81125a34 <__reset+0xfb105a34>
81126118:	21003fcc 	andi	r4,r4,255
8112611c:	2002701e 	bne	r4,zero,81126ae0 <___svfiprintf_internal_r+0x11f0>
81126120:	94800414 	ori	r18,r18,16
81126124:	9080080c 	andi	r2,r18,32
81126128:	103fb71e 	bne	r2,zero,81126008 <__reset+0xfb106008>
8112612c:	9080040c 	andi	r2,r18,16
81126130:	1001ab26 	beq	r2,zero,811267e0 <___svfiprintf_internal_r+0xef0>
81126134:	dac02317 	ldw	r11,140(sp)
81126138:	5f000017 	ldw	fp,0(r11)
8112613c:	5ac00104 	addi	r11,r11,4
81126140:	dac02315 	stw	r11,140(sp)
81126144:	e013d7fa 	srai	r9,fp,31
81126148:	4805883a 	mov	r2,r9
8112614c:	103fb50e 	bge	r2,zero,81126024 <__reset+0xfb106024>
81126150:	0739c83a 	sub	fp,zero,fp
81126154:	02800b44 	movi	r10,45
81126158:	e004c03a 	cmpne	r2,fp,zero
8112615c:	0253c83a 	sub	r9,zero,r9
81126160:	da801d85 	stb	r10,118(sp)
81126164:	4893c83a 	sub	r9,r9,r2
81126168:	80023016 	blt	r16,zero,81126a2c <___svfiprintf_internal_r+0x113c>
8112616c:	00bfdfc4 	movi	r2,-129
81126170:	90a4703a 	and	r18,r18,r2
81126174:	483fb21e 	bne	r9,zero,81126040 <__reset+0xfb106040>
81126178:	00003d06 	br	81126270 <___svfiprintf_internal_r+0x980>
8112617c:	9817883a 	mov	r11,r19
81126180:	d8002415 	stw	zero,144(sp)
81126184:	18bff404 	addi	r2,r3,-48
81126188:	0019883a 	mov	r12,zero
8112618c:	58c00007 	ldb	r3,0(r11)
81126190:	630002a4 	muli	r12,r12,10
81126194:	9cc00044 	addi	r19,r19,1
81126198:	9817883a 	mov	r11,r19
8112619c:	1319883a 	add	r12,r2,r12
811261a0:	18bff404 	addi	r2,r3,-48
811261a4:	30bff92e 	bgeu	r6,r2,8112618c <__reset+0xfb10618c>
811261a8:	db002415 	stw	r12,144(sp)
811261ac:	18bff804 	addi	r2,r3,-32
811261b0:	28be232e 	bgeu	r5,r2,81125a40 <__reset+0xfb105a40>
811261b4:	21003fcc 	andi	r4,r4,255
811261b8:	20024b1e 	bne	r4,zero,81126ae8 <___svfiprintf_internal_r+0x11f8>
811261bc:	1800d626 	beq	r3,zero,81126518 <___svfiprintf_internal_r+0xc28>
811261c0:	02c00044 	movi	r11,1
811261c4:	dac02015 	stw	r11,128(sp)
811261c8:	d8c01005 	stb	r3,64(sp)
811261cc:	d8001d85 	stb	zero,118(sp)
811261d0:	dac02115 	stw	r11,132(sp)
811261d4:	dc401004 	addi	r17,sp,64
811261d8:	003f2606 	br	81125e74 <__reset+0xfb105e74>
811261dc:	94802014 	ori	r18,r18,128
811261e0:	98c00007 	ldb	r3,0(r19)
811261e4:	003e1306 	br	81125a34 <__reset+0xfb105a34>
811261e8:	98c00007 	ldb	r3,0(r19)
811261ec:	9ac00044 	addi	r11,r19,1
811261f0:	1a822b26 	beq	r3,r10,81126aa0 <___svfiprintf_internal_r+0x11b0>
811261f4:	18bff404 	addi	r2,r3,-48
811261f8:	0021883a 	mov	r16,zero
811261fc:	30821e36 	bltu	r6,r2,81126a78 <___svfiprintf_internal_r+0x1188>
81126200:	58c00007 	ldb	r3,0(r11)
81126204:	840002a4 	muli	r16,r16,10
81126208:	5cc00044 	addi	r19,r11,1
8112620c:	9817883a 	mov	r11,r19
81126210:	80a1883a 	add	r16,r16,r2
81126214:	18bff404 	addi	r2,r3,-48
81126218:	30bff92e 	bgeu	r6,r2,81126200 <__reset+0xfb106200>
8112621c:	803e060e 	bge	r16,zero,81125a38 <__reset+0xfb105a38>
81126220:	043fffc4 	movi	r16,-1
81126224:	003e0406 	br	81125a38 <__reset+0xfb105a38>
81126228:	21003fcc 	andi	r4,r4,255
8112622c:	2002371e 	bne	r4,zero,81126b0c <___svfiprintf_internal_r+0x121c>
81126230:	94800414 	ori	r18,r18,16
81126234:	9080080c 	andi	r2,r18,32
81126238:	103ebb1e 	bne	r2,zero,81125d28 <__reset+0xfb105d28>
8112623c:	9080040c 	andi	r2,r18,16
81126240:	10013b26 	beq	r2,zero,81126730 <___svfiprintf_internal_r+0xe40>
81126244:	dac02317 	ldw	r11,140(sp)
81126248:	d8001d85 	stb	zero,118(sp)
8112624c:	0013883a 	mov	r9,zero
81126250:	58800104 	addi	r2,r11,4
81126254:	5f000017 	ldw	fp,0(r11)
81126258:	80013d16 	blt	r16,zero,81126750 <___svfiprintf_internal_r+0xe60>
8112625c:	00ffdfc4 	movi	r3,-129
81126260:	d8802315 	stw	r2,140(sp)
81126264:	90e4703a 	and	r18,r18,r3
81126268:	0015883a 	mov	r10,zero
8112626c:	e03eba26 	beq	fp,zero,81125d58 <__reset+0xfb105d58>
81126270:	00800244 	movi	r2,9
81126274:	173f7236 	bltu	r2,fp,81126040 <__reset+0xfb106040>
81126278:	dac02b17 	ldw	r11,172(sp)
8112627c:	e7000c04 	addi	fp,fp,48
81126280:	df0019c5 	stb	fp,103(sp)
81126284:	dac02115 	stw	r11,132(sp)
81126288:	dc4019c4 	addi	r17,sp,103
8112628c:	003eb606 	br	81125d68 <__reset+0xfb105d68>
81126290:	21003fcc 	andi	r4,r4,255
81126294:	20021f1e 	bne	r4,zero,81126b14 <___svfiprintf_internal_r+0x1224>
81126298:	94800414 	ori	r18,r18,16
8112629c:	9080080c 	andi	r2,r18,32
811262a0:	103ec51e 	bne	r2,zero,81125db8 <__reset+0xfb105db8>
811262a4:	9080040c 	andi	r2,r18,16
811262a8:	10016926 	beq	r2,zero,81126850 <___svfiprintf_internal_r+0xf60>
811262ac:	dac02317 	ldw	r11,140(sp)
811262b0:	d8001d85 	stb	zero,118(sp)
811262b4:	0013883a 	mov	r9,zero
811262b8:	58800104 	addi	r2,r11,4
811262bc:	5f000017 	ldw	fp,0(r11)
811262c0:	80016b16 	blt	r16,zero,81126870 <___svfiprintf_internal_r+0xf80>
811262c4:	00ffdfc4 	movi	r3,-129
811262c8:	d8802315 	stw	r2,140(sp)
811262cc:	90e4703a 	and	r18,r18,r3
811262d0:	e03ec41e 	bne	fp,zero,81125de4 <__reset+0xfb105de4>
811262d4:	0015883a 	mov	r10,zero
811262d8:	8001c226 	beq	r16,zero,811269e4 <___svfiprintf_internal_r+0x10f4>
811262dc:	0039883a 	mov	fp,zero
811262e0:	0013883a 	mov	r9,zero
811262e4:	003ec006 	br	81125de8 <__reset+0xfb105de8>
811262e8:	d8c01c17 	ldw	r3,112(sp)
811262ec:	d8801b17 	ldw	r2,108(sp)
811262f0:	d9001d87 	ldb	r4,118(sp)
811262f4:	20000b26 	beq	r4,zero,81126324 <___svfiprintf_internal_r+0xa34>
811262f8:	d9001d84 	addi	r4,sp,118
811262fc:	18c00044 	addi	r3,r3,1
81126300:	10800044 	addi	r2,r2,1
81126304:	41000015 	stw	r4,0(r8)
81126308:	01000044 	movi	r4,1
8112630c:	41000115 	stw	r4,4(r8)
81126310:	d8c01c15 	stw	r3,112(sp)
81126314:	d8801b15 	stw	r2,108(sp)
81126318:	010001c4 	movi	r4,7
8112631c:	2080e116 	blt	r4,r2,811266a4 <___svfiprintf_internal_r+0xdb4>
81126320:	42000204 	addi	r8,r8,8
81126324:	dac02217 	ldw	r11,136(sp)
81126328:	58000b26 	beq	r11,zero,81126358 <___svfiprintf_internal_r+0xa68>
8112632c:	d9001d04 	addi	r4,sp,116
81126330:	18c00084 	addi	r3,r3,2
81126334:	10800044 	addi	r2,r2,1
81126338:	41000015 	stw	r4,0(r8)
8112633c:	01000084 	movi	r4,2
81126340:	41000115 	stw	r4,4(r8)
81126344:	d8c01c15 	stw	r3,112(sp)
81126348:	d8801b15 	stw	r2,108(sp)
8112634c:	010001c4 	movi	r4,7
81126350:	2080dd16 	blt	r4,r2,811266c8 <___svfiprintf_internal_r+0xdd8>
81126354:	42000204 	addi	r8,r8,8
81126358:	dac02617 	ldw	r11,152(sp)
8112635c:	01002004 	movi	r4,128
81126360:	59008426 	beq	r11,r4,81126574 <___svfiprintf_internal_r+0xc84>
81126364:	dac02117 	ldw	r11,132(sp)
81126368:	82e1c83a 	sub	r16,r16,r11
8112636c:	0400270e 	bge	zero,r16,8112640c <___svfiprintf_internal_r+0xb1c>
81126370:	01c00404 	movi	r7,16
81126374:	3c016a0e 	bge	r7,r16,81126920 <___svfiprintf_internal_r+0x1030>
81126378:	01604534 	movhi	r5,33044
8112637c:	2957bd04 	addi	r5,r5,24308
81126380:	d9402215 	stw	r5,136(sp)
81126384:	070001c4 	movi	fp,7
81126388:	00000306 	br	81126398 <___svfiprintf_internal_r+0xaa8>
8112638c:	843ffc04 	addi	r16,r16,-16
81126390:	42000204 	addi	r8,r8,8
81126394:	3c00130e 	bge	r7,r16,811263e4 <___svfiprintf_internal_r+0xaf4>
81126398:	18c00404 	addi	r3,r3,16
8112639c:	10800044 	addi	r2,r2,1
811263a0:	45000015 	stw	r20,0(r8)
811263a4:	41c00115 	stw	r7,4(r8)
811263a8:	d8c01c15 	stw	r3,112(sp)
811263ac:	d8801b15 	stw	r2,108(sp)
811263b0:	e0bff60e 	bge	fp,r2,8112638c <__reset+0xfb10638c>
811263b4:	d9801a04 	addi	r6,sp,104
811263b8:	b80b883a 	mov	r5,r23
811263bc:	a809883a 	mov	r4,r21
811263c0:	d9c02c15 	stw	r7,176(sp)
811263c4:	11257180 	call	81125718 <__ssprint_r>
811263c8:	d9c02c17 	ldw	r7,176(sp)
811263cc:	1000581e 	bne	r2,zero,81126530 <___svfiprintf_internal_r+0xc40>
811263d0:	843ffc04 	addi	r16,r16,-16
811263d4:	d8c01c17 	ldw	r3,112(sp)
811263d8:	d8801b17 	ldw	r2,108(sp)
811263dc:	d811883a 	mov	r8,sp
811263e0:	3c3fed16 	blt	r7,r16,81126398 <__reset+0xfb106398>
811263e4:	dac02217 	ldw	r11,136(sp)
811263e8:	1c07883a 	add	r3,r3,r16
811263ec:	10800044 	addi	r2,r2,1
811263f0:	42c00015 	stw	r11,0(r8)
811263f4:	44000115 	stw	r16,4(r8)
811263f8:	d8c01c15 	stw	r3,112(sp)
811263fc:	d8801b15 	stw	r2,108(sp)
81126400:	010001c4 	movi	r4,7
81126404:	20809e16 	blt	r4,r2,81126680 <___svfiprintf_internal_r+0xd90>
81126408:	42000204 	addi	r8,r8,8
8112640c:	dac02117 	ldw	r11,132(sp)
81126410:	10800044 	addi	r2,r2,1
81126414:	44400015 	stw	r17,0(r8)
81126418:	58c7883a 	add	r3,r11,r3
8112641c:	42c00115 	stw	r11,4(r8)
81126420:	d8c01c15 	stw	r3,112(sp)
81126424:	d8801b15 	stw	r2,108(sp)
81126428:	010001c4 	movi	r4,7
8112642c:	20807f16 	blt	r4,r2,8112662c <___svfiprintf_internal_r+0xd3c>
81126430:	42000204 	addi	r8,r8,8
81126434:	9480010c 	andi	r18,r18,4
81126438:	90002926 	beq	r18,zero,811264e0 <___svfiprintf_internal_r+0xbf0>
8112643c:	dac02417 	ldw	r11,144(sp)
81126440:	d8802017 	ldw	r2,128(sp)
81126444:	58a1c83a 	sub	r16,r11,r2
81126448:	0400250e 	bge	zero,r16,811264e0 <___svfiprintf_internal_r+0xbf0>
8112644c:	04400404 	movi	r17,16
81126450:	d8801b17 	ldw	r2,108(sp)
81126454:	8c017c0e 	bge	r17,r16,81126a48 <___svfiprintf_internal_r+0x1158>
81126458:	01604534 	movhi	r5,33044
8112645c:	2957c104 	addi	r5,r5,24324
81126460:	d9402815 	stw	r5,160(sp)
81126464:	048001c4 	movi	r18,7
81126468:	00000306 	br	81126478 <___svfiprintf_internal_r+0xb88>
8112646c:	843ffc04 	addi	r16,r16,-16
81126470:	42000204 	addi	r8,r8,8
81126474:	8c00110e 	bge	r17,r16,811264bc <___svfiprintf_internal_r+0xbcc>
81126478:	18c00404 	addi	r3,r3,16
8112647c:	10800044 	addi	r2,r2,1
81126480:	45800015 	stw	r22,0(r8)
81126484:	44400115 	stw	r17,4(r8)
81126488:	d8c01c15 	stw	r3,112(sp)
8112648c:	d8801b15 	stw	r2,108(sp)
81126490:	90bff60e 	bge	r18,r2,8112646c <__reset+0xfb10646c>
81126494:	d9801a04 	addi	r6,sp,104
81126498:	b80b883a 	mov	r5,r23
8112649c:	a809883a 	mov	r4,r21
811264a0:	11257180 	call	81125718 <__ssprint_r>
811264a4:	1000221e 	bne	r2,zero,81126530 <___svfiprintf_internal_r+0xc40>
811264a8:	843ffc04 	addi	r16,r16,-16
811264ac:	d8c01c17 	ldw	r3,112(sp)
811264b0:	d8801b17 	ldw	r2,108(sp)
811264b4:	d811883a 	mov	r8,sp
811264b8:	8c3fef16 	blt	r17,r16,81126478 <__reset+0xfb106478>
811264bc:	dac02817 	ldw	r11,160(sp)
811264c0:	1c07883a 	add	r3,r3,r16
811264c4:	10800044 	addi	r2,r2,1
811264c8:	42c00015 	stw	r11,0(r8)
811264cc:	44000115 	stw	r16,4(r8)
811264d0:	d8c01c15 	stw	r3,112(sp)
811264d4:	d8801b15 	stw	r2,108(sp)
811264d8:	010001c4 	movi	r4,7
811264dc:	2080aa16 	blt	r4,r2,81126788 <___svfiprintf_internal_r+0xe98>
811264e0:	d8802417 	ldw	r2,144(sp)
811264e4:	dac02017 	ldw	r11,128(sp)
811264e8:	12c0010e 	bge	r2,r11,811264f0 <___svfiprintf_internal_r+0xc00>
811264ec:	5805883a 	mov	r2,r11
811264f0:	dac02517 	ldw	r11,148(sp)
811264f4:	5897883a 	add	r11,r11,r2
811264f8:	dac02515 	stw	r11,148(sp)
811264fc:	1800531e 	bne	r3,zero,8112664c <___svfiprintf_internal_r+0xd5c>
81126500:	98800007 	ldb	r2,0(r19)
81126504:	d8001b15 	stw	zero,108(sp)
81126508:	d811883a 	mov	r8,sp
8112650c:	103d231e 	bne	r2,zero,8112599c <__reset+0xfb10599c>
81126510:	9823883a 	mov	r17,r19
81126514:	003d3906 	br	811259fc <__reset+0xfb1059fc>
81126518:	d8801c17 	ldw	r2,112(sp)
8112651c:	10000426 	beq	r2,zero,81126530 <___svfiprintf_internal_r+0xc40>
81126520:	d9402717 	ldw	r5,156(sp)
81126524:	d9002a17 	ldw	r4,168(sp)
81126528:	d9801a04 	addi	r6,sp,104
8112652c:	11257180 	call	81125718 <__ssprint_r>
81126530:	dac02717 	ldw	r11,156(sp)
81126534:	d8802517 	ldw	r2,148(sp)
81126538:	58c0030b 	ldhu	r3,12(r11)
8112653c:	18c0100c 	andi	r3,r3,64
81126540:	1801381e 	bne	r3,zero,81126a24 <___svfiprintf_internal_r+0x1134>
81126544:	dfc03717 	ldw	ra,220(sp)
81126548:	df003617 	ldw	fp,216(sp)
8112654c:	ddc03517 	ldw	r23,212(sp)
81126550:	dd803417 	ldw	r22,208(sp)
81126554:	dd403317 	ldw	r21,204(sp)
81126558:	dd003217 	ldw	r20,200(sp)
8112655c:	dcc03117 	ldw	r19,196(sp)
81126560:	dc803017 	ldw	r18,192(sp)
81126564:	dc402f17 	ldw	r17,188(sp)
81126568:	dc002e17 	ldw	r16,184(sp)
8112656c:	dec03804 	addi	sp,sp,224
81126570:	f800283a 	ret
81126574:	dac02417 	ldw	r11,144(sp)
81126578:	d9002017 	ldw	r4,128(sp)
8112657c:	5939c83a 	sub	fp,r11,r4
81126580:	073f780e 	bge	zero,fp,81126364 <__reset+0xfb106364>
81126584:	02400404 	movi	r9,16
81126588:	4f01370e 	bge	r9,fp,81126a68 <___svfiprintf_internal_r+0x1178>
8112658c:	02e04534 	movhi	r11,33044
81126590:	5ad7bd04 	addi	r11,r11,24308
81126594:	dac02215 	stw	r11,136(sp)
81126598:	028001c4 	movi	r10,7
8112659c:	00000306 	br	811265ac <___svfiprintf_internal_r+0xcbc>
811265a0:	e73ffc04 	addi	fp,fp,-16
811265a4:	42000204 	addi	r8,r8,8
811265a8:	4f00150e 	bge	r9,fp,81126600 <___svfiprintf_internal_r+0xd10>
811265ac:	18c00404 	addi	r3,r3,16
811265b0:	10800044 	addi	r2,r2,1
811265b4:	45000015 	stw	r20,0(r8)
811265b8:	42400115 	stw	r9,4(r8)
811265bc:	d8c01c15 	stw	r3,112(sp)
811265c0:	d8801b15 	stw	r2,108(sp)
811265c4:	50bff60e 	bge	r10,r2,811265a0 <__reset+0xfb1065a0>
811265c8:	d9801a04 	addi	r6,sp,104
811265cc:	b80b883a 	mov	r5,r23
811265d0:	a809883a 	mov	r4,r21
811265d4:	da402c15 	stw	r9,176(sp)
811265d8:	da802d15 	stw	r10,180(sp)
811265dc:	11257180 	call	81125718 <__ssprint_r>
811265e0:	da402c17 	ldw	r9,176(sp)
811265e4:	da802d17 	ldw	r10,180(sp)
811265e8:	103fd11e 	bne	r2,zero,81126530 <__reset+0xfb106530>
811265ec:	e73ffc04 	addi	fp,fp,-16
811265f0:	d8c01c17 	ldw	r3,112(sp)
811265f4:	d8801b17 	ldw	r2,108(sp)
811265f8:	d811883a 	mov	r8,sp
811265fc:	4f3feb16 	blt	r9,fp,811265ac <__reset+0xfb1065ac>
81126600:	dac02217 	ldw	r11,136(sp)
81126604:	1f07883a 	add	r3,r3,fp
81126608:	10800044 	addi	r2,r2,1
8112660c:	42c00015 	stw	r11,0(r8)
81126610:	47000115 	stw	fp,4(r8)
81126614:	d8c01c15 	stw	r3,112(sp)
81126618:	d8801b15 	stw	r2,108(sp)
8112661c:	010001c4 	movi	r4,7
81126620:	2080b616 	blt	r4,r2,811268fc <___svfiprintf_internal_r+0x100c>
81126624:	42000204 	addi	r8,r8,8
81126628:	003f4e06 	br	81126364 <__reset+0xfb106364>
8112662c:	d9801a04 	addi	r6,sp,104
81126630:	b80b883a 	mov	r5,r23
81126634:	a809883a 	mov	r4,r21
81126638:	11257180 	call	81125718 <__ssprint_r>
8112663c:	103fbc1e 	bne	r2,zero,81126530 <__reset+0xfb106530>
81126640:	d8c01c17 	ldw	r3,112(sp)
81126644:	d811883a 	mov	r8,sp
81126648:	003f7a06 	br	81126434 <__reset+0xfb106434>
8112664c:	d9801a04 	addi	r6,sp,104
81126650:	b80b883a 	mov	r5,r23
81126654:	a809883a 	mov	r4,r21
81126658:	11257180 	call	81125718 <__ssprint_r>
8112665c:	103fa826 	beq	r2,zero,81126500 <__reset+0xfb106500>
81126660:	003fb306 	br	81126530 <__reset+0xfb106530>
81126664:	d9801a04 	addi	r6,sp,104
81126668:	b80b883a 	mov	r5,r23
8112666c:	a809883a 	mov	r4,r21
81126670:	11257180 	call	81125718 <__ssprint_r>
81126674:	103fae1e 	bne	r2,zero,81126530 <__reset+0xfb106530>
81126678:	d811883a 	mov	r8,sp
8112667c:	003cdc06 	br	811259f0 <__reset+0xfb1059f0>
81126680:	d9801a04 	addi	r6,sp,104
81126684:	b80b883a 	mov	r5,r23
81126688:	a809883a 	mov	r4,r21
8112668c:	11257180 	call	81125718 <__ssprint_r>
81126690:	103fa71e 	bne	r2,zero,81126530 <__reset+0xfb106530>
81126694:	d8c01c17 	ldw	r3,112(sp)
81126698:	d8801b17 	ldw	r2,108(sp)
8112669c:	d811883a 	mov	r8,sp
811266a0:	003f5a06 	br	8112640c <__reset+0xfb10640c>
811266a4:	d9801a04 	addi	r6,sp,104
811266a8:	b80b883a 	mov	r5,r23
811266ac:	a809883a 	mov	r4,r21
811266b0:	11257180 	call	81125718 <__ssprint_r>
811266b4:	103f9e1e 	bne	r2,zero,81126530 <__reset+0xfb106530>
811266b8:	d8c01c17 	ldw	r3,112(sp)
811266bc:	d8801b17 	ldw	r2,108(sp)
811266c0:	d811883a 	mov	r8,sp
811266c4:	003f1706 	br	81126324 <__reset+0xfb106324>
811266c8:	d9801a04 	addi	r6,sp,104
811266cc:	b80b883a 	mov	r5,r23
811266d0:	a809883a 	mov	r4,r21
811266d4:	11257180 	call	81125718 <__ssprint_r>
811266d8:	103f951e 	bne	r2,zero,81126530 <__reset+0xfb106530>
811266dc:	d8c01c17 	ldw	r3,112(sp)
811266e0:	d8801b17 	ldw	r2,108(sp)
811266e4:	d811883a 	mov	r8,sp
811266e8:	003f1b06 	br	81126358 <__reset+0xfb106358>
811266ec:	d8001d85 	stb	zero,118(sp)
811266f0:	80007b16 	blt	r16,zero,811268e0 <___svfiprintf_internal_r+0xff0>
811266f4:	00ffdfc4 	movi	r3,-129
811266f8:	e244b03a 	or	r2,fp,r9
811266fc:	90e4703a 	and	r18,r18,r3
81126700:	103d7026 	beq	r2,zero,81125cc4 <__reset+0xfb105cc4>
81126704:	0015883a 	mov	r10,zero
81126708:	003d7206 	br	81125cd4 <__reset+0xfb105cd4>
8112670c:	d9801a04 	addi	r6,sp,104
81126710:	b80b883a 	mov	r5,r23
81126714:	a809883a 	mov	r4,r21
81126718:	11257180 	call	81125718 <__ssprint_r>
8112671c:	103f841e 	bne	r2,zero,81126530 <__reset+0xfb106530>
81126720:	d8c01c17 	ldw	r3,112(sp)
81126724:	d8801b17 	ldw	r2,108(sp)
81126728:	d811883a 	mov	r8,sp
8112672c:	003ef006 	br	811262f0 <__reset+0xfb1062f0>
81126730:	9080100c 	andi	r2,r18,64
81126734:	d8001d85 	stb	zero,118(sp)
81126738:	dac02317 	ldw	r11,140(sp)
8112673c:	10008126 	beq	r2,zero,81126944 <___svfiprintf_internal_r+0x1054>
81126740:	58800104 	addi	r2,r11,4
81126744:	5f00000b 	ldhu	fp,0(r11)
81126748:	0013883a 	mov	r9,zero
8112674c:	803ec30e 	bge	r16,zero,8112625c <__reset+0xfb10625c>
81126750:	d8802315 	stw	r2,140(sp)
81126754:	0015883a 	mov	r10,zero
81126758:	e244b03a 	or	r2,fp,r9
8112675c:	103e371e 	bne	r2,zero,8112603c <__reset+0xfb10603c>
81126760:	00800044 	movi	r2,1
81126764:	10803fcc 	andi	r2,r2,255
81126768:	00c00044 	movi	r3,1
8112676c:	10c06126 	beq	r2,r3,811268f4 <___svfiprintf_internal_r+0x1004>
81126770:	00c00084 	movi	r3,2
81126774:	10fd5526 	beq	r2,r3,81125ccc <__reset+0xfb105ccc>
81126778:	003ed806 	br	811262dc <__reset+0xfb1062dc>
8112677c:	d8802315 	stw	r2,140(sp)
81126780:	98c00007 	ldb	r3,0(r19)
81126784:	003cab06 	br	81125a34 <__reset+0xfb105a34>
81126788:	d9801a04 	addi	r6,sp,104
8112678c:	b80b883a 	mov	r5,r23
81126790:	a809883a 	mov	r4,r21
81126794:	11257180 	call	81125718 <__ssprint_r>
81126798:	103f651e 	bne	r2,zero,81126530 <__reset+0xfb106530>
8112679c:	d8c01c17 	ldw	r3,112(sp)
811267a0:	003f4f06 	br	811264e0 <__reset+0xfb1064e0>
811267a4:	00a04534 	movhi	r2,33044
811267a8:	10973304 	addi	r2,r2,23756
811267ac:	d8802915 	stw	r2,164(sp)
811267b0:	003d4406 	br	81125cc4 <__reset+0xfb105cc4>
811267b4:	dac02317 	ldw	r11,140(sp)
811267b8:	58800017 	ldw	r2,0(r11)
811267bc:	dac02517 	ldw	r11,148(sp)
811267c0:	5807d7fa 	srai	r3,r11,31
811267c4:	dac02317 	ldw	r11,140(sp)
811267c8:	10c00115 	stw	r3,4(r2)
811267cc:	5ac00104 	addi	r11,r11,4
811267d0:	dac02315 	stw	r11,140(sp)
811267d4:	dac02517 	ldw	r11,148(sp)
811267d8:	12c00015 	stw	r11,0(r2)
811267dc:	003c6d06 	br	81125994 <__reset+0xfb105994>
811267e0:	9080100c 	andi	r2,r18,64
811267e4:	dac02317 	ldw	r11,140(sp)
811267e8:	103e5326 	beq	r2,zero,81126138 <__reset+0xfb106138>
811267ec:	5f00000f 	ldh	fp,0(r11)
811267f0:	5ac00104 	addi	r11,r11,4
811267f4:	dac02315 	stw	r11,140(sp)
811267f8:	e013d7fa 	srai	r9,fp,31
811267fc:	4805883a 	mov	r2,r9
81126800:	003e0706 	br	81126020 <__reset+0xfb106020>
81126804:	00800c04 	movi	r2,48
81126808:	d8801d05 	stb	r2,116(sp)
8112680c:	d8c01d45 	stb	r3,117(sp)
81126810:	d8001d85 	stb	zero,118(sp)
81126814:	90800094 	ori	r2,r18,2
81126818:	80008f16 	blt	r16,zero,81126a58 <___svfiprintf_internal_r+0x1168>
8112681c:	00bfdfc4 	movi	r2,-129
81126820:	90a4703a 	and	r18,r18,r2
81126824:	94800094 	ori	r18,r18,2
81126828:	0015883a 	mov	r10,zero
8112682c:	003d2906 	br	81125cd4 <__reset+0xfb105cd4>
81126830:	98c00007 	ldb	r3,0(r19)
81126834:	003c7f06 	br	81125a34 <__reset+0xfb105a34>
81126838:	dac02317 	ldw	r11,140(sp)
8112683c:	0013883a 	mov	r9,zero
81126840:	5f000017 	ldw	fp,0(r11)
81126844:	5ac00104 	addi	r11,r11,4
81126848:	dac02315 	stw	r11,140(sp)
8112684c:	003d1506 	br	81125ca4 <__reset+0xfb105ca4>
81126850:	9080100c 	andi	r2,r18,64
81126854:	d8001d85 	stb	zero,118(sp)
81126858:	dac02317 	ldw	r11,140(sp)
8112685c:	10003426 	beq	r2,zero,81126930 <___svfiprintf_internal_r+0x1040>
81126860:	58800104 	addi	r2,r11,4
81126864:	5f00000b 	ldhu	fp,0(r11)
81126868:	0013883a 	mov	r9,zero
8112686c:	803e950e 	bge	r16,zero,811262c4 <__reset+0xfb1062c4>
81126870:	e246b03a 	or	r3,fp,r9
81126874:	d8802315 	stw	r2,140(sp)
81126878:	183d5a1e 	bne	r3,zero,81125de4 <__reset+0xfb105de4>
8112687c:	0015883a 	mov	r10,zero
81126880:	0005883a 	mov	r2,zero
81126884:	003fb706 	br	81126764 <__reset+0xfb106764>
81126888:	98c00043 	ldbu	r3,1(r19)
8112688c:	94800814 	ori	r18,r18,32
81126890:	9cc00044 	addi	r19,r19,1
81126894:	18c03fcc 	andi	r3,r3,255
81126898:	18c0201c 	xori	r3,r3,128
8112689c:	18ffe004 	addi	r3,r3,-128
811268a0:	003c6406 	br	81125a34 <__reset+0xfb105a34>
811268a4:	d8c02315 	stw	r3,140(sp)
811268a8:	0015883a 	mov	r10,zero
811268ac:	003faa06 	br	81126758 <__reset+0xfb106758>
811268b0:	dac02317 	ldw	r11,140(sp)
811268b4:	58800017 	ldw	r2,0(r11)
811268b8:	5ac00104 	addi	r11,r11,4
811268bc:	dac02315 	stw	r11,140(sp)
811268c0:	dac02517 	ldw	r11,148(sp)
811268c4:	12c00015 	stw	r11,0(r2)
811268c8:	003c3206 	br	81125994 <__reset+0xfb105994>
811268cc:	01204534 	movhi	r4,33044
811268d0:	21173304 	addi	r4,r4,23756
811268d4:	d9002915 	stw	r4,164(sp)
811268d8:	d8c02315 	stw	r3,140(sp)
811268dc:	1025883a 	mov	r18,r2
811268e0:	e244b03a 	or	r2,fp,r9
811268e4:	103f871e 	bne	r2,zero,81126704 <__reset+0xfb106704>
811268e8:	0015883a 	mov	r10,zero
811268ec:	00800084 	movi	r2,2
811268f0:	003f9c06 	br	81126764 <__reset+0xfb106764>
811268f4:	0039883a 	mov	fp,zero
811268f8:	003e5f06 	br	81126278 <__reset+0xfb106278>
811268fc:	d9801a04 	addi	r6,sp,104
81126900:	b80b883a 	mov	r5,r23
81126904:	a809883a 	mov	r4,r21
81126908:	11257180 	call	81125718 <__ssprint_r>
8112690c:	103f081e 	bne	r2,zero,81126530 <__reset+0xfb106530>
81126910:	d8c01c17 	ldw	r3,112(sp)
81126914:	d8801b17 	ldw	r2,108(sp)
81126918:	d811883a 	mov	r8,sp
8112691c:	003e9106 	br	81126364 <__reset+0xfb106364>
81126920:	01204534 	movhi	r4,33044
81126924:	2117bd04 	addi	r4,r4,24308
81126928:	d9002215 	stw	r4,136(sp)
8112692c:	003ead06 	br	811263e4 <__reset+0xfb1063e4>
81126930:	58800104 	addi	r2,r11,4
81126934:	5f000017 	ldw	fp,0(r11)
81126938:	0013883a 	mov	r9,zero
8112693c:	803e610e 	bge	r16,zero,811262c4 <__reset+0xfb1062c4>
81126940:	003fcb06 	br	81126870 <__reset+0xfb106870>
81126944:	58800104 	addi	r2,r11,4
81126948:	5f000017 	ldw	fp,0(r11)
8112694c:	0013883a 	mov	r9,zero
81126950:	803e420e 	bge	r16,zero,8112625c <__reset+0xfb10625c>
81126954:	003f7e06 	br	81126750 <__reset+0xfb106750>
81126958:	5f000017 	ldw	fp,0(r11)
8112695c:	5ac00104 	addi	r11,r11,4
81126960:	0013883a 	mov	r9,zero
81126964:	dac02315 	stw	r11,140(sp)
81126968:	003cce06 	br	81125ca4 <__reset+0xfb105ca4>
8112696c:	8809883a 	mov	r4,r17
81126970:	da002c15 	stw	r8,176(sp)
81126974:	11187c00 	call	811187c0 <strlen>
81126978:	d8802115 	stw	r2,132(sp)
8112697c:	da801d83 	ldbu	r10,118(sp)
81126980:	df002315 	stw	fp,140(sp)
81126984:	0021883a 	mov	r16,zero
81126988:	da002c17 	ldw	r8,176(sp)
8112698c:	003cf606 	br	81125d68 <__reset+0xfb105d68>
81126990:	00800184 	movi	r2,6
81126994:	1400012e 	bgeu	r2,r16,8112699c <___svfiprintf_internal_r+0x10ac>
81126998:	1021883a 	mov	r16,r2
8112699c:	dc002115 	stw	r16,132(sp)
811269a0:	8005883a 	mov	r2,r16
811269a4:	80003c16 	blt	r16,zero,81126a98 <___svfiprintf_internal_r+0x11a8>
811269a8:	04604534 	movhi	r17,33044
811269ac:	d8802015 	stw	r2,128(sp)
811269b0:	df002315 	stw	fp,140(sp)
811269b4:	8c573804 	addi	r17,r17,23776
811269b8:	003d2e06 	br	81125e74 <__reset+0xfb105e74>
811269bc:	04001004 	movi	r16,64
811269c0:	800b883a 	mov	r5,r16
811269c4:	11174b80 	call	811174b8 <_malloc_r>
811269c8:	dac02717 	ldw	r11,156(sp)
811269cc:	58800015 	stw	r2,0(r11)
811269d0:	58800415 	stw	r2,16(r11)
811269d4:	10004826 	beq	r2,zero,81126af8 <___svfiprintf_internal_r+0x1208>
811269d8:	dac02717 	ldw	r11,156(sp)
811269dc:	5c000515 	stw	r16,20(r11)
811269e0:	003bd906 	br	81125948 <__reset+0xfb105948>
811269e4:	9080004c 	andi	r2,r18,1
811269e8:	0015883a 	mov	r10,zero
811269ec:	10000626 	beq	r2,zero,81126a08 <___svfiprintf_internal_r+0x1118>
811269f0:	dac02b17 	ldw	r11,172(sp)
811269f4:	00800c04 	movi	r2,48
811269f8:	d88019c5 	stb	r2,103(sp)
811269fc:	dac02115 	stw	r11,132(sp)
81126a00:	dc4019c4 	addi	r17,sp,103
81126a04:	003cd806 	br	81125d68 <__reset+0xfb105d68>
81126a08:	d8002115 	stw	zero,132(sp)
81126a0c:	dc401a04 	addi	r17,sp,104
81126a10:	003cd506 	br	81125d68 <__reset+0xfb105d68>
81126a14:	01204534 	movhi	r4,33044
81126a18:	2117c104 	addi	r4,r4,24324
81126a1c:	d9002815 	stw	r4,160(sp)
81126a20:	003d4306 	br	81125f30 <__reset+0xfb105f30>
81126a24:	00bfffc4 	movi	r2,-1
81126a28:	003ec606 	br	81126544 <__reset+0xfb106544>
81126a2c:	00800044 	movi	r2,1
81126a30:	10803fcc 	andi	r2,r2,255
81126a34:	00c00044 	movi	r3,1
81126a38:	10fd8026 	beq	r2,r3,8112603c <__reset+0xfb10603c>
81126a3c:	00c00084 	movi	r3,2
81126a40:	10fca426 	beq	r2,r3,81125cd4 <__reset+0xfb105cd4>
81126a44:	003ce806 	br	81125de8 <__reset+0xfb105de8>
81126a48:	01204534 	movhi	r4,33044
81126a4c:	2117c104 	addi	r4,r4,24324
81126a50:	d9002815 	stw	r4,160(sp)
81126a54:	003e9906 	br	811264bc <__reset+0xfb1064bc>
81126a58:	1025883a 	mov	r18,r2
81126a5c:	0015883a 	mov	r10,zero
81126a60:	00800084 	movi	r2,2
81126a64:	003ff206 	br	81126a30 <__reset+0xfb106a30>
81126a68:	01604534 	movhi	r5,33044
81126a6c:	2957bd04 	addi	r5,r5,24308
81126a70:	d9402215 	stw	r5,136(sp)
81126a74:	003ee206 	br	81126600 <__reset+0xfb106600>
81126a78:	5827883a 	mov	r19,r11
81126a7c:	0021883a 	mov	r16,zero
81126a80:	003bed06 	br	81125a38 <__reset+0xfb105a38>
81126a84:	dc002115 	stw	r16,132(sp)
81126a88:	da801d83 	ldbu	r10,118(sp)
81126a8c:	df002315 	stw	fp,140(sp)
81126a90:	0021883a 	mov	r16,zero
81126a94:	003cb406 	br	81125d68 <__reset+0xfb105d68>
81126a98:	0005883a 	mov	r2,zero
81126a9c:	003fc206 	br	811269a8 <__reset+0xfb1069a8>
81126aa0:	d8802317 	ldw	r2,140(sp)
81126aa4:	98c00043 	ldbu	r3,1(r19)
81126aa8:	5827883a 	mov	r19,r11
81126aac:	14000017 	ldw	r16,0(r2)
81126ab0:	10800104 	addi	r2,r2,4
81126ab4:	d8802315 	stw	r2,140(sp)
81126ab8:	803f760e 	bge	r16,zero,81126894 <__reset+0xfb106894>
81126abc:	18c03fcc 	andi	r3,r3,255
81126ac0:	18c0201c 	xori	r3,r3,128
81126ac4:	043fffc4 	movi	r16,-1
81126ac8:	18ffe004 	addi	r3,r3,-128
81126acc:	003bd906 	br	81125a34 <__reset+0xfb105a34>
81126ad0:	d9c01d85 	stb	r7,118(sp)
81126ad4:	003cb606 	br	81125db0 <__reset+0xfb105db0>
81126ad8:	d9c01d85 	stb	r7,118(sp)
81126adc:	003d2106 	br	81125f64 <__reset+0xfb105f64>
81126ae0:	d9c01d85 	stb	r7,118(sp)
81126ae4:	003d8e06 	br	81126120 <__reset+0xfb106120>
81126ae8:	d9c01d85 	stb	r7,118(sp)
81126aec:	003db306 	br	811261bc <__reset+0xfb1061bc>
81126af0:	d9c01d85 	stb	r7,118(sp)
81126af4:	003c8a06 	br	81125d20 <__reset+0xfb105d20>
81126af8:	dac02a17 	ldw	r11,168(sp)
81126afc:	00800304 	movi	r2,12
81126b00:	58800015 	stw	r2,0(r11)
81126b04:	00bfffc4 	movi	r2,-1
81126b08:	003e8e06 	br	81126544 <__reset+0xfb106544>
81126b0c:	d9c01d85 	stb	r7,118(sp)
81126b10:	003dc706 	br	81126230 <__reset+0xfb106230>
81126b14:	d9c01d85 	stb	r7,118(sp)
81126b18:	003ddf06 	br	81126298 <__reset+0xfb106298>
81126b1c:	d9c01d85 	stb	r7,118(sp)
81126b20:	003d3706 	br	81126000 <__reset+0xfb106000>
81126b24:	d9c01d85 	stb	r7,118(sp)
81126b28:	003c5406 	br	81125c7c <__reset+0xfb105c7c>
81126b2c:	d9c01d85 	stb	r7,118(sp)
81126b30:	003d1d06 	br	81125fa8 <__reset+0xfb105fa8>

81126b34 <__submore>:
81126b34:	defffa04 	addi	sp,sp,-24
81126b38:	de00012e 	bgeu	sp,et,81126b40 <__submore+0xc>
81126b3c:	003b68fa 	trap	3
81126b40:	dc000015 	stw	r16,0(sp)
81126b44:	2821883a 	mov	r16,r5
81126b48:	29400c17 	ldw	r5,48(r5)
81126b4c:	dfc00515 	stw	ra,20(sp)
81126b50:	dd000415 	stw	r20,16(sp)
81126b54:	dcc00315 	stw	r19,12(sp)
81126b58:	dc800215 	stw	r18,8(sp)
81126b5c:	dc400115 	stw	r17,4(sp)
81126b60:	80801004 	addi	r2,r16,64
81126b64:	28801726 	beq	r5,r2,81126bc4 <__submore+0x90>
81126b68:	84400d17 	ldw	r17,52(r16)
81126b6c:	8c67883a 	add	r19,r17,r17
81126b70:	980d883a 	mov	r6,r19
81126b74:	1122fc00 	call	81122fc0 <_realloc_r>
81126b78:	1025883a 	mov	r18,r2
81126b7c:	10002226 	beq	r2,zero,81126c08 <__submore+0xd4>
81126b80:	1469883a 	add	r20,r2,r17
81126b84:	880d883a 	mov	r6,r17
81126b88:	100b883a 	mov	r5,r2
81126b8c:	a009883a 	mov	r4,r20
81126b90:	1117ccc0 	call	81117ccc <memcpy>
81126b94:	0005883a 	mov	r2,zero
81126b98:	85000015 	stw	r20,0(r16)
81126b9c:	84800c15 	stw	r18,48(r16)
81126ba0:	84c00d15 	stw	r19,52(r16)
81126ba4:	dfc00517 	ldw	ra,20(sp)
81126ba8:	dd000417 	ldw	r20,16(sp)
81126bac:	dcc00317 	ldw	r19,12(sp)
81126bb0:	dc800217 	ldw	r18,8(sp)
81126bb4:	dc400117 	ldw	r17,4(sp)
81126bb8:	dc000017 	ldw	r16,0(sp)
81126bbc:	dec00604 	addi	sp,sp,24
81126bc0:	f800283a 	ret
81126bc4:	04410004 	movi	r17,1024
81126bc8:	880b883a 	mov	r5,r17
81126bcc:	11174b80 	call	811174b8 <_malloc_r>
81126bd0:	1007883a 	mov	r3,r2
81126bd4:	10000c26 	beq	r2,zero,81126c08 <__submore+0xd4>
81126bd8:	80801083 	ldbu	r2,66(r16)
81126bdc:	80c00c15 	stw	r3,48(r16)
81126be0:	84400d15 	stw	r17,52(r16)
81126be4:	1880ffc5 	stb	r2,1023(r3)
81126be8:	81401043 	ldbu	r5,65(r16)
81126bec:	1900ff44 	addi	r4,r3,1021
81126bf0:	0005883a 	mov	r2,zero
81126bf4:	1940ff85 	stb	r5,1022(r3)
81126bf8:	81401003 	ldbu	r5,64(r16)
81126bfc:	1940ff45 	stb	r5,1021(r3)
81126c00:	81000015 	stw	r4,0(r16)
81126c04:	003fe706 	br	81126ba4 <__reset+0xfb106ba4>
81126c08:	00bfffc4 	movi	r2,-1
81126c0c:	003fe506 	br	81126ba4 <__reset+0xfb106ba4>

81126c10 <_ungetc_r>:
81126c10:	00bfffc4 	movi	r2,-1
81126c14:	28806326 	beq	r5,r2,81126da4 <_ungetc_r+0x194>
81126c18:	defffb04 	addi	sp,sp,-20
81126c1c:	de00012e 	bgeu	sp,et,81126c24 <_ungetc_r+0x14>
81126c20:	003b68fa 	trap	3
81126c24:	dcc00315 	stw	r19,12(sp)
81126c28:	dc400115 	stw	r17,4(sp)
81126c2c:	dc000015 	stw	r16,0(sp)
81126c30:	dfc00415 	stw	ra,16(sp)
81126c34:	dc800215 	stw	r18,8(sp)
81126c38:	2023883a 	mov	r17,r4
81126c3c:	3021883a 	mov	r16,r6
81126c40:	2827883a 	mov	r19,r5
81126c44:	20000226 	beq	r4,zero,81126c50 <_ungetc_r+0x40>
81126c48:	20800e17 	ldw	r2,56(r4)
81126c4c:	10002e26 	beq	r2,zero,81126d08 <_ungetc_r+0xf8>
81126c50:	80c0030b 	ldhu	r3,12(r16)
81126c54:	1888000c 	andi	r2,r3,8192
81126c58:	1000051e 	bne	r2,zero,81126c70 <_ungetc_r+0x60>
81126c5c:	81001917 	ldw	r4,100(r16)
81126c60:	00b7ffc4 	movi	r2,-8193
81126c64:	18c80014 	ori	r3,r3,8192
81126c68:	2084703a 	and	r2,r4,r2
81126c6c:	80801915 	stw	r2,100(r16)
81126c70:	00bff7c4 	movi	r2,-33
81126c74:	1884703a 	and	r2,r3,r2
81126c78:	8080030d 	sth	r2,12(r16)
81126c7c:	1900010c 	andi	r4,r3,4
81126c80:	2000061e 	bne	r4,zero,81126c9c <_ungetc_r+0x8c>
81126c84:	1900040c 	andi	r4,r3,16
81126c88:	20001d26 	beq	r4,zero,81126d00 <_ungetc_r+0xf0>
81126c8c:	18c0020c 	andi	r3,r3,8
81126c90:	1800331e 	bne	r3,zero,81126d60 <_ungetc_r+0x150>
81126c94:	10800114 	ori	r2,r2,4
81126c98:	8080030d 	sth	r2,12(r16)
81126c9c:	80800c17 	ldw	r2,48(r16)
81126ca0:	9c803fcc 	andi	r18,r19,255
81126ca4:	10001a26 	beq	r2,zero,81126d10 <_ungetc_r+0x100>
81126ca8:	80c00117 	ldw	r3,4(r16)
81126cac:	80800d17 	ldw	r2,52(r16)
81126cb0:	18800f0e 	bge	r3,r2,81126cf0 <_ungetc_r+0xe0>
81126cb4:	80c00017 	ldw	r3,0(r16)
81126cb8:	9005883a 	mov	r2,r18
81126cbc:	193fffc4 	addi	r4,r3,-1
81126cc0:	81000015 	stw	r4,0(r16)
81126cc4:	1cffffc5 	stb	r19,-1(r3)
81126cc8:	80c00117 	ldw	r3,4(r16)
81126ccc:	18c00044 	addi	r3,r3,1
81126cd0:	80c00115 	stw	r3,4(r16)
81126cd4:	dfc00417 	ldw	ra,16(sp)
81126cd8:	dcc00317 	ldw	r19,12(sp)
81126cdc:	dc800217 	ldw	r18,8(sp)
81126ce0:	dc400117 	ldw	r17,4(sp)
81126ce4:	dc000017 	ldw	r16,0(sp)
81126ce8:	dec00504 	addi	sp,sp,20
81126cec:	f800283a 	ret
81126cf0:	800b883a 	mov	r5,r16
81126cf4:	8809883a 	mov	r4,r17
81126cf8:	1126b340 	call	81126b34 <__submore>
81126cfc:	103fed26 	beq	r2,zero,81126cb4 <__reset+0xfb106cb4>
81126d00:	00bfffc4 	movi	r2,-1
81126d04:	003ff306 	br	81126cd4 <__reset+0xfb106cd4>
81126d08:	1120a940 	call	81120a94 <__sinit>
81126d0c:	003fd006 	br	81126c50 <__reset+0xfb106c50>
81126d10:	80c00417 	ldw	r3,16(r16)
81126d14:	80800017 	ldw	r2,0(r16)
81126d18:	18000326 	beq	r3,zero,81126d28 <_ungetc_r+0x118>
81126d1c:	1880022e 	bgeu	r3,r2,81126d28 <_ungetc_r+0x118>
81126d20:	10ffffc3 	ldbu	r3,-1(r2)
81126d24:	90c01826 	beq	r18,r3,81126d88 <_ungetc_r+0x178>
81126d28:	81400117 	ldw	r5,4(r16)
81126d2c:	80800e15 	stw	r2,56(r16)
81126d30:	008000c4 	movi	r2,3
81126d34:	81001004 	addi	r4,r16,64
81126d38:	80c01084 	addi	r3,r16,66
81126d3c:	80800d15 	stw	r2,52(r16)
81126d40:	00800044 	movi	r2,1
81126d44:	80800115 	stw	r2,4(r16)
81126d48:	81400f15 	stw	r5,60(r16)
81126d4c:	81000c15 	stw	r4,48(r16)
81126d50:	84c01085 	stb	r19,66(r16)
81126d54:	80c00015 	stw	r3,0(r16)
81126d58:	9005883a 	mov	r2,r18
81126d5c:	003fdd06 	br	81126cd4 <__reset+0xfb106cd4>
81126d60:	800b883a 	mov	r5,r16
81126d64:	8809883a 	mov	r4,r17
81126d68:	11206980 	call	81120698 <_fflush_r>
81126d6c:	103fe41e 	bne	r2,zero,81126d00 <__reset+0xfb106d00>
81126d70:	8080030b 	ldhu	r2,12(r16)
81126d74:	00fffdc4 	movi	r3,-9
81126d78:	80000215 	stw	zero,8(r16)
81126d7c:	1884703a 	and	r2,r3,r2
81126d80:	80000615 	stw	zero,24(r16)
81126d84:	003fc306 	br	81126c94 <__reset+0xfb106c94>
81126d88:	80c00117 	ldw	r3,4(r16)
81126d8c:	10bfffc4 	addi	r2,r2,-1
81126d90:	80800015 	stw	r2,0(r16)
81126d94:	18800044 	addi	r2,r3,1
81126d98:	80800115 	stw	r2,4(r16)
81126d9c:	9005883a 	mov	r2,r18
81126da0:	003fcc06 	br	81126cd4 <__reset+0xfb106cd4>
81126da4:	00bfffc4 	movi	r2,-1
81126da8:	f800283a 	ret

81126dac <ungetc>:
81126dac:	00a04574 	movhi	r2,33045
81126db0:	10a10204 	addi	r2,r2,-31736
81126db4:	280d883a 	mov	r6,r5
81126db8:	200b883a 	mov	r5,r4
81126dbc:	11000017 	ldw	r4,0(r2)
81126dc0:	1126c101 	jmpi	81126c10 <_ungetc_r>

81126dc4 <__sprint_r.part.0>:
81126dc4:	defff604 	addi	sp,sp,-40
81126dc8:	de00012e 	bgeu	sp,et,81126dd0 <__sprint_r.part.0+0xc>
81126dcc:	003b68fa 	trap	3
81126dd0:	28801917 	ldw	r2,100(r5)
81126dd4:	dd400515 	stw	r21,20(sp)
81126dd8:	dfc00915 	stw	ra,36(sp)
81126ddc:	df000815 	stw	fp,32(sp)
81126de0:	ddc00715 	stw	r23,28(sp)
81126de4:	dd800615 	stw	r22,24(sp)
81126de8:	dd000415 	stw	r20,16(sp)
81126dec:	dcc00315 	stw	r19,12(sp)
81126df0:	dc800215 	stw	r18,8(sp)
81126df4:	dc400115 	stw	r17,4(sp)
81126df8:	dc000015 	stw	r16,0(sp)
81126dfc:	1088000c 	andi	r2,r2,8192
81126e00:	302b883a 	mov	r21,r6
81126e04:	10002e26 	beq	r2,zero,81126ec0 <__sprint_r.part.0+0xfc>
81126e08:	30800217 	ldw	r2,8(r6)
81126e0c:	35800017 	ldw	r22,0(r6)
81126e10:	10002926 	beq	r2,zero,81126eb8 <__sprint_r.part.0+0xf4>
81126e14:	2827883a 	mov	r19,r5
81126e18:	2029883a 	mov	r20,r4
81126e1c:	b5c00104 	addi	r23,r22,4
81126e20:	04bfffc4 	movi	r18,-1
81126e24:	bc400017 	ldw	r17,0(r23)
81126e28:	b4000017 	ldw	r16,0(r22)
81126e2c:	0039883a 	mov	fp,zero
81126e30:	8822d0ba 	srli	r17,r17,2
81126e34:	8800031e 	bne	r17,zero,81126e44 <__sprint_r.part.0+0x80>
81126e38:	00001806 	br	81126e9c <__sprint_r.part.0+0xd8>
81126e3c:	84000104 	addi	r16,r16,4
81126e40:	8f001526 	beq	r17,fp,81126e98 <__sprint_r.part.0+0xd4>
81126e44:	81400017 	ldw	r5,0(r16)
81126e48:	980d883a 	mov	r6,r19
81126e4c:	a009883a 	mov	r4,r20
81126e50:	11287680 	call	81128768 <_fputwc_r>
81126e54:	e7000044 	addi	fp,fp,1
81126e58:	14bff81e 	bne	r2,r18,81126e3c <__reset+0xfb106e3c>
81126e5c:	9005883a 	mov	r2,r18
81126e60:	a8000215 	stw	zero,8(r21)
81126e64:	a8000115 	stw	zero,4(r21)
81126e68:	dfc00917 	ldw	ra,36(sp)
81126e6c:	df000817 	ldw	fp,32(sp)
81126e70:	ddc00717 	ldw	r23,28(sp)
81126e74:	dd800617 	ldw	r22,24(sp)
81126e78:	dd400517 	ldw	r21,20(sp)
81126e7c:	dd000417 	ldw	r20,16(sp)
81126e80:	dcc00317 	ldw	r19,12(sp)
81126e84:	dc800217 	ldw	r18,8(sp)
81126e88:	dc400117 	ldw	r17,4(sp)
81126e8c:	dc000017 	ldw	r16,0(sp)
81126e90:	dec00a04 	addi	sp,sp,40
81126e94:	f800283a 	ret
81126e98:	a8800217 	ldw	r2,8(r21)
81126e9c:	8c63883a 	add	r17,r17,r17
81126ea0:	8c63883a 	add	r17,r17,r17
81126ea4:	1445c83a 	sub	r2,r2,r17
81126ea8:	a8800215 	stw	r2,8(r21)
81126eac:	b5800204 	addi	r22,r22,8
81126eb0:	bdc00204 	addi	r23,r23,8
81126eb4:	103fdb1e 	bne	r2,zero,81126e24 <__reset+0xfb106e24>
81126eb8:	0005883a 	mov	r2,zero
81126ebc:	003fe806 	br	81126e60 <__reset+0xfb106e60>
81126ec0:	11212440 	call	81121244 <__sfvwrite_r>
81126ec4:	003fe606 	br	81126e60 <__reset+0xfb106e60>

81126ec8 <__sprint_r>:
81126ec8:	30c00217 	ldw	r3,8(r6)
81126ecc:	18000126 	beq	r3,zero,81126ed4 <__sprint_r+0xc>
81126ed0:	1126dc41 	jmpi	81126dc4 <__sprint_r.part.0>
81126ed4:	30000115 	stw	zero,4(r6)
81126ed8:	0005883a 	mov	r2,zero
81126edc:	f800283a 	ret

81126ee0 <___vfiprintf_internal_r>:
81126ee0:	deffc904 	addi	sp,sp,-220
81126ee4:	de00012e 	bgeu	sp,et,81126eec <___vfiprintf_internal_r+0xc>
81126ee8:	003b68fa 	trap	3
81126eec:	df003515 	stw	fp,212(sp)
81126ef0:	dd003115 	stw	r20,196(sp)
81126ef4:	dfc03615 	stw	ra,216(sp)
81126ef8:	ddc03415 	stw	r23,208(sp)
81126efc:	dd803315 	stw	r22,204(sp)
81126f00:	dd403215 	stw	r21,200(sp)
81126f04:	dcc03015 	stw	r19,192(sp)
81126f08:	dc802f15 	stw	r18,188(sp)
81126f0c:	dc402e15 	stw	r17,184(sp)
81126f10:	dc002d15 	stw	r16,180(sp)
81126f14:	d9002015 	stw	r4,128(sp)
81126f18:	d9c02215 	stw	r7,136(sp)
81126f1c:	2829883a 	mov	r20,r5
81126f20:	3039883a 	mov	fp,r6
81126f24:	20000226 	beq	r4,zero,81126f30 <___vfiprintf_internal_r+0x50>
81126f28:	20800e17 	ldw	r2,56(r4)
81126f2c:	1000cf26 	beq	r2,zero,8112726c <___vfiprintf_internal_r+0x38c>
81126f30:	a080030b 	ldhu	r2,12(r20)
81126f34:	10c8000c 	andi	r3,r2,8192
81126f38:	1800061e 	bne	r3,zero,81126f54 <___vfiprintf_internal_r+0x74>
81126f3c:	a1001917 	ldw	r4,100(r20)
81126f40:	00f7ffc4 	movi	r3,-8193
81126f44:	10880014 	ori	r2,r2,8192
81126f48:	20c6703a 	and	r3,r4,r3
81126f4c:	a080030d 	sth	r2,12(r20)
81126f50:	a0c01915 	stw	r3,100(r20)
81126f54:	10c0020c 	andi	r3,r2,8
81126f58:	1800a926 	beq	r3,zero,81127200 <___vfiprintf_internal_r+0x320>
81126f5c:	a0c00417 	ldw	r3,16(r20)
81126f60:	1800a726 	beq	r3,zero,81127200 <___vfiprintf_internal_r+0x320>
81126f64:	1080068c 	andi	r2,r2,26
81126f68:	00c00284 	movi	r3,10
81126f6c:	10c0ac26 	beq	r2,r3,81127220 <___vfiprintf_internal_r+0x340>
81126f70:	da801a04 	addi	r10,sp,104
81126f74:	da801e15 	stw	r10,120(sp)
81126f78:	d8801e17 	ldw	r2,120(sp)
81126f7c:	da8019c4 	addi	r10,sp,103
81126f80:	05a04534 	movhi	r22,33044
81126f84:	05e04534 	movhi	r23,33044
81126f88:	da801f15 	stw	r10,124(sp)
81126f8c:	1295c83a 	sub	r10,r2,r10
81126f90:	b597c904 	addi	r22,r22,24356
81126f94:	bdd7c504 	addi	r23,r23,24340
81126f98:	dec01a15 	stw	sp,104(sp)
81126f9c:	d8001c15 	stw	zero,112(sp)
81126fa0:	d8001b15 	stw	zero,108(sp)
81126fa4:	d8002615 	stw	zero,152(sp)
81126fa8:	d8002315 	stw	zero,140(sp)
81126fac:	da802715 	stw	r10,156(sp)
81126fb0:	d811883a 	mov	r8,sp
81126fb4:	dd002115 	stw	r20,132(sp)
81126fb8:	e021883a 	mov	r16,fp
81126fbc:	80800007 	ldb	r2,0(r16)
81126fc0:	1003ea26 	beq	r2,zero,81127f6c <___vfiprintf_internal_r+0x108c>
81126fc4:	00c00944 	movi	r3,37
81126fc8:	8025883a 	mov	r18,r16
81126fcc:	10c0021e 	bne	r2,r3,81126fd8 <___vfiprintf_internal_r+0xf8>
81126fd0:	00001606 	br	8112702c <___vfiprintf_internal_r+0x14c>
81126fd4:	10c00326 	beq	r2,r3,81126fe4 <___vfiprintf_internal_r+0x104>
81126fd8:	94800044 	addi	r18,r18,1
81126fdc:	90800007 	ldb	r2,0(r18)
81126fe0:	103ffc1e 	bne	r2,zero,81126fd4 <__reset+0xfb106fd4>
81126fe4:	9423c83a 	sub	r17,r18,r16
81126fe8:	88001026 	beq	r17,zero,8112702c <___vfiprintf_internal_r+0x14c>
81126fec:	d8c01c17 	ldw	r3,112(sp)
81126ff0:	d8801b17 	ldw	r2,108(sp)
81126ff4:	44000015 	stw	r16,0(r8)
81126ff8:	88c7883a 	add	r3,r17,r3
81126ffc:	10800044 	addi	r2,r2,1
81127000:	44400115 	stw	r17,4(r8)
81127004:	d8c01c15 	stw	r3,112(sp)
81127008:	d8801b15 	stw	r2,108(sp)
8112700c:	010001c4 	movi	r4,7
81127010:	2080760e 	bge	r4,r2,811271ec <___vfiprintf_internal_r+0x30c>
81127014:	1803821e 	bne	r3,zero,81127e20 <___vfiprintf_internal_r+0xf40>
81127018:	da802317 	ldw	r10,140(sp)
8112701c:	d8001b15 	stw	zero,108(sp)
81127020:	d811883a 	mov	r8,sp
81127024:	5455883a 	add	r10,r10,r17
81127028:	da802315 	stw	r10,140(sp)
8112702c:	90800007 	ldb	r2,0(r18)
81127030:	10044626 	beq	r2,zero,8112814c <___vfiprintf_internal_r+0x126c>
81127034:	90c00047 	ldb	r3,1(r18)
81127038:	94000044 	addi	r16,r18,1
8112703c:	d8001d85 	stb	zero,118(sp)
81127040:	0009883a 	mov	r4,zero
81127044:	000f883a 	mov	r7,zero
81127048:	027fffc4 	movi	r9,-1
8112704c:	0023883a 	mov	r17,zero
81127050:	0029883a 	mov	r20,zero
81127054:	01401604 	movi	r5,88
81127058:	01800244 	movi	r6,9
8112705c:	03400a84 	movi	r13,42
81127060:	03001b04 	movi	r12,108
81127064:	84000044 	addi	r16,r16,1
81127068:	18bff804 	addi	r2,r3,-32
8112706c:	28827336 	bltu	r5,r2,81127a3c <___vfiprintf_internal_r+0xb5c>
81127070:	100490ba 	slli	r2,r2,2
81127074:	02a044b4 	movhi	r10,33042
81127078:	529c2204 	addi	r10,r10,28808
8112707c:	1285883a 	add	r2,r2,r10
81127080:	10800017 	ldw	r2,0(r2)
81127084:	1000683a 	jmp	r2
81127088:	81127770 	cmpltui	r4,r16,18909
8112708c:	81127a3c 	xorhi	r4,r16,18920
81127090:	81127a3c 	xorhi	r4,r16,18920
81127094:	81127790 	cmplti	r4,r16,18910
81127098:	81127a3c 	xorhi	r4,r16,18920
8112709c:	81127a3c 	xorhi	r4,r16,18920
811270a0:	81127a3c 	xorhi	r4,r16,18920
811270a4:	81127a3c 	xorhi	r4,r16,18920
811270a8:	81127a3c 	xorhi	r4,r16,18920
811270ac:	81127a3c 	xorhi	r4,r16,18920
811270b0:	81127978 	rdprs	r4,r16,18917
811270b4:	81127994 	ori	r4,r16,18918
811270b8:	81127a3c 	xorhi	r4,r16,18920
811270bc:	8112727c 	xorhi	r4,r16,18889
811270c0:	811279a4 	muli	r4,r16,18918
811270c4:	81127a3c 	xorhi	r4,r16,18920
811270c8:	8112779c 	xori	r4,r16,18910
811270cc:	811277a8 	cmpgeui	r4,r16,18910
811270d0:	811277a8 	cmpgeui	r4,r16,18910
811270d4:	811277a8 	cmpgeui	r4,r16,18910
811270d8:	811277a8 	cmpgeui	r4,r16,18910
811270dc:	811277a8 	cmpgeui	r4,r16,18910
811270e0:	811277a8 	cmpgeui	r4,r16,18910
811270e4:	811277a8 	cmpgeui	r4,r16,18910
811270e8:	811277a8 	cmpgeui	r4,r16,18910
811270ec:	811277a8 	cmpgeui	r4,r16,18910
811270f0:	81127a3c 	xorhi	r4,r16,18920
811270f4:	81127a3c 	xorhi	r4,r16,18920
811270f8:	81127a3c 	xorhi	r4,r16,18920
811270fc:	81127a3c 	xorhi	r4,r16,18920
81127100:	81127a3c 	xorhi	r4,r16,18920
81127104:	81127a3c 	xorhi	r4,r16,18920
81127108:	81127a3c 	xorhi	r4,r16,18920
8112710c:	81127a3c 	xorhi	r4,r16,18920
81127110:	81127a3c 	xorhi	r4,r16,18920
81127114:	81127a3c 	xorhi	r4,r16,18920
81127118:	811277d4 	ori	r4,r16,18911
8112711c:	81127a3c 	xorhi	r4,r16,18920
81127120:	81127a3c 	xorhi	r4,r16,18920
81127124:	81127a3c 	xorhi	r4,r16,18920
81127128:	81127a3c 	xorhi	r4,r16,18920
8112712c:	81127a3c 	xorhi	r4,r16,18920
81127130:	81127a3c 	xorhi	r4,r16,18920
81127134:	81127a3c 	xorhi	r4,r16,18920
81127138:	81127a3c 	xorhi	r4,r16,18920
8112713c:	81127a3c 	xorhi	r4,r16,18920
81127140:	81127a3c 	xorhi	r4,r16,18920
81127144:	8112780c 	andi	r4,r16,18912
81127148:	81127a3c 	xorhi	r4,r16,18920
8112714c:	81127a3c 	xorhi	r4,r16,18920
81127150:	81127a3c 	xorhi	r4,r16,18920
81127154:	81127a3c 	xorhi	r4,r16,18920
81127158:	81127a3c 	xorhi	r4,r16,18920
8112715c:	81127864 	muli	r4,r16,18913
81127160:	81127a3c 	xorhi	r4,r16,18920
81127164:	81127a3c 	xorhi	r4,r16,18920
81127168:	811278d4 	ori	r4,r16,18915
8112716c:	81127a3c 	xorhi	r4,r16,18920
81127170:	81127a3c 	xorhi	r4,r16,18920
81127174:	81127a3c 	xorhi	r4,r16,18920
81127178:	81127a3c 	xorhi	r4,r16,18920
8112717c:	81127a3c 	xorhi	r4,r16,18920
81127180:	81127a3c 	xorhi	r4,r16,18920
81127184:	81127a3c 	xorhi	r4,r16,18920
81127188:	81127a3c 	xorhi	r4,r16,18920
8112718c:	81127a3c 	xorhi	r4,r16,18920
81127190:	81127a3c 	xorhi	r4,r16,18920
81127194:	81127680 	call	88112768 <__reset+0x20f2768>
81127198:	811276ac 	andhi	r4,r16,18906
8112719c:	81127a3c 	xorhi	r4,r16,18920
811271a0:	81127a3c 	xorhi	r4,r16,18920
811271a4:	81127a3c 	xorhi	r4,r16,18920
811271a8:	811279e4 	muli	r4,r16,18919
811271ac:	811276ac 	andhi	r4,r16,18906
811271b0:	81127a3c 	xorhi	r4,r16,18920
811271b4:	81127a3c 	xorhi	r4,r16,18920
811271b8:	81127540 	call	88112754 <__reset+0x20f2754>
811271bc:	81127a3c 	xorhi	r4,r16,18920
811271c0:	81127550 	cmplti	r4,r16,18901
811271c4:	8112758c 	andi	r4,r16,18902
811271c8:	81127288 	cmpgei	r4,r16,18890
811271cc:	81127534 	orhi	r4,r16,18900
811271d0:	81127a3c 	xorhi	r4,r16,18920
811271d4:	81127910 	cmplti	r4,r16,18916
811271d8:	81127a3c 	xorhi	r4,r16,18920
811271dc:	81127968 	cmpgeui	r4,r16,18917
811271e0:	81127a3c 	xorhi	r4,r16,18920
811271e4:	81127a3c 	xorhi	r4,r16,18920
811271e8:	8112762c 	andhi	r4,r16,18904
811271ec:	42000204 	addi	r8,r8,8
811271f0:	da802317 	ldw	r10,140(sp)
811271f4:	5455883a 	add	r10,r10,r17
811271f8:	da802315 	stw	r10,140(sp)
811271fc:	003f8b06 	br	8112702c <__reset+0xfb10702c>
81127200:	d9002017 	ldw	r4,128(sp)
81127204:	a00b883a 	mov	r5,r20
81127208:	111ea240 	call	8111ea24 <__swsetup_r>
8112720c:	1003b11e 	bne	r2,zero,811280d4 <___vfiprintf_internal_r+0x11f4>
81127210:	a080030b 	ldhu	r2,12(r20)
81127214:	00c00284 	movi	r3,10
81127218:	1080068c 	andi	r2,r2,26
8112721c:	10ff541e 	bne	r2,r3,81126f70 <__reset+0xfb106f70>
81127220:	a080038f 	ldh	r2,14(r20)
81127224:	103f5216 	blt	r2,zero,81126f70 <__reset+0xfb106f70>
81127228:	d9c02217 	ldw	r7,136(sp)
8112722c:	d9002017 	ldw	r4,128(sp)
81127230:	e00d883a 	mov	r6,fp
81127234:	a00b883a 	mov	r5,r20
81127238:	11283600 	call	81128360 <__sbprintf>
8112723c:	dfc03617 	ldw	ra,216(sp)
81127240:	df003517 	ldw	fp,212(sp)
81127244:	ddc03417 	ldw	r23,208(sp)
81127248:	dd803317 	ldw	r22,204(sp)
8112724c:	dd403217 	ldw	r21,200(sp)
81127250:	dd003117 	ldw	r20,196(sp)
81127254:	dcc03017 	ldw	r19,192(sp)
81127258:	dc802f17 	ldw	r18,188(sp)
8112725c:	dc402e17 	ldw	r17,184(sp)
81127260:	dc002d17 	ldw	r16,180(sp)
81127264:	dec03704 	addi	sp,sp,220
81127268:	f800283a 	ret
8112726c:	1120a940 	call	81120a94 <__sinit>
81127270:	003f2f06 	br	81126f30 <__reset+0xfb106f30>
81127274:	0463c83a 	sub	r17,zero,r17
81127278:	d8802215 	stw	r2,136(sp)
8112727c:	a5000114 	ori	r20,r20,4
81127280:	80c00007 	ldb	r3,0(r16)
81127284:	003f7706 	br	81127064 <__reset+0xfb107064>
81127288:	00800c04 	movi	r2,48
8112728c:	da802217 	ldw	r10,136(sp)
81127290:	d8801d05 	stb	r2,116(sp)
81127294:	00801e04 	movi	r2,120
81127298:	d8801d45 	stb	r2,117(sp)
8112729c:	d8001d85 	stb	zero,118(sp)
811272a0:	50c00104 	addi	r3,r10,4
811272a4:	54800017 	ldw	r18,0(r10)
811272a8:	0027883a 	mov	r19,zero
811272ac:	a0800094 	ori	r2,r20,2
811272b0:	48030b16 	blt	r9,zero,81127ee0 <___vfiprintf_internal_r+0x1000>
811272b4:	00bfdfc4 	movi	r2,-129
811272b8:	a096703a 	and	r11,r20,r2
811272bc:	d8c02215 	stw	r3,136(sp)
811272c0:	5d000094 	ori	r20,r11,2
811272c4:	90032b1e 	bne	r18,zero,81127f74 <___vfiprintf_internal_r+0x1094>
811272c8:	00a04534 	movhi	r2,33044
811272cc:	10973304 	addi	r2,r2,23756
811272d0:	d8802615 	stw	r2,152(sp)
811272d4:	0039883a 	mov	fp,zero
811272d8:	48017b1e 	bne	r9,zero,811278c8 <___vfiprintf_internal_r+0x9e8>
811272dc:	0013883a 	mov	r9,zero
811272e0:	0027883a 	mov	r19,zero
811272e4:	dd401a04 	addi	r21,sp,104
811272e8:	4825883a 	mov	r18,r9
811272ec:	4cc0010e 	bge	r9,r19,811272f4 <___vfiprintf_internal_r+0x414>
811272f0:	9825883a 	mov	r18,r19
811272f4:	e7003fcc 	andi	fp,fp,255
811272f8:	e700201c 	xori	fp,fp,128
811272fc:	e73fe004 	addi	fp,fp,-128
81127300:	e0000126 	beq	fp,zero,81127308 <___vfiprintf_internal_r+0x428>
81127304:	94800044 	addi	r18,r18,1
81127308:	a380008c 	andi	r14,r20,2
8112730c:	70000126 	beq	r14,zero,81127314 <___vfiprintf_internal_r+0x434>
81127310:	94800084 	addi	r18,r18,2
81127314:	a700210c 	andi	fp,r20,132
81127318:	e001df1e 	bne	fp,zero,81127a98 <___vfiprintf_internal_r+0xbb8>
8112731c:	8c87c83a 	sub	r3,r17,r18
81127320:	00c1dd0e 	bge	zero,r3,81127a98 <___vfiprintf_internal_r+0xbb8>
81127324:	01c00404 	movi	r7,16
81127328:	d8801c17 	ldw	r2,112(sp)
8112732c:	38c3ad0e 	bge	r7,r3,811281e4 <___vfiprintf_internal_r+0x1304>
81127330:	02a04534 	movhi	r10,33044
81127334:	5297c904 	addi	r10,r10,24356
81127338:	dc002915 	stw	r16,164(sp)
8112733c:	d9801b17 	ldw	r6,108(sp)
81127340:	da802415 	stw	r10,144(sp)
81127344:	03c001c4 	movi	r15,7
81127348:	da402515 	stw	r9,148(sp)
8112734c:	db802815 	stw	r14,160(sp)
81127350:	1821883a 	mov	r16,r3
81127354:	00000506 	br	8112736c <___vfiprintf_internal_r+0x48c>
81127358:	31400084 	addi	r5,r6,2
8112735c:	42000204 	addi	r8,r8,8
81127360:	200d883a 	mov	r6,r4
81127364:	843ffc04 	addi	r16,r16,-16
81127368:	3c000d0e 	bge	r7,r16,811273a0 <___vfiprintf_internal_r+0x4c0>
8112736c:	10800404 	addi	r2,r2,16
81127370:	31000044 	addi	r4,r6,1
81127374:	45800015 	stw	r22,0(r8)
81127378:	41c00115 	stw	r7,4(r8)
8112737c:	d8801c15 	stw	r2,112(sp)
81127380:	d9001b15 	stw	r4,108(sp)
81127384:	793ff40e 	bge	r15,r4,81127358 <__reset+0xfb107358>
81127388:	1001b51e 	bne	r2,zero,81127a60 <___vfiprintf_internal_r+0xb80>
8112738c:	843ffc04 	addi	r16,r16,-16
81127390:	000d883a 	mov	r6,zero
81127394:	01400044 	movi	r5,1
81127398:	d811883a 	mov	r8,sp
8112739c:	3c3ff316 	blt	r7,r16,8112736c <__reset+0xfb10736c>
811273a0:	8007883a 	mov	r3,r16
811273a4:	da402517 	ldw	r9,148(sp)
811273a8:	db802817 	ldw	r14,160(sp)
811273ac:	dc002917 	ldw	r16,164(sp)
811273b0:	da802417 	ldw	r10,144(sp)
811273b4:	1885883a 	add	r2,r3,r2
811273b8:	40c00115 	stw	r3,4(r8)
811273bc:	42800015 	stw	r10,0(r8)
811273c0:	d8801c15 	stw	r2,112(sp)
811273c4:	d9401b15 	stw	r5,108(sp)
811273c8:	00c001c4 	movi	r3,7
811273cc:	19426016 	blt	r3,r5,81127d50 <___vfiprintf_internal_r+0xe70>
811273d0:	d8c01d87 	ldb	r3,118(sp)
811273d4:	42000204 	addi	r8,r8,8
811273d8:	29000044 	addi	r4,r5,1
811273dc:	1801b31e 	bne	r3,zero,81127aac <___vfiprintf_internal_r+0xbcc>
811273e0:	7001c026 	beq	r14,zero,81127ae4 <___vfiprintf_internal_r+0xc04>
811273e4:	d8c01d04 	addi	r3,sp,116
811273e8:	10800084 	addi	r2,r2,2
811273ec:	40c00015 	stw	r3,0(r8)
811273f0:	00c00084 	movi	r3,2
811273f4:	40c00115 	stw	r3,4(r8)
811273f8:	d8801c15 	stw	r2,112(sp)
811273fc:	d9001b15 	stw	r4,108(sp)
81127400:	00c001c4 	movi	r3,7
81127404:	1902650e 	bge	r3,r4,81127d9c <___vfiprintf_internal_r+0xebc>
81127408:	10029a1e 	bne	r2,zero,81127e74 <___vfiprintf_internal_r+0xf94>
8112740c:	00c02004 	movi	r3,128
81127410:	01000044 	movi	r4,1
81127414:	000b883a 	mov	r5,zero
81127418:	d811883a 	mov	r8,sp
8112741c:	e0c1b31e 	bne	fp,r3,81127aec <___vfiprintf_internal_r+0xc0c>
81127420:	8cb9c83a 	sub	fp,r17,r18
81127424:	0701b10e 	bge	zero,fp,81127aec <___vfiprintf_internal_r+0xc0c>
81127428:	01c00404 	movi	r7,16
8112742c:	3f03890e 	bge	r7,fp,81128254 <___vfiprintf_internal_r+0x1374>
81127430:	00e04534 	movhi	r3,33044
81127434:	18d7c504 	addi	r3,r3,24340
81127438:	d8c02415 	stw	r3,144(sp)
8112743c:	8007883a 	mov	r3,r16
81127440:	034001c4 	movi	r13,7
81127444:	e021883a 	mov	r16,fp
81127448:	da402515 	stw	r9,148(sp)
8112744c:	1839883a 	mov	fp,r3
81127450:	00000506 	br	81127468 <___vfiprintf_internal_r+0x588>
81127454:	29800084 	addi	r6,r5,2
81127458:	42000204 	addi	r8,r8,8
8112745c:	180b883a 	mov	r5,r3
81127460:	843ffc04 	addi	r16,r16,-16
81127464:	3c000d0e 	bge	r7,r16,8112749c <___vfiprintf_internal_r+0x5bc>
81127468:	10800404 	addi	r2,r2,16
8112746c:	28c00044 	addi	r3,r5,1
81127470:	45c00015 	stw	r23,0(r8)
81127474:	41c00115 	stw	r7,4(r8)
81127478:	d8801c15 	stw	r2,112(sp)
8112747c:	d8c01b15 	stw	r3,108(sp)
81127480:	68fff40e 	bge	r13,r3,81127454 <__reset+0xfb107454>
81127484:	1002241e 	bne	r2,zero,81127d18 <___vfiprintf_internal_r+0xe38>
81127488:	843ffc04 	addi	r16,r16,-16
8112748c:	01800044 	movi	r6,1
81127490:	000b883a 	mov	r5,zero
81127494:	d811883a 	mov	r8,sp
81127498:	3c3ff316 	blt	r7,r16,81127468 <__reset+0xfb107468>
8112749c:	da402517 	ldw	r9,148(sp)
811274a0:	e007883a 	mov	r3,fp
811274a4:	8039883a 	mov	fp,r16
811274a8:	1821883a 	mov	r16,r3
811274ac:	d8c02417 	ldw	r3,144(sp)
811274b0:	1705883a 	add	r2,r2,fp
811274b4:	47000115 	stw	fp,4(r8)
811274b8:	40c00015 	stw	r3,0(r8)
811274bc:	d8801c15 	stw	r2,112(sp)
811274c0:	d9801b15 	stw	r6,108(sp)
811274c4:	00c001c4 	movi	r3,7
811274c8:	19827616 	blt	r3,r6,81127ea4 <___vfiprintf_internal_r+0xfc4>
811274cc:	4cf9c83a 	sub	fp,r9,r19
811274d0:	42000204 	addi	r8,r8,8
811274d4:	31000044 	addi	r4,r6,1
811274d8:	300b883a 	mov	r5,r6
811274dc:	07018516 	blt	zero,fp,81127af4 <___vfiprintf_internal_r+0xc14>
811274e0:	9885883a 	add	r2,r19,r2
811274e4:	45400015 	stw	r21,0(r8)
811274e8:	44c00115 	stw	r19,4(r8)
811274ec:	d8801c15 	stw	r2,112(sp)
811274f0:	d9001b15 	stw	r4,108(sp)
811274f4:	00c001c4 	movi	r3,7
811274f8:	1901dd0e 	bge	r3,r4,81127c70 <___vfiprintf_internal_r+0xd90>
811274fc:	1002401e 	bne	r2,zero,81127e00 <___vfiprintf_internal_r+0xf20>
81127500:	d8001b15 	stw	zero,108(sp)
81127504:	a2c0010c 	andi	r11,r20,4
81127508:	58000226 	beq	r11,zero,81127514 <___vfiprintf_internal_r+0x634>
8112750c:	8ca7c83a 	sub	r19,r17,r18
81127510:	04c2f216 	blt	zero,r19,811280dc <___vfiprintf_internal_r+0x11fc>
81127514:	8c80010e 	bge	r17,r18,8112751c <___vfiprintf_internal_r+0x63c>
81127518:	9023883a 	mov	r17,r18
8112751c:	da802317 	ldw	r10,140(sp)
81127520:	5455883a 	add	r10,r10,r17
81127524:	da802315 	stw	r10,140(sp)
81127528:	d8001b15 	stw	zero,108(sp)
8112752c:	d811883a 	mov	r8,sp
81127530:	003ea206 	br	81126fbc <__reset+0xfb106fbc>
81127534:	a5000814 	ori	r20,r20,32
81127538:	80c00007 	ldb	r3,0(r16)
8112753c:	003ec906 	br	81127064 <__reset+0xfb107064>
81127540:	80c00007 	ldb	r3,0(r16)
81127544:	1b030926 	beq	r3,r12,8112816c <___vfiprintf_internal_r+0x128c>
81127548:	a5000414 	ori	r20,r20,16
8112754c:	003ec506 	br	81127064 <__reset+0xfb107064>
81127550:	21003fcc 	andi	r4,r4,255
81127554:	20035e1e 	bne	r4,zero,811282d0 <___vfiprintf_internal_r+0x13f0>
81127558:	a080080c 	andi	r2,r20,32
8112755c:	1002a526 	beq	r2,zero,81127ff4 <___vfiprintf_internal_r+0x1114>
81127560:	da802217 	ldw	r10,136(sp)
81127564:	50800017 	ldw	r2,0(r10)
81127568:	da802317 	ldw	r10,140(sp)
8112756c:	5007d7fa 	srai	r3,r10,31
81127570:	da802217 	ldw	r10,136(sp)
81127574:	10c00115 	stw	r3,4(r2)
81127578:	52800104 	addi	r10,r10,4
8112757c:	da802215 	stw	r10,136(sp)
81127580:	da802317 	ldw	r10,140(sp)
81127584:	12800015 	stw	r10,0(r2)
81127588:	003e8c06 	br	81126fbc <__reset+0xfb106fbc>
8112758c:	21003fcc 	andi	r4,r4,255
81127590:	2003511e 	bne	r4,zero,811282d8 <___vfiprintf_internal_r+0x13f8>
81127594:	a080080c 	andi	r2,r20,32
81127598:	1000a126 	beq	r2,zero,81127820 <___vfiprintf_internal_r+0x940>
8112759c:	da802217 	ldw	r10,136(sp)
811275a0:	d8001d85 	stb	zero,118(sp)
811275a4:	50800204 	addi	r2,r10,8
811275a8:	54800017 	ldw	r18,0(r10)
811275ac:	54c00117 	ldw	r19,4(r10)
811275b0:	4802b416 	blt	r9,zero,81128084 <___vfiprintf_internal_r+0x11a4>
811275b4:	013fdfc4 	movi	r4,-129
811275b8:	94c6b03a 	or	r3,r18,r19
811275bc:	d8802215 	stw	r2,136(sp)
811275c0:	a128703a 	and	r20,r20,r4
811275c4:	1800a226 	beq	r3,zero,81127850 <___vfiprintf_internal_r+0x970>
811275c8:	0039883a 	mov	fp,zero
811275cc:	dd401a04 	addi	r21,sp,104
811275d0:	9006d0fa 	srli	r3,r18,3
811275d4:	9808977a 	slli	r4,r19,29
811275d8:	9826d0fa 	srli	r19,r19,3
811275dc:	948001cc 	andi	r18,r18,7
811275e0:	90800c04 	addi	r2,r18,48
811275e4:	ad7fffc4 	addi	r21,r21,-1
811275e8:	20e4b03a 	or	r18,r4,r3
811275ec:	a8800005 	stb	r2,0(r21)
811275f0:	94c6b03a 	or	r3,r18,r19
811275f4:	183ff61e 	bne	r3,zero,811275d0 <__reset+0xfb1075d0>
811275f8:	a0c0004c 	andi	r3,r20,1
811275fc:	18005926 	beq	r3,zero,81127764 <___vfiprintf_internal_r+0x884>
81127600:	10803fcc 	andi	r2,r2,255
81127604:	1080201c 	xori	r2,r2,128
81127608:	10bfe004 	addi	r2,r2,-128
8112760c:	00c00c04 	movi	r3,48
81127610:	10c05426 	beq	r2,r3,81127764 <___vfiprintf_internal_r+0x884>
81127614:	da801e17 	ldw	r10,120(sp)
81127618:	a8bfffc4 	addi	r2,r21,-1
8112761c:	a8ffffc5 	stb	r3,-1(r21)
81127620:	50a7c83a 	sub	r19,r10,r2
81127624:	102b883a 	mov	r21,r2
81127628:	003f2f06 	br	811272e8 <__reset+0xfb1072e8>
8112762c:	21003fcc 	andi	r4,r4,255
81127630:	2003421e 	bne	r4,zero,8112833c <___vfiprintf_internal_r+0x145c>
81127634:	00a04534 	movhi	r2,33044
81127638:	10973304 	addi	r2,r2,23756
8112763c:	d8802615 	stw	r2,152(sp)
81127640:	a080080c 	andi	r2,r20,32
81127644:	1000aa26 	beq	r2,zero,811278f0 <___vfiprintf_internal_r+0xa10>
81127648:	da802217 	ldw	r10,136(sp)
8112764c:	54800017 	ldw	r18,0(r10)
81127650:	54c00117 	ldw	r19,4(r10)
81127654:	52800204 	addi	r10,r10,8
81127658:	da802215 	stw	r10,136(sp)
8112765c:	a080004c 	andi	r2,r20,1
81127660:	1001d226 	beq	r2,zero,81127dac <___vfiprintf_internal_r+0xecc>
81127664:	94c4b03a 	or	r2,r18,r19
81127668:	1002351e 	bne	r2,zero,81127f40 <___vfiprintf_internal_r+0x1060>
8112766c:	d8001d85 	stb	zero,118(sp)
81127670:	48022216 	blt	r9,zero,81127efc <___vfiprintf_internal_r+0x101c>
81127674:	00bfdfc4 	movi	r2,-129
81127678:	a0a8703a 	and	r20,r20,r2
8112767c:	003f1506 	br	811272d4 <__reset+0xfb1072d4>
81127680:	da802217 	ldw	r10,136(sp)
81127684:	04800044 	movi	r18,1
81127688:	d8001d85 	stb	zero,118(sp)
8112768c:	50800017 	ldw	r2,0(r10)
81127690:	52800104 	addi	r10,r10,4
81127694:	da802215 	stw	r10,136(sp)
81127698:	d8801005 	stb	r2,64(sp)
8112769c:	9027883a 	mov	r19,r18
811276a0:	dd401004 	addi	r21,sp,64
811276a4:	0013883a 	mov	r9,zero
811276a8:	003f1706 	br	81127308 <__reset+0xfb107308>
811276ac:	21003fcc 	andi	r4,r4,255
811276b0:	2003201e 	bne	r4,zero,81128334 <___vfiprintf_internal_r+0x1454>
811276b4:	a080080c 	andi	r2,r20,32
811276b8:	10004b26 	beq	r2,zero,811277e8 <___vfiprintf_internal_r+0x908>
811276bc:	da802217 	ldw	r10,136(sp)
811276c0:	50800117 	ldw	r2,4(r10)
811276c4:	54800017 	ldw	r18,0(r10)
811276c8:	52800204 	addi	r10,r10,8
811276cc:	da802215 	stw	r10,136(sp)
811276d0:	1027883a 	mov	r19,r2
811276d4:	10022c16 	blt	r2,zero,81127f88 <___vfiprintf_internal_r+0x10a8>
811276d8:	df001d83 	ldbu	fp,118(sp)
811276dc:	48007216 	blt	r9,zero,811278a8 <___vfiprintf_internal_r+0x9c8>
811276e0:	00ffdfc4 	movi	r3,-129
811276e4:	94c4b03a 	or	r2,r18,r19
811276e8:	a0e8703a 	and	r20,r20,r3
811276ec:	1000cc26 	beq	r2,zero,81127a20 <___vfiprintf_internal_r+0xb40>
811276f0:	98021026 	beq	r19,zero,81127f34 <___vfiprintf_internal_r+0x1054>
811276f4:	dc402415 	stw	r17,144(sp)
811276f8:	dc002515 	stw	r16,148(sp)
811276fc:	9823883a 	mov	r17,r19
81127700:	9021883a 	mov	r16,r18
81127704:	dd401a04 	addi	r21,sp,104
81127708:	4825883a 	mov	r18,r9
8112770c:	4027883a 	mov	r19,r8
81127710:	8009883a 	mov	r4,r16
81127714:	880b883a 	mov	r5,r17
81127718:	01800284 	movi	r6,10
8112771c:	000f883a 	mov	r7,zero
81127720:	1129c7c0 	call	81129c7c <__umoddi3>
81127724:	10800c04 	addi	r2,r2,48
81127728:	ad7fffc4 	addi	r21,r21,-1
8112772c:	8009883a 	mov	r4,r16
81127730:	880b883a 	mov	r5,r17
81127734:	a8800005 	stb	r2,0(r21)
81127738:	01800284 	movi	r6,10
8112773c:	000f883a 	mov	r7,zero
81127740:	11296fc0 	call	811296fc <__udivdi3>
81127744:	1021883a 	mov	r16,r2
81127748:	10c4b03a 	or	r2,r2,r3
8112774c:	1823883a 	mov	r17,r3
81127750:	103fef1e 	bne	r2,zero,81127710 <__reset+0xfb107710>
81127754:	dc402417 	ldw	r17,144(sp)
81127758:	dc002517 	ldw	r16,148(sp)
8112775c:	9013883a 	mov	r9,r18
81127760:	9811883a 	mov	r8,r19
81127764:	da801e17 	ldw	r10,120(sp)
81127768:	5567c83a 	sub	r19,r10,r21
8112776c:	003ede06 	br	811272e8 <__reset+0xfb1072e8>
81127770:	38803fcc 	andi	r2,r7,255
81127774:	1080201c 	xori	r2,r2,128
81127778:	10bfe004 	addi	r2,r2,-128
8112777c:	1002371e 	bne	r2,zero,8112805c <___vfiprintf_internal_r+0x117c>
81127780:	01000044 	movi	r4,1
81127784:	01c00804 	movi	r7,32
81127788:	80c00007 	ldb	r3,0(r16)
8112778c:	003e3506 	br	81127064 <__reset+0xfb107064>
81127790:	a5000054 	ori	r20,r20,1
81127794:	80c00007 	ldb	r3,0(r16)
81127798:	003e3206 	br	81127064 <__reset+0xfb107064>
8112779c:	a5002014 	ori	r20,r20,128
811277a0:	80c00007 	ldb	r3,0(r16)
811277a4:	003e2f06 	br	81127064 <__reset+0xfb107064>
811277a8:	8015883a 	mov	r10,r16
811277ac:	0023883a 	mov	r17,zero
811277b0:	18bff404 	addi	r2,r3,-48
811277b4:	50c00007 	ldb	r3,0(r10)
811277b8:	8c4002a4 	muli	r17,r17,10
811277bc:	84000044 	addi	r16,r16,1
811277c0:	8015883a 	mov	r10,r16
811277c4:	1463883a 	add	r17,r2,r17
811277c8:	18bff404 	addi	r2,r3,-48
811277cc:	30bff92e 	bgeu	r6,r2,811277b4 <__reset+0xfb1077b4>
811277d0:	003e2506 	br	81127068 <__reset+0xfb107068>
811277d4:	21003fcc 	andi	r4,r4,255
811277d8:	2002d41e 	bne	r4,zero,8112832c <___vfiprintf_internal_r+0x144c>
811277dc:	a5000414 	ori	r20,r20,16
811277e0:	a080080c 	andi	r2,r20,32
811277e4:	103fb51e 	bne	r2,zero,811276bc <__reset+0xfb1076bc>
811277e8:	a080040c 	andi	r2,r20,16
811277ec:	1001f826 	beq	r2,zero,81127fd0 <___vfiprintf_internal_r+0x10f0>
811277f0:	da802217 	ldw	r10,136(sp)
811277f4:	54800017 	ldw	r18,0(r10)
811277f8:	52800104 	addi	r10,r10,4
811277fc:	da802215 	stw	r10,136(sp)
81127800:	9027d7fa 	srai	r19,r18,31
81127804:	9805883a 	mov	r2,r19
81127808:	003fb206 	br	811276d4 <__reset+0xfb1076d4>
8112780c:	21003fcc 	andi	r4,r4,255
81127810:	2002c41e 	bne	r4,zero,81128324 <___vfiprintf_internal_r+0x1444>
81127814:	a5000414 	ori	r20,r20,16
81127818:	a080080c 	andi	r2,r20,32
8112781c:	103f5f1e 	bne	r2,zero,8112759c <__reset+0xfb10759c>
81127820:	a080040c 	andi	r2,r20,16
81127824:	10020f26 	beq	r2,zero,81128064 <___vfiprintf_internal_r+0x1184>
81127828:	da802217 	ldw	r10,136(sp)
8112782c:	d8001d85 	stb	zero,118(sp)
81127830:	0027883a 	mov	r19,zero
81127834:	50800104 	addi	r2,r10,4
81127838:	54800017 	ldw	r18,0(r10)
8112783c:	48021116 	blt	r9,zero,81128084 <___vfiprintf_internal_r+0x11a4>
81127840:	00ffdfc4 	movi	r3,-129
81127844:	d8802215 	stw	r2,136(sp)
81127848:	a0e8703a 	and	r20,r20,r3
8112784c:	903f5e1e 	bne	r18,zero,811275c8 <__reset+0xfb1075c8>
81127850:	0039883a 	mov	fp,zero
81127854:	4802a626 	beq	r9,zero,811282f0 <___vfiprintf_internal_r+0x1410>
81127858:	0025883a 	mov	r18,zero
8112785c:	0027883a 	mov	r19,zero
81127860:	003f5a06 	br	811275cc <__reset+0xfb1075cc>
81127864:	21003fcc 	andi	r4,r4,255
81127868:	20029f1e 	bne	r4,zero,811282e8 <___vfiprintf_internal_r+0x1408>
8112786c:	a5000414 	ori	r20,r20,16
81127870:	a080080c 	andi	r2,r20,32
81127874:	10005e1e 	bne	r2,zero,811279f0 <___vfiprintf_internal_r+0xb10>
81127878:	a080040c 	andi	r2,r20,16
8112787c:	1001a21e 	bne	r2,zero,81127f08 <___vfiprintf_internal_r+0x1028>
81127880:	a080100c 	andi	r2,r20,64
81127884:	d8001d85 	stb	zero,118(sp)
81127888:	da802217 	ldw	r10,136(sp)
8112788c:	1002231e 	bne	r2,zero,8112811c <___vfiprintf_internal_r+0x123c>
81127890:	50800104 	addi	r2,r10,4
81127894:	54800017 	ldw	r18,0(r10)
81127898:	0027883a 	mov	r19,zero
8112789c:	4801a00e 	bge	r9,zero,81127f20 <___vfiprintf_internal_r+0x1040>
811278a0:	d8802215 	stw	r2,136(sp)
811278a4:	0039883a 	mov	fp,zero
811278a8:	94c4b03a 	or	r2,r18,r19
811278ac:	103f901e 	bne	r2,zero,811276f0 <__reset+0xfb1076f0>
811278b0:	00800044 	movi	r2,1
811278b4:	10803fcc 	andi	r2,r2,255
811278b8:	00c00044 	movi	r3,1
811278bc:	10c05926 	beq	r2,r3,81127a24 <___vfiprintf_internal_r+0xb44>
811278c0:	00c00084 	movi	r3,2
811278c4:	10ffe41e 	bne	r2,r3,81127858 <__reset+0xfb107858>
811278c8:	0025883a 	mov	r18,zero
811278cc:	0027883a 	mov	r19,zero
811278d0:	00013d06 	br	81127dc8 <___vfiprintf_internal_r+0xee8>
811278d4:	21003fcc 	andi	r4,r4,255
811278d8:	2002811e 	bne	r4,zero,811282e0 <___vfiprintf_internal_r+0x1400>
811278dc:	00a04534 	movhi	r2,33044
811278e0:	10972e04 	addi	r2,r2,23736
811278e4:	d8802615 	stw	r2,152(sp)
811278e8:	a080080c 	andi	r2,r20,32
811278ec:	103f561e 	bne	r2,zero,81127648 <__reset+0xfb107648>
811278f0:	a080040c 	andi	r2,r20,16
811278f4:	1001d126 	beq	r2,zero,8112803c <___vfiprintf_internal_r+0x115c>
811278f8:	da802217 	ldw	r10,136(sp)
811278fc:	0027883a 	mov	r19,zero
81127900:	54800017 	ldw	r18,0(r10)
81127904:	52800104 	addi	r10,r10,4
81127908:	da802215 	stw	r10,136(sp)
8112790c:	003f5306 	br	8112765c <__reset+0xfb10765c>
81127910:	da802217 	ldw	r10,136(sp)
81127914:	d8001d85 	stb	zero,118(sp)
81127918:	55400017 	ldw	r21,0(r10)
8112791c:	50c00104 	addi	r3,r10,4
81127920:	a8024226 	beq	r21,zero,8112822c <___vfiprintf_internal_r+0x134c>
81127924:	48021816 	blt	r9,zero,81128188 <___vfiprintf_internal_r+0x12a8>
81127928:	480d883a 	mov	r6,r9
8112792c:	000b883a 	mov	r5,zero
81127930:	a809883a 	mov	r4,r21
81127934:	d8c02a15 	stw	r3,168(sp)
81127938:	da002b15 	stw	r8,172(sp)
8112793c:	da402c15 	stw	r9,176(sp)
81127940:	1121cbc0 	call	81121cbc <memchr>
81127944:	d8c02a17 	ldw	r3,168(sp)
81127948:	da002b17 	ldw	r8,172(sp)
8112794c:	da402c17 	ldw	r9,176(sp)
81127950:	10024826 	beq	r2,zero,81128274 <___vfiprintf_internal_r+0x1394>
81127954:	1567c83a 	sub	r19,r2,r21
81127958:	df001d83 	ldbu	fp,118(sp)
8112795c:	d8c02215 	stw	r3,136(sp)
81127960:	0013883a 	mov	r9,zero
81127964:	003e6006 	br	811272e8 <__reset+0xfb1072e8>
81127968:	21003fcc 	andi	r4,r4,255
8112796c:	203fc026 	beq	r4,zero,81127870 <__reset+0xfb107870>
81127970:	d9c01d85 	stb	r7,118(sp)
81127974:	003fbe06 	br	81127870 <__reset+0xfb107870>
81127978:	da802217 	ldw	r10,136(sp)
8112797c:	54400017 	ldw	r17,0(r10)
81127980:	50800104 	addi	r2,r10,4
81127984:	883e3b16 	blt	r17,zero,81127274 <__reset+0xfb107274>
81127988:	d8802215 	stw	r2,136(sp)
8112798c:	80c00007 	ldb	r3,0(r16)
81127990:	003db406 	br	81127064 <__reset+0xfb107064>
81127994:	01000044 	movi	r4,1
81127998:	01c00ac4 	movi	r7,43
8112799c:	80c00007 	ldb	r3,0(r16)
811279a0:	003db006 	br	81127064 <__reset+0xfb107064>
811279a4:	80c00007 	ldb	r3,0(r16)
811279a8:	82800044 	addi	r10,r16,1
811279ac:	1b423c26 	beq	r3,r13,811282a0 <___vfiprintf_internal_r+0x13c0>
811279b0:	18bff404 	addi	r2,r3,-48
811279b4:	0013883a 	mov	r9,zero
811279b8:	30822b36 	bltu	r6,r2,81128268 <___vfiprintf_internal_r+0x1388>
811279bc:	50c00007 	ldb	r3,0(r10)
811279c0:	4a4002a4 	muli	r9,r9,10
811279c4:	54000044 	addi	r16,r10,1
811279c8:	8015883a 	mov	r10,r16
811279cc:	4893883a 	add	r9,r9,r2
811279d0:	18bff404 	addi	r2,r3,-48
811279d4:	30bff92e 	bgeu	r6,r2,811279bc <__reset+0xfb1079bc>
811279d8:	483da30e 	bge	r9,zero,81127068 <__reset+0xfb107068>
811279dc:	027fffc4 	movi	r9,-1
811279e0:	003da106 	br	81127068 <__reset+0xfb107068>
811279e4:	a5001014 	ori	r20,r20,64
811279e8:	80c00007 	ldb	r3,0(r16)
811279ec:	003d9d06 	br	81127064 <__reset+0xfb107064>
811279f0:	da802217 	ldw	r10,136(sp)
811279f4:	d8001d85 	stb	zero,118(sp)
811279f8:	50c00204 	addi	r3,r10,8
811279fc:	54800017 	ldw	r18,0(r10)
81127a00:	54c00117 	ldw	r19,4(r10)
81127a04:	4801ca16 	blt	r9,zero,81128130 <___vfiprintf_internal_r+0x1250>
81127a08:	013fdfc4 	movi	r4,-129
81127a0c:	94c4b03a 	or	r2,r18,r19
81127a10:	d8c02215 	stw	r3,136(sp)
81127a14:	a128703a 	and	r20,r20,r4
81127a18:	0039883a 	mov	fp,zero
81127a1c:	103f341e 	bne	r2,zero,811276f0 <__reset+0xfb1076f0>
81127a20:	483e2e26 	beq	r9,zero,811272dc <__reset+0xfb1072dc>
81127a24:	0025883a 	mov	r18,zero
81127a28:	94800c04 	addi	r18,r18,48
81127a2c:	dc8019c5 	stb	r18,103(sp)
81127a30:	dcc02717 	ldw	r19,156(sp)
81127a34:	dd4019c4 	addi	r21,sp,103
81127a38:	003e2b06 	br	811272e8 <__reset+0xfb1072e8>
81127a3c:	21003fcc 	andi	r4,r4,255
81127a40:	2002361e 	bne	r4,zero,8112831c <___vfiprintf_internal_r+0x143c>
81127a44:	1801c126 	beq	r3,zero,8112814c <___vfiprintf_internal_r+0x126c>
81127a48:	04800044 	movi	r18,1
81127a4c:	d8c01005 	stb	r3,64(sp)
81127a50:	d8001d85 	stb	zero,118(sp)
81127a54:	9027883a 	mov	r19,r18
81127a58:	dd401004 	addi	r21,sp,64
81127a5c:	003f1106 	br	811276a4 <__reset+0xfb1076a4>
81127a60:	d9402117 	ldw	r5,132(sp)
81127a64:	d9002017 	ldw	r4,128(sp)
81127a68:	d9801a04 	addi	r6,sp,104
81127a6c:	d9c02b15 	stw	r7,172(sp)
81127a70:	dbc02a15 	stw	r15,168(sp)
81127a74:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127a78:	d9c02b17 	ldw	r7,172(sp)
81127a7c:	dbc02a17 	ldw	r15,168(sp)
81127a80:	10006d1e 	bne	r2,zero,81127c38 <___vfiprintf_internal_r+0xd58>
81127a84:	d9801b17 	ldw	r6,108(sp)
81127a88:	d8801c17 	ldw	r2,112(sp)
81127a8c:	d811883a 	mov	r8,sp
81127a90:	31400044 	addi	r5,r6,1
81127a94:	003e3306 	br	81127364 <__reset+0xfb107364>
81127a98:	d9401b17 	ldw	r5,108(sp)
81127a9c:	d8801c17 	ldw	r2,112(sp)
81127aa0:	29000044 	addi	r4,r5,1
81127aa4:	d8c01d87 	ldb	r3,118(sp)
81127aa8:	183e4d26 	beq	r3,zero,811273e0 <__reset+0xfb1073e0>
81127aac:	00c00044 	movi	r3,1
81127ab0:	d9401d84 	addi	r5,sp,118
81127ab4:	10c5883a 	add	r2,r2,r3
81127ab8:	41400015 	stw	r5,0(r8)
81127abc:	40c00115 	stw	r3,4(r8)
81127ac0:	d8801c15 	stw	r2,112(sp)
81127ac4:	d9001b15 	stw	r4,108(sp)
81127ac8:	014001c4 	movi	r5,7
81127acc:	2900a90e 	bge	r5,r4,81127d74 <___vfiprintf_internal_r+0xe94>
81127ad0:	1000da1e 	bne	r2,zero,81127e3c <___vfiprintf_internal_r+0xf5c>
81127ad4:	7000ab1e 	bne	r14,zero,81127d84 <___vfiprintf_internal_r+0xea4>
81127ad8:	000b883a 	mov	r5,zero
81127adc:	1809883a 	mov	r4,r3
81127ae0:	d811883a 	mov	r8,sp
81127ae4:	00c02004 	movi	r3,128
81127ae8:	e0fe4d26 	beq	fp,r3,81127420 <__reset+0xfb107420>
81127aec:	4cf9c83a 	sub	fp,r9,r19
81127af0:	073e7b0e 	bge	zero,fp,811274e0 <__reset+0xfb1074e0>
81127af4:	01c00404 	movi	r7,16
81127af8:	3f01900e 	bge	r7,fp,8112813c <___vfiprintf_internal_r+0x125c>
81127afc:	00e04534 	movhi	r3,33044
81127b00:	18d7c504 	addi	r3,r3,24340
81127b04:	d8c02415 	stw	r3,144(sp)
81127b08:	034001c4 	movi	r13,7
81127b0c:	00000506 	br	81127b24 <___vfiprintf_internal_r+0xc44>
81127b10:	29000084 	addi	r4,r5,2
81127b14:	42000204 	addi	r8,r8,8
81127b18:	180b883a 	mov	r5,r3
81127b1c:	e73ffc04 	addi	fp,fp,-16
81127b20:	3f000d0e 	bge	r7,fp,81127b58 <___vfiprintf_internal_r+0xc78>
81127b24:	10800404 	addi	r2,r2,16
81127b28:	28c00044 	addi	r3,r5,1
81127b2c:	45c00015 	stw	r23,0(r8)
81127b30:	41c00115 	stw	r7,4(r8)
81127b34:	d8801c15 	stw	r2,112(sp)
81127b38:	d8c01b15 	stw	r3,108(sp)
81127b3c:	68fff40e 	bge	r13,r3,81127b10 <__reset+0xfb107b10>
81127b40:	1000101e 	bne	r2,zero,81127b84 <___vfiprintf_internal_r+0xca4>
81127b44:	e73ffc04 	addi	fp,fp,-16
81127b48:	01000044 	movi	r4,1
81127b4c:	000b883a 	mov	r5,zero
81127b50:	d811883a 	mov	r8,sp
81127b54:	3f3ff316 	blt	r7,fp,81127b24 <__reset+0xfb107b24>
81127b58:	da802417 	ldw	r10,144(sp)
81127b5c:	1705883a 	add	r2,r2,fp
81127b60:	47000115 	stw	fp,4(r8)
81127b64:	42800015 	stw	r10,0(r8)
81127b68:	d8801c15 	stw	r2,112(sp)
81127b6c:	d9001b15 	stw	r4,108(sp)
81127b70:	00c001c4 	movi	r3,7
81127b74:	19003616 	blt	r3,r4,81127c50 <___vfiprintf_internal_r+0xd70>
81127b78:	42000204 	addi	r8,r8,8
81127b7c:	21000044 	addi	r4,r4,1
81127b80:	003e5706 	br	811274e0 <__reset+0xfb1074e0>
81127b84:	d9402117 	ldw	r5,132(sp)
81127b88:	d9002017 	ldw	r4,128(sp)
81127b8c:	d9801a04 	addi	r6,sp,104
81127b90:	d9c02b15 	stw	r7,172(sp)
81127b94:	db402a15 	stw	r13,168(sp)
81127b98:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127b9c:	d9c02b17 	ldw	r7,172(sp)
81127ba0:	db402a17 	ldw	r13,168(sp)
81127ba4:	1000241e 	bne	r2,zero,81127c38 <___vfiprintf_internal_r+0xd58>
81127ba8:	d9401b17 	ldw	r5,108(sp)
81127bac:	d8801c17 	ldw	r2,112(sp)
81127bb0:	d811883a 	mov	r8,sp
81127bb4:	29000044 	addi	r4,r5,1
81127bb8:	003fd806 	br	81127b1c <__reset+0xfb107b1c>
81127bbc:	d9401b17 	ldw	r5,108(sp)
81127bc0:	00e04534 	movhi	r3,33044
81127bc4:	18d7c904 	addi	r3,r3,24356
81127bc8:	d8c02415 	stw	r3,144(sp)
81127bcc:	29400044 	addi	r5,r5,1
81127bd0:	d8c02417 	ldw	r3,144(sp)
81127bd4:	14c5883a 	add	r2,r2,r19
81127bd8:	44c00115 	stw	r19,4(r8)
81127bdc:	40c00015 	stw	r3,0(r8)
81127be0:	d8801c15 	stw	r2,112(sp)
81127be4:	d9401b15 	stw	r5,108(sp)
81127be8:	00c001c4 	movi	r3,7
81127bec:	1940070e 	bge	r3,r5,81127c0c <___vfiprintf_internal_r+0xd2c>
81127bf0:	103e4826 	beq	r2,zero,81127514 <__reset+0xfb107514>
81127bf4:	d9402117 	ldw	r5,132(sp)
81127bf8:	d9002017 	ldw	r4,128(sp)
81127bfc:	d9801a04 	addi	r6,sp,104
81127c00:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127c04:	10000c1e 	bne	r2,zero,81127c38 <___vfiprintf_internal_r+0xd58>
81127c08:	d8801c17 	ldw	r2,112(sp)
81127c0c:	8c80010e 	bge	r17,r18,81127c14 <___vfiprintf_internal_r+0xd34>
81127c10:	9023883a 	mov	r17,r18
81127c14:	da802317 	ldw	r10,140(sp)
81127c18:	5455883a 	add	r10,r10,r17
81127c1c:	da802315 	stw	r10,140(sp)
81127c20:	103e4126 	beq	r2,zero,81127528 <__reset+0xfb107528>
81127c24:	d9402117 	ldw	r5,132(sp)
81127c28:	d9002017 	ldw	r4,128(sp)
81127c2c:	d9801a04 	addi	r6,sp,104
81127c30:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127c34:	103e3c26 	beq	r2,zero,81127528 <__reset+0xfb107528>
81127c38:	dd002117 	ldw	r20,132(sp)
81127c3c:	a080030b 	ldhu	r2,12(r20)
81127c40:	1080100c 	andi	r2,r2,64
81127c44:	1001231e 	bne	r2,zero,811280d4 <___vfiprintf_internal_r+0x11f4>
81127c48:	d8802317 	ldw	r2,140(sp)
81127c4c:	003d7b06 	br	8112723c <__reset+0xfb10723c>
81127c50:	1000991e 	bne	r2,zero,81127eb8 <___vfiprintf_internal_r+0xfd8>
81127c54:	00c00044 	movi	r3,1
81127c58:	9805883a 	mov	r2,r19
81127c5c:	dd400015 	stw	r21,0(sp)
81127c60:	dcc00115 	stw	r19,4(sp)
81127c64:	dcc01c15 	stw	r19,112(sp)
81127c68:	d8c01b15 	stw	r3,108(sp)
81127c6c:	d811883a 	mov	r8,sp
81127c70:	42000204 	addi	r8,r8,8
81127c74:	a2c0010c 	andi	r11,r20,4
81127c78:	583fe426 	beq	r11,zero,81127c0c <__reset+0xfb107c0c>
81127c7c:	8ca7c83a 	sub	r19,r17,r18
81127c80:	04ffe20e 	bge	zero,r19,81127c0c <__reset+0xfb107c0c>
81127c84:	01c00404 	movi	r7,16
81127c88:	3cffcc0e 	bge	r7,r19,81127bbc <__reset+0xfb107bbc>
81127c8c:	02a04534 	movhi	r10,33044
81127c90:	5297c904 	addi	r10,r10,24356
81127c94:	d9001b17 	ldw	r4,108(sp)
81127c98:	da802415 	stw	r10,144(sp)
81127c9c:	382b883a 	mov	r21,r7
81127ca0:	050001c4 	movi	r20,7
81127ca4:	df002017 	ldw	fp,128(sp)
81127ca8:	00000506 	br	81127cc0 <___vfiprintf_internal_r+0xde0>
81127cac:	21400084 	addi	r5,r4,2
81127cb0:	42000204 	addi	r8,r8,8
81127cb4:	1809883a 	mov	r4,r3
81127cb8:	9cfffc04 	addi	r19,r19,-16
81127cbc:	acffc40e 	bge	r21,r19,81127bd0 <__reset+0xfb107bd0>
81127cc0:	10800404 	addi	r2,r2,16
81127cc4:	20c00044 	addi	r3,r4,1
81127cc8:	45800015 	stw	r22,0(r8)
81127ccc:	45400115 	stw	r21,4(r8)
81127cd0:	d8801c15 	stw	r2,112(sp)
81127cd4:	d8c01b15 	stw	r3,108(sp)
81127cd8:	a0fff40e 	bge	r20,r3,81127cac <__reset+0xfb107cac>
81127cdc:	1000041e 	bne	r2,zero,81127cf0 <___vfiprintf_internal_r+0xe10>
81127ce0:	01400044 	movi	r5,1
81127ce4:	0009883a 	mov	r4,zero
81127ce8:	d811883a 	mov	r8,sp
81127cec:	003ff206 	br	81127cb8 <__reset+0xfb107cb8>
81127cf0:	d9402117 	ldw	r5,132(sp)
81127cf4:	d9801a04 	addi	r6,sp,104
81127cf8:	e009883a 	mov	r4,fp
81127cfc:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127d00:	103fcd1e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127d04:	d9001b17 	ldw	r4,108(sp)
81127d08:	d8801c17 	ldw	r2,112(sp)
81127d0c:	d811883a 	mov	r8,sp
81127d10:	21400044 	addi	r5,r4,1
81127d14:	003fe806 	br	81127cb8 <__reset+0xfb107cb8>
81127d18:	d9402117 	ldw	r5,132(sp)
81127d1c:	d9002017 	ldw	r4,128(sp)
81127d20:	d9801a04 	addi	r6,sp,104
81127d24:	d9c02b15 	stw	r7,172(sp)
81127d28:	db402a15 	stw	r13,168(sp)
81127d2c:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127d30:	d9c02b17 	ldw	r7,172(sp)
81127d34:	db402a17 	ldw	r13,168(sp)
81127d38:	103fbf1e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127d3c:	d9401b17 	ldw	r5,108(sp)
81127d40:	d8801c17 	ldw	r2,112(sp)
81127d44:	d811883a 	mov	r8,sp
81127d48:	29800044 	addi	r6,r5,1
81127d4c:	003dc406 	br	81127460 <__reset+0xfb107460>
81127d50:	1000d21e 	bne	r2,zero,8112809c <___vfiprintf_internal_r+0x11bc>
81127d54:	d8c01d87 	ldb	r3,118(sp)
81127d58:	18009526 	beq	r3,zero,81127fb0 <___vfiprintf_internal_r+0x10d0>
81127d5c:	00800044 	movi	r2,1
81127d60:	d8c01d84 	addi	r3,sp,118
81127d64:	1009883a 	mov	r4,r2
81127d68:	d8c00015 	stw	r3,0(sp)
81127d6c:	d8800115 	stw	r2,4(sp)
81127d70:	d811883a 	mov	r8,sp
81127d74:	200b883a 	mov	r5,r4
81127d78:	42000204 	addi	r8,r8,8
81127d7c:	21000044 	addi	r4,r4,1
81127d80:	003d9706 	br	811273e0 <__reset+0xfb1073e0>
81127d84:	d9001d04 	addi	r4,sp,116
81127d88:	00800084 	movi	r2,2
81127d8c:	d9000015 	stw	r4,0(sp)
81127d90:	d8800115 	stw	r2,4(sp)
81127d94:	1809883a 	mov	r4,r3
81127d98:	d811883a 	mov	r8,sp
81127d9c:	200b883a 	mov	r5,r4
81127da0:	42000204 	addi	r8,r8,8
81127da4:	21000044 	addi	r4,r4,1
81127da8:	003f4e06 	br	81127ae4 <__reset+0xfb107ae4>
81127dac:	d8001d85 	stb	zero,118(sp)
81127db0:	48005016 	blt	r9,zero,81127ef4 <___vfiprintf_internal_r+0x1014>
81127db4:	00ffdfc4 	movi	r3,-129
81127db8:	94c4b03a 	or	r2,r18,r19
81127dbc:	a0e8703a 	and	r20,r20,r3
81127dc0:	103d4426 	beq	r2,zero,811272d4 <__reset+0xfb1072d4>
81127dc4:	0039883a 	mov	fp,zero
81127dc8:	d9002617 	ldw	r4,152(sp)
81127dcc:	dd401a04 	addi	r21,sp,104
81127dd0:	908003cc 	andi	r2,r18,15
81127dd4:	9806973a 	slli	r3,r19,28
81127dd8:	2085883a 	add	r2,r4,r2
81127ddc:	9024d13a 	srli	r18,r18,4
81127de0:	10800003 	ldbu	r2,0(r2)
81127de4:	9826d13a 	srli	r19,r19,4
81127de8:	ad7fffc4 	addi	r21,r21,-1
81127dec:	1ca4b03a 	or	r18,r3,r18
81127df0:	a8800005 	stb	r2,0(r21)
81127df4:	94c4b03a 	or	r2,r18,r19
81127df8:	103ff51e 	bne	r2,zero,81127dd0 <__reset+0xfb107dd0>
81127dfc:	003e5906 	br	81127764 <__reset+0xfb107764>
81127e00:	d9402117 	ldw	r5,132(sp)
81127e04:	d9002017 	ldw	r4,128(sp)
81127e08:	d9801a04 	addi	r6,sp,104
81127e0c:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127e10:	103f891e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127e14:	d8801c17 	ldw	r2,112(sp)
81127e18:	d811883a 	mov	r8,sp
81127e1c:	003f9506 	br	81127c74 <__reset+0xfb107c74>
81127e20:	d9402117 	ldw	r5,132(sp)
81127e24:	d9002017 	ldw	r4,128(sp)
81127e28:	d9801a04 	addi	r6,sp,104
81127e2c:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127e30:	103f811e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127e34:	d811883a 	mov	r8,sp
81127e38:	003ced06 	br	811271f0 <__reset+0xfb1071f0>
81127e3c:	d9402117 	ldw	r5,132(sp)
81127e40:	d9002017 	ldw	r4,128(sp)
81127e44:	d9801a04 	addi	r6,sp,104
81127e48:	da402c15 	stw	r9,176(sp)
81127e4c:	db802a15 	stw	r14,168(sp)
81127e50:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127e54:	da402c17 	ldw	r9,176(sp)
81127e58:	db802a17 	ldw	r14,168(sp)
81127e5c:	103f761e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127e60:	d9401b17 	ldw	r5,108(sp)
81127e64:	d8801c17 	ldw	r2,112(sp)
81127e68:	d811883a 	mov	r8,sp
81127e6c:	29000044 	addi	r4,r5,1
81127e70:	003d5b06 	br	811273e0 <__reset+0xfb1073e0>
81127e74:	d9402117 	ldw	r5,132(sp)
81127e78:	d9002017 	ldw	r4,128(sp)
81127e7c:	d9801a04 	addi	r6,sp,104
81127e80:	da402c15 	stw	r9,176(sp)
81127e84:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127e88:	da402c17 	ldw	r9,176(sp)
81127e8c:	103f6a1e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127e90:	d9401b17 	ldw	r5,108(sp)
81127e94:	d8801c17 	ldw	r2,112(sp)
81127e98:	d811883a 	mov	r8,sp
81127e9c:	29000044 	addi	r4,r5,1
81127ea0:	003f1006 	br	81127ae4 <__reset+0xfb107ae4>
81127ea4:	1000c31e 	bne	r2,zero,811281b4 <___vfiprintf_internal_r+0x12d4>
81127ea8:	01000044 	movi	r4,1
81127eac:	000b883a 	mov	r5,zero
81127eb0:	d811883a 	mov	r8,sp
81127eb4:	003f0d06 	br	81127aec <__reset+0xfb107aec>
81127eb8:	d9402117 	ldw	r5,132(sp)
81127ebc:	d9002017 	ldw	r4,128(sp)
81127ec0:	d9801a04 	addi	r6,sp,104
81127ec4:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81127ec8:	103f5b1e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
81127ecc:	d9001b17 	ldw	r4,108(sp)
81127ed0:	d8801c17 	ldw	r2,112(sp)
81127ed4:	d811883a 	mov	r8,sp
81127ed8:	21000044 	addi	r4,r4,1
81127edc:	003d8006 	br	811274e0 <__reset+0xfb1074e0>
81127ee0:	01204534 	movhi	r4,33044
81127ee4:	21173304 	addi	r4,r4,23756
81127ee8:	d9002615 	stw	r4,152(sp)
81127eec:	d8c02215 	stw	r3,136(sp)
81127ef0:	1029883a 	mov	r20,r2
81127ef4:	94c4b03a 	or	r2,r18,r19
81127ef8:	103fb21e 	bne	r2,zero,81127dc4 <__reset+0xfb107dc4>
81127efc:	0039883a 	mov	fp,zero
81127f00:	00800084 	movi	r2,2
81127f04:	003e6b06 	br	811278b4 <__reset+0xfb1078b4>
81127f08:	da802217 	ldw	r10,136(sp)
81127f0c:	d8001d85 	stb	zero,118(sp)
81127f10:	0027883a 	mov	r19,zero
81127f14:	50800104 	addi	r2,r10,4
81127f18:	54800017 	ldw	r18,0(r10)
81127f1c:	483e6016 	blt	r9,zero,811278a0 <__reset+0xfb1078a0>
81127f20:	00ffdfc4 	movi	r3,-129
81127f24:	d8802215 	stw	r2,136(sp)
81127f28:	a0e8703a 	and	r20,r20,r3
81127f2c:	0039883a 	mov	fp,zero
81127f30:	903ebb26 	beq	r18,zero,81127a20 <__reset+0xfb107a20>
81127f34:	00800244 	movi	r2,9
81127f38:	14bdee36 	bltu	r2,r18,811276f4 <__reset+0xfb1076f4>
81127f3c:	003eba06 	br	81127a28 <__reset+0xfb107a28>
81127f40:	00800c04 	movi	r2,48
81127f44:	d8c01d45 	stb	r3,117(sp)
81127f48:	d8801d05 	stb	r2,116(sp)
81127f4c:	d8001d85 	stb	zero,118(sp)
81127f50:	a0c00094 	ori	r3,r20,2
81127f54:	4800a916 	blt	r9,zero,811281fc <___vfiprintf_internal_r+0x131c>
81127f58:	00bfdfc4 	movi	r2,-129
81127f5c:	a096703a 	and	r11,r20,r2
81127f60:	5d000094 	ori	r20,r11,2
81127f64:	0039883a 	mov	fp,zero
81127f68:	003f9706 	br	81127dc8 <__reset+0xfb107dc8>
81127f6c:	8025883a 	mov	r18,r16
81127f70:	003c2e06 	br	8112702c <__reset+0xfb10702c>
81127f74:	00a04534 	movhi	r2,33044
81127f78:	10973304 	addi	r2,r2,23756
81127f7c:	0039883a 	mov	fp,zero
81127f80:	d8802615 	stw	r2,152(sp)
81127f84:	003f9006 	br	81127dc8 <__reset+0xfb107dc8>
81127f88:	04a5c83a 	sub	r18,zero,r18
81127f8c:	07000b44 	movi	fp,45
81127f90:	9004c03a 	cmpne	r2,r18,zero
81127f94:	04e7c83a 	sub	r19,zero,r19
81127f98:	df001d85 	stb	fp,118(sp)
81127f9c:	98a7c83a 	sub	r19,r19,r2
81127fa0:	48009f16 	blt	r9,zero,81128220 <___vfiprintf_internal_r+0x1340>
81127fa4:	00bfdfc4 	movi	r2,-129
81127fa8:	a0a8703a 	and	r20,r20,r2
81127fac:	003dd006 	br	811276f0 <__reset+0xfb1076f0>
81127fb0:	70004c26 	beq	r14,zero,811280e4 <___vfiprintf_internal_r+0x1204>
81127fb4:	00800084 	movi	r2,2
81127fb8:	d8c01d04 	addi	r3,sp,116
81127fbc:	d8c00015 	stw	r3,0(sp)
81127fc0:	d8800115 	stw	r2,4(sp)
81127fc4:	01000044 	movi	r4,1
81127fc8:	d811883a 	mov	r8,sp
81127fcc:	003f7306 	br	81127d9c <__reset+0xfb107d9c>
81127fd0:	a080100c 	andi	r2,r20,64
81127fd4:	da802217 	ldw	r10,136(sp)
81127fd8:	103e0626 	beq	r2,zero,811277f4 <__reset+0xfb1077f4>
81127fdc:	5480000f 	ldh	r18,0(r10)
81127fe0:	52800104 	addi	r10,r10,4
81127fe4:	da802215 	stw	r10,136(sp)
81127fe8:	9027d7fa 	srai	r19,r18,31
81127fec:	9805883a 	mov	r2,r19
81127ff0:	003db806 	br	811276d4 <__reset+0xfb1076d4>
81127ff4:	a080040c 	andi	r2,r20,16
81127ff8:	1000091e 	bne	r2,zero,81128020 <___vfiprintf_internal_r+0x1140>
81127ffc:	a2c0100c 	andi	r11,r20,64
81128000:	58000726 	beq	r11,zero,81128020 <___vfiprintf_internal_r+0x1140>
81128004:	da802217 	ldw	r10,136(sp)
81128008:	50800017 	ldw	r2,0(r10)
8112800c:	52800104 	addi	r10,r10,4
81128010:	da802215 	stw	r10,136(sp)
81128014:	da802317 	ldw	r10,140(sp)
81128018:	1280000d 	sth	r10,0(r2)
8112801c:	003be706 	br	81126fbc <__reset+0xfb106fbc>
81128020:	da802217 	ldw	r10,136(sp)
81128024:	50800017 	ldw	r2,0(r10)
81128028:	52800104 	addi	r10,r10,4
8112802c:	da802215 	stw	r10,136(sp)
81128030:	da802317 	ldw	r10,140(sp)
81128034:	12800015 	stw	r10,0(r2)
81128038:	003be006 	br	81126fbc <__reset+0xfb106fbc>
8112803c:	a080100c 	andi	r2,r20,64
81128040:	da802217 	ldw	r10,136(sp)
81128044:	10003026 	beq	r2,zero,81128108 <___vfiprintf_internal_r+0x1228>
81128048:	5480000b 	ldhu	r18,0(r10)
8112804c:	52800104 	addi	r10,r10,4
81128050:	0027883a 	mov	r19,zero
81128054:	da802215 	stw	r10,136(sp)
81128058:	003d8006 	br	8112765c <__reset+0xfb10765c>
8112805c:	80c00007 	ldb	r3,0(r16)
81128060:	003c0006 	br	81127064 <__reset+0xfb107064>
81128064:	a080100c 	andi	r2,r20,64
81128068:	d8001d85 	stb	zero,118(sp)
8112806c:	da802217 	ldw	r10,136(sp)
81128070:	1000201e 	bne	r2,zero,811280f4 <___vfiprintf_internal_r+0x1214>
81128074:	50800104 	addi	r2,r10,4
81128078:	54800017 	ldw	r18,0(r10)
8112807c:	0027883a 	mov	r19,zero
81128080:	483def0e 	bge	r9,zero,81127840 <__reset+0xfb107840>
81128084:	94c6b03a 	or	r3,r18,r19
81128088:	d8802215 	stw	r2,136(sp)
8112808c:	183d4e1e 	bne	r3,zero,811275c8 <__reset+0xfb1075c8>
81128090:	0039883a 	mov	fp,zero
81128094:	0005883a 	mov	r2,zero
81128098:	003e0606 	br	811278b4 <__reset+0xfb1078b4>
8112809c:	d9402117 	ldw	r5,132(sp)
811280a0:	d9002017 	ldw	r4,128(sp)
811280a4:	d9801a04 	addi	r6,sp,104
811280a8:	da402c15 	stw	r9,176(sp)
811280ac:	db802a15 	stw	r14,168(sp)
811280b0:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
811280b4:	da402c17 	ldw	r9,176(sp)
811280b8:	db802a17 	ldw	r14,168(sp)
811280bc:	103ede1e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
811280c0:	d9401b17 	ldw	r5,108(sp)
811280c4:	d8801c17 	ldw	r2,112(sp)
811280c8:	d811883a 	mov	r8,sp
811280cc:	29000044 	addi	r4,r5,1
811280d0:	003e7406 	br	81127aa4 <__reset+0xfb107aa4>
811280d4:	00bfffc4 	movi	r2,-1
811280d8:	003c5806 	br	8112723c <__reset+0xfb10723c>
811280dc:	d811883a 	mov	r8,sp
811280e0:	003ee806 	br	81127c84 <__reset+0xfb107c84>
811280e4:	000b883a 	mov	r5,zero
811280e8:	01000044 	movi	r4,1
811280ec:	d811883a 	mov	r8,sp
811280f0:	003e7c06 	br	81127ae4 <__reset+0xfb107ae4>
811280f4:	50800104 	addi	r2,r10,4
811280f8:	5480000b 	ldhu	r18,0(r10)
811280fc:	0027883a 	mov	r19,zero
81128100:	483dcf0e 	bge	r9,zero,81127840 <__reset+0xfb107840>
81128104:	003fdf06 	br	81128084 <__reset+0xfb108084>
81128108:	54800017 	ldw	r18,0(r10)
8112810c:	52800104 	addi	r10,r10,4
81128110:	0027883a 	mov	r19,zero
81128114:	da802215 	stw	r10,136(sp)
81128118:	003d5006 	br	8112765c <__reset+0xfb10765c>
8112811c:	50800104 	addi	r2,r10,4
81128120:	5480000b 	ldhu	r18,0(r10)
81128124:	0027883a 	mov	r19,zero
81128128:	483f7d0e 	bge	r9,zero,81127f20 <__reset+0xfb107f20>
8112812c:	003ddc06 	br	811278a0 <__reset+0xfb1078a0>
81128130:	d8c02215 	stw	r3,136(sp)
81128134:	0039883a 	mov	fp,zero
81128138:	003ddb06 	br	811278a8 <__reset+0xfb1078a8>
8112813c:	02a04534 	movhi	r10,33044
81128140:	5297c504 	addi	r10,r10,24340
81128144:	da802415 	stw	r10,144(sp)
81128148:	003e8306 	br	81127b58 <__reset+0xfb107b58>
8112814c:	d8801c17 	ldw	r2,112(sp)
81128150:	dd002117 	ldw	r20,132(sp)
81128154:	103eb926 	beq	r2,zero,81127c3c <__reset+0xfb107c3c>
81128158:	d9002017 	ldw	r4,128(sp)
8112815c:	d9801a04 	addi	r6,sp,104
81128160:	a00b883a 	mov	r5,r20
81128164:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
81128168:	003eb406 	br	81127c3c <__reset+0xfb107c3c>
8112816c:	80c00043 	ldbu	r3,1(r16)
81128170:	a5000814 	ori	r20,r20,32
81128174:	84000044 	addi	r16,r16,1
81128178:	18c03fcc 	andi	r3,r3,255
8112817c:	18c0201c 	xori	r3,r3,128
81128180:	18ffe004 	addi	r3,r3,-128
81128184:	003bb706 	br	81127064 <__reset+0xfb107064>
81128188:	a809883a 	mov	r4,r21
8112818c:	d8c02a15 	stw	r3,168(sp)
81128190:	da002b15 	stw	r8,172(sp)
81128194:	11187c00 	call	811187c0 <strlen>
81128198:	d8c02a17 	ldw	r3,168(sp)
8112819c:	1027883a 	mov	r19,r2
811281a0:	df001d83 	ldbu	fp,118(sp)
811281a4:	d8c02215 	stw	r3,136(sp)
811281a8:	0013883a 	mov	r9,zero
811281ac:	da002b17 	ldw	r8,172(sp)
811281b0:	003c4d06 	br	811272e8 <__reset+0xfb1072e8>
811281b4:	d9402117 	ldw	r5,132(sp)
811281b8:	d9002017 	ldw	r4,128(sp)
811281bc:	d9801a04 	addi	r6,sp,104
811281c0:	da402c15 	stw	r9,176(sp)
811281c4:	1126dc40 	call	81126dc4 <__sprint_r.part.0>
811281c8:	da402c17 	ldw	r9,176(sp)
811281cc:	103e9a1e 	bne	r2,zero,81127c38 <__reset+0xfb107c38>
811281d0:	d9401b17 	ldw	r5,108(sp)
811281d4:	d8801c17 	ldw	r2,112(sp)
811281d8:	d811883a 	mov	r8,sp
811281dc:	29000044 	addi	r4,r5,1
811281e0:	003e4206 	br	81127aec <__reset+0xfb107aec>
811281e4:	d9401b17 	ldw	r5,108(sp)
811281e8:	01204534 	movhi	r4,33044
811281ec:	2117c904 	addi	r4,r4,24356
811281f0:	d9002415 	stw	r4,144(sp)
811281f4:	29400044 	addi	r5,r5,1
811281f8:	003c6d06 	br	811273b0 <__reset+0xfb1073b0>
811281fc:	0039883a 	mov	fp,zero
81128200:	00800084 	movi	r2,2
81128204:	10803fcc 	andi	r2,r2,255
81128208:	01000044 	movi	r4,1
8112820c:	11001e26 	beq	r2,r4,81128288 <___vfiprintf_internal_r+0x13a8>
81128210:	01000084 	movi	r4,2
81128214:	11001e1e 	bne	r2,r4,81128290 <___vfiprintf_internal_r+0x13b0>
81128218:	1829883a 	mov	r20,r3
8112821c:	003eea06 	br	81127dc8 <__reset+0xfb107dc8>
81128220:	a007883a 	mov	r3,r20
81128224:	00800044 	movi	r2,1
81128228:	003ff606 	br	81128204 <__reset+0xfb108204>
8112822c:	00800184 	movi	r2,6
81128230:	1240012e 	bgeu	r2,r9,81128238 <___vfiprintf_internal_r+0x1358>
81128234:	1013883a 	mov	r9,r2
81128238:	4827883a 	mov	r19,r9
8112823c:	4825883a 	mov	r18,r9
81128240:	48001516 	blt	r9,zero,81128298 <___vfiprintf_internal_r+0x13b8>
81128244:	05604534 	movhi	r21,33044
81128248:	d8c02215 	stw	r3,136(sp)
8112824c:	ad573804 	addi	r21,r21,23776
81128250:	003d1406 	br	811276a4 <__reset+0xfb1076a4>
81128254:	02a04534 	movhi	r10,33044
81128258:	5297c504 	addi	r10,r10,24340
8112825c:	da802415 	stw	r10,144(sp)
81128260:	200d883a 	mov	r6,r4
81128264:	003c9106 	br	811274ac <__reset+0xfb1074ac>
81128268:	5021883a 	mov	r16,r10
8112826c:	0013883a 	mov	r9,zero
81128270:	003b7d06 	br	81127068 <__reset+0xfb107068>
81128274:	4827883a 	mov	r19,r9
81128278:	df001d83 	ldbu	fp,118(sp)
8112827c:	d8c02215 	stw	r3,136(sp)
81128280:	0013883a 	mov	r9,zero
81128284:	003c1806 	br	811272e8 <__reset+0xfb1072e8>
81128288:	1829883a 	mov	r20,r3
8112828c:	003d1806 	br	811276f0 <__reset+0xfb1076f0>
81128290:	1829883a 	mov	r20,r3
81128294:	003ccd06 	br	811275cc <__reset+0xfb1075cc>
81128298:	0025883a 	mov	r18,zero
8112829c:	003fe906 	br	81128244 <__reset+0xfb108244>
811282a0:	d8802217 	ldw	r2,136(sp)
811282a4:	80c00043 	ldbu	r3,1(r16)
811282a8:	5021883a 	mov	r16,r10
811282ac:	12400017 	ldw	r9,0(r2)
811282b0:	10800104 	addi	r2,r2,4
811282b4:	d8802215 	stw	r2,136(sp)
811282b8:	483faf0e 	bge	r9,zero,81128178 <__reset+0xfb108178>
811282bc:	18c03fcc 	andi	r3,r3,255
811282c0:	18c0201c 	xori	r3,r3,128
811282c4:	027fffc4 	movi	r9,-1
811282c8:	18ffe004 	addi	r3,r3,-128
811282cc:	003b6506 	br	81127064 <__reset+0xfb107064>
811282d0:	d9c01d85 	stb	r7,118(sp)
811282d4:	003ca006 	br	81127558 <__reset+0xfb107558>
811282d8:	d9c01d85 	stb	r7,118(sp)
811282dc:	003cad06 	br	81127594 <__reset+0xfb107594>
811282e0:	d9c01d85 	stb	r7,118(sp)
811282e4:	003d7d06 	br	811278dc <__reset+0xfb1078dc>
811282e8:	d9c01d85 	stb	r7,118(sp)
811282ec:	003d5f06 	br	8112786c <__reset+0xfb10786c>
811282f0:	a080004c 	andi	r2,r20,1
811282f4:	0039883a 	mov	fp,zero
811282f8:	10000526 	beq	r2,zero,81128310 <___vfiprintf_internal_r+0x1430>
811282fc:	00800c04 	movi	r2,48
81128300:	d88019c5 	stb	r2,103(sp)
81128304:	dcc02717 	ldw	r19,156(sp)
81128308:	dd4019c4 	addi	r21,sp,103
8112830c:	003bf606 	br	811272e8 <__reset+0xfb1072e8>
81128310:	0027883a 	mov	r19,zero
81128314:	dd401a04 	addi	r21,sp,104
81128318:	003bf306 	br	811272e8 <__reset+0xfb1072e8>
8112831c:	d9c01d85 	stb	r7,118(sp)
81128320:	003dc806 	br	81127a44 <__reset+0xfb107a44>
81128324:	d9c01d85 	stb	r7,118(sp)
81128328:	003d3a06 	br	81127814 <__reset+0xfb107814>
8112832c:	d9c01d85 	stb	r7,118(sp)
81128330:	003d2a06 	br	811277dc <__reset+0xfb1077dc>
81128334:	d9c01d85 	stb	r7,118(sp)
81128338:	003cde06 	br	811276b4 <__reset+0xfb1076b4>
8112833c:	d9c01d85 	stb	r7,118(sp)
81128340:	003cbc06 	br	81127634 <__reset+0xfb107634>

81128344 <__vfiprintf_internal>:
81128344:	00a04574 	movhi	r2,33045
81128348:	10a10204 	addi	r2,r2,-31736
8112834c:	300f883a 	mov	r7,r6
81128350:	280d883a 	mov	r6,r5
81128354:	200b883a 	mov	r5,r4
81128358:	11000017 	ldw	r4,0(r2)
8112835c:	1126ee01 	jmpi	81126ee0 <___vfiprintf_internal_r>

81128360 <__sbprintf>:
81128360:	defee204 	addi	sp,sp,-1144
81128364:	de00012e 	bgeu	sp,et,8112836c <__sbprintf+0xc>
81128368:	003b68fa 	trap	3
8112836c:	2880030b 	ldhu	r2,12(r5)
81128370:	2ac01917 	ldw	r11,100(r5)
81128374:	2a80038b 	ldhu	r10,14(r5)
81128378:	2a400717 	ldw	r9,28(r5)
8112837c:	2a000917 	ldw	r8,36(r5)
81128380:	00c10004 	movi	r3,1024
81128384:	dc011a15 	stw	r16,1128(sp)
81128388:	10bfff4c 	andi	r2,r2,65533
8112838c:	2821883a 	mov	r16,r5
81128390:	d8cb883a 	add	r5,sp,r3
81128394:	dc811c15 	stw	r18,1136(sp)
81128398:	dc411b15 	stw	r17,1132(sp)
8112839c:	dfc11d15 	stw	ra,1140(sp)
811283a0:	2025883a 	mov	r18,r4
811283a4:	d881030d 	sth	r2,1036(sp)
811283a8:	dac11915 	stw	r11,1124(sp)
811283ac:	da81038d 	sth	r10,1038(sp)
811283b0:	da410715 	stw	r9,1052(sp)
811283b4:	da010915 	stw	r8,1060(sp)
811283b8:	dec10015 	stw	sp,1024(sp)
811283bc:	dec10415 	stw	sp,1040(sp)
811283c0:	d8c10215 	stw	r3,1032(sp)
811283c4:	d8c10515 	stw	r3,1044(sp)
811283c8:	d8010615 	stw	zero,1048(sp)
811283cc:	1126ee00 	call	81126ee0 <___vfiprintf_internal_r>
811283d0:	1023883a 	mov	r17,r2
811283d4:	10000416 	blt	r2,zero,811283e8 <__sbprintf+0x88>
811283d8:	d9410004 	addi	r5,sp,1024
811283dc:	9009883a 	mov	r4,r18
811283e0:	11206980 	call	81120698 <_fflush_r>
811283e4:	10000d1e 	bne	r2,zero,8112841c <__sbprintf+0xbc>
811283e8:	d881030b 	ldhu	r2,1036(sp)
811283ec:	1080100c 	andi	r2,r2,64
811283f0:	10000326 	beq	r2,zero,81128400 <__sbprintf+0xa0>
811283f4:	8080030b 	ldhu	r2,12(r16)
811283f8:	10801014 	ori	r2,r2,64
811283fc:	8080030d 	sth	r2,12(r16)
81128400:	8805883a 	mov	r2,r17
81128404:	dfc11d17 	ldw	ra,1140(sp)
81128408:	dc811c17 	ldw	r18,1136(sp)
8112840c:	dc411b17 	ldw	r17,1132(sp)
81128410:	dc011a17 	ldw	r16,1128(sp)
81128414:	dec11e04 	addi	sp,sp,1144
81128418:	f800283a 	ret
8112841c:	047fffc4 	movi	r17,-1
81128420:	003ff106 	br	811283e8 <__reset+0xfb1083e8>

81128424 <_calloc_r>:
81128424:	298b383a 	mul	r5,r5,r6
81128428:	defffe04 	addi	sp,sp,-8
8112842c:	de00012e 	bgeu	sp,et,81128434 <_calloc_r+0x10>
81128430:	003b68fa 	trap	3
81128434:	dfc00115 	stw	ra,4(sp)
81128438:	dc000015 	stw	r16,0(sp)
8112843c:	11174b80 	call	811174b8 <_malloc_r>
81128440:	10002926 	beq	r2,zero,811284e8 <_calloc_r+0xc4>
81128444:	11bfff17 	ldw	r6,-4(r2)
81128448:	1021883a 	mov	r16,r2
8112844c:	00bfff04 	movi	r2,-4
81128450:	308c703a 	and	r6,r6,r2
81128454:	00c00904 	movi	r3,36
81128458:	308d883a 	add	r6,r6,r2
8112845c:	19801636 	bltu	r3,r6,811284b8 <_calloc_r+0x94>
81128460:	008004c4 	movi	r2,19
81128464:	11800b2e 	bgeu	r2,r6,81128494 <_calloc_r+0x70>
81128468:	80000015 	stw	zero,0(r16)
8112846c:	80000115 	stw	zero,4(r16)
81128470:	008006c4 	movi	r2,27
81128474:	11801a2e 	bgeu	r2,r6,811284e0 <_calloc_r+0xbc>
81128478:	80000215 	stw	zero,8(r16)
8112847c:	80000315 	stw	zero,12(r16)
81128480:	30c0151e 	bne	r6,r3,811284d8 <_calloc_r+0xb4>
81128484:	80000415 	stw	zero,16(r16)
81128488:	80800604 	addi	r2,r16,24
8112848c:	80000515 	stw	zero,20(r16)
81128490:	00000106 	br	81128498 <_calloc_r+0x74>
81128494:	8005883a 	mov	r2,r16
81128498:	10000015 	stw	zero,0(r2)
8112849c:	10000115 	stw	zero,4(r2)
811284a0:	10000215 	stw	zero,8(r2)
811284a4:	8005883a 	mov	r2,r16
811284a8:	dfc00117 	ldw	ra,4(sp)
811284ac:	dc000017 	ldw	r16,0(sp)
811284b0:	dec00204 	addi	sp,sp,8
811284b4:	f800283a 	ret
811284b8:	000b883a 	mov	r5,zero
811284bc:	8009883a 	mov	r4,r16
811284c0:	1117e1c0 	call	81117e1c <memset>
811284c4:	8005883a 	mov	r2,r16
811284c8:	dfc00117 	ldw	ra,4(sp)
811284cc:	dc000017 	ldw	r16,0(sp)
811284d0:	dec00204 	addi	sp,sp,8
811284d4:	f800283a 	ret
811284d8:	80800404 	addi	r2,r16,16
811284dc:	003fee06 	br	81128498 <__reset+0xfb108498>
811284e0:	80800204 	addi	r2,r16,8
811284e4:	003fec06 	br	81128498 <__reset+0xfb108498>
811284e8:	0005883a 	mov	r2,zero
811284ec:	003fee06 	br	811284a8 <__reset+0xfb1084a8>

811284f0 <_fclose_r>:
811284f0:	28003b26 	beq	r5,zero,811285e0 <_fclose_r+0xf0>
811284f4:	defffc04 	addi	sp,sp,-16
811284f8:	de00012e 	bgeu	sp,et,81128500 <_fclose_r+0x10>
811284fc:	003b68fa 	trap	3
81128500:	dc400115 	stw	r17,4(sp)
81128504:	dc000015 	stw	r16,0(sp)
81128508:	dfc00315 	stw	ra,12(sp)
8112850c:	dc800215 	stw	r18,8(sp)
81128510:	2023883a 	mov	r17,r4
81128514:	2821883a 	mov	r16,r5
81128518:	20000226 	beq	r4,zero,81128524 <_fclose_r+0x34>
8112851c:	20800e17 	ldw	r2,56(r4)
81128520:	10002726 	beq	r2,zero,811285c0 <_fclose_r+0xd0>
81128524:	8080030f 	ldh	r2,12(r16)
81128528:	1000071e 	bne	r2,zero,81128548 <_fclose_r+0x58>
8112852c:	0005883a 	mov	r2,zero
81128530:	dfc00317 	ldw	ra,12(sp)
81128534:	dc800217 	ldw	r18,8(sp)
81128538:	dc400117 	ldw	r17,4(sp)
8112853c:	dc000017 	ldw	r16,0(sp)
81128540:	dec00404 	addi	sp,sp,16
81128544:	f800283a 	ret
81128548:	800b883a 	mov	r5,r16
8112854c:	8809883a 	mov	r4,r17
81128550:	11204740 	call	81120474 <__sflush_r>
81128554:	1025883a 	mov	r18,r2
81128558:	80800b17 	ldw	r2,44(r16)
8112855c:	10000426 	beq	r2,zero,81128570 <_fclose_r+0x80>
81128560:	81400717 	ldw	r5,28(r16)
81128564:	8809883a 	mov	r4,r17
81128568:	103ee83a 	callr	r2
8112856c:	10001616 	blt	r2,zero,811285c8 <_fclose_r+0xd8>
81128570:	8080030b 	ldhu	r2,12(r16)
81128574:	1080200c 	andi	r2,r2,128
81128578:	1000151e 	bne	r2,zero,811285d0 <_fclose_r+0xe0>
8112857c:	81400c17 	ldw	r5,48(r16)
81128580:	28000526 	beq	r5,zero,81128598 <_fclose_r+0xa8>
81128584:	80801004 	addi	r2,r16,64
81128588:	28800226 	beq	r5,r2,81128594 <_fclose_r+0xa4>
8112858c:	8809883a 	mov	r4,r17
81128590:	1120f2c0 	call	81120f2c <_free_r>
81128594:	80000c15 	stw	zero,48(r16)
81128598:	81401117 	ldw	r5,68(r16)
8112859c:	28000326 	beq	r5,zero,811285ac <_fclose_r+0xbc>
811285a0:	8809883a 	mov	r4,r17
811285a4:	1120f2c0 	call	81120f2c <_free_r>
811285a8:	80001115 	stw	zero,68(r16)
811285ac:	1120aa40 	call	81120aa4 <__sfp_lock_acquire>
811285b0:	8000030d 	sth	zero,12(r16)
811285b4:	1120aa80 	call	81120aa8 <__sfp_lock_release>
811285b8:	9005883a 	mov	r2,r18
811285bc:	003fdc06 	br	81128530 <__reset+0xfb108530>
811285c0:	1120a940 	call	81120a94 <__sinit>
811285c4:	003fd706 	br	81128524 <__reset+0xfb108524>
811285c8:	04bfffc4 	movi	r18,-1
811285cc:	003fe806 	br	81128570 <__reset+0xfb108570>
811285d0:	81400417 	ldw	r5,16(r16)
811285d4:	8809883a 	mov	r4,r17
811285d8:	1120f2c0 	call	81120f2c <_free_r>
811285dc:	003fe706 	br	8112857c <__reset+0xfb10857c>
811285e0:	0005883a 	mov	r2,zero
811285e4:	f800283a 	ret

811285e8 <fclose>:
811285e8:	00a04574 	movhi	r2,33045
811285ec:	10a10204 	addi	r2,r2,-31736
811285f0:	200b883a 	mov	r5,r4
811285f4:	11000017 	ldw	r4,0(r2)
811285f8:	11284f01 	jmpi	811284f0 <_fclose_r>

811285fc <__fputwc>:
811285fc:	defff804 	addi	sp,sp,-32
81128600:	de00012e 	bgeu	sp,et,81128608 <__fputwc+0xc>
81128604:	003b68fa 	trap	3
81128608:	dcc00415 	stw	r19,16(sp)
8112860c:	dc800315 	stw	r18,12(sp)
81128610:	dc000115 	stw	r16,4(sp)
81128614:	dfc00715 	stw	ra,28(sp)
81128618:	dd400615 	stw	r21,24(sp)
8112861c:	dd000515 	stw	r20,20(sp)
81128620:	dc400215 	stw	r17,8(sp)
81128624:	2027883a 	mov	r19,r4
81128628:	2825883a 	mov	r18,r5
8112862c:	3021883a 	mov	r16,r6
81128630:	11219bc0 	call	811219bc <__locale_mb_cur_max>
81128634:	00c00044 	movi	r3,1
81128638:	10c03e26 	beq	r2,r3,81128734 <__fputwc+0x138>
8112863c:	81c01704 	addi	r7,r16,92
81128640:	900d883a 	mov	r6,r18
81128644:	d80b883a 	mov	r5,sp
81128648:	9809883a 	mov	r4,r19
8112864c:	11294800 	call	81129480 <_wcrtomb_r>
81128650:	1029883a 	mov	r20,r2
81128654:	00bfffc4 	movi	r2,-1
81128658:	a0802026 	beq	r20,r2,811286dc <__fputwc+0xe0>
8112865c:	d9400003 	ldbu	r5,0(sp)
81128660:	a0001c26 	beq	r20,zero,811286d4 <__fputwc+0xd8>
81128664:	0023883a 	mov	r17,zero
81128668:	05400284 	movi	r21,10
8112866c:	00000906 	br	81128694 <__fputwc+0x98>
81128670:	80800017 	ldw	r2,0(r16)
81128674:	11400005 	stb	r5,0(r2)
81128678:	80c00017 	ldw	r3,0(r16)
8112867c:	18c00044 	addi	r3,r3,1
81128680:	80c00015 	stw	r3,0(r16)
81128684:	8c400044 	addi	r17,r17,1
81128688:	dc45883a 	add	r2,sp,r17
8112868c:	8d00112e 	bgeu	r17,r20,811286d4 <__fputwc+0xd8>
81128690:	11400003 	ldbu	r5,0(r2)
81128694:	80c00217 	ldw	r3,8(r16)
81128698:	18ffffc4 	addi	r3,r3,-1
8112869c:	80c00215 	stw	r3,8(r16)
811286a0:	183ff30e 	bge	r3,zero,81128670 <__reset+0xfb108670>
811286a4:	80800617 	ldw	r2,24(r16)
811286a8:	18801916 	blt	r3,r2,81128710 <__fputwc+0x114>
811286ac:	80800017 	ldw	r2,0(r16)
811286b0:	11400005 	stb	r5,0(r2)
811286b4:	80800017 	ldw	r2,0(r16)
811286b8:	10c00003 	ldbu	r3,0(r2)
811286bc:	10800044 	addi	r2,r2,1
811286c0:	1d402326 	beq	r3,r21,81128750 <__fputwc+0x154>
811286c4:	80800015 	stw	r2,0(r16)
811286c8:	8c400044 	addi	r17,r17,1
811286cc:	dc45883a 	add	r2,sp,r17
811286d0:	8d3fef36 	bltu	r17,r20,81128690 <__reset+0xfb108690>
811286d4:	9005883a 	mov	r2,r18
811286d8:	00000406 	br	811286ec <__fputwc+0xf0>
811286dc:	80c0030b 	ldhu	r3,12(r16)
811286e0:	a005883a 	mov	r2,r20
811286e4:	18c01014 	ori	r3,r3,64
811286e8:	80c0030d 	sth	r3,12(r16)
811286ec:	dfc00717 	ldw	ra,28(sp)
811286f0:	dd400617 	ldw	r21,24(sp)
811286f4:	dd000517 	ldw	r20,20(sp)
811286f8:	dcc00417 	ldw	r19,16(sp)
811286fc:	dc800317 	ldw	r18,12(sp)
81128700:	dc400217 	ldw	r17,8(sp)
81128704:	dc000117 	ldw	r16,4(sp)
81128708:	dec00804 	addi	sp,sp,32
8112870c:	f800283a 	ret
81128710:	800d883a 	mov	r6,r16
81128714:	29403fcc 	andi	r5,r5,255
81128718:	9809883a 	mov	r4,r19
8112871c:	111e85c0 	call	8111e85c <__swbuf_r>
81128720:	10bfffe0 	cmpeqi	r2,r2,-1
81128724:	10803fcc 	andi	r2,r2,255
81128728:	103fd626 	beq	r2,zero,81128684 <__reset+0xfb108684>
8112872c:	00bfffc4 	movi	r2,-1
81128730:	003fee06 	br	811286ec <__reset+0xfb1086ec>
81128734:	90ffffc4 	addi	r3,r18,-1
81128738:	01003f84 	movi	r4,254
8112873c:	20ffbf36 	bltu	r4,r3,8112863c <__reset+0xfb10863c>
81128740:	900b883a 	mov	r5,r18
81128744:	dc800005 	stb	r18,0(sp)
81128748:	1029883a 	mov	r20,r2
8112874c:	003fc506 	br	81128664 <__reset+0xfb108664>
81128750:	800d883a 	mov	r6,r16
81128754:	a80b883a 	mov	r5,r21
81128758:	9809883a 	mov	r4,r19
8112875c:	111e85c0 	call	8111e85c <__swbuf_r>
81128760:	10bfffe0 	cmpeqi	r2,r2,-1
81128764:	003fef06 	br	81128724 <__reset+0xfb108724>

81128768 <_fputwc_r>:
81128768:	3080030b 	ldhu	r2,12(r6)
8112876c:	10c8000c 	andi	r3,r2,8192
81128770:	1800051e 	bne	r3,zero,81128788 <_fputwc_r+0x20>
81128774:	30c01917 	ldw	r3,100(r6)
81128778:	10880014 	ori	r2,r2,8192
8112877c:	3080030d 	sth	r2,12(r6)
81128780:	18880014 	ori	r2,r3,8192
81128784:	30801915 	stw	r2,100(r6)
81128788:	11285fc1 	jmpi	811285fc <__fputwc>

8112878c <fputwc>:
8112878c:	00a04574 	movhi	r2,33045
81128790:	defffc04 	addi	sp,sp,-16
81128794:	10a10204 	addi	r2,r2,-31736
81128798:	de00012e 	bgeu	sp,et,811287a0 <fputwc+0x14>
8112879c:	003b68fa 	trap	3
811287a0:	dc000115 	stw	r16,4(sp)
811287a4:	14000017 	ldw	r16,0(r2)
811287a8:	dc400215 	stw	r17,8(sp)
811287ac:	dfc00315 	stw	ra,12(sp)
811287b0:	2023883a 	mov	r17,r4
811287b4:	80000226 	beq	r16,zero,811287c0 <fputwc+0x34>
811287b8:	80800e17 	ldw	r2,56(r16)
811287bc:	10001026 	beq	r2,zero,81128800 <fputwc+0x74>
811287c0:	2880030b 	ldhu	r2,12(r5)
811287c4:	10c8000c 	andi	r3,r2,8192
811287c8:	1800051e 	bne	r3,zero,811287e0 <fputwc+0x54>
811287cc:	28c01917 	ldw	r3,100(r5)
811287d0:	10880014 	ori	r2,r2,8192
811287d4:	2880030d 	sth	r2,12(r5)
811287d8:	18880014 	ori	r2,r3,8192
811287dc:	28801915 	stw	r2,100(r5)
811287e0:	280d883a 	mov	r6,r5
811287e4:	8009883a 	mov	r4,r16
811287e8:	880b883a 	mov	r5,r17
811287ec:	dfc00317 	ldw	ra,12(sp)
811287f0:	dc400217 	ldw	r17,8(sp)
811287f4:	dc000117 	ldw	r16,4(sp)
811287f8:	dec00404 	addi	sp,sp,16
811287fc:	11285fc1 	jmpi	811285fc <__fputwc>
81128800:	8009883a 	mov	r4,r16
81128804:	d9400015 	stw	r5,0(sp)
81128808:	1120a940 	call	81120a94 <__sinit>
8112880c:	d9400017 	ldw	r5,0(sp)
81128810:	003feb06 	br	811287c0 <__reset+0xfb1087c0>

81128814 <rshift>:
81128814:	2807d17a 	srai	r3,r5,5
81128818:	20800417 	ldw	r2,16(r4)
8112881c:	22000504 	addi	r8,r4,20
81128820:	1880250e 	bge	r3,r2,811288b8 <rshift+0xa4>
81128824:	1085883a 	add	r2,r2,r2
81128828:	18c7883a 	add	r3,r3,r3
8112882c:	1085883a 	add	r2,r2,r2
81128830:	18c7883a 	add	r3,r3,r3
81128834:	294007cc 	andi	r5,r5,31
81128838:	4085883a 	add	r2,r8,r2
8112883c:	40c7883a 	add	r3,r8,r3
81128840:	28002026 	beq	r5,zero,811288c4 <rshift+0xb0>
81128844:	19800017 	ldw	r6,0(r3)
81128848:	02c00804 	movi	r11,32
8112884c:	19c00104 	addi	r7,r3,4
81128850:	5957c83a 	sub	r11,r11,r5
81128854:	314cd83a 	srl	r6,r6,r5
81128858:	38802c2e 	bgeu	r7,r2,8112890c <rshift+0xf8>
8112885c:	4015883a 	mov	r10,r8
81128860:	3a400017 	ldw	r9,0(r7)
81128864:	52800104 	addi	r10,r10,4
81128868:	39c00104 	addi	r7,r7,4
8112886c:	4ad2983a 	sll	r9,r9,r11
81128870:	498cb03a 	or	r6,r9,r6
81128874:	51bfff15 	stw	r6,-4(r10)
81128878:	39bfff17 	ldw	r6,-4(r7)
8112887c:	314cd83a 	srl	r6,r6,r5
81128880:	38bff736 	bltu	r7,r2,81128860 <__reset+0xfb108860>
81128884:	10c7c83a 	sub	r3,r2,r3
81128888:	18fffec4 	addi	r3,r3,-5
8112888c:	1806d0ba 	srli	r3,r3,2
81128890:	18c00044 	addi	r3,r3,1
81128894:	18c7883a 	add	r3,r3,r3
81128898:	18c7883a 	add	r3,r3,r3
8112889c:	40c7883a 	add	r3,r8,r3
811288a0:	19800015 	stw	r6,0(r3)
811288a4:	30000126 	beq	r6,zero,811288ac <rshift+0x98>
811288a8:	18c00104 	addi	r3,r3,4
811288ac:	1a05c83a 	sub	r2,r3,r8
811288b0:	1005d0ba 	srai	r2,r2,2
811288b4:	00001206 	br	81128900 <rshift+0xec>
811288b8:	20000415 	stw	zero,16(r4)
811288bc:	20000515 	stw	zero,20(r4)
811288c0:	f800283a 	ret
811288c4:	18bffc2e 	bgeu	r3,r2,811288b8 <__reset+0xfb1088b8>
811288c8:	180d883a 	mov	r6,r3
811288cc:	400b883a 	mov	r5,r8
811288d0:	31c00017 	ldw	r7,0(r6)
811288d4:	29400104 	addi	r5,r5,4
811288d8:	31800104 	addi	r6,r6,4
811288dc:	29ffff15 	stw	r7,-4(r5)
811288e0:	30bffb36 	bltu	r6,r2,811288d0 <__reset+0xfb1088d0>
811288e4:	00c6303a 	nor	r3,zero,r3
811288e8:	1885883a 	add	r2,r3,r2
811288ec:	1004d0ba 	srli	r2,r2,2
811288f0:	10800044 	addi	r2,r2,1
811288f4:	1085883a 	add	r2,r2,r2
811288f8:	1085883a 	add	r2,r2,r2
811288fc:	1005d0ba 	srai	r2,r2,2
81128900:	20800415 	stw	r2,16(r4)
81128904:	103fed26 	beq	r2,zero,811288bc <__reset+0xfb1088bc>
81128908:	f800283a 	ret
8112890c:	4007883a 	mov	r3,r8
81128910:	003fe306 	br	811288a0 <__reset+0xfb1088a0>

81128914 <__gethex>:
81128914:	deffeb04 	addi	sp,sp,-84
81128918:	de00012e 	bgeu	sp,et,81128920 <__gethex+0xc>
8112891c:	003b68fa 	trap	3
81128920:	dfc01415 	stw	ra,80(sp)
81128924:	dd801115 	stw	r22,68(sp)
81128928:	dcc00e15 	stw	r19,56(sp)
8112892c:	dc800d15 	stw	r18,52(sp)
81128930:	2827883a 	mov	r19,r5
81128934:	d9000115 	stw	r4,4(sp)
81128938:	d9800015 	stw	r6,0(sp)
8112893c:	d9c00415 	stw	r7,16(sp)
81128940:	df001315 	stw	fp,76(sp)
81128944:	ddc01215 	stw	r23,72(sp)
81128948:	dd401015 	stw	r21,64(sp)
8112894c:	dd000f15 	stw	r20,60(sp)
81128950:	dc400c15 	stw	r17,48(sp)
81128954:	dc000b15 	stw	r16,44(sp)
81128958:	11219e00 	call	811219e0 <_localeconv_r>
8112895c:	14800017 	ldw	r18,0(r2)
81128960:	9009883a 	mov	r4,r18
81128964:	11187c00 	call	811187c0 <strlen>
81128968:	98c00017 	ldw	r3,0(r19)
8112896c:	102d883a 	mov	r22,r2
81128970:	9085883a 	add	r2,r18,r2
81128974:	10bfffc3 	ldbu	r2,-1(r2)
81128978:	19000083 	ldbu	r4,2(r3)
8112897c:	d8800305 	stb	r2,12(sp)
81128980:	00800c04 	movi	r2,48
81128984:	2081521e 	bne	r4,r2,81128ed0 <__gethex+0x5bc>
81128988:	017fff84 	movi	r5,-2
8112898c:	188000c4 	addi	r2,r3,3
81128990:	28cbc83a 	sub	r5,r5,r3
81128994:	200d883a 	mov	r6,r4
81128998:	28a3883a 	add	r17,r5,r2
8112899c:	102b883a 	mov	r21,r2
811289a0:	10800044 	addi	r2,r2,1
811289a4:	113fffc3 	ldbu	r4,-1(r2)
811289a8:	21bffb26 	beq	r4,r6,81128998 <__reset+0xfb108998>
811289ac:	05204534 	movhi	r20,33044
811289b0:	a517cd04 	addi	r20,r20,24372
811289b4:	a109883a 	add	r4,r20,r4
811289b8:	20800003 	ldbu	r2,0(r4)
811289bc:	10008826 	beq	r2,zero,81128be0 <__gethex+0x2cc>
811289c0:	a8800003 	ldbu	r2,0(r21)
811289c4:	0015883a 	mov	r10,zero
811289c8:	002f883a 	mov	r23,zero
811289cc:	a085883a 	add	r2,r20,r2
811289d0:	10800003 	ldbu	r2,0(r2)
811289d4:	a821883a 	mov	r16,r21
811289d8:	10000526 	beq	r2,zero,811289f0 <__gethex+0xdc>
811289dc:	84000044 	addi	r16,r16,1
811289e0:	80800003 	ldbu	r2,0(r16)
811289e4:	a085883a 	add	r2,r20,r2
811289e8:	10800003 	ldbu	r2,0(r2)
811289ec:	103ffb1e 	bne	r2,zero,811289dc <__reset+0xfb1089dc>
811289f0:	b00d883a 	mov	r6,r22
811289f4:	900b883a 	mov	r5,r18
811289f8:	8009883a 	mov	r4,r16
811289fc:	da800a15 	stw	r10,40(sp)
81128a00:	11293b00 	call	811293b0 <strncmp>
81128a04:	da800a17 	ldw	r10,40(sp)
81128a08:	1000031e 	bne	r2,zero,81128a18 <__gethex+0x104>
81128a0c:	b8015226 	beq	r23,zero,81128f58 <__gethex+0x644>
81128a10:	80800003 	ldbu	r2,0(r16)
81128a14:	00000206 	br	81128a20 <__gethex+0x10c>
81128a18:	80800003 	ldbu	r2,0(r16)
81128a1c:	b8011f26 	beq	r23,zero,81128e9c <__gethex+0x588>
81128a20:	85efc83a 	sub	r23,r16,r23
81128a24:	bdef883a 	add	r23,r23,r23
81128a28:	bdef883a 	add	r23,r23,r23
81128a2c:	05efc83a 	sub	r23,zero,r23
81128a30:	10803fcc 	andi	r2,r2,255
81128a34:	01001404 	movi	r4,80
81128a38:	11008626 	beq	r2,r4,81128c54 <__gethex+0x340>
81128a3c:	01001c04 	movi	r4,112
81128a40:	11008426 	beq	r2,r4,81128c54 <__gethex+0x340>
81128a44:	8039883a 	mov	fp,r16
81128a48:	9c000015 	stw	r16,0(r19)
81128a4c:	5000711e 	bne	r10,zero,81128c14 <__gethex+0x300>
81128a50:	e545c83a 	sub	r2,fp,r21
81128a54:	10bfffc4 	addi	r2,r2,-1
81128a58:	010001c4 	movi	r4,7
81128a5c:	000b883a 	mov	r5,zero
81128a60:	2080030e 	bge	r4,r2,81128a70 <__gethex+0x15c>
81128a64:	1005d07a 	srai	r2,r2,1
81128a68:	29400044 	addi	r5,r5,1
81128a6c:	20bffd16 	blt	r4,r2,81128a64 <__reset+0xfb108a64>
81128a70:	d9000117 	ldw	r4,4(sp)
81128a74:	1121efc0 	call	81121efc <_Balloc>
81128a78:	10c00504 	addi	r3,r2,20
81128a7c:	d8c00215 	stw	r3,8(sp)
81128a80:	1021883a 	mov	r16,r2
81128a84:	af01732e 	bgeu	r21,fp,81129054 <__gethex+0x740>
81128a88:	dc400303 	ldbu	r17,12(sp)
81128a8c:	03400044 	movi	r13,1
81128a90:	1815883a 	mov	r10,r3
81128a94:	0013883a 	mov	r9,zero
81128a98:	0027883a 	mov	r19,zero
81128a9c:	6d9bc83a 	sub	r13,r13,r22
81128aa0:	02c00804 	movi	r11,32
81128aa4:	e0bfffc3 	ldbu	r2,-1(fp)
81128aa8:	e3bfffc4 	addi	r14,fp,-1
81128aac:	88803026 	beq	r17,r2,81128b70 <__gethex+0x25c>
81128ab0:	9ac04526 	beq	r19,r11,81128bc8 <__gethex+0x2b4>
81128ab4:	980b883a 	mov	r5,r19
81128ab8:	9cc00104 	addi	r19,r19,4
81128abc:	e13fffc3 	ldbu	r4,-1(fp)
81128ac0:	7039883a 	mov	fp,r14
81128ac4:	a109883a 	add	r4,r20,r4
81128ac8:	20800003 	ldbu	r2,0(r4)
81128acc:	108003cc 	andi	r2,r2,15
81128ad0:	1144983a 	sll	r2,r2,r5
81128ad4:	4892b03a 	or	r9,r9,r2
81128ad8:	af3ff236 	bltu	r21,fp,81128aa4 <__reset+0xfb108aa4>
81128adc:	d8c00217 	ldw	r3,8(sp)
81128ae0:	50800104 	addi	r2,r10,4
81128ae4:	52400015 	stw	r9,0(r10)
81128ae8:	10c5c83a 	sub	r2,r2,r3
81128aec:	1005d0ba 	srai	r2,r2,2
81128af0:	4809883a 	mov	r4,r9
81128af4:	80800415 	stw	r2,16(r16)
81128af8:	1022917a 	slli	r17,r2,5
81128afc:	11222080 	call	81122208 <__hi0bits>
81128b00:	d8c00017 	ldw	r3,0(sp)
81128b04:	8885c83a 	sub	r2,r17,r2
81128b08:	1c800017 	ldw	r18,0(r3)
81128b0c:	9080c716 	blt	r18,r2,81128e2c <__gethex+0x518>
81128b10:	1480e416 	blt	r2,r18,81128ea4 <__gethex+0x590>
81128b14:	0027883a 	mov	r19,zero
81128b18:	d8c00017 	ldw	r3,0(sp)
81128b1c:	18800217 	ldw	r2,8(r3)
81128b20:	15c08d16 	blt	r2,r23,81128d58 <__gethex+0x444>
81128b24:	d8c00017 	ldw	r3,0(sp)
81128b28:	18800117 	ldw	r2,4(r3)
81128b2c:	b880aa0e 	bge	r23,r2,81128dd8 <__gethex+0x4c4>
81128b30:	15efc83a 	sub	r23,r2,r23
81128b34:	bc80ed16 	blt	r23,r18,81128eec <__gethex+0x5d8>
81128b38:	18c00317 	ldw	r3,12(r3)
81128b3c:	01000084 	movi	r4,2
81128b40:	19014926 	beq	r3,r4,81129068 <__gethex+0x754>
81128b44:	010000c4 	movi	r4,3
81128b48:	19012e26 	beq	r3,r4,81129004 <__gethex+0x6f0>
81128b4c:	01000044 	movi	r4,1
81128b50:	19014826 	beq	r3,r4,81129074 <__gethex+0x760>
81128b54:	d9000117 	ldw	r4,4(sp)
81128b58:	800b883a 	mov	r5,r16
81128b5c:	1121fac0 	call	81121fac <_Bfree>
81128b60:	d8801517 	ldw	r2,84(sp)
81128b64:	10000015 	stw	zero,0(r2)
81128b68:	00801404 	movi	r2,80
81128b6c:	00002b06 	br	81128c1c <__gethex+0x308>
81128b70:	735f883a 	add	r15,r14,r13
81128b74:	7d7fce36 	bltu	r15,r21,81128ab0 <__reset+0xfb108ab0>
81128b78:	7809883a 	mov	r4,r15
81128b7c:	b00d883a 	mov	r6,r22
81128b80:	900b883a 	mov	r5,r18
81128b84:	da400515 	stw	r9,20(sp)
81128b88:	da800a15 	stw	r10,40(sp)
81128b8c:	dac00915 	stw	r11,36(sp)
81128b90:	db400815 	stw	r13,32(sp)
81128b94:	db800615 	stw	r14,24(sp)
81128b98:	dbc00715 	stw	r15,28(sp)
81128b9c:	11293b00 	call	811293b0 <strncmp>
81128ba0:	da400517 	ldw	r9,20(sp)
81128ba4:	da800a17 	ldw	r10,40(sp)
81128ba8:	dac00917 	ldw	r11,36(sp)
81128bac:	db400817 	ldw	r13,32(sp)
81128bb0:	db800617 	ldw	r14,24(sp)
81128bb4:	dbc00717 	ldw	r15,28(sp)
81128bb8:	103fbd1e 	bne	r2,zero,81128ab0 <__reset+0xfb108ab0>
81128bbc:	7839883a 	mov	fp,r15
81128bc0:	af3fb836 	bltu	r21,fp,81128aa4 <__reset+0xfb108aa4>
81128bc4:	003fc506 	br	81128adc <__reset+0xfb108adc>
81128bc8:	04c00104 	movi	r19,4
81128bcc:	52400015 	stw	r9,0(r10)
81128bd0:	000b883a 	mov	r5,zero
81128bd4:	54d5883a 	add	r10,r10,r19
81128bd8:	0013883a 	mov	r9,zero
81128bdc:	003fb706 	br	81128abc <__reset+0xfb108abc>
81128be0:	b00d883a 	mov	r6,r22
81128be4:	900b883a 	mov	r5,r18
81128be8:	a809883a 	mov	r4,r21
81128bec:	11293b00 	call	811293b0 <strncmp>
81128bf0:	10006426 	beq	r2,zero,81128d84 <__gethex+0x470>
81128bf4:	a8800003 	ldbu	r2,0(r21)
81128bf8:	a821883a 	mov	r16,r21
81128bfc:	10803fcc 	andi	r2,r2,255
81128c00:	01001404 	movi	r4,80
81128c04:	11001126 	beq	r2,r4,81128c4c <__gethex+0x338>
81128c08:	01001c04 	movi	r4,112
81128c0c:	11000f26 	beq	r2,r4,81128c4c <__gethex+0x338>
81128c10:	9c000015 	stw	r16,0(r19)
81128c14:	8800831e 	bne	r17,zero,81128e24 <__gethex+0x510>
81128c18:	00800184 	movi	r2,6
81128c1c:	dfc01417 	ldw	ra,80(sp)
81128c20:	df001317 	ldw	fp,76(sp)
81128c24:	ddc01217 	ldw	r23,72(sp)
81128c28:	dd801117 	ldw	r22,68(sp)
81128c2c:	dd401017 	ldw	r21,64(sp)
81128c30:	dd000f17 	ldw	r20,60(sp)
81128c34:	dcc00e17 	ldw	r19,56(sp)
81128c38:	dc800d17 	ldw	r18,52(sp)
81128c3c:	dc400c17 	ldw	r17,48(sp)
81128c40:	dc000b17 	ldw	r16,44(sp)
81128c44:	dec01504 	addi	sp,sp,84
81128c48:	f800283a 	ret
81128c4c:	002f883a 	mov	r23,zero
81128c50:	02800044 	movi	r10,1
81128c54:	80800043 	ldbu	r2,1(r16)
81128c58:	01400ac4 	movi	r5,43
81128c5c:	11003fcc 	andi	r4,r2,255
81128c60:	21406e26 	beq	r4,r5,81128e1c <__gethex+0x508>
81128c64:	01400b44 	movi	r5,45
81128c68:	21404226 	beq	r4,r5,81128d74 <__gethex+0x460>
81128c6c:	81400044 	addi	r5,r16,1
81128c70:	000d883a 	mov	r6,zero
81128c74:	10803fcc 	andi	r2,r2,255
81128c78:	a085883a 	add	r2,r20,r2
81128c7c:	11000003 	ldbu	r4,0(r2)
81128c80:	03000604 	movi	r12,24
81128c84:	20bfffc4 	addi	r2,r4,-1
81128c88:	10803fcc 	andi	r2,r2,255
81128c8c:	60bf6d36 	bltu	r12,r2,81128a44 <__reset+0xfb108a44>
81128c90:	2ac00043 	ldbu	r11,1(r5)
81128c94:	20803fcc 	andi	r2,r4,255
81128c98:	01204534 	movhi	r4,33044
81128c9c:	2117cd04 	addi	r4,r4,24372
81128ca0:	22c9883a 	add	r4,r4,r11
81128ca4:	23400003 	ldbu	r13,0(r4)
81128ca8:	10bffc04 	addi	r2,r2,-16
81128cac:	29400044 	addi	r5,r5,1
81128cb0:	693fffc4 	addi	r4,r13,-1
81128cb4:	21003fcc 	andi	r4,r4,255
81128cb8:	6b403fcc 	andi	r13,r13,255
81128cbc:	61000b36 	bltu	r12,r4,81128cec <__gethex+0x3d8>
81128cc0:	29400044 	addi	r5,r5,1
81128cc4:	29000003 	ldbu	r4,0(r5)
81128cc8:	108002a4 	muli	r2,r2,10
81128ccc:	a109883a 	add	r4,r20,r4
81128cd0:	22c00003 	ldbu	r11,0(r4)
81128cd4:	1345883a 	add	r2,r2,r13
81128cd8:	10bffc04 	addi	r2,r2,-16
81128cdc:	593fffc4 	addi	r4,r11,-1
81128ce0:	21003fcc 	andi	r4,r4,255
81128ce4:	5b403fcc 	andi	r13,r11,255
81128ce8:	613ff52e 	bgeu	r12,r4,81128cc0 <__reset+0xfb108cc0>
81128cec:	30000126 	beq	r6,zero,81128cf4 <__gethex+0x3e0>
81128cf0:	0085c83a 	sub	r2,zero,r2
81128cf4:	8039883a 	mov	fp,r16
81128cf8:	b8af883a 	add	r23,r23,r2
81128cfc:	2821883a 	mov	r16,r5
81128d00:	003f5106 	br	81128a48 <__reset+0xfb108a48>
81128d04:	80800217 	ldw	r2,8(r16)
81128d08:	e080f00e 	bge	fp,r2,811290cc <__gethex+0x7b8>
81128d0c:	e007883a 	mov	r3,fp
81128d10:	18800144 	addi	r2,r3,5
81128d14:	1085883a 	add	r2,r2,r2
81128d18:	18c00044 	addi	r3,r3,1
81128d1c:	1085883a 	add	r2,r2,r2
81128d20:	8085883a 	add	r2,r16,r2
81128d24:	80c00415 	stw	r3,16(r16)
81128d28:	01000044 	movi	r4,1
81128d2c:	11000015 	stw	r4,0(r2)
81128d30:	00800084 	movi	r2,2
81128d34:	8880d826 	beq	r17,r2,81129098 <__gethex+0x784>
81128d38:	e0c0ac0e 	bge	fp,r3,81128fec <__gethex+0x6d8>
81128d3c:	01400044 	movi	r5,1
81128d40:	8009883a 	mov	r4,r16
81128d44:	11288140 	call	81128814 <rshift>
81128d48:	d8c00017 	ldw	r3,0(sp)
81128d4c:	bdc00044 	addi	r23,r23,1
81128d50:	18800217 	ldw	r2,8(r3)
81128d54:	15c0a70e 	bge	r2,r23,81128ff4 <__gethex+0x6e0>
81128d58:	d9000117 	ldw	r4,4(sp)
81128d5c:	800b883a 	mov	r5,r16
81128d60:	1121fac0 	call	81121fac <_Bfree>
81128d64:	d9001517 	ldw	r4,84(sp)
81128d68:	008028c4 	movi	r2,163
81128d6c:	20000015 	stw	zero,0(r4)
81128d70:	003faa06 	br	81128c1c <__reset+0xfb108c1c>
81128d74:	01800044 	movi	r6,1
81128d78:	80800083 	ldbu	r2,2(r16)
81128d7c:	81400084 	addi	r5,r16,2
81128d80:	003fbc06 	br	81128c74 <__reset+0xfb108c74>
81128d84:	ada1883a 	add	r16,r21,r22
81128d88:	81000003 	ldbu	r4,0(r16)
81128d8c:	21403fcc 	andi	r5,r4,255
81128d90:	a145883a 	add	r2,r20,r5
81128d94:	10800003 	ldbu	r2,0(r2)
81128d98:	11803fcc 	andi	r6,r2,255
81128d9c:	30004f26 	beq	r6,zero,81128edc <__gethex+0x5c8>
81128da0:	00c00c04 	movi	r3,48
81128da4:	802b883a 	mov	r21,r16
81128da8:	28c0061e 	bne	r5,r3,81128dc4 <__gethex+0x4b0>
81128dac:	2809883a 	mov	r4,r5
81128db0:	ad400044 	addi	r21,r21,1
81128db4:	a8800003 	ldbu	r2,0(r21)
81128db8:	113ffd26 	beq	r2,r4,81128db0 <__reset+0xfb108db0>
81128dbc:	a085883a 	add	r2,r20,r2
81128dc0:	10800003 	ldbu	r2,0(r2)
81128dc4:	10803fcc 	andi	r2,r2,255
81128dc8:	1015003a 	cmpeq	r10,r2,zero
81128dcc:	802f883a 	mov	r23,r16
81128dd0:	04400044 	movi	r17,1
81128dd4:	003eff06 	br	811289d4 <__reset+0xfb1089d4>
81128dd8:	04400044 	movi	r17,1
81128ddc:	98000926 	beq	r19,zero,81128e04 <__gethex+0x4f0>
81128de0:	d8c00017 	ldw	r3,0(sp)
81128de4:	18800317 	ldw	r2,12(r3)
81128de8:	00c00084 	movi	r3,2
81128dec:	10c06826 	beq	r2,r3,81128f90 <__gethex+0x67c>
81128df0:	00c000c4 	movi	r3,3
81128df4:	10c06a26 	beq	r2,r3,81128fa0 <__gethex+0x68c>
81128df8:	00c00044 	movi	r3,1
81128dfc:	10c08d26 	beq	r2,r3,81129034 <__gethex+0x720>
81128e00:	8c400414 	ori	r17,r17,16
81128e04:	d9001517 	ldw	r4,84(sp)
81128e08:	d8c00417 	ldw	r3,16(sp)
81128e0c:	8805883a 	mov	r2,r17
81128e10:	24000015 	stw	r16,0(r4)
81128e14:	1dc00015 	stw	r23,0(r3)
81128e18:	003f8006 	br	81128c1c <__reset+0xfb108c1c>
81128e1c:	000d883a 	mov	r6,zero
81128e20:	003fd506 	br	81128d78 <__reset+0xfb108d78>
81128e24:	0005883a 	mov	r2,zero
81128e28:	003f7c06 	br	81128c1c <__reset+0xfb108c1c>
81128e2c:	14a3c83a 	sub	r17,r2,r18
81128e30:	880b883a 	mov	r5,r17
81128e34:	8009883a 	mov	r4,r16
81128e38:	1122ecc0 	call	81122ecc <__any_on>
81128e3c:	10002926 	beq	r2,zero,81128ee4 <__gethex+0x5d0>
81128e40:	897fffc4 	addi	r5,r17,-1
81128e44:	2807d17a 	srai	r3,r5,5
81128e48:	d8800217 	ldw	r2,8(sp)
81128e4c:	290007cc 	andi	r4,r5,31
81128e50:	18c7883a 	add	r3,r3,r3
81128e54:	18c7883a 	add	r3,r3,r3
81128e58:	04c00044 	movi	r19,1
81128e5c:	10c7883a 	add	r3,r2,r3
81128e60:	9908983a 	sll	r4,r19,r4
81128e64:	18c00017 	ldw	r3,0(r3)
81128e68:	20c6703a 	and	r3,r4,r3
81128e6c:	18000626 	beq	r3,zero,81128e88 <__gethex+0x574>
81128e70:	99407b0e 	bge	r19,r5,81129060 <__gethex+0x74c>
81128e74:	897fff84 	addi	r5,r17,-2
81128e78:	8009883a 	mov	r4,r16
81128e7c:	1122ecc0 	call	81122ecc <__any_on>
81128e80:	10007726 	beq	r2,zero,81129060 <__gethex+0x74c>
81128e84:	04c000c4 	movi	r19,3
81128e88:	880b883a 	mov	r5,r17
81128e8c:	8009883a 	mov	r4,r16
81128e90:	11288140 	call	81128814 <rshift>
81128e94:	bc6f883a 	add	r23,r23,r17
81128e98:	003f1f06 	br	81128b18 <__reset+0xfb108b18>
81128e9c:	002f883a 	mov	r23,zero
81128ea0:	003ee306 	br	81128a30 <__reset+0xfb108a30>
81128ea4:	d9000117 	ldw	r4,4(sp)
81128ea8:	90a3c83a 	sub	r17,r18,r2
81128eac:	800b883a 	mov	r5,r16
81128eb0:	880d883a 	mov	r6,r17
81128eb4:	11226ac0 	call	811226ac <__lshift>
81128eb8:	10c00504 	addi	r3,r2,20
81128ebc:	1021883a 	mov	r16,r2
81128ec0:	bc6fc83a 	sub	r23,r23,r17
81128ec4:	d8c00215 	stw	r3,8(sp)
81128ec8:	0027883a 	mov	r19,zero
81128ecc:	003f1206 	br	81128b18 <__reset+0xfb108b18>
81128ed0:	1d400084 	addi	r21,r3,2
81128ed4:	0023883a 	mov	r17,zero
81128ed8:	003eb406 	br	811289ac <__reset+0xfb1089ac>
81128edc:	2005883a 	mov	r2,r4
81128ee0:	003f4606 	br	81128bfc <__reset+0xfb108bfc>
81128ee4:	0027883a 	mov	r19,zero
81128ee8:	003fe706 	br	81128e88 <__reset+0xfb108e88>
81128eec:	bc7fffc4 	addi	r17,r23,-1
81128ef0:	9800421e 	bne	r19,zero,81128ffc <__gethex+0x6e8>
81128ef4:	88000426 	beq	r17,zero,81128f08 <__gethex+0x5f4>
81128ef8:	880b883a 	mov	r5,r17
81128efc:	8009883a 	mov	r4,r16
81128f00:	1122ecc0 	call	81122ecc <__any_on>
81128f04:	1027883a 	mov	r19,r2
81128f08:	8805d17a 	srai	r2,r17,5
81128f0c:	d8c00217 	ldw	r3,8(sp)
81128f10:	8c4007cc 	andi	r17,r17,31
81128f14:	1085883a 	add	r2,r2,r2
81128f18:	1085883a 	add	r2,r2,r2
81128f1c:	1885883a 	add	r2,r3,r2
81128f20:	00c00044 	movi	r3,1
81128f24:	1c62983a 	sll	r17,r3,r17
81128f28:	10800017 	ldw	r2,0(r2)
81128f2c:	8884703a 	and	r2,r17,r2
81128f30:	10000126 	beq	r2,zero,81128f38 <__gethex+0x624>
81128f34:	9cc00094 	ori	r19,r19,2
81128f38:	b80b883a 	mov	r5,r23
81128f3c:	8009883a 	mov	r4,r16
81128f40:	11288140 	call	81128814 <rshift>
81128f44:	d8c00017 	ldw	r3,0(sp)
81128f48:	95e5c83a 	sub	r18,r18,r23
81128f4c:	04400084 	movi	r17,2
81128f50:	1dc00117 	ldw	r23,4(r3)
81128f54:	003fa106 	br	81128ddc <__reset+0xfb108ddc>
81128f58:	85af883a 	add	r23,r16,r22
81128f5c:	b8800003 	ldbu	r2,0(r23)
81128f60:	b821883a 	mov	r16,r23
81128f64:	11003fcc 	andi	r4,r2,255
81128f68:	a109883a 	add	r4,r20,r4
81128f6c:	21000003 	ldbu	r4,0(r4)
81128f70:	203eaa26 	beq	r4,zero,81128a1c <__reset+0xfb108a1c>
81128f74:	84000044 	addi	r16,r16,1
81128f78:	80800003 	ldbu	r2,0(r16)
81128f7c:	11003fcc 	andi	r4,r2,255
81128f80:	a109883a 	add	r4,r20,r4
81128f84:	21000003 	ldbu	r4,0(r4)
81128f88:	203ffa1e 	bne	r4,zero,81128f74 <__reset+0xfb108f74>
81128f8c:	003ea306 	br	81128a1c <__reset+0xfb108a1c>
81128f90:	d9001617 	ldw	r4,88(sp)
81128f94:	00800044 	movi	r2,1
81128f98:	1109c83a 	sub	r4,r2,r4
81128f9c:	d9001615 	stw	r4,88(sp)
81128fa0:	d8801617 	ldw	r2,88(sp)
81128fa4:	103f9626 	beq	r2,zero,81128e00 <__reset+0xfb108e00>
81128fa8:	87000417 	ldw	fp,16(r16)
81128fac:	d9800217 	ldw	r6,8(sp)
81128fb0:	013fffc4 	movi	r4,-1
81128fb4:	e727883a 	add	r19,fp,fp
81128fb8:	9ce7883a 	add	r19,r19,r19
81128fbc:	3005883a 	mov	r2,r6
81128fc0:	34cb883a 	add	r5,r6,r19
81128fc4:	00000306 	br	81128fd4 <__gethex+0x6c0>
81128fc8:	10000015 	stw	zero,0(r2)
81128fcc:	10800104 	addi	r2,r2,4
81128fd0:	117f4c2e 	bgeu	r2,r5,81128d04 <__reset+0xfb108d04>
81128fd4:	10c00017 	ldw	r3,0(r2)
81128fd8:	193ffb26 	beq	r3,r4,81128fc8 <__reset+0xfb108fc8>
81128fdc:	18c00044 	addi	r3,r3,1
81128fe0:	10c00015 	stw	r3,0(r2)
81128fe4:	00800084 	movi	r2,2
81128fe8:	88802b26 	beq	r17,r2,81129098 <__gethex+0x784>
81128fec:	948007cc 	andi	r18,r18,31
81128ff0:	90002f1e 	bne	r18,zero,811290b0 <__gethex+0x79c>
81128ff4:	04400844 	movi	r17,33
81128ff8:	003f8206 	br	81128e04 <__reset+0xfb108e04>
81128ffc:	04c00044 	movi	r19,1
81129000:	003fc106 	br	81128f08 <__reset+0xfb108f08>
81129004:	d8c01617 	ldw	r3,88(sp)
81129008:	183ed226 	beq	r3,zero,81128b54 <__reset+0xfb108b54>
8112900c:	d8c00417 	ldw	r3,16(sp)
81129010:	d9001517 	ldw	r4,84(sp)
81129014:	18800015 	stw	r2,0(r3)
81129018:	d8c00217 	ldw	r3,8(sp)
8112901c:	00800044 	movi	r2,1
81129020:	80800415 	stw	r2,16(r16)
81129024:	18800015 	stw	r2,0(r3)
81129028:	24000015 	stw	r16,0(r4)
8112902c:	00801884 	movi	r2,98
81129030:	003efa06 	br	81128c1c <__reset+0xfb108c1c>
81129034:	9880008c 	andi	r2,r19,2
81129038:	103f7126 	beq	r2,zero,81128e00 <__reset+0xfb108e00>
8112903c:	d8c00217 	ldw	r3,8(sp)
81129040:	18800017 	ldw	r2,0(r3)
81129044:	9884b03a 	or	r2,r19,r2
81129048:	1080004c 	andi	r2,r2,1
8112904c:	103fd61e 	bne	r2,zero,81128fa8 <__reset+0xfb108fa8>
81129050:	003f6b06 	br	81128e00 <__reset+0xfb108e00>
81129054:	da800217 	ldw	r10,8(sp)
81129058:	0013883a 	mov	r9,zero
8112905c:	003e9f06 	br	81128adc <__reset+0xfb108adc>
81129060:	04c00084 	movi	r19,2
81129064:	003f8806 	br	81128e88 <__reset+0xfb108e88>
81129068:	d9001617 	ldw	r4,88(sp)
8112906c:	203fe726 	beq	r4,zero,8112900c <__reset+0xfb10900c>
81129070:	003eb806 	br	81128b54 <__reset+0xfb108b54>
81129074:	95feb71e 	bne	r18,r23,81128b54 <__reset+0xfb108b54>
81129078:	1cbfe40e 	bge	r3,r18,8112900c <__reset+0xfb10900c>
8112907c:	917fffc4 	addi	r5,r18,-1
81129080:	8009883a 	mov	r4,r16
81129084:	1122ecc0 	call	81122ecc <__any_on>
81129088:	103eb226 	beq	r2,zero,81128b54 <__reset+0xfb108b54>
8112908c:	d8c00017 	ldw	r3,0(sp)
81129090:	18800117 	ldw	r2,4(r3)
81129094:	003fdd06 	br	8112900c <__reset+0xfb10900c>
81129098:	d8c00017 	ldw	r3,0(sp)
8112909c:	18800017 	ldw	r2,0(r3)
811290a0:	10bfffc4 	addi	r2,r2,-1
811290a4:	90801c26 	beq	r18,r2,81129118 <__gethex+0x804>
811290a8:	04400884 	movi	r17,34
811290ac:	003f5506 	br	81128e04 <__reset+0xfb108e04>
811290b0:	34c5883a 	add	r2,r6,r19
811290b4:	113fff17 	ldw	r4,-4(r2)
811290b8:	11222080 	call	81122208 <__hi0bits>
811290bc:	00c00804 	movi	r3,32
811290c0:	1ca5c83a 	sub	r18,r3,r18
811290c4:	14bfcb0e 	bge	r2,r18,81128ff4 <__reset+0xfb108ff4>
811290c8:	003f1c06 	br	81128d3c <__reset+0xfb108d3c>
811290cc:	81400117 	ldw	r5,4(r16)
811290d0:	d9000117 	ldw	r4,4(sp)
811290d4:	29400044 	addi	r5,r5,1
811290d8:	1121efc0 	call	81121efc <_Balloc>
811290dc:	81800417 	ldw	r6,16(r16)
811290e0:	81400304 	addi	r5,r16,12
811290e4:	11000304 	addi	r4,r2,12
811290e8:	31800084 	addi	r6,r6,2
811290ec:	318d883a 	add	r6,r6,r6
811290f0:	318d883a 	add	r6,r6,r6
811290f4:	1029883a 	mov	r20,r2
811290f8:	1117ccc0 	call	81117ccc <memcpy>
811290fc:	d9000117 	ldw	r4,4(sp)
81129100:	800b883a 	mov	r5,r16
81129104:	a021883a 	mov	r16,r20
81129108:	1121fac0 	call	81121fac <_Bfree>
8112910c:	a0c00417 	ldw	r3,16(r20)
81129110:	a1800504 	addi	r6,r20,20
81129114:	003efe06 	br	81128d10 <__reset+0xfb108d10>
81129118:	9005d17a 	srai	r2,r18,5
8112911c:	944007cc 	andi	r17,r18,31
81129120:	1085883a 	add	r2,r2,r2
81129124:	1085883a 	add	r2,r2,r2
81129128:	3087883a 	add	r3,r6,r2
8112912c:	00800044 	movi	r2,1
81129130:	1462983a 	sll	r17,r2,r17
81129134:	18800017 	ldw	r2,0(r3)
81129138:	8884703a 	and	r2,r17,r2
8112913c:	1022c03a 	cmpne	r17,r2,zero
81129140:	00800884 	movi	r2,34
81129144:	1463c83a 	sub	r17,r2,r17
81129148:	003f2e06 	br	81128e04 <__reset+0xfb108e04>

8112914c <__hexnan>:
8112914c:	defff904 	addi	sp,sp,-28
81129150:	de00012e 	bgeu	sp,et,81129158 <__hexnan+0xc>
81129154:	003b68fa 	trap	3
81129158:	dc800215 	stw	r18,8(sp)
8112915c:	2c800017 	ldw	r18,0(r5)
81129160:	dfc00615 	stw	ra,24(sp)
81129164:	dd400515 	stw	r21,20(sp)
81129168:	901fd17a 	srai	r15,r18,5
8112916c:	dd000415 	stw	r20,16(sp)
81129170:	dcc00315 	stw	r19,12(sp)
81129174:	7bdf883a 	add	r15,r15,r15
81129178:	7bdf883a 	add	r15,r15,r15
8112917c:	dc400115 	stw	r17,4(sp)
81129180:	dc000015 	stw	r16,0(sp)
81129184:	948007cc 	andi	r18,r18,31
81129188:	33df883a 	add	r15,r6,r15
8112918c:	90000126 	beq	r18,zero,81129194 <__hexnan+0x48>
81129190:	7bc00104 	addi	r15,r15,4
81129194:	22000017 	ldw	r8,0(r4)
81129198:	7affff04 	addi	r11,r15,-4
8112919c:	03a04534 	movhi	r14,33044
811291a0:	783fff15 	stw	zero,-4(r15)
811291a4:	581b883a 	mov	r13,r11
811291a8:	580b883a 	mov	r5,r11
811291ac:	000f883a 	mov	r7,zero
811291b0:	003f883a 	mov	ra,zero
811291b4:	0019883a 	mov	r12,zero
811291b8:	7397cd04 	addi	r14,r14,24372
811291bc:	04400204 	movi	r17,8
811291c0:	04000804 	movi	r16,32
811291c4:	04c001c4 	movi	r19,7
811291c8:	42000044 	addi	r8,r8,1
811291cc:	40c00003 	ldbu	r3,0(r8)
811291d0:	18001d26 	beq	r3,zero,81129248 <__hexnan+0xfc>
811291d4:	70c5883a 	add	r2,r14,r3
811291d8:	10800003 	ldbu	r2,0(r2)
811291dc:	12403fcc 	andi	r9,r2,255
811291e0:	4800301e 	bne	r9,zero,811292a4 <__hexnan+0x158>
811291e4:	80c04236 	bltu	r16,r3,811292f0 <__hexnan+0x1a4>
811291e8:	fb3ff70e 	bge	ra,r12,811291c8 <__reset+0xfb1091c8>
811291ec:	2b40112e 	bgeu	r5,r13,81129234 <__hexnan+0xe8>
811291f0:	99c01016 	blt	r19,r7,81129234 <__hexnan+0xe8>
811291f4:	89e9c83a 	sub	r20,r17,r7
811291f8:	a529883a 	add	r20,r20,r20
811291fc:	2a800017 	ldw	r10,0(r5)
81129200:	a529883a 	add	r20,r20,r20
81129204:	852bc83a 	sub	r21,r16,r20
81129208:	28c00104 	addi	r3,r5,4
8112920c:	2805883a 	mov	r2,r5
81129210:	19c00017 	ldw	r7,0(r3)
81129214:	10800104 	addi	r2,r2,4
81129218:	18c00104 	addi	r3,r3,4
8112921c:	3d52983a 	sll	r9,r7,r21
81129220:	4a92b03a 	or	r9,r9,r10
81129224:	3d14d83a 	srl	r10,r7,r20
81129228:	127fff15 	stw	r9,-4(r2)
8112922c:	1abfff15 	stw	r10,-4(r3)
81129230:	137ff736 	bltu	r2,r13,81129210 <__reset+0xfb109210>
81129234:	31402836 	bltu	r6,r5,811292d8 <__hexnan+0x18c>
81129238:	42000044 	addi	r8,r8,1
8112923c:	40c00003 	ldbu	r3,0(r8)
81129240:	01c00204 	movi	r7,8
81129244:	183fe31e 	bne	r3,zero,811291d4 <__reset+0xfb1091d4>
81129248:	60002b26 	beq	r12,zero,811292f8 <__hexnan+0x1ac>
8112924c:	2b40022e 	bgeu	r5,r13,81129258 <__hexnan+0x10c>
81129250:	008001c4 	movi	r2,7
81129254:	11c0430e 	bge	r2,r7,81129364 <__hexnan+0x218>
81129258:	3140312e 	bgeu	r6,r5,81129320 <__hexnan+0x1d4>
8112925c:	3007883a 	mov	r3,r6
81129260:	29000017 	ldw	r4,0(r5)
81129264:	18800104 	addi	r2,r3,4
81129268:	29400104 	addi	r5,r5,4
8112926c:	19000015 	stw	r4,0(r3)
81129270:	1007883a 	mov	r3,r2
81129274:	597ffa2e 	bgeu	r11,r5,81129260 <__reset+0xfb109260>
81129278:	10000015 	stw	zero,0(r2)
8112927c:	10800104 	addi	r2,r2,4
81129280:	58bffd2e 	bgeu	r11,r2,81129278 <__reset+0xfb109278>
81129284:	78bfff17 	ldw	r2,-4(r15)
81129288:	1000041e 	bne	r2,zero,8112929c <__hexnan+0x150>
8112928c:	32c02d26 	beq	r6,r11,81129344 <__hexnan+0x1f8>
81129290:	5affff04 	addi	r11,r11,-4
81129294:	58800017 	ldw	r2,0(r11)
81129298:	103ffc26 	beq	r2,zero,8112928c <__reset+0xfb10928c>
8112929c:	00800144 	movi	r2,5
811292a0:	00001606 	br	811292fc <__hexnan+0x1b0>
811292a4:	39c00044 	addi	r7,r7,1
811292a8:	63000044 	addi	r12,r12,1
811292ac:	89c0040e 	bge	r17,r7,811292c0 <__hexnan+0x174>
811292b0:	317fc52e 	bgeu	r6,r5,811291c8 <__reset+0xfb1091c8>
811292b4:	283fff15 	stw	zero,-4(r5)
811292b8:	01c00044 	movi	r7,1
811292bc:	297fff04 	addi	r5,r5,-4
811292c0:	28c00017 	ldw	r3,0(r5)
811292c4:	108003cc 	andi	r2,r2,15
811292c8:	1806913a 	slli	r3,r3,4
811292cc:	1884b03a 	or	r2,r3,r2
811292d0:	28800015 	stw	r2,0(r5)
811292d4:	003fbc06 	br	811291c8 <__reset+0xfb1091c8>
811292d8:	2b7fff04 	addi	r13,r5,-4
811292dc:	283fff15 	stw	zero,-4(r5)
811292e0:	603f883a 	mov	ra,r12
811292e4:	680b883a 	mov	r5,r13
811292e8:	000f883a 	mov	r7,zero
811292ec:	003fb606 	br	811291c8 <__reset+0xfb1091c8>
811292f0:	00800a44 	movi	r2,41
811292f4:	18801726 	beq	r3,r2,81129354 <__hexnan+0x208>
811292f8:	00800104 	movi	r2,4
811292fc:	dfc00617 	ldw	ra,24(sp)
81129300:	dd400517 	ldw	r21,20(sp)
81129304:	dd000417 	ldw	r20,16(sp)
81129308:	dcc00317 	ldw	r19,12(sp)
8112930c:	dc800217 	ldw	r18,8(sp)
81129310:	dc400117 	ldw	r17,4(sp)
81129314:	dc000017 	ldw	r16,0(sp)
81129318:	dec00704 	addi	sp,sp,28
8112931c:	f800283a 	ret
81129320:	903fd826 	beq	r18,zero,81129284 <__reset+0xfb109284>
81129324:	00c00804 	movi	r3,32
81129328:	1ca5c83a 	sub	r18,r3,r18
8112932c:	00ffffc4 	movi	r3,-1
81129330:	78bfff17 	ldw	r2,-4(r15)
81129334:	1c86d83a 	srl	r3,r3,r18
81129338:	1884703a 	and	r2,r3,r2
8112933c:	78bfff15 	stw	r2,-4(r15)
81129340:	003fd106 	br	81129288 <__reset+0xfb109288>
81129344:	00800044 	movi	r2,1
81129348:	58800015 	stw	r2,0(r11)
8112934c:	00800144 	movi	r2,5
81129350:	003fea06 	br	811292fc <__reset+0xfb1092fc>
81129354:	42000044 	addi	r8,r8,1
81129358:	22000015 	stw	r8,0(r4)
8112935c:	603fbb1e 	bne	r12,zero,8112924c <__reset+0xfb10924c>
81129360:	003fe506 	br	811292f8 <__reset+0xfb1092f8>
81129364:	02400204 	movi	r9,8
81129368:	49d3c83a 	sub	r9,r9,r7
8112936c:	4a53883a 	add	r9,r9,r9
81129370:	2a000017 	ldw	r8,0(r5)
81129374:	4a53883a 	add	r9,r9,r9
81129378:	02800804 	movi	r10,32
8112937c:	5255c83a 	sub	r10,r10,r9
81129380:	28c00104 	addi	r3,r5,4
81129384:	2805883a 	mov	r2,r5
81129388:	19c00017 	ldw	r7,0(r3)
8112938c:	10800104 	addi	r2,r2,4
81129390:	18c00104 	addi	r3,r3,4
81129394:	3a88983a 	sll	r4,r7,r10
81129398:	2208b03a 	or	r4,r4,r8
8112939c:	3a50d83a 	srl	r8,r7,r9
811293a0:	113fff15 	stw	r4,-4(r2)
811293a4:	1a3fff15 	stw	r8,-4(r3)
811293a8:	137ff736 	bltu	r2,r13,81129388 <__reset+0xfb109388>
811293ac:	003faa06 	br	81129258 <__reset+0xfb109258>

811293b0 <strncmp>:
811293b0:	30003126 	beq	r6,zero,81129478 <strncmp+0xc8>
811293b4:	2144b03a 	or	r2,r4,r5
811293b8:	108000cc 	andi	r2,r2,3
811293bc:	10001e1e 	bne	r2,zero,81129438 <strncmp+0x88>
811293c0:	024000c4 	movi	r9,3
811293c4:	49801c2e 	bgeu	r9,r6,81129438 <strncmp+0x88>
811293c8:	20800017 	ldw	r2,0(r4)
811293cc:	28c00017 	ldw	r3,0(r5)
811293d0:	10c0191e 	bne	r2,r3,81129438 <strncmp+0x88>
811293d4:	31bfff04 	addi	r6,r6,-4
811293d8:	30002726 	beq	r6,zero,81129478 <strncmp+0xc8>
811293dc:	02ffbff4 	movhi	r11,65279
811293e0:	5affbfc4 	addi	r11,r11,-257
811293e4:	0086303a 	nor	r3,zero,r2
811293e8:	02a02074 	movhi	r10,32897
811293ec:	12c5883a 	add	r2,r2,r11
811293f0:	52a02004 	addi	r10,r10,-32640
811293f4:	10c4703a 	and	r2,r2,r3
811293f8:	1284703a 	and	r2,r2,r10
811293fc:	10000b26 	beq	r2,zero,8112942c <strncmp+0x7c>
81129400:	00001d06 	br	81129478 <strncmp+0xc8>
81129404:	20c00017 	ldw	r3,0(r4)
81129408:	29c00017 	ldw	r7,0(r5)
8112940c:	1ad1883a 	add	r8,r3,r11
81129410:	00c4303a 	nor	r2,zero,r3
81129414:	4084703a 	and	r2,r8,r2
81129418:	1284703a 	and	r2,r2,r10
8112941c:	19c0061e 	bne	r3,r7,81129438 <strncmp+0x88>
81129420:	31bfff04 	addi	r6,r6,-4
81129424:	30001426 	beq	r6,zero,81129478 <strncmp+0xc8>
81129428:	1000131e 	bne	r2,zero,81129478 <strncmp+0xc8>
8112942c:	21000104 	addi	r4,r4,4
81129430:	29400104 	addi	r5,r5,4
81129434:	49bff336 	bltu	r9,r6,81129404 <__reset+0xfb109404>
81129438:	28800007 	ldb	r2,0(r5)
8112943c:	20c00007 	ldb	r3,0(r4)
81129440:	31bfffc4 	addi	r6,r6,-1
81129444:	10c0081e 	bne	r2,r3,81129468 <strncmp+0xb8>
81129448:	30000b26 	beq	r6,zero,81129478 <strncmp+0xc8>
8112944c:	10000a26 	beq	r2,zero,81129478 <strncmp+0xc8>
81129450:	21000044 	addi	r4,r4,1
81129454:	29400044 	addi	r5,r5,1
81129458:	20800007 	ldb	r2,0(r4)
8112945c:	28c00007 	ldb	r3,0(r5)
81129460:	31bfffc4 	addi	r6,r6,-1
81129464:	10fff826 	beq	r2,r3,81129448 <__reset+0xfb109448>
81129468:	20800003 	ldbu	r2,0(r4)
8112946c:	28c00003 	ldbu	r3,0(r5)
81129470:	10c5c83a 	sub	r2,r2,r3
81129474:	f800283a 	ret
81129478:	0005883a 	mov	r2,zero
8112947c:	f800283a 	ret

81129480 <_wcrtomb_r>:
81129480:	defff604 	addi	sp,sp,-40
81129484:	00a04574 	movhi	r2,33045
81129488:	de00012e 	bgeu	sp,et,81129490 <_wcrtomb_r+0x10>
8112948c:	003b68fa 	trap	3
81129490:	10a10704 	addi	r2,r2,-31716
81129494:	dc800815 	stw	r18,32(sp)
81129498:	dc400715 	stw	r17,28(sp)
8112949c:	dc000615 	stw	r16,24(sp)
811294a0:	dfc00915 	stw	ra,36(sp)
811294a4:	2021883a 	mov	r16,r4
811294a8:	3823883a 	mov	r17,r7
811294ac:	14800017 	ldw	r18,0(r2)
811294b0:	28001426 	beq	r5,zero,81129504 <_wcrtomb_r+0x84>
811294b4:	d9400415 	stw	r5,16(sp)
811294b8:	d9800515 	stw	r6,20(sp)
811294bc:	11219b00 	call	811219b0 <__locale_charset>
811294c0:	d9800517 	ldw	r6,20(sp)
811294c4:	d9400417 	ldw	r5,16(sp)
811294c8:	100f883a 	mov	r7,r2
811294cc:	dc400015 	stw	r17,0(sp)
811294d0:	8009883a 	mov	r4,r16
811294d4:	903ee83a 	callr	r18
811294d8:	00ffffc4 	movi	r3,-1
811294dc:	10c0031e 	bne	r2,r3,811294ec <_wcrtomb_r+0x6c>
811294e0:	88000015 	stw	zero,0(r17)
811294e4:	00c02284 	movi	r3,138
811294e8:	80c00015 	stw	r3,0(r16)
811294ec:	dfc00917 	ldw	ra,36(sp)
811294f0:	dc800817 	ldw	r18,32(sp)
811294f4:	dc400717 	ldw	r17,28(sp)
811294f8:	dc000617 	ldw	r16,24(sp)
811294fc:	dec00a04 	addi	sp,sp,40
81129500:	f800283a 	ret
81129504:	11219b00 	call	811219b0 <__locale_charset>
81129508:	100f883a 	mov	r7,r2
8112950c:	dc400015 	stw	r17,0(sp)
81129510:	000d883a 	mov	r6,zero
81129514:	d9400104 	addi	r5,sp,4
81129518:	8009883a 	mov	r4,r16
8112951c:	903ee83a 	callr	r18
81129520:	003fed06 	br	811294d8 <__reset+0xfb1094d8>

81129524 <wcrtomb>:
81129524:	defff604 	addi	sp,sp,-40
81129528:	00a04574 	movhi	r2,33045
8112952c:	de00012e 	bgeu	sp,et,81129534 <wcrtomb+0x10>
81129530:	003b68fa 	trap	3
81129534:	10a10204 	addi	r2,r2,-31736
81129538:	dc800615 	stw	r18,24(sp)
8112953c:	dc400515 	stw	r17,20(sp)
81129540:	dfc00915 	stw	ra,36(sp)
81129544:	dd000815 	stw	r20,32(sp)
81129548:	dcc00715 	stw	r19,28(sp)
8112954c:	dc000415 	stw	r16,16(sp)
81129550:	3025883a 	mov	r18,r6
81129554:	14400017 	ldw	r17,0(r2)
81129558:	20001926 	beq	r4,zero,811295c0 <wcrtomb+0x9c>
8112955c:	00a04574 	movhi	r2,33045
81129560:	10a10704 	addi	r2,r2,-31716
81129564:	15000017 	ldw	r20,0(r2)
81129568:	2021883a 	mov	r16,r4
8112956c:	2827883a 	mov	r19,r5
81129570:	11219b00 	call	811219b0 <__locale_charset>
81129574:	100f883a 	mov	r7,r2
81129578:	dc800015 	stw	r18,0(sp)
8112957c:	980d883a 	mov	r6,r19
81129580:	800b883a 	mov	r5,r16
81129584:	8809883a 	mov	r4,r17
81129588:	a03ee83a 	callr	r20
8112958c:	00ffffc4 	movi	r3,-1
81129590:	10c0031e 	bne	r2,r3,811295a0 <wcrtomb+0x7c>
81129594:	90000015 	stw	zero,0(r18)
81129598:	00c02284 	movi	r3,138
8112959c:	88c00015 	stw	r3,0(r17)
811295a0:	dfc00917 	ldw	ra,36(sp)
811295a4:	dd000817 	ldw	r20,32(sp)
811295a8:	dcc00717 	ldw	r19,28(sp)
811295ac:	dc800617 	ldw	r18,24(sp)
811295b0:	dc400517 	ldw	r17,20(sp)
811295b4:	dc000417 	ldw	r16,16(sp)
811295b8:	dec00a04 	addi	sp,sp,40
811295bc:	f800283a 	ret
811295c0:	00a04574 	movhi	r2,33045
811295c4:	10a10704 	addi	r2,r2,-31716
811295c8:	14000017 	ldw	r16,0(r2)
811295cc:	11219b00 	call	811219b0 <__locale_charset>
811295d0:	100f883a 	mov	r7,r2
811295d4:	dc800015 	stw	r18,0(sp)
811295d8:	000d883a 	mov	r6,zero
811295dc:	d9400104 	addi	r5,sp,4
811295e0:	8809883a 	mov	r4,r17
811295e4:	803ee83a 	callr	r16
811295e8:	003fe806 	br	8112958c <__reset+0xfb10958c>

811295ec <__ascii_wctomb>:
811295ec:	28000526 	beq	r5,zero,81129604 <__ascii_wctomb+0x18>
811295f0:	00803fc4 	movi	r2,255
811295f4:	11800536 	bltu	r2,r6,8112960c <__ascii_wctomb+0x20>
811295f8:	29800005 	stb	r6,0(r5)
811295fc:	00800044 	movi	r2,1
81129600:	f800283a 	ret
81129604:	0005883a 	mov	r2,zero
81129608:	f800283a 	ret
8112960c:	00802284 	movi	r2,138
81129610:	20800015 	stw	r2,0(r4)
81129614:	00bfffc4 	movi	r2,-1
81129618:	f800283a 	ret

8112961c <_wctomb_r>:
8112961c:	00a04574 	movhi	r2,33045
81129620:	defff904 	addi	sp,sp,-28
81129624:	10a10704 	addi	r2,r2,-31716
81129628:	de00012e 	bgeu	sp,et,81129630 <_wctomb_r+0x14>
8112962c:	003b68fa 	trap	3
81129630:	dfc00615 	stw	ra,24(sp)
81129634:	dc400515 	stw	r17,20(sp)
81129638:	dc000415 	stw	r16,16(sp)
8112963c:	3823883a 	mov	r17,r7
81129640:	14000017 	ldw	r16,0(r2)
81129644:	d9000115 	stw	r4,4(sp)
81129648:	d9400215 	stw	r5,8(sp)
8112964c:	d9800315 	stw	r6,12(sp)
81129650:	11219b00 	call	811219b0 <__locale_charset>
81129654:	d9800317 	ldw	r6,12(sp)
81129658:	d9400217 	ldw	r5,8(sp)
8112965c:	d9000117 	ldw	r4,4(sp)
81129660:	100f883a 	mov	r7,r2
81129664:	dc400015 	stw	r17,0(sp)
81129668:	803ee83a 	callr	r16
8112966c:	dfc00617 	ldw	ra,24(sp)
81129670:	dc400517 	ldw	r17,20(sp)
81129674:	dc000417 	ldw	r16,16(sp)
81129678:	dec00704 	addi	sp,sp,28
8112967c:	f800283a 	ret

81129680 <__fixunsdfsi>:
81129680:	defffd04 	addi	sp,sp,-12
81129684:	000d883a 	mov	r6,zero
81129688:	01d07834 	movhi	r7,16864
8112968c:	de00012e 	bgeu	sp,et,81129694 <__fixunsdfsi+0x14>
81129690:	003b68fa 	trap	3
81129694:	dc400115 	stw	r17,4(sp)
81129698:	dc000015 	stw	r16,0(sp)
8112969c:	dfc00215 	stw	ra,8(sp)
811296a0:	2023883a 	mov	r17,r4
811296a4:	2821883a 	mov	r16,r5
811296a8:	112b7980 	call	8112b798 <__gedf2>
811296ac:	1000080e 	bge	r2,zero,811296d0 <__fixunsdfsi+0x50>
811296b0:	8809883a 	mov	r4,r17
811296b4:	800b883a 	mov	r5,r16
811296b8:	112c26c0 	call	8112c26c <__fixdfsi>
811296bc:	dfc00217 	ldw	ra,8(sp)
811296c0:	dc400117 	ldw	r17,4(sp)
811296c4:	dc000017 	ldw	r16,0(sp)
811296c8:	dec00304 	addi	sp,sp,12
811296cc:	f800283a 	ret
811296d0:	000d883a 	mov	r6,zero
811296d4:	01d07834 	movhi	r7,16864
811296d8:	8809883a 	mov	r4,r17
811296dc:	800b883a 	mov	r5,r16
811296e0:	112b9680 	call	8112b968 <__subdf3>
811296e4:	180b883a 	mov	r5,r3
811296e8:	1009883a 	mov	r4,r2
811296ec:	112c26c0 	call	8112c26c <__fixdfsi>
811296f0:	00e00034 	movhi	r3,32768
811296f4:	10c5883a 	add	r2,r2,r3
811296f8:	003ff006 	br	811296bc <__reset+0xfb1096bc>

811296fc <__udivdi3>:
811296fc:	defff504 	addi	sp,sp,-44
81129700:	de00012e 	bgeu	sp,et,81129708 <__udivdi3+0xc>
81129704:	003b68fa 	trap	3
81129708:	dcc00415 	stw	r19,16(sp)
8112970c:	dc000115 	stw	r16,4(sp)
81129710:	dfc00a15 	stw	ra,40(sp)
81129714:	df000915 	stw	fp,36(sp)
81129718:	ddc00815 	stw	r23,32(sp)
8112971c:	dd800715 	stw	r22,28(sp)
81129720:	dd400615 	stw	r21,24(sp)
81129724:	dd000515 	stw	r20,20(sp)
81129728:	dc800315 	stw	r18,12(sp)
8112972c:	dc400215 	stw	r17,8(sp)
81129730:	2027883a 	mov	r19,r4
81129734:	2821883a 	mov	r16,r5
81129738:	3800411e 	bne	r7,zero,81129840 <__udivdi3+0x144>
8112973c:	3023883a 	mov	r17,r6
81129740:	2025883a 	mov	r18,r4
81129744:	2980522e 	bgeu	r5,r6,81129890 <__udivdi3+0x194>
81129748:	00bfffd4 	movui	r2,65535
8112974c:	282d883a 	mov	r22,r5
81129750:	1180a836 	bltu	r2,r6,811299f4 <__udivdi3+0x2f8>
81129754:	00803fc4 	movi	r2,255
81129758:	1185803a 	cmpltu	r2,r2,r6
8112975c:	100490fa 	slli	r2,r2,3
81129760:	3086d83a 	srl	r3,r6,r2
81129764:	01204534 	movhi	r4,33044
81129768:	21164704 	addi	r4,r4,22812
8112976c:	20c7883a 	add	r3,r4,r3
81129770:	18c00003 	ldbu	r3,0(r3)
81129774:	1885883a 	add	r2,r3,r2
81129778:	00c00804 	movi	r3,32
8112977c:	1887c83a 	sub	r3,r3,r2
81129780:	18000526 	beq	r3,zero,81129798 <__udivdi3+0x9c>
81129784:	80e0983a 	sll	r16,r16,r3
81129788:	9884d83a 	srl	r2,r19,r2
8112978c:	30e2983a 	sll	r17,r6,r3
81129790:	98e4983a 	sll	r18,r19,r3
81129794:	142cb03a 	or	r22,r2,r16
81129798:	882ad43a 	srli	r21,r17,16
8112979c:	b009883a 	mov	r4,r22
811297a0:	8d3fffcc 	andi	r20,r17,65535
811297a4:	a80b883a 	mov	r5,r21
811297a8:	112a3180 	call	8112a318 <__umodsi3>
811297ac:	b009883a 	mov	r4,r22
811297b0:	a80b883a 	mov	r5,r21
811297b4:	1027883a 	mov	r19,r2
811297b8:	112a2b40 	call	8112a2b4 <__udivsi3>
811297bc:	102d883a 	mov	r22,r2
811297c0:	9826943a 	slli	r19,r19,16
811297c4:	9004d43a 	srli	r2,r18,16
811297c8:	a5a1383a 	mul	r16,r20,r22
811297cc:	14c4b03a 	or	r2,r2,r19
811297d0:	1400052e 	bgeu	r2,r16,811297e8 <__udivdi3+0xec>
811297d4:	1445883a 	add	r2,r2,r17
811297d8:	b0ffffc4 	addi	r3,r22,-1
811297dc:	14400136 	bltu	r2,r17,811297e4 <__udivdi3+0xe8>
811297e0:	14012336 	bltu	r2,r16,81129c70 <__udivdi3+0x574>
811297e4:	182d883a 	mov	r22,r3
811297e8:	1421c83a 	sub	r16,r2,r16
811297ec:	a80b883a 	mov	r5,r21
811297f0:	8009883a 	mov	r4,r16
811297f4:	112a3180 	call	8112a318 <__umodsi3>
811297f8:	1027883a 	mov	r19,r2
811297fc:	a80b883a 	mov	r5,r21
81129800:	8009883a 	mov	r4,r16
81129804:	112a2b40 	call	8112a2b4 <__udivsi3>
81129808:	9826943a 	slli	r19,r19,16
8112980c:	a0a9383a 	mul	r20,r20,r2
81129810:	94bfffcc 	andi	r18,r18,65535
81129814:	94e4b03a 	or	r18,r18,r19
81129818:	9500052e 	bgeu	r18,r20,81129830 <__udivdi3+0x134>
8112981c:	8ca5883a 	add	r18,r17,r18
81129820:	10ffffc4 	addi	r3,r2,-1
81129824:	9440f136 	bltu	r18,r17,81129bec <__udivdi3+0x4f0>
81129828:	9500f02e 	bgeu	r18,r20,81129bec <__udivdi3+0x4f0>
8112982c:	10bfff84 	addi	r2,r2,-2
81129830:	b00c943a 	slli	r6,r22,16
81129834:	0007883a 	mov	r3,zero
81129838:	3084b03a 	or	r2,r6,r2
8112983c:	00005906 	br	811299a4 <__udivdi3+0x2a8>
81129840:	29c05636 	bltu	r5,r7,8112999c <__udivdi3+0x2a0>
81129844:	00bfffd4 	movui	r2,65535
81129848:	11c0622e 	bgeu	r2,r7,811299d4 <__udivdi3+0x2d8>
8112984c:	00804034 	movhi	r2,256
81129850:	10bfffc4 	addi	r2,r2,-1
81129854:	11c0ee36 	bltu	r2,r7,81129c10 <__udivdi3+0x514>
81129858:	00800404 	movi	r2,16
8112985c:	3886d83a 	srl	r3,r7,r2
81129860:	01204534 	movhi	r4,33044
81129864:	21164704 	addi	r4,r4,22812
81129868:	20c7883a 	add	r3,r4,r3
8112986c:	18c00003 	ldbu	r3,0(r3)
81129870:	05400804 	movi	r21,32
81129874:	1885883a 	add	r2,r3,r2
81129878:	a8abc83a 	sub	r21,r21,r2
8112987c:	a800621e 	bne	r21,zero,81129a08 <__udivdi3+0x30c>
81129880:	3c00e936 	bltu	r7,r16,81129c28 <__udivdi3+0x52c>
81129884:	9985403a 	cmpgeu	r2,r19,r6
81129888:	0007883a 	mov	r3,zero
8112988c:	00004506 	br	811299a4 <__udivdi3+0x2a8>
81129890:	3000041e 	bne	r6,zero,811298a4 <__udivdi3+0x1a8>
81129894:	000b883a 	mov	r5,zero
81129898:	01000044 	movi	r4,1
8112989c:	112a2b40 	call	8112a2b4 <__udivsi3>
811298a0:	1023883a 	mov	r17,r2
811298a4:	00bfffd4 	movui	r2,65535
811298a8:	14404e2e 	bgeu	r2,r17,811299e4 <__udivdi3+0x2e8>
811298ac:	00804034 	movhi	r2,256
811298b0:	10bfffc4 	addi	r2,r2,-1
811298b4:	1440d836 	bltu	r2,r17,81129c18 <__udivdi3+0x51c>
811298b8:	00800404 	movi	r2,16
811298bc:	8886d83a 	srl	r3,r17,r2
811298c0:	01204534 	movhi	r4,33044
811298c4:	21164704 	addi	r4,r4,22812
811298c8:	20c7883a 	add	r3,r4,r3
811298cc:	18c00003 	ldbu	r3,0(r3)
811298d0:	1885883a 	add	r2,r3,r2
811298d4:	00c00804 	movi	r3,32
811298d8:	1887c83a 	sub	r3,r3,r2
811298dc:	18008f1e 	bne	r3,zero,81129b1c <__udivdi3+0x420>
811298e0:	882ad43a 	srli	r21,r17,16
811298e4:	8461c83a 	sub	r16,r16,r17
811298e8:	8d3fffcc 	andi	r20,r17,65535
811298ec:	00c00044 	movi	r3,1
811298f0:	8009883a 	mov	r4,r16
811298f4:	a80b883a 	mov	r5,r21
811298f8:	d8c00015 	stw	r3,0(sp)
811298fc:	112a3180 	call	8112a318 <__umodsi3>
81129900:	8009883a 	mov	r4,r16
81129904:	a80b883a 	mov	r5,r21
81129908:	1027883a 	mov	r19,r2
8112990c:	112a2b40 	call	8112a2b4 <__udivsi3>
81129910:	9826943a 	slli	r19,r19,16
81129914:	9008d43a 	srli	r4,r18,16
81129918:	1521383a 	mul	r16,r2,r20
8112991c:	102d883a 	mov	r22,r2
81129920:	24c8b03a 	or	r4,r4,r19
81129924:	d8c00017 	ldw	r3,0(sp)
81129928:	2400052e 	bgeu	r4,r16,81129940 <__udivdi3+0x244>
8112992c:	2449883a 	add	r4,r4,r17
81129930:	b0bfffc4 	addi	r2,r22,-1
81129934:	24400136 	bltu	r4,r17,8112993c <__udivdi3+0x240>
81129938:	2400ca36 	bltu	r4,r16,81129c64 <__udivdi3+0x568>
8112993c:	102d883a 	mov	r22,r2
81129940:	2421c83a 	sub	r16,r4,r16
81129944:	a80b883a 	mov	r5,r21
81129948:	8009883a 	mov	r4,r16
8112994c:	d8c00015 	stw	r3,0(sp)
81129950:	112a3180 	call	8112a318 <__umodsi3>
81129954:	1027883a 	mov	r19,r2
81129958:	a80b883a 	mov	r5,r21
8112995c:	8009883a 	mov	r4,r16
81129960:	112a2b40 	call	8112a2b4 <__udivsi3>
81129964:	9826943a 	slli	r19,r19,16
81129968:	1529383a 	mul	r20,r2,r20
8112996c:	94bfffcc 	andi	r18,r18,65535
81129970:	94e4b03a 	or	r18,r18,r19
81129974:	d8c00017 	ldw	r3,0(sp)
81129978:	9500052e 	bgeu	r18,r20,81129990 <__udivdi3+0x294>
8112997c:	8ca5883a 	add	r18,r17,r18
81129980:	113fffc4 	addi	r4,r2,-1
81129984:	94409736 	bltu	r18,r17,81129be4 <__udivdi3+0x4e8>
81129988:	9500962e 	bgeu	r18,r20,81129be4 <__udivdi3+0x4e8>
8112998c:	10bfff84 	addi	r2,r2,-2
81129990:	b00c943a 	slli	r6,r22,16
81129994:	3084b03a 	or	r2,r6,r2
81129998:	00000206 	br	811299a4 <__udivdi3+0x2a8>
8112999c:	0007883a 	mov	r3,zero
811299a0:	0005883a 	mov	r2,zero
811299a4:	dfc00a17 	ldw	ra,40(sp)
811299a8:	df000917 	ldw	fp,36(sp)
811299ac:	ddc00817 	ldw	r23,32(sp)
811299b0:	dd800717 	ldw	r22,28(sp)
811299b4:	dd400617 	ldw	r21,24(sp)
811299b8:	dd000517 	ldw	r20,20(sp)
811299bc:	dcc00417 	ldw	r19,16(sp)
811299c0:	dc800317 	ldw	r18,12(sp)
811299c4:	dc400217 	ldw	r17,8(sp)
811299c8:	dc000117 	ldw	r16,4(sp)
811299cc:	dec00b04 	addi	sp,sp,44
811299d0:	f800283a 	ret
811299d4:	00803fc4 	movi	r2,255
811299d8:	11c5803a 	cmpltu	r2,r2,r7
811299dc:	100490fa 	slli	r2,r2,3
811299e0:	003f9e06 	br	8112985c <__reset+0xfb10985c>
811299e4:	00803fc4 	movi	r2,255
811299e8:	1445803a 	cmpltu	r2,r2,r17
811299ec:	100490fa 	slli	r2,r2,3
811299f0:	003fb206 	br	811298bc <__reset+0xfb1098bc>
811299f4:	00804034 	movhi	r2,256
811299f8:	10bfffc4 	addi	r2,r2,-1
811299fc:	11808836 	bltu	r2,r6,81129c20 <__udivdi3+0x524>
81129a00:	00800404 	movi	r2,16
81129a04:	003f5606 	br	81129760 <__reset+0xfb109760>
81129a08:	30aed83a 	srl	r23,r6,r2
81129a0c:	3d4e983a 	sll	r7,r7,r21
81129a10:	80acd83a 	srl	r22,r16,r2
81129a14:	9884d83a 	srl	r2,r19,r2
81129a18:	3deeb03a 	or	r23,r7,r23
81129a1c:	b824d43a 	srli	r18,r23,16
81129a20:	8560983a 	sll	r16,r16,r21
81129a24:	b009883a 	mov	r4,r22
81129a28:	900b883a 	mov	r5,r18
81129a2c:	3568983a 	sll	r20,r6,r21
81129a30:	1420b03a 	or	r16,r2,r16
81129a34:	112a3180 	call	8112a318 <__umodsi3>
81129a38:	b009883a 	mov	r4,r22
81129a3c:	900b883a 	mov	r5,r18
81129a40:	1023883a 	mov	r17,r2
81129a44:	112a2b40 	call	8112a2b4 <__udivsi3>
81129a48:	8808943a 	slli	r4,r17,16
81129a4c:	bf3fffcc 	andi	fp,r23,65535
81129a50:	8006d43a 	srli	r3,r16,16
81129a54:	e0a3383a 	mul	r17,fp,r2
81129a58:	100d883a 	mov	r6,r2
81129a5c:	1906b03a 	or	r3,r3,r4
81129a60:	1c40042e 	bgeu	r3,r17,81129a74 <__udivdi3+0x378>
81129a64:	1dc7883a 	add	r3,r3,r23
81129a68:	10bfffc4 	addi	r2,r2,-1
81129a6c:	1dc0752e 	bgeu	r3,r23,81129c44 <__udivdi3+0x548>
81129a70:	100d883a 	mov	r6,r2
81129a74:	1c63c83a 	sub	r17,r3,r17
81129a78:	900b883a 	mov	r5,r18
81129a7c:	8809883a 	mov	r4,r17
81129a80:	d9800015 	stw	r6,0(sp)
81129a84:	112a3180 	call	8112a318 <__umodsi3>
81129a88:	102d883a 	mov	r22,r2
81129a8c:	8809883a 	mov	r4,r17
81129a90:	900b883a 	mov	r5,r18
81129a94:	112a2b40 	call	8112a2b4 <__udivsi3>
81129a98:	b02c943a 	slli	r22,r22,16
81129a9c:	e089383a 	mul	r4,fp,r2
81129aa0:	843fffcc 	andi	r16,r16,65535
81129aa4:	85a0b03a 	or	r16,r16,r22
81129aa8:	d9800017 	ldw	r6,0(sp)
81129aac:	8100042e 	bgeu	r16,r4,81129ac0 <__udivdi3+0x3c4>
81129ab0:	85e1883a 	add	r16,r16,r23
81129ab4:	10ffffc4 	addi	r3,r2,-1
81129ab8:	85c05e2e 	bgeu	r16,r23,81129c34 <__udivdi3+0x538>
81129abc:	1805883a 	mov	r2,r3
81129ac0:	300c943a 	slli	r6,r6,16
81129ac4:	a17fffcc 	andi	r5,r20,65535
81129ac8:	a028d43a 	srli	r20,r20,16
81129acc:	3084b03a 	or	r2,r6,r2
81129ad0:	10ffffcc 	andi	r3,r2,65535
81129ad4:	100cd43a 	srli	r6,r2,16
81129ad8:	194f383a 	mul	r7,r3,r5
81129adc:	1d07383a 	mul	r3,r3,r20
81129ae0:	314b383a 	mul	r5,r6,r5
81129ae4:	3810d43a 	srli	r8,r7,16
81129ae8:	8121c83a 	sub	r16,r16,r4
81129aec:	1947883a 	add	r3,r3,r5
81129af0:	40c7883a 	add	r3,r8,r3
81129af4:	350d383a 	mul	r6,r6,r20
81129af8:	1940022e 	bgeu	r3,r5,81129b04 <__udivdi3+0x408>
81129afc:	01000074 	movhi	r4,1
81129b00:	310d883a 	add	r6,r6,r4
81129b04:	1828d43a 	srli	r20,r3,16
81129b08:	a18d883a 	add	r6,r20,r6
81129b0c:	81803e36 	bltu	r16,r6,81129c08 <__udivdi3+0x50c>
81129b10:	81803826 	beq	r16,r6,81129bf4 <__udivdi3+0x4f8>
81129b14:	0007883a 	mov	r3,zero
81129b18:	003fa206 	br	811299a4 <__reset+0xfb1099a4>
81129b1c:	88e2983a 	sll	r17,r17,r3
81129b20:	80a8d83a 	srl	r20,r16,r2
81129b24:	80e0983a 	sll	r16,r16,r3
81129b28:	882ad43a 	srli	r21,r17,16
81129b2c:	9884d83a 	srl	r2,r19,r2
81129b30:	a009883a 	mov	r4,r20
81129b34:	a80b883a 	mov	r5,r21
81129b38:	142eb03a 	or	r23,r2,r16
81129b3c:	98e4983a 	sll	r18,r19,r3
81129b40:	112a3180 	call	8112a318 <__umodsi3>
81129b44:	a009883a 	mov	r4,r20
81129b48:	a80b883a 	mov	r5,r21
81129b4c:	1021883a 	mov	r16,r2
81129b50:	112a2b40 	call	8112a2b4 <__udivsi3>
81129b54:	1039883a 	mov	fp,r2
81129b58:	8d3fffcc 	andi	r20,r17,65535
81129b5c:	8020943a 	slli	r16,r16,16
81129b60:	b804d43a 	srli	r2,r23,16
81129b64:	a72d383a 	mul	r22,r20,fp
81129b68:	1404b03a 	or	r2,r2,r16
81129b6c:	1580062e 	bgeu	r2,r22,81129b88 <__udivdi3+0x48c>
81129b70:	1445883a 	add	r2,r2,r17
81129b74:	e0ffffc4 	addi	r3,fp,-1
81129b78:	14403836 	bltu	r2,r17,81129c5c <__udivdi3+0x560>
81129b7c:	1580372e 	bgeu	r2,r22,81129c5c <__udivdi3+0x560>
81129b80:	e73fff84 	addi	fp,fp,-2
81129b84:	1445883a 	add	r2,r2,r17
81129b88:	15adc83a 	sub	r22,r2,r22
81129b8c:	a80b883a 	mov	r5,r21
81129b90:	b009883a 	mov	r4,r22
81129b94:	112a3180 	call	8112a318 <__umodsi3>
81129b98:	1027883a 	mov	r19,r2
81129b9c:	b009883a 	mov	r4,r22
81129ba0:	a80b883a 	mov	r5,r21
81129ba4:	112a2b40 	call	8112a2b4 <__udivsi3>
81129ba8:	9826943a 	slli	r19,r19,16
81129bac:	a0a1383a 	mul	r16,r20,r2
81129bb0:	b93fffcc 	andi	r4,r23,65535
81129bb4:	24c8b03a 	or	r4,r4,r19
81129bb8:	2400062e 	bgeu	r4,r16,81129bd4 <__udivdi3+0x4d8>
81129bbc:	2449883a 	add	r4,r4,r17
81129bc0:	10ffffc4 	addi	r3,r2,-1
81129bc4:	24402336 	bltu	r4,r17,81129c54 <__udivdi3+0x558>
81129bc8:	2400222e 	bgeu	r4,r16,81129c54 <__udivdi3+0x558>
81129bcc:	10bfff84 	addi	r2,r2,-2
81129bd0:	2449883a 	add	r4,r4,r17
81129bd4:	e038943a 	slli	fp,fp,16
81129bd8:	2421c83a 	sub	r16,r4,r16
81129bdc:	e086b03a 	or	r3,fp,r2
81129be0:	003f4306 	br	811298f0 <__reset+0xfb1098f0>
81129be4:	2005883a 	mov	r2,r4
81129be8:	003f6906 	br	81129990 <__reset+0xfb109990>
81129bec:	1805883a 	mov	r2,r3
81129bf0:	003f0f06 	br	81129830 <__reset+0xfb109830>
81129bf4:	1806943a 	slli	r3,r3,16
81129bf8:	9d66983a 	sll	r19,r19,r21
81129bfc:	39ffffcc 	andi	r7,r7,65535
81129c00:	19c7883a 	add	r3,r3,r7
81129c04:	98ffc32e 	bgeu	r19,r3,81129b14 <__reset+0xfb109b14>
81129c08:	10bfffc4 	addi	r2,r2,-1
81129c0c:	003fc106 	br	81129b14 <__reset+0xfb109b14>
81129c10:	00800604 	movi	r2,24
81129c14:	003f1106 	br	8112985c <__reset+0xfb10985c>
81129c18:	00800604 	movi	r2,24
81129c1c:	003f2706 	br	811298bc <__reset+0xfb1098bc>
81129c20:	00800604 	movi	r2,24
81129c24:	003ece06 	br	81129760 <__reset+0xfb109760>
81129c28:	0007883a 	mov	r3,zero
81129c2c:	00800044 	movi	r2,1
81129c30:	003f5c06 	br	811299a4 <__reset+0xfb1099a4>
81129c34:	813fa12e 	bgeu	r16,r4,81129abc <__reset+0xfb109abc>
81129c38:	10bfff84 	addi	r2,r2,-2
81129c3c:	85e1883a 	add	r16,r16,r23
81129c40:	003f9f06 	br	81129ac0 <__reset+0xfb109ac0>
81129c44:	1c7f8a2e 	bgeu	r3,r17,81129a70 <__reset+0xfb109a70>
81129c48:	31bfff84 	addi	r6,r6,-2
81129c4c:	1dc7883a 	add	r3,r3,r23
81129c50:	003f8806 	br	81129a74 <__reset+0xfb109a74>
81129c54:	1805883a 	mov	r2,r3
81129c58:	003fde06 	br	81129bd4 <__reset+0xfb109bd4>
81129c5c:	1839883a 	mov	fp,r3
81129c60:	003fc906 	br	81129b88 <__reset+0xfb109b88>
81129c64:	b5bfff84 	addi	r22,r22,-2
81129c68:	2449883a 	add	r4,r4,r17
81129c6c:	003f3406 	br	81129940 <__reset+0xfb109940>
81129c70:	b5bfff84 	addi	r22,r22,-2
81129c74:	1445883a 	add	r2,r2,r17
81129c78:	003edb06 	br	811297e8 <__reset+0xfb1097e8>

81129c7c <__umoddi3>:
81129c7c:	defff404 	addi	sp,sp,-48
81129c80:	de00012e 	bgeu	sp,et,81129c88 <__umoddi3+0xc>
81129c84:	003b68fa 	trap	3
81129c88:	df000a15 	stw	fp,40(sp)
81129c8c:	dc400315 	stw	r17,12(sp)
81129c90:	dc000215 	stw	r16,8(sp)
81129c94:	dfc00b15 	stw	ra,44(sp)
81129c98:	ddc00915 	stw	r23,36(sp)
81129c9c:	dd800815 	stw	r22,32(sp)
81129ca0:	dd400715 	stw	r21,28(sp)
81129ca4:	dd000615 	stw	r20,24(sp)
81129ca8:	dcc00515 	stw	r19,20(sp)
81129cac:	dc800415 	stw	r18,16(sp)
81129cb0:	2021883a 	mov	r16,r4
81129cb4:	2823883a 	mov	r17,r5
81129cb8:	2839883a 	mov	fp,r5
81129cbc:	38003c1e 	bne	r7,zero,81129db0 <__umoddi3+0x134>
81129cc0:	3027883a 	mov	r19,r6
81129cc4:	2029883a 	mov	r20,r4
81129cc8:	2980512e 	bgeu	r5,r6,81129e10 <__umoddi3+0x194>
81129ccc:	00bfffd4 	movui	r2,65535
81129cd0:	11809a36 	bltu	r2,r6,81129f3c <__umoddi3+0x2c0>
81129cd4:	01003fc4 	movi	r4,255
81129cd8:	2189803a 	cmpltu	r4,r4,r6
81129cdc:	200890fa 	slli	r4,r4,3
81129ce0:	3104d83a 	srl	r2,r6,r4
81129ce4:	00e04534 	movhi	r3,33044
81129ce8:	18d64704 	addi	r3,r3,22812
81129cec:	1885883a 	add	r2,r3,r2
81129cf0:	10c00003 	ldbu	r3,0(r2)
81129cf4:	00800804 	movi	r2,32
81129cf8:	1909883a 	add	r4,r3,r4
81129cfc:	1125c83a 	sub	r18,r2,r4
81129d00:	90000526 	beq	r18,zero,81129d18 <__umoddi3+0x9c>
81129d04:	8ca2983a 	sll	r17,r17,r18
81129d08:	8108d83a 	srl	r4,r16,r4
81129d0c:	34a6983a 	sll	r19,r6,r18
81129d10:	84a8983a 	sll	r20,r16,r18
81129d14:	2478b03a 	or	fp,r4,r17
81129d18:	982ed43a 	srli	r23,r19,16
81129d1c:	e009883a 	mov	r4,fp
81129d20:	9dbfffcc 	andi	r22,r19,65535
81129d24:	b80b883a 	mov	r5,r23
81129d28:	112a3180 	call	8112a318 <__umodsi3>
81129d2c:	e009883a 	mov	r4,fp
81129d30:	b80b883a 	mov	r5,r23
81129d34:	102b883a 	mov	r21,r2
81129d38:	112a2b40 	call	8112a2b4 <__udivsi3>
81129d3c:	a806943a 	slli	r3,r21,16
81129d40:	a008d43a 	srli	r4,r20,16
81129d44:	b085383a 	mul	r2,r22,r2
81129d48:	20c8b03a 	or	r4,r4,r3
81129d4c:	2080032e 	bgeu	r4,r2,81129d5c <__umoddi3+0xe0>
81129d50:	24c9883a 	add	r4,r4,r19
81129d54:	24c00136 	bltu	r4,r19,81129d5c <__umoddi3+0xe0>
81129d58:	20811036 	bltu	r4,r2,8112a19c <__umoddi3+0x520>
81129d5c:	20abc83a 	sub	r21,r4,r2
81129d60:	b80b883a 	mov	r5,r23
81129d64:	a809883a 	mov	r4,r21
81129d68:	112a3180 	call	8112a318 <__umodsi3>
81129d6c:	1023883a 	mov	r17,r2
81129d70:	b80b883a 	mov	r5,r23
81129d74:	a809883a 	mov	r4,r21
81129d78:	112a2b40 	call	8112a2b4 <__udivsi3>
81129d7c:	8822943a 	slli	r17,r17,16
81129d80:	b085383a 	mul	r2,r22,r2
81129d84:	a0ffffcc 	andi	r3,r20,65535
81129d88:	1c46b03a 	or	r3,r3,r17
81129d8c:	1880042e 	bgeu	r3,r2,81129da0 <__umoddi3+0x124>
81129d90:	1cc7883a 	add	r3,r3,r19
81129d94:	1cc00236 	bltu	r3,r19,81129da0 <__umoddi3+0x124>
81129d98:	1880012e 	bgeu	r3,r2,81129da0 <__umoddi3+0x124>
81129d9c:	1cc7883a 	add	r3,r3,r19
81129da0:	1885c83a 	sub	r2,r3,r2
81129da4:	1484d83a 	srl	r2,r2,r18
81129da8:	0007883a 	mov	r3,zero
81129dac:	00004f06 	br	81129eec <__umoddi3+0x270>
81129db0:	29c04c36 	bltu	r5,r7,81129ee4 <__umoddi3+0x268>
81129db4:	00bfffd4 	movui	r2,65535
81129db8:	11c0582e 	bgeu	r2,r7,81129f1c <__umoddi3+0x2a0>
81129dbc:	00804034 	movhi	r2,256
81129dc0:	10bfffc4 	addi	r2,r2,-1
81129dc4:	11c0e736 	bltu	r2,r7,8112a164 <__umoddi3+0x4e8>
81129dc8:	01000404 	movi	r4,16
81129dcc:	3904d83a 	srl	r2,r7,r4
81129dd0:	00e04534 	movhi	r3,33044
81129dd4:	18d64704 	addi	r3,r3,22812
81129dd8:	1885883a 	add	r2,r3,r2
81129ddc:	14c00003 	ldbu	r19,0(r2)
81129de0:	00c00804 	movi	r3,32
81129de4:	9927883a 	add	r19,r19,r4
81129de8:	1ce9c83a 	sub	r20,r3,r19
81129dec:	a000581e 	bne	r20,zero,81129f50 <__umoddi3+0x2d4>
81129df0:	3c400136 	bltu	r7,r17,81129df8 <__umoddi3+0x17c>
81129df4:	8180eb36 	bltu	r16,r6,8112a1a4 <__umoddi3+0x528>
81129df8:	8185c83a 	sub	r2,r16,r6
81129dfc:	89e3c83a 	sub	r17,r17,r7
81129e00:	8089803a 	cmpltu	r4,r16,r2
81129e04:	8939c83a 	sub	fp,r17,r4
81129e08:	e007883a 	mov	r3,fp
81129e0c:	00003706 	br	81129eec <__umoddi3+0x270>
81129e10:	3000041e 	bne	r6,zero,81129e24 <__umoddi3+0x1a8>
81129e14:	000b883a 	mov	r5,zero
81129e18:	01000044 	movi	r4,1
81129e1c:	112a2b40 	call	8112a2b4 <__udivsi3>
81129e20:	1027883a 	mov	r19,r2
81129e24:	00bfffd4 	movui	r2,65535
81129e28:	14c0402e 	bgeu	r2,r19,81129f2c <__umoddi3+0x2b0>
81129e2c:	00804034 	movhi	r2,256
81129e30:	10bfffc4 	addi	r2,r2,-1
81129e34:	14c0cd36 	bltu	r2,r19,8112a16c <__umoddi3+0x4f0>
81129e38:	00800404 	movi	r2,16
81129e3c:	9886d83a 	srl	r3,r19,r2
81129e40:	01204534 	movhi	r4,33044
81129e44:	21164704 	addi	r4,r4,22812
81129e48:	20c7883a 	add	r3,r4,r3
81129e4c:	18c00003 	ldbu	r3,0(r3)
81129e50:	1887883a 	add	r3,r3,r2
81129e54:	00800804 	movi	r2,32
81129e58:	10e5c83a 	sub	r18,r2,r3
81129e5c:	9000901e 	bne	r18,zero,8112a0a0 <__umoddi3+0x424>
81129e60:	982cd43a 	srli	r22,r19,16
81129e64:	8ce3c83a 	sub	r17,r17,r19
81129e68:	9d7fffcc 	andi	r21,r19,65535
81129e6c:	b00b883a 	mov	r5,r22
81129e70:	8809883a 	mov	r4,r17
81129e74:	112a3180 	call	8112a318 <__umodsi3>
81129e78:	8809883a 	mov	r4,r17
81129e7c:	b00b883a 	mov	r5,r22
81129e80:	1021883a 	mov	r16,r2
81129e84:	112a2b40 	call	8112a2b4 <__udivsi3>
81129e88:	8006943a 	slli	r3,r16,16
81129e8c:	a008d43a 	srli	r4,r20,16
81129e90:	1545383a 	mul	r2,r2,r21
81129e94:	20c8b03a 	or	r4,r4,r3
81129e98:	2080042e 	bgeu	r4,r2,81129eac <__umoddi3+0x230>
81129e9c:	24c9883a 	add	r4,r4,r19
81129ea0:	24c00236 	bltu	r4,r19,81129eac <__umoddi3+0x230>
81129ea4:	2080012e 	bgeu	r4,r2,81129eac <__umoddi3+0x230>
81129ea8:	24c9883a 	add	r4,r4,r19
81129eac:	20a1c83a 	sub	r16,r4,r2
81129eb0:	b00b883a 	mov	r5,r22
81129eb4:	8009883a 	mov	r4,r16
81129eb8:	112a3180 	call	8112a318 <__umodsi3>
81129ebc:	1023883a 	mov	r17,r2
81129ec0:	b00b883a 	mov	r5,r22
81129ec4:	8009883a 	mov	r4,r16
81129ec8:	112a2b40 	call	8112a2b4 <__udivsi3>
81129ecc:	8822943a 	slli	r17,r17,16
81129ed0:	1545383a 	mul	r2,r2,r21
81129ed4:	a53fffcc 	andi	r20,r20,65535
81129ed8:	a446b03a 	or	r3,r20,r17
81129edc:	18bfb02e 	bgeu	r3,r2,81129da0 <__reset+0xfb109da0>
81129ee0:	003fab06 	br	81129d90 <__reset+0xfb109d90>
81129ee4:	2005883a 	mov	r2,r4
81129ee8:	2807883a 	mov	r3,r5
81129eec:	dfc00b17 	ldw	ra,44(sp)
81129ef0:	df000a17 	ldw	fp,40(sp)
81129ef4:	ddc00917 	ldw	r23,36(sp)
81129ef8:	dd800817 	ldw	r22,32(sp)
81129efc:	dd400717 	ldw	r21,28(sp)
81129f00:	dd000617 	ldw	r20,24(sp)
81129f04:	dcc00517 	ldw	r19,20(sp)
81129f08:	dc800417 	ldw	r18,16(sp)
81129f0c:	dc400317 	ldw	r17,12(sp)
81129f10:	dc000217 	ldw	r16,8(sp)
81129f14:	dec00c04 	addi	sp,sp,48
81129f18:	f800283a 	ret
81129f1c:	04c03fc4 	movi	r19,255
81129f20:	99c9803a 	cmpltu	r4,r19,r7
81129f24:	200890fa 	slli	r4,r4,3
81129f28:	003fa806 	br	81129dcc <__reset+0xfb109dcc>
81129f2c:	00803fc4 	movi	r2,255
81129f30:	14c5803a 	cmpltu	r2,r2,r19
81129f34:	100490fa 	slli	r2,r2,3
81129f38:	003fc006 	br	81129e3c <__reset+0xfb109e3c>
81129f3c:	00804034 	movhi	r2,256
81129f40:	10bfffc4 	addi	r2,r2,-1
81129f44:	11808b36 	bltu	r2,r6,8112a174 <__umoddi3+0x4f8>
81129f48:	01000404 	movi	r4,16
81129f4c:	003f6406 	br	81129ce0 <__reset+0xfb109ce0>
81129f50:	34c4d83a 	srl	r2,r6,r19
81129f54:	3d0e983a 	sll	r7,r7,r20
81129f58:	8cf8d83a 	srl	fp,r17,r19
81129f5c:	8d10983a 	sll	r8,r17,r20
81129f60:	38aab03a 	or	r21,r7,r2
81129f64:	a82cd43a 	srli	r22,r21,16
81129f68:	84e2d83a 	srl	r17,r16,r19
81129f6c:	e009883a 	mov	r4,fp
81129f70:	b00b883a 	mov	r5,r22
81129f74:	8a22b03a 	or	r17,r17,r8
81129f78:	3524983a 	sll	r18,r6,r20
81129f7c:	112a3180 	call	8112a318 <__umodsi3>
81129f80:	e009883a 	mov	r4,fp
81129f84:	b00b883a 	mov	r5,r22
81129f88:	102f883a 	mov	r23,r2
81129f8c:	112a2b40 	call	8112a2b4 <__udivsi3>
81129f90:	100d883a 	mov	r6,r2
81129f94:	b808943a 	slli	r4,r23,16
81129f98:	aa3fffcc 	andi	r8,r21,65535
81129f9c:	8804d43a 	srli	r2,r17,16
81129fa0:	41af383a 	mul	r23,r8,r6
81129fa4:	8520983a 	sll	r16,r16,r20
81129fa8:	1104b03a 	or	r2,r2,r4
81129fac:	15c0042e 	bgeu	r2,r23,81129fc0 <__umoddi3+0x344>
81129fb0:	1545883a 	add	r2,r2,r21
81129fb4:	30ffffc4 	addi	r3,r6,-1
81129fb8:	1540742e 	bgeu	r2,r21,8112a18c <__umoddi3+0x510>
81129fbc:	180d883a 	mov	r6,r3
81129fc0:	15efc83a 	sub	r23,r2,r23
81129fc4:	b00b883a 	mov	r5,r22
81129fc8:	b809883a 	mov	r4,r23
81129fcc:	d9800115 	stw	r6,4(sp)
81129fd0:	da000015 	stw	r8,0(sp)
81129fd4:	112a3180 	call	8112a318 <__umodsi3>
81129fd8:	b00b883a 	mov	r5,r22
81129fdc:	b809883a 	mov	r4,r23
81129fe0:	1039883a 	mov	fp,r2
81129fe4:	112a2b40 	call	8112a2b4 <__udivsi3>
81129fe8:	da000017 	ldw	r8,0(sp)
81129fec:	e038943a 	slli	fp,fp,16
81129ff0:	100b883a 	mov	r5,r2
81129ff4:	4089383a 	mul	r4,r8,r2
81129ff8:	8a3fffcc 	andi	r8,r17,65535
81129ffc:	4710b03a 	or	r8,r8,fp
8112a000:	d9800117 	ldw	r6,4(sp)
8112a004:	4100042e 	bgeu	r8,r4,8112a018 <__umoddi3+0x39c>
8112a008:	4551883a 	add	r8,r8,r21
8112a00c:	10bfffc4 	addi	r2,r2,-1
8112a010:	45405a2e 	bgeu	r8,r21,8112a17c <__umoddi3+0x500>
8112a014:	100b883a 	mov	r5,r2
8112a018:	300c943a 	slli	r6,r6,16
8112a01c:	91ffffcc 	andi	r7,r18,65535
8112a020:	9004d43a 	srli	r2,r18,16
8112a024:	314cb03a 	or	r6,r6,r5
8112a028:	317fffcc 	andi	r5,r6,65535
8112a02c:	300cd43a 	srli	r6,r6,16
8112a030:	29d3383a 	mul	r9,r5,r7
8112a034:	288b383a 	mul	r5,r5,r2
8112a038:	31cf383a 	mul	r7,r6,r7
8112a03c:	4806d43a 	srli	r3,r9,16
8112a040:	4111c83a 	sub	r8,r8,r4
8112a044:	29cb883a 	add	r5,r5,r7
8112a048:	194b883a 	add	r5,r3,r5
8112a04c:	3085383a 	mul	r2,r6,r2
8112a050:	29c0022e 	bgeu	r5,r7,8112a05c <__umoddi3+0x3e0>
8112a054:	00c00074 	movhi	r3,1
8112a058:	10c5883a 	add	r2,r2,r3
8112a05c:	2808d43a 	srli	r4,r5,16
8112a060:	280a943a 	slli	r5,r5,16
8112a064:	4a7fffcc 	andi	r9,r9,65535
8112a068:	2085883a 	add	r2,r4,r2
8112a06c:	2a4b883a 	add	r5,r5,r9
8112a070:	40803636 	bltu	r8,r2,8112a14c <__umoddi3+0x4d0>
8112a074:	40804d26 	beq	r8,r2,8112a1ac <__umoddi3+0x530>
8112a078:	4089c83a 	sub	r4,r8,r2
8112a07c:	280f883a 	mov	r7,r5
8112a080:	81cfc83a 	sub	r7,r16,r7
8112a084:	81c7803a 	cmpltu	r3,r16,r7
8112a088:	20c7c83a 	sub	r3,r4,r3
8112a08c:	1cc4983a 	sll	r2,r3,r19
8112a090:	3d0ed83a 	srl	r7,r7,r20
8112a094:	1d06d83a 	srl	r3,r3,r20
8112a098:	11c4b03a 	or	r2,r2,r7
8112a09c:	003f9306 	br	81129eec <__reset+0xfb109eec>
8112a0a0:	9ca6983a 	sll	r19,r19,r18
8112a0a4:	88e8d83a 	srl	r20,r17,r3
8112a0a8:	80c4d83a 	srl	r2,r16,r3
8112a0ac:	982cd43a 	srli	r22,r19,16
8112a0b0:	8ca2983a 	sll	r17,r17,r18
8112a0b4:	a009883a 	mov	r4,r20
8112a0b8:	b00b883a 	mov	r5,r22
8112a0bc:	1478b03a 	or	fp,r2,r17
8112a0c0:	112a3180 	call	8112a318 <__umodsi3>
8112a0c4:	a009883a 	mov	r4,r20
8112a0c8:	b00b883a 	mov	r5,r22
8112a0cc:	1023883a 	mov	r17,r2
8112a0d0:	112a2b40 	call	8112a2b4 <__udivsi3>
8112a0d4:	9d7fffcc 	andi	r21,r19,65535
8112a0d8:	880a943a 	slli	r5,r17,16
8112a0dc:	e008d43a 	srli	r4,fp,16
8112a0e0:	a885383a 	mul	r2,r21,r2
8112a0e4:	84a8983a 	sll	r20,r16,r18
8112a0e8:	2148b03a 	or	r4,r4,r5
8112a0ec:	2080042e 	bgeu	r4,r2,8112a100 <__umoddi3+0x484>
8112a0f0:	24c9883a 	add	r4,r4,r19
8112a0f4:	24c00236 	bltu	r4,r19,8112a100 <__umoddi3+0x484>
8112a0f8:	2080012e 	bgeu	r4,r2,8112a100 <__umoddi3+0x484>
8112a0fc:	24c9883a 	add	r4,r4,r19
8112a100:	20a3c83a 	sub	r17,r4,r2
8112a104:	b00b883a 	mov	r5,r22
8112a108:	8809883a 	mov	r4,r17
8112a10c:	112a3180 	call	8112a318 <__umodsi3>
8112a110:	102f883a 	mov	r23,r2
8112a114:	8809883a 	mov	r4,r17
8112a118:	b00b883a 	mov	r5,r22
8112a11c:	112a2b40 	call	8112a2b4 <__udivsi3>
8112a120:	b82e943a 	slli	r23,r23,16
8112a124:	a885383a 	mul	r2,r21,r2
8112a128:	e13fffcc 	andi	r4,fp,65535
8112a12c:	25c8b03a 	or	r4,r4,r23
8112a130:	2080042e 	bgeu	r4,r2,8112a144 <__umoddi3+0x4c8>
8112a134:	24c9883a 	add	r4,r4,r19
8112a138:	24c00236 	bltu	r4,r19,8112a144 <__umoddi3+0x4c8>
8112a13c:	2080012e 	bgeu	r4,r2,8112a144 <__umoddi3+0x4c8>
8112a140:	24c9883a 	add	r4,r4,r19
8112a144:	20a3c83a 	sub	r17,r4,r2
8112a148:	003f4806 	br	81129e6c <__reset+0xfb109e6c>
8112a14c:	2c8fc83a 	sub	r7,r5,r18
8112a150:	1545c83a 	sub	r2,r2,r21
8112a154:	29cb803a 	cmpltu	r5,r5,r7
8112a158:	1145c83a 	sub	r2,r2,r5
8112a15c:	4089c83a 	sub	r4,r8,r2
8112a160:	003fc706 	br	8112a080 <__reset+0xfb10a080>
8112a164:	01000604 	movi	r4,24
8112a168:	003f1806 	br	81129dcc <__reset+0xfb109dcc>
8112a16c:	00800604 	movi	r2,24
8112a170:	003f3206 	br	81129e3c <__reset+0xfb109e3c>
8112a174:	01000604 	movi	r4,24
8112a178:	003ed906 	br	81129ce0 <__reset+0xfb109ce0>
8112a17c:	413fa52e 	bgeu	r8,r4,8112a014 <__reset+0xfb10a014>
8112a180:	297fff84 	addi	r5,r5,-2
8112a184:	4551883a 	add	r8,r8,r21
8112a188:	003fa306 	br	8112a018 <__reset+0xfb10a018>
8112a18c:	15ff8b2e 	bgeu	r2,r23,81129fbc <__reset+0xfb109fbc>
8112a190:	31bfff84 	addi	r6,r6,-2
8112a194:	1545883a 	add	r2,r2,r21
8112a198:	003f8906 	br	81129fc0 <__reset+0xfb109fc0>
8112a19c:	24c9883a 	add	r4,r4,r19
8112a1a0:	003eee06 	br	81129d5c <__reset+0xfb109d5c>
8112a1a4:	8005883a 	mov	r2,r16
8112a1a8:	003f1706 	br	81129e08 <__reset+0xfb109e08>
8112a1ac:	817fe736 	bltu	r16,r5,8112a14c <__reset+0xfb10a14c>
8112a1b0:	280f883a 	mov	r7,r5
8112a1b4:	0009883a 	mov	r4,zero
8112a1b8:	003fb106 	br	8112a080 <__reset+0xfb10a080>

8112a1bc <__divsi3>:
8112a1bc:	20001b16 	blt	r4,zero,8112a22c <__divsi3+0x70>
8112a1c0:	000f883a 	mov	r7,zero
8112a1c4:	28001616 	blt	r5,zero,8112a220 <__divsi3+0x64>
8112a1c8:	200d883a 	mov	r6,r4
8112a1cc:	29001a2e 	bgeu	r5,r4,8112a238 <__divsi3+0x7c>
8112a1d0:	00800804 	movi	r2,32
8112a1d4:	00c00044 	movi	r3,1
8112a1d8:	00000106 	br	8112a1e0 <__divsi3+0x24>
8112a1dc:	10000d26 	beq	r2,zero,8112a214 <__divsi3+0x58>
8112a1e0:	294b883a 	add	r5,r5,r5
8112a1e4:	10bfffc4 	addi	r2,r2,-1
8112a1e8:	18c7883a 	add	r3,r3,r3
8112a1ec:	293ffb36 	bltu	r5,r4,8112a1dc <__reset+0xfb10a1dc>
8112a1f0:	0005883a 	mov	r2,zero
8112a1f4:	18000726 	beq	r3,zero,8112a214 <__divsi3+0x58>
8112a1f8:	0005883a 	mov	r2,zero
8112a1fc:	31400236 	bltu	r6,r5,8112a208 <__divsi3+0x4c>
8112a200:	314dc83a 	sub	r6,r6,r5
8112a204:	10c4b03a 	or	r2,r2,r3
8112a208:	1806d07a 	srli	r3,r3,1
8112a20c:	280ad07a 	srli	r5,r5,1
8112a210:	183ffa1e 	bne	r3,zero,8112a1fc <__reset+0xfb10a1fc>
8112a214:	38000126 	beq	r7,zero,8112a21c <__divsi3+0x60>
8112a218:	0085c83a 	sub	r2,zero,r2
8112a21c:	f800283a 	ret
8112a220:	014bc83a 	sub	r5,zero,r5
8112a224:	39c0005c 	xori	r7,r7,1
8112a228:	003fe706 	br	8112a1c8 <__reset+0xfb10a1c8>
8112a22c:	0109c83a 	sub	r4,zero,r4
8112a230:	01c00044 	movi	r7,1
8112a234:	003fe306 	br	8112a1c4 <__reset+0xfb10a1c4>
8112a238:	00c00044 	movi	r3,1
8112a23c:	003fee06 	br	8112a1f8 <__reset+0xfb10a1f8>

8112a240 <__modsi3>:
8112a240:	20001716 	blt	r4,zero,8112a2a0 <__modsi3+0x60>
8112a244:	000f883a 	mov	r7,zero
8112a248:	2005883a 	mov	r2,r4
8112a24c:	28001216 	blt	r5,zero,8112a298 <__modsi3+0x58>
8112a250:	2900162e 	bgeu	r5,r4,8112a2ac <__modsi3+0x6c>
8112a254:	01800804 	movi	r6,32
8112a258:	00c00044 	movi	r3,1
8112a25c:	00000106 	br	8112a264 <__modsi3+0x24>
8112a260:	30000a26 	beq	r6,zero,8112a28c <__modsi3+0x4c>
8112a264:	294b883a 	add	r5,r5,r5
8112a268:	31bfffc4 	addi	r6,r6,-1
8112a26c:	18c7883a 	add	r3,r3,r3
8112a270:	293ffb36 	bltu	r5,r4,8112a260 <__reset+0xfb10a260>
8112a274:	18000526 	beq	r3,zero,8112a28c <__modsi3+0x4c>
8112a278:	1806d07a 	srli	r3,r3,1
8112a27c:	11400136 	bltu	r2,r5,8112a284 <__modsi3+0x44>
8112a280:	1145c83a 	sub	r2,r2,r5
8112a284:	280ad07a 	srli	r5,r5,1
8112a288:	183ffb1e 	bne	r3,zero,8112a278 <__reset+0xfb10a278>
8112a28c:	38000126 	beq	r7,zero,8112a294 <__modsi3+0x54>
8112a290:	0085c83a 	sub	r2,zero,r2
8112a294:	f800283a 	ret
8112a298:	014bc83a 	sub	r5,zero,r5
8112a29c:	003fec06 	br	8112a250 <__reset+0xfb10a250>
8112a2a0:	0109c83a 	sub	r4,zero,r4
8112a2a4:	01c00044 	movi	r7,1
8112a2a8:	003fe706 	br	8112a248 <__reset+0xfb10a248>
8112a2ac:	00c00044 	movi	r3,1
8112a2b0:	003ff106 	br	8112a278 <__reset+0xfb10a278>

8112a2b4 <__udivsi3>:
8112a2b4:	200d883a 	mov	r6,r4
8112a2b8:	2900152e 	bgeu	r5,r4,8112a310 <__udivsi3+0x5c>
8112a2bc:	28001416 	blt	r5,zero,8112a310 <__udivsi3+0x5c>
8112a2c0:	00800804 	movi	r2,32
8112a2c4:	00c00044 	movi	r3,1
8112a2c8:	00000206 	br	8112a2d4 <__udivsi3+0x20>
8112a2cc:	10000e26 	beq	r2,zero,8112a308 <__udivsi3+0x54>
8112a2d0:	28000516 	blt	r5,zero,8112a2e8 <__udivsi3+0x34>
8112a2d4:	294b883a 	add	r5,r5,r5
8112a2d8:	10bfffc4 	addi	r2,r2,-1
8112a2dc:	18c7883a 	add	r3,r3,r3
8112a2e0:	293ffa36 	bltu	r5,r4,8112a2cc <__reset+0xfb10a2cc>
8112a2e4:	18000826 	beq	r3,zero,8112a308 <__udivsi3+0x54>
8112a2e8:	0005883a 	mov	r2,zero
8112a2ec:	31400236 	bltu	r6,r5,8112a2f8 <__udivsi3+0x44>
8112a2f0:	314dc83a 	sub	r6,r6,r5
8112a2f4:	10c4b03a 	or	r2,r2,r3
8112a2f8:	1806d07a 	srli	r3,r3,1
8112a2fc:	280ad07a 	srli	r5,r5,1
8112a300:	183ffa1e 	bne	r3,zero,8112a2ec <__reset+0xfb10a2ec>
8112a304:	f800283a 	ret
8112a308:	0005883a 	mov	r2,zero
8112a30c:	f800283a 	ret
8112a310:	00c00044 	movi	r3,1
8112a314:	003ff406 	br	8112a2e8 <__reset+0xfb10a2e8>

8112a318 <__umodsi3>:
8112a318:	2005883a 	mov	r2,r4
8112a31c:	2900122e 	bgeu	r5,r4,8112a368 <__umodsi3+0x50>
8112a320:	28001116 	blt	r5,zero,8112a368 <__umodsi3+0x50>
8112a324:	01800804 	movi	r6,32
8112a328:	00c00044 	movi	r3,1
8112a32c:	00000206 	br	8112a338 <__umodsi3+0x20>
8112a330:	30000c26 	beq	r6,zero,8112a364 <__umodsi3+0x4c>
8112a334:	28000516 	blt	r5,zero,8112a34c <__umodsi3+0x34>
8112a338:	294b883a 	add	r5,r5,r5
8112a33c:	31bfffc4 	addi	r6,r6,-1
8112a340:	18c7883a 	add	r3,r3,r3
8112a344:	293ffa36 	bltu	r5,r4,8112a330 <__reset+0xfb10a330>
8112a348:	18000626 	beq	r3,zero,8112a364 <__umodsi3+0x4c>
8112a34c:	1806d07a 	srli	r3,r3,1
8112a350:	11400136 	bltu	r2,r5,8112a358 <__umodsi3+0x40>
8112a354:	1145c83a 	sub	r2,r2,r5
8112a358:	280ad07a 	srli	r5,r5,1
8112a35c:	183ffb1e 	bne	r3,zero,8112a34c <__reset+0xfb10a34c>
8112a360:	f800283a 	ret
8112a364:	f800283a 	ret
8112a368:	00c00044 	movi	r3,1
8112a36c:	003ff706 	br	8112a34c <__reset+0xfb10a34c>

8112a370 <__eqsf2>:
8112a370:	2006d5fa 	srli	r3,r4,23
8112a374:	280cd5fa 	srli	r6,r5,23
8112a378:	01c02034 	movhi	r7,128
8112a37c:	39ffffc4 	addi	r7,r7,-1
8112a380:	18c03fcc 	andi	r3,r3,255
8112a384:	02003fc4 	movi	r8,255
8112a388:	3904703a 	and	r2,r7,r4
8112a38c:	31803fcc 	andi	r6,r6,255
8112a390:	394e703a 	and	r7,r7,r5
8112a394:	2008d7fa 	srli	r4,r4,31
8112a398:	280ad7fa 	srli	r5,r5,31
8112a39c:	1a000d26 	beq	r3,r8,8112a3d4 <__eqsf2+0x64>
8112a3a0:	02003fc4 	movi	r8,255
8112a3a4:	32000826 	beq	r6,r8,8112a3c8 <__eqsf2+0x58>
8112a3a8:	19800226 	beq	r3,r6,8112a3b4 <__eqsf2+0x44>
8112a3ac:	00800044 	movi	r2,1
8112a3b0:	f800283a 	ret
8112a3b4:	11fffd1e 	bne	r2,r7,8112a3ac <__reset+0xfb10a3ac>
8112a3b8:	21400926 	beq	r4,r5,8112a3e0 <__eqsf2+0x70>
8112a3bc:	183ffb1e 	bne	r3,zero,8112a3ac <__reset+0xfb10a3ac>
8112a3c0:	1004c03a 	cmpne	r2,r2,zero
8112a3c4:	f800283a 	ret
8112a3c8:	383ff726 	beq	r7,zero,8112a3a8 <__reset+0xfb10a3a8>
8112a3cc:	00800044 	movi	r2,1
8112a3d0:	f800283a 	ret
8112a3d4:	103ff226 	beq	r2,zero,8112a3a0 <__reset+0xfb10a3a0>
8112a3d8:	00800044 	movi	r2,1
8112a3dc:	f800283a 	ret
8112a3e0:	0005883a 	mov	r2,zero
8112a3e4:	f800283a 	ret

8112a3e8 <__gesf2>:
8112a3e8:	2004d5fa 	srli	r2,r4,23
8112a3ec:	2806d5fa 	srli	r3,r5,23
8112a3f0:	01802034 	movhi	r6,128
8112a3f4:	31bfffc4 	addi	r6,r6,-1
8112a3f8:	10803fcc 	andi	r2,r2,255
8112a3fc:	01c03fc4 	movi	r7,255
8112a400:	3110703a 	and	r8,r6,r4
8112a404:	18c03fcc 	andi	r3,r3,255
8112a408:	314c703a 	and	r6,r6,r5
8112a40c:	2008d7fa 	srli	r4,r4,31
8112a410:	280ad7fa 	srli	r5,r5,31
8112a414:	11c01926 	beq	r2,r7,8112a47c <__gesf2+0x94>
8112a418:	01c03fc4 	movi	r7,255
8112a41c:	19c00f26 	beq	r3,r7,8112a45c <__gesf2+0x74>
8112a420:	1000061e 	bne	r2,zero,8112a43c <__gesf2+0x54>
8112a424:	400f003a 	cmpeq	r7,r8,zero
8112a428:	1800071e 	bne	r3,zero,8112a448 <__gesf2+0x60>
8112a42c:	3000061e 	bne	r6,zero,8112a448 <__gesf2+0x60>
8112a430:	0005883a 	mov	r2,zero
8112a434:	40000e1e 	bne	r8,zero,8112a470 <__gesf2+0x88>
8112a438:	f800283a 	ret
8112a43c:	18000a1e 	bne	r3,zero,8112a468 <__gesf2+0x80>
8112a440:	30000b26 	beq	r6,zero,8112a470 <__gesf2+0x88>
8112a444:	000f883a 	mov	r7,zero
8112a448:	29403fcc 	andi	r5,r5,255
8112a44c:	38000726 	beq	r7,zero,8112a46c <__gesf2+0x84>
8112a450:	28000826 	beq	r5,zero,8112a474 <__gesf2+0x8c>
8112a454:	00800044 	movi	r2,1
8112a458:	f800283a 	ret
8112a45c:	303ff026 	beq	r6,zero,8112a420 <__reset+0xfb10a420>
8112a460:	00bfff84 	movi	r2,-2
8112a464:	f800283a 	ret
8112a468:	29403fcc 	andi	r5,r5,255
8112a46c:	21400526 	beq	r4,r5,8112a484 <__gesf2+0x9c>
8112a470:	203ff826 	beq	r4,zero,8112a454 <__reset+0xfb10a454>
8112a474:	00bfffc4 	movi	r2,-1
8112a478:	f800283a 	ret
8112a47c:	403fe626 	beq	r8,zero,8112a418 <__reset+0xfb10a418>
8112a480:	003ff706 	br	8112a460 <__reset+0xfb10a460>
8112a484:	18bffa16 	blt	r3,r2,8112a470 <__reset+0xfb10a470>
8112a488:	10c00216 	blt	r2,r3,8112a494 <__gesf2+0xac>
8112a48c:	323ff836 	bltu	r6,r8,8112a470 <__reset+0xfb10a470>
8112a490:	4180022e 	bgeu	r8,r6,8112a49c <__gesf2+0xb4>
8112a494:	203fef1e 	bne	r4,zero,8112a454 <__reset+0xfb10a454>
8112a498:	003ff606 	br	8112a474 <__reset+0xfb10a474>
8112a49c:	0005883a 	mov	r2,zero
8112a4a0:	f800283a 	ret

8112a4a4 <__lesf2>:
8112a4a4:	2004d5fa 	srli	r2,r4,23
8112a4a8:	280cd5fa 	srli	r6,r5,23
8112a4ac:	00c02034 	movhi	r3,128
8112a4b0:	18ffffc4 	addi	r3,r3,-1
8112a4b4:	10803fcc 	andi	r2,r2,255
8112a4b8:	01c03fc4 	movi	r7,255
8112a4bc:	1910703a 	and	r8,r3,r4
8112a4c0:	31803fcc 	andi	r6,r6,255
8112a4c4:	1946703a 	and	r3,r3,r5
8112a4c8:	2008d7fa 	srli	r4,r4,31
8112a4cc:	280ad7fa 	srli	r5,r5,31
8112a4d0:	11c01b26 	beq	r2,r7,8112a540 <__lesf2+0x9c>
8112a4d4:	01c03fc4 	movi	r7,255
8112a4d8:	31c01126 	beq	r6,r7,8112a520 <__lesf2+0x7c>
8112a4dc:	1000071e 	bne	r2,zero,8112a4fc <__lesf2+0x58>
8112a4e0:	400f003a 	cmpeq	r7,r8,zero
8112a4e4:	21003fcc 	andi	r4,r4,255
8112a4e8:	3000081e 	bne	r6,zero,8112a50c <__lesf2+0x68>
8112a4ec:	1800071e 	bne	r3,zero,8112a50c <__lesf2+0x68>
8112a4f0:	0005883a 	mov	r2,zero
8112a4f4:	40000f1e 	bne	r8,zero,8112a534 <__lesf2+0x90>
8112a4f8:	f800283a 	ret
8112a4fc:	21003fcc 	andi	r4,r4,255
8112a500:	30000a1e 	bne	r6,zero,8112a52c <__lesf2+0x88>
8112a504:	18000b26 	beq	r3,zero,8112a534 <__lesf2+0x90>
8112a508:	000f883a 	mov	r7,zero
8112a50c:	29403fcc 	andi	r5,r5,255
8112a510:	38000726 	beq	r7,zero,8112a530 <__lesf2+0x8c>
8112a514:	28000826 	beq	r5,zero,8112a538 <__lesf2+0x94>
8112a518:	00800044 	movi	r2,1
8112a51c:	f800283a 	ret
8112a520:	183fee26 	beq	r3,zero,8112a4dc <__reset+0xfb10a4dc>
8112a524:	00800084 	movi	r2,2
8112a528:	f800283a 	ret
8112a52c:	29403fcc 	andi	r5,r5,255
8112a530:	21400626 	beq	r4,r5,8112a54c <__lesf2+0xa8>
8112a534:	203ff826 	beq	r4,zero,8112a518 <__reset+0xfb10a518>
8112a538:	00bfffc4 	movi	r2,-1
8112a53c:	f800283a 	ret
8112a540:	403fe426 	beq	r8,zero,8112a4d4 <__reset+0xfb10a4d4>
8112a544:	00800084 	movi	r2,2
8112a548:	f800283a 	ret
8112a54c:	30bff916 	blt	r6,r2,8112a534 <__reset+0xfb10a534>
8112a550:	11800216 	blt	r2,r6,8112a55c <__lesf2+0xb8>
8112a554:	1a3ff736 	bltu	r3,r8,8112a534 <__reset+0xfb10a534>
8112a558:	40c0022e 	bgeu	r8,r3,8112a564 <__lesf2+0xc0>
8112a55c:	203fee1e 	bne	r4,zero,8112a518 <__reset+0xfb10a518>
8112a560:	003ff506 	br	8112a538 <__reset+0xfb10a538>
8112a564:	0005883a 	mov	r2,zero
8112a568:	f800283a 	ret

8112a56c <__adddf3>:
8112a56c:	02c00434 	movhi	r11,16
8112a570:	5affffc4 	addi	r11,r11,-1
8112a574:	2806d7fa 	srli	r3,r5,31
8112a578:	2ad4703a 	and	r10,r5,r11
8112a57c:	3ad2703a 	and	r9,r7,r11
8112a580:	3804d53a 	srli	r2,r7,20
8112a584:	3018d77a 	srli	r12,r6,29
8112a588:	280ad53a 	srli	r5,r5,20
8112a58c:	501490fa 	slli	r10,r10,3
8112a590:	2010d77a 	srli	r8,r4,29
8112a594:	481290fa 	slli	r9,r9,3
8112a598:	380ed7fa 	srli	r7,r7,31
8112a59c:	defffb04 	addi	sp,sp,-20
8112a5a0:	de00012e 	bgeu	sp,et,8112a5a8 <__adddf3+0x3c>
8112a5a4:	003b68fa 	trap	3
8112a5a8:	dc800215 	stw	r18,8(sp)
8112a5ac:	dc400115 	stw	r17,4(sp)
8112a5b0:	dc000015 	stw	r16,0(sp)
8112a5b4:	dfc00415 	stw	ra,16(sp)
8112a5b8:	dcc00315 	stw	r19,12(sp)
8112a5bc:	1c803fcc 	andi	r18,r3,255
8112a5c0:	2c01ffcc 	andi	r16,r5,2047
8112a5c4:	5210b03a 	or	r8,r10,r8
8112a5c8:	202290fa 	slli	r17,r4,3
8112a5cc:	1081ffcc 	andi	r2,r2,2047
8112a5d0:	4b12b03a 	or	r9,r9,r12
8112a5d4:	300c90fa 	slli	r6,r6,3
8112a5d8:	91c07526 	beq	r18,r7,8112a7b0 <__adddf3+0x244>
8112a5dc:	8087c83a 	sub	r3,r16,r2
8112a5e0:	00c0ab0e 	bge	zero,r3,8112a890 <__adddf3+0x324>
8112a5e4:	10002a1e 	bne	r2,zero,8112a690 <__adddf3+0x124>
8112a5e8:	4984b03a 	or	r2,r9,r6
8112a5ec:	1000961e 	bne	r2,zero,8112a848 <__adddf3+0x2dc>
8112a5f0:	888001cc 	andi	r2,r17,7
8112a5f4:	10000726 	beq	r2,zero,8112a614 <__adddf3+0xa8>
8112a5f8:	888003cc 	andi	r2,r17,15
8112a5fc:	00c00104 	movi	r3,4
8112a600:	10c00426 	beq	r2,r3,8112a614 <__adddf3+0xa8>
8112a604:	88c7883a 	add	r3,r17,r3
8112a608:	1c63803a 	cmpltu	r17,r3,r17
8112a60c:	4451883a 	add	r8,r8,r17
8112a610:	1823883a 	mov	r17,r3
8112a614:	4080202c 	andhi	r2,r8,128
8112a618:	10005926 	beq	r2,zero,8112a780 <__adddf3+0x214>
8112a61c:	84000044 	addi	r16,r16,1
8112a620:	0081ffc4 	movi	r2,2047
8112a624:	8080ba26 	beq	r16,r2,8112a910 <__adddf3+0x3a4>
8112a628:	00bfe034 	movhi	r2,65408
8112a62c:	10bfffc4 	addi	r2,r2,-1
8112a630:	4090703a 	and	r8,r8,r2
8112a634:	4004977a 	slli	r2,r8,29
8112a638:	4010927a 	slli	r8,r8,9
8112a63c:	8822d0fa 	srli	r17,r17,3
8112a640:	8401ffcc 	andi	r16,r16,2047
8112a644:	4010d33a 	srli	r8,r8,12
8112a648:	9007883a 	mov	r3,r18
8112a64c:	1444b03a 	or	r2,r2,r17
8112a650:	8401ffcc 	andi	r16,r16,2047
8112a654:	8020953a 	slli	r16,r16,20
8112a658:	18c03fcc 	andi	r3,r3,255
8112a65c:	01000434 	movhi	r4,16
8112a660:	213fffc4 	addi	r4,r4,-1
8112a664:	180697fa 	slli	r3,r3,31
8112a668:	4110703a 	and	r8,r8,r4
8112a66c:	4410b03a 	or	r8,r8,r16
8112a670:	40c6b03a 	or	r3,r8,r3
8112a674:	dfc00417 	ldw	ra,16(sp)
8112a678:	dcc00317 	ldw	r19,12(sp)
8112a67c:	dc800217 	ldw	r18,8(sp)
8112a680:	dc400117 	ldw	r17,4(sp)
8112a684:	dc000017 	ldw	r16,0(sp)
8112a688:	dec00504 	addi	sp,sp,20
8112a68c:	f800283a 	ret
8112a690:	0081ffc4 	movi	r2,2047
8112a694:	80bfd626 	beq	r16,r2,8112a5f0 <__reset+0xfb10a5f0>
8112a698:	4a402034 	orhi	r9,r9,128
8112a69c:	00800e04 	movi	r2,56
8112a6a0:	10c09f16 	blt	r2,r3,8112a920 <__adddf3+0x3b4>
8112a6a4:	008007c4 	movi	r2,31
8112a6a8:	10c0c216 	blt	r2,r3,8112a9b4 <__adddf3+0x448>
8112a6ac:	00800804 	movi	r2,32
8112a6b0:	10c5c83a 	sub	r2,r2,r3
8112a6b4:	488a983a 	sll	r5,r9,r2
8112a6b8:	30c8d83a 	srl	r4,r6,r3
8112a6bc:	3084983a 	sll	r2,r6,r2
8112a6c0:	48c6d83a 	srl	r3,r9,r3
8112a6c4:	290cb03a 	or	r6,r5,r4
8112a6c8:	1004c03a 	cmpne	r2,r2,zero
8112a6cc:	308cb03a 	or	r6,r6,r2
8112a6d0:	898dc83a 	sub	r6,r17,r6
8112a6d4:	89a3803a 	cmpltu	r17,r17,r6
8112a6d8:	40d1c83a 	sub	r8,r8,r3
8112a6dc:	4451c83a 	sub	r8,r8,r17
8112a6e0:	3023883a 	mov	r17,r6
8112a6e4:	4080202c 	andhi	r2,r8,128
8112a6e8:	10002326 	beq	r2,zero,8112a778 <__adddf3+0x20c>
8112a6ec:	04c02034 	movhi	r19,128
8112a6f0:	9cffffc4 	addi	r19,r19,-1
8112a6f4:	44e6703a 	and	r19,r8,r19
8112a6f8:	98007626 	beq	r19,zero,8112a8d4 <__adddf3+0x368>
8112a6fc:	9809883a 	mov	r4,r19
8112a700:	1116a5c0 	call	81116a5c <__clzsi2>
8112a704:	10fffe04 	addi	r3,r2,-8
8112a708:	010007c4 	movi	r4,31
8112a70c:	20c07716 	blt	r4,r3,8112a8ec <__adddf3+0x380>
8112a710:	00800804 	movi	r2,32
8112a714:	10c5c83a 	sub	r2,r2,r3
8112a718:	8884d83a 	srl	r2,r17,r2
8112a71c:	98d0983a 	sll	r8,r19,r3
8112a720:	88e2983a 	sll	r17,r17,r3
8112a724:	1204b03a 	or	r2,r2,r8
8112a728:	1c007416 	blt	r3,r16,8112a8fc <__adddf3+0x390>
8112a72c:	1c21c83a 	sub	r16,r3,r16
8112a730:	82000044 	addi	r8,r16,1
8112a734:	00c007c4 	movi	r3,31
8112a738:	1a009116 	blt	r3,r8,8112a980 <__adddf3+0x414>
8112a73c:	00c00804 	movi	r3,32
8112a740:	1a07c83a 	sub	r3,r3,r8
8112a744:	8a08d83a 	srl	r4,r17,r8
8112a748:	88e2983a 	sll	r17,r17,r3
8112a74c:	10c6983a 	sll	r3,r2,r3
8112a750:	1210d83a 	srl	r8,r2,r8
8112a754:	8804c03a 	cmpne	r2,r17,zero
8112a758:	1906b03a 	or	r3,r3,r4
8112a75c:	18a2b03a 	or	r17,r3,r2
8112a760:	0021883a 	mov	r16,zero
8112a764:	003fa206 	br	8112a5f0 <__reset+0xfb10a5f0>
8112a768:	1890b03a 	or	r8,r3,r2
8112a76c:	40017d26 	beq	r8,zero,8112ad64 <__adddf3+0x7f8>
8112a770:	1011883a 	mov	r8,r2
8112a774:	1823883a 	mov	r17,r3
8112a778:	888001cc 	andi	r2,r17,7
8112a77c:	103f9e1e 	bne	r2,zero,8112a5f8 <__reset+0xfb10a5f8>
8112a780:	4004977a 	slli	r2,r8,29
8112a784:	8822d0fa 	srli	r17,r17,3
8112a788:	4010d0fa 	srli	r8,r8,3
8112a78c:	9007883a 	mov	r3,r18
8112a790:	1444b03a 	or	r2,r2,r17
8112a794:	0101ffc4 	movi	r4,2047
8112a798:	81002426 	beq	r16,r4,8112a82c <__adddf3+0x2c0>
8112a79c:	8120703a 	and	r16,r16,r4
8112a7a0:	01000434 	movhi	r4,16
8112a7a4:	213fffc4 	addi	r4,r4,-1
8112a7a8:	4110703a 	and	r8,r8,r4
8112a7ac:	003fa806 	br	8112a650 <__reset+0xfb10a650>
8112a7b0:	8089c83a 	sub	r4,r16,r2
8112a7b4:	01005e0e 	bge	zero,r4,8112a930 <__adddf3+0x3c4>
8112a7b8:	10002b26 	beq	r2,zero,8112a868 <__adddf3+0x2fc>
8112a7bc:	0081ffc4 	movi	r2,2047
8112a7c0:	80bf8b26 	beq	r16,r2,8112a5f0 <__reset+0xfb10a5f0>
8112a7c4:	4a402034 	orhi	r9,r9,128
8112a7c8:	00800e04 	movi	r2,56
8112a7cc:	1100a40e 	bge	r2,r4,8112aa60 <__adddf3+0x4f4>
8112a7d0:	498cb03a 	or	r6,r9,r6
8112a7d4:	300ac03a 	cmpne	r5,r6,zero
8112a7d8:	0013883a 	mov	r9,zero
8112a7dc:	2c4b883a 	add	r5,r5,r17
8112a7e0:	2c63803a 	cmpltu	r17,r5,r17
8112a7e4:	4a11883a 	add	r8,r9,r8
8112a7e8:	8a11883a 	add	r8,r17,r8
8112a7ec:	2823883a 	mov	r17,r5
8112a7f0:	4080202c 	andhi	r2,r8,128
8112a7f4:	103fe026 	beq	r2,zero,8112a778 <__reset+0xfb10a778>
8112a7f8:	84000044 	addi	r16,r16,1
8112a7fc:	0081ffc4 	movi	r2,2047
8112a800:	8080d226 	beq	r16,r2,8112ab4c <__adddf3+0x5e0>
8112a804:	00bfe034 	movhi	r2,65408
8112a808:	10bfffc4 	addi	r2,r2,-1
8112a80c:	4090703a 	and	r8,r8,r2
8112a810:	880ad07a 	srli	r5,r17,1
8112a814:	400897fa 	slli	r4,r8,31
8112a818:	88c0004c 	andi	r3,r17,1
8112a81c:	28e2b03a 	or	r17,r5,r3
8112a820:	4010d07a 	srli	r8,r8,1
8112a824:	2462b03a 	or	r17,r4,r17
8112a828:	003f7106 	br	8112a5f0 <__reset+0xfb10a5f0>
8112a82c:	4088b03a 	or	r4,r8,r2
8112a830:	20014526 	beq	r4,zero,8112ad48 <__adddf3+0x7dc>
8112a834:	01000434 	movhi	r4,16
8112a838:	42000234 	orhi	r8,r8,8
8112a83c:	213fffc4 	addi	r4,r4,-1
8112a840:	4110703a 	and	r8,r8,r4
8112a844:	003f8206 	br	8112a650 <__reset+0xfb10a650>
8112a848:	18ffffc4 	addi	r3,r3,-1
8112a84c:	1800491e 	bne	r3,zero,8112a974 <__adddf3+0x408>
8112a850:	898bc83a 	sub	r5,r17,r6
8112a854:	8963803a 	cmpltu	r17,r17,r5
8112a858:	4251c83a 	sub	r8,r8,r9
8112a85c:	4451c83a 	sub	r8,r8,r17
8112a860:	2823883a 	mov	r17,r5
8112a864:	003f9f06 	br	8112a6e4 <__reset+0xfb10a6e4>
8112a868:	4984b03a 	or	r2,r9,r6
8112a86c:	103f6026 	beq	r2,zero,8112a5f0 <__reset+0xfb10a5f0>
8112a870:	213fffc4 	addi	r4,r4,-1
8112a874:	2000931e 	bne	r4,zero,8112aac4 <__adddf3+0x558>
8112a878:	898d883a 	add	r6,r17,r6
8112a87c:	3463803a 	cmpltu	r17,r6,r17
8112a880:	4251883a 	add	r8,r8,r9
8112a884:	8a11883a 	add	r8,r17,r8
8112a888:	3023883a 	mov	r17,r6
8112a88c:	003fd806 	br	8112a7f0 <__reset+0xfb10a7f0>
8112a890:	1800541e 	bne	r3,zero,8112a9e4 <__adddf3+0x478>
8112a894:	80800044 	addi	r2,r16,1
8112a898:	1081ffcc 	andi	r2,r2,2047
8112a89c:	00c00044 	movi	r3,1
8112a8a0:	1880a00e 	bge	r3,r2,8112ab24 <__adddf3+0x5b8>
8112a8a4:	8989c83a 	sub	r4,r17,r6
8112a8a8:	8905803a 	cmpltu	r2,r17,r4
8112a8ac:	4267c83a 	sub	r19,r8,r9
8112a8b0:	98a7c83a 	sub	r19,r19,r2
8112a8b4:	9880202c 	andhi	r2,r19,128
8112a8b8:	10006326 	beq	r2,zero,8112aa48 <__adddf3+0x4dc>
8112a8bc:	3463c83a 	sub	r17,r6,r17
8112a8c0:	4a07c83a 	sub	r3,r9,r8
8112a8c4:	344d803a 	cmpltu	r6,r6,r17
8112a8c8:	19a7c83a 	sub	r19,r3,r6
8112a8cc:	3825883a 	mov	r18,r7
8112a8d0:	983f8a1e 	bne	r19,zero,8112a6fc <__reset+0xfb10a6fc>
8112a8d4:	8809883a 	mov	r4,r17
8112a8d8:	1116a5c0 	call	81116a5c <__clzsi2>
8112a8dc:	10800804 	addi	r2,r2,32
8112a8e0:	10fffe04 	addi	r3,r2,-8
8112a8e4:	010007c4 	movi	r4,31
8112a8e8:	20ff890e 	bge	r4,r3,8112a710 <__reset+0xfb10a710>
8112a8ec:	10bff604 	addi	r2,r2,-40
8112a8f0:	8884983a 	sll	r2,r17,r2
8112a8f4:	0023883a 	mov	r17,zero
8112a8f8:	1c3f8c0e 	bge	r3,r16,8112a72c <__reset+0xfb10a72c>
8112a8fc:	023fe034 	movhi	r8,65408
8112a900:	423fffc4 	addi	r8,r8,-1
8112a904:	80e1c83a 	sub	r16,r16,r3
8112a908:	1210703a 	and	r8,r2,r8
8112a90c:	003f3806 	br	8112a5f0 <__reset+0xfb10a5f0>
8112a910:	9007883a 	mov	r3,r18
8112a914:	0011883a 	mov	r8,zero
8112a918:	0005883a 	mov	r2,zero
8112a91c:	003f4c06 	br	8112a650 <__reset+0xfb10a650>
8112a920:	498cb03a 	or	r6,r9,r6
8112a924:	300cc03a 	cmpne	r6,r6,zero
8112a928:	0007883a 	mov	r3,zero
8112a92c:	003f6806 	br	8112a6d0 <__reset+0xfb10a6d0>
8112a930:	20009c1e 	bne	r4,zero,8112aba4 <__adddf3+0x638>
8112a934:	80800044 	addi	r2,r16,1
8112a938:	1141ffcc 	andi	r5,r2,2047
8112a93c:	01000044 	movi	r4,1
8112a940:	2140670e 	bge	r4,r5,8112aae0 <__adddf3+0x574>
8112a944:	0101ffc4 	movi	r4,2047
8112a948:	11007f26 	beq	r2,r4,8112ab48 <__adddf3+0x5dc>
8112a94c:	898d883a 	add	r6,r17,r6
8112a950:	4247883a 	add	r3,r8,r9
8112a954:	3451803a 	cmpltu	r8,r6,r17
8112a958:	40d1883a 	add	r8,r8,r3
8112a95c:	402297fa 	slli	r17,r8,31
8112a960:	300cd07a 	srli	r6,r6,1
8112a964:	4010d07a 	srli	r8,r8,1
8112a968:	1021883a 	mov	r16,r2
8112a96c:	89a2b03a 	or	r17,r17,r6
8112a970:	003f1f06 	br	8112a5f0 <__reset+0xfb10a5f0>
8112a974:	0081ffc4 	movi	r2,2047
8112a978:	80bf481e 	bne	r16,r2,8112a69c <__reset+0xfb10a69c>
8112a97c:	003f1c06 	br	8112a5f0 <__reset+0xfb10a5f0>
8112a980:	843ff844 	addi	r16,r16,-31
8112a984:	01000804 	movi	r4,32
8112a988:	1406d83a 	srl	r3,r2,r16
8112a98c:	41005026 	beq	r8,r4,8112aad0 <__adddf3+0x564>
8112a990:	01001004 	movi	r4,64
8112a994:	2211c83a 	sub	r8,r4,r8
8112a998:	1204983a 	sll	r2,r2,r8
8112a99c:	88a2b03a 	or	r17,r17,r2
8112a9a0:	8822c03a 	cmpne	r17,r17,zero
8112a9a4:	1c62b03a 	or	r17,r3,r17
8112a9a8:	0011883a 	mov	r8,zero
8112a9ac:	0021883a 	mov	r16,zero
8112a9b0:	003f7106 	br	8112a778 <__reset+0xfb10a778>
8112a9b4:	193ff804 	addi	r4,r3,-32
8112a9b8:	00800804 	movi	r2,32
8112a9bc:	4908d83a 	srl	r4,r9,r4
8112a9c0:	18804526 	beq	r3,r2,8112aad8 <__adddf3+0x56c>
8112a9c4:	00801004 	movi	r2,64
8112a9c8:	10c5c83a 	sub	r2,r2,r3
8112a9cc:	4886983a 	sll	r3,r9,r2
8112a9d0:	198cb03a 	or	r6,r3,r6
8112a9d4:	300cc03a 	cmpne	r6,r6,zero
8112a9d8:	218cb03a 	or	r6,r4,r6
8112a9dc:	0007883a 	mov	r3,zero
8112a9e0:	003f3b06 	br	8112a6d0 <__reset+0xfb10a6d0>
8112a9e4:	80002a26 	beq	r16,zero,8112aa90 <__adddf3+0x524>
8112a9e8:	0101ffc4 	movi	r4,2047
8112a9ec:	11006826 	beq	r2,r4,8112ab90 <__adddf3+0x624>
8112a9f0:	00c7c83a 	sub	r3,zero,r3
8112a9f4:	42002034 	orhi	r8,r8,128
8112a9f8:	01000e04 	movi	r4,56
8112a9fc:	20c07c16 	blt	r4,r3,8112abf0 <__adddf3+0x684>
8112aa00:	010007c4 	movi	r4,31
8112aa04:	20c0da16 	blt	r4,r3,8112ad70 <__adddf3+0x804>
8112aa08:	01000804 	movi	r4,32
8112aa0c:	20c9c83a 	sub	r4,r4,r3
8112aa10:	4114983a 	sll	r10,r8,r4
8112aa14:	88cad83a 	srl	r5,r17,r3
8112aa18:	8908983a 	sll	r4,r17,r4
8112aa1c:	40c6d83a 	srl	r3,r8,r3
8112aa20:	5162b03a 	or	r17,r10,r5
8112aa24:	2008c03a 	cmpne	r4,r4,zero
8112aa28:	8922b03a 	or	r17,r17,r4
8112aa2c:	3463c83a 	sub	r17,r6,r17
8112aa30:	48c7c83a 	sub	r3,r9,r3
8112aa34:	344d803a 	cmpltu	r6,r6,r17
8112aa38:	1991c83a 	sub	r8,r3,r6
8112aa3c:	1021883a 	mov	r16,r2
8112aa40:	3825883a 	mov	r18,r7
8112aa44:	003f2706 	br	8112a6e4 <__reset+0xfb10a6e4>
8112aa48:	24d0b03a 	or	r8,r4,r19
8112aa4c:	40001b1e 	bne	r8,zero,8112aabc <__adddf3+0x550>
8112aa50:	0005883a 	mov	r2,zero
8112aa54:	0007883a 	mov	r3,zero
8112aa58:	0021883a 	mov	r16,zero
8112aa5c:	003f4d06 	br	8112a794 <__reset+0xfb10a794>
8112aa60:	008007c4 	movi	r2,31
8112aa64:	11003c16 	blt	r2,r4,8112ab58 <__adddf3+0x5ec>
8112aa68:	00800804 	movi	r2,32
8112aa6c:	1105c83a 	sub	r2,r2,r4
8112aa70:	488e983a 	sll	r7,r9,r2
8112aa74:	310ad83a 	srl	r5,r6,r4
8112aa78:	3084983a 	sll	r2,r6,r2
8112aa7c:	4912d83a 	srl	r9,r9,r4
8112aa80:	394ab03a 	or	r5,r7,r5
8112aa84:	1004c03a 	cmpne	r2,r2,zero
8112aa88:	288ab03a 	or	r5,r5,r2
8112aa8c:	003f5306 	br	8112a7dc <__reset+0xfb10a7dc>
8112aa90:	4448b03a 	or	r4,r8,r17
8112aa94:	20003e26 	beq	r4,zero,8112ab90 <__adddf3+0x624>
8112aa98:	00c6303a 	nor	r3,zero,r3
8112aa9c:	18003a1e 	bne	r3,zero,8112ab88 <__adddf3+0x61c>
8112aaa0:	3463c83a 	sub	r17,r6,r17
8112aaa4:	4a07c83a 	sub	r3,r9,r8
8112aaa8:	344d803a 	cmpltu	r6,r6,r17
8112aaac:	1991c83a 	sub	r8,r3,r6
8112aab0:	1021883a 	mov	r16,r2
8112aab4:	3825883a 	mov	r18,r7
8112aab8:	003f0a06 	br	8112a6e4 <__reset+0xfb10a6e4>
8112aabc:	2023883a 	mov	r17,r4
8112aac0:	003f0d06 	br	8112a6f8 <__reset+0xfb10a6f8>
8112aac4:	0081ffc4 	movi	r2,2047
8112aac8:	80bf3f1e 	bne	r16,r2,8112a7c8 <__reset+0xfb10a7c8>
8112aacc:	003ec806 	br	8112a5f0 <__reset+0xfb10a5f0>
8112aad0:	0005883a 	mov	r2,zero
8112aad4:	003fb106 	br	8112a99c <__reset+0xfb10a99c>
8112aad8:	0007883a 	mov	r3,zero
8112aadc:	003fbc06 	br	8112a9d0 <__reset+0xfb10a9d0>
8112aae0:	4444b03a 	or	r2,r8,r17
8112aae4:	8000871e 	bne	r16,zero,8112ad04 <__adddf3+0x798>
8112aae8:	1000ba26 	beq	r2,zero,8112add4 <__adddf3+0x868>
8112aaec:	4984b03a 	or	r2,r9,r6
8112aaf0:	103ebf26 	beq	r2,zero,8112a5f0 <__reset+0xfb10a5f0>
8112aaf4:	8985883a 	add	r2,r17,r6
8112aaf8:	4247883a 	add	r3,r8,r9
8112aafc:	1451803a 	cmpltu	r8,r2,r17
8112ab00:	40d1883a 	add	r8,r8,r3
8112ab04:	40c0202c 	andhi	r3,r8,128
8112ab08:	1023883a 	mov	r17,r2
8112ab0c:	183f1a26 	beq	r3,zero,8112a778 <__reset+0xfb10a778>
8112ab10:	00bfe034 	movhi	r2,65408
8112ab14:	10bfffc4 	addi	r2,r2,-1
8112ab18:	2021883a 	mov	r16,r4
8112ab1c:	4090703a 	and	r8,r8,r2
8112ab20:	003eb306 	br	8112a5f0 <__reset+0xfb10a5f0>
8112ab24:	4444b03a 	or	r2,r8,r17
8112ab28:	8000291e 	bne	r16,zero,8112abd0 <__adddf3+0x664>
8112ab2c:	10004b1e 	bne	r2,zero,8112ac5c <__adddf3+0x6f0>
8112ab30:	4990b03a 	or	r8,r9,r6
8112ab34:	40008b26 	beq	r8,zero,8112ad64 <__adddf3+0x7f8>
8112ab38:	4811883a 	mov	r8,r9
8112ab3c:	3023883a 	mov	r17,r6
8112ab40:	3825883a 	mov	r18,r7
8112ab44:	003eaa06 	br	8112a5f0 <__reset+0xfb10a5f0>
8112ab48:	1021883a 	mov	r16,r2
8112ab4c:	0011883a 	mov	r8,zero
8112ab50:	0005883a 	mov	r2,zero
8112ab54:	003f0f06 	br	8112a794 <__reset+0xfb10a794>
8112ab58:	217ff804 	addi	r5,r4,-32
8112ab5c:	00800804 	movi	r2,32
8112ab60:	494ad83a 	srl	r5,r9,r5
8112ab64:	20807d26 	beq	r4,r2,8112ad5c <__adddf3+0x7f0>
8112ab68:	00801004 	movi	r2,64
8112ab6c:	1109c83a 	sub	r4,r2,r4
8112ab70:	4912983a 	sll	r9,r9,r4
8112ab74:	498cb03a 	or	r6,r9,r6
8112ab78:	300cc03a 	cmpne	r6,r6,zero
8112ab7c:	298ab03a 	or	r5,r5,r6
8112ab80:	0013883a 	mov	r9,zero
8112ab84:	003f1506 	br	8112a7dc <__reset+0xfb10a7dc>
8112ab88:	0101ffc4 	movi	r4,2047
8112ab8c:	113f9a1e 	bne	r2,r4,8112a9f8 <__reset+0xfb10a9f8>
8112ab90:	4811883a 	mov	r8,r9
8112ab94:	3023883a 	mov	r17,r6
8112ab98:	1021883a 	mov	r16,r2
8112ab9c:	3825883a 	mov	r18,r7
8112aba0:	003e9306 	br	8112a5f0 <__reset+0xfb10a5f0>
8112aba4:	8000161e 	bne	r16,zero,8112ac00 <__adddf3+0x694>
8112aba8:	444ab03a 	or	r5,r8,r17
8112abac:	28005126 	beq	r5,zero,8112acf4 <__adddf3+0x788>
8112abb0:	0108303a 	nor	r4,zero,r4
8112abb4:	20004d1e 	bne	r4,zero,8112acec <__adddf3+0x780>
8112abb8:	89a3883a 	add	r17,r17,r6
8112abbc:	4253883a 	add	r9,r8,r9
8112abc0:	898d803a 	cmpltu	r6,r17,r6
8112abc4:	3251883a 	add	r8,r6,r9
8112abc8:	1021883a 	mov	r16,r2
8112abcc:	003f0806 	br	8112a7f0 <__reset+0xfb10a7f0>
8112abd0:	1000301e 	bne	r2,zero,8112ac94 <__adddf3+0x728>
8112abd4:	4984b03a 	or	r2,r9,r6
8112abd8:	10007126 	beq	r2,zero,8112ada0 <__adddf3+0x834>
8112abdc:	4811883a 	mov	r8,r9
8112abe0:	3023883a 	mov	r17,r6
8112abe4:	3825883a 	mov	r18,r7
8112abe8:	0401ffc4 	movi	r16,2047
8112abec:	003e8006 	br	8112a5f0 <__reset+0xfb10a5f0>
8112abf0:	4462b03a 	or	r17,r8,r17
8112abf4:	8822c03a 	cmpne	r17,r17,zero
8112abf8:	0007883a 	mov	r3,zero
8112abfc:	003f8b06 	br	8112aa2c <__reset+0xfb10aa2c>
8112ac00:	0141ffc4 	movi	r5,2047
8112ac04:	11403b26 	beq	r2,r5,8112acf4 <__adddf3+0x788>
8112ac08:	0109c83a 	sub	r4,zero,r4
8112ac0c:	42002034 	orhi	r8,r8,128
8112ac10:	01400e04 	movi	r5,56
8112ac14:	29006716 	blt	r5,r4,8112adb4 <__adddf3+0x848>
8112ac18:	014007c4 	movi	r5,31
8112ac1c:	29007016 	blt	r5,r4,8112ade0 <__adddf3+0x874>
8112ac20:	01400804 	movi	r5,32
8112ac24:	290bc83a 	sub	r5,r5,r4
8112ac28:	4154983a 	sll	r10,r8,r5
8112ac2c:	890ed83a 	srl	r7,r17,r4
8112ac30:	894a983a 	sll	r5,r17,r5
8112ac34:	4108d83a 	srl	r4,r8,r4
8112ac38:	51e2b03a 	or	r17,r10,r7
8112ac3c:	280ac03a 	cmpne	r5,r5,zero
8112ac40:	8962b03a 	or	r17,r17,r5
8112ac44:	89a3883a 	add	r17,r17,r6
8112ac48:	2253883a 	add	r9,r4,r9
8112ac4c:	898d803a 	cmpltu	r6,r17,r6
8112ac50:	3251883a 	add	r8,r6,r9
8112ac54:	1021883a 	mov	r16,r2
8112ac58:	003ee506 	br	8112a7f0 <__reset+0xfb10a7f0>
8112ac5c:	4984b03a 	or	r2,r9,r6
8112ac60:	103e6326 	beq	r2,zero,8112a5f0 <__reset+0xfb10a5f0>
8112ac64:	8987c83a 	sub	r3,r17,r6
8112ac68:	88c9803a 	cmpltu	r4,r17,r3
8112ac6c:	4245c83a 	sub	r2,r8,r9
8112ac70:	1105c83a 	sub	r2,r2,r4
8112ac74:	1100202c 	andhi	r4,r2,128
8112ac78:	203ebb26 	beq	r4,zero,8112a768 <__reset+0xfb10a768>
8112ac7c:	3463c83a 	sub	r17,r6,r17
8112ac80:	4a07c83a 	sub	r3,r9,r8
8112ac84:	344d803a 	cmpltu	r6,r6,r17
8112ac88:	1991c83a 	sub	r8,r3,r6
8112ac8c:	3825883a 	mov	r18,r7
8112ac90:	003e5706 	br	8112a5f0 <__reset+0xfb10a5f0>
8112ac94:	4984b03a 	or	r2,r9,r6
8112ac98:	10002e26 	beq	r2,zero,8112ad54 <__adddf3+0x7e8>
8112ac9c:	4004d0fa 	srli	r2,r8,3
8112aca0:	8822d0fa 	srli	r17,r17,3
8112aca4:	4010977a 	slli	r8,r8,29
8112aca8:	10c0022c 	andhi	r3,r2,8
8112acac:	4462b03a 	or	r17,r8,r17
8112acb0:	18000826 	beq	r3,zero,8112acd4 <__adddf3+0x768>
8112acb4:	4808d0fa 	srli	r4,r9,3
8112acb8:	20c0022c 	andhi	r3,r4,8
8112acbc:	1800051e 	bne	r3,zero,8112acd4 <__adddf3+0x768>
8112acc0:	300cd0fa 	srli	r6,r6,3
8112acc4:	4806977a 	slli	r3,r9,29
8112acc8:	2005883a 	mov	r2,r4
8112accc:	3825883a 	mov	r18,r7
8112acd0:	19a2b03a 	or	r17,r3,r6
8112acd4:	8810d77a 	srli	r8,r17,29
8112acd8:	100490fa 	slli	r2,r2,3
8112acdc:	882290fa 	slli	r17,r17,3
8112ace0:	0401ffc4 	movi	r16,2047
8112ace4:	4090b03a 	or	r8,r8,r2
8112ace8:	003e4106 	br	8112a5f0 <__reset+0xfb10a5f0>
8112acec:	0141ffc4 	movi	r5,2047
8112acf0:	117fc71e 	bne	r2,r5,8112ac10 <__reset+0xfb10ac10>
8112acf4:	4811883a 	mov	r8,r9
8112acf8:	3023883a 	mov	r17,r6
8112acfc:	1021883a 	mov	r16,r2
8112ad00:	003e3b06 	br	8112a5f0 <__reset+0xfb10a5f0>
8112ad04:	10002f26 	beq	r2,zero,8112adc4 <__adddf3+0x858>
8112ad08:	4984b03a 	or	r2,r9,r6
8112ad0c:	10001126 	beq	r2,zero,8112ad54 <__adddf3+0x7e8>
8112ad10:	4004d0fa 	srli	r2,r8,3
8112ad14:	8822d0fa 	srli	r17,r17,3
8112ad18:	4010977a 	slli	r8,r8,29
8112ad1c:	10c0022c 	andhi	r3,r2,8
8112ad20:	4462b03a 	or	r17,r8,r17
8112ad24:	183feb26 	beq	r3,zero,8112acd4 <__reset+0xfb10acd4>
8112ad28:	4808d0fa 	srli	r4,r9,3
8112ad2c:	20c0022c 	andhi	r3,r4,8
8112ad30:	183fe81e 	bne	r3,zero,8112acd4 <__reset+0xfb10acd4>
8112ad34:	300cd0fa 	srli	r6,r6,3
8112ad38:	4806977a 	slli	r3,r9,29
8112ad3c:	2005883a 	mov	r2,r4
8112ad40:	19a2b03a 	or	r17,r3,r6
8112ad44:	003fe306 	br	8112acd4 <__reset+0xfb10acd4>
8112ad48:	0011883a 	mov	r8,zero
8112ad4c:	0005883a 	mov	r2,zero
8112ad50:	003e3f06 	br	8112a650 <__reset+0xfb10a650>
8112ad54:	0401ffc4 	movi	r16,2047
8112ad58:	003e2506 	br	8112a5f0 <__reset+0xfb10a5f0>
8112ad5c:	0013883a 	mov	r9,zero
8112ad60:	003f8406 	br	8112ab74 <__reset+0xfb10ab74>
8112ad64:	0005883a 	mov	r2,zero
8112ad68:	0007883a 	mov	r3,zero
8112ad6c:	003e8906 	br	8112a794 <__reset+0xfb10a794>
8112ad70:	197ff804 	addi	r5,r3,-32
8112ad74:	01000804 	movi	r4,32
8112ad78:	414ad83a 	srl	r5,r8,r5
8112ad7c:	19002426 	beq	r3,r4,8112ae10 <__adddf3+0x8a4>
8112ad80:	01001004 	movi	r4,64
8112ad84:	20c7c83a 	sub	r3,r4,r3
8112ad88:	40c6983a 	sll	r3,r8,r3
8112ad8c:	1c46b03a 	or	r3,r3,r17
8112ad90:	1806c03a 	cmpne	r3,r3,zero
8112ad94:	28e2b03a 	or	r17,r5,r3
8112ad98:	0007883a 	mov	r3,zero
8112ad9c:	003f2306 	br	8112aa2c <__reset+0xfb10aa2c>
8112ada0:	0007883a 	mov	r3,zero
8112ada4:	5811883a 	mov	r8,r11
8112ada8:	00bfffc4 	movi	r2,-1
8112adac:	0401ffc4 	movi	r16,2047
8112adb0:	003e7806 	br	8112a794 <__reset+0xfb10a794>
8112adb4:	4462b03a 	or	r17,r8,r17
8112adb8:	8822c03a 	cmpne	r17,r17,zero
8112adbc:	0009883a 	mov	r4,zero
8112adc0:	003fa006 	br	8112ac44 <__reset+0xfb10ac44>
8112adc4:	4811883a 	mov	r8,r9
8112adc8:	3023883a 	mov	r17,r6
8112adcc:	0401ffc4 	movi	r16,2047
8112add0:	003e0706 	br	8112a5f0 <__reset+0xfb10a5f0>
8112add4:	4811883a 	mov	r8,r9
8112add8:	3023883a 	mov	r17,r6
8112addc:	003e0406 	br	8112a5f0 <__reset+0xfb10a5f0>
8112ade0:	21fff804 	addi	r7,r4,-32
8112ade4:	01400804 	movi	r5,32
8112ade8:	41ced83a 	srl	r7,r8,r7
8112adec:	21400a26 	beq	r4,r5,8112ae18 <__adddf3+0x8ac>
8112adf0:	01401004 	movi	r5,64
8112adf4:	2909c83a 	sub	r4,r5,r4
8112adf8:	4108983a 	sll	r4,r8,r4
8112adfc:	2448b03a 	or	r4,r4,r17
8112ae00:	2008c03a 	cmpne	r4,r4,zero
8112ae04:	3922b03a 	or	r17,r7,r4
8112ae08:	0009883a 	mov	r4,zero
8112ae0c:	003f8d06 	br	8112ac44 <__reset+0xfb10ac44>
8112ae10:	0007883a 	mov	r3,zero
8112ae14:	003fdd06 	br	8112ad8c <__reset+0xfb10ad8c>
8112ae18:	0009883a 	mov	r4,zero
8112ae1c:	003ff706 	br	8112adfc <__reset+0xfb10adfc>

8112ae20 <__divdf3>:
8112ae20:	defff204 	addi	sp,sp,-56
8112ae24:	de00012e 	bgeu	sp,et,8112ae2c <__divdf3+0xc>
8112ae28:	003b68fa 	trap	3
8112ae2c:	dd400915 	stw	r21,36(sp)
8112ae30:	282ad53a 	srli	r21,r5,20
8112ae34:	dd000815 	stw	r20,32(sp)
8112ae38:	2828d7fa 	srli	r20,r5,31
8112ae3c:	dc000415 	stw	r16,16(sp)
8112ae40:	04000434 	movhi	r16,16
8112ae44:	df000c15 	stw	fp,48(sp)
8112ae48:	843fffc4 	addi	r16,r16,-1
8112ae4c:	dfc00d15 	stw	ra,52(sp)
8112ae50:	ddc00b15 	stw	r23,44(sp)
8112ae54:	dd800a15 	stw	r22,40(sp)
8112ae58:	dcc00715 	stw	r19,28(sp)
8112ae5c:	dc800615 	stw	r18,24(sp)
8112ae60:	dc400515 	stw	r17,20(sp)
8112ae64:	ad41ffcc 	andi	r21,r21,2047
8112ae68:	2c20703a 	and	r16,r5,r16
8112ae6c:	a7003fcc 	andi	fp,r20,255
8112ae70:	a8006126 	beq	r21,zero,8112aff8 <__divdf3+0x1d8>
8112ae74:	0081ffc4 	movi	r2,2047
8112ae78:	2025883a 	mov	r18,r4
8112ae7c:	a8803726 	beq	r21,r2,8112af5c <__divdf3+0x13c>
8112ae80:	80800434 	orhi	r2,r16,16
8112ae84:	100490fa 	slli	r2,r2,3
8112ae88:	2020d77a 	srli	r16,r4,29
8112ae8c:	202490fa 	slli	r18,r4,3
8112ae90:	ad7f0044 	addi	r21,r21,-1023
8112ae94:	80a0b03a 	or	r16,r16,r2
8112ae98:	0027883a 	mov	r19,zero
8112ae9c:	0013883a 	mov	r9,zero
8112aea0:	3804d53a 	srli	r2,r7,20
8112aea4:	382cd7fa 	srli	r22,r7,31
8112aea8:	04400434 	movhi	r17,16
8112aeac:	8c7fffc4 	addi	r17,r17,-1
8112aeb0:	1081ffcc 	andi	r2,r2,2047
8112aeb4:	3011883a 	mov	r8,r6
8112aeb8:	3c62703a 	and	r17,r7,r17
8112aebc:	b5c03fcc 	andi	r23,r22,255
8112aec0:	10006c26 	beq	r2,zero,8112b074 <__divdf3+0x254>
8112aec4:	00c1ffc4 	movi	r3,2047
8112aec8:	10c06426 	beq	r2,r3,8112b05c <__divdf3+0x23c>
8112aecc:	88c00434 	orhi	r3,r17,16
8112aed0:	180690fa 	slli	r3,r3,3
8112aed4:	3022d77a 	srli	r17,r6,29
8112aed8:	301090fa 	slli	r8,r6,3
8112aedc:	10bf0044 	addi	r2,r2,-1023
8112aee0:	88e2b03a 	or	r17,r17,r3
8112aee4:	000f883a 	mov	r7,zero
8112aee8:	a58cf03a 	xor	r6,r20,r22
8112aeec:	3cc8b03a 	or	r4,r7,r19
8112aef0:	a8abc83a 	sub	r21,r21,r2
8112aef4:	008003c4 	movi	r2,15
8112aef8:	3007883a 	mov	r3,r6
8112aefc:	34c03fcc 	andi	r19,r6,255
8112af00:	11009036 	bltu	r2,r4,8112b144 <__divdf3+0x324>
8112af04:	200890ba 	slli	r4,r4,2
8112af08:	00a044f4 	movhi	r2,33043
8112af0c:	10abc704 	addi	r2,r2,-20708
8112af10:	2089883a 	add	r4,r4,r2
8112af14:	20800017 	ldw	r2,0(r4)
8112af18:	1000683a 	jmp	r2
8112af1c:	8112b144 	addi	r4,r16,19141
8112af20:	8112af94 	ori	r4,r16,19134
8112af24:	8112b134 	orhi	r4,r16,19140
8112af28:	8112af88 	cmpgei	r4,r16,19134
8112af2c:	8112b134 	orhi	r4,r16,19140
8112af30:	8112b108 	cmpgei	r4,r16,19140
8112af34:	8112b134 	orhi	r4,r16,19140
8112af38:	8112af88 	cmpgei	r4,r16,19134
8112af3c:	8112af94 	ori	r4,r16,19134
8112af40:	8112af94 	ori	r4,r16,19134
8112af44:	8112b108 	cmpgei	r4,r16,19140
8112af48:	8112af88 	cmpgei	r4,r16,19134
8112af4c:	8112af78 	rdprs	r4,r16,19133
8112af50:	8112af78 	rdprs	r4,r16,19133
8112af54:	8112af78 	rdprs	r4,r16,19133
8112af58:	8112b428 	cmpgeui	r4,r16,19152
8112af5c:	2404b03a 	or	r2,r4,r16
8112af60:	1000661e 	bne	r2,zero,8112b0fc <__divdf3+0x2dc>
8112af64:	04c00204 	movi	r19,8
8112af68:	0021883a 	mov	r16,zero
8112af6c:	0025883a 	mov	r18,zero
8112af70:	02400084 	movi	r9,2
8112af74:	003fca06 	br	8112aea0 <__reset+0xfb10aea0>
8112af78:	8023883a 	mov	r17,r16
8112af7c:	9011883a 	mov	r8,r18
8112af80:	e02f883a 	mov	r23,fp
8112af84:	480f883a 	mov	r7,r9
8112af88:	00800084 	movi	r2,2
8112af8c:	3881311e 	bne	r7,r2,8112b454 <__divdf3+0x634>
8112af90:	b827883a 	mov	r19,r23
8112af94:	98c0004c 	andi	r3,r19,1
8112af98:	0081ffc4 	movi	r2,2047
8112af9c:	000b883a 	mov	r5,zero
8112afa0:	0025883a 	mov	r18,zero
8112afa4:	1004953a 	slli	r2,r2,20
8112afa8:	18c03fcc 	andi	r3,r3,255
8112afac:	04400434 	movhi	r17,16
8112afb0:	8c7fffc4 	addi	r17,r17,-1
8112afb4:	180697fa 	slli	r3,r3,31
8112afb8:	2c4a703a 	and	r5,r5,r17
8112afbc:	288ab03a 	or	r5,r5,r2
8112afc0:	28c6b03a 	or	r3,r5,r3
8112afc4:	9005883a 	mov	r2,r18
8112afc8:	dfc00d17 	ldw	ra,52(sp)
8112afcc:	df000c17 	ldw	fp,48(sp)
8112afd0:	ddc00b17 	ldw	r23,44(sp)
8112afd4:	dd800a17 	ldw	r22,40(sp)
8112afd8:	dd400917 	ldw	r21,36(sp)
8112afdc:	dd000817 	ldw	r20,32(sp)
8112afe0:	dcc00717 	ldw	r19,28(sp)
8112afe4:	dc800617 	ldw	r18,24(sp)
8112afe8:	dc400517 	ldw	r17,20(sp)
8112afec:	dc000417 	ldw	r16,16(sp)
8112aff0:	dec00e04 	addi	sp,sp,56
8112aff4:	f800283a 	ret
8112aff8:	2404b03a 	or	r2,r4,r16
8112affc:	2027883a 	mov	r19,r4
8112b000:	10003926 	beq	r2,zero,8112b0e8 <__divdf3+0x2c8>
8112b004:	80012e26 	beq	r16,zero,8112b4c0 <__divdf3+0x6a0>
8112b008:	8009883a 	mov	r4,r16
8112b00c:	d9800315 	stw	r6,12(sp)
8112b010:	d9c00215 	stw	r7,8(sp)
8112b014:	1116a5c0 	call	81116a5c <__clzsi2>
8112b018:	d9800317 	ldw	r6,12(sp)
8112b01c:	d9c00217 	ldw	r7,8(sp)
8112b020:	113ffd44 	addi	r4,r2,-11
8112b024:	00c00704 	movi	r3,28
8112b028:	19012116 	blt	r3,r4,8112b4b0 <__divdf3+0x690>
8112b02c:	00c00744 	movi	r3,29
8112b030:	147ffe04 	addi	r17,r2,-8
8112b034:	1907c83a 	sub	r3,r3,r4
8112b038:	8460983a 	sll	r16,r16,r17
8112b03c:	98c6d83a 	srl	r3,r19,r3
8112b040:	9c64983a 	sll	r18,r19,r17
8112b044:	1c20b03a 	or	r16,r3,r16
8112b048:	1080fcc4 	addi	r2,r2,1011
8112b04c:	00abc83a 	sub	r21,zero,r2
8112b050:	0027883a 	mov	r19,zero
8112b054:	0013883a 	mov	r9,zero
8112b058:	003f9106 	br	8112aea0 <__reset+0xfb10aea0>
8112b05c:	3446b03a 	or	r3,r6,r17
8112b060:	18001f1e 	bne	r3,zero,8112b0e0 <__divdf3+0x2c0>
8112b064:	0023883a 	mov	r17,zero
8112b068:	0011883a 	mov	r8,zero
8112b06c:	01c00084 	movi	r7,2
8112b070:	003f9d06 	br	8112aee8 <__reset+0xfb10aee8>
8112b074:	3446b03a 	or	r3,r6,r17
8112b078:	18001526 	beq	r3,zero,8112b0d0 <__divdf3+0x2b0>
8112b07c:	88011b26 	beq	r17,zero,8112b4ec <__divdf3+0x6cc>
8112b080:	8809883a 	mov	r4,r17
8112b084:	d9800315 	stw	r6,12(sp)
8112b088:	da400115 	stw	r9,4(sp)
8112b08c:	1116a5c0 	call	81116a5c <__clzsi2>
8112b090:	d9800317 	ldw	r6,12(sp)
8112b094:	da400117 	ldw	r9,4(sp)
8112b098:	113ffd44 	addi	r4,r2,-11
8112b09c:	00c00704 	movi	r3,28
8112b0a0:	19010e16 	blt	r3,r4,8112b4dc <__divdf3+0x6bc>
8112b0a4:	00c00744 	movi	r3,29
8112b0a8:	123ffe04 	addi	r8,r2,-8
8112b0ac:	1907c83a 	sub	r3,r3,r4
8112b0b0:	8a22983a 	sll	r17,r17,r8
8112b0b4:	30c6d83a 	srl	r3,r6,r3
8112b0b8:	3210983a 	sll	r8,r6,r8
8112b0bc:	1c62b03a 	or	r17,r3,r17
8112b0c0:	1080fcc4 	addi	r2,r2,1011
8112b0c4:	0085c83a 	sub	r2,zero,r2
8112b0c8:	000f883a 	mov	r7,zero
8112b0cc:	003f8606 	br	8112aee8 <__reset+0xfb10aee8>
8112b0d0:	0023883a 	mov	r17,zero
8112b0d4:	0011883a 	mov	r8,zero
8112b0d8:	01c00044 	movi	r7,1
8112b0dc:	003f8206 	br	8112aee8 <__reset+0xfb10aee8>
8112b0e0:	01c000c4 	movi	r7,3
8112b0e4:	003f8006 	br	8112aee8 <__reset+0xfb10aee8>
8112b0e8:	04c00104 	movi	r19,4
8112b0ec:	0021883a 	mov	r16,zero
8112b0f0:	0025883a 	mov	r18,zero
8112b0f4:	02400044 	movi	r9,1
8112b0f8:	003f6906 	br	8112aea0 <__reset+0xfb10aea0>
8112b0fc:	04c00304 	movi	r19,12
8112b100:	024000c4 	movi	r9,3
8112b104:	003f6606 	br	8112aea0 <__reset+0xfb10aea0>
8112b108:	01400434 	movhi	r5,16
8112b10c:	0007883a 	mov	r3,zero
8112b110:	297fffc4 	addi	r5,r5,-1
8112b114:	04bfffc4 	movi	r18,-1
8112b118:	0081ffc4 	movi	r2,2047
8112b11c:	003fa106 	br	8112afa4 <__reset+0xfb10afa4>
8112b120:	00c00044 	movi	r3,1
8112b124:	1887c83a 	sub	r3,r3,r2
8112b128:	01000e04 	movi	r4,56
8112b12c:	20c1210e 	bge	r4,r3,8112b5b4 <__divdf3+0x794>
8112b130:	98c0004c 	andi	r3,r19,1
8112b134:	0005883a 	mov	r2,zero
8112b138:	000b883a 	mov	r5,zero
8112b13c:	0025883a 	mov	r18,zero
8112b140:	003f9806 	br	8112afa4 <__reset+0xfb10afa4>
8112b144:	8c00fd36 	bltu	r17,r16,8112b53c <__divdf3+0x71c>
8112b148:	8440fb26 	beq	r16,r17,8112b538 <__divdf3+0x718>
8112b14c:	8007883a 	mov	r3,r16
8112b150:	ad7fffc4 	addi	r21,r21,-1
8112b154:	0021883a 	mov	r16,zero
8112b158:	4004d63a 	srli	r2,r8,24
8112b15c:	8822923a 	slli	r17,r17,8
8112b160:	1809883a 	mov	r4,r3
8112b164:	402c923a 	slli	r22,r8,8
8112b168:	88b8b03a 	or	fp,r17,r2
8112b16c:	e028d43a 	srli	r20,fp,16
8112b170:	d8c00015 	stw	r3,0(sp)
8112b174:	e5ffffcc 	andi	r23,fp,65535
8112b178:	a00b883a 	mov	r5,r20
8112b17c:	112a2b40 	call	8112a2b4 <__udivsi3>
8112b180:	d8c00017 	ldw	r3,0(sp)
8112b184:	a00b883a 	mov	r5,r20
8112b188:	d8800315 	stw	r2,12(sp)
8112b18c:	1809883a 	mov	r4,r3
8112b190:	112a3180 	call	8112a318 <__umodsi3>
8112b194:	d9800317 	ldw	r6,12(sp)
8112b198:	1006943a 	slli	r3,r2,16
8112b19c:	9004d43a 	srli	r2,r18,16
8112b1a0:	b9a3383a 	mul	r17,r23,r6
8112b1a4:	10c4b03a 	or	r2,r2,r3
8112b1a8:	1440062e 	bgeu	r2,r17,8112b1c4 <__divdf3+0x3a4>
8112b1ac:	1705883a 	add	r2,r2,fp
8112b1b0:	30ffffc4 	addi	r3,r6,-1
8112b1b4:	1700ee36 	bltu	r2,fp,8112b570 <__divdf3+0x750>
8112b1b8:	1440ed2e 	bgeu	r2,r17,8112b570 <__divdf3+0x750>
8112b1bc:	31bfff84 	addi	r6,r6,-2
8112b1c0:	1705883a 	add	r2,r2,fp
8112b1c4:	1463c83a 	sub	r17,r2,r17
8112b1c8:	a00b883a 	mov	r5,r20
8112b1cc:	8809883a 	mov	r4,r17
8112b1d0:	d9800315 	stw	r6,12(sp)
8112b1d4:	112a2b40 	call	8112a2b4 <__udivsi3>
8112b1d8:	a00b883a 	mov	r5,r20
8112b1dc:	8809883a 	mov	r4,r17
8112b1e0:	d8800215 	stw	r2,8(sp)
8112b1e4:	112a3180 	call	8112a318 <__umodsi3>
8112b1e8:	d9c00217 	ldw	r7,8(sp)
8112b1ec:	1004943a 	slli	r2,r2,16
8112b1f0:	94bfffcc 	andi	r18,r18,65535
8112b1f4:	b9d1383a 	mul	r8,r23,r7
8112b1f8:	90a4b03a 	or	r18,r18,r2
8112b1fc:	d9800317 	ldw	r6,12(sp)
8112b200:	9200062e 	bgeu	r18,r8,8112b21c <__divdf3+0x3fc>
8112b204:	9725883a 	add	r18,r18,fp
8112b208:	38bfffc4 	addi	r2,r7,-1
8112b20c:	9700d636 	bltu	r18,fp,8112b568 <__divdf3+0x748>
8112b210:	9200d52e 	bgeu	r18,r8,8112b568 <__divdf3+0x748>
8112b214:	39ffff84 	addi	r7,r7,-2
8112b218:	9725883a 	add	r18,r18,fp
8112b21c:	3004943a 	slli	r2,r6,16
8112b220:	b012d43a 	srli	r9,r22,16
8112b224:	b1bfffcc 	andi	r6,r22,65535
8112b228:	11e2b03a 	or	r17,r2,r7
8112b22c:	8806d43a 	srli	r3,r17,16
8112b230:	893fffcc 	andi	r4,r17,65535
8112b234:	218b383a 	mul	r5,r4,r6
8112b238:	30c5383a 	mul	r2,r6,r3
8112b23c:	2249383a 	mul	r4,r4,r9
8112b240:	280ed43a 	srli	r7,r5,16
8112b244:	9225c83a 	sub	r18,r18,r8
8112b248:	2089883a 	add	r4,r4,r2
8112b24c:	3909883a 	add	r4,r7,r4
8112b250:	1a47383a 	mul	r3,r3,r9
8112b254:	2080022e 	bgeu	r4,r2,8112b260 <__divdf3+0x440>
8112b258:	00800074 	movhi	r2,1
8112b25c:	1887883a 	add	r3,r3,r2
8112b260:	2004d43a 	srli	r2,r4,16
8112b264:	2008943a 	slli	r4,r4,16
8112b268:	297fffcc 	andi	r5,r5,65535
8112b26c:	10c7883a 	add	r3,r2,r3
8112b270:	2149883a 	add	r4,r4,r5
8112b274:	90c0a536 	bltu	r18,r3,8112b50c <__divdf3+0x6ec>
8112b278:	90c0bf26 	beq	r18,r3,8112b578 <__divdf3+0x758>
8112b27c:	90c7c83a 	sub	r3,r18,r3
8112b280:	810fc83a 	sub	r7,r16,r4
8112b284:	81e5803a 	cmpltu	r18,r16,r7
8112b288:	1ca5c83a 	sub	r18,r3,r18
8112b28c:	e480c126 	beq	fp,r18,8112b594 <__divdf3+0x774>
8112b290:	a00b883a 	mov	r5,r20
8112b294:	9009883a 	mov	r4,r18
8112b298:	d9800315 	stw	r6,12(sp)
8112b29c:	d9c00215 	stw	r7,8(sp)
8112b2a0:	da400115 	stw	r9,4(sp)
8112b2a4:	112a2b40 	call	8112a2b4 <__udivsi3>
8112b2a8:	a00b883a 	mov	r5,r20
8112b2ac:	9009883a 	mov	r4,r18
8112b2b0:	d8800015 	stw	r2,0(sp)
8112b2b4:	112a3180 	call	8112a318 <__umodsi3>
8112b2b8:	d9c00217 	ldw	r7,8(sp)
8112b2bc:	da000017 	ldw	r8,0(sp)
8112b2c0:	1006943a 	slli	r3,r2,16
8112b2c4:	3804d43a 	srli	r2,r7,16
8112b2c8:	ba21383a 	mul	r16,r23,r8
8112b2cc:	d9800317 	ldw	r6,12(sp)
8112b2d0:	10c4b03a 	or	r2,r2,r3
8112b2d4:	da400117 	ldw	r9,4(sp)
8112b2d8:	1400062e 	bgeu	r2,r16,8112b2f4 <__divdf3+0x4d4>
8112b2dc:	1705883a 	add	r2,r2,fp
8112b2e0:	40ffffc4 	addi	r3,r8,-1
8112b2e4:	1700ad36 	bltu	r2,fp,8112b59c <__divdf3+0x77c>
8112b2e8:	1400ac2e 	bgeu	r2,r16,8112b59c <__divdf3+0x77c>
8112b2ec:	423fff84 	addi	r8,r8,-2
8112b2f0:	1705883a 	add	r2,r2,fp
8112b2f4:	1421c83a 	sub	r16,r2,r16
8112b2f8:	a00b883a 	mov	r5,r20
8112b2fc:	8009883a 	mov	r4,r16
8112b300:	d9800315 	stw	r6,12(sp)
8112b304:	d9c00215 	stw	r7,8(sp)
8112b308:	da000015 	stw	r8,0(sp)
8112b30c:	da400115 	stw	r9,4(sp)
8112b310:	112a2b40 	call	8112a2b4 <__udivsi3>
8112b314:	8009883a 	mov	r4,r16
8112b318:	a00b883a 	mov	r5,r20
8112b31c:	1025883a 	mov	r18,r2
8112b320:	112a3180 	call	8112a318 <__umodsi3>
8112b324:	d9c00217 	ldw	r7,8(sp)
8112b328:	1004943a 	slli	r2,r2,16
8112b32c:	bcaf383a 	mul	r23,r23,r18
8112b330:	393fffcc 	andi	r4,r7,65535
8112b334:	2088b03a 	or	r4,r4,r2
8112b338:	d9800317 	ldw	r6,12(sp)
8112b33c:	da000017 	ldw	r8,0(sp)
8112b340:	da400117 	ldw	r9,4(sp)
8112b344:	25c0062e 	bgeu	r4,r23,8112b360 <__divdf3+0x540>
8112b348:	2709883a 	add	r4,r4,fp
8112b34c:	90bfffc4 	addi	r2,r18,-1
8112b350:	27009436 	bltu	r4,fp,8112b5a4 <__divdf3+0x784>
8112b354:	25c0932e 	bgeu	r4,r23,8112b5a4 <__divdf3+0x784>
8112b358:	94bfff84 	addi	r18,r18,-2
8112b35c:	2709883a 	add	r4,r4,fp
8112b360:	4004943a 	slli	r2,r8,16
8112b364:	25efc83a 	sub	r23,r4,r23
8112b368:	1490b03a 	or	r8,r2,r18
8112b36c:	4008d43a 	srli	r4,r8,16
8112b370:	40ffffcc 	andi	r3,r8,65535
8112b374:	30c5383a 	mul	r2,r6,r3
8112b378:	1a47383a 	mul	r3,r3,r9
8112b37c:	310d383a 	mul	r6,r6,r4
8112b380:	100ad43a 	srli	r5,r2,16
8112b384:	4913383a 	mul	r9,r9,r4
8112b388:	1987883a 	add	r3,r3,r6
8112b38c:	28c7883a 	add	r3,r5,r3
8112b390:	1980022e 	bgeu	r3,r6,8112b39c <__divdf3+0x57c>
8112b394:	01000074 	movhi	r4,1
8112b398:	4913883a 	add	r9,r9,r4
8112b39c:	1808d43a 	srli	r4,r3,16
8112b3a0:	1806943a 	slli	r3,r3,16
8112b3a4:	10bfffcc 	andi	r2,r2,65535
8112b3a8:	2253883a 	add	r9,r4,r9
8112b3ac:	1887883a 	add	r3,r3,r2
8112b3b0:	ba403836 	bltu	r23,r9,8112b494 <__divdf3+0x674>
8112b3b4:	ba403626 	beq	r23,r9,8112b490 <__divdf3+0x670>
8112b3b8:	42000054 	ori	r8,r8,1
8112b3bc:	a880ffc4 	addi	r2,r21,1023
8112b3c0:	00bf570e 	bge	zero,r2,8112b120 <__reset+0xfb10b120>
8112b3c4:	40c001cc 	andi	r3,r8,7
8112b3c8:	18000726 	beq	r3,zero,8112b3e8 <__divdf3+0x5c8>
8112b3cc:	40c003cc 	andi	r3,r8,15
8112b3d0:	01000104 	movi	r4,4
8112b3d4:	19000426 	beq	r3,r4,8112b3e8 <__divdf3+0x5c8>
8112b3d8:	4107883a 	add	r3,r8,r4
8112b3dc:	1a11803a 	cmpltu	r8,r3,r8
8112b3e0:	8a23883a 	add	r17,r17,r8
8112b3e4:	1811883a 	mov	r8,r3
8112b3e8:	88c0402c 	andhi	r3,r17,256
8112b3ec:	18000426 	beq	r3,zero,8112b400 <__divdf3+0x5e0>
8112b3f0:	00ffc034 	movhi	r3,65280
8112b3f4:	18ffffc4 	addi	r3,r3,-1
8112b3f8:	a8810004 	addi	r2,r21,1024
8112b3fc:	88e2703a 	and	r17,r17,r3
8112b400:	00c1ff84 	movi	r3,2046
8112b404:	18bee316 	blt	r3,r2,8112af94 <__reset+0xfb10af94>
8112b408:	8824977a 	slli	r18,r17,29
8112b40c:	4010d0fa 	srli	r8,r8,3
8112b410:	8822927a 	slli	r17,r17,9
8112b414:	1081ffcc 	andi	r2,r2,2047
8112b418:	9224b03a 	or	r18,r18,r8
8112b41c:	880ad33a 	srli	r5,r17,12
8112b420:	98c0004c 	andi	r3,r19,1
8112b424:	003edf06 	br	8112afa4 <__reset+0xfb10afa4>
8112b428:	8080022c 	andhi	r2,r16,8
8112b42c:	10001226 	beq	r2,zero,8112b478 <__divdf3+0x658>
8112b430:	8880022c 	andhi	r2,r17,8
8112b434:	1000101e 	bne	r2,zero,8112b478 <__divdf3+0x658>
8112b438:	00800434 	movhi	r2,16
8112b43c:	89400234 	orhi	r5,r17,8
8112b440:	10bfffc4 	addi	r2,r2,-1
8112b444:	b007883a 	mov	r3,r22
8112b448:	288a703a 	and	r5,r5,r2
8112b44c:	4025883a 	mov	r18,r8
8112b450:	003f3106 	br	8112b118 <__reset+0xfb10b118>
8112b454:	008000c4 	movi	r2,3
8112b458:	3880a626 	beq	r7,r2,8112b6f4 <__divdf3+0x8d4>
8112b45c:	00800044 	movi	r2,1
8112b460:	3880521e 	bne	r7,r2,8112b5ac <__divdf3+0x78c>
8112b464:	b807883a 	mov	r3,r23
8112b468:	0005883a 	mov	r2,zero
8112b46c:	000b883a 	mov	r5,zero
8112b470:	0025883a 	mov	r18,zero
8112b474:	003ecb06 	br	8112afa4 <__reset+0xfb10afa4>
8112b478:	00800434 	movhi	r2,16
8112b47c:	81400234 	orhi	r5,r16,8
8112b480:	10bfffc4 	addi	r2,r2,-1
8112b484:	a007883a 	mov	r3,r20
8112b488:	288a703a 	and	r5,r5,r2
8112b48c:	003f2206 	br	8112b118 <__reset+0xfb10b118>
8112b490:	183fca26 	beq	r3,zero,8112b3bc <__reset+0xfb10b3bc>
8112b494:	e5ef883a 	add	r23,fp,r23
8112b498:	40bfffc4 	addi	r2,r8,-1
8112b49c:	bf00392e 	bgeu	r23,fp,8112b584 <__divdf3+0x764>
8112b4a0:	1011883a 	mov	r8,r2
8112b4a4:	ba7fc41e 	bne	r23,r9,8112b3b8 <__reset+0xfb10b3b8>
8112b4a8:	b0ffc31e 	bne	r22,r3,8112b3b8 <__reset+0xfb10b3b8>
8112b4ac:	003fc306 	br	8112b3bc <__reset+0xfb10b3bc>
8112b4b0:	143ff604 	addi	r16,r2,-40
8112b4b4:	9c20983a 	sll	r16,r19,r16
8112b4b8:	0025883a 	mov	r18,zero
8112b4bc:	003ee206 	br	8112b048 <__reset+0xfb10b048>
8112b4c0:	d9800315 	stw	r6,12(sp)
8112b4c4:	d9c00215 	stw	r7,8(sp)
8112b4c8:	1116a5c0 	call	81116a5c <__clzsi2>
8112b4cc:	10800804 	addi	r2,r2,32
8112b4d0:	d9c00217 	ldw	r7,8(sp)
8112b4d4:	d9800317 	ldw	r6,12(sp)
8112b4d8:	003ed106 	br	8112b020 <__reset+0xfb10b020>
8112b4dc:	147ff604 	addi	r17,r2,-40
8112b4e0:	3462983a 	sll	r17,r6,r17
8112b4e4:	0011883a 	mov	r8,zero
8112b4e8:	003ef506 	br	8112b0c0 <__reset+0xfb10b0c0>
8112b4ec:	3009883a 	mov	r4,r6
8112b4f0:	d9800315 	stw	r6,12(sp)
8112b4f4:	da400115 	stw	r9,4(sp)
8112b4f8:	1116a5c0 	call	81116a5c <__clzsi2>
8112b4fc:	10800804 	addi	r2,r2,32
8112b500:	da400117 	ldw	r9,4(sp)
8112b504:	d9800317 	ldw	r6,12(sp)
8112b508:	003ee306 	br	8112b098 <__reset+0xfb10b098>
8112b50c:	85a1883a 	add	r16,r16,r22
8112b510:	8585803a 	cmpltu	r2,r16,r22
8112b514:	1705883a 	add	r2,r2,fp
8112b518:	14a5883a 	add	r18,r2,r18
8112b51c:	88bfffc4 	addi	r2,r17,-1
8112b520:	e4800c2e 	bgeu	fp,r18,8112b554 <__divdf3+0x734>
8112b524:	90c03e36 	bltu	r18,r3,8112b620 <__divdf3+0x800>
8112b528:	1c806926 	beq	r3,r18,8112b6d0 <__divdf3+0x8b0>
8112b52c:	90c7c83a 	sub	r3,r18,r3
8112b530:	1023883a 	mov	r17,r2
8112b534:	003f5206 	br	8112b280 <__reset+0xfb10b280>
8112b538:	923f0436 	bltu	r18,r8,8112b14c <__reset+0xfb10b14c>
8112b53c:	800897fa 	slli	r4,r16,31
8112b540:	9004d07a 	srli	r2,r18,1
8112b544:	8006d07a 	srli	r3,r16,1
8112b548:	902097fa 	slli	r16,r18,31
8112b54c:	20a4b03a 	or	r18,r4,r2
8112b550:	003f0106 	br	8112b158 <__reset+0xfb10b158>
8112b554:	e4bff51e 	bne	fp,r18,8112b52c <__reset+0xfb10b52c>
8112b558:	85bff22e 	bgeu	r16,r22,8112b524 <__reset+0xfb10b524>
8112b55c:	e0c7c83a 	sub	r3,fp,r3
8112b560:	1023883a 	mov	r17,r2
8112b564:	003f4606 	br	8112b280 <__reset+0xfb10b280>
8112b568:	100f883a 	mov	r7,r2
8112b56c:	003f2b06 	br	8112b21c <__reset+0xfb10b21c>
8112b570:	180d883a 	mov	r6,r3
8112b574:	003f1306 	br	8112b1c4 <__reset+0xfb10b1c4>
8112b578:	813fe436 	bltu	r16,r4,8112b50c <__reset+0xfb10b50c>
8112b57c:	0007883a 	mov	r3,zero
8112b580:	003f3f06 	br	8112b280 <__reset+0xfb10b280>
8112b584:	ba402c36 	bltu	r23,r9,8112b638 <__divdf3+0x818>
8112b588:	4dc05426 	beq	r9,r23,8112b6dc <__divdf3+0x8bc>
8112b58c:	1011883a 	mov	r8,r2
8112b590:	003f8906 	br	8112b3b8 <__reset+0xfb10b3b8>
8112b594:	023fffc4 	movi	r8,-1
8112b598:	003f8806 	br	8112b3bc <__reset+0xfb10b3bc>
8112b59c:	1811883a 	mov	r8,r3
8112b5a0:	003f5406 	br	8112b2f4 <__reset+0xfb10b2f4>
8112b5a4:	1025883a 	mov	r18,r2
8112b5a8:	003f6d06 	br	8112b360 <__reset+0xfb10b360>
8112b5ac:	b827883a 	mov	r19,r23
8112b5b0:	003f8206 	br	8112b3bc <__reset+0xfb10b3bc>
8112b5b4:	010007c4 	movi	r4,31
8112b5b8:	20c02616 	blt	r4,r3,8112b654 <__divdf3+0x834>
8112b5bc:	00800804 	movi	r2,32
8112b5c0:	10c5c83a 	sub	r2,r2,r3
8112b5c4:	888a983a 	sll	r5,r17,r2
8112b5c8:	40c8d83a 	srl	r4,r8,r3
8112b5cc:	4084983a 	sll	r2,r8,r2
8112b5d0:	88e2d83a 	srl	r17,r17,r3
8112b5d4:	2906b03a 	or	r3,r5,r4
8112b5d8:	1004c03a 	cmpne	r2,r2,zero
8112b5dc:	1886b03a 	or	r3,r3,r2
8112b5e0:	188001cc 	andi	r2,r3,7
8112b5e4:	10000726 	beq	r2,zero,8112b604 <__divdf3+0x7e4>
8112b5e8:	188003cc 	andi	r2,r3,15
8112b5ec:	01000104 	movi	r4,4
8112b5f0:	11000426 	beq	r2,r4,8112b604 <__divdf3+0x7e4>
8112b5f4:	1805883a 	mov	r2,r3
8112b5f8:	10c00104 	addi	r3,r2,4
8112b5fc:	1885803a 	cmpltu	r2,r3,r2
8112b600:	88a3883a 	add	r17,r17,r2
8112b604:	8880202c 	andhi	r2,r17,128
8112b608:	10002726 	beq	r2,zero,8112b6a8 <__divdf3+0x888>
8112b60c:	98c0004c 	andi	r3,r19,1
8112b610:	00800044 	movi	r2,1
8112b614:	000b883a 	mov	r5,zero
8112b618:	0025883a 	mov	r18,zero
8112b61c:	003e6106 	br	8112afa4 <__reset+0xfb10afa4>
8112b620:	85a1883a 	add	r16,r16,r22
8112b624:	8585803a 	cmpltu	r2,r16,r22
8112b628:	1705883a 	add	r2,r2,fp
8112b62c:	14a5883a 	add	r18,r2,r18
8112b630:	8c7fff84 	addi	r17,r17,-2
8112b634:	003f1106 	br	8112b27c <__reset+0xfb10b27c>
8112b638:	b589883a 	add	r4,r22,r22
8112b63c:	25ad803a 	cmpltu	r22,r4,r22
8112b640:	b739883a 	add	fp,r22,fp
8112b644:	40bfff84 	addi	r2,r8,-2
8112b648:	bf2f883a 	add	r23,r23,fp
8112b64c:	202d883a 	mov	r22,r4
8112b650:	003f9306 	br	8112b4a0 <__reset+0xfb10b4a0>
8112b654:	013ff844 	movi	r4,-31
8112b658:	2085c83a 	sub	r2,r4,r2
8112b65c:	8888d83a 	srl	r4,r17,r2
8112b660:	00800804 	movi	r2,32
8112b664:	18802126 	beq	r3,r2,8112b6ec <__divdf3+0x8cc>
8112b668:	00801004 	movi	r2,64
8112b66c:	10c5c83a 	sub	r2,r2,r3
8112b670:	8884983a 	sll	r2,r17,r2
8112b674:	1204b03a 	or	r2,r2,r8
8112b678:	1004c03a 	cmpne	r2,r2,zero
8112b67c:	2084b03a 	or	r2,r4,r2
8112b680:	144001cc 	andi	r17,r2,7
8112b684:	88000d1e 	bne	r17,zero,8112b6bc <__divdf3+0x89c>
8112b688:	000b883a 	mov	r5,zero
8112b68c:	1024d0fa 	srli	r18,r2,3
8112b690:	98c0004c 	andi	r3,r19,1
8112b694:	0005883a 	mov	r2,zero
8112b698:	9464b03a 	or	r18,r18,r17
8112b69c:	003e4106 	br	8112afa4 <__reset+0xfb10afa4>
8112b6a0:	1007883a 	mov	r3,r2
8112b6a4:	0023883a 	mov	r17,zero
8112b6a8:	880a927a 	slli	r5,r17,9
8112b6ac:	1805883a 	mov	r2,r3
8112b6b0:	8822977a 	slli	r17,r17,29
8112b6b4:	280ad33a 	srli	r5,r5,12
8112b6b8:	003ff406 	br	8112b68c <__reset+0xfb10b68c>
8112b6bc:	10c003cc 	andi	r3,r2,15
8112b6c0:	01000104 	movi	r4,4
8112b6c4:	193ff626 	beq	r3,r4,8112b6a0 <__reset+0xfb10b6a0>
8112b6c8:	0023883a 	mov	r17,zero
8112b6cc:	003fca06 	br	8112b5f8 <__reset+0xfb10b5f8>
8112b6d0:	813fd336 	bltu	r16,r4,8112b620 <__reset+0xfb10b620>
8112b6d4:	1023883a 	mov	r17,r2
8112b6d8:	003fa806 	br	8112b57c <__reset+0xfb10b57c>
8112b6dc:	b0ffd636 	bltu	r22,r3,8112b638 <__reset+0xfb10b638>
8112b6e0:	1011883a 	mov	r8,r2
8112b6e4:	b0ff341e 	bne	r22,r3,8112b3b8 <__reset+0xfb10b3b8>
8112b6e8:	003f3406 	br	8112b3bc <__reset+0xfb10b3bc>
8112b6ec:	0005883a 	mov	r2,zero
8112b6f0:	003fe006 	br	8112b674 <__reset+0xfb10b674>
8112b6f4:	00800434 	movhi	r2,16
8112b6f8:	89400234 	orhi	r5,r17,8
8112b6fc:	10bfffc4 	addi	r2,r2,-1
8112b700:	b807883a 	mov	r3,r23
8112b704:	288a703a 	and	r5,r5,r2
8112b708:	4025883a 	mov	r18,r8
8112b70c:	003e8206 	br	8112b118 <__reset+0xfb10b118>

8112b710 <__eqdf2>:
8112b710:	2804d53a 	srli	r2,r5,20
8112b714:	3806d53a 	srli	r3,r7,20
8112b718:	02000434 	movhi	r8,16
8112b71c:	423fffc4 	addi	r8,r8,-1
8112b720:	1081ffcc 	andi	r2,r2,2047
8112b724:	0281ffc4 	movi	r10,2047
8112b728:	2a12703a 	and	r9,r5,r8
8112b72c:	18c1ffcc 	andi	r3,r3,2047
8112b730:	3a10703a 	and	r8,r7,r8
8112b734:	280ad7fa 	srli	r5,r5,31
8112b738:	380ed7fa 	srli	r7,r7,31
8112b73c:	12801026 	beq	r2,r10,8112b780 <__eqdf2+0x70>
8112b740:	0281ffc4 	movi	r10,2047
8112b744:	1a800a26 	beq	r3,r10,8112b770 <__eqdf2+0x60>
8112b748:	10c00226 	beq	r2,r3,8112b754 <__eqdf2+0x44>
8112b74c:	00800044 	movi	r2,1
8112b750:	f800283a 	ret
8112b754:	4a3ffd1e 	bne	r9,r8,8112b74c <__reset+0xfb10b74c>
8112b758:	21bffc1e 	bne	r4,r6,8112b74c <__reset+0xfb10b74c>
8112b75c:	29c00c26 	beq	r5,r7,8112b790 <__eqdf2+0x80>
8112b760:	103ffa1e 	bne	r2,zero,8112b74c <__reset+0xfb10b74c>
8112b764:	2244b03a 	or	r2,r4,r9
8112b768:	1004c03a 	cmpne	r2,r2,zero
8112b76c:	f800283a 	ret
8112b770:	3214b03a 	or	r10,r6,r8
8112b774:	503ff426 	beq	r10,zero,8112b748 <__reset+0xfb10b748>
8112b778:	00800044 	movi	r2,1
8112b77c:	f800283a 	ret
8112b780:	2254b03a 	or	r10,r4,r9
8112b784:	503fee26 	beq	r10,zero,8112b740 <__reset+0xfb10b740>
8112b788:	00800044 	movi	r2,1
8112b78c:	f800283a 	ret
8112b790:	0005883a 	mov	r2,zero
8112b794:	f800283a 	ret

8112b798 <__gedf2>:
8112b798:	2804d53a 	srli	r2,r5,20
8112b79c:	3806d53a 	srli	r3,r7,20
8112b7a0:	02000434 	movhi	r8,16
8112b7a4:	423fffc4 	addi	r8,r8,-1
8112b7a8:	1081ffcc 	andi	r2,r2,2047
8112b7ac:	0241ffc4 	movi	r9,2047
8112b7b0:	2a14703a 	and	r10,r5,r8
8112b7b4:	18c1ffcc 	andi	r3,r3,2047
8112b7b8:	3a10703a 	and	r8,r7,r8
8112b7bc:	280ad7fa 	srli	r5,r5,31
8112b7c0:	380ed7fa 	srli	r7,r7,31
8112b7c4:	12401d26 	beq	r2,r9,8112b83c <__gedf2+0xa4>
8112b7c8:	0241ffc4 	movi	r9,2047
8112b7cc:	1a401226 	beq	r3,r9,8112b818 <__gedf2+0x80>
8112b7d0:	1000081e 	bne	r2,zero,8112b7f4 <__gedf2+0x5c>
8112b7d4:	2296b03a 	or	r11,r4,r10
8112b7d8:	5813003a 	cmpeq	r9,r11,zero
8112b7dc:	1800091e 	bne	r3,zero,8112b804 <__gedf2+0x6c>
8112b7e0:	3218b03a 	or	r12,r6,r8
8112b7e4:	6000071e 	bne	r12,zero,8112b804 <__gedf2+0x6c>
8112b7e8:	0005883a 	mov	r2,zero
8112b7ec:	5800101e 	bne	r11,zero,8112b830 <__gedf2+0x98>
8112b7f0:	f800283a 	ret
8112b7f4:	18000c1e 	bne	r3,zero,8112b828 <__gedf2+0x90>
8112b7f8:	3212b03a 	or	r9,r6,r8
8112b7fc:	48000c26 	beq	r9,zero,8112b830 <__gedf2+0x98>
8112b800:	0013883a 	mov	r9,zero
8112b804:	39c03fcc 	andi	r7,r7,255
8112b808:	48000826 	beq	r9,zero,8112b82c <__gedf2+0x94>
8112b80c:	38000926 	beq	r7,zero,8112b834 <__gedf2+0x9c>
8112b810:	00800044 	movi	r2,1
8112b814:	f800283a 	ret
8112b818:	3212b03a 	or	r9,r6,r8
8112b81c:	483fec26 	beq	r9,zero,8112b7d0 <__reset+0xfb10b7d0>
8112b820:	00bfff84 	movi	r2,-2
8112b824:	f800283a 	ret
8112b828:	39c03fcc 	andi	r7,r7,255
8112b82c:	29c00626 	beq	r5,r7,8112b848 <__gedf2+0xb0>
8112b830:	283ff726 	beq	r5,zero,8112b810 <__reset+0xfb10b810>
8112b834:	00bfffc4 	movi	r2,-1
8112b838:	f800283a 	ret
8112b83c:	2292b03a 	or	r9,r4,r10
8112b840:	483fe126 	beq	r9,zero,8112b7c8 <__reset+0xfb10b7c8>
8112b844:	003ff606 	br	8112b820 <__reset+0xfb10b820>
8112b848:	18bff916 	blt	r3,r2,8112b830 <__reset+0xfb10b830>
8112b84c:	10c00316 	blt	r2,r3,8112b85c <__gedf2+0xc4>
8112b850:	42bff736 	bltu	r8,r10,8112b830 <__reset+0xfb10b830>
8112b854:	52000326 	beq	r10,r8,8112b864 <__gedf2+0xcc>
8112b858:	5200042e 	bgeu	r10,r8,8112b86c <__gedf2+0xd4>
8112b85c:	283fec1e 	bne	r5,zero,8112b810 <__reset+0xfb10b810>
8112b860:	003ff406 	br	8112b834 <__reset+0xfb10b834>
8112b864:	313ff236 	bltu	r6,r4,8112b830 <__reset+0xfb10b830>
8112b868:	21bffc36 	bltu	r4,r6,8112b85c <__reset+0xfb10b85c>
8112b86c:	0005883a 	mov	r2,zero
8112b870:	f800283a 	ret

8112b874 <__ledf2>:
8112b874:	2804d53a 	srli	r2,r5,20
8112b878:	3810d53a 	srli	r8,r7,20
8112b87c:	00c00434 	movhi	r3,16
8112b880:	18ffffc4 	addi	r3,r3,-1
8112b884:	1081ffcc 	andi	r2,r2,2047
8112b888:	0241ffc4 	movi	r9,2047
8112b88c:	28d4703a 	and	r10,r5,r3
8112b890:	4201ffcc 	andi	r8,r8,2047
8112b894:	38c6703a 	and	r3,r7,r3
8112b898:	280ad7fa 	srli	r5,r5,31
8112b89c:	380ed7fa 	srli	r7,r7,31
8112b8a0:	12401f26 	beq	r2,r9,8112b920 <__ledf2+0xac>
8112b8a4:	0241ffc4 	movi	r9,2047
8112b8a8:	42401426 	beq	r8,r9,8112b8fc <__ledf2+0x88>
8112b8ac:	1000091e 	bne	r2,zero,8112b8d4 <__ledf2+0x60>
8112b8b0:	2296b03a 	or	r11,r4,r10
8112b8b4:	5813003a 	cmpeq	r9,r11,zero
8112b8b8:	29403fcc 	andi	r5,r5,255
8112b8bc:	40000a1e 	bne	r8,zero,8112b8e8 <__ledf2+0x74>
8112b8c0:	30d8b03a 	or	r12,r6,r3
8112b8c4:	6000081e 	bne	r12,zero,8112b8e8 <__ledf2+0x74>
8112b8c8:	0005883a 	mov	r2,zero
8112b8cc:	5800111e 	bne	r11,zero,8112b914 <__ledf2+0xa0>
8112b8d0:	f800283a 	ret
8112b8d4:	29403fcc 	andi	r5,r5,255
8112b8d8:	40000c1e 	bne	r8,zero,8112b90c <__ledf2+0x98>
8112b8dc:	30d2b03a 	or	r9,r6,r3
8112b8e0:	48000c26 	beq	r9,zero,8112b914 <__ledf2+0xa0>
8112b8e4:	0013883a 	mov	r9,zero
8112b8e8:	39c03fcc 	andi	r7,r7,255
8112b8ec:	48000826 	beq	r9,zero,8112b910 <__ledf2+0x9c>
8112b8f0:	38001126 	beq	r7,zero,8112b938 <__ledf2+0xc4>
8112b8f4:	00800044 	movi	r2,1
8112b8f8:	f800283a 	ret
8112b8fc:	30d2b03a 	or	r9,r6,r3
8112b900:	483fea26 	beq	r9,zero,8112b8ac <__reset+0xfb10b8ac>
8112b904:	00800084 	movi	r2,2
8112b908:	f800283a 	ret
8112b90c:	39c03fcc 	andi	r7,r7,255
8112b910:	39400726 	beq	r7,r5,8112b930 <__ledf2+0xbc>
8112b914:	2800081e 	bne	r5,zero,8112b938 <__ledf2+0xc4>
8112b918:	00800044 	movi	r2,1
8112b91c:	f800283a 	ret
8112b920:	2292b03a 	or	r9,r4,r10
8112b924:	483fdf26 	beq	r9,zero,8112b8a4 <__reset+0xfb10b8a4>
8112b928:	00800084 	movi	r2,2
8112b92c:	f800283a 	ret
8112b930:	4080030e 	bge	r8,r2,8112b940 <__ledf2+0xcc>
8112b934:	383fef26 	beq	r7,zero,8112b8f4 <__reset+0xfb10b8f4>
8112b938:	00bfffc4 	movi	r2,-1
8112b93c:	f800283a 	ret
8112b940:	123feb16 	blt	r2,r8,8112b8f0 <__reset+0xfb10b8f0>
8112b944:	1abff336 	bltu	r3,r10,8112b914 <__reset+0xfb10b914>
8112b948:	50c00326 	beq	r10,r3,8112b958 <__ledf2+0xe4>
8112b94c:	50c0042e 	bgeu	r10,r3,8112b960 <__ledf2+0xec>
8112b950:	283fe81e 	bne	r5,zero,8112b8f4 <__reset+0xfb10b8f4>
8112b954:	003ff806 	br	8112b938 <__reset+0xfb10b938>
8112b958:	313fee36 	bltu	r6,r4,8112b914 <__reset+0xfb10b914>
8112b95c:	21bffc36 	bltu	r4,r6,8112b950 <__reset+0xfb10b950>
8112b960:	0005883a 	mov	r2,zero
8112b964:	f800283a 	ret

8112b968 <__subdf3>:
8112b968:	02000434 	movhi	r8,16
8112b96c:	423fffc4 	addi	r8,r8,-1
8112b970:	defffb04 	addi	sp,sp,-20
8112b974:	2a14703a 	and	r10,r5,r8
8112b978:	3812d53a 	srli	r9,r7,20
8112b97c:	3a10703a 	and	r8,r7,r8
8112b980:	de00012e 	bgeu	sp,et,8112b988 <__subdf3+0x20>
8112b984:	003b68fa 	trap	3
8112b988:	2006d77a 	srli	r3,r4,29
8112b98c:	3004d77a 	srli	r2,r6,29
8112b990:	dc000015 	stw	r16,0(sp)
8112b994:	501490fa 	slli	r10,r10,3
8112b998:	2820d53a 	srli	r16,r5,20
8112b99c:	401090fa 	slli	r8,r8,3
8112b9a0:	dc800215 	stw	r18,8(sp)
8112b9a4:	dc400115 	stw	r17,4(sp)
8112b9a8:	dfc00415 	stw	ra,16(sp)
8112b9ac:	202290fa 	slli	r17,r4,3
8112b9b0:	dcc00315 	stw	r19,12(sp)
8112b9b4:	4a41ffcc 	andi	r9,r9,2047
8112b9b8:	0101ffc4 	movi	r4,2047
8112b9bc:	2824d7fa 	srli	r18,r5,31
8112b9c0:	8401ffcc 	andi	r16,r16,2047
8112b9c4:	50c6b03a 	or	r3,r10,r3
8112b9c8:	380ed7fa 	srli	r7,r7,31
8112b9cc:	408ab03a 	or	r5,r8,r2
8112b9d0:	300c90fa 	slli	r6,r6,3
8112b9d4:	49009626 	beq	r9,r4,8112bc30 <__subdf3+0x2c8>
8112b9d8:	39c0005c 	xori	r7,r7,1
8112b9dc:	8245c83a 	sub	r2,r16,r9
8112b9e0:	3c807426 	beq	r7,r18,8112bbb4 <__subdf3+0x24c>
8112b9e4:	0080af0e 	bge	zero,r2,8112bca4 <__subdf3+0x33c>
8112b9e8:	48002a1e 	bne	r9,zero,8112ba94 <__subdf3+0x12c>
8112b9ec:	2988b03a 	or	r4,r5,r6
8112b9f0:	20009a1e 	bne	r4,zero,8112bc5c <__subdf3+0x2f4>
8112b9f4:	888001cc 	andi	r2,r17,7
8112b9f8:	10000726 	beq	r2,zero,8112ba18 <__subdf3+0xb0>
8112b9fc:	888003cc 	andi	r2,r17,15
8112ba00:	01000104 	movi	r4,4
8112ba04:	11000426 	beq	r2,r4,8112ba18 <__subdf3+0xb0>
8112ba08:	890b883a 	add	r5,r17,r4
8112ba0c:	2c63803a 	cmpltu	r17,r5,r17
8112ba10:	1c47883a 	add	r3,r3,r17
8112ba14:	2823883a 	mov	r17,r5
8112ba18:	1880202c 	andhi	r2,r3,128
8112ba1c:	10005926 	beq	r2,zero,8112bb84 <__subdf3+0x21c>
8112ba20:	84000044 	addi	r16,r16,1
8112ba24:	0081ffc4 	movi	r2,2047
8112ba28:	8080be26 	beq	r16,r2,8112bd24 <__subdf3+0x3bc>
8112ba2c:	017fe034 	movhi	r5,65408
8112ba30:	297fffc4 	addi	r5,r5,-1
8112ba34:	1946703a 	and	r3,r3,r5
8112ba38:	1804977a 	slli	r2,r3,29
8112ba3c:	1806927a 	slli	r3,r3,9
8112ba40:	8822d0fa 	srli	r17,r17,3
8112ba44:	8401ffcc 	andi	r16,r16,2047
8112ba48:	180ad33a 	srli	r5,r3,12
8112ba4c:	9100004c 	andi	r4,r18,1
8112ba50:	1444b03a 	or	r2,r2,r17
8112ba54:	80c1ffcc 	andi	r3,r16,2047
8112ba58:	1820953a 	slli	r16,r3,20
8112ba5c:	20c03fcc 	andi	r3,r4,255
8112ba60:	180897fa 	slli	r4,r3,31
8112ba64:	00c00434 	movhi	r3,16
8112ba68:	18ffffc4 	addi	r3,r3,-1
8112ba6c:	28c6703a 	and	r3,r5,r3
8112ba70:	1c06b03a 	or	r3,r3,r16
8112ba74:	1906b03a 	or	r3,r3,r4
8112ba78:	dfc00417 	ldw	ra,16(sp)
8112ba7c:	dcc00317 	ldw	r19,12(sp)
8112ba80:	dc800217 	ldw	r18,8(sp)
8112ba84:	dc400117 	ldw	r17,4(sp)
8112ba88:	dc000017 	ldw	r16,0(sp)
8112ba8c:	dec00504 	addi	sp,sp,20
8112ba90:	f800283a 	ret
8112ba94:	0101ffc4 	movi	r4,2047
8112ba98:	813fd626 	beq	r16,r4,8112b9f4 <__reset+0xfb10b9f4>
8112ba9c:	29402034 	orhi	r5,r5,128
8112baa0:	01000e04 	movi	r4,56
8112baa4:	2080a316 	blt	r4,r2,8112bd34 <__subdf3+0x3cc>
8112baa8:	010007c4 	movi	r4,31
8112baac:	2080c616 	blt	r4,r2,8112bdc8 <__subdf3+0x460>
8112bab0:	01000804 	movi	r4,32
8112bab4:	2089c83a 	sub	r4,r4,r2
8112bab8:	2910983a 	sll	r8,r5,r4
8112babc:	308ed83a 	srl	r7,r6,r2
8112bac0:	3108983a 	sll	r4,r6,r4
8112bac4:	2884d83a 	srl	r2,r5,r2
8112bac8:	41ccb03a 	or	r6,r8,r7
8112bacc:	2008c03a 	cmpne	r4,r4,zero
8112bad0:	310cb03a 	or	r6,r6,r4
8112bad4:	898dc83a 	sub	r6,r17,r6
8112bad8:	89a3803a 	cmpltu	r17,r17,r6
8112badc:	1887c83a 	sub	r3,r3,r2
8112bae0:	1c47c83a 	sub	r3,r3,r17
8112bae4:	3023883a 	mov	r17,r6
8112bae8:	1880202c 	andhi	r2,r3,128
8112baec:	10002326 	beq	r2,zero,8112bb7c <__subdf3+0x214>
8112baf0:	04c02034 	movhi	r19,128
8112baf4:	9cffffc4 	addi	r19,r19,-1
8112baf8:	1ce6703a 	and	r19,r3,r19
8112bafc:	98007a26 	beq	r19,zero,8112bce8 <__subdf3+0x380>
8112bb00:	9809883a 	mov	r4,r19
8112bb04:	1116a5c0 	call	81116a5c <__clzsi2>
8112bb08:	113ffe04 	addi	r4,r2,-8
8112bb0c:	00c007c4 	movi	r3,31
8112bb10:	19007b16 	blt	r3,r4,8112bd00 <__subdf3+0x398>
8112bb14:	00800804 	movi	r2,32
8112bb18:	1105c83a 	sub	r2,r2,r4
8112bb1c:	8884d83a 	srl	r2,r17,r2
8112bb20:	9906983a 	sll	r3,r19,r4
8112bb24:	8922983a 	sll	r17,r17,r4
8112bb28:	10c4b03a 	or	r2,r2,r3
8112bb2c:	24007816 	blt	r4,r16,8112bd10 <__subdf3+0x3a8>
8112bb30:	2421c83a 	sub	r16,r4,r16
8112bb34:	80c00044 	addi	r3,r16,1
8112bb38:	010007c4 	movi	r4,31
8112bb3c:	20c09516 	blt	r4,r3,8112bd94 <__subdf3+0x42c>
8112bb40:	01400804 	movi	r5,32
8112bb44:	28cbc83a 	sub	r5,r5,r3
8112bb48:	88c8d83a 	srl	r4,r17,r3
8112bb4c:	8962983a 	sll	r17,r17,r5
8112bb50:	114a983a 	sll	r5,r2,r5
8112bb54:	10c6d83a 	srl	r3,r2,r3
8112bb58:	8804c03a 	cmpne	r2,r17,zero
8112bb5c:	290ab03a 	or	r5,r5,r4
8112bb60:	28a2b03a 	or	r17,r5,r2
8112bb64:	0021883a 	mov	r16,zero
8112bb68:	003fa206 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bb6c:	2090b03a 	or	r8,r4,r2
8112bb70:	40018e26 	beq	r8,zero,8112c1ac <__subdf3+0x844>
8112bb74:	1007883a 	mov	r3,r2
8112bb78:	2023883a 	mov	r17,r4
8112bb7c:	888001cc 	andi	r2,r17,7
8112bb80:	103f9e1e 	bne	r2,zero,8112b9fc <__reset+0xfb10b9fc>
8112bb84:	1804977a 	slli	r2,r3,29
8112bb88:	8822d0fa 	srli	r17,r17,3
8112bb8c:	1810d0fa 	srli	r8,r3,3
8112bb90:	9100004c 	andi	r4,r18,1
8112bb94:	1444b03a 	or	r2,r2,r17
8112bb98:	00c1ffc4 	movi	r3,2047
8112bb9c:	80c02826 	beq	r16,r3,8112bc40 <__subdf3+0x2d8>
8112bba0:	01400434 	movhi	r5,16
8112bba4:	297fffc4 	addi	r5,r5,-1
8112bba8:	80e0703a 	and	r16,r16,r3
8112bbac:	414a703a 	and	r5,r8,r5
8112bbb0:	003fa806 	br	8112ba54 <__reset+0xfb10ba54>
8112bbb4:	0080630e 	bge	zero,r2,8112bd44 <__subdf3+0x3dc>
8112bbb8:	48003026 	beq	r9,zero,8112bc7c <__subdf3+0x314>
8112bbbc:	0101ffc4 	movi	r4,2047
8112bbc0:	813f8c26 	beq	r16,r4,8112b9f4 <__reset+0xfb10b9f4>
8112bbc4:	29402034 	orhi	r5,r5,128
8112bbc8:	01000e04 	movi	r4,56
8112bbcc:	2080a90e 	bge	r4,r2,8112be74 <__subdf3+0x50c>
8112bbd0:	298cb03a 	or	r6,r5,r6
8112bbd4:	3012c03a 	cmpne	r9,r6,zero
8112bbd8:	0005883a 	mov	r2,zero
8112bbdc:	4c53883a 	add	r9,r9,r17
8112bbe0:	4c63803a 	cmpltu	r17,r9,r17
8112bbe4:	10c7883a 	add	r3,r2,r3
8112bbe8:	88c7883a 	add	r3,r17,r3
8112bbec:	4823883a 	mov	r17,r9
8112bbf0:	1880202c 	andhi	r2,r3,128
8112bbf4:	1000d026 	beq	r2,zero,8112bf38 <__subdf3+0x5d0>
8112bbf8:	84000044 	addi	r16,r16,1
8112bbfc:	0081ffc4 	movi	r2,2047
8112bc00:	8080fe26 	beq	r16,r2,8112bffc <__subdf3+0x694>
8112bc04:	00bfe034 	movhi	r2,65408
8112bc08:	10bfffc4 	addi	r2,r2,-1
8112bc0c:	1886703a 	and	r3,r3,r2
8112bc10:	880ad07a 	srli	r5,r17,1
8112bc14:	180497fa 	slli	r2,r3,31
8112bc18:	8900004c 	andi	r4,r17,1
8112bc1c:	2922b03a 	or	r17,r5,r4
8112bc20:	1806d07a 	srli	r3,r3,1
8112bc24:	1462b03a 	or	r17,r2,r17
8112bc28:	3825883a 	mov	r18,r7
8112bc2c:	003f7106 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bc30:	2984b03a 	or	r2,r5,r6
8112bc34:	103f6826 	beq	r2,zero,8112b9d8 <__reset+0xfb10b9d8>
8112bc38:	39c03fcc 	andi	r7,r7,255
8112bc3c:	003f6706 	br	8112b9dc <__reset+0xfb10b9dc>
8112bc40:	4086b03a 	or	r3,r8,r2
8112bc44:	18015226 	beq	r3,zero,8112c190 <__subdf3+0x828>
8112bc48:	00c00434 	movhi	r3,16
8112bc4c:	41400234 	orhi	r5,r8,8
8112bc50:	18ffffc4 	addi	r3,r3,-1
8112bc54:	28ca703a 	and	r5,r5,r3
8112bc58:	003f7e06 	br	8112ba54 <__reset+0xfb10ba54>
8112bc5c:	10bfffc4 	addi	r2,r2,-1
8112bc60:	1000491e 	bne	r2,zero,8112bd88 <__subdf3+0x420>
8112bc64:	898fc83a 	sub	r7,r17,r6
8112bc68:	89e3803a 	cmpltu	r17,r17,r7
8112bc6c:	1947c83a 	sub	r3,r3,r5
8112bc70:	1c47c83a 	sub	r3,r3,r17
8112bc74:	3823883a 	mov	r17,r7
8112bc78:	003f9b06 	br	8112bae8 <__reset+0xfb10bae8>
8112bc7c:	2988b03a 	or	r4,r5,r6
8112bc80:	203f5c26 	beq	r4,zero,8112b9f4 <__reset+0xfb10b9f4>
8112bc84:	10bfffc4 	addi	r2,r2,-1
8112bc88:	1000931e 	bne	r2,zero,8112bed8 <__subdf3+0x570>
8112bc8c:	898d883a 	add	r6,r17,r6
8112bc90:	3463803a 	cmpltu	r17,r6,r17
8112bc94:	1947883a 	add	r3,r3,r5
8112bc98:	88c7883a 	add	r3,r17,r3
8112bc9c:	3023883a 	mov	r17,r6
8112bca0:	003fd306 	br	8112bbf0 <__reset+0xfb10bbf0>
8112bca4:	1000541e 	bne	r2,zero,8112bdf8 <__subdf3+0x490>
8112bca8:	80800044 	addi	r2,r16,1
8112bcac:	1081ffcc 	andi	r2,r2,2047
8112bcb0:	01000044 	movi	r4,1
8112bcb4:	2080a20e 	bge	r4,r2,8112bf40 <__subdf3+0x5d8>
8112bcb8:	8989c83a 	sub	r4,r17,r6
8112bcbc:	8905803a 	cmpltu	r2,r17,r4
8112bcc0:	1967c83a 	sub	r19,r3,r5
8112bcc4:	98a7c83a 	sub	r19,r19,r2
8112bcc8:	9880202c 	andhi	r2,r19,128
8112bccc:	10006326 	beq	r2,zero,8112be5c <__subdf3+0x4f4>
8112bcd0:	3463c83a 	sub	r17,r6,r17
8112bcd4:	28c7c83a 	sub	r3,r5,r3
8112bcd8:	344d803a 	cmpltu	r6,r6,r17
8112bcdc:	19a7c83a 	sub	r19,r3,r6
8112bce0:	3825883a 	mov	r18,r7
8112bce4:	983f861e 	bne	r19,zero,8112bb00 <__reset+0xfb10bb00>
8112bce8:	8809883a 	mov	r4,r17
8112bcec:	1116a5c0 	call	81116a5c <__clzsi2>
8112bcf0:	10800804 	addi	r2,r2,32
8112bcf4:	113ffe04 	addi	r4,r2,-8
8112bcf8:	00c007c4 	movi	r3,31
8112bcfc:	193f850e 	bge	r3,r4,8112bb14 <__reset+0xfb10bb14>
8112bd00:	10bff604 	addi	r2,r2,-40
8112bd04:	8884983a 	sll	r2,r17,r2
8112bd08:	0023883a 	mov	r17,zero
8112bd0c:	243f880e 	bge	r4,r16,8112bb30 <__reset+0xfb10bb30>
8112bd10:	00ffe034 	movhi	r3,65408
8112bd14:	18ffffc4 	addi	r3,r3,-1
8112bd18:	8121c83a 	sub	r16,r16,r4
8112bd1c:	10c6703a 	and	r3,r2,r3
8112bd20:	003f3406 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bd24:	9100004c 	andi	r4,r18,1
8112bd28:	000b883a 	mov	r5,zero
8112bd2c:	0005883a 	mov	r2,zero
8112bd30:	003f4806 	br	8112ba54 <__reset+0xfb10ba54>
8112bd34:	298cb03a 	or	r6,r5,r6
8112bd38:	300cc03a 	cmpne	r6,r6,zero
8112bd3c:	0005883a 	mov	r2,zero
8112bd40:	003f6406 	br	8112bad4 <__reset+0xfb10bad4>
8112bd44:	10009a1e 	bne	r2,zero,8112bfb0 <__subdf3+0x648>
8112bd48:	82400044 	addi	r9,r16,1
8112bd4c:	4881ffcc 	andi	r2,r9,2047
8112bd50:	02800044 	movi	r10,1
8112bd54:	5080670e 	bge	r10,r2,8112bef4 <__subdf3+0x58c>
8112bd58:	0081ffc4 	movi	r2,2047
8112bd5c:	4880af26 	beq	r9,r2,8112c01c <__subdf3+0x6b4>
8112bd60:	898d883a 	add	r6,r17,r6
8112bd64:	1945883a 	add	r2,r3,r5
8112bd68:	3447803a 	cmpltu	r3,r6,r17
8112bd6c:	1887883a 	add	r3,r3,r2
8112bd70:	182297fa 	slli	r17,r3,31
8112bd74:	300cd07a 	srli	r6,r6,1
8112bd78:	1806d07a 	srli	r3,r3,1
8112bd7c:	4821883a 	mov	r16,r9
8112bd80:	89a2b03a 	or	r17,r17,r6
8112bd84:	003f1b06 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bd88:	0101ffc4 	movi	r4,2047
8112bd8c:	813f441e 	bne	r16,r4,8112baa0 <__reset+0xfb10baa0>
8112bd90:	003f1806 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bd94:	843ff844 	addi	r16,r16,-31
8112bd98:	01400804 	movi	r5,32
8112bd9c:	1408d83a 	srl	r4,r2,r16
8112bda0:	19405026 	beq	r3,r5,8112bee4 <__subdf3+0x57c>
8112bda4:	01401004 	movi	r5,64
8112bda8:	28c7c83a 	sub	r3,r5,r3
8112bdac:	10c4983a 	sll	r2,r2,r3
8112bdb0:	88a2b03a 	or	r17,r17,r2
8112bdb4:	8822c03a 	cmpne	r17,r17,zero
8112bdb8:	2462b03a 	or	r17,r4,r17
8112bdbc:	0007883a 	mov	r3,zero
8112bdc0:	0021883a 	mov	r16,zero
8112bdc4:	003f6d06 	br	8112bb7c <__reset+0xfb10bb7c>
8112bdc8:	11fff804 	addi	r7,r2,-32
8112bdcc:	01000804 	movi	r4,32
8112bdd0:	29ced83a 	srl	r7,r5,r7
8112bdd4:	11004526 	beq	r2,r4,8112beec <__subdf3+0x584>
8112bdd8:	01001004 	movi	r4,64
8112bddc:	2089c83a 	sub	r4,r4,r2
8112bde0:	2904983a 	sll	r2,r5,r4
8112bde4:	118cb03a 	or	r6,r2,r6
8112bde8:	300cc03a 	cmpne	r6,r6,zero
8112bdec:	398cb03a 	or	r6,r7,r6
8112bdf0:	0005883a 	mov	r2,zero
8112bdf4:	003f3706 	br	8112bad4 <__reset+0xfb10bad4>
8112bdf8:	80002a26 	beq	r16,zero,8112bea4 <__subdf3+0x53c>
8112bdfc:	0101ffc4 	movi	r4,2047
8112be00:	49006626 	beq	r9,r4,8112bf9c <__subdf3+0x634>
8112be04:	0085c83a 	sub	r2,zero,r2
8112be08:	18c02034 	orhi	r3,r3,128
8112be0c:	01000e04 	movi	r4,56
8112be10:	20807e16 	blt	r4,r2,8112c00c <__subdf3+0x6a4>
8112be14:	010007c4 	movi	r4,31
8112be18:	2080e716 	blt	r4,r2,8112c1b8 <__subdf3+0x850>
8112be1c:	01000804 	movi	r4,32
8112be20:	2089c83a 	sub	r4,r4,r2
8112be24:	1914983a 	sll	r10,r3,r4
8112be28:	8890d83a 	srl	r8,r17,r2
8112be2c:	8908983a 	sll	r4,r17,r4
8112be30:	1884d83a 	srl	r2,r3,r2
8112be34:	5222b03a 	or	r17,r10,r8
8112be38:	2006c03a 	cmpne	r3,r4,zero
8112be3c:	88e2b03a 	or	r17,r17,r3
8112be40:	3463c83a 	sub	r17,r6,r17
8112be44:	2885c83a 	sub	r2,r5,r2
8112be48:	344d803a 	cmpltu	r6,r6,r17
8112be4c:	1187c83a 	sub	r3,r2,r6
8112be50:	4821883a 	mov	r16,r9
8112be54:	3825883a 	mov	r18,r7
8112be58:	003f2306 	br	8112bae8 <__reset+0xfb10bae8>
8112be5c:	24d0b03a 	or	r8,r4,r19
8112be60:	40001b1e 	bne	r8,zero,8112bed0 <__subdf3+0x568>
8112be64:	0005883a 	mov	r2,zero
8112be68:	0009883a 	mov	r4,zero
8112be6c:	0021883a 	mov	r16,zero
8112be70:	003f4906 	br	8112bb98 <__reset+0xfb10bb98>
8112be74:	010007c4 	movi	r4,31
8112be78:	20803a16 	blt	r4,r2,8112bf64 <__subdf3+0x5fc>
8112be7c:	01000804 	movi	r4,32
8112be80:	2089c83a 	sub	r4,r4,r2
8112be84:	2912983a 	sll	r9,r5,r4
8112be88:	3090d83a 	srl	r8,r6,r2
8112be8c:	3108983a 	sll	r4,r6,r4
8112be90:	2884d83a 	srl	r2,r5,r2
8112be94:	4a12b03a 	or	r9,r9,r8
8112be98:	2008c03a 	cmpne	r4,r4,zero
8112be9c:	4912b03a 	or	r9,r9,r4
8112bea0:	003f4e06 	br	8112bbdc <__reset+0xfb10bbdc>
8112bea4:	1c48b03a 	or	r4,r3,r17
8112bea8:	20003c26 	beq	r4,zero,8112bf9c <__subdf3+0x634>
8112beac:	0084303a 	nor	r2,zero,r2
8112beb0:	1000381e 	bne	r2,zero,8112bf94 <__subdf3+0x62c>
8112beb4:	3463c83a 	sub	r17,r6,r17
8112beb8:	28c5c83a 	sub	r2,r5,r3
8112bebc:	344d803a 	cmpltu	r6,r6,r17
8112bec0:	1187c83a 	sub	r3,r2,r6
8112bec4:	4821883a 	mov	r16,r9
8112bec8:	3825883a 	mov	r18,r7
8112becc:	003f0606 	br	8112bae8 <__reset+0xfb10bae8>
8112bed0:	2023883a 	mov	r17,r4
8112bed4:	003f0906 	br	8112bafc <__reset+0xfb10bafc>
8112bed8:	0101ffc4 	movi	r4,2047
8112bedc:	813f3a1e 	bne	r16,r4,8112bbc8 <__reset+0xfb10bbc8>
8112bee0:	003ec406 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bee4:	0005883a 	mov	r2,zero
8112bee8:	003fb106 	br	8112bdb0 <__reset+0xfb10bdb0>
8112beec:	0005883a 	mov	r2,zero
8112bef0:	003fbc06 	br	8112bde4 <__reset+0xfb10bde4>
8112bef4:	1c44b03a 	or	r2,r3,r17
8112bef8:	80008e1e 	bne	r16,zero,8112c134 <__subdf3+0x7cc>
8112befc:	1000c826 	beq	r2,zero,8112c220 <__subdf3+0x8b8>
8112bf00:	2984b03a 	or	r2,r5,r6
8112bf04:	103ebb26 	beq	r2,zero,8112b9f4 <__reset+0xfb10b9f4>
8112bf08:	8989883a 	add	r4,r17,r6
8112bf0c:	1945883a 	add	r2,r3,r5
8112bf10:	2447803a 	cmpltu	r3,r4,r17
8112bf14:	1887883a 	add	r3,r3,r2
8112bf18:	1880202c 	andhi	r2,r3,128
8112bf1c:	2023883a 	mov	r17,r4
8112bf20:	103f1626 	beq	r2,zero,8112bb7c <__reset+0xfb10bb7c>
8112bf24:	00bfe034 	movhi	r2,65408
8112bf28:	10bfffc4 	addi	r2,r2,-1
8112bf2c:	5021883a 	mov	r16,r10
8112bf30:	1886703a 	and	r3,r3,r2
8112bf34:	003eaf06 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bf38:	3825883a 	mov	r18,r7
8112bf3c:	003f0f06 	br	8112bb7c <__reset+0xfb10bb7c>
8112bf40:	1c44b03a 	or	r2,r3,r17
8112bf44:	8000251e 	bne	r16,zero,8112bfdc <__subdf3+0x674>
8112bf48:	1000661e 	bne	r2,zero,8112c0e4 <__subdf3+0x77c>
8112bf4c:	2990b03a 	or	r8,r5,r6
8112bf50:	40009626 	beq	r8,zero,8112c1ac <__subdf3+0x844>
8112bf54:	2807883a 	mov	r3,r5
8112bf58:	3023883a 	mov	r17,r6
8112bf5c:	3825883a 	mov	r18,r7
8112bf60:	003ea406 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bf64:	127ff804 	addi	r9,r2,-32
8112bf68:	01000804 	movi	r4,32
8112bf6c:	2a52d83a 	srl	r9,r5,r9
8112bf70:	11008c26 	beq	r2,r4,8112c1a4 <__subdf3+0x83c>
8112bf74:	01001004 	movi	r4,64
8112bf78:	2085c83a 	sub	r2,r4,r2
8112bf7c:	2884983a 	sll	r2,r5,r2
8112bf80:	118cb03a 	or	r6,r2,r6
8112bf84:	300cc03a 	cmpne	r6,r6,zero
8112bf88:	4992b03a 	or	r9,r9,r6
8112bf8c:	0005883a 	mov	r2,zero
8112bf90:	003f1206 	br	8112bbdc <__reset+0xfb10bbdc>
8112bf94:	0101ffc4 	movi	r4,2047
8112bf98:	493f9c1e 	bne	r9,r4,8112be0c <__reset+0xfb10be0c>
8112bf9c:	2807883a 	mov	r3,r5
8112bfa0:	3023883a 	mov	r17,r6
8112bfa4:	4821883a 	mov	r16,r9
8112bfa8:	3825883a 	mov	r18,r7
8112bfac:	003e9106 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bfb0:	80001f1e 	bne	r16,zero,8112c030 <__subdf3+0x6c8>
8112bfb4:	1c48b03a 	or	r4,r3,r17
8112bfb8:	20005a26 	beq	r4,zero,8112c124 <__subdf3+0x7bc>
8112bfbc:	0084303a 	nor	r2,zero,r2
8112bfc0:	1000561e 	bne	r2,zero,8112c11c <__subdf3+0x7b4>
8112bfc4:	89a3883a 	add	r17,r17,r6
8112bfc8:	1945883a 	add	r2,r3,r5
8112bfcc:	898d803a 	cmpltu	r6,r17,r6
8112bfd0:	3087883a 	add	r3,r6,r2
8112bfd4:	4821883a 	mov	r16,r9
8112bfd8:	003f0506 	br	8112bbf0 <__reset+0xfb10bbf0>
8112bfdc:	10002b1e 	bne	r2,zero,8112c08c <__subdf3+0x724>
8112bfe0:	2984b03a 	or	r2,r5,r6
8112bfe4:	10008026 	beq	r2,zero,8112c1e8 <__subdf3+0x880>
8112bfe8:	2807883a 	mov	r3,r5
8112bfec:	3023883a 	mov	r17,r6
8112bff0:	3825883a 	mov	r18,r7
8112bff4:	0401ffc4 	movi	r16,2047
8112bff8:	003e7e06 	br	8112b9f4 <__reset+0xfb10b9f4>
8112bffc:	3809883a 	mov	r4,r7
8112c000:	0011883a 	mov	r8,zero
8112c004:	0005883a 	mov	r2,zero
8112c008:	003ee306 	br	8112bb98 <__reset+0xfb10bb98>
8112c00c:	1c62b03a 	or	r17,r3,r17
8112c010:	8822c03a 	cmpne	r17,r17,zero
8112c014:	0005883a 	mov	r2,zero
8112c018:	003f8906 	br	8112be40 <__reset+0xfb10be40>
8112c01c:	3809883a 	mov	r4,r7
8112c020:	4821883a 	mov	r16,r9
8112c024:	0011883a 	mov	r8,zero
8112c028:	0005883a 	mov	r2,zero
8112c02c:	003eda06 	br	8112bb98 <__reset+0xfb10bb98>
8112c030:	0101ffc4 	movi	r4,2047
8112c034:	49003b26 	beq	r9,r4,8112c124 <__subdf3+0x7bc>
8112c038:	0085c83a 	sub	r2,zero,r2
8112c03c:	18c02034 	orhi	r3,r3,128
8112c040:	01000e04 	movi	r4,56
8112c044:	20806e16 	blt	r4,r2,8112c200 <__subdf3+0x898>
8112c048:	010007c4 	movi	r4,31
8112c04c:	20807716 	blt	r4,r2,8112c22c <__subdf3+0x8c4>
8112c050:	01000804 	movi	r4,32
8112c054:	2089c83a 	sub	r4,r4,r2
8112c058:	1914983a 	sll	r10,r3,r4
8112c05c:	8890d83a 	srl	r8,r17,r2
8112c060:	8908983a 	sll	r4,r17,r4
8112c064:	1884d83a 	srl	r2,r3,r2
8112c068:	5222b03a 	or	r17,r10,r8
8112c06c:	2006c03a 	cmpne	r3,r4,zero
8112c070:	88e2b03a 	or	r17,r17,r3
8112c074:	89a3883a 	add	r17,r17,r6
8112c078:	1145883a 	add	r2,r2,r5
8112c07c:	898d803a 	cmpltu	r6,r17,r6
8112c080:	3087883a 	add	r3,r6,r2
8112c084:	4821883a 	mov	r16,r9
8112c088:	003ed906 	br	8112bbf0 <__reset+0xfb10bbf0>
8112c08c:	2984b03a 	or	r2,r5,r6
8112c090:	10004226 	beq	r2,zero,8112c19c <__subdf3+0x834>
8112c094:	1808d0fa 	srli	r4,r3,3
8112c098:	8822d0fa 	srli	r17,r17,3
8112c09c:	1806977a 	slli	r3,r3,29
8112c0a0:	2080022c 	andhi	r2,r4,8
8112c0a4:	1c62b03a 	or	r17,r3,r17
8112c0a8:	10000826 	beq	r2,zero,8112c0cc <__subdf3+0x764>
8112c0ac:	2812d0fa 	srli	r9,r5,3
8112c0b0:	4880022c 	andhi	r2,r9,8
8112c0b4:	1000051e 	bne	r2,zero,8112c0cc <__subdf3+0x764>
8112c0b8:	300cd0fa 	srli	r6,r6,3
8112c0bc:	2804977a 	slli	r2,r5,29
8112c0c0:	4809883a 	mov	r4,r9
8112c0c4:	3825883a 	mov	r18,r7
8112c0c8:	11a2b03a 	or	r17,r2,r6
8112c0cc:	8806d77a 	srli	r3,r17,29
8112c0d0:	200890fa 	slli	r4,r4,3
8112c0d4:	882290fa 	slli	r17,r17,3
8112c0d8:	0401ffc4 	movi	r16,2047
8112c0dc:	1906b03a 	or	r3,r3,r4
8112c0e0:	003e4406 	br	8112b9f4 <__reset+0xfb10b9f4>
8112c0e4:	2984b03a 	or	r2,r5,r6
8112c0e8:	103e4226 	beq	r2,zero,8112b9f4 <__reset+0xfb10b9f4>
8112c0ec:	8989c83a 	sub	r4,r17,r6
8112c0f0:	8911803a 	cmpltu	r8,r17,r4
8112c0f4:	1945c83a 	sub	r2,r3,r5
8112c0f8:	1205c83a 	sub	r2,r2,r8
8112c0fc:	1200202c 	andhi	r8,r2,128
8112c100:	403e9a26 	beq	r8,zero,8112bb6c <__reset+0xfb10bb6c>
8112c104:	3463c83a 	sub	r17,r6,r17
8112c108:	28c5c83a 	sub	r2,r5,r3
8112c10c:	344d803a 	cmpltu	r6,r6,r17
8112c110:	1187c83a 	sub	r3,r2,r6
8112c114:	3825883a 	mov	r18,r7
8112c118:	003e3606 	br	8112b9f4 <__reset+0xfb10b9f4>
8112c11c:	0101ffc4 	movi	r4,2047
8112c120:	493fc71e 	bne	r9,r4,8112c040 <__reset+0xfb10c040>
8112c124:	2807883a 	mov	r3,r5
8112c128:	3023883a 	mov	r17,r6
8112c12c:	4821883a 	mov	r16,r9
8112c130:	003e3006 	br	8112b9f4 <__reset+0xfb10b9f4>
8112c134:	10003626 	beq	r2,zero,8112c210 <__subdf3+0x8a8>
8112c138:	2984b03a 	or	r2,r5,r6
8112c13c:	10001726 	beq	r2,zero,8112c19c <__subdf3+0x834>
8112c140:	1808d0fa 	srli	r4,r3,3
8112c144:	8822d0fa 	srli	r17,r17,3
8112c148:	1806977a 	slli	r3,r3,29
8112c14c:	2080022c 	andhi	r2,r4,8
8112c150:	1c62b03a 	or	r17,r3,r17
8112c154:	10000726 	beq	r2,zero,8112c174 <__subdf3+0x80c>
8112c158:	2812d0fa 	srli	r9,r5,3
8112c15c:	4880022c 	andhi	r2,r9,8
8112c160:	1000041e 	bne	r2,zero,8112c174 <__subdf3+0x80c>
8112c164:	300cd0fa 	srli	r6,r6,3
8112c168:	2804977a 	slli	r2,r5,29
8112c16c:	4809883a 	mov	r4,r9
8112c170:	11a2b03a 	or	r17,r2,r6
8112c174:	8806d77a 	srli	r3,r17,29
8112c178:	200890fa 	slli	r4,r4,3
8112c17c:	882290fa 	slli	r17,r17,3
8112c180:	3825883a 	mov	r18,r7
8112c184:	1906b03a 	or	r3,r3,r4
8112c188:	0401ffc4 	movi	r16,2047
8112c18c:	003e1906 	br	8112b9f4 <__reset+0xfb10b9f4>
8112c190:	000b883a 	mov	r5,zero
8112c194:	0005883a 	mov	r2,zero
8112c198:	003e2e06 	br	8112ba54 <__reset+0xfb10ba54>
8112c19c:	0401ffc4 	movi	r16,2047
8112c1a0:	003e1406 	br	8112b9f4 <__reset+0xfb10b9f4>
8112c1a4:	0005883a 	mov	r2,zero
8112c1a8:	003f7506 	br	8112bf80 <__reset+0xfb10bf80>
8112c1ac:	0005883a 	mov	r2,zero
8112c1b0:	0009883a 	mov	r4,zero
8112c1b4:	003e7806 	br	8112bb98 <__reset+0xfb10bb98>
8112c1b8:	123ff804 	addi	r8,r2,-32
8112c1bc:	01000804 	movi	r4,32
8112c1c0:	1a10d83a 	srl	r8,r3,r8
8112c1c4:	11002526 	beq	r2,r4,8112c25c <__subdf3+0x8f4>
8112c1c8:	01001004 	movi	r4,64
8112c1cc:	2085c83a 	sub	r2,r4,r2
8112c1d0:	1884983a 	sll	r2,r3,r2
8112c1d4:	1444b03a 	or	r2,r2,r17
8112c1d8:	1004c03a 	cmpne	r2,r2,zero
8112c1dc:	40a2b03a 	or	r17,r8,r2
8112c1e0:	0005883a 	mov	r2,zero
8112c1e4:	003f1606 	br	8112be40 <__reset+0xfb10be40>
8112c1e8:	02000434 	movhi	r8,16
8112c1ec:	0009883a 	mov	r4,zero
8112c1f0:	423fffc4 	addi	r8,r8,-1
8112c1f4:	00bfffc4 	movi	r2,-1
8112c1f8:	0401ffc4 	movi	r16,2047
8112c1fc:	003e6606 	br	8112bb98 <__reset+0xfb10bb98>
8112c200:	1c62b03a 	or	r17,r3,r17
8112c204:	8822c03a 	cmpne	r17,r17,zero
8112c208:	0005883a 	mov	r2,zero
8112c20c:	003f9906 	br	8112c074 <__reset+0xfb10c074>
8112c210:	2807883a 	mov	r3,r5
8112c214:	3023883a 	mov	r17,r6
8112c218:	0401ffc4 	movi	r16,2047
8112c21c:	003df506 	br	8112b9f4 <__reset+0xfb10b9f4>
8112c220:	2807883a 	mov	r3,r5
8112c224:	3023883a 	mov	r17,r6
8112c228:	003df206 	br	8112b9f4 <__reset+0xfb10b9f4>
8112c22c:	123ff804 	addi	r8,r2,-32
8112c230:	01000804 	movi	r4,32
8112c234:	1a10d83a 	srl	r8,r3,r8
8112c238:	11000a26 	beq	r2,r4,8112c264 <__subdf3+0x8fc>
8112c23c:	01001004 	movi	r4,64
8112c240:	2085c83a 	sub	r2,r4,r2
8112c244:	1884983a 	sll	r2,r3,r2
8112c248:	1444b03a 	or	r2,r2,r17
8112c24c:	1004c03a 	cmpne	r2,r2,zero
8112c250:	40a2b03a 	or	r17,r8,r2
8112c254:	0005883a 	mov	r2,zero
8112c258:	003f8606 	br	8112c074 <__reset+0xfb10c074>
8112c25c:	0005883a 	mov	r2,zero
8112c260:	003fdc06 	br	8112c1d4 <__reset+0xfb10c1d4>
8112c264:	0005883a 	mov	r2,zero
8112c268:	003ff706 	br	8112c248 <__reset+0xfb10c248>

8112c26c <__fixdfsi>:
8112c26c:	280cd53a 	srli	r6,r5,20
8112c270:	00c00434 	movhi	r3,16
8112c274:	18ffffc4 	addi	r3,r3,-1
8112c278:	3181ffcc 	andi	r6,r6,2047
8112c27c:	01c0ff84 	movi	r7,1022
8112c280:	28c6703a 	and	r3,r5,r3
8112c284:	280ad7fa 	srli	r5,r5,31
8112c288:	3980120e 	bge	r7,r6,8112c2d4 <__fixdfsi+0x68>
8112c28c:	00810744 	movi	r2,1053
8112c290:	11800c16 	blt	r2,r6,8112c2c4 <__fixdfsi+0x58>
8112c294:	00810cc4 	movi	r2,1075
8112c298:	1185c83a 	sub	r2,r2,r6
8112c29c:	01c007c4 	movi	r7,31
8112c2a0:	18c00434 	orhi	r3,r3,16
8112c2a4:	38800d16 	blt	r7,r2,8112c2dc <__fixdfsi+0x70>
8112c2a8:	31befb44 	addi	r6,r6,-1043
8112c2ac:	2084d83a 	srl	r2,r4,r2
8112c2b0:	1986983a 	sll	r3,r3,r6
8112c2b4:	1884b03a 	or	r2,r3,r2
8112c2b8:	28000726 	beq	r5,zero,8112c2d8 <__fixdfsi+0x6c>
8112c2bc:	0085c83a 	sub	r2,zero,r2
8112c2c0:	f800283a 	ret
8112c2c4:	00a00034 	movhi	r2,32768
8112c2c8:	10bfffc4 	addi	r2,r2,-1
8112c2cc:	2885883a 	add	r2,r5,r2
8112c2d0:	f800283a 	ret
8112c2d4:	0005883a 	mov	r2,zero
8112c2d8:	f800283a 	ret
8112c2dc:	008104c4 	movi	r2,1043
8112c2e0:	1185c83a 	sub	r2,r2,r6
8112c2e4:	1884d83a 	srl	r2,r3,r2
8112c2e8:	003ff306 	br	8112c2b8 <__reset+0xfb10c2b8>

8112c2ec <__floatsidf>:
8112c2ec:	defffd04 	addi	sp,sp,-12
8112c2f0:	de00012e 	bgeu	sp,et,8112c2f8 <__floatsidf+0xc>
8112c2f4:	003b68fa 	trap	3
8112c2f8:	dfc00215 	stw	ra,8(sp)
8112c2fc:	dc400115 	stw	r17,4(sp)
8112c300:	dc000015 	stw	r16,0(sp)
8112c304:	20002b26 	beq	r4,zero,8112c3b4 <__floatsidf+0xc8>
8112c308:	2023883a 	mov	r17,r4
8112c30c:	2020d7fa 	srli	r16,r4,31
8112c310:	20002d16 	blt	r4,zero,8112c3c8 <__floatsidf+0xdc>
8112c314:	8809883a 	mov	r4,r17
8112c318:	1116a5c0 	call	81116a5c <__clzsi2>
8112c31c:	01410784 	movi	r5,1054
8112c320:	288bc83a 	sub	r5,r5,r2
8112c324:	01010cc4 	movi	r4,1075
8112c328:	2149c83a 	sub	r4,r4,r5
8112c32c:	00c007c4 	movi	r3,31
8112c330:	1900160e 	bge	r3,r4,8112c38c <__floatsidf+0xa0>
8112c334:	00c104c4 	movi	r3,1043
8112c338:	1947c83a 	sub	r3,r3,r5
8112c33c:	88c6983a 	sll	r3,r17,r3
8112c340:	00800434 	movhi	r2,16
8112c344:	10bfffc4 	addi	r2,r2,-1
8112c348:	1886703a 	and	r3,r3,r2
8112c34c:	2941ffcc 	andi	r5,r5,2047
8112c350:	800d883a 	mov	r6,r16
8112c354:	0005883a 	mov	r2,zero
8112c358:	280a953a 	slli	r5,r5,20
8112c35c:	31803fcc 	andi	r6,r6,255
8112c360:	01000434 	movhi	r4,16
8112c364:	300c97fa 	slli	r6,r6,31
8112c368:	213fffc4 	addi	r4,r4,-1
8112c36c:	1906703a 	and	r3,r3,r4
8112c370:	1946b03a 	or	r3,r3,r5
8112c374:	1986b03a 	or	r3,r3,r6
8112c378:	dfc00217 	ldw	ra,8(sp)
8112c37c:	dc400117 	ldw	r17,4(sp)
8112c380:	dc000017 	ldw	r16,0(sp)
8112c384:	dec00304 	addi	sp,sp,12
8112c388:	f800283a 	ret
8112c38c:	00c002c4 	movi	r3,11
8112c390:	1887c83a 	sub	r3,r3,r2
8112c394:	88c6d83a 	srl	r3,r17,r3
8112c398:	8904983a 	sll	r2,r17,r4
8112c39c:	01000434 	movhi	r4,16
8112c3a0:	213fffc4 	addi	r4,r4,-1
8112c3a4:	2941ffcc 	andi	r5,r5,2047
8112c3a8:	1906703a 	and	r3,r3,r4
8112c3ac:	800d883a 	mov	r6,r16
8112c3b0:	003fe906 	br	8112c358 <__reset+0xfb10c358>
8112c3b4:	000d883a 	mov	r6,zero
8112c3b8:	000b883a 	mov	r5,zero
8112c3bc:	0007883a 	mov	r3,zero
8112c3c0:	0005883a 	mov	r2,zero
8112c3c4:	003fe406 	br	8112c358 <__reset+0xfb10c358>
8112c3c8:	0123c83a 	sub	r17,zero,r4
8112c3cc:	003fd106 	br	8112c314 <__reset+0xfb10c314>

8112c3d0 <__floatunsidf>:
8112c3d0:	defffe04 	addi	sp,sp,-8
8112c3d4:	de00012e 	bgeu	sp,et,8112c3dc <__floatunsidf+0xc>
8112c3d8:	003b68fa 	trap	3
8112c3dc:	dc000015 	stw	r16,0(sp)
8112c3e0:	dfc00115 	stw	ra,4(sp)
8112c3e4:	2021883a 	mov	r16,r4
8112c3e8:	20002226 	beq	r4,zero,8112c474 <__floatunsidf+0xa4>
8112c3ec:	1116a5c0 	call	81116a5c <__clzsi2>
8112c3f0:	01010784 	movi	r4,1054
8112c3f4:	2089c83a 	sub	r4,r4,r2
8112c3f8:	01810cc4 	movi	r6,1075
8112c3fc:	310dc83a 	sub	r6,r6,r4
8112c400:	00c007c4 	movi	r3,31
8112c404:	1980120e 	bge	r3,r6,8112c450 <__floatunsidf+0x80>
8112c408:	00c104c4 	movi	r3,1043
8112c40c:	1907c83a 	sub	r3,r3,r4
8112c410:	80ca983a 	sll	r5,r16,r3
8112c414:	00800434 	movhi	r2,16
8112c418:	10bfffc4 	addi	r2,r2,-1
8112c41c:	2101ffcc 	andi	r4,r4,2047
8112c420:	0021883a 	mov	r16,zero
8112c424:	288a703a 	and	r5,r5,r2
8112c428:	2008953a 	slli	r4,r4,20
8112c42c:	00c00434 	movhi	r3,16
8112c430:	18ffffc4 	addi	r3,r3,-1
8112c434:	28c6703a 	and	r3,r5,r3
8112c438:	8005883a 	mov	r2,r16
8112c43c:	1906b03a 	or	r3,r3,r4
8112c440:	dfc00117 	ldw	ra,4(sp)
8112c444:	dc000017 	ldw	r16,0(sp)
8112c448:	dec00204 	addi	sp,sp,8
8112c44c:	f800283a 	ret
8112c450:	00c002c4 	movi	r3,11
8112c454:	188bc83a 	sub	r5,r3,r2
8112c458:	814ad83a 	srl	r5,r16,r5
8112c45c:	00c00434 	movhi	r3,16
8112c460:	18ffffc4 	addi	r3,r3,-1
8112c464:	81a0983a 	sll	r16,r16,r6
8112c468:	2101ffcc 	andi	r4,r4,2047
8112c46c:	28ca703a 	and	r5,r5,r3
8112c470:	003fed06 	br	8112c428 <__reset+0xfb10c428>
8112c474:	0009883a 	mov	r4,zero
8112c478:	000b883a 	mov	r5,zero
8112c47c:	003fea06 	br	8112c428 <__reset+0xfb10c428>

8112c480 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
8112c480:	defffb04 	addi	sp,sp,-20
8112c484:	de00012e 	bgeu	sp,et,8112c48c <alt_busy_sleep+0xc>
8112c488:	003b68fa 	trap	3
8112c48c:	df000415 	stw	fp,16(sp)
8112c490:	df000404 	addi	fp,sp,16
8112c494:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
8112c498:	008000c4 	movi	r2,3
8112c49c:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
8112c4a0:	e0fffd17 	ldw	r3,-12(fp)
8112c4a4:	008003f4 	movhi	r2,15
8112c4a8:	10909004 	addi	r2,r2,16960
8112c4ac:	1887383a 	mul	r3,r3,r2
8112c4b0:	00817db4 	movhi	r2,1526
8112c4b4:	10b84004 	addi	r2,r2,-7936
8112c4b8:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
8112c4bc:	00a00034 	movhi	r2,32768
8112c4c0:	10bfffc4 	addi	r2,r2,-1
8112c4c4:	10c5203a 	divu	r2,r2,r3
8112c4c8:	e0ffff17 	ldw	r3,-4(fp)
8112c4cc:	1885203a 	divu	r2,r3,r2
8112c4d0:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
8112c4d4:	e0bffe17 	ldw	r2,-8(fp)
8112c4d8:	10002526 	beq	r2,zero,8112c570 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
8112c4dc:	e03ffc15 	stw	zero,-16(fp)
8112c4e0:	00001406 	br	8112c534 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
8112c4e4:	00a00034 	movhi	r2,32768
8112c4e8:	10bfffc4 	addi	r2,r2,-1
8112c4ec:	10bfffc4 	addi	r2,r2,-1
8112c4f0:	103ffe1e 	bne	r2,zero,8112c4ec <__reset+0xfb10c4ec>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
8112c4f4:	e0fffd17 	ldw	r3,-12(fp)
8112c4f8:	008003f4 	movhi	r2,15
8112c4fc:	10909004 	addi	r2,r2,16960
8112c500:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
8112c504:	00817db4 	movhi	r2,1526
8112c508:	10b84004 	addi	r2,r2,-7936
8112c50c:	10c7203a 	divu	r3,r2,r3
8112c510:	00a00034 	movhi	r2,32768
8112c514:	10bfffc4 	addi	r2,r2,-1
8112c518:	10c5203a 	divu	r2,r2,r3
8112c51c:	e0ffff17 	ldw	r3,-4(fp)
8112c520:	1885c83a 	sub	r2,r3,r2
8112c524:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
8112c528:	e0bffc17 	ldw	r2,-16(fp)
8112c52c:	10800044 	addi	r2,r2,1
8112c530:	e0bffc15 	stw	r2,-16(fp)
8112c534:	e0fffc17 	ldw	r3,-16(fp)
8112c538:	e0bffe17 	ldw	r2,-8(fp)
8112c53c:	18bfe916 	blt	r3,r2,8112c4e4 <__reset+0xfb10c4e4>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8112c540:	e0fffd17 	ldw	r3,-12(fp)
8112c544:	008003f4 	movhi	r2,15
8112c548:	10909004 	addi	r2,r2,16960
8112c54c:	1887383a 	mul	r3,r3,r2
8112c550:	00817db4 	movhi	r2,1526
8112c554:	10b84004 	addi	r2,r2,-7936
8112c558:	10c7203a 	divu	r3,r2,r3
8112c55c:	e0bfff17 	ldw	r2,-4(fp)
8112c560:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
8112c564:	10bfffc4 	addi	r2,r2,-1
8112c568:	103ffe1e 	bne	r2,zero,8112c564 <__reset+0xfb10c564>
8112c56c:	00000b06 	br	8112c59c <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8112c570:	e0fffd17 	ldw	r3,-12(fp)
8112c574:	008003f4 	movhi	r2,15
8112c578:	10909004 	addi	r2,r2,16960
8112c57c:	1887383a 	mul	r3,r3,r2
8112c580:	00817db4 	movhi	r2,1526
8112c584:	10b84004 	addi	r2,r2,-7936
8112c588:	10c7203a 	divu	r3,r2,r3
8112c58c:	e0bfff17 	ldw	r2,-4(fp)
8112c590:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
8112c594:	10bfffc4 	addi	r2,r2,-1
8112c598:	00bffe16 	blt	zero,r2,8112c594 <__reset+0xfb10c594>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
8112c59c:	0005883a 	mov	r2,zero
}
8112c5a0:	e037883a 	mov	sp,fp
8112c5a4:	df000017 	ldw	fp,0(sp)
8112c5a8:	dec00104 	addi	sp,sp,4
8112c5ac:	f800283a 	ret

8112c5b0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112c5b0:	defffe04 	addi	sp,sp,-8
8112c5b4:	de00012e 	bgeu	sp,et,8112c5bc <alt_get_errno+0xc>
8112c5b8:	003b68fa 	trap	3
8112c5bc:	dfc00115 	stw	ra,4(sp)
8112c5c0:	df000015 	stw	fp,0(sp)
8112c5c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112c5c8:	d0a01017 	ldw	r2,-32704(gp)
8112c5cc:	10000326 	beq	r2,zero,8112c5dc <alt_get_errno+0x2c>
8112c5d0:	d0a01017 	ldw	r2,-32704(gp)
8112c5d4:	103ee83a 	callr	r2
8112c5d8:	00000106 	br	8112c5e0 <alt_get_errno+0x30>
8112c5dc:	d0a06904 	addi	r2,gp,-32348
}
8112c5e0:	e037883a 	mov	sp,fp
8112c5e4:	dfc00117 	ldw	ra,4(sp)
8112c5e8:	df000017 	ldw	fp,0(sp)
8112c5ec:	dec00204 	addi	sp,sp,8
8112c5f0:	f800283a 	ret

8112c5f4 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
8112c5f4:	defffb04 	addi	sp,sp,-20
8112c5f8:	de00012e 	bgeu	sp,et,8112c600 <close+0xc>
8112c5fc:	003b68fa 	trap	3
8112c600:	dfc00415 	stw	ra,16(sp)
8112c604:	df000315 	stw	fp,12(sp)
8112c608:	df000304 	addi	fp,sp,12
8112c60c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
8112c610:	e0bfff17 	ldw	r2,-4(fp)
8112c614:	10000616 	blt	r2,zero,8112c630 <close+0x3c>
8112c618:	e0bfff17 	ldw	r2,-4(fp)
8112c61c:	10c00324 	muli	r3,r2,12
8112c620:	00a04534 	movhi	r2,33044
8112c624:	109bea04 	addi	r2,r2,28584
8112c628:	1885883a 	add	r2,r3,r2
8112c62c:	00000106 	br	8112c634 <close+0x40>
8112c630:	0005883a 	mov	r2,zero
8112c634:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
8112c638:	e0bffd17 	ldw	r2,-12(fp)
8112c63c:	10001926 	beq	r2,zero,8112c6a4 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
8112c640:	e0bffd17 	ldw	r2,-12(fp)
8112c644:	10800017 	ldw	r2,0(r2)
8112c648:	10800417 	ldw	r2,16(r2)
8112c64c:	10000626 	beq	r2,zero,8112c668 <close+0x74>
8112c650:	e0bffd17 	ldw	r2,-12(fp)
8112c654:	10800017 	ldw	r2,0(r2)
8112c658:	10800417 	ldw	r2,16(r2)
8112c65c:	e13ffd17 	ldw	r4,-12(fp)
8112c660:	103ee83a 	callr	r2
8112c664:	00000106 	br	8112c66c <close+0x78>
8112c668:	0005883a 	mov	r2,zero
8112c66c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
8112c670:	e13fff17 	ldw	r4,-4(fp)
8112c674:	112dbd80 	call	8112dbd8 <alt_release_fd>
    if (rval < 0)
8112c678:	e0bffe17 	ldw	r2,-8(fp)
8112c67c:	1000070e 	bge	r2,zero,8112c69c <close+0xa8>
    {
      ALT_ERRNO = -rval;
8112c680:	112c5b00 	call	8112c5b0 <alt_get_errno>
8112c684:	1007883a 	mov	r3,r2
8112c688:	e0bffe17 	ldw	r2,-8(fp)
8112c68c:	0085c83a 	sub	r2,zero,r2
8112c690:	18800015 	stw	r2,0(r3)
      return -1;
8112c694:	00bfffc4 	movi	r2,-1
8112c698:	00000706 	br	8112c6b8 <close+0xc4>
    }
    return 0;
8112c69c:	0005883a 	mov	r2,zero
8112c6a0:	00000506 	br	8112c6b8 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
8112c6a4:	112c5b00 	call	8112c5b0 <alt_get_errno>
8112c6a8:	1007883a 	mov	r3,r2
8112c6ac:	00801444 	movi	r2,81
8112c6b0:	18800015 	stw	r2,0(r3)
    return -1;
8112c6b4:	00bfffc4 	movi	r2,-1
  }
}
8112c6b8:	e037883a 	mov	sp,fp
8112c6bc:	dfc00117 	ldw	ra,4(sp)
8112c6c0:	df000017 	ldw	fp,0(sp)
8112c6c4:	dec00204 	addi	sp,sp,8
8112c6c8:	f800283a 	ret

8112c6cc <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
8112c6cc:	deffff04 	addi	sp,sp,-4
8112c6d0:	de00012e 	bgeu	sp,et,8112c6d8 <alt_dcache_flush_all+0xc>
8112c6d4:	003b68fa 	trap	3
8112c6d8:	df000015 	stw	fp,0(sp)
8112c6dc:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
8112c6e0:	0001883a 	nop
8112c6e4:	e037883a 	mov	sp,fp
8112c6e8:	df000017 	ldw	fp,0(sp)
8112c6ec:	dec00104 	addi	sp,sp,4
8112c6f0:	f800283a 	ret

8112c6f4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
8112c6f4:	defffc04 	addi	sp,sp,-16
8112c6f8:	de00012e 	bgeu	sp,et,8112c700 <alt_dev_null_write+0xc>
8112c6fc:	003b68fa 	trap	3
8112c700:	df000315 	stw	fp,12(sp)
8112c704:	df000304 	addi	fp,sp,12
8112c708:	e13ffd15 	stw	r4,-12(fp)
8112c70c:	e17ffe15 	stw	r5,-8(fp)
8112c710:	e1bfff15 	stw	r6,-4(fp)
  return len;
8112c714:	e0bfff17 	ldw	r2,-4(fp)
}
8112c718:	e037883a 	mov	sp,fp
8112c71c:	df000017 	ldw	fp,0(sp)
8112c720:	dec00104 	addi	sp,sp,4
8112c724:	f800283a 	ret

8112c728 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112c728:	defffe04 	addi	sp,sp,-8
8112c72c:	de00012e 	bgeu	sp,et,8112c734 <alt_get_errno+0xc>
8112c730:	003b68fa 	trap	3
8112c734:	dfc00115 	stw	ra,4(sp)
8112c738:	df000015 	stw	fp,0(sp)
8112c73c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112c740:	d0a01017 	ldw	r2,-32704(gp)
8112c744:	10000326 	beq	r2,zero,8112c754 <alt_get_errno+0x2c>
8112c748:	d0a01017 	ldw	r2,-32704(gp)
8112c74c:	103ee83a 	callr	r2
8112c750:	00000106 	br	8112c758 <alt_get_errno+0x30>
8112c754:	d0a06904 	addi	r2,gp,-32348
}
8112c758:	e037883a 	mov	sp,fp
8112c75c:	dfc00117 	ldw	ra,4(sp)
8112c760:	df000017 	ldw	fp,0(sp)
8112c764:	dec00204 	addi	sp,sp,8
8112c768:	f800283a 	ret

8112c76c <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
8112c76c:	defffb04 	addi	sp,sp,-20
8112c770:	de00012e 	bgeu	sp,et,8112c778 <fstat+0xc>
8112c774:	003b68fa 	trap	3
8112c778:	dfc00415 	stw	ra,16(sp)
8112c77c:	df000315 	stw	fp,12(sp)
8112c780:	df000304 	addi	fp,sp,12
8112c784:	e13ffe15 	stw	r4,-8(fp)
8112c788:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112c78c:	e0bffe17 	ldw	r2,-8(fp)
8112c790:	10000616 	blt	r2,zero,8112c7ac <fstat+0x40>
8112c794:	e0bffe17 	ldw	r2,-8(fp)
8112c798:	10c00324 	muli	r3,r2,12
8112c79c:	00a04534 	movhi	r2,33044
8112c7a0:	109bea04 	addi	r2,r2,28584
8112c7a4:	1885883a 	add	r2,r3,r2
8112c7a8:	00000106 	br	8112c7b0 <fstat+0x44>
8112c7ac:	0005883a 	mov	r2,zero
8112c7b0:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
8112c7b4:	e0bffd17 	ldw	r2,-12(fp)
8112c7b8:	10001026 	beq	r2,zero,8112c7fc <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
8112c7bc:	e0bffd17 	ldw	r2,-12(fp)
8112c7c0:	10800017 	ldw	r2,0(r2)
8112c7c4:	10800817 	ldw	r2,32(r2)
8112c7c8:	10000726 	beq	r2,zero,8112c7e8 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
8112c7cc:	e0bffd17 	ldw	r2,-12(fp)
8112c7d0:	10800017 	ldw	r2,0(r2)
8112c7d4:	10800817 	ldw	r2,32(r2)
8112c7d8:	e17fff17 	ldw	r5,-4(fp)
8112c7dc:	e13ffd17 	ldw	r4,-12(fp)
8112c7e0:	103ee83a 	callr	r2
8112c7e4:	00000a06 	br	8112c810 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
8112c7e8:	e0bfff17 	ldw	r2,-4(fp)
8112c7ec:	00c80004 	movi	r3,8192
8112c7f0:	10c00115 	stw	r3,4(r2)
      return 0;
8112c7f4:	0005883a 	mov	r2,zero
8112c7f8:	00000506 	br	8112c810 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8112c7fc:	112c7280 	call	8112c728 <alt_get_errno>
8112c800:	1007883a 	mov	r3,r2
8112c804:	00801444 	movi	r2,81
8112c808:	18800015 	stw	r2,0(r3)
    return -1;
8112c80c:	00bfffc4 	movi	r2,-1
  }
}
8112c810:	e037883a 	mov	sp,fp
8112c814:	dfc00117 	ldw	ra,4(sp)
8112c818:	df000017 	ldw	fp,0(sp)
8112c81c:	dec00204 	addi	sp,sp,8
8112c820:	f800283a 	ret

8112c824 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
8112c824:	defff004 	addi	sp,sp,-64
8112c828:	de00012e 	bgeu	sp,et,8112c830 <alt_irq_register+0xc>
8112c82c:	003b68fa 	trap	3
8112c830:	df000f15 	stw	fp,60(sp)
8112c834:	df000f04 	addi	fp,sp,60
8112c838:	e13ffd15 	stw	r4,-12(fp)
8112c83c:	e17ffe15 	stw	r5,-8(fp)
8112c840:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
8112c844:	00bffa84 	movi	r2,-22
8112c848:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8112c84c:	e0bffd17 	ldw	r2,-12(fp)
8112c850:	10800828 	cmpgeui	r2,r2,32
8112c854:	1000501e 	bne	r2,zero,8112c998 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c858:	0005303a 	rdctl	r2,status
8112c85c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c860:	e0fff617 	ldw	r3,-40(fp)
8112c864:	00bfff84 	movi	r2,-2
8112c868:	1884703a 	and	r2,r3,r2
8112c86c:	1001703a 	wrctl	status,r2
  
  return context;
8112c870:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
8112c874:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
8112c878:	00a045b4 	movhi	r2,33046
8112c87c:	1089a404 	addi	r2,r2,9872
8112c880:	e0fffd17 	ldw	r3,-12(fp)
8112c884:	180690fa 	slli	r3,r3,3
8112c888:	10c5883a 	add	r2,r2,r3
8112c88c:	e0ffff17 	ldw	r3,-4(fp)
8112c890:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
8112c894:	00a045b4 	movhi	r2,33046
8112c898:	1089a404 	addi	r2,r2,9872
8112c89c:	e0fffd17 	ldw	r3,-12(fp)
8112c8a0:	180690fa 	slli	r3,r3,3
8112c8a4:	10c5883a 	add	r2,r2,r3
8112c8a8:	10800104 	addi	r2,r2,4
8112c8ac:	e0fffe17 	ldw	r3,-8(fp)
8112c8b0:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
8112c8b4:	e0bfff17 	ldw	r2,-4(fp)
8112c8b8:	10001926 	beq	r2,zero,8112c920 <alt_irq_register+0xfc>
8112c8bc:	e0bffd17 	ldw	r2,-12(fp)
8112c8c0:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c8c4:	0005303a 	rdctl	r2,status
8112c8c8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c8cc:	e0fff717 	ldw	r3,-36(fp)
8112c8d0:	00bfff84 	movi	r2,-2
8112c8d4:	1884703a 	and	r2,r3,r2
8112c8d8:	1001703a 	wrctl	status,r2
  
  return context;
8112c8dc:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8112c8e0:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
8112c8e4:	00c00044 	movi	r3,1
8112c8e8:	e0bff217 	ldw	r2,-56(fp)
8112c8ec:	1884983a 	sll	r2,r3,r2
8112c8f0:	1007883a 	mov	r3,r2
8112c8f4:	d0a07117 	ldw	r2,-32316(gp)
8112c8f8:	1884b03a 	or	r2,r3,r2
8112c8fc:	d0a07115 	stw	r2,-32316(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8112c900:	d0a07117 	ldw	r2,-32316(gp)
8112c904:	100170fa 	wrctl	ienable,r2
8112c908:	e0bff817 	ldw	r2,-32(fp)
8112c90c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112c910:	e0bff917 	ldw	r2,-28(fp)
8112c914:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8112c918:	0005883a 	mov	r2,zero
8112c91c:	00001906 	br	8112c984 <alt_irq_register+0x160>
8112c920:	e0bffd17 	ldw	r2,-12(fp)
8112c924:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112c928:	0005303a 	rdctl	r2,status
8112c92c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112c930:	e0fffa17 	ldw	r3,-24(fp)
8112c934:	00bfff84 	movi	r2,-2
8112c938:	1884703a 	and	r2,r3,r2
8112c93c:	1001703a 	wrctl	status,r2
  
  return context;
8112c940:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8112c944:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
8112c948:	00c00044 	movi	r3,1
8112c94c:	e0bff417 	ldw	r2,-48(fp)
8112c950:	1884983a 	sll	r2,r3,r2
8112c954:	0084303a 	nor	r2,zero,r2
8112c958:	1007883a 	mov	r3,r2
8112c95c:	d0a07117 	ldw	r2,-32316(gp)
8112c960:	1884703a 	and	r2,r3,r2
8112c964:	d0a07115 	stw	r2,-32316(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8112c968:	d0a07117 	ldw	r2,-32316(gp)
8112c96c:	100170fa 	wrctl	ienable,r2
8112c970:	e0bffb17 	ldw	r2,-20(fp)
8112c974:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112c978:	e0bffc17 	ldw	r2,-16(fp)
8112c97c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8112c980:	0005883a 	mov	r2,zero
8112c984:	e0bff115 	stw	r2,-60(fp)
8112c988:	e0bff317 	ldw	r2,-52(fp)
8112c98c:	e0bff515 	stw	r2,-44(fp)
8112c990:	e0bff517 	ldw	r2,-44(fp)
8112c994:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
8112c998:	e0bff117 	ldw	r2,-60(fp)
}
8112c99c:	e037883a 	mov	sp,fp
8112c9a0:	df000017 	ldw	fp,0(sp)
8112c9a4:	dec00104 	addi	sp,sp,4
8112c9a8:	f800283a 	ret

8112c9ac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112c9ac:	defffe04 	addi	sp,sp,-8
8112c9b0:	de00012e 	bgeu	sp,et,8112c9b8 <alt_get_errno+0xc>
8112c9b4:	003b68fa 	trap	3
8112c9b8:	dfc00115 	stw	ra,4(sp)
8112c9bc:	df000015 	stw	fp,0(sp)
8112c9c0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112c9c4:	d0a01017 	ldw	r2,-32704(gp)
8112c9c8:	10000326 	beq	r2,zero,8112c9d8 <alt_get_errno+0x2c>
8112c9cc:	d0a01017 	ldw	r2,-32704(gp)
8112c9d0:	103ee83a 	callr	r2
8112c9d4:	00000106 	br	8112c9dc <alt_get_errno+0x30>
8112c9d8:	d0a06904 	addi	r2,gp,-32348
}
8112c9dc:	e037883a 	mov	sp,fp
8112c9e0:	dfc00117 	ldw	ra,4(sp)
8112c9e4:	df000017 	ldw	fp,0(sp)
8112c9e8:	dec00204 	addi	sp,sp,8
8112c9ec:	f800283a 	ret

8112c9f0 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
8112c9f0:	deffed04 	addi	sp,sp,-76
8112c9f4:	de00012e 	bgeu	sp,et,8112c9fc <isatty+0xc>
8112c9f8:	003b68fa 	trap	3
8112c9fc:	dfc01215 	stw	ra,72(sp)
8112ca00:	df001115 	stw	fp,68(sp)
8112ca04:	df001104 	addi	fp,sp,68
8112ca08:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112ca0c:	e0bfff17 	ldw	r2,-4(fp)
8112ca10:	10000616 	blt	r2,zero,8112ca2c <isatty+0x3c>
8112ca14:	e0bfff17 	ldw	r2,-4(fp)
8112ca18:	10c00324 	muli	r3,r2,12
8112ca1c:	00a04534 	movhi	r2,33044
8112ca20:	109bea04 	addi	r2,r2,28584
8112ca24:	1885883a 	add	r2,r3,r2
8112ca28:	00000106 	br	8112ca30 <isatty+0x40>
8112ca2c:	0005883a 	mov	r2,zero
8112ca30:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
8112ca34:	e0bfef17 	ldw	r2,-68(fp)
8112ca38:	10000e26 	beq	r2,zero,8112ca74 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
8112ca3c:	e0bfef17 	ldw	r2,-68(fp)
8112ca40:	10800017 	ldw	r2,0(r2)
8112ca44:	10800817 	ldw	r2,32(r2)
8112ca48:	1000021e 	bne	r2,zero,8112ca54 <isatty+0x64>
    {
      return 1;
8112ca4c:	00800044 	movi	r2,1
8112ca50:	00000d06 	br	8112ca88 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
8112ca54:	e0bff004 	addi	r2,fp,-64
8112ca58:	100b883a 	mov	r5,r2
8112ca5c:	e13fff17 	ldw	r4,-4(fp)
8112ca60:	112c76c0 	call	8112c76c <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
8112ca64:	e0bff117 	ldw	r2,-60(fp)
8112ca68:	10880020 	cmpeqi	r2,r2,8192
8112ca6c:	10803fcc 	andi	r2,r2,255
8112ca70:	00000506 	br	8112ca88 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8112ca74:	112c9ac0 	call	8112c9ac <alt_get_errno>
8112ca78:	1007883a 	mov	r3,r2
8112ca7c:	00801444 	movi	r2,81
8112ca80:	18800015 	stw	r2,0(r3)
    return 0;
8112ca84:	0005883a 	mov	r2,zero
  }
}
8112ca88:	e037883a 	mov	sp,fp
8112ca8c:	dfc00117 	ldw	ra,4(sp)
8112ca90:	df000017 	ldw	fp,0(sp)
8112ca94:	dec00204 	addi	sp,sp,8
8112ca98:	f800283a 	ret

8112ca9c <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
8112ca9c:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
8112caa0:	318c2404 	addi	r6,r6,12432

8112caa4 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
8112caa4:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
8112caa8:	01c00826 	beq	zero,r7,8112cacc <end_tx>

8112caac <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
8112caac:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
8112cab0:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
8112cab4:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
8112cab8:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
8112cabc:	283ffb26 	beq	r5,zero,8112caac <__reset+0xfb10caac>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
8112cac0:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
8112cac4:	21000044 	addi	r4,r4,1
	br tx_next_char
8112cac8:	003ff606 	br	8112caa4 <__reset+0xfb10caa4>

8112cacc <end_tx>:
end_tx:	
        ret
8112cacc:	f800283a 	ret

8112cad0 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
8112cad0:	defffd04 	addi	sp,sp,-12
8112cad4:	de00012e 	bgeu	sp,et,8112cadc <alt_log_txchar+0xc>
8112cad8:	003b68fa 	trap	3
8112cadc:	df000215 	stw	fp,8(sp)
8112cae0:	df000204 	addi	fp,sp,8
8112cae4:	e13ffe15 	stw	r4,-8(fp)
8112cae8:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
8112caec:	0001883a 	nop
8112caf0:	e0bfff17 	ldw	r2,-4(fp)
8112caf4:	10800104 	addi	r2,r2,4
8112caf8:	10800037 	ldwio	r2,0(r2)
8112cafc:	10bfffec 	andhi	r2,r2,65535
8112cb00:	103ffb26 	beq	r2,zero,8112caf0 <__reset+0xfb10caf0>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
8112cb04:	e0bfff17 	ldw	r2,-4(fp)
8112cb08:	e0fffe17 	ldw	r3,-8(fp)
8112cb0c:	10c00035 	stwio	r3,0(r2)
}
8112cb10:	0001883a 	nop
8112cb14:	e037883a 	mov	sp,fp
8112cb18:	df000017 	ldw	fp,0(sp)
8112cb1c:	dec00104 	addi	sp,sp,4
8112cb20:	f800283a 	ret

8112cb24 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
8112cb24:	defffb04 	addi	sp,sp,-20
8112cb28:	de00012e 	bgeu	sp,et,8112cb30 <alt_log_repchar+0xc>
8112cb2c:	003b68fa 	trap	3
8112cb30:	dfc00415 	stw	ra,16(sp)
8112cb34:	df000315 	stw	fp,12(sp)
8112cb38:	df000304 	addi	fp,sp,12
8112cb3c:	2005883a 	mov	r2,r4
8112cb40:	e17ffe15 	stw	r5,-8(fp)
8112cb44:	e1bfff15 	stw	r6,-4(fp)
8112cb48:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
8112cb4c:	00000506 	br	8112cb64 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
8112cb50:	e0bffd07 	ldb	r2,-12(fp)
8112cb54:	e0ffff17 	ldw	r3,-4(fp)
8112cb58:	180b883a 	mov	r5,r3
8112cb5c:	1009883a 	mov	r4,r2
8112cb60:	112cad00 	call	8112cad0 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
8112cb64:	e0bffe17 	ldw	r2,-8(fp)
8112cb68:	10ffffc4 	addi	r3,r2,-1
8112cb6c:	e0fffe15 	stw	r3,-8(fp)
8112cb70:	00bff716 	blt	zero,r2,8112cb50 <__reset+0xfb10cb50>
    alt_log_txchar(c,(char*) base);
}
8112cb74:	0001883a 	nop
8112cb78:	e037883a 	mov	sp,fp
8112cb7c:	dfc00117 	ldw	ra,4(sp)
8112cb80:	df000017 	ldw	fp,0(sp)
8112cb84:	dec00204 	addi	sp,sp,8
8112cb88:	f800283a 	ret

8112cb8c <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
8112cb8c:	deffe904 	addi	sp,sp,-92
8112cb90:	de00012e 	bgeu	sp,et,8112cb98 <alt_log_private_printf+0xc>
8112cb94:	003b68fa 	trap	3
8112cb98:	dfc01615 	stw	ra,88(sp)
8112cb9c:	df001515 	stw	fp,84(sp)
8112cba0:	dc001415 	stw	r16,80(sp)
8112cba4:	df001504 	addi	fp,sp,84
8112cba8:	e13ffc15 	stw	r4,-16(fp)
8112cbac:	e17ffd15 	stw	r5,-12(fp)
8112cbb0:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
8112cbb4:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
8112cbb8:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
8112cbbc:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
8112cbc0:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
8112cbc4:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
8112cbc8:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
8112cbcc:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
8112cbd0:	e0bffc17 	ldw	r2,-16(fp)
8112cbd4:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
8112cbd8:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
8112cbdc:	00014b06 	br	8112d10c <alt_log_private_printf+0x580>
    {
    switch(state)
8112cbe0:	e0bfec17 	ldw	r2,-80(fp)
8112cbe4:	10c00060 	cmpeqi	r3,r2,1
8112cbe8:	18001b1e 	bne	r3,zero,8112cc58 <alt_log_private_printf+0xcc>
8112cbec:	10c000a0 	cmpeqi	r3,r2,2
8112cbf0:	18002d1e 	bne	r3,zero,8112cca8 <alt_log_private_printf+0x11c>
8112cbf4:	10000126 	beq	r2,zero,8112cbfc <alt_log_private_printf+0x70>
8112cbf8:	00014406 	br	8112d10c <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
8112cbfc:	e0bffb07 	ldb	r2,-20(fp)
8112cc00:	10800958 	cmpnei	r2,r2,37
8112cc04:	10000e1e 	bne	r2,zero,8112cc40 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
8112cc08:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
8112cc0c:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
8112cc10:	00800284 	movi	r2,10
8112cc14:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
8112cc18:	00800044 	movi	r2,1
8112cc1c:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
8112cc20:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
8112cc24:	00bfffc4 	movi	r2,-1
8112cc28:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
8112cc2c:	00bfffc4 	movi	r2,-1
8112cc30:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
8112cc34:	00800044 	movi	r2,1
8112cc38:	e0bfec15 	stw	r2,-80(fp)
8112cc3c:	00013306 	br	8112d10c <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
8112cc40:	e0bffb07 	ldb	r2,-20(fp)
8112cc44:	e0fffd17 	ldw	r3,-12(fp)
8112cc48:	180b883a 	mov	r5,r3
8112cc4c:	1009883a 	mov	r4,r2
8112cc50:	112cad00 	call	8112cad0 <alt_log_txchar>
        }
        break;
8112cc54:	00012d06 	br	8112d10c <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
8112cc58:	e0bffb07 	ldb	r2,-20(fp)
8112cc5c:	10800c18 	cmpnei	r2,r2,48
8112cc60:	1000051e 	bne	r2,zero,8112cc78 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
8112cc64:	00800044 	movi	r2,1
8112cc68:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
8112cc6c:	00800084 	movi	r2,2
8112cc70:	e0bfec15 	stw	r2,-80(fp)
8112cc74:	00012506 	br	8112d10c <alt_log_private_printf+0x580>
        }
        else if(c == '%')
8112cc78:	e0bffb07 	ldb	r2,-20(fp)
8112cc7c:	10800958 	cmpnei	r2,r2,37
8112cc80:	1000071e 	bne	r2,zero,8112cca0 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
8112cc84:	e0bffb07 	ldb	r2,-20(fp)
8112cc88:	e0fffd17 	ldw	r3,-12(fp)
8112cc8c:	180b883a 	mov	r5,r3
8112cc90:	1009883a 	mov	r4,r2
8112cc94:	112cad00 	call	8112cad0 <alt_log_txchar>
          state = pfState_chars;
8112cc98:	e03fec15 	stw	zero,-80(fp)
8112cc9c:	00011b06 	br	8112d10c <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
8112cca0:	00800084 	movi	r2,2
8112cca4:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
8112cca8:	e0bffb07 	ldb	r2,-20(fp)
8112ccac:	10800b98 	cmpnei	r2,r2,46
8112ccb0:	1000021e 	bne	r2,zero,8112ccbc <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
8112ccb4:	e03ff015 	stw	zero,-64(fp)
8112ccb8:	00011306 	br	8112d108 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
8112ccbc:	e0bffb07 	ldb	r2,-20(fp)
8112ccc0:	10800c10 	cmplti	r2,r2,48
8112ccc4:	10001a1e 	bne	r2,zero,8112cd30 <alt_log_private_printf+0x1a4>
8112ccc8:	e0bffb07 	ldb	r2,-20(fp)
8112cccc:	10800e88 	cmpgei	r2,r2,58
8112ccd0:	1000171e 	bne	r2,zero,8112cd30 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
8112ccd4:	e0bffb03 	ldbu	r2,-20(fp)
8112ccd8:	10bff404 	addi	r2,r2,-48
8112ccdc:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
8112cce0:	e0bff017 	ldw	r2,-64(fp)
8112cce4:	10000c0e 	bge	r2,zero,8112cd18 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
8112cce8:	e0bfef17 	ldw	r2,-68(fp)
8112ccec:	1000020e 	bge	r2,zero,8112ccf8 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
8112ccf0:	e03fef15 	stw	zero,-68(fp)
8112ccf4:	00000306 	br	8112cd04 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
8112ccf8:	e0bfef17 	ldw	r2,-68(fp)
8112ccfc:	108002a4 	muli	r2,r2,10
8112cd00:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
8112cd04:	e0bffb07 	ldb	r2,-20(fp)
8112cd08:	e0ffef17 	ldw	r3,-68(fp)
8112cd0c:	1885883a 	add	r2,r3,r2
8112cd10:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
8112cd14:	0000fc06 	br	8112d108 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
8112cd18:	e0bff017 	ldw	r2,-64(fp)
8112cd1c:	10c002a4 	muli	r3,r2,10
8112cd20:	e0bffb07 	ldb	r2,-20(fp)
8112cd24:	1885883a 	add	r2,r3,r2
8112cd28:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
8112cd2c:	0000f606 	br	8112d108 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
8112cd30:	e0bffb07 	ldb	r2,-20(fp)
8112cd34:	10801b18 	cmpnei	r2,r2,108
8112cd38:	1000031e 	bne	r2,zero,8112cd48 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
8112cd3c:	00800044 	movi	r2,1
8112cd40:	e0bfee15 	stw	r2,-72(fp)
8112cd44:	0000f006 	br	8112d108 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
8112cd48:	e0bffb07 	ldb	r2,-20(fp)
8112cd4c:	10bfea04 	addi	r2,r2,-88
8112cd50:	10c00868 	cmpgeui	r3,r2,33
8112cd54:	1800eb1e 	bne	r3,zero,8112d104 <alt_log_private_printf+0x578>
8112cd58:	100690ba 	slli	r3,r2,2
8112cd5c:	00a044f4 	movhi	r2,33043
8112cd60:	10b35c04 	addi	r2,r2,-12944
8112cd64:	1885883a 	add	r2,r3,r2
8112cd68:	10800017 	ldw	r2,0(r2)
8112cd6c:	1000683a 	jmp	r2
8112cd70:	8112d030 	cmpltui	r4,r16,19264
8112cd74:	8112d104 	addi	r4,r16,19268
8112cd78:	8112d104 	addi	r4,r16,19268
8112cd7c:	8112d104 	addi	r4,r16,19268
8112cd80:	8112d104 	addi	r4,r16,19268
8112cd84:	8112d104 	addi	r4,r16,19268
8112cd88:	8112d104 	addi	r4,r16,19268
8112cd8c:	8112d104 	addi	r4,r16,19268
8112cd90:	8112d104 	addi	r4,r16,19268
8112cd94:	8112d104 	addi	r4,r16,19268
8112cd98:	8112d104 	addi	r4,r16,19268
8112cd9c:	8112d048 	cmpgei	r4,r16,19265
8112cda0:	8112cdf4 	orhi	r4,r16,19255
8112cda4:	8112d104 	addi	r4,r16,19268
8112cda8:	8112d104 	addi	r4,r16,19268
8112cdac:	8112d104 	addi	r4,r16,19268
8112cdb0:	8112d104 	addi	r4,r16,19268
8112cdb4:	8112cdf4 	orhi	r4,r16,19255
8112cdb8:	8112d104 	addi	r4,r16,19268
8112cdbc:	8112d104 	addi	r4,r16,19268
8112cdc0:	8112d104 	addi	r4,r16,19268
8112cdc4:	8112d104 	addi	r4,r16,19268
8112cdc8:	8112d104 	addi	r4,r16,19268
8112cdcc:	8112d010 	cmplti	r4,r16,19264
8112cdd0:	8112d104 	addi	r4,r16,19268
8112cdd4:	8112d104 	addi	r4,r16,19268
8112cdd8:	8112d104 	addi	r4,r16,19268
8112cddc:	8112d084 	addi	r4,r16,19266
8112cde0:	8112d104 	addi	r4,r16,19268
8112cde4:	8112d008 	cmpgei	r4,r16,19264
8112cde8:	8112d104 	addi	r4,r16,19268
8112cdec:	8112d104 	addi	r4,r16,19268
8112cdf0:	8112d020 	cmpeqi	r4,r16,19264
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
8112cdf4:	e0bfee17 	ldw	r2,-72(fp)
8112cdf8:	10000e26 	beq	r2,zero,8112ce34 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
8112cdfc:	e0bff217 	ldw	r2,-56(fp)
8112ce00:	10000626 	beq	r2,zero,8112ce1c <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
8112ce04:	e0bffe17 	ldw	r2,-8(fp)
8112ce08:	10c00104 	addi	r3,r2,4
8112ce0c:	e0fffe15 	stw	r3,-8(fp)
8112ce10:	10800017 	ldw	r2,0(r2)
8112ce14:	e0bff415 	stw	r2,-48(fp)
8112ce18:	00001306 	br	8112ce68 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
8112ce1c:	e0bffe17 	ldw	r2,-8(fp)
8112ce20:	10c00104 	addi	r3,r2,4
8112ce24:	e0fffe15 	stw	r3,-8(fp)
8112ce28:	10800017 	ldw	r2,0(r2)
8112ce2c:	e0bff415 	stw	r2,-48(fp)
8112ce30:	00000d06 	br	8112ce68 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
8112ce34:	e0bff217 	ldw	r2,-56(fp)
8112ce38:	10000626 	beq	r2,zero,8112ce54 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
8112ce3c:	e0bffe17 	ldw	r2,-8(fp)
8112ce40:	10c00104 	addi	r3,r2,4
8112ce44:	e0fffe15 	stw	r3,-8(fp)
8112ce48:	10800017 	ldw	r2,0(r2)
8112ce4c:	e0bff415 	stw	r2,-48(fp)
8112ce50:	00000506 	br	8112ce68 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
8112ce54:	e0bffe17 	ldw	r2,-8(fp)
8112ce58:	10c00104 	addi	r3,r2,4
8112ce5c:	e0fffe15 	stw	r3,-8(fp)
8112ce60:	10800017 	ldw	r2,0(r2)
8112ce64:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
8112ce68:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
8112ce6c:	e0bff217 	ldw	r2,-56(fp)
8112ce70:	10000726 	beq	r2,zero,8112ce90 <alt_log_private_printf+0x304>
8112ce74:	e0bff417 	ldw	r2,-48(fp)
8112ce78:	1000050e 	bge	r2,zero,8112ce90 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
8112ce7c:	e0bff417 	ldw	r2,-48(fp)
8112ce80:	0085c83a 	sub	r2,zero,r2
8112ce84:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
8112ce88:	00800044 	movi	r2,1
8112ce8c:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
8112ce90:	e0bff417 	ldw	r2,-48(fp)
8112ce94:	e0bff615 	stw	r2,-40(fp)
                p = 1;
8112ce98:	00800044 	movi	r2,1
8112ce9c:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
8112cea0:	00800044 	movi	r2,1
8112cea4:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
8112cea8:	00000706 	br	8112cec8 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
8112ceac:	e0bff817 	ldw	r2,-32(fp)
8112ceb0:	10800044 	addi	r2,r2,1
8112ceb4:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
8112ceb8:	e0bff117 	ldw	r2,-60(fp)
8112cebc:	e0fff517 	ldw	r3,-44(fp)
8112cec0:	1885383a 	mul	r2,r3,r2
8112cec4:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
8112cec8:	e0bff117 	ldw	r2,-60(fp)
8112cecc:	e0fff617 	ldw	r3,-40(fp)
8112ced0:	1885203a 	divu	r2,r3,r2
8112ced4:	e0bff615 	stw	r2,-40(fp)
8112ced8:	e0bff617 	ldw	r2,-40(fp)
8112cedc:	103ff31e 	bne	r2,zero,8112ceac <__reset+0xfb10ceac>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
8112cee0:	e0ffef17 	ldw	r3,-68(fp)
8112cee4:	e0bff817 	ldw	r2,-32(fp)
8112cee8:	1885c83a 	sub	r2,r3,r2
8112ceec:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
8112cef0:	e0bfed17 	ldw	r2,-76(fp)
8112cef4:	10000e26 	beq	r2,zero,8112cf30 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
8112cef8:	e0bff717 	ldw	r2,-36(fp)
8112cefc:	10000726 	beq	r2,zero,8112cf1c <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
8112cf00:	e0bffd17 	ldw	r2,-12(fp)
8112cf04:	100b883a 	mov	r5,r2
8112cf08:	01000b44 	movi	r4,45
8112cf0c:	112cad00 	call	8112cad0 <alt_log_txchar>
                    fmtBeforeDecimal--;
8112cf10:	e0bfef17 	ldw	r2,-68(fp)
8112cf14:	10bfffc4 	addi	r2,r2,-1
8112cf18:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
8112cf1c:	e1bffd17 	ldw	r6,-12(fp)
8112cf20:	e17fef17 	ldw	r5,-68(fp)
8112cf24:	01000c04 	movi	r4,48
8112cf28:	112cb240 	call	8112cb24 <alt_log_repchar>
8112cf2c:	00003206 	br	8112cff8 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
8112cf30:	e0bff717 	ldw	r2,-36(fp)
8112cf34:	10000326 	beq	r2,zero,8112cf44 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
8112cf38:	e0bfef17 	ldw	r2,-68(fp)
8112cf3c:	10bfffc4 	addi	r2,r2,-1
8112cf40:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
8112cf44:	e1bffd17 	ldw	r6,-12(fp)
8112cf48:	e17fef17 	ldw	r5,-68(fp)
8112cf4c:	01000804 	movi	r4,32
8112cf50:	112cb240 	call	8112cb24 <alt_log_repchar>
                    if(sign)
8112cf54:	e0bff717 	ldw	r2,-36(fp)
8112cf58:	10002726 	beq	r2,zero,8112cff8 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
8112cf5c:	e0bffd17 	ldw	r2,-12(fp)
8112cf60:	100b883a 	mov	r5,r2
8112cf64:	01000b44 	movi	r4,45
8112cf68:	112cad00 	call	8112cad0 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
8112cf6c:	00002206 	br	8112cff8 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
8112cf70:	e0fff417 	ldw	r3,-48(fp)
8112cf74:	e0bff517 	ldw	r2,-44(fp)
8112cf78:	1885203a 	divu	r2,r3,r2
8112cf7c:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
8112cf80:	e0bff903 	ldbu	r2,-28(fp)
8112cf84:	10800c04 	addi	r2,r2,48
8112cf88:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
8112cf8c:	e0bff903 	ldbu	r2,-28(fp)
8112cf90:	10800eb0 	cmpltui	r2,r2,58
8112cf94:	1000081e 	bne	r2,zero,8112cfb8 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
8112cf98:	e0bff317 	ldw	r2,-52(fp)
8112cf9c:	10000226 	beq	r2,zero,8112cfa8 <alt_log_private_printf+0x41c>
8112cfa0:	008001c4 	movi	r2,7
8112cfa4:	00000106 	br	8112cfac <alt_log_private_printf+0x420>
8112cfa8:	008009c4 	movi	r2,39
8112cfac:	e0fff903 	ldbu	r3,-28(fp)
8112cfb0:	10c5883a 	add	r2,r2,r3
8112cfb4:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
8112cfb8:	e0bff903 	ldbu	r2,-28(fp)
8112cfbc:	e0fffd17 	ldw	r3,-12(fp)
8112cfc0:	180b883a 	mov	r5,r3
8112cfc4:	1009883a 	mov	r4,r2
8112cfc8:	112cad00 	call	8112cad0 <alt_log_txchar>

                  v = v % p;
8112cfcc:	e0bff417 	ldw	r2,-48(fp)
8112cfd0:	e0fff517 	ldw	r3,-44(fp)
8112cfd4:	10c9203a 	divu	r4,r2,r3
8112cfd8:	e0fff517 	ldw	r3,-44(fp)
8112cfdc:	20c7383a 	mul	r3,r4,r3
8112cfe0:	10c5c83a 	sub	r2,r2,r3
8112cfe4:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
8112cfe8:	e0bff117 	ldw	r2,-60(fp)
8112cfec:	e0fff517 	ldw	r3,-44(fp)
8112cff0:	1885203a 	divu	r2,r3,r2
8112cff4:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
8112cff8:	e0bff517 	ldw	r2,-44(fp)
8112cffc:	103fdc1e 	bne	r2,zero,8112cf70 <__reset+0xfb10cf70>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
8112d000:	e03fec15 	stw	zero,-80(fp)
              break;
8112d004:	00003f06 	br	8112d104 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
8112d008:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
8112d00c:	003f7906 	br	8112cdf4 <__reset+0xfb10cdf4>
            case 'o':
              fmtSigned = 0;
8112d010:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
8112d014:	00800204 	movi	r2,8
8112d018:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8112d01c:	003f7506 	br	8112cdf4 <__reset+0xfb10cdf4>
            case 'x':
              fmtSigned = 0;
8112d020:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
8112d024:	00800404 	movi	r2,16
8112d028:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8112d02c:	003f7106 	br	8112cdf4 <__reset+0xfb10cdf4>
            case 'X':
              fmtSigned = 0;
8112d030:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
8112d034:	00800404 	movi	r2,16
8112d038:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
8112d03c:	00800044 	movi	r2,1
8112d040:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
8112d044:	003f6b06 	br	8112cdf4 <__reset+0xfb10cdf4>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
8112d048:	e0bfef17 	ldw	r2,-68(fp)
8112d04c:	10bfffc4 	addi	r2,r2,-1
8112d050:	e1bffd17 	ldw	r6,-12(fp)
8112d054:	100b883a 	mov	r5,r2
8112d058:	01000804 	movi	r4,32
8112d05c:	112cb240 	call	8112cb24 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
8112d060:	e0bffe17 	ldw	r2,-8(fp)
8112d064:	10c00104 	addi	r3,r2,4
8112d068:	e0fffe15 	stw	r3,-8(fp)
8112d06c:	10800017 	ldw	r2,0(r2)
8112d070:	e0fffd17 	ldw	r3,-12(fp)
8112d074:	180b883a 	mov	r5,r3
8112d078:	1009883a 	mov	r4,r2
8112d07c:	112cad00 	call	8112cad0 <alt_log_txchar>
              break;
8112d080:	00002006 	br	8112d104 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
8112d084:	e0bffe17 	ldw	r2,-8(fp)
8112d088:	10c00104 	addi	r3,r2,4
8112d08c:	e0fffe15 	stw	r3,-8(fp)
8112d090:	10800017 	ldw	r2,0(r2)
8112d094:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
8112d098:	e43fef17 	ldw	r16,-68(fp)
8112d09c:	e13ffa17 	ldw	r4,-24(fp)
8112d0a0:	11187c00 	call	811187c0 <strlen>
8112d0a4:	8085c83a 	sub	r2,r16,r2
8112d0a8:	e1bffd17 	ldw	r6,-12(fp)
8112d0ac:	100b883a 	mov	r5,r2
8112d0b0:	01000804 	movi	r4,32
8112d0b4:	112cb240 	call	8112cb24 <alt_log_repchar>

                while(*s)
8112d0b8:	00000b06 	br	8112d0e8 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
8112d0bc:	e0bffa17 	ldw	r2,-24(fp)
8112d0c0:	10c00044 	addi	r3,r2,1
8112d0c4:	e0fffa15 	stw	r3,-24(fp)
8112d0c8:	10800003 	ldbu	r2,0(r2)
8112d0cc:	10803fcc 	andi	r2,r2,255
8112d0d0:	1080201c 	xori	r2,r2,128
8112d0d4:	10bfe004 	addi	r2,r2,-128
8112d0d8:	e0fffd17 	ldw	r3,-12(fp)
8112d0dc:	180b883a 	mov	r5,r3
8112d0e0:	1009883a 	mov	r4,r2
8112d0e4:	112cad00 	call	8112cad0 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
8112d0e8:	e0bffa17 	ldw	r2,-24(fp)
8112d0ec:	10800003 	ldbu	r2,0(r2)
8112d0f0:	10803fcc 	andi	r2,r2,255
8112d0f4:	1080201c 	xori	r2,r2,128
8112d0f8:	10bfe004 	addi	r2,r2,-128
8112d0fc:	103fef1e 	bne	r2,zero,8112d0bc <__reset+0xfb10d0bc>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
8112d100:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
8112d104:	e03fec15 	stw	zero,-80(fp)
          }
        break;
8112d108:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
8112d10c:	e0bfeb17 	ldw	r2,-84(fp)
8112d110:	10c00044 	addi	r3,r2,1
8112d114:	e0ffeb15 	stw	r3,-84(fp)
8112d118:	10800003 	ldbu	r2,0(r2)
8112d11c:	e0bffb05 	stb	r2,-20(fp)
8112d120:	e0bffb07 	ldb	r2,-20(fp)
8112d124:	103eae1e 	bne	r2,zero,8112cbe0 <__reset+0xfb10cbe0>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
8112d128:	0001883a 	nop
8112d12c:	e6ffff04 	addi	sp,fp,-4
8112d130:	dfc00217 	ldw	ra,8(sp)
8112d134:	df000117 	ldw	fp,4(sp)
8112d138:	dc000017 	ldw	r16,0(sp)
8112d13c:	dec00304 	addi	sp,sp,12
8112d140:	f800283a 	ret

8112d144 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
8112d144:	defff904 	addi	sp,sp,-28
8112d148:	de00012e 	bgeu	sp,et,8112d150 <alt_log_printf_proc+0xc>
8112d14c:	003b68fa 	trap	3
8112d150:	dfc00315 	stw	ra,12(sp)
8112d154:	df000215 	stw	fp,8(sp)
8112d158:	df000204 	addi	fp,sp,8
8112d15c:	e13fff15 	stw	r4,-4(fp)
8112d160:	e1400215 	stw	r5,8(fp)
8112d164:	e1800315 	stw	r6,12(fp)
8112d168:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
8112d16c:	e0800204 	addi	r2,fp,8
8112d170:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
8112d174:	e0bffe17 	ldw	r2,-8(fp)
8112d178:	100d883a 	mov	r6,r2
8112d17c:	01604834 	movhi	r5,33056
8112d180:	294c2404 	addi	r5,r5,12432
8112d184:	e13fff17 	ldw	r4,-4(fp)
8112d188:	112cb8c0 	call	8112cb8c <alt_log_private_printf>
    return (0);
8112d18c:	0005883a 	mov	r2,zero
}
8112d190:	e037883a 	mov	sp,fp
8112d194:	dfc00117 	ldw	ra,4(sp)
8112d198:	df000017 	ldw	fp,0(sp)
8112d19c:	dec00504 	addi	sp,sp,20
8112d1a0:	f800283a 	ret

8112d1a4 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
8112d1a4:	defff904 	addi	sp,sp,-28
8112d1a8:	de00012e 	bgeu	sp,et,8112d1b0 <altera_avalon_jtag_uart_report_log+0xc>
8112d1ac:	003b68fa 	trap	3
8112d1b0:	dfc00615 	stw	ra,24(sp)
8112d1b4:	df000515 	stw	fp,20(sp)
8112d1b8:	dc400415 	stw	r17,16(sp)
8112d1bc:	dc000315 	stw	r16,12(sp)
8112d1c0:	df000504 	addi	fp,sp,20
8112d1c4:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
8112d1c8:	d0a07283 	ldbu	r2,-32310(gp)
8112d1cc:	10803fcc 	andi	r2,r2,255
8112d1d0:	10001426 	beq	r2,zero,8112d224 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
8112d1d4:	e0bffd17 	ldw	r2,-12(fp)
8112d1d8:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
8112d1dc:	00a04534 	movhi	r2,33044
8112d1e0:	10981004 	addi	r2,r2,24640
8112d1e4:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
8112d1e8:	e0bffb17 	ldw	r2,-20(fp)
8112d1ec:	10800017 	ldw	r2,0(r2)
8112d1f0:	e1bffc17 	ldw	r6,-16(fp)
8112d1f4:	100b883a 	mov	r5,r2
8112d1f8:	e13ffb17 	ldw	r4,-20(fp)
8112d1fc:	112d2440 	call	8112d244 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8112d200:	d0e07917 	ldw	r3,-32284(gp)
        return ALT_LOG_JTAG_UART_TICKS;
8112d204:	00b33374 	movhi	r2,52429
8112d208:	10b33344 	addi	r2,r2,-13107
8112d20c:	1888383a 	mulxuu	r4,r3,r2
8112d210:	1885383a 	mul	r2,r3,r2
8112d214:	1021883a 	mov	r16,r2
8112d218:	2023883a 	mov	r17,r4
8112d21c:	8804d0fa 	srli	r2,r17,3
8112d220:	00000106 	br	8112d228 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
8112d224:	0005883a 	mov	r2,zero
    }
}
8112d228:	e6fffe04 	addi	sp,fp,-8
8112d22c:	dfc00317 	ldw	ra,12(sp)
8112d230:	df000217 	ldw	fp,8(sp)
8112d234:	dc400117 	ldw	r17,4(sp)
8112d238:	dc000017 	ldw	r16,0(sp)
8112d23c:	dec00404 	addi	sp,sp,16
8112d240:	f800283a 	ret

8112d244 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
8112d244:	deffef04 	addi	sp,sp,-68
8112d248:	de00012e 	bgeu	sp,et,8112d250 <alt_log_jtag_uart_print_control_reg+0xc>
8112d24c:	003b68fa 	trap	3
8112d250:	dfc01015 	stw	ra,64(sp)
8112d254:	df000f15 	stw	fp,60(sp)
8112d258:	df000f04 	addi	fp,sp,60
8112d25c:	e13ffd15 	stw	r4,-12(fp)
8112d260:	e17ffe15 	stw	r5,-8(fp)
8112d264:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8112d268:	e0bffe17 	ldw	r2,-8(fp)
8112d26c:	10800104 	addi	r2,r2,4
8112d270:	10800037 	ldwio	r2,0(r2)
8112d274:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
8112d278:	e0bff617 	ldw	r2,-40(fp)
8112d27c:	1004d43a 	srli	r2,r2,16
8112d280:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
8112d284:	e0bff617 	ldw	r2,-40(fp)
8112d288:	1080008c 	andi	r2,r2,2
8112d28c:	1004d07a 	srli	r2,r2,1
8112d290:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
8112d294:	e0bff617 	ldw	r2,-40(fp)
8112d298:	1080004c 	andi	r2,r2,1
8112d29c:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
8112d2a0:	e0bff617 	ldw	r2,-40(fp)
8112d2a4:	1080400c 	andi	r2,r2,256
8112d2a8:	1004d23a 	srli	r2,r2,8
8112d2ac:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
8112d2b0:	e0bff617 	ldw	r2,-40(fp)
8112d2b4:	1080800c 	andi	r2,r2,512
8112d2b8:	1004d27a 	srli	r2,r2,9
8112d2bc:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
8112d2c0:	e0bff617 	ldw	r2,-40(fp)
8112d2c4:	1081000c 	andi	r2,r2,1024
8112d2c8:	1004d2ba 	srli	r2,r2,10
8112d2cc:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
8112d2d0:	e0bffd17 	ldw	r2,-12(fp)
8112d2d4:	10c01017 	ldw	r3,64(r2)
8112d2d8:	e0bffd17 	ldw	r2,-12(fp)
8112d2dc:	10800f17 	ldw	r2,60(r2)
8112d2e0:	1887c83a 	sub	r3,r3,r2
8112d2e4:	e0bff917 	ldw	r2,-28(fp)
8112d2e8:	d8800415 	stw	r2,16(sp)
8112d2ec:	e0bff817 	ldw	r2,-32(fp)
8112d2f0:	d8800315 	stw	r2,12(sp)
8112d2f4:	e0bffa17 	ldw	r2,-24(fp)
8112d2f8:	d8800215 	stw	r2,8(sp)
8112d2fc:	e0bffb17 	ldw	r2,-20(fp)
8112d300:	d8800115 	stw	r2,4(sp)
8112d304:	e0bffc17 	ldw	r2,-16(fp)
8112d308:	d8800015 	stw	r2,0(sp)
8112d30c:	e1fff717 	ldw	r7,-36(fp)
8112d310:	180d883a 	mov	r6,r3
8112d314:	e17fff17 	ldw	r5,-4(fp)
8112d318:	01204534 	movhi	r4,33044
8112d31c:	21181304 	addi	r4,r4,24652
8112d320:	112d1440 	call	8112d144 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
8112d324:	0001883a 	nop

}
8112d328:	e037883a 	mov	sp,fp
8112d32c:	dfc00117 	ldw	ra,4(sp)
8112d330:	df000017 	ldw	fp,0(sp)
8112d334:	dec00204 	addi	sp,sp,8
8112d338:	f800283a 	ret

8112d33c <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
8112d33c:	defffb04 	addi	sp,sp,-20
8112d340:	de00012e 	bgeu	sp,et,8112d348 <alt_log_jtag_uart_startup_info+0xc>
8112d344:	003b68fa 	trap	3
8112d348:	dfc00415 	stw	ra,16(sp)
8112d34c:	df000315 	stw	fp,12(sp)
8112d350:	df000304 	addi	fp,sp,12
8112d354:	e13ffe15 	stw	r4,-8(fp)
8112d358:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
8112d35c:	00a04534 	movhi	r2,33044
8112d360:	10982504 	addi	r2,r2,24724
8112d364:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
8112d368:	e1bffd17 	ldw	r6,-12(fp)
8112d36c:	e17fff17 	ldw	r5,-4(fp)
8112d370:	e13ffe17 	ldw	r4,-8(fp)
8112d374:	112d2440 	call	8112d244 <alt_log_jtag_uart_print_control_reg>
     return;
8112d378:	0001883a 	nop
}
8112d37c:	e037883a 	mov	sp,fp
8112d380:	dfc00117 	ldw	ra,4(sp)
8112d384:	df000017 	ldw	fp,0(sp)
8112d388:	dec00204 	addi	sp,sp,8
8112d38c:	f800283a 	ret

8112d390 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
8112d390:	defffb04 	addi	sp,sp,-20
8112d394:	de00012e 	bgeu	sp,et,8112d39c <alt_log_jtag_uart_isr_proc+0xc>
8112d398:	003b68fa 	trap	3
8112d39c:	dfc00415 	stw	ra,16(sp)
8112d3a0:	df000315 	stw	fp,12(sp)
8112d3a4:	df000304 	addi	fp,sp,12
8112d3a8:	e13ffe15 	stw	r4,-8(fp)
8112d3ac:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
8112d3b0:	d0a072c3 	ldbu	r2,-32309(gp)
8112d3b4:	10803fcc 	andi	r2,r2,255
8112d3b8:	10000826 	beq	r2,zero,8112d3dc <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
8112d3bc:	00a04534 	movhi	r2,33044
8112d3c0:	10982a04 	addi	r2,r2,24744
8112d3c4:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
8112d3c8:	e1bffd17 	ldw	r6,-12(fp)
8112d3cc:	e17ffe17 	ldw	r5,-8(fp)
8112d3d0:	e13fff17 	ldw	r4,-4(fp)
8112d3d4:	112d2440 	call	8112d244 <alt_log_jtag_uart_print_control_reg>
    }
    return;
8112d3d8:	0001883a 	nop
8112d3dc:	0001883a 	nop
}
8112d3e0:	e037883a 	mov	sp,fp
8112d3e4:	dfc00117 	ldw	ra,4(sp)
8112d3e8:	df000017 	ldw	fp,0(sp)
8112d3ec:	dec00204 	addi	sp,sp,8
8112d3f0:	f800283a 	ret

8112d3f4 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
8112d3f4:	defffa04 	addi	sp,sp,-24
8112d3f8:	de00012e 	bgeu	sp,et,8112d400 <alt_log_write+0xc>
8112d3fc:	003b68fa 	trap	3
8112d400:	dfc00515 	stw	ra,20(sp)
8112d404:	df000415 	stw	fp,16(sp)
8112d408:	df000404 	addi	fp,sp,16
8112d40c:	e13ffe15 	stw	r4,-8(fp)
8112d410:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
8112d414:	d0a07203 	ldbu	r2,-32312(gp)
8112d418:	10803fcc 	andi	r2,r2,255
8112d41c:	10004026 	beq	r2,zero,8112d520 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
8112d420:	e0bfff17 	ldw	r2,-4(fp)
8112d424:	10c00430 	cmpltui	r3,r2,16
8112d428:	1800011e 	bne	r3,zero,8112d430 <alt_log_write+0x3c>
8112d42c:	008003c4 	movi	r2,15
8112d430:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
8112d434:	e0bffd17 	ldw	r2,-12(fp)
8112d438:	10800088 	cmpgei	r2,r2,2
8112d43c:	10003726 	beq	r2,zero,8112d51c <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
8112d440:	e0bffd17 	ldw	r2,-12(fp)
8112d444:	100d883a 	mov	r6,r2
8112d448:	e17ffe17 	ldw	r5,-8(fp)
8112d44c:	012045b4 	movhi	r4,33046
8112d450:	21320804 	addi	r4,r4,-14304
8112d454:	114120c0 	call	8114120c <strncpy>
    alt_log_write_buf[length-1]='\n';
8112d458:	e0bffd17 	ldw	r2,-12(fp)
8112d45c:	10ffffc4 	addi	r3,r2,-1
8112d460:	00a045b4 	movhi	r2,33046
8112d464:	10b20804 	addi	r2,r2,-14304
8112d468:	10c5883a 	add	r2,r2,r3
8112d46c:	00c00284 	movi	r3,10
8112d470:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
8112d474:	00a045b4 	movhi	r2,33046
8112d478:	10b20804 	addi	r2,r2,-14304
8112d47c:	e0fffd17 	ldw	r3,-12(fp)
8112d480:	10c5883a 	add	r2,r2,r3
8112d484:	00c00344 	movi	r3,13
8112d488:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
8112d48c:	e0bffd17 	ldw	r2,-12(fp)
8112d490:	10c00044 	addi	r3,r2,1
8112d494:	00a045b4 	movhi	r2,33046
8112d498:	10b20804 	addi	r2,r2,-14304
8112d49c:	10c5883a 	add	r2,r2,r3
8112d4a0:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8112d4a4:	e03ffc15 	stw	zero,-16(fp)
8112d4a8:	00001306 	br	8112d4f8 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
8112d4ac:	00a045b4 	movhi	r2,33046
8112d4b0:	10b20804 	addi	r2,r2,-14304
8112d4b4:	e0fffc17 	ldw	r3,-16(fp)
8112d4b8:	10c5883a 	add	r2,r2,r3
8112d4bc:	10800003 	ldbu	r2,0(r2)
8112d4c0:	10803fcc 	andi	r2,r2,255
8112d4c4:	1080201c 	xori	r2,r2,128
8112d4c8:	10bfe004 	addi	r2,r2,-128
8112d4cc:	10800118 	cmpnei	r2,r2,4
8112d4d0:	1000061e 	bne	r2,zero,8112d4ec <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
8112d4d4:	00a045b4 	movhi	r2,33046
8112d4d8:	10b20804 	addi	r2,r2,-14304
8112d4dc:	e0fffc17 	ldw	r3,-16(fp)
8112d4e0:	10c5883a 	add	r2,r2,r3
8112d4e4:	00c01104 	movi	r3,68
8112d4e8:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8112d4ec:	e0bffc17 	ldw	r2,-16(fp)
8112d4f0:	10800044 	addi	r2,r2,1
8112d4f4:	e0bffc15 	stw	r2,-16(fp)
8112d4f8:	e0fffc17 	ldw	r3,-16(fp)
8112d4fc:	e0bffd17 	ldw	r2,-12(fp)
8112d500:	18bfea16 	blt	r3,r2,8112d4ac <__reset+0xfb10d4ac>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
8112d504:	016045b4 	movhi	r5,33046
8112d508:	29720804 	addi	r5,r5,-14304
8112d50c:	01204534 	movhi	r4,33044
8112d510:	21182d04 	addi	r4,r4,24756
8112d514:	112d1440 	call	8112d144 <alt_log_printf_proc>
8112d518:	00000106 	br	8112d520 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
8112d51c:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
8112d520:	e037883a 	mov	sp,fp
8112d524:	dfc00117 	ldw	ra,4(sp)
8112d528:	df000017 	ldw	fp,0(sp)
8112d52c:	dec00204 	addi	sp,sp,8
8112d530:	f800283a 	ret

8112d534 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
8112d534:	defffe04 	addi	sp,sp,-8
8112d538:	de00012e 	bgeu	sp,et,8112d540 <alt_log_system_clock+0xc>
8112d53c:	003b68fa 	trap	3
8112d540:	dfc00115 	stw	ra,4(sp)
8112d544:	df000015 	stw	fp,0(sp)
8112d548:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
8112d54c:	d0a07243 	ldbu	r2,-32311(gp)
8112d550:	10803fcc 	andi	r2,r2,255
8112d554:	10000e26 	beq	r2,zero,8112d590 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
8112d558:	d0a07517 	ldw	r2,-32300(gp)
8112d55c:	10800044 	addi	r2,r2,1
8112d560:	d0a07515 	stw	r2,-32300(gp)
8112d564:	d0a07917 	ldw	r2,-32284(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
8112d568:	d0e07517 	ldw	r3,-32300(gp)
8112d56c:	10c0082e 	bgeu	r2,r3,8112d590 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
8112d570:	d0207515 	stw	zero,-32300(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
8112d574:	d0a07417 	ldw	r2,-32304(gp)
8112d578:	10c00044 	addi	r3,r2,1
8112d57c:	d0e07415 	stw	r3,-32304(gp)
8112d580:	100b883a 	mov	r5,r2
8112d584:	01204534 	movhi	r4,33044
8112d588:	21183104 	addi	r4,r4,24772
8112d58c:	112d1440 	call	8112d144 <alt_log_printf_proc>
        }
    }
}
8112d590:	0001883a 	nop
8112d594:	e037883a 	mov	sp,fp
8112d598:	dfc00117 	ldw	ra,4(sp)
8112d59c:	df000017 	ldw	fp,0(sp)
8112d5a0:	dec00204 	addi	sp,sp,8
8112d5a4:	f800283a 	ret

8112d5a8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112d5a8:	defffe04 	addi	sp,sp,-8
8112d5ac:	de00012e 	bgeu	sp,et,8112d5b4 <alt_get_errno+0xc>
8112d5b0:	003b68fa 	trap	3
8112d5b4:	dfc00115 	stw	ra,4(sp)
8112d5b8:	df000015 	stw	fp,0(sp)
8112d5bc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112d5c0:	d0a01017 	ldw	r2,-32704(gp)
8112d5c4:	10000326 	beq	r2,zero,8112d5d4 <alt_get_errno+0x2c>
8112d5c8:	d0a01017 	ldw	r2,-32704(gp)
8112d5cc:	103ee83a 	callr	r2
8112d5d0:	00000106 	br	8112d5d8 <alt_get_errno+0x30>
8112d5d4:	d0a06904 	addi	r2,gp,-32348
}
8112d5d8:	e037883a 	mov	sp,fp
8112d5dc:	dfc00117 	ldw	ra,4(sp)
8112d5e0:	df000017 	ldw	fp,0(sp)
8112d5e4:	dec00204 	addi	sp,sp,8
8112d5e8:	f800283a 	ret

8112d5ec <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
8112d5ec:	defff904 	addi	sp,sp,-28
8112d5f0:	de00012e 	bgeu	sp,et,8112d5f8 <lseek+0xc>
8112d5f4:	003b68fa 	trap	3
8112d5f8:	dfc00615 	stw	ra,24(sp)
8112d5fc:	df000515 	stw	fp,20(sp)
8112d600:	df000504 	addi	fp,sp,20
8112d604:	e13ffd15 	stw	r4,-12(fp)
8112d608:	e17ffe15 	stw	r5,-8(fp)
8112d60c:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
8112d610:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112d614:	e0bffd17 	ldw	r2,-12(fp)
8112d618:	10000616 	blt	r2,zero,8112d634 <lseek+0x48>
8112d61c:	e0bffd17 	ldw	r2,-12(fp)
8112d620:	10c00324 	muli	r3,r2,12
8112d624:	00a04534 	movhi	r2,33044
8112d628:	109bea04 	addi	r2,r2,28584
8112d62c:	1885883a 	add	r2,r3,r2
8112d630:	00000106 	br	8112d638 <lseek+0x4c>
8112d634:	0005883a 	mov	r2,zero
8112d638:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
8112d63c:	e0bffc17 	ldw	r2,-16(fp)
8112d640:	10001026 	beq	r2,zero,8112d684 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
8112d644:	e0bffc17 	ldw	r2,-16(fp)
8112d648:	10800017 	ldw	r2,0(r2)
8112d64c:	10800717 	ldw	r2,28(r2)
8112d650:	10000926 	beq	r2,zero,8112d678 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
8112d654:	e0bffc17 	ldw	r2,-16(fp)
8112d658:	10800017 	ldw	r2,0(r2)
8112d65c:	10800717 	ldw	r2,28(r2)
8112d660:	e1bfff17 	ldw	r6,-4(fp)
8112d664:	e17ffe17 	ldw	r5,-8(fp)
8112d668:	e13ffc17 	ldw	r4,-16(fp)
8112d66c:	103ee83a 	callr	r2
8112d670:	e0bffb15 	stw	r2,-20(fp)
8112d674:	00000506 	br	8112d68c <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
8112d678:	00bfde84 	movi	r2,-134
8112d67c:	e0bffb15 	stw	r2,-20(fp)
8112d680:	00000206 	br	8112d68c <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
8112d684:	00bfebc4 	movi	r2,-81
8112d688:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
8112d68c:	e0bffb17 	ldw	r2,-20(fp)
8112d690:	1000070e 	bge	r2,zero,8112d6b0 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
8112d694:	112d5a80 	call	8112d5a8 <alt_get_errno>
8112d698:	1007883a 	mov	r3,r2
8112d69c:	e0bffb17 	ldw	r2,-20(fp)
8112d6a0:	0085c83a 	sub	r2,zero,r2
8112d6a4:	18800015 	stw	r2,0(r3)
    rc = -1;
8112d6a8:	00bfffc4 	movi	r2,-1
8112d6ac:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
8112d6b0:	e0bffb17 	ldw	r2,-20(fp)
}
8112d6b4:	e037883a 	mov	sp,fp
8112d6b8:	dfc00117 	ldw	ra,4(sp)
8112d6bc:	df000017 	ldw	fp,0(sp)
8112d6c0:	dec00204 	addi	sp,sp,8
8112d6c4:	f800283a 	ret

8112d6c8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
8112d6c8:	defff904 	addi	sp,sp,-28
8112d6cc:	de00012e 	bgeu	sp,et,8112d6d4 <alt_main+0xc>
8112d6d0:	003b68fa 	trap	3
8112d6d4:	dfc00615 	stw	ra,24(sp)
8112d6d8:	df000515 	stw	fp,20(sp)
8112d6dc:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
8112d6e0:	d0a01217 	ldw	r2,-32696(gp)
8112d6e4:	10800058 	cmpnei	r2,r2,1
8112d6e8:	1000031e 	bne	r2,zero,8112d6f8 <alt_main+0x30>
8112d6ec:	01204534 	movhi	r4,33044
8112d6f0:	21183704 	addi	r4,r4,24796
8112d6f4:	112d1440 	call	8112d144 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
8112d6f8:	0009883a 	mov	r4,zero
8112d6fc:	113806c0 	call	8113806c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
8112d700:	d0a01217 	ldw	r2,-32696(gp)
8112d704:	10800058 	cmpnei	r2,r2,1
8112d708:	1000031e 	bne	r2,zero,8112d718 <alt_main+0x50>
8112d70c:	01204534 	movhi	r4,33044
8112d710:	21184504 	addi	r4,r4,24852
8112d714:	112d1440 	call	8112d144 <alt_log_printf_proc>
  ALT_OS_INIT();
8112d718:	112ecb40 	call	8112ecb4 <OSInit>
8112d71c:	01000044 	movi	r4,1
8112d720:	11349d00 	call	811349d0 <OSSemCreate>
8112d724:	d0a07c15 	stw	r2,-32272(gp)
8112d728:	01000044 	movi	r4,1
8112d72c:	11349d00 	call	811349d0 <OSSemCreate>
8112d730:	d0a07e15 	stw	r2,-32264(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
8112d734:	d0a01217 	ldw	r2,-32696(gp)
8112d738:	10800058 	cmpnei	r2,r2,1
8112d73c:	1000031e 	bne	r2,zero,8112d74c <alt_main+0x84>
8112d740:	01204534 	movhi	r4,33044
8112d744:	21185304 	addi	r4,r4,24908
8112d748:	112d1440 	call	8112d144 <alt_log_printf_proc>
8112d74c:	d0a07004 	addi	r2,gp,-32320
8112d750:	e0bffc15 	stw	r2,-16(fp)
8112d754:	00800044 	movi	r2,1
8112d758:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8112d75c:	e0bffd0b 	ldhu	r2,-12(fp)
8112d760:	1009883a 	mov	r4,r2
8112d764:	11349d00 	call	811349d0 <OSSemCreate>
8112d768:	1007883a 	mov	r3,r2
8112d76c:	e0bffc17 	ldw	r2,-16(fp)
8112d770:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
8112d774:	d0a01217 	ldw	r2,-32696(gp)
8112d778:	10800058 	cmpnei	r2,r2,1
8112d77c:	1000031e 	bne	r2,zero,8112d78c <alt_main+0xc4>
8112d780:	01204534 	movhi	r4,33044
8112d784:	21186104 	addi	r4,r4,24964
8112d788:	112d1440 	call	8112d144 <alt_log_printf_proc>
  alt_sys_init();
8112d78c:	11380ac0 	call	811380ac <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
8112d790:	d0a01217 	ldw	r2,-32696(gp)
8112d794:	10800058 	cmpnei	r2,r2,1
8112d798:	1000031e 	bne	r2,zero,8112d7a8 <alt_main+0xe0>
8112d79c:	01204534 	movhi	r4,33044
8112d7a0:	21186b04 	addi	r4,r4,25004
8112d7a4:	112d1440 	call	8112d144 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
8112d7a8:	d0a01217 	ldw	r2,-32696(gp)
8112d7ac:	10800058 	cmpnei	r2,r2,1
8112d7b0:	1000031e 	bne	r2,zero,8112d7c0 <alt_main+0xf8>
8112d7b4:	01204534 	movhi	r4,33044
8112d7b8:	21187404 	addi	r4,r4,25040
8112d7bc:	112d1440 	call	8112d144 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
8112d7c0:	01a04534 	movhi	r6,33044
8112d7c4:	31987c04 	addi	r6,r6,25072
8112d7c8:	01604534 	movhi	r5,33044
8112d7cc:	29588104 	addi	r5,r5,25092
8112d7d0:	01204534 	movhi	r4,33044
8112d7d4:	21188104 	addi	r4,r4,25092
8112d7d8:	114099c0 	call	8114099c <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
8112d7dc:	d0a01217 	ldw	r2,-32696(gp)
8112d7e0:	10800058 	cmpnei	r2,r2,1
8112d7e4:	1000031e 	bne	r2,zero,8112d7f4 <alt_main+0x12c>
8112d7e8:	01204534 	movhi	r4,33044
8112d7ec:	21188504 	addi	r4,r4,25108
8112d7f0:	112d1440 	call	8112d144 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
8112d7f4:	d0a07617 	ldw	r2,-32296(gp)
8112d7f8:	d0e07717 	ldw	r3,-32292(gp)
8112d7fc:	d1207817 	ldw	r4,-32288(gp)
8112d800:	200d883a 	mov	r6,r4
8112d804:	180b883a 	mov	r5,r3
8112d808:	1009883a 	mov	r4,r2
8112d80c:	110f9800 	call	8110f980 <main>
8112d810:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
8112d814:	01000044 	movi	r4,1
8112d818:	112c5f40 	call	8112c5f4 <close>
  exit (result);
8112d81c:	e13ffb17 	ldw	r4,-20(fp)
8112d820:	11411500 	call	81141150 <exit>

8112d824 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112d824:	defffe04 	addi	sp,sp,-8
8112d828:	de00012e 	bgeu	sp,et,8112d830 <alt_get_errno+0xc>
8112d82c:	003b68fa 	trap	3
8112d830:	dfc00115 	stw	ra,4(sp)
8112d834:	df000015 	stw	fp,0(sp)
8112d838:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112d83c:	d0a01017 	ldw	r2,-32704(gp)
8112d840:	10000326 	beq	r2,zero,8112d850 <alt_get_errno+0x2c>
8112d844:	d0a01017 	ldw	r2,-32704(gp)
8112d848:	103ee83a 	callr	r2
8112d84c:	00000106 	br	8112d854 <alt_get_errno+0x30>
8112d850:	d0a06904 	addi	r2,gp,-32348
}
8112d854:	e037883a 	mov	sp,fp
8112d858:	dfc00117 	ldw	ra,4(sp)
8112d85c:	df000017 	ldw	fp,0(sp)
8112d860:	dec00204 	addi	sp,sp,8
8112d864:	f800283a 	ret

8112d868 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
8112d868:	defffd04 	addi	sp,sp,-12
8112d86c:	de00012e 	bgeu	sp,et,8112d874 <alt_file_locked+0xc>
8112d870:	003b68fa 	trap	3
8112d874:	df000215 	stw	fp,8(sp)
8112d878:	df000204 	addi	fp,sp,8
8112d87c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
8112d880:	e0bfff17 	ldw	r2,-4(fp)
8112d884:	10800217 	ldw	r2,8(r2)
8112d888:	10d00034 	orhi	r3,r2,16384
8112d88c:	e0bfff17 	ldw	r2,-4(fp)
8112d890:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
8112d894:	e03ffe15 	stw	zero,-8(fp)
8112d898:	00001d06 	br	8112d910 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
8112d89c:	00a04534 	movhi	r2,33044
8112d8a0:	109bea04 	addi	r2,r2,28584
8112d8a4:	e0fffe17 	ldw	r3,-8(fp)
8112d8a8:	18c00324 	muli	r3,r3,12
8112d8ac:	10c5883a 	add	r2,r2,r3
8112d8b0:	10c00017 	ldw	r3,0(r2)
8112d8b4:	e0bfff17 	ldw	r2,-4(fp)
8112d8b8:	10800017 	ldw	r2,0(r2)
8112d8bc:	1880111e 	bne	r3,r2,8112d904 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
8112d8c0:	00a04534 	movhi	r2,33044
8112d8c4:	109bea04 	addi	r2,r2,28584
8112d8c8:	e0fffe17 	ldw	r3,-8(fp)
8112d8cc:	18c00324 	muli	r3,r3,12
8112d8d0:	10c5883a 	add	r2,r2,r3
8112d8d4:	10800204 	addi	r2,r2,8
8112d8d8:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
8112d8dc:	1000090e 	bge	r2,zero,8112d904 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
8112d8e0:	e0bffe17 	ldw	r2,-8(fp)
8112d8e4:	10c00324 	muli	r3,r2,12
8112d8e8:	00a04534 	movhi	r2,33044
8112d8ec:	109bea04 	addi	r2,r2,28584
8112d8f0:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
8112d8f4:	e0bfff17 	ldw	r2,-4(fp)
8112d8f8:	18800226 	beq	r3,r2,8112d904 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
8112d8fc:	00bffcc4 	movi	r2,-13
8112d900:	00000806 	br	8112d924 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
8112d904:	e0bffe17 	ldw	r2,-8(fp)
8112d908:	10800044 	addi	r2,r2,1
8112d90c:	e0bffe15 	stw	r2,-8(fp)
8112d910:	d0a00f17 	ldw	r2,-32708(gp)
8112d914:	1007883a 	mov	r3,r2
8112d918:	e0bffe17 	ldw	r2,-8(fp)
8112d91c:	18bfdf2e 	bgeu	r3,r2,8112d89c <__reset+0xfb10d89c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
8112d920:	0005883a 	mov	r2,zero
}
8112d924:	e037883a 	mov	sp,fp
8112d928:	df000017 	ldw	fp,0(sp)
8112d92c:	dec00104 	addi	sp,sp,4
8112d930:	f800283a 	ret

8112d934 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
8112d934:	defff604 	addi	sp,sp,-40
8112d938:	de00012e 	bgeu	sp,et,8112d940 <open+0xc>
8112d93c:	003b68fa 	trap	3
8112d940:	dfc00915 	stw	ra,36(sp)
8112d944:	df000815 	stw	fp,32(sp)
8112d948:	df000804 	addi	fp,sp,32
8112d94c:	e13ffd15 	stw	r4,-12(fp)
8112d950:	e17ffe15 	stw	r5,-8(fp)
8112d954:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
8112d958:	00bfffc4 	movi	r2,-1
8112d95c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
8112d960:	00bffb44 	movi	r2,-19
8112d964:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
8112d968:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
8112d96c:	d1600d04 	addi	r5,gp,-32716
8112d970:	e13ffd17 	ldw	r4,-12(fp)
8112d974:	114037c0 	call	8114037c <alt_find_dev>
8112d978:	e0bff815 	stw	r2,-32(fp)
8112d97c:	e0bff817 	ldw	r2,-32(fp)
8112d980:	1000051e 	bne	r2,zero,8112d998 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
8112d984:	e13ffd17 	ldw	r4,-12(fp)
8112d988:	11404140 	call	81140414 <alt_find_file>
8112d98c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
8112d990:	00800044 	movi	r2,1
8112d994:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
8112d998:	e0bff817 	ldw	r2,-32(fp)
8112d99c:	10002926 	beq	r2,zero,8112da44 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
8112d9a0:	e13ff817 	ldw	r4,-32(fp)
8112d9a4:	11405240 	call	81140524 <alt_get_fd>
8112d9a8:	e0bff915 	stw	r2,-28(fp)
8112d9ac:	e0bff917 	ldw	r2,-28(fp)
8112d9b0:	1000030e 	bge	r2,zero,8112d9c0 <open+0x8c>
    {
      status = index;
8112d9b4:	e0bff917 	ldw	r2,-28(fp)
8112d9b8:	e0bffa15 	stw	r2,-24(fp)
8112d9bc:	00002306 	br	8112da4c <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
8112d9c0:	e0bff917 	ldw	r2,-28(fp)
8112d9c4:	10c00324 	muli	r3,r2,12
8112d9c8:	00a04534 	movhi	r2,33044
8112d9cc:	109bea04 	addi	r2,r2,28584
8112d9d0:	1885883a 	add	r2,r3,r2
8112d9d4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
8112d9d8:	e0fffe17 	ldw	r3,-8(fp)
8112d9dc:	00900034 	movhi	r2,16384
8112d9e0:	10bfffc4 	addi	r2,r2,-1
8112d9e4:	1886703a 	and	r3,r3,r2
8112d9e8:	e0bffc17 	ldw	r2,-16(fp)
8112d9ec:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
8112d9f0:	e0bffb17 	ldw	r2,-20(fp)
8112d9f4:	1000051e 	bne	r2,zero,8112da0c <open+0xd8>
8112d9f8:	e13ffc17 	ldw	r4,-16(fp)
8112d9fc:	112d8680 	call	8112d868 <alt_file_locked>
8112da00:	e0bffa15 	stw	r2,-24(fp)
8112da04:	e0bffa17 	ldw	r2,-24(fp)
8112da08:	10001016 	blt	r2,zero,8112da4c <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
8112da0c:	e0bff817 	ldw	r2,-32(fp)
8112da10:	10800317 	ldw	r2,12(r2)
8112da14:	10000826 	beq	r2,zero,8112da38 <open+0x104>
8112da18:	e0bff817 	ldw	r2,-32(fp)
8112da1c:	10800317 	ldw	r2,12(r2)
8112da20:	e1ffff17 	ldw	r7,-4(fp)
8112da24:	e1bffe17 	ldw	r6,-8(fp)
8112da28:	e17ffd17 	ldw	r5,-12(fp)
8112da2c:	e13ffc17 	ldw	r4,-16(fp)
8112da30:	103ee83a 	callr	r2
8112da34:	00000106 	br	8112da3c <open+0x108>
8112da38:	0005883a 	mov	r2,zero
8112da3c:	e0bffa15 	stw	r2,-24(fp)
8112da40:	00000206 	br	8112da4c <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
8112da44:	00bffb44 	movi	r2,-19
8112da48:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
8112da4c:	e0bffa17 	ldw	r2,-24(fp)
8112da50:	1000090e 	bge	r2,zero,8112da78 <open+0x144>
  {
    alt_release_fd (index);  
8112da54:	e13ff917 	ldw	r4,-28(fp)
8112da58:	112dbd80 	call	8112dbd8 <alt_release_fd>
    ALT_ERRNO = -status;
8112da5c:	112d8240 	call	8112d824 <alt_get_errno>
8112da60:	1007883a 	mov	r3,r2
8112da64:	e0bffa17 	ldw	r2,-24(fp)
8112da68:	0085c83a 	sub	r2,zero,r2
8112da6c:	18800015 	stw	r2,0(r3)
    return -1;
8112da70:	00bfffc4 	movi	r2,-1
8112da74:	00000106 	br	8112da7c <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
8112da78:	e0bff917 	ldw	r2,-28(fp)
}
8112da7c:	e037883a 	mov	sp,fp
8112da80:	dfc00117 	ldw	ra,4(sp)
8112da84:	df000017 	ldw	fp,0(sp)
8112da88:	dec00204 	addi	sp,sp,8
8112da8c:	f800283a 	ret

8112da90 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112da90:	defffe04 	addi	sp,sp,-8
8112da94:	de00012e 	bgeu	sp,et,8112da9c <alt_get_errno+0xc>
8112da98:	003b68fa 	trap	3
8112da9c:	dfc00115 	stw	ra,4(sp)
8112daa0:	df000015 	stw	fp,0(sp)
8112daa4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112daa8:	d0a01017 	ldw	r2,-32704(gp)
8112daac:	10000326 	beq	r2,zero,8112dabc <alt_get_errno+0x2c>
8112dab0:	d0a01017 	ldw	r2,-32704(gp)
8112dab4:	103ee83a 	callr	r2
8112dab8:	00000106 	br	8112dac0 <alt_get_errno+0x30>
8112dabc:	d0a06904 	addi	r2,gp,-32348
}
8112dac0:	e037883a 	mov	sp,fp
8112dac4:	dfc00117 	ldw	ra,4(sp)
8112dac8:	df000017 	ldw	fp,0(sp)
8112dacc:	dec00204 	addi	sp,sp,8
8112dad0:	f800283a 	ret

8112dad4 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
8112dad4:	defff904 	addi	sp,sp,-28
8112dad8:	de00012e 	bgeu	sp,et,8112dae0 <read+0xc>
8112dadc:	003b68fa 	trap	3
8112dae0:	dfc00615 	stw	ra,24(sp)
8112dae4:	df000515 	stw	fp,20(sp)
8112dae8:	df000504 	addi	fp,sp,20
8112daec:	e13ffd15 	stw	r4,-12(fp)
8112daf0:	e17ffe15 	stw	r5,-8(fp)
8112daf4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112daf8:	e0bffd17 	ldw	r2,-12(fp)
8112dafc:	10000616 	blt	r2,zero,8112db18 <read+0x44>
8112db00:	e0bffd17 	ldw	r2,-12(fp)
8112db04:	10c00324 	muli	r3,r2,12
8112db08:	00a04534 	movhi	r2,33044
8112db0c:	109bea04 	addi	r2,r2,28584
8112db10:	1885883a 	add	r2,r3,r2
8112db14:	00000106 	br	8112db1c <read+0x48>
8112db18:	0005883a 	mov	r2,zero
8112db1c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
8112db20:	e0bffb17 	ldw	r2,-20(fp)
8112db24:	10002226 	beq	r2,zero,8112dbb0 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8112db28:	e0bffb17 	ldw	r2,-20(fp)
8112db2c:	10800217 	ldw	r2,8(r2)
8112db30:	108000cc 	andi	r2,r2,3
8112db34:	10800060 	cmpeqi	r2,r2,1
8112db38:	1000181e 	bne	r2,zero,8112db9c <read+0xc8>
        (fd->dev->read))
8112db3c:	e0bffb17 	ldw	r2,-20(fp)
8112db40:	10800017 	ldw	r2,0(r2)
8112db44:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8112db48:	10001426 	beq	r2,zero,8112db9c <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
8112db4c:	e0bffb17 	ldw	r2,-20(fp)
8112db50:	10800017 	ldw	r2,0(r2)
8112db54:	10800517 	ldw	r2,20(r2)
8112db58:	e0ffff17 	ldw	r3,-4(fp)
8112db5c:	180d883a 	mov	r6,r3
8112db60:	e17ffe17 	ldw	r5,-8(fp)
8112db64:	e13ffb17 	ldw	r4,-20(fp)
8112db68:	103ee83a 	callr	r2
8112db6c:	e0bffc15 	stw	r2,-16(fp)
8112db70:	e0bffc17 	ldw	r2,-16(fp)
8112db74:	1000070e 	bge	r2,zero,8112db94 <read+0xc0>
        {
          ALT_ERRNO = -rval;
8112db78:	112da900 	call	8112da90 <alt_get_errno>
8112db7c:	1007883a 	mov	r3,r2
8112db80:	e0bffc17 	ldw	r2,-16(fp)
8112db84:	0085c83a 	sub	r2,zero,r2
8112db88:	18800015 	stw	r2,0(r3)
          return -1;
8112db8c:	00bfffc4 	movi	r2,-1
8112db90:	00000c06 	br	8112dbc4 <read+0xf0>
        }
        return rval;
8112db94:	e0bffc17 	ldw	r2,-16(fp)
8112db98:	00000a06 	br	8112dbc4 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
8112db9c:	112da900 	call	8112da90 <alt_get_errno>
8112dba0:	1007883a 	mov	r3,r2
8112dba4:	00800344 	movi	r2,13
8112dba8:	18800015 	stw	r2,0(r3)
8112dbac:	00000406 	br	8112dbc0 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
8112dbb0:	112da900 	call	8112da90 <alt_get_errno>
8112dbb4:	1007883a 	mov	r3,r2
8112dbb8:	00801444 	movi	r2,81
8112dbbc:	18800015 	stw	r2,0(r3)
  }
  return -1;
8112dbc0:	00bfffc4 	movi	r2,-1
}
8112dbc4:	e037883a 	mov	sp,fp
8112dbc8:	dfc00117 	ldw	ra,4(sp)
8112dbcc:	df000017 	ldw	fp,0(sp)
8112dbd0:	dec00204 	addi	sp,sp,8
8112dbd4:	f800283a 	ret

8112dbd8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
8112dbd8:	defffe04 	addi	sp,sp,-8
8112dbdc:	de00012e 	bgeu	sp,et,8112dbe4 <alt_release_fd+0xc>
8112dbe0:	003b68fa 	trap	3
8112dbe4:	df000115 	stw	fp,4(sp)
8112dbe8:	df000104 	addi	fp,sp,4
8112dbec:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
8112dbf0:	e0bfff17 	ldw	r2,-4(fp)
8112dbf4:	108000d0 	cmplti	r2,r2,3
8112dbf8:	10000d1e 	bne	r2,zero,8112dc30 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
8112dbfc:	00a04534 	movhi	r2,33044
8112dc00:	109bea04 	addi	r2,r2,28584
8112dc04:	e0ffff17 	ldw	r3,-4(fp)
8112dc08:	18c00324 	muli	r3,r3,12
8112dc0c:	10c5883a 	add	r2,r2,r3
8112dc10:	10800204 	addi	r2,r2,8
8112dc14:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
8112dc18:	00a04534 	movhi	r2,33044
8112dc1c:	109bea04 	addi	r2,r2,28584
8112dc20:	e0ffff17 	ldw	r3,-4(fp)
8112dc24:	18c00324 	muli	r3,r3,12
8112dc28:	10c5883a 	add	r2,r2,r3
8112dc2c:	10000015 	stw	zero,0(r2)
  }
}
8112dc30:	0001883a 	nop
8112dc34:	e037883a 	mov	sp,fp
8112dc38:	df000017 	ldw	fp,0(sp)
8112dc3c:	dec00104 	addi	sp,sp,4
8112dc40:	f800283a 	ret

8112dc44 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
8112dc44:	defff604 	addi	sp,sp,-40
8112dc48:	de00012e 	bgeu	sp,et,8112dc50 <sbrk+0xc>
8112dc4c:	003b68fa 	trap	3
8112dc50:	df000915 	stw	fp,36(sp)
8112dc54:	df000904 	addi	fp,sp,36
8112dc58:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112dc5c:	0005303a 	rdctl	r2,status
8112dc60:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112dc64:	e0fffe17 	ldw	r3,-8(fp)
8112dc68:	00bfff84 	movi	r2,-2
8112dc6c:	1884703a 	and	r2,r3,r2
8112dc70:	1001703a 	wrctl	status,r2
  
  return context;
8112dc74:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
8112dc78:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
8112dc7c:	d0a01317 	ldw	r2,-32692(gp)
8112dc80:	10c000c4 	addi	r3,r2,3
8112dc84:	00bfff04 	movi	r2,-4
8112dc88:	1884703a 	and	r2,r3,r2
8112dc8c:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
8112dc90:	d0e01317 	ldw	r3,-32692(gp)
8112dc94:	e0bfff17 	ldw	r2,-4(fp)
8112dc98:	1887883a 	add	r3,r3,r2
8112dc9c:	00a04834 	movhi	r2,33056
8112dca0:	10a80004 	addi	r2,r2,-24576
8112dca4:	10c0062e 	bgeu	r2,r3,8112dcc0 <sbrk+0x7c>
8112dca8:	e0bff817 	ldw	r2,-32(fp)
8112dcac:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112dcb0:	e0bff717 	ldw	r2,-36(fp)
8112dcb4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
8112dcb8:	00bfffc4 	movi	r2,-1
8112dcbc:	00001c06 	br	8112dd30 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
8112dcc0:	d0a01317 	ldw	r2,-32692(gp)
8112dcc4:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
8112dcc8:	d0e01317 	ldw	r3,-32692(gp)
8112dccc:	e0bfff17 	ldw	r2,-4(fp)
8112dcd0:	1885883a 	add	r2,r3,r2
8112dcd4:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
8112dcd8:	c005883a 	mov	r2,et
8112dcdc:	e0bff915 	stw	r2,-28(fp)

  return limit; 
8112dce0:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
8112dce4:	e0bffa17 	ldw	r2,-24(fp)
8112dce8:	18800c1e 	bne	r3,r2,8112dd1c <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
8112dcec:	d805883a 	mov	r2,sp
8112dcf0:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
8112dcf4:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
8112dcf8:	d0e01317 	ldw	r3,-32692(gp)
8112dcfc:	18800136 	bltu	r3,r2,8112dd04 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
8112dd00:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
8112dd04:	d0a01317 	ldw	r2,-32692(gp)
8112dd08:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
8112dd0c:	e0bffc17 	ldw	r2,-16(fp)
8112dd10:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
8112dd14:	e0bffc17 	ldw	r2,-16(fp)
8112dd18:	1031883a 	mov	et,r2
8112dd1c:	e0bff817 	ldw	r2,-32(fp)
8112dd20:	e0bffd15 	stw	r2,-12(fp)
8112dd24:	e0bffd17 	ldw	r2,-12(fp)
8112dd28:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
8112dd2c:	e0bffa17 	ldw	r2,-24(fp)
} 
8112dd30:	e037883a 	mov	sp,fp
8112dd34:	df000017 	ldw	fp,0(sp)
8112dd38:	dec00104 	addi	sp,sp,4
8112dd3c:	f800283a 	ret

8112dd40 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
8112dd40:	defffa04 	addi	sp,sp,-24
8112dd44:	de00012e 	bgeu	sp,et,8112dd4c <alt_alarm_stop+0xc>
8112dd48:	003b68fa 	trap	3
8112dd4c:	df000515 	stw	fp,20(sp)
8112dd50:	df000504 	addi	fp,sp,20
8112dd54:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112dd58:	0005303a 	rdctl	r2,status
8112dd5c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112dd60:	e0fffc17 	ldw	r3,-16(fp)
8112dd64:	00bfff84 	movi	r2,-2
8112dd68:	1884703a 	and	r2,r3,r2
8112dd6c:	1001703a 	wrctl	status,r2
  
  return context;
8112dd70:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
8112dd74:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
8112dd78:	e0bfff17 	ldw	r2,-4(fp)
8112dd7c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
8112dd80:	e0bffd17 	ldw	r2,-12(fp)
8112dd84:	10800017 	ldw	r2,0(r2)
8112dd88:	e0fffd17 	ldw	r3,-12(fp)
8112dd8c:	18c00117 	ldw	r3,4(r3)
8112dd90:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
8112dd94:	e0bffd17 	ldw	r2,-12(fp)
8112dd98:	10800117 	ldw	r2,4(r2)
8112dd9c:	e0fffd17 	ldw	r3,-12(fp)
8112dda0:	18c00017 	ldw	r3,0(r3)
8112dda4:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
8112dda8:	e0bffd17 	ldw	r2,-12(fp)
8112ddac:	e0fffd17 	ldw	r3,-12(fp)
8112ddb0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
8112ddb4:	e0bffd17 	ldw	r2,-12(fp)
8112ddb8:	e0fffd17 	ldw	r3,-12(fp)
8112ddbc:	10c00015 	stw	r3,0(r2)
8112ddc0:	e0bffb17 	ldw	r2,-20(fp)
8112ddc4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ddc8:	e0bffe17 	ldw	r2,-8(fp)
8112ddcc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
8112ddd0:	0001883a 	nop
8112ddd4:	e037883a 	mov	sp,fp
8112ddd8:	df000017 	ldw	fp,0(sp)
8112dddc:	dec00104 	addi	sp,sp,4
8112dde0:	f800283a 	ret

8112dde4 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
8112dde4:	defffb04 	addi	sp,sp,-20
8112dde8:	de00012e 	bgeu	sp,et,8112ddf0 <alt_tick+0xc>
8112ddec:	003b68fa 	trap	3
8112ddf0:	dfc00415 	stw	ra,16(sp)
8112ddf4:	df000315 	stw	fp,12(sp)
8112ddf8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
8112ddfc:	d0a01417 	ldw	r2,-32688(gp)
8112de00:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
8112de04:	d0a07a17 	ldw	r2,-32280(gp)
8112de08:	10800044 	addi	r2,r2,1
8112de0c:	d0a07a15 	stw	r2,-32280(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
8112de10:	00002e06 	br	8112decc <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
8112de14:	e0bffd17 	ldw	r2,-12(fp)
8112de18:	10800017 	ldw	r2,0(r2)
8112de1c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
8112de20:	e0bffd17 	ldw	r2,-12(fp)
8112de24:	10800403 	ldbu	r2,16(r2)
8112de28:	10803fcc 	andi	r2,r2,255
8112de2c:	10000426 	beq	r2,zero,8112de40 <alt_tick+0x5c>
8112de30:	d0a07a17 	ldw	r2,-32280(gp)
8112de34:	1000021e 	bne	r2,zero,8112de40 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
8112de38:	e0bffd17 	ldw	r2,-12(fp)
8112de3c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
8112de40:	e0bffd17 	ldw	r2,-12(fp)
8112de44:	10800217 	ldw	r2,8(r2)
8112de48:	d0e07a17 	ldw	r3,-32280(gp)
8112de4c:	18801d36 	bltu	r3,r2,8112dec4 <alt_tick+0xe0>
8112de50:	e0bffd17 	ldw	r2,-12(fp)
8112de54:	10800403 	ldbu	r2,16(r2)
8112de58:	10803fcc 	andi	r2,r2,255
8112de5c:	1000191e 	bne	r2,zero,8112dec4 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
8112de60:	e0bffd17 	ldw	r2,-12(fp)
8112de64:	10800317 	ldw	r2,12(r2)
8112de68:	e0fffd17 	ldw	r3,-12(fp)
8112de6c:	18c00517 	ldw	r3,20(r3)
8112de70:	1809883a 	mov	r4,r3
8112de74:	103ee83a 	callr	r2
8112de78:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
8112de7c:	e0bfff17 	ldw	r2,-4(fp)
8112de80:	1000031e 	bne	r2,zero,8112de90 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
8112de84:	e13ffd17 	ldw	r4,-12(fp)
8112de88:	112dd400 	call	8112dd40 <alt_alarm_stop>
8112de8c:	00000d06 	br	8112dec4 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
8112de90:	e0bffd17 	ldw	r2,-12(fp)
8112de94:	10c00217 	ldw	r3,8(r2)
8112de98:	e0bfff17 	ldw	r2,-4(fp)
8112de9c:	1887883a 	add	r3,r3,r2
8112dea0:	e0bffd17 	ldw	r2,-12(fp)
8112dea4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
8112dea8:	e0bffd17 	ldw	r2,-12(fp)
8112deac:	10c00217 	ldw	r3,8(r2)
8112deb0:	d0a07a17 	ldw	r2,-32280(gp)
8112deb4:	1880032e 	bgeu	r3,r2,8112dec4 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
8112deb8:	e0bffd17 	ldw	r2,-12(fp)
8112debc:	00c00044 	movi	r3,1
8112dec0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
8112dec4:	e0bffe17 	ldw	r2,-8(fp)
8112dec8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
8112decc:	e0fffd17 	ldw	r3,-12(fp)
8112ded0:	d0a01404 	addi	r2,gp,-32688
8112ded4:	18bfcf1e 	bne	r3,r2,8112de14 <__reset+0xfb10de14>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
8112ded8:	112f1140 	call	8112f114 <OSTimeTick>
}
8112dedc:	0001883a 	nop
8112dee0:	e037883a 	mov	sp,fp
8112dee4:	dfc00117 	ldw	ra,4(sp)
8112dee8:	df000017 	ldw	fp,0(sp)
8112deec:	dec00204 	addi	sp,sp,8
8112def0:	f800283a 	ret

8112def4 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
8112def4:	defffb04 	addi	sp,sp,-20
8112def8:	de00012e 	bgeu	sp,et,8112df00 <usleep+0xc>
8112defc:	003b68fa 	trap	3
8112df00:	dfc00415 	stw	ra,16(sp)
8112df04:	df000315 	stw	fp,12(sp)
8112df08:	df000304 	addi	fp,sp,12
8112df0c:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
8112df10:	d0a08203 	ldbu	r2,-32248(gp)
8112df14:	10803fcc 	andi	r2,r2,255
8112df18:	1000031e 	bne	r2,zero,8112df28 <usleep+0x34>
  {
    return alt_busy_sleep (us);
8112df1c:	e13fff17 	ldw	r4,-4(fp)
8112df20:	112c4800 	call	8112c480 <alt_busy_sleep>
8112df24:	00003d06 	br	8112e01c <usleep+0x128>
8112df28:	d0a07917 	ldw	r2,-32284(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
8112df2c:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
8112df30:	e0ffff17 	ldw	r3,-4(fp)
8112df34:	0090c734 	movhi	r2,17180
8112df38:	10b7a0c4 	addi	r2,r2,-8573
8112df3c:	1888383a 	mulxuu	r4,r3,r2
8112df40:	1885383a 	mul	r2,r3,r2
8112df44:	1013883a 	mov	r9,r2
8112df48:	2015883a 	mov	r10,r4
8112df4c:	5006d4ba 	srli	r3,r10,18
8112df50:	e0bffe17 	ldw	r2,-8(fp)
8112df54:	1893383a 	mul	r9,r3,r2
8112df58:	e0ffff17 	ldw	r3,-4(fp)
8112df5c:	0090c734 	movhi	r2,17180
8112df60:	10b7a0c4 	addi	r2,r2,-8573
8112df64:	1888383a 	mulxuu	r4,r3,r2
8112df68:	1885383a 	mul	r2,r3,r2
8112df6c:	100f883a 	mov	r7,r2
8112df70:	2011883a 	mov	r8,r4
8112df74:	4004d4ba 	srli	r2,r8,18
8112df78:	010003f4 	movhi	r4,15
8112df7c:	21109004 	addi	r4,r4,16960
8112df80:	1105383a 	mul	r2,r2,r4
8112df84:	1885c83a 	sub	r2,r3,r2
8112df88:	e0fffe17 	ldw	r3,-8(fp)
8112df8c:	10c7383a 	mul	r3,r2,r3
8112df90:	0090c734 	movhi	r2,17180
8112df94:	10b7a0c4 	addi	r2,r2,-8573
8112df98:	1888383a 	mulxuu	r4,r3,r2
8112df9c:	1885383a 	mul	r2,r3,r2
8112dfa0:	100b883a 	mov	r5,r2
8112dfa4:	200d883a 	mov	r6,r4
8112dfa8:	3004d4ba 	srli	r2,r6,18
8112dfac:	4885883a 	add	r2,r9,r2
8112dfb0:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
8112dfb4:	00000706 	br	8112dfd4 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
8112dfb8:	013fffd4 	movui	r4,65535
8112dfbc:	11369d00 	call	811369d0 <OSTimeDly>
    ticks -= 0xffff;
8112dfc0:	e0fffd17 	ldw	r3,-12(fp)
8112dfc4:	00bffff4 	movhi	r2,65535
8112dfc8:	10800044 	addi	r2,r2,1
8112dfcc:	1885883a 	add	r2,r3,r2
8112dfd0:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
8112dfd4:	e0bffd17 	ldw	r2,-12(fp)
8112dfd8:	00ffffd4 	movui	r3,65535
8112dfdc:	18bff636 	bltu	r3,r2,8112dfb8 <__reset+0xfb10dfb8>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
8112dfe0:	e0bffd17 	ldw	r2,-12(fp)
8112dfe4:	10bfffcc 	andi	r2,r2,65535
8112dfe8:	1009883a 	mov	r4,r2
8112dfec:	11369d00 	call	811369d0 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
8112dff0:	008003f4 	movhi	r2,15
8112dff4:	10909004 	addi	r2,r2,16960
8112dff8:	e0fffe17 	ldw	r3,-8(fp)
8112dffc:	10c7203a 	divu	r3,r2,r3
8112e000:	e0bfff17 	ldw	r2,-4(fp)
8112e004:	10c9203a 	divu	r4,r2,r3
8112e008:	20c7383a 	mul	r3,r4,r3
8112e00c:	10c5c83a 	sub	r2,r2,r3
8112e010:	1009883a 	mov	r4,r2
8112e014:	112c4800 	call	8112c480 <alt_busy_sleep>

  return 0;  
8112e018:	0005883a 	mov	r2,zero
}
8112e01c:	e037883a 	mov	sp,fp
8112e020:	dfc00117 	ldw	ra,4(sp)
8112e024:	df000017 	ldw	fp,0(sp)
8112e028:	dec00204 	addi	sp,sp,8
8112e02c:	f800283a 	ret

8112e030 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112e030:	defffe04 	addi	sp,sp,-8
8112e034:	de00012e 	bgeu	sp,et,8112e03c <alt_get_errno+0xc>
8112e038:	003b68fa 	trap	3
8112e03c:	dfc00115 	stw	ra,4(sp)
8112e040:	df000015 	stw	fp,0(sp)
8112e044:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112e048:	d0a01017 	ldw	r2,-32704(gp)
8112e04c:	10000326 	beq	r2,zero,8112e05c <alt_get_errno+0x2c>
8112e050:	d0a01017 	ldw	r2,-32704(gp)
8112e054:	103ee83a 	callr	r2
8112e058:	00000106 	br	8112e060 <alt_get_errno+0x30>
8112e05c:	d0a06904 	addi	r2,gp,-32348
}
8112e060:	e037883a 	mov	sp,fp
8112e064:	dfc00117 	ldw	ra,4(sp)
8112e068:	df000017 	ldw	fp,0(sp)
8112e06c:	dec00204 	addi	sp,sp,8
8112e070:	f800283a 	ret

8112e074 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
8112e074:	defff904 	addi	sp,sp,-28
8112e078:	de00012e 	bgeu	sp,et,8112e080 <write+0xc>
8112e07c:	003b68fa 	trap	3
8112e080:	dfc00615 	stw	ra,24(sp)
8112e084:	df000515 	stw	fp,20(sp)
8112e088:	df000504 	addi	fp,sp,20
8112e08c:	e13ffd15 	stw	r4,-12(fp)
8112e090:	e17ffe15 	stw	r5,-8(fp)
8112e094:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112e098:	e0bffd17 	ldw	r2,-12(fp)
8112e09c:	10000616 	blt	r2,zero,8112e0b8 <write+0x44>
8112e0a0:	e0bffd17 	ldw	r2,-12(fp)
8112e0a4:	10c00324 	muli	r3,r2,12
8112e0a8:	00a04534 	movhi	r2,33044
8112e0ac:	109bea04 	addi	r2,r2,28584
8112e0b0:	1885883a 	add	r2,r3,r2
8112e0b4:	00000106 	br	8112e0bc <write+0x48>
8112e0b8:	0005883a 	mov	r2,zero
8112e0bc:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
8112e0c0:	e0bffb17 	ldw	r2,-20(fp)
8112e0c4:	10002426 	beq	r2,zero,8112e158 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
8112e0c8:	e0bffb17 	ldw	r2,-20(fp)
8112e0cc:	10800217 	ldw	r2,8(r2)
8112e0d0:	108000cc 	andi	r2,r2,3
8112e0d4:	10001b26 	beq	r2,zero,8112e144 <write+0xd0>
8112e0d8:	e0bffb17 	ldw	r2,-20(fp)
8112e0dc:	10800017 	ldw	r2,0(r2)
8112e0e0:	10800617 	ldw	r2,24(r2)
8112e0e4:	10001726 	beq	r2,zero,8112e144 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
8112e0e8:	e17fff17 	ldw	r5,-4(fp)
8112e0ec:	e13ffe17 	ldw	r4,-8(fp)
8112e0f0:	112d3f40 	call	8112d3f4 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
8112e0f4:	e0bffb17 	ldw	r2,-20(fp)
8112e0f8:	10800017 	ldw	r2,0(r2)
8112e0fc:	10800617 	ldw	r2,24(r2)
8112e100:	e0ffff17 	ldw	r3,-4(fp)
8112e104:	180d883a 	mov	r6,r3
8112e108:	e17ffe17 	ldw	r5,-8(fp)
8112e10c:	e13ffb17 	ldw	r4,-20(fp)
8112e110:	103ee83a 	callr	r2
8112e114:	e0bffc15 	stw	r2,-16(fp)
8112e118:	e0bffc17 	ldw	r2,-16(fp)
8112e11c:	1000070e 	bge	r2,zero,8112e13c <write+0xc8>
      {
        ALT_ERRNO = -rval;
8112e120:	112e0300 	call	8112e030 <alt_get_errno>
8112e124:	1007883a 	mov	r3,r2
8112e128:	e0bffc17 	ldw	r2,-16(fp)
8112e12c:	0085c83a 	sub	r2,zero,r2
8112e130:	18800015 	stw	r2,0(r3)
        return -1;
8112e134:	00bfffc4 	movi	r2,-1
8112e138:	00000c06 	br	8112e16c <write+0xf8>
      }
      return rval;
8112e13c:	e0bffc17 	ldw	r2,-16(fp)
8112e140:	00000a06 	br	8112e16c <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
8112e144:	112e0300 	call	8112e030 <alt_get_errno>
8112e148:	1007883a 	mov	r3,r2
8112e14c:	00800344 	movi	r2,13
8112e150:	18800015 	stw	r2,0(r3)
8112e154:	00000406 	br	8112e168 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
8112e158:	112e0300 	call	8112e030 <alt_get_errno>
8112e15c:	1007883a 	mov	r3,r2
8112e160:	00801444 	movi	r2,81
8112e164:	18800015 	stw	r2,0(r3)
  }
  return -1;
8112e168:	00bfffc4 	movi	r2,-1
}
8112e16c:	e037883a 	mov	sp,fp
8112e170:	dfc00117 	ldw	ra,4(sp)
8112e174:	df000017 	ldw	fp,0(sp)
8112e178:	dec00204 	addi	sp,sp,8
8112e17c:	f800283a 	ret

8112e180 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
8112e180:	deffde04 	addi	sp,sp,-136
8112e184:	de00012e 	bgeu	sp,et,8112e18c <__env_lock+0xc>
8112e188:	003b68fa 	trap	3
8112e18c:	dfc02115 	stw	ra,132(sp)
8112e190:	df002015 	stw	fp,128(sp)
8112e194:	df002004 	addi	fp,sp,128
8112e198:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
8112e19c:	e0bfe104 	addi	r2,fp,-124
8112e1a0:	100b883a 	mov	r5,r2
8112e1a4:	01003fc4 	movi	r4,255
8112e1a8:	113682c0 	call	8113682c <OSTaskQuery>
8112e1ac:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
8112e1b0:	e0bffe83 	ldbu	r2,-6(fp)
8112e1b4:	10803fcc 	andi	r2,r2,255
8112e1b8:	10001e1e 	bne	r2,zero,8112e234 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
8112e1bc:	e0bfed83 	ldbu	r2,-74(fp)
8112e1c0:	10803fcc 	andi	r2,r2,255
8112e1c4:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
8112e1c8:	d0a07c17 	ldw	r2,-32272(gp)
8112e1cc:	e0fffc04 	addi	r3,fp,-16
8112e1d0:	180b883a 	mov	r5,r3
8112e1d4:	1009883a 	mov	r4,r2
8112e1d8:	11351980 	call	81135198 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
8112e1dc:	e0bffe03 	ldbu	r2,-8(fp)
8112e1e0:	10803fcc 	andi	r2,r2,255
8112e1e4:	10000726 	beq	r2,zero,8112e204 <__env_lock+0x84>
8112e1e8:	d0a01617 	ldw	r2,-32680(gp)
8112e1ec:	e0ffe017 	ldw	r3,-128(fp)
8112e1f0:	1880041e 	bne	r3,r2,8112e204 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
8112e1f4:	d0a07b17 	ldw	r2,-32276(gp)
8112e1f8:	10800044 	addi	r2,r2,1
8112e1fc:	d0a07b15 	stw	r2,-32276(gp)
8112e200:	00000a06 	br	8112e22c <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
8112e204:	d0a07c17 	ldw	r2,-32272(gp)
8112e208:	e0fffe84 	addi	r3,fp,-6
8112e20c:	180d883a 	mov	r6,r3
8112e210:	000b883a 	mov	r5,zero
8112e214:	1009883a 	mov	r4,r2
8112e218:	1134cf80 	call	81134cf8 <OSSemPend>
    locks  = 1;
8112e21c:	00800044 	movi	r2,1
8112e220:	d0a07b15 	stw	r2,-32276(gp)
    lockid = id;
8112e224:	e0bfe017 	ldw	r2,-128(fp)
8112e228:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
8112e22c:	0001883a 	nop
8112e230:	00000106 	br	8112e238 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
8112e234:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8112e238:	e037883a 	mov	sp,fp
8112e23c:	dfc00117 	ldw	ra,4(sp)
8112e240:	df000017 	ldw	fp,0(sp)
8112e244:	dec00204 	addi	sp,sp,8
8112e248:	f800283a 	ret

8112e24c <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
8112e24c:	defffd04 	addi	sp,sp,-12
8112e250:	de00012e 	bgeu	sp,et,8112e258 <__env_unlock+0xc>
8112e254:	003b68fa 	trap	3
8112e258:	dfc00215 	stw	ra,8(sp)
8112e25c:	df000115 	stw	fp,4(sp)
8112e260:	df000104 	addi	fp,sp,4
8112e264:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
8112e268:	d0a07b17 	ldw	r2,-32276(gp)
8112e26c:	10000b26 	beq	r2,zero,8112e29c <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
8112e270:	d0a07b17 	ldw	r2,-32276(gp)
8112e274:	10bfffc4 	addi	r2,r2,-1
8112e278:	d0a07b15 	stw	r2,-32276(gp)
8112e27c:	d0a07b17 	ldw	r2,-32276(gp)
8112e280:	1000071e 	bne	r2,zero,8112e2a0 <__env_unlock+0x54>
  {
    lockid = -1;
8112e284:	00bfffc4 	movi	r2,-1
8112e288:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
8112e28c:	d0a07c17 	ldw	r2,-32272(gp)
8112e290:	1009883a 	mov	r4,r2
8112e294:	11350800 	call	81135080 <OSSemPost>
8112e298:	00000106 	br	8112e2a0 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
8112e29c:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8112e2a0:	e037883a 	mov	sp,fp
8112e2a4:	dfc00117 	ldw	ra,4(sp)
8112e2a8:	df000017 	ldw	fp,0(sp)
8112e2ac:	dec00204 	addi	sp,sp,8
8112e2b0:	f800283a 	ret

8112e2b4 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
8112e2b4:	deffda04 	addi	sp,sp,-152
8112e2b8:	de00012e 	bgeu	sp,et,8112e2c0 <__malloc_lock+0xc>
8112e2bc:	003b68fa 	trap	3
8112e2c0:	dfc02515 	stw	ra,148(sp)
8112e2c4:	df002415 	stw	fp,144(sp)
8112e2c8:	df002404 	addi	fp,sp,144
8112e2cc:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112e2d0:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
8112e2d4:	d0a08203 	ldbu	r2,-32248(gp)
8112e2d8:	10803fcc 	andi	r2,r2,255
8112e2dc:	10800060 	cmpeqi	r2,r2,1
8112e2e0:	10003626 	beq	r2,zero,8112e3bc <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
8112e2e4:	e0bfe104 	addi	r2,fp,-124
8112e2e8:	100b883a 	mov	r5,r2
8112e2ec:	01003fc4 	movi	r4,255
8112e2f0:	113682c0 	call	8113682c <OSTaskQuery>
8112e2f4:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
8112e2f8:	e0bffe83 	ldbu	r2,-6(fp)
8112e2fc:	10803fcc 	andi	r2,r2,255
8112e300:	1000301e 	bne	r2,zero,8112e3c4 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
8112e304:	e0bfed83 	ldbu	r2,-74(fp)
8112e308:	10803fcc 	andi	r2,r2,255
8112e30c:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
8112e310:	d0a07e17 	ldw	r2,-32264(gp)
8112e314:	e0fffc04 	addi	r3,fp,-16
8112e318:	180b883a 	mov	r5,r3
8112e31c:	1009883a 	mov	r4,r2
8112e320:	11351980 	call	81135198 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e324:	0005303a 	rdctl	r2,status
8112e328:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e32c:	e0ffe017 	ldw	r3,-128(fp)
8112e330:	00bfff84 	movi	r2,-2
8112e334:	1884703a 	and	r2,r3,r2
8112e338:	1001703a 	wrctl	status,r2
  
  return context;
8112e33c:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
8112e340:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
8112e344:	e0bffc0b 	ldhu	r2,-16(fp)
8112e348:	10bfffcc 	andi	r2,r2,65535
8112e34c:	10000b1e 	bne	r2,zero,8112e37c <__malloc_lock+0xc8>
8112e350:	d0a01717 	ldw	r2,-32676(gp)
8112e354:	e0ffdd17 	ldw	r3,-140(fp)
8112e358:	1880081e 	bne	r3,r2,8112e37c <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
8112e35c:	d0a07d17 	ldw	r2,-32268(gp)
8112e360:	10800044 	addi	r2,r2,1
8112e364:	d0a07d15 	stw	r2,-32268(gp)
8112e368:	e0bfdc17 	ldw	r2,-144(fp)
8112e36c:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e370:	e0bfde17 	ldw	r2,-136(fp)
8112e374:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
8112e378:	00000e06 	br	8112e3b4 <__malloc_lock+0x100>
8112e37c:	e0bfdc17 	ldw	r2,-144(fp)
8112e380:	e0bfdf15 	stw	r2,-132(fp)
8112e384:	e0bfdf17 	ldw	r2,-132(fp)
8112e388:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
8112e38c:	d0a07e17 	ldw	r2,-32264(gp)
8112e390:	e0fffe84 	addi	r3,fp,-6
8112e394:	180d883a 	mov	r6,r3
8112e398:	000b883a 	mov	r5,zero
8112e39c:	1009883a 	mov	r4,r2
8112e3a0:	1134cf80 	call	81134cf8 <OSSemPend>
    locks  = 1;
8112e3a4:	00800044 	movi	r2,1
8112e3a8:	d0a07d15 	stw	r2,-32268(gp)
    lockid = id;
8112e3ac:	e0bfdd17 	ldw	r2,-140(fp)
8112e3b0:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
8112e3b4:	0001883a 	nop
8112e3b8:	00000306 	br	8112e3c8 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
8112e3bc:	0001883a 	nop
8112e3c0:	00000106 	br	8112e3c8 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
8112e3c4:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8112e3c8:	e037883a 	mov	sp,fp
8112e3cc:	dfc00117 	ldw	ra,4(sp)
8112e3d0:	df000017 	ldw	fp,0(sp)
8112e3d4:	dec00204 	addi	sp,sp,8
8112e3d8:	f800283a 	ret

8112e3dc <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
8112e3dc:	defff804 	addi	sp,sp,-32
8112e3e0:	de00012e 	bgeu	sp,et,8112e3e8 <__malloc_unlock+0xc>
8112e3e4:	003b68fa 	trap	3
8112e3e8:	dfc00715 	stw	ra,28(sp)
8112e3ec:	df000615 	stw	fp,24(sp)
8112e3f0:	df000604 	addi	fp,sp,24
8112e3f4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112e3f8:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
8112e3fc:	d0a08203 	ldbu	r2,-32248(gp)
8112e400:	10803fcc 	andi	r2,r2,255
8112e404:	10800060 	cmpeqi	r2,r2,1
8112e408:	10002326 	beq	r2,zero,8112e498 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e40c:	0005303a 	rdctl	r2,status
8112e410:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e414:	e0fffe17 	ldw	r3,-8(fp)
8112e418:	00bfff84 	movi	r2,-2
8112e41c:	1884703a 	and	r2,r3,r2
8112e420:	1001703a 	wrctl	status,r2
  
  return context;
8112e424:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
8112e428:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
8112e42c:	d0a07d17 	ldw	r2,-32268(gp)
8112e430:	1000051e 	bne	r2,zero,8112e448 <__malloc_unlock+0x6c>
8112e434:	e0bffa17 	ldw	r2,-24(fp)
8112e438:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e43c:	e0bffb17 	ldw	r2,-20(fp)
8112e440:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
8112e444:	00001506 	br	8112e49c <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
8112e448:	d0a07d17 	ldw	r2,-32268(gp)
8112e44c:	10bfffc4 	addi	r2,r2,-1
8112e450:	d0a07d15 	stw	r2,-32268(gp)
8112e454:	d0a07d17 	ldw	r2,-32268(gp)
8112e458:	10000a1e 	bne	r2,zero,8112e484 <__malloc_unlock+0xa8>
  {
    lockid = -1;
8112e45c:	00bfffc4 	movi	r2,-1
8112e460:	d0a01715 	stw	r2,-32676(gp)
8112e464:	e0bffa17 	ldw	r2,-24(fp)
8112e468:	e0bffc15 	stw	r2,-16(fp)
8112e46c:	e0bffc17 	ldw	r2,-16(fp)
8112e470:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
8112e474:	d0a07e17 	ldw	r2,-32264(gp)
8112e478:	1009883a 	mov	r4,r2
8112e47c:	11350800 	call	81135080 <OSSemPost>
8112e480:	00000606 	br	8112e49c <__malloc_unlock+0xc0>
8112e484:	e0bffa17 	ldw	r2,-24(fp)
8112e488:	e0bffd15 	stw	r2,-12(fp)
8112e48c:	e0bffd17 	ldw	r2,-12(fp)
8112e490:	1001703a 	wrctl	status,r2
8112e494:	00000106 	br	8112e49c <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
8112e498:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8112e49c:	e037883a 	mov	sp,fp
8112e4a0:	dfc00117 	ldw	ra,4(sp)
8112e4a4:	df000017 	ldw	fp,0(sp)
8112e4a8:	dec00204 	addi	sp,sp,8
8112e4ac:	f800283a 	ret

8112e4b0 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8112e4b0:	defff704 	addi	sp,sp,-36
8112e4b4:	de00012e 	bgeu	sp,et,8112e4bc <OSEventNameGet+0xc>
8112e4b8:	003b68fa 	trap	3
8112e4bc:	dfc00815 	stw	ra,32(sp)
8112e4c0:	df000715 	stw	fp,28(sp)
8112e4c4:	df000704 	addi	fp,sp,28
8112e4c8:	e13ffd15 	stw	r4,-12(fp)
8112e4cc:	e17ffe15 	stw	r5,-8(fp)
8112e4d0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112e4d4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112e4d8:	e0bfff17 	ldw	r2,-4(fp)
8112e4dc:	1000021e 	bne	r2,zero,8112e4e8 <OSEventNameGet+0x38>
        return (0);
8112e4e0:	0005883a 	mov	r2,zero
8112e4e4:	00003706 	br	8112e5c4 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8112e4e8:	e0bffd17 	ldw	r2,-12(fp)
8112e4ec:	1000051e 	bne	r2,zero,8112e504 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
8112e4f0:	e0bfff17 	ldw	r2,-4(fp)
8112e4f4:	00c00104 	movi	r3,4
8112e4f8:	10c00005 	stb	r3,0(r2)
        return (0);
8112e4fc:	0005883a 	mov	r2,zero
8112e500:	00003006 	br	8112e5c4 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112e504:	e0bffe17 	ldw	r2,-8(fp)
8112e508:	1000051e 	bne	r2,zero,8112e520 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8112e50c:	e0bfff17 	ldw	r2,-4(fp)
8112e510:	00c00304 	movi	r3,12
8112e514:	10c00005 	stb	r3,0(r2)
        return (0);
8112e518:	0005883a 	mov	r2,zero
8112e51c:	00002906 	br	8112e5c4 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112e520:	d0a09203 	ldbu	r2,-32184(gp)
8112e524:	10803fcc 	andi	r2,r2,255
8112e528:	10000526 	beq	r2,zero,8112e540 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
8112e52c:	e0bfff17 	ldw	r2,-4(fp)
8112e530:	00c00444 	movi	r3,17
8112e534:	10c00005 	stb	r3,0(r2)
        return (0);
8112e538:	0005883a 	mov	r2,zero
8112e53c:	00002106 	br	8112e5c4 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
8112e540:	e0bffd17 	ldw	r2,-12(fp)
8112e544:	10800003 	ldbu	r2,0(r2)
8112e548:	10803fcc 	andi	r2,r2,255
8112e54c:	10bfffc4 	addi	r2,r2,-1
8112e550:	10800128 	cmpgeui	r2,r2,4
8112e554:	10000526 	beq	r2,zero,8112e56c <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8112e558:	e0bfff17 	ldw	r2,-4(fp)
8112e55c:	00c00044 	movi	r3,1
8112e560:	10c00005 	stb	r3,0(r2)
             return (0);
8112e564:	0005883a 	mov	r2,zero
8112e568:	00001606 	br	8112e5c4 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8112e56c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e570:	0005303a 	rdctl	r2,status
8112e574:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e578:	e0fffb17 	ldw	r3,-20(fp)
8112e57c:	00bfff84 	movi	r2,-2
8112e580:	1884703a 	and	r2,r3,r2
8112e584:	1001703a 	wrctl	status,r2
  
  return context;
8112e588:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
8112e58c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
8112e590:	e0bffd17 	ldw	r2,-12(fp)
8112e594:	10800444 	addi	r2,r2,17
8112e598:	100b883a 	mov	r5,r2
8112e59c:	e13ffe17 	ldw	r4,-8(fp)
8112e5a0:	112ff9c0 	call	8112ff9c <OS_StrCopy>
8112e5a4:	e0bffa05 	stb	r2,-24(fp)
8112e5a8:	e0bff917 	ldw	r2,-28(fp)
8112e5ac:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e5b0:	e0bffc17 	ldw	r2,-16(fp)
8112e5b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112e5b8:	e0bfff17 	ldw	r2,-4(fp)
8112e5bc:	10000005 	stb	zero,0(r2)
    return (len);
8112e5c0:	e0bffa03 	ldbu	r2,-24(fp)
}
8112e5c4:	e037883a 	mov	sp,fp
8112e5c8:	dfc00117 	ldw	ra,4(sp)
8112e5cc:	df000017 	ldw	fp,0(sp)
8112e5d0:	dec00204 	addi	sp,sp,8
8112e5d4:	f800283a 	ret

8112e5d8 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8112e5d8:	defff604 	addi	sp,sp,-40
8112e5dc:	de00012e 	bgeu	sp,et,8112e5e4 <OSEventNameSet+0xc>
8112e5e0:	003b68fa 	trap	3
8112e5e4:	dfc00915 	stw	ra,36(sp)
8112e5e8:	df000815 	stw	fp,32(sp)
8112e5ec:	df000804 	addi	fp,sp,32
8112e5f0:	e13ffd15 	stw	r4,-12(fp)
8112e5f4:	e17ffe15 	stw	r5,-8(fp)
8112e5f8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112e5fc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8112e600:	e0bfff17 	ldw	r2,-4(fp)
8112e604:	10004026 	beq	r2,zero,8112e708 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8112e608:	e0bffd17 	ldw	r2,-12(fp)
8112e60c:	1000041e 	bne	r2,zero,8112e620 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8112e610:	e0bfff17 	ldw	r2,-4(fp)
8112e614:	00c00104 	movi	r3,4
8112e618:	10c00005 	stb	r3,0(r2)
        return;
8112e61c:	00003b06 	br	8112e70c <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8112e620:	e0bffe17 	ldw	r2,-8(fp)
8112e624:	1000041e 	bne	r2,zero,8112e638 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8112e628:	e0bfff17 	ldw	r2,-4(fp)
8112e62c:	00c00304 	movi	r3,12
8112e630:	10c00005 	stb	r3,0(r2)
        return;
8112e634:	00003506 	br	8112e70c <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8112e638:	d0a09203 	ldbu	r2,-32184(gp)
8112e63c:	10803fcc 	andi	r2,r2,255
8112e640:	10000426 	beq	r2,zero,8112e654 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8112e644:	e0bfff17 	ldw	r2,-4(fp)
8112e648:	00c00484 	movi	r3,18
8112e64c:	10c00005 	stb	r3,0(r2)
        return;
8112e650:	00002e06 	br	8112e70c <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
8112e654:	e0bffd17 	ldw	r2,-12(fp)
8112e658:	10800003 	ldbu	r2,0(r2)
8112e65c:	10803fcc 	andi	r2,r2,255
8112e660:	10bfffc4 	addi	r2,r2,-1
8112e664:	10800128 	cmpgeui	r2,r2,4
8112e668:	10000426 	beq	r2,zero,8112e67c <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8112e66c:	e0bfff17 	ldw	r2,-4(fp)
8112e670:	00c00044 	movi	r3,1
8112e674:	10c00005 	stb	r3,0(r2)
             return;
8112e678:	00002406 	br	8112e70c <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8112e67c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e680:	0005303a 	rdctl	r2,status
8112e684:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e688:	e0fffc17 	ldw	r3,-16(fp)
8112e68c:	00bfff84 	movi	r2,-2
8112e690:	1884703a 	and	r2,r3,r2
8112e694:	1001703a 	wrctl	status,r2
  
  return context;
8112e698:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
8112e69c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
8112e6a0:	e13ffe17 	ldw	r4,-8(fp)
8112e6a4:	11300180 	call	81130018 <OS_StrLen>
8112e6a8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
8112e6ac:	e0bffa03 	ldbu	r2,-24(fp)
8112e6b0:	10800830 	cmpltui	r2,r2,32
8112e6b4:	1000081e 	bne	r2,zero,8112e6d8 <OSEventNameSet+0x100>
8112e6b8:	e0bff817 	ldw	r2,-32(fp)
8112e6bc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112e6c0:	e0bff917 	ldw	r2,-28(fp)
8112e6c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
8112e6c8:	e0bfff17 	ldw	r2,-4(fp)
8112e6cc:	00c002c4 	movi	r3,11
8112e6d0:	10c00005 	stb	r3,0(r2)
        return;
8112e6d4:	00000d06 	br	8112e70c <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
8112e6d8:	e0bffd17 	ldw	r2,-12(fp)
8112e6dc:	10800444 	addi	r2,r2,17
8112e6e0:	e17ffe17 	ldw	r5,-8(fp)
8112e6e4:	1009883a 	mov	r4,r2
8112e6e8:	112ff9c0 	call	8112ff9c <OS_StrCopy>
8112e6ec:	e0bff817 	ldw	r2,-32(fp)
8112e6f0:	e0bffb15 	stw	r2,-20(fp)
8112e6f4:	e0bffb17 	ldw	r2,-20(fp)
8112e6f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8112e6fc:	e0bfff17 	ldw	r2,-4(fp)
8112e700:	10000005 	stb	zero,0(r2)
8112e704:	00000106 	br	8112e70c <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8112e708:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8112e70c:	e037883a 	mov	sp,fp
8112e710:	dfc00117 	ldw	ra,4(sp)
8112e714:	df000017 	ldw	fp,0(sp)
8112e718:	dec00204 	addi	sp,sp,8
8112e71c:	f800283a 	ret

8112e720 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
8112e720:	deffed04 	addi	sp,sp,-76
8112e724:	de00012e 	bgeu	sp,et,8112e72c <OSEventPendMulti+0xc>
8112e728:	003b68fa 	trap	3
8112e72c:	dfc01215 	stw	ra,72(sp)
8112e730:	df001115 	stw	fp,68(sp)
8112e734:	df001104 	addi	fp,sp,68
8112e738:	e13ffc15 	stw	r4,-16(fp)
8112e73c:	e17ffd15 	stw	r5,-12(fp)
8112e740:	e1bffe15 	stw	r6,-8(fp)
8112e744:	3805883a 	mov	r2,r7
8112e748:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
8112e74c:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
8112e750:	e0800217 	ldw	r2,8(fp)
8112e754:	1000021e 	bne	r2,zero,8112e760 <OSEventPendMulti+0x40>
        return (0);
8112e758:	0005883a 	mov	r2,zero
8112e75c:	00015006 	br	8112eca0 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
8112e760:	e0bffc17 	ldw	r2,-16(fp)
8112e764:	1000051e 	bne	r2,zero,8112e77c <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
8112e768:	e0800217 	ldw	r2,8(fp)
8112e76c:	00c00104 	movi	r3,4
8112e770:	10c00005 	stb	r3,0(r2)
        return (0);
8112e774:	0005883a 	mov	r2,zero
8112e778:	00014906 	br	8112eca0 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
8112e77c:	e0bffd17 	ldw	r2,-12(fp)
8112e780:	1000051e 	bne	r2,zero,8112e798 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
8112e784:	e0800217 	ldw	r2,8(fp)
8112e788:	00c00104 	movi	r3,4
8112e78c:	10c00005 	stb	r3,0(r2)
        return (0);
8112e790:	0005883a 	mov	r2,zero
8112e794:	00014206 	br	8112eca0 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
8112e798:	e0bffe17 	ldw	r2,-8(fp)
8112e79c:	1000051e 	bne	r2,zero,8112e7b4 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
8112e7a0:	e0800217 	ldw	r2,8(fp)
8112e7a4:	00c00104 	movi	r3,4
8112e7a8:	10c00005 	stb	r3,0(r2)
        return (0);
8112e7ac:	0005883a 	mov	r2,zero
8112e7b0:	00013b06 	br	8112eca0 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
8112e7b4:	e0bffd17 	ldw	r2,-12(fp)
8112e7b8:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
8112e7bc:	e0bffc17 	ldw	r2,-16(fp)
8112e7c0:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
8112e7c4:	e0bfef17 	ldw	r2,-68(fp)
8112e7c8:	10800017 	ldw	r2,0(r2)
8112e7cc:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
8112e7d0:	00001506 	br	8112e828 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
8112e7d4:	e0bff017 	ldw	r2,-64(fp)
8112e7d8:	10800003 	ldbu	r2,0(r2)
8112e7dc:	10803fcc 	andi	r2,r2,255
8112e7e0:	10c000a0 	cmpeqi	r3,r2,2
8112e7e4:	1800071e 	bne	r3,zero,8112e804 <OSEventPendMulti+0xe4>
8112e7e8:	108000e0 	cmpeqi	r2,r2,3
8112e7ec:	1000071e 	bne	r2,zero,8112e80c <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
8112e7f0:	e0800217 	ldw	r2,8(fp)
8112e7f4:	00c00044 	movi	r3,1
8112e7f8:	10c00005 	stb	r3,0(r2)
                 return (0);
8112e7fc:	0005883a 	mov	r2,zero
8112e800:	00012706 	br	8112eca0 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
8112e804:	0001883a 	nop
8112e808:	00000106 	br	8112e810 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
8112e80c:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
8112e810:	e0bfef17 	ldw	r2,-68(fp)
8112e814:	10800104 	addi	r2,r2,4
8112e818:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8112e81c:	e0bfef17 	ldw	r2,-68(fp)
8112e820:	10800017 	ldw	r2,0(r2)
8112e824:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
8112e828:	e0bff017 	ldw	r2,-64(fp)
8112e82c:	103fe91e 	bne	r2,zero,8112e7d4 <__reset+0xfb10e7d4>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
8112e830:	d0a09203 	ldbu	r2,-32184(gp)
8112e834:	10803fcc 	andi	r2,r2,255
8112e838:	10000526 	beq	r2,zero,8112e850 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
8112e83c:	e0800217 	ldw	r2,8(fp)
8112e840:	00c00084 	movi	r3,2
8112e844:	10c00005 	stb	r3,0(r2)
        return (0);
8112e848:	0005883a 	mov	r2,zero
8112e84c:	00011406 	br	8112eca0 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
8112e850:	d0a08003 	ldbu	r2,-32256(gp)
8112e854:	10803fcc 	andi	r2,r2,255
8112e858:	10000526 	beq	r2,zero,8112e870 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
8112e85c:	e0800217 	ldw	r2,8(fp)
8112e860:	00c00344 	movi	r3,13
8112e864:	10c00005 	stb	r3,0(r2)
        return (0);
8112e868:	0005883a 	mov	r2,zero
8112e86c:	00010c06 	br	8112eca0 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112e870:	0005303a 	rdctl	r2,status
8112e874:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112e878:	e0fffb17 	ldw	r3,-20(fp)
8112e87c:	00bfff84 	movi	r2,-2
8112e880:	1884703a 	and	r2,r3,r2
8112e884:	1001703a 	wrctl	status,r2
  
  return context;
8112e888:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
8112e88c:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
8112e890:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
8112e894:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
8112e898:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
8112e89c:	e0bffc17 	ldw	r2,-16(fp)
8112e8a0:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
8112e8a4:	e0bfef17 	ldw	r2,-68(fp)
8112e8a8:	10800017 	ldw	r2,0(r2)
8112e8ac:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8112e8b0:	00006406 	br	8112ea44 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
8112e8b4:	e0bff017 	ldw	r2,-64(fp)
8112e8b8:	10800003 	ldbu	r2,0(r2)
8112e8bc:	10803fcc 	andi	r2,r2,255
8112e8c0:	10c000a0 	cmpeqi	r3,r2,2
8112e8c4:	18001f1e 	bne	r3,zero,8112e944 <OSEventPendMulti+0x224>
8112e8c8:	108000e0 	cmpeqi	r2,r2,3
8112e8cc:	10004c26 	beq	r2,zero,8112ea00 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
8112e8d0:	e0bff017 	ldw	r2,-64(fp)
8112e8d4:	1080020b 	ldhu	r2,8(r2)
8112e8d8:	10bfffcc 	andi	r2,r2,65535
8112e8dc:	10001526 	beq	r2,zero,8112e934 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
8112e8e0:	e0bff017 	ldw	r2,-64(fp)
8112e8e4:	1080020b 	ldhu	r2,8(r2)
8112e8e8:	10bfffc4 	addi	r2,r2,-1
8112e8ec:	1007883a 	mov	r3,r2
8112e8f0:	e0bff017 	ldw	r2,-64(fp)
8112e8f4:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
8112e8f8:	e0bffd17 	ldw	r2,-12(fp)
8112e8fc:	10c00104 	addi	r3,r2,4
8112e900:	e0fffd15 	stw	r3,-12(fp)
8112e904:	e0fff017 	ldw	r3,-64(fp)
8112e908:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
8112e90c:	00800044 	movi	r2,1
8112e910:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
8112e914:	e0bffe17 	ldw	r2,-8(fp)
8112e918:	10c00104 	addi	r3,r2,4
8112e91c:	e0fffe15 	stw	r3,-8(fp)
8112e920:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
8112e924:	e0bff18b 	ldhu	r2,-58(fp)
8112e928:	10800044 	addi	r2,r2,1
8112e92c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
8112e930:	00003e06 	br	8112ea2c <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
8112e934:	e0bff203 	ldbu	r2,-56(fp)
8112e938:	10800054 	ori	r2,r2,1
8112e93c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8112e940:	00003a06 	br	8112ea2c <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
8112e944:	e0bff017 	ldw	r2,-64(fp)
8112e948:	10800117 	ldw	r2,4(r2)
8112e94c:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
8112e950:	e0bff517 	ldw	r2,-44(fp)
8112e954:	1080058b 	ldhu	r2,22(r2)
8112e958:	10bfffcc 	andi	r2,r2,65535
8112e95c:	10002426 	beq	r2,zero,8112e9f0 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
8112e960:	e0bffe17 	ldw	r2,-8(fp)
8112e964:	10c00104 	addi	r3,r2,4
8112e968:	e0fffe15 	stw	r3,-8(fp)
8112e96c:	e0fff517 	ldw	r3,-44(fp)
8112e970:	18c00417 	ldw	r3,16(r3)
8112e974:	19400104 	addi	r5,r3,4
8112e978:	e13ff517 	ldw	r4,-44(fp)
8112e97c:	21400415 	stw	r5,16(r4)
8112e980:	18c00017 	ldw	r3,0(r3)
8112e984:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
8112e988:	e0bff517 	ldw	r2,-44(fp)
8112e98c:	10c00417 	ldw	r3,16(r2)
8112e990:	e0bff517 	ldw	r2,-44(fp)
8112e994:	10800217 	ldw	r2,8(r2)
8112e998:	1880041e 	bne	r3,r2,8112e9ac <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
8112e99c:	e0bff517 	ldw	r2,-44(fp)
8112e9a0:	10c00117 	ldw	r3,4(r2)
8112e9a4:	e0bff517 	ldw	r2,-44(fp)
8112e9a8:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
8112e9ac:	e0bff517 	ldw	r2,-44(fp)
8112e9b0:	1080058b 	ldhu	r2,22(r2)
8112e9b4:	10bfffc4 	addi	r2,r2,-1
8112e9b8:	1007883a 	mov	r3,r2
8112e9bc:	e0bff517 	ldw	r2,-44(fp)
8112e9c0:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
8112e9c4:	e0bffd17 	ldw	r2,-12(fp)
8112e9c8:	10c00104 	addi	r3,r2,4
8112e9cc:	e0fffd15 	stw	r3,-12(fp)
8112e9d0:	e0fff017 	ldw	r3,-64(fp)
8112e9d4:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
8112e9d8:	00800044 	movi	r2,1
8112e9dc:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
8112e9e0:	e0bff18b 	ldhu	r2,-58(fp)
8112e9e4:	10800044 	addi	r2,r2,1
8112e9e8:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
8112e9ec:	00000f06 	br	8112ea2c <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
8112e9f0:	e0bff203 	ldbu	r2,-56(fp)
8112e9f4:	10800114 	ori	r2,r2,4
8112e9f8:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8112e9fc:	00000b06 	br	8112ea2c <OSEventPendMulti+0x30c>
8112ea00:	e0bff317 	ldw	r2,-52(fp)
8112ea04:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ea08:	e0bff417 	ldw	r2,-48(fp)
8112ea0c:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
8112ea10:	e0bffd17 	ldw	r2,-12(fp)
8112ea14:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
8112ea18:	e0800217 	ldw	r2,8(fp)
8112ea1c:	00c00044 	movi	r3,1
8112ea20:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
8112ea24:	e0bff18b 	ldhu	r2,-58(fp)
8112ea28:	00009d06 	br	8112eca0 <OSEventPendMulti+0x580>
        }
        pevents++;
8112ea2c:	e0bfef17 	ldw	r2,-68(fp)
8112ea30:	10800104 	addi	r2,r2,4
8112ea34:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8112ea38:	e0bfef17 	ldw	r2,-68(fp)
8112ea3c:	10800017 	ldw	r2,0(r2)
8112ea40:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8112ea44:	e0bff017 	ldw	r2,-64(fp)
8112ea48:	103f9a1e 	bne	r2,zero,8112e8b4 <__reset+0xfb10e8b4>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
8112ea4c:	e0bff103 	ldbu	r2,-60(fp)
8112ea50:	10800058 	cmpnei	r2,r2,1
8112ea54:	10000a1e 	bne	r2,zero,8112ea80 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
8112ea58:	e0bffd17 	ldw	r2,-12(fp)
8112ea5c:	10000015 	stw	zero,0(r2)
8112ea60:	e0bff317 	ldw	r2,-52(fp)
8112ea64:	e0bff615 	stw	r2,-40(fp)
8112ea68:	e0bff617 	ldw	r2,-40(fp)
8112ea6c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
8112ea70:	e0800217 	ldw	r2,8(fp)
8112ea74:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
8112ea78:	e0bff18b 	ldhu	r2,-58(fp)
8112ea7c:	00008806 	br	8112eca0 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
8112ea80:	d0a09317 	ldw	r2,-32180(gp)
8112ea84:	d0e09317 	ldw	r3,-32180(gp)
8112ea88:	19000c03 	ldbu	r4,48(r3)
8112ea8c:	e0fff203 	ldbu	r3,-56(fp)
8112ea90:	20c6b03a 	or	r3,r4,r3
8112ea94:	1809883a 	mov	r4,r3
8112ea98:	00ffe004 	movi	r3,-128
8112ea9c:	20c6b03a 	or	r3,r4,r3
8112eaa0:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8112eaa4:	d0a09317 	ldw	r2,-32180(gp)
8112eaa8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
8112eaac:	d0a09317 	ldw	r2,-32180(gp)
8112eab0:	e0ffff0b 	ldhu	r3,-4(fp)
8112eab4:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
8112eab8:	e13ffc17 	ldw	r4,-16(fp)
8112eabc:	112f6440 	call	8112f644 <OS_EventTaskWaitMulti>
8112eac0:	e0bff317 	ldw	r2,-52(fp)
8112eac4:	e0bff915 	stw	r2,-28(fp)
8112eac8:	e0bff917 	ldw	r2,-28(fp)
8112eacc:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
8112ead0:	112fe480 	call	8112fe48 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ead4:	0005303a 	rdctl	r2,status
8112ead8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112eadc:	e0fff717 	ldw	r3,-36(fp)
8112eae0:	00bfff84 	movi	r2,-2
8112eae4:	1884703a 	and	r2,r3,r2
8112eae8:	1001703a 	wrctl	status,r2
  
  return context;
8112eaec:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
8112eaf0:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
8112eaf4:	d0a09317 	ldw	r2,-32180(gp)
8112eaf8:	10800c43 	ldbu	r2,49(r2)
8112eafc:	10803fcc 	andi	r2,r2,255
8112eb00:	10000226 	beq	r2,zero,8112eb0c <OSEventPendMulti+0x3ec>
8112eb04:	108000a0 	cmpeqi	r2,r2,2
8112eb08:	10001826 	beq	r2,zero,8112eb6c <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8112eb0c:	d0a09317 	ldw	r2,-32180(gp)
8112eb10:	10800717 	ldw	r2,28(r2)
8112eb14:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
8112eb18:	e0bff017 	ldw	r2,-64(fp)
8112eb1c:	10000b26 	beq	r2,zero,8112eb4c <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
8112eb20:	e0bffd17 	ldw	r2,-12(fp)
8112eb24:	10c00104 	addi	r3,r2,4
8112eb28:	e0fffd15 	stw	r3,-12(fp)
8112eb2c:	e0fff017 	ldw	r3,-64(fp)
8112eb30:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
8112eb34:	e0bffd17 	ldw	r2,-12(fp)
8112eb38:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
8112eb3c:	e0bff18b 	ldhu	r2,-58(fp)
8112eb40:	10800044 	addi	r2,r2,1
8112eb44:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
8112eb48:	00000d06 	br	8112eb80 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
8112eb4c:	d0a09317 	ldw	r2,-32180(gp)
8112eb50:	00c00044 	movi	r3,1
8112eb54:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8112eb58:	d0a09317 	ldw	r2,-32180(gp)
8112eb5c:	e17ffc17 	ldw	r5,-16(fp)
8112eb60:	1009883a 	mov	r4,r2
8112eb64:	112f85c0 	call	8112f85c <OS_EventTaskRemoveMulti>
             }
			 break;
8112eb68:	00000506 	br	8112eb80 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8112eb6c:	d0a09317 	ldw	r2,-32180(gp)
8112eb70:	e17ffc17 	ldw	r5,-16(fp)
8112eb74:	1009883a 	mov	r4,r2
8112eb78:	112f85c0 	call	8112f85c <OS_EventTaskRemoveMulti>
             break;
8112eb7c:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
8112eb80:	d0a09317 	ldw	r2,-32180(gp)
8112eb84:	10800c43 	ldbu	r2,49(r2)
8112eb88:	10803fcc 	andi	r2,r2,255
8112eb8c:	10000326 	beq	r2,zero,8112eb9c <OSEventPendMulti+0x47c>
8112eb90:	108000a0 	cmpeqi	r2,r2,2
8112eb94:	1000231e 	bne	r2,zero,8112ec24 <OSEventPendMulti+0x504>
8112eb98:	00002a06 	br	8112ec44 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
8112eb9c:	e0bff017 	ldw	r2,-64(fp)
8112eba0:	10800003 	ldbu	r2,0(r2)
8112eba4:	10803fcc 	andi	r2,r2,255
8112eba8:	0080100e 	bge	zero,r2,8112ebec <OSEventPendMulti+0x4cc>
8112ebac:	10c000d0 	cmplti	r3,r2,3
8112ebb0:	1800071e 	bne	r3,zero,8112ebd0 <OSEventPendMulti+0x4b0>
8112ebb4:	108000e0 	cmpeqi	r2,r2,3
8112ebb8:	10000c26 	beq	r2,zero,8112ebec <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
8112ebbc:	e0bffe17 	ldw	r2,-8(fp)
8112ebc0:	10c00104 	addi	r3,r2,4
8112ebc4:	e0fffe15 	stw	r3,-8(fp)
8112ebc8:	10000015 	stw	zero,0(r2)
                      break;
8112ebcc:	00001206 	br	8112ec18 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
8112ebd0:	e0bffe17 	ldw	r2,-8(fp)
8112ebd4:	10c00104 	addi	r3,r2,4
8112ebd8:	e0fffe15 	stw	r3,-8(fp)
8112ebdc:	d0e09317 	ldw	r3,-32180(gp)
8112ebe0:	18c00917 	ldw	r3,36(r3)
8112ebe4:	10c00015 	stw	r3,0(r2)
                      break;
8112ebe8:	00000b06 	br	8112ec18 <OSEventPendMulti+0x4f8>
8112ebec:	e0bff317 	ldw	r2,-52(fp)
8112ebf0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ebf4:	e0bff817 	ldw	r2,-32(fp)
8112ebf8:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
8112ebfc:	e0bffd17 	ldw	r2,-12(fp)
8112ec00:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
8112ec04:	e0800217 	ldw	r2,8(fp)
8112ec08:	00c00044 	movi	r3,1
8112ec0c:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
8112ec10:	e0bff18b 	ldhu	r2,-58(fp)
8112ec14:	00002206 	br	8112eca0 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
8112ec18:	e0800217 	ldw	r2,8(fp)
8112ec1c:	10000005 	stb	zero,0(r2)
             break;
8112ec20:	00001006 	br	8112ec64 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
8112ec24:	e0bffe17 	ldw	r2,-8(fp)
8112ec28:	10c00104 	addi	r3,r2,4
8112ec2c:	e0fffe15 	stw	r3,-8(fp)
8112ec30:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
8112ec34:	e0800217 	ldw	r2,8(fp)
8112ec38:	00c00384 	movi	r3,14
8112ec3c:	10c00005 	stb	r3,0(r2)
             break;
8112ec40:	00000806 	br	8112ec64 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
8112ec44:	e0bffe17 	ldw	r2,-8(fp)
8112ec48:	10c00104 	addi	r3,r2,4
8112ec4c:	e0fffe15 	stw	r3,-8(fp)
8112ec50:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
8112ec54:	e0800217 	ldw	r2,8(fp)
8112ec58:	00c00284 	movi	r3,10
8112ec5c:	10c00005 	stb	r3,0(r2)
             break;
8112ec60:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
8112ec64:	d0a09317 	ldw	r2,-32180(gp)
8112ec68:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
8112ec6c:	d0a09317 	ldw	r2,-32180(gp)
8112ec70:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
8112ec74:	d0a09317 	ldw	r2,-32180(gp)
8112ec78:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8112ec7c:	d0a09317 	ldw	r2,-32180(gp)
8112ec80:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
8112ec84:	d0a09317 	ldw	r2,-32180(gp)
8112ec88:	10000915 	stw	zero,36(r2)
8112ec8c:	e0bff317 	ldw	r2,-52(fp)
8112ec90:	e0bffa15 	stw	r2,-24(fp)
8112ec94:	e0bffa17 	ldw	r2,-24(fp)
8112ec98:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
8112ec9c:	e0bff18b 	ldhu	r2,-58(fp)
}
8112eca0:	e037883a 	mov	sp,fp
8112eca4:	dfc00117 	ldw	ra,4(sp)
8112eca8:	df000017 	ldw	fp,0(sp)
8112ecac:	dec00204 	addi	sp,sp,8
8112ecb0:	f800283a 	ret

8112ecb4 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
8112ecb4:	defffe04 	addi	sp,sp,-8
8112ecb8:	de00012e 	bgeu	sp,et,8112ecc0 <OSInit+0xc>
8112ecbc:	003b68fa 	trap	3
8112ecc0:	dfc00115 	stw	ra,4(sp)
8112ecc4:	df000015 	stw	fp,0(sp)
8112ecc8:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
8112eccc:	11410040 	call	81141004 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
8112ecd0:	112fabc0 	call	8112fabc <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
8112ecd4:	112fb0c0 	call	8112fb0c <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
8112ecd8:	112fc900 	call	8112fc90 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
8112ecdc:	112f9d40 	call	8112f9d4 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
8112ece0:	1131c500 	call	81131c50 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
8112ece4:	11325980 	call	81132598 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
8112ece8:	11348680 	call	81134868 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
8112ecec:	112fb800 	call	8112fb80 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
8112ecf0:	112fc080 	call	8112fc08 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
8112ecf4:	1137a580 	call	81137a58 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
8112ecf8:	11410300 	call	81141030 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
8112ecfc:	113056c0 	call	8113056c <OSDebugInit>
#endif
}
8112ed00:	0001883a 	nop
8112ed04:	e037883a 	mov	sp,fp
8112ed08:	dfc00117 	ldw	ra,4(sp)
8112ed0c:	df000017 	ldw	fp,0(sp)
8112ed10:	dec00204 	addi	sp,sp,8
8112ed14:	f800283a 	ret

8112ed18 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
8112ed18:	deffff04 	addi	sp,sp,-4
8112ed1c:	de00012e 	bgeu	sp,et,8112ed24 <OSIntEnter+0xc>
8112ed20:	003b68fa 	trap	3
8112ed24:	df000015 	stw	fp,0(sp)
8112ed28:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
8112ed2c:	d0a08203 	ldbu	r2,-32248(gp)
8112ed30:	10803fcc 	andi	r2,r2,255
8112ed34:	10800058 	cmpnei	r2,r2,1
8112ed38:	1000071e 	bne	r2,zero,8112ed58 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
8112ed3c:	d0a09203 	ldbu	r2,-32184(gp)
8112ed40:	10803fcc 	andi	r2,r2,255
8112ed44:	10803fe0 	cmpeqi	r2,r2,255
8112ed48:	1000031e 	bne	r2,zero,8112ed58 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
8112ed4c:	d0a09203 	ldbu	r2,-32184(gp)
8112ed50:	10800044 	addi	r2,r2,1
8112ed54:	d0a09205 	stb	r2,-32184(gp)
        }
    }
}
8112ed58:	0001883a 	nop
8112ed5c:	e037883a 	mov	sp,fp
8112ed60:	df000017 	ldw	fp,0(sp)
8112ed64:	dec00104 	addi	sp,sp,4
8112ed68:	f800283a 	ret

8112ed6c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
8112ed6c:	defffb04 	addi	sp,sp,-20
8112ed70:	de00012e 	bgeu	sp,et,8112ed78 <OSIntExit+0xc>
8112ed74:	003b68fa 	trap	3
8112ed78:	dfc00415 	stw	ra,16(sp)
8112ed7c:	df000315 	stw	fp,12(sp)
8112ed80:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112ed84:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
8112ed88:	d0a08203 	ldbu	r2,-32248(gp)
8112ed8c:	10803fcc 	andi	r2,r2,255
8112ed90:	10800058 	cmpnei	r2,r2,1
8112ed94:	10002f1e 	bne	r2,zero,8112ee54 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ed98:	0005303a 	rdctl	r2,status
8112ed9c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112eda0:	e0ffff17 	ldw	r3,-4(fp)
8112eda4:	00bfff84 	movi	r2,-2
8112eda8:	1884703a 	and	r2,r3,r2
8112edac:	1001703a 	wrctl	status,r2
  
  return context;
8112edb0:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8112edb4:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
8112edb8:	d0a09203 	ldbu	r2,-32184(gp)
8112edbc:	10803fcc 	andi	r2,r2,255
8112edc0:	10000326 	beq	r2,zero,8112edd0 <OSIntExit+0x64>
            OSIntNesting--;
8112edc4:	d0a09203 	ldbu	r2,-32184(gp)
8112edc8:	10bfffc4 	addi	r2,r2,-1
8112edcc:	d0a09205 	stb	r2,-32184(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
8112edd0:	d0a09203 	ldbu	r2,-32184(gp)
8112edd4:	10803fcc 	andi	r2,r2,255
8112edd8:	10001a1e 	bne	r2,zero,8112ee44 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
8112eddc:	d0a08003 	ldbu	r2,-32256(gp)
8112ede0:	10803fcc 	andi	r2,r2,255
8112ede4:	1000171e 	bne	r2,zero,8112ee44 <OSIntExit+0xd8>
                OS_SchedNew();
8112ede8:	112ff200 	call	8112ff20 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
8112edec:	d0e08483 	ldbu	r3,-32238(gp)
8112edf0:	d0a084c3 	ldbu	r2,-32237(gp)
8112edf4:	18c03fcc 	andi	r3,r3,255
8112edf8:	10803fcc 	andi	r2,r2,255
8112edfc:	18801126 	beq	r3,r2,8112ee44 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
8112ee00:	d0a08483 	ldbu	r2,-32238(gp)
8112ee04:	10c03fcc 	andi	r3,r2,255
8112ee08:	00a045b4 	movhi	r2,33046
8112ee0c:	10882104 	addi	r2,r2,8324
8112ee10:	18c7883a 	add	r3,r3,r3
8112ee14:	18c7883a 	add	r3,r3,r3
8112ee18:	10c5883a 	add	r2,r2,r3
8112ee1c:	10800017 	ldw	r2,0(r2)
8112ee20:	d0a08d15 	stw	r2,-32204(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
8112ee24:	d0a08d17 	ldw	r2,-32204(gp)
8112ee28:	10c00e17 	ldw	r3,56(r2)
8112ee2c:	18c00044 	addi	r3,r3,1
8112ee30:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
8112ee34:	d0a08717 	ldw	r2,-32228(gp)
8112ee38:	10800044 	addi	r2,r2,1
8112ee3c:	d0a08715 	stw	r2,-32228(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
8112ee40:	1140cc40 	call	81140cc4 <OSCtxSw>
8112ee44:	e0bffd17 	ldw	r2,-12(fp)
8112ee48:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ee4c:	e0bffe17 	ldw	r2,-8(fp)
8112ee50:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8112ee54:	0001883a 	nop
8112ee58:	e037883a 	mov	sp,fp
8112ee5c:	dfc00117 	ldw	ra,4(sp)
8112ee60:	df000017 	ldw	fp,0(sp)
8112ee64:	dec00204 	addi	sp,sp,8
8112ee68:	f800283a 	ret

8112ee6c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
8112ee6c:	defffc04 	addi	sp,sp,-16
8112ee70:	de00012e 	bgeu	sp,et,8112ee78 <OSSchedLock+0xc>
8112ee74:	003b68fa 	trap	3
8112ee78:	df000315 	stw	fp,12(sp)
8112ee7c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112ee80:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
8112ee84:	d0a08203 	ldbu	r2,-32248(gp)
8112ee88:	10803fcc 	andi	r2,r2,255
8112ee8c:	10800058 	cmpnei	r2,r2,1
8112ee90:	1000161e 	bne	r2,zero,8112eeec <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ee94:	0005303a 	rdctl	r2,status
8112ee98:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ee9c:	e0ffff17 	ldw	r3,-4(fp)
8112eea0:	00bfff84 	movi	r2,-2
8112eea4:	1884703a 	and	r2,r3,r2
8112eea8:	1001703a 	wrctl	status,r2
  
  return context;
8112eeac:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8112eeb0:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
8112eeb4:	d0a09203 	ldbu	r2,-32184(gp)
8112eeb8:	10803fcc 	andi	r2,r2,255
8112eebc:	1000071e 	bne	r2,zero,8112eedc <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
8112eec0:	d0a08003 	ldbu	r2,-32256(gp)
8112eec4:	10803fcc 	andi	r2,r2,255
8112eec8:	10803fe0 	cmpeqi	r2,r2,255
8112eecc:	1000031e 	bne	r2,zero,8112eedc <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
8112eed0:	d0a08003 	ldbu	r2,-32256(gp)
8112eed4:	10800044 	addi	r2,r2,1
8112eed8:	d0a08005 	stb	r2,-32256(gp)
8112eedc:	e0bffd17 	ldw	r2,-12(fp)
8112eee0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112eee4:	e0bffe17 	ldw	r2,-8(fp)
8112eee8:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8112eeec:	0001883a 	nop
8112eef0:	e037883a 	mov	sp,fp
8112eef4:	df000017 	ldw	fp,0(sp)
8112eef8:	dec00104 	addi	sp,sp,4
8112eefc:	f800283a 	ret

8112ef00 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
8112ef00:	defff804 	addi	sp,sp,-32
8112ef04:	de00012e 	bgeu	sp,et,8112ef0c <OSSchedUnlock+0xc>
8112ef08:	003b68fa 	trap	3
8112ef0c:	dfc00715 	stw	ra,28(sp)
8112ef10:	df000615 	stw	fp,24(sp)
8112ef14:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8112ef18:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
8112ef1c:	d0a08203 	ldbu	r2,-32248(gp)
8112ef20:	10803fcc 	andi	r2,r2,255
8112ef24:	10800058 	cmpnei	r2,r2,1
8112ef28:	1000281e 	bne	r2,zero,8112efcc <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112ef2c:	0005303a 	rdctl	r2,status
8112ef30:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112ef34:	e0ffff17 	ldw	r3,-4(fp)
8112ef38:	00bfff84 	movi	r2,-2
8112ef3c:	1884703a 	and	r2,r3,r2
8112ef40:	1001703a 	wrctl	status,r2
  
  return context;
8112ef44:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8112ef48:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
8112ef4c:	d0a08003 	ldbu	r2,-32256(gp)
8112ef50:	10803fcc 	andi	r2,r2,255
8112ef54:	10001926 	beq	r2,zero,8112efbc <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
8112ef58:	d0a08003 	ldbu	r2,-32256(gp)
8112ef5c:	10bfffc4 	addi	r2,r2,-1
8112ef60:	d0a08005 	stb	r2,-32256(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
8112ef64:	d0a08003 	ldbu	r2,-32256(gp)
8112ef68:	10803fcc 	andi	r2,r2,255
8112ef6c:	10000e1e 	bne	r2,zero,8112efa8 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
8112ef70:	d0a09203 	ldbu	r2,-32184(gp)
8112ef74:	10803fcc 	andi	r2,r2,255
8112ef78:	1000061e 	bne	r2,zero,8112ef94 <OSSchedUnlock+0x94>
8112ef7c:	e0bffa17 	ldw	r2,-24(fp)
8112ef80:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ef84:	e0bffb17 	ldw	r2,-20(fp)
8112ef88:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
8112ef8c:	112fe480 	call	8112fe48 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
8112ef90:	00000e06 	br	8112efcc <OSSchedUnlock+0xcc>
8112ef94:	e0bffa17 	ldw	r2,-24(fp)
8112ef98:	e0bffc15 	stw	r2,-16(fp)
8112ef9c:	e0bffc17 	ldw	r2,-16(fp)
8112efa0:	1001703a 	wrctl	status,r2
8112efa4:	00000906 	br	8112efcc <OSSchedUnlock+0xcc>
8112efa8:	e0bffa17 	ldw	r2,-24(fp)
8112efac:	e0bffd15 	stw	r2,-12(fp)
8112efb0:	e0bffd17 	ldw	r2,-12(fp)
8112efb4:	1001703a 	wrctl	status,r2
8112efb8:	00000406 	br	8112efcc <OSSchedUnlock+0xcc>
8112efbc:	e0bffa17 	ldw	r2,-24(fp)
8112efc0:	e0bffe15 	stw	r2,-8(fp)
8112efc4:	e0bffe17 	ldw	r2,-8(fp)
8112efc8:	1001703a 	wrctl	status,r2
8112efcc:	0001883a 	nop
8112efd0:	e037883a 	mov	sp,fp
8112efd4:	dfc00117 	ldw	ra,4(sp)
8112efd8:	df000017 	ldw	fp,0(sp)
8112efdc:	dec00204 	addi	sp,sp,8
8112efe0:	f800283a 	ret

8112efe4 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
8112efe4:	defffe04 	addi	sp,sp,-8
8112efe8:	de00012e 	bgeu	sp,et,8112eff0 <OSStart+0xc>
8112efec:	003b68fa 	trap	3
8112eff0:	dfc00115 	stw	ra,4(sp)
8112eff4:	df000015 	stw	fp,0(sp)
8112eff8:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
8112effc:	d0a08203 	ldbu	r2,-32248(gp)
8112f000:	10803fcc 	andi	r2,r2,255
8112f004:	10000f1e 	bne	r2,zero,8112f044 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
8112f008:	112ff200 	call	8112ff20 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
8112f00c:	d0a08483 	ldbu	r2,-32238(gp)
8112f010:	d0a084c5 	stb	r2,-32237(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
8112f014:	d0a08483 	ldbu	r2,-32238(gp)
8112f018:	10c03fcc 	andi	r3,r2,255
8112f01c:	00a045b4 	movhi	r2,33046
8112f020:	10882104 	addi	r2,r2,8324
8112f024:	18c7883a 	add	r3,r3,r3
8112f028:	18c7883a 	add	r3,r3,r3
8112f02c:	10c5883a 	add	r2,r2,r3
8112f030:	10800017 	ldw	r2,0(r2)
8112f034:	d0a08d15 	stw	r2,-32204(gp)
        OSTCBCur      = OSTCBHighRdy;
8112f038:	d0a08d17 	ldw	r2,-32204(gp)
8112f03c:	d0a09315 	stw	r2,-32180(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
8112f040:	1140d600 	call	81140d60 <OSStartHighRdy>
    }
}
8112f044:	0001883a 	nop
8112f048:	e037883a 	mov	sp,fp
8112f04c:	dfc00117 	ldw	ra,4(sp)
8112f050:	df000017 	ldw	fp,0(sp)
8112f054:	dec00204 	addi	sp,sp,8
8112f058:	f800283a 	ret

8112f05c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
8112f05c:	defff904 	addi	sp,sp,-28
8112f060:	de00012e 	bgeu	sp,et,8112f068 <OSStatInit+0xc>
8112f064:	003b68fa 	trap	3
8112f068:	dfc00615 	stw	ra,24(sp)
8112f06c:	df000515 	stw	fp,20(sp)
8112f070:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8112f074:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
8112f078:	01000084 	movi	r4,2
8112f07c:	11369d00 	call	811369d0 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f080:	0005303a 	rdctl	r2,status
8112f084:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f088:	e0fffc17 	ldw	r3,-16(fp)
8112f08c:	00bfff84 	movi	r2,-2
8112f090:	1884703a 	and	r2,r3,r2
8112f094:	1001703a 	wrctl	status,r2
  
  return context;
8112f098:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
8112f09c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
8112f0a0:	d0208315 	stw	zero,-32244(gp)
8112f0a4:	e0bffb17 	ldw	r2,-20(fp)
8112f0a8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f0ac:	e0bffd17 	ldw	r2,-12(fp)
8112f0b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
8112f0b4:	01001904 	movi	r4,100
8112f0b8:	11369d00 	call	811369d0 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f0bc:	0005303a 	rdctl	r2,status
8112f0c0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f0c4:	e0fffe17 	ldw	r3,-8(fp)
8112f0c8:	00bfff84 	movi	r2,-2
8112f0cc:	1884703a 	and	r2,r3,r2
8112f0d0:	1001703a 	wrctl	status,r2
  
  return context;
8112f0d4:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
8112f0d8:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
8112f0dc:	d0a08317 	ldw	r2,-32244(gp)
8112f0e0:	d0a08915 	stw	r2,-32220(gp)
    OSStatRdy    = OS_TRUE;
8112f0e4:	00800044 	movi	r2,1
8112f0e8:	d0a09805 	stb	r2,-32160(gp)
8112f0ec:	e0bffb17 	ldw	r2,-20(fp)
8112f0f0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f0f4:	e0bfff17 	ldw	r2,-4(fp)
8112f0f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8112f0fc:	0001883a 	nop
8112f100:	e037883a 	mov	sp,fp
8112f104:	dfc00117 	ldw	ra,4(sp)
8112f108:	df000017 	ldw	fp,0(sp)
8112f10c:	dec00204 	addi	sp,sp,8
8112f110:	f800283a 	ret

8112f114 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
8112f114:	defff704 	addi	sp,sp,-36
8112f118:	de00012e 	bgeu	sp,et,8112f120 <OSTimeTick+0xc>
8112f11c:	003b68fa 	trap	3
8112f120:	dfc00815 	stw	ra,32(sp)
8112f124:	df000715 	stw	fp,28(sp)
8112f128:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8112f12c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
8112f130:	1140fb00 	call	81140fb0 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f134:	0005303a 	rdctl	r2,status
8112f138:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f13c:	e0fffd17 	ldw	r3,-12(fp)
8112f140:	00bfff84 	movi	r2,-2
8112f144:	1884703a 	and	r2,r3,r2
8112f148:	1001703a 	wrctl	status,r2
  
  return context;
8112f14c:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
8112f150:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
8112f154:	d0a09517 	ldw	r2,-32172(gp)
8112f158:	10800044 	addi	r2,r2,1
8112f15c:	d0a09515 	stw	r2,-32172(gp)
8112f160:	e0bffb17 	ldw	r2,-20(fp)
8112f164:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f168:	e0bfff17 	ldw	r2,-4(fp)
8112f16c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
8112f170:	d0a08203 	ldbu	r2,-32248(gp)
8112f174:	10803fcc 	andi	r2,r2,255
8112f178:	10800058 	cmpnei	r2,r2,1
8112f17c:	10006a1e 	bne	r2,zero,8112f328 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
8112f180:	d0a08603 	ldbu	r2,-32232(gp)
8112f184:	10803fcc 	andi	r2,r2,255
8112f188:	10c00060 	cmpeqi	r3,r2,1
8112f18c:	1800061e 	bne	r3,zero,8112f1a8 <OSTimeTick+0x94>
8112f190:	10c000a0 	cmpeqi	r3,r2,2
8112f194:	1800061e 	bne	r3,zero,8112f1b0 <OSTimeTick+0x9c>
8112f198:	10000a1e 	bne	r2,zero,8112f1c4 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
8112f19c:	00800044 	movi	r2,1
8112f1a0:	e0bffa05 	stb	r2,-24(fp)
                 break;
8112f1a4:	00000b06 	br	8112f1d4 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
8112f1a8:	e03ffa05 	stb	zero,-24(fp)
                 break;
8112f1ac:	00000906 	br	8112f1d4 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
8112f1b0:	00800044 	movi	r2,1
8112f1b4:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
8112f1b8:	00800044 	movi	r2,1
8112f1bc:	d0a08605 	stb	r2,-32232(gp)
                 break;
8112f1c0:	00000406 	br	8112f1d4 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
8112f1c4:	00800044 	movi	r2,1
8112f1c8:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
8112f1cc:	d0208605 	stb	zero,-32232(gp)
                 break;
8112f1d0:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
8112f1d4:	e0bffa03 	ldbu	r2,-24(fp)
8112f1d8:	10005226 	beq	r2,zero,8112f324 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
8112f1dc:	d0a08517 	ldw	r2,-32236(gp)
8112f1e0:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8112f1e4:	00004906 	br	8112f30c <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f1e8:	0005303a 	rdctl	r2,status
8112f1ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f1f0:	e0fffc17 	ldw	r3,-16(fp)
8112f1f4:	00bfff84 	movi	r2,-2
8112f1f8:	1884703a 	and	r2,r3,r2
8112f1fc:	1001703a 	wrctl	status,r2
  
  return context;
8112f200:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
8112f204:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
8112f208:	e0bff917 	ldw	r2,-28(fp)
8112f20c:	10800b8b 	ldhu	r2,46(r2)
8112f210:	10bfffcc 	andi	r2,r2,65535
8112f214:	10003626 	beq	r2,zero,8112f2f0 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
8112f218:	e0bff917 	ldw	r2,-28(fp)
8112f21c:	10800b8b 	ldhu	r2,46(r2)
8112f220:	10bfffc4 	addi	r2,r2,-1
8112f224:	1007883a 	mov	r3,r2
8112f228:	e0bff917 	ldw	r2,-28(fp)
8112f22c:	10c00b8d 	sth	r3,46(r2)
8112f230:	e0bff917 	ldw	r2,-28(fp)
8112f234:	10800b8b 	ldhu	r2,46(r2)
8112f238:	10bfffcc 	andi	r2,r2,65535
8112f23c:	10002c1e 	bne	r2,zero,8112f2f0 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8112f240:	e0bff917 	ldw	r2,-28(fp)
8112f244:	10800c03 	ldbu	r2,48(r2)
8112f248:	10803fcc 	andi	r2,r2,255
8112f24c:	10800dcc 	andi	r2,r2,55
8112f250:	10000b26 	beq	r2,zero,8112f280 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
8112f254:	e0bff917 	ldw	r2,-28(fp)
8112f258:	10c00c03 	ldbu	r3,48(r2)
8112f25c:	00bff204 	movi	r2,-56
8112f260:	1884703a 	and	r2,r3,r2
8112f264:	1007883a 	mov	r3,r2
8112f268:	e0bff917 	ldw	r2,-28(fp)
8112f26c:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
8112f270:	e0bff917 	ldw	r2,-28(fp)
8112f274:	00c00044 	movi	r3,1
8112f278:	10c00c45 	stb	r3,49(r2)
8112f27c:	00000206 	br	8112f288 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8112f280:	e0bff917 	ldw	r2,-28(fp)
8112f284:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
8112f288:	e0bff917 	ldw	r2,-28(fp)
8112f28c:	10800c03 	ldbu	r2,48(r2)
8112f290:	10803fcc 	andi	r2,r2,255
8112f294:	1080020c 	andi	r2,r2,8
8112f298:	1000151e 	bne	r2,zero,8112f2f0 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
8112f29c:	e0bff917 	ldw	r2,-28(fp)
8112f2a0:	10c00d83 	ldbu	r3,54(r2)
8112f2a4:	d0a08f03 	ldbu	r2,-32196(gp)
8112f2a8:	1884b03a 	or	r2,r3,r2
8112f2ac:	d0a08f05 	stb	r2,-32196(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8112f2b0:	e0bff917 	ldw	r2,-28(fp)
8112f2b4:	10800d03 	ldbu	r2,52(r2)
8112f2b8:	10c03fcc 	andi	r3,r2,255
8112f2bc:	e0bff917 	ldw	r2,-28(fp)
8112f2c0:	10800d03 	ldbu	r2,52(r2)
8112f2c4:	11003fcc 	andi	r4,r2,255
8112f2c8:	d0a08f44 	addi	r2,gp,-32195
8112f2cc:	2085883a 	add	r2,r4,r2
8112f2d0:	11000003 	ldbu	r4,0(r2)
8112f2d4:	e0bff917 	ldw	r2,-28(fp)
8112f2d8:	10800d43 	ldbu	r2,53(r2)
8112f2dc:	2084b03a 	or	r2,r4,r2
8112f2e0:	1009883a 	mov	r4,r2
8112f2e4:	d0a08f44 	addi	r2,gp,-32195
8112f2e8:	1885883a 	add	r2,r3,r2
8112f2ec:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
8112f2f0:	e0bff917 	ldw	r2,-28(fp)
8112f2f4:	10800517 	ldw	r2,20(r2)
8112f2f8:	e0bff915 	stw	r2,-28(fp)
8112f2fc:	e0bffb17 	ldw	r2,-20(fp)
8112f300:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f304:	e0bffe17 	ldw	r2,-8(fp)
8112f308:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8112f30c:	e0bff917 	ldw	r2,-28(fp)
8112f310:	10800c83 	ldbu	r2,50(r2)
8112f314:	10803fcc 	andi	r2,r2,255
8112f318:	10800a18 	cmpnei	r2,r2,40
8112f31c:	103fb21e 	bne	r2,zero,8112f1e8 <__reset+0xfb10f1e8>
8112f320:	00000106 	br	8112f328 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
8112f324:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
8112f328:	e037883a 	mov	sp,fp
8112f32c:	dfc00117 	ldw	ra,4(sp)
8112f330:	df000017 	ldw	fp,0(sp)
8112f334:	dec00204 	addi	sp,sp,8
8112f338:	f800283a 	ret

8112f33c <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8112f33c:	deffff04 	addi	sp,sp,-4
8112f340:	de00012e 	bgeu	sp,et,8112f348 <OSVersion+0xc>
8112f344:	003b68fa 	trap	3
8112f348:	df000015 	stw	fp,0(sp)
8112f34c:	d839883a 	mov	fp,sp
    return (OS_VERSION);
8112f350:	00804784 	movi	r2,286
}
8112f354:	e037883a 	mov	sp,fp
8112f358:	df000017 	ldw	fp,0(sp)
8112f35c:	dec00104 	addi	sp,sp,4
8112f360:	f800283a 	ret

8112f364 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
8112f364:	deffff04 	addi	sp,sp,-4
8112f368:	de00012e 	bgeu	sp,et,8112f370 <OS_Dummy+0xc>
8112f36c:	003b68fa 	trap	3
8112f370:	df000015 	stw	fp,0(sp)
8112f374:	d839883a 	mov	fp,sp
}
8112f378:	0001883a 	nop
8112f37c:	e037883a 	mov	sp,fp
8112f380:	df000017 	ldw	fp,0(sp)
8112f384:	dec00104 	addi	sp,sp,4
8112f388:	f800283a 	ret

8112f38c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
8112f38c:	defff804 	addi	sp,sp,-32
8112f390:	de00012e 	bgeu	sp,et,8112f398 <OS_EventTaskRdy+0xc>
8112f394:	003b68fa 	trap	3
8112f398:	dfc00715 	stw	ra,28(sp)
8112f39c:	df000615 	stw	fp,24(sp)
8112f3a0:	df000604 	addi	fp,sp,24
8112f3a4:	e13ffc15 	stw	r4,-16(fp)
8112f3a8:	e17ffd15 	stw	r5,-12(fp)
8112f3ac:	3007883a 	mov	r3,r6
8112f3b0:	3805883a 	mov	r2,r7
8112f3b4:	e0fffe05 	stb	r3,-8(fp)
8112f3b8:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
8112f3bc:	e0bffc17 	ldw	r2,-16(fp)
8112f3c0:	10800283 	ldbu	r2,10(r2)
8112f3c4:	10c03fcc 	andi	r3,r2,255
8112f3c8:	00a04534 	movhi	r2,33044
8112f3cc:	10988d04 	addi	r2,r2,25140
8112f3d0:	10c5883a 	add	r2,r2,r3
8112f3d4:	10800003 	ldbu	r2,0(r2)
8112f3d8:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
8112f3dc:	e0bffa03 	ldbu	r2,-24(fp)
8112f3e0:	e0fffc17 	ldw	r3,-16(fp)
8112f3e4:	1885883a 	add	r2,r3,r2
8112f3e8:	108002c4 	addi	r2,r2,11
8112f3ec:	10800003 	ldbu	r2,0(r2)
8112f3f0:	10c03fcc 	andi	r3,r2,255
8112f3f4:	00a04534 	movhi	r2,33044
8112f3f8:	10988d04 	addi	r2,r2,25140
8112f3fc:	10c5883a 	add	r2,r2,r3
8112f400:	10800003 	ldbu	r2,0(r2)
8112f404:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
8112f408:	e0bffa03 	ldbu	r2,-24(fp)
8112f40c:	100490fa 	slli	r2,r2,3
8112f410:	1007883a 	mov	r3,r2
8112f414:	e0bffa43 	ldbu	r2,-23(fp)
8112f418:	1885883a 	add	r2,r3,r2
8112f41c:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
8112f420:	e0fffa83 	ldbu	r3,-22(fp)
8112f424:	00a045b4 	movhi	r2,33046
8112f428:	10882104 	addi	r2,r2,8324
8112f42c:	18c7883a 	add	r3,r3,r3
8112f430:	18c7883a 	add	r3,r3,r3
8112f434:	10c5883a 	add	r2,r2,r3
8112f438:	10800017 	ldw	r2,0(r2)
8112f43c:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
8112f440:	e0bffb17 	ldw	r2,-20(fp)
8112f444:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
8112f448:	e0bffb17 	ldw	r2,-20(fp)
8112f44c:	e0fffd17 	ldw	r3,-12(fp)
8112f450:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
8112f454:	e0bffb17 	ldw	r2,-20(fp)
8112f458:	10800c03 	ldbu	r2,48(r2)
8112f45c:	1007883a 	mov	r3,r2
8112f460:	e0bffe03 	ldbu	r2,-8(fp)
8112f464:	0084303a 	nor	r2,zero,r2
8112f468:	1884703a 	and	r2,r3,r2
8112f46c:	1007883a 	mov	r3,r2
8112f470:	e0bffb17 	ldw	r2,-20(fp)
8112f474:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
8112f478:	e0bffb17 	ldw	r2,-20(fp)
8112f47c:	e0ffff03 	ldbu	r3,-4(fp)
8112f480:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
8112f484:	e0bffb17 	ldw	r2,-20(fp)
8112f488:	10800c03 	ldbu	r2,48(r2)
8112f48c:	10803fcc 	andi	r2,r2,255
8112f490:	1080020c 	andi	r2,r2,8
8112f494:	1000111e 	bne	r2,zero,8112f4dc <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
8112f498:	e0bffb17 	ldw	r2,-20(fp)
8112f49c:	10c00d83 	ldbu	r3,54(r2)
8112f4a0:	d0a08f03 	ldbu	r2,-32196(gp)
8112f4a4:	1884b03a 	or	r2,r3,r2
8112f4a8:	d0a08f05 	stb	r2,-32196(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
8112f4ac:	e0fffa03 	ldbu	r3,-24(fp)
8112f4b0:	e13ffa03 	ldbu	r4,-24(fp)
8112f4b4:	d0a08f44 	addi	r2,gp,-32195
8112f4b8:	2085883a 	add	r2,r4,r2
8112f4bc:	11000003 	ldbu	r4,0(r2)
8112f4c0:	e0bffb17 	ldw	r2,-20(fp)
8112f4c4:	10800d43 	ldbu	r2,53(r2)
8112f4c8:	2084b03a 	or	r2,r4,r2
8112f4cc:	1009883a 	mov	r4,r2
8112f4d0:	d0a08f44 	addi	r2,gp,-32195
8112f4d4:	1885883a 	add	r2,r3,r2
8112f4d8:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
8112f4dc:	e17ffc17 	ldw	r5,-16(fp)
8112f4e0:	e13ffb17 	ldw	r4,-20(fp)
8112f4e4:	112f79c0 	call	8112f79c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
8112f4e8:	e0bffb17 	ldw	r2,-20(fp)
8112f4ec:	10800817 	ldw	r2,32(r2)
8112f4f0:	10000826 	beq	r2,zero,8112f514 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8112f4f4:	e0bffb17 	ldw	r2,-20(fp)
8112f4f8:	10800817 	ldw	r2,32(r2)
8112f4fc:	100b883a 	mov	r5,r2
8112f500:	e13ffb17 	ldw	r4,-20(fp)
8112f504:	112f85c0 	call	8112f85c <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8112f508:	e0bffb17 	ldw	r2,-20(fp)
8112f50c:	e0fffc17 	ldw	r3,-16(fp)
8112f510:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
8112f514:	e0bffa83 	ldbu	r2,-22(fp)
}
8112f518:	e037883a 	mov	sp,fp
8112f51c:	dfc00117 	ldw	ra,4(sp)
8112f520:	df000017 	ldw	fp,0(sp)
8112f524:	dec00204 	addi	sp,sp,8
8112f528:	f800283a 	ret

8112f52c <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
8112f52c:	defffd04 	addi	sp,sp,-12
8112f530:	de00012e 	bgeu	sp,et,8112f538 <OS_EventTaskWait+0xc>
8112f534:	003b68fa 	trap	3
8112f538:	df000215 	stw	fp,8(sp)
8112f53c:	df000204 	addi	fp,sp,8
8112f540:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
8112f544:	d0a09317 	ldw	r2,-32180(gp)
8112f548:	e0ffff17 	ldw	r3,-4(fp)
8112f54c:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
8112f550:	d0a09317 	ldw	r2,-32180(gp)
8112f554:	10800d03 	ldbu	r2,52(r2)
8112f558:	10803fcc 	andi	r2,r2,255
8112f55c:	d0e09317 	ldw	r3,-32180(gp)
8112f560:	18c00d03 	ldbu	r3,52(r3)
8112f564:	18c03fcc 	andi	r3,r3,255
8112f568:	e13fff17 	ldw	r4,-4(fp)
8112f56c:	20c7883a 	add	r3,r4,r3
8112f570:	18c002c4 	addi	r3,r3,11
8112f574:	19000003 	ldbu	r4,0(r3)
8112f578:	d0e09317 	ldw	r3,-32180(gp)
8112f57c:	18c00d43 	ldbu	r3,53(r3)
8112f580:	20c6b03a 	or	r3,r4,r3
8112f584:	1809883a 	mov	r4,r3
8112f588:	e0ffff17 	ldw	r3,-4(fp)
8112f58c:	1885883a 	add	r2,r3,r2
8112f590:	108002c4 	addi	r2,r2,11
8112f594:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8112f598:	e0bfff17 	ldw	r2,-4(fp)
8112f59c:	10c00283 	ldbu	r3,10(r2)
8112f5a0:	d0a09317 	ldw	r2,-32180(gp)
8112f5a4:	10800d83 	ldbu	r2,54(r2)
8112f5a8:	1884b03a 	or	r2,r3,r2
8112f5ac:	1007883a 	mov	r3,r2
8112f5b0:	e0bfff17 	ldw	r2,-4(fp)
8112f5b4:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8112f5b8:	d0a09317 	ldw	r2,-32180(gp)
8112f5bc:	10800d03 	ldbu	r2,52(r2)
8112f5c0:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8112f5c4:	e0fffe03 	ldbu	r3,-8(fp)
8112f5c8:	e13ffe03 	ldbu	r4,-8(fp)
8112f5cc:	d0a08f44 	addi	r2,gp,-32195
8112f5d0:	2085883a 	add	r2,r4,r2
8112f5d4:	10800003 	ldbu	r2,0(r2)
8112f5d8:	1009883a 	mov	r4,r2
8112f5dc:	d0a09317 	ldw	r2,-32180(gp)
8112f5e0:	10800d43 	ldbu	r2,53(r2)
8112f5e4:	0084303a 	nor	r2,zero,r2
8112f5e8:	2084703a 	and	r2,r4,r2
8112f5ec:	1009883a 	mov	r4,r2
8112f5f0:	d0a08f44 	addi	r2,gp,-32195
8112f5f4:	1885883a 	add	r2,r3,r2
8112f5f8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8112f5fc:	e0fffe03 	ldbu	r3,-8(fp)
8112f600:	d0a08f44 	addi	r2,gp,-32195
8112f604:	1885883a 	add	r2,r3,r2
8112f608:	10800003 	ldbu	r2,0(r2)
8112f60c:	10803fcc 	andi	r2,r2,255
8112f610:	1000071e 	bne	r2,zero,8112f630 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8112f614:	d0a09317 	ldw	r2,-32180(gp)
8112f618:	10800d83 	ldbu	r2,54(r2)
8112f61c:	0084303a 	nor	r2,zero,r2
8112f620:	1007883a 	mov	r3,r2
8112f624:	d0a08f03 	ldbu	r2,-32196(gp)
8112f628:	1884703a 	and	r2,r3,r2
8112f62c:	d0a08f05 	stb	r2,-32196(gp)
    }
}
8112f630:	0001883a 	nop
8112f634:	e037883a 	mov	sp,fp
8112f638:	df000017 	ldw	fp,0(sp)
8112f63c:	dec00104 	addi	sp,sp,4
8112f640:	f800283a 	ret

8112f644 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
8112f644:	defffb04 	addi	sp,sp,-20
8112f648:	de00012e 	bgeu	sp,et,8112f650 <OS_EventTaskWaitMulti+0xc>
8112f64c:	003b68fa 	trap	3
8112f650:	df000415 	stw	fp,16(sp)
8112f654:	df000404 	addi	fp,sp,16
8112f658:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
8112f65c:	d0a09317 	ldw	r2,-32180(gp)
8112f660:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
8112f664:	d0a09317 	ldw	r2,-32180(gp)
8112f668:	e0ffff17 	ldw	r3,-4(fp)
8112f66c:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
8112f670:	e0bfff17 	ldw	r2,-4(fp)
8112f674:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
8112f678:	e0bffc17 	ldw	r2,-16(fp)
8112f67c:	10800017 	ldw	r2,0(r2)
8112f680:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8112f684:	00002006 	br	8112f708 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
8112f688:	d0a09317 	ldw	r2,-32180(gp)
8112f68c:	10800d03 	ldbu	r2,52(r2)
8112f690:	10803fcc 	andi	r2,r2,255
8112f694:	d0e09317 	ldw	r3,-32180(gp)
8112f698:	18c00d03 	ldbu	r3,52(r3)
8112f69c:	18c03fcc 	andi	r3,r3,255
8112f6a0:	e13ffd17 	ldw	r4,-12(fp)
8112f6a4:	20c7883a 	add	r3,r4,r3
8112f6a8:	18c002c4 	addi	r3,r3,11
8112f6ac:	19000003 	ldbu	r4,0(r3)
8112f6b0:	d0e09317 	ldw	r3,-32180(gp)
8112f6b4:	18c00d43 	ldbu	r3,53(r3)
8112f6b8:	20c6b03a 	or	r3,r4,r3
8112f6bc:	1809883a 	mov	r4,r3
8112f6c0:	e0fffd17 	ldw	r3,-12(fp)
8112f6c4:	1885883a 	add	r2,r3,r2
8112f6c8:	108002c4 	addi	r2,r2,11
8112f6cc:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8112f6d0:	e0bffd17 	ldw	r2,-12(fp)
8112f6d4:	10c00283 	ldbu	r3,10(r2)
8112f6d8:	d0a09317 	ldw	r2,-32180(gp)
8112f6dc:	10800d83 	ldbu	r2,54(r2)
8112f6e0:	1884b03a 	or	r2,r3,r2
8112f6e4:	1007883a 	mov	r3,r2
8112f6e8:	e0bffd17 	ldw	r2,-12(fp)
8112f6ec:	10c00285 	stb	r3,10(r2)
        pevents++;
8112f6f0:	e0bffc17 	ldw	r2,-16(fp)
8112f6f4:	10800104 	addi	r2,r2,4
8112f6f8:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8112f6fc:	e0bffc17 	ldw	r2,-16(fp)
8112f700:	10800017 	ldw	r2,0(r2)
8112f704:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8112f708:	e0bffd17 	ldw	r2,-12(fp)
8112f70c:	103fde1e 	bne	r2,zero,8112f688 <__reset+0xfb10f688>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8112f710:	d0a09317 	ldw	r2,-32180(gp)
8112f714:	10800d03 	ldbu	r2,52(r2)
8112f718:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8112f71c:	e0fffe03 	ldbu	r3,-8(fp)
8112f720:	e13ffe03 	ldbu	r4,-8(fp)
8112f724:	d0a08f44 	addi	r2,gp,-32195
8112f728:	2085883a 	add	r2,r4,r2
8112f72c:	10800003 	ldbu	r2,0(r2)
8112f730:	1009883a 	mov	r4,r2
8112f734:	d0a09317 	ldw	r2,-32180(gp)
8112f738:	10800d43 	ldbu	r2,53(r2)
8112f73c:	0084303a 	nor	r2,zero,r2
8112f740:	2084703a 	and	r2,r4,r2
8112f744:	1009883a 	mov	r4,r2
8112f748:	d0a08f44 	addi	r2,gp,-32195
8112f74c:	1885883a 	add	r2,r3,r2
8112f750:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8112f754:	e0fffe03 	ldbu	r3,-8(fp)
8112f758:	d0a08f44 	addi	r2,gp,-32195
8112f75c:	1885883a 	add	r2,r3,r2
8112f760:	10800003 	ldbu	r2,0(r2)
8112f764:	10803fcc 	andi	r2,r2,255
8112f768:	1000071e 	bne	r2,zero,8112f788 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8112f76c:	d0a09317 	ldw	r2,-32180(gp)
8112f770:	10800d83 	ldbu	r2,54(r2)
8112f774:	0084303a 	nor	r2,zero,r2
8112f778:	1007883a 	mov	r3,r2
8112f77c:	d0a08f03 	ldbu	r2,-32196(gp)
8112f780:	1884703a 	and	r2,r3,r2
8112f784:	d0a08f05 	stb	r2,-32196(gp)
    }
}
8112f788:	0001883a 	nop
8112f78c:	e037883a 	mov	sp,fp
8112f790:	df000017 	ldw	fp,0(sp)
8112f794:	dec00104 	addi	sp,sp,4
8112f798:	f800283a 	ret

8112f79c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
8112f79c:	defffc04 	addi	sp,sp,-16
8112f7a0:	de00012e 	bgeu	sp,et,8112f7a8 <OS_EventTaskRemove+0xc>
8112f7a4:	003b68fa 	trap	3
8112f7a8:	df000315 	stw	fp,12(sp)
8112f7ac:	df000304 	addi	fp,sp,12
8112f7b0:	e13ffe15 	stw	r4,-8(fp)
8112f7b4:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
8112f7b8:	e0bffe17 	ldw	r2,-8(fp)
8112f7bc:	10800d03 	ldbu	r2,52(r2)
8112f7c0:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
8112f7c4:	e0bffd03 	ldbu	r2,-12(fp)
8112f7c8:	e0fffd03 	ldbu	r3,-12(fp)
8112f7cc:	e13fff17 	ldw	r4,-4(fp)
8112f7d0:	20c7883a 	add	r3,r4,r3
8112f7d4:	18c002c4 	addi	r3,r3,11
8112f7d8:	18c00003 	ldbu	r3,0(r3)
8112f7dc:	1809883a 	mov	r4,r3
8112f7e0:	e0fffe17 	ldw	r3,-8(fp)
8112f7e4:	18c00d43 	ldbu	r3,53(r3)
8112f7e8:	00c6303a 	nor	r3,zero,r3
8112f7ec:	20c6703a 	and	r3,r4,r3
8112f7f0:	1809883a 	mov	r4,r3
8112f7f4:	e0ffff17 	ldw	r3,-4(fp)
8112f7f8:	1885883a 	add	r2,r3,r2
8112f7fc:	108002c4 	addi	r2,r2,11
8112f800:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
8112f804:	e0bffd03 	ldbu	r2,-12(fp)
8112f808:	e0ffff17 	ldw	r3,-4(fp)
8112f80c:	1885883a 	add	r2,r3,r2
8112f810:	108002c4 	addi	r2,r2,11
8112f814:	10800003 	ldbu	r2,0(r2)
8112f818:	10803fcc 	andi	r2,r2,255
8112f81c:	10000a1e 	bne	r2,zero,8112f848 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
8112f820:	e0bfff17 	ldw	r2,-4(fp)
8112f824:	10800283 	ldbu	r2,10(r2)
8112f828:	1007883a 	mov	r3,r2
8112f82c:	e0bffe17 	ldw	r2,-8(fp)
8112f830:	10800d83 	ldbu	r2,54(r2)
8112f834:	0084303a 	nor	r2,zero,r2
8112f838:	1884703a 	and	r2,r3,r2
8112f83c:	1007883a 	mov	r3,r2
8112f840:	e0bfff17 	ldw	r2,-4(fp)
8112f844:	10c00285 	stb	r3,10(r2)
    }
}
8112f848:	0001883a 	nop
8112f84c:	e037883a 	mov	sp,fp
8112f850:	df000017 	ldw	fp,0(sp)
8112f854:	dec00104 	addi	sp,sp,4
8112f858:	f800283a 	ret

8112f85c <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
8112f85c:	defffa04 	addi	sp,sp,-24
8112f860:	de00012e 	bgeu	sp,et,8112f868 <OS_EventTaskRemoveMulti+0xc>
8112f864:	003b68fa 	trap	3
8112f868:	df000515 	stw	fp,20(sp)
8112f86c:	df000504 	addi	fp,sp,20
8112f870:	e13ffe15 	stw	r4,-8(fp)
8112f874:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
8112f878:	e0bffe17 	ldw	r2,-8(fp)
8112f87c:	10800d03 	ldbu	r2,52(r2)
8112f880:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
8112f884:	e0bffe17 	ldw	r2,-8(fp)
8112f888:	10800d83 	ldbu	r2,54(r2)
8112f88c:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
8112f890:	e0bffe17 	ldw	r2,-8(fp)
8112f894:	10800d43 	ldbu	r2,53(r2)
8112f898:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
8112f89c:	e0bfff17 	ldw	r2,-4(fp)
8112f8a0:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
8112f8a4:	e0bffb17 	ldw	r2,-20(fp)
8112f8a8:	10800017 	ldw	r2,0(r2)
8112f8ac:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8112f8b0:	00002506 	br	8112f948 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
8112f8b4:	e0bffd03 	ldbu	r2,-12(fp)
8112f8b8:	e0fffd03 	ldbu	r3,-12(fp)
8112f8bc:	e13ffc17 	ldw	r4,-16(fp)
8112f8c0:	20c7883a 	add	r3,r4,r3
8112f8c4:	18c002c4 	addi	r3,r3,11
8112f8c8:	18c00003 	ldbu	r3,0(r3)
8112f8cc:	1809883a 	mov	r4,r3
8112f8d0:	e0fffd83 	ldbu	r3,-10(fp)
8112f8d4:	00c6303a 	nor	r3,zero,r3
8112f8d8:	20c6703a 	and	r3,r4,r3
8112f8dc:	1809883a 	mov	r4,r3
8112f8e0:	e0fffc17 	ldw	r3,-16(fp)
8112f8e4:	1885883a 	add	r2,r3,r2
8112f8e8:	108002c4 	addi	r2,r2,11
8112f8ec:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
8112f8f0:	e0bffd03 	ldbu	r2,-12(fp)
8112f8f4:	e0fffc17 	ldw	r3,-16(fp)
8112f8f8:	1885883a 	add	r2,r3,r2
8112f8fc:	108002c4 	addi	r2,r2,11
8112f900:	10800003 	ldbu	r2,0(r2)
8112f904:	10803fcc 	andi	r2,r2,255
8112f908:	1000091e 	bne	r2,zero,8112f930 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8112f90c:	e0bffc17 	ldw	r2,-16(fp)
8112f910:	10800283 	ldbu	r2,10(r2)
8112f914:	1007883a 	mov	r3,r2
8112f918:	e0bffd43 	ldbu	r2,-11(fp)
8112f91c:	0084303a 	nor	r2,zero,r2
8112f920:	1884703a 	and	r2,r3,r2
8112f924:	1007883a 	mov	r3,r2
8112f928:	e0bffc17 	ldw	r2,-16(fp)
8112f92c:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
8112f930:	e0bffb17 	ldw	r2,-20(fp)
8112f934:	10800104 	addi	r2,r2,4
8112f938:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
8112f93c:	e0bffb17 	ldw	r2,-20(fp)
8112f940:	10800017 	ldw	r2,0(r2)
8112f944:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8112f948:	e0bffc17 	ldw	r2,-16(fp)
8112f94c:	103fd91e 	bne	r2,zero,8112f8b4 <__reset+0xfb10f8b4>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
8112f950:	0001883a 	nop
8112f954:	e037883a 	mov	sp,fp
8112f958:	df000017 	ldw	fp,0(sp)
8112f95c:	dec00104 	addi	sp,sp,4
8112f960:	f800283a 	ret

8112f964 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
8112f964:	defffc04 	addi	sp,sp,-16
8112f968:	de00012e 	bgeu	sp,et,8112f970 <OS_EventWaitListInit+0xc>
8112f96c:	003b68fa 	trap	3
8112f970:	df000315 	stw	fp,12(sp)
8112f974:	df000304 	addi	fp,sp,12
8112f978:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
8112f97c:	e0bfff17 	ldw	r2,-4(fp)
8112f980:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
8112f984:	e0bfff17 	ldw	r2,-4(fp)
8112f988:	108002c4 	addi	r2,r2,11
8112f98c:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112f990:	e03ffe05 	stb	zero,-8(fp)
8112f994:	00000706 	br	8112f9b4 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
8112f998:	e0bffd17 	ldw	r2,-12(fp)
8112f99c:	10c00044 	addi	r3,r2,1
8112f9a0:	e0fffd15 	stw	r3,-12(fp)
8112f9a4:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8112f9a8:	e0bffe03 	ldbu	r2,-8(fp)
8112f9ac:	10800044 	addi	r2,r2,1
8112f9b0:	e0bffe05 	stb	r2,-8(fp)
8112f9b4:	e0bffe03 	ldbu	r2,-8(fp)
8112f9b8:	108001b0 	cmpltui	r2,r2,6
8112f9bc:	103ff61e 	bne	r2,zero,8112f998 <__reset+0xfb10f998>
        *ptbl++ = 0;
    }
}
8112f9c0:	0001883a 	nop
8112f9c4:	e037883a 	mov	sp,fp
8112f9c8:	df000017 	ldw	fp,0(sp)
8112f9cc:	dec00104 	addi	sp,sp,4
8112f9d0:	f800283a 	ret

8112f9d4 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
8112f9d4:	defffb04 	addi	sp,sp,-20
8112f9d8:	de00012e 	bgeu	sp,et,8112f9e0 <OS_InitEventList+0xc>
8112f9dc:	003b68fa 	trap	3
8112f9e0:	dfc00415 	stw	ra,16(sp)
8112f9e4:	df000315 	stw	fp,12(sp)
8112f9e8:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8112f9ec:	01434004 	movi	r5,3328
8112f9f0:	012045b4 	movhi	r4,33046
8112f9f4:	21014b04 	addi	r4,r4,1324
8112f9f8:	112fd7c0 	call	8112fd7c <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8112f9fc:	00a045b4 	movhi	r2,33046
8112fa00:	10814b04 	addi	r2,r2,1324
8112fa04:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8112fa08:	00a045b4 	movhi	r2,33046
8112fa0c:	10815804 	addi	r2,r2,1376
8112fa10:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8112fa14:	e03ffd0d 	sth	zero,-12(fp)
8112fa18:	00001306 	br	8112fa68 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8112fa1c:	e0bffe17 	ldw	r2,-8(fp)
8112fa20:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
8112fa24:	e0bffe17 	ldw	r2,-8(fp)
8112fa28:	e0ffff17 	ldw	r3,-4(fp)
8112fa2c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
8112fa30:	e0bffe17 	ldw	r2,-8(fp)
8112fa34:	00c00fc4 	movi	r3,63
8112fa38:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
8112fa3c:	e0bffe17 	ldw	r2,-8(fp)
8112fa40:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
8112fa44:	e0bffe17 	ldw	r2,-8(fp)
8112fa48:	10800d04 	addi	r2,r2,52
8112fa4c:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
8112fa50:	e0bfff17 	ldw	r2,-4(fp)
8112fa54:	10800d04 	addi	r2,r2,52
8112fa58:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8112fa5c:	e0bffd0b 	ldhu	r2,-12(fp)
8112fa60:	10800044 	addi	r2,r2,1
8112fa64:	e0bffd0d 	sth	r2,-12(fp)
8112fa68:	e0bffd0b 	ldhu	r2,-12(fp)
8112fa6c:	10800ff0 	cmpltui	r2,r2,63
8112fa70:	103fea1e 	bne	r2,zero,8112fa1c <__reset+0xfb10fa1c>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
8112fa74:	e0bffe17 	ldw	r2,-8(fp)
8112fa78:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
8112fa7c:	e0bffe17 	ldw	r2,-8(fp)
8112fa80:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
8112fa84:	e0bffe17 	ldw	r2,-8(fp)
8112fa88:	00c00fc4 	movi	r3,63
8112fa8c:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
8112fa90:	e0bffe17 	ldw	r2,-8(fp)
8112fa94:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
8112fa98:	00a045b4 	movhi	r2,33046
8112fa9c:	10814b04 	addi	r2,r2,1324
8112faa0:	d0a09115 	stw	r2,-32188(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
8112faa4:	0001883a 	nop
8112faa8:	e037883a 	mov	sp,fp
8112faac:	dfc00117 	ldw	ra,4(sp)
8112fab0:	df000017 	ldw	fp,0(sp)
8112fab4:	dec00204 	addi	sp,sp,8
8112fab8:	f800283a 	ret

8112fabc <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
8112fabc:	deffff04 	addi	sp,sp,-4
8112fac0:	de00012e 	bgeu	sp,et,8112fac8 <OS_InitMisc+0xc>
8112fac4:	003b68fa 	trap	3
8112fac8:	df000015 	stw	fp,0(sp)
8112facc:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
8112fad0:	d0209515 	stw	zero,-32172(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
8112fad4:	d0209205 	stb	zero,-32184(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8112fad8:	d0208005 	stb	zero,-32256(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
8112fadc:	d0208b45 	stb	zero,-32211(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
8112fae0:	d0208205 	stb	zero,-32248(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
8112fae4:	d0208715 	stw	zero,-32228(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8112fae8:	d0208315 	stw	zero,-32244(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8112faec:	d0209915 	stw	zero,-32156(gp)
    OSIdleCtrMax  = 0L;
8112faf0:	d0208915 	stw	zero,-32220(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
8112faf4:	d0209805 	stb	zero,-32160(gp)
#endif
}
8112faf8:	0001883a 	nop
8112fafc:	e037883a 	mov	sp,fp
8112fb00:	df000017 	ldw	fp,0(sp)
8112fb04:	dec00104 	addi	sp,sp,4
8112fb08:	f800283a 	ret

8112fb0c <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8112fb0c:	defffd04 	addi	sp,sp,-12
8112fb10:	de00012e 	bgeu	sp,et,8112fb18 <OS_InitRdyList+0xc>
8112fb14:	003b68fa 	trap	3
8112fb18:	df000215 	stw	fp,8(sp)
8112fb1c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
8112fb20:	d0208f05 	stb	zero,-32196(gp)
    prdytbl       = &OSRdyTbl[0];
8112fb24:	d0a08f44 	addi	r2,gp,-32195
8112fb28:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8112fb2c:	e03ffe05 	stb	zero,-8(fp)
8112fb30:	00000706 	br	8112fb50 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
8112fb34:	e0bfff17 	ldw	r2,-4(fp)
8112fb38:	10c00044 	addi	r3,r2,1
8112fb3c:	e0ffff15 	stw	r3,-4(fp)
8112fb40:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8112fb44:	e0bffe03 	ldbu	r2,-8(fp)
8112fb48:	10800044 	addi	r2,r2,1
8112fb4c:	e0bffe05 	stb	r2,-8(fp)
8112fb50:	e0bffe03 	ldbu	r2,-8(fp)
8112fb54:	108001b0 	cmpltui	r2,r2,6
8112fb58:	103ff61e 	bne	r2,zero,8112fb34 <__reset+0xfb10fb34>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8112fb5c:	d02084c5 	stb	zero,-32237(gp)
    OSPrioHighRdy = 0;
8112fb60:	d0208485 	stb	zero,-32238(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
8112fb64:	d0208d15 	stw	zero,-32204(gp)
    OSTCBCur      = (OS_TCB *)0;
8112fb68:	d0209315 	stw	zero,-32180(gp)
}
8112fb6c:	0001883a 	nop
8112fb70:	e037883a 	mov	sp,fp
8112fb74:	df000017 	ldw	fp,0(sp)
8112fb78:	dec00104 	addi	sp,sp,4
8112fb7c:	f800283a 	ret

8112fb80 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
8112fb80:	defff804 	addi	sp,sp,-32
8112fb84:	de00012e 	bgeu	sp,et,8112fb8c <OS_InitTaskIdle+0xc>
8112fb88:	003b68fa 	trap	3
8112fb8c:	dfc00715 	stw	ra,28(sp)
8112fb90:	df000615 	stw	fp,24(sp)
8112fb94:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
8112fb98:	008000c4 	movi	r2,3
8112fb9c:	d8800415 	stw	r2,16(sp)
8112fba0:	d8000315 	stw	zero,12(sp)
8112fba4:	00810004 	movi	r2,1024
8112fba8:	d8800215 	stw	r2,8(sp)
8112fbac:	00a045b4 	movhi	r2,33046
8112fbb0:	10bd4b04 	addi	r2,r2,-2772
8112fbb4:	d8800115 	stw	r2,4(sp)
8112fbb8:	00bfffd4 	movui	r2,65535
8112fbbc:	d8800015 	stw	r2,0(sp)
8112fbc0:	01c00a04 	movi	r7,40
8112fbc4:	01a045b4 	movhi	r6,33046
8112fbc8:	31814a04 	addi	r6,r6,1320
8112fbcc:	000b883a 	mov	r5,zero
8112fbd0:	012044f4 	movhi	r4,33043
8112fbd4:	21001d04 	addi	r4,r4,116
8112fbd8:	11358b00 	call	811358b0 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
8112fbdc:	e1bfff04 	addi	r6,fp,-4
8112fbe0:	01604534 	movhi	r5,33044
8112fbe4:	2958cd04 	addi	r5,r5,25396
8112fbe8:	01000a04 	movi	r4,40
8112fbec:	11360e00 	call	811360e0 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
8112fbf0:	0001883a 	nop
8112fbf4:	e037883a 	mov	sp,fp
8112fbf8:	dfc00117 	ldw	ra,4(sp)
8112fbfc:	df000017 	ldw	fp,0(sp)
8112fc00:	dec00204 	addi	sp,sp,8
8112fc04:	f800283a 	ret

8112fc08 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8112fc08:	defff804 	addi	sp,sp,-32
8112fc0c:	de00012e 	bgeu	sp,et,8112fc14 <OS_InitTaskStat+0xc>
8112fc10:	003b68fa 	trap	3
8112fc14:	dfc00715 	stw	ra,28(sp)
8112fc18:	df000615 	stw	fp,24(sp)
8112fc1c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
8112fc20:	008000c4 	movi	r2,3
8112fc24:	d8800415 	stw	r2,16(sp)
8112fc28:	d8000315 	stw	zero,12(sp)
8112fc2c:	00810004 	movi	r2,1024
8112fc30:	d8800215 	stw	r2,8(sp)
8112fc34:	00a045b4 	movhi	r2,33046
8112fc38:	10b6eb04 	addi	r2,r2,-9300
8112fc3c:	d8800115 	stw	r2,4(sp)
8112fc40:	00bfff94 	movui	r2,65534
8112fc44:	d8800015 	stw	r2,0(sp)
8112fc48:	01c009c4 	movi	r7,39
8112fc4c:	01a045b4 	movhi	r6,33046
8112fc50:	31baea04 	addi	r6,r6,-5208
8112fc54:	000b883a 	mov	r5,zero
8112fc58:	012044f4 	movhi	r4,33043
8112fc5c:	21003604 	addi	r4,r4,216
8112fc60:	11358b00 	call	811358b0 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
8112fc64:	e1bfff04 	addi	r6,fp,-4
8112fc68:	01604534 	movhi	r5,33044
8112fc6c:	2958d104 	addi	r5,r5,25412
8112fc70:	010009c4 	movi	r4,39
8112fc74:	11360e00 	call	811360e0 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
8112fc78:	0001883a 	nop
8112fc7c:	e037883a 	mov	sp,fp
8112fc80:	dfc00117 	ldw	ra,4(sp)
8112fc84:	df000017 	ldw	fp,0(sp)
8112fc88:	dec00204 	addi	sp,sp,8
8112fc8c:	f800283a 	ret

8112fc90 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
8112fc90:	defffb04 	addi	sp,sp,-20
8112fc94:	de00012e 	bgeu	sp,et,8112fc9c <OS_InitTCBList+0xc>
8112fc98:	003b68fa 	trap	3
8112fc9c:	dfc00415 	stw	ra,16(sp)
8112fca0:	df000315 	stw	fp,12(sp)
8112fca4:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
8112fca8:	01439604 	movi	r5,3672
8112fcac:	012045b4 	movhi	r4,33046
8112fcb0:	21048b04 	addi	r4,r4,4652
8112fcb4:	112fd7c0 	call	8112fd7c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
8112fcb8:	01402904 	movi	r5,164
8112fcbc:	012045b4 	movhi	r4,33046
8112fcc0:	21082104 	addi	r4,r4,8324
8112fcc4:	112fd7c0 	call	8112fd7c <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
8112fcc8:	00a045b4 	movhi	r2,33046
8112fccc:	10848b04 	addi	r2,r2,4652
8112fcd0:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
8112fcd4:	00a045b4 	movhi	r2,33046
8112fcd8:	1084a604 	addi	r2,r2,4760
8112fcdc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8112fce0:	e03ffd05 	stb	zero,-12(fp)
8112fce4:	00001106 	br	8112fd2c <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
8112fce8:	e0bffe17 	ldw	r2,-8(fp)
8112fcec:	e0ffff17 	ldw	r3,-4(fp)
8112fcf0:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
8112fcf4:	e0bffe17 	ldw	r2,-8(fp)
8112fcf8:	00c00fc4 	movi	r3,63
8112fcfc:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8112fd00:	e0bffe17 	ldw	r2,-8(fp)
8112fd04:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
8112fd08:	e0bffe17 	ldw	r2,-8(fp)
8112fd0c:	10801b04 	addi	r2,r2,108
8112fd10:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
8112fd14:	e0bfff17 	ldw	r2,-4(fp)
8112fd18:	10801b04 	addi	r2,r2,108
8112fd1c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
8112fd20:	e0bffd03 	ldbu	r2,-12(fp)
8112fd24:	10800044 	addi	r2,r2,1
8112fd28:	e0bffd05 	stb	r2,-12(fp)
8112fd2c:	e0bffd03 	ldbu	r2,-12(fp)
8112fd30:	10800870 	cmpltui	r2,r2,33
8112fd34:	103fec1e 	bne	r2,zero,8112fce8 <__reset+0xfb10fce8>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
8112fd38:	e0bffe17 	ldw	r2,-8(fp)
8112fd3c:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
8112fd40:	e0bffe17 	ldw	r2,-8(fp)
8112fd44:	00c00fc4 	movi	r3,63
8112fd48:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
8112fd4c:	e0bffe17 	ldw	r2,-8(fp)
8112fd50:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
8112fd54:	d0208515 	stw	zero,-32236(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
8112fd58:	00a045b4 	movhi	r2,33046
8112fd5c:	10848b04 	addi	r2,r2,4652
8112fd60:	d0a08a15 	stw	r2,-32216(gp)
}
8112fd64:	0001883a 	nop
8112fd68:	e037883a 	mov	sp,fp
8112fd6c:	dfc00117 	ldw	ra,4(sp)
8112fd70:	df000017 	ldw	fp,0(sp)
8112fd74:	dec00204 	addi	sp,sp,8
8112fd78:	f800283a 	ret

8112fd7c <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
8112fd7c:	defffd04 	addi	sp,sp,-12
8112fd80:	de00012e 	bgeu	sp,et,8112fd88 <OS_MemClr+0xc>
8112fd84:	003b68fa 	trap	3
8112fd88:	df000215 	stw	fp,8(sp)
8112fd8c:	df000204 	addi	fp,sp,8
8112fd90:	e13ffe15 	stw	r4,-8(fp)
8112fd94:	2805883a 	mov	r2,r5
8112fd98:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8112fd9c:	00000706 	br	8112fdbc <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
8112fda0:	e0bffe17 	ldw	r2,-8(fp)
8112fda4:	10c00044 	addi	r3,r2,1
8112fda8:	e0fffe15 	stw	r3,-8(fp)
8112fdac:	10000005 	stb	zero,0(r2)
        size--;
8112fdb0:	e0bfff0b 	ldhu	r2,-4(fp)
8112fdb4:	10bfffc4 	addi	r2,r2,-1
8112fdb8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
8112fdbc:	e0bfff0b 	ldhu	r2,-4(fp)
8112fdc0:	103ff71e 	bne	r2,zero,8112fda0 <__reset+0xfb10fda0>
        *pdest++ = (INT8U)0;
        size--;
    }
}
8112fdc4:	0001883a 	nop
8112fdc8:	e037883a 	mov	sp,fp
8112fdcc:	df000017 	ldw	fp,0(sp)
8112fdd0:	dec00104 	addi	sp,sp,4
8112fdd4:	f800283a 	ret

8112fdd8 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
8112fdd8:	defffc04 	addi	sp,sp,-16
8112fddc:	de00012e 	bgeu	sp,et,8112fde4 <OS_MemCopy+0xc>
8112fde0:	003b68fa 	trap	3
8112fde4:	df000315 	stw	fp,12(sp)
8112fde8:	df000304 	addi	fp,sp,12
8112fdec:	e13ffd15 	stw	r4,-12(fp)
8112fdf0:	e17ffe15 	stw	r5,-8(fp)
8112fdf4:	3005883a 	mov	r2,r6
8112fdf8:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8112fdfc:	00000b06 	br	8112fe2c <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
8112fe00:	e0bffd17 	ldw	r2,-12(fp)
8112fe04:	10c00044 	addi	r3,r2,1
8112fe08:	e0fffd15 	stw	r3,-12(fp)
8112fe0c:	e0fffe17 	ldw	r3,-8(fp)
8112fe10:	19000044 	addi	r4,r3,1
8112fe14:	e13ffe15 	stw	r4,-8(fp)
8112fe18:	18c00003 	ldbu	r3,0(r3)
8112fe1c:	10c00005 	stb	r3,0(r2)
        size--;
8112fe20:	e0bfff0b 	ldhu	r2,-4(fp)
8112fe24:	10bfffc4 	addi	r2,r2,-1
8112fe28:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
8112fe2c:	e0bfff0b 	ldhu	r2,-4(fp)
8112fe30:	103ff31e 	bne	r2,zero,8112fe00 <__reset+0xfb10fe00>
        *pdest++ = *psrc++;
        size--;
    }
}
8112fe34:	0001883a 	nop
8112fe38:	e037883a 	mov	sp,fp
8112fe3c:	df000017 	ldw	fp,0(sp)
8112fe40:	dec00104 	addi	sp,sp,4
8112fe44:	f800283a 	ret

8112fe48 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
8112fe48:	defffb04 	addi	sp,sp,-20
8112fe4c:	de00012e 	bgeu	sp,et,8112fe54 <OS_Sched+0xc>
8112fe50:	003b68fa 	trap	3
8112fe54:	dfc00415 	stw	ra,16(sp)
8112fe58:	df000315 	stw	fp,12(sp)
8112fe5c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8112fe60:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112fe64:	0005303a 	rdctl	r2,status
8112fe68:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112fe6c:	e0ffff17 	ldw	r3,-4(fp)
8112fe70:	00bfff84 	movi	r2,-2
8112fe74:	1884703a 	and	r2,r3,r2
8112fe78:	1001703a 	wrctl	status,r2
  
  return context;
8112fe7c:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
8112fe80:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
8112fe84:	d0a09203 	ldbu	r2,-32184(gp)
8112fe88:	10803fcc 	andi	r2,r2,255
8112fe8c:	10001a1e 	bne	r2,zero,8112fef8 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
8112fe90:	d0a08003 	ldbu	r2,-32256(gp)
8112fe94:	10803fcc 	andi	r2,r2,255
8112fe98:	1000171e 	bne	r2,zero,8112fef8 <OS_Sched+0xb0>
            OS_SchedNew();
8112fe9c:	112ff200 	call	8112ff20 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
8112fea0:	d0e08483 	ldbu	r3,-32238(gp)
8112fea4:	d0a084c3 	ldbu	r2,-32237(gp)
8112fea8:	18c03fcc 	andi	r3,r3,255
8112feac:	10803fcc 	andi	r2,r2,255
8112feb0:	18801126 	beq	r3,r2,8112fef8 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
8112feb4:	d0a08483 	ldbu	r2,-32238(gp)
8112feb8:	10c03fcc 	andi	r3,r2,255
8112febc:	00a045b4 	movhi	r2,33046
8112fec0:	10882104 	addi	r2,r2,8324
8112fec4:	18c7883a 	add	r3,r3,r3
8112fec8:	18c7883a 	add	r3,r3,r3
8112fecc:	10c5883a 	add	r2,r2,r3
8112fed0:	10800017 	ldw	r2,0(r2)
8112fed4:	d0a08d15 	stw	r2,-32204(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
8112fed8:	d0a08d17 	ldw	r2,-32204(gp)
8112fedc:	10c00e17 	ldw	r3,56(r2)
8112fee0:	18c00044 	addi	r3,r3,1
8112fee4:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
8112fee8:	d0a08717 	ldw	r2,-32228(gp)
8112feec:	10800044 	addi	r2,r2,1
8112fef0:	d0a08715 	stw	r2,-32228(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
8112fef4:	1140cc40 	call	81140cc4 <OSCtxSw>
8112fef8:	e0bffd17 	ldw	r2,-12(fp)
8112fefc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112ff00:	e0bffe17 	ldw	r2,-8(fp)
8112ff04:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
8112ff08:	0001883a 	nop
8112ff0c:	e037883a 	mov	sp,fp
8112ff10:	dfc00117 	ldw	ra,4(sp)
8112ff14:	df000017 	ldw	fp,0(sp)
8112ff18:	dec00204 	addi	sp,sp,8
8112ff1c:	f800283a 	ret

8112ff20 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
8112ff20:	defffe04 	addi	sp,sp,-8
8112ff24:	de00012e 	bgeu	sp,et,8112ff2c <OS_SchedNew+0xc>
8112ff28:	003b68fa 	trap	3
8112ff2c:	df000115 	stw	fp,4(sp)
8112ff30:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
8112ff34:	d0a08f03 	ldbu	r2,-32196(gp)
8112ff38:	10c03fcc 	andi	r3,r2,255
8112ff3c:	00a04534 	movhi	r2,33044
8112ff40:	10988d04 	addi	r2,r2,25140
8112ff44:	10c5883a 	add	r2,r2,r3
8112ff48:	10800003 	ldbu	r2,0(r2)
8112ff4c:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
8112ff50:	e0bfff03 	ldbu	r2,-4(fp)
8112ff54:	100490fa 	slli	r2,r2,3
8112ff58:	1009883a 	mov	r4,r2
8112ff5c:	e0ffff03 	ldbu	r3,-4(fp)
8112ff60:	d0a08f44 	addi	r2,gp,-32195
8112ff64:	1885883a 	add	r2,r3,r2
8112ff68:	10800003 	ldbu	r2,0(r2)
8112ff6c:	10c03fcc 	andi	r3,r2,255
8112ff70:	00a04534 	movhi	r2,33044
8112ff74:	10988d04 	addi	r2,r2,25140
8112ff78:	10c5883a 	add	r2,r2,r3
8112ff7c:	10800003 	ldbu	r2,0(r2)
8112ff80:	2085883a 	add	r2,r4,r2
8112ff84:	d0a08485 	stb	r2,-32238(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
8112ff88:	0001883a 	nop
8112ff8c:	e037883a 	mov	sp,fp
8112ff90:	df000017 	ldw	fp,0(sp)
8112ff94:	dec00104 	addi	sp,sp,4
8112ff98:	f800283a 	ret

8112ff9c <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
8112ff9c:	defffc04 	addi	sp,sp,-16
8112ffa0:	de00012e 	bgeu	sp,et,8112ffa8 <OS_StrCopy+0xc>
8112ffa4:	003b68fa 	trap	3
8112ffa8:	df000315 	stw	fp,12(sp)
8112ffac:	df000304 	addi	fp,sp,12
8112ffb0:	e13ffe15 	stw	r4,-8(fp)
8112ffb4:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
8112ffb8:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
8112ffbc:	00000b06 	br	8112ffec <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
8112ffc0:	e0bffe17 	ldw	r2,-8(fp)
8112ffc4:	10c00044 	addi	r3,r2,1
8112ffc8:	e0fffe15 	stw	r3,-8(fp)
8112ffcc:	e0ffff17 	ldw	r3,-4(fp)
8112ffd0:	19000044 	addi	r4,r3,1
8112ffd4:	e13fff15 	stw	r4,-4(fp)
8112ffd8:	18c00003 	ldbu	r3,0(r3)
8112ffdc:	10c00005 	stb	r3,0(r2)
        len++;
8112ffe0:	e0bffd03 	ldbu	r2,-12(fp)
8112ffe4:	10800044 	addi	r2,r2,1
8112ffe8:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8112ffec:	e0bfff17 	ldw	r2,-4(fp)
8112fff0:	10800003 	ldbu	r2,0(r2)
8112fff4:	10803fcc 	andi	r2,r2,255
8112fff8:	103ff11e 	bne	r2,zero,8112ffc0 <__reset+0xfb10ffc0>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
8112fffc:	e0bffe17 	ldw	r2,-8(fp)
81130000:	10000005 	stb	zero,0(r2)
    return (len);
81130004:	e0bffd03 	ldbu	r2,-12(fp)
}
81130008:	e037883a 	mov	sp,fp
8113000c:	df000017 	ldw	fp,0(sp)
81130010:	dec00104 	addi	sp,sp,4
81130014:	f800283a 	ret

81130018 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81130018:	defffd04 	addi	sp,sp,-12
8113001c:	de00012e 	bgeu	sp,et,81130024 <OS_StrLen+0xc>
81130020:	003b68fa 	trap	3
81130024:	df000215 	stw	fp,8(sp)
81130028:	df000204 	addi	fp,sp,8
8113002c:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
81130030:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81130034:	00000606 	br	81130050 <OS_StrLen+0x38>
        psrc++;
81130038:	e0bfff17 	ldw	r2,-4(fp)
8113003c:	10800044 	addi	r2,r2,1
81130040:	e0bfff15 	stw	r2,-4(fp)
        len++;
81130044:	e0bffe03 	ldbu	r2,-8(fp)
81130048:	10800044 	addi	r2,r2,1
8113004c:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81130050:	e0bfff17 	ldw	r2,-4(fp)
81130054:	10800003 	ldbu	r2,0(r2)
81130058:	10803fcc 	andi	r2,r2,255
8113005c:	103ff61e 	bne	r2,zero,81130038 <__reset+0xfb110038>
        psrc++;
        len++;
    }
    return (len);
81130060:	e0bffe03 	ldbu	r2,-8(fp)
}
81130064:	e037883a 	mov	sp,fp
81130068:	df000017 	ldw	fp,0(sp)
8113006c:	dec00104 	addi	sp,sp,4
81130070:	f800283a 	ret

81130074 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81130074:	defffa04 	addi	sp,sp,-24
81130078:	de00012e 	bgeu	sp,et,81130080 <OS_TaskIdle+0xc>
8113007c:	003b68fa 	trap	3
81130080:	dfc00515 	stw	ra,20(sp)
81130084:	df000415 	stw	fp,16(sp)
81130088:	df000404 	addi	fp,sp,16
8113008c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130090:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130094:	0005303a 	rdctl	r2,status
81130098:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113009c:	e0fffd17 	ldw	r3,-12(fp)
811300a0:	00bfff84 	movi	r2,-2
811300a4:	1884703a 	and	r2,r3,r2
811300a8:	1001703a 	wrctl	status,r2
  
  return context;
811300ac:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
811300b0:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
811300b4:	d0a08317 	ldw	r2,-32244(gp)
811300b8:	10800044 	addi	r2,r2,1
811300bc:	d0a08315 	stw	r2,-32244(gp)
811300c0:	e0bffc17 	ldw	r2,-16(fp)
811300c4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811300c8:	e0bffe17 	ldw	r2,-8(fp)
811300cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
811300d0:	11410580 	call	81141058 <OSTaskIdleHook>
    }
811300d4:	003fef06 	br	81130094 <__reset+0xfb110094>

811300d8 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
811300d8:	defff804 	addi	sp,sp,-32
811300dc:	de00012e 	bgeu	sp,et,811300e4 <OS_TaskStat+0xc>
811300e0:	003b68fa 	trap	3
811300e4:	dfc00715 	stw	ra,28(sp)
811300e8:	df000615 	stw	fp,24(sp)
811300ec:	dc400515 	stw	r17,20(sp)
811300f0:	dc000415 	stw	r16,16(sp)
811300f4:	df000604 	addi	fp,sp,24
811300f8:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811300fc:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81130100:	00000206 	br	8113010c <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81130104:	01003204 	movi	r4,200
81130108:	11369d00 	call	811369d0 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113010c:	d0a09803 	ldbu	r2,-32160(gp)
81130110:	10803fcc 	andi	r2,r2,255
81130114:	103ffb26 	beq	r2,zero,81130104 <__reset+0xfb110104>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81130118:	d0e08917 	ldw	r3,-32220(gp)
8113011c:	00947b34 	movhi	r2,20972
81130120:	10a147c4 	addi	r2,r2,-31457
81130124:	1888383a 	mulxuu	r4,r3,r2
81130128:	1885383a 	mul	r2,r3,r2
8113012c:	1021883a 	mov	r16,r2
81130130:	2023883a 	mov	r17,r4
81130134:	8804d17a 	srli	r2,r17,5
81130138:	d0a08915 	stw	r2,-32220(gp)
    if (OSIdleCtrMax == 0L) {
8113013c:	d0a08917 	ldw	r2,-32220(gp)
81130140:	1000031e 	bne	r2,zero,81130150 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81130144:	d0208b05 	stb	zero,-32212(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81130148:	01003fc4 	movi	r4,255
8113014c:	11366400 	call	81136640 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130150:	0005303a 	rdctl	r2,status
81130154:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130158:	e0fffb17 	ldw	r3,-20(fp)
8113015c:	00bfff84 	movi	r2,-2
81130160:	1884703a 	and	r2,r3,r2
81130164:	1001703a 	wrctl	status,r2
  
  return context;
81130168:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
8113016c:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81130170:	d0a08317 	ldw	r2,-32244(gp)
81130174:	d0a09915 	stw	r2,-32156(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81130178:	d0208315 	stw	zero,-32244(gp)
8113017c:	e0bffa17 	ldw	r2,-24(fp)
81130180:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130184:	e0bffc17 	ldw	r2,-16(fp)
81130188:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
8113018c:	d0e09917 	ldw	r3,-32156(gp)
81130190:	d0a08917 	ldw	r2,-32220(gp)
81130194:	1885203a 	divu	r2,r3,r2
81130198:	1007883a 	mov	r3,r2
8113019c:	00801904 	movi	r2,100
811301a0:	10c5c83a 	sub	r2,r2,r3
811301a4:	d0a08b05 	stb	r2,-32212(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
811301a8:	1140f880 	call	81140f88 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
811301ac:	11301bc0 	call	811301bc <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
811301b0:	01001904 	movi	r4,100
811301b4:	11369d00 	call	811369d0 <OSTimeDly>
    }
811301b8:	003fe506 	br	81130150 <__reset+0xfb110150>

811301bc <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
811301bc:	defffa04 	addi	sp,sp,-24
811301c0:	de00012e 	bgeu	sp,et,811301c8 <OS_TaskStatStkChk+0xc>
811301c4:	003b68fa 	trap	3
811301c8:	dfc00515 	stw	ra,20(sp)
811301cc:	df000415 	stw	fp,16(sp)
811301d0:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
811301d4:	e03ffc05 	stb	zero,-16(fp)
811301d8:	00002406 	br	8113026c <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
811301dc:	e0bffc03 	ldbu	r2,-16(fp)
811301e0:	e0fffe04 	addi	r3,fp,-8
811301e4:	180b883a 	mov	r5,r3
811301e8:	1009883a 	mov	r4,r2
811301ec:	11364780 	call	81136478 <OSTaskStkChk>
811301f0:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
811301f4:	e0bffc43 	ldbu	r2,-15(fp)
811301f8:	1000191e 	bne	r2,zero,81130260 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
811301fc:	e0fffc03 	ldbu	r3,-16(fp)
81130200:	00a045b4 	movhi	r2,33046
81130204:	10882104 	addi	r2,r2,8324
81130208:	18c7883a 	add	r3,r3,r3
8113020c:	18c7883a 	add	r3,r3,r3
81130210:	10c5883a 	add	r2,r2,r3
81130214:	10800017 	ldw	r2,0(r2)
81130218:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8113021c:	e0bffd17 	ldw	r2,-12(fp)
81130220:	10000f26 	beq	r2,zero,81130260 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81130224:	e0bffd17 	ldw	r2,-12(fp)
81130228:	10800060 	cmpeqi	r2,r2,1
8113022c:	10000c1e 	bne	r2,zero,81130260 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
81130230:	e0bffd17 	ldw	r2,-12(fp)
81130234:	10c00217 	ldw	r3,8(r2)
81130238:	e0bffd17 	ldw	r2,-12(fp)
8113023c:	10800317 	ldw	r2,12(r2)
81130240:	1085883a 	add	r2,r2,r2
81130244:	1085883a 	add	r2,r2,r2
81130248:	1887883a 	add	r3,r3,r2
8113024c:	e0bffd17 	ldw	r2,-12(fp)
81130250:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81130254:	e0ffff17 	ldw	r3,-4(fp)
81130258:	e0bffd17 	ldw	r2,-12(fp)
8113025c:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81130260:	e0bffc03 	ldbu	r2,-16(fp)
81130264:	10800044 	addi	r2,r2,1
81130268:	e0bffc05 	stb	r2,-16(fp)
8113026c:	e0bffc03 	ldbu	r2,-16(fp)
81130270:	10800a70 	cmpltui	r2,r2,41
81130274:	103fd91e 	bne	r2,zero,811301dc <__reset+0xfb1101dc>
#endif
                }
            }
        }
    }
}
81130278:	0001883a 	nop
8113027c:	e037883a 	mov	sp,fp
81130280:	dfc00117 	ldw	ra,4(sp)
81130284:	df000017 	ldw	fp,0(sp)
81130288:	dec00204 	addi	sp,sp,8
8113028c:	f800283a 	ret

81130290 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
81130290:	defff204 	addi	sp,sp,-56
81130294:	de00012e 	bgeu	sp,et,8113029c <OS_TCBInit+0xc>
81130298:	003b68fa 	trap	3
8113029c:	dfc00d15 	stw	ra,52(sp)
811302a0:	df000c15 	stw	fp,48(sp)
811302a4:	df000c04 	addi	fp,sp,48
811302a8:	e17ffc15 	stw	r5,-16(fp)
811302ac:	e1bffd15 	stw	r6,-12(fp)
811302b0:	3807883a 	mov	r3,r7
811302b4:	e0800417 	ldw	r2,16(fp)
811302b8:	e13ffb05 	stb	r4,-20(fp)
811302bc:	e0fffe0d 	sth	r3,-8(fp)
811302c0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811302c4:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811302c8:	0005303a 	rdctl	r2,status
811302cc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811302d0:	e0fffa17 	ldw	r3,-24(fp)
811302d4:	00bfff84 	movi	r2,-2
811302d8:	1884703a 	and	r2,r3,r2
811302dc:	1001703a 	wrctl	status,r2
  
  return context;
811302e0:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
811302e4:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
811302e8:	d0a08a17 	ldw	r2,-32216(gp)
811302ec:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
811302f0:	e0bff617 	ldw	r2,-40(fp)
811302f4:	10009326 	beq	r2,zero,81130544 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
811302f8:	e0bff617 	ldw	r2,-40(fp)
811302fc:	10800517 	ldw	r2,20(r2)
81130300:	d0a08a15 	stw	r2,-32216(gp)
81130304:	e0bff417 	ldw	r2,-48(fp)
81130308:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113030c:	e0bff817 	ldw	r2,-32(fp)
81130310:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81130314:	e0bff617 	ldw	r2,-40(fp)
81130318:	e0fffc17 	ldw	r3,-16(fp)
8113031c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
81130320:	e0bff617 	ldw	r2,-40(fp)
81130324:	e0fffb03 	ldbu	r3,-20(fp)
81130328:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8113032c:	e0bff617 	ldw	r2,-40(fp)
81130330:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81130334:	e0bff617 	ldw	r2,-40(fp)
81130338:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8113033c:	e0bff617 	ldw	r2,-40(fp)
81130340:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81130344:	e0bff617 	ldw	r2,-40(fp)
81130348:	e0c00317 	ldw	r3,12(fp)
8113034c:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
81130350:	e0bff617 	ldw	r2,-40(fp)
81130354:	e0c00217 	ldw	r3,8(fp)
81130358:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8113035c:	e0bff617 	ldw	r2,-40(fp)
81130360:	e0fffd17 	ldw	r3,-12(fp)
81130364:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81130368:	e0bff617 	ldw	r2,-40(fp)
8113036c:	e0ffff0b 	ldhu	r3,-4(fp)
81130370:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81130374:	e0bff617 	ldw	r2,-40(fp)
81130378:	e0fffe0b 	ldhu	r3,-8(fp)
8113037c:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
81130380:	e0bff617 	ldw	r2,-40(fp)
81130384:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81130388:	e0bffb03 	ldbu	r2,-20(fp)
8113038c:	1004d0fa 	srli	r2,r2,3
81130390:	1007883a 	mov	r3,r2
81130394:	e0bff617 	ldw	r2,-40(fp)
81130398:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8113039c:	e0bffb03 	ldbu	r2,-20(fp)
811303a0:	108001cc 	andi	r2,r2,7
811303a4:	1007883a 	mov	r3,r2
811303a8:	e0bff617 	ldw	r2,-40(fp)
811303ac:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
811303b0:	e0bff617 	ldw	r2,-40(fp)
811303b4:	10800d03 	ldbu	r2,52(r2)
811303b8:	10803fcc 	andi	r2,r2,255
811303bc:	00c00044 	movi	r3,1
811303c0:	1884983a 	sll	r2,r3,r2
811303c4:	1007883a 	mov	r3,r2
811303c8:	e0bff617 	ldw	r2,-40(fp)
811303cc:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
811303d0:	e0bff617 	ldw	r2,-40(fp)
811303d4:	10800cc3 	ldbu	r2,51(r2)
811303d8:	10803fcc 	andi	r2,r2,255
811303dc:	00c00044 	movi	r3,1
811303e0:	1884983a 	sll	r2,r3,r2
811303e4:	1007883a 	mov	r3,r2
811303e8:	e0bff617 	ldw	r2,-40(fp)
811303ec:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
811303f0:	e0bff617 	ldw	r2,-40(fp)
811303f4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
811303f8:	e0bff617 	ldw	r2,-40(fp)
811303fc:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81130400:	e0bff617 	ldw	r2,-40(fp)
81130404:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81130408:	e0bff617 	ldw	r2,-40(fp)
8113040c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81130410:	e0bff617 	ldw	r2,-40(fp)
81130414:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81130418:	e0bff617 	ldw	r2,-40(fp)
8113041c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
81130420:	e0bff617 	ldw	r2,-40(fp)
81130424:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81130428:	e0bff617 	ldw	r2,-40(fp)
8113042c:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
81130430:	e0bff617 	ldw	r2,-40(fp)
81130434:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81130438:	e0bff617 	ldw	r2,-40(fp)
8113043c:	00c00fc4 	movi	r3,63
81130440:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81130444:	e0bff617 	ldw	r2,-40(fp)
81130448:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8113044c:	e13ff617 	ldw	r4,-40(fp)
81130450:	11410800 	call	81141080 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81130454:	e13ff617 	ldw	r4,-40(fp)
81130458:	1140f080 	call	81140f08 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113045c:	0005303a 	rdctl	r2,status
81130460:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130464:	e0fff517 	ldw	r3,-44(fp)
81130468:	00bfff84 	movi	r2,-2
8113046c:	1884703a 	and	r2,r3,r2
81130470:	1001703a 	wrctl	status,r2
  
  return context;
81130474:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81130478:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8113047c:	e0fffb03 	ldbu	r3,-20(fp)
81130480:	00a045b4 	movhi	r2,33046
81130484:	10882104 	addi	r2,r2,8324
81130488:	18c7883a 	add	r3,r3,r3
8113048c:	18c7883a 	add	r3,r3,r3
81130490:	10c5883a 	add	r2,r2,r3
81130494:	e0fff617 	ldw	r3,-40(fp)
81130498:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8113049c:	d0e08517 	ldw	r3,-32236(gp)
811304a0:	e0bff617 	ldw	r2,-40(fp)
811304a4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
811304a8:	e0bff617 	ldw	r2,-40(fp)
811304ac:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
811304b0:	d0a08517 	ldw	r2,-32236(gp)
811304b4:	10000326 	beq	r2,zero,811304c4 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
811304b8:	d0a08517 	ldw	r2,-32236(gp)
811304bc:	e0fff617 	ldw	r3,-40(fp)
811304c0:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
811304c4:	e0bff617 	ldw	r2,-40(fp)
811304c8:	d0a08515 	stw	r2,-32236(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
811304cc:	e0bff617 	ldw	r2,-40(fp)
811304d0:	10c00d83 	ldbu	r3,54(r2)
811304d4:	d0a08f03 	ldbu	r2,-32196(gp)
811304d8:	1884b03a 	or	r2,r3,r2
811304dc:	d0a08f05 	stb	r2,-32196(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811304e0:	e0bff617 	ldw	r2,-40(fp)
811304e4:	10800d03 	ldbu	r2,52(r2)
811304e8:	10c03fcc 	andi	r3,r2,255
811304ec:	e0bff617 	ldw	r2,-40(fp)
811304f0:	10800d03 	ldbu	r2,52(r2)
811304f4:	11003fcc 	andi	r4,r2,255
811304f8:	d0a08f44 	addi	r2,gp,-32195
811304fc:	2085883a 	add	r2,r4,r2
81130500:	11000003 	ldbu	r4,0(r2)
81130504:	e0bff617 	ldw	r2,-40(fp)
81130508:	10800d43 	ldbu	r2,53(r2)
8113050c:	2084b03a 	or	r2,r4,r2
81130510:	1009883a 	mov	r4,r2
81130514:	d0a08f44 	addi	r2,gp,-32195
81130518:	1885883a 	add	r2,r3,r2
8113051c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
81130520:	d0a08b43 	ldbu	r2,-32211(gp)
81130524:	10800044 	addi	r2,r2,1
81130528:	d0a08b45 	stb	r2,-32211(gp)
8113052c:	e0bff417 	ldw	r2,-48(fp)
81130530:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130534:	e0bff717 	ldw	r2,-36(fp)
81130538:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113053c:	0005883a 	mov	r2,zero
81130540:	00000506 	br	81130558 <OS_TCBInit+0x2c8>
81130544:	e0bff417 	ldw	r2,-48(fp)
81130548:	e0bff915 	stw	r2,-28(fp)
8113054c:	e0bff917 	ldw	r2,-28(fp)
81130550:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81130554:	00801084 	movi	r2,66
}
81130558:	e037883a 	mov	sp,fp
8113055c:	dfc00117 	ldw	ra,4(sp)
81130560:	df000017 	ldw	fp,0(sp)
81130564:	dec00204 	addi	sp,sp,8
81130568:	f800283a 	ret

8113056c <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8113056c:	defffe04 	addi	sp,sp,-8
81130570:	de00012e 	bgeu	sp,et,81130578 <OSDebugInit+0xc>
81130574:	003b68fa 	trap	3
81130578:	df000115 	stw	fp,4(sp)
8113057c:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
81130580:	d0a01804 	addi	r2,gp,-32672
81130584:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
81130588:	d0a01904 	addi	r2,gp,-32668
8113058c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
81130590:	d0a01a84 	addi	r2,gp,-32662
81130594:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
81130598:	d0a01b04 	addi	r2,gp,-32660
8113059c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
811305a0:	d0a01a04 	addi	r2,gp,-32664
811305a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
811305a8:	d0a01b84 	addi	r2,gp,-32658
811305ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
811305b0:	d0a01c04 	addi	r2,gp,-32656
811305b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
811305b8:	d0a01c84 	addi	r2,gp,-32654
811305bc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
811305c0:	d0a01d04 	addi	r2,gp,-32652
811305c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
811305c8:	d0a01d84 	addi	r2,gp,-32650
811305cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
811305d0:	d0a01e04 	addi	r2,gp,-32648
811305d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
811305d8:	d0a01e84 	addi	r2,gp,-32646
811305dc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
811305e0:	d0a01f04 	addi	r2,gp,-32644
811305e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
811305e8:	d0a01f84 	addi	r2,gp,-32642
811305ec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
811305f0:	d0a02004 	addi	r2,gp,-32640
811305f4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
811305f8:	d0a02084 	addi	r2,gp,-32638
811305fc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
81130600:	d0a02104 	addi	r2,gp,-32636
81130604:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
81130608:	d0a02184 	addi	r2,gp,-32634
8113060c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
81130610:	d0a02204 	addi	r2,gp,-32632
81130614:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
81130618:	d0a02284 	addi	r2,gp,-32630
8113061c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
81130620:	d0a02304 	addi	r2,gp,-32628
81130624:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
81130628:	d0a02384 	addi	r2,gp,-32626
8113062c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
81130630:	d0a02404 	addi	r2,gp,-32624
81130634:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
81130638:	d0a02484 	addi	r2,gp,-32622
8113063c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
81130640:	d0a02504 	addi	r2,gp,-32620
81130644:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
81130648:	d0a02584 	addi	r2,gp,-32618
8113064c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
81130650:	d0a02604 	addi	r2,gp,-32616
81130654:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
81130658:	d0a02684 	addi	r2,gp,-32614
8113065c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
81130660:	d0a02704 	addi	r2,gp,-32612
81130664:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
81130668:	d0a02784 	addi	r2,gp,-32610
8113066c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
81130670:	d0a02804 	addi	r2,gp,-32608
81130674:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
81130678:	d0a02884 	addi	r2,gp,-32606
8113067c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
81130680:	d0a02904 	addi	r2,gp,-32604
81130684:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
81130688:	d0a02984 	addi	r2,gp,-32602
8113068c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
81130690:	d0a02a04 	addi	r2,gp,-32600
81130694:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
81130698:	d0a02a84 	addi	r2,gp,-32598
8113069c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
811306a0:	d0a02b04 	addi	r2,gp,-32596
811306a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
811306a8:	d0a02b84 	addi	r2,gp,-32594
811306ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
811306b0:	d0a02c04 	addi	r2,gp,-32592
811306b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
811306b8:	d0a02c84 	addi	r2,gp,-32590
811306bc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
811306c0:	d0a02d04 	addi	r2,gp,-32588
811306c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
811306c8:	d0a02d84 	addi	r2,gp,-32586
811306cc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
811306d0:	d0a02e04 	addi	r2,gp,-32584
811306d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
811306d8:	d0a02e84 	addi	r2,gp,-32582
811306dc:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
811306e0:	00a045b4 	movhi	r2,33046
811306e4:	10b37704 	addi	r2,r2,-12836
811306e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
811306ec:	00a045b4 	movhi	r2,33046
811306f0:	10b21304 	addi	r2,r2,-14260
811306f4:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
811306f8:	d0a02f84 	addi	r2,gp,-32578
811306fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
81130700:	d0a03004 	addi	r2,gp,-32576
81130704:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
81130708:	d0a03084 	addi	r2,gp,-32574
8113070c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
81130710:	d0a03104 	addi	r2,gp,-32572
81130714:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
81130718:	d0a03184 	addi	r2,gp,-32570
8113071c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
81130720:	d0a03204 	addi	r2,gp,-32568
81130724:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
81130728:	d0a03284 	addi	r2,gp,-32566
8113072c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
81130730:	d0a03304 	addi	r2,gp,-32564
81130734:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
81130738:	d0a03384 	addi	r2,gp,-32562
8113073c:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
81130740:	d0a02f04 	addi	r2,gp,-32580
81130744:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
81130748:	d0a03404 	addi	r2,gp,-32560
8113074c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
81130750:	0001883a 	nop
81130754:	e037883a 	mov	sp,fp
81130758:	df000017 	ldw	fp,0(sp)
8113075c:	dec00104 	addi	sp,sp,4
81130760:	f800283a 	ret

81130764 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
81130764:	defff204 	addi	sp,sp,-56
81130768:	de00012e 	bgeu	sp,et,81130770 <OSFlagAccept+0xc>
8113076c:	003b68fa 	trap	3
81130770:	df000d15 	stw	fp,52(sp)
81130774:	df000d04 	addi	fp,sp,52
81130778:	e13ffc15 	stw	r4,-16(fp)
8113077c:	2807883a 	mov	r3,r5
81130780:	3005883a 	mov	r2,r6
81130784:	e1ffff15 	stw	r7,-4(fp)
81130788:	e0fffd0d 	sth	r3,-12(fp)
8113078c:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81130790:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81130794:	e0bfff17 	ldw	r2,-4(fp)
81130798:	1000021e 	bne	r2,zero,811307a4 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8113079c:	0005883a 	mov	r2,zero
811307a0:	0000b006 	br	81130a64 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811307a4:	e0bffc17 	ldw	r2,-16(fp)
811307a8:	1000051e 	bne	r2,zero,811307c0 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811307ac:	e0bfff17 	ldw	r2,-4(fp)
811307b0:	00c01b84 	movi	r3,110
811307b4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811307b8:	0005883a 	mov	r2,zero
811307bc:	0000a906 	br	81130a64 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
811307c0:	e0bffc17 	ldw	r2,-16(fp)
811307c4:	10800003 	ldbu	r2,0(r2)
811307c8:	10803fcc 	andi	r2,r2,255
811307cc:	10800160 	cmpeqi	r2,r2,5
811307d0:	1000051e 	bne	r2,zero,811307e8 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
811307d4:	e0bfff17 	ldw	r2,-4(fp)
811307d8:	00c00044 	movi	r3,1
811307dc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811307e0:	0005883a 	mov	r2,zero
811307e4:	00009f06 	br	81130a64 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
811307e8:	e0fffe03 	ldbu	r3,-8(fp)
811307ec:	00bfe004 	movi	r2,-128
811307f0:	1884703a 	and	r2,r3,r2
811307f4:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
811307f8:	e0bff503 	ldbu	r2,-44(fp)
811307fc:	10000626 	beq	r2,zero,81130818 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
81130800:	e0bffe03 	ldbu	r2,-8(fp)
81130804:	10801fcc 	andi	r2,r2,127
81130808:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113080c:	00800044 	movi	r2,1
81130810:	e0bff385 	stb	r2,-50(fp)
81130814:	00000106 	br	8113081c <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
81130818:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113081c:	e0bfff17 	ldw	r2,-4(fp)
81130820:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130824:	0005303a 	rdctl	r2,status
81130828:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113082c:	e0fffb17 	ldw	r3,-20(fp)
81130830:	00bfff84 	movi	r2,-2
81130834:	1884703a 	and	r2,r3,r2
81130838:	1001703a 	wrctl	status,r2
  
  return context;
8113083c:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
81130840:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
81130844:	e0bffe03 	ldbu	r2,-8(fp)
81130848:	10c00060 	cmpeqi	r3,r2,1
8113084c:	18005f1e 	bne	r3,zero,811309cc <OSFlagAccept+0x268>
81130850:	10c00088 	cmpgei	r3,r2,2
81130854:	1800021e 	bne	r3,zero,81130860 <OSFlagAccept+0xfc>
81130858:	10003f26 	beq	r2,zero,81130958 <OSFlagAccept+0x1f4>
8113085c:	00007706 	br	81130a3c <OSFlagAccept+0x2d8>
81130860:	10c000a0 	cmpeqi	r3,r2,2
81130864:	1800031e 	bne	r3,zero,81130874 <OSFlagAccept+0x110>
81130868:	108000e0 	cmpeqi	r2,r2,3
8113086c:	10001e1e 	bne	r2,zero,811308e8 <OSFlagAccept+0x184>
81130870:	00007206 	br	81130a3c <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81130874:	e0bffc17 	ldw	r2,-16(fp)
81130878:	10c0020b 	ldhu	r3,8(r2)
8113087c:	e0bffd0b 	ldhu	r2,-12(fp)
81130880:	1884703a 	and	r2,r3,r2
81130884:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81130888:	e0fff30b 	ldhu	r3,-52(fp)
8113088c:	e0bffd0b 	ldhu	r2,-12(fp)
81130890:	18800d1e 	bne	r3,r2,811308c8 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81130894:	e0bff383 	ldbu	r2,-50(fp)
81130898:	10800058 	cmpnei	r2,r2,1
8113089c:	10000d1e 	bne	r2,zero,811308d4 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
811308a0:	e0bffc17 	ldw	r2,-16(fp)
811308a4:	1080020b 	ldhu	r2,8(r2)
811308a8:	1007883a 	mov	r3,r2
811308ac:	e0bff30b 	ldhu	r2,-52(fp)
811308b0:	0084303a 	nor	r2,zero,r2
811308b4:	1884703a 	and	r2,r3,r2
811308b8:	1007883a 	mov	r3,r2
811308bc:	e0bffc17 	ldw	r2,-16(fp)
811308c0:	10c0020d 	sth	r3,8(r2)
811308c4:	00000306 	br	811308d4 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811308c8:	e0bfff17 	ldw	r2,-4(fp)
811308cc:	00c01c04 	movi	r3,112
811308d0:	10c00005 	stb	r3,0(r2)
811308d4:	e0bff417 	ldw	r2,-48(fp)
811308d8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811308dc:	e0bff617 	ldw	r2,-40(fp)
811308e0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811308e4:	00005e06 	br	81130a60 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
811308e8:	e0bffc17 	ldw	r2,-16(fp)
811308ec:	10c0020b 	ldhu	r3,8(r2)
811308f0:	e0bffd0b 	ldhu	r2,-12(fp)
811308f4:	1884703a 	and	r2,r3,r2
811308f8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
811308fc:	e0bff30b 	ldhu	r2,-52(fp)
81130900:	10000d26 	beq	r2,zero,81130938 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81130904:	e0bff383 	ldbu	r2,-50(fp)
81130908:	10800058 	cmpnei	r2,r2,1
8113090c:	10000d1e 	bne	r2,zero,81130944 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81130910:	e0bffc17 	ldw	r2,-16(fp)
81130914:	1080020b 	ldhu	r2,8(r2)
81130918:	1007883a 	mov	r3,r2
8113091c:	e0bff30b 	ldhu	r2,-52(fp)
81130920:	0084303a 	nor	r2,zero,r2
81130924:	1884703a 	and	r2,r3,r2
81130928:	1007883a 	mov	r3,r2
8113092c:	e0bffc17 	ldw	r2,-16(fp)
81130930:	10c0020d 	sth	r3,8(r2)
81130934:	00000306 	br	81130944 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81130938:	e0bfff17 	ldw	r2,-4(fp)
8113093c:	00c01c04 	movi	r3,112
81130940:	10c00005 	stb	r3,0(r2)
81130944:	e0bff417 	ldw	r2,-48(fp)
81130948:	e0bff715 	stw	r2,-36(fp)
8113094c:	e0bff717 	ldw	r2,-36(fp)
81130950:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81130954:	00004206 	br	81130a60 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81130958:	e0bffc17 	ldw	r2,-16(fp)
8113095c:	1080020b 	ldhu	r2,8(r2)
81130960:	0084303a 	nor	r2,zero,r2
81130964:	1007883a 	mov	r3,r2
81130968:	e0bffd0b 	ldhu	r2,-12(fp)
8113096c:	1884703a 	and	r2,r3,r2
81130970:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81130974:	e0fff30b 	ldhu	r3,-52(fp)
81130978:	e0bffd0b 	ldhu	r2,-12(fp)
8113097c:	18800b1e 	bne	r3,r2,811309ac <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81130980:	e0bff383 	ldbu	r2,-50(fp)
81130984:	10800058 	cmpnei	r2,r2,1
81130988:	10000b1e 	bne	r2,zero,811309b8 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113098c:	e0bffc17 	ldw	r2,-16(fp)
81130990:	10c0020b 	ldhu	r3,8(r2)
81130994:	e0bff30b 	ldhu	r2,-52(fp)
81130998:	1884b03a 	or	r2,r3,r2
8113099c:	1007883a 	mov	r3,r2
811309a0:	e0bffc17 	ldw	r2,-16(fp)
811309a4:	10c0020d 	sth	r3,8(r2)
811309a8:	00000306 	br	811309b8 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811309ac:	e0bfff17 	ldw	r2,-4(fp)
811309b0:	00c01c04 	movi	r3,112
811309b4:	10c00005 	stb	r3,0(r2)
811309b8:	e0bff417 	ldw	r2,-48(fp)
811309bc:	e0bff815 	stw	r2,-32(fp)
811309c0:	e0bff817 	ldw	r2,-32(fp)
811309c4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811309c8:	00002506 	br	81130a60 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
811309cc:	e0bffc17 	ldw	r2,-16(fp)
811309d0:	1080020b 	ldhu	r2,8(r2)
811309d4:	0084303a 	nor	r2,zero,r2
811309d8:	1007883a 	mov	r3,r2
811309dc:	e0bffd0b 	ldhu	r2,-12(fp)
811309e0:	1884703a 	and	r2,r3,r2
811309e4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
811309e8:	e0bff30b 	ldhu	r2,-52(fp)
811309ec:	10000b26 	beq	r2,zero,81130a1c <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811309f0:	e0bff383 	ldbu	r2,-50(fp)
811309f4:	10800058 	cmpnei	r2,r2,1
811309f8:	10000b1e 	bne	r2,zero,81130a28 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
811309fc:	e0bffc17 	ldw	r2,-16(fp)
81130a00:	10c0020b 	ldhu	r3,8(r2)
81130a04:	e0bff30b 	ldhu	r2,-52(fp)
81130a08:	1884b03a 	or	r2,r3,r2
81130a0c:	1007883a 	mov	r3,r2
81130a10:	e0bffc17 	ldw	r2,-16(fp)
81130a14:	10c0020d 	sth	r3,8(r2)
81130a18:	00000306 	br	81130a28 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81130a1c:	e0bfff17 	ldw	r2,-4(fp)
81130a20:	00c01c04 	movi	r3,112
81130a24:	10c00005 	stb	r3,0(r2)
81130a28:	e0bff417 	ldw	r2,-48(fp)
81130a2c:	e0bff915 	stw	r2,-28(fp)
81130a30:	e0bff917 	ldw	r2,-28(fp)
81130a34:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81130a38:	00000906 	br	81130a60 <OSFlagAccept+0x2fc>
81130a3c:	e0bff417 	ldw	r2,-48(fp)
81130a40:	e0bffa15 	stw	r2,-24(fp)
81130a44:	e0bffa17 	ldw	r2,-24(fp)
81130a48:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81130a4c:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
81130a50:	e0bfff17 	ldw	r2,-4(fp)
81130a54:	00c01bc4 	movi	r3,111
81130a58:	10c00005 	stb	r3,0(r2)
             break;
81130a5c:	0001883a 	nop
    }
    return (flags_rdy);
81130a60:	e0bff30b 	ldhu	r2,-52(fp)
}
81130a64:	e037883a 	mov	sp,fp
81130a68:	df000017 	ldw	fp,0(sp)
81130a6c:	dec00104 	addi	sp,sp,4
81130a70:	f800283a 	ret

81130a74 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
81130a74:	defff804 	addi	sp,sp,-32
81130a78:	de00012e 	bgeu	sp,et,81130a80 <OSFlagCreate+0xc>
81130a7c:	003b68fa 	trap	3
81130a80:	df000715 	stw	fp,28(sp)
81130a84:	df000704 	addi	fp,sp,28
81130a88:	2005883a 	mov	r2,r4
81130a8c:	e17fff15 	stw	r5,-4(fp)
81130a90:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
81130a94:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
81130a98:	e0bfff17 	ldw	r2,-4(fp)
81130a9c:	1000021e 	bne	r2,zero,81130aa8 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
81130aa0:	0005883a 	mov	r2,zero
81130aa4:	00003306 	br	81130b74 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
81130aa8:	d0a09203 	ldbu	r2,-32184(gp)
81130aac:	10803fcc 	andi	r2,r2,255
81130ab0:	10000526 	beq	r2,zero,81130ac8 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
81130ab4:	e0bfff17 	ldw	r2,-4(fp)
81130ab8:	00c00404 	movi	r3,16
81130abc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
81130ac0:	0005883a 	mov	r2,zero
81130ac4:	00002b06 	br	81130b74 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130ac8:	0005303a 	rdctl	r2,status
81130acc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130ad0:	e0fffd17 	ldw	r3,-12(fp)
81130ad4:	00bfff84 	movi	r2,-2
81130ad8:	1884703a 	and	r2,r3,r2
81130adc:	1001703a 	wrctl	status,r2
  
  return context;
81130ae0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81130ae4:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
81130ae8:	d0a09717 	ldw	r2,-32164(gp)
81130aec:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
81130af0:	e0bffb17 	ldw	r2,-20(fp)
81130af4:	10001726 	beq	r2,zero,81130b54 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
81130af8:	d0a09717 	ldw	r2,-32164(gp)
81130afc:	10800117 	ldw	r2,4(r2)
81130b00:	d0a09715 	stw	r2,-32164(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
81130b04:	e0bffb17 	ldw	r2,-20(fp)
81130b08:	00c00144 	movi	r3,5
81130b0c:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
81130b10:	e0bffb17 	ldw	r2,-20(fp)
81130b14:	e0fffe0b 	ldhu	r3,-8(fp)
81130b18:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
81130b1c:	e0bffb17 	ldw	r2,-20(fp)
81130b20:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
81130b24:	e0bffb17 	ldw	r2,-20(fp)
81130b28:	00c00fc4 	movi	r3,63
81130b2c:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81130b30:	e0bffb17 	ldw	r2,-20(fp)
81130b34:	100002c5 	stb	zero,11(r2)
81130b38:	e0bff917 	ldw	r2,-28(fp)
81130b3c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130b40:	e0bffa17 	ldw	r2,-24(fp)
81130b44:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
81130b48:	e0bfff17 	ldw	r2,-4(fp)
81130b4c:	10000005 	stb	zero,0(r2)
81130b50:	00000706 	br	81130b70 <OSFlagCreate+0xfc>
81130b54:	e0bff917 	ldw	r2,-28(fp)
81130b58:	e0bffc15 	stw	r2,-16(fp)
81130b5c:	e0bffc17 	ldw	r2,-16(fp)
81130b60:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
81130b64:	e0bfff17 	ldw	r2,-4(fp)
81130b68:	00c01c84 	movi	r3,114
81130b6c:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
81130b70:	e0bffb17 	ldw	r2,-20(fp)
}
81130b74:	e037883a 	mov	sp,fp
81130b78:	df000017 	ldw	fp,0(sp)
81130b7c:	dec00104 	addi	sp,sp,4
81130b80:	f800283a 	ret

81130b84 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
81130b84:	defff204 	addi	sp,sp,-56
81130b88:	de00012e 	bgeu	sp,et,81130b90 <OSFlagDel+0xc>
81130b8c:	003b68fa 	trap	3
81130b90:	dfc00d15 	stw	ra,52(sp)
81130b94:	df000c15 	stw	fp,48(sp)
81130b98:	df000c04 	addi	fp,sp,48
81130b9c:	e13ffd15 	stw	r4,-12(fp)
81130ba0:	2805883a 	mov	r2,r5
81130ba4:	e1bfff15 	stw	r6,-4(fp)
81130ba8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81130bac:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81130bb0:	e0bfff17 	ldw	r2,-4(fp)
81130bb4:	1000021e 	bne	r2,zero,81130bc0 <OSFlagDel+0x3c>
        return (pgrp);
81130bb8:	e0bffd17 	ldw	r2,-12(fp)
81130bbc:	00008006 	br	81130dc0 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81130bc0:	e0bffd17 	ldw	r2,-12(fp)
81130bc4:	1000051e 	bne	r2,zero,81130bdc <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81130bc8:	e0bfff17 	ldw	r2,-4(fp)
81130bcc:	00c01b84 	movi	r3,110
81130bd0:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81130bd4:	e0bffd17 	ldw	r2,-12(fp)
81130bd8:	00007906 	br	81130dc0 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81130bdc:	d0a09203 	ldbu	r2,-32184(gp)
81130be0:	10803fcc 	andi	r2,r2,255
81130be4:	10000526 	beq	r2,zero,81130bfc <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
81130be8:	e0bfff17 	ldw	r2,-4(fp)
81130bec:	00c003c4 	movi	r3,15
81130bf0:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81130bf4:	e0bffd17 	ldw	r2,-12(fp)
81130bf8:	00007106 	br	81130dc0 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
81130bfc:	e0bffd17 	ldw	r2,-12(fp)
81130c00:	10800003 	ldbu	r2,0(r2)
81130c04:	10803fcc 	andi	r2,r2,255
81130c08:	10800160 	cmpeqi	r2,r2,5
81130c0c:	1000051e 	bne	r2,zero,81130c24 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81130c10:	e0bfff17 	ldw	r2,-4(fp)
81130c14:	00c00044 	movi	r3,1
81130c18:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81130c1c:	e0bffd17 	ldw	r2,-12(fp)
81130c20:	00006706 	br	81130dc0 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130c24:	0005303a 	rdctl	r2,status
81130c28:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130c2c:	e0fffc17 	ldw	r3,-16(fp)
81130c30:	00bfff84 	movi	r2,-2
81130c34:	1884703a 	and	r2,r3,r2
81130c38:	1001703a 	wrctl	status,r2
  
  return context;
81130c3c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81130c40:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
81130c44:	e0bffd17 	ldw	r2,-12(fp)
81130c48:	10800117 	ldw	r2,4(r2)
81130c4c:	10000326 	beq	r2,zero,81130c5c <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81130c50:	00800044 	movi	r2,1
81130c54:	e0bff405 	stb	r2,-48(fp)
81130c58:	00000106 	br	81130c60 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81130c5c:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81130c60:	e0bffe03 	ldbu	r2,-8(fp)
81130c64:	10000326 	beq	r2,zero,81130c74 <OSFlagDel+0xf0>
81130c68:	10800060 	cmpeqi	r2,r2,1
81130c6c:	1000231e 	bne	r2,zero,81130cfc <OSFlagDel+0x178>
81130c70:	00004806 	br	81130d94 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
81130c74:	e0bff403 	ldbu	r2,-48(fp)
81130c78:	1000161e 	bne	r2,zero,81130cd4 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
81130c7c:	e0bffd17 	ldw	r2,-12(fp)
81130c80:	00c00fc4 	movi	r3,63
81130c84:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81130c88:	e0bffd17 	ldw	r2,-12(fp)
81130c8c:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81130c90:	e0bffd17 	ldw	r2,-12(fp)
81130c94:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
81130c98:	d0e09717 	ldw	r3,-32164(gp)
81130c9c:	e0bffd17 	ldw	r2,-12(fp)
81130ca0:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
81130ca4:	e0bffd17 	ldw	r2,-12(fp)
81130ca8:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
81130cac:	e0bffd17 	ldw	r2,-12(fp)
81130cb0:	d0a09715 	stw	r2,-32164(gp)
81130cb4:	e0bff717 	ldw	r2,-36(fp)
81130cb8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130cbc:	e0bff817 	ldw	r2,-32(fp)
81130cc0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
81130cc4:	e0bfff17 	ldw	r2,-4(fp)
81130cc8:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
81130ccc:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
81130cd0:	00003a06 	br	81130dbc <OSFlagDel+0x238>
81130cd4:	e0bff717 	ldw	r2,-36(fp)
81130cd8:	e0bff915 	stw	r2,-28(fp)
81130cdc:	e0bff917 	ldw	r2,-28(fp)
81130ce0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
81130ce4:	e0bfff17 	ldw	r2,-4(fp)
81130ce8:	00c01244 	movi	r3,73
81130cec:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
81130cf0:	e0bffd17 	ldw	r2,-12(fp)
81130cf4:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81130cf8:	00003006 	br	81130dbc <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81130cfc:	e0bffd17 	ldw	r2,-12(fp)
81130d00:	10800117 	ldw	r2,4(r2)
81130d04:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81130d08:	00000606 	br	81130d24 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
81130d0c:	000b883a 	mov	r5,zero
81130d10:	e13ff517 	ldw	r4,-44(fp)
81130d14:	1131d380 	call	81131d38 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81130d18:	e0bff517 	ldw	r2,-44(fp)
81130d1c:	10800017 	ldw	r2,0(r2)
81130d20:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81130d24:	e0bff517 	ldw	r2,-44(fp)
81130d28:	103ff81e 	bne	r2,zero,81130d0c <__reset+0xfb110d0c>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
81130d2c:	e0bffd17 	ldw	r2,-12(fp)
81130d30:	00c00fc4 	movi	r3,63
81130d34:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81130d38:	e0bffd17 	ldw	r2,-12(fp)
81130d3c:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81130d40:	e0bffd17 	ldw	r2,-12(fp)
81130d44:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
81130d48:	d0e09717 	ldw	r3,-32164(gp)
81130d4c:	e0bffd17 	ldw	r2,-12(fp)
81130d50:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
81130d54:	e0bffd17 	ldw	r2,-12(fp)
81130d58:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
81130d5c:	e0bffd17 	ldw	r2,-12(fp)
81130d60:	d0a09715 	stw	r2,-32164(gp)
81130d64:	e0bff717 	ldw	r2,-36(fp)
81130d68:	e0bffa15 	stw	r2,-24(fp)
81130d6c:	e0bffa17 	ldw	r2,-24(fp)
81130d70:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81130d74:	e0bff403 	ldbu	r2,-48(fp)
81130d78:	10800058 	cmpnei	r2,r2,1
81130d7c:	1000011e 	bne	r2,zero,81130d84 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81130d80:	112fe480 	call	8112fe48 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
81130d84:	e0bfff17 	ldw	r2,-4(fp)
81130d88:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
81130d8c:	e03ff615 	stw	zero,-40(fp)
             break;
81130d90:	00000a06 	br	81130dbc <OSFlagDel+0x238>
81130d94:	e0bff717 	ldw	r2,-36(fp)
81130d98:	e0bffb15 	stw	r2,-20(fp)
81130d9c:	e0bffb17 	ldw	r2,-20(fp)
81130da0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
81130da4:	e0bfff17 	ldw	r2,-4(fp)
81130da8:	00c001c4 	movi	r3,7
81130dac:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
81130db0:	e0bffd17 	ldw	r2,-12(fp)
81130db4:	e0bff615 	stw	r2,-40(fp)
             break;
81130db8:	0001883a 	nop
    }
    return (pgrp_return);
81130dbc:	e0bff617 	ldw	r2,-40(fp)
}
81130dc0:	e037883a 	mov	sp,fp
81130dc4:	dfc00117 	ldw	ra,4(sp)
81130dc8:	df000017 	ldw	fp,0(sp)
81130dcc:	dec00204 	addi	sp,sp,8
81130dd0:	f800283a 	ret

81130dd4 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81130dd4:	defff604 	addi	sp,sp,-40
81130dd8:	de00012e 	bgeu	sp,et,81130de0 <OSFlagNameGet+0xc>
81130ddc:	003b68fa 	trap	3
81130de0:	dfc00915 	stw	ra,36(sp)
81130de4:	df000815 	stw	fp,32(sp)
81130de8:	df000804 	addi	fp,sp,32
81130dec:	e13ffd15 	stw	r4,-12(fp)
81130df0:	e17ffe15 	stw	r5,-8(fp)
81130df4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130df8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81130dfc:	e0bfff17 	ldw	r2,-4(fp)
81130e00:	1000021e 	bne	r2,zero,81130e0c <OSFlagNameGet+0x38>
        return (0);
81130e04:	0005883a 	mov	r2,zero
81130e08:	00003906 	br	81130ef0 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81130e0c:	e0bffd17 	ldw	r2,-12(fp)
81130e10:	1000051e 	bne	r2,zero,81130e28 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81130e14:	e0bfff17 	ldw	r2,-4(fp)
81130e18:	00c01b84 	movi	r3,110
81130e1c:	10c00005 	stb	r3,0(r2)
        return (0);
81130e20:	0005883a 	mov	r2,zero
81130e24:	00003206 	br	81130ef0 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81130e28:	e0bffe17 	ldw	r2,-8(fp)
81130e2c:	1000051e 	bne	r2,zero,81130e44 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81130e30:	e0bfff17 	ldw	r2,-4(fp)
81130e34:	00c00304 	movi	r3,12
81130e38:	10c00005 	stb	r3,0(r2)
        return (0);
81130e3c:	0005883a 	mov	r2,zero
81130e40:	00002b06 	br	81130ef0 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81130e44:	d0a09203 	ldbu	r2,-32184(gp)
81130e48:	10803fcc 	andi	r2,r2,255
81130e4c:	10000526 	beq	r2,zero,81130e64 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81130e50:	e0bfff17 	ldw	r2,-4(fp)
81130e54:	00c00444 	movi	r3,17
81130e58:	10c00005 	stb	r3,0(r2)
        return (0);
81130e5c:	0005883a 	mov	r2,zero
81130e60:	00002306 	br	81130ef0 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130e64:	0005303a 	rdctl	r2,status
81130e68:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130e6c:	e0fffc17 	ldw	r3,-16(fp)
81130e70:	00bfff84 	movi	r2,-2
81130e74:	1884703a 	and	r2,r3,r2
81130e78:	1001703a 	wrctl	status,r2
  
  return context;
81130e7c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81130e80:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81130e84:	e0bffd17 	ldw	r2,-12(fp)
81130e88:	10800003 	ldbu	r2,0(r2)
81130e8c:	10803fcc 	andi	r2,r2,255
81130e90:	10800160 	cmpeqi	r2,r2,5
81130e94:	1000091e 	bne	r2,zero,81130ebc <OSFlagNameGet+0xe8>
81130e98:	e0bff817 	ldw	r2,-32(fp)
81130e9c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130ea0:	e0bff917 	ldw	r2,-28(fp)
81130ea4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81130ea8:	e0bfff17 	ldw	r2,-4(fp)
81130eac:	00c00044 	movi	r3,1
81130eb0:	10c00005 	stb	r3,0(r2)
        return (0);
81130eb4:	0005883a 	mov	r2,zero
81130eb8:	00000d06 	br	81130ef0 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
81130ebc:	e0bffd17 	ldw	r2,-12(fp)
81130ec0:	10800284 	addi	r2,r2,10
81130ec4:	100b883a 	mov	r5,r2
81130ec8:	e13ffe17 	ldw	r4,-8(fp)
81130ecc:	112ff9c0 	call	8112ff9c <OS_StrCopy>
81130ed0:	e0bffb05 	stb	r2,-20(fp)
81130ed4:	e0bff817 	ldw	r2,-32(fp)
81130ed8:	e0bffa15 	stw	r2,-24(fp)
81130edc:	e0bffa17 	ldw	r2,-24(fp)
81130ee0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81130ee4:	e0bfff17 	ldw	r2,-4(fp)
81130ee8:	10000005 	stb	zero,0(r2)
    return (len);
81130eec:	e0bffb03 	ldbu	r2,-20(fp)
}
81130ef0:	e037883a 	mov	sp,fp
81130ef4:	dfc00117 	ldw	ra,4(sp)
81130ef8:	df000017 	ldw	fp,0(sp)
81130efc:	dec00204 	addi	sp,sp,8
81130f00:	f800283a 	ret

81130f04 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81130f04:	defff504 	addi	sp,sp,-44
81130f08:	de00012e 	bgeu	sp,et,81130f10 <OSFlagNameSet+0xc>
81130f0c:	003b68fa 	trap	3
81130f10:	dfc00a15 	stw	ra,40(sp)
81130f14:	df000915 	stw	fp,36(sp)
81130f18:	df000904 	addi	fp,sp,36
81130f1c:	e13ffd15 	stw	r4,-12(fp)
81130f20:	e17ffe15 	stw	r5,-8(fp)
81130f24:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130f28:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81130f2c:	e0bfff17 	ldw	r2,-4(fp)
81130f30:	10004326 	beq	r2,zero,81131040 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81130f34:	e0bffd17 	ldw	r2,-12(fp)
81130f38:	1000041e 	bne	r2,zero,81130f4c <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81130f3c:	e0bfff17 	ldw	r2,-4(fp)
81130f40:	00c01b84 	movi	r3,110
81130f44:	10c00005 	stb	r3,0(r2)
        return;
81130f48:	00003e06 	br	81131044 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81130f4c:	e0bffe17 	ldw	r2,-8(fp)
81130f50:	1000041e 	bne	r2,zero,81130f64 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81130f54:	e0bfff17 	ldw	r2,-4(fp)
81130f58:	00c00304 	movi	r3,12
81130f5c:	10c00005 	stb	r3,0(r2)
        return;
81130f60:	00003806 	br	81131044 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81130f64:	d0a09203 	ldbu	r2,-32184(gp)
81130f68:	10803fcc 	andi	r2,r2,255
81130f6c:	10000426 	beq	r2,zero,81130f80 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81130f70:	e0bfff17 	ldw	r2,-4(fp)
81130f74:	00c00484 	movi	r3,18
81130f78:	10c00005 	stb	r3,0(r2)
        return;
81130f7c:	00003106 	br	81131044 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130f80:	0005303a 	rdctl	r2,status
81130f84:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130f88:	e0fffc17 	ldw	r3,-16(fp)
81130f8c:	00bfff84 	movi	r2,-2
81130f90:	1884703a 	and	r2,r3,r2
81130f94:	1001703a 	wrctl	status,r2
  
  return context;
81130f98:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81130f9c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81130fa0:	e0bffd17 	ldw	r2,-12(fp)
81130fa4:	10800003 	ldbu	r2,0(r2)
81130fa8:	10803fcc 	andi	r2,r2,255
81130fac:	10800160 	cmpeqi	r2,r2,5
81130fb0:	1000081e 	bne	r2,zero,81130fd4 <OSFlagNameSet+0xd0>
81130fb4:	e0bff717 	ldw	r2,-36(fp)
81130fb8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130fbc:	e0bff817 	ldw	r2,-32(fp)
81130fc0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81130fc4:	e0bfff17 	ldw	r2,-4(fp)
81130fc8:	00c00044 	movi	r3,1
81130fcc:	10c00005 	stb	r3,0(r2)
        return;
81130fd0:	00001c06 	br	81131044 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81130fd4:	e13ffe17 	ldw	r4,-8(fp)
81130fd8:	11300180 	call	81130018 <OS_StrLen>
81130fdc:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
81130fe0:	e0bffa03 	ldbu	r2,-24(fp)
81130fe4:	10800830 	cmpltui	r2,r2,32
81130fe8:	1000081e 	bne	r2,zero,8113100c <OSFlagNameSet+0x108>
81130fec:	e0bff717 	ldw	r2,-36(fp)
81130ff0:	e0bff915 	stw	r2,-28(fp)
81130ff4:	e0bff917 	ldw	r2,-28(fp)
81130ff8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
81130ffc:	e0bfff17 	ldw	r2,-4(fp)
81131000:	00c01cc4 	movi	r3,115
81131004:	10c00005 	stb	r3,0(r2)
        return;
81131008:	00000e06 	br	81131044 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113100c:	e0bffd17 	ldw	r2,-12(fp)
81131010:	10800284 	addi	r2,r2,10
81131014:	e17ffe17 	ldw	r5,-8(fp)
81131018:	1009883a 	mov	r4,r2
8113101c:	112ff9c0 	call	8112ff9c <OS_StrCopy>
81131020:	e0bff717 	ldw	r2,-36(fp)
81131024:	e0bffb15 	stw	r2,-20(fp)
81131028:	e0bffb17 	ldw	r2,-20(fp)
8113102c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81131030:	e0bfff17 	ldw	r2,-4(fp)
81131034:	10000005 	stb	zero,0(r2)
    return;
81131038:	0001883a 	nop
8113103c:	00000106 	br	81131044 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81131040:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
81131044:	e037883a 	mov	sp,fp
81131048:	dfc00117 	ldw	ra,4(sp)
8113104c:	df000017 	ldw	fp,0(sp)
81131050:	dec00204 	addi	sp,sp,8
81131054:	f800283a 	ret

81131058 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
81131058:	deffe104 	addi	sp,sp,-124
8113105c:	de00012e 	bgeu	sp,et,81131064 <OSFlagPend+0xc>
81131060:	003b68fa 	trap	3
81131064:	dfc01e15 	stw	ra,120(sp)
81131068:	df001d15 	stw	fp,116(sp)
8113106c:	df001d04 	addi	fp,sp,116
81131070:	e13ffc15 	stw	r4,-16(fp)
81131074:	2809883a 	mov	r4,r5
81131078:	3007883a 	mov	r3,r6
8113107c:	3805883a 	mov	r2,r7
81131080:	e13ffd0d 	sth	r4,-12(fp)
81131084:	e0fffe05 	stb	r3,-8(fp)
81131088:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113108c:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81131090:	e0800217 	ldw	r2,8(fp)
81131094:	1000021e 	bne	r2,zero,811310a0 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
81131098:	0005883a 	mov	r2,zero
8113109c:	00015906 	br	81131604 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811310a0:	e0bffc17 	ldw	r2,-16(fp)
811310a4:	1000051e 	bne	r2,zero,811310bc <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811310a8:	e0800217 	ldw	r2,8(fp)
811310ac:	00c01b84 	movi	r3,110
811310b0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811310b4:	0005883a 	mov	r2,zero
811310b8:	00015206 	br	81131604 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811310bc:	d0a09203 	ldbu	r2,-32184(gp)
811310c0:	10803fcc 	andi	r2,r2,255
811310c4:	10000526 	beq	r2,zero,811310dc <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
811310c8:	e0800217 	ldw	r2,8(fp)
811310cc:	00c00084 	movi	r3,2
811310d0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811310d4:	0005883a 	mov	r2,zero
811310d8:	00014a06 	br	81131604 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
811310dc:	d0a08003 	ldbu	r2,-32256(gp)
811310e0:	10803fcc 	andi	r2,r2,255
811310e4:	10000526 	beq	r2,zero,811310fc <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
811310e8:	e0800217 	ldw	r2,8(fp)
811310ec:	00c00344 	movi	r3,13
811310f0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811310f4:	0005883a 	mov	r2,zero
811310f8:	00014206 	br	81131604 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
811310fc:	e0bffc17 	ldw	r2,-16(fp)
81131100:	10800003 	ldbu	r2,0(r2)
81131104:	10803fcc 	andi	r2,r2,255
81131108:	10800160 	cmpeqi	r2,r2,5
8113110c:	1000051e 	bne	r2,zero,81131124 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
81131110:	e0800217 	ldw	r2,8(fp)
81131114:	00c00044 	movi	r3,1
81131118:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113111c:	0005883a 	mov	r2,zero
81131120:	00013806 	br	81131604 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81131124:	e0fffe03 	ldbu	r3,-8(fp)
81131128:	00bfe004 	movi	r2,-128
8113112c:	1884703a 	and	r2,r3,r2
81131130:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
81131134:	e0bfe603 	ldbu	r2,-104(fp)
81131138:	10000626 	beq	r2,zero,81131154 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113113c:	e0bffe03 	ldbu	r2,-8(fp)
81131140:	10801fcc 	andi	r2,r2,127
81131144:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81131148:	00800044 	movi	r2,1
8113114c:	e0bfe405 	stb	r2,-112(fp)
81131150:	00000106 	br	81131158 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
81131154:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131158:	0005303a 	rdctl	r2,status
8113115c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131160:	e0fff617 	ldw	r3,-40(fp)
81131164:	00bfff84 	movi	r2,-2
81131168:	1884703a 	and	r2,r3,r2
8113116c:	1001703a 	wrctl	status,r2
  
  return context;
81131170:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81131174:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
81131178:	e0bffe03 	ldbu	r2,-8(fp)
8113117c:	10c00060 	cmpeqi	r3,r2,1
81131180:	1800921e 	bne	r3,zero,811313cc <OSFlagPend+0x374>
81131184:	10c00088 	cmpgei	r3,r2,2
81131188:	1800021e 	bne	r3,zero,81131194 <OSFlagPend+0x13c>
8113118c:	10006126 	beq	r2,zero,81131314 <OSFlagPend+0x2bc>
81131190:	0000bb06 	br	81131480 <OSFlagPend+0x428>
81131194:	10c000a0 	cmpeqi	r3,r2,2
81131198:	1800031e 	bne	r3,zero,811311a8 <OSFlagPend+0x150>
8113119c:	108000e0 	cmpeqi	r2,r2,3
811311a0:	10002f1e 	bne	r2,zero,81131260 <OSFlagPend+0x208>
811311a4:	0000b606 	br	81131480 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
811311a8:	e0bffc17 	ldw	r2,-16(fp)
811311ac:	10c0020b 	ldhu	r3,8(r2)
811311b0:	e0bffd0b 	ldhu	r2,-12(fp)
811311b4:	1884703a 	and	r2,r3,r2
811311b8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
811311bc:	e0ffe80b 	ldhu	r3,-96(fp)
811311c0:	e0bffd0b 	ldhu	r2,-12(fp)
811311c4:	1880171e 	bne	r3,r2,81131224 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811311c8:	e0bfe403 	ldbu	r2,-112(fp)
811311cc:	10800058 	cmpnei	r2,r2,1
811311d0:	1000091e 	bne	r2,zero,811311f8 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
811311d4:	e0bffc17 	ldw	r2,-16(fp)
811311d8:	1080020b 	ldhu	r2,8(r2)
811311dc:	1007883a 	mov	r3,r2
811311e0:	e0bfe80b 	ldhu	r2,-96(fp)
811311e4:	0084303a 	nor	r2,zero,r2
811311e8:	1884703a 	and	r2,r3,r2
811311ec:	1007883a 	mov	r3,r2
811311f0:	e0bffc17 	ldw	r2,-16(fp)
811311f4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
811311f8:	d0a09317 	ldw	r2,-32180(gp)
811311fc:	e0ffe80b 	ldhu	r3,-96(fp)
81131200:	10c00b0d 	sth	r3,44(r2)
81131204:	e0bfe517 	ldw	r2,-108(fp)
81131208:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113120c:	e0bfe717 	ldw	r2,-100(fp)
81131210:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81131214:	e0800217 	ldw	r2,8(fp)
81131218:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113121c:	e0bfe80b 	ldhu	r2,-96(fp)
81131220:	0000f806 	br	81131604 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81131224:	e13ffd0b 	ldhu	r4,-12(fp)
81131228:	e17ffe03 	ldbu	r5,-8(fp)
8113122c:	e0bfff0b 	ldhu	r2,-4(fp)
81131230:	e0fff704 	addi	r3,fp,-36
81131234:	d8800015 	stw	r2,0(sp)
81131238:	280f883a 	mov	r7,r5
8113123c:	200d883a 	mov	r6,r4
81131240:	180b883a 	mov	r5,r3
81131244:	e13ffc17 	ldw	r4,-16(fp)
81131248:	1131ae80 	call	81131ae8 <OS_FlagBlock>
8113124c:	e0bfe517 	ldw	r2,-108(fp)
81131250:	e0bfe915 	stw	r2,-92(fp)
81131254:	e0bfe917 	ldw	r2,-92(fp)
81131258:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113125c:	00009206 	br	811314a8 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
81131260:	e0bffc17 	ldw	r2,-16(fp)
81131264:	10c0020b 	ldhu	r3,8(r2)
81131268:	e0bffd0b 	ldhu	r2,-12(fp)
8113126c:	1884703a 	and	r2,r3,r2
81131270:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81131274:	e0bfe80b 	ldhu	r2,-96(fp)
81131278:	10001726 	beq	r2,zero,811312d8 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113127c:	e0bfe403 	ldbu	r2,-112(fp)
81131280:	10800058 	cmpnei	r2,r2,1
81131284:	1000091e 	bne	r2,zero,811312ac <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81131288:	e0bffc17 	ldw	r2,-16(fp)
8113128c:	1080020b 	ldhu	r2,8(r2)
81131290:	1007883a 	mov	r3,r2
81131294:	e0bfe80b 	ldhu	r2,-96(fp)
81131298:	0084303a 	nor	r2,zero,r2
8113129c:	1884703a 	and	r2,r3,r2
811312a0:	1007883a 	mov	r3,r2
811312a4:	e0bffc17 	ldw	r2,-16(fp)
811312a8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
811312ac:	d0a09317 	ldw	r2,-32180(gp)
811312b0:	e0ffe80b 	ldhu	r3,-96(fp)
811312b4:	10c00b0d 	sth	r3,44(r2)
811312b8:	e0bfe517 	ldw	r2,-108(fp)
811312bc:	e0bfea15 	stw	r2,-88(fp)
811312c0:	e0bfea17 	ldw	r2,-88(fp)
811312c4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
811312c8:	e0800217 	ldw	r2,8(fp)
811312cc:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
811312d0:	e0bfe80b 	ldhu	r2,-96(fp)
811312d4:	0000cb06 	br	81131604 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
811312d8:	e13ffd0b 	ldhu	r4,-12(fp)
811312dc:	e17ffe03 	ldbu	r5,-8(fp)
811312e0:	e0bfff0b 	ldhu	r2,-4(fp)
811312e4:	e0fff704 	addi	r3,fp,-36
811312e8:	d8800015 	stw	r2,0(sp)
811312ec:	280f883a 	mov	r7,r5
811312f0:	200d883a 	mov	r6,r4
811312f4:	180b883a 	mov	r5,r3
811312f8:	e13ffc17 	ldw	r4,-16(fp)
811312fc:	1131ae80 	call	81131ae8 <OS_FlagBlock>
81131300:	e0bfe517 	ldw	r2,-108(fp)
81131304:	e0bfeb15 	stw	r2,-84(fp)
81131308:	e0bfeb17 	ldw	r2,-84(fp)
8113130c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81131310:	00006506 	br	811314a8 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81131314:	e0bffc17 	ldw	r2,-16(fp)
81131318:	1080020b 	ldhu	r2,8(r2)
8113131c:	0084303a 	nor	r2,zero,r2
81131320:	1007883a 	mov	r3,r2
81131324:	e0bffd0b 	ldhu	r2,-12(fp)
81131328:	1884703a 	and	r2,r3,r2
8113132c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81131330:	e0ffe80b 	ldhu	r3,-96(fp)
81131334:	e0bffd0b 	ldhu	r2,-12(fp)
81131338:	1880151e 	bne	r3,r2,81131390 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113133c:	e0bfe403 	ldbu	r2,-112(fp)
81131340:	10800058 	cmpnei	r2,r2,1
81131344:	1000071e 	bne	r2,zero,81131364 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81131348:	e0bffc17 	ldw	r2,-16(fp)
8113134c:	10c0020b 	ldhu	r3,8(r2)
81131350:	e0bfe80b 	ldhu	r2,-96(fp)
81131354:	1884b03a 	or	r2,r3,r2
81131358:	1007883a 	mov	r3,r2
8113135c:	e0bffc17 	ldw	r2,-16(fp)
81131360:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81131364:	d0a09317 	ldw	r2,-32180(gp)
81131368:	e0ffe80b 	ldhu	r3,-96(fp)
8113136c:	10c00b0d 	sth	r3,44(r2)
81131370:	e0bfe517 	ldw	r2,-108(fp)
81131374:	e0bfec15 	stw	r2,-80(fp)
81131378:	e0bfec17 	ldw	r2,-80(fp)
8113137c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81131380:	e0800217 	ldw	r2,8(fp)
81131384:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81131388:	e0bfe80b 	ldhu	r2,-96(fp)
8113138c:	00009d06 	br	81131604 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81131390:	e13ffd0b 	ldhu	r4,-12(fp)
81131394:	e17ffe03 	ldbu	r5,-8(fp)
81131398:	e0bfff0b 	ldhu	r2,-4(fp)
8113139c:	e0fff704 	addi	r3,fp,-36
811313a0:	d8800015 	stw	r2,0(sp)
811313a4:	280f883a 	mov	r7,r5
811313a8:	200d883a 	mov	r6,r4
811313ac:	180b883a 	mov	r5,r3
811313b0:	e13ffc17 	ldw	r4,-16(fp)
811313b4:	1131ae80 	call	81131ae8 <OS_FlagBlock>
811313b8:	e0bfe517 	ldw	r2,-108(fp)
811313bc:	e0bfed15 	stw	r2,-76(fp)
811313c0:	e0bfed17 	ldw	r2,-76(fp)
811313c4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
811313c8:	00003706 	br	811314a8 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
811313cc:	e0bffc17 	ldw	r2,-16(fp)
811313d0:	1080020b 	ldhu	r2,8(r2)
811313d4:	0084303a 	nor	r2,zero,r2
811313d8:	1007883a 	mov	r3,r2
811313dc:	e0bffd0b 	ldhu	r2,-12(fp)
811313e0:	1884703a 	and	r2,r3,r2
811313e4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
811313e8:	e0bfe80b 	ldhu	r2,-96(fp)
811313ec:	10001526 	beq	r2,zero,81131444 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811313f0:	e0bfe403 	ldbu	r2,-112(fp)
811313f4:	10800058 	cmpnei	r2,r2,1
811313f8:	1000071e 	bne	r2,zero,81131418 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
811313fc:	e0bffc17 	ldw	r2,-16(fp)
81131400:	10c0020b 	ldhu	r3,8(r2)
81131404:	e0bfe80b 	ldhu	r2,-96(fp)
81131408:	1884b03a 	or	r2,r3,r2
8113140c:	1007883a 	mov	r3,r2
81131410:	e0bffc17 	ldw	r2,-16(fp)
81131414:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81131418:	d0a09317 	ldw	r2,-32180(gp)
8113141c:	e0ffe80b 	ldhu	r3,-96(fp)
81131420:	10c00b0d 	sth	r3,44(r2)
81131424:	e0bfe517 	ldw	r2,-108(fp)
81131428:	e0bfee15 	stw	r2,-72(fp)
8113142c:	e0bfee17 	ldw	r2,-72(fp)
81131430:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81131434:	e0800217 	ldw	r2,8(fp)
81131438:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113143c:	e0bfe80b 	ldhu	r2,-96(fp)
81131440:	00007006 	br	81131604 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81131444:	e13ffd0b 	ldhu	r4,-12(fp)
81131448:	e17ffe03 	ldbu	r5,-8(fp)
8113144c:	e0bfff0b 	ldhu	r2,-4(fp)
81131450:	e0fff704 	addi	r3,fp,-36
81131454:	d8800015 	stw	r2,0(sp)
81131458:	280f883a 	mov	r7,r5
8113145c:	200d883a 	mov	r6,r4
81131460:	180b883a 	mov	r5,r3
81131464:	e13ffc17 	ldw	r4,-16(fp)
81131468:	1131ae80 	call	81131ae8 <OS_FlagBlock>
8113146c:	e0bfe517 	ldw	r2,-108(fp)
81131470:	e0bfef15 	stw	r2,-68(fp)
81131474:	e0bfef17 	ldw	r2,-68(fp)
81131478:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113147c:	00000a06 	br	811314a8 <OSFlagPend+0x450>
81131480:	e0bfe517 	ldw	r2,-108(fp)
81131484:	e0bff015 	stw	r2,-64(fp)
81131488:	e0bff017 	ldw	r2,-64(fp)
8113148c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81131490:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
81131494:	e0800217 	ldw	r2,8(fp)
81131498:	00c01bc4 	movi	r3,111
8113149c:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
811314a0:	e0bfe80b 	ldhu	r2,-96(fp)
811314a4:	00005706 	br	81131604 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
811314a8:	112fe480 	call	8112fe48 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811314ac:	0005303a 	rdctl	r2,status
811314b0:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811314b4:	e0fff117 	ldw	r3,-60(fp)
811314b8:	00bfff84 	movi	r2,-2
811314bc:	1884703a 	and	r2,r3,r2
811314c0:	1001703a 	wrctl	status,r2
  
  return context;
811314c4:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
811314c8:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
811314cc:	d0a09317 	ldw	r2,-32180(gp)
811314d0:	10800c43 	ldbu	r2,49(r2)
811314d4:	10803fcc 	andi	r2,r2,255
811314d8:	10001c26 	beq	r2,zero,8113154c <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
811314dc:	d0a09317 	ldw	r2,-32180(gp)
811314e0:	10800c43 	ldbu	r2,49(r2)
811314e4:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
811314e8:	d0a09317 	ldw	r2,-32180(gp)
811314ec:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
811314f0:	e0bff704 	addi	r2,fp,-36
811314f4:	1009883a 	mov	r4,r2
811314f8:	1131e340 	call	81131e34 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
811314fc:	d0a09317 	ldw	r2,-32180(gp)
81131500:	10000c05 	stb	zero,48(r2)
81131504:	e0bfe517 	ldw	r2,-108(fp)
81131508:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113150c:	e0bff217 	ldw	r2,-56(fp)
81131510:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
81131514:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
81131518:	e0bff303 	ldbu	r2,-52(fp)
8113151c:	108000a0 	cmpeqi	r2,r2,2
81131520:	10000426 	beq	r2,zero,81131534 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
81131524:	e0800217 	ldw	r2,8(fp)
81131528:	00c00384 	movi	r3,14
8113152c:	10c00005 	stb	r3,0(r2)
                 break;
81131530:	00000406 	br	81131544 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
81131534:	e0800217 	ldw	r2,8(fp)
81131538:	00c00284 	movi	r3,10
8113153c:	10c00005 	stb	r3,0(r2)
                 break;
81131540:	0001883a 	nop
        }
        return (flags_rdy);
81131544:	e0bfe80b 	ldhu	r2,-96(fp)
81131548:	00002e06 	br	81131604 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113154c:	d0a09317 	ldw	r2,-32180(gp)
81131550:	10800b0b 	ldhu	r2,44(r2)
81131554:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
81131558:	e0bfe403 	ldbu	r2,-112(fp)
8113155c:	10800058 	cmpnei	r2,r2,1
81131560:	1000211e 	bne	r2,zero,811315e8 <OSFlagPend+0x590>
        switch (wait_type) {
81131564:	e0bffe03 	ldbu	r2,-8(fp)
81131568:	10001616 	blt	r2,zero,811315c4 <OSFlagPend+0x56c>
8113156c:	10c00090 	cmplti	r3,r2,2
81131570:	18000c1e 	bne	r3,zero,811315a4 <OSFlagPend+0x54c>
81131574:	10800108 	cmpgei	r2,r2,4
81131578:	1000121e 	bne	r2,zero,811315c4 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113157c:	e0bffc17 	ldw	r2,-16(fp)
81131580:	1080020b 	ldhu	r2,8(r2)
81131584:	1007883a 	mov	r3,r2
81131588:	e0bfe80b 	ldhu	r2,-96(fp)
8113158c:	0084303a 	nor	r2,zero,r2
81131590:	1884703a 	and	r2,r3,r2
81131594:	1007883a 	mov	r3,r2
81131598:	e0bffc17 	ldw	r2,-16(fp)
8113159c:	10c0020d 	sth	r3,8(r2)
                 break;
811315a0:	00001106 	br	811315e8 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
811315a4:	e0bffc17 	ldw	r2,-16(fp)
811315a8:	10c0020b 	ldhu	r3,8(r2)
811315ac:	e0bfe80b 	ldhu	r2,-96(fp)
811315b0:	1884b03a 	or	r2,r3,r2
811315b4:	1007883a 	mov	r3,r2
811315b8:	e0bffc17 	ldw	r2,-16(fp)
811315bc:	10c0020d 	sth	r3,8(r2)
                 break;
811315c0:	00000906 	br	811315e8 <OSFlagPend+0x590>
811315c4:	e0bfe517 	ldw	r2,-108(fp)
811315c8:	e0bff415 	stw	r2,-48(fp)
811315cc:	e0bff417 	ldw	r2,-48(fp)
811315d0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
811315d4:	e0800217 	ldw	r2,8(fp)
811315d8:	00c01bc4 	movi	r3,111
811315dc:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
811315e0:	0005883a 	mov	r2,zero
811315e4:	00000706 	br	81131604 <OSFlagPend+0x5ac>
811315e8:	e0bfe517 	ldw	r2,-108(fp)
811315ec:	e0bff515 	stw	r2,-44(fp)
811315f0:	e0bff517 	ldw	r2,-44(fp)
811315f4:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
811315f8:	e0800217 	ldw	r2,8(fp)
811315fc:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
81131600:	e0bfe80b 	ldhu	r2,-96(fp)
}
81131604:	e037883a 	mov	sp,fp
81131608:	dfc00117 	ldw	ra,4(sp)
8113160c:	df000017 	ldw	fp,0(sp)
81131610:	dec00204 	addi	sp,sp,8
81131614:	f800283a 	ret

81131618 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
81131618:	defffb04 	addi	sp,sp,-20
8113161c:	de00012e 	bgeu	sp,et,81131624 <OSFlagPendGetFlagsRdy+0xc>
81131620:	003b68fa 	trap	3
81131624:	df000415 	stw	fp,16(sp)
81131628:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113162c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131630:	0005303a 	rdctl	r2,status
81131634:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131638:	e0fffe17 	ldw	r3,-8(fp)
8113163c:	00bfff84 	movi	r2,-2
81131640:	1884703a 	and	r2,r3,r2
81131644:	1001703a 	wrctl	status,r2
  
  return context;
81131648:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113164c:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
81131650:	d0a09317 	ldw	r2,-32180(gp)
81131654:	10800b0b 	ldhu	r2,44(r2)
81131658:	e0bffd0d 	sth	r2,-12(fp)
8113165c:	e0bffc17 	ldw	r2,-16(fp)
81131660:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131664:	e0bfff17 	ldw	r2,-4(fp)
81131668:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113166c:	e0bffd0b 	ldhu	r2,-12(fp)
}
81131670:	e037883a 	mov	sp,fp
81131674:	df000017 	ldw	fp,0(sp)
81131678:	dec00104 	addi	sp,sp,4
8113167c:	f800283a 	ret

81131680 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
81131680:	deffef04 	addi	sp,sp,-68
81131684:	de00012e 	bgeu	sp,et,8113168c <OSFlagPost+0xc>
81131688:	003b68fa 	trap	3
8113168c:	dfc01015 	stw	ra,64(sp)
81131690:	df000f15 	stw	fp,60(sp)
81131694:	df000f04 	addi	fp,sp,60
81131698:	e13ffc15 	stw	r4,-16(fp)
8113169c:	2807883a 	mov	r3,r5
811316a0:	3005883a 	mov	r2,r6
811316a4:	e1ffff15 	stw	r7,-4(fp)
811316a8:	e0fffd0d 	sth	r3,-12(fp)
811316ac:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
811316b0:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
811316b4:	e0bfff17 	ldw	r2,-4(fp)
811316b8:	1000021e 	bne	r2,zero,811316c4 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
811316bc:	0005883a 	mov	r2,zero
811316c0:	0000d106 	br	81131a08 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
811316c4:	e0bffc17 	ldw	r2,-16(fp)
811316c8:	1000051e 	bne	r2,zero,811316e0 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811316cc:	e0bfff17 	ldw	r2,-4(fp)
811316d0:	00c01b84 	movi	r3,110
811316d4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811316d8:	0005883a 	mov	r2,zero
811316dc:	0000ca06 	br	81131a08 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
811316e0:	e0bffc17 	ldw	r2,-16(fp)
811316e4:	10800003 	ldbu	r2,0(r2)
811316e8:	10803fcc 	andi	r2,r2,255
811316ec:	10800160 	cmpeqi	r2,r2,5
811316f0:	1000051e 	bne	r2,zero,81131708 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
811316f4:	e0bfff17 	ldw	r2,-4(fp)
811316f8:	00c00044 	movi	r3,1
811316fc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81131700:	0005883a 	mov	r2,zero
81131704:	0000c006 	br	81131a08 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131708:	0005303a 	rdctl	r2,status
8113170c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131710:	e0fffb17 	ldw	r3,-20(fp)
81131714:	00bfff84 	movi	r2,-2
81131718:	1884703a 	and	r2,r3,r2
8113171c:	1001703a 	wrctl	status,r2
  
  return context;
81131720:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81131724:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
81131728:	e0bffe03 	ldbu	r2,-8(fp)
8113172c:	10000326 	beq	r2,zero,8113173c <OSFlagPost+0xbc>
81131730:	10800060 	cmpeqi	r2,r2,1
81131734:	10000b1e 	bne	r2,zero,81131764 <OSFlagPost+0xe4>
81131738:	00001206 	br	81131784 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113173c:	e0bffc17 	ldw	r2,-16(fp)
81131740:	1080020b 	ldhu	r2,8(r2)
81131744:	1007883a 	mov	r3,r2
81131748:	e0bffd0b 	ldhu	r2,-12(fp)
8113174c:	0084303a 	nor	r2,zero,r2
81131750:	1884703a 	and	r2,r3,r2
81131754:	1007883a 	mov	r3,r2
81131758:	e0bffc17 	ldw	r2,-16(fp)
8113175c:	10c0020d 	sth	r3,8(r2)
             break;
81131760:	00001106 	br	811317a8 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
81131764:	e0bffc17 	ldw	r2,-16(fp)
81131768:	10c0020b 	ldhu	r3,8(r2)
8113176c:	e0bffd0b 	ldhu	r2,-12(fp)
81131770:	1884b03a 	or	r2,r3,r2
81131774:	1007883a 	mov	r3,r2
81131778:	e0bffc17 	ldw	r2,-16(fp)
8113177c:	10c0020d 	sth	r3,8(r2)
             break;
81131780:	00000906 	br	811317a8 <OSFlagPost+0x128>
81131784:	e0bff317 	ldw	r2,-52(fp)
81131788:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113178c:	e0bff417 	ldw	r2,-48(fp)
81131790:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
81131794:	e0bfff17 	ldw	r2,-4(fp)
81131798:	00c01c44 	movi	r3,113
8113179c:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
811317a0:	0005883a 	mov	r2,zero
811317a4:	00009806 	br	81131a08 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
811317a8:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
811317ac:	e0bffc17 	ldw	r2,-16(fp)
811317b0:	10800117 	ldw	r2,4(r2)
811317b4:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
811317b8:	00007706 	br	81131998 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
811317bc:	e0bff117 	ldw	r2,-60(fp)
811317c0:	10800483 	ldbu	r2,18(r2)
811317c4:	10803fcc 	andi	r2,r2,255
811317c8:	10c00060 	cmpeqi	r3,r2,1
811317cc:	18004a1e 	bne	r3,zero,811318f8 <OSFlagPost+0x278>
811317d0:	10c00088 	cmpgei	r3,r2,2
811317d4:	1800021e 	bne	r3,zero,811317e0 <OSFlagPost+0x160>
811317d8:	10002f26 	beq	r2,zero,81131898 <OSFlagPost+0x218>
811317dc:	00005b06 	br	8113194c <OSFlagPost+0x2cc>
811317e0:	10c000a0 	cmpeqi	r3,r2,2
811317e4:	1800031e 	bne	r3,zero,811317f4 <OSFlagPost+0x174>
811317e8:	108000e0 	cmpeqi	r2,r2,3
811317ec:	1000171e 	bne	r2,zero,8113184c <OSFlagPost+0x1cc>
811317f0:	00005606 	br	8113194c <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811317f4:	e0bffc17 	ldw	r2,-16(fp)
811317f8:	10c0020b 	ldhu	r3,8(r2)
811317fc:	e0bff117 	ldw	r2,-60(fp)
81131800:	1080040b 	ldhu	r2,16(r2)
81131804:	1884703a 	and	r2,r3,r2
81131808:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113180c:	e0bff117 	ldw	r2,-60(fp)
81131810:	1080040b 	ldhu	r2,16(r2)
81131814:	10ffffcc 	andi	r3,r2,65535
81131818:	e0bff60b 	ldhu	r2,-40(fp)
8113181c:	1880541e 	bne	r3,r2,81131970 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81131820:	e0bff60b 	ldhu	r2,-40(fp)
81131824:	100b883a 	mov	r5,r2
81131828:	e13ff117 	ldw	r4,-60(fp)
8113182c:	1131d380 	call	81131d38 <OS_FlagTaskRdy>
81131830:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81131834:	e0bff683 	ldbu	r2,-38(fp)
81131838:	10800058 	cmpnei	r2,r2,1
8113183c:	10004c1e 	bne	r2,zero,81131970 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81131840:	00800044 	movi	r2,1
81131844:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81131848:	00004906 	br	81131970 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113184c:	e0bffc17 	ldw	r2,-16(fp)
81131850:	10c0020b 	ldhu	r3,8(r2)
81131854:	e0bff117 	ldw	r2,-60(fp)
81131858:	1080040b 	ldhu	r2,16(r2)
8113185c:	1884703a 	and	r2,r3,r2
81131860:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81131864:	e0bff60b 	ldhu	r2,-40(fp)
81131868:	10004326 	beq	r2,zero,81131978 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113186c:	e0bff60b 	ldhu	r2,-40(fp)
81131870:	100b883a 	mov	r5,r2
81131874:	e13ff117 	ldw	r4,-60(fp)
81131878:	1131d380 	call	81131d38 <OS_FlagTaskRdy>
8113187c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81131880:	e0bff683 	ldbu	r2,-38(fp)
81131884:	10800058 	cmpnei	r2,r2,1
81131888:	10003b1e 	bne	r2,zero,81131978 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113188c:	00800044 	movi	r2,1
81131890:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81131894:	00003806 	br	81131978 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81131898:	e0bffc17 	ldw	r2,-16(fp)
8113189c:	1080020b 	ldhu	r2,8(r2)
811318a0:	0084303a 	nor	r2,zero,r2
811318a4:	1007883a 	mov	r3,r2
811318a8:	e0bff117 	ldw	r2,-60(fp)
811318ac:	1080040b 	ldhu	r2,16(r2)
811318b0:	1884703a 	and	r2,r3,r2
811318b4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
811318b8:	e0bff117 	ldw	r2,-60(fp)
811318bc:	1080040b 	ldhu	r2,16(r2)
811318c0:	10ffffcc 	andi	r3,r2,65535
811318c4:	e0bff60b 	ldhu	r2,-40(fp)
811318c8:	18802d1e 	bne	r3,r2,81131980 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811318cc:	e0bff60b 	ldhu	r2,-40(fp)
811318d0:	100b883a 	mov	r5,r2
811318d4:	e13ff117 	ldw	r4,-60(fp)
811318d8:	1131d380 	call	81131d38 <OS_FlagTaskRdy>
811318dc:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811318e0:	e0bff683 	ldbu	r2,-38(fp)
811318e4:	10800058 	cmpnei	r2,r2,1
811318e8:	1000251e 	bne	r2,zero,81131980 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811318ec:	00800044 	movi	r2,1
811318f0:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811318f4:	00002206 	br	81131980 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811318f8:	e0bffc17 	ldw	r2,-16(fp)
811318fc:	1080020b 	ldhu	r2,8(r2)
81131900:	0084303a 	nor	r2,zero,r2
81131904:	1007883a 	mov	r3,r2
81131908:	e0bff117 	ldw	r2,-60(fp)
8113190c:	1080040b 	ldhu	r2,16(r2)
81131910:	1884703a 	and	r2,r3,r2
81131914:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81131918:	e0bff60b 	ldhu	r2,-40(fp)
8113191c:	10001a26 	beq	r2,zero,81131988 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81131920:	e0bff60b 	ldhu	r2,-40(fp)
81131924:	100b883a 	mov	r5,r2
81131928:	e13ff117 	ldw	r4,-60(fp)
8113192c:	1131d380 	call	81131d38 <OS_FlagTaskRdy>
81131930:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81131934:	e0bff683 	ldbu	r2,-38(fp)
81131938:	10800058 	cmpnei	r2,r2,1
8113193c:	1000121e 	bne	r2,zero,81131988 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81131940:	00800044 	movi	r2,1
81131944:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81131948:	00000f06 	br	81131988 <OSFlagPost+0x308>
8113194c:	e0bff317 	ldw	r2,-52(fp)
81131950:	e0bff515 	stw	r2,-44(fp)
81131954:	e0bff517 	ldw	r2,-44(fp)
81131958:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113195c:	e0bfff17 	ldw	r2,-4(fp)
81131960:	00c01bc4 	movi	r3,111
81131964:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81131968:	0005883a 	mov	r2,zero
8113196c:	00002606 	br	81131a08 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81131970:	0001883a 	nop
81131974:	00000506 	br	8113198c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81131978:	0001883a 	nop
8113197c:	00000306 	br	8113198c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81131980:	0001883a 	nop
81131984:	00000106 	br	8113198c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81131988:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113198c:	e0bff117 	ldw	r2,-60(fp)
81131990:	10800017 	ldw	r2,0(r2)
81131994:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81131998:	e0bff117 	ldw	r2,-60(fp)
8113199c:	103f871e 	bne	r2,zero,811317bc <__reset+0xfb1117bc>
811319a0:	e0bff317 	ldw	r2,-52(fp)
811319a4:	e0bff715 	stw	r2,-36(fp)
811319a8:	e0bff717 	ldw	r2,-36(fp)
811319ac:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
811319b0:	e0bff203 	ldbu	r2,-56(fp)
811319b4:	10800058 	cmpnei	r2,r2,1
811319b8:	1000011e 	bne	r2,zero,811319c0 <OSFlagPost+0x340>
        OS_Sched();
811319bc:	112fe480 	call	8112fe48 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811319c0:	0005303a 	rdctl	r2,status
811319c4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811319c8:	e0fffa17 	ldw	r3,-24(fp)
811319cc:	00bfff84 	movi	r2,-2
811319d0:	1884703a 	and	r2,r3,r2
811319d4:	1001703a 	wrctl	status,r2
  
  return context;
811319d8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
811319dc:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
811319e0:	e0bffc17 	ldw	r2,-16(fp)
811319e4:	1080020b 	ldhu	r2,8(r2)
811319e8:	e0bff90d 	sth	r2,-28(fp)
811319ec:	e0bff317 	ldw	r2,-52(fp)
811319f0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811319f4:	e0bff817 	ldw	r2,-32(fp)
811319f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
811319fc:	e0bfff17 	ldw	r2,-4(fp)
81131a00:	10000005 	stb	zero,0(r2)
    return (flags_cur);
81131a04:	e0bff90b 	ldhu	r2,-28(fp)
}
81131a08:	e037883a 	mov	sp,fp
81131a0c:	dfc00117 	ldw	ra,4(sp)
81131a10:	df000017 	ldw	fp,0(sp)
81131a14:	dec00204 	addi	sp,sp,8
81131a18:	f800283a 	ret

81131a1c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
81131a1c:	defff904 	addi	sp,sp,-28
81131a20:	de00012e 	bgeu	sp,et,81131a28 <OSFlagQuery+0xc>
81131a24:	003b68fa 	trap	3
81131a28:	df000615 	stw	fp,24(sp)
81131a2c:	df000604 	addi	fp,sp,24
81131a30:	e13ffe15 	stw	r4,-8(fp)
81131a34:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
81131a38:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
81131a3c:	e0bfff17 	ldw	r2,-4(fp)
81131a40:	1000021e 	bne	r2,zero,81131a4c <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
81131a44:	0005883a 	mov	r2,zero
81131a48:	00002306 	br	81131ad8 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
81131a4c:	e0bffe17 	ldw	r2,-8(fp)
81131a50:	1000051e 	bne	r2,zero,81131a68 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81131a54:	e0bfff17 	ldw	r2,-4(fp)
81131a58:	00c01b84 	movi	r3,110
81131a5c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81131a60:	0005883a 	mov	r2,zero
81131a64:	00001c06 	br	81131ad8 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
81131a68:	e0bffe17 	ldw	r2,-8(fp)
81131a6c:	10800003 	ldbu	r2,0(r2)
81131a70:	10803fcc 	andi	r2,r2,255
81131a74:	10800160 	cmpeqi	r2,r2,5
81131a78:	1000051e 	bne	r2,zero,81131a90 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81131a7c:	e0bfff17 	ldw	r2,-4(fp)
81131a80:	00c00044 	movi	r3,1
81131a84:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81131a88:	0005883a 	mov	r2,zero
81131a8c:	00001206 	br	81131ad8 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131a90:	0005303a 	rdctl	r2,status
81131a94:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131a98:	e0fffc17 	ldw	r3,-16(fp)
81131a9c:	00bfff84 	movi	r2,-2
81131aa0:	1884703a 	and	r2,r3,r2
81131aa4:	1001703a 	wrctl	status,r2
  
  return context;
81131aa8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81131aac:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
81131ab0:	e0bffe17 	ldw	r2,-8(fp)
81131ab4:	1080020b 	ldhu	r2,8(r2)
81131ab8:	e0bffb0d 	sth	r2,-20(fp)
81131abc:	e0bffa17 	ldw	r2,-24(fp)
81131ac0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131ac4:	e0bffd17 	ldw	r2,-12(fp)
81131ac8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81131acc:	e0bfff17 	ldw	r2,-4(fp)
81131ad0:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
81131ad4:	e0bffb0b 	ldhu	r2,-20(fp)
}
81131ad8:	e037883a 	mov	sp,fp
81131adc:	df000017 	ldw	fp,0(sp)
81131ae0:	dec00104 	addi	sp,sp,4
81131ae4:	f800283a 	ret

81131ae8 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
81131ae8:	defff804 	addi	sp,sp,-32
81131aec:	de00012e 	bgeu	sp,et,81131af4 <OS_FlagBlock+0xc>
81131af0:	003b68fa 	trap	3
81131af4:	df000715 	stw	fp,28(sp)
81131af8:	df000704 	addi	fp,sp,28
81131afc:	e13ffb15 	stw	r4,-20(fp)
81131b00:	e17ffc15 	stw	r5,-16(fp)
81131b04:	3009883a 	mov	r4,r6
81131b08:	3807883a 	mov	r3,r7
81131b0c:	e0800117 	ldw	r2,4(fp)
81131b10:	e13ffd0d 	sth	r4,-12(fp)
81131b14:	e0fffe05 	stb	r3,-8(fp)
81131b18:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
81131b1c:	d0a09317 	ldw	r2,-32180(gp)
81131b20:	d0e09317 	ldw	r3,-32180(gp)
81131b24:	18c00c03 	ldbu	r3,48(r3)
81131b28:	18c00814 	ori	r3,r3,32
81131b2c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
81131b30:	d0a09317 	ldw	r2,-32180(gp)
81131b34:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
81131b38:	d0a09317 	ldw	r2,-32180(gp)
81131b3c:	e0ffff0b 	ldhu	r3,-4(fp)
81131b40:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
81131b44:	d0a09317 	ldw	r2,-32180(gp)
81131b48:	e0fffc17 	ldw	r3,-16(fp)
81131b4c:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
81131b50:	e0bffc17 	ldw	r2,-16(fp)
81131b54:	e0fffd0b 	ldhu	r3,-12(fp)
81131b58:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
81131b5c:	e0bffc17 	ldw	r2,-16(fp)
81131b60:	e0fffe03 	ldbu	r3,-8(fp)
81131b64:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
81131b68:	d0e09317 	ldw	r3,-32180(gp)
81131b6c:	e0bffc17 	ldw	r2,-16(fp)
81131b70:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
81131b74:	e0bffb17 	ldw	r2,-20(fp)
81131b78:	10c00117 	ldw	r3,4(r2)
81131b7c:	e0bffc17 	ldw	r2,-16(fp)
81131b80:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
81131b84:	e0bffc17 	ldw	r2,-16(fp)
81131b88:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
81131b8c:	e0bffc17 	ldw	r2,-16(fp)
81131b90:	e0fffb17 	ldw	r3,-20(fp)
81131b94:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81131b98:	e0bffb17 	ldw	r2,-20(fp)
81131b9c:	10800117 	ldw	r2,4(r2)
81131ba0:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
81131ba4:	e0bff917 	ldw	r2,-28(fp)
81131ba8:	10000326 	beq	r2,zero,81131bb8 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
81131bac:	e0bff917 	ldw	r2,-28(fp)
81131bb0:	e0fffc17 	ldw	r3,-16(fp)
81131bb4:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
81131bb8:	e0bffb17 	ldw	r2,-20(fp)
81131bbc:	e0fffc17 	ldw	r3,-16(fp)
81131bc0:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
81131bc4:	d0a09317 	ldw	r2,-32180(gp)
81131bc8:	10800d03 	ldbu	r2,52(r2)
81131bcc:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81131bd0:	e0fffa03 	ldbu	r3,-24(fp)
81131bd4:	e13ffa03 	ldbu	r4,-24(fp)
81131bd8:	d0a08f44 	addi	r2,gp,-32195
81131bdc:	2085883a 	add	r2,r4,r2
81131be0:	10800003 	ldbu	r2,0(r2)
81131be4:	1009883a 	mov	r4,r2
81131be8:	d0a09317 	ldw	r2,-32180(gp)
81131bec:	10800d43 	ldbu	r2,53(r2)
81131bf0:	0084303a 	nor	r2,zero,r2
81131bf4:	2084703a 	and	r2,r4,r2
81131bf8:	1009883a 	mov	r4,r2
81131bfc:	d0a08f44 	addi	r2,gp,-32195
81131c00:	1885883a 	add	r2,r3,r2
81131c04:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
81131c08:	e0fffa03 	ldbu	r3,-24(fp)
81131c0c:	d0a08f44 	addi	r2,gp,-32195
81131c10:	1885883a 	add	r2,r3,r2
81131c14:	10800003 	ldbu	r2,0(r2)
81131c18:	10803fcc 	andi	r2,r2,255
81131c1c:	1000071e 	bne	r2,zero,81131c3c <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81131c20:	d0a09317 	ldw	r2,-32180(gp)
81131c24:	10800d83 	ldbu	r2,54(r2)
81131c28:	0084303a 	nor	r2,zero,r2
81131c2c:	1007883a 	mov	r3,r2
81131c30:	d0a08f03 	ldbu	r2,-32196(gp)
81131c34:	1884703a 	and	r2,r3,r2
81131c38:	d0a08f05 	stb	r2,-32196(gp)
    }
}
81131c3c:	0001883a 	nop
81131c40:	e037883a 	mov	sp,fp
81131c44:	df000017 	ldw	fp,0(sp)
81131c48:	dec00104 	addi	sp,sp,4
81131c4c:	f800283a 	ret

81131c50 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
81131c50:	defffb04 	addi	sp,sp,-20
81131c54:	de00012e 	bgeu	sp,et,81131c5c <OS_FlagInit+0xc>
81131c58:	003b68fa 	trap	3
81131c5c:	dfc00415 	stw	ra,16(sp)
81131c60:	df000315 	stw	fp,12(sp)
81131c64:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
81131c68:	01416004 	movi	r5,1408
81131c6c:	012045b4 	movhi	r4,33046
81131c70:	21321704 	addi	r4,r4,-14244
81131c74:	112fd7c0 	call	8112fd7c <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
81131c78:	00a045b4 	movhi	r2,33046
81131c7c:	10b21704 	addi	r2,r2,-14244
81131c80:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
81131c84:	00a045b4 	movhi	r2,33046
81131c88:	10b22204 	addi	r2,r2,-14200
81131c8c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81131c90:	e03ffd0d 	sth	zero,-12(fp)
81131c94:	00001306 	br	81131ce4 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81131c98:	e0bffe17 	ldw	r2,-8(fp)
81131c9c:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
81131ca0:	e0bffe17 	ldw	r2,-8(fp)
81131ca4:	e0ffff17 	ldw	r3,-4(fp)
81131ca8:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
81131cac:	e0bffe17 	ldw	r2,-8(fp)
81131cb0:	00c00fc4 	movi	r3,63
81131cb4:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81131cb8:	e0bffe17 	ldw	r2,-8(fp)
81131cbc:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
81131cc0:	e0bffe17 	ldw	r2,-8(fp)
81131cc4:	10800b04 	addi	r2,r2,44
81131cc8:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
81131ccc:	e0bfff17 	ldw	r2,-4(fp)
81131cd0:	10800b04 	addi	r2,r2,44
81131cd4:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81131cd8:	e0bffd0b 	ldhu	r2,-12(fp)
81131cdc:	10800044 	addi	r2,r2,1
81131ce0:	e0bffd0d 	sth	r2,-12(fp)
81131ce4:	e0bffd0b 	ldhu	r2,-12(fp)
81131ce8:	108007f0 	cmpltui	r2,r2,31
81131cec:	103fea1e 	bne	r2,zero,81131c98 <__reset+0xfb111c98>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81131cf0:	e0bffe17 	ldw	r2,-8(fp)
81131cf4:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
81131cf8:	e0bffe17 	ldw	r2,-8(fp)
81131cfc:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
81131d00:	e0bffe17 	ldw	r2,-8(fp)
81131d04:	00c00fc4 	movi	r3,63
81131d08:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81131d0c:	e0bffe17 	ldw	r2,-8(fp)
81131d10:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
81131d14:	00a045b4 	movhi	r2,33046
81131d18:	10b21704 	addi	r2,r2,-14244
81131d1c:	d0a09715 	stw	r2,-32164(gp)
#endif
}
81131d20:	0001883a 	nop
81131d24:	e037883a 	mov	sp,fp
81131d28:	dfc00117 	ldw	ra,4(sp)
81131d2c:	df000017 	ldw	fp,0(sp)
81131d30:	dec00204 	addi	sp,sp,8
81131d34:	f800283a 	ret

81131d38 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
81131d38:	defffa04 	addi	sp,sp,-24
81131d3c:	de00012e 	bgeu	sp,et,81131d44 <OS_FlagTaskRdy+0xc>
81131d40:	003b68fa 	trap	3
81131d44:	dfc00515 	stw	ra,20(sp)
81131d48:	df000415 	stw	fp,16(sp)
81131d4c:	df000404 	addi	fp,sp,16
81131d50:	e13ffe15 	stw	r4,-8(fp)
81131d54:	2805883a 	mov	r2,r5
81131d58:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
81131d5c:	e0bffe17 	ldw	r2,-8(fp)
81131d60:	10800217 	ldw	r2,8(r2)
81131d64:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
81131d68:	e0bffd17 	ldw	r2,-12(fp)
81131d6c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
81131d70:	e0bffd17 	ldw	r2,-12(fp)
81131d74:	e0ffff0b 	ldhu	r3,-4(fp)
81131d78:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
81131d7c:	e0bffd17 	ldw	r2,-12(fp)
81131d80:	10c00c03 	ldbu	r3,48(r2)
81131d84:	00bff7c4 	movi	r2,-33
81131d88:	1884703a 	and	r2,r3,r2
81131d8c:	1007883a 	mov	r3,r2
81131d90:	e0bffd17 	ldw	r2,-12(fp)
81131d94:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
81131d98:	e0bffd17 	ldw	r2,-12(fp)
81131d9c:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
81131da0:	e0bffd17 	ldw	r2,-12(fp)
81131da4:	10800c03 	ldbu	r2,48(r2)
81131da8:	10803fcc 	andi	r2,r2,255
81131dac:	1000181e 	bne	r2,zero,81131e10 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
81131db0:	e0bffd17 	ldw	r2,-12(fp)
81131db4:	10c00d83 	ldbu	r3,54(r2)
81131db8:	d0a08f03 	ldbu	r2,-32196(gp)
81131dbc:	1884b03a 	or	r2,r3,r2
81131dc0:	d0a08f05 	stb	r2,-32196(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81131dc4:	e0bffd17 	ldw	r2,-12(fp)
81131dc8:	10800d03 	ldbu	r2,52(r2)
81131dcc:	10c03fcc 	andi	r3,r2,255
81131dd0:	e0bffd17 	ldw	r2,-12(fp)
81131dd4:	10800d03 	ldbu	r2,52(r2)
81131dd8:	11003fcc 	andi	r4,r2,255
81131ddc:	d0a08f44 	addi	r2,gp,-32195
81131de0:	2085883a 	add	r2,r4,r2
81131de4:	11000003 	ldbu	r4,0(r2)
81131de8:	e0bffd17 	ldw	r2,-12(fp)
81131dec:	10800d43 	ldbu	r2,53(r2)
81131df0:	2084b03a 	or	r2,r4,r2
81131df4:	1009883a 	mov	r4,r2
81131df8:	d0a08f44 	addi	r2,gp,-32195
81131dfc:	1885883a 	add	r2,r3,r2
81131e00:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
81131e04:	00800044 	movi	r2,1
81131e08:	e0bffc05 	stb	r2,-16(fp)
81131e0c:	00000106 	br	81131e14 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81131e10:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
81131e14:	e13ffe17 	ldw	r4,-8(fp)
81131e18:	1131e340 	call	81131e34 <OS_FlagUnlink>
    return (sched);
81131e1c:	e0bffc03 	ldbu	r2,-16(fp)
}
81131e20:	e037883a 	mov	sp,fp
81131e24:	dfc00117 	ldw	ra,4(sp)
81131e28:	df000017 	ldw	fp,0(sp)
81131e2c:	dec00204 	addi	sp,sp,8
81131e30:	f800283a 	ret

81131e34 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
81131e34:	defffa04 	addi	sp,sp,-24
81131e38:	de00012e 	bgeu	sp,et,81131e40 <OS_FlagUnlink+0xc>
81131e3c:	003b68fa 	trap	3
81131e40:	df000515 	stw	fp,20(sp)
81131e44:	df000504 	addi	fp,sp,20
81131e48:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
81131e4c:	e0bfff17 	ldw	r2,-4(fp)
81131e50:	10800117 	ldw	r2,4(r2)
81131e54:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81131e58:	e0bfff17 	ldw	r2,-4(fp)
81131e5c:	10800017 	ldw	r2,0(r2)
81131e60:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
81131e64:	e0bffb17 	ldw	r2,-20(fp)
81131e68:	10000b1e 	bne	r2,zero,81131e98 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
81131e6c:	e0bfff17 	ldw	r2,-4(fp)
81131e70:	10800317 	ldw	r2,12(r2)
81131e74:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
81131e78:	e0bffd17 	ldw	r2,-12(fp)
81131e7c:	e0fffc17 	ldw	r3,-16(fp)
81131e80:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
81131e84:	e0bffc17 	ldw	r2,-16(fp)
81131e88:	10000b26 	beq	r2,zero,81131eb8 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
81131e8c:	e0bffc17 	ldw	r2,-16(fp)
81131e90:	10000115 	stw	zero,4(r2)
81131e94:	00000806 	br	81131eb8 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
81131e98:	e0bffb17 	ldw	r2,-20(fp)
81131e9c:	e0fffc17 	ldw	r3,-16(fp)
81131ea0:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
81131ea4:	e0bffc17 	ldw	r2,-16(fp)
81131ea8:	10000326 	beq	r2,zero,81131eb8 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
81131eac:	e0bffc17 	ldw	r2,-16(fp)
81131eb0:	e0fffb17 	ldw	r3,-20(fp)
81131eb4:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
81131eb8:	e0bfff17 	ldw	r2,-4(fp)
81131ebc:	10800217 	ldw	r2,8(r2)
81131ec0:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
81131ec4:	e0bffe17 	ldw	r2,-8(fp)
81131ec8:	10000a15 	stw	zero,40(r2)
#endif
}
81131ecc:	0001883a 	nop
81131ed0:	e037883a 	mov	sp,fp
81131ed4:	df000017 	ldw	fp,0(sp)
81131ed8:	dec00104 	addi	sp,sp,4
81131edc:	f800283a 	ret

81131ee0 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
81131ee0:	defff404 	addi	sp,sp,-48
81131ee4:	de00012e 	bgeu	sp,et,81131eec <OSMemCreate+0xc>
81131ee8:	003b68fa 	trap	3
81131eec:	df000b15 	stw	fp,44(sp)
81131ef0:	df000b04 	addi	fp,sp,44
81131ef4:	e13ffc15 	stw	r4,-16(fp)
81131ef8:	e17ffd15 	stw	r5,-12(fp)
81131efc:	e1bffe15 	stw	r6,-8(fp)
81131f00:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81131f04:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81131f08:	e0bfff17 	ldw	r2,-4(fp)
81131f0c:	1000021e 	bne	r2,zero,81131f18 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81131f10:	0005883a 	mov	r2,zero
81131f14:	00006506 	br	811320ac <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
81131f18:	e0bffc17 	ldw	r2,-16(fp)
81131f1c:	1000051e 	bne	r2,zero,81131f34 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81131f20:	e0bfff17 	ldw	r2,-4(fp)
81131f24:	00c01884 	movi	r3,98
81131f28:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81131f2c:	0005883a 	mov	r2,zero
81131f30:	00005e06 	br	811320ac <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
81131f34:	e0bffc17 	ldw	r2,-16(fp)
81131f38:	108000cc 	andi	r2,r2,3
81131f3c:	10000526 	beq	r2,zero,81131f54 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81131f40:	e0bfff17 	ldw	r2,-4(fp)
81131f44:	00c01884 	movi	r3,98
81131f48:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81131f4c:	0005883a 	mov	r2,zero
81131f50:	00005606 	br	811320ac <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
81131f54:	e0bffd17 	ldw	r2,-12(fp)
81131f58:	108000a8 	cmpgeui	r2,r2,2
81131f5c:	1000051e 	bne	r2,zero,81131f74 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
81131f60:	e0bfff17 	ldw	r2,-4(fp)
81131f64:	00c016c4 	movi	r3,91
81131f68:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81131f6c:	0005883a 	mov	r2,zero
81131f70:	00004e06 	br	811320ac <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
81131f74:	e0bffe17 	ldw	r2,-8(fp)
81131f78:	10800128 	cmpgeui	r2,r2,4
81131f7c:	1000051e 	bne	r2,zero,81131f94 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
81131f80:	e0bfff17 	ldw	r2,-4(fp)
81131f84:	00c01704 	movi	r3,92
81131f88:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81131f8c:	0005883a 	mov	r2,zero
81131f90:	00004606 	br	811320ac <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131f94:	0005303a 	rdctl	r2,status
81131f98:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131f9c:	e0fffb17 	ldw	r3,-20(fp)
81131fa0:	00bfff84 	movi	r2,-2
81131fa4:	1884703a 	and	r2,r3,r2
81131fa8:	1001703a 	wrctl	status,r2
  
  return context;
81131fac:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81131fb0:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
81131fb4:	d0a08c17 	ldw	r2,-32208(gp)
81131fb8:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
81131fbc:	d0a08c17 	ldw	r2,-32208(gp)
81131fc0:	10000326 	beq	r2,zero,81131fd0 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
81131fc4:	d0a08c17 	ldw	r2,-32208(gp)
81131fc8:	10800117 	ldw	r2,4(r2)
81131fcc:	d0a08c15 	stw	r2,-32208(gp)
81131fd0:	e0bff817 	ldw	r2,-32(fp)
81131fd4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131fd8:	e0bff917 	ldw	r2,-28(fp)
81131fdc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
81131fe0:	e0bffa17 	ldw	r2,-24(fp)
81131fe4:	1000051e 	bne	r2,zero,81131ffc <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
81131fe8:	e0bfff17 	ldw	r2,-4(fp)
81131fec:	00c01684 	movi	r3,90
81131ff0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81131ff4:	0005883a 	mov	r2,zero
81131ff8:	00002c06 	br	811320ac <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
81131ffc:	e0bffc17 	ldw	r2,-16(fp)
81132000:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
81132004:	e0fffc17 	ldw	r3,-16(fp)
81132008:	e0bffe17 	ldw	r2,-8(fp)
8113200c:	1885883a 	add	r2,r3,r2
81132010:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81132014:	e03ff715 	stw	zero,-36(fp)
81132018:	00000c06 	br	8113204c <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113201c:	e0bff617 	ldw	r2,-40(fp)
81132020:	e0fff517 	ldw	r3,-44(fp)
81132024:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
81132028:	e0bff517 	ldw	r2,-44(fp)
8113202c:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
81132030:	e0fff517 	ldw	r3,-44(fp)
81132034:	e0bffe17 	ldw	r2,-8(fp)
81132038:	1885883a 	add	r2,r3,r2
8113203c:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
81132040:	e0bff717 	ldw	r2,-36(fp)
81132044:	10800044 	addi	r2,r2,1
81132048:	e0bff715 	stw	r2,-36(fp)
8113204c:	e0bffd17 	ldw	r2,-12(fp)
81132050:	10bfffc4 	addi	r2,r2,-1
81132054:	e0fff717 	ldw	r3,-36(fp)
81132058:	18bff036 	bltu	r3,r2,8113201c <__reset+0xfb11201c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113205c:	e0bff617 	ldw	r2,-40(fp)
81132060:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
81132064:	e0bffa17 	ldw	r2,-24(fp)
81132068:	e0fffc17 	ldw	r3,-16(fp)
8113206c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
81132070:	e0bffa17 	ldw	r2,-24(fp)
81132074:	e0fffc17 	ldw	r3,-16(fp)
81132078:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113207c:	e0bffa17 	ldw	r2,-24(fp)
81132080:	e0fffd17 	ldw	r3,-12(fp)
81132084:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
81132088:	e0bffa17 	ldw	r2,-24(fp)
8113208c:	e0fffd17 	ldw	r3,-12(fp)
81132090:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81132094:	e0bffa17 	ldw	r2,-24(fp)
81132098:	e0fffe17 	ldw	r3,-8(fp)
8113209c:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
811320a0:	e0bfff17 	ldw	r2,-4(fp)
811320a4:	10000005 	stb	zero,0(r2)
    return (pmem);
811320a8:	e0bffa17 	ldw	r2,-24(fp)
}
811320ac:	e037883a 	mov	sp,fp
811320b0:	df000017 	ldw	fp,0(sp)
811320b4:	dec00104 	addi	sp,sp,4
811320b8:	f800283a 	ret

811320bc <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
811320bc:	defff804 	addi	sp,sp,-32
811320c0:	de00012e 	bgeu	sp,et,811320c8 <OSMemGet+0xc>
811320c4:	003b68fa 	trap	3
811320c8:	df000715 	stw	fp,28(sp)
811320cc:	df000704 	addi	fp,sp,28
811320d0:	e13ffe15 	stw	r4,-8(fp)
811320d4:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811320d8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
811320dc:	e0bfff17 	ldw	r2,-4(fp)
811320e0:	1000021e 	bne	r2,zero,811320ec <OSMemGet+0x30>
        return ((void *)0);
811320e4:	0005883a 	mov	r2,zero
811320e8:	00002e06 	br	811321a4 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
811320ec:	e0bffe17 	ldw	r2,-8(fp)
811320f0:	1000051e 	bne	r2,zero,81132108 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
811320f4:	e0bfff17 	ldw	r2,-4(fp)
811320f8:	00c01804 	movi	r3,96
811320fc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81132100:	0005883a 	mov	r2,zero
81132104:	00002706 	br	811321a4 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132108:	0005303a 	rdctl	r2,status
8113210c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132110:	e0fffd17 	ldw	r3,-12(fp)
81132114:	00bfff84 	movi	r2,-2
81132118:	1884703a 	and	r2,r3,r2
8113211c:	1001703a 	wrctl	status,r2
  
  return context;
81132120:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81132124:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
81132128:	e0bffe17 	ldw	r2,-8(fp)
8113212c:	10800417 	ldw	r2,16(r2)
81132130:	10001426 	beq	r2,zero,81132184 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
81132134:	e0bffe17 	ldw	r2,-8(fp)
81132138:	10800117 	ldw	r2,4(r2)
8113213c:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
81132140:	e0bffb17 	ldw	r2,-20(fp)
81132144:	10c00017 	ldw	r3,0(r2)
81132148:	e0bffe17 	ldw	r2,-8(fp)
8113214c:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
81132150:	e0bffe17 	ldw	r2,-8(fp)
81132154:	10800417 	ldw	r2,16(r2)
81132158:	10ffffc4 	addi	r3,r2,-1
8113215c:	e0bffe17 	ldw	r2,-8(fp)
81132160:	10c00415 	stw	r3,16(r2)
81132164:	e0bff917 	ldw	r2,-28(fp)
81132168:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113216c:	e0bffa17 	ldw	r2,-24(fp)
81132170:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
81132174:	e0bfff17 	ldw	r2,-4(fp)
81132178:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113217c:	e0bffb17 	ldw	r2,-20(fp)
81132180:	00000806 	br	811321a4 <OSMemGet+0xe8>
81132184:	e0bff917 	ldw	r2,-28(fp)
81132188:	e0bffc15 	stw	r2,-16(fp)
8113218c:	e0bffc17 	ldw	r2,-16(fp)
81132190:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81132194:	e0bfff17 	ldw	r2,-4(fp)
81132198:	00c01744 	movi	r3,93
8113219c:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
811321a0:	0005883a 	mov	r2,zero
}
811321a4:	e037883a 	mov	sp,fp
811321a8:	df000017 	ldw	fp,0(sp)
811321ac:	dec00104 	addi	sp,sp,4
811321b0:	f800283a 	ret

811321b4 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
811321b4:	defff704 	addi	sp,sp,-36
811321b8:	de00012e 	bgeu	sp,et,811321c0 <OSMemNameGet+0xc>
811321bc:	003b68fa 	trap	3
811321c0:	dfc00815 	stw	ra,32(sp)
811321c4:	df000715 	stw	fp,28(sp)
811321c8:	df000704 	addi	fp,sp,28
811321cc:	e13ffd15 	stw	r4,-12(fp)
811321d0:	e17ffe15 	stw	r5,-8(fp)
811321d4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811321d8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811321dc:	e0bfff17 	ldw	r2,-4(fp)
811321e0:	1000021e 	bne	r2,zero,811321ec <OSMemNameGet+0x38>
        return (0);
811321e4:	0005883a 	mov	r2,zero
811321e8:	00002b06 	br	81132298 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
811321ec:	e0bffd17 	ldw	r2,-12(fp)
811321f0:	1000051e 	bne	r2,zero,81132208 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
811321f4:	e0bfff17 	ldw	r2,-4(fp)
811321f8:	00c01804 	movi	r3,96
811321fc:	10c00005 	stb	r3,0(r2)
        return (0);
81132200:	0005883a 	mov	r2,zero
81132204:	00002406 	br	81132298 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81132208:	e0bffe17 	ldw	r2,-8(fp)
8113220c:	1000051e 	bne	r2,zero,81132224 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81132210:	e0bfff17 	ldw	r2,-4(fp)
81132214:	00c00304 	movi	r3,12
81132218:	10c00005 	stb	r3,0(r2)
        return (0);
8113221c:	0005883a 	mov	r2,zero
81132220:	00001d06 	br	81132298 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81132224:	d0a09203 	ldbu	r2,-32184(gp)
81132228:	10803fcc 	andi	r2,r2,255
8113222c:	10000526 	beq	r2,zero,81132244 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81132230:	e0bfff17 	ldw	r2,-4(fp)
81132234:	00c00444 	movi	r3,17
81132238:	10c00005 	stb	r3,0(r2)
        return (0);
8113223c:	0005883a 	mov	r2,zero
81132240:	00001506 	br	81132298 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132244:	0005303a 	rdctl	r2,status
81132248:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113224c:	e0fffb17 	ldw	r3,-20(fp)
81132250:	00bfff84 	movi	r2,-2
81132254:	1884703a 	and	r2,r3,r2
81132258:	1001703a 	wrctl	status,r2
  
  return context;
8113225c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
81132260:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
81132264:	e0bffd17 	ldw	r2,-12(fp)
81132268:	10800504 	addi	r2,r2,20
8113226c:	100b883a 	mov	r5,r2
81132270:	e13ffe17 	ldw	r4,-8(fp)
81132274:	112ff9c0 	call	8112ff9c <OS_StrCopy>
81132278:	e0bffa05 	stb	r2,-24(fp)
8113227c:	e0bff917 	ldw	r2,-28(fp)
81132280:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132284:	e0bffc17 	ldw	r2,-16(fp)
81132288:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113228c:	e0bfff17 	ldw	r2,-4(fp)
81132290:	10000005 	stb	zero,0(r2)
    return (len);
81132294:	e0bffa03 	ldbu	r2,-24(fp)
}
81132298:	e037883a 	mov	sp,fp
8113229c:	dfc00117 	ldw	ra,4(sp)
811322a0:	df000017 	ldw	fp,0(sp)
811322a4:	dec00204 	addi	sp,sp,8
811322a8:	f800283a 	ret

811322ac <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
811322ac:	defff604 	addi	sp,sp,-40
811322b0:	de00012e 	bgeu	sp,et,811322b8 <OSMemNameSet+0xc>
811322b4:	003b68fa 	trap	3
811322b8:	dfc00915 	stw	ra,36(sp)
811322bc:	df000815 	stw	fp,32(sp)
811322c0:	df000804 	addi	fp,sp,32
811322c4:	e13ffd15 	stw	r4,-12(fp)
811322c8:	e17ffe15 	stw	r5,-8(fp)
811322cc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811322d0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811322d4:	e0bfff17 	ldw	r2,-4(fp)
811322d8:	10003526 	beq	r2,zero,811323b0 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
811322dc:	e0bffd17 	ldw	r2,-12(fp)
811322e0:	1000041e 	bne	r2,zero,811322f4 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
811322e4:	e0bfff17 	ldw	r2,-4(fp)
811322e8:	00c01804 	movi	r3,96
811322ec:	10c00005 	stb	r3,0(r2)
        return;
811322f0:	00003006 	br	811323b4 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811322f4:	e0bffe17 	ldw	r2,-8(fp)
811322f8:	1000041e 	bne	r2,zero,8113230c <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
811322fc:	e0bfff17 	ldw	r2,-4(fp)
81132300:	00c00304 	movi	r3,12
81132304:	10c00005 	stb	r3,0(r2)
        return;
81132308:	00002a06 	br	811323b4 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113230c:	d0a09203 	ldbu	r2,-32184(gp)
81132310:	10803fcc 	andi	r2,r2,255
81132314:	10000426 	beq	r2,zero,81132328 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81132318:	e0bfff17 	ldw	r2,-4(fp)
8113231c:	00c00484 	movi	r3,18
81132320:	10c00005 	stb	r3,0(r2)
        return;
81132324:	00002306 	br	811323b4 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132328:	0005303a 	rdctl	r2,status
8113232c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132330:	e0fffc17 	ldw	r3,-16(fp)
81132334:	00bfff84 	movi	r2,-2
81132338:	1884703a 	and	r2,r3,r2
8113233c:	1001703a 	wrctl	status,r2
  
  return context;
81132340:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81132344:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81132348:	e13ffe17 	ldw	r4,-8(fp)
8113234c:	11300180 	call	81130018 <OS_StrLen>
81132350:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
81132354:	e0bffa03 	ldbu	r2,-24(fp)
81132358:	10800830 	cmpltui	r2,r2,32
8113235c:	1000081e 	bne	r2,zero,81132380 <OSMemNameSet+0xd4>
81132360:	e0bff817 	ldw	r2,-32(fp)
81132364:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132368:	e0bff917 	ldw	r2,-28(fp)
8113236c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
81132370:	e0bfff17 	ldw	r2,-4(fp)
81132374:	00c018c4 	movi	r3,99
81132378:	10c00005 	stb	r3,0(r2)
        return;
8113237c:	00000d06 	br	811323b4 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
81132380:	e0bffd17 	ldw	r2,-12(fp)
81132384:	10800504 	addi	r2,r2,20
81132388:	e17ffe17 	ldw	r5,-8(fp)
8113238c:	1009883a 	mov	r4,r2
81132390:	112ff9c0 	call	8112ff9c <OS_StrCopy>
81132394:	e0bff817 	ldw	r2,-32(fp)
81132398:	e0bffb15 	stw	r2,-20(fp)
8113239c:	e0bffb17 	ldw	r2,-20(fp)
811323a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811323a4:	e0bfff17 	ldw	r2,-4(fp)
811323a8:	10000005 	stb	zero,0(r2)
811323ac:	00000106 	br	811323b4 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
811323b0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
811323b4:	e037883a 	mov	sp,fp
811323b8:	dfc00117 	ldw	ra,4(sp)
811323bc:	df000017 	ldw	fp,0(sp)
811323c0:	dec00204 	addi	sp,sp,8
811323c4:	f800283a 	ret

811323c8 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
811323c8:	defff904 	addi	sp,sp,-28
811323cc:	de00012e 	bgeu	sp,et,811323d4 <OSMemPut+0xc>
811323d0:	003b68fa 	trap	3
811323d4:	df000615 	stw	fp,24(sp)
811323d8:	df000604 	addi	fp,sp,24
811323dc:	e13ffe15 	stw	r4,-8(fp)
811323e0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811323e4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
811323e8:	e0bffe17 	ldw	r2,-8(fp)
811323ec:	1000021e 	bne	r2,zero,811323f8 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
811323f0:	00801804 	movi	r2,96
811323f4:	00002806 	br	81132498 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
811323f8:	e0bfff17 	ldw	r2,-4(fp)
811323fc:	1000021e 	bne	r2,zero,81132408 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
81132400:	008017c4 	movi	r2,95
81132404:	00002406 	br	81132498 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132408:	0005303a 	rdctl	r2,status
8113240c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132410:	e0fffd17 	ldw	r3,-12(fp)
81132414:	00bfff84 	movi	r2,-2
81132418:	1884703a 	and	r2,r3,r2
8113241c:	1001703a 	wrctl	status,r2
  
  return context;
81132420:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81132424:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
81132428:	e0bffe17 	ldw	r2,-8(fp)
8113242c:	10c00417 	ldw	r3,16(r2)
81132430:	e0bffe17 	ldw	r2,-8(fp)
81132434:	10800317 	ldw	r2,12(r2)
81132438:	18800636 	bltu	r3,r2,81132454 <OSMemPut+0x8c>
8113243c:	e0bffa17 	ldw	r2,-24(fp)
81132440:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132444:	e0bffb17 	ldw	r2,-20(fp)
81132448:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113244c:	00801784 	movi	r2,94
81132450:	00001106 	br	81132498 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
81132454:	e0bffe17 	ldw	r2,-8(fp)
81132458:	10c00117 	ldw	r3,4(r2)
8113245c:	e0bfff17 	ldw	r2,-4(fp)
81132460:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
81132464:	e0bffe17 	ldw	r2,-8(fp)
81132468:	e0ffff17 	ldw	r3,-4(fp)
8113246c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
81132470:	e0bffe17 	ldw	r2,-8(fp)
81132474:	10800417 	ldw	r2,16(r2)
81132478:	10c00044 	addi	r3,r2,1
8113247c:	e0bffe17 	ldw	r2,-8(fp)
81132480:	10c00415 	stw	r3,16(r2)
81132484:	e0bffa17 	ldw	r2,-24(fp)
81132488:	e0bffc15 	stw	r2,-16(fp)
8113248c:	e0bffc17 	ldw	r2,-16(fp)
81132490:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
81132494:	0005883a 	mov	r2,zero
}
81132498:	e037883a 	mov	sp,fp
8113249c:	df000017 	ldw	fp,0(sp)
811324a0:	dec00104 	addi	sp,sp,4
811324a4:	f800283a 	ret

811324a8 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
811324a8:	defffa04 	addi	sp,sp,-24
811324ac:	de00012e 	bgeu	sp,et,811324b4 <OSMemQuery+0xc>
811324b0:	003b68fa 	trap	3
811324b4:	df000515 	stw	fp,20(sp)
811324b8:	df000504 	addi	fp,sp,20
811324bc:	e13ffe15 	stw	r4,-8(fp)
811324c0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811324c4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
811324c8:	e0bffe17 	ldw	r2,-8(fp)
811324cc:	1000021e 	bne	r2,zero,811324d8 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
811324d0:	00801804 	movi	r2,96
811324d4:	00002c06 	br	81132588 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
811324d8:	e0bfff17 	ldw	r2,-4(fp)
811324dc:	1000021e 	bne	r2,zero,811324e8 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
811324e0:	00801844 	movi	r2,97
811324e4:	00002806 	br	81132588 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811324e8:	0005303a 	rdctl	r2,status
811324ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811324f0:	e0fffc17 	ldw	r3,-16(fp)
811324f4:	00bfff84 	movi	r2,-2
811324f8:	1884703a 	and	r2,r3,r2
811324fc:	1001703a 	wrctl	status,r2
  
  return context;
81132500:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81132504:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
81132508:	e0bffe17 	ldw	r2,-8(fp)
8113250c:	10c00017 	ldw	r3,0(r2)
81132510:	e0bfff17 	ldw	r2,-4(fp)
81132514:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
81132518:	e0bffe17 	ldw	r2,-8(fp)
8113251c:	10c00117 	ldw	r3,4(r2)
81132520:	e0bfff17 	ldw	r2,-4(fp)
81132524:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
81132528:	e0bffe17 	ldw	r2,-8(fp)
8113252c:	10c00217 	ldw	r3,8(r2)
81132530:	e0bfff17 	ldw	r2,-4(fp)
81132534:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
81132538:	e0bffe17 	ldw	r2,-8(fp)
8113253c:	10c00317 	ldw	r3,12(r2)
81132540:	e0bfff17 	ldw	r2,-4(fp)
81132544:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
81132548:	e0bffe17 	ldw	r2,-8(fp)
8113254c:	10c00417 	ldw	r3,16(r2)
81132550:	e0bfff17 	ldw	r2,-4(fp)
81132554:	10c00415 	stw	r3,16(r2)
81132558:	e0bffb17 	ldw	r2,-20(fp)
8113255c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132560:	e0bffd17 	ldw	r2,-12(fp)
81132564:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
81132568:	e0bfff17 	ldw	r2,-4(fp)
8113256c:	10c00317 	ldw	r3,12(r2)
81132570:	e0bfff17 	ldw	r2,-4(fp)
81132574:	10800417 	ldw	r2,16(r2)
81132578:	1887c83a 	sub	r3,r3,r2
8113257c:	e0bfff17 	ldw	r2,-4(fp)
81132580:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
81132584:	0005883a 	mov	r2,zero
}
81132588:	e037883a 	mov	sp,fp
8113258c:	df000017 	ldw	fp,0(sp)
81132590:	dec00104 	addi	sp,sp,4
81132594:	f800283a 	ret

81132598 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
81132598:	defffc04 	addi	sp,sp,-16
8113259c:	de00012e 	bgeu	sp,et,811325a4 <OS_MemInit+0xc>
811325a0:	003b68fa 	trap	3
811325a4:	dfc00315 	stw	ra,12(sp)
811325a8:	df000215 	stw	fp,8(sp)
811325ac:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
811325b0:	01430c04 	movi	r5,3120
811325b4:	012045b4 	movhi	r4,33046
811325b8:	2133df04 	addi	r4,r4,-12420
811325bc:	112fd7c0 	call	8112fd7c <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
811325c0:	00a045b4 	movhi	r2,33046
811325c4:	10b3df04 	addi	r2,r2,-12420
811325c8:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
811325cc:	e03fff0d 	sth	zero,-4(fp)
811325d0:	00001306 	br	81132620 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
811325d4:	e0bfff0b 	ldhu	r2,-4(fp)
811325d8:	10800044 	addi	r2,r2,1
811325dc:	10c00d24 	muli	r3,r2,52
811325e0:	00a045b4 	movhi	r2,33046
811325e4:	10b3df04 	addi	r2,r2,-12420
811325e8:	1887883a 	add	r3,r3,r2
811325ec:	e0bffe17 	ldw	r2,-8(fp)
811325f0:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
811325f4:	e0bffe17 	ldw	r2,-8(fp)
811325f8:	00c00fc4 	movi	r3,63
811325fc:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
81132600:	e0bffe17 	ldw	r2,-8(fp)
81132604:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
81132608:	e0bffe17 	ldw	r2,-8(fp)
8113260c:	10800d04 	addi	r2,r2,52
81132610:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81132614:	e0bfff0b 	ldhu	r2,-4(fp)
81132618:	10800044 	addi	r2,r2,1
8113261c:	e0bfff0d 	sth	r2,-4(fp)
81132620:	e0bfff0b 	ldhu	r2,-4(fp)
81132624:	10800ef0 	cmpltui	r2,r2,59
81132628:	103fea1e 	bne	r2,zero,811325d4 <__reset+0xfb1125d4>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113262c:	e0bffe17 	ldw	r2,-8(fp)
81132630:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
81132634:	e0bffe17 	ldw	r2,-8(fp)
81132638:	00c00fc4 	movi	r3,63
8113263c:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
81132640:	e0bffe17 	ldw	r2,-8(fp)
81132644:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
81132648:	00a045b4 	movhi	r2,33046
8113264c:	10b3df04 	addi	r2,r2,-12420
81132650:	d0a08c15 	stw	r2,-32208(gp)
#endif
}
81132654:	0001883a 	nop
81132658:	e037883a 	mov	sp,fp
8113265c:	dfc00117 	ldw	ra,4(sp)
81132660:	df000017 	ldw	fp,0(sp)
81132664:	dec00204 	addi	sp,sp,8
81132668:	f800283a 	ret

8113266c <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113266c:	defff704 	addi	sp,sp,-36
81132670:	de00012e 	bgeu	sp,et,81132678 <OSMutexAccept+0xc>
81132674:	003b68fa 	trap	3
81132678:	df000815 	stw	fp,32(sp)
8113267c:	df000804 	addi	fp,sp,32
81132680:	e13ffe15 	stw	r4,-8(fp)
81132684:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81132688:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113268c:	e0bfff17 	ldw	r2,-4(fp)
81132690:	1000021e 	bne	r2,zero,8113269c <OSMutexAccept+0x30>
        return (OS_FALSE);
81132694:	0005883a 	mov	r2,zero
81132698:	00005b06 	br	81132808 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113269c:	e0bffe17 	ldw	r2,-8(fp)
811326a0:	1000051e 	bne	r2,zero,811326b8 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
811326a4:	e0bfff17 	ldw	r2,-4(fp)
811326a8:	00c00104 	movi	r3,4
811326ac:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811326b0:	0005883a 	mov	r2,zero
811326b4:	00005406 	br	81132808 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
811326b8:	e0bffe17 	ldw	r2,-8(fp)
811326bc:	10800003 	ldbu	r2,0(r2)
811326c0:	10803fcc 	andi	r2,r2,255
811326c4:	10800120 	cmpeqi	r2,r2,4
811326c8:	1000051e 	bne	r2,zero,811326e0 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
811326cc:	e0bfff17 	ldw	r2,-4(fp)
811326d0:	00c00044 	movi	r3,1
811326d4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811326d8:	0005883a 	mov	r2,zero
811326dc:	00004a06 	br	81132808 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
811326e0:	d0a09203 	ldbu	r2,-32184(gp)
811326e4:	10803fcc 	andi	r2,r2,255
811326e8:	10000526 	beq	r2,zero,81132700 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
811326ec:	e0bfff17 	ldw	r2,-4(fp)
811326f0:	00c00084 	movi	r3,2
811326f4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811326f8:	0005883a 	mov	r2,zero
811326fc:	00004206 	br	81132808 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132700:	0005303a 	rdctl	r2,status
81132704:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132708:	e0fffd17 	ldw	r3,-12(fp)
8113270c:	00bfff84 	movi	r2,-2
81132710:	1884703a 	and	r2,r3,r2
81132714:	1001703a 	wrctl	status,r2
  
  return context;
81132718:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113271c:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
81132720:	e0bffe17 	ldw	r2,-8(fp)
81132724:	1080020b 	ldhu	r2,8(r2)
81132728:	10bfffcc 	andi	r2,r2,65535
8113272c:	1004d23a 	srli	r2,r2,8
81132730:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81132734:	e0bffe17 	ldw	r2,-8(fp)
81132738:	1080020b 	ldhu	r2,8(r2)
8113273c:	10bfffcc 	andi	r2,r2,65535
81132740:	10803fcc 	andi	r2,r2,255
81132744:	10803fd8 	cmpnei	r2,r2,255
81132748:	1000281e 	bne	r2,zero,811327ec <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113274c:	e0bffe17 	ldw	r2,-8(fp)
81132750:	10c0020b 	ldhu	r3,8(r2)
81132754:	00bfc004 	movi	r2,-256
81132758:	1884703a 	and	r2,r3,r2
8113275c:	1007883a 	mov	r3,r2
81132760:	e0bffe17 	ldw	r2,-8(fp)
81132764:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
81132768:	e0bffe17 	ldw	r2,-8(fp)
8113276c:	10c0020b 	ldhu	r3,8(r2)
81132770:	d0a09317 	ldw	r2,-32180(gp)
81132774:	10800c83 	ldbu	r2,50(r2)
81132778:	10803fcc 	andi	r2,r2,255
8113277c:	1884b03a 	or	r2,r3,r2
81132780:	1007883a 	mov	r3,r2
81132784:	e0bffe17 	ldw	r2,-8(fp)
81132788:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113278c:	d0e09317 	ldw	r3,-32180(gp)
81132790:	e0bffe17 	ldw	r2,-8(fp)
81132794:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
81132798:	d0a09317 	ldw	r2,-32180(gp)
8113279c:	10800c83 	ldbu	r2,50(r2)
811327a0:	10803fcc 	andi	r2,r2,255
811327a4:	e0fffa03 	ldbu	r3,-24(fp)
811327a8:	18800836 	bltu	r3,r2,811327cc <OSMutexAccept+0x160>
811327ac:	e0bff817 	ldw	r2,-32(fp)
811327b0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811327b4:	e0bff917 	ldw	r2,-28(fp)
811327b8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
811327bc:	e0bfff17 	ldw	r2,-4(fp)
811327c0:	00c01e04 	movi	r3,120
811327c4:	10c00005 	stb	r3,0(r2)
811327c8:	00000606 	br	811327e4 <OSMutexAccept+0x178>
811327cc:	e0bff817 	ldw	r2,-32(fp)
811327d0:	e0bffb15 	stw	r2,-20(fp)
811327d4:	e0bffb17 	ldw	r2,-20(fp)
811327d8:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
811327dc:	e0bfff17 	ldw	r2,-4(fp)
811327e0:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
811327e4:	00800044 	movi	r2,1
811327e8:	00000706 	br	81132808 <OSMutexAccept+0x19c>
811327ec:	e0bff817 	ldw	r2,-32(fp)
811327f0:	e0bffc15 	stw	r2,-16(fp)
811327f4:	e0bffc17 	ldw	r2,-16(fp)
811327f8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811327fc:	e0bfff17 	ldw	r2,-4(fp)
81132800:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
81132804:	0005883a 	mov	r2,zero
}
81132808:	e037883a 	mov	sp,fp
8113280c:	df000017 	ldw	fp,0(sp)
81132810:	dec00104 	addi	sp,sp,4
81132814:	f800283a 	ret

81132818 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
81132818:	defff604 	addi	sp,sp,-40
8113281c:	de00012e 	bgeu	sp,et,81132824 <OSMutexCreate+0xc>
81132820:	003b68fa 	trap	3
81132824:	dfc00915 	stw	ra,36(sp)
81132828:	df000815 	stw	fp,32(sp)
8113282c:	df000804 	addi	fp,sp,32
81132830:	2005883a 	mov	r2,r4
81132834:	e17fff15 	stw	r5,-4(fp)
81132838:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113283c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81132840:	e0bfff17 	ldw	r2,-4(fp)
81132844:	1000021e 	bne	r2,zero,81132850 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
81132848:	0005883a 	mov	r2,zero
8113284c:	00006106 	br	811329d4 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
81132850:	e0bffe03 	ldbu	r2,-8(fp)
81132854:	10800a30 	cmpltui	r2,r2,40
81132858:	1000051e 	bne	r2,zero,81132870 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113285c:	e0bfff17 	ldw	r2,-4(fp)
81132860:	00c00a84 	movi	r3,42
81132864:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81132868:	0005883a 	mov	r2,zero
8113286c:	00005906 	br	811329d4 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81132870:	d0a09203 	ldbu	r2,-32184(gp)
81132874:	10803fcc 	andi	r2,r2,255
81132878:	10000526 	beq	r2,zero,81132890 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113287c:	e0bfff17 	ldw	r2,-4(fp)
81132880:	00c00404 	movi	r3,16
81132884:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81132888:	0005883a 	mov	r2,zero
8113288c:	00005106 	br	811329d4 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132890:	0005303a 	rdctl	r2,status
81132894:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132898:	e0fffd17 	ldw	r3,-12(fp)
8113289c:	00bfff84 	movi	r2,-2
811328a0:	1884703a 	and	r2,r3,r2
811328a4:	1001703a 	wrctl	status,r2
  
  return context;
811328a8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811328ac:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
811328b0:	e0fffe03 	ldbu	r3,-8(fp)
811328b4:	00a045b4 	movhi	r2,33046
811328b8:	10882104 	addi	r2,r2,8324
811328bc:	18c7883a 	add	r3,r3,r3
811328c0:	18c7883a 	add	r3,r3,r3
811328c4:	10c5883a 	add	r2,r2,r3
811328c8:	10800017 	ldw	r2,0(r2)
811328cc:	10000926 	beq	r2,zero,811328f4 <OSMutexCreate+0xdc>
811328d0:	e0bff817 	ldw	r2,-32(fp)
811328d4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811328d8:	e0bff917 	ldw	r2,-28(fp)
811328dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
811328e0:	e0bfff17 	ldw	r2,-4(fp)
811328e4:	00c00a04 	movi	r3,40
811328e8:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
811328ec:	0005883a 	mov	r2,zero
811328f0:	00003806 	br	811329d4 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
811328f4:	e0fffe03 	ldbu	r3,-8(fp)
811328f8:	00a045b4 	movhi	r2,33046
811328fc:	10882104 	addi	r2,r2,8324
81132900:	18c7883a 	add	r3,r3,r3
81132904:	18c7883a 	add	r3,r3,r3
81132908:	10c5883a 	add	r2,r2,r3
8113290c:	00c00044 	movi	r3,1
81132910:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
81132914:	d0a09117 	ldw	r2,-32188(gp)
81132918:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113291c:	e0bffb17 	ldw	r2,-20(fp)
81132920:	1000101e 	bne	r2,zero,81132964 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
81132924:	e0fffe03 	ldbu	r3,-8(fp)
81132928:	00a045b4 	movhi	r2,33046
8113292c:	10882104 	addi	r2,r2,8324
81132930:	18c7883a 	add	r3,r3,r3
81132934:	18c7883a 	add	r3,r3,r3
81132938:	10c5883a 	add	r2,r2,r3
8113293c:	10000015 	stw	zero,0(r2)
81132940:	e0bff817 	ldw	r2,-32(fp)
81132944:	e0bffa15 	stw	r2,-24(fp)
81132948:	e0bffa17 	ldw	r2,-24(fp)
8113294c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
81132950:	e0bfff17 	ldw	r2,-4(fp)
81132954:	00c00104 	movi	r3,4
81132958:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113295c:	e0bffb17 	ldw	r2,-20(fp)
81132960:	00001c06 	br	811329d4 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
81132964:	d0a09117 	ldw	r2,-32188(gp)
81132968:	10800117 	ldw	r2,4(r2)
8113296c:	d0a09115 	stw	r2,-32188(gp)
81132970:	e0bff817 	ldw	r2,-32(fp)
81132974:	e0bffc15 	stw	r2,-16(fp)
81132978:	e0bffc17 	ldw	r2,-16(fp)
8113297c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
81132980:	e0bffb17 	ldw	r2,-20(fp)
81132984:	00c00104 	movi	r3,4
81132988:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113298c:	e0bffe03 	ldbu	r2,-8(fp)
81132990:	1004923a 	slli	r2,r2,8
81132994:	10803fd4 	ori	r2,r2,255
81132998:	1007883a 	mov	r3,r2
8113299c:	e0bffb17 	ldw	r2,-20(fp)
811329a0:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
811329a4:	e0bffb17 	ldw	r2,-20(fp)
811329a8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
811329ac:	e0bffb17 	ldw	r2,-20(fp)
811329b0:	00c00fc4 	movi	r3,63
811329b4:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
811329b8:	e0bffb17 	ldw	r2,-20(fp)
811329bc:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
811329c0:	e13ffb17 	ldw	r4,-20(fp)
811329c4:	112f9640 	call	8112f964 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
811329c8:	e0bfff17 	ldw	r2,-4(fp)
811329cc:	10000005 	stb	zero,0(r2)
    return (pevent);
811329d0:	e0bffb17 	ldw	r2,-20(fp)
}
811329d4:	e037883a 	mov	sp,fp
811329d8:	dfc00117 	ldw	ra,4(sp)
811329dc:	df000017 	ldw	fp,0(sp)
811329e0:	dec00204 	addi	sp,sp,8
811329e4:	f800283a 	ret

811329e8 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
811329e8:	defff004 	addi	sp,sp,-64
811329ec:	de00012e 	bgeu	sp,et,811329f4 <OSMutexDel+0xc>
811329f0:	003b68fa 	trap	3
811329f4:	dfc00f15 	stw	ra,60(sp)
811329f8:	df000e15 	stw	fp,56(sp)
811329fc:	df000e04 	addi	fp,sp,56
81132a00:	e13ffd15 	stw	r4,-12(fp)
81132a04:	2805883a 	mov	r2,r5
81132a08:	e1bfff15 	stw	r6,-4(fp)
81132a0c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81132a10:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81132a14:	e0bfff17 	ldw	r2,-4(fp)
81132a18:	1000021e 	bne	r2,zero,81132a24 <OSMutexDel+0x3c>
        return (pevent);
81132a1c:	e0bffd17 	ldw	r2,-12(fp)
81132a20:	0000ad06 	br	81132cd8 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81132a24:	e0bffd17 	ldw	r2,-12(fp)
81132a28:	1000051e 	bne	r2,zero,81132a40 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81132a2c:	e0bfff17 	ldw	r2,-4(fp)
81132a30:	00c00104 	movi	r3,4
81132a34:	10c00005 	stb	r3,0(r2)
        return (pevent);
81132a38:	e0bffd17 	ldw	r2,-12(fp)
81132a3c:	0000a606 	br	81132cd8 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81132a40:	e0bffd17 	ldw	r2,-12(fp)
81132a44:	10800003 	ldbu	r2,0(r2)
81132a48:	10803fcc 	andi	r2,r2,255
81132a4c:	10800120 	cmpeqi	r2,r2,4
81132a50:	1000051e 	bne	r2,zero,81132a68 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81132a54:	e0bfff17 	ldw	r2,-4(fp)
81132a58:	00c00044 	movi	r3,1
81132a5c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81132a60:	e0bffd17 	ldw	r2,-12(fp)
81132a64:	00009c06 	br	81132cd8 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81132a68:	d0a09203 	ldbu	r2,-32184(gp)
81132a6c:	10803fcc 	andi	r2,r2,255
81132a70:	10000526 	beq	r2,zero,81132a88 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
81132a74:	e0bfff17 	ldw	r2,-4(fp)
81132a78:	00c003c4 	movi	r3,15
81132a7c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81132a80:	e0bffd17 	ldw	r2,-12(fp)
81132a84:	00009406 	br	81132cd8 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132a88:	0005303a 	rdctl	r2,status
81132a8c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132a90:	e0fffc17 	ldw	r3,-16(fp)
81132a94:	00bfff84 	movi	r2,-2
81132a98:	1884703a 	and	r2,r3,r2
81132a9c:	1001703a 	wrctl	status,r2
  
  return context;
81132aa0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81132aa4:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
81132aa8:	e0bffd17 	ldw	r2,-12(fp)
81132aac:	10800283 	ldbu	r2,10(r2)
81132ab0:	10803fcc 	andi	r2,r2,255
81132ab4:	10000326 	beq	r2,zero,81132ac4 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81132ab8:	00800044 	movi	r2,1
81132abc:	e0bff205 	stb	r2,-56(fp)
81132ac0:	00000106 	br	81132ac8 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81132ac4:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
81132ac8:	e0bffe03 	ldbu	r2,-8(fp)
81132acc:	10000326 	beq	r2,zero,81132adc <OSMutexDel+0xf4>
81132ad0:	10800060 	cmpeqi	r2,r2,1
81132ad4:	10002f1e 	bne	r2,zero,81132b94 <OSMutexDel+0x1ac>
81132ad8:	00007406 	br	81132cac <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
81132adc:	e0bff203 	ldbu	r2,-56(fp)
81132ae0:	1000221e 	bne	r2,zero,81132b6c <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81132ae4:	e0bffd17 	ldw	r2,-12(fp)
81132ae8:	00c00fc4 	movi	r3,63
81132aec:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81132af0:	e0bffd17 	ldw	r2,-12(fp)
81132af4:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81132af8:	e0bffd17 	ldw	r2,-12(fp)
81132afc:	1080020b 	ldhu	r2,8(r2)
81132b00:	10bfffcc 	andi	r2,r2,65535
81132b04:	1004d23a 	srli	r2,r2,8
81132b08:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
81132b0c:	e0fff603 	ldbu	r3,-40(fp)
81132b10:	00a045b4 	movhi	r2,33046
81132b14:	10882104 	addi	r2,r2,8324
81132b18:	18c7883a 	add	r3,r3,r3
81132b1c:	18c7883a 	add	r3,r3,r3
81132b20:	10c5883a 	add	r2,r2,r3
81132b24:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81132b28:	e0bffd17 	ldw	r2,-12(fp)
81132b2c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
81132b30:	d0e09117 	ldw	r3,-32188(gp)
81132b34:	e0bffd17 	ldw	r2,-12(fp)
81132b38:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
81132b3c:	e0bffd17 	ldw	r2,-12(fp)
81132b40:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
81132b44:	e0bffd17 	ldw	r2,-12(fp)
81132b48:	d0a09115 	stw	r2,-32188(gp)
81132b4c:	e0bff417 	ldw	r2,-48(fp)
81132b50:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132b54:	e0bff517 	ldw	r2,-44(fp)
81132b58:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
81132b5c:	e0bfff17 	ldw	r2,-4(fp)
81132b60:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
81132b64:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
81132b68:	00005a06 	br	81132cd4 <OSMutexDel+0x2ec>
81132b6c:	e0bff417 	ldw	r2,-48(fp)
81132b70:	e0bff715 	stw	r2,-36(fp)
81132b74:	e0bff717 	ldw	r2,-36(fp)
81132b78:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
81132b7c:	e0bfff17 	ldw	r2,-4(fp)
81132b80:	00c01244 	movi	r3,73
81132b84:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
81132b88:	e0bffd17 	ldw	r2,-12(fp)
81132b8c:	e0bff315 	stw	r2,-52(fp)
             }
             break;
81132b90:	00005006 	br	81132cd4 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
81132b94:	e0bffd17 	ldw	r2,-12(fp)
81132b98:	1080020b 	ldhu	r2,8(r2)
81132b9c:	10bfffcc 	andi	r2,r2,65535
81132ba0:	1004d23a 	srli	r2,r2,8
81132ba4:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
81132ba8:	e0bffd17 	ldw	r2,-12(fp)
81132bac:	1080020b 	ldhu	r2,8(r2)
81132bb0:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
81132bb4:	e0bffd17 	ldw	r2,-12(fp)
81132bb8:	10800117 	ldw	r2,4(r2)
81132bbc:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
81132bc0:	e0bffa17 	ldw	r2,-24(fp)
81132bc4:	10000f26 	beq	r2,zero,81132c04 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
81132bc8:	e0bffa17 	ldw	r2,-24(fp)
81132bcc:	10800c83 	ldbu	r2,50(r2)
81132bd0:	10c03fcc 	andi	r3,r2,255
81132bd4:	e0bff603 	ldbu	r2,-40(fp)
81132bd8:	18800a1e 	bne	r3,r2,81132c04 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
81132bdc:	e0bff903 	ldbu	r2,-28(fp)
81132be0:	100b883a 	mov	r5,r2
81132be4:	e13ffa17 	ldw	r4,-24(fp)
81132be8:	11336240 	call	81133624 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81132bec:	00000506 	br	81132c04 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81132bf0:	000f883a 	mov	r7,zero
81132bf4:	01800404 	movi	r6,16
81132bf8:	000b883a 	mov	r5,zero
81132bfc:	e13ffd17 	ldw	r4,-12(fp)
81132c00:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81132c04:	e0bffd17 	ldw	r2,-12(fp)
81132c08:	10800283 	ldbu	r2,10(r2)
81132c0c:	10803fcc 	andi	r2,r2,255
81132c10:	103ff71e 	bne	r2,zero,81132bf0 <__reset+0xfb112bf0>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81132c14:	e0bffd17 	ldw	r2,-12(fp)
81132c18:	00c00fc4 	movi	r3,63
81132c1c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81132c20:	e0bffd17 	ldw	r2,-12(fp)
81132c24:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81132c28:	e0bffd17 	ldw	r2,-12(fp)
81132c2c:	1080020b 	ldhu	r2,8(r2)
81132c30:	10bfffcc 	andi	r2,r2,65535
81132c34:	1004d23a 	srli	r2,r2,8
81132c38:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
81132c3c:	e0fff603 	ldbu	r3,-40(fp)
81132c40:	00a045b4 	movhi	r2,33046
81132c44:	10882104 	addi	r2,r2,8324
81132c48:	18c7883a 	add	r3,r3,r3
81132c4c:	18c7883a 	add	r3,r3,r3
81132c50:	10c5883a 	add	r2,r2,r3
81132c54:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81132c58:	e0bffd17 	ldw	r2,-12(fp)
81132c5c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
81132c60:	d0e09117 	ldw	r3,-32188(gp)
81132c64:	e0bffd17 	ldw	r2,-12(fp)
81132c68:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
81132c6c:	e0bffd17 	ldw	r2,-12(fp)
81132c70:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
81132c74:	e0bffd17 	ldw	r2,-12(fp)
81132c78:	d0a09115 	stw	r2,-32188(gp)
81132c7c:	e0bff417 	ldw	r2,-48(fp)
81132c80:	e0bff815 	stw	r2,-32(fp)
81132c84:	e0bff817 	ldw	r2,-32(fp)
81132c88:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81132c8c:	e0bff203 	ldbu	r2,-56(fp)
81132c90:	10800058 	cmpnei	r2,r2,1
81132c94:	1000011e 	bne	r2,zero,81132c9c <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81132c98:	112fe480 	call	8112fe48 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
81132c9c:	e0bfff17 	ldw	r2,-4(fp)
81132ca0:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
81132ca4:	e03ff315 	stw	zero,-52(fp)
             break;
81132ca8:	00000a06 	br	81132cd4 <OSMutexDel+0x2ec>
81132cac:	e0bff417 	ldw	r2,-48(fp)
81132cb0:	e0bffb15 	stw	r2,-20(fp)
81132cb4:	e0bffb17 	ldw	r2,-20(fp)
81132cb8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
81132cbc:	e0bfff17 	ldw	r2,-4(fp)
81132cc0:	00c001c4 	movi	r3,7
81132cc4:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
81132cc8:	e0bffd17 	ldw	r2,-12(fp)
81132ccc:	e0bff315 	stw	r2,-52(fp)
             break;
81132cd0:	0001883a 	nop
    }
    return (pevent_return);
81132cd4:	e0bff317 	ldw	r2,-52(fp)
}
81132cd8:	e037883a 	mov	sp,fp
81132cdc:	dfc00117 	ldw	ra,4(sp)
81132ce0:	df000017 	ldw	fp,0(sp)
81132ce4:	dec00204 	addi	sp,sp,8
81132ce8:	f800283a 	ret

81132cec <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81132cec:	deffee04 	addi	sp,sp,-72
81132cf0:	de00012e 	bgeu	sp,et,81132cf8 <OSMutexPend+0xc>
81132cf4:	003b68fa 	trap	3
81132cf8:	dfc01115 	stw	ra,68(sp)
81132cfc:	df001015 	stw	fp,64(sp)
81132d00:	df001004 	addi	fp,sp,64
81132d04:	e13ffd15 	stw	r4,-12(fp)
81132d08:	2805883a 	mov	r2,r5
81132d0c:	e1bfff15 	stw	r6,-4(fp)
81132d10:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81132d14:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81132d18:	e0bfff17 	ldw	r2,-4(fp)
81132d1c:	10015626 	beq	r2,zero,81133278 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81132d20:	e0bffd17 	ldw	r2,-12(fp)
81132d24:	1000041e 	bne	r2,zero,81132d38 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81132d28:	e0bfff17 	ldw	r2,-4(fp)
81132d2c:	00c00104 	movi	r3,4
81132d30:	10c00005 	stb	r3,0(r2)
        return;
81132d34:	00015106 	br	8113327c <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81132d38:	e0bffd17 	ldw	r2,-12(fp)
81132d3c:	10800003 	ldbu	r2,0(r2)
81132d40:	10803fcc 	andi	r2,r2,255
81132d44:	10800120 	cmpeqi	r2,r2,4
81132d48:	1000041e 	bne	r2,zero,81132d5c <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
81132d4c:	e0bfff17 	ldw	r2,-4(fp)
81132d50:	00c00044 	movi	r3,1
81132d54:	10c00005 	stb	r3,0(r2)
        return;
81132d58:	00014806 	br	8113327c <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81132d5c:	d0a09203 	ldbu	r2,-32184(gp)
81132d60:	10803fcc 	andi	r2,r2,255
81132d64:	10000426 	beq	r2,zero,81132d78 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81132d68:	e0bfff17 	ldw	r2,-4(fp)
81132d6c:	00c00084 	movi	r3,2
81132d70:	10c00005 	stb	r3,0(r2)
        return;
81132d74:	00014106 	br	8113327c <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81132d78:	d0a08003 	ldbu	r2,-32256(gp)
81132d7c:	10803fcc 	andi	r2,r2,255
81132d80:	10000426 	beq	r2,zero,81132d94 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81132d84:	e0bfff17 	ldw	r2,-4(fp)
81132d88:	00c00344 	movi	r3,13
81132d8c:	10c00005 	stb	r3,0(r2)
        return;
81132d90:	00013a06 	br	8113327c <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132d94:	0005303a 	rdctl	r2,status
81132d98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132d9c:	e0fffc17 	ldw	r3,-16(fp)
81132da0:	00bfff84 	movi	r2,-2
81132da4:	1884703a 	and	r2,r3,r2
81132da8:	1001703a 	wrctl	status,r2
  
  return context;
81132dac:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81132db0:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
81132db4:	e0bffd17 	ldw	r2,-12(fp)
81132db8:	1080020b 	ldhu	r2,8(r2)
81132dbc:	10bfffcc 	andi	r2,r2,65535
81132dc0:	1004d23a 	srli	r2,r2,8
81132dc4:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81132dc8:	e0bffd17 	ldw	r2,-12(fp)
81132dcc:	1080020b 	ldhu	r2,8(r2)
81132dd0:	10803fcc 	andi	r2,r2,255
81132dd4:	10803fd8 	cmpnei	r2,r2,255
81132dd8:	1000271e 	bne	r2,zero,81132e78 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
81132ddc:	e0bffd17 	ldw	r2,-12(fp)
81132de0:	10c0020b 	ldhu	r3,8(r2)
81132de4:	00bfc004 	movi	r2,-256
81132de8:	1884703a 	and	r2,r3,r2
81132dec:	1007883a 	mov	r3,r2
81132df0:	e0bffd17 	ldw	r2,-12(fp)
81132df4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
81132df8:	e0bffd17 	ldw	r2,-12(fp)
81132dfc:	10c0020b 	ldhu	r3,8(r2)
81132e00:	d0a09317 	ldw	r2,-32180(gp)
81132e04:	10800c83 	ldbu	r2,50(r2)
81132e08:	10803fcc 	andi	r2,r2,255
81132e0c:	1884b03a 	or	r2,r3,r2
81132e10:	1007883a 	mov	r3,r2
81132e14:	e0bffd17 	ldw	r2,-12(fp)
81132e18:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
81132e1c:	d0e09317 	ldw	r3,-32180(gp)
81132e20:	e0bffd17 	ldw	r2,-12(fp)
81132e24:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
81132e28:	d0a09317 	ldw	r2,-32180(gp)
81132e2c:	10800c83 	ldbu	r2,50(r2)
81132e30:	10803fcc 	andi	r2,r2,255
81132e34:	e0fff303 	ldbu	r3,-52(fp)
81132e38:	18800836 	bltu	r3,r2,81132e5c <OSMutexPend+0x170>
81132e3c:	e0bff117 	ldw	r2,-60(fp)
81132e40:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132e44:	e0bff217 	ldw	r2,-56(fp)
81132e48:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
81132e4c:	e0bfff17 	ldw	r2,-4(fp)
81132e50:	00c01e04 	movi	r3,120
81132e54:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
81132e58:	00010806 	br	8113327c <OSMutexPend+0x590>
81132e5c:	e0bff117 	ldw	r2,-60(fp)
81132e60:	e0bff415 	stw	r2,-48(fp)
81132e64:	e0bff417 	ldw	r2,-48(fp)
81132e68:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
81132e6c:	e0bfff17 	ldw	r2,-4(fp)
81132e70:	10000005 	stb	zero,0(r2)
        }
        return;
81132e74:	00010106 	br	8113327c <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
81132e78:	e0bffd17 	ldw	r2,-12(fp)
81132e7c:	1080020b 	ldhu	r2,8(r2)
81132e80:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
81132e84:	e0bffd17 	ldw	r2,-12(fp)
81132e88:	10800117 	ldw	r2,4(r2)
81132e8c:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
81132e90:	e0bff717 	ldw	r2,-36(fp)
81132e94:	10800c83 	ldbu	r2,50(r2)
81132e98:	10803fcc 	andi	r2,r2,255
81132e9c:	e0fff303 	ldbu	r3,-52(fp)
81132ea0:	1880b92e 	bgeu	r3,r2,81133188 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
81132ea4:	d0a09317 	ldw	r2,-32180(gp)
81132ea8:	10800c83 	ldbu	r2,50(r2)
81132eac:	10c03fcc 	andi	r3,r2,255
81132eb0:	e0bff603 	ldbu	r2,-40(fp)
81132eb4:	1880b42e 	bgeu	r3,r2,81133188 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
81132eb8:	e0bff717 	ldw	r2,-36(fp)
81132ebc:	10800d03 	ldbu	r2,52(r2)
81132ec0:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
81132ec4:	e0fff803 	ldbu	r3,-32(fp)
81132ec8:	d0a08f44 	addi	r2,gp,-32195
81132ecc:	1885883a 	add	r2,r3,r2
81132ed0:	10c00003 	ldbu	r3,0(r2)
81132ed4:	e0bff717 	ldw	r2,-36(fp)
81132ed8:	10800d43 	ldbu	r2,53(r2)
81132edc:	1884703a 	and	r2,r3,r2
81132ee0:	10803fcc 	andi	r2,r2,255
81132ee4:	10001e26 	beq	r2,zero,81132f60 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
81132ee8:	e0fff803 	ldbu	r3,-32(fp)
81132eec:	e13ff803 	ldbu	r4,-32(fp)
81132ef0:	d0a08f44 	addi	r2,gp,-32195
81132ef4:	2085883a 	add	r2,r4,r2
81132ef8:	10800003 	ldbu	r2,0(r2)
81132efc:	1009883a 	mov	r4,r2
81132f00:	e0bff717 	ldw	r2,-36(fp)
81132f04:	10800d43 	ldbu	r2,53(r2)
81132f08:	0084303a 	nor	r2,zero,r2
81132f0c:	2084703a 	and	r2,r4,r2
81132f10:	1009883a 	mov	r4,r2
81132f14:	d0a08f44 	addi	r2,gp,-32195
81132f18:	1885883a 	add	r2,r3,r2
81132f1c:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
81132f20:	e0fff803 	ldbu	r3,-32(fp)
81132f24:	d0a08f44 	addi	r2,gp,-32195
81132f28:	1885883a 	add	r2,r3,r2
81132f2c:	10800003 	ldbu	r2,0(r2)
81132f30:	10803fcc 	andi	r2,r2,255
81132f34:	1000071e 	bne	r2,zero,81132f54 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
81132f38:	e0bff717 	ldw	r2,-36(fp)
81132f3c:	10800d83 	ldbu	r2,54(r2)
81132f40:	0084303a 	nor	r2,zero,r2
81132f44:	1007883a 	mov	r3,r2
81132f48:	d0a08f03 	ldbu	r2,-32196(gp)
81132f4c:	1884703a 	and	r2,r3,r2
81132f50:	d0a08f05 	stb	r2,-32196(gp)
                }
                rdy = OS_TRUE;
81132f54:	00800044 	movi	r2,1
81132f58:	e0bff005 	stb	r2,-64(fp)
81132f5c:	00002a06 	br	81133008 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81132f60:	e0bff717 	ldw	r2,-36(fp)
81132f64:	10800717 	ldw	r2,28(r2)
81132f68:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
81132f6c:	e0bff917 	ldw	r2,-28(fp)
81132f70:	10002426 	beq	r2,zero,81133004 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
81132f74:	e0bff717 	ldw	r2,-36(fp)
81132f78:	10800d03 	ldbu	r2,52(r2)
81132f7c:	10803fcc 	andi	r2,r2,255
81132f80:	e0fff717 	ldw	r3,-36(fp)
81132f84:	18c00d03 	ldbu	r3,52(r3)
81132f88:	18c03fcc 	andi	r3,r3,255
81132f8c:	e13ff917 	ldw	r4,-28(fp)
81132f90:	20c7883a 	add	r3,r4,r3
81132f94:	18c002c4 	addi	r3,r3,11
81132f98:	18c00003 	ldbu	r3,0(r3)
81132f9c:	1809883a 	mov	r4,r3
81132fa0:	e0fff717 	ldw	r3,-36(fp)
81132fa4:	18c00d43 	ldbu	r3,53(r3)
81132fa8:	00c6303a 	nor	r3,zero,r3
81132fac:	20c6703a 	and	r3,r4,r3
81132fb0:	1809883a 	mov	r4,r3
81132fb4:	e0fff917 	ldw	r3,-28(fp)
81132fb8:	1887883a 	add	r3,r3,r2
81132fbc:	18c002c4 	addi	r3,r3,11
81132fc0:	19000005 	stb	r4,0(r3)
81132fc4:	e0fff917 	ldw	r3,-28(fp)
81132fc8:	1885883a 	add	r2,r3,r2
81132fcc:	108002c4 	addi	r2,r2,11
81132fd0:	10800003 	ldbu	r2,0(r2)
81132fd4:	10803fcc 	andi	r2,r2,255
81132fd8:	10000a1e 	bne	r2,zero,81133004 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
81132fdc:	e0bff917 	ldw	r2,-28(fp)
81132fe0:	10800283 	ldbu	r2,10(r2)
81132fe4:	1007883a 	mov	r3,r2
81132fe8:	e0bff717 	ldw	r2,-36(fp)
81132fec:	10800d83 	ldbu	r2,54(r2)
81132ff0:	0084303a 	nor	r2,zero,r2
81132ff4:	1884703a 	and	r2,r3,r2
81132ff8:	1007883a 	mov	r3,r2
81132ffc:	e0bff917 	ldw	r2,-28(fp)
81133000:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
81133004:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
81133008:	e0bff717 	ldw	r2,-36(fp)
8113300c:	e0fff303 	ldbu	r3,-52(fp)
81133010:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
81133014:	e0bff717 	ldw	r2,-36(fp)
81133018:	10800c83 	ldbu	r2,50(r2)
8113301c:	10803fcc 	andi	r2,r2,255
81133020:	1004d0fa 	srli	r2,r2,3
81133024:	1007883a 	mov	r3,r2
81133028:	e0bff717 	ldw	r2,-36(fp)
8113302c:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
81133030:	e0bff717 	ldw	r2,-36(fp)
81133034:	10800c83 	ldbu	r2,50(r2)
81133038:	108001cc 	andi	r2,r2,7
8113303c:	1007883a 	mov	r3,r2
81133040:	e0bff717 	ldw	r2,-36(fp)
81133044:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
81133048:	e0bff717 	ldw	r2,-36(fp)
8113304c:	10800d03 	ldbu	r2,52(r2)
81133050:	10803fcc 	andi	r2,r2,255
81133054:	00c00044 	movi	r3,1
81133058:	1884983a 	sll	r2,r3,r2
8113305c:	1007883a 	mov	r3,r2
81133060:	e0bff717 	ldw	r2,-36(fp)
81133064:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
81133068:	e0bff717 	ldw	r2,-36(fp)
8113306c:	10800cc3 	ldbu	r2,51(r2)
81133070:	10803fcc 	andi	r2,r2,255
81133074:	00c00044 	movi	r3,1
81133078:	1884983a 	sll	r2,r3,r2
8113307c:	1007883a 	mov	r3,r2
81133080:	e0bff717 	ldw	r2,-36(fp)
81133084:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
81133088:	e0bff003 	ldbu	r2,-64(fp)
8113308c:	10800058 	cmpnei	r2,r2,1
81133090:	1000161e 	bne	r2,zero,811330ec <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
81133094:	e0bff717 	ldw	r2,-36(fp)
81133098:	10c00d83 	ldbu	r3,54(r2)
8113309c:	d0a08f03 	ldbu	r2,-32196(gp)
811330a0:	1884b03a 	or	r2,r3,r2
811330a4:	d0a08f05 	stb	r2,-32196(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811330a8:	e0bff717 	ldw	r2,-36(fp)
811330ac:	10800d03 	ldbu	r2,52(r2)
811330b0:	10c03fcc 	andi	r3,r2,255
811330b4:	e0bff717 	ldw	r2,-36(fp)
811330b8:	10800d03 	ldbu	r2,52(r2)
811330bc:	11003fcc 	andi	r4,r2,255
811330c0:	d0a08f44 	addi	r2,gp,-32195
811330c4:	2085883a 	add	r2,r4,r2
811330c8:	11000003 	ldbu	r4,0(r2)
811330cc:	e0bff717 	ldw	r2,-36(fp)
811330d0:	10800d43 	ldbu	r2,53(r2)
811330d4:	2084b03a 	or	r2,r4,r2
811330d8:	1009883a 	mov	r4,r2
811330dc:	d0a08f44 	addi	r2,gp,-32195
811330e0:	1885883a 	add	r2,r3,r2
811330e4:	11000005 	stb	r4,0(r2)
811330e8:	00001f06 	br	81133168 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
811330ec:	e0bff717 	ldw	r2,-36(fp)
811330f0:	10800717 	ldw	r2,28(r2)
811330f4:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
811330f8:	e0bff917 	ldw	r2,-28(fp)
811330fc:	10001a26 	beq	r2,zero,81133168 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
81133100:	e0bff917 	ldw	r2,-28(fp)
81133104:	10c00283 	ldbu	r3,10(r2)
81133108:	e0bff717 	ldw	r2,-36(fp)
8113310c:	10800d83 	ldbu	r2,54(r2)
81133110:	1884b03a 	or	r2,r3,r2
81133114:	1007883a 	mov	r3,r2
81133118:	e0bff917 	ldw	r2,-28(fp)
8113311c:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81133120:	e0bff717 	ldw	r2,-36(fp)
81133124:	10800d03 	ldbu	r2,52(r2)
81133128:	10803fcc 	andi	r2,r2,255
8113312c:	e0fff717 	ldw	r3,-36(fp)
81133130:	18c00d03 	ldbu	r3,52(r3)
81133134:	18c03fcc 	andi	r3,r3,255
81133138:	e13ff917 	ldw	r4,-28(fp)
8113313c:	20c7883a 	add	r3,r4,r3
81133140:	18c002c4 	addi	r3,r3,11
81133144:	19000003 	ldbu	r4,0(r3)
81133148:	e0fff717 	ldw	r3,-36(fp)
8113314c:	18c00d43 	ldbu	r3,53(r3)
81133150:	20c6b03a 	or	r3,r4,r3
81133154:	1809883a 	mov	r4,r3
81133158:	e0fff917 	ldw	r3,-28(fp)
8113315c:	1885883a 	add	r2,r3,r2
81133160:	108002c4 	addi	r2,r2,11
81133164:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
81133168:	e0fff303 	ldbu	r3,-52(fp)
8113316c:	00a045b4 	movhi	r2,33046
81133170:	10882104 	addi	r2,r2,8324
81133174:	18c7883a 	add	r3,r3,r3
81133178:	18c7883a 	add	r3,r3,r3
8113317c:	10c5883a 	add	r2,r2,r3
81133180:	e0fff717 	ldw	r3,-36(fp)
81133184:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
81133188:	d0a09317 	ldw	r2,-32180(gp)
8113318c:	d0e09317 	ldw	r3,-32180(gp)
81133190:	18c00c03 	ldbu	r3,48(r3)
81133194:	18c00414 	ori	r3,r3,16
81133198:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113319c:	d0a09317 	ldw	r2,-32180(gp)
811331a0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
811331a4:	d0a09317 	ldw	r2,-32180(gp)
811331a8:	e0fffe0b 	ldhu	r3,-8(fp)
811331ac:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
811331b0:	e13ffd17 	ldw	r4,-12(fp)
811331b4:	112f52c0 	call	8112f52c <OS_EventTaskWait>
811331b8:	e0bff117 	ldw	r2,-60(fp)
811331bc:	e0bffb15 	stw	r2,-20(fp)
811331c0:	e0bffb17 	ldw	r2,-20(fp)
811331c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
811331c8:	112fe480 	call	8112fe48 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811331cc:	0005303a 	rdctl	r2,status
811331d0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811331d4:	e0fff517 	ldw	r3,-44(fp)
811331d8:	00bfff84 	movi	r2,-2
811331dc:	1884703a 	and	r2,r3,r2
811331e0:	1001703a 	wrctl	status,r2
  
  return context;
811331e4:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
811331e8:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
811331ec:	d0a09317 	ldw	r2,-32180(gp)
811331f0:	10800c43 	ldbu	r2,49(r2)
811331f4:	10803fcc 	andi	r2,r2,255
811331f8:	10000326 	beq	r2,zero,81133208 <OSMutexPend+0x51c>
811331fc:	108000a0 	cmpeqi	r2,r2,2
81133200:	1000041e 	bne	r2,zero,81133214 <OSMutexPend+0x528>
81133204:	00000706 	br	81133224 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81133208:	e0bfff17 	ldw	r2,-4(fp)
8113320c:	10000005 	stb	zero,0(r2)
             break;
81133210:	00000c06 	br	81133244 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
81133214:	e0bfff17 	ldw	r2,-4(fp)
81133218:	00c00384 	movi	r3,14
8113321c:	10c00005 	stb	r3,0(r2)
             break;
81133220:	00000806 	br	81133244 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81133224:	d0a09317 	ldw	r2,-32180(gp)
81133228:	e17ffd17 	ldw	r5,-12(fp)
8113322c:	1009883a 	mov	r4,r2
81133230:	112f79c0 	call	8112f79c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
81133234:	e0bfff17 	ldw	r2,-4(fp)
81133238:	00c00284 	movi	r3,10
8113323c:	10c00005 	stb	r3,0(r2)
             break;
81133240:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81133244:	d0a09317 	ldw	r2,-32180(gp)
81133248:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113324c:	d0a09317 	ldw	r2,-32180(gp)
81133250:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81133254:	d0a09317 	ldw	r2,-32180(gp)
81133258:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113325c:	d0a09317 	ldw	r2,-32180(gp)
81133260:	10000815 	stw	zero,32(r2)
81133264:	e0bff117 	ldw	r2,-60(fp)
81133268:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113326c:	e0bffa17 	ldw	r2,-24(fp)
81133270:	1001703a 	wrctl	status,r2
81133274:	00000106 	br	8113327c <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
81133278:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113327c:	e037883a 	mov	sp,fp
81133280:	dfc00117 	ldw	ra,4(sp)
81133284:	df000017 	ldw	fp,0(sp)
81133288:	dec00204 	addi	sp,sp,8
8113328c:	f800283a 	ret

81133290 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
81133290:	defff604 	addi	sp,sp,-40
81133294:	de00012e 	bgeu	sp,et,8113329c <OSMutexPost+0xc>
81133298:	003b68fa 	trap	3
8113329c:	dfc00915 	stw	ra,36(sp)
811332a0:	df000815 	stw	fp,32(sp)
811332a4:	df000804 	addi	fp,sp,32
811332a8:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811332ac:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
811332b0:	d0a09203 	ldbu	r2,-32184(gp)
811332b4:	10803fcc 	andi	r2,r2,255
811332b8:	10000226 	beq	r2,zero,811332c4 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
811332bc:	00800144 	movi	r2,5
811332c0:	00007606 	br	8113349c <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811332c4:	e0bfff17 	ldw	r2,-4(fp)
811332c8:	1000021e 	bne	r2,zero,811332d4 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
811332cc:	00800104 	movi	r2,4
811332d0:	00007206 	br	8113349c <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
811332d4:	e0bfff17 	ldw	r2,-4(fp)
811332d8:	10800003 	ldbu	r2,0(r2)
811332dc:	10803fcc 	andi	r2,r2,255
811332e0:	10800120 	cmpeqi	r2,r2,4
811332e4:	1000021e 	bne	r2,zero,811332f0 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
811332e8:	00800044 	movi	r2,1
811332ec:	00006b06 	br	8113349c <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811332f0:	0005303a 	rdctl	r2,status
811332f4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811332f8:	e0fffe17 	ldw	r3,-8(fp)
811332fc:	00bfff84 	movi	r2,-2
81133300:	1884703a 	and	r2,r3,r2
81133304:	1001703a 	wrctl	status,r2
  
  return context;
81133308:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113330c:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
81133310:	e0bfff17 	ldw	r2,-4(fp)
81133314:	1080020b 	ldhu	r2,8(r2)
81133318:	10bfffcc 	andi	r2,r2,65535
8113331c:	1004d23a 	srli	r2,r2,8
81133320:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
81133324:	e0bfff17 	ldw	r2,-4(fp)
81133328:	1080020b 	ldhu	r2,8(r2)
8113332c:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
81133330:	e0bfff17 	ldw	r2,-4(fp)
81133334:	10c00117 	ldw	r3,4(r2)
81133338:	d0a09317 	ldw	r2,-32180(gp)
8113333c:	18800626 	beq	r3,r2,81133358 <OSMutexPost+0xc8>
81133340:	e0bff817 	ldw	r2,-32(fp)
81133344:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133348:	e0bff917 	ldw	r2,-28(fp)
8113334c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
81133350:	00801904 	movi	r2,100
81133354:	00005106 	br	8113349c <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
81133358:	d0a09317 	ldw	r2,-32180(gp)
8113335c:	10800c83 	ldbu	r2,50(r2)
81133360:	10c03fcc 	andi	r3,r2,255
81133364:	e0bffa03 	ldbu	r2,-24(fp)
81133368:	1880051e 	bne	r3,r2,81133380 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113336c:	d0a09317 	ldw	r2,-32180(gp)
81133370:	e0fffa43 	ldbu	r3,-23(fp)
81133374:	180b883a 	mov	r5,r3
81133378:	1009883a 	mov	r4,r2
8113337c:	11336240 	call	81133624 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
81133380:	e0fffa03 	ldbu	r3,-24(fp)
81133384:	00a045b4 	movhi	r2,33046
81133388:	10882104 	addi	r2,r2,8324
8113338c:	18c7883a 	add	r3,r3,r3
81133390:	18c7883a 	add	r3,r3,r3
81133394:	10c5883a 	add	r2,r2,r3
81133398:	00c00044 	movi	r3,1
8113339c:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
811333a0:	e0bfff17 	ldw	r2,-4(fp)
811333a4:	10800283 	ldbu	r2,10(r2)
811333a8:	10803fcc 	andi	r2,r2,255
811333ac:	10002e26 	beq	r2,zero,81133468 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
811333b0:	000f883a 	mov	r7,zero
811333b4:	01800404 	movi	r6,16
811333b8:	000b883a 	mov	r5,zero
811333bc:	e13fff17 	ldw	r4,-4(fp)
811333c0:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
811333c4:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
811333c8:	e0bfff17 	ldw	r2,-4(fp)
811333cc:	10c0020b 	ldhu	r3,8(r2)
811333d0:	00bfc004 	movi	r2,-256
811333d4:	1884703a 	and	r2,r3,r2
811333d8:	1007883a 	mov	r3,r2
811333dc:	e0bfff17 	ldw	r2,-4(fp)
811333e0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
811333e4:	e0bfff17 	ldw	r2,-4(fp)
811333e8:	10c0020b 	ldhu	r3,8(r2)
811333ec:	e0bffa43 	ldbu	r2,-23(fp)
811333f0:	1884b03a 	or	r2,r3,r2
811333f4:	1007883a 	mov	r3,r2
811333f8:	e0bfff17 	ldw	r2,-4(fp)
811333fc:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
81133400:	e0fffa43 	ldbu	r3,-23(fp)
81133404:	00a045b4 	movhi	r2,33046
81133408:	10882104 	addi	r2,r2,8324
8113340c:	18c7883a 	add	r3,r3,r3
81133410:	18c7883a 	add	r3,r3,r3
81133414:	10c5883a 	add	r2,r2,r3
81133418:	10c00017 	ldw	r3,0(r2)
8113341c:	e0bfff17 	ldw	r2,-4(fp)
81133420:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
81133424:	e0bffa43 	ldbu	r2,-23(fp)
81133428:	e0fffa03 	ldbu	r3,-24(fp)
8113342c:	18800736 	bltu	r3,r2,8113344c <OSMutexPost+0x1bc>
81133430:	e0bff817 	ldw	r2,-32(fp)
81133434:	e0bffb15 	stw	r2,-20(fp)
81133438:	e0bffb17 	ldw	r2,-20(fp)
8113343c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
81133440:	112fe480 	call	8112fe48 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
81133444:	00801e04 	movi	r2,120
81133448:	00001406 	br	8113349c <OSMutexPost+0x20c>
8113344c:	e0bff817 	ldw	r2,-32(fp)
81133450:	e0bffc15 	stw	r2,-16(fp)
81133454:	e0bffc17 	ldw	r2,-16(fp)
81133458:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113345c:	112fe480 	call	8112fe48 <OS_Sched>
            return (OS_ERR_NONE);
81133460:	0005883a 	mov	r2,zero
81133464:	00000d06 	br	8113349c <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
81133468:	e0bfff17 	ldw	r2,-4(fp)
8113346c:	1080020b 	ldhu	r2,8(r2)
81133470:	10803fd4 	ori	r2,r2,255
81133474:	1007883a 	mov	r3,r2
81133478:	e0bfff17 	ldw	r2,-4(fp)
8113347c:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
81133480:	e0bfff17 	ldw	r2,-4(fp)
81133484:	10000115 	stw	zero,4(r2)
81133488:	e0bff817 	ldw	r2,-32(fp)
8113348c:	e0bffd15 	stw	r2,-12(fp)
81133490:	e0bffd17 	ldw	r2,-12(fp)
81133494:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81133498:	0005883a 	mov	r2,zero
}
8113349c:	e037883a 	mov	sp,fp
811334a0:	dfc00117 	ldw	ra,4(sp)
811334a4:	df000017 	ldw	fp,0(sp)
811334a8:	dec00204 	addi	sp,sp,8
811334ac:	f800283a 	ret

811334b0 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
811334b0:	defff704 	addi	sp,sp,-36
811334b4:	de00012e 	bgeu	sp,et,811334bc <OSMutexQuery+0xc>
811334b8:	003b68fa 	trap	3
811334bc:	df000815 	stw	fp,32(sp)
811334c0:	df000804 	addi	fp,sp,32
811334c4:	e13ffe15 	stw	r4,-8(fp)
811334c8:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811334cc:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811334d0:	d0a09203 	ldbu	r2,-32184(gp)
811334d4:	10803fcc 	andi	r2,r2,255
811334d8:	10000226 	beq	r2,zero,811334e4 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
811334dc:	00800184 	movi	r2,6
811334e0:	00004c06 	br	81133614 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811334e4:	e0bffe17 	ldw	r2,-8(fp)
811334e8:	1000021e 	bne	r2,zero,811334f4 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
811334ec:	00800104 	movi	r2,4
811334f0:	00004806 	br	81133614 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
811334f4:	e0bfff17 	ldw	r2,-4(fp)
811334f8:	1000021e 	bne	r2,zero,81133504 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
811334fc:	00800244 	movi	r2,9
81133500:	00004406 	br	81133614 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81133504:	e0bffe17 	ldw	r2,-8(fp)
81133508:	10800003 	ldbu	r2,0(r2)
8113350c:	10803fcc 	andi	r2,r2,255
81133510:	10800120 	cmpeqi	r2,r2,4
81133514:	1000021e 	bne	r2,zero,81133520 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
81133518:	00800044 	movi	r2,1
8113351c:	00003d06 	br	81133614 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133520:	0005303a 	rdctl	r2,status
81133524:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133528:	e0fffd17 	ldw	r3,-12(fp)
8113352c:	00bfff84 	movi	r2,-2
81133530:	1884703a 	and	r2,r3,r2
81133534:	1001703a 	wrctl	status,r2
  
  return context;
81133538:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113353c:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
81133540:	e0bffe17 	ldw	r2,-8(fp)
81133544:	1080020b 	ldhu	r2,8(r2)
81133548:	10bfffcc 	andi	r2,r2,65535
8113354c:	1004d23a 	srli	r2,r2,8
81133550:	1007883a 	mov	r3,r2
81133554:	e0bfff17 	ldw	r2,-4(fp)
81133558:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113355c:	e0bffe17 	ldw	r2,-8(fp)
81133560:	1080020b 	ldhu	r2,8(r2)
81133564:	1007883a 	mov	r3,r2
81133568:	e0bfff17 	ldw	r2,-4(fp)
8113356c:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
81133570:	e0bfff17 	ldw	r2,-4(fp)
81133574:	10800203 	ldbu	r2,8(r2)
81133578:	10803fcc 	andi	r2,r2,255
8113357c:	10803fd8 	cmpnei	r2,r2,255
81133580:	1000041e 	bne	r2,zero,81133594 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
81133584:	e0bfff17 	ldw	r2,-4(fp)
81133588:	00c00044 	movi	r3,1
8113358c:	10c001c5 	stb	r3,7(r2)
81133590:	00000206 	br	8113359c <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
81133594:	e0bfff17 	ldw	r2,-4(fp)
81133598:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113359c:	e0bffe17 	ldw	r2,-8(fp)
811335a0:	10c00283 	ldbu	r3,10(r2)
811335a4:	e0bfff17 	ldw	r2,-4(fp)
811335a8:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
811335ac:	e0bffe17 	ldw	r2,-8(fp)
811335b0:	108002c4 	addi	r2,r2,11
811335b4:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
811335b8:	e0bfff17 	ldw	r2,-4(fp)
811335bc:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811335c0:	e03ff805 	stb	zero,-32(fp)
811335c4:	00000b06 	br	811335f4 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
811335c8:	e0bffa17 	ldw	r2,-24(fp)
811335cc:	10c00044 	addi	r3,r2,1
811335d0:	e0fffa15 	stw	r3,-24(fp)
811335d4:	e0fff917 	ldw	r3,-28(fp)
811335d8:	19000044 	addi	r4,r3,1
811335dc:	e13ff915 	stw	r4,-28(fp)
811335e0:	18c00003 	ldbu	r3,0(r3)
811335e4:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811335e8:	e0bff803 	ldbu	r2,-32(fp)
811335ec:	10800044 	addi	r2,r2,1
811335f0:	e0bff805 	stb	r2,-32(fp)
811335f4:	e0bff803 	ldbu	r2,-32(fp)
811335f8:	108001b0 	cmpltui	r2,r2,6
811335fc:	103ff21e 	bne	r2,zero,811335c8 <__reset+0xfb1135c8>
81133600:	e0bffb17 	ldw	r2,-20(fp)
81133604:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133608:	e0bffc17 	ldw	r2,-16(fp)
8113360c:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81133610:	0005883a 	mov	r2,zero
}
81133614:	e037883a 	mov	sp,fp
81133618:	df000017 	ldw	fp,0(sp)
8113361c:	dec00104 	addi	sp,sp,4
81133620:	f800283a 	ret

81133624 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
81133624:	defffc04 	addi	sp,sp,-16
81133628:	de00012e 	bgeu	sp,et,81133630 <OSMutex_RdyAtPrio+0xc>
8113362c:	003b68fa 	trap	3
81133630:	df000315 	stw	fp,12(sp)
81133634:	df000304 	addi	fp,sp,12
81133638:	e13ffe15 	stw	r4,-8(fp)
8113363c:	2805883a 	mov	r2,r5
81133640:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
81133644:	e0bffe17 	ldw	r2,-8(fp)
81133648:	10800d03 	ldbu	r2,52(r2)
8113364c:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
81133650:	e0fffd03 	ldbu	r3,-12(fp)
81133654:	e13ffd03 	ldbu	r4,-12(fp)
81133658:	d0a08f44 	addi	r2,gp,-32195
8113365c:	2085883a 	add	r2,r4,r2
81133660:	10800003 	ldbu	r2,0(r2)
81133664:	1009883a 	mov	r4,r2
81133668:	e0bffe17 	ldw	r2,-8(fp)
8113366c:	10800d43 	ldbu	r2,53(r2)
81133670:	0084303a 	nor	r2,zero,r2
81133674:	2084703a 	and	r2,r4,r2
81133678:	1009883a 	mov	r4,r2
8113367c:	d0a08f44 	addi	r2,gp,-32195
81133680:	1885883a 	add	r2,r3,r2
81133684:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81133688:	e0fffd03 	ldbu	r3,-12(fp)
8113368c:	d0a08f44 	addi	r2,gp,-32195
81133690:	1885883a 	add	r2,r3,r2
81133694:	10800003 	ldbu	r2,0(r2)
81133698:	10803fcc 	andi	r2,r2,255
8113369c:	1000071e 	bne	r2,zero,811336bc <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
811336a0:	e0bffe17 	ldw	r2,-8(fp)
811336a4:	10800d83 	ldbu	r2,54(r2)
811336a8:	0084303a 	nor	r2,zero,r2
811336ac:	1007883a 	mov	r3,r2
811336b0:	d0a08f03 	ldbu	r2,-32196(gp)
811336b4:	1884703a 	and	r2,r3,r2
811336b8:	d0a08f05 	stb	r2,-32196(gp)
    }
    ptcb->OSTCBPrio         = prio;
811336bc:	e0bffe17 	ldw	r2,-8(fp)
811336c0:	e0ffff03 	ldbu	r3,-4(fp)
811336c4:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
811336c8:	e0bfff03 	ldbu	r2,-4(fp)
811336cc:	1004d0fa 	srli	r2,r2,3
811336d0:	108001cc 	andi	r2,r2,7
811336d4:	1007883a 	mov	r3,r2
811336d8:	e0bffe17 	ldw	r2,-8(fp)
811336dc:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
811336e0:	e0bfff03 	ldbu	r2,-4(fp)
811336e4:	108001cc 	andi	r2,r2,7
811336e8:	1007883a 	mov	r3,r2
811336ec:	e0bffe17 	ldw	r2,-8(fp)
811336f0:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
811336f4:	e0bffe17 	ldw	r2,-8(fp)
811336f8:	10800d03 	ldbu	r2,52(r2)
811336fc:	10803fcc 	andi	r2,r2,255
81133700:	00c00044 	movi	r3,1
81133704:	1884983a 	sll	r2,r3,r2
81133708:	1007883a 	mov	r3,r2
8113370c:	e0bffe17 	ldw	r2,-8(fp)
81133710:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
81133714:	e0bffe17 	ldw	r2,-8(fp)
81133718:	10800cc3 	ldbu	r2,51(r2)
8113371c:	10803fcc 	andi	r2,r2,255
81133720:	00c00044 	movi	r3,1
81133724:	1884983a 	sll	r2,r3,r2
81133728:	1007883a 	mov	r3,r2
8113372c:	e0bffe17 	ldw	r2,-8(fp)
81133730:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
81133734:	e0bffe17 	ldw	r2,-8(fp)
81133738:	10c00d83 	ldbu	r3,54(r2)
8113373c:	d0a08f03 	ldbu	r2,-32196(gp)
81133740:	1884b03a 	or	r2,r3,r2
81133744:	d0a08f05 	stb	r2,-32196(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81133748:	e0bffe17 	ldw	r2,-8(fp)
8113374c:	10800d03 	ldbu	r2,52(r2)
81133750:	10c03fcc 	andi	r3,r2,255
81133754:	e0bffe17 	ldw	r2,-8(fp)
81133758:	10800d03 	ldbu	r2,52(r2)
8113375c:	11003fcc 	andi	r4,r2,255
81133760:	d0a08f44 	addi	r2,gp,-32195
81133764:	2085883a 	add	r2,r4,r2
81133768:	11000003 	ldbu	r4,0(r2)
8113376c:	e0bffe17 	ldw	r2,-8(fp)
81133770:	10800d43 	ldbu	r2,53(r2)
81133774:	2084b03a 	or	r2,r4,r2
81133778:	1009883a 	mov	r4,r2
8113377c:	d0a08f44 	addi	r2,gp,-32195
81133780:	1885883a 	add	r2,r3,r2
81133784:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
81133788:	e0ffff03 	ldbu	r3,-4(fp)
8113378c:	00a045b4 	movhi	r2,33046
81133790:	10882104 	addi	r2,r2,8324
81133794:	18c7883a 	add	r3,r3,r3
81133798:	18c7883a 	add	r3,r3,r3
8113379c:	10c5883a 	add	r2,r2,r3
811337a0:	e0fffe17 	ldw	r3,-8(fp)
811337a4:	10c00015 	stw	r3,0(r2)
}
811337a8:	0001883a 	nop
811337ac:	e037883a 	mov	sp,fp
811337b0:	df000017 	ldw	fp,0(sp)
811337b4:	dec00104 	addi	sp,sp,4
811337b8:	f800283a 	ret

811337bc <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
811337bc:	defff804 	addi	sp,sp,-32
811337c0:	de00012e 	bgeu	sp,et,811337c8 <OSQAccept+0xc>
811337c4:	003b68fa 	trap	3
811337c8:	df000715 	stw	fp,28(sp)
811337cc:	df000704 	addi	fp,sp,28
811337d0:	e13ffe15 	stw	r4,-8(fp)
811337d4:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811337d8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811337dc:	e0bfff17 	ldw	r2,-4(fp)
811337e0:	1000021e 	bne	r2,zero,811337ec <OSQAccept+0x30>
        return ((void *)0);
811337e4:	0005883a 	mov	r2,zero
811337e8:	00004206 	br	811338f4 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
811337ec:	e0bffe17 	ldw	r2,-8(fp)
811337f0:	1000051e 	bne	r2,zero,81133808 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
811337f4:	e0bfff17 	ldw	r2,-4(fp)
811337f8:	00c00104 	movi	r3,4
811337fc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81133800:	0005883a 	mov	r2,zero
81133804:	00003b06 	br	811338f4 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81133808:	e0bffe17 	ldw	r2,-8(fp)
8113380c:	10800003 	ldbu	r2,0(r2)
81133810:	10803fcc 	andi	r2,r2,255
81133814:	108000a0 	cmpeqi	r2,r2,2
81133818:	1000051e 	bne	r2,zero,81133830 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113381c:	e0bfff17 	ldw	r2,-4(fp)
81133820:	00c00044 	movi	r3,1
81133824:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81133828:	0005883a 	mov	r2,zero
8113382c:	00003106 	br	811338f4 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133830:	0005303a 	rdctl	r2,status
81133834:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133838:	e0fffd17 	ldw	r3,-12(fp)
8113383c:	00bfff84 	movi	r2,-2
81133840:	1884703a 	and	r2,r3,r2
81133844:	1001703a 	wrctl	status,r2
  
  return context;
81133848:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113384c:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81133850:	e0bffe17 	ldw	r2,-8(fp)
81133854:	10800117 	ldw	r2,4(r2)
81133858:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113385c:	e0bffc17 	ldw	r2,-16(fp)
81133860:	1080058b 	ldhu	r2,22(r2)
81133864:	10bfffcc 	andi	r2,r2,65535
81133868:	10001926 	beq	r2,zero,811338d0 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113386c:	e0bffc17 	ldw	r2,-16(fp)
81133870:	10800417 	ldw	r2,16(r2)
81133874:	11000104 	addi	r4,r2,4
81133878:	e0fffc17 	ldw	r3,-16(fp)
8113387c:	19000415 	stw	r4,16(r3)
81133880:	10800017 	ldw	r2,0(r2)
81133884:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81133888:	e0bffc17 	ldw	r2,-16(fp)
8113388c:	1080058b 	ldhu	r2,22(r2)
81133890:	10bfffc4 	addi	r2,r2,-1
81133894:	1007883a 	mov	r3,r2
81133898:	e0bffc17 	ldw	r2,-16(fp)
8113389c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
811338a0:	e0bffc17 	ldw	r2,-16(fp)
811338a4:	10c00417 	ldw	r3,16(r2)
811338a8:	e0bffc17 	ldw	r2,-16(fp)
811338ac:	10800217 	ldw	r2,8(r2)
811338b0:	1880041e 	bne	r3,r2,811338c4 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
811338b4:	e0bffc17 	ldw	r2,-16(fp)
811338b8:	10c00117 	ldw	r3,4(r2)
811338bc:	e0bffc17 	ldw	r2,-16(fp)
811338c0:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
811338c4:	e0bfff17 	ldw	r2,-4(fp)
811338c8:	10000005 	stb	zero,0(r2)
811338cc:	00000406 	br	811338e0 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
811338d0:	e0bfff17 	ldw	r2,-4(fp)
811338d4:	00c007c4 	movi	r3,31
811338d8:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
811338dc:	e03ff915 	stw	zero,-28(fp)
811338e0:	e0bffa17 	ldw	r2,-24(fp)
811338e4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811338e8:	e0bffb17 	ldw	r2,-20(fp)
811338ec:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
811338f0:	e0bff917 	ldw	r2,-28(fp)
}
811338f4:	e037883a 	mov	sp,fp
811338f8:	df000017 	ldw	fp,0(sp)
811338fc:	dec00104 	addi	sp,sp,4
81133900:	f800283a 	ret

81133904 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
81133904:	defff404 	addi	sp,sp,-48
81133908:	de00012e 	bgeu	sp,et,81133910 <OSQCreate+0xc>
8113390c:	003b68fa 	trap	3
81133910:	dfc00b15 	stw	ra,44(sp)
81133914:	df000a15 	stw	fp,40(sp)
81133918:	df000a04 	addi	fp,sp,40
8113391c:	e13ffe15 	stw	r4,-8(fp)
81133920:	2805883a 	mov	r2,r5
81133924:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133928:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113392c:	d0a09203 	ldbu	r2,-32184(gp)
81133930:	10803fcc 	andi	r2,r2,255
81133934:	10000226 	beq	r2,zero,81133940 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
81133938:	0005883a 	mov	r2,zero
8113393c:	00005906 	br	81133aa4 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133940:	0005303a 	rdctl	r2,status
81133944:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133948:	e0fffd17 	ldw	r3,-12(fp)
8113394c:	00bfff84 	movi	r2,-2
81133950:	1884703a 	and	r2,r3,r2
81133954:	1001703a 	wrctl	status,r2
  
  return context;
81133958:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113395c:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
81133960:	d0a09117 	ldw	r2,-32188(gp)
81133964:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
81133968:	d0a09117 	ldw	r2,-32188(gp)
8113396c:	10000326 	beq	r2,zero,8113397c <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
81133970:	d0a09117 	ldw	r2,-32188(gp)
81133974:	10800117 	ldw	r2,4(r2)
81133978:	d0a09115 	stw	r2,-32188(gp)
8113397c:	e0bff717 	ldw	r2,-36(fp)
81133980:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133984:	e0bff817 	ldw	r2,-32(fp)
81133988:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113398c:	e0bff617 	ldw	r2,-40(fp)
81133990:	10004326 	beq	r2,zero,81133aa0 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133994:	0005303a 	rdctl	r2,status
81133998:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113399c:	e0fff917 	ldw	r3,-28(fp)
811339a0:	00bfff84 	movi	r2,-2
811339a4:	1884703a 	and	r2,r3,r2
811339a8:	1001703a 	wrctl	status,r2
  
  return context;
811339ac:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
811339b0:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
811339b4:	d0a08e17 	ldw	r2,-32200(gp)
811339b8:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
811339bc:	e0bffb17 	ldw	r2,-20(fp)
811339c0:	10002d26 	beq	r2,zero,81133a78 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
811339c4:	d0a08e17 	ldw	r2,-32200(gp)
811339c8:	10800017 	ldw	r2,0(r2)
811339cc:	d0a08e15 	stw	r2,-32200(gp)
811339d0:	e0bff717 	ldw	r2,-36(fp)
811339d4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811339d8:	e0bffa17 	ldw	r2,-24(fp)
811339dc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
811339e0:	e0bffb17 	ldw	r2,-20(fp)
811339e4:	e0fffe17 	ldw	r3,-8(fp)
811339e8:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
811339ec:	e0bfff0b 	ldhu	r2,-4(fp)
811339f0:	1085883a 	add	r2,r2,r2
811339f4:	1085883a 	add	r2,r2,r2
811339f8:	1007883a 	mov	r3,r2
811339fc:	e0bffe17 	ldw	r2,-8(fp)
81133a00:	10c7883a 	add	r3,r2,r3
81133a04:	e0bffb17 	ldw	r2,-20(fp)
81133a08:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
81133a0c:	e0bffb17 	ldw	r2,-20(fp)
81133a10:	e0fffe17 	ldw	r3,-8(fp)
81133a14:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
81133a18:	e0bffb17 	ldw	r2,-20(fp)
81133a1c:	e0fffe17 	ldw	r3,-8(fp)
81133a20:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
81133a24:	e0bffb17 	ldw	r2,-20(fp)
81133a28:	e0ffff0b 	ldhu	r3,-4(fp)
81133a2c:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
81133a30:	e0bffb17 	ldw	r2,-20(fp)
81133a34:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
81133a38:	e0bff617 	ldw	r2,-40(fp)
81133a3c:	00c00084 	movi	r3,2
81133a40:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
81133a44:	e0bff617 	ldw	r2,-40(fp)
81133a48:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
81133a4c:	e0bff617 	ldw	r2,-40(fp)
81133a50:	e0fffb17 	ldw	r3,-20(fp)
81133a54:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
81133a58:	e0bff617 	ldw	r2,-40(fp)
81133a5c:	00c00fc4 	movi	r3,63
81133a60:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
81133a64:	e0bff617 	ldw	r2,-40(fp)
81133a68:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
81133a6c:	e13ff617 	ldw	r4,-40(fp)
81133a70:	112f9640 	call	8112f964 <OS_EventWaitListInit>
81133a74:	00000a06 	br	81133aa0 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
81133a78:	d0e09117 	ldw	r3,-32188(gp)
81133a7c:	e0bff617 	ldw	r2,-40(fp)
81133a80:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
81133a84:	e0bff617 	ldw	r2,-40(fp)
81133a88:	d0a09115 	stw	r2,-32188(gp)
81133a8c:	e0bff717 	ldw	r2,-36(fp)
81133a90:	e0bffc15 	stw	r2,-16(fp)
81133a94:	e0bffc17 	ldw	r2,-16(fp)
81133a98:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
81133a9c:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
81133aa0:	e0bff617 	ldw	r2,-40(fp)
}
81133aa4:	e037883a 	mov	sp,fp
81133aa8:	dfc00117 	ldw	ra,4(sp)
81133aac:	df000017 	ldw	fp,0(sp)
81133ab0:	dec00204 	addi	sp,sp,8
81133ab4:	f800283a 	ret

81133ab8 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81133ab8:	defff204 	addi	sp,sp,-56
81133abc:	de00012e 	bgeu	sp,et,81133ac4 <OSQDel+0xc>
81133ac0:	003b68fa 	trap	3
81133ac4:	dfc00d15 	stw	ra,52(sp)
81133ac8:	df000c15 	stw	fp,48(sp)
81133acc:	df000c04 	addi	fp,sp,48
81133ad0:	e13ffd15 	stw	r4,-12(fp)
81133ad4:	2805883a 	mov	r2,r5
81133ad8:	e1bfff15 	stw	r6,-4(fp)
81133adc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81133ae0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81133ae4:	e0bfff17 	ldw	r2,-4(fp)
81133ae8:	1000021e 	bne	r2,zero,81133af4 <OSQDel+0x3c>
        return (pevent);
81133aec:	e0bffd17 	ldw	r2,-12(fp)
81133af0:	00008e06 	br	81133d2c <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81133af4:	e0bffd17 	ldw	r2,-12(fp)
81133af8:	1000051e 	bne	r2,zero,81133b10 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81133afc:	e0bfff17 	ldw	r2,-4(fp)
81133b00:	00c00104 	movi	r3,4
81133b04:	10c00005 	stb	r3,0(r2)
        return (pevent);
81133b08:	e0bffd17 	ldw	r2,-12(fp)
81133b0c:	00008706 	br	81133d2c <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81133b10:	e0bffd17 	ldw	r2,-12(fp)
81133b14:	10800003 	ldbu	r2,0(r2)
81133b18:	10803fcc 	andi	r2,r2,255
81133b1c:	108000a0 	cmpeqi	r2,r2,2
81133b20:	1000051e 	bne	r2,zero,81133b38 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81133b24:	e0bfff17 	ldw	r2,-4(fp)
81133b28:	00c00044 	movi	r3,1
81133b2c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81133b30:	e0bffd17 	ldw	r2,-12(fp)
81133b34:	00007d06 	br	81133d2c <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81133b38:	d0a09203 	ldbu	r2,-32184(gp)
81133b3c:	10803fcc 	andi	r2,r2,255
81133b40:	10000526 	beq	r2,zero,81133b58 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
81133b44:	e0bfff17 	ldw	r2,-4(fp)
81133b48:	00c003c4 	movi	r3,15
81133b4c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81133b50:	e0bffd17 	ldw	r2,-12(fp)
81133b54:	00007506 	br	81133d2c <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133b58:	0005303a 	rdctl	r2,status
81133b5c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133b60:	e0fffc17 	ldw	r3,-16(fp)
81133b64:	00bfff84 	movi	r2,-2
81133b68:	1884703a 	and	r2,r3,r2
81133b6c:	1001703a 	wrctl	status,r2
  
  return context;
81133b70:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81133b74:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
81133b78:	e0bffd17 	ldw	r2,-12(fp)
81133b7c:	10800283 	ldbu	r2,10(r2)
81133b80:	10803fcc 	andi	r2,r2,255
81133b84:	10000326 	beq	r2,zero,81133b94 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81133b88:	00800044 	movi	r2,1
81133b8c:	e0bff405 	stb	r2,-48(fp)
81133b90:	00000106 	br	81133b98 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81133b94:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81133b98:	e0bffe03 	ldbu	r2,-8(fp)
81133b9c:	10000326 	beq	r2,zero,81133bac <OSQDel+0xf4>
81133ba0:	10800060 	cmpeqi	r2,r2,1
81133ba4:	1000301e 	bne	r2,zero,81133c68 <OSQDel+0x1b0>
81133ba8:	00005506 	br	81133d00 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
81133bac:	e0bff403 	ldbu	r2,-48(fp)
81133bb0:	10001e1e 	bne	r2,zero,81133c2c <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81133bb4:	e0bffd17 	ldw	r2,-12(fp)
81133bb8:	00c00fc4 	movi	r3,63
81133bbc:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81133bc0:	e0bffd17 	ldw	r2,-12(fp)
81133bc4:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
81133bc8:	e0bffd17 	ldw	r2,-12(fp)
81133bcc:	10800117 	ldw	r2,4(r2)
81133bd0:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
81133bd4:	d0e08e17 	ldw	r3,-32200(gp)
81133bd8:	e0bff817 	ldw	r2,-32(fp)
81133bdc:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
81133be0:	e0bff817 	ldw	r2,-32(fp)
81133be4:	d0a08e15 	stw	r2,-32200(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81133be8:	e0bffd17 	ldw	r2,-12(fp)
81133bec:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81133bf0:	d0e09117 	ldw	r3,-32188(gp)
81133bf4:	e0bffd17 	ldw	r2,-12(fp)
81133bf8:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81133bfc:	e0bffd17 	ldw	r2,-12(fp)
81133c00:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81133c04:	e0bffd17 	ldw	r2,-12(fp)
81133c08:	d0a09115 	stw	r2,-32188(gp)
81133c0c:	e0bff617 	ldw	r2,-40(fp)
81133c10:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133c14:	e0bff717 	ldw	r2,-36(fp)
81133c18:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81133c1c:	e0bfff17 	ldw	r2,-4(fp)
81133c20:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
81133c24:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81133c28:	00003f06 	br	81133d28 <OSQDel+0x270>
81133c2c:	e0bff617 	ldw	r2,-40(fp)
81133c30:	e0bff915 	stw	r2,-28(fp)
81133c34:	e0bff917 	ldw	r2,-28(fp)
81133c38:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81133c3c:	e0bfff17 	ldw	r2,-4(fp)
81133c40:	00c01244 	movi	r3,73
81133c44:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81133c48:	e0bffd17 	ldw	r2,-12(fp)
81133c4c:	e0bff515 	stw	r2,-44(fp)
             }
             break;
81133c50:	00003506 	br	81133d28 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
81133c54:	000f883a 	mov	r7,zero
81133c58:	01800104 	movi	r6,4
81133c5c:	000b883a 	mov	r5,zero
81133c60:	e13ffd17 	ldw	r4,-12(fp)
81133c64:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
81133c68:	e0bffd17 	ldw	r2,-12(fp)
81133c6c:	10800283 	ldbu	r2,10(r2)
81133c70:	10803fcc 	andi	r2,r2,255
81133c74:	103ff71e 	bne	r2,zero,81133c54 <__reset+0xfb113c54>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81133c78:	e0bffd17 	ldw	r2,-12(fp)
81133c7c:	00c00fc4 	movi	r3,63
81133c80:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81133c84:	e0bffd17 	ldw	r2,-12(fp)
81133c88:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
81133c8c:	e0bffd17 	ldw	r2,-12(fp)
81133c90:	10800117 	ldw	r2,4(r2)
81133c94:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
81133c98:	d0e08e17 	ldw	r3,-32200(gp)
81133c9c:	e0bff817 	ldw	r2,-32(fp)
81133ca0:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
81133ca4:	e0bff817 	ldw	r2,-32(fp)
81133ca8:	d0a08e15 	stw	r2,-32200(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81133cac:	e0bffd17 	ldw	r2,-12(fp)
81133cb0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
81133cb4:	d0e09117 	ldw	r3,-32188(gp)
81133cb8:	e0bffd17 	ldw	r2,-12(fp)
81133cbc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81133cc0:	e0bffd17 	ldw	r2,-12(fp)
81133cc4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81133cc8:	e0bffd17 	ldw	r2,-12(fp)
81133ccc:	d0a09115 	stw	r2,-32188(gp)
81133cd0:	e0bff617 	ldw	r2,-40(fp)
81133cd4:	e0bffa15 	stw	r2,-24(fp)
81133cd8:	e0bffa17 	ldw	r2,-24(fp)
81133cdc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81133ce0:	e0bff403 	ldbu	r2,-48(fp)
81133ce4:	10800058 	cmpnei	r2,r2,1
81133ce8:	1000011e 	bne	r2,zero,81133cf0 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81133cec:	112fe480 	call	8112fe48 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81133cf0:	e0bfff17 	ldw	r2,-4(fp)
81133cf4:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
81133cf8:	e03ff515 	stw	zero,-44(fp)
             break;
81133cfc:	00000a06 	br	81133d28 <OSQDel+0x270>
81133d00:	e0bff617 	ldw	r2,-40(fp)
81133d04:	e0bffb15 	stw	r2,-20(fp)
81133d08:	e0bffb17 	ldw	r2,-20(fp)
81133d0c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81133d10:	e0bfff17 	ldw	r2,-4(fp)
81133d14:	00c001c4 	movi	r3,7
81133d18:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81133d1c:	e0bffd17 	ldw	r2,-12(fp)
81133d20:	e0bff515 	stw	r2,-44(fp)
             break;
81133d24:	0001883a 	nop
    }
    return (pevent_return);
81133d28:	e0bff517 	ldw	r2,-44(fp)
}
81133d2c:	e037883a 	mov	sp,fp
81133d30:	dfc00117 	ldw	ra,4(sp)
81133d34:	df000017 	ldw	fp,0(sp)
81133d38:	dec00204 	addi	sp,sp,8
81133d3c:	f800283a 	ret

81133d40 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
81133d40:	defffa04 	addi	sp,sp,-24
81133d44:	de00012e 	bgeu	sp,et,81133d4c <OSQFlush+0xc>
81133d48:	003b68fa 	trap	3
81133d4c:	df000515 	stw	fp,20(sp)
81133d50:	df000504 	addi	fp,sp,20
81133d54:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81133d58:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81133d5c:	e0bfff17 	ldw	r2,-4(fp)
81133d60:	1000021e 	bne	r2,zero,81133d6c <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
81133d64:	00800104 	movi	r2,4
81133d68:	00002106 	br	81133df0 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81133d6c:	e0bfff17 	ldw	r2,-4(fp)
81133d70:	10800003 	ldbu	r2,0(r2)
81133d74:	10803fcc 	andi	r2,r2,255
81133d78:	108000a0 	cmpeqi	r2,r2,2
81133d7c:	1000021e 	bne	r2,zero,81133d88 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
81133d80:	00800044 	movi	r2,1
81133d84:	00001a06 	br	81133df0 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133d88:	0005303a 	rdctl	r2,status
81133d8c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133d90:	e0fffd17 	ldw	r3,-12(fp)
81133d94:	00bfff84 	movi	r2,-2
81133d98:	1884703a 	and	r2,r3,r2
81133d9c:	1001703a 	wrctl	status,r2
  
  return context;
81133da0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81133da4:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
81133da8:	e0bfff17 	ldw	r2,-4(fp)
81133dac:	10800117 	ldw	r2,4(r2)
81133db0:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
81133db4:	e0bffc17 	ldw	r2,-16(fp)
81133db8:	10c00117 	ldw	r3,4(r2)
81133dbc:	e0bffc17 	ldw	r2,-16(fp)
81133dc0:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
81133dc4:	e0bffc17 	ldw	r2,-16(fp)
81133dc8:	10c00117 	ldw	r3,4(r2)
81133dcc:	e0bffc17 	ldw	r2,-16(fp)
81133dd0:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
81133dd4:	e0bffc17 	ldw	r2,-16(fp)
81133dd8:	1000058d 	sth	zero,22(r2)
81133ddc:	e0bffb17 	ldw	r2,-20(fp)
81133de0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133de4:	e0bffe17 	ldw	r2,-8(fp)
81133de8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81133dec:	0005883a 	mov	r2,zero
}
81133df0:	e037883a 	mov	sp,fp
81133df4:	df000017 	ldw	fp,0(sp)
81133df8:	dec00104 	addi	sp,sp,4
81133dfc:	f800283a 	ret

81133e00 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81133e00:	defff304 	addi	sp,sp,-52
81133e04:	de00012e 	bgeu	sp,et,81133e0c <OSQPend+0xc>
81133e08:	003b68fa 	trap	3
81133e0c:	dfc00c15 	stw	ra,48(sp)
81133e10:	df000b15 	stw	fp,44(sp)
81133e14:	df000b04 	addi	fp,sp,44
81133e18:	e13ffd15 	stw	r4,-12(fp)
81133e1c:	2805883a 	mov	r2,r5
81133e20:	e1bfff15 	stw	r6,-4(fp)
81133e24:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133e28:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81133e2c:	e0bfff17 	ldw	r2,-4(fp)
81133e30:	1000021e 	bne	r2,zero,81133e3c <OSQPend+0x3c>
        return ((void *)0);
81133e34:	0005883a 	mov	r2,zero
81133e38:	00009106 	br	81134080 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
81133e3c:	e0bffd17 	ldw	r2,-12(fp)
81133e40:	1000051e 	bne	r2,zero,81133e58 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81133e44:	e0bfff17 	ldw	r2,-4(fp)
81133e48:	00c00104 	movi	r3,4
81133e4c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81133e50:	0005883a 	mov	r2,zero
81133e54:	00008a06 	br	81134080 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81133e58:	e0bffd17 	ldw	r2,-12(fp)
81133e5c:	10800003 	ldbu	r2,0(r2)
81133e60:	10803fcc 	andi	r2,r2,255
81133e64:	108000a0 	cmpeqi	r2,r2,2
81133e68:	1000051e 	bne	r2,zero,81133e80 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81133e6c:	e0bfff17 	ldw	r2,-4(fp)
81133e70:	00c00044 	movi	r3,1
81133e74:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81133e78:	0005883a 	mov	r2,zero
81133e7c:	00008006 	br	81134080 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81133e80:	d0a09203 	ldbu	r2,-32184(gp)
81133e84:	10803fcc 	andi	r2,r2,255
81133e88:	10000526 	beq	r2,zero,81133ea0 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
81133e8c:	e0bfff17 	ldw	r2,-4(fp)
81133e90:	00c00084 	movi	r3,2
81133e94:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81133e98:	0005883a 	mov	r2,zero
81133e9c:	00007806 	br	81134080 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
81133ea0:	d0a08003 	ldbu	r2,-32256(gp)
81133ea4:	10803fcc 	andi	r2,r2,255
81133ea8:	10000526 	beq	r2,zero,81133ec0 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
81133eac:	e0bfff17 	ldw	r2,-4(fp)
81133eb0:	00c00344 	movi	r3,13
81133eb4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81133eb8:	0005883a 	mov	r2,zero
81133ebc:	00007006 	br	81134080 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133ec0:	0005303a 	rdctl	r2,status
81133ec4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133ec8:	e0fffc17 	ldw	r3,-16(fp)
81133ecc:	00bfff84 	movi	r2,-2
81133ed0:	1884703a 	and	r2,r3,r2
81133ed4:	1001703a 	wrctl	status,r2
  
  return context;
81133ed8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81133edc:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81133ee0:	e0bffd17 	ldw	r2,-12(fp)
81133ee4:	10800117 	ldw	r2,4(r2)
81133ee8:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
81133eec:	e0bff817 	ldw	r2,-32(fp)
81133ef0:	1080058b 	ldhu	r2,22(r2)
81133ef4:	10bfffcc 	andi	r2,r2,65535
81133ef8:	10001e26 	beq	r2,zero,81133f74 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
81133efc:	e0bff817 	ldw	r2,-32(fp)
81133f00:	10800417 	ldw	r2,16(r2)
81133f04:	11000104 	addi	r4,r2,4
81133f08:	e0fff817 	ldw	r3,-32(fp)
81133f0c:	19000415 	stw	r4,16(r3)
81133f10:	10800017 	ldw	r2,0(r2)
81133f14:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81133f18:	e0bff817 	ldw	r2,-32(fp)
81133f1c:	1080058b 	ldhu	r2,22(r2)
81133f20:	10bfffc4 	addi	r2,r2,-1
81133f24:	1007883a 	mov	r3,r2
81133f28:	e0bff817 	ldw	r2,-32(fp)
81133f2c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81133f30:	e0bff817 	ldw	r2,-32(fp)
81133f34:	10c00417 	ldw	r3,16(r2)
81133f38:	e0bff817 	ldw	r2,-32(fp)
81133f3c:	10800217 	ldw	r2,8(r2)
81133f40:	1880041e 	bne	r3,r2,81133f54 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
81133f44:	e0bff817 	ldw	r2,-32(fp)
81133f48:	10c00117 	ldw	r3,4(r2)
81133f4c:	e0bff817 	ldw	r2,-32(fp)
81133f50:	10c00415 	stw	r3,16(r2)
81133f54:	e0bff617 	ldw	r2,-40(fp)
81133f58:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133f5c:	e0bff717 	ldw	r2,-36(fp)
81133f60:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81133f64:	e0bfff17 	ldw	r2,-4(fp)
81133f68:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
81133f6c:	e0bff517 	ldw	r2,-44(fp)
81133f70:	00004306 	br	81134080 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
81133f74:	d0a09317 	ldw	r2,-32180(gp)
81133f78:	d0e09317 	ldw	r3,-32180(gp)
81133f7c:	18c00c03 	ldbu	r3,48(r3)
81133f80:	18c00114 	ori	r3,r3,4
81133f84:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81133f88:	d0a09317 	ldw	r2,-32180(gp)
81133f8c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
81133f90:	d0a09317 	ldw	r2,-32180(gp)
81133f94:	e0fffe0b 	ldhu	r3,-8(fp)
81133f98:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
81133f9c:	e13ffd17 	ldw	r4,-12(fp)
81133fa0:	112f52c0 	call	8112f52c <OS_EventTaskWait>
81133fa4:	e0bff617 	ldw	r2,-40(fp)
81133fa8:	e0bffb15 	stw	r2,-20(fp)
81133fac:	e0bffb17 	ldw	r2,-20(fp)
81133fb0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
81133fb4:	112fe480 	call	8112fe48 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133fb8:	0005303a 	rdctl	r2,status
81133fbc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133fc0:	e0fff917 	ldw	r3,-28(fp)
81133fc4:	00bfff84 	movi	r2,-2
81133fc8:	1884703a 	and	r2,r3,r2
81133fcc:	1001703a 	wrctl	status,r2
  
  return context;
81133fd0:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81133fd4:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81133fd8:	d0a09317 	ldw	r2,-32180(gp)
81133fdc:	10800c43 	ldbu	r2,49(r2)
81133fe0:	10803fcc 	andi	r2,r2,255
81133fe4:	10000326 	beq	r2,zero,81133ff4 <OSQPend+0x1f4>
81133fe8:	108000a0 	cmpeqi	r2,r2,2
81133fec:	1000071e 	bne	r2,zero,8113400c <OSQPend+0x20c>
81133ff0:	00000b06 	br	81134020 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
81133ff4:	d0a09317 	ldw	r2,-32180(gp)
81133ff8:	10800917 	ldw	r2,36(r2)
81133ffc:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
81134000:	e0bfff17 	ldw	r2,-4(fp)
81134004:	10000005 	stb	zero,0(r2)
             break;
81134008:	00000e06 	br	81134044 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113400c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81134010:	e0bfff17 	ldw	r2,-4(fp)
81134014:	00c00384 	movi	r3,14
81134018:	10c00005 	stb	r3,0(r2)
             break;
8113401c:	00000906 	br	81134044 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81134020:	d0a09317 	ldw	r2,-32180(gp)
81134024:	e17ffd17 	ldw	r5,-12(fp)
81134028:	1009883a 	mov	r4,r2
8113402c:	112f79c0 	call	8112f79c <OS_EventTaskRemove>
             pmsg = (void *)0;
81134030:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81134034:	e0bfff17 	ldw	r2,-4(fp)
81134038:	00c00284 	movi	r3,10
8113403c:	10c00005 	stb	r3,0(r2)
             break;
81134040:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81134044:	d0a09317 	ldw	r2,-32180(gp)
81134048:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113404c:	d0a09317 	ldw	r2,-32180(gp)
81134050:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81134054:	d0a09317 	ldw	r2,-32180(gp)
81134058:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113405c:	d0a09317 	ldw	r2,-32180(gp)
81134060:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
81134064:	d0a09317 	ldw	r2,-32180(gp)
81134068:	10000915 	stw	zero,36(r2)
8113406c:	e0bff617 	ldw	r2,-40(fp)
81134070:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134074:	e0bffa17 	ldw	r2,-24(fp)
81134078:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113407c:	e0bff517 	ldw	r2,-44(fp)
}
81134080:	e037883a 	mov	sp,fp
81134084:	dfc00117 	ldw	ra,4(sp)
81134088:	df000017 	ldw	fp,0(sp)
8113408c:	dec00204 	addi	sp,sp,8
81134090:	f800283a 	ret

81134094 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81134094:	defff604 	addi	sp,sp,-40
81134098:	de00012e 	bgeu	sp,et,811340a0 <OSQPendAbort+0xc>
8113409c:	003b68fa 	trap	3
811340a0:	dfc00915 	stw	ra,36(sp)
811340a4:	df000815 	stw	fp,32(sp)
811340a8:	df000804 	addi	fp,sp,32
811340ac:	e13ffd15 	stw	r4,-12(fp)
811340b0:	2805883a 	mov	r2,r5
811340b4:	e1bfff15 	stw	r6,-4(fp)
811340b8:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811340bc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811340c0:	e0bfff17 	ldw	r2,-4(fp)
811340c4:	1000021e 	bne	r2,zero,811340d0 <OSQPendAbort+0x3c>
        return (0);
811340c8:	0005883a 	mov	r2,zero
811340cc:	00004906 	br	811341f4 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811340d0:	e0bffd17 	ldw	r2,-12(fp)
811340d4:	1000051e 	bne	r2,zero,811340ec <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811340d8:	e0bfff17 	ldw	r2,-4(fp)
811340dc:	00c00104 	movi	r3,4
811340e0:	10c00005 	stb	r3,0(r2)
        return (0);
811340e4:	0005883a 	mov	r2,zero
811340e8:	00004206 	br	811341f4 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
811340ec:	e0bffd17 	ldw	r2,-12(fp)
811340f0:	10800003 	ldbu	r2,0(r2)
811340f4:	10803fcc 	andi	r2,r2,255
811340f8:	108000a0 	cmpeqi	r2,r2,2
811340fc:	1000051e 	bne	r2,zero,81134114 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81134100:	e0bfff17 	ldw	r2,-4(fp)
81134104:	00c00044 	movi	r3,1
81134108:	10c00005 	stb	r3,0(r2)
        return (0);
8113410c:	0005883a 	mov	r2,zero
81134110:	00003806 	br	811341f4 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134114:	0005303a 	rdctl	r2,status
81134118:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113411c:	e0fffc17 	ldw	r3,-16(fp)
81134120:	00bfff84 	movi	r2,-2
81134124:	1884703a 	and	r2,r3,r2
81134128:	1001703a 	wrctl	status,r2
  
  return context;
8113412c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134130:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
81134134:	e0bffd17 	ldw	r2,-12(fp)
81134138:	10800283 	ldbu	r2,10(r2)
8113413c:	10803fcc 	andi	r2,r2,255
81134140:	10002526 	beq	r2,zero,811341d8 <OSQPendAbort+0x144>
        nbr_tasks = 0;
81134144:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81134148:	e0bffe03 	ldbu	r2,-8(fp)
8113414c:	10800060 	cmpeqi	r2,r2,1
81134150:	10000e26 	beq	r2,zero,8113418c <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81134154:	00000806 	br	81134178 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81134158:	01c00084 	movi	r7,2
8113415c:	01800104 	movi	r6,4
81134160:	000b883a 	mov	r5,zero
81134164:	e13ffd17 	ldw	r4,-12(fp)
81134168:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
                     nbr_tasks++;
8113416c:	e0bff803 	ldbu	r2,-32(fp)
81134170:	10800044 	addi	r2,r2,1
81134174:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81134178:	e0bffd17 	ldw	r2,-12(fp)
8113417c:	10800283 	ldbu	r2,10(r2)
81134180:	10803fcc 	andi	r2,r2,255
81134184:	103ff41e 	bne	r2,zero,81134158 <__reset+0xfb114158>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81134188:	00000906 	br	811341b0 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113418c:	01c00084 	movi	r7,2
81134190:	01800104 	movi	r6,4
81134194:	000b883a 	mov	r5,zero
81134198:	e13ffd17 	ldw	r4,-12(fp)
8113419c:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
                 nbr_tasks++;
811341a0:	e0bff803 	ldbu	r2,-32(fp)
811341a4:	10800044 	addi	r2,r2,1
811341a8:	e0bff805 	stb	r2,-32(fp)
                 break;
811341ac:	0001883a 	nop
811341b0:	e0bff917 	ldw	r2,-28(fp)
811341b4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811341b8:	e0bffa17 	ldw	r2,-24(fp)
811341bc:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
811341c0:	112fe480 	call	8112fe48 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
811341c4:	e0bfff17 	ldw	r2,-4(fp)
811341c8:	00c00384 	movi	r3,14
811341cc:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
811341d0:	e0bff803 	ldbu	r2,-32(fp)
811341d4:	00000706 	br	811341f4 <OSQPendAbort+0x160>
811341d8:	e0bff917 	ldw	r2,-28(fp)
811341dc:	e0bffb15 	stw	r2,-20(fp)
811341e0:	e0bffb17 	ldw	r2,-20(fp)
811341e4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811341e8:	e0bfff17 	ldw	r2,-4(fp)
811341ec:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
811341f0:	0005883a 	mov	r2,zero
}
811341f4:	e037883a 	mov	sp,fp
811341f8:	dfc00117 	ldw	ra,4(sp)
811341fc:	df000017 	ldw	fp,0(sp)
81134200:	dec00204 	addi	sp,sp,8
81134204:	f800283a 	ret

81134208 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
81134208:	defff604 	addi	sp,sp,-40
8113420c:	de00012e 	bgeu	sp,et,81134214 <OSQPost+0xc>
81134210:	003b68fa 	trap	3
81134214:	dfc00915 	stw	ra,36(sp)
81134218:	df000815 	stw	fp,32(sp)
8113421c:	df000804 	addi	fp,sp,32
81134220:	e13ffe15 	stw	r4,-8(fp)
81134224:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81134228:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113422c:	e0bffe17 	ldw	r2,-8(fp)
81134230:	1000021e 	bne	r2,zero,8113423c <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
81134234:	00800104 	movi	r2,4
81134238:	00004a06 	br	81134364 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113423c:	e0bffe17 	ldw	r2,-8(fp)
81134240:	10800003 	ldbu	r2,0(r2)
81134244:	10803fcc 	andi	r2,r2,255
81134248:	108000a0 	cmpeqi	r2,r2,2
8113424c:	1000021e 	bne	r2,zero,81134258 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
81134250:	00800044 	movi	r2,1
81134254:	00004306 	br	81134364 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134258:	0005303a 	rdctl	r2,status
8113425c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134260:	e0fffd17 	ldw	r3,-12(fp)
81134264:	00bfff84 	movi	r2,-2
81134268:	1884703a 	and	r2,r3,r2
8113426c:	1001703a 	wrctl	status,r2
  
  return context;
81134270:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81134274:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
81134278:	e0bffe17 	ldw	r2,-8(fp)
8113427c:	10800283 	ldbu	r2,10(r2)
81134280:	10803fcc 	andi	r2,r2,255
81134284:	10000c26 	beq	r2,zero,811342b8 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81134288:	000f883a 	mov	r7,zero
8113428c:	01800104 	movi	r6,4
81134290:	e17fff17 	ldw	r5,-4(fp)
81134294:	e13ffe17 	ldw	r4,-8(fp)
81134298:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
8113429c:	e0bff817 	ldw	r2,-32(fp)
811342a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811342a4:	e0bff917 	ldw	r2,-28(fp)
811342a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
811342ac:	112fe480 	call	8112fe48 <OS_Sched>
        return (OS_ERR_NONE);
811342b0:	0005883a 	mov	r2,zero
811342b4:	00002b06 	br	81134364 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
811342b8:	e0bffe17 	ldw	r2,-8(fp)
811342bc:	10800117 	ldw	r2,4(r2)
811342c0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
811342c4:	e0bffb17 	ldw	r2,-20(fp)
811342c8:	10c0058b 	ldhu	r3,22(r2)
811342cc:	e0bffb17 	ldw	r2,-20(fp)
811342d0:	1080050b 	ldhu	r2,20(r2)
811342d4:	18ffffcc 	andi	r3,r3,65535
811342d8:	10bfffcc 	andi	r2,r2,65535
811342dc:	18800636 	bltu	r3,r2,811342f8 <OSQPost+0xf0>
811342e0:	e0bff817 	ldw	r2,-32(fp)
811342e4:	e0bffa15 	stw	r2,-24(fp)
811342e8:	e0bffa17 	ldw	r2,-24(fp)
811342ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
811342f0:	00800784 	movi	r2,30
811342f4:	00001b06 	br	81134364 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
811342f8:	e0bffb17 	ldw	r2,-20(fp)
811342fc:	10800317 	ldw	r2,12(r2)
81134300:	11000104 	addi	r4,r2,4
81134304:	e0fffb17 	ldw	r3,-20(fp)
81134308:	19000315 	stw	r4,12(r3)
8113430c:	e0ffff17 	ldw	r3,-4(fp)
81134310:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
81134314:	e0bffb17 	ldw	r2,-20(fp)
81134318:	1080058b 	ldhu	r2,22(r2)
8113431c:	10800044 	addi	r2,r2,1
81134320:	1007883a 	mov	r3,r2
81134324:	e0bffb17 	ldw	r2,-20(fp)
81134328:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113432c:	e0bffb17 	ldw	r2,-20(fp)
81134330:	10c00317 	ldw	r3,12(r2)
81134334:	e0bffb17 	ldw	r2,-20(fp)
81134338:	10800217 	ldw	r2,8(r2)
8113433c:	1880041e 	bne	r3,r2,81134350 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
81134340:	e0bffb17 	ldw	r2,-20(fp)
81134344:	10c00117 	ldw	r3,4(r2)
81134348:	e0bffb17 	ldw	r2,-20(fp)
8113434c:	10c00315 	stw	r3,12(r2)
81134350:	e0bff817 	ldw	r2,-32(fp)
81134354:	e0bffc15 	stw	r2,-16(fp)
81134358:	e0bffc17 	ldw	r2,-16(fp)
8113435c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81134360:	0005883a 	mov	r2,zero
}
81134364:	e037883a 	mov	sp,fp
81134368:	dfc00117 	ldw	ra,4(sp)
8113436c:	df000017 	ldw	fp,0(sp)
81134370:	dec00204 	addi	sp,sp,8
81134374:	f800283a 	ret

81134378 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
81134378:	defff604 	addi	sp,sp,-40
8113437c:	de00012e 	bgeu	sp,et,81134384 <OSQPostFront+0xc>
81134380:	003b68fa 	trap	3
81134384:	dfc00915 	stw	ra,36(sp)
81134388:	df000815 	stw	fp,32(sp)
8113438c:	df000804 	addi	fp,sp,32
81134390:	e13ffe15 	stw	r4,-8(fp)
81134394:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81134398:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113439c:	e0bffe17 	ldw	r2,-8(fp)
811343a0:	1000021e 	bne	r2,zero,811343ac <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
811343a4:	00800104 	movi	r2,4
811343a8:	00004c06 	br	811344dc <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
811343ac:	e0bffe17 	ldw	r2,-8(fp)
811343b0:	10800003 	ldbu	r2,0(r2)
811343b4:	10803fcc 	andi	r2,r2,255
811343b8:	108000a0 	cmpeqi	r2,r2,2
811343bc:	1000021e 	bne	r2,zero,811343c8 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
811343c0:	00800044 	movi	r2,1
811343c4:	00004506 	br	811344dc <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811343c8:	0005303a 	rdctl	r2,status
811343cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811343d0:	e0fffd17 	ldw	r3,-12(fp)
811343d4:	00bfff84 	movi	r2,-2
811343d8:	1884703a 	and	r2,r3,r2
811343dc:	1001703a 	wrctl	status,r2
  
  return context;
811343e0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811343e4:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
811343e8:	e0bffe17 	ldw	r2,-8(fp)
811343ec:	10800283 	ldbu	r2,10(r2)
811343f0:	10803fcc 	andi	r2,r2,255
811343f4:	10000c26 	beq	r2,zero,81134428 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
811343f8:	000f883a 	mov	r7,zero
811343fc:	01800104 	movi	r6,4
81134400:	e17fff17 	ldw	r5,-4(fp)
81134404:	e13ffe17 	ldw	r4,-8(fp)
81134408:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
8113440c:	e0bff817 	ldw	r2,-32(fp)
81134410:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134414:	e0bff917 	ldw	r2,-28(fp)
81134418:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113441c:	112fe480 	call	8112fe48 <OS_Sched>
        return (OS_ERR_NONE);
81134420:	0005883a 	mov	r2,zero
81134424:	00002d06 	br	811344dc <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81134428:	e0bffe17 	ldw	r2,-8(fp)
8113442c:	10800117 	ldw	r2,4(r2)
81134430:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81134434:	e0bffb17 	ldw	r2,-20(fp)
81134438:	10c0058b 	ldhu	r3,22(r2)
8113443c:	e0bffb17 	ldw	r2,-20(fp)
81134440:	1080050b 	ldhu	r2,20(r2)
81134444:	18ffffcc 	andi	r3,r3,65535
81134448:	10bfffcc 	andi	r2,r2,65535
8113444c:	18800636 	bltu	r3,r2,81134468 <OSQPostFront+0xf0>
81134450:	e0bff817 	ldw	r2,-32(fp)
81134454:	e0bffa15 	stw	r2,-24(fp)
81134458:	e0bffa17 	ldw	r2,-24(fp)
8113445c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81134460:	00800784 	movi	r2,30
81134464:	00001d06 	br	811344dc <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
81134468:	e0bffb17 	ldw	r2,-20(fp)
8113446c:	10c00417 	ldw	r3,16(r2)
81134470:	e0bffb17 	ldw	r2,-20(fp)
81134474:	10800117 	ldw	r2,4(r2)
81134478:	1880041e 	bne	r3,r2,8113448c <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113447c:	e0bffb17 	ldw	r2,-20(fp)
81134480:	10c00217 	ldw	r3,8(r2)
81134484:	e0bffb17 	ldw	r2,-20(fp)
81134488:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113448c:	e0bffb17 	ldw	r2,-20(fp)
81134490:	10800417 	ldw	r2,16(r2)
81134494:	10ffff04 	addi	r3,r2,-4
81134498:	e0bffb17 	ldw	r2,-20(fp)
8113449c:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
811344a0:	e0bffb17 	ldw	r2,-20(fp)
811344a4:	10800417 	ldw	r2,16(r2)
811344a8:	e0ffff17 	ldw	r3,-4(fp)
811344ac:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
811344b0:	e0bffb17 	ldw	r2,-20(fp)
811344b4:	1080058b 	ldhu	r2,22(r2)
811344b8:	10800044 	addi	r2,r2,1
811344bc:	1007883a 	mov	r3,r2
811344c0:	e0bffb17 	ldw	r2,-20(fp)
811344c4:	10c0058d 	sth	r3,22(r2)
811344c8:	e0bff817 	ldw	r2,-32(fp)
811344cc:	e0bffc15 	stw	r2,-16(fp)
811344d0:	e0bffc17 	ldw	r2,-16(fp)
811344d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811344d8:	0005883a 	mov	r2,zero
}
811344dc:	e037883a 	mov	sp,fp
811344e0:	dfc00117 	ldw	ra,4(sp)
811344e4:	df000017 	ldw	fp,0(sp)
811344e8:	dec00204 	addi	sp,sp,8
811344ec:	f800283a 	ret

811344f0 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
811344f0:	defff504 	addi	sp,sp,-44
811344f4:	de00012e 	bgeu	sp,et,811344fc <OSQPostOpt+0xc>
811344f8:	003b68fa 	trap	3
811344fc:	dfc00a15 	stw	ra,40(sp)
81134500:	df000915 	stw	fp,36(sp)
81134504:	df000904 	addi	fp,sp,36
81134508:	e13ffd15 	stw	r4,-12(fp)
8113450c:	e17ffe15 	stw	r5,-8(fp)
81134510:	3005883a 	mov	r2,r6
81134514:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81134518:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113451c:	e0bffd17 	ldw	r2,-12(fp)
81134520:	1000021e 	bne	r2,zero,8113452c <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
81134524:	00800104 	movi	r2,4
81134528:	00007106 	br	811346f0 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113452c:	e0bffd17 	ldw	r2,-12(fp)
81134530:	10800003 	ldbu	r2,0(r2)
81134534:	10803fcc 	andi	r2,r2,255
81134538:	108000a0 	cmpeqi	r2,r2,2
8113453c:	1000021e 	bne	r2,zero,81134548 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
81134540:	00800044 	movi	r2,1
81134544:	00006a06 	br	811346f0 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134548:	0005303a 	rdctl	r2,status
8113454c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134550:	e0fffc17 	ldw	r3,-16(fp)
81134554:	00bfff84 	movi	r2,-2
81134558:	1884703a 	and	r2,r3,r2
8113455c:	1001703a 	wrctl	status,r2
  
  return context;
81134560:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134564:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
81134568:	e0bffd17 	ldw	r2,-12(fp)
8113456c:	10800283 	ldbu	r2,10(r2)
81134570:	10803fcc 	andi	r2,r2,255
81134574:	10001d26 	beq	r2,zero,811345ec <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
81134578:	e0bfff03 	ldbu	r2,-4(fp)
8113457c:	1080004c 	andi	r2,r2,1
81134580:	10000b26 	beq	r2,zero,811345b0 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81134584:	00000506 	br	8113459c <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81134588:	000f883a 	mov	r7,zero
8113458c:	01800104 	movi	r6,4
81134590:	e17ffe17 	ldw	r5,-8(fp)
81134594:	e13ffd17 	ldw	r4,-12(fp)
81134598:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113459c:	e0bffd17 	ldw	r2,-12(fp)
811345a0:	10800283 	ldbu	r2,10(r2)
811345a4:	10803fcc 	andi	r2,r2,255
811345a8:	103ff71e 	bne	r2,zero,81134588 <__reset+0xfb114588>
811345ac:	00000506 	br	811345c4 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
811345b0:	000f883a 	mov	r7,zero
811345b4:	01800104 	movi	r6,4
811345b8:	e17ffe17 	ldw	r5,-8(fp)
811345bc:	e13ffd17 	ldw	r4,-12(fp)
811345c0:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
811345c4:	e0bff717 	ldw	r2,-36(fp)
811345c8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811345cc:	e0bff817 	ldw	r2,-32(fp)
811345d0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
811345d4:	e0bfff03 	ldbu	r2,-4(fp)
811345d8:	1080010c 	andi	r2,r2,4
811345dc:	1000011e 	bne	r2,zero,811345e4 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
811345e0:	112fe480 	call	8112fe48 <OS_Sched>
        }
        return (OS_ERR_NONE);
811345e4:	0005883a 	mov	r2,zero
811345e8:	00004106 	br	811346f0 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
811345ec:	e0bffd17 	ldw	r2,-12(fp)
811345f0:	10800117 	ldw	r2,4(r2)
811345f4:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
811345f8:	e0bffa17 	ldw	r2,-24(fp)
811345fc:	10c0058b 	ldhu	r3,22(r2)
81134600:	e0bffa17 	ldw	r2,-24(fp)
81134604:	1080050b 	ldhu	r2,20(r2)
81134608:	18ffffcc 	andi	r3,r3,65535
8113460c:	10bfffcc 	andi	r2,r2,65535
81134610:	18800636 	bltu	r3,r2,8113462c <OSQPostOpt+0x13c>
81134614:	e0bff717 	ldw	r2,-36(fp)
81134618:	e0bff915 	stw	r2,-28(fp)
8113461c:	e0bff917 	ldw	r2,-28(fp)
81134620:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81134624:	00800784 	movi	r2,30
81134628:	00003106 	br	811346f0 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113462c:	e0bfff03 	ldbu	r2,-4(fp)
81134630:	1080008c 	andi	r2,r2,2
81134634:	10001326 	beq	r2,zero,81134684 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
81134638:	e0bffa17 	ldw	r2,-24(fp)
8113463c:	10c00417 	ldw	r3,16(r2)
81134640:	e0bffa17 	ldw	r2,-24(fp)
81134644:	10800117 	ldw	r2,4(r2)
81134648:	1880041e 	bne	r3,r2,8113465c <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113464c:	e0bffa17 	ldw	r2,-24(fp)
81134650:	10c00217 	ldw	r3,8(r2)
81134654:	e0bffa17 	ldw	r2,-24(fp)
81134658:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113465c:	e0bffa17 	ldw	r2,-24(fp)
81134660:	10800417 	ldw	r2,16(r2)
81134664:	10ffff04 	addi	r3,r2,-4
81134668:	e0bffa17 	ldw	r2,-24(fp)
8113466c:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
81134670:	e0bffa17 	ldw	r2,-24(fp)
81134674:	10800417 	ldw	r2,16(r2)
81134678:	e0fffe17 	ldw	r3,-8(fp)
8113467c:	10c00015 	stw	r3,0(r2)
81134680:	00001006 	br	811346c4 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
81134684:	e0bffa17 	ldw	r2,-24(fp)
81134688:	10800317 	ldw	r2,12(r2)
8113468c:	11000104 	addi	r4,r2,4
81134690:	e0fffa17 	ldw	r3,-24(fp)
81134694:	19000315 	stw	r4,12(r3)
81134698:	e0fffe17 	ldw	r3,-8(fp)
8113469c:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
811346a0:	e0bffa17 	ldw	r2,-24(fp)
811346a4:	10c00317 	ldw	r3,12(r2)
811346a8:	e0bffa17 	ldw	r2,-24(fp)
811346ac:	10800217 	ldw	r2,8(r2)
811346b0:	1880041e 	bne	r3,r2,811346c4 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
811346b4:	e0bffa17 	ldw	r2,-24(fp)
811346b8:	10c00117 	ldw	r3,4(r2)
811346bc:	e0bffa17 	ldw	r2,-24(fp)
811346c0:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
811346c4:	e0bffa17 	ldw	r2,-24(fp)
811346c8:	1080058b 	ldhu	r2,22(r2)
811346cc:	10800044 	addi	r2,r2,1
811346d0:	1007883a 	mov	r3,r2
811346d4:	e0bffa17 	ldw	r2,-24(fp)
811346d8:	10c0058d 	sth	r3,22(r2)
811346dc:	e0bff717 	ldw	r2,-36(fp)
811346e0:	e0bffb15 	stw	r2,-20(fp)
811346e4:	e0bffb17 	ldw	r2,-20(fp)
811346e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811346ec:	0005883a 	mov	r2,zero
}
811346f0:	e037883a 	mov	sp,fp
811346f4:	dfc00117 	ldw	ra,4(sp)
811346f8:	df000017 	ldw	fp,0(sp)
811346fc:	dec00204 	addi	sp,sp,8
81134700:	f800283a 	ret

81134704 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
81134704:	defff604 	addi	sp,sp,-40
81134708:	de00012e 	bgeu	sp,et,81134710 <OSQQuery+0xc>
8113470c:	003b68fa 	trap	3
81134710:	df000915 	stw	fp,36(sp)
81134714:	df000904 	addi	fp,sp,36
81134718:	e13ffe15 	stw	r4,-8(fp)
8113471c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81134720:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81134724:	e0bffe17 	ldw	r2,-8(fp)
81134728:	1000021e 	bne	r2,zero,81134734 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113472c:	00800104 	movi	r2,4
81134730:	00004906 	br	81134858 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
81134734:	e0bfff17 	ldw	r2,-4(fp)
81134738:	1000021e 	bne	r2,zero,81134744 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113473c:	00800244 	movi	r2,9
81134740:	00004506 	br	81134858 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81134744:	e0bffe17 	ldw	r2,-8(fp)
81134748:	10800003 	ldbu	r2,0(r2)
8113474c:	10803fcc 	andi	r2,r2,255
81134750:	108000a0 	cmpeqi	r2,r2,2
81134754:	1000021e 	bne	r2,zero,81134760 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81134758:	00800044 	movi	r2,1
8113475c:	00003e06 	br	81134858 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134760:	0005303a 	rdctl	r2,status
81134764:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134768:	e0fffd17 	ldw	r3,-12(fp)
8113476c:	00bfff84 	movi	r2,-2
81134770:	1884703a 	and	r2,r3,r2
81134774:	1001703a 	wrctl	status,r2
  
  return context;
81134778:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113477c:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
81134780:	e0bffe17 	ldw	r2,-8(fp)
81134784:	10c00283 	ldbu	r3,10(r2)
81134788:	e0bfff17 	ldw	r2,-4(fp)
8113478c:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
81134790:	e0bffe17 	ldw	r2,-8(fp)
81134794:	108002c4 	addi	r2,r2,11
81134798:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113479c:	e0bfff17 	ldw	r2,-4(fp)
811347a0:	10800204 	addi	r2,r2,8
811347a4:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811347a8:	e03ff705 	stb	zero,-36(fp)
811347ac:	00000b06 	br	811347dc <OSQQuery+0xd8>
        *pdest++ = *psrc++;
811347b0:	e0bff917 	ldw	r2,-28(fp)
811347b4:	10c00044 	addi	r3,r2,1
811347b8:	e0fff915 	stw	r3,-28(fp)
811347bc:	e0fff817 	ldw	r3,-32(fp)
811347c0:	19000044 	addi	r4,r3,1
811347c4:	e13ff815 	stw	r4,-32(fp)
811347c8:	18c00003 	ldbu	r3,0(r3)
811347cc:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811347d0:	e0bff703 	ldbu	r2,-36(fp)
811347d4:	10800044 	addi	r2,r2,1
811347d8:	e0bff705 	stb	r2,-36(fp)
811347dc:	e0bff703 	ldbu	r2,-36(fp)
811347e0:	108001b0 	cmpltui	r2,r2,6
811347e4:	103ff21e 	bne	r2,zero,811347b0 <__reset+0xfb1147b0>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
811347e8:	e0bffe17 	ldw	r2,-8(fp)
811347ec:	10800117 	ldw	r2,4(r2)
811347f0:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
811347f4:	e0bffc17 	ldw	r2,-16(fp)
811347f8:	1080058b 	ldhu	r2,22(r2)
811347fc:	10bfffcc 	andi	r2,r2,65535
81134800:	10000626 	beq	r2,zero,8113481c <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
81134804:	e0bffc17 	ldw	r2,-16(fp)
81134808:	10800417 	ldw	r2,16(r2)
8113480c:	10c00017 	ldw	r3,0(r2)
81134810:	e0bfff17 	ldw	r2,-4(fp)
81134814:	10c00015 	stw	r3,0(r2)
81134818:	00000206 	br	81134824 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113481c:	e0bfff17 	ldw	r2,-4(fp)
81134820:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
81134824:	e0bffc17 	ldw	r2,-16(fp)
81134828:	10c0058b 	ldhu	r3,22(r2)
8113482c:	e0bfff17 	ldw	r2,-4(fp)
81134830:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
81134834:	e0bffc17 	ldw	r2,-16(fp)
81134838:	10c0050b 	ldhu	r3,20(r2)
8113483c:	e0bfff17 	ldw	r2,-4(fp)
81134840:	10c0018d 	sth	r3,6(r2)
81134844:	e0bffa17 	ldw	r2,-24(fp)
81134848:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113484c:	e0bffb17 	ldw	r2,-20(fp)
81134850:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81134854:	0005883a 	mov	r2,zero
}
81134858:	e037883a 	mov	sp,fp
8113485c:	df000017 	ldw	fp,0(sp)
81134860:	dec00104 	addi	sp,sp,4
81134864:	f800283a 	ret

81134868 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
81134868:	defffb04 	addi	sp,sp,-20
8113486c:	de00012e 	bgeu	sp,et,81134874 <OS_QInit+0xc>
81134870:	003b68fa 	trap	3
81134874:	dfc00415 	stw	ra,16(sp)
81134878:	df000315 	stw	fp,12(sp)
8113487c:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
81134880:	01406004 	movi	r5,384
81134884:	012045b4 	movhi	r4,33046
81134888:	213aeb04 	addi	r4,r4,-5204
8113488c:	112fd7c0 	call	8112fd7c <OS_MemClr>
    pq1 = &OSQTbl[0];
81134890:	00a045b4 	movhi	r2,33046
81134894:	10baeb04 	addi	r2,r2,-5204
81134898:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113489c:	00a045b4 	movhi	r2,33046
811348a0:	10baf104 	addi	r2,r2,-5180
811348a4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
811348a8:	e03ffd0d 	sth	zero,-12(fp)
811348ac:	00000c06 	br	811348e0 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
811348b0:	e0bffe17 	ldw	r2,-8(fp)
811348b4:	e0ffff17 	ldw	r3,-4(fp)
811348b8:	10c00015 	stw	r3,0(r2)
        pq1++;
811348bc:	e0bffe17 	ldw	r2,-8(fp)
811348c0:	10800604 	addi	r2,r2,24
811348c4:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
811348c8:	e0bfff17 	ldw	r2,-4(fp)
811348cc:	10800604 	addi	r2,r2,24
811348d0:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
811348d4:	e0bffd0b 	ldhu	r2,-12(fp)
811348d8:	10800044 	addi	r2,r2,1
811348dc:	e0bffd0d 	sth	r2,-12(fp)
811348e0:	e0bffd0b 	ldhu	r2,-12(fp)
811348e4:	108003f0 	cmpltui	r2,r2,15
811348e8:	103ff11e 	bne	r2,zero,811348b0 <__reset+0xfb1148b0>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
811348ec:	e0bffe17 	ldw	r2,-8(fp)
811348f0:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
811348f4:	00a045b4 	movhi	r2,33046
811348f8:	10baeb04 	addi	r2,r2,-5204
811348fc:	d0a08e15 	stw	r2,-32200(gp)
#endif
}
81134900:	0001883a 	nop
81134904:	e037883a 	mov	sp,fp
81134908:	dfc00117 	ldw	ra,4(sp)
8113490c:	df000017 	ldw	fp,0(sp)
81134910:	dec00204 	addi	sp,sp,8
81134914:	f800283a 	ret

81134918 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
81134918:	defffa04 	addi	sp,sp,-24
8113491c:	de00012e 	bgeu	sp,et,81134924 <OSSemAccept+0xc>
81134920:	003b68fa 	trap	3
81134924:	df000515 	stw	fp,20(sp)
81134928:	df000504 	addi	fp,sp,20
8113492c:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81134930:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81134934:	e0bfff17 	ldw	r2,-4(fp)
81134938:	1000021e 	bne	r2,zero,81134944 <OSSemAccept+0x2c>
        return (0);
8113493c:	0005883a 	mov	r2,zero
81134940:	00001f06 	br	811349c0 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81134944:	e0bfff17 	ldw	r2,-4(fp)
81134948:	10800003 	ldbu	r2,0(r2)
8113494c:	10803fcc 	andi	r2,r2,255
81134950:	108000e0 	cmpeqi	r2,r2,3
81134954:	1000021e 	bne	r2,zero,81134960 <OSSemAccept+0x48>
        return (0);
81134958:	0005883a 	mov	r2,zero
8113495c:	00001806 	br	811349c0 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134960:	0005303a 	rdctl	r2,status
81134964:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134968:	e0fffe17 	ldw	r3,-8(fp)
8113496c:	00bfff84 	movi	r2,-2
81134970:	1884703a 	and	r2,r3,r2
81134974:	1001703a 	wrctl	status,r2
  
  return context;
81134978:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113497c:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
81134980:	e0bfff17 	ldw	r2,-4(fp)
81134984:	1080020b 	ldhu	r2,8(r2)
81134988:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113498c:	e0bffd0b 	ldhu	r2,-12(fp)
81134990:	10000626 	beq	r2,zero,811349ac <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
81134994:	e0bfff17 	ldw	r2,-4(fp)
81134998:	1080020b 	ldhu	r2,8(r2)
8113499c:	10bfffc4 	addi	r2,r2,-1
811349a0:	1007883a 	mov	r3,r2
811349a4:	e0bfff17 	ldw	r2,-4(fp)
811349a8:	10c0020d 	sth	r3,8(r2)
811349ac:	e0bffb17 	ldw	r2,-20(fp)
811349b0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811349b4:	e0bffc17 	ldw	r2,-16(fp)
811349b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
811349bc:	e0bffd0b 	ldhu	r2,-12(fp)
}
811349c0:	e037883a 	mov	sp,fp
811349c4:	df000017 	ldw	fp,0(sp)
811349c8:	dec00104 	addi	sp,sp,4
811349cc:	f800283a 	ret

811349d0 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
811349d0:	defff904 	addi	sp,sp,-28
811349d4:	de00012e 	bgeu	sp,et,811349dc <OSSemCreate+0xc>
811349d8:	003b68fa 	trap	3
811349dc:	dfc00615 	stw	ra,24(sp)
811349e0:	df000515 	stw	fp,20(sp)
811349e4:	df000504 	addi	fp,sp,20
811349e8:	2005883a 	mov	r2,r4
811349ec:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811349f0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811349f4:	d0a09203 	ldbu	r2,-32184(gp)
811349f8:	10803fcc 	andi	r2,r2,255
811349fc:	10000226 	beq	r2,zero,81134a08 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
81134a00:	0005883a 	mov	r2,zero
81134a04:	00002506 	br	81134a9c <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134a08:	0005303a 	rdctl	r2,status
81134a0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134a10:	e0fffe17 	ldw	r3,-8(fp)
81134a14:	00bfff84 	movi	r2,-2
81134a18:	1884703a 	and	r2,r3,r2
81134a1c:	1001703a 	wrctl	status,r2
  
  return context;
81134a20:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81134a24:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
81134a28:	d0a09117 	ldw	r2,-32188(gp)
81134a2c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
81134a30:	d0a09117 	ldw	r2,-32188(gp)
81134a34:	10000326 	beq	r2,zero,81134a44 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
81134a38:	d0a09117 	ldw	r2,-32188(gp)
81134a3c:	10800117 	ldw	r2,4(r2)
81134a40:	d0a09115 	stw	r2,-32188(gp)
81134a44:	e0bffb17 	ldw	r2,-20(fp)
81134a48:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134a4c:	e0bffc17 	ldw	r2,-16(fp)
81134a50:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
81134a54:	e0bffd17 	ldw	r2,-12(fp)
81134a58:	10000f26 	beq	r2,zero,81134a98 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
81134a5c:	e0bffd17 	ldw	r2,-12(fp)
81134a60:	00c000c4 	movi	r3,3
81134a64:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
81134a68:	e0bffd17 	ldw	r2,-12(fp)
81134a6c:	e0ffff0b 	ldhu	r3,-4(fp)
81134a70:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
81134a74:	e0bffd17 	ldw	r2,-12(fp)
81134a78:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
81134a7c:	e0bffd17 	ldw	r2,-12(fp)
81134a80:	00c00fc4 	movi	r3,63
81134a84:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
81134a88:	e0bffd17 	ldw	r2,-12(fp)
81134a8c:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
81134a90:	e13ffd17 	ldw	r4,-12(fp)
81134a94:	112f9640 	call	8112f964 <OS_EventWaitListInit>
    }
    return (pevent);
81134a98:	e0bffd17 	ldw	r2,-12(fp)
}
81134a9c:	e037883a 	mov	sp,fp
81134aa0:	dfc00117 	ldw	ra,4(sp)
81134aa4:	df000017 	ldw	fp,0(sp)
81134aa8:	dec00204 	addi	sp,sp,8
81134aac:	f800283a 	ret

81134ab0 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81134ab0:	defff304 	addi	sp,sp,-52
81134ab4:	de00012e 	bgeu	sp,et,81134abc <OSSemDel+0xc>
81134ab8:	003b68fa 	trap	3
81134abc:	dfc00c15 	stw	ra,48(sp)
81134ac0:	df000b15 	stw	fp,44(sp)
81134ac4:	df000b04 	addi	fp,sp,44
81134ac8:	e13ffd15 	stw	r4,-12(fp)
81134acc:	2805883a 	mov	r2,r5
81134ad0:	e1bfff15 	stw	r6,-4(fp)
81134ad4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81134ad8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81134adc:	e0bfff17 	ldw	r2,-4(fp)
81134ae0:	1000021e 	bne	r2,zero,81134aec <OSSemDel+0x3c>
        return (pevent);
81134ae4:	e0bffd17 	ldw	r2,-12(fp)
81134ae8:	00007e06 	br	81134ce4 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81134aec:	e0bffd17 	ldw	r2,-12(fp)
81134af0:	1000051e 	bne	r2,zero,81134b08 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81134af4:	e0bfff17 	ldw	r2,-4(fp)
81134af8:	00c00104 	movi	r3,4
81134afc:	10c00005 	stb	r3,0(r2)
        return (pevent);
81134b00:	e0bffd17 	ldw	r2,-12(fp)
81134b04:	00007706 	br	81134ce4 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81134b08:	e0bffd17 	ldw	r2,-12(fp)
81134b0c:	10800003 	ldbu	r2,0(r2)
81134b10:	10803fcc 	andi	r2,r2,255
81134b14:	108000e0 	cmpeqi	r2,r2,3
81134b18:	1000051e 	bne	r2,zero,81134b30 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81134b1c:	e0bfff17 	ldw	r2,-4(fp)
81134b20:	00c00044 	movi	r3,1
81134b24:	10c00005 	stb	r3,0(r2)
        return (pevent);
81134b28:	e0bffd17 	ldw	r2,-12(fp)
81134b2c:	00006d06 	br	81134ce4 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81134b30:	d0a09203 	ldbu	r2,-32184(gp)
81134b34:	10803fcc 	andi	r2,r2,255
81134b38:	10000526 	beq	r2,zero,81134b50 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
81134b3c:	e0bfff17 	ldw	r2,-4(fp)
81134b40:	00c003c4 	movi	r3,15
81134b44:	10c00005 	stb	r3,0(r2)
        return (pevent);
81134b48:	e0bffd17 	ldw	r2,-12(fp)
81134b4c:	00006506 	br	81134ce4 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134b50:	0005303a 	rdctl	r2,status
81134b54:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134b58:	e0fffc17 	ldw	r3,-16(fp)
81134b5c:	00bfff84 	movi	r2,-2
81134b60:	1884703a 	and	r2,r3,r2
81134b64:	1001703a 	wrctl	status,r2
  
  return context;
81134b68:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134b6c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
81134b70:	e0bffd17 	ldw	r2,-12(fp)
81134b74:	10800283 	ldbu	r2,10(r2)
81134b78:	10803fcc 	andi	r2,r2,255
81134b7c:	10000326 	beq	r2,zero,81134b8c <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81134b80:	00800044 	movi	r2,1
81134b84:	e0bff505 	stb	r2,-44(fp)
81134b88:	00000106 	br	81134b90 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81134b8c:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
81134b90:	e0bffe03 	ldbu	r2,-8(fp)
81134b94:	10000326 	beq	r2,zero,81134ba4 <OSSemDel+0xf4>
81134b98:	10800060 	cmpeqi	r2,r2,1
81134b9c:	1000281e 	bne	r2,zero,81134c40 <OSSemDel+0x190>
81134ba0:	00004506 	br	81134cb8 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
81134ba4:	e0bff503 	ldbu	r2,-44(fp)
81134ba8:	1000161e 	bne	r2,zero,81134c04 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81134bac:	e0bffd17 	ldw	r2,-12(fp)
81134bb0:	00c00fc4 	movi	r3,63
81134bb4:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81134bb8:	e0bffd17 	ldw	r2,-12(fp)
81134bbc:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81134bc0:	e0bffd17 	ldw	r2,-12(fp)
81134bc4:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81134bc8:	d0e09117 	ldw	r3,-32188(gp)
81134bcc:	e0bffd17 	ldw	r2,-12(fp)
81134bd0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81134bd4:	e0bffd17 	ldw	r2,-12(fp)
81134bd8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81134bdc:	e0bffd17 	ldw	r2,-12(fp)
81134be0:	d0a09115 	stw	r2,-32188(gp)
81134be4:	e0bff717 	ldw	r2,-36(fp)
81134be8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134bec:	e0bff817 	ldw	r2,-32(fp)
81134bf0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81134bf4:	e0bfff17 	ldw	r2,-4(fp)
81134bf8:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
81134bfc:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81134c00:	00003706 	br	81134ce0 <OSSemDel+0x230>
81134c04:	e0bff717 	ldw	r2,-36(fp)
81134c08:	e0bff915 	stw	r2,-28(fp)
81134c0c:	e0bff917 	ldw	r2,-28(fp)
81134c10:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81134c14:	e0bfff17 	ldw	r2,-4(fp)
81134c18:	00c01244 	movi	r3,73
81134c1c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81134c20:	e0bffd17 	ldw	r2,-12(fp)
81134c24:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81134c28:	00002d06 	br	81134ce0 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81134c2c:	000f883a 	mov	r7,zero
81134c30:	01800044 	movi	r6,1
81134c34:	000b883a 	mov	r5,zero
81134c38:	e13ffd17 	ldw	r4,-12(fp)
81134c3c:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
81134c40:	e0bffd17 	ldw	r2,-12(fp)
81134c44:	10800283 	ldbu	r2,10(r2)
81134c48:	10803fcc 	andi	r2,r2,255
81134c4c:	103ff71e 	bne	r2,zero,81134c2c <__reset+0xfb114c2c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81134c50:	e0bffd17 	ldw	r2,-12(fp)
81134c54:	00c00fc4 	movi	r3,63
81134c58:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81134c5c:	e0bffd17 	ldw	r2,-12(fp)
81134c60:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81134c64:	e0bffd17 	ldw	r2,-12(fp)
81134c68:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
81134c6c:	d0e09117 	ldw	r3,-32188(gp)
81134c70:	e0bffd17 	ldw	r2,-12(fp)
81134c74:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81134c78:	e0bffd17 	ldw	r2,-12(fp)
81134c7c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81134c80:	e0bffd17 	ldw	r2,-12(fp)
81134c84:	d0a09115 	stw	r2,-32188(gp)
81134c88:	e0bff717 	ldw	r2,-36(fp)
81134c8c:	e0bffa15 	stw	r2,-24(fp)
81134c90:	e0bffa17 	ldw	r2,-24(fp)
81134c94:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81134c98:	e0bff503 	ldbu	r2,-44(fp)
81134c9c:	10800058 	cmpnei	r2,r2,1
81134ca0:	1000011e 	bne	r2,zero,81134ca8 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81134ca4:	112fe480 	call	8112fe48 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81134ca8:	e0bfff17 	ldw	r2,-4(fp)
81134cac:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
81134cb0:	e03ff615 	stw	zero,-40(fp)
             break;
81134cb4:	00000a06 	br	81134ce0 <OSSemDel+0x230>
81134cb8:	e0bff717 	ldw	r2,-36(fp)
81134cbc:	e0bffb15 	stw	r2,-20(fp)
81134cc0:	e0bffb17 	ldw	r2,-20(fp)
81134cc4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81134cc8:	e0bfff17 	ldw	r2,-4(fp)
81134ccc:	00c001c4 	movi	r3,7
81134cd0:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81134cd4:	e0bffd17 	ldw	r2,-12(fp)
81134cd8:	e0bff615 	stw	r2,-40(fp)
             break;
81134cdc:	0001883a 	nop
    }
    return (pevent_return);
81134ce0:	e0bff617 	ldw	r2,-40(fp)
}
81134ce4:	e037883a 	mov	sp,fp
81134ce8:	dfc00117 	ldw	ra,4(sp)
81134cec:	df000017 	ldw	fp,0(sp)
81134cf0:	dec00204 	addi	sp,sp,8
81134cf4:	f800283a 	ret

81134cf8 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81134cf8:	defff504 	addi	sp,sp,-44
81134cfc:	de00012e 	bgeu	sp,et,81134d04 <OSSemPend+0xc>
81134d00:	003b68fa 	trap	3
81134d04:	dfc00a15 	stw	ra,40(sp)
81134d08:	df000915 	stw	fp,36(sp)
81134d0c:	df000904 	addi	fp,sp,36
81134d10:	e13ffd15 	stw	r4,-12(fp)
81134d14:	2805883a 	mov	r2,r5
81134d18:	e1bfff15 	stw	r6,-4(fp)
81134d1c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81134d20:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81134d24:	e0bfff17 	ldw	r2,-4(fp)
81134d28:	10007226 	beq	r2,zero,81134ef4 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81134d2c:	e0bffd17 	ldw	r2,-12(fp)
81134d30:	1000041e 	bne	r2,zero,81134d44 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81134d34:	e0bfff17 	ldw	r2,-4(fp)
81134d38:	00c00104 	movi	r3,4
81134d3c:	10c00005 	stb	r3,0(r2)
        return;
81134d40:	00006d06 	br	81134ef8 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81134d44:	e0bffd17 	ldw	r2,-12(fp)
81134d48:	10800003 	ldbu	r2,0(r2)
81134d4c:	10803fcc 	andi	r2,r2,255
81134d50:	108000e0 	cmpeqi	r2,r2,3
81134d54:	1000041e 	bne	r2,zero,81134d68 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
81134d58:	e0bfff17 	ldw	r2,-4(fp)
81134d5c:	00c00044 	movi	r3,1
81134d60:	10c00005 	stb	r3,0(r2)
        return;
81134d64:	00006406 	br	81134ef8 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81134d68:	d0a09203 	ldbu	r2,-32184(gp)
81134d6c:	10803fcc 	andi	r2,r2,255
81134d70:	10000426 	beq	r2,zero,81134d84 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
81134d74:	e0bfff17 	ldw	r2,-4(fp)
81134d78:	00c00084 	movi	r3,2
81134d7c:	10c00005 	stb	r3,0(r2)
        return;
81134d80:	00005d06 	br	81134ef8 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
81134d84:	d0a08003 	ldbu	r2,-32256(gp)
81134d88:	10803fcc 	andi	r2,r2,255
81134d8c:	10000426 	beq	r2,zero,81134da0 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
81134d90:	e0bfff17 	ldw	r2,-4(fp)
81134d94:	00c00344 	movi	r3,13
81134d98:	10c00005 	stb	r3,0(r2)
        return;
81134d9c:	00005606 	br	81134ef8 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134da0:	0005303a 	rdctl	r2,status
81134da4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134da8:	e0fffc17 	ldw	r3,-16(fp)
81134dac:	00bfff84 	movi	r2,-2
81134db0:	1884703a 	and	r2,r3,r2
81134db4:	1001703a 	wrctl	status,r2
  
  return context;
81134db8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134dbc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
81134dc0:	e0bffd17 	ldw	r2,-12(fp)
81134dc4:	1080020b 	ldhu	r2,8(r2)
81134dc8:	10bfffcc 	andi	r2,r2,65535
81134dcc:	10000d26 	beq	r2,zero,81134e04 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
81134dd0:	e0bffd17 	ldw	r2,-12(fp)
81134dd4:	1080020b 	ldhu	r2,8(r2)
81134dd8:	10bfffc4 	addi	r2,r2,-1
81134ddc:	1007883a 	mov	r3,r2
81134de0:	e0bffd17 	ldw	r2,-12(fp)
81134de4:	10c0020d 	sth	r3,8(r2)
81134de8:	e0bff717 	ldw	r2,-36(fp)
81134dec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134df0:	e0bff817 	ldw	r2,-32(fp)
81134df4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81134df8:	e0bfff17 	ldw	r2,-4(fp)
81134dfc:	10000005 	stb	zero,0(r2)
        return;
81134e00:	00003d06 	br	81134ef8 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
81134e04:	d0a09317 	ldw	r2,-32180(gp)
81134e08:	d0e09317 	ldw	r3,-32180(gp)
81134e0c:	18c00c03 	ldbu	r3,48(r3)
81134e10:	18c00054 	ori	r3,r3,1
81134e14:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81134e18:	d0a09317 	ldw	r2,-32180(gp)
81134e1c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
81134e20:	d0a09317 	ldw	r2,-32180(gp)
81134e24:	e0fffe0b 	ldhu	r3,-8(fp)
81134e28:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81134e2c:	e13ffd17 	ldw	r4,-12(fp)
81134e30:	112f52c0 	call	8112f52c <OS_EventTaskWait>
81134e34:	e0bff717 	ldw	r2,-36(fp)
81134e38:	e0bffb15 	stw	r2,-20(fp)
81134e3c:	e0bffb17 	ldw	r2,-20(fp)
81134e40:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81134e44:	112fe480 	call	8112fe48 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134e48:	0005303a 	rdctl	r2,status
81134e4c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134e50:	e0fff917 	ldw	r3,-28(fp)
81134e54:	00bfff84 	movi	r2,-2
81134e58:	1884703a 	and	r2,r3,r2
81134e5c:	1001703a 	wrctl	status,r2
  
  return context;
81134e60:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81134e64:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81134e68:	d0a09317 	ldw	r2,-32180(gp)
81134e6c:	10800c43 	ldbu	r2,49(r2)
81134e70:	10803fcc 	andi	r2,r2,255
81134e74:	10000326 	beq	r2,zero,81134e84 <OSSemPend+0x18c>
81134e78:	108000a0 	cmpeqi	r2,r2,2
81134e7c:	1000041e 	bne	r2,zero,81134e90 <OSSemPend+0x198>
81134e80:	00000706 	br	81134ea0 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81134e84:	e0bfff17 	ldw	r2,-4(fp)
81134e88:	10000005 	stb	zero,0(r2)
             break;
81134e8c:	00000c06 	br	81134ec0 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81134e90:	e0bfff17 	ldw	r2,-4(fp)
81134e94:	00c00384 	movi	r3,14
81134e98:	10c00005 	stb	r3,0(r2)
             break;
81134e9c:	00000806 	br	81134ec0 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
81134ea0:	d0a09317 	ldw	r2,-32180(gp)
81134ea4:	e17ffd17 	ldw	r5,-12(fp)
81134ea8:	1009883a 	mov	r4,r2
81134eac:	112f79c0 	call	8112f79c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81134eb0:	e0bfff17 	ldw	r2,-4(fp)
81134eb4:	00c00284 	movi	r3,10
81134eb8:	10c00005 	stb	r3,0(r2)
             break;
81134ebc:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81134ec0:	d0a09317 	ldw	r2,-32180(gp)
81134ec4:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81134ec8:	d0a09317 	ldw	r2,-32180(gp)
81134ecc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81134ed0:	d0a09317 	ldw	r2,-32180(gp)
81134ed4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81134ed8:	d0a09317 	ldw	r2,-32180(gp)
81134edc:	10000815 	stw	zero,32(r2)
81134ee0:	e0bff717 	ldw	r2,-36(fp)
81134ee4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134ee8:	e0bffa17 	ldw	r2,-24(fp)
81134eec:	1001703a 	wrctl	status,r2
81134ef0:	00000106 	br	81134ef8 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81134ef4:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81134ef8:	e037883a 	mov	sp,fp
81134efc:	dfc00117 	ldw	ra,4(sp)
81134f00:	df000017 	ldw	fp,0(sp)
81134f04:	dec00204 	addi	sp,sp,8
81134f08:	f800283a 	ret

81134f0c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81134f0c:	defff604 	addi	sp,sp,-40
81134f10:	de00012e 	bgeu	sp,et,81134f18 <OSSemPendAbort+0xc>
81134f14:	003b68fa 	trap	3
81134f18:	dfc00915 	stw	ra,36(sp)
81134f1c:	df000815 	stw	fp,32(sp)
81134f20:	df000804 	addi	fp,sp,32
81134f24:	e13ffd15 	stw	r4,-12(fp)
81134f28:	2805883a 	mov	r2,r5
81134f2c:	e1bfff15 	stw	r6,-4(fp)
81134f30:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81134f34:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81134f38:	e0bfff17 	ldw	r2,-4(fp)
81134f3c:	1000021e 	bne	r2,zero,81134f48 <OSSemPendAbort+0x3c>
        return (0);
81134f40:	0005883a 	mov	r2,zero
81134f44:	00004906 	br	8113506c <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81134f48:	e0bffd17 	ldw	r2,-12(fp)
81134f4c:	1000051e 	bne	r2,zero,81134f64 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81134f50:	e0bfff17 	ldw	r2,-4(fp)
81134f54:	00c00104 	movi	r3,4
81134f58:	10c00005 	stb	r3,0(r2)
        return (0);
81134f5c:	0005883a 	mov	r2,zero
81134f60:	00004206 	br	8113506c <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81134f64:	e0bffd17 	ldw	r2,-12(fp)
81134f68:	10800003 	ldbu	r2,0(r2)
81134f6c:	10803fcc 	andi	r2,r2,255
81134f70:	108000e0 	cmpeqi	r2,r2,3
81134f74:	1000051e 	bne	r2,zero,81134f8c <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81134f78:	e0bfff17 	ldw	r2,-4(fp)
81134f7c:	00c00044 	movi	r3,1
81134f80:	10c00005 	stb	r3,0(r2)
        return (0);
81134f84:	0005883a 	mov	r2,zero
81134f88:	00003806 	br	8113506c <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134f8c:	0005303a 	rdctl	r2,status
81134f90:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134f94:	e0fffc17 	ldw	r3,-16(fp)
81134f98:	00bfff84 	movi	r2,-2
81134f9c:	1884703a 	and	r2,r3,r2
81134fa0:	1001703a 	wrctl	status,r2
  
  return context;
81134fa4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134fa8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
81134fac:	e0bffd17 	ldw	r2,-12(fp)
81134fb0:	10800283 	ldbu	r2,10(r2)
81134fb4:	10803fcc 	andi	r2,r2,255
81134fb8:	10002526 	beq	r2,zero,81135050 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
81134fbc:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81134fc0:	e0bffe03 	ldbu	r2,-8(fp)
81134fc4:	10800060 	cmpeqi	r2,r2,1
81134fc8:	10000e26 	beq	r2,zero,81135004 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81134fcc:	00000806 	br	81134ff0 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81134fd0:	01c00084 	movi	r7,2
81134fd4:	01800044 	movi	r6,1
81134fd8:	000b883a 	mov	r5,zero
81134fdc:	e13ffd17 	ldw	r4,-12(fp)
81134fe0:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
                     nbr_tasks++;
81134fe4:	e0bff803 	ldbu	r2,-32(fp)
81134fe8:	10800044 	addi	r2,r2,1
81134fec:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81134ff0:	e0bffd17 	ldw	r2,-12(fp)
81134ff4:	10800283 	ldbu	r2,10(r2)
81134ff8:	10803fcc 	andi	r2,r2,255
81134ffc:	103ff41e 	bne	r2,zero,81134fd0 <__reset+0xfb114fd0>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81135000:	00000906 	br	81135028 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81135004:	01c00084 	movi	r7,2
81135008:	01800044 	movi	r6,1
8113500c:	000b883a 	mov	r5,zero
81135010:	e13ffd17 	ldw	r4,-12(fp)
81135014:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
                 nbr_tasks++;
81135018:	e0bff803 	ldbu	r2,-32(fp)
8113501c:	10800044 	addi	r2,r2,1
81135020:	e0bff805 	stb	r2,-32(fp)
                 break;
81135024:	0001883a 	nop
81135028:	e0bff917 	ldw	r2,-28(fp)
8113502c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135030:	e0bffa17 	ldw	r2,-24(fp)
81135034:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81135038:	112fe480 	call	8112fe48 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113503c:	e0bfff17 	ldw	r2,-4(fp)
81135040:	00c00384 	movi	r3,14
81135044:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81135048:	e0bff803 	ldbu	r2,-32(fp)
8113504c:	00000706 	br	8113506c <OSSemPendAbort+0x160>
81135050:	e0bff917 	ldw	r2,-28(fp)
81135054:	e0bffb15 	stw	r2,-20(fp)
81135058:	e0bffb17 	ldw	r2,-20(fp)
8113505c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81135060:	e0bfff17 	ldw	r2,-4(fp)
81135064:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
81135068:	0005883a 	mov	r2,zero
}
8113506c:	e037883a 	mov	sp,fp
81135070:	dfc00117 	ldw	ra,4(sp)
81135074:	df000017 	ldw	fp,0(sp)
81135078:	dec00204 	addi	sp,sp,8
8113507c:	f800283a 	ret

81135080 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
81135080:	defff804 	addi	sp,sp,-32
81135084:	de00012e 	bgeu	sp,et,8113508c <OSSemPost+0xc>
81135088:	003b68fa 	trap	3
8113508c:	dfc00715 	stw	ra,28(sp)
81135090:	df000615 	stw	fp,24(sp)
81135094:	df000604 	addi	fp,sp,24
81135098:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113509c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811350a0:	e0bfff17 	ldw	r2,-4(fp)
811350a4:	1000021e 	bne	r2,zero,811350b0 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
811350a8:	00800104 	movi	r2,4
811350ac:	00003506 	br	81135184 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811350b0:	e0bfff17 	ldw	r2,-4(fp)
811350b4:	10800003 	ldbu	r2,0(r2)
811350b8:	10803fcc 	andi	r2,r2,255
811350bc:	108000e0 	cmpeqi	r2,r2,3
811350c0:	1000021e 	bne	r2,zero,811350cc <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
811350c4:	00800044 	movi	r2,1
811350c8:	00002e06 	br	81135184 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811350cc:	0005303a 	rdctl	r2,status
811350d0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811350d4:	e0fffe17 	ldw	r3,-8(fp)
811350d8:	00bfff84 	movi	r2,-2
811350dc:	1884703a 	and	r2,r3,r2
811350e0:	1001703a 	wrctl	status,r2
  
  return context;
811350e4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811350e8:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
811350ec:	e0bfff17 	ldw	r2,-4(fp)
811350f0:	10800283 	ldbu	r2,10(r2)
811350f4:	10803fcc 	andi	r2,r2,255
811350f8:	10000c26 	beq	r2,zero,8113512c <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
811350fc:	000f883a 	mov	r7,zero
81135100:	01800044 	movi	r6,1
81135104:	000b883a 	mov	r5,zero
81135108:	e13fff17 	ldw	r4,-4(fp)
8113510c:	112f38c0 	call	8112f38c <OS_EventTaskRdy>
81135110:	e0bffa17 	ldw	r2,-24(fp)
81135114:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135118:	e0bffb17 	ldw	r2,-20(fp)
8113511c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81135120:	112fe480 	call	8112fe48 <OS_Sched>
        return (OS_ERR_NONE);
81135124:	0005883a 	mov	r2,zero
81135128:	00001606 	br	81135184 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8113512c:	e0bfff17 	ldw	r2,-4(fp)
81135130:	1080020b 	ldhu	r2,8(r2)
81135134:	10ffffcc 	andi	r3,r2,65535
81135138:	00bfffd4 	movui	r2,65535
8113513c:	18800c26 	beq	r3,r2,81135170 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
81135140:	e0bfff17 	ldw	r2,-4(fp)
81135144:	1080020b 	ldhu	r2,8(r2)
81135148:	10800044 	addi	r2,r2,1
8113514c:	1007883a 	mov	r3,r2
81135150:	e0bfff17 	ldw	r2,-4(fp)
81135154:	10c0020d 	sth	r3,8(r2)
81135158:	e0bffa17 	ldw	r2,-24(fp)
8113515c:	e0bffc15 	stw	r2,-16(fp)
81135160:	e0bffc17 	ldw	r2,-16(fp)
81135164:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81135168:	0005883a 	mov	r2,zero
8113516c:	00000506 	br	81135184 <OSSemPost+0x104>
81135170:	e0bffa17 	ldw	r2,-24(fp)
81135174:	e0bffd15 	stw	r2,-12(fp)
81135178:	e0bffd17 	ldw	r2,-12(fp)
8113517c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
81135180:	00800c84 	movi	r2,50
}
81135184:	e037883a 	mov	sp,fp
81135188:	dfc00117 	ldw	ra,4(sp)
8113518c:	df000017 	ldw	fp,0(sp)
81135190:	dec00204 	addi	sp,sp,8
81135194:	f800283a 	ret

81135198 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
81135198:	defff704 	addi	sp,sp,-36
8113519c:	de00012e 	bgeu	sp,et,811351a4 <OSSemQuery+0xc>
811351a0:	003b68fa 	trap	3
811351a4:	df000815 	stw	fp,32(sp)
811351a8:	df000804 	addi	fp,sp,32
811351ac:	e13ffe15 	stw	r4,-8(fp)
811351b0:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811351b4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811351b8:	e0bffe17 	ldw	r2,-8(fp)
811351bc:	1000021e 	bne	r2,zero,811351c8 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
811351c0:	00800104 	movi	r2,4
811351c4:	00003606 	br	811352a0 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
811351c8:	e0bfff17 	ldw	r2,-4(fp)
811351cc:	1000021e 	bne	r2,zero,811351d8 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
811351d0:	00800244 	movi	r2,9
811351d4:	00003206 	br	811352a0 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
811351d8:	e0bffe17 	ldw	r2,-8(fp)
811351dc:	10800003 	ldbu	r2,0(r2)
811351e0:	10803fcc 	andi	r2,r2,255
811351e4:	108000e0 	cmpeqi	r2,r2,3
811351e8:	1000021e 	bne	r2,zero,811351f4 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
811351ec:	00800044 	movi	r2,1
811351f0:	00002b06 	br	811352a0 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811351f4:	0005303a 	rdctl	r2,status
811351f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811351fc:	e0fffd17 	ldw	r3,-12(fp)
81135200:	00bfff84 	movi	r2,-2
81135204:	1884703a 	and	r2,r3,r2
81135208:	1001703a 	wrctl	status,r2
  
  return context;
8113520c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81135210:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
81135214:	e0bffe17 	ldw	r2,-8(fp)
81135218:	10c00283 	ldbu	r3,10(r2)
8113521c:	e0bfff17 	ldw	r2,-4(fp)
81135220:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
81135224:	e0bffe17 	ldw	r2,-8(fp)
81135228:	108002c4 	addi	r2,r2,11
8113522c:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
81135230:	e0bfff17 	ldw	r2,-4(fp)
81135234:	10800084 	addi	r2,r2,2
81135238:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113523c:	e03ffa05 	stb	zero,-24(fp)
81135240:	00000b06 	br	81135270 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
81135244:	e0bff917 	ldw	r2,-28(fp)
81135248:	10c00044 	addi	r3,r2,1
8113524c:	e0fff915 	stw	r3,-28(fp)
81135250:	e0fff817 	ldw	r3,-32(fp)
81135254:	19000044 	addi	r4,r3,1
81135258:	e13ff815 	stw	r4,-32(fp)
8113525c:	18c00003 	ldbu	r3,0(r3)
81135260:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81135264:	e0bffa03 	ldbu	r2,-24(fp)
81135268:	10800044 	addi	r2,r2,1
8113526c:	e0bffa05 	stb	r2,-24(fp)
81135270:	e0bffa03 	ldbu	r2,-24(fp)
81135274:	108001b0 	cmpltui	r2,r2,6
81135278:	103ff21e 	bne	r2,zero,81135244 <__reset+0xfb115244>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113527c:	e0bffe17 	ldw	r2,-8(fp)
81135280:	10c0020b 	ldhu	r3,8(r2)
81135284:	e0bfff17 	ldw	r2,-4(fp)
81135288:	10c0000d 	sth	r3,0(r2)
8113528c:	e0bffb17 	ldw	r2,-20(fp)
81135290:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135294:	e0bffc17 	ldw	r2,-16(fp)
81135298:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113529c:	0005883a 	mov	r2,zero
}
811352a0:	e037883a 	mov	sp,fp
811352a4:	df000017 	ldw	fp,0(sp)
811352a8:	dec00104 	addi	sp,sp,4
811352ac:	f800283a 	ret

811352b0 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
811352b0:	defff904 	addi	sp,sp,-28
811352b4:	de00012e 	bgeu	sp,et,811352bc <OSSemSet+0xc>
811352b8:	003b68fa 	trap	3
811352bc:	df000615 	stw	fp,24(sp)
811352c0:	df000604 	addi	fp,sp,24
811352c4:	e13ffd15 	stw	r4,-12(fp)
811352c8:	2805883a 	mov	r2,r5
811352cc:	e1bfff15 	stw	r6,-4(fp)
811352d0:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811352d4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
811352d8:	e0bfff17 	ldw	r2,-4(fp)
811352dc:	10003126 	beq	r2,zero,811353a4 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811352e0:	e0bffd17 	ldw	r2,-12(fp)
811352e4:	1000041e 	bne	r2,zero,811352f8 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
811352e8:	e0bfff17 	ldw	r2,-4(fp)
811352ec:	00c00104 	movi	r3,4
811352f0:	10c00005 	stb	r3,0(r2)
        return;
811352f4:	00002c06 	br	811353a8 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811352f8:	e0bffd17 	ldw	r2,-12(fp)
811352fc:	10800003 	ldbu	r2,0(r2)
81135300:	10803fcc 	andi	r2,r2,255
81135304:	108000e0 	cmpeqi	r2,r2,3
81135308:	1000041e 	bne	r2,zero,8113531c <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113530c:	e0bfff17 	ldw	r2,-4(fp)
81135310:	00c00044 	movi	r3,1
81135314:	10c00005 	stb	r3,0(r2)
        return;
81135318:	00002306 	br	811353a8 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113531c:	0005303a 	rdctl	r2,status
81135320:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135324:	e0fffc17 	ldw	r3,-16(fp)
81135328:	00bfff84 	movi	r2,-2
8113532c:	1884703a 	and	r2,r3,r2
81135330:	1001703a 	wrctl	status,r2
  
  return context;
81135334:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81135338:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113533c:	e0bfff17 	ldw	r2,-4(fp)
81135340:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
81135344:	e0bffd17 	ldw	r2,-12(fp)
81135348:	1080020b 	ldhu	r2,8(r2)
8113534c:	10bfffcc 	andi	r2,r2,65535
81135350:	10000426 	beq	r2,zero,81135364 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
81135354:	e0bffd17 	ldw	r2,-12(fp)
81135358:	e0fffe0b 	ldhu	r3,-8(fp)
8113535c:	10c0020d 	sth	r3,8(r2)
81135360:	00000b06 	br	81135390 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
81135364:	e0bffd17 	ldw	r2,-12(fp)
81135368:	10800283 	ldbu	r2,10(r2)
8113536c:	10803fcc 	andi	r2,r2,255
81135370:	1000041e 	bne	r2,zero,81135384 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
81135374:	e0bffd17 	ldw	r2,-12(fp)
81135378:	e0fffe0b 	ldhu	r3,-8(fp)
8113537c:	10c0020d 	sth	r3,8(r2)
81135380:	00000306 	br	81135390 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
81135384:	e0bfff17 	ldw	r2,-4(fp)
81135388:	00c01244 	movi	r3,73
8113538c:	10c00005 	stb	r3,0(r2)
81135390:	e0bffa17 	ldw	r2,-24(fp)
81135394:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135398:	e0bffb17 	ldw	r2,-20(fp)
8113539c:	1001703a 	wrctl	status,r2
811353a0:	00000106 	br	811353a8 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
811353a4:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
811353a8:	e037883a 	mov	sp,fp
811353ac:	df000017 	ldw	fp,0(sp)
811353b0:	dec00104 	addi	sp,sp,4
811353b4:	f800283a 	ret

811353b8 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
811353b8:	defff104 	addi	sp,sp,-60
811353bc:	de00012e 	bgeu	sp,et,811353c4 <OSTaskChangePrio+0xc>
811353c0:	003b68fa 	trap	3
811353c4:	dfc00e15 	stw	ra,56(sp)
811353c8:	df000d15 	stw	fp,52(sp)
811353cc:	df000d04 	addi	fp,sp,52
811353d0:	2007883a 	mov	r3,r4
811353d4:	2805883a 	mov	r2,r5
811353d8:	e0fffe05 	stb	r3,-8(fp)
811353dc:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
811353e0:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
811353e4:	e0bffe03 	ldbu	r2,-8(fp)
811353e8:	10800a30 	cmpltui	r2,r2,40
811353ec:	1000051e 	bne	r2,zero,81135404 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
811353f0:	e0bffe03 	ldbu	r2,-8(fp)
811353f4:	10803fe0 	cmpeqi	r2,r2,255
811353f8:	1000021e 	bne	r2,zero,81135404 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
811353fc:	00800a84 	movi	r2,42
81135400:	00012606 	br	8113589c <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
81135404:	e0bfff03 	ldbu	r2,-4(fp)
81135408:	10800a30 	cmpltui	r2,r2,40
8113540c:	1000021e 	bne	r2,zero,81135418 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
81135410:	00800a84 	movi	r2,42
81135414:	00012106 	br	8113589c <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135418:	0005303a 	rdctl	r2,status
8113541c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135420:	e0fffd17 	ldw	r3,-12(fp)
81135424:	00bfff84 	movi	r2,-2
81135428:	1884703a 	and	r2,r3,r2
8113542c:	1001703a 	wrctl	status,r2
  
  return context;
81135430:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81135434:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
81135438:	e0ffff03 	ldbu	r3,-4(fp)
8113543c:	00a045b4 	movhi	r2,33046
81135440:	10882104 	addi	r2,r2,8324
81135444:	18c7883a 	add	r3,r3,r3
81135448:	18c7883a 	add	r3,r3,r3
8113544c:	10c5883a 	add	r2,r2,r3
81135450:	10800017 	ldw	r2,0(r2)
81135454:	10000626 	beq	r2,zero,81135470 <OSTaskChangePrio+0xb8>
81135458:	e0bff517 	ldw	r2,-44(fp)
8113545c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135460:	e0bff617 	ldw	r2,-40(fp)
81135464:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
81135468:	00800a04 	movi	r2,40
8113546c:	00010b06 	br	8113589c <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
81135470:	e0bffe03 	ldbu	r2,-8(fp)
81135474:	10803fd8 	cmpnei	r2,r2,255
81135478:	1000031e 	bne	r2,zero,81135488 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113547c:	d0a09317 	ldw	r2,-32180(gp)
81135480:	10800c83 	ldbu	r2,50(r2)
81135484:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
81135488:	e0fffe03 	ldbu	r3,-8(fp)
8113548c:	00a045b4 	movhi	r2,33046
81135490:	10882104 	addi	r2,r2,8324
81135494:	18c7883a 	add	r3,r3,r3
81135498:	18c7883a 	add	r3,r3,r3
8113549c:	10c5883a 	add	r2,r2,r3
811354a0:	10800017 	ldw	r2,0(r2)
811354a4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
811354a8:	e0bff817 	ldw	r2,-32(fp)
811354ac:	1000061e 	bne	r2,zero,811354c8 <OSTaskChangePrio+0x110>
811354b0:	e0bff517 	ldw	r2,-44(fp)
811354b4:	e0bff715 	stw	r2,-36(fp)
811354b8:	e0bff717 	ldw	r2,-36(fp)
811354bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
811354c0:	00800a44 	movi	r2,41
811354c4:	0000f506 	br	8113589c <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
811354c8:	e0bff817 	ldw	r2,-32(fp)
811354cc:	10800058 	cmpnei	r2,r2,1
811354d0:	1000061e 	bne	r2,zero,811354ec <OSTaskChangePrio+0x134>
811354d4:	e0bff517 	ldw	r2,-44(fp)
811354d8:	e0bff915 	stw	r2,-28(fp)
811354dc:	e0bff917 	ldw	r2,-28(fp)
811354e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
811354e4:	008010c4 	movi	r2,67
811354e8:	0000ec06 	br	8113589c <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
811354ec:	e0bfff03 	ldbu	r2,-4(fp)
811354f0:	1004d0fa 	srli	r2,r2,3
811354f4:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
811354f8:	e0bfff03 	ldbu	r2,-4(fp)
811354fc:	108001cc 	andi	r2,r2,7
81135500:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
81135504:	e0bffb03 	ldbu	r2,-20(fp)
81135508:	00c00044 	movi	r3,1
8113550c:	1884983a 	sll	r2,r3,r2
81135510:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
81135514:	e0bffb43 	ldbu	r2,-19(fp)
81135518:	00c00044 	movi	r3,1
8113551c:	1884983a 	sll	r2,r3,r2
81135520:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
81135524:	e0fffe03 	ldbu	r3,-8(fp)
81135528:	00a045b4 	movhi	r2,33046
8113552c:	10882104 	addi	r2,r2,8324
81135530:	18c7883a 	add	r3,r3,r3
81135534:	18c7883a 	add	r3,r3,r3
81135538:	10c5883a 	add	r2,r2,r3
8113553c:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
81135540:	e0ffff03 	ldbu	r3,-4(fp)
81135544:	00a045b4 	movhi	r2,33046
81135548:	10882104 	addi	r2,r2,8324
8113554c:	18c7883a 	add	r3,r3,r3
81135550:	18c7883a 	add	r3,r3,r3
81135554:	10c5883a 	add	r2,r2,r3
81135558:	e0fff817 	ldw	r3,-32(fp)
8113555c:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
81135560:	e0bff817 	ldw	r2,-32(fp)
81135564:	10800d03 	ldbu	r2,52(r2)
81135568:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113556c:	e0bff817 	ldw	r2,-32(fp)
81135570:	10800d83 	ldbu	r2,54(r2)
81135574:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
81135578:	e0bff817 	ldw	r2,-32(fp)
8113557c:	10800d43 	ldbu	r2,53(r2)
81135580:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
81135584:	e0fffc03 	ldbu	r3,-16(fp)
81135588:	d0a08f44 	addi	r2,gp,-32195
8113558c:	1885883a 	add	r2,r3,r2
81135590:	10c00003 	ldbu	r3,0(r2)
81135594:	e0bffc83 	ldbu	r2,-14(fp)
81135598:	1884703a 	and	r2,r3,r2
8113559c:	10803fcc 	andi	r2,r2,255
811355a0:	10002826 	beq	r2,zero,81135644 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
811355a4:	e0fffc03 	ldbu	r3,-16(fp)
811355a8:	e13ffc03 	ldbu	r4,-16(fp)
811355ac:	d0a08f44 	addi	r2,gp,-32195
811355b0:	2085883a 	add	r2,r4,r2
811355b4:	10800003 	ldbu	r2,0(r2)
811355b8:	1009883a 	mov	r4,r2
811355bc:	e0bffc83 	ldbu	r2,-14(fp)
811355c0:	0084303a 	nor	r2,zero,r2
811355c4:	2084703a 	and	r2,r4,r2
811355c8:	1009883a 	mov	r4,r2
811355cc:	d0a08f44 	addi	r2,gp,-32195
811355d0:	1885883a 	add	r2,r3,r2
811355d4:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
811355d8:	e0fffc03 	ldbu	r3,-16(fp)
811355dc:	d0a08f44 	addi	r2,gp,-32195
811355e0:	1885883a 	add	r2,r3,r2
811355e4:	10800003 	ldbu	r2,0(r2)
811355e8:	10803fcc 	andi	r2,r2,255
811355ec:	1000061e 	bne	r2,zero,81135608 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
811355f0:	e0bffc43 	ldbu	r2,-15(fp)
811355f4:	0084303a 	nor	r2,zero,r2
811355f8:	1007883a 	mov	r3,r2
811355fc:	d0a08f03 	ldbu	r2,-32196(gp)
81135600:	1884703a 	and	r2,r3,r2
81135604:	d0a08f05 	stb	r2,-32196(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
81135608:	d0e08f03 	ldbu	r3,-32196(gp)
8113560c:	e0bffb83 	ldbu	r2,-18(fp)
81135610:	1884b03a 	or	r2,r3,r2
81135614:	d0a08f05 	stb	r2,-32196(gp)
         OSRdyTbl[y_new] |= bitx_new;
81135618:	e0fffb03 	ldbu	r3,-20(fp)
8113561c:	e13ffb03 	ldbu	r4,-20(fp)
81135620:	d0a08f44 	addi	r2,gp,-32195
81135624:	2085883a 	add	r2,r4,r2
81135628:	11000003 	ldbu	r4,0(r2)
8113562c:	e0bffbc3 	ldbu	r2,-17(fp)
81135630:	2084b03a 	or	r2,r4,r2
81135634:	1009883a 	mov	r4,r2
81135638:	d0a08f44 	addi	r2,gp,-32195
8113563c:	1885883a 	add	r2,r3,r2
81135640:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
81135644:	e0bff817 	ldw	r2,-32(fp)
81135648:	10800717 	ldw	r2,28(r2)
8113564c:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
81135650:	e0bff317 	ldw	r2,-52(fp)
81135654:	10003326 	beq	r2,zero,81135724 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
81135658:	e0bffc03 	ldbu	r2,-16(fp)
8113565c:	e0fffc03 	ldbu	r3,-16(fp)
81135660:	e13ff317 	ldw	r4,-52(fp)
81135664:	20c7883a 	add	r3,r4,r3
81135668:	18c002c4 	addi	r3,r3,11
8113566c:	18c00003 	ldbu	r3,0(r3)
81135670:	1809883a 	mov	r4,r3
81135674:	e0fffc83 	ldbu	r3,-14(fp)
81135678:	00c6303a 	nor	r3,zero,r3
8113567c:	20c6703a 	and	r3,r4,r3
81135680:	1809883a 	mov	r4,r3
81135684:	e0fff317 	ldw	r3,-52(fp)
81135688:	1885883a 	add	r2,r3,r2
8113568c:	108002c4 	addi	r2,r2,11
81135690:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
81135694:	e0bffc03 	ldbu	r2,-16(fp)
81135698:	e0fff317 	ldw	r3,-52(fp)
8113569c:	1885883a 	add	r2,r3,r2
811356a0:	108002c4 	addi	r2,r2,11
811356a4:	10800003 	ldbu	r2,0(r2)
811356a8:	10803fcc 	andi	r2,r2,255
811356ac:	1000091e 	bne	r2,zero,811356d4 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
811356b0:	e0bff317 	ldw	r2,-52(fp)
811356b4:	10800283 	ldbu	r2,10(r2)
811356b8:	1007883a 	mov	r3,r2
811356bc:	e0bffc43 	ldbu	r2,-15(fp)
811356c0:	0084303a 	nor	r2,zero,r2
811356c4:	1884703a 	and	r2,r3,r2
811356c8:	1007883a 	mov	r3,r2
811356cc:	e0bff317 	ldw	r2,-52(fp)
811356d0:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
811356d4:	e0bff317 	ldw	r2,-52(fp)
811356d8:	10c00283 	ldbu	r3,10(r2)
811356dc:	e0bffb83 	ldbu	r2,-18(fp)
811356e0:	1884b03a 	or	r2,r3,r2
811356e4:	1007883a 	mov	r3,r2
811356e8:	e0bff317 	ldw	r2,-52(fp)
811356ec:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
811356f0:	e0bffb03 	ldbu	r2,-20(fp)
811356f4:	e0fffb03 	ldbu	r3,-20(fp)
811356f8:	e13ff317 	ldw	r4,-52(fp)
811356fc:	20c7883a 	add	r3,r4,r3
81135700:	18c002c4 	addi	r3,r3,11
81135704:	19000003 	ldbu	r4,0(r3)
81135708:	e0fffbc3 	ldbu	r3,-17(fp)
8113570c:	20c6b03a 	or	r3,r4,r3
81135710:	1809883a 	mov	r4,r3
81135714:	e0fff317 	ldw	r3,-52(fp)
81135718:	1885883a 	add	r2,r3,r2
8113571c:	108002c4 	addi	r2,r2,11
81135720:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
81135724:	e0bff817 	ldw	r2,-32(fp)
81135728:	10800817 	ldw	r2,32(r2)
8113572c:	10004226 	beq	r2,zero,81135838 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
81135730:	e0bff817 	ldw	r2,-32(fp)
81135734:	10800817 	ldw	r2,32(r2)
81135738:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113573c:	e0bff417 	ldw	r2,-48(fp)
81135740:	10800017 	ldw	r2,0(r2)
81135744:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
81135748:	00003906 	br	81135830 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113574c:	e0bffc03 	ldbu	r2,-16(fp)
81135750:	e0fffc03 	ldbu	r3,-16(fp)
81135754:	e13ff317 	ldw	r4,-52(fp)
81135758:	20c7883a 	add	r3,r4,r3
8113575c:	18c002c4 	addi	r3,r3,11
81135760:	18c00003 	ldbu	r3,0(r3)
81135764:	1809883a 	mov	r4,r3
81135768:	e0fffc83 	ldbu	r3,-14(fp)
8113576c:	00c6303a 	nor	r3,zero,r3
81135770:	20c6703a 	and	r3,r4,r3
81135774:	1809883a 	mov	r4,r3
81135778:	e0fff317 	ldw	r3,-52(fp)
8113577c:	1885883a 	add	r2,r3,r2
81135780:	108002c4 	addi	r2,r2,11
81135784:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
81135788:	e0bffc03 	ldbu	r2,-16(fp)
8113578c:	e0fff317 	ldw	r3,-52(fp)
81135790:	1885883a 	add	r2,r3,r2
81135794:	108002c4 	addi	r2,r2,11
81135798:	10800003 	ldbu	r2,0(r2)
8113579c:	10803fcc 	andi	r2,r2,255
811357a0:	1000091e 	bne	r2,zero,811357c8 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
811357a4:	e0bff317 	ldw	r2,-52(fp)
811357a8:	10800283 	ldbu	r2,10(r2)
811357ac:	1007883a 	mov	r3,r2
811357b0:	e0bffc43 	ldbu	r2,-15(fp)
811357b4:	0084303a 	nor	r2,zero,r2
811357b8:	1884703a 	and	r2,r3,r2
811357bc:	1007883a 	mov	r3,r2
811357c0:	e0bff317 	ldw	r2,-52(fp)
811357c4:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
811357c8:	e0bff317 	ldw	r2,-52(fp)
811357cc:	10c00283 	ldbu	r3,10(r2)
811357d0:	e0bffb83 	ldbu	r2,-18(fp)
811357d4:	1884b03a 	or	r2,r3,r2
811357d8:	1007883a 	mov	r3,r2
811357dc:	e0bff317 	ldw	r2,-52(fp)
811357e0:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
811357e4:	e0bffb03 	ldbu	r2,-20(fp)
811357e8:	e0fffb03 	ldbu	r3,-20(fp)
811357ec:	e13ff317 	ldw	r4,-52(fp)
811357f0:	20c7883a 	add	r3,r4,r3
811357f4:	18c002c4 	addi	r3,r3,11
811357f8:	19000003 	ldbu	r4,0(r3)
811357fc:	e0fffbc3 	ldbu	r3,-17(fp)
81135800:	20c6b03a 	or	r3,r4,r3
81135804:	1809883a 	mov	r4,r3
81135808:	e0fff317 	ldw	r3,-52(fp)
8113580c:	1885883a 	add	r2,r3,r2
81135810:	108002c4 	addi	r2,r2,11
81135814:	11000005 	stb	r4,0(r2)
            pevents++;
81135818:	e0bff417 	ldw	r2,-48(fp)
8113581c:	10800104 	addi	r2,r2,4
81135820:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
81135824:	e0bff417 	ldw	r2,-48(fp)
81135828:	10800017 	ldw	r2,0(r2)
8113582c:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
81135830:	e0bff317 	ldw	r2,-52(fp)
81135834:	103fc51e 	bne	r2,zero,8113574c <__reset+0xfb11574c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
81135838:	e0bff817 	ldw	r2,-32(fp)
8113583c:	e0ffff03 	ldbu	r3,-4(fp)
81135840:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
81135844:	e0bff817 	ldw	r2,-32(fp)
81135848:	e0fffb03 	ldbu	r3,-20(fp)
8113584c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
81135850:	e0bff817 	ldw	r2,-32(fp)
81135854:	e0fffb43 	ldbu	r3,-19(fp)
81135858:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113585c:	e0bff817 	ldw	r2,-32(fp)
81135860:	e0fffb83 	ldbu	r3,-18(fp)
81135864:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
81135868:	e0bff817 	ldw	r2,-32(fp)
8113586c:	e0fffbc3 	ldbu	r3,-17(fp)
81135870:	10c00d45 	stb	r3,53(r2)
81135874:	e0bff517 	ldw	r2,-44(fp)
81135878:	e0bffa15 	stw	r2,-24(fp)
8113587c:	e0bffa17 	ldw	r2,-24(fp)
81135880:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81135884:	d0a08203 	ldbu	r2,-32248(gp)
81135888:	10803fcc 	andi	r2,r2,255
8113588c:	10800058 	cmpnei	r2,r2,1
81135890:	1000011e 	bne	r2,zero,81135898 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
81135894:	112fe480 	call	8112fe48 <OS_Sched>
    }
    return (OS_ERR_NONE);
81135898:	0005883a 	mov	r2,zero
}
8113589c:	e037883a 	mov	sp,fp
811358a0:	dfc00117 	ldw	ra,4(sp)
811358a4:	df000017 	ldw	fp,0(sp)
811358a8:	dec00204 	addi	sp,sp,8
811358ac:	f800283a 	ret

811358b0 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
811358b0:	deffec04 	addi	sp,sp,-80
811358b4:	de00012e 	bgeu	sp,et,811358bc <OSTaskCreateExt+0xc>
811358b8:	003b68fa 	trap	3
811358bc:	dfc01315 	stw	ra,76(sp)
811358c0:	df001215 	stw	fp,72(sp)
811358c4:	df001204 	addi	fp,sp,72
811358c8:	e13ffa15 	stw	r4,-24(fp)
811358cc:	e17ffb15 	stw	r5,-20(fp)
811358d0:	e1bffc15 	stw	r6,-16(fp)
811358d4:	3809883a 	mov	r4,r7
811358d8:	e0c00217 	ldw	r3,8(fp)
811358dc:	e0800617 	ldw	r2,24(fp)
811358e0:	e13ffd05 	stb	r4,-12(fp)
811358e4:	e0fffe0d 	sth	r3,-8(fp)
811358e8:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
811358ec:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
811358f0:	e0bffd03 	ldbu	r2,-12(fp)
811358f4:	10800a70 	cmpltui	r2,r2,41
811358f8:	1000021e 	bne	r2,zero,81135904 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
811358fc:	00800a84 	movi	r2,42
81135900:	00006106 	br	81135a88 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135904:	0005303a 	rdctl	r2,status
81135908:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113590c:	e0fff917 	ldw	r3,-28(fp)
81135910:	00bfff84 	movi	r2,-2
81135914:	1884703a 	and	r2,r3,r2
81135918:	1001703a 	wrctl	status,r2
  
  return context;
8113591c:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81135920:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81135924:	d0a09203 	ldbu	r2,-32184(gp)
81135928:	10803fcc 	andi	r2,r2,255
8113592c:	10000626 	beq	r2,zero,81135948 <OSTaskCreateExt+0x98>
81135930:	e0bff117 	ldw	r2,-60(fp)
81135934:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135938:	e0bff217 	ldw	r2,-56(fp)
8113593c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81135940:	00800f04 	movi	r2,60
81135944:	00005006 	br	81135a88 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
81135948:	e0fffd03 	ldbu	r3,-12(fp)
8113594c:	00a045b4 	movhi	r2,33046
81135950:	10882104 	addi	r2,r2,8324
81135954:	18c7883a 	add	r3,r3,r3
81135958:	18c7883a 	add	r3,r3,r3
8113595c:	10c5883a 	add	r2,r2,r3
81135960:	10800017 	ldw	r2,0(r2)
81135964:	1000431e 	bne	r2,zero,81135a74 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
81135968:	e0fffd03 	ldbu	r3,-12(fp)
8113596c:	00a045b4 	movhi	r2,33046
81135970:	10882104 	addi	r2,r2,8324
81135974:	18c7883a 	add	r3,r3,r3
81135978:	18c7883a 	add	r3,r3,r3
8113597c:	10c5883a 	add	r2,r2,r3
81135980:	00c00044 	movi	r3,1
81135984:	10c00015 	stw	r3,0(r2)
81135988:	e0bff117 	ldw	r2,-60(fp)
8113598c:	e0bff315 	stw	r2,-52(fp)
81135990:	e0bff317 	ldw	r2,-52(fp)
81135994:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
81135998:	e0bfff0b 	ldhu	r2,-4(fp)
8113599c:	100d883a 	mov	r6,r2
811359a0:	e1400417 	ldw	r5,16(fp)
811359a4:	e1000317 	ldw	r4,12(fp)
811359a8:	11369580 	call	81136958 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
811359ac:	e0bfff0b 	ldhu	r2,-4(fp)
811359b0:	100f883a 	mov	r7,r2
811359b4:	e1bffc17 	ldw	r6,-16(fp)
811359b8:	e17ffb17 	ldw	r5,-20(fp)
811359bc:	e13ffa17 	ldw	r4,-24(fp)
811359c0:	1140da40 	call	81140da4 <OSTaskStkInit>
811359c4:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
811359c8:	e0fffd03 	ldbu	r3,-12(fp)
811359cc:	e13ffe0b 	ldhu	r4,-8(fp)
811359d0:	e0bfff0b 	ldhu	r2,-4(fp)
811359d4:	d8800215 	stw	r2,8(sp)
811359d8:	e0800517 	ldw	r2,20(fp)
811359dc:	d8800115 	stw	r2,4(sp)
811359e0:	e0800417 	ldw	r2,16(fp)
811359e4:	d8800015 	stw	r2,0(sp)
811359e8:	200f883a 	mov	r7,r4
811359ec:	e1800317 	ldw	r6,12(fp)
811359f0:	e17ff517 	ldw	r5,-44(fp)
811359f4:	1809883a 	mov	r4,r3
811359f8:	11302900 	call	81130290 <OS_TCBInit>
811359fc:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
81135a00:	e0bff603 	ldbu	r2,-40(fp)
81135a04:	1000061e 	bne	r2,zero,81135a20 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
81135a08:	d0a08203 	ldbu	r2,-32248(gp)
81135a0c:	10803fcc 	andi	r2,r2,255
81135a10:	10800058 	cmpnei	r2,r2,1
81135a14:	1000151e 	bne	r2,zero,81135a6c <OSTaskCreateExt+0x1bc>
                OS_Sched();
81135a18:	112fe480 	call	8112fe48 <OS_Sched>
81135a1c:	00001306 	br	81135a6c <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135a20:	0005303a 	rdctl	r2,status
81135a24:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135a28:	e0fff817 	ldw	r3,-32(fp)
81135a2c:	00bfff84 	movi	r2,-2
81135a30:	1884703a 	and	r2,r3,r2
81135a34:	1001703a 	wrctl	status,r2
  
  return context;
81135a38:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81135a3c:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
81135a40:	e0fffd03 	ldbu	r3,-12(fp)
81135a44:	00a045b4 	movhi	r2,33046
81135a48:	10882104 	addi	r2,r2,8324
81135a4c:	18c7883a 	add	r3,r3,r3
81135a50:	18c7883a 	add	r3,r3,r3
81135a54:	10c5883a 	add	r2,r2,r3
81135a58:	10000015 	stw	zero,0(r2)
81135a5c:	e0bff117 	ldw	r2,-60(fp)
81135a60:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135a64:	e0bff417 	ldw	r2,-48(fp)
81135a68:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
81135a6c:	e0bff603 	ldbu	r2,-40(fp)
81135a70:	00000506 	br	81135a88 <OSTaskCreateExt+0x1d8>
81135a74:	e0bff117 	ldw	r2,-60(fp)
81135a78:	e0bff715 	stw	r2,-36(fp)
81135a7c:	e0bff717 	ldw	r2,-36(fp)
81135a80:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
81135a84:	00800a04 	movi	r2,40
}
81135a88:	e037883a 	mov	sp,fp
81135a8c:	dfc00117 	ldw	ra,4(sp)
81135a90:	df000017 	ldw	fp,0(sp)
81135a94:	dec00204 	addi	sp,sp,8
81135a98:	f800283a 	ret

81135a9c <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
81135a9c:	defff404 	addi	sp,sp,-48
81135aa0:	de00012e 	bgeu	sp,et,81135aa8 <OSTaskDel+0xc>
81135aa4:	003b68fa 	trap	3
81135aa8:	dfc00b15 	stw	ra,44(sp)
81135aac:	df000a15 	stw	fp,40(sp)
81135ab0:	df000a04 	addi	fp,sp,40
81135ab4:	2005883a 	mov	r2,r4
81135ab8:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
81135abc:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
81135ac0:	d0a09203 	ldbu	r2,-32184(gp)
81135ac4:	10803fcc 	andi	r2,r2,255
81135ac8:	10000226 	beq	r2,zero,81135ad4 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
81135acc:	00801004 	movi	r2,64
81135ad0:	0000c006 	br	81135dd4 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
81135ad4:	e0bfff03 	ldbu	r2,-4(fp)
81135ad8:	10800a18 	cmpnei	r2,r2,40
81135adc:	1000021e 	bne	r2,zero,81135ae8 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
81135ae0:	00800f84 	movi	r2,62
81135ae4:	0000bb06 	br	81135dd4 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
81135ae8:	e0bfff03 	ldbu	r2,-4(fp)
81135aec:	10800a30 	cmpltui	r2,r2,40
81135af0:	1000051e 	bne	r2,zero,81135b08 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
81135af4:	e0bfff03 	ldbu	r2,-4(fp)
81135af8:	10803fe0 	cmpeqi	r2,r2,255
81135afc:	1000021e 	bne	r2,zero,81135b08 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
81135b00:	00800a84 	movi	r2,42
81135b04:	0000b306 	br	81135dd4 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135b08:	0005303a 	rdctl	r2,status
81135b0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135b10:	e0fffe17 	ldw	r3,-8(fp)
81135b14:	00bfff84 	movi	r2,-2
81135b18:	1884703a 	and	r2,r3,r2
81135b1c:	1001703a 	wrctl	status,r2
  
  return context;
81135b20:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
81135b24:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
81135b28:	e0bfff03 	ldbu	r2,-4(fp)
81135b2c:	10803fd8 	cmpnei	r2,r2,255
81135b30:	1000031e 	bne	r2,zero,81135b40 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
81135b34:	d0a09317 	ldw	r2,-32180(gp)
81135b38:	10800c83 	ldbu	r2,50(r2)
81135b3c:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81135b40:	e0ffff03 	ldbu	r3,-4(fp)
81135b44:	00a045b4 	movhi	r2,33046
81135b48:	10882104 	addi	r2,r2,8324
81135b4c:	18c7883a 	add	r3,r3,r3
81135b50:	18c7883a 	add	r3,r3,r3
81135b54:	10c5883a 	add	r2,r2,r3
81135b58:	10800017 	ldw	r2,0(r2)
81135b5c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
81135b60:	e0bff817 	ldw	r2,-32(fp)
81135b64:	1000061e 	bne	r2,zero,81135b80 <OSTaskDel+0xe4>
81135b68:	e0bff617 	ldw	r2,-40(fp)
81135b6c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135b70:	e0bff717 	ldw	r2,-36(fp)
81135b74:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81135b78:	008010c4 	movi	r2,67
81135b7c:	00009506 	br	81135dd4 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
81135b80:	e0bff817 	ldw	r2,-32(fp)
81135b84:	10800058 	cmpnei	r2,r2,1
81135b88:	1000061e 	bne	r2,zero,81135ba4 <OSTaskDel+0x108>
81135b8c:	e0bff617 	ldw	r2,-40(fp)
81135b90:	e0bff915 	stw	r2,-28(fp)
81135b94:	e0bff917 	ldw	r2,-28(fp)
81135b98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81135b9c:	00800f44 	movi	r2,61
81135ba0:	00008c06 	br	81135dd4 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
81135ba4:	e0bff817 	ldw	r2,-32(fp)
81135ba8:	10800d03 	ldbu	r2,52(r2)
81135bac:	10c03fcc 	andi	r3,r2,255
81135bb0:	e0bff817 	ldw	r2,-32(fp)
81135bb4:	10800d03 	ldbu	r2,52(r2)
81135bb8:	11003fcc 	andi	r4,r2,255
81135bbc:	d0a08f44 	addi	r2,gp,-32195
81135bc0:	2085883a 	add	r2,r4,r2
81135bc4:	10800003 	ldbu	r2,0(r2)
81135bc8:	1009883a 	mov	r4,r2
81135bcc:	e0bff817 	ldw	r2,-32(fp)
81135bd0:	10800d43 	ldbu	r2,53(r2)
81135bd4:	0084303a 	nor	r2,zero,r2
81135bd8:	2084703a 	and	r2,r4,r2
81135bdc:	1009883a 	mov	r4,r2
81135be0:	d0a08f44 	addi	r2,gp,-32195
81135be4:	1885883a 	add	r2,r3,r2
81135be8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
81135bec:	e0bff817 	ldw	r2,-32(fp)
81135bf0:	10800d03 	ldbu	r2,52(r2)
81135bf4:	10c03fcc 	andi	r3,r2,255
81135bf8:	d0a08f44 	addi	r2,gp,-32195
81135bfc:	1885883a 	add	r2,r3,r2
81135c00:	10800003 	ldbu	r2,0(r2)
81135c04:	10803fcc 	andi	r2,r2,255
81135c08:	1000071e 	bne	r2,zero,81135c28 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
81135c0c:	e0bff817 	ldw	r2,-32(fp)
81135c10:	10800d83 	ldbu	r2,54(r2)
81135c14:	0084303a 	nor	r2,zero,r2
81135c18:	1007883a 	mov	r3,r2
81135c1c:	d0a08f03 	ldbu	r2,-32196(gp)
81135c20:	1884703a 	and	r2,r3,r2
81135c24:	d0a08f05 	stb	r2,-32196(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
81135c28:	e0bff817 	ldw	r2,-32(fp)
81135c2c:	10800717 	ldw	r2,28(r2)
81135c30:	10000526 	beq	r2,zero,81135c48 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
81135c34:	e0bff817 	ldw	r2,-32(fp)
81135c38:	10800717 	ldw	r2,28(r2)
81135c3c:	100b883a 	mov	r5,r2
81135c40:	e13ff817 	ldw	r4,-32(fp)
81135c44:	112f79c0 	call	8112f79c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
81135c48:	e0bff817 	ldw	r2,-32(fp)
81135c4c:	10800817 	ldw	r2,32(r2)
81135c50:	10000526 	beq	r2,zero,81135c68 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81135c54:	e0bff817 	ldw	r2,-32(fp)
81135c58:	10800817 	ldw	r2,32(r2)
81135c5c:	100b883a 	mov	r5,r2
81135c60:	e13ff817 	ldw	r4,-32(fp)
81135c64:	112f85c0 	call	8112f85c <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
81135c68:	e0bff817 	ldw	r2,-32(fp)
81135c6c:	10800a17 	ldw	r2,40(r2)
81135c70:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
81135c74:	e0bffb17 	ldw	r2,-20(fp)
81135c78:	10000226 	beq	r2,zero,81135c84 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
81135c7c:	e13ffb17 	ldw	r4,-20(fp)
81135c80:	1131e340 	call	81131e34 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
81135c84:	e0bff817 	ldw	r2,-32(fp)
81135c88:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
81135c8c:	e0bff817 	ldw	r2,-32(fp)
81135c90:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81135c94:	e0bff817 	ldw	r2,-32(fp)
81135c98:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
81135c9c:	d0a08003 	ldbu	r2,-32256(gp)
81135ca0:	10803fcc 	andi	r2,r2,255
81135ca4:	10803fe0 	cmpeqi	r2,r2,255
81135ca8:	1000031e 	bne	r2,zero,81135cb8 <OSTaskDel+0x21c>
        OSLockNesting++;
81135cac:	d0a08003 	ldbu	r2,-32256(gp)
81135cb0:	10800044 	addi	r2,r2,1
81135cb4:	d0a08005 	stb	r2,-32256(gp)
81135cb8:	e0bff617 	ldw	r2,-40(fp)
81135cbc:	e0bffd15 	stw	r2,-12(fp)
81135cc0:	e0bffd17 	ldw	r2,-12(fp)
81135cc4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
81135cc8:	112f3640 	call	8112f364 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135ccc:	0005303a 	rdctl	r2,status
81135cd0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135cd4:	e0fffa17 	ldw	r3,-24(fp)
81135cd8:	00bfff84 	movi	r2,-2
81135cdc:	1884703a 	and	r2,r3,r2
81135ce0:	1001703a 	wrctl	status,r2
  
  return context;
81135ce4:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
81135ce8:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
81135cec:	d0a08003 	ldbu	r2,-32256(gp)
81135cf0:	10803fcc 	andi	r2,r2,255
81135cf4:	10000326 	beq	r2,zero,81135d04 <OSTaskDel+0x268>
        OSLockNesting--;
81135cf8:	d0a08003 	ldbu	r2,-32256(gp)
81135cfc:	10bfffc4 	addi	r2,r2,-1
81135d00:	d0a08005 	stb	r2,-32256(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
81135d04:	e13ff817 	ldw	r4,-32(fp)
81135d08:	1140f340 	call	81140f34 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
81135d0c:	d0a08b43 	ldbu	r2,-32211(gp)
81135d10:	10bfffc4 	addi	r2,r2,-1
81135d14:	d0a08b45 	stb	r2,-32211(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
81135d18:	e0ffff03 	ldbu	r3,-4(fp)
81135d1c:	00a045b4 	movhi	r2,33046
81135d20:	10882104 	addi	r2,r2,8324
81135d24:	18c7883a 	add	r3,r3,r3
81135d28:	18c7883a 	add	r3,r3,r3
81135d2c:	10c5883a 	add	r2,r2,r3
81135d30:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
81135d34:	e0bff817 	ldw	r2,-32(fp)
81135d38:	10800617 	ldw	r2,24(r2)
81135d3c:	1000071e 	bne	r2,zero,81135d5c <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
81135d40:	e0bff817 	ldw	r2,-32(fp)
81135d44:	10800517 	ldw	r2,20(r2)
81135d48:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
81135d4c:	e0bff817 	ldw	r2,-32(fp)
81135d50:	10800517 	ldw	r2,20(r2)
81135d54:	d0a08515 	stw	r2,-32236(gp)
81135d58:	00000a06 	br	81135d84 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
81135d5c:	e0bff817 	ldw	r2,-32(fp)
81135d60:	10800617 	ldw	r2,24(r2)
81135d64:	e0fff817 	ldw	r3,-32(fp)
81135d68:	18c00517 	ldw	r3,20(r3)
81135d6c:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
81135d70:	e0bff817 	ldw	r2,-32(fp)
81135d74:	10800517 	ldw	r2,20(r2)
81135d78:	e0fff817 	ldw	r3,-32(fp)
81135d7c:	18c00617 	ldw	r3,24(r3)
81135d80:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
81135d84:	d0e08a17 	ldw	r3,-32216(gp)
81135d88:	e0bff817 	ldw	r2,-32(fp)
81135d8c:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
81135d90:	e0bff817 	ldw	r2,-32(fp)
81135d94:	d0a08a15 	stw	r2,-32216(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
81135d98:	e0bff817 	ldw	r2,-32(fp)
81135d9c:	00c00fc4 	movi	r3,63
81135da0:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81135da4:	e0bff817 	ldw	r2,-32(fp)
81135da8:	10001345 	stb	zero,77(r2)
81135dac:	e0bff617 	ldw	r2,-40(fp)
81135db0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135db4:	e0bffc17 	ldw	r2,-16(fp)
81135db8:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81135dbc:	d0a08203 	ldbu	r2,-32248(gp)
81135dc0:	10803fcc 	andi	r2,r2,255
81135dc4:	10800058 	cmpnei	r2,r2,1
81135dc8:	1000011e 	bne	r2,zero,81135dd0 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
81135dcc:	112fe480 	call	8112fe48 <OS_Sched>
    }
    return (OS_ERR_NONE);
81135dd0:	0005883a 	mov	r2,zero
}
81135dd4:	e037883a 	mov	sp,fp
81135dd8:	dfc00117 	ldw	ra,4(sp)
81135ddc:	df000017 	ldw	fp,0(sp)
81135de0:	dec00204 	addi	sp,sp,8
81135de4:	f800283a 	ret

81135de8 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
81135de8:	defff504 	addi	sp,sp,-44
81135dec:	de00012e 	bgeu	sp,et,81135df4 <OSTaskDelReq+0xc>
81135df0:	003b68fa 	trap	3
81135df4:	df000a15 	stw	fp,40(sp)
81135df8:	df000a04 	addi	fp,sp,40
81135dfc:	2005883a 	mov	r2,r4
81135e00:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135e04:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
81135e08:	e0bfff03 	ldbu	r2,-4(fp)
81135e0c:	10800a18 	cmpnei	r2,r2,40
81135e10:	1000021e 	bne	r2,zero,81135e1c <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
81135e14:	00800f84 	movi	r2,62
81135e18:	00004506 	br	81135f30 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81135e1c:	e0bfff03 	ldbu	r2,-4(fp)
81135e20:	10800a30 	cmpltui	r2,r2,40
81135e24:	1000051e 	bne	r2,zero,81135e3c <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
81135e28:	e0bfff03 	ldbu	r2,-4(fp)
81135e2c:	10803fe0 	cmpeqi	r2,r2,255
81135e30:	1000021e 	bne	r2,zero,81135e3c <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
81135e34:	00800a84 	movi	r2,42
81135e38:	00003d06 	br	81135f30 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
81135e3c:	e0bfff03 	ldbu	r2,-4(fp)
81135e40:	10803fd8 	cmpnei	r2,r2,255
81135e44:	1000111e 	bne	r2,zero,81135e8c <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135e48:	0005303a 	rdctl	r2,status
81135e4c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135e50:	e0fff917 	ldw	r3,-28(fp)
81135e54:	00bfff84 	movi	r2,-2
81135e58:	1884703a 	and	r2,r3,r2
81135e5c:	1001703a 	wrctl	status,r2
  
  return context;
81135e60:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
81135e64:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
81135e68:	d0a09317 	ldw	r2,-32180(gp)
81135e6c:	10800dc3 	ldbu	r2,55(r2)
81135e70:	e0bff805 	stb	r2,-32(fp)
81135e74:	e0bff617 	ldw	r2,-40(fp)
81135e78:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135e7c:	e0bffe17 	ldw	r2,-8(fp)
81135e80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
81135e84:	e0bff803 	ldbu	r2,-32(fp)
81135e88:	00002906 	br	81135f30 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135e8c:	0005303a 	rdctl	r2,status
81135e90:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135e94:	e0fff717 	ldw	r3,-36(fp)
81135e98:	00bfff84 	movi	r2,-2
81135e9c:	1884703a 	and	r2,r3,r2
81135ea0:	1001703a 	wrctl	status,r2
  
  return context;
81135ea4:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
81135ea8:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81135eac:	e0ffff03 	ldbu	r3,-4(fp)
81135eb0:	00a045b4 	movhi	r2,33046
81135eb4:	10882104 	addi	r2,r2,8324
81135eb8:	18c7883a 	add	r3,r3,r3
81135ebc:	18c7883a 	add	r3,r3,r3
81135ec0:	10c5883a 	add	r2,r2,r3
81135ec4:	10800017 	ldw	r2,0(r2)
81135ec8:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
81135ecc:	e0bffb17 	ldw	r2,-20(fp)
81135ed0:	1000061e 	bne	r2,zero,81135eec <OSTaskDelReq+0x104>
81135ed4:	e0bff617 	ldw	r2,-40(fp)
81135ed8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135edc:	e0bffa17 	ldw	r2,-24(fp)
81135ee0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
81135ee4:	008010c4 	movi	r2,67
81135ee8:	00001106 	br	81135f30 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
81135eec:	e0bffb17 	ldw	r2,-20(fp)
81135ef0:	10800058 	cmpnei	r2,r2,1
81135ef4:	1000061e 	bne	r2,zero,81135f10 <OSTaskDelReq+0x128>
81135ef8:	e0bff617 	ldw	r2,-40(fp)
81135efc:	e0bffc15 	stw	r2,-16(fp)
81135f00:	e0bffc17 	ldw	r2,-16(fp)
81135f04:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81135f08:	00800f44 	movi	r2,61
81135f0c:	00000806 	br	81135f30 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
81135f10:	e0bffb17 	ldw	r2,-20(fp)
81135f14:	00c00fc4 	movi	r3,63
81135f18:	10c00dc5 	stb	r3,55(r2)
81135f1c:	e0bff617 	ldw	r2,-40(fp)
81135f20:	e0bffd15 	stw	r2,-12(fp)
81135f24:	e0bffd17 	ldw	r2,-12(fp)
81135f28:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81135f2c:	0005883a 	mov	r2,zero
}
81135f30:	e037883a 	mov	sp,fp
81135f34:	df000017 	ldw	fp,0(sp)
81135f38:	dec00104 	addi	sp,sp,4
81135f3c:	f800283a 	ret

81135f40 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
81135f40:	defff404 	addi	sp,sp,-48
81135f44:	de00012e 	bgeu	sp,et,81135f4c <OSTaskNameGet+0xc>
81135f48:	003b68fa 	trap	3
81135f4c:	dfc00b15 	stw	ra,44(sp)
81135f50:	df000a15 	stw	fp,40(sp)
81135f54:	df000a04 	addi	fp,sp,40
81135f58:	2005883a 	mov	r2,r4
81135f5c:	e17ffe15 	stw	r5,-8(fp)
81135f60:	e1bfff15 	stw	r6,-4(fp)
81135f64:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
81135f68:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
81135f6c:	e0bfff17 	ldw	r2,-4(fp)
81135f70:	1000021e 	bne	r2,zero,81135f7c <OSTaskNameGet+0x3c>
        return (0);
81135f74:	0005883a 	mov	r2,zero
81135f78:	00005406 	br	811360cc <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
81135f7c:	e0bffd03 	ldbu	r2,-12(fp)
81135f80:	10800a70 	cmpltui	r2,r2,41
81135f84:	1000081e 	bne	r2,zero,81135fa8 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
81135f88:	e0bffd03 	ldbu	r2,-12(fp)
81135f8c:	10803fe0 	cmpeqi	r2,r2,255
81135f90:	1000051e 	bne	r2,zero,81135fa8 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
81135f94:	e0bfff17 	ldw	r2,-4(fp)
81135f98:	00c00a84 	movi	r3,42
81135f9c:	10c00005 	stb	r3,0(r2)
            return (0);
81135fa0:	0005883a 	mov	r2,zero
81135fa4:	00004906 	br	811360cc <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
81135fa8:	e0bffe17 	ldw	r2,-8(fp)
81135fac:	1000051e 	bne	r2,zero,81135fc4 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
81135fb0:	e0bfff17 	ldw	r2,-4(fp)
81135fb4:	00c00304 	movi	r3,12
81135fb8:	10c00005 	stb	r3,0(r2)
        return (0);
81135fbc:	0005883a 	mov	r2,zero
81135fc0:	00004206 	br	811360cc <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
81135fc4:	d0a09203 	ldbu	r2,-32184(gp)
81135fc8:	10803fcc 	andi	r2,r2,255
81135fcc:	10000526 	beq	r2,zero,81135fe4 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
81135fd0:	e0bfff17 	ldw	r2,-4(fp)
81135fd4:	00c00444 	movi	r3,17
81135fd8:	10c00005 	stb	r3,0(r2)
        return (0);
81135fdc:	0005883a 	mov	r2,zero
81135fe0:	00003a06 	br	811360cc <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135fe4:	0005303a 	rdctl	r2,status
81135fe8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135fec:	e0fffc17 	ldw	r3,-16(fp)
81135ff0:	00bfff84 	movi	r2,-2
81135ff4:	1884703a 	and	r2,r3,r2
81135ff8:	1001703a 	wrctl	status,r2
  
  return context;
81135ffc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136000:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
81136004:	e0bffd03 	ldbu	r2,-12(fp)
81136008:	10803fd8 	cmpnei	r2,r2,255
8113600c:	1000031e 	bne	r2,zero,8113601c <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
81136010:	d0a09317 	ldw	r2,-32180(gp)
81136014:	10800c83 	ldbu	r2,50(r2)
81136018:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113601c:	e0fffd03 	ldbu	r3,-12(fp)
81136020:	00a045b4 	movhi	r2,33046
81136024:	10882104 	addi	r2,r2,8324
81136028:	18c7883a 	add	r3,r3,r3
8113602c:	18c7883a 	add	r3,r3,r3
81136030:	10c5883a 	add	r2,r2,r3
81136034:	10800017 	ldw	r2,0(r2)
81136038:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113603c:	e0bff817 	ldw	r2,-32(fp)
81136040:	1000091e 	bne	r2,zero,81136068 <OSTaskNameGet+0x128>
81136044:	e0bff617 	ldw	r2,-40(fp)
81136048:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113604c:	e0bff717 	ldw	r2,-36(fp)
81136050:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
81136054:	e0bfff17 	ldw	r2,-4(fp)
81136058:	00c010c4 	movi	r3,67
8113605c:	10c00005 	stb	r3,0(r2)
        return (0);
81136060:	0005883a 	mov	r2,zero
81136064:	00001906 	br	811360cc <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
81136068:	e0bff817 	ldw	r2,-32(fp)
8113606c:	10800058 	cmpnei	r2,r2,1
81136070:	1000091e 	bne	r2,zero,81136098 <OSTaskNameGet+0x158>
81136074:	e0bff617 	ldw	r2,-40(fp)
81136078:	e0bff915 	stw	r2,-28(fp)
8113607c:	e0bff917 	ldw	r2,-28(fp)
81136080:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
81136084:	e0bfff17 	ldw	r2,-4(fp)
81136088:	00c010c4 	movi	r3,67
8113608c:	10c00005 	stb	r3,0(r2)
        return (0);
81136090:	0005883a 	mov	r2,zero
81136094:	00000d06 	br	811360cc <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
81136098:	e0bff817 	ldw	r2,-32(fp)
8113609c:	10801304 	addi	r2,r2,76
811360a0:	100b883a 	mov	r5,r2
811360a4:	e13ffe17 	ldw	r4,-8(fp)
811360a8:	112ff9c0 	call	8112ff9c <OS_StrCopy>
811360ac:	e0bffb05 	stb	r2,-20(fp)
811360b0:	e0bff617 	ldw	r2,-40(fp)
811360b4:	e0bffa15 	stw	r2,-24(fp)
811360b8:	e0bffa17 	ldw	r2,-24(fp)
811360bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811360c0:	e0bfff17 	ldw	r2,-4(fp)
811360c4:	10000005 	stb	zero,0(r2)
    return (len);
811360c8:	e0bffb03 	ldbu	r2,-20(fp)
}
811360cc:	e037883a 	mov	sp,fp
811360d0:	dfc00117 	ldw	ra,4(sp)
811360d4:	df000017 	ldw	fp,0(sp)
811360d8:	dec00204 	addi	sp,sp,8
811360dc:	f800283a 	ret

811360e0 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
811360e0:	defff304 	addi	sp,sp,-52
811360e4:	de00012e 	bgeu	sp,et,811360ec <OSTaskNameSet+0xc>
811360e8:	003b68fa 	trap	3
811360ec:	dfc00c15 	stw	ra,48(sp)
811360f0:	df000b15 	stw	fp,44(sp)
811360f4:	df000b04 	addi	fp,sp,44
811360f8:	2005883a 	mov	r2,r4
811360fc:	e17ffe15 	stw	r5,-8(fp)
81136100:	e1bfff15 	stw	r6,-4(fp)
81136104:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81136108:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113610c:	e0bfff17 	ldw	r2,-4(fp)
81136110:	10005c26 	beq	r2,zero,81136284 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
81136114:	e0bffd03 	ldbu	r2,-12(fp)
81136118:	10800a70 	cmpltui	r2,r2,41
8113611c:	1000071e 	bne	r2,zero,8113613c <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
81136120:	e0bffd03 	ldbu	r2,-12(fp)
81136124:	10803fe0 	cmpeqi	r2,r2,255
81136128:	1000041e 	bne	r2,zero,8113613c <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113612c:	e0bfff17 	ldw	r2,-4(fp)
81136130:	00c00a84 	movi	r3,42
81136134:	10c00005 	stb	r3,0(r2)
            return;
81136138:	00005306 	br	81136288 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113613c:	e0bffe17 	ldw	r2,-8(fp)
81136140:	1000041e 	bne	r2,zero,81136154 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
81136144:	e0bfff17 	ldw	r2,-4(fp)
81136148:	00c00304 	movi	r3,12
8113614c:	10c00005 	stb	r3,0(r2)
        return;
81136150:	00004d06 	br	81136288 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
81136154:	d0a09203 	ldbu	r2,-32184(gp)
81136158:	10803fcc 	andi	r2,r2,255
8113615c:	10000426 	beq	r2,zero,81136170 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
81136160:	e0bfff17 	ldw	r2,-4(fp)
81136164:	00c00484 	movi	r3,18
81136168:	10c00005 	stb	r3,0(r2)
        return;
8113616c:	00004606 	br	81136288 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136170:	0005303a 	rdctl	r2,status
81136174:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136178:	e0fffc17 	ldw	r3,-16(fp)
8113617c:	00bfff84 	movi	r2,-2
81136180:	1884703a 	and	r2,r3,r2
81136184:	1001703a 	wrctl	status,r2
  
  return context;
81136188:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113618c:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
81136190:	e0bffd03 	ldbu	r2,-12(fp)
81136194:	10803fd8 	cmpnei	r2,r2,255
81136198:	1000031e 	bne	r2,zero,811361a8 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113619c:	d0a09317 	ldw	r2,-32180(gp)
811361a0:	10800c83 	ldbu	r2,50(r2)
811361a4:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811361a8:	e0fffd03 	ldbu	r3,-12(fp)
811361ac:	00a045b4 	movhi	r2,33046
811361b0:	10882104 	addi	r2,r2,8324
811361b4:	18c7883a 	add	r3,r3,r3
811361b8:	18c7883a 	add	r3,r3,r3
811361bc:	10c5883a 	add	r2,r2,r3
811361c0:	10800017 	ldw	r2,0(r2)
811361c4:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
811361c8:	e0bff717 	ldw	r2,-36(fp)
811361cc:	1000081e 	bne	r2,zero,811361f0 <OSTaskNameSet+0x110>
811361d0:	e0bff517 	ldw	r2,-44(fp)
811361d4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811361d8:	e0bff617 	ldw	r2,-40(fp)
811361dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
811361e0:	e0bfff17 	ldw	r2,-4(fp)
811361e4:	00c010c4 	movi	r3,67
811361e8:	10c00005 	stb	r3,0(r2)
        return;
811361ec:	00002606 	br	81136288 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
811361f0:	e0bff717 	ldw	r2,-36(fp)
811361f4:	10800058 	cmpnei	r2,r2,1
811361f8:	1000081e 	bne	r2,zero,8113621c <OSTaskNameSet+0x13c>
811361fc:	e0bff517 	ldw	r2,-44(fp)
81136200:	e0bff815 	stw	r2,-32(fp)
81136204:	e0bff817 	ldw	r2,-32(fp)
81136208:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113620c:	e0bfff17 	ldw	r2,-4(fp)
81136210:	00c010c4 	movi	r3,67
81136214:	10c00005 	stb	r3,0(r2)
        return;
81136218:	00001b06 	br	81136288 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113621c:	e13ffe17 	ldw	r4,-8(fp)
81136220:	11300180 	call	81130018 <OS_StrLen>
81136224:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
81136228:	e0bffa03 	ldbu	r2,-24(fp)
8113622c:	10800830 	cmpltui	r2,r2,32
81136230:	1000081e 	bne	r2,zero,81136254 <OSTaskNameSet+0x174>
81136234:	e0bff517 	ldw	r2,-44(fp)
81136238:	e0bff915 	stw	r2,-28(fp)
8113623c:	e0bff917 	ldw	r2,-28(fp)
81136240:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
81136244:	e0bfff17 	ldw	r2,-4(fp)
81136248:	00c01044 	movi	r3,65
8113624c:	10c00005 	stb	r3,0(r2)
        return;
81136250:	00000d06 	br	81136288 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
81136254:	e0bff717 	ldw	r2,-36(fp)
81136258:	10801304 	addi	r2,r2,76
8113625c:	e17ffe17 	ldw	r5,-8(fp)
81136260:	1009883a 	mov	r4,r2
81136264:	112ff9c0 	call	8112ff9c <OS_StrCopy>
81136268:	e0bff517 	ldw	r2,-44(fp)
8113626c:	e0bffb15 	stw	r2,-20(fp)
81136270:	e0bffb17 	ldw	r2,-20(fp)
81136274:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136278:	e0bfff17 	ldw	r2,-4(fp)
8113627c:	10000005 	stb	zero,0(r2)
81136280:	00000106 	br	81136288 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
81136284:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81136288:	e037883a 	mov	sp,fp
8113628c:	dfc00117 	ldw	ra,4(sp)
81136290:	df000017 	ldw	fp,0(sp)
81136294:	dec00204 	addi	sp,sp,8
81136298:	f800283a 	ret

8113629c <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113629c:	defff404 	addi	sp,sp,-48
811362a0:	de00012e 	bgeu	sp,et,811362a8 <OSTaskResume+0xc>
811362a4:	003b68fa 	trap	3
811362a8:	dfc00b15 	stw	ra,44(sp)
811362ac:	df000a15 	stw	fp,40(sp)
811362b0:	df000a04 	addi	fp,sp,40
811362b4:	2005883a 	mov	r2,r4
811362b8:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
811362bc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
811362c0:	e0bfff03 	ldbu	r2,-4(fp)
811362c4:	10800a30 	cmpltui	r2,r2,40
811362c8:	1000021e 	bne	r2,zero,811362d4 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
811362cc:	00800a84 	movi	r2,42
811362d0:	00006406 	br	81136464 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811362d4:	0005303a 	rdctl	r2,status
811362d8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811362dc:	e0fffe17 	ldw	r3,-8(fp)
811362e0:	00bfff84 	movi	r2,-2
811362e4:	1884703a 	and	r2,r3,r2
811362e8:	1001703a 	wrctl	status,r2
  
  return context;
811362ec:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811362f0:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
811362f4:	e0ffff03 	ldbu	r3,-4(fp)
811362f8:	00a045b4 	movhi	r2,33046
811362fc:	10882104 	addi	r2,r2,8324
81136300:	18c7883a 	add	r3,r3,r3
81136304:	18c7883a 	add	r3,r3,r3
81136308:	10c5883a 	add	r2,r2,r3
8113630c:	10800017 	ldw	r2,0(r2)
81136310:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
81136314:	e0bff817 	ldw	r2,-32(fp)
81136318:	1000061e 	bne	r2,zero,81136334 <OSTaskResume+0x98>
8113631c:	e0bff617 	ldw	r2,-40(fp)
81136320:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136324:	e0bff717 	ldw	r2,-36(fp)
81136328:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113632c:	00801184 	movi	r2,70
81136330:	00004c06 	br	81136464 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
81136334:	e0bff817 	ldw	r2,-32(fp)
81136338:	10800058 	cmpnei	r2,r2,1
8113633c:	1000061e 	bne	r2,zero,81136358 <OSTaskResume+0xbc>
81136340:	e0bff617 	ldw	r2,-40(fp)
81136344:	e0bff915 	stw	r2,-28(fp)
81136348:	e0bff917 	ldw	r2,-28(fp)
8113634c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81136350:	008010c4 	movi	r2,67
81136354:	00004306 	br	81136464 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
81136358:	e0bff817 	ldw	r2,-32(fp)
8113635c:	10800c03 	ldbu	r2,48(r2)
81136360:	10803fcc 	andi	r2,r2,255
81136364:	1080020c 	andi	r2,r2,8
81136368:	10003926 	beq	r2,zero,81136450 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113636c:	e0bff817 	ldw	r2,-32(fp)
81136370:	10c00c03 	ldbu	r3,48(r2)
81136374:	00bffdc4 	movi	r2,-9
81136378:	1884703a 	and	r2,r3,r2
8113637c:	1007883a 	mov	r3,r2
81136380:	e0bff817 	ldw	r2,-32(fp)
81136384:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
81136388:	e0bff817 	ldw	r2,-32(fp)
8113638c:	10800c03 	ldbu	r2,48(r2)
81136390:	10803fcc 	andi	r2,r2,255
81136394:	1000281e 	bne	r2,zero,81136438 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
81136398:	e0bff817 	ldw	r2,-32(fp)
8113639c:	10800b8b 	ldhu	r2,46(r2)
811363a0:	10bfffcc 	andi	r2,r2,65535
811363a4:	10001f1e 	bne	r2,zero,81136424 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
811363a8:	e0bff817 	ldw	r2,-32(fp)
811363ac:	10c00d83 	ldbu	r3,54(r2)
811363b0:	d0a08f03 	ldbu	r2,-32196(gp)
811363b4:	1884b03a 	or	r2,r3,r2
811363b8:	d0a08f05 	stb	r2,-32196(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811363bc:	e0bff817 	ldw	r2,-32(fp)
811363c0:	10800d03 	ldbu	r2,52(r2)
811363c4:	10c03fcc 	andi	r3,r2,255
811363c8:	e0bff817 	ldw	r2,-32(fp)
811363cc:	10800d03 	ldbu	r2,52(r2)
811363d0:	11003fcc 	andi	r4,r2,255
811363d4:	d0a08f44 	addi	r2,gp,-32195
811363d8:	2085883a 	add	r2,r4,r2
811363dc:	11000003 	ldbu	r4,0(r2)
811363e0:	e0bff817 	ldw	r2,-32(fp)
811363e4:	10800d43 	ldbu	r2,53(r2)
811363e8:	2084b03a 	or	r2,r4,r2
811363ec:	1009883a 	mov	r4,r2
811363f0:	d0a08f44 	addi	r2,gp,-32195
811363f4:	1885883a 	add	r2,r3,r2
811363f8:	11000005 	stb	r4,0(r2)
811363fc:	e0bff617 	ldw	r2,-40(fp)
81136400:	e0bffa15 	stw	r2,-24(fp)
81136404:	e0bffa17 	ldw	r2,-24(fp)
81136408:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113640c:	d0a08203 	ldbu	r2,-32248(gp)
81136410:	10803fcc 	andi	r2,r2,255
81136414:	10800058 	cmpnei	r2,r2,1
81136418:	10000b1e 	bne	r2,zero,81136448 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113641c:	112fe480 	call	8112fe48 <OS_Sched>
81136420:	00000906 	br	81136448 <OSTaskResume+0x1ac>
81136424:	e0bff617 	ldw	r2,-40(fp)
81136428:	e0bffb15 	stw	r2,-20(fp)
8113642c:	e0bffb17 	ldw	r2,-20(fp)
81136430:	1001703a 	wrctl	status,r2
81136434:	00000406 	br	81136448 <OSTaskResume+0x1ac>
81136438:	e0bff617 	ldw	r2,-40(fp)
8113643c:	e0bffc15 	stw	r2,-16(fp)
81136440:	e0bffc17 	ldw	r2,-16(fp)
81136444:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
81136448:	0005883a 	mov	r2,zero
8113644c:	00000506 	br	81136464 <OSTaskResume+0x1c8>
81136450:	e0bff617 	ldw	r2,-40(fp)
81136454:	e0bffd15 	stw	r2,-12(fp)
81136458:	e0bffd17 	ldw	r2,-12(fp)
8113645c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
81136460:	00801104 	movi	r2,68
}
81136464:	e037883a 	mov	sp,fp
81136468:	dfc00117 	ldw	ra,4(sp)
8113646c:	df000017 	ldw	fp,0(sp)
81136470:	dec00204 	addi	sp,sp,8
81136474:	f800283a 	ret

81136478 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
81136478:	defff304 	addi	sp,sp,-52
8113647c:	de00012e 	bgeu	sp,et,81136484 <OSTaskStkChk+0xc>
81136480:	003b68fa 	trap	3
81136484:	df000c15 	stw	fp,48(sp)
81136488:	df000c04 	addi	fp,sp,48
8113648c:	2005883a 	mov	r2,r4
81136490:	e17fff15 	stw	r5,-4(fp)
81136494:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81136498:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113649c:	e0bffe03 	ldbu	r2,-8(fp)
811364a0:	10800a70 	cmpltui	r2,r2,41
811364a4:	1000051e 	bne	r2,zero,811364bc <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
811364a8:	e0bffe03 	ldbu	r2,-8(fp)
811364ac:	10803fe0 	cmpeqi	r2,r2,255
811364b0:	1000021e 	bne	r2,zero,811364bc <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
811364b4:	00800a84 	movi	r2,42
811364b8:	00005d06 	br	81136630 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
811364bc:	e0bfff17 	ldw	r2,-4(fp)
811364c0:	1000021e 	bne	r2,zero,811364cc <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
811364c4:	00800244 	movi	r2,9
811364c8:	00005906 	br	81136630 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
811364cc:	e0bfff17 	ldw	r2,-4(fp)
811364d0:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
811364d4:	e0bfff17 	ldw	r2,-4(fp)
811364d8:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811364dc:	0005303a 	rdctl	r2,status
811364e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811364e4:	e0fffd17 	ldw	r3,-12(fp)
811364e8:	00bfff84 	movi	r2,-2
811364ec:	1884703a 	and	r2,r3,r2
811364f0:	1001703a 	wrctl	status,r2
  
  return context;
811364f4:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
811364f8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
811364fc:	e0bffe03 	ldbu	r2,-8(fp)
81136500:	10803fd8 	cmpnei	r2,r2,255
81136504:	1000031e 	bne	r2,zero,81136514 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
81136508:	d0a09317 	ldw	r2,-32180(gp)
8113650c:	10800c83 	ldbu	r2,50(r2)
81136510:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81136514:	e0fffe03 	ldbu	r3,-8(fp)
81136518:	00a045b4 	movhi	r2,33046
8113651c:	10882104 	addi	r2,r2,8324
81136520:	18c7883a 	add	r3,r3,r3
81136524:	18c7883a 	add	r3,r3,r3
81136528:	10c5883a 	add	r2,r2,r3
8113652c:	10800017 	ldw	r2,0(r2)
81136530:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
81136534:	e0bff817 	ldw	r2,-32(fp)
81136538:	1000061e 	bne	r2,zero,81136554 <OSTaskStkChk+0xdc>
8113653c:	e0bff617 	ldw	r2,-40(fp)
81136540:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136544:	e0bff717 	ldw	r2,-36(fp)
81136548:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113654c:	008010c4 	movi	r2,67
81136550:	00003706 	br	81136630 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81136554:	e0bff817 	ldw	r2,-32(fp)
81136558:	10800058 	cmpnei	r2,r2,1
8113655c:	1000061e 	bne	r2,zero,81136578 <OSTaskStkChk+0x100>
81136560:	e0bff617 	ldw	r2,-40(fp)
81136564:	e0bff915 	stw	r2,-28(fp)
81136568:	e0bff917 	ldw	r2,-28(fp)
8113656c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81136570:	008010c4 	movi	r2,67
81136574:	00002e06 	br	81136630 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
81136578:	e0bff817 	ldw	r2,-32(fp)
8113657c:	1080040b 	ldhu	r2,16(r2)
81136580:	10bfffcc 	andi	r2,r2,65535
81136584:	1080004c 	andi	r2,r2,1
81136588:	1000061e 	bne	r2,zero,811365a4 <OSTaskStkChk+0x12c>
8113658c:	e0bff617 	ldw	r2,-40(fp)
81136590:	e0bffa15 	stw	r2,-24(fp)
81136594:	e0bffa17 	ldw	r2,-24(fp)
81136598:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113659c:	00801144 	movi	r2,69
811365a0:	00002306 	br	81136630 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
811365a4:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
811365a8:	e0bff817 	ldw	r2,-32(fp)
811365ac:	10800317 	ldw	r2,12(r2)
811365b0:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
811365b4:	e0bff817 	ldw	r2,-32(fp)
811365b8:	10800217 	ldw	r2,8(r2)
811365bc:	e0bff415 	stw	r2,-48(fp)
811365c0:	e0bff617 	ldw	r2,-40(fp)
811365c4:	e0bffb15 	stw	r2,-20(fp)
811365c8:	e0bffb17 	ldw	r2,-20(fp)
811365cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811365d0:	00000306 	br	811365e0 <OSTaskStkChk+0x168>
        nfree++;
811365d4:	e0bff517 	ldw	r2,-44(fp)
811365d8:	10800044 	addi	r2,r2,1
811365dc:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
811365e0:	e0bff417 	ldw	r2,-48(fp)
811365e4:	10c00104 	addi	r3,r2,4
811365e8:	e0fff415 	stw	r3,-48(fp)
811365ec:	10800017 	ldw	r2,0(r2)
811365f0:	103ff826 	beq	r2,zero,811365d4 <__reset+0xfb1165d4>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
811365f4:	e0bff517 	ldw	r2,-44(fp)
811365f8:	1085883a 	add	r2,r2,r2
811365fc:	1085883a 	add	r2,r2,r2
81136600:	1007883a 	mov	r3,r2
81136604:	e0bfff17 	ldw	r2,-4(fp)
81136608:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113660c:	e0fffc17 	ldw	r3,-16(fp)
81136610:	e0bff517 	ldw	r2,-44(fp)
81136614:	1885c83a 	sub	r2,r3,r2
81136618:	1085883a 	add	r2,r2,r2
8113661c:	1085883a 	add	r2,r2,r2
81136620:	1007883a 	mov	r3,r2
81136624:	e0bfff17 	ldw	r2,-4(fp)
81136628:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113662c:	0005883a 	mov	r2,zero
}
81136630:	e037883a 	mov	sp,fp
81136634:	df000017 	ldw	fp,0(sp)
81136638:	dec00104 	addi	sp,sp,4
8113663c:	f800283a 	ret

81136640 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
81136640:	defff504 	addi	sp,sp,-44
81136644:	de00012e 	bgeu	sp,et,8113664c <OSTaskSuspend+0xc>
81136648:	003b68fa 	trap	3
8113664c:	dfc00a15 	stw	ra,40(sp)
81136650:	df000915 	stw	fp,36(sp)
81136654:	df000904 	addi	fp,sp,36
81136658:	2005883a 	mov	r2,r4
8113665c:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136660:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
81136664:	e0bfff03 	ldbu	r2,-4(fp)
81136668:	10800a18 	cmpnei	r2,r2,40
8113666c:	1000021e 	bne	r2,zero,81136678 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
81136670:	008011c4 	movi	r2,71
81136674:	00006806 	br	81136818 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81136678:	e0bfff03 	ldbu	r2,-4(fp)
8113667c:	10800a30 	cmpltui	r2,r2,40
81136680:	1000051e 	bne	r2,zero,81136698 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
81136684:	e0bfff03 	ldbu	r2,-4(fp)
81136688:	10803fe0 	cmpeqi	r2,r2,255
8113668c:	1000021e 	bne	r2,zero,81136698 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
81136690:	00800a84 	movi	r2,42
81136694:	00006006 	br	81136818 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136698:	0005303a 	rdctl	r2,status
8113669c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811366a0:	e0fffe17 	ldw	r3,-8(fp)
811366a4:	00bfff84 	movi	r2,-2
811366a8:	1884703a 	and	r2,r3,r2
811366ac:	1001703a 	wrctl	status,r2
  
  return context;
811366b0:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
811366b4:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
811366b8:	e0bfff03 	ldbu	r2,-4(fp)
811366bc:	10803fd8 	cmpnei	r2,r2,255
811366c0:	1000061e 	bne	r2,zero,811366dc <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
811366c4:	d0a09317 	ldw	r2,-32180(gp)
811366c8:	10800c83 	ldbu	r2,50(r2)
811366cc:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
811366d0:	00800044 	movi	r2,1
811366d4:	e0bff705 	stb	r2,-36(fp)
811366d8:	00000906 	br	81136700 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
811366dc:	d0a09317 	ldw	r2,-32180(gp)
811366e0:	10800c83 	ldbu	r2,50(r2)
811366e4:	10c03fcc 	andi	r3,r2,255
811366e8:	e0bfff03 	ldbu	r2,-4(fp)
811366ec:	1880031e 	bne	r3,r2,811366fc <OSTaskSuspend+0xbc>
        self = OS_TRUE;
811366f0:	00800044 	movi	r2,1
811366f4:	e0bff705 	stb	r2,-36(fp)
811366f8:	00000106 	br	81136700 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
811366fc:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81136700:	e0ffff03 	ldbu	r3,-4(fp)
81136704:	00a045b4 	movhi	r2,33046
81136708:	10882104 	addi	r2,r2,8324
8113670c:	18c7883a 	add	r3,r3,r3
81136710:	18c7883a 	add	r3,r3,r3
81136714:	10c5883a 	add	r2,r2,r3
81136718:	10800017 	ldw	r2,0(r2)
8113671c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
81136720:	e0bffa17 	ldw	r2,-24(fp)
81136724:	1000061e 	bne	r2,zero,81136740 <OSTaskSuspend+0x100>
81136728:	e0bff817 	ldw	r2,-32(fp)
8113672c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136730:	e0bff917 	ldw	r2,-28(fp)
81136734:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
81136738:	00801204 	movi	r2,72
8113673c:	00003606 	br	81136818 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
81136740:	e0bffa17 	ldw	r2,-24(fp)
81136744:	10800058 	cmpnei	r2,r2,1
81136748:	1000061e 	bne	r2,zero,81136764 <OSTaskSuspend+0x124>
8113674c:	e0bff817 	ldw	r2,-32(fp)
81136750:	e0bffb15 	stw	r2,-20(fp)
81136754:	e0bffb17 	ldw	r2,-20(fp)
81136758:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113675c:	008010c4 	movi	r2,67
81136760:	00002d06 	br	81136818 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
81136764:	e0bffa17 	ldw	r2,-24(fp)
81136768:	10800d03 	ldbu	r2,52(r2)
8113676c:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
81136770:	e0fffd03 	ldbu	r3,-12(fp)
81136774:	e13ffd03 	ldbu	r4,-12(fp)
81136778:	d0a08f44 	addi	r2,gp,-32195
8113677c:	2085883a 	add	r2,r4,r2
81136780:	10800003 	ldbu	r2,0(r2)
81136784:	1009883a 	mov	r4,r2
81136788:	e0bffa17 	ldw	r2,-24(fp)
8113678c:	10800d43 	ldbu	r2,53(r2)
81136790:	0084303a 	nor	r2,zero,r2
81136794:	2084703a 	and	r2,r4,r2
81136798:	1009883a 	mov	r4,r2
8113679c:	d0a08f44 	addi	r2,gp,-32195
811367a0:	1885883a 	add	r2,r3,r2
811367a4:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811367a8:	e0fffd03 	ldbu	r3,-12(fp)
811367ac:	d0a08f44 	addi	r2,gp,-32195
811367b0:	1885883a 	add	r2,r3,r2
811367b4:	10800003 	ldbu	r2,0(r2)
811367b8:	10803fcc 	andi	r2,r2,255
811367bc:	1000071e 	bne	r2,zero,811367dc <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
811367c0:	e0bffa17 	ldw	r2,-24(fp)
811367c4:	10800d83 	ldbu	r2,54(r2)
811367c8:	0084303a 	nor	r2,zero,r2
811367cc:	1007883a 	mov	r3,r2
811367d0:	d0a08f03 	ldbu	r2,-32196(gp)
811367d4:	1884703a 	and	r2,r3,r2
811367d8:	d0a08f05 	stb	r2,-32196(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
811367dc:	e0bffa17 	ldw	r2,-24(fp)
811367e0:	10800c03 	ldbu	r2,48(r2)
811367e4:	10800214 	ori	r2,r2,8
811367e8:	1007883a 	mov	r3,r2
811367ec:	e0bffa17 	ldw	r2,-24(fp)
811367f0:	10c00c05 	stb	r3,48(r2)
811367f4:	e0bff817 	ldw	r2,-32(fp)
811367f8:	e0bffc15 	stw	r2,-16(fp)
811367fc:	e0bffc17 	ldw	r2,-16(fp)
81136800:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
81136804:	e0bff703 	ldbu	r2,-36(fp)
81136808:	10800058 	cmpnei	r2,r2,1
8113680c:	1000011e 	bne	r2,zero,81136814 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
81136810:	112fe480 	call	8112fe48 <OS_Sched>
    }
    return (OS_ERR_NONE);
81136814:	0005883a 	mov	r2,zero
}
81136818:	e037883a 	mov	sp,fp
8113681c:	dfc00117 	ldw	ra,4(sp)
81136820:	df000017 	ldw	fp,0(sp)
81136824:	dec00204 	addi	sp,sp,8
81136828:	f800283a 	ret

8113682c <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8113682c:	defff604 	addi	sp,sp,-40
81136830:	de00012e 	bgeu	sp,et,81136838 <OSTaskQuery+0xc>
81136834:	003b68fa 	trap	3
81136838:	dfc00915 	stw	ra,36(sp)
8113683c:	df000815 	stw	fp,32(sp)
81136840:	df000804 	addi	fp,sp,32
81136844:	2005883a 	mov	r2,r4
81136848:	e17fff15 	stw	r5,-4(fp)
8113684c:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136850:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
81136854:	e0bffe03 	ldbu	r2,-8(fp)
81136858:	10800a70 	cmpltui	r2,r2,41
8113685c:	1000051e 	bne	r2,zero,81136874 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
81136860:	e0bffe03 	ldbu	r2,-8(fp)
81136864:	10803fe0 	cmpeqi	r2,r2,255
81136868:	1000021e 	bne	r2,zero,81136874 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8113686c:	00800a84 	movi	r2,42
81136870:	00003406 	br	81136944 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
81136874:	e0bfff17 	ldw	r2,-4(fp)
81136878:	1000021e 	bne	r2,zero,81136884 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8113687c:	00800244 	movi	r2,9
81136880:	00003006 	br	81136944 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136884:	0005303a 	rdctl	r2,status
81136888:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113688c:	e0fffd17 	ldw	r3,-12(fp)
81136890:	00bfff84 	movi	r2,-2
81136894:	1884703a 	and	r2,r3,r2
81136898:	1001703a 	wrctl	status,r2
  
  return context;
8113689c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811368a0:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
811368a4:	e0bffe03 	ldbu	r2,-8(fp)
811368a8:	10803fd8 	cmpnei	r2,r2,255
811368ac:	1000031e 	bne	r2,zero,811368bc <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
811368b0:	d0a09317 	ldw	r2,-32180(gp)
811368b4:	10800c83 	ldbu	r2,50(r2)
811368b8:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811368bc:	e0fffe03 	ldbu	r3,-8(fp)
811368c0:	00a045b4 	movhi	r2,33046
811368c4:	10882104 	addi	r2,r2,8324
811368c8:	18c7883a 	add	r3,r3,r3
811368cc:	18c7883a 	add	r3,r3,r3
811368d0:	10c5883a 	add	r2,r2,r3
811368d4:	10800017 	ldw	r2,0(r2)
811368d8:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
811368dc:	e0bffa17 	ldw	r2,-24(fp)
811368e0:	1000061e 	bne	r2,zero,811368fc <OSTaskQuery+0xd0>
811368e4:	e0bff817 	ldw	r2,-32(fp)
811368e8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811368ec:	e0bff917 	ldw	r2,-28(fp)
811368f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
811368f4:	00800a44 	movi	r2,41
811368f8:	00001206 	br	81136944 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
811368fc:	e0bffa17 	ldw	r2,-24(fp)
81136900:	10800058 	cmpnei	r2,r2,1
81136904:	1000061e 	bne	r2,zero,81136920 <OSTaskQuery+0xf4>
81136908:	e0bff817 	ldw	r2,-32(fp)
8113690c:	e0bffb15 	stw	r2,-20(fp)
81136910:	e0bffb17 	ldw	r2,-20(fp)
81136914:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81136918:	008010c4 	movi	r2,67
8113691c:	00000906 	br	81136944 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
81136920:	01801b04 	movi	r6,108
81136924:	e17ffa17 	ldw	r5,-24(fp)
81136928:	e13fff17 	ldw	r4,-4(fp)
8113692c:	112fdd80 	call	8112fdd8 <OS_MemCopy>
81136930:	e0bff817 	ldw	r2,-32(fp)
81136934:	e0bffc15 	stw	r2,-16(fp)
81136938:	e0bffc17 	ldw	r2,-16(fp)
8113693c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81136940:	0005883a 	mov	r2,zero
}
81136944:	e037883a 	mov	sp,fp
81136948:	dfc00117 	ldw	ra,4(sp)
8113694c:	df000017 	ldw	fp,0(sp)
81136950:	dec00204 	addi	sp,sp,8
81136954:	f800283a 	ret

81136958 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
81136958:	defffc04 	addi	sp,sp,-16
8113695c:	de00012e 	bgeu	sp,et,81136964 <OS_TaskStkClr+0xc>
81136960:	003b68fa 	trap	3
81136964:	df000315 	stw	fp,12(sp)
81136968:	df000304 	addi	fp,sp,12
8113696c:	e13ffd15 	stw	r4,-12(fp)
81136970:	e17ffe15 	stw	r5,-8(fp)
81136974:	3005883a 	mov	r2,r6
81136978:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8113697c:	e0bfff0b 	ldhu	r2,-4(fp)
81136980:	1080004c 	andi	r2,r2,1
81136984:	10000d26 	beq	r2,zero,811369bc <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
81136988:	e0bfff0b 	ldhu	r2,-4(fp)
8113698c:	1080008c 	andi	r2,r2,2
81136990:	10000a26 	beq	r2,zero,811369bc <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
81136994:	00000706 	br	811369b4 <OS_TaskStkClr+0x5c>
                size--;
81136998:	e0bffe17 	ldw	r2,-8(fp)
8113699c:	10bfffc4 	addi	r2,r2,-1
811369a0:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
811369a4:	e0bffd17 	ldw	r2,-12(fp)
811369a8:	10c00104 	addi	r3,r2,4
811369ac:	e0fffd15 	stw	r3,-12(fp)
811369b0:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811369b4:	e0bffe17 	ldw	r2,-8(fp)
811369b8:	103ff71e 	bne	r2,zero,81136998 <__reset+0xfb116998>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
811369bc:	0001883a 	nop
811369c0:	e037883a 	mov	sp,fp
811369c4:	df000017 	ldw	fp,0(sp)
811369c8:	dec00104 	addi	sp,sp,4
811369cc:	f800283a 	ret

811369d0 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
811369d0:	defff904 	addi	sp,sp,-28
811369d4:	de00012e 	bgeu	sp,et,811369dc <OSTimeDly+0xc>
811369d8:	003b68fa 	trap	3
811369dc:	dfc00615 	stw	ra,24(sp)
811369e0:	df000515 	stw	fp,20(sp)
811369e4:	df000504 	addi	fp,sp,20
811369e8:	2005883a 	mov	r2,r4
811369ec:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811369f0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811369f4:	d0a09203 	ldbu	r2,-32184(gp)
811369f8:	10803fcc 	andi	r2,r2,255
811369fc:	1000311e 	bne	r2,zero,81136ac4 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
81136a00:	e0bfff0b 	ldhu	r2,-4(fp)
81136a04:	10003026 	beq	r2,zero,81136ac8 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136a08:	0005303a 	rdctl	r2,status
81136a0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136a10:	e0fffe17 	ldw	r3,-8(fp)
81136a14:	00bfff84 	movi	r2,-2
81136a18:	1884703a 	and	r2,r3,r2
81136a1c:	1001703a 	wrctl	status,r2
  
  return context;
81136a20:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
81136a24:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
81136a28:	d0a09317 	ldw	r2,-32180(gp)
81136a2c:	10800d03 	ldbu	r2,52(r2)
81136a30:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81136a34:	e0fffd03 	ldbu	r3,-12(fp)
81136a38:	e13ffd03 	ldbu	r4,-12(fp)
81136a3c:	d0a08f44 	addi	r2,gp,-32195
81136a40:	2085883a 	add	r2,r4,r2
81136a44:	10800003 	ldbu	r2,0(r2)
81136a48:	1009883a 	mov	r4,r2
81136a4c:	d0a09317 	ldw	r2,-32180(gp)
81136a50:	10800d43 	ldbu	r2,53(r2)
81136a54:	0084303a 	nor	r2,zero,r2
81136a58:	2084703a 	and	r2,r4,r2
81136a5c:	1009883a 	mov	r4,r2
81136a60:	d0a08f44 	addi	r2,gp,-32195
81136a64:	1885883a 	add	r2,r3,r2
81136a68:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
81136a6c:	e0fffd03 	ldbu	r3,-12(fp)
81136a70:	d0a08f44 	addi	r2,gp,-32195
81136a74:	1885883a 	add	r2,r3,r2
81136a78:	10800003 	ldbu	r2,0(r2)
81136a7c:	10803fcc 	andi	r2,r2,255
81136a80:	1000071e 	bne	r2,zero,81136aa0 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81136a84:	d0a09317 	ldw	r2,-32180(gp)
81136a88:	10800d83 	ldbu	r2,54(r2)
81136a8c:	0084303a 	nor	r2,zero,r2
81136a90:	1007883a 	mov	r3,r2
81136a94:	d0a08f03 	ldbu	r2,-32196(gp)
81136a98:	1884703a 	and	r2,r3,r2
81136a9c:	d0a08f05 	stb	r2,-32196(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
81136aa0:	d0a09317 	ldw	r2,-32180(gp)
81136aa4:	e0ffff0b 	ldhu	r3,-4(fp)
81136aa8:	10c00b8d 	sth	r3,46(r2)
81136aac:	e0bffb17 	ldw	r2,-20(fp)
81136ab0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136ab4:	e0bffc17 	ldw	r2,-16(fp)
81136ab8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
81136abc:	112fe480 	call	8112fe48 <OS_Sched>
81136ac0:	00000106 	br	81136ac8 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
81136ac4:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
81136ac8:	e037883a 	mov	sp,fp
81136acc:	dfc00117 	ldw	ra,4(sp)
81136ad0:	df000017 	ldw	fp,0(sp)
81136ad4:	dec00204 	addi	sp,sp,8
81136ad8:	f800283a 	ret

81136adc <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81136adc:	defff804 	addi	sp,sp,-32
81136ae0:	de00012e 	bgeu	sp,et,81136ae8 <OSTimeDlyHMSM+0xc>
81136ae4:	003b68fa 	trap	3
81136ae8:	dfc00715 	stw	ra,28(sp)
81136aec:	df000615 	stw	fp,24(sp)
81136af0:	df000604 	addi	fp,sp,24
81136af4:	2015883a 	mov	r10,r4
81136af8:	2809883a 	mov	r4,r5
81136afc:	3007883a 	mov	r3,r6
81136b00:	3805883a 	mov	r2,r7
81136b04:	e2bffc05 	stb	r10,-16(fp)
81136b08:	e13ffd05 	stb	r4,-12(fp)
81136b0c:	e0fffe05 	stb	r3,-8(fp)
81136b10:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136b14:	d0a09203 	ldbu	r2,-32184(gp)
81136b18:	10803fcc 	andi	r2,r2,255
81136b1c:	10000226 	beq	r2,zero,81136b28 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81136b20:	00801544 	movi	r2,85
81136b24:	00004106 	br	81136c2c <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
81136b28:	e0bffc03 	ldbu	r2,-16(fp)
81136b2c:	1000081e 	bne	r2,zero,81136b50 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81136b30:	e0bffd03 	ldbu	r2,-12(fp)
81136b34:	1000061e 	bne	r2,zero,81136b50 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
81136b38:	e0bffe03 	ldbu	r2,-8(fp)
81136b3c:	1000041e 	bne	r2,zero,81136b50 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
81136b40:	e0bfff0b 	ldhu	r2,-4(fp)
81136b44:	1000021e 	bne	r2,zero,81136b50 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
81136b48:	00801504 	movi	r2,84
81136b4c:	00003706 	br	81136c2c <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
81136b50:	e0bffd03 	ldbu	r2,-12(fp)
81136b54:	10800f30 	cmpltui	r2,r2,60
81136b58:	1000021e 	bne	r2,zero,81136b64 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
81136b5c:	00801444 	movi	r2,81
81136b60:	00003206 	br	81136c2c <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
81136b64:	e0bffe03 	ldbu	r2,-8(fp)
81136b68:	10800f30 	cmpltui	r2,r2,60
81136b6c:	1000021e 	bne	r2,zero,81136b78 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
81136b70:	00801484 	movi	r2,82
81136b74:	00002d06 	br	81136c2c <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
81136b78:	e0bfff0b 	ldhu	r2,-4(fp)
81136b7c:	1080fa30 	cmpltui	r2,r2,1000
81136b80:	1000021e 	bne	r2,zero,81136b8c <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
81136b84:	008014c4 	movi	r2,83
81136b88:	00002806 	br	81136c2c <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81136b8c:	e0bffc03 	ldbu	r2,-16(fp)
81136b90:	10c38424 	muli	r3,r2,3600
81136b94:	e0bffd03 	ldbu	r2,-12(fp)
81136b98:	10800f24 	muli	r2,r2,60
81136b9c:	1887883a 	add	r3,r3,r2
81136ba0:	e0bffe03 	ldbu	r2,-8(fp)
81136ba4:	1885883a 	add	r2,r3,r2
81136ba8:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
81136bac:	e0bfff0b 	ldhu	r2,-4(fp)
81136bb0:	10c0fa24 	muli	r3,r2,1000
81136bb4:	008418b4 	movhi	r2,4194
81136bb8:	109374c4 	addi	r2,r2,19923
81136bbc:	188a383a 	mulxuu	r5,r3,r2
81136bc0:	1885383a 	mul	r2,r3,r2
81136bc4:	1011883a 	mov	r8,r2
81136bc8:	2813883a 	mov	r9,r5
81136bcc:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81136bd0:	2085883a 	add	r2,r4,r2
81136bd4:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
81136bd8:	e0bffb17 	ldw	r2,-20(fp)
81136bdc:	1004d43a 	srli	r2,r2,16
81136be0:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
81136be4:	e0bffb17 	ldw	r2,-20(fp)
81136be8:	10bfffcc 	andi	r2,r2,65535
81136bec:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81136bf0:	e0bffb17 	ldw	r2,-20(fp)
81136bf4:	10bfffcc 	andi	r2,r2,65535
81136bf8:	1009883a 	mov	r4,r2
81136bfc:	11369d00 	call	811369d0 <OSTimeDly>
    while (loops > 0) {
81136c00:	00000706 	br	81136c20 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
81136c04:	01200014 	movui	r4,32768
81136c08:	11369d00 	call	811369d0 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81136c0c:	01200014 	movui	r4,32768
81136c10:	11369d00 	call	811369d0 <OSTimeDly>
        loops--;
81136c14:	e0bffa0b 	ldhu	r2,-24(fp)
81136c18:	10bfffc4 	addi	r2,r2,-1
81136c1c:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81136c20:	e0bffa0b 	ldhu	r2,-24(fp)
81136c24:	103ff71e 	bne	r2,zero,81136c04 <__reset+0xfb116c04>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
81136c28:	0005883a 	mov	r2,zero
}
81136c2c:	e037883a 	mov	sp,fp
81136c30:	dfc00117 	ldw	ra,4(sp)
81136c34:	df000017 	ldw	fp,0(sp)
81136c38:	dec00204 	addi	sp,sp,8
81136c3c:	f800283a 	ret

81136c40 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
81136c40:	defff504 	addi	sp,sp,-44
81136c44:	de00012e 	bgeu	sp,et,81136c4c <OSTimeDlyResume+0xc>
81136c48:	003b68fa 	trap	3
81136c4c:	dfc00a15 	stw	ra,40(sp)
81136c50:	df000915 	stw	fp,36(sp)
81136c54:	df000904 	addi	fp,sp,36
81136c58:	2005883a 	mov	r2,r4
81136c5c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81136c60:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
81136c64:	e0bfff03 	ldbu	r2,-4(fp)
81136c68:	10800a30 	cmpltui	r2,r2,40
81136c6c:	1000021e 	bne	r2,zero,81136c78 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81136c70:	00800a84 	movi	r2,42
81136c74:	00006406 	br	81136e08 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136c78:	0005303a 	rdctl	r2,status
81136c7c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136c80:	e0fffe17 	ldw	r3,-8(fp)
81136c84:	00bfff84 	movi	r2,-2
81136c88:	1884703a 	and	r2,r3,r2
81136c8c:	1001703a 	wrctl	status,r2
  
  return context;
81136c90:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81136c94:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
81136c98:	e0ffff03 	ldbu	r3,-4(fp)
81136c9c:	00a045b4 	movhi	r2,33046
81136ca0:	10882104 	addi	r2,r2,8324
81136ca4:	18c7883a 	add	r3,r3,r3
81136ca8:	18c7883a 	add	r3,r3,r3
81136cac:	10c5883a 	add	r2,r2,r3
81136cb0:	10800017 	ldw	r2,0(r2)
81136cb4:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
81136cb8:	e0bff917 	ldw	r2,-28(fp)
81136cbc:	1000061e 	bne	r2,zero,81136cd8 <OSTimeDlyResume+0x98>
81136cc0:	e0bff717 	ldw	r2,-36(fp)
81136cc4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136cc8:	e0bff817 	ldw	r2,-32(fp)
81136ccc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81136cd0:	008010c4 	movi	r2,67
81136cd4:	00004c06 	br	81136e08 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81136cd8:	e0bff917 	ldw	r2,-28(fp)
81136cdc:	10800058 	cmpnei	r2,r2,1
81136ce0:	1000061e 	bne	r2,zero,81136cfc <OSTimeDlyResume+0xbc>
81136ce4:	e0bff717 	ldw	r2,-36(fp)
81136ce8:	e0bffa15 	stw	r2,-24(fp)
81136cec:	e0bffa17 	ldw	r2,-24(fp)
81136cf0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81136cf4:	008010c4 	movi	r2,67
81136cf8:	00004306 	br	81136e08 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81136cfc:	e0bff917 	ldw	r2,-28(fp)
81136d00:	10800b8b 	ldhu	r2,46(r2)
81136d04:	10bfffcc 	andi	r2,r2,65535
81136d08:	1000061e 	bne	r2,zero,81136d24 <OSTimeDlyResume+0xe4>
81136d0c:	e0bff717 	ldw	r2,-36(fp)
81136d10:	e0bffb15 	stw	r2,-20(fp)
81136d14:	e0bffb17 	ldw	r2,-20(fp)
81136d18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81136d1c:	00801404 	movi	r2,80
81136d20:	00003906 	br	81136e08 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
81136d24:	e0bff917 	ldw	r2,-28(fp)
81136d28:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81136d2c:	e0bff917 	ldw	r2,-28(fp)
81136d30:	10800c03 	ldbu	r2,48(r2)
81136d34:	10803fcc 	andi	r2,r2,255
81136d38:	10800dcc 	andi	r2,r2,55
81136d3c:	10000b26 	beq	r2,zero,81136d6c <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
81136d40:	e0bff917 	ldw	r2,-28(fp)
81136d44:	10c00c03 	ldbu	r3,48(r2)
81136d48:	00bff204 	movi	r2,-56
81136d4c:	1884703a 	and	r2,r3,r2
81136d50:	1007883a 	mov	r3,r2
81136d54:	e0bff917 	ldw	r2,-28(fp)
81136d58:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
81136d5c:	e0bff917 	ldw	r2,-28(fp)
81136d60:	00c00044 	movi	r3,1
81136d64:	10c00c45 	stb	r3,49(r2)
81136d68:	00000206 	br	81136d74 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
81136d6c:	e0bff917 	ldw	r2,-28(fp)
81136d70:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
81136d74:	e0bff917 	ldw	r2,-28(fp)
81136d78:	10800c03 	ldbu	r2,48(r2)
81136d7c:	10803fcc 	andi	r2,r2,255
81136d80:	1080020c 	andi	r2,r2,8
81136d84:	10001b1e 	bne	r2,zero,81136df4 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
81136d88:	e0bff917 	ldw	r2,-28(fp)
81136d8c:	10c00d83 	ldbu	r3,54(r2)
81136d90:	d0a08f03 	ldbu	r2,-32196(gp)
81136d94:	1884b03a 	or	r2,r3,r2
81136d98:	d0a08f05 	stb	r2,-32196(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81136d9c:	e0bff917 	ldw	r2,-28(fp)
81136da0:	10800d03 	ldbu	r2,52(r2)
81136da4:	10c03fcc 	andi	r3,r2,255
81136da8:	e0bff917 	ldw	r2,-28(fp)
81136dac:	10800d03 	ldbu	r2,52(r2)
81136db0:	11003fcc 	andi	r4,r2,255
81136db4:	d0a08f44 	addi	r2,gp,-32195
81136db8:	2085883a 	add	r2,r4,r2
81136dbc:	11000003 	ldbu	r4,0(r2)
81136dc0:	e0bff917 	ldw	r2,-28(fp)
81136dc4:	10800d43 	ldbu	r2,53(r2)
81136dc8:	2084b03a 	or	r2,r4,r2
81136dcc:	1009883a 	mov	r4,r2
81136dd0:	d0a08f44 	addi	r2,gp,-32195
81136dd4:	1885883a 	add	r2,r3,r2
81136dd8:	11000005 	stb	r4,0(r2)
81136ddc:	e0bff717 	ldw	r2,-36(fp)
81136de0:	e0bffc15 	stw	r2,-16(fp)
81136de4:	e0bffc17 	ldw	r2,-16(fp)
81136de8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81136dec:	112fe480 	call	8112fe48 <OS_Sched>
81136df0:	00000406 	br	81136e04 <OSTimeDlyResume+0x1c4>
81136df4:	e0bff717 	ldw	r2,-36(fp)
81136df8:	e0bffd15 	stw	r2,-12(fp)
81136dfc:	e0bffd17 	ldw	r2,-12(fp)
81136e00:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
81136e04:	0005883a 	mov	r2,zero
}
81136e08:	e037883a 	mov	sp,fp
81136e0c:	dfc00117 	ldw	ra,4(sp)
81136e10:	df000017 	ldw	fp,0(sp)
81136e14:	dec00204 	addi	sp,sp,8
81136e18:	f800283a 	ret

81136e1c <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
81136e1c:	defffb04 	addi	sp,sp,-20
81136e20:	de00012e 	bgeu	sp,et,81136e28 <OSTimeGet+0xc>
81136e24:	003b68fa 	trap	3
81136e28:	df000415 	stw	fp,16(sp)
81136e2c:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136e30:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136e34:	0005303a 	rdctl	r2,status
81136e38:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136e3c:	e0fffe17 	ldw	r3,-8(fp)
81136e40:	00bfff84 	movi	r2,-2
81136e44:	1884703a 	and	r2,r3,r2
81136e48:	1001703a 	wrctl	status,r2
  
  return context;
81136e4c:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81136e50:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
81136e54:	d0a09517 	ldw	r2,-32172(gp)
81136e58:	e0bffd15 	stw	r2,-12(fp)
81136e5c:	e0bffc17 	ldw	r2,-16(fp)
81136e60:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136e64:	e0bfff17 	ldw	r2,-4(fp)
81136e68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
81136e6c:	e0bffd17 	ldw	r2,-12(fp)
}
81136e70:	e037883a 	mov	sp,fp
81136e74:	df000017 	ldw	fp,0(sp)
81136e78:	dec00104 	addi	sp,sp,4
81136e7c:	f800283a 	ret

81136e80 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
81136e80:	defffb04 	addi	sp,sp,-20
81136e84:	de00012e 	bgeu	sp,et,81136e8c <OSTimeSet+0xc>
81136e88:	003b68fa 	trap	3
81136e8c:	df000415 	stw	fp,16(sp)
81136e90:	df000404 	addi	fp,sp,16
81136e94:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136e98:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136e9c:	0005303a 	rdctl	r2,status
81136ea0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136ea4:	e0fffd17 	ldw	r3,-12(fp)
81136ea8:	00bfff84 	movi	r2,-2
81136eac:	1884703a 	and	r2,r3,r2
81136eb0:	1001703a 	wrctl	status,r2
  
  return context;
81136eb4:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81136eb8:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
81136ebc:	e0bfff17 	ldw	r2,-4(fp)
81136ec0:	d0a09515 	stw	r2,-32172(gp)
81136ec4:	e0bffc17 	ldw	r2,-16(fp)
81136ec8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136ecc:	e0bffe17 	ldw	r2,-8(fp)
81136ed0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81136ed4:	0001883a 	nop
81136ed8:	e037883a 	mov	sp,fp
81136edc:	df000017 	ldw	fp,0(sp)
81136ee0:	dec00104 	addi	sp,sp,4
81136ee4:	f800283a 	ret

81136ee8 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81136ee8:	defff804 	addi	sp,sp,-32
81136eec:	de00012e 	bgeu	sp,et,81136ef4 <OSTmrCreate+0xc>
81136ef0:	003b68fa 	trap	3
81136ef4:	dfc00715 	stw	ra,28(sp)
81136ef8:	df000615 	stw	fp,24(sp)
81136efc:	df000604 	addi	fp,sp,24
81136f00:	e13ffc15 	stw	r4,-16(fp)
81136f04:	e17ffd15 	stw	r5,-12(fp)
81136f08:	3005883a 	mov	r2,r6
81136f0c:	e1ffff15 	stw	r7,-4(fp)
81136f10:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81136f14:	e0800417 	ldw	r2,16(fp)
81136f18:	1000021e 	bne	r2,zero,81136f24 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
81136f1c:	0005883a 	mov	r2,zero
81136f20:	00005d06 	br	81137098 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
81136f24:	e0bffe03 	ldbu	r2,-8(fp)
81136f28:	10c00060 	cmpeqi	r3,r2,1
81136f2c:	1800091e 	bne	r3,zero,81136f54 <OSTmrCreate+0x6c>
81136f30:	108000a0 	cmpeqi	r2,r2,2
81136f34:	10000e26 	beq	r2,zero,81136f70 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
81136f38:	e0bffd17 	ldw	r2,-12(fp)
81136f3c:	1000111e 	bne	r2,zero,81136f84 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
81136f40:	e0800417 	ldw	r2,16(fp)
81136f44:	00ffe0c4 	movi	r3,-125
81136f48:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81136f4c:	0005883a 	mov	r2,zero
81136f50:	00005106 	br	81137098 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
81136f54:	e0bffc17 	ldw	r2,-16(fp)
81136f58:	10000c1e 	bne	r2,zero,81136f8c <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
81136f5c:	e0800417 	ldw	r2,16(fp)
81136f60:	00ffe084 	movi	r3,-126
81136f64:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81136f68:	0005883a 	mov	r2,zero
81136f6c:	00004a06 	br	81137098 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
81136f70:	e0800417 	ldw	r2,16(fp)
81136f74:	00ffe104 	movi	r3,-124
81136f78:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
81136f7c:	0005883a 	mov	r2,zero
81136f80:	00004506 	br	81137098 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
81136f84:	0001883a 	nop
81136f88:	00000106 	br	81136f90 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
81136f8c:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81136f90:	d0a09203 	ldbu	r2,-32184(gp)
81136f94:	10803fcc 	andi	r2,r2,255
81136f98:	10000526 	beq	r2,zero,81136fb0 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
81136f9c:	e0800417 	ldw	r2,16(fp)
81136fa0:	00ffe2c4 	movi	r3,-117
81136fa4:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81136fa8:	0005883a 	mov	r2,zero
81136fac:	00003a06 	br	81137098 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
81136fb0:	1137ea00 	call	81137ea0 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
81136fb4:	11379400 	call	81137940 <OSTmr_Alloc>
81136fb8:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
81136fbc:	e0bffa17 	ldw	r2,-24(fp)
81136fc0:	1000061e 	bne	r2,zero,81136fdc <OSTmrCreate+0xf4>
        OSTmr_Unlock();
81136fc4:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81136fc8:	e0800417 	ldw	r2,16(fp)
81136fcc:	00ffe184 	movi	r3,-122
81136fd0:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81136fd4:	0005883a 	mov	r2,zero
81136fd8:	00002f06 	br	81137098 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81136fdc:	e0bffa17 	ldw	r2,-24(fp)
81136fe0:	00c00044 	movi	r3,1
81136fe4:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81136fe8:	e0bffa17 	ldw	r2,-24(fp)
81136fec:	e0fffc17 	ldw	r3,-16(fp)
81136ff0:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81136ff4:	e0bffa17 	ldw	r2,-24(fp)
81136ff8:	e0fffd17 	ldw	r3,-12(fp)
81136ffc:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81137000:	e0bffa17 	ldw	r2,-24(fp)
81137004:	e0fffe03 	ldbu	r3,-8(fp)
81137008:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8113700c:	e0bffa17 	ldw	r2,-24(fp)
81137010:	e0ffff17 	ldw	r3,-4(fp)
81137014:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81137018:	e0bffa17 	ldw	r2,-24(fp)
8113701c:	e0c00217 	ldw	r3,8(fp)
81137020:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
81137024:	e0800317 	ldw	r2,12(fp)
81137028:	10001726 	beq	r2,zero,81137088 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8113702c:	e1000317 	ldw	r4,12(fp)
81137030:	11300180 	call	81130018 <OS_StrLen>
81137034:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
81137038:	e0bffb03 	ldbu	r2,-20(fp)
8113703c:	10800428 	cmpgeui	r2,r2,16
81137040:	1000061e 	bne	r2,zero,8113705c <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
81137044:	e0bffa17 	ldw	r2,-24(fp)
81137048:	10800804 	addi	r2,r2,32
8113704c:	e1400317 	ldw	r5,12(fp)
81137050:	1009883a 	mov	r4,r2
81137054:	112ff9c0 	call	8112ff9c <OS_StrCopy>
81137058:	00000b06 	br	81137088 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8113705c:	e0bffa17 	ldw	r2,-24(fp)
81137060:	00c008c4 	movi	r3,35
81137064:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
81137068:	e0bffa17 	ldw	r2,-24(fp)
8113706c:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81137070:	e0800417 	ldw	r2,16(fp)
81137074:	00ffe304 	movi	r3,-116
81137078:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8113707c:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
            return (ptmr);
81137080:	e0bffa17 	ldw	r2,-24(fp)
81137084:	00000406 	br	81137098 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81137088:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8113708c:	e0800417 	ldw	r2,16(fp)
81137090:	10000005 	stb	zero,0(r2)
    return (ptmr);
81137094:	e0bffa17 	ldw	r2,-24(fp)
}
81137098:	e037883a 	mov	sp,fp
8113709c:	dfc00117 	ldw	ra,4(sp)
811370a0:	df000017 	ldw	fp,0(sp)
811370a4:	dec00204 	addi	sp,sp,8
811370a8:	f800283a 	ret

811370ac <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
811370ac:	defffc04 	addi	sp,sp,-16
811370b0:	de00012e 	bgeu	sp,et,811370b8 <OSTmrDel+0xc>
811370b4:	003b68fa 	trap	3
811370b8:	dfc00315 	stw	ra,12(sp)
811370bc:	df000215 	stw	fp,8(sp)
811370c0:	df000204 	addi	fp,sp,8
811370c4:	e13ffe15 	stw	r4,-8(fp)
811370c8:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
811370cc:	e0bfff17 	ldw	r2,-4(fp)
811370d0:	1000021e 	bne	r2,zero,811370dc <OSTmrDel+0x30>
        return (OS_FALSE);
811370d4:	0005883a 	mov	r2,zero
811370d8:	00003f06 	br	811371d8 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
811370dc:	e0bffe17 	ldw	r2,-8(fp)
811370e0:	1000051e 	bne	r2,zero,811370f8 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811370e4:	e0bfff17 	ldw	r2,-4(fp)
811370e8:	00ffe284 	movi	r3,-118
811370ec:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811370f0:	0005883a 	mov	r2,zero
811370f4:	00003806 	br	811371d8 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
811370f8:	e0bffe17 	ldw	r2,-8(fp)
811370fc:	10800003 	ldbu	r2,0(r2)
81137100:	10803fcc 	andi	r2,r2,255
81137104:	10801920 	cmpeqi	r2,r2,100
81137108:	1000051e 	bne	r2,zero,81137120 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113710c:	e0bfff17 	ldw	r2,-4(fp)
81137110:	00ffe244 	movi	r3,-119
81137114:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137118:	0005883a 	mov	r2,zero
8113711c:	00002e06 	br	811371d8 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81137120:	d0a09203 	ldbu	r2,-32184(gp)
81137124:	10803fcc 	andi	r2,r2,255
81137128:	10000526 	beq	r2,zero,81137140 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113712c:	e0bfff17 	ldw	r2,-4(fp)
81137130:	00ffe2c4 	movi	r3,-117
81137134:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137138:	0005883a 	mov	r2,zero
8113713c:	00002606 	br	811371d8 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81137140:	1137ea00 	call	81137ea0 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81137144:	e0bffe17 	ldw	r2,-8(fp)
81137148:	10800c43 	ldbu	r2,49(r2)
8113714c:	10803fcc 	andi	r2,r2,255
81137150:	10c000c8 	cmpgei	r3,r2,3
81137154:	1800031e 	bne	r3,zero,81137164 <OSTmrDel+0xb8>
81137158:	00800d16 	blt	zero,r2,81137190 <OSTmrDel+0xe4>
8113715c:	10001326 	beq	r2,zero,811371ac <OSTmrDel+0x100>
81137160:	00001806 	br	811371c4 <OSTmrDel+0x118>
81137164:	108000e0 	cmpeqi	r2,r2,3
81137168:	10001626 	beq	r2,zero,811371c4 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8113716c:	e13ffe17 	ldw	r4,-8(fp)
81137170:	1137da40 	call	81137da4 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81137174:	e13ffe17 	ldw	r4,-8(fp)
81137178:	11379b40 	call	811379b4 <OSTmr_Free>
             OSTmr_Unlock();
8113717c:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81137180:	e0bfff17 	ldw	r2,-4(fp)
81137184:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81137188:	00800044 	movi	r2,1
8113718c:	00001206 	br	811371d8 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81137190:	e13ffe17 	ldw	r4,-8(fp)
81137194:	11379b40 	call	811379b4 <OSTmr_Free>
             OSTmr_Unlock();
81137198:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113719c:	e0bfff17 	ldw	r2,-4(fp)
811371a0:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811371a4:	00800044 	movi	r2,1
811371a8:	00000b06 	br	811371d8 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
811371ac:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811371b0:	e0bfff17 	ldw	r2,-4(fp)
811371b4:	00ffe1c4 	movi	r3,-121
811371b8:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811371bc:	0005883a 	mov	r2,zero
811371c0:	00000506 	br	811371d8 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
811371c4:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811371c8:	e0bfff17 	ldw	r2,-4(fp)
811371cc:	00ffe344 	movi	r3,-115
811371d0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811371d4:	0005883a 	mov	r2,zero
    }
}
811371d8:	e037883a 	mov	sp,fp
811371dc:	dfc00117 	ldw	ra,4(sp)
811371e0:	df000017 	ldw	fp,0(sp)
811371e4:	dec00204 	addi	sp,sp,8
811371e8:	f800283a 	ret

811371ec <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
811371ec:	defffa04 	addi	sp,sp,-24
811371f0:	de00012e 	bgeu	sp,et,811371f8 <OSTmrNameGet+0xc>
811371f4:	003b68fa 	trap	3
811371f8:	dfc00515 	stw	ra,20(sp)
811371fc:	df000415 	stw	fp,16(sp)
81137200:	df000404 	addi	fp,sp,16
81137204:	e13ffd15 	stw	r4,-12(fp)
81137208:	e17ffe15 	stw	r5,-8(fp)
8113720c:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81137210:	e0bfff17 	ldw	r2,-4(fp)
81137214:	1000021e 	bne	r2,zero,81137220 <OSTmrNameGet+0x34>
        return (0);
81137218:	0005883a 	mov	r2,zero
8113721c:	00003e06 	br	81137318 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
81137220:	e0bffe17 	ldw	r2,-8(fp)
81137224:	1000051e 	bne	r2,zero,8113723c <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
81137228:	e0bfff17 	ldw	r2,-4(fp)
8113722c:	00ffe204 	movi	r3,-120
81137230:	10c00005 	stb	r3,0(r2)
        return (0);
81137234:	0005883a 	mov	r2,zero
81137238:	00003706 	br	81137318 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113723c:	e0bffd17 	ldw	r2,-12(fp)
81137240:	1000051e 	bne	r2,zero,81137258 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
81137244:	e0bfff17 	ldw	r2,-4(fp)
81137248:	00ffe284 	movi	r3,-118
8113724c:	10c00005 	stb	r3,0(r2)
        return (0);
81137250:	0005883a 	mov	r2,zero
81137254:	00003006 	br	81137318 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81137258:	e0bffd17 	ldw	r2,-12(fp)
8113725c:	10800003 	ldbu	r2,0(r2)
81137260:	10803fcc 	andi	r2,r2,255
81137264:	10801920 	cmpeqi	r2,r2,100
81137268:	1000051e 	bne	r2,zero,81137280 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113726c:	e0bfff17 	ldw	r2,-4(fp)
81137270:	00ffe244 	movi	r3,-119
81137274:	10c00005 	stb	r3,0(r2)
        return (0);
81137278:	0005883a 	mov	r2,zero
8113727c:	00002606 	br	81137318 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81137280:	d0a09203 	ldbu	r2,-32184(gp)
81137284:	10803fcc 	andi	r2,r2,255
81137288:	10000526 	beq	r2,zero,811372a0 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8113728c:	e0bfff17 	ldw	r2,-4(fp)
81137290:	00c00444 	movi	r3,17
81137294:	10c00005 	stb	r3,0(r2)
        return (0);
81137298:	0005883a 	mov	r2,zero
8113729c:	00001e06 	br	81137318 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
811372a0:	1137ea00 	call	81137ea0 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811372a4:	e0bffd17 	ldw	r2,-12(fp)
811372a8:	10800c43 	ldbu	r2,49(r2)
811372ac:	10803fcc 	andi	r2,r2,255
811372b0:	10000e26 	beq	r2,zero,811372ec <OSTmrNameGet+0x100>
811372b4:	10001316 	blt	r2,zero,81137304 <OSTmrNameGet+0x118>
811372b8:	10800108 	cmpgei	r2,r2,4
811372bc:	1000111e 	bne	r2,zero,81137304 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
811372c0:	e0bffd17 	ldw	r2,-12(fp)
811372c4:	10800804 	addi	r2,r2,32
811372c8:	100b883a 	mov	r5,r2
811372cc:	e13ffe17 	ldw	r4,-8(fp)
811372d0:	112ff9c0 	call	8112ff9c <OS_StrCopy>
811372d4:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
811372d8:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811372dc:	e0bfff17 	ldw	r2,-4(fp)
811372e0:	10000005 	stb	zero,0(r2)
             return (len);
811372e4:	e0bffc03 	ldbu	r2,-16(fp)
811372e8:	00000b06 	br	81137318 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
811372ec:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811372f0:	e0bfff17 	ldw	r2,-4(fp)
811372f4:	00ffe1c4 	movi	r3,-121
811372f8:	10c00005 	stb	r3,0(r2)
             return (0);
811372fc:	0005883a 	mov	r2,zero
81137300:	00000506 	br	81137318 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
81137304:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81137308:	e0bfff17 	ldw	r2,-4(fp)
8113730c:	00ffe344 	movi	r3,-115
81137310:	10c00005 	stb	r3,0(r2)
             return (0);
81137314:	0005883a 	mov	r2,zero
    }
}
81137318:	e037883a 	mov	sp,fp
8113731c:	dfc00117 	ldw	ra,4(sp)
81137320:	df000017 	ldw	fp,0(sp)
81137324:	dec00204 	addi	sp,sp,8
81137328:	f800283a 	ret

8113732c <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8113732c:	defffb04 	addi	sp,sp,-20
81137330:	de00012e 	bgeu	sp,et,81137338 <OSTmrRemainGet+0xc>
81137334:	003b68fa 	trap	3
81137338:	dfc00415 	stw	ra,16(sp)
8113733c:	df000315 	stw	fp,12(sp)
81137340:	df000304 	addi	fp,sp,12
81137344:	e13ffe15 	stw	r4,-8(fp)
81137348:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113734c:	e0bfff17 	ldw	r2,-4(fp)
81137350:	1000021e 	bne	r2,zero,8113735c <OSTmrRemainGet+0x30>
        return (0);
81137354:	0005883a 	mov	r2,zero
81137358:	00005d06 	br	811374d0 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8113735c:	e0bffe17 	ldw	r2,-8(fp)
81137360:	1000051e 	bne	r2,zero,81137378 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81137364:	e0bfff17 	ldw	r2,-4(fp)
81137368:	00ffe284 	movi	r3,-118
8113736c:	10c00005 	stb	r3,0(r2)
        return (0);
81137370:	0005883a 	mov	r2,zero
81137374:	00005606 	br	811374d0 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81137378:	e0bffe17 	ldw	r2,-8(fp)
8113737c:	10800003 	ldbu	r2,0(r2)
81137380:	10803fcc 	andi	r2,r2,255
81137384:	10801920 	cmpeqi	r2,r2,100
81137388:	1000051e 	bne	r2,zero,811373a0 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113738c:	e0bfff17 	ldw	r2,-4(fp)
81137390:	00ffe244 	movi	r3,-119
81137394:	10c00005 	stb	r3,0(r2)
        return (0);
81137398:	0005883a 	mov	r2,zero
8113739c:	00004c06 	br	811374d0 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
811373a0:	d0a09203 	ldbu	r2,-32184(gp)
811373a4:	10803fcc 	andi	r2,r2,255
811373a8:	10000526 	beq	r2,zero,811373c0 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
811373ac:	e0bfff17 	ldw	r2,-4(fp)
811373b0:	00ffe2c4 	movi	r3,-117
811373b4:	10c00005 	stb	r3,0(r2)
        return (0);
811373b8:	0005883a 	mov	r2,zero
811373bc:	00004406 	br	811374d0 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
811373c0:	1137ea00 	call	81137ea0 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811373c4:	e0bffe17 	ldw	r2,-8(fp)
811373c8:	10800c43 	ldbu	r2,49(r2)
811373cc:	10803fcc 	andi	r2,r2,255
811373d0:	10c00060 	cmpeqi	r3,r2,1
811373d4:	1800121e 	bne	r3,zero,81137420 <OSTmrRemainGet+0xf4>
811373d8:	10c00088 	cmpgei	r3,r2,2
811373dc:	1800021e 	bne	r3,zero,811373e8 <OSTmrRemainGet+0xbc>
811373e0:	10003026 	beq	r2,zero,811374a4 <OSTmrRemainGet+0x178>
811373e4:	00003506 	br	811374bc <OSTmrRemainGet+0x190>
811373e8:	10c000a0 	cmpeqi	r3,r2,2
811373ec:	1800281e 	bne	r3,zero,81137490 <OSTmrRemainGet+0x164>
811373f0:	108000e0 	cmpeqi	r2,r2,3
811373f4:	10003126 	beq	r2,zero,811374bc <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
811373f8:	e0bffe17 	ldw	r2,-8(fp)
811373fc:	10c00517 	ldw	r3,20(r2)
81137400:	d0a09417 	ldw	r2,-32176(gp)
81137404:	1885c83a 	sub	r2,r3,r2
81137408:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8113740c:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
81137410:	e0bfff17 	ldw	r2,-4(fp)
81137414:	10000005 	stb	zero,0(r2)
             return (remain);
81137418:	e0bffd17 	ldw	r2,-12(fp)
8113741c:	00002c06 	br	811374d0 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
81137420:	e0bffe17 	ldw	r2,-8(fp)
81137424:	10800c03 	ldbu	r2,48(r2)
81137428:	10803fcc 	andi	r2,r2,255
8113742c:	108000a0 	cmpeqi	r2,r2,2
81137430:	10000e26 	beq	r2,zero,8113746c <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
81137434:	e0bffe17 	ldw	r2,-8(fp)
81137438:	10800617 	ldw	r2,24(r2)
8113743c:	1000041e 	bne	r2,zero,81137450 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81137440:	e0bffe17 	ldw	r2,-8(fp)
81137444:	10800717 	ldw	r2,28(r2)
81137448:	e0bffd15 	stw	r2,-12(fp)
8113744c:	00000306 	br	8113745c <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81137450:	e0bffe17 	ldw	r2,-8(fp)
81137454:	10800617 	ldw	r2,24(r2)
81137458:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8113745c:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81137460:	e0bfff17 	ldw	r2,-4(fp)
81137464:	10000005 	stb	zero,0(r2)
                      break;
81137468:	00000706 	br	81137488 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8113746c:	e0bffe17 	ldw	r2,-8(fp)
81137470:	10800617 	ldw	r2,24(r2)
81137474:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
81137478:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113747c:	e0bfff17 	ldw	r2,-4(fp)
81137480:	10000005 	stb	zero,0(r2)
                      break;
81137484:	0001883a 	nop
             }
             return (remain);
81137488:	e0bffd17 	ldw	r2,-12(fp)
8113748c:	00001006 	br	811374d0 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
81137490:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81137494:	e0bfff17 	ldw	r2,-4(fp)
81137498:	10000005 	stb	zero,0(r2)
             return (0);
8113749c:	0005883a 	mov	r2,zero
811374a0:	00000b06 	br	811374d0 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
811374a4:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811374a8:	e0bfff17 	ldw	r2,-4(fp)
811374ac:	00ffe1c4 	movi	r3,-121
811374b0:	10c00005 	stb	r3,0(r2)
             return (0);
811374b4:	0005883a 	mov	r2,zero
811374b8:	00000506 	br	811374d0 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
811374bc:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811374c0:	e0bfff17 	ldw	r2,-4(fp)
811374c4:	00ffe344 	movi	r3,-115
811374c8:	10c00005 	stb	r3,0(r2)
             return (0);
811374cc:	0005883a 	mov	r2,zero
    }
}
811374d0:	e037883a 	mov	sp,fp
811374d4:	dfc00117 	ldw	ra,4(sp)
811374d8:	df000017 	ldw	fp,0(sp)
811374dc:	dec00204 	addi	sp,sp,8
811374e0:	f800283a 	ret

811374e4 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
811374e4:	defffb04 	addi	sp,sp,-20
811374e8:	de00012e 	bgeu	sp,et,811374f0 <OSTmrStateGet+0xc>
811374ec:	003b68fa 	trap	3
811374f0:	dfc00415 	stw	ra,16(sp)
811374f4:	df000315 	stw	fp,12(sp)
811374f8:	df000304 	addi	fp,sp,12
811374fc:	e13ffe15 	stw	r4,-8(fp)
81137500:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81137504:	e0bfff17 	ldw	r2,-4(fp)
81137508:	1000021e 	bne	r2,zero,81137514 <OSTmrStateGet+0x30>
        return (0);
8113750c:	0005883a 	mov	r2,zero
81137510:	00002a06 	br	811375bc <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
81137514:	e0bffe17 	ldw	r2,-8(fp)
81137518:	1000051e 	bne	r2,zero,81137530 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113751c:	e0bfff17 	ldw	r2,-4(fp)
81137520:	00ffe284 	movi	r3,-118
81137524:	10c00005 	stb	r3,0(r2)
        return (0);
81137528:	0005883a 	mov	r2,zero
8113752c:	00002306 	br	811375bc <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81137530:	e0bffe17 	ldw	r2,-8(fp)
81137534:	10800003 	ldbu	r2,0(r2)
81137538:	10803fcc 	andi	r2,r2,255
8113753c:	10801920 	cmpeqi	r2,r2,100
81137540:	1000051e 	bne	r2,zero,81137558 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81137544:	e0bfff17 	ldw	r2,-4(fp)
81137548:	00ffe244 	movi	r3,-119
8113754c:	10c00005 	stb	r3,0(r2)
        return (0);
81137550:	0005883a 	mov	r2,zero
81137554:	00001906 	br	811375bc <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81137558:	d0a09203 	ldbu	r2,-32184(gp)
8113755c:	10803fcc 	andi	r2,r2,255
81137560:	10000526 	beq	r2,zero,81137578 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81137564:	e0bfff17 	ldw	r2,-4(fp)
81137568:	00ffe2c4 	movi	r3,-117
8113756c:	10c00005 	stb	r3,0(r2)
        return (0);
81137570:	0005883a 	mov	r2,zero
81137574:	00001106 	br	811375bc <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
81137578:	1137ea00 	call	81137ea0 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8113757c:	e0bffe17 	ldw	r2,-8(fp)
81137580:	10800c43 	ldbu	r2,49(r2)
81137584:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
81137588:	e0bffd03 	ldbu	r2,-12(fp)
8113758c:	1005883a 	mov	r2,r2
81137590:	10800128 	cmpgeui	r2,r2,4
81137594:	1000031e 	bne	r2,zero,811375a4 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
81137598:	e0bfff17 	ldw	r2,-4(fp)
8113759c:	10000005 	stb	zero,0(r2)
             break;
811375a0:	00000406 	br	811375b4 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
811375a4:	e0bfff17 	ldw	r2,-4(fp)
811375a8:	00ffe344 	movi	r3,-115
811375ac:	10c00005 	stb	r3,0(r2)
             break;
811375b0:	0001883a 	nop
    }
    OSTmr_Unlock();
811375b4:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
    return (state);
811375b8:	e0bffd03 	ldbu	r2,-12(fp)
}
811375bc:	e037883a 	mov	sp,fp
811375c0:	dfc00117 	ldw	ra,4(sp)
811375c4:	df000017 	ldw	fp,0(sp)
811375c8:	dec00204 	addi	sp,sp,8
811375cc:	f800283a 	ret

811375d0 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
811375d0:	defffc04 	addi	sp,sp,-16
811375d4:	de00012e 	bgeu	sp,et,811375dc <OSTmrStart+0xc>
811375d8:	003b68fa 	trap	3
811375dc:	dfc00315 	stw	ra,12(sp)
811375e0:	df000215 	stw	fp,8(sp)
811375e4:	df000204 	addi	fp,sp,8
811375e8:	e13ffe15 	stw	r4,-8(fp)
811375ec:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
811375f0:	e0bfff17 	ldw	r2,-4(fp)
811375f4:	1000021e 	bne	r2,zero,81137600 <OSTmrStart+0x30>
        return (OS_FALSE);
811375f8:	0005883a 	mov	r2,zero
811375fc:	00004106 	br	81137704 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
81137600:	e0bffe17 	ldw	r2,-8(fp)
81137604:	1000051e 	bne	r2,zero,8113761c <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81137608:	e0bfff17 	ldw	r2,-4(fp)
8113760c:	00ffe284 	movi	r3,-118
81137610:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137614:	0005883a 	mov	r2,zero
81137618:	00003a06 	br	81137704 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113761c:	e0bffe17 	ldw	r2,-8(fp)
81137620:	10800003 	ldbu	r2,0(r2)
81137624:	10803fcc 	andi	r2,r2,255
81137628:	10801920 	cmpeqi	r2,r2,100
8113762c:	1000051e 	bne	r2,zero,81137644 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81137630:	e0bfff17 	ldw	r2,-4(fp)
81137634:	00ffe244 	movi	r3,-119
81137638:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113763c:	0005883a 	mov	r2,zero
81137640:	00003006 	br	81137704 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81137644:	d0a09203 	ldbu	r2,-32184(gp)
81137648:	10803fcc 	andi	r2,r2,255
8113764c:	10000526 	beq	r2,zero,81137664 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
81137650:	e0bfff17 	ldw	r2,-4(fp)
81137654:	00ffe2c4 	movi	r3,-117
81137658:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113765c:	0005883a 	mov	r2,zero
81137660:	00002806 	br	81137704 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
81137664:	1137ea00 	call	81137ea0 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81137668:	e0bffe17 	ldw	r2,-8(fp)
8113766c:	10800c43 	ldbu	r2,49(r2)
81137670:	10803fcc 	andi	r2,r2,255
81137674:	10c000c8 	cmpgei	r3,r2,3
81137678:	1800031e 	bne	r3,zero,81137688 <OSTmrStart+0xb8>
8113767c:	00800e16 	blt	zero,r2,811376b8 <OSTmrStart+0xe8>
81137680:	10001526 	beq	r2,zero,811376d8 <OSTmrStart+0x108>
81137684:	00001a06 	br	811376f0 <OSTmrStart+0x120>
81137688:	108000e0 	cmpeqi	r2,r2,3
8113768c:	10001826 	beq	r2,zero,811376f0 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
81137690:	e13ffe17 	ldw	r4,-8(fp)
81137694:	1137da40 	call	81137da4 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81137698:	000b883a 	mov	r5,zero
8113769c:	e13ffe17 	ldw	r4,-8(fp)
811376a0:	1137c540 	call	81137c54 <OSTmr_Link>
             OSTmr_Unlock();
811376a4:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811376a8:	e0bfff17 	ldw	r2,-4(fp)
811376ac:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811376b0:	00800044 	movi	r2,1
811376b4:	00001306 	br	81137704 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
811376b8:	000b883a 	mov	r5,zero
811376bc:	e13ffe17 	ldw	r4,-8(fp)
811376c0:	1137c540 	call	81137c54 <OSTmr_Link>
             OSTmr_Unlock();
811376c4:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811376c8:	e0bfff17 	ldw	r2,-4(fp)
811376cc:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811376d0:	00800044 	movi	r2,1
811376d4:	00000b06 	br	81137704 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
811376d8:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811376dc:	e0bfff17 	ldw	r2,-4(fp)
811376e0:	00ffe1c4 	movi	r3,-121
811376e4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811376e8:	0005883a 	mov	r2,zero
811376ec:	00000506 	br	81137704 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
811376f0:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811376f4:	e0bfff17 	ldw	r2,-4(fp)
811376f8:	00ffe344 	movi	r3,-115
811376fc:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81137700:	0005883a 	mov	r2,zero
    }
}
81137704:	e037883a 	mov	sp,fp
81137708:	dfc00117 	ldw	ra,4(sp)
8113770c:	df000017 	ldw	fp,0(sp)
81137710:	dec00204 	addi	sp,sp,8
81137714:	f800283a 	ret

81137718 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
81137718:	defff904 	addi	sp,sp,-28
8113771c:	de00012e 	bgeu	sp,et,81137724 <OSTmrStop+0xc>
81137720:	003b68fa 	trap	3
81137724:	dfc00615 	stw	ra,24(sp)
81137728:	df000515 	stw	fp,20(sp)
8113772c:	df000504 	addi	fp,sp,20
81137730:	e13ffc15 	stw	r4,-16(fp)
81137734:	2805883a 	mov	r2,r5
81137738:	e1bffe15 	stw	r6,-8(fp)
8113773c:	e1ffff15 	stw	r7,-4(fp)
81137740:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
81137744:	e0bfff17 	ldw	r2,-4(fp)
81137748:	1000021e 	bne	r2,zero,81137754 <OSTmrStop+0x3c>
        return (OS_FALSE);
8113774c:	0005883a 	mov	r2,zero
81137750:	00006606 	br	811378ec <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
81137754:	e0bffc17 	ldw	r2,-16(fp)
81137758:	1000051e 	bne	r2,zero,81137770 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8113775c:	e0bfff17 	ldw	r2,-4(fp)
81137760:	00ffe284 	movi	r3,-118
81137764:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137768:	0005883a 	mov	r2,zero
8113776c:	00005f06 	br	811378ec <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
81137770:	e0bffc17 	ldw	r2,-16(fp)
81137774:	10800003 	ldbu	r2,0(r2)
81137778:	10803fcc 	andi	r2,r2,255
8113777c:	10801920 	cmpeqi	r2,r2,100
81137780:	1000051e 	bne	r2,zero,81137798 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81137784:	e0bfff17 	ldw	r2,-4(fp)
81137788:	00ffe244 	movi	r3,-119
8113778c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137790:	0005883a 	mov	r2,zero
81137794:	00005506 	br	811378ec <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
81137798:	d0a09203 	ldbu	r2,-32184(gp)
8113779c:	10803fcc 	andi	r2,r2,255
811377a0:	10000526 	beq	r2,zero,811377b8 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
811377a4:	e0bfff17 	ldw	r2,-4(fp)
811377a8:	00ffe2c4 	movi	r3,-117
811377ac:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811377b0:	0005883a 	mov	r2,zero
811377b4:	00004d06 	br	811378ec <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
811377b8:	1137ea00 	call	81137ea0 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811377bc:	e0bffc17 	ldw	r2,-16(fp)
811377c0:	10800c43 	ldbu	r2,49(r2)
811377c4:	10803fcc 	andi	r2,r2,255
811377c8:	10c000c8 	cmpgei	r3,r2,3
811377cc:	1800031e 	bne	r3,zero,811377dc <OSTmrStop+0xc4>
811377d0:	00803516 	blt	zero,r2,811378a8 <OSTmrStop+0x190>
811377d4:	10003a26 	beq	r2,zero,811378c0 <OSTmrStop+0x1a8>
811377d8:	00003f06 	br	811378d8 <OSTmrStop+0x1c0>
811377dc:	108000e0 	cmpeqi	r2,r2,3
811377e0:	10003d26 	beq	r2,zero,811378d8 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
811377e4:	e13ffc17 	ldw	r4,-16(fp)
811377e8:	1137da40 	call	81137da4 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
811377ec:	e0bfff17 	ldw	r2,-4(fp)
811377f0:	10000005 	stb	zero,0(r2)
             switch (opt) {
811377f4:	e0bffd03 	ldbu	r2,-12(fp)
811377f8:	10c000e0 	cmpeqi	r3,r2,3
811377fc:	1800041e 	bne	r3,zero,81137810 <OSTmrStop+0xf8>
81137800:	10c00120 	cmpeqi	r3,r2,4
81137804:	1800121e 	bne	r3,zero,81137850 <OSTmrStop+0x138>
81137808:	10002326 	beq	r2,zero,81137898 <OSTmrStop+0x180>
8113780c:	00001e06 	br	81137888 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81137810:	e0bffc17 	ldw	r2,-16(fp)
81137814:	10800117 	ldw	r2,4(r2)
81137818:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113781c:	e0bffb17 	ldw	r2,-20(fp)
81137820:	10000726 	beq	r2,zero,81137840 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
81137824:	e0bffc17 	ldw	r2,-16(fp)
81137828:	10c00217 	ldw	r3,8(r2)
8113782c:	e0bffb17 	ldw	r2,-20(fp)
81137830:	180b883a 	mov	r5,r3
81137834:	e13ffc17 	ldw	r4,-16(fp)
81137838:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113783c:	00001706 	br	8113789c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81137840:	e0bfff17 	ldw	r2,-4(fp)
81137844:	00ffe3c4 	movi	r3,-113
81137848:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113784c:	00001306 	br	8113789c <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81137850:	e0bffc17 	ldw	r2,-16(fp)
81137854:	10800117 	ldw	r2,4(r2)
81137858:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113785c:	e0bffb17 	ldw	r2,-20(fp)
81137860:	10000526 	beq	r2,zero,81137878 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
81137864:	e0bffb17 	ldw	r2,-20(fp)
81137868:	e17ffe17 	ldw	r5,-8(fp)
8113786c:	e13ffc17 	ldw	r4,-16(fp)
81137870:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81137874:	00000906 	br	8113789c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81137878:	e0bfff17 	ldw	r2,-4(fp)
8113787c:	00ffe3c4 	movi	r3,-113
81137880:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81137884:	00000506 	br	8113789c <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
81137888:	e0bfff17 	ldw	r2,-4(fp)
8113788c:	00ffe104 	movi	r3,-124
81137890:	10c00005 	stb	r3,0(r2)
                     break;
81137894:	00000106 	br	8113789c <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
81137898:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8113789c:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             return (OS_TRUE);
811378a0:	00800044 	movi	r2,1
811378a4:	00001106 	br	811378ec <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
811378a8:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
811378ac:	e0bfff17 	ldw	r2,-4(fp)
811378b0:	00ffe384 	movi	r3,-114
811378b4:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
811378b8:	00800044 	movi	r2,1
811378bc:	00000b06 	br	811378ec <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
811378c0:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811378c4:	e0bfff17 	ldw	r2,-4(fp)
811378c8:	00ffe1c4 	movi	r3,-121
811378cc:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811378d0:	0005883a 	mov	r2,zero
811378d4:	00000506 	br	811378ec <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
811378d8:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811378dc:	e0bfff17 	ldw	r2,-4(fp)
811378e0:	00ffe344 	movi	r3,-115
811378e4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
811378e8:	0005883a 	mov	r2,zero
    }
}
811378ec:	e037883a 	mov	sp,fp
811378f0:	dfc00117 	ldw	ra,4(sp)
811378f4:	df000017 	ldw	fp,0(sp)
811378f8:	dec00204 	addi	sp,sp,8
811378fc:	f800283a 	ret

81137900 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
81137900:	defffd04 	addi	sp,sp,-12
81137904:	de00012e 	bgeu	sp,et,8113790c <OSTmrSignal+0xc>
81137908:	003b68fa 	trap	3
8113790c:	dfc00215 	stw	ra,8(sp)
81137910:	df000115 	stw	fp,4(sp)
81137914:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
81137918:	d0a08117 	ldw	r2,-32252(gp)
8113791c:	1009883a 	mov	r4,r2
81137920:	11350800 	call	81135080 <OSSemPost>
81137924:	e0bfff05 	stb	r2,-4(fp)
    return (err);
81137928:	e0bfff03 	ldbu	r2,-4(fp)
}
8113792c:	e037883a 	mov	sp,fp
81137930:	dfc00117 	ldw	ra,4(sp)
81137934:	df000017 	ldw	fp,0(sp)
81137938:	dec00204 	addi	sp,sp,8
8113793c:	f800283a 	ret

81137940 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
81137940:	defffe04 	addi	sp,sp,-8
81137944:	de00012e 	bgeu	sp,et,8113794c <OSTmr_Alloc+0xc>
81137948:	003b68fa 	trap	3
8113794c:	df000115 	stw	fp,4(sp)
81137950:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
81137954:	d0a07f17 	ldw	r2,-32260(gp)
81137958:	1000021e 	bne	r2,zero,81137964 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8113795c:	0005883a 	mov	r2,zero
81137960:	00001006 	br	811379a4 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
81137964:	d0a07f17 	ldw	r2,-32260(gp)
81137968:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8113796c:	e0bfff17 	ldw	r2,-4(fp)
81137970:	10800317 	ldw	r2,12(r2)
81137974:	d0a07f15 	stw	r2,-32260(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
81137978:	e0bfff17 	ldw	r2,-4(fp)
8113797c:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
81137980:	e0bfff17 	ldw	r2,-4(fp)
81137984:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
81137988:	d0a0840b 	ldhu	r2,-32240(gp)
8113798c:	10800044 	addi	r2,r2,1
81137990:	d0a0840d 	sth	r2,-32240(gp)
    OSTmrFree--;
81137994:	d0a0880b 	ldhu	r2,-32224(gp)
81137998:	10bfffc4 	addi	r2,r2,-1
8113799c:	d0a0880d 	sth	r2,-32224(gp)
    return (ptmr);
811379a0:	e0bfff17 	ldw	r2,-4(fp)
}
811379a4:	e037883a 	mov	sp,fp
811379a8:	df000017 	ldw	fp,0(sp)
811379ac:	dec00104 	addi	sp,sp,4
811379b0:	f800283a 	ret

811379b4 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
811379b4:	defffe04 	addi	sp,sp,-8
811379b8:	de00012e 	bgeu	sp,et,811379c0 <OSTmr_Free+0xc>
811379bc:	003b68fa 	trap	3
811379c0:	df000115 	stw	fp,4(sp)
811379c4:	df000104 	addi	fp,sp,4
811379c8:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
811379cc:	e0bfff17 	ldw	r2,-4(fp)
811379d0:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
811379d4:	e0bfff17 	ldw	r2,-4(fp)
811379d8:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
811379dc:	e0bfff17 	ldw	r2,-4(fp)
811379e0:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
811379e4:	e0bfff17 	ldw	r2,-4(fp)
811379e8:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
811379ec:	e0bfff17 	ldw	r2,-4(fp)
811379f0:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
811379f4:	e0bfff17 	ldw	r2,-4(fp)
811379f8:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
811379fc:	e0bfff17 	ldw	r2,-4(fp)
81137a00:	00c00fc4 	movi	r3,63
81137a04:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
81137a08:	e0bfff17 	ldw	r2,-4(fp)
81137a0c:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
81137a10:	e0bfff17 	ldw	r2,-4(fp)
81137a14:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
81137a18:	d0e07f17 	ldw	r3,-32260(gp)
81137a1c:	e0bfff17 	ldw	r2,-4(fp)
81137a20:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
81137a24:	e0bfff17 	ldw	r2,-4(fp)
81137a28:	d0a07f15 	stw	r2,-32260(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
81137a2c:	d0a0840b 	ldhu	r2,-32240(gp)
81137a30:	10bfffc4 	addi	r2,r2,-1
81137a34:	d0a0840d 	sth	r2,-32240(gp)
    OSTmrFree++;
81137a38:	d0a0880b 	ldhu	r2,-32224(gp)
81137a3c:	10800044 	addi	r2,r2,1
81137a40:	d0a0880d 	sth	r2,-32224(gp)
}
81137a44:	0001883a 	nop
81137a48:	e037883a 	mov	sp,fp
81137a4c:	df000017 	ldw	fp,0(sp)
81137a50:	dec00104 	addi	sp,sp,4
81137a54:	f800283a 	ret

81137a58 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
81137a58:	defffa04 	addi	sp,sp,-24
81137a5c:	de00012e 	bgeu	sp,et,81137a64 <OSTmr_Init+0xc>
81137a60:	003b68fa 	trap	3
81137a64:	dfc00515 	stw	ra,20(sp)
81137a68:	df000415 	stw	fp,16(sp)
81137a6c:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
81137a70:	01406804 	movi	r5,416
81137a74:	012045b4 	movhi	r4,33046
81137a78:	21337704 	addi	r4,r4,-12836
81137a7c:	112fd7c0 	call	8112fd7c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
81137a80:	01400404 	movi	r5,16
81137a84:	012045b4 	movhi	r4,33046
81137a88:	21321304 	addi	r4,r4,-14260
81137a8c:	112fd7c0 	call	8112fd7c <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
81137a90:	00a045b4 	movhi	r2,33046
81137a94:	10b37704 	addi	r2,r2,-12836
81137a98:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
81137a9c:	00a045b4 	movhi	r2,33046
81137aa0:	10b38404 	addi	r2,r2,-12784
81137aa4:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81137aa8:	e03ffc0d 	sth	zero,-16(fp)
81137aac:	00001606 	br	81137b08 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
81137ab0:	e0bffd17 	ldw	r2,-12(fp)
81137ab4:	00c01904 	movi	r3,100
81137ab8:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
81137abc:	e0bffd17 	ldw	r2,-12(fp)
81137ac0:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
81137ac4:	e0bffd17 	ldw	r2,-12(fp)
81137ac8:	e0fffe17 	ldw	r3,-8(fp)
81137acc:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
81137ad0:	e0bffd17 	ldw	r2,-12(fp)
81137ad4:	00c00fc4 	movi	r3,63
81137ad8:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81137adc:	e0bffd17 	ldw	r2,-12(fp)
81137ae0:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
81137ae4:	e0bffd17 	ldw	r2,-12(fp)
81137ae8:	10800d04 	addi	r2,r2,52
81137aec:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81137af0:	e0bffe17 	ldw	r2,-8(fp)
81137af4:	10800d04 	addi	r2,r2,52
81137af8:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81137afc:	e0bffc0b 	ldhu	r2,-16(fp)
81137b00:	10800044 	addi	r2,r2,1
81137b04:	e0bffc0d 	sth	r2,-16(fp)
81137b08:	e0bffc0b 	ldhu	r2,-16(fp)
81137b0c:	108001f0 	cmpltui	r2,r2,7
81137b10:	103fe71e 	bne	r2,zero,81137ab0 <__reset+0xfb117ab0>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
81137b14:	e0bffd17 	ldw	r2,-12(fp)
81137b18:	00c01904 	movi	r3,100
81137b1c:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81137b20:	e0bffd17 	ldw	r2,-12(fp)
81137b24:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81137b28:	e0bffd17 	ldw	r2,-12(fp)
81137b2c:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81137b30:	e0bffd17 	ldw	r2,-12(fp)
81137b34:	00c00fc4 	movi	r3,63
81137b38:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81137b3c:	e0bffd17 	ldw	r2,-12(fp)
81137b40:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
81137b44:	d0209415 	stw	zero,-32176(gp)
    OSTmrUsed           = 0;
81137b48:	d020840d 	sth	zero,-32240(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
81137b4c:	00800204 	movi	r2,8
81137b50:	d0a0880d 	sth	r2,-32224(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
81137b54:	00a045b4 	movhi	r2,33046
81137b58:	10b37704 	addi	r2,r2,-12836
81137b5c:	d0a07f15 	stw	r2,-32260(gp)
    OSTmrSem            = OSSemCreate(1);
81137b60:	01000044 	movi	r4,1
81137b64:	11349d00 	call	811349d0 <OSSemCreate>
81137b68:	d0a09615 	stw	r2,-32168(gp)
    OSTmrSemSignal      = OSSemCreate(0);
81137b6c:	0009883a 	mov	r4,zero
81137b70:	11349d00 	call	811349d0 <OSSemCreate>
81137b74:	d0a08115 	stw	r2,-32252(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
81137b78:	d0a09617 	ldw	r2,-32168(gp)
81137b7c:	e0ffff04 	addi	r3,fp,-4
81137b80:	180d883a 	mov	r6,r3
81137b84:	01604534 	movhi	r5,33044
81137b88:	2958d504 	addi	r5,r5,25428
81137b8c:	1009883a 	mov	r4,r2
81137b90:	112e5d80 	call	8112e5d8 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
81137b94:	d0a08117 	ldw	r2,-32252(gp)
81137b98:	e0ffff04 	addi	r3,fp,-4
81137b9c:	180d883a 	mov	r6,r3
81137ba0:	01604534 	movhi	r5,33044
81137ba4:	2958da04 	addi	r5,r5,25448
81137ba8:	1009883a 	mov	r4,r2
81137bac:	112e5d80 	call	8112e5d8 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
81137bb0:	1137bcc0 	call	81137bcc <OSTmr_InitTask>
}
81137bb4:	0001883a 	nop
81137bb8:	e037883a 	mov	sp,fp
81137bbc:	dfc00117 	ldw	ra,4(sp)
81137bc0:	df000017 	ldw	fp,0(sp)
81137bc4:	dec00204 	addi	sp,sp,8
81137bc8:	f800283a 	ret

81137bcc <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81137bcc:	defff804 	addi	sp,sp,-32
81137bd0:	de00012e 	bgeu	sp,et,81137bd8 <OSTmr_InitTask+0xc>
81137bd4:	003b68fa 	trap	3
81137bd8:	dfc00715 	stw	ra,28(sp)
81137bdc:	df000615 	stw	fp,24(sp)
81137be0:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
81137be4:	008000c4 	movi	r2,3
81137be8:	d8800415 	stw	r2,16(sp)
81137bec:	d8000315 	stw	zero,12(sp)
81137bf0:	00808004 	movi	r2,512
81137bf4:	d8800215 	stw	r2,8(sp)
81137bf8:	00a045b4 	movhi	r2,33046
81137bfc:	10bb4b04 	addi	r2,r2,-4820
81137c00:	d8800115 	stw	r2,4(sp)
81137c04:	00bfff54 	movui	r2,65533
81137c08:	d8800015 	stw	r2,0(sp)
81137c0c:	01c00744 	movi	r7,29
81137c10:	01a045b4 	movhi	r6,33046
81137c14:	31bd4a04 	addi	r6,r6,-2776
81137c18:	000b883a 	mov	r5,zero
81137c1c:	012044f4 	movhi	r4,33043
81137c20:	211fc804 	addi	r4,r4,32544
81137c24:	11358b00 	call	811358b0 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81137c28:	e1bfff04 	addi	r6,fp,-4
81137c2c:	01604534 	movhi	r5,33044
81137c30:	2958df04 	addi	r5,r5,25468
81137c34:	01000744 	movi	r4,29
81137c38:	11360e00 	call	811360e0 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
81137c3c:	0001883a 	nop
81137c40:	e037883a 	mov	sp,fp
81137c44:	dfc00117 	ldw	ra,4(sp)
81137c48:	df000017 	ldw	fp,0(sp)
81137c4c:	dec00204 	addi	sp,sp,8
81137c50:	f800283a 	ret

81137c54 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
81137c54:	defffa04 	addi	sp,sp,-24
81137c58:	de00012e 	bgeu	sp,et,81137c60 <OSTmr_Link+0xc>
81137c5c:	003b68fa 	trap	3
81137c60:	df000515 	stw	fp,20(sp)
81137c64:	df000504 	addi	fp,sp,20
81137c68:	e13ffe15 	stw	r4,-8(fp)
81137c6c:	2805883a 	mov	r2,r5
81137c70:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
81137c74:	e0bffe17 	ldw	r2,-8(fp)
81137c78:	00c000c4 	movi	r3,3
81137c7c:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
81137c80:	e0bfff03 	ldbu	r2,-4(fp)
81137c84:	10800058 	cmpnei	r2,r2,1
81137c88:	1000071e 	bne	r2,zero,81137ca8 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81137c8c:	e0bffe17 	ldw	r2,-8(fp)
81137c90:	10c00717 	ldw	r3,28(r2)
81137c94:	d0a09417 	ldw	r2,-32176(gp)
81137c98:	1887883a 	add	r3,r3,r2
81137c9c:	e0bffe17 	ldw	r2,-8(fp)
81137ca0:	10c00515 	stw	r3,20(r2)
81137ca4:	00001006 	br	81137ce8 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
81137ca8:	e0bffe17 	ldw	r2,-8(fp)
81137cac:	10800617 	ldw	r2,24(r2)
81137cb0:	1000071e 	bne	r2,zero,81137cd0 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81137cb4:	e0bffe17 	ldw	r2,-8(fp)
81137cb8:	10c00717 	ldw	r3,28(r2)
81137cbc:	d0a09417 	ldw	r2,-32176(gp)
81137cc0:	1887883a 	add	r3,r3,r2
81137cc4:	e0bffe17 	ldw	r2,-8(fp)
81137cc8:	10c00515 	stw	r3,20(r2)
81137ccc:	00000606 	br	81137ce8 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
81137cd0:	e0bffe17 	ldw	r2,-8(fp)
81137cd4:	10c00617 	ldw	r3,24(r2)
81137cd8:	d0a09417 	ldw	r2,-32176(gp)
81137cdc:	1887883a 	add	r3,r3,r2
81137ce0:	e0bffe17 	ldw	r2,-8(fp)
81137ce4:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81137ce8:	e0bffe17 	ldw	r2,-8(fp)
81137cec:	10800517 	ldw	r2,20(r2)
81137cf0:	1080004c 	andi	r2,r2,1
81137cf4:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81137cf8:	e0bffb0b 	ldhu	r2,-20(fp)
81137cfc:	100690fa 	slli	r3,r2,3
81137d00:	00a045b4 	movhi	r2,33046
81137d04:	10b21304 	addi	r2,r2,-14260
81137d08:	1885883a 	add	r2,r3,r2
81137d0c:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81137d10:	e0bffc17 	ldw	r2,-16(fp)
81137d14:	10800017 	ldw	r2,0(r2)
81137d18:	1000091e 	bne	r2,zero,81137d40 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81137d1c:	e0bffc17 	ldw	r2,-16(fp)
81137d20:	e0fffe17 	ldw	r3,-8(fp)
81137d24:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81137d28:	e0bffe17 	ldw	r2,-8(fp)
81137d2c:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81137d30:	e0bffc17 	ldw	r2,-16(fp)
81137d34:	00c00044 	movi	r3,1
81137d38:	10c0010d 	sth	r3,4(r2)
81137d3c:	00001206 	br	81137d88 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
81137d40:	e0bffc17 	ldw	r2,-16(fp)
81137d44:	10800017 	ldw	r2,0(r2)
81137d48:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
81137d4c:	e0bffc17 	ldw	r2,-16(fp)
81137d50:	e0fffe17 	ldw	r3,-8(fp)
81137d54:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
81137d58:	e0bffe17 	ldw	r2,-8(fp)
81137d5c:	e0fffd17 	ldw	r3,-12(fp)
81137d60:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
81137d64:	e0bffd17 	ldw	r2,-12(fp)
81137d68:	e0fffe17 	ldw	r3,-8(fp)
81137d6c:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
81137d70:	e0bffc17 	ldw	r2,-16(fp)
81137d74:	1080010b 	ldhu	r2,4(r2)
81137d78:	10800044 	addi	r2,r2,1
81137d7c:	1007883a 	mov	r3,r2
81137d80:	e0bffc17 	ldw	r2,-16(fp)
81137d84:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
81137d88:	e0bffe17 	ldw	r2,-8(fp)
81137d8c:	10000415 	stw	zero,16(r2)
}
81137d90:	0001883a 	nop
81137d94:	e037883a 	mov	sp,fp
81137d98:	df000017 	ldw	fp,0(sp)
81137d9c:	dec00104 	addi	sp,sp,4
81137da0:	f800283a 	ret

81137da4 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
81137da4:	defffa04 	addi	sp,sp,-24
81137da8:	de00012e 	bgeu	sp,et,81137db0 <OSTmr_Unlink+0xc>
81137dac:	003b68fa 	trap	3
81137db0:	df000515 	stw	fp,20(sp)
81137db4:	df000504 	addi	fp,sp,20
81137db8:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81137dbc:	e0bfff17 	ldw	r2,-4(fp)
81137dc0:	10800517 	ldw	r2,20(r2)
81137dc4:	1080004c 	andi	r2,r2,1
81137dc8:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81137dcc:	e0bffb0b 	ldhu	r2,-20(fp)
81137dd0:	100690fa 	slli	r3,r2,3
81137dd4:	00a045b4 	movhi	r2,33046
81137dd8:	10b21304 	addi	r2,r2,-14260
81137ddc:	1885883a 	add	r2,r3,r2
81137de0:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
81137de4:	e0bffc17 	ldw	r2,-16(fp)
81137de8:	10c00017 	ldw	r3,0(r2)
81137dec:	e0bfff17 	ldw	r2,-4(fp)
81137df0:	18800b1e 	bne	r3,r2,81137e20 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
81137df4:	e0bfff17 	ldw	r2,-4(fp)
81137df8:	10800317 	ldw	r2,12(r2)
81137dfc:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
81137e00:	e0bffc17 	ldw	r2,-16(fp)
81137e04:	e0fffd17 	ldw	r3,-12(fp)
81137e08:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81137e0c:	e0bffd17 	ldw	r2,-12(fp)
81137e10:	10001126 	beq	r2,zero,81137e58 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
81137e14:	e0bffd17 	ldw	r2,-12(fp)
81137e18:	10000415 	stw	zero,16(r2)
81137e1c:	00000e06 	br	81137e58 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
81137e20:	e0bfff17 	ldw	r2,-4(fp)
81137e24:	10800417 	ldw	r2,16(r2)
81137e28:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
81137e2c:	e0bfff17 	ldw	r2,-4(fp)
81137e30:	10800317 	ldw	r2,12(r2)
81137e34:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
81137e38:	e0bffd17 	ldw	r2,-12(fp)
81137e3c:	e0fffe17 	ldw	r3,-8(fp)
81137e40:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
81137e44:	e0bffe17 	ldw	r2,-8(fp)
81137e48:	10000326 	beq	r2,zero,81137e58 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
81137e4c:	e0bffe17 	ldw	r2,-8(fp)
81137e50:	e0fffd17 	ldw	r3,-12(fp)
81137e54:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
81137e58:	e0bfff17 	ldw	r2,-4(fp)
81137e5c:	00c00044 	movi	r3,1
81137e60:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
81137e64:	e0bfff17 	ldw	r2,-4(fp)
81137e68:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
81137e6c:	e0bfff17 	ldw	r2,-4(fp)
81137e70:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
81137e74:	e0bffc17 	ldw	r2,-16(fp)
81137e78:	1080010b 	ldhu	r2,4(r2)
81137e7c:	10bfffc4 	addi	r2,r2,-1
81137e80:	1007883a 	mov	r3,r2
81137e84:	e0bffc17 	ldw	r2,-16(fp)
81137e88:	10c0010d 	sth	r3,4(r2)
}
81137e8c:	0001883a 	nop
81137e90:	e037883a 	mov	sp,fp
81137e94:	df000017 	ldw	fp,0(sp)
81137e98:	dec00104 	addi	sp,sp,4
81137e9c:	f800283a 	ret

81137ea0 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81137ea0:	defffd04 	addi	sp,sp,-12
81137ea4:	de00012e 	bgeu	sp,et,81137eac <OSTmr_Lock+0xc>
81137ea8:	003b68fa 	trap	3
81137eac:	dfc00215 	stw	ra,8(sp)
81137eb0:	df000115 	stw	fp,4(sp)
81137eb4:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81137eb8:	d0a09617 	ldw	r2,-32168(gp)
81137ebc:	e1bfff04 	addi	r6,fp,-4
81137ec0:	000b883a 	mov	r5,zero
81137ec4:	1009883a 	mov	r4,r2
81137ec8:	1134cf80 	call	81134cf8 <OSSemPend>
    (void)err;
}
81137ecc:	0001883a 	nop
81137ed0:	e037883a 	mov	sp,fp
81137ed4:	dfc00117 	ldw	ra,4(sp)
81137ed8:	df000017 	ldw	fp,0(sp)
81137edc:	dec00204 	addi	sp,sp,8
81137ee0:	f800283a 	ret

81137ee4 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
81137ee4:	defffe04 	addi	sp,sp,-8
81137ee8:	de00012e 	bgeu	sp,et,81137ef0 <OSTmr_Unlock+0xc>
81137eec:	003b68fa 	trap	3
81137ef0:	dfc00115 	stw	ra,4(sp)
81137ef4:	df000015 	stw	fp,0(sp)
81137ef8:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
81137efc:	d0a09617 	ldw	r2,-32168(gp)
81137f00:	1009883a 	mov	r4,r2
81137f04:	11350800 	call	81135080 <OSSemPost>
}
81137f08:	0001883a 	nop
81137f0c:	e037883a 	mov	sp,fp
81137f10:	dfc00117 	ldw	ra,4(sp)
81137f14:	df000017 	ldw	fp,0(sp)
81137f18:	dec00204 	addi	sp,sp,8
81137f1c:	f800283a 	ret

81137f20 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
81137f20:	defff704 	addi	sp,sp,-36
81137f24:	de00012e 	bgeu	sp,et,81137f2c <OSTmr_Task+0xc>
81137f28:	003b68fa 	trap	3
81137f2c:	dfc00815 	stw	ra,32(sp)
81137f30:	df000715 	stw	fp,28(sp)
81137f34:	df000704 	addi	fp,sp,28
81137f38:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
81137f3c:	d0a08117 	ldw	r2,-32252(gp)
81137f40:	e0fffe04 	addi	r3,fp,-8
81137f44:	180d883a 	mov	r6,r3
81137f48:	000b883a 	mov	r5,zero
81137f4c:	1009883a 	mov	r4,r2
81137f50:	1134cf80 	call	81134cf8 <OSSemPend>
        OSTmr_Lock();
81137f54:	1137ea00 	call	81137ea0 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
81137f58:	d0a09417 	ldw	r2,-32176(gp)
81137f5c:	10800044 	addi	r2,r2,1
81137f60:	d0a09415 	stw	r2,-32176(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
81137f64:	d0a09417 	ldw	r2,-32176(gp)
81137f68:	1080004c 	andi	r2,r2,1
81137f6c:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
81137f70:	e0bffa0b 	ldhu	r2,-24(fp)
81137f74:	100690fa 	slli	r3,r2,3
81137f78:	00a045b4 	movhi	r2,33046
81137f7c:	10b21304 	addi	r2,r2,-14260
81137f80:	1885883a 	add	r2,r3,r2
81137f84:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81137f88:	e0bffb17 	ldw	r2,-20(fp)
81137f8c:	10800017 	ldw	r2,0(r2)
81137f90:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
81137f94:	00002206 	br	81138020 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81137f98:	e0bff917 	ldw	r2,-28(fp)
81137f9c:	10800317 	ldw	r2,12(r2)
81137fa0:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81137fa4:	e0bff917 	ldw	r2,-28(fp)
81137fa8:	10c00517 	ldw	r3,20(r2)
81137fac:	d0a09417 	ldw	r2,-32176(gp)
81137fb0:	1880191e 	bne	r3,r2,81138018 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
81137fb4:	e0bff917 	ldw	r2,-28(fp)
81137fb8:	10800117 	ldw	r2,4(r2)
81137fbc:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
81137fc0:	e0bffd17 	ldw	r2,-12(fp)
81137fc4:	10000626 	beq	r2,zero,81137fe0 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81137fc8:	e0bff917 	ldw	r2,-28(fp)
81137fcc:	10c00217 	ldw	r3,8(r2)
81137fd0:	e0bffd17 	ldw	r2,-12(fp)
81137fd4:	180b883a 	mov	r5,r3
81137fd8:	e13ff917 	ldw	r4,-28(fp)
81137fdc:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
81137fe0:	e13ff917 	ldw	r4,-28(fp)
81137fe4:	1137da40 	call	81137da4 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81137fe8:	e0bff917 	ldw	r2,-28(fp)
81137fec:	10800c03 	ldbu	r2,48(r2)
81137ff0:	10803fcc 	andi	r2,r2,255
81137ff4:	10800098 	cmpnei	r2,r2,2
81137ff8:	1000041e 	bne	r2,zero,8113800c <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
81137ffc:	01400044 	movi	r5,1
81138000:	e13ff917 	ldw	r4,-28(fp)
81138004:	1137c540 	call	81137c54 <OSTmr_Link>
81138008:	00000306 	br	81138018 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8113800c:	e0bff917 	ldw	r2,-28(fp)
81138010:	00c00084 	movi	r3,2
81138014:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
81138018:	e0bffc17 	ldw	r2,-16(fp)
8113801c:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
81138020:	e0bff917 	ldw	r2,-28(fp)
81138024:	103fdc1e 	bne	r2,zero,81137f98 <__reset+0xfb117f98>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
81138028:	1137ee40 	call	81137ee4 <OSTmr_Unlock>
    }
8113802c:	003fc306 	br	81137f3c <__reset+0xfb117f3c>

81138030 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
81138030:	defffd04 	addi	sp,sp,-12
81138034:	de00012e 	bgeu	sp,et,8113803c <alt_dev_reg+0xc>
81138038:	003b68fa 	trap	3
8113803c:	dfc00215 	stw	ra,8(sp)
81138040:	df000115 	stw	fp,4(sp)
81138044:	df000104 	addi	fp,sp,4
81138048:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8113804c:	d1600d04 	addi	r5,gp,-32716
81138050:	e13fff17 	ldw	r4,-4(fp)
81138054:	11402d00 	call	811402d0 <alt_dev_llist_insert>
}
81138058:	e037883a 	mov	sp,fp
8113805c:	dfc00117 	ldw	ra,4(sp)
81138060:	df000017 	ldw	fp,0(sp)
81138064:	dec00204 	addi	sp,sp,8
81138068:	f800283a 	ret

8113806c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8113806c:	defffd04 	addi	sp,sp,-12
81138070:	de00012e 	bgeu	sp,et,81138078 <alt_irq_init+0xc>
81138074:	003b68fa 	trap	3
81138078:	dfc00215 	stw	ra,8(sp)
8113807c:	df000115 	stw	fp,4(sp)
81138080:	df000104 	addi	fp,sp,4
81138084:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81138088:	1140c980 	call	81140c98 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8113808c:	00800044 	movi	r2,1
81138090:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81138094:	0001883a 	nop
81138098:	e037883a 	mov	sp,fp
8113809c:	dfc00117 	ldw	ra,4(sp)
811380a0:	df000017 	ldw	fp,0(sp)
811380a4:	dec00204 	addi	sp,sp,8
811380a8:	f800283a 	ret

811380ac <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
811380ac:	defffe04 	addi	sp,sp,-8
811380b0:	de00012e 	bgeu	sp,et,811380b8 <alt_sys_init+0xc>
811380b4:	003b68fa 	trap	3
811380b8:	dfc00115 	stw	ra,4(sp)
811380bc:	df000015 	stw	fp,0(sp)
811380c0:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
811380c4:	01c0fa04 	movi	r7,1000
811380c8:	01800304 	movi	r6,12
811380cc:	000b883a 	mov	r5,zero
811380d0:	01200034 	movhi	r4,32768
811380d4:	21022004 	addi	r4,r4,2176
811380d8:	113d4040 	call	8113d404 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
811380dc:	018002c4 	movi	r6,11
811380e0:	000b883a 	mov	r5,zero
811380e4:	01204534 	movhi	r4,33044
811380e8:	211c7b04 	addi	r4,r4,29164
811380ec:	113c6f00 	call	8113c6f0 <altera_avalon_jtag_uart_init>
811380f0:	01204534 	movhi	r4,33044
811380f4:	211c7104 	addi	r4,r4,29124
811380f8:	11380300 	call	81138030 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
811380fc:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
81138100:	018003c4 	movi	r6,15
81138104:	000b883a 	mov	r5,zero
81138108:	01204574 	movhi	r4,33045
8113810c:	21209604 	addi	r4,r4,-32168
81138110:	113d5b00 	call	8113d5b0 <altera_avalon_uart_init>
81138114:	01204574 	movhi	r4,33045
81138118:	21208c04 	addi	r4,r4,-32208
8113811c:	11380300 	call	81138030 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
81138120:	00a04574 	movhi	r2,33045
81138124:	10a0c004 	addi	r2,r2,-32000
81138128:	10c00717 	ldw	r3,28(r2)
8113812c:	00a04574 	movhi	r2,33045
81138130:	10a0c004 	addi	r2,r2,-32000
81138134:	10800817 	ldw	r2,32(r2)
81138138:	100d883a 	mov	r6,r2
8113813c:	180b883a 	mov	r5,r3
81138140:	01204574 	movhi	r4,33045
81138144:	2120c004 	addi	r4,r4,-32000
81138148:	113fe380 	call	8113fe38 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8113814c:	00a04574 	movhi	r2,33045
81138150:	10a0d904 	addi	r2,r2,-31900
81138154:	10c00717 	ldw	r3,28(r2)
81138158:	00a04574 	movhi	r2,33045
8113815c:	10a0d904 	addi	r2,r2,-31900
81138160:	10800817 	ldw	r2,32(r2)
81138164:	100d883a 	mov	r6,r2
81138168:	180b883a 	mov	r5,r3
8113816c:	01204574 	movhi	r4,33045
81138170:	2120d904 	addi	r4,r4,-31900
81138174:	113fe380 	call	8113fe38 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
81138178:	01204574 	movhi	r4,33045
8113817c:	2120f204 	addi	r4,r4,-31800
81138180:	11380300 	call	81138030 <alt_dev_reg>
}
81138184:	0001883a 	nop
81138188:	e037883a 	mov	sp,fp
8113818c:	dfc00117 	ldw	ra,4(sp)
81138190:	df000017 	ldw	fp,0(sp)
81138194:	dec00204 	addi	sp,sp,8
81138198:	f800283a 	ret

8113819c <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8113819c:	defffa04 	addi	sp,sp,-24
811381a0:	de00012e 	bgeu	sp,et,811381a8 <Write_Sector_Data+0xc>
811381a4:	003b68fa 	trap	3
811381a8:	dfc00515 	stw	ra,20(sp)
811381ac:	df000415 	stw	fp,16(sp)
811381b0:	df000404 	addi	fp,sp,16
811381b4:	e13ffe15 	stw	r4,-8(fp)
811381b8:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
811381bc:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
811381c0:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
811381c4:	10001e26 	beq	r2,zero,81138240 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
811381c8:	00803fc4 	movi	r2,255
811381cc:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
811381d0:	d0a0a017 	ldw	r2,-32128(gp)
811381d4:	e13ffe17 	ldw	r4,-8(fp)
811381d8:	e0ffff17 	ldw	r3,-4(fp)
811381dc:	20c7883a 	add	r3,r4,r3
811381e0:	1806927a 	slli	r3,r3,9
811381e4:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
811381e8:	d0a09f17 	ldw	r2,-32132(gp)
811381ec:	00c00604 	movi	r3,24
811381f0:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811381f4:	d0a09c17 	ldw	r2,-32144(gp)
811381f8:	1080002b 	ldhuio	r2,0(r2)
811381fc:	10bfffcc 	andi	r2,r2,65535
81138200:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
81138204:	e0bffd0b 	ldhu	r2,-12(fp)
81138208:	10bfffcc 	andi	r2,r2,65535
8113820c:	1080010c 	andi	r2,r2,4
81138210:	103ff81e 	bne	r2,zero,811381f4 <__reset+0xfb1181f4>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
81138214:	e0bffd0b 	ldhu	r2,-12(fp)
81138218:	10bfffcc 	andi	r2,r2,65535
8113821c:	1080040c 	andi	r2,r2,16
81138220:	1000071e 	bne	r2,zero,81138240 <Write_Sector_Data+0xa4>
        {
            result = true;
81138224:	00800044 	movi	r2,1
81138228:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113822c:	d020a515 	stw	zero,-32108(gp)
            current_sector_index = sector_index+partition_offset;
81138230:	e0fffe17 	ldw	r3,-8(fp)
81138234:	e0bfff17 	ldw	r2,-4(fp)
81138238:	1885883a 	add	r2,r3,r2
8113823c:	d0a0a615 	stw	r2,-32104(gp)
        }
    }
    return result;
81138240:	e0bffc17 	ldw	r2,-16(fp)
}
81138244:	e037883a 	mov	sp,fp
81138248:	dfc00117 	ldw	ra,4(sp)
8113824c:	df000017 	ldw	fp,0(sp)
81138250:	dec00204 	addi	sp,sp,8
81138254:	f800283a 	ret

81138258 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
81138258:	defffd04 	addi	sp,sp,-12
8113825c:	de00012e 	bgeu	sp,et,81138264 <Save_Modified_Sector+0xc>
81138260:	003b68fa 	trap	3
81138264:	dfc00215 	stw	ra,8(sp)
81138268:	df000115 	stw	fp,4(sp)
8113826c:	df000104 	addi	fp,sp,4
    bool result = true;
81138270:	00800044 	movi	r2,1
81138274:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
81138278:	d0a0a517 	ldw	r2,-32108(gp)
8113827c:	10000526 	beq	r2,zero,81138294 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81138280:	d0a0a617 	ldw	r2,-32104(gp)
81138284:	000b883a 	mov	r5,zero
81138288:	1009883a 	mov	r4,r2
8113828c:	113819c0 	call	8113819c <Write_Sector_Data>
81138290:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
81138294:	e0bfff17 	ldw	r2,-4(fp)
}
81138298:	e037883a 	mov	sp,fp
8113829c:	dfc00117 	ldw	ra,4(sp)
811382a0:	df000017 	ldw	fp,0(sp)
811382a4:	dec00204 	addi	sp,sp,8
811382a8:	f800283a 	ret

811382ac <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
811382ac:	defffa04 	addi	sp,sp,-24
811382b0:	de00012e 	bgeu	sp,et,811382b8 <Read_Sector_Data+0xc>
811382b4:	003b68fa 	trap	3
811382b8:	dfc00515 	stw	ra,20(sp)
811382bc:	df000415 	stw	fp,16(sp)
811382c0:	df000404 	addi	fp,sp,16
811382c4:	e13ffe15 	stw	r4,-8(fp)
811382c8:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
811382cc:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
811382d0:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
811382d4:	10002726 	beq	r2,zero,81138374 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
811382d8:	00803fc4 	movi	r2,255
811382dc:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
811382e0:	d0a0a517 	ldw	r2,-32108(gp)
811382e4:	10000726 	beq	r2,zero,81138304 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
811382e8:	d0a0a617 	ldw	r2,-32104(gp)
811382ec:	000b883a 	mov	r5,zero
811382f0:	1009883a 	mov	r4,r2
811382f4:	113819c0 	call	8113819c <Write_Sector_Data>
811382f8:	1000021e 	bne	r2,zero,81138304 <Read_Sector_Data+0x58>
            {
                return false;
811382fc:	0005883a 	mov	r2,zero
81138300:	00001d06 	br	81138378 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81138304:	d0a0a017 	ldw	r2,-32128(gp)
81138308:	e13ffe17 	ldw	r4,-8(fp)
8113830c:	e0ffff17 	ldw	r3,-4(fp)
81138310:	20c7883a 	add	r3,r4,r3
81138314:	1806927a 	slli	r3,r3,9
81138318:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8113831c:	d0a09f17 	ldw	r2,-32132(gp)
81138320:	00c00444 	movi	r3,17
81138324:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81138328:	d0a09c17 	ldw	r2,-32144(gp)
8113832c:	1080002b 	ldhuio	r2,0(r2)
81138330:	10bfffcc 	andi	r2,r2,65535
81138334:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
81138338:	e0bffd0b 	ldhu	r2,-12(fp)
8113833c:	10bfffcc 	andi	r2,r2,65535
81138340:	1080010c 	andi	r2,r2,4
81138344:	103ff81e 	bne	r2,zero,81138328 <__reset+0xfb118328>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
81138348:	e0bffd0b 	ldhu	r2,-12(fp)
8113834c:	10bfffcc 	andi	r2,r2,65535
81138350:	1080040c 	andi	r2,r2,16
81138354:	1000071e 	bne	r2,zero,81138374 <Read_Sector_Data+0xc8>
		{
			result = true;
81138358:	00800044 	movi	r2,1
8113835c:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81138360:	d020a515 	stw	zero,-32108(gp)
            current_sector_index = sector_index+partition_offset;
81138364:	e0fffe17 	ldw	r3,-8(fp)
81138368:	e0bfff17 	ldw	r2,-4(fp)
8113836c:	1885883a 	add	r2,r3,r2
81138370:	d0a0a615 	stw	r2,-32104(gp)
		}
	}
	return result;
81138374:	e0bffc17 	ldw	r2,-16(fp)
}
81138378:	e037883a 	mov	sp,fp
8113837c:	dfc00117 	ldw	ra,4(sp)
81138380:	df000017 	ldw	fp,0(sp)
81138384:	dec00204 	addi	sp,sp,8
81138388:	f800283a 	ret

8113838c <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8113838c:	defffb04 	addi	sp,sp,-20
81138390:	de00012e 	bgeu	sp,et,81138398 <get_cluster_flag+0xc>
81138394:	003b68fa 	trap	3
81138398:	dfc00415 	stw	ra,16(sp)
8113839c:	df000315 	stw	fp,12(sp)
811383a0:	df000304 	addi	fp,sp,12
811383a4:	e13ffe15 	stw	r4,-8(fp)
811383a8:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
811383ac:	e0bffe17 	ldw	r2,-8(fp)
811383b0:	1004d23a 	srli	r2,r2,8
811383b4:	d0e0a217 	ldw	r3,-32120(gp)
811383b8:	10c5883a 	add	r2,r2,r3
811383bc:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
811383c0:	00a045b4 	movhi	r2,33046
811383c4:	10884f04 	addi	r2,r2,8508
811383c8:	10801117 	ldw	r2,68(r2)
811383cc:	e0fffd17 	ldw	r3,-12(fp)
811383d0:	1885883a 	add	r2,r3,r2
811383d4:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
811383d8:	d0a0a617 	ldw	r2,-32104(gp)
811383dc:	e0fffd17 	ldw	r3,-12(fp)
811383e0:	18800726 	beq	r3,r2,81138400 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811383e4:	e0bffd17 	ldw	r2,-12(fp)
811383e8:	000b883a 	mov	r5,zero
811383ec:	1009883a 	mov	r4,r2
811383f0:	11382ac0 	call	811382ac <Read_Sector_Data>
811383f4:	1000021e 	bne	r2,zero,81138400 <get_cluster_flag+0x74>
        {
            return false;
811383f8:	0005883a 	mov	r2,zero
811383fc:	00000d06 	br	81138434 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
81138400:	e0bffe17 	ldw	r2,-8(fp)
81138404:	10803fcc 	andi	r2,r2,255
81138408:	1085883a 	add	r2,r2,r2
8113840c:	1007883a 	mov	r3,r2
81138410:	d0a0a417 	ldw	r2,-32112(gp)
81138414:	10800a17 	ldw	r2,40(r2)
81138418:	1885883a 	add	r2,r3,r2
8113841c:	1080002b 	ldhuio	r2,0(r2)
81138420:	10bfffcc 	andi	r2,r2,65535
81138424:	1007883a 	mov	r3,r2
81138428:	e0bfff17 	ldw	r2,-4(fp)
8113842c:	10c0000d 	sth	r3,0(r2)
    return true;
81138430:	00800044 	movi	r2,1
}
81138434:	e037883a 	mov	sp,fp
81138438:	dfc00117 	ldw	ra,4(sp)
8113843c:	df000017 	ldw	fp,0(sp)
81138440:	dec00204 	addi	sp,sp,8
81138444:	f800283a 	ret

81138448 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
81138448:	defffa04 	addi	sp,sp,-24
8113844c:	de00012e 	bgeu	sp,et,81138454 <mark_cluster+0xc>
81138450:	003b68fa 	trap	3
81138454:	dfc00515 	stw	ra,20(sp)
81138458:	df000415 	stw	fp,16(sp)
8113845c:	df000404 	addi	fp,sp,16
81138460:	e13ffd15 	stw	r4,-12(fp)
81138464:	2805883a 	mov	r2,r5
81138468:	e1bfff15 	stw	r6,-4(fp)
8113846c:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81138470:	e0bffd17 	ldw	r2,-12(fp)
81138474:	1004d23a 	srli	r2,r2,8
81138478:	d0e0a217 	ldw	r3,-32120(gp)
8113847c:	10c5883a 	add	r2,r2,r3
81138480:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
81138484:	e0bfff17 	ldw	r2,-4(fp)
81138488:	10000726 	beq	r2,zero,811384a8 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113848c:	00a045b4 	movhi	r2,33046
81138490:	10884f04 	addi	r2,r2,8508
81138494:	10801117 	ldw	r2,68(r2)
81138498:	e0fffc17 	ldw	r3,-16(fp)
8113849c:	1885883a 	add	r2,r3,r2
811384a0:	e0bffc15 	stw	r2,-16(fp)
811384a4:	00000606 	br	811384c0 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
811384a8:	00a045b4 	movhi	r2,33046
811384ac:	10884f04 	addi	r2,r2,8508
811384b0:	10801217 	ldw	r2,72(r2)
811384b4:	e0fffc17 	ldw	r3,-16(fp)
811384b8:	1885883a 	add	r2,r3,r2
811384bc:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
811384c0:	d0a0a617 	ldw	r2,-32104(gp)
811384c4:	e0fffc17 	ldw	r3,-16(fp)
811384c8:	18800726 	beq	r3,r2,811384e8 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811384cc:	e0bffc17 	ldw	r2,-16(fp)
811384d0:	000b883a 	mov	r5,zero
811384d4:	1009883a 	mov	r4,r2
811384d8:	11382ac0 	call	811382ac <Read_Sector_Data>
811384dc:	1000021e 	bne	r2,zero,811384e8 <mark_cluster+0xa0>
        {
            return false;
811384e0:	0005883a 	mov	r2,zero
811384e4:	00000d06 	br	8113851c <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
811384e8:	e0bffd17 	ldw	r2,-12(fp)
811384ec:	10803fcc 	andi	r2,r2,255
811384f0:	1085883a 	add	r2,r2,r2
811384f4:	1007883a 	mov	r3,r2
811384f8:	d0a0a417 	ldw	r2,-32112(gp)
811384fc:	10800a17 	ldw	r2,40(r2)
81138500:	1885883a 	add	r2,r3,r2
81138504:	1007883a 	mov	r3,r2
81138508:	e0bffe0f 	ldh	r2,-8(fp)
8113850c:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
81138510:	00800044 	movi	r2,1
81138514:	d0a0a515 	stw	r2,-32108(gp)
    return true;
81138518:	00800044 	movi	r2,1
}
8113851c:	e037883a 	mov	sp,fp
81138520:	dfc00117 	ldw	ra,4(sp)
81138524:	df000017 	ldw	fp,0(sp)
81138528:	dec00204 	addi	sp,sp,8
8113852c:	f800283a 	ret

81138530 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
81138530:	defff704 	addi	sp,sp,-36
81138534:	de00012e 	bgeu	sp,et,8113853c <Check_for_Master_Boot_Record+0xc>
81138538:	003b68fa 	trap	3
8113853c:	dfc00815 	stw	ra,32(sp)
81138540:	df000715 	stw	fp,28(sp)
81138544:	df000704 	addi	fp,sp,28
	bool result = false;
81138548:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8113854c:	000b883a 	mov	r5,zero
81138550:	0009883a 	mov	r4,zero
81138554:	11382ac0 	call	811382ac <Read_Sector_Data>
81138558:	10005a26 	beq	r2,zero,811386c4 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8113855c:	d0a0a417 	ldw	r2,-32112(gp)
81138560:	10800a17 	ldw	r2,40(r2)
81138564:	10807f84 	addi	r2,r2,510
81138568:	1080002b 	ldhuio	r2,0(r2)
8113856c:	10bfffcc 	andi	r2,r2,65535
81138570:	10bfffcc 	andi	r2,r2,65535
81138574:	10a0001c 	xori	r2,r2,32768
81138578:	10a00004 	addi	r2,r2,-32768
8113857c:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81138580:	e0bffb17 	ldw	r2,-20(fp)
81138584:	10ffffcc 	andi	r3,r2,65535
81138588:	00aa9554 	movui	r2,43605
8113858c:	18804d1e 	bne	r3,r2,811386c4 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81138590:	e03ffa15 	stw	zero,-24(fp)
81138594:	00004806 	br	811386b8 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
81138598:	e0bffa17 	ldw	r2,-24(fp)
8113859c:	1004913a 	slli	r2,r2,4
811385a0:	10806f84 	addi	r2,r2,446
811385a4:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
811385a8:	d0a0a417 	ldw	r2,-32112(gp)
811385ac:	10c00a17 	ldw	r3,40(r2)
811385b0:	e0bffc17 	ldw	r2,-16(fp)
811385b4:	1885883a 	add	r2,r3,r2
811385b8:	10800104 	addi	r2,r2,4
811385bc:	10800023 	ldbuio	r2,0(r2)
811385c0:	10803fcc 	andi	r2,r2,255
811385c4:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
811385c8:	e0bffd07 	ldb	r2,-12(fp)
811385cc:	10800060 	cmpeqi	r2,r2,1
811385d0:	1000091e 	bne	r2,zero,811385f8 <Check_for_Master_Boot_Record+0xc8>
811385d4:	e0bffd07 	ldb	r2,-12(fp)
811385d8:	10800120 	cmpeqi	r2,r2,4
811385dc:	1000061e 	bne	r2,zero,811385f8 <Check_for_Master_Boot_Record+0xc8>
811385e0:	e0bffd07 	ldb	r2,-12(fp)
811385e4:	108001a0 	cmpeqi	r2,r2,6
811385e8:	1000031e 	bne	r2,zero,811385f8 <Check_for_Master_Boot_Record+0xc8>
811385ec:	e0bffd07 	ldb	r2,-12(fp)
811385f0:	10800398 	cmpnei	r2,r2,14
811385f4:	10002d1e 	bne	r2,zero,811386ac <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
811385f8:	d0a0a417 	ldw	r2,-32112(gp)
811385fc:	10c00a17 	ldw	r3,40(r2)
81138600:	e0bffc17 	ldw	r2,-16(fp)
81138604:	1885883a 	add	r2,r3,r2
81138608:	10800284 	addi	r2,r2,10
8113860c:	1080002b 	ldhuio	r2,0(r2)
81138610:	10bfffcc 	andi	r2,r2,65535
81138614:	1006943a 	slli	r3,r2,16
81138618:	d0a0a417 	ldw	r2,-32112(gp)
8113861c:	11000a17 	ldw	r4,40(r2)
81138620:	e0bffc17 	ldw	r2,-16(fp)
81138624:	2085883a 	add	r2,r4,r2
81138628:	10800204 	addi	r2,r2,8
8113862c:	1080002b 	ldhuio	r2,0(r2)
81138630:	10bfffcc 	andi	r2,r2,65535
81138634:	10bfffcc 	andi	r2,r2,65535
81138638:	1884b03a 	or	r2,r3,r2
8113863c:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
81138640:	d0a0a417 	ldw	r2,-32112(gp)
81138644:	10c00a17 	ldw	r3,40(r2)
81138648:	e0bffc17 	ldw	r2,-16(fp)
8113864c:	1885883a 	add	r2,r3,r2
81138650:	10800384 	addi	r2,r2,14
81138654:	1080002b 	ldhuio	r2,0(r2)
81138658:	10bfffcc 	andi	r2,r2,65535
8113865c:	1006943a 	slli	r3,r2,16
81138660:	d0a0a417 	ldw	r2,-32112(gp)
81138664:	11000a17 	ldw	r4,40(r2)
81138668:	e0bffc17 	ldw	r2,-16(fp)
8113866c:	2085883a 	add	r2,r4,r2
81138670:	10800304 	addi	r2,r2,12
81138674:	1080002b 	ldhuio	r2,0(r2)
81138678:	10bfffcc 	andi	r2,r2,65535
8113867c:	10bfffcc 	andi	r2,r2,65535
81138680:	1884b03a 	or	r2,r3,r2
81138684:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
81138688:	e0bfff17 	ldw	r2,-4(fp)
8113868c:	0080070e 	bge	zero,r2,811386ac <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
81138690:	00800044 	movi	r2,1
81138694:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
81138698:	e0bfff17 	ldw	r2,-4(fp)
8113869c:	d0a0a315 	stw	r2,-32116(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
811386a0:	e0bffe17 	ldw	r2,-8(fp)
811386a4:	d0a0a215 	stw	r2,-32120(gp)
						break;
811386a8:	00000606 	br	811386c4 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
811386ac:	e0bffa17 	ldw	r2,-24(fp)
811386b0:	10800044 	addi	r2,r2,1
811386b4:	e0bffa15 	stw	r2,-24(fp)
811386b8:	e0bffa17 	ldw	r2,-24(fp)
811386bc:	10800110 	cmplti	r2,r2,4
811386c0:	103fb51e 	bne	r2,zero,81138598 <__reset+0xfb118598>
				}
			}
		}
	}

	return result;
811386c4:	e0bff917 	ldw	r2,-28(fp)
}
811386c8:	e037883a 	mov	sp,fp
811386cc:	dfc00117 	ldw	ra,4(sp)
811386d0:	df000017 	ldw	fp,0(sp)
811386d4:	dec00204 	addi	sp,sp,8
811386d8:	f800283a 	ret

811386dc <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
811386dc:	defff804 	addi	sp,sp,-32
811386e0:	de00012e 	bgeu	sp,et,811386e8 <Read_File_Record_At_Offset+0xc>
811386e4:	003b68fa 	trap	3
811386e8:	dfc00715 	stw	ra,28(sp)
811386ec:	df000615 	stw	fp,24(sp)
811386f0:	df000604 	addi	fp,sp,24
811386f4:	e13ffc15 	stw	r4,-16(fp)
811386f8:	e17ffd15 	stw	r5,-12(fp)
811386fc:	e1bffe15 	stw	r6,-8(fp)
81138700:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
81138704:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81138708:	e0bffc17 	ldw	r2,-16(fp)
8113870c:	108007cc 	andi	r2,r2,31
81138710:	10008d1e 	bne	r2,zero,81138948 <Read_File_Record_At_Offset+0x26c>
81138714:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
81138718:	10008b26 	beq	r2,zero,81138948 <Read_File_Record_At_Offset+0x26c>
8113871c:	d0a09b17 	ldw	r2,-32148(gp)
81138720:	10008926 	beq	r2,zero,81138948 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
81138724:	e03ffb15 	stw	zero,-20(fp)
81138728:	00001106 	br	81138770 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
8113872c:	e0fffc17 	ldw	r3,-16(fp)
81138730:	e0bffb17 	ldw	r2,-20(fp)
81138734:	1885883a 	add	r2,r3,r2
81138738:	1007883a 	mov	r3,r2
8113873c:	d0a0a417 	ldw	r2,-32112(gp)
81138740:	10800a17 	ldw	r2,40(r2)
81138744:	1885883a 	add	r2,r3,r2
81138748:	10800023 	ldbuio	r2,0(r2)
8113874c:	10803fcc 	andi	r2,r2,255
81138750:	1009883a 	mov	r4,r2
81138754:	e0fffd17 	ldw	r3,-12(fp)
81138758:	e0bffb17 	ldw	r2,-20(fp)
8113875c:	1885883a 	add	r2,r3,r2
81138760:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
81138764:	e0bffb17 	ldw	r2,-20(fp)
81138768:	10800044 	addi	r2,r2,1
8113876c:	e0bffb15 	stw	r2,-20(fp)
81138770:	e0bffb17 	ldw	r2,-20(fp)
81138774:	10800210 	cmplti	r2,r2,8
81138778:	103fec1e 	bne	r2,zero,8113872c <__reset+0xfb11872c>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113877c:	e03ffb15 	stw	zero,-20(fp)
81138780:	00001306 	br	811387d0 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
81138784:	e0fffc17 	ldw	r3,-16(fp)
81138788:	e0bffb17 	ldw	r2,-20(fp)
8113878c:	1885883a 	add	r2,r3,r2
81138790:	1007883a 	mov	r3,r2
81138794:	d0a0a417 	ldw	r2,-32112(gp)
81138798:	10800a17 	ldw	r2,40(r2)
8113879c:	1885883a 	add	r2,r3,r2
811387a0:	10800204 	addi	r2,r2,8
811387a4:	10800023 	ldbuio	r2,0(r2)
811387a8:	10803fcc 	andi	r2,r2,255
811387ac:	1009883a 	mov	r4,r2
811387b0:	e0fffd17 	ldw	r3,-12(fp)
811387b4:	e0bffb17 	ldw	r2,-20(fp)
811387b8:	1885883a 	add	r2,r3,r2
811387bc:	10800204 	addi	r2,r2,8
811387c0:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
811387c4:	e0bffb17 	ldw	r2,-20(fp)
811387c8:	10800044 	addi	r2,r2,1
811387cc:	e0bffb15 	stw	r2,-20(fp)
811387d0:	e0bffb17 	ldw	r2,-20(fp)
811387d4:	108000d0 	cmplti	r2,r2,3
811387d8:	103fea1e 	bne	r2,zero,81138784 <__reset+0xfb118784>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
811387dc:	d0a0a417 	ldw	r2,-32112(gp)
811387e0:	10c00a17 	ldw	r3,40(r2)
811387e4:	e0bffc17 	ldw	r2,-16(fp)
811387e8:	1885883a 	add	r2,r3,r2
811387ec:	108002c4 	addi	r2,r2,11
811387f0:	10800023 	ldbuio	r2,0(r2)
811387f4:	10803fcc 	andi	r2,r2,255
811387f8:	1007883a 	mov	r3,r2
811387fc:	e0bffd17 	ldw	r2,-12(fp)
81138800:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
81138804:	d0a0a417 	ldw	r2,-32112(gp)
81138808:	10c00a17 	ldw	r3,40(r2)
8113880c:	e0bffc17 	ldw	r2,-16(fp)
81138810:	1885883a 	add	r2,r3,r2
81138814:	10800384 	addi	r2,r2,14
81138818:	1080002b 	ldhuio	r2,0(r2)
8113881c:	10bfffcc 	andi	r2,r2,65535
81138820:	1007883a 	mov	r3,r2
81138824:	e0bffd17 	ldw	r2,-12(fp)
81138828:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
8113882c:	d0a0a417 	ldw	r2,-32112(gp)
81138830:	10c00a17 	ldw	r3,40(r2)
81138834:	e0bffc17 	ldw	r2,-16(fp)
81138838:	1885883a 	add	r2,r3,r2
8113883c:	10800404 	addi	r2,r2,16
81138840:	1080002b 	ldhuio	r2,0(r2)
81138844:	10bfffcc 	andi	r2,r2,65535
81138848:	1007883a 	mov	r3,r2
8113884c:	e0bffd17 	ldw	r2,-12(fp)
81138850:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
81138854:	d0a0a417 	ldw	r2,-32112(gp)
81138858:	10c00a17 	ldw	r3,40(r2)
8113885c:	e0bffc17 	ldw	r2,-16(fp)
81138860:	1885883a 	add	r2,r3,r2
81138864:	10800484 	addi	r2,r2,18
81138868:	1080002b 	ldhuio	r2,0(r2)
8113886c:	10bfffcc 	andi	r2,r2,65535
81138870:	1007883a 	mov	r3,r2
81138874:	e0bffd17 	ldw	r2,-12(fp)
81138878:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
8113887c:	d0a0a417 	ldw	r2,-32112(gp)
81138880:	10c00a17 	ldw	r3,40(r2)
81138884:	e0bffc17 	ldw	r2,-16(fp)
81138888:	1885883a 	add	r2,r3,r2
8113888c:	10800584 	addi	r2,r2,22
81138890:	1080002b 	ldhuio	r2,0(r2)
81138894:	10bfffcc 	andi	r2,r2,65535
81138898:	1007883a 	mov	r3,r2
8113889c:	e0bffd17 	ldw	r2,-12(fp)
811388a0:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
811388a4:	d0a0a417 	ldw	r2,-32112(gp)
811388a8:	10c00a17 	ldw	r3,40(r2)
811388ac:	e0bffc17 	ldw	r2,-16(fp)
811388b0:	1885883a 	add	r2,r3,r2
811388b4:	10800604 	addi	r2,r2,24
811388b8:	1080002b 	ldhuio	r2,0(r2)
811388bc:	10bfffcc 	andi	r2,r2,65535
811388c0:	1007883a 	mov	r3,r2
811388c4:	e0bffd17 	ldw	r2,-12(fp)
811388c8:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
811388cc:	d0a0a417 	ldw	r2,-32112(gp)
811388d0:	10c00a17 	ldw	r3,40(r2)
811388d4:	e0bffc17 	ldw	r2,-16(fp)
811388d8:	1885883a 	add	r2,r3,r2
811388dc:	10800684 	addi	r2,r2,26
811388e0:	1080002b 	ldhuio	r2,0(r2)
811388e4:	10bfffcc 	andi	r2,r2,65535
811388e8:	1007883a 	mov	r3,r2
811388ec:	e0bffd17 	ldw	r2,-12(fp)
811388f0:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
811388f4:	d0a0a417 	ldw	r2,-32112(gp)
811388f8:	10c00a17 	ldw	r3,40(r2)
811388fc:	e0bffc17 	ldw	r2,-16(fp)
81138900:	1885883a 	add	r2,r3,r2
81138904:	10800704 	addi	r2,r2,28
81138908:	10800037 	ldwio	r2,0(r2)
8113890c:	1007883a 	mov	r3,r2
81138910:	e0bffd17 	ldw	r2,-12(fp)
81138914:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
81138918:	e0bffd17 	ldw	r2,-12(fp)
8113891c:	e0fffe17 	ldw	r3,-8(fp)
81138920:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
81138924:	e0bffd17 	ldw	r2,-12(fp)
81138928:	e0ffff17 	ldw	r3,-4(fp)
8113892c:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81138930:	e0bffc17 	ldw	r2,-16(fp)
81138934:	1007883a 	mov	r3,r2
81138938:	e0bffd17 	ldw	r2,-12(fp)
8113893c:	10c00c0d 	sth	r3,48(r2)
		result = true;
81138940:	00800044 	movi	r2,1
81138944:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
81138948:	e0bffa17 	ldw	r2,-24(fp)
}
8113894c:	e037883a 	mov	sp,fp
81138950:	dfc00117 	ldw	ra,4(sp)
81138954:	df000017 	ldw	fp,0(sp)
81138958:	dec00204 	addi	sp,sp,8
8113895c:	f800283a 	ret

81138960 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81138960:	defff904 	addi	sp,sp,-28
81138964:	de00012e 	bgeu	sp,et,8113896c <Write_File_Record_At_Offset+0xc>
81138968:	003b68fa 	trap	3
8113896c:	dfc00615 	stw	ra,24(sp)
81138970:	df000515 	stw	fp,20(sp)
81138974:	df000504 	addi	fp,sp,20
81138978:	e13ffe15 	stw	r4,-8(fp)
8113897c:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81138980:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81138984:	e0bffe17 	ldw	r2,-8(fp)
81138988:	108007cc 	andi	r2,r2,31
8113898c:	1000931e 	bne	r2,zero,81138bdc <Write_File_Record_At_Offset+0x27c>
81138990:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
81138994:	10009126 	beq	r2,zero,81138bdc <Write_File_Record_At_Offset+0x27c>
81138998:	d0a09b17 	ldw	r2,-32148(gp)
8113899c:	10008f26 	beq	r2,zero,81138bdc <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
811389a0:	e03ffc15 	stw	zero,-16(fp)
811389a4:	00001f06 	br	81138a24 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
811389a8:	e0bffc17 	ldw	r2,-16(fp)
811389ac:	10800044 	addi	r2,r2,1
811389b0:	e0ffff17 	ldw	r3,-4(fp)
811389b4:	1885883a 	add	r2,r3,r2
811389b8:	10800003 	ldbu	r2,0(r2)
811389bc:	10803fcc 	andi	r2,r2,255
811389c0:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
811389c4:	e0bffd0f 	ldh	r2,-12(fp)
811389c8:	1004923a 	slli	r2,r2,8
811389cc:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
811389d0:	e0ffff17 	ldw	r3,-4(fp)
811389d4:	e0bffc17 	ldw	r2,-16(fp)
811389d8:	1885883a 	add	r2,r3,r2
811389dc:	10800003 	ldbu	r2,0(r2)
811389e0:	10c03fcc 	andi	r3,r2,255
811389e4:	e0bffd0b 	ldhu	r2,-12(fp)
811389e8:	1884b03a 	or	r2,r3,r2
811389ec:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
811389f0:	e0fffe17 	ldw	r3,-8(fp)
811389f4:	e0bffc17 	ldw	r2,-16(fp)
811389f8:	1885883a 	add	r2,r3,r2
811389fc:	1007883a 	mov	r3,r2
81138a00:	d0a0a417 	ldw	r2,-32112(gp)
81138a04:	10800a17 	ldw	r2,40(r2)
81138a08:	1885883a 	add	r2,r3,r2
81138a0c:	1007883a 	mov	r3,r2
81138a10:	e0bffd0f 	ldh	r2,-12(fp)
81138a14:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81138a18:	e0bffc17 	ldw	r2,-16(fp)
81138a1c:	10800084 	addi	r2,r2,2
81138a20:	e0bffc15 	stw	r2,-16(fp)
81138a24:	e0bffc17 	ldw	r2,-16(fp)
81138a28:	10800210 	cmplti	r2,r2,8
81138a2c:	103fde1e 	bne	r2,zero,811389a8 <__reset+0xfb1189a8>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81138a30:	e03ffc15 	stw	zero,-16(fp)
81138a34:	00001306 	br	81138a84 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
81138a38:	e0fffe17 	ldw	r3,-8(fp)
81138a3c:	e0bffc17 	ldw	r2,-16(fp)
81138a40:	1885883a 	add	r2,r3,r2
81138a44:	1007883a 	mov	r3,r2
81138a48:	d0a0a417 	ldw	r2,-32112(gp)
81138a4c:	10800a17 	ldw	r2,40(r2)
81138a50:	1885883a 	add	r2,r3,r2
81138a54:	10800204 	addi	r2,r2,8
81138a58:	1009883a 	mov	r4,r2
81138a5c:	e0ffff17 	ldw	r3,-4(fp)
81138a60:	e0bffc17 	ldw	r2,-16(fp)
81138a64:	1885883a 	add	r2,r3,r2
81138a68:	10800204 	addi	r2,r2,8
81138a6c:	10800003 	ldbu	r2,0(r2)
81138a70:	10803fcc 	andi	r2,r2,255
81138a74:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81138a78:	e0bffc17 	ldw	r2,-16(fp)
81138a7c:	10800044 	addi	r2,r2,1
81138a80:	e0bffc15 	stw	r2,-16(fp)
81138a84:	e0bffc17 	ldw	r2,-16(fp)
81138a88:	108000d0 	cmplti	r2,r2,3
81138a8c:	103fea1e 	bne	r2,zero,81138a38 <__reset+0xfb118a38>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
81138a90:	d0a0a417 	ldw	r2,-32112(gp)
81138a94:	10c00a17 	ldw	r3,40(r2)
81138a98:	e0bffe17 	ldw	r2,-8(fp)
81138a9c:	1885883a 	add	r2,r3,r2
81138aa0:	108002c4 	addi	r2,r2,11
81138aa4:	1007883a 	mov	r3,r2
81138aa8:	e0bfff17 	ldw	r2,-4(fp)
81138aac:	108002c3 	ldbu	r2,11(r2)
81138ab0:	10803fcc 	andi	r2,r2,255
81138ab4:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
81138ab8:	d0a0a417 	ldw	r2,-32112(gp)
81138abc:	10c00a17 	ldw	r3,40(r2)
81138ac0:	e0bffe17 	ldw	r2,-8(fp)
81138ac4:	1885883a 	add	r2,r3,r2
81138ac8:	10800384 	addi	r2,r2,14
81138acc:	1007883a 	mov	r3,r2
81138ad0:	e0bfff17 	ldw	r2,-4(fp)
81138ad4:	1080030b 	ldhu	r2,12(r2)
81138ad8:	10bfffcc 	andi	r2,r2,65535
81138adc:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81138ae0:	d0a0a417 	ldw	r2,-32112(gp)
81138ae4:	10c00a17 	ldw	r3,40(r2)
81138ae8:	e0bffe17 	ldw	r2,-8(fp)
81138aec:	1885883a 	add	r2,r3,r2
81138af0:	10800404 	addi	r2,r2,16
81138af4:	1007883a 	mov	r3,r2
81138af8:	e0bfff17 	ldw	r2,-4(fp)
81138afc:	1080038b 	ldhu	r2,14(r2)
81138b00:	10bfffcc 	andi	r2,r2,65535
81138b04:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81138b08:	d0a0a417 	ldw	r2,-32112(gp)
81138b0c:	10c00a17 	ldw	r3,40(r2)
81138b10:	e0bffe17 	ldw	r2,-8(fp)
81138b14:	1885883a 	add	r2,r3,r2
81138b18:	10800484 	addi	r2,r2,18
81138b1c:	1007883a 	mov	r3,r2
81138b20:	e0bfff17 	ldw	r2,-4(fp)
81138b24:	1080040b 	ldhu	r2,16(r2)
81138b28:	10bfffcc 	andi	r2,r2,65535
81138b2c:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81138b30:	d0a0a417 	ldw	r2,-32112(gp)
81138b34:	10c00a17 	ldw	r3,40(r2)
81138b38:	e0bffe17 	ldw	r2,-8(fp)
81138b3c:	1885883a 	add	r2,r3,r2
81138b40:	10800584 	addi	r2,r2,22
81138b44:	1007883a 	mov	r3,r2
81138b48:	e0bfff17 	ldw	r2,-4(fp)
81138b4c:	1080048b 	ldhu	r2,18(r2)
81138b50:	10bfffcc 	andi	r2,r2,65535
81138b54:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81138b58:	d0a0a417 	ldw	r2,-32112(gp)
81138b5c:	10c00a17 	ldw	r3,40(r2)
81138b60:	e0bffe17 	ldw	r2,-8(fp)
81138b64:	1885883a 	add	r2,r3,r2
81138b68:	10800604 	addi	r2,r2,24
81138b6c:	1007883a 	mov	r3,r2
81138b70:	e0bfff17 	ldw	r2,-4(fp)
81138b74:	1080050b 	ldhu	r2,20(r2)
81138b78:	10bfffcc 	andi	r2,r2,65535
81138b7c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
81138b80:	d0a0a417 	ldw	r2,-32112(gp)
81138b84:	10c00a17 	ldw	r3,40(r2)
81138b88:	e0bffe17 	ldw	r2,-8(fp)
81138b8c:	1885883a 	add	r2,r3,r2
81138b90:	10800684 	addi	r2,r2,26
81138b94:	1007883a 	mov	r3,r2
81138b98:	e0bfff17 	ldw	r2,-4(fp)
81138b9c:	1080058b 	ldhu	r2,22(r2)
81138ba0:	10bfffcc 	andi	r2,r2,65535
81138ba4:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81138ba8:	d0a0a417 	ldw	r2,-32112(gp)
81138bac:	10c00a17 	ldw	r3,40(r2)
81138bb0:	e0bffe17 	ldw	r2,-8(fp)
81138bb4:	1885883a 	add	r2,r3,r2
81138bb8:	10800704 	addi	r2,r2,28
81138bbc:	1007883a 	mov	r3,r2
81138bc0:	e0bfff17 	ldw	r2,-4(fp)
81138bc4:	10800617 	ldw	r2,24(r2)
81138bc8:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81138bcc:	00800044 	movi	r2,1
81138bd0:	d0a0a515 	stw	r2,-32108(gp)
        result = true;
81138bd4:	00800044 	movi	r2,1
81138bd8:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81138bdc:	e0bffb17 	ldw	r2,-20(fp)
}
81138be0:	e037883a 	mov	sp,fp
81138be4:	dfc00117 	ldw	ra,4(sp)
81138be8:	df000017 	ldw	fp,0(sp)
81138bec:	dec00204 	addi	sp,sp,8
81138bf0:	f800283a 	ret

81138bf4 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
81138bf4:	defff904 	addi	sp,sp,-28
81138bf8:	de00012e 	bgeu	sp,et,81138c00 <Check_for_DOS_FAT+0xc>
81138bfc:	003b68fa 	trap	3
81138c00:	dfc00615 	stw	ra,24(sp)
81138c04:	df000515 	stw	fp,20(sp)
81138c08:	df000504 	addi	fp,sp,20
81138c0c:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81138c10:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
81138c14:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81138c18:	e17fff17 	ldw	r5,-4(fp)
81138c1c:	0009883a 	mov	r4,zero
81138c20:	11382ac0 	call	811382ac <Read_Sector_Data>
81138c24:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81138c28:	d0a0a417 	ldw	r2,-32112(gp)
81138c2c:	10800a17 	ldw	r2,40(r2)
81138c30:	10807f84 	addi	r2,r2,510
81138c34:	1080002b 	ldhuio	r2,0(r2)
81138c38:	10bfffcc 	andi	r2,r2,65535
81138c3c:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81138c40:	e0bffe0f 	ldh	r2,-8(fp)
81138c44:	10ffffcc 	andi	r3,r2,65535
81138c48:	00aa9554 	movui	r2,43605
81138c4c:	1881841e 	bne	r3,r2,81139260 <Check_for_DOS_FAT+0x66c>
81138c50:	e0bffb17 	ldw	r2,-20(fp)
81138c54:	10018226 	beq	r2,zero,81139260 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81138c58:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81138c5c:	d0a0a417 	ldw	r2,-32112(gp)
81138c60:	10800a17 	ldw	r2,40(r2)
81138c64:	10800023 	ldbuio	r2,0(r2)
81138c68:	10803fcc 	andi	r2,r2,255
81138c6c:	1007883a 	mov	r3,r2
81138c70:	00a045b4 	movhi	r2,33046
81138c74:	10884f04 	addi	r2,r2,8508
81138c78:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
81138c7c:	d0a0a417 	ldw	r2,-32112(gp)
81138c80:	10800a17 	ldw	r2,40(r2)
81138c84:	10800044 	addi	r2,r2,1
81138c88:	10800023 	ldbuio	r2,0(r2)
81138c8c:	10803fcc 	andi	r2,r2,255
81138c90:	1007883a 	mov	r3,r2
81138c94:	00a045b4 	movhi	r2,33046
81138c98:	10884f04 	addi	r2,r2,8508
81138c9c:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
81138ca0:	d0a0a417 	ldw	r2,-32112(gp)
81138ca4:	10800a17 	ldw	r2,40(r2)
81138ca8:	10800084 	addi	r2,r2,2
81138cac:	10800023 	ldbuio	r2,0(r2)
81138cb0:	10803fcc 	andi	r2,r2,255
81138cb4:	1007883a 	mov	r3,r2
81138cb8:	00a045b4 	movhi	r2,33046
81138cbc:	10884f04 	addi	r2,r2,8508
81138cc0:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
81138cc4:	e03ffc15 	stw	zero,-16(fp)
81138cc8:	00001106 	br	81138d10 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81138ccc:	d0a0a417 	ldw	r2,-32112(gp)
81138cd0:	10c00a17 	ldw	r3,40(r2)
81138cd4:	e0bffc17 	ldw	r2,-16(fp)
81138cd8:	1885883a 	add	r2,r3,r2
81138cdc:	108000c4 	addi	r2,r2,3
81138ce0:	10800023 	ldbuio	r2,0(r2)
81138ce4:	10803fcc 	andi	r2,r2,255
81138ce8:	1009883a 	mov	r4,r2
81138cec:	00a045b4 	movhi	r2,33046
81138cf0:	10884f04 	addi	r2,r2,8508
81138cf4:	e0fffc17 	ldw	r3,-16(fp)
81138cf8:	10c5883a 	add	r2,r2,r3
81138cfc:	108000c4 	addi	r2,r2,3
81138d00:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81138d04:	e0bffc17 	ldw	r2,-16(fp)
81138d08:	10800044 	addi	r2,r2,1
81138d0c:	e0bffc15 	stw	r2,-16(fp)
81138d10:	e0bffc17 	ldw	r2,-16(fp)
81138d14:	10800210 	cmplti	r2,r2,8
81138d18:	103fec1e 	bne	r2,zero,81138ccc <__reset+0xfb118ccc>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81138d1c:	d0a0a417 	ldw	r2,-32112(gp)
81138d20:	10800a17 	ldw	r2,40(r2)
81138d24:	10800304 	addi	r2,r2,12
81138d28:	10800023 	ldbuio	r2,0(r2)
81138d2c:	10803fcc 	andi	r2,r2,255
81138d30:	1004923a 	slli	r2,r2,8
81138d34:	1007883a 	mov	r3,r2
81138d38:	d0a0a417 	ldw	r2,-32112(gp)
81138d3c:	10800a17 	ldw	r2,40(r2)
81138d40:	108002c4 	addi	r2,r2,11
81138d44:	10800023 	ldbuio	r2,0(r2)
81138d48:	10803fcc 	andi	r2,r2,255
81138d4c:	10803fcc 	andi	r2,r2,255
81138d50:	1080201c 	xori	r2,r2,128
81138d54:	10bfe004 	addi	r2,r2,-128
81138d58:	1884b03a 	or	r2,r3,r2
81138d5c:	1007883a 	mov	r3,r2
81138d60:	00a045b4 	movhi	r2,33046
81138d64:	10884f04 	addi	r2,r2,8508
81138d68:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
81138d6c:	d0a0a417 	ldw	r2,-32112(gp)
81138d70:	10800a17 	ldw	r2,40(r2)
81138d74:	10800344 	addi	r2,r2,13
81138d78:	10800023 	ldbuio	r2,0(r2)
81138d7c:	10803fcc 	andi	r2,r2,255
81138d80:	1007883a 	mov	r3,r2
81138d84:	00a045b4 	movhi	r2,33046
81138d88:	10884f04 	addi	r2,r2,8508
81138d8c:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
81138d90:	d0a0a417 	ldw	r2,-32112(gp)
81138d94:	10800a17 	ldw	r2,40(r2)
81138d98:	10800384 	addi	r2,r2,14
81138d9c:	1080002b 	ldhuio	r2,0(r2)
81138da0:	10bfffcc 	andi	r2,r2,65535
81138da4:	1007883a 	mov	r3,r2
81138da8:	00a045b4 	movhi	r2,33046
81138dac:	10884f04 	addi	r2,r2,8508
81138db0:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
81138db4:	d0a0a417 	ldw	r2,-32112(gp)
81138db8:	10800a17 	ldw	r2,40(r2)
81138dbc:	10800404 	addi	r2,r2,16
81138dc0:	10800023 	ldbuio	r2,0(r2)
81138dc4:	10803fcc 	andi	r2,r2,255
81138dc8:	1007883a 	mov	r3,r2
81138dcc:	00a045b4 	movhi	r2,33046
81138dd0:	10884f04 	addi	r2,r2,8508
81138dd4:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81138dd8:	d0a0a417 	ldw	r2,-32112(gp)
81138ddc:	10800a17 	ldw	r2,40(r2)
81138de0:	10800484 	addi	r2,r2,18
81138de4:	10800023 	ldbuio	r2,0(r2)
81138de8:	10803fcc 	andi	r2,r2,255
81138dec:	1004923a 	slli	r2,r2,8
81138df0:	1007883a 	mov	r3,r2
81138df4:	d0a0a417 	ldw	r2,-32112(gp)
81138df8:	10800a17 	ldw	r2,40(r2)
81138dfc:	10800444 	addi	r2,r2,17
81138e00:	10800023 	ldbuio	r2,0(r2)
81138e04:	10803fcc 	andi	r2,r2,255
81138e08:	10803fcc 	andi	r2,r2,255
81138e0c:	1884b03a 	or	r2,r3,r2
81138e10:	1007883a 	mov	r3,r2
81138e14:	00a045b4 	movhi	r2,33046
81138e18:	10884f04 	addi	r2,r2,8508
81138e1c:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81138e20:	d0a0a417 	ldw	r2,-32112(gp)
81138e24:	10800a17 	ldw	r2,40(r2)
81138e28:	10800504 	addi	r2,r2,20
81138e2c:	10800023 	ldbuio	r2,0(r2)
81138e30:	10803fcc 	andi	r2,r2,255
81138e34:	1004923a 	slli	r2,r2,8
81138e38:	1007883a 	mov	r3,r2
81138e3c:	d0a0a417 	ldw	r2,-32112(gp)
81138e40:	10800a17 	ldw	r2,40(r2)
81138e44:	108004c4 	addi	r2,r2,19
81138e48:	10800023 	ldbuio	r2,0(r2)
81138e4c:	10803fcc 	andi	r2,r2,255
81138e50:	10803fcc 	andi	r2,r2,255
81138e54:	1884b03a 	or	r2,r3,r2
81138e58:	1007883a 	mov	r3,r2
81138e5c:	00a045b4 	movhi	r2,33046
81138e60:	10884f04 	addi	r2,r2,8508
81138e64:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
81138e68:	d0a0a417 	ldw	r2,-32112(gp)
81138e6c:	10800a17 	ldw	r2,40(r2)
81138e70:	10800544 	addi	r2,r2,21
81138e74:	10800023 	ldbuio	r2,0(r2)
81138e78:	10803fcc 	andi	r2,r2,255
81138e7c:	1007883a 	mov	r3,r2
81138e80:	00a045b4 	movhi	r2,33046
81138e84:	10884f04 	addi	r2,r2,8508
81138e88:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
81138e8c:	d0a0a417 	ldw	r2,-32112(gp)
81138e90:	10800a17 	ldw	r2,40(r2)
81138e94:	10800584 	addi	r2,r2,22
81138e98:	1080002b 	ldhuio	r2,0(r2)
81138e9c:	10bfffcc 	andi	r2,r2,65535
81138ea0:	1007883a 	mov	r3,r2
81138ea4:	00a045b4 	movhi	r2,33046
81138ea8:	10884f04 	addi	r2,r2,8508
81138eac:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81138eb0:	d0a0a417 	ldw	r2,-32112(gp)
81138eb4:	10800a17 	ldw	r2,40(r2)
81138eb8:	10800604 	addi	r2,r2,24
81138ebc:	1080002b 	ldhuio	r2,0(r2)
81138ec0:	10bfffcc 	andi	r2,r2,65535
81138ec4:	1007883a 	mov	r3,r2
81138ec8:	00a045b4 	movhi	r2,33046
81138ecc:	10884f04 	addi	r2,r2,8508
81138ed0:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
81138ed4:	d0a0a417 	ldw	r2,-32112(gp)
81138ed8:	10800a17 	ldw	r2,40(r2)
81138edc:	10800684 	addi	r2,r2,26
81138ee0:	1080002b 	ldhuio	r2,0(r2)
81138ee4:	10bfffcc 	andi	r2,r2,65535
81138ee8:	1007883a 	mov	r3,r2
81138eec:	00a045b4 	movhi	r2,33046
81138ef0:	10884f04 	addi	r2,r2,8508
81138ef4:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81138ef8:	d0a0a417 	ldw	r2,-32112(gp)
81138efc:	10800a17 	ldw	r2,40(r2)
81138f00:	10800704 	addi	r2,r2,28
81138f04:	10800037 	ldwio	r2,0(r2)
81138f08:	1007883a 	mov	r3,r2
81138f0c:	00a045b4 	movhi	r2,33046
81138f10:	10884f04 	addi	r2,r2,8508
81138f14:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81138f18:	d0a0a417 	ldw	r2,-32112(gp)
81138f1c:	10800a17 	ldw	r2,40(r2)
81138f20:	10800804 	addi	r2,r2,32
81138f24:	10800037 	ldwio	r2,0(r2)
81138f28:	1007883a 	mov	r3,r2
81138f2c:	00a045b4 	movhi	r2,33046
81138f30:	10884f04 	addi	r2,r2,8508
81138f34:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
81138f38:	d0a0a417 	ldw	r2,-32112(gp)
81138f3c:	10800a17 	ldw	r2,40(r2)
81138f40:	10800904 	addi	r2,r2,36
81138f44:	10800023 	ldbuio	r2,0(r2)
81138f48:	10803fcc 	andi	r2,r2,255
81138f4c:	1007883a 	mov	r3,r2
81138f50:	00a045b4 	movhi	r2,33046
81138f54:	10884f04 	addi	r2,r2,8508
81138f58:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
81138f5c:	d0a0a417 	ldw	r2,-32112(gp)
81138f60:	10800a17 	ldw	r2,40(r2)
81138f64:	10800944 	addi	r2,r2,37
81138f68:	10800023 	ldbuio	r2,0(r2)
81138f6c:	10803fcc 	andi	r2,r2,255
81138f70:	1007883a 	mov	r3,r2
81138f74:	00a045b4 	movhi	r2,33046
81138f78:	10884f04 	addi	r2,r2,8508
81138f7c:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81138f80:	d0a0a417 	ldw	r2,-32112(gp)
81138f84:	10800a17 	ldw	r2,40(r2)
81138f88:	10800984 	addi	r2,r2,38
81138f8c:	10800023 	ldbuio	r2,0(r2)
81138f90:	10803fcc 	andi	r2,r2,255
81138f94:	1007883a 	mov	r3,r2
81138f98:	00a045b4 	movhi	r2,33046
81138f9c:	10884f04 	addi	r2,r2,8508
81138fa0:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81138fa4:	00a045b4 	movhi	r2,33046
81138fa8:	10884f04 	addi	r2,r2,8508
81138fac:	1080040b 	ldhu	r2,16(r2)
81138fb0:	10ffffcc 	andi	r3,r2,65535
81138fb4:	00a045b4 	movhi	r2,33046
81138fb8:	10884f04 	addi	r2,r2,8508
81138fbc:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81138fc0:	00a045b4 	movhi	r2,33046
81138fc4:	10884f04 	addi	r2,r2,8508
81138fc8:	10c01117 	ldw	r3,68(r2)
81138fcc:	00a045b4 	movhi	r2,33046
81138fd0:	10884f04 	addi	r2,r2,8508
81138fd4:	1080068b 	ldhu	r2,26(r2)
81138fd8:	10bfffcc 	andi	r2,r2,65535
81138fdc:	1887883a 	add	r3,r3,r2
81138fe0:	00a045b4 	movhi	r2,33046
81138fe4:	10884f04 	addi	r2,r2,8508
81138fe8:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81138fec:	00a045b4 	movhi	r2,33046
81138ff0:	10884f04 	addi	r2,r2,8508
81138ff4:	10c01217 	ldw	r3,72(r2)
81138ff8:	00a045b4 	movhi	r2,33046
81138ffc:	10884f04 	addi	r2,r2,8508
81139000:	1080068b 	ldhu	r2,26(r2)
81139004:	10bfffcc 	andi	r2,r2,65535
81139008:	1887883a 	add	r3,r3,r2
8113900c:	00a045b4 	movhi	r2,33046
81139010:	10884f04 	addi	r2,r2,8508
81139014:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81139018:	00a045b4 	movhi	r2,33046
8113901c:	10884f04 	addi	r2,r2,8508
81139020:	10c01317 	ldw	r3,76(r2)
81139024:	00a045b4 	movhi	r2,33046
81139028:	10884f04 	addi	r2,r2,8508
8113902c:	1080050b 	ldhu	r2,20(r2)
81139030:	10bfffcc 	andi	r2,r2,65535
81139034:	1008917a 	slli	r4,r2,5
81139038:	00a045b4 	movhi	r2,33046
8113903c:	10884f04 	addi	r2,r2,8508
81139040:	1080030b 	ldhu	r2,12(r2)
81139044:	10bfffcc 	andi	r2,r2,65535
81139048:	2085283a 	div	r2,r4,r2
8113904c:	1887883a 	add	r3,r3,r2
81139050:	00a045b4 	movhi	r2,33046
81139054:	10884f04 	addi	r2,r2,8508
81139058:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8113905c:	00a045b4 	movhi	r2,33046
81139060:	10884f04 	addi	r2,r2,8508
81139064:	1080058b 	ldhu	r2,22(r2)
81139068:	10bfffcc 	andi	r2,r2,65535
8113906c:	10000b26 	beq	r2,zero,8113909c <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81139070:	00a045b4 	movhi	r2,33046
81139074:	10884f04 	addi	r2,r2,8508
81139078:	1080058b 	ldhu	r2,22(r2)
8113907c:	10ffffcc 	andi	r3,r2,65535
81139080:	00a045b4 	movhi	r2,33046
81139084:	10884f04 	addi	r2,r2,8508
81139088:	10800383 	ldbu	r2,14(r2)
8113908c:	10803fcc 	andi	r2,r2,255
81139090:	1885283a 	div	r2,r3,r2
81139094:	e0bffd15 	stw	r2,-12(fp)
81139098:	00000906 	br	811390c0 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8113909c:	00a045b4 	movhi	r2,33046
811390a0:	10884f04 	addi	r2,r2,8508
811390a4:	10c00917 	ldw	r3,36(r2)
811390a8:	00a045b4 	movhi	r2,33046
811390ac:	10884f04 	addi	r2,r2,8508
811390b0:	10800383 	ldbu	r2,14(r2)
811390b4:	10803fcc 	andi	r2,r2,255
811390b8:	1885203a 	divu	r2,r3,r2
811390bc:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
811390c0:	e0bffd17 	ldw	r2,-12(fp)
811390c4:	1083fdc8 	cmpgei	r2,r2,4087
811390c8:	1000051e 	bne	r2,zero,811390e0 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
811390cc:	00a045b4 	movhi	r2,33046
811390d0:	10884f04 	addi	r2,r2,8508
811390d4:	00c00304 	movi	r3,12
811390d8:	10c01085 	stb	r3,66(r2)
811390dc:	00000c06 	br	81139110 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
811390e0:	e0bffd17 	ldw	r2,-12(fp)
811390e4:	00fffb54 	movui	r3,65517
811390e8:	18800516 	blt	r3,r2,81139100 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
811390ec:	00a045b4 	movhi	r2,33046
811390f0:	10884f04 	addi	r2,r2,8508
811390f4:	00c00404 	movi	r3,16
811390f8:	10c01085 	stb	r3,66(r2)
811390fc:	00000406 	br	81139110 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
81139100:	00a045b4 	movhi	r2,33046
81139104:	10884f04 	addi	r2,r2,8508
81139108:	00c00804 	movi	r3,32
8113910c:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
81139110:	e03ffc15 	stw	zero,-16(fp)
81139114:	00001106 	br	8113915c <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
81139118:	d0a0a417 	ldw	r2,-32112(gp)
8113911c:	10c00a17 	ldw	r3,40(r2)
81139120:	e0bffc17 	ldw	r2,-16(fp)
81139124:	1885883a 	add	r2,r3,r2
81139128:	108009c4 	addi	r2,r2,39
8113912c:	10800023 	ldbuio	r2,0(r2)
81139130:	10803fcc 	andi	r2,r2,255
81139134:	1009883a 	mov	r4,r2
81139138:	00a045b4 	movhi	r2,33046
8113913c:	10884f04 	addi	r2,r2,8508
81139140:	e0fffc17 	ldw	r3,-16(fp)
81139144:	10c5883a 	add	r2,r2,r3
81139148:	10800ac4 	addi	r2,r2,43
8113914c:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81139150:	e0bffc17 	ldw	r2,-16(fp)
81139154:	10800044 	addi	r2,r2,1
81139158:	e0bffc15 	stw	r2,-16(fp)
8113915c:	e0bffc17 	ldw	r2,-16(fp)
81139160:	10800110 	cmplti	r2,r2,4
81139164:	103fec1e 	bne	r2,zero,81139118 <__reset+0xfb119118>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81139168:	e03ffc15 	stw	zero,-16(fp)
8113916c:	00001106 	br	811391b4 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81139170:	d0a0a417 	ldw	r2,-32112(gp)
81139174:	10c00a17 	ldw	r3,40(r2)
81139178:	e0bffc17 	ldw	r2,-16(fp)
8113917c:	1885883a 	add	r2,r3,r2
81139180:	10800ac4 	addi	r2,r2,43
81139184:	10800023 	ldbuio	r2,0(r2)
81139188:	10803fcc 	andi	r2,r2,255
8113918c:	1009883a 	mov	r4,r2
81139190:	00a045b4 	movhi	r2,33046
81139194:	10884f04 	addi	r2,r2,8508
81139198:	e0fffc17 	ldw	r3,-16(fp)
8113919c:	10c5883a 	add	r2,r2,r3
811391a0:	10800bc4 	addi	r2,r2,47
811391a4:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
811391a8:	e0bffc17 	ldw	r2,-16(fp)
811391ac:	10800044 	addi	r2,r2,1
811391b0:	e0bffc15 	stw	r2,-16(fp)
811391b4:	e0bffc17 	ldw	r2,-16(fp)
811391b8:	108002d0 	cmplti	r2,r2,11
811391bc:	103fec1e 	bne	r2,zero,81139170 <__reset+0xfb119170>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
811391c0:	e03ffc15 	stw	zero,-16(fp)
811391c4:	00001106 	br	8113920c <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
811391c8:	d0a0a417 	ldw	r2,-32112(gp)
811391cc:	10c00a17 	ldw	r3,40(r2)
811391d0:	e0bffc17 	ldw	r2,-16(fp)
811391d4:	1885883a 	add	r2,r3,r2
811391d8:	10800d84 	addi	r2,r2,54
811391dc:	10800023 	ldbuio	r2,0(r2)
811391e0:	10803fcc 	andi	r2,r2,255
811391e4:	1009883a 	mov	r4,r2
811391e8:	00a045b4 	movhi	r2,33046
811391ec:	10884f04 	addi	r2,r2,8508
811391f0:	e0fffc17 	ldw	r3,-16(fp)
811391f4:	10c5883a 	add	r2,r2,r3
811391f8:	10800e84 	addi	r2,r2,58
811391fc:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81139200:	e0bffc17 	ldw	r2,-16(fp)
81139204:	10800044 	addi	r2,r2,1
81139208:	e0bffc15 	stw	r2,-16(fp)
8113920c:	e0bffc17 	ldw	r2,-16(fp)
81139210:	10800210 	cmplti	r2,r2,8
81139214:	103fec1e 	bne	r2,zero,811391c8 <__reset+0xfb1191c8>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81139218:	e03ffc15 	stw	zero,-16(fp)
8113921c:	00000a06 	br	81139248 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
81139220:	00a045b4 	movhi	r2,33046
81139224:	10886404 	addi	r2,r2,8592
81139228:	e0fffc17 	ldw	r3,-16(fp)
8113922c:	180691ba 	slli	r3,r3,6
81139230:	10c5883a 	add	r2,r2,r3
81139234:	10800f04 	addi	r2,r2,60
81139238:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113923c:	e0bffc17 	ldw	r2,-16(fp)
81139240:	10800044 	addi	r2,r2,1
81139244:	e0bffc15 	stw	r2,-16(fp)
81139248:	e0bffc17 	ldw	r2,-16(fp)
8113924c:	10800510 	cmplti	r2,r2,20
81139250:	103ff31e 	bne	r2,zero,81139220 <__reset+0xfb119220>
		{
			active_files[counter].in_use = false;
		}
		result = true;
81139254:	00800044 	movi	r2,1
81139258:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8113925c:	00000106 	br	81139264 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81139260:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
81139264:	e0bffb17 	ldw	r2,-20(fp)
}
81139268:	e037883a 	mov	sp,fp
8113926c:	dfc00117 	ldw	ra,4(sp)
81139270:	df000017 	ldw	fp,0(sp)
81139274:	dec00204 	addi	sp,sp,8
81139278:	f800283a 	ret

8113927c <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8113927c:	defffc04 	addi	sp,sp,-16
81139280:	de00012e 	bgeu	sp,et,81139288 <Look_for_FAT16+0xc>
81139284:	003b68fa 	trap	3
81139288:	dfc00315 	stw	ra,12(sp)
8113928c:	df000215 	stw	fp,8(sp)
81139290:	df000204 	addi	fp,sp,8
	bool result = false;
81139294:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
81139298:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
8113929c:	10002e26 	beq	r2,zero,81139358 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
811392a0:	d0a09e17 	ldw	r2,-32136(gp)
811392a4:	1080000b 	ldhu	r2,0(r2)
811392a8:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
811392ac:	d020a215 	stw	zero,-32120(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
811392b0:	d020a315 	stw	zero,-32116(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
811392b4:	e0bfff0f 	ldh	r2,-4(fp)
811392b8:	10002716 	blt	r2,zero,81139358 <Look_for_FAT16+0xdc>
811392bc:	e0bfff0b 	ldhu	r2,-4(fp)
811392c0:	10bfffcc 	andi	r2,r2,65535
811392c4:	1083000c 	andi	r2,r2,3072
811392c8:	10830020 	cmpeqi	r2,r2,3072
811392cc:	1000221e 	bne	r2,zero,81139358 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
811392d0:	e0bfff0b 	ldhu	r2,-4(fp)
811392d4:	10bfffcc 	andi	r2,r2,65535
811392d8:	1083000c 	andi	r2,r2,3072
811392dc:	10810018 	cmpnei	r2,r2,1024
811392e0:	1000031e 	bne	r2,zero,811392f0 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
811392e4:	0009883a 	mov	r4,zero
811392e8:	1138bf40 	call	81138bf4 <Check_for_DOS_FAT>
811392ec:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
811392f0:	e0bfff0b 	ldhu	r2,-4(fp)
811392f4:	10bfffcc 	andi	r2,r2,65535
811392f8:	1083000c 	andi	r2,r2,3072
811392fc:	1000061e 	bne	r2,zero,81139318 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
81139300:	11385300 	call	81138530 <Check_for_Master_Boot_Record>
81139304:	10000426 	beq	r2,zero,81139318 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
81139308:	d0a0a217 	ldw	r2,-32120(gp)
8113930c:	1009883a 	mov	r4,r2
81139310:	1138bf40 	call	81138bf4 <Check_for_DOS_FAT>
81139314:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
81139318:	e0bffe17 	ldw	r2,-8(fp)
8113931c:	10800058 	cmpnei	r2,r2,1
81139320:	10000d1e 	bne	r2,zero,81139358 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
81139324:	00a045b4 	movhi	r2,33046
81139328:	10884f04 	addi	r2,r2,8508
8113932c:	10801083 	ldbu	r2,66(r2)
81139330:	10803fcc 	andi	r2,r2,255
81139334:	10800420 	cmpeqi	r2,r2,16
81139338:	1000021e 	bne	r2,zero,81139344 <Look_for_FAT16+0xc8>
				{
					result = false;
8113933c:	e03ffe15 	stw	zero,-8(fp)
81139340:	00000506 	br	81139358 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
81139344:	00a045b4 	movhi	r2,33046
81139348:	10884f04 	addi	r2,r2,8508
8113934c:	1080058b 	ldhu	r2,22(r2)
81139350:	10bfffcc 	andi	r2,r2,65535
81139354:	d0a0a315 	stw	r2,-32116(gp)
				}
			}
		}
	}
	return result;
81139358:	e0bffe17 	ldw	r2,-8(fp)
}
8113935c:	e037883a 	mov	sp,fp
81139360:	dfc00117 	ldw	ra,4(sp)
81139364:	df000017 	ldw	fp,0(sp)
81139368:	dec00204 	addi	sp,sp,8
8113936c:	f800283a 	ret

81139370 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81139370:	defffb04 	addi	sp,sp,-20
81139374:	de00012e 	bgeu	sp,et,8113937c <filename_to_upper_case+0xc>
81139378:	003b68fa 	trap	3
8113937c:	dfc00415 	stw	ra,16(sp)
81139380:	df000315 	stw	fp,12(sp)
81139384:	df000304 	addi	fp,sp,12
81139388:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8113938c:	e13fff17 	ldw	r4,-4(fp)
81139390:	11187c00 	call	811187c0 <strlen>
81139394:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
81139398:	e03ffd15 	stw	zero,-12(fp)
8113939c:	00001e06 	br	81139418 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
811393a0:	e0bffd17 	ldw	r2,-12(fp)
811393a4:	e0ffff17 	ldw	r3,-4(fp)
811393a8:	1885883a 	add	r2,r3,r2
811393ac:	10800003 	ldbu	r2,0(r2)
811393b0:	10803fcc 	andi	r2,r2,255
811393b4:	1080201c 	xori	r2,r2,128
811393b8:	10bfe004 	addi	r2,r2,-128
811393bc:	10801850 	cmplti	r2,r2,97
811393c0:	1000121e 	bne	r2,zero,8113940c <filename_to_upper_case+0x9c>
811393c4:	e0bffd17 	ldw	r2,-12(fp)
811393c8:	e0ffff17 	ldw	r3,-4(fp)
811393cc:	1885883a 	add	r2,r3,r2
811393d0:	10800003 	ldbu	r2,0(r2)
811393d4:	10803fcc 	andi	r2,r2,255
811393d8:	1080201c 	xori	r2,r2,128
811393dc:	10bfe004 	addi	r2,r2,-128
811393e0:	10801ec8 	cmpgei	r2,r2,123
811393e4:	1000091e 	bne	r2,zero,8113940c <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
811393e8:	e0bffd17 	ldw	r2,-12(fp)
811393ec:	e0ffff17 	ldw	r3,-4(fp)
811393f0:	1885883a 	add	r2,r3,r2
811393f4:	e0fffd17 	ldw	r3,-12(fp)
811393f8:	e13fff17 	ldw	r4,-4(fp)
811393fc:	20c7883a 	add	r3,r4,r3
81139400:	18c00003 	ldbu	r3,0(r3)
81139404:	18fff804 	addi	r3,r3,-32
81139408:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8113940c:	e0bffd17 	ldw	r2,-12(fp)
81139410:	10800044 	addi	r2,r2,1
81139414:	e0bffd15 	stw	r2,-12(fp)
81139418:	e0fffd17 	ldw	r3,-12(fp)
8113941c:	e0bffe17 	ldw	r2,-8(fp)
81139420:	18bfdf16 	blt	r3,r2,811393a0 <__reset+0xfb1193a0>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
81139424:	0001883a 	nop
81139428:	e037883a 	mov	sp,fp
8113942c:	dfc00117 	ldw	ra,4(sp)
81139430:	df000017 	ldw	fp,0(sp)
81139434:	dec00204 	addi	sp,sp,8
81139438:	f800283a 	ret

8113943c <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8113943c:	defff804 	addi	sp,sp,-32
81139440:	de00012e 	bgeu	sp,et,81139448 <check_file_name_for_FAT16_compliance+0xc>
81139444:	003b68fa 	trap	3
81139448:	dfc00715 	stw	ra,28(sp)
8113944c:	df000615 	stw	fp,24(sp)
81139450:	df000604 	addi	fp,sp,24
81139454:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
81139458:	e13fff17 	ldw	r4,-4(fp)
8113945c:	11187c00 	call	811187c0 <strlen>
81139460:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
81139464:	00bfffc4 	movi	r2,-1
81139468:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
8113946c:	00bfffc4 	movi	r2,-1
81139470:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
81139474:	00800044 	movi	r2,1
81139478:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8113947c:	e03ffa15 	stw	zero,-24(fp)
81139480:	00006d06 	br	81139638 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
81139484:	e0bffa17 	ldw	r2,-24(fp)
81139488:	e0ffff17 	ldw	r3,-4(fp)
8113948c:	1885883a 	add	r2,r3,r2
81139490:	10800003 	ldbu	r2,0(r2)
81139494:	10803fcc 	andi	r2,r2,255
81139498:	1080201c 	xori	r2,r2,128
8113949c:	10bfe004 	addi	r2,r2,-128
811394a0:	10800820 	cmpeqi	r2,r2,32
811394a4:	10003e1e 	bne	r2,zero,811395a0 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811394a8:	e0bffa17 	ldw	r2,-24(fp)
811394ac:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
811394b0:	e0bffb17 	ldw	r2,-20(fp)
811394b4:	1880121e 	bne	r3,r2,81139500 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811394b8:	e0bffa17 	ldw	r2,-24(fp)
811394bc:	e0ffff17 	ldw	r3,-4(fp)
811394c0:	1885883a 	add	r2,r3,r2
811394c4:	10800003 	ldbu	r2,0(r2)
811394c8:	10803fcc 	andi	r2,r2,255
811394cc:	1080201c 	xori	r2,r2,128
811394d0:	10bfe004 	addi	r2,r2,-128
811394d4:	10801720 	cmpeqi	r2,r2,92
811394d8:	1000311e 	bne	r2,zero,811395a0 <check_file_name_for_FAT16_compliance+0x164>
811394dc:	e0bffa17 	ldw	r2,-24(fp)
811394e0:	e0ffff17 	ldw	r3,-4(fp)
811394e4:	1885883a 	add	r2,r3,r2
811394e8:	10800003 	ldbu	r2,0(r2)
811394ec:	10803fcc 	andi	r2,r2,255
811394f0:	1080201c 	xori	r2,r2,128
811394f4:	10bfe004 	addi	r2,r2,-128
811394f8:	10800be0 	cmpeqi	r2,r2,47
811394fc:	1000281e 	bne	r2,zero,811395a0 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81139500:	e0fffa17 	ldw	r3,-24(fp)
81139504:	e0bffc17 	ldw	r2,-16(fp)
81139508:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113950c:	10800258 	cmpnei	r2,r2,9
81139510:	1000091e 	bne	r2,zero,81139538 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81139514:	e0bffa17 	ldw	r2,-24(fp)
81139518:	e0ffff17 	ldw	r3,-4(fp)
8113951c:	1885883a 	add	r2,r3,r2
81139520:	10800003 	ldbu	r2,0(r2)
81139524:	10803fcc 	andi	r2,r2,255
81139528:	1080201c 	xori	r2,r2,128
8113952c:	10bfe004 	addi	r2,r2,-128
81139530:	10800b98 	cmpnei	r2,r2,46
81139534:	10001a1e 	bne	r2,zero,811395a0 <check_file_name_for_FAT16_compliance+0x164>
81139538:	e0fffb17 	ldw	r3,-20(fp)
8113953c:	e0bffc17 	ldw	r2,-16(fp)
81139540:	18801926 	beq	r3,r2,811395a8 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81139544:	e0fffa17 	ldw	r3,-24(fp)
81139548:	e0bffc17 	ldw	r2,-16(fp)
8113954c:	1885c83a 	sub	r2,r3,r2
81139550:	10800110 	cmplti	r2,r2,4
81139554:	1000141e 	bne	r2,zero,811395a8 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81139558:	e0bffa17 	ldw	r2,-24(fp)
8113955c:	e0ffff17 	ldw	r3,-4(fp)
81139560:	1885883a 	add	r2,r3,r2
81139564:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81139568:	10803fcc 	andi	r2,r2,255
8113956c:	1080201c 	xori	r2,r2,128
81139570:	10bfe004 	addi	r2,r2,-128
81139574:	10801720 	cmpeqi	r2,r2,92
81139578:	10000b1e 	bne	r2,zero,811395a8 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113957c:	e0bffa17 	ldw	r2,-24(fp)
81139580:	e0ffff17 	ldw	r3,-4(fp)
81139584:	1885883a 	add	r2,r3,r2
81139588:	10800003 	ldbu	r2,0(r2)
8113958c:	10803fcc 	andi	r2,r2,255
81139590:	1080201c 	xori	r2,r2,128
81139594:	10bfe004 	addi	r2,r2,-128
81139598:	10800be0 	cmpeqi	r2,r2,47
8113959c:	1000021e 	bne	r2,zero,811395a8 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
811395a0:	e03ffd15 	stw	zero,-12(fp)
            break;
811395a4:	00002706 	br	81139644 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
811395a8:	e0bffa17 	ldw	r2,-24(fp)
811395ac:	e0ffff17 	ldw	r3,-4(fp)
811395b0:	1885883a 	add	r2,r3,r2
811395b4:	10800003 	ldbu	r2,0(r2)
811395b8:	10803fcc 	andi	r2,r2,255
811395bc:	1080201c 	xori	r2,r2,128
811395c0:	10bfe004 	addi	r2,r2,-128
811395c4:	10801720 	cmpeqi	r2,r2,92
811395c8:	1000091e 	bne	r2,zero,811395f0 <check_file_name_for_FAT16_compliance+0x1b4>
811395cc:	e0bffa17 	ldw	r2,-24(fp)
811395d0:	e0ffff17 	ldw	r3,-4(fp)
811395d4:	1885883a 	add	r2,r3,r2
811395d8:	10800003 	ldbu	r2,0(r2)
811395dc:	10803fcc 	andi	r2,r2,255
811395e0:	1080201c 	xori	r2,r2,128
811395e4:	10bfe004 	addi	r2,r2,-128
811395e8:	10800bd8 	cmpnei	r2,r2,47
811395ec:	1000041e 	bne	r2,zero,81139600 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
811395f0:	e0bffa17 	ldw	r2,-24(fp)
811395f4:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
811395f8:	e0bffa17 	ldw	r2,-24(fp)
811395fc:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
81139600:	e0bffa17 	ldw	r2,-24(fp)
81139604:	e0ffff17 	ldw	r3,-4(fp)
81139608:	1885883a 	add	r2,r3,r2
8113960c:	10800003 	ldbu	r2,0(r2)
81139610:	10803fcc 	andi	r2,r2,255
81139614:	1080201c 	xori	r2,r2,128
81139618:	10bfe004 	addi	r2,r2,-128
8113961c:	10800b98 	cmpnei	r2,r2,46
81139620:	1000021e 	bne	r2,zero,8113962c <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
81139624:	e0bffa17 	ldw	r2,-24(fp)
81139628:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
8113962c:	e0bffa17 	ldw	r2,-24(fp)
81139630:	10800044 	addi	r2,r2,1
81139634:	e0bffa15 	stw	r2,-24(fp)
81139638:	e0fffa17 	ldw	r3,-24(fp)
8113963c:	e0bffe17 	ldw	r2,-8(fp)
81139640:	18bf9016 	blt	r3,r2,81139484 <__reset+0xfb119484>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
81139644:	e0bffe17 	ldw	r2,-8(fp)
81139648:	10bfffc4 	addi	r2,r2,-1
8113964c:	e0ffff17 	ldw	r3,-4(fp)
81139650:	1885883a 	add	r2,r3,r2
81139654:	10800003 	ldbu	r2,0(r2)
81139658:	10803fcc 	andi	r2,r2,255
8113965c:	1080201c 	xori	r2,r2,128
81139660:	10bfe004 	addi	r2,r2,-128
81139664:	10801720 	cmpeqi	r2,r2,92
81139668:	10000a1e 	bne	r2,zero,81139694 <check_file_name_for_FAT16_compliance+0x258>
8113966c:	e0bffe17 	ldw	r2,-8(fp)
81139670:	10bfffc4 	addi	r2,r2,-1
81139674:	e0ffff17 	ldw	r3,-4(fp)
81139678:	1885883a 	add	r2,r3,r2
8113967c:	10800003 	ldbu	r2,0(r2)
81139680:	10803fcc 	andi	r2,r2,255
81139684:	1080201c 	xori	r2,r2,128
81139688:	10bfe004 	addi	r2,r2,-128
8113968c:	10800bd8 	cmpnei	r2,r2,47
81139690:	1000011e 	bne	r2,zero,81139698 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
81139694:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
81139698:	e0bffd17 	ldw	r2,-12(fp)
}
8113969c:	e037883a 	mov	sp,fp
811396a0:	dfc00117 	ldw	ra,4(sp)
811396a4:	df000017 	ldw	fp,0(sp)
811396a8:	dec00204 	addi	sp,sp,8
811396ac:	f800283a 	ret

811396b0 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
811396b0:	defffb04 	addi	sp,sp,-20
811396b4:	de00012e 	bgeu	sp,et,811396bc <get_dir_divider_location+0xc>
811396b8:	003b68fa 	trap	3
811396bc:	dfc00415 	stw	ra,16(sp)
811396c0:	df000315 	stw	fp,12(sp)
811396c4:	df000304 	addi	fp,sp,12
811396c8:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
811396cc:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
811396d0:	e13fff17 	ldw	r4,-4(fp)
811396d4:	11187c00 	call	811187c0 <strlen>
811396d8:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
811396dc:	e03ffd15 	stw	zero,-12(fp)
811396e0:	00001506 	br	81139738 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
811396e4:	e0bffd17 	ldw	r2,-12(fp)
811396e8:	e0ffff17 	ldw	r3,-4(fp)
811396ec:	1885883a 	add	r2,r3,r2
811396f0:	10800003 	ldbu	r2,0(r2)
811396f4:	10803fcc 	andi	r2,r2,255
811396f8:	1080201c 	xori	r2,r2,128
811396fc:	10bfe004 	addi	r2,r2,-128
81139700:	10801720 	cmpeqi	r2,r2,92
81139704:	10000f1e 	bne	r2,zero,81139744 <get_dir_divider_location+0x94>
81139708:	e0bffd17 	ldw	r2,-12(fp)
8113970c:	e0ffff17 	ldw	r3,-4(fp)
81139710:	1885883a 	add	r2,r3,r2
81139714:	10800003 	ldbu	r2,0(r2)
81139718:	10803fcc 	andi	r2,r2,255
8113971c:	1080201c 	xori	r2,r2,128
81139720:	10bfe004 	addi	r2,r2,-128
81139724:	10800be0 	cmpeqi	r2,r2,47
81139728:	1000061e 	bne	r2,zero,81139744 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
8113972c:	e0bffd17 	ldw	r2,-12(fp)
81139730:	10800044 	addi	r2,r2,1
81139734:	e0bffd15 	stw	r2,-12(fp)
81139738:	e0fffd17 	ldw	r3,-12(fp)
8113973c:	e0bffe17 	ldw	r2,-8(fp)
81139740:	18bfe816 	blt	r3,r2,811396e4 <__reset+0xfb1196e4>
        {
            break;
        }
    }
    
    if (index == length)
81139744:	e0fffd17 	ldw	r3,-12(fp)
81139748:	e0bffe17 	ldw	r2,-8(fp)
8113974c:	1880021e 	bne	r3,r2,81139758 <get_dir_divider_location+0xa8>
    {
        index = -1;
81139750:	00bfffc4 	movi	r2,-1
81139754:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
81139758:	e0bffd17 	ldw	r2,-12(fp)
}
8113975c:	e037883a 	mov	sp,fp
81139760:	dfc00117 	ldw	ra,4(sp)
81139764:	df000017 	ldw	fp,0(sp)
81139768:	dec00204 	addi	sp,sp,8
8113976c:	f800283a 	ret

81139770 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
81139770:	defffa04 	addi	sp,sp,-24
81139774:	de00012e 	bgeu	sp,et,8113977c <match_file_record_to_name_ext+0xc>
81139778:	003b68fa 	trap	3
8113977c:	df000515 	stw	fp,20(sp)
81139780:	df000504 	addi	fp,sp,20
81139784:	e13ffd15 	stw	r4,-12(fp)
81139788:	e17ffe15 	stw	r5,-8(fp)
8113978c:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
81139790:	00800044 	movi	r2,1
81139794:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
81139798:	e03ffc15 	stw	zero,-16(fp)
8113979c:	00004606 	br	811398b8 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
811397a0:	e0fffd17 	ldw	r3,-12(fp)
811397a4:	e0bffc17 	ldw	r2,-16(fp)
811397a8:	1885883a 	add	r2,r3,r2
811397ac:	10800003 	ldbu	r2,0(r2)
811397b0:	10803fcc 	andi	r2,r2,255
811397b4:	10801870 	cmpltui	r2,r2,97
811397b8:	1000101e 	bne	r2,zero,811397fc <match_file_record_to_name_ext+0x8c>
811397bc:	e0fffd17 	ldw	r3,-12(fp)
811397c0:	e0bffc17 	ldw	r2,-16(fp)
811397c4:	1885883a 	add	r2,r3,r2
811397c8:	10800003 	ldbu	r2,0(r2)
811397cc:	10803fcc 	andi	r2,r2,255
811397d0:	10801ee8 	cmpgeui	r2,r2,123
811397d4:	1000091e 	bne	r2,zero,811397fc <match_file_record_to_name_ext+0x8c>
811397d8:	e0fffd17 	ldw	r3,-12(fp)
811397dc:	e0bffc17 	ldw	r2,-16(fp)
811397e0:	1885883a 	add	r2,r3,r2
811397e4:	10800003 	ldbu	r2,0(r2)
811397e8:	10bff804 	addi	r2,r2,-32
811397ec:	10c03fcc 	andi	r3,r2,255
811397f0:	18c0201c 	xori	r3,r3,128
811397f4:	18ffe004 	addi	r3,r3,-128
811397f8:	00000706 	br	81139818 <match_file_record_to_name_ext+0xa8>
811397fc:	e0fffd17 	ldw	r3,-12(fp)
81139800:	e0bffc17 	ldw	r2,-16(fp)
81139804:	1885883a 	add	r2,r3,r2
81139808:	10800003 	ldbu	r2,0(r2)
8113980c:	10c03fcc 	andi	r3,r2,255
81139810:	18c0201c 	xori	r3,r3,128
81139814:	18ffe004 	addi	r3,r3,-128
81139818:	e0bffc17 	ldw	r2,-16(fp)
8113981c:	e13ffe17 	ldw	r4,-8(fp)
81139820:	2085883a 	add	r2,r4,r2
81139824:	10800003 	ldbu	r2,0(r2)
81139828:	10803fcc 	andi	r2,r2,255
8113982c:	1080201c 	xori	r2,r2,128
81139830:	10bfe004 	addi	r2,r2,-128
81139834:	10801850 	cmplti	r2,r2,97
81139838:	1000121e 	bne	r2,zero,81139884 <match_file_record_to_name_ext+0x114>
8113983c:	e0bffc17 	ldw	r2,-16(fp)
81139840:	e13ffe17 	ldw	r4,-8(fp)
81139844:	2085883a 	add	r2,r4,r2
81139848:	10800003 	ldbu	r2,0(r2)
8113984c:	10803fcc 	andi	r2,r2,255
81139850:	1080201c 	xori	r2,r2,128
81139854:	10bfe004 	addi	r2,r2,-128
81139858:	10801ec8 	cmpgei	r2,r2,123
8113985c:	1000091e 	bne	r2,zero,81139884 <match_file_record_to_name_ext+0x114>
81139860:	e0bffc17 	ldw	r2,-16(fp)
81139864:	e13ffe17 	ldw	r4,-8(fp)
81139868:	2085883a 	add	r2,r4,r2
8113986c:	10800003 	ldbu	r2,0(r2)
81139870:	10bff804 	addi	r2,r2,-32
81139874:	10803fcc 	andi	r2,r2,255
81139878:	1080201c 	xori	r2,r2,128
8113987c:	10bfe004 	addi	r2,r2,-128
81139880:	00000706 	br	811398a0 <match_file_record_to_name_ext+0x130>
81139884:	e0bffc17 	ldw	r2,-16(fp)
81139888:	e13ffe17 	ldw	r4,-8(fp)
8113988c:	2085883a 	add	r2,r4,r2
81139890:	10800003 	ldbu	r2,0(r2)
81139894:	10803fcc 	andi	r2,r2,255
81139898:	1080201c 	xori	r2,r2,128
8113989c:	10bfe004 	addi	r2,r2,-128
811398a0:	18800226 	beq	r3,r2,811398ac <match_file_record_to_name_ext+0x13c>
        {
            match = false;
811398a4:	e03ffb15 	stw	zero,-20(fp)
			break;
811398a8:	00000606 	br	811398c4 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
811398ac:	e0bffc17 	ldw	r2,-16(fp)
811398b0:	10800044 	addi	r2,r2,1
811398b4:	e0bffc15 	stw	r2,-16(fp)
811398b8:	e0bffc17 	ldw	r2,-16(fp)
811398bc:	10800210 	cmplti	r2,r2,8
811398c0:	103fb71e 	bne	r2,zero,811397a0 <__reset+0xfb1197a0>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
811398c4:	e03ffc15 	stw	zero,-16(fp)
811398c8:	00004a06 	br	811399f4 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
811398cc:	e0fffd17 	ldw	r3,-12(fp)
811398d0:	e0bffc17 	ldw	r2,-16(fp)
811398d4:	1885883a 	add	r2,r3,r2
811398d8:	10800204 	addi	r2,r2,8
811398dc:	10800003 	ldbu	r2,0(r2)
811398e0:	10803fcc 	andi	r2,r2,255
811398e4:	10801870 	cmpltui	r2,r2,97
811398e8:	1000121e 	bne	r2,zero,81139934 <match_file_record_to_name_ext+0x1c4>
811398ec:	e0fffd17 	ldw	r3,-12(fp)
811398f0:	e0bffc17 	ldw	r2,-16(fp)
811398f4:	1885883a 	add	r2,r3,r2
811398f8:	10800204 	addi	r2,r2,8
811398fc:	10800003 	ldbu	r2,0(r2)
81139900:	10803fcc 	andi	r2,r2,255
81139904:	10801ee8 	cmpgeui	r2,r2,123
81139908:	10000a1e 	bne	r2,zero,81139934 <match_file_record_to_name_ext+0x1c4>
8113990c:	e0fffd17 	ldw	r3,-12(fp)
81139910:	e0bffc17 	ldw	r2,-16(fp)
81139914:	1885883a 	add	r2,r3,r2
81139918:	10800204 	addi	r2,r2,8
8113991c:	10800003 	ldbu	r2,0(r2)
81139920:	10bff804 	addi	r2,r2,-32
81139924:	10c03fcc 	andi	r3,r2,255
81139928:	18c0201c 	xori	r3,r3,128
8113992c:	18ffe004 	addi	r3,r3,-128
81139930:	00000806 	br	81139954 <match_file_record_to_name_ext+0x1e4>
81139934:	e0fffd17 	ldw	r3,-12(fp)
81139938:	e0bffc17 	ldw	r2,-16(fp)
8113993c:	1885883a 	add	r2,r3,r2
81139940:	10800204 	addi	r2,r2,8
81139944:	10800003 	ldbu	r2,0(r2)
81139948:	10c03fcc 	andi	r3,r2,255
8113994c:	18c0201c 	xori	r3,r3,128
81139950:	18ffe004 	addi	r3,r3,-128
81139954:	e0bffc17 	ldw	r2,-16(fp)
81139958:	e13fff17 	ldw	r4,-4(fp)
8113995c:	2085883a 	add	r2,r4,r2
81139960:	10800003 	ldbu	r2,0(r2)
81139964:	10803fcc 	andi	r2,r2,255
81139968:	1080201c 	xori	r2,r2,128
8113996c:	10bfe004 	addi	r2,r2,-128
81139970:	10801850 	cmplti	r2,r2,97
81139974:	1000121e 	bne	r2,zero,811399c0 <match_file_record_to_name_ext+0x250>
81139978:	e0bffc17 	ldw	r2,-16(fp)
8113997c:	e13fff17 	ldw	r4,-4(fp)
81139980:	2085883a 	add	r2,r4,r2
81139984:	10800003 	ldbu	r2,0(r2)
81139988:	10803fcc 	andi	r2,r2,255
8113998c:	1080201c 	xori	r2,r2,128
81139990:	10bfe004 	addi	r2,r2,-128
81139994:	10801ec8 	cmpgei	r2,r2,123
81139998:	1000091e 	bne	r2,zero,811399c0 <match_file_record_to_name_ext+0x250>
8113999c:	e0bffc17 	ldw	r2,-16(fp)
811399a0:	e13fff17 	ldw	r4,-4(fp)
811399a4:	2085883a 	add	r2,r4,r2
811399a8:	10800003 	ldbu	r2,0(r2)
811399ac:	10bff804 	addi	r2,r2,-32
811399b0:	10803fcc 	andi	r2,r2,255
811399b4:	1080201c 	xori	r2,r2,128
811399b8:	10bfe004 	addi	r2,r2,-128
811399bc:	00000706 	br	811399dc <match_file_record_to_name_ext+0x26c>
811399c0:	e0bffc17 	ldw	r2,-16(fp)
811399c4:	e13fff17 	ldw	r4,-4(fp)
811399c8:	2085883a 	add	r2,r4,r2
811399cc:	10800003 	ldbu	r2,0(r2)
811399d0:	10803fcc 	andi	r2,r2,255
811399d4:	1080201c 	xori	r2,r2,128
811399d8:	10bfe004 	addi	r2,r2,-128
811399dc:	18800226 	beq	r3,r2,811399e8 <match_file_record_to_name_ext+0x278>
        {
            match = false;
811399e0:	e03ffb15 	stw	zero,-20(fp)
			break;
811399e4:	00000606 	br	81139a00 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
811399e8:	e0bffc17 	ldw	r2,-16(fp)
811399ec:	10800044 	addi	r2,r2,1
811399f0:	e0bffc15 	stw	r2,-16(fp)
811399f4:	e0bffc17 	ldw	r2,-16(fp)
811399f8:	108000d0 	cmplti	r2,r2,3
811399fc:	103fb31e 	bne	r2,zero,811398cc <__reset+0xfb1198cc>
        {
            match = false;
			break;
        }
    }
	return match;
81139a00:	e0bffb17 	ldw	r2,-20(fp)
}
81139a04:	e037883a 	mov	sp,fp
81139a08:	df000017 	ldw	fp,0(sp)
81139a0c:	dec00104 	addi	sp,sp,4
81139a10:	f800283a 	ret

81139a14 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
81139a14:	deffe704 	addi	sp,sp,-100
81139a18:	de00012e 	bgeu	sp,et,81139a20 <get_home_directory_cluster_for_file+0xc>
81139a1c:	003b68fa 	trap	3
81139a20:	dfc01815 	stw	ra,96(sp)
81139a24:	df001715 	stw	fp,92(sp)
81139a28:	df001704 	addi	fp,sp,92
81139a2c:	e13ffd15 	stw	r4,-12(fp)
81139a30:	e17ffe15 	stw	r5,-8(fp)
81139a34:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
81139a38:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81139a3c:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81139a40:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
81139a44:	e13ffd17 	ldw	r4,-12(fp)
81139a48:	11396b00 	call	811396b0 <get_dir_divider_location>
81139a4c:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81139a50:	00012f06 	br	81139f10 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81139a54:	00800804 	movi	r2,32
81139a58:	e0bff905 	stb	r2,-28(fp)
81139a5c:	00800804 	movi	r2,32
81139a60:	e0bff945 	stb	r2,-27(fp)
81139a64:	00800804 	movi	r2,32
81139a68:	e0bff985 	stb	r2,-26(fp)
81139a6c:	00800804 	movi	r2,32
81139a70:	e0bff9c5 	stb	r2,-25(fp)
81139a74:	00800804 	movi	r2,32
81139a78:	e0bffa05 	stb	r2,-24(fp)
81139a7c:	00800804 	movi	r2,32
81139a80:	e0bffa45 	stb	r2,-23(fp)
81139a84:	00800804 	movi	r2,32
81139a88:	e0bffa85 	stb	r2,-22(fp)
81139a8c:	00800804 	movi	r2,32
81139a90:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
81139a94:	00800804 	movi	r2,32
81139a98:	e0bffb05 	stb	r2,-20(fp)
81139a9c:	00800804 	movi	r2,32
81139aa0:	e0bffb45 	stb	r2,-19(fp)
81139aa4:	00800804 	movi	r2,32
81139aa8:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81139aac:	00bfffc4 	movi	r2,-1
81139ab0:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
81139ab4:	e0bfea17 	ldw	r2,-88(fp)
81139ab8:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81139abc:	e03fec15 	stw	zero,-80(fp)
81139ac0:	00002d06 	br	81139b78 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
81139ac4:	e0ffec17 	ldw	r3,-80(fp)
81139ac8:	e0bfed17 	ldw	r2,-76(fp)
81139acc:	1885883a 	add	r2,r3,r2
81139ad0:	1007883a 	mov	r3,r2
81139ad4:	e0bffd17 	ldw	r2,-12(fp)
81139ad8:	10c5883a 	add	r2,r2,r3
81139adc:	10800003 	ldbu	r2,0(r2)
81139ae0:	10803fcc 	andi	r2,r2,255
81139ae4:	1080201c 	xori	r2,r2,128
81139ae8:	10bfe004 	addi	r2,r2,-128
81139aec:	10800b98 	cmpnei	r2,r2,46
81139af0:	1000031e 	bne	r2,zero,81139b00 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
81139af4:	e0bfec17 	ldw	r2,-80(fp)
81139af8:	e0bfee15 	stw	r2,-72(fp)
81139afc:	00001b06 	br	81139b6c <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81139b00:	e0bfee17 	ldw	r2,-72(fp)
81139b04:	10000c0e 	bge	r2,zero,81139b38 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81139b08:	e0ffec17 	ldw	r3,-80(fp)
81139b0c:	e0bfed17 	ldw	r2,-76(fp)
81139b10:	1885883a 	add	r2,r3,r2
81139b14:	1007883a 	mov	r3,r2
81139b18:	e0bffd17 	ldw	r2,-12(fp)
81139b1c:	10c5883a 	add	r2,r2,r3
81139b20:	10c00003 	ldbu	r3,0(r2)
81139b24:	e13ff904 	addi	r4,fp,-28
81139b28:	e0bfec17 	ldw	r2,-80(fp)
81139b2c:	2085883a 	add	r2,r4,r2
81139b30:	10c00005 	stb	r3,0(r2)
81139b34:	00000d06 	br	81139b6c <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81139b38:	e0ffec17 	ldw	r3,-80(fp)
81139b3c:	e0bfee17 	ldw	r2,-72(fp)
81139b40:	1885c83a 	sub	r2,r3,r2
81139b44:	e13fec17 	ldw	r4,-80(fp)
81139b48:	e0ffed17 	ldw	r3,-76(fp)
81139b4c:	20c7883a 	add	r3,r4,r3
81139b50:	1809883a 	mov	r4,r3
81139b54:	e0fffd17 	ldw	r3,-12(fp)
81139b58:	1907883a 	add	r3,r3,r4
81139b5c:	18c00003 	ldbu	r3,0(r3)
81139b60:	e13ffb04 	addi	r4,fp,-20
81139b64:	2085883a 	add	r2,r4,r2
81139b68:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81139b6c:	e0bfec17 	ldw	r2,-80(fp)
81139b70:	10800044 	addi	r2,r2,1
81139b74:	e0bfec15 	stw	r2,-80(fp)
81139b78:	e0ffec17 	ldw	r3,-80(fp)
81139b7c:	e0bfeb17 	ldw	r2,-84(fp)
81139b80:	18bfd016 	blt	r3,r2,81139ac4 <__reset+0xfb119ac4>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81139b84:	e0bfea17 	ldw	r2,-88(fp)
81139b88:	10005c1e 	bne	r2,zero,81139cfc <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81139b8c:	00a045b4 	movhi	r2,33046
81139b90:	10884f04 	addi	r2,r2,8508
81139b94:	1080050b 	ldhu	r2,20(r2)
81139b98:	10bfffcc 	andi	r2,r2,65535
81139b9c:	1006917a 	slli	r3,r2,5
81139ba0:	00a045b4 	movhi	r2,33046
81139ba4:	10884f04 	addi	r2,r2,8508
81139ba8:	1080030b 	ldhu	r2,12(r2)
81139bac:	10bfffcc 	andi	r2,r2,65535
81139bb0:	1885283a 	div	r2,r3,r2
81139bb4:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81139bb8:	e03ff015 	stw	zero,-64(fp)
81139bbc:	00003b06 	br	81139cac <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
81139bc0:	00a045b4 	movhi	r2,33046
81139bc4:	10884f04 	addi	r2,r2,8508
81139bc8:	10c01317 	ldw	r3,76(r2)
81139bcc:	e0bff017 	ldw	r2,-64(fp)
81139bd0:	1885883a 	add	r2,r3,r2
81139bd4:	1007883a 	mov	r3,r2
81139bd8:	d0a0a217 	ldw	r2,-32120(gp)
81139bdc:	100b883a 	mov	r5,r2
81139be0:	1809883a 	mov	r4,r3
81139be4:	11382ac0 	call	811382ac <Read_Sector_Data>
81139be8:	10003426 	beq	r2,zero,81139cbc <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81139bec:	e03ff115 	stw	zero,-60(fp)
81139bf0:	00002506 	br	81139c88 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81139bf4:	e0bff117 	ldw	r2,-60(fp)
81139bf8:	1004917a 	slli	r2,r2,5
81139bfc:	e0fff017 	ldw	r3,-64(fp)
81139c00:	180f883a 	mov	r7,r3
81139c04:	000d883a 	mov	r6,zero
81139c08:	e17fff17 	ldw	r5,-4(fp)
81139c0c:	1009883a 	mov	r4,r2
81139c10:	11386dc0 	call	811386dc <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81139c14:	e0bfff17 	ldw	r2,-4(fp)
81139c18:	10800003 	ldbu	r2,0(r2)
81139c1c:	10803fcc 	andi	r2,r2,255
81139c20:	10803960 	cmpeqi	r2,r2,229
81139c24:	1000151e 	bne	r2,zero,81139c7c <get_home_directory_cluster_for_file+0x268>
81139c28:	e0bfff17 	ldw	r2,-4(fp)
81139c2c:	10800003 	ldbu	r2,0(r2)
81139c30:	10803fcc 	andi	r2,r2,255
81139c34:	10001126 	beq	r2,zero,81139c7c <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81139c38:	e0fffb04 	addi	r3,fp,-20
81139c3c:	e0bff904 	addi	r2,fp,-28
81139c40:	180d883a 	mov	r6,r3
81139c44:	100b883a 	mov	r5,r2
81139c48:	e13fff17 	ldw	r4,-4(fp)
81139c4c:	11397700 	call	81139770 <match_file_record_to_name_ext>
81139c50:	e0bff815 	stw	r2,-32(fp)
                            if (match)
81139c54:	e0bff817 	ldw	r2,-32(fp)
81139c58:	10000826 	beq	r2,zero,81139c7c <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81139c5c:	e0bfff17 	ldw	r2,-4(fp)
81139c60:	1080058b 	ldhu	r2,22(r2)
81139c64:	10bfffcc 	andi	r2,r2,65535
81139c68:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81139c6c:	e0bfff17 	ldw	r2,-4(fp)
81139c70:	00c00044 	movi	r3,1
81139c74:	10c00a15 	stw	r3,40(r2)
                                break;
81139c78:	00000606 	br	81139c94 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81139c7c:	e0bff117 	ldw	r2,-60(fp)
81139c80:	10800044 	addi	r2,r2,1
81139c84:	e0bff115 	stw	r2,-60(fp)
81139c88:	e0bff117 	ldw	r2,-60(fp)
81139c8c:	10800410 	cmplti	r2,r2,16
81139c90:	103fd81e 	bne	r2,zero,81139bf4 <__reset+0xfb119bf4>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81139c94:	e0ffef17 	ldw	r3,-68(fp)
81139c98:	e0bfea17 	ldw	r2,-88(fp)
81139c9c:	1880091e 	bne	r3,r2,81139cc4 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81139ca0:	e0bff017 	ldw	r2,-64(fp)
81139ca4:	10800044 	addi	r2,r2,1
81139ca8:	e0bff015 	stw	r2,-64(fp)
81139cac:	e0fff017 	ldw	r3,-64(fp)
81139cb0:	e0bff717 	ldw	r2,-36(fp)
81139cb4:	18bfc216 	blt	r3,r2,81139bc0 <__reset+0xfb119bc0>
81139cb8:	00000306 	br	81139cc8 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81139cbc:	0001883a 	nop
81139cc0:	00000106 	br	81139cc8 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81139cc4:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81139cc8:	e0ffef17 	ldw	r3,-68(fp)
81139ccc:	e0bfea17 	ldw	r2,-88(fp)
81139cd0:	18800826 	beq	r3,r2,81139cf4 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81139cd4:	e0bfef17 	ldw	r2,-68(fp)
81139cd8:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81139cdc:	e0ffed17 	ldw	r3,-76(fp)
81139ce0:	e0bfeb17 	ldw	r2,-84(fp)
81139ce4:	1885883a 	add	r2,r3,r2
81139ce8:	10800044 	addi	r2,r2,1
81139cec:	e0bfed15 	stw	r2,-76(fp)
81139cf0:	00007d06 	br	81139ee8 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81139cf4:	0005883a 	mov	r2,zero
81139cf8:	00009106 	br	81139f40 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81139cfc:	e0bfea17 	ldw	r2,-88(fp)
81139d00:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81139d04:	e0bff417 	ldw	r2,-48(fp)
81139d08:	10ffff84 	addi	r3,r2,-2
81139d0c:	00a045b4 	movhi	r2,33046
81139d10:	10884f04 	addi	r2,r2,8508
81139d14:	10800383 	ldbu	r2,14(r2)
81139d18:	10803fcc 	andi	r2,r2,255
81139d1c:	1885383a 	mul	r2,r3,r2
81139d20:	1007883a 	mov	r3,r2
81139d24:	00a045b4 	movhi	r2,33046
81139d28:	10884f04 	addi	r2,r2,8508
81139d2c:	10801417 	ldw	r2,80(r2)
81139d30:	1885883a 	add	r2,r3,r2
81139d34:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81139d38:	e03ff215 	stw	zero,-56(fp)
81139d3c:	00003606 	br	81139e18 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81139d40:	e0fff217 	ldw	r3,-56(fp)
81139d44:	e0bff517 	ldw	r2,-44(fp)
81139d48:	1885883a 	add	r2,r3,r2
81139d4c:	d0e0a217 	ldw	r3,-32120(gp)
81139d50:	180b883a 	mov	r5,r3
81139d54:	1009883a 	mov	r4,r2
81139d58:	11382ac0 	call	811382ac <Read_Sector_Data>
81139d5c:	10003526 	beq	r2,zero,81139e34 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81139d60:	e03ff315 	stw	zero,-52(fp)
81139d64:	00002306 	br	81139df4 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81139d68:	e0bff317 	ldw	r2,-52(fp)
81139d6c:	1004917a 	slli	r2,r2,5
81139d70:	e0fff417 	ldw	r3,-48(fp)
81139d74:	e13ff217 	ldw	r4,-56(fp)
81139d78:	200f883a 	mov	r7,r4
81139d7c:	180d883a 	mov	r6,r3
81139d80:	e17fff17 	ldw	r5,-4(fp)
81139d84:	1009883a 	mov	r4,r2
81139d88:	11386dc0 	call	811386dc <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81139d8c:	e0bfff17 	ldw	r2,-4(fp)
81139d90:	10800003 	ldbu	r2,0(r2)
81139d94:	10803fcc 	andi	r2,r2,255
81139d98:	10803960 	cmpeqi	r2,r2,229
81139d9c:	1000121e 	bne	r2,zero,81139de8 <get_home_directory_cluster_for_file+0x3d4>
81139da0:	e0bfff17 	ldw	r2,-4(fp)
81139da4:	10800003 	ldbu	r2,0(r2)
81139da8:	10803fcc 	andi	r2,r2,255
81139dac:	10000e26 	beq	r2,zero,81139de8 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
81139db0:	e0fffb04 	addi	r3,fp,-20
81139db4:	e0bff904 	addi	r2,fp,-28
81139db8:	180d883a 	mov	r6,r3
81139dbc:	100b883a 	mov	r5,r2
81139dc0:	e13fff17 	ldw	r4,-4(fp)
81139dc4:	11397700 	call	81139770 <match_file_record_to_name_ext>
81139dc8:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81139dcc:	e0bff617 	ldw	r2,-40(fp)
81139dd0:	10000526 	beq	r2,zero,81139de8 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
81139dd4:	e0bfff17 	ldw	r2,-4(fp)
81139dd8:	1080058b 	ldhu	r2,22(r2)
81139ddc:	10bfffcc 	andi	r2,r2,65535
81139de0:	e0bfef15 	stw	r2,-68(fp)
                                    break;
81139de4:	00000606 	br	81139e00 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81139de8:	e0bff317 	ldw	r2,-52(fp)
81139dec:	10800044 	addi	r2,r2,1
81139df0:	e0bff315 	stw	r2,-52(fp)
81139df4:	e0bff317 	ldw	r2,-52(fp)
81139df8:	10800410 	cmplti	r2,r2,16
81139dfc:	103fda1e 	bne	r2,zero,81139d68 <__reset+0xfb119d68>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81139e00:	e0ffef17 	ldw	r3,-68(fp)
81139e04:	e0bfea17 	ldw	r2,-88(fp)
81139e08:	18800c1e 	bne	r3,r2,81139e3c <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81139e0c:	e0bff217 	ldw	r2,-56(fp)
81139e10:	10800044 	addi	r2,r2,1
81139e14:	e0bff215 	stw	r2,-56(fp)
81139e18:	00a045b4 	movhi	r2,33046
81139e1c:	10884f04 	addi	r2,r2,8508
81139e20:	10800383 	ldbu	r2,14(r2)
81139e24:	10803fcc 	andi	r2,r2,255
81139e28:	e0fff217 	ldw	r3,-56(fp)
81139e2c:	18bfc416 	blt	r3,r2,81139d40 <__reset+0xfb119d40>
81139e30:	00000306 	br	81139e40 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
81139e34:	0001883a 	nop
81139e38:	00000106 	br	81139e40 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
81139e3c:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
81139e40:	e0ffef17 	ldw	r3,-68(fp)
81139e44:	e0bfea17 	ldw	r2,-88(fp)
81139e48:	1880141e 	bne	r3,r2,81139e9c <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
81139e4c:	e0bfef17 	ldw	r2,-68(fp)
81139e50:	e0fffc04 	addi	r3,fp,-16
81139e54:	180b883a 	mov	r5,r3
81139e58:	1009883a 	mov	r4,r2
81139e5c:	113838c0 	call	8113838c <get_cluster_flag>
81139e60:	10000c26 	beq	r2,zero,81139e94 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81139e64:	e0bffc0b 	ldhu	r2,-16(fp)
81139e68:	10bfffcc 	andi	r2,r2,65535
81139e6c:	10fffe0c 	andi	r3,r2,65528
81139e70:	00bffe14 	movui	r2,65528
81139e74:	1880021e 	bne	r3,r2,81139e80 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81139e78:	0005883a 	mov	r2,zero
81139e7c:	00003006 	br	81139f40 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81139e80:	e0bffc0b 	ldhu	r2,-16(fp)
81139e84:	10bfffcc 	andi	r2,r2,65535
81139e88:	10bffe0c 	andi	r2,r2,65528
81139e8c:	e0bfef15 	stw	r2,-68(fp)
81139e90:	00000206 	br	81139e9c <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81139e94:	0005883a 	mov	r2,zero
81139e98:	00002906 	br	81139f40 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81139e9c:	e0bff417 	ldw	r2,-48(fp)
81139ea0:	00fffdd4 	movui	r3,65527
81139ea4:	18800316 	blt	r3,r2,81139eb4 <get_home_directory_cluster_for_file+0x4a0>
81139ea8:	e0ffef17 	ldw	r3,-68(fp)
81139eac:	e0bfea17 	ldw	r2,-88(fp)
81139eb0:	18bf9426 	beq	r3,r2,81139d04 <__reset+0xfb119d04>
            if (new_cluster != home_dir_cluster)
81139eb4:	e0ffef17 	ldw	r3,-68(fp)
81139eb8:	e0bfea17 	ldw	r2,-88(fp)
81139ebc:	18800826 	beq	r3,r2,81139ee0 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81139ec0:	e0bfef17 	ldw	r2,-68(fp)
81139ec4:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81139ec8:	e0ffed17 	ldw	r3,-76(fp)
81139ecc:	e0bfeb17 	ldw	r2,-84(fp)
81139ed0:	1885883a 	add	r2,r3,r2
81139ed4:	10800044 	addi	r2,r2,1
81139ed8:	e0bfed15 	stw	r2,-76(fp)
81139edc:	00000206 	br	81139ee8 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81139ee0:	0005883a 	mov	r2,zero
81139ee4:	00001606 	br	81139f40 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81139ee8:	e0bfed17 	ldw	r2,-76(fp)
81139eec:	e0fffd17 	ldw	r3,-12(fp)
81139ef0:	1885883a 	add	r2,r3,r2
81139ef4:	1009883a 	mov	r4,r2
81139ef8:	11396b00 	call	811396b0 <get_dir_divider_location>
81139efc:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81139f00:	e0bfeb17 	ldw	r2,-84(fp)
81139f04:	1000020e 	bge	r2,zero,81139f10 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81139f08:	00800044 	movi	r2,1
81139f0c:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81139f10:	e0bfeb17 	ldw	r2,-84(fp)
81139f14:	00becf16 	blt	zero,r2,81139a54 <__reset+0xfb119a54>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81139f18:	e0bffe17 	ldw	r2,-8(fp)
81139f1c:	e0ffea17 	ldw	r3,-88(fp)
81139f20:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
81139f24:	e0bfea17 	ldw	r2,-88(fp)
81139f28:	1000041e 	bne	r2,zero,81139f3c <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
81139f2c:	e0bfff17 	ldw	r2,-4(fp)
81139f30:	10000a15 	stw	zero,40(r2)
		result = true;
81139f34:	00800044 	movi	r2,1
81139f38:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
81139f3c:	e0bfe917 	ldw	r2,-92(fp)
}
81139f40:	e037883a 	mov	sp,fp
81139f44:	dfc00117 	ldw	ra,4(sp)
81139f48:	df000017 	ldw	fp,0(sp)
81139f4c:	dec00204 	addi	sp,sp,8
81139f50:	f800283a 	ret

81139f54 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
81139f54:	deffe804 	addi	sp,sp,-96
81139f58:	de00012e 	bgeu	sp,et,81139f60 <find_file_in_directory+0xc>
81139f5c:	003b68fa 	trap	3
81139f60:	dfc01715 	stw	ra,92(sp)
81139f64:	df001615 	stw	fp,88(sp)
81139f68:	df001604 	addi	fp,sp,88
81139f6c:	e13ffd15 	stw	r4,-12(fp)
81139f70:	e17ffe15 	stw	r5,-8(fp)
81139f74:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81139f78:	e13ffe17 	ldw	r4,-8(fp)
81139f7c:	11396b00 	call	811396b0 <get_dir_divider_location>
81139f80:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81139f84:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81139f88:	00800804 	movi	r2,32
81139f8c:	e0bff905 	stb	r2,-28(fp)
81139f90:	00800804 	movi	r2,32
81139f94:	e0bff945 	stb	r2,-27(fp)
81139f98:	00800804 	movi	r2,32
81139f9c:	e0bff985 	stb	r2,-26(fp)
81139fa0:	00800804 	movi	r2,32
81139fa4:	e0bff9c5 	stb	r2,-25(fp)
81139fa8:	00800804 	movi	r2,32
81139fac:	e0bffa05 	stb	r2,-24(fp)
81139fb0:	00800804 	movi	r2,32
81139fb4:	e0bffa45 	stb	r2,-23(fp)
81139fb8:	00800804 	movi	r2,32
81139fbc:	e0bffa85 	stb	r2,-22(fp)
81139fc0:	00800804 	movi	r2,32
81139fc4:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81139fc8:	00800804 	movi	r2,32
81139fcc:	e0bffb05 	stb	r2,-20(fp)
81139fd0:	00800804 	movi	r2,32
81139fd4:	e0bffb45 	stb	r2,-19(fp)
81139fd8:	00800804 	movi	r2,32
81139fdc:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81139fe0:	00bfffc4 	movi	r2,-1
81139fe4:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81139fe8:	e0bffd17 	ldw	r2,-12(fp)
81139fec:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81139ff0:	e13ffe17 	ldw	r4,-8(fp)
81139ff4:	11187c00 	call	811187c0 <strlen>
81139ff8:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81139ffc:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
8113a000:	00000b06 	br	8113a030 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
8113a004:	e0ffeb17 	ldw	r3,-84(fp)
8113a008:	e0bfea17 	ldw	r2,-88(fp)
8113a00c:	1885883a 	add	r2,r3,r2
8113a010:	10800044 	addi	r2,r2,1
8113a014:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
8113a018:	e0bfeb17 	ldw	r2,-84(fp)
8113a01c:	e0fffe17 	ldw	r3,-8(fp)
8113a020:	1885883a 	add	r2,r3,r2
8113a024:	1009883a 	mov	r4,r2
8113a028:	11396b00 	call	811396b0 <get_dir_divider_location>
8113a02c:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
8113a030:	e0bfea17 	ldw	r2,-88(fp)
8113a034:	00bff316 	blt	zero,r2,8113a004 <__reset+0xfb11a004>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113a038:	e0bfeb17 	ldw	r2,-84(fp)
8113a03c:	e0bfee15 	stw	r2,-72(fp)
8113a040:	00002706 	br	8113a0e0 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
8113a044:	e0bfee17 	ldw	r2,-72(fp)
8113a048:	e0fffe17 	ldw	r3,-8(fp)
8113a04c:	1885883a 	add	r2,r3,r2
8113a050:	10800003 	ldbu	r2,0(r2)
8113a054:	10803fcc 	andi	r2,r2,255
8113a058:	1080201c 	xori	r2,r2,128
8113a05c:	10bfe004 	addi	r2,r2,-128
8113a060:	10800b98 	cmpnei	r2,r2,46
8113a064:	1000031e 	bne	r2,zero,8113a074 <find_file_in_directory+0x120>
        {
            ext_index = index;
8113a068:	e0bfee17 	ldw	r2,-72(fp)
8113a06c:	e0bfec15 	stw	r2,-80(fp)
8113a070:	00001806 	br	8113a0d4 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
8113a074:	e0bfec17 	ldw	r2,-80(fp)
8113a078:	10000b0e 	bge	r2,zero,8113a0a8 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8113a07c:	e0ffee17 	ldw	r3,-72(fp)
8113a080:	e0bfeb17 	ldw	r2,-84(fp)
8113a084:	1885c83a 	sub	r2,r3,r2
8113a088:	e0ffee17 	ldw	r3,-72(fp)
8113a08c:	e13ffe17 	ldw	r4,-8(fp)
8113a090:	20c7883a 	add	r3,r4,r3
8113a094:	18c00003 	ldbu	r3,0(r3)
8113a098:	e13ff904 	addi	r4,fp,-28
8113a09c:	2085883a 	add	r2,r4,r2
8113a0a0:	10c00005 	stb	r3,0(r2)
8113a0a4:	00000b06 	br	8113a0d4 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
8113a0a8:	e0ffee17 	ldw	r3,-72(fp)
8113a0ac:	e0bfec17 	ldw	r2,-80(fp)
8113a0b0:	1885c83a 	sub	r2,r3,r2
8113a0b4:	10bfffc4 	addi	r2,r2,-1
8113a0b8:	e0ffee17 	ldw	r3,-72(fp)
8113a0bc:	e13ffe17 	ldw	r4,-8(fp)
8113a0c0:	20c7883a 	add	r3,r4,r3
8113a0c4:	18c00003 	ldbu	r3,0(r3)
8113a0c8:	e13ffb04 	addi	r4,fp,-20
8113a0cc:	2085883a 	add	r2,r4,r2
8113a0d0:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113a0d4:	e0bfee17 	ldw	r2,-72(fp)
8113a0d8:	10800044 	addi	r2,r2,1
8113a0dc:	e0bfee15 	stw	r2,-72(fp)
8113a0e0:	e0ffee17 	ldw	r3,-72(fp)
8113a0e4:	e0bff417 	ldw	r2,-48(fp)
8113a0e8:	18bfd616 	blt	r3,r2,8113a044 <__reset+0xfb11a044>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
8113a0ec:	e0bffd17 	ldw	r2,-12(fp)
8113a0f0:	1000461e 	bne	r2,zero,8113a20c <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113a0f4:	00a045b4 	movhi	r2,33046
8113a0f8:	10884f04 	addi	r2,r2,8508
8113a0fc:	1080050b 	ldhu	r2,20(r2)
8113a100:	10bfffcc 	andi	r2,r2,65535
8113a104:	1006917a 	slli	r3,r2,5
8113a108:	00a045b4 	movhi	r2,33046
8113a10c:	10884f04 	addi	r2,r2,8508
8113a110:	1080030b 	ldhu	r2,12(r2)
8113a114:	10bfffcc 	andi	r2,r2,65535
8113a118:	1885283a 	div	r2,r3,r2
8113a11c:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113a120:	e03ff015 	stw	zero,-64(fp)
8113a124:	00003506 	br	8113a1fc <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113a128:	00a045b4 	movhi	r2,33046
8113a12c:	10884f04 	addi	r2,r2,8508
8113a130:	10c01317 	ldw	r3,76(r2)
8113a134:	e0bff017 	ldw	r2,-64(fp)
8113a138:	1885883a 	add	r2,r3,r2
8113a13c:	1007883a 	mov	r3,r2
8113a140:	d0a0a217 	ldw	r2,-32120(gp)
8113a144:	100b883a 	mov	r5,r2
8113a148:	1809883a 	mov	r4,r3
8113a14c:	11382ac0 	call	811382ac <Read_Sector_Data>
8113a150:	10009626 	beq	r2,zero,8113a3ac <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113a154:	e03ff115 	stw	zero,-60(fp)
8113a158:	00002006 	br	8113a1dc <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113a15c:	e0bff117 	ldw	r2,-60(fp)
8113a160:	1004917a 	slli	r2,r2,5
8113a164:	e0fff017 	ldw	r3,-64(fp)
8113a168:	180f883a 	mov	r7,r3
8113a16c:	000d883a 	mov	r6,zero
8113a170:	e17fff17 	ldw	r5,-4(fp)
8113a174:	1009883a 	mov	r4,r2
8113a178:	11386dc0 	call	811386dc <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113a17c:	e0bfff17 	ldw	r2,-4(fp)
8113a180:	10800003 	ldbu	r2,0(r2)
8113a184:	10803fcc 	andi	r2,r2,255
8113a188:	10803960 	cmpeqi	r2,r2,229
8113a18c:	1000101e 	bne	r2,zero,8113a1d0 <find_file_in_directory+0x27c>
8113a190:	e0bfff17 	ldw	r2,-4(fp)
8113a194:	10800003 	ldbu	r2,0(r2)
8113a198:	10803fcc 	andi	r2,r2,255
8113a19c:	10000c26 	beq	r2,zero,8113a1d0 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
8113a1a0:	e0fffb04 	addi	r3,fp,-20
8113a1a4:	e0bff904 	addi	r2,fp,-28
8113a1a8:	180d883a 	mov	r6,r3
8113a1ac:	100b883a 	mov	r5,r2
8113a1b0:	e13fff17 	ldw	r4,-4(fp)
8113a1b4:	11397700 	call	81139770 <match_file_record_to_name_ext>
8113a1b8:	e0bff815 	stw	r2,-32(fp)

                        if (match)
8113a1bc:	e0bff817 	ldw	r2,-32(fp)
8113a1c0:	10000326 	beq	r2,zero,8113a1d0 <find_file_in_directory+0x27c>
                        {
                            result = true;
8113a1c4:	00800044 	movi	r2,1
8113a1c8:	e0bfef15 	stw	r2,-68(fp)
                            break;
8113a1cc:	00000606 	br	8113a1e8 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113a1d0:	e0bff117 	ldw	r2,-60(fp)
8113a1d4:	10800044 	addi	r2,r2,1
8113a1d8:	e0bff115 	stw	r2,-60(fp)
8113a1dc:	e0bff117 	ldw	r2,-60(fp)
8113a1e0:	10800410 	cmplti	r2,r2,16
8113a1e4:	103fdd1e 	bne	r2,zero,8113a15c <__reset+0xfb11a15c>
            }
            else
            {
                break;
            }
            if (result)
8113a1e8:	e0bfef17 	ldw	r2,-68(fp)
8113a1ec:	1000711e 	bne	r2,zero,8113a3b4 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113a1f0:	e0bff017 	ldw	r2,-64(fp)
8113a1f4:	10800044 	addi	r2,r2,1
8113a1f8:	e0bff015 	stw	r2,-64(fp)
8113a1fc:	e0fff017 	ldw	r3,-64(fp)
8113a200:	e0bff717 	ldw	r2,-36(fp)
8113a204:	18bfc816 	blt	r3,r2,8113a128 <__reset+0xfb11a128>
8113a208:	00006b06 	br	8113a3b8 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113a20c:	e0bfed17 	ldw	r2,-76(fp)
8113a210:	10ffff84 	addi	r3,r2,-2
8113a214:	00a045b4 	movhi	r2,33046
8113a218:	10884f04 	addi	r2,r2,8508
8113a21c:	10800383 	ldbu	r2,14(r2)
8113a220:	10803fcc 	andi	r2,r2,255
8113a224:	1885383a 	mul	r2,r3,r2
8113a228:	1007883a 	mov	r3,r2
8113a22c:	00a045b4 	movhi	r2,33046
8113a230:	10884f04 	addi	r2,r2,8508
8113a234:	10801417 	ldw	r2,80(r2)
8113a238:	1885883a 	add	r2,r3,r2
8113a23c:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113a240:	e03ff215 	stw	zero,-56(fp)
8113a244:	00003306 	br	8113a314 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113a248:	e0fff217 	ldw	r3,-56(fp)
8113a24c:	e0bff517 	ldw	r2,-44(fp)
8113a250:	1885883a 	add	r2,r3,r2
8113a254:	d0e0a217 	ldw	r3,-32120(gp)
8113a258:	180b883a 	mov	r5,r3
8113a25c:	1009883a 	mov	r4,r2
8113a260:	11382ac0 	call	811382ac <Read_Sector_Data>
8113a264:	10003226 	beq	r2,zero,8113a330 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113a268:	e03ff315 	stw	zero,-52(fp)
8113a26c:	00002106 	br	8113a2f4 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113a270:	e0bff317 	ldw	r2,-52(fp)
8113a274:	1004917a 	slli	r2,r2,5
8113a278:	e0ffed17 	ldw	r3,-76(fp)
8113a27c:	e13ff217 	ldw	r4,-56(fp)
8113a280:	200f883a 	mov	r7,r4
8113a284:	180d883a 	mov	r6,r3
8113a288:	e17fff17 	ldw	r5,-4(fp)
8113a28c:	1009883a 	mov	r4,r2
8113a290:	11386dc0 	call	811386dc <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113a294:	e0bfff17 	ldw	r2,-4(fp)
8113a298:	10800003 	ldbu	r2,0(r2)
8113a29c:	10803fcc 	andi	r2,r2,255
8113a2a0:	10803960 	cmpeqi	r2,r2,229
8113a2a4:	1000101e 	bne	r2,zero,8113a2e8 <find_file_in_directory+0x394>
8113a2a8:	e0bfff17 	ldw	r2,-4(fp)
8113a2ac:	10800003 	ldbu	r2,0(r2)
8113a2b0:	10803fcc 	andi	r2,r2,255
8113a2b4:	10000c26 	beq	r2,zero,8113a2e8 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113a2b8:	e0fffb04 	addi	r3,fp,-20
8113a2bc:	e0bff904 	addi	r2,fp,-28
8113a2c0:	180d883a 	mov	r6,r3
8113a2c4:	100b883a 	mov	r5,r2
8113a2c8:	e13fff17 	ldw	r4,-4(fp)
8113a2cc:	11397700 	call	81139770 <match_file_record_to_name_ext>
8113a2d0:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8113a2d4:	e0bff617 	ldw	r2,-40(fp)
8113a2d8:	10000326 	beq	r2,zero,8113a2e8 <find_file_in_directory+0x394>
                            {                               
                                result = true;
8113a2dc:	00800044 	movi	r2,1
8113a2e0:	e0bfef15 	stw	r2,-68(fp)
                                break;
8113a2e4:	00000606 	br	8113a300 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113a2e8:	e0bff317 	ldw	r2,-52(fp)
8113a2ec:	10800044 	addi	r2,r2,1
8113a2f0:	e0bff315 	stw	r2,-52(fp)
8113a2f4:	e0bff317 	ldw	r2,-52(fp)
8113a2f8:	10800410 	cmplti	r2,r2,16
8113a2fc:	103fdc1e 	bne	r2,zero,8113a270 <__reset+0xfb11a270>
                }
                else
                {
                    break;
                }
                if (result)
8113a300:	e0bfef17 	ldw	r2,-68(fp)
8113a304:	10000c1e 	bne	r2,zero,8113a338 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113a308:	e0bff217 	ldw	r2,-56(fp)
8113a30c:	10800044 	addi	r2,r2,1
8113a310:	e0bff215 	stw	r2,-56(fp)
8113a314:	00a045b4 	movhi	r2,33046
8113a318:	10884f04 	addi	r2,r2,8508
8113a31c:	10800383 	ldbu	r2,14(r2)
8113a320:	10803fcc 	andi	r2,r2,255
8113a324:	e0fff217 	ldw	r3,-56(fp)
8113a328:	18bfc716 	blt	r3,r2,8113a248 <__reset+0xfb11a248>
8113a32c:	00000306 	br	8113a33c <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
8113a330:	0001883a 	nop
8113a334:	00000106 	br	8113a33c <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8113a338:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
8113a33c:	e0bfef17 	ldw	r2,-68(fp)
8113a340:	1000141e 	bne	r2,zero,8113a394 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
8113a344:	e0bfed17 	ldw	r2,-76(fp)
8113a348:	e0fffc04 	addi	r3,fp,-16
8113a34c:	180b883a 	mov	r5,r3
8113a350:	1009883a 	mov	r4,r2
8113a354:	113838c0 	call	8113838c <get_cluster_flag>
8113a358:	10000c26 	beq	r2,zero,8113a38c <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113a35c:	e0bffc0b 	ldhu	r2,-16(fp)
8113a360:	10bfffcc 	andi	r2,r2,65535
8113a364:	10fffe0c 	andi	r3,r2,65528
8113a368:	00bffe14 	movui	r2,65528
8113a36c:	1880021e 	bne	r3,r2,8113a378 <find_file_in_directory+0x424>
					{
						return false;
8113a370:	0005883a 	mov	r2,zero
8113a374:	00001106 	br	8113a3bc <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8113a378:	e0bffc0b 	ldhu	r2,-16(fp)
8113a37c:	10bfffcc 	andi	r2,r2,65535
8113a380:	10bffe0c 	andi	r2,r2,65528
8113a384:	e0bfed15 	stw	r2,-76(fp)
8113a388:	00000206 	br	8113a394 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8113a38c:	0005883a 	mov	r2,zero
8113a390:	00000a06 	br	8113a3bc <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
8113a394:	e0bfed17 	ldw	r2,-76(fp)
8113a398:	00fffdd4 	movui	r3,65527
8113a39c:	18800616 	blt	r3,r2,8113a3b8 <find_file_in_directory+0x464>
8113a3a0:	e0bfef17 	ldw	r2,-68(fp)
8113a3a4:	103f9926 	beq	r2,zero,8113a20c <__reset+0xfb11a20c>
8113a3a8:	00000306 	br	8113a3b8 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8113a3ac:	0001883a 	nop
8113a3b0:	00000106 	br	8113a3b8 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
8113a3b4:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
8113a3b8:	e0bfef17 	ldw	r2,-68(fp)
}
8113a3bc:	e037883a 	mov	sp,fp
8113a3c0:	dfc00117 	ldw	ra,4(sp)
8113a3c4:	df000017 	ldw	fp,0(sp)
8113a3c8:	dec00204 	addi	sp,sp,8
8113a3cc:	f800283a 	ret

8113a3d0 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
8113a3d0:	defff504 	addi	sp,sp,-44
8113a3d4:	de00012e 	bgeu	sp,et,8113a3dc <find_first_empty_cluster+0xc>
8113a3d8:	003b68fa 	trap	3
8113a3dc:	dfc00a15 	stw	ra,40(sp)
8113a3e0:	df000915 	stw	fp,36(sp)
8113a3e4:	df000904 	addi	fp,sp,36
8113a3e8:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
8113a3ec:	00a045b4 	movhi	r2,33046
8113a3f0:	10884f04 	addi	r2,r2,8508
8113a3f4:	10801117 	ldw	r2,68(r2)
8113a3f8:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
8113a3fc:	00800084 	movi	r2,2
8113a400:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8113a404:	00bfffc4 	movi	r2,-1
8113a408:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
8113a40c:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
8113a410:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8113a414:	00a045b4 	movhi	r2,33046
8113a418:	10884f04 	addi	r2,r2,8508
8113a41c:	10801417 	ldw	r2,80(r2)
8113a420:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
8113a424:	00a045b4 	movhi	r2,33046
8113a428:	10884f04 	addi	r2,r2,8508
8113a42c:	1080058b 	ldhu	r2,22(r2)
8113a430:	10bfffcc 	andi	r2,r2,65535
8113a434:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8113a438:	00a045b4 	movhi	r2,33046
8113a43c:	10884f04 	addi	r2,r2,8508
8113a440:	10800917 	ldw	r2,36(r2)
8113a444:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8113a448:	e0bffd17 	ldw	r2,-12(fp)
8113a44c:	e0fffe17 	ldw	r3,-8(fp)
8113a450:	18800b2e 	bgeu	r3,r2,8113a480 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113a454:	e0fffd17 	ldw	r3,-12(fp)
8113a458:	e0bffc17 	ldw	r2,-16(fp)
8113a45c:	1887c83a 	sub	r3,r3,r2
8113a460:	00a045b4 	movhi	r2,33046
8113a464:	10884f04 	addi	r2,r2,8508
8113a468:	10800383 	ldbu	r2,14(r2)
8113a46c:	10803fcc 	andi	r2,r2,255
8113a470:	1885203a 	divu	r2,r3,r2
8113a474:	10800044 	addi	r2,r2,1
8113a478:	e0bffb15 	stw	r2,-20(fp)
8113a47c:	00002a06 	br	8113a528 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113a480:	e0fffe17 	ldw	r3,-8(fp)
8113a484:	e0bffc17 	ldw	r2,-16(fp)
8113a488:	1887c83a 	sub	r3,r3,r2
8113a48c:	00a045b4 	movhi	r2,33046
8113a490:	10884f04 	addi	r2,r2,8508
8113a494:	10800383 	ldbu	r2,14(r2)
8113a498:	10803fcc 	andi	r2,r2,255
8113a49c:	1885203a 	divu	r2,r3,r2
8113a4a0:	10800044 	addi	r2,r2,1
8113a4a4:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113a4a8:	00001f06 	br	8113a528 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8113a4ac:	e0bff717 	ldw	r2,-36(fp)
8113a4b0:	d0e0a217 	ldw	r3,-32120(gp)
8113a4b4:	180b883a 	mov	r5,r3
8113a4b8:	1009883a 	mov	r4,r2
8113a4bc:	11382ac0 	call	811382ac <Read_Sector_Data>
8113a4c0:	10001426 	beq	r2,zero,8113a514 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
8113a4c4:	e0bff817 	ldw	r2,-32(fp)
8113a4c8:	10803fcc 	andi	r2,r2,255
8113a4cc:	1085883a 	add	r2,r2,r2
8113a4d0:	1007883a 	mov	r3,r2
8113a4d4:	d0a0a417 	ldw	r2,-32112(gp)
8113a4d8:	10800a17 	ldw	r2,40(r2)
8113a4dc:	1885883a 	add	r2,r3,r2
8113a4e0:	1080002b 	ldhuio	r2,0(r2)
8113a4e4:	10bfffcc 	andi	r2,r2,65535
8113a4e8:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
8113a4ec:	e0bff90f 	ldh	r2,-28(fp)
8113a4f0:	10000726 	beq	r2,zero,8113a510 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8113a4f4:	e0bff817 	ldw	r2,-32(fp)
8113a4f8:	10800044 	addi	r2,r2,1
8113a4fc:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
8113a500:	e0bff817 	ldw	r2,-32(fp)
8113a504:	10803fcc 	andi	r2,r2,255
8113a508:	103fee1e 	bne	r2,zero,8113a4c4 <__reset+0xfb11a4c4>
8113a50c:	00000106 	br	8113a514 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
8113a510:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8113a514:	e0bff90f 	ldh	r2,-28(fp)
8113a518:	10000926 	beq	r2,zero,8113a540 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
8113a51c:	e0bff717 	ldw	r2,-36(fp)
8113a520:	10800044 	addi	r2,r2,1
8113a524:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113a528:	00a045b4 	movhi	r2,33046
8113a52c:	10884f04 	addi	r2,r2,8508
8113a530:	10c01217 	ldw	r3,72(r2)
8113a534:	e0bff717 	ldw	r2,-36(fp)
8113a538:	18bfdc1e 	bne	r3,r2,8113a4ac <__reset+0xfb11a4ac>
8113a53c:	00000106 	br	8113a544 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
8113a540:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8113a544:	e0bff90f 	ldh	r2,-28(fp)
8113a548:	1000081e 	bne	r2,zero,8113a56c <find_first_empty_cluster+0x19c>
8113a54c:	e0bff90f 	ldh	r2,-28(fp)
8113a550:	e0fffb17 	ldw	r3,-20(fp)
8113a554:	18800536 	bltu	r3,r2,8113a56c <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8113a558:	e0bfff17 	ldw	r2,-4(fp)
8113a55c:	e0fff817 	ldw	r3,-32(fp)
8113a560:	10c00015 	stw	r3,0(r2)
		result = true;
8113a564:	00800044 	movi	r2,1
8113a568:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
8113a56c:	e0bffa17 	ldw	r2,-24(fp)
}
8113a570:	e037883a 	mov	sp,fp
8113a574:	dfc00117 	ldw	ra,4(sp)
8113a578:	df000017 	ldw	fp,0(sp)
8113a57c:	dec00204 	addi	sp,sp,8
8113a580:	f800283a 	ret

8113a584 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8113a584:	defff604 	addi	sp,sp,-40
8113a588:	de00012e 	bgeu	sp,et,8113a590 <find_first_empty_record_in_a_subdirectory+0xc>
8113a58c:	003b68fa 	trap	3
8113a590:	dfc00915 	stw	ra,36(sp)
8113a594:	df000815 	stw	fp,32(sp)
8113a598:	df000804 	addi	fp,sp,32
8113a59c:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
8113a5a0:	00bfffc4 	movi	r2,-1
8113a5a4:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
8113a5a8:	e0bfff17 	ldw	r2,-4(fp)
8113a5ac:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113a5b0:	e0bff917 	ldw	r2,-28(fp)
8113a5b4:	10ffff84 	addi	r3,r2,-2
8113a5b8:	00a045b4 	movhi	r2,33046
8113a5bc:	10884f04 	addi	r2,r2,8508
8113a5c0:	10800383 	ldbu	r2,14(r2)
8113a5c4:	10803fcc 	andi	r2,r2,255
8113a5c8:	1885383a 	mul	r2,r3,r2
8113a5cc:	1007883a 	mov	r3,r2
8113a5d0:	00a045b4 	movhi	r2,33046
8113a5d4:	10884f04 	addi	r2,r2,8508
8113a5d8:	10801417 	ldw	r2,80(r2)
8113a5dc:	1885883a 	add	r2,r3,r2
8113a5e0:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113a5e4:	e03ffa15 	stw	zero,-24(fp)
8113a5e8:	00002c06 	br	8113a69c <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113a5ec:	e0fffa17 	ldw	r3,-24(fp)
8113a5f0:	e0bffc17 	ldw	r2,-16(fp)
8113a5f4:	1885883a 	add	r2,r3,r2
8113a5f8:	d0e0a217 	ldw	r3,-32120(gp)
8113a5fc:	180b883a 	mov	r5,r3
8113a600:	1009883a 	mov	r4,r2
8113a604:	11382ac0 	call	811382ac <Read_Sector_Data>
8113a608:	10002b26 	beq	r2,zero,8113a6b8 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113a60c:	e03ffb15 	stw	zero,-20(fp)
8113a610:	00001c06 	br	8113a684 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113a614:	e0bffb17 	ldw	r2,-20(fp)
8113a618:	1004917a 	slli	r2,r2,5
8113a61c:	1007883a 	mov	r3,r2
8113a620:	d0a0a417 	ldw	r2,-32112(gp)
8113a624:	10800a17 	ldw	r2,40(r2)
8113a628:	1885883a 	add	r2,r3,r2
8113a62c:	10800023 	ldbuio	r2,0(r2)
8113a630:	10803fcc 	andi	r2,r2,255
8113a634:	10803fcc 	andi	r2,r2,255
8113a638:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
8113a63c:	e0bffd0b 	ldhu	r2,-12(fp)
8113a640:	10803960 	cmpeqi	r2,r2,229
8113a644:	1000021e 	bne	r2,zero,8113a650 <find_first_empty_record_in_a_subdirectory+0xcc>
8113a648:	e0bffd0b 	ldhu	r2,-12(fp)
8113a64c:	10000a1e 	bne	r2,zero,8113a678 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
8113a650:	e0bffa17 	ldw	r2,-24(fp)
8113a654:	1006913a 	slli	r3,r2,4
8113a658:	e0bffb17 	ldw	r2,-20(fp)
8113a65c:	1885883a 	add	r2,r3,r2
8113a660:	1006943a 	slli	r3,r2,16
8113a664:	e0bff917 	ldw	r2,-28(fp)
8113a668:	1884b03a 	or	r2,r3,r2
8113a66c:	e0bff815 	stw	r2,-32(fp)
                        return result;
8113a670:	e0bff817 	ldw	r2,-32(fp)
8113a674:	00005306 	br	8113a7c4 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113a678:	e0bffb17 	ldw	r2,-20(fp)
8113a67c:	10800044 	addi	r2,r2,1
8113a680:	e0bffb15 	stw	r2,-20(fp)
8113a684:	e0bffb17 	ldw	r2,-20(fp)
8113a688:	10800410 	cmplti	r2,r2,16
8113a68c:	103fe11e 	bne	r2,zero,8113a614 <__reset+0xfb11a614>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113a690:	e0bffa17 	ldw	r2,-24(fp)
8113a694:	10800044 	addi	r2,r2,1
8113a698:	e0bffa15 	stw	r2,-24(fp)
8113a69c:	00a045b4 	movhi	r2,33046
8113a6a0:	10884f04 	addi	r2,r2,8508
8113a6a4:	10800383 	ldbu	r2,14(r2)
8113a6a8:	10803fcc 	andi	r2,r2,255
8113a6ac:	e0fffa17 	ldw	r3,-24(fp)
8113a6b0:	18bfce16 	blt	r3,r2,8113a5ec <__reset+0xfb11a5ec>
8113a6b4:	00000106 	br	8113a6bc <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
8113a6b8:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
8113a6bc:	e0bff817 	ldw	r2,-32(fp)
8113a6c0:	1000390e 	bge	r2,zero,8113a7a8 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8113a6c4:	e0bff917 	ldw	r2,-28(fp)
8113a6c8:	e0fffd84 	addi	r3,fp,-10
8113a6cc:	180b883a 	mov	r5,r3
8113a6d0:	1009883a 	mov	r4,r2
8113a6d4:	113838c0 	call	8113838c <get_cluster_flag>
8113a6d8:	10003126 	beq	r2,zero,8113a7a0 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113a6dc:	e0bffd8b 	ldhu	r2,-10(fp)
8113a6e0:	10bfffcc 	andi	r2,r2,65535
8113a6e4:	10fffe0c 	andi	r3,r2,65528
8113a6e8:	00bffe14 	movui	r2,65528
8113a6ec:	18802e1e 	bne	r3,r2,8113a7a8 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
8113a6f0:	e0bffe04 	addi	r2,fp,-8
8113a6f4:	1009883a 	mov	r4,r2
8113a6f8:	113a3d00 	call	8113a3d0 <find_first_empty_cluster>
8113a6fc:	10002326 	beq	r2,zero,8113a78c <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113a700:	e0bff917 	ldw	r2,-28(fp)
8113a704:	e0fffe17 	ldw	r3,-8(fp)
8113a708:	18ffffcc 	andi	r3,r3,65535
8113a70c:	18e0001c 	xori	r3,r3,32768
8113a710:	18e00004 	addi	r3,r3,-32768
8113a714:	01800044 	movi	r6,1
8113a718:	180b883a 	mov	r5,r3
8113a71c:	1009883a 	mov	r4,r2
8113a720:	11384480 	call	81138448 <mark_cluster>
8113a724:	10001926 	beq	r2,zero,8113a78c <find_first_empty_record_in_a_subdirectory+0x208>
8113a728:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113a72c:	01800044 	movi	r6,1
8113a730:	017fffc4 	movi	r5,-1
8113a734:	1009883a 	mov	r4,r2
8113a738:	11384480 	call	81138448 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113a73c:	10001326 	beq	r2,zero,8113a78c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113a740:	e0bff917 	ldw	r2,-28(fp)
8113a744:	e0fffe17 	ldw	r3,-8(fp)
8113a748:	18ffffcc 	andi	r3,r3,65535
8113a74c:	18e0001c 	xori	r3,r3,32768
8113a750:	18e00004 	addi	r3,r3,-32768
8113a754:	000d883a 	mov	r6,zero
8113a758:	180b883a 	mov	r5,r3
8113a75c:	1009883a 	mov	r4,r2
8113a760:	11384480 	call	81138448 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113a764:	10000926 	beq	r2,zero,8113a78c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113a768:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
8113a76c:	000d883a 	mov	r6,zero
8113a770:	017fffc4 	movi	r5,-1
8113a774:	1009883a 	mov	r4,r2
8113a778:	11384480 	call	81138448 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113a77c:	10000326 	beq	r2,zero,8113a78c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
8113a780:	11382580 	call	81138258 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
8113a784:	e0bffe17 	ldw	r2,-8(fp)
8113a788:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
8113a78c:	e0bffd8b 	ldhu	r2,-10(fp)
8113a790:	10bfffcc 	andi	r2,r2,65535
8113a794:	10bffe0c 	andi	r2,r2,65528
8113a798:	e0bff915 	stw	r2,-28(fp)
8113a79c:	00000206 	br	8113a7a8 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
8113a7a0:	00bfffc4 	movi	r2,-1
8113a7a4:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
8113a7a8:	e0bff917 	ldw	r2,-28(fp)
8113a7ac:	00fffdd4 	movui	r3,65527
8113a7b0:	18800316 	blt	r3,r2,8113a7c0 <find_first_empty_record_in_a_subdirectory+0x23c>
8113a7b4:	e0bff817 	ldw	r2,-32(fp)
8113a7b8:	10bfffe0 	cmpeqi	r2,r2,-1
8113a7bc:	103f7c1e 	bne	r2,zero,8113a5b0 <__reset+0xfb11a5b0>
    return result; 
8113a7c0:	e0bff817 	ldw	r2,-32(fp)
}
8113a7c4:	e037883a 	mov	sp,fp
8113a7c8:	dfc00117 	ldw	ra,4(sp)
8113a7cc:	df000017 	ldw	fp,0(sp)
8113a7d0:	dec00204 	addi	sp,sp,8
8113a7d4:	f800283a 	ret

8113a7d8 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
8113a7d8:	defff904 	addi	sp,sp,-28
8113a7dc:	de00012e 	bgeu	sp,et,8113a7e4 <find_first_empty_record_in_root_directory+0xc>
8113a7e0:	003b68fa 	trap	3
8113a7e4:	dfc00615 	stw	ra,24(sp)
8113a7e8:	df000515 	stw	fp,20(sp)
8113a7ec:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113a7f0:	00a045b4 	movhi	r2,33046
8113a7f4:	10884f04 	addi	r2,r2,8508
8113a7f8:	1080050b 	ldhu	r2,20(r2)
8113a7fc:	10bfffcc 	andi	r2,r2,65535
8113a800:	1006917a 	slli	r3,r2,5
8113a804:	00a045b4 	movhi	r2,33046
8113a808:	10884f04 	addi	r2,r2,8508
8113a80c:	1080030b 	ldhu	r2,12(r2)
8113a810:	10bfffcc 	andi	r2,r2,65535
8113a814:	1885283a 	div	r2,r3,r2
8113a818:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
8113a81c:	00bfffc4 	movi	r2,-1
8113a820:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113a824:	e03ffb15 	stw	zero,-20(fp)
8113a828:	00002d06 	br	8113a8e0 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113a82c:	00a045b4 	movhi	r2,33046
8113a830:	10884f04 	addi	r2,r2,8508
8113a834:	10c01317 	ldw	r3,76(r2)
8113a838:	e0bffb17 	ldw	r2,-20(fp)
8113a83c:	1885883a 	add	r2,r3,r2
8113a840:	1007883a 	mov	r3,r2
8113a844:	d0a0a217 	ldw	r2,-32120(gp)
8113a848:	100b883a 	mov	r5,r2
8113a84c:	1809883a 	mov	r4,r3
8113a850:	11382ac0 	call	811382ac <Read_Sector_Data>
8113a854:	10002626 	beq	r2,zero,8113a8f0 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113a858:	e03ffc15 	stw	zero,-16(fp)
8113a85c:	00001a06 	br	8113a8c8 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113a860:	e0bffc17 	ldw	r2,-16(fp)
8113a864:	1004917a 	slli	r2,r2,5
8113a868:	1007883a 	mov	r3,r2
8113a86c:	d0a0a417 	ldw	r2,-32112(gp)
8113a870:	10800a17 	ldw	r2,40(r2)
8113a874:	1885883a 	add	r2,r3,r2
8113a878:	10800023 	ldbuio	r2,0(r2)
8113a87c:	10803fcc 	andi	r2,r2,255
8113a880:	10803fcc 	andi	r2,r2,255
8113a884:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
8113a888:	e0bfff0b 	ldhu	r2,-4(fp)
8113a88c:	10803960 	cmpeqi	r2,r2,229
8113a890:	1000021e 	bne	r2,zero,8113a89c <find_first_empty_record_in_root_directory+0xc4>
8113a894:	e0bfff0b 	ldhu	r2,-4(fp)
8113a898:	1000081e 	bne	r2,zero,8113a8bc <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
8113a89c:	e0bffb17 	ldw	r2,-20(fp)
8113a8a0:	1006913a 	slli	r3,r2,4
8113a8a4:	e0bffc17 	ldw	r2,-16(fp)
8113a8a8:	1885883a 	add	r2,r3,r2
8113a8ac:	1004943a 	slli	r2,r2,16
8113a8b0:	e0bffe15 	stw	r2,-8(fp)
                    return result;
8113a8b4:	e0bffe17 	ldw	r2,-8(fp)
8113a8b8:	00000f06 	br	8113a8f8 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113a8bc:	e0bffc17 	ldw	r2,-16(fp)
8113a8c0:	10800044 	addi	r2,r2,1
8113a8c4:	e0bffc15 	stw	r2,-16(fp)
8113a8c8:	e0bffc17 	ldw	r2,-16(fp)
8113a8cc:	10800410 	cmplti	r2,r2,16
8113a8d0:	103fe31e 	bne	r2,zero,8113a860 <__reset+0xfb11a860>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113a8d4:	e0bffb17 	ldw	r2,-20(fp)
8113a8d8:	10800044 	addi	r2,r2,1
8113a8dc:	e0bffb15 	stw	r2,-20(fp)
8113a8e0:	e0fffb17 	ldw	r3,-20(fp)
8113a8e4:	e0bffd17 	ldw	r2,-12(fp)
8113a8e8:	18bfd016 	blt	r3,r2,8113a82c <__reset+0xfb11a82c>
8113a8ec:	00000106 	br	8113a8f4 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
8113a8f0:	0001883a 	nop
        }
    }
    return result;
8113a8f4:	e0bffe17 	ldw	r2,-8(fp)
}
8113a8f8:	e037883a 	mov	sp,fp
8113a8fc:	dfc00117 	ldw	ra,4(sp)
8113a900:	df000017 	ldw	fp,0(sp)
8113a904:	dec00204 	addi	sp,sp,8
8113a908:	f800283a 	ret

8113a90c <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
8113a90c:	defffa04 	addi	sp,sp,-24
8113a910:	de00012e 	bgeu	sp,et,8113a918 <convert_filename_to_name_extension+0xc>
8113a914:	003b68fa 	trap	3
8113a918:	df000515 	stw	fp,20(sp)
8113a91c:	df000504 	addi	fp,sp,20
8113a920:	e13ffd15 	stw	r4,-12(fp)
8113a924:	e17ffe15 	stw	r5,-8(fp)
8113a928:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
8113a92c:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
8113a930:	e03ffb15 	stw	zero,-20(fp)
8113a934:	00002506 	br	8113a9cc <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8113a938:	e0bffc17 	ldw	r2,-16(fp)
8113a93c:	e0fffd17 	ldw	r3,-12(fp)
8113a940:	1885883a 	add	r2,r3,r2
8113a944:	10800003 	ldbu	r2,0(r2)
8113a948:	10803fcc 	andi	r2,r2,255
8113a94c:	1080201c 	xori	r2,r2,128
8113a950:	10bfe004 	addi	r2,r2,-128
8113a954:	10800ba0 	cmpeqi	r2,r2,46
8113a958:	1000141e 	bne	r2,zero,8113a9ac <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
8113a95c:	e0bffb17 	ldw	r2,-20(fp)
8113a960:	e0fffe17 	ldw	r3,-8(fp)
8113a964:	1885883a 	add	r2,r3,r2
8113a968:	e0fffc17 	ldw	r3,-16(fp)
8113a96c:	e13ffd17 	ldw	r4,-12(fp)
8113a970:	20c7883a 	add	r3,r4,r3
8113a974:	18c00003 	ldbu	r3,0(r3)
8113a978:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
8113a97c:	e0bffc17 	ldw	r2,-16(fp)
8113a980:	e0fffd17 	ldw	r3,-12(fp)
8113a984:	1885883a 	add	r2,r3,r2
8113a988:	10800003 	ldbu	r2,0(r2)
8113a98c:	10803fcc 	andi	r2,r2,255
8113a990:	1080201c 	xori	r2,r2,128
8113a994:	10bfe004 	addi	r2,r2,-128
8113a998:	10000926 	beq	r2,zero,8113a9c0 <convert_filename_to_name_extension+0xb4>
8113a99c:	e0bffc17 	ldw	r2,-16(fp)
8113a9a0:	10800044 	addi	r2,r2,1
8113a9a4:	e0bffc15 	stw	r2,-16(fp)
8113a9a8:	00000506 	br	8113a9c0 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
8113a9ac:	e0bffb17 	ldw	r2,-20(fp)
8113a9b0:	e0fffe17 	ldw	r3,-8(fp)
8113a9b4:	1885883a 	add	r2,r3,r2
8113a9b8:	00c00804 	movi	r3,32
8113a9bc:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
8113a9c0:	e0bffb17 	ldw	r2,-20(fp)
8113a9c4:	10800044 	addi	r2,r2,1
8113a9c8:	e0bffb15 	stw	r2,-20(fp)
8113a9cc:	e0bffb17 	ldw	r2,-20(fp)
8113a9d0:	10800210 	cmplti	r2,r2,8
8113a9d4:	103fd81e 	bne	r2,zero,8113a938 <__reset+0xfb11a938>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
8113a9d8:	e0bffc17 	ldw	r2,-16(fp)
8113a9dc:	e0fffd17 	ldw	r3,-12(fp)
8113a9e0:	1885883a 	add	r2,r3,r2
8113a9e4:	10800003 	ldbu	r2,0(r2)
8113a9e8:	10803fcc 	andi	r2,r2,255
8113a9ec:	1080201c 	xori	r2,r2,128
8113a9f0:	10bfe004 	addi	r2,r2,-128
8113a9f4:	10800b98 	cmpnei	r2,r2,46
8113a9f8:	1000031e 	bne	r2,zero,8113aa08 <convert_filename_to_name_extension+0xfc>
8113a9fc:	e0bffc17 	ldw	r2,-16(fp)
8113aa00:	10800044 	addi	r2,r2,1
8113aa04:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
8113aa08:	e03ffb15 	stw	zero,-20(fp)
8113aa0c:	00001c06 	br	8113aa80 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
8113aa10:	e0bffc17 	ldw	r2,-16(fp)
8113aa14:	e0fffd17 	ldw	r3,-12(fp)
8113aa18:	1885883a 	add	r2,r3,r2
8113aa1c:	10800003 	ldbu	r2,0(r2)
8113aa20:	10803fcc 	andi	r2,r2,255
8113aa24:	1080201c 	xori	r2,r2,128
8113aa28:	10bfe004 	addi	r2,r2,-128
8113aa2c:	10000c26 	beq	r2,zero,8113aa60 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
8113aa30:	e0bffb17 	ldw	r2,-20(fp)
8113aa34:	e0ffff17 	ldw	r3,-4(fp)
8113aa38:	1885883a 	add	r2,r3,r2
8113aa3c:	e0fffc17 	ldw	r3,-16(fp)
8113aa40:	e13ffd17 	ldw	r4,-12(fp)
8113aa44:	20c7883a 	add	r3,r4,r3
8113aa48:	18c00003 	ldbu	r3,0(r3)
8113aa4c:	10c00005 	stb	r3,0(r2)
            local++;
8113aa50:	e0bffc17 	ldw	r2,-16(fp)
8113aa54:	10800044 	addi	r2,r2,1
8113aa58:	e0bffc15 	stw	r2,-16(fp)
8113aa5c:	00000506 	br	8113aa74 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
8113aa60:	e0bffb17 	ldw	r2,-20(fp)
8113aa64:	e0ffff17 	ldw	r3,-4(fp)
8113aa68:	1885883a 	add	r2,r3,r2
8113aa6c:	00c00804 	movi	r3,32
8113aa70:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
8113aa74:	e0bffb17 	ldw	r2,-20(fp)
8113aa78:	10800044 	addi	r2,r2,1
8113aa7c:	e0bffb15 	stw	r2,-20(fp)
8113aa80:	e0bffb17 	ldw	r2,-20(fp)
8113aa84:	108000d0 	cmplti	r2,r2,3
8113aa88:	103fe11e 	bne	r2,zero,8113aa10 <__reset+0xfb11aa10>
        {
            extension[counter] = ' ';
        }
    }

}
8113aa8c:	0001883a 	nop
8113aa90:	e037883a 	mov	sp,fp
8113aa94:	df000017 	ldw	fp,0(sp)
8113aa98:	dec00104 	addi	sp,sp,4
8113aa9c:	f800283a 	ret

8113aaa0 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
8113aaa0:	defff504 	addi	sp,sp,-44
8113aaa4:	de00012e 	bgeu	sp,et,8113aaac <create_file+0xc>
8113aaa8:	003b68fa 	trap	3
8113aaac:	dfc00a15 	stw	ra,40(sp)
8113aab0:	df000915 	stw	fp,36(sp)
8113aab4:	df000904 	addi	fp,sp,36
8113aab8:	e13ffd15 	stw	r4,-12(fp)
8113aabc:	e17ffe15 	stw	r5,-8(fp)
8113aac0:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
8113aac4:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
8113aac8:	e0bffc04 	addi	r2,fp,-16
8113aacc:	1009883a 	mov	r4,r2
8113aad0:	113a3d00 	call	8113a3d0 <find_first_empty_cluster>
8113aad4:	1000a026 	beq	r2,zero,8113ad58 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
8113aad8:	e0bfff17 	ldw	r2,-4(fp)
8113aadc:	10800a17 	ldw	r2,40(r2)
8113aae0:	1000031e 	bne	r2,zero,8113aaf0 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
8113aae4:	113a7d80 	call	8113a7d8 <find_first_empty_record_in_root_directory>
8113aae8:	e0bff815 	stw	r2,-32(fp)
8113aaec:	00000606 	br	8113ab08 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
8113aaf0:	e0bfff17 	ldw	r2,-4(fp)
8113aaf4:	1080058b 	ldhu	r2,22(r2)
8113aaf8:	10bfffcc 	andi	r2,r2,65535
8113aafc:	1009883a 	mov	r4,r2
8113ab00:	113a5840 	call	8113a584 <find_first_empty_record_in_a_subdirectory>
8113ab04:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
8113ab08:	e0bff817 	ldw	r2,-32(fp)
8113ab0c:	10009216 	blt	r2,zero,8113ad58 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
8113ab10:	e13ffd17 	ldw	r4,-12(fp)
8113ab14:	11396b00 	call	811396b0 <get_dir_divider_location>
8113ab18:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
8113ab1c:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
8113ab20:	00000b06 	br	8113ab50 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
8113ab24:	e0fffa17 	ldw	r3,-24(fp)
8113ab28:	e0bff917 	ldw	r2,-28(fp)
8113ab2c:	1885883a 	add	r2,r3,r2
8113ab30:	10800044 	addi	r2,r2,1
8113ab34:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
8113ab38:	e0bffa17 	ldw	r2,-24(fp)
8113ab3c:	e0fffd17 	ldw	r3,-12(fp)
8113ab40:	1885883a 	add	r2,r3,r2
8113ab44:	1009883a 	mov	r4,r2
8113ab48:	11396b00 	call	811396b0 <get_dir_divider_location>
8113ab4c:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
8113ab50:	e0bff917 	ldw	r2,-28(fp)
8113ab54:	00bff316 	blt	zero,r2,8113ab24 <__reset+0xfb11ab24>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
8113ab58:	e0bffa17 	ldw	r2,-24(fp)
8113ab5c:	e0fffd17 	ldw	r3,-12(fp)
8113ab60:	1887883a 	add	r3,r3,r2
8113ab64:	e13ffe17 	ldw	r4,-8(fp)
8113ab68:	e0bffe17 	ldw	r2,-8(fp)
8113ab6c:	10800204 	addi	r2,r2,8
8113ab70:	100d883a 	mov	r6,r2
8113ab74:	200b883a 	mov	r5,r4
8113ab78:	1809883a 	mov	r4,r3
8113ab7c:	113a90c0 	call	8113a90c <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
8113ab80:	e0bffe17 	ldw	r2,-8(fp)
8113ab84:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
8113ab88:	e0bffe17 	ldw	r2,-8(fp)
8113ab8c:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
8113ab90:	e0bffe17 	ldw	r2,-8(fp)
8113ab94:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
8113ab98:	e0bffe17 	ldw	r2,-8(fp)
8113ab9c:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
8113aba0:	e0bffe17 	ldw	r2,-8(fp)
8113aba4:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
8113aba8:	e0bffe17 	ldw	r2,-8(fp)
8113abac:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
8113abb0:	e0bffc17 	ldw	r2,-16(fp)
8113abb4:	1007883a 	mov	r3,r2
8113abb8:	e0bffe17 	ldw	r2,-8(fp)
8113abbc:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
8113abc0:	e0bffe17 	ldw	r2,-8(fp)
8113abc4:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
8113abc8:	e0fffc17 	ldw	r3,-16(fp)
8113abcc:	e0bffe17 	ldw	r2,-8(fp)
8113abd0:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
8113abd4:	e0bffe17 	ldw	r2,-8(fp)
8113abd8:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
8113abdc:	e0bffe17 	ldw	r2,-8(fp)
8113abe0:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
8113abe4:	e0bff817 	ldw	r2,-32(fp)
8113abe8:	10ffffcc 	andi	r3,r2,65535
8113abec:	e0bffe17 	ldw	r2,-8(fp)
8113abf0:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
8113abf4:	e0bff817 	ldw	r2,-32(fp)
8113abf8:	1004d43a 	srli	r2,r2,16
8113abfc:	1000010e 	bge	r2,zero,8113ac04 <create_file+0x164>
8113ac00:	108003c4 	addi	r2,r2,15
8113ac04:	1005d13a 	srai	r2,r2,4
8113ac08:	1007883a 	mov	r3,r2
8113ac0c:	e0bffe17 	ldw	r2,-8(fp)
8113ac10:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
8113ac14:	e0bff817 	ldw	r2,-32(fp)
8113ac18:	1004d43a 	srli	r2,r2,16
8113ac1c:	1007883a 	mov	r3,r2
8113ac20:	00a00034 	movhi	r2,32768
8113ac24:	108003c4 	addi	r2,r2,15
8113ac28:	1884703a 	and	r2,r3,r2
8113ac2c:	1000040e 	bge	r2,zero,8113ac40 <create_file+0x1a0>
8113ac30:	10bfffc4 	addi	r2,r2,-1
8113ac34:	00fffc04 	movi	r3,-16
8113ac38:	10c4b03a 	or	r2,r2,r3
8113ac3c:	10800044 	addi	r2,r2,1
8113ac40:	1004917a 	slli	r2,r2,5
8113ac44:	1007883a 	mov	r3,r2
8113ac48:	e0bffe17 	ldw	r2,-8(fp)
8113ac4c:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
8113ac50:	e0bfff17 	ldw	r2,-4(fp)
8113ac54:	1080058b 	ldhu	r2,22(r2)
8113ac58:	10ffffcc 	andi	r3,r2,65535
8113ac5c:	e0bffe17 	ldw	r2,-8(fp)
8113ac60:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
8113ac64:	e0bffe17 	ldw	r2,-8(fp)
8113ac68:	00c00044 	movi	r3,1
8113ac6c:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
8113ac70:	e0bffe17 	ldw	r2,-8(fp)
8113ac74:	00c00044 	movi	r3,1
8113ac78:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113ac7c:	e0bffe17 	ldw	r2,-8(fp)
8113ac80:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113ac84:	1000071e 	bne	r2,zero,8113aca4 <create_file+0x204>
8113ac88:	00a045b4 	movhi	r2,33046
8113ac8c:	10884f04 	addi	r2,r2,8508
8113ac90:	10c01317 	ldw	r3,76(r2)
8113ac94:	e0bffe17 	ldw	r2,-8(fp)
8113ac98:	10800b17 	ldw	r2,44(r2)
8113ac9c:	1885883a 	add	r2,r3,r2
8113aca0:	00000f06 	br	8113ace0 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
8113aca4:	00a045b4 	movhi	r2,33046
8113aca8:	10884f04 	addi	r2,r2,8508
8113acac:	10c01417 	ldw	r3,80(r2)
8113acb0:	e0bffe17 	ldw	r2,-8(fp)
8113acb4:	10800a17 	ldw	r2,40(r2)
8113acb8:	113fff84 	addi	r4,r2,-2
8113acbc:	00a045b4 	movhi	r2,33046
8113acc0:	10884f04 	addi	r2,r2,8508
8113acc4:	10800383 	ldbu	r2,14(r2)
8113acc8:	10803fcc 	andi	r2,r2,255
8113accc:	2085383a 	mul	r2,r4,r2
8113acd0:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
8113acd4:	e0bffe17 	ldw	r2,-8(fp)
8113acd8:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113acdc:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113ace0:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
8113ace4:	e0bffb17 	ldw	r2,-20(fp)
8113ace8:	d0e0a217 	ldw	r3,-32120(gp)
8113acec:	180b883a 	mov	r5,r3
8113acf0:	1009883a 	mov	r4,r2
8113acf4:	11382ac0 	call	811382ac <Read_Sector_Data>
8113acf8:	10001726 	beq	r2,zero,8113ad58 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
8113acfc:	e0bffe17 	ldw	r2,-8(fp)
8113ad00:	10800c0b 	ldhu	r2,48(r2)
8113ad04:	10bfffcc 	andi	r2,r2,65535
8113ad08:	10a0001c 	xori	r2,r2,32768
8113ad0c:	10a00004 	addi	r2,r2,-32768
8113ad10:	e17ffe17 	ldw	r5,-8(fp)
8113ad14:	1009883a 	mov	r4,r2
8113ad18:	11389600 	call	81138960 <Write_File_Record_At_Offset>
8113ad1c:	10000e26 	beq	r2,zero,8113ad58 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
8113ad20:	11382580 	call	81138258 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
8113ad24:	e0bffc17 	ldw	r2,-16(fp)
8113ad28:	01800044 	movi	r6,1
8113ad2c:	017fffc4 	movi	r5,-1
8113ad30:	1009883a 	mov	r4,r2
8113ad34:	11384480 	call	81138448 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
8113ad38:	e0bffc17 	ldw	r2,-16(fp)
8113ad3c:	000d883a 	mov	r6,zero
8113ad40:	017fffc4 	movi	r5,-1
8113ad44:	1009883a 	mov	r4,r2
8113ad48:	11384480 	call	81138448 <mark_cluster>
8113ad4c:	10000226 	beq	r2,zero,8113ad58 <create_file+0x2b8>
                    {
                        result = true;
8113ad50:	00800044 	movi	r2,1
8113ad54:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
8113ad58:	e0bff717 	ldw	r2,-36(fp)
}
8113ad5c:	e037883a 	mov	sp,fp
8113ad60:	dfc00117 	ldw	ra,4(sp)
8113ad64:	df000017 	ldw	fp,0(sp)
8113ad68:	dec00204 	addi	sp,sp,8
8113ad6c:	f800283a 	ret

8113ad70 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
8113ad70:	defffb04 	addi	sp,sp,-20
8113ad74:	de00012e 	bgeu	sp,et,8113ad7c <copy_file_record_name_to_string+0xc>
8113ad78:	003b68fa 	trap	3
8113ad7c:	df000415 	stw	fp,16(sp)
8113ad80:	df000404 	addi	fp,sp,16
8113ad84:	e13ffe15 	stw	r4,-8(fp)
8113ad88:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
8113ad8c:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113ad90:	e03ffc15 	stw	zero,-16(fp)
8113ad94:	00001506 	br	8113adec <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
8113ad98:	e0fffe17 	ldw	r3,-8(fp)
8113ad9c:	e0bffc17 	ldw	r2,-16(fp)
8113ada0:	1885883a 	add	r2,r3,r2
8113ada4:	10800003 	ldbu	r2,0(r2)
8113ada8:	10803fcc 	andi	r2,r2,255
8113adac:	10800820 	cmpeqi	r2,r2,32
8113adb0:	10000b1e 	bne	r2,zero,8113ade0 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
8113adb4:	e0bffd17 	ldw	r2,-12(fp)
8113adb8:	e0ffff17 	ldw	r3,-4(fp)
8113adbc:	1885883a 	add	r2,r3,r2
8113adc0:	e13ffe17 	ldw	r4,-8(fp)
8113adc4:	e0fffc17 	ldw	r3,-16(fp)
8113adc8:	20c7883a 	add	r3,r4,r3
8113adcc:	18c00003 	ldbu	r3,0(r3)
8113add0:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
8113add4:	e0bffd17 	ldw	r2,-12(fp)
8113add8:	10800044 	addi	r2,r2,1
8113addc:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113ade0:	e0bffc17 	ldw	r2,-16(fp)
8113ade4:	10800044 	addi	r2,r2,1
8113ade8:	e0bffc15 	stw	r2,-16(fp)
8113adec:	e0bffc17 	ldw	r2,-16(fp)
8113adf0:	10800210 	cmplti	r2,r2,8
8113adf4:	103fe81e 	bne	r2,zero,8113ad98 <__reset+0xfb11ad98>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
8113adf8:	e0bffe17 	ldw	r2,-8(fp)
8113adfc:	10800203 	ldbu	r2,8(r2)
8113ae00:	10803fcc 	andi	r2,r2,255
8113ae04:	10800820 	cmpeqi	r2,r2,32
8113ae08:	1000241e 	bne	r2,zero,8113ae9c <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
8113ae0c:	e0bffd17 	ldw	r2,-12(fp)
8113ae10:	e0ffff17 	ldw	r3,-4(fp)
8113ae14:	1885883a 	add	r2,r3,r2
8113ae18:	00c00b84 	movi	r3,46
8113ae1c:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
8113ae20:	e0bffd17 	ldw	r2,-12(fp)
8113ae24:	10800044 	addi	r2,r2,1
8113ae28:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
8113ae2c:	e03ffc15 	stw	zero,-16(fp)
8113ae30:	00001706 	br	8113ae90 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
8113ae34:	e0fffe17 	ldw	r3,-8(fp)
8113ae38:	e0bffc17 	ldw	r2,-16(fp)
8113ae3c:	1885883a 	add	r2,r3,r2
8113ae40:	10800204 	addi	r2,r2,8
8113ae44:	10800003 	ldbu	r2,0(r2)
8113ae48:	10803fcc 	andi	r2,r2,255
8113ae4c:	10800820 	cmpeqi	r2,r2,32
8113ae50:	10000c1e 	bne	r2,zero,8113ae84 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
8113ae54:	e0bffd17 	ldw	r2,-12(fp)
8113ae58:	e0ffff17 	ldw	r3,-4(fp)
8113ae5c:	1885883a 	add	r2,r3,r2
8113ae60:	e13ffe17 	ldw	r4,-8(fp)
8113ae64:	e0fffc17 	ldw	r3,-16(fp)
8113ae68:	20c7883a 	add	r3,r4,r3
8113ae6c:	18c00204 	addi	r3,r3,8
8113ae70:	18c00003 	ldbu	r3,0(r3)
8113ae74:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
8113ae78:	e0bffd17 	ldw	r2,-12(fp)
8113ae7c:	10800044 	addi	r2,r2,1
8113ae80:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
8113ae84:	e0bffc17 	ldw	r2,-16(fp)
8113ae88:	10800044 	addi	r2,r2,1
8113ae8c:	e0bffc15 	stw	r2,-16(fp)
8113ae90:	e0bffc17 	ldw	r2,-16(fp)
8113ae94:	108000d0 	cmplti	r2,r2,3
8113ae98:	103fe61e 	bne	r2,zero,8113ae34 <__reset+0xfb11ae34>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
8113ae9c:	e0bffd17 	ldw	r2,-12(fp)
8113aea0:	e0ffff17 	ldw	r3,-4(fp)
8113aea4:	1885883a 	add	r2,r3,r2
8113aea8:	10000005 	stb	zero,0(r2)
}
8113aeac:	0001883a 	nop
8113aeb0:	e037883a 	mov	sp,fp
8113aeb4:	df000017 	ldw	fp,0(sp)
8113aeb8:	dec00104 	addi	sp,sp,4
8113aebc:	f800283a 	ret

8113aec0 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
8113aec0:	defffc04 	addi	sp,sp,-16
8113aec4:	de00012e 	bgeu	sp,et,8113aecc <alt_up_sd_card_open_dev+0xc>
8113aec8:	003b68fa 	trap	3
8113aecc:	dfc00315 	stw	ra,12(sp)
8113aed0:	df000215 	stw	fp,8(sp)
8113aed4:	df000204 	addi	fp,sp,8
8113aed8:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
8113aedc:	d1600d04 	addi	r5,gp,-32716
8113aee0:	e13fff17 	ldw	r4,-4(fp)
8113aee4:	114037c0 	call	8114037c <alt_find_dev>
8113aee8:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
8113aeec:	e0bffe17 	ldw	r2,-8(fp)
8113aef0:	10001e26 	beq	r2,zero,8113af6c <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
8113aef4:	e0bffe17 	ldw	r2,-8(fp)
8113aef8:	10800a17 	ldw	r2,40(r2)
8113aefc:	10808d04 	addi	r2,r2,564
8113af00:	d0a09c15 	stw	r2,-32144(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
8113af04:	e0bffe17 	ldw	r2,-8(fp)
8113af08:	10800a17 	ldw	r2,40(r2)
8113af0c:	10808904 	addi	r2,r2,548
8113af10:	d0a09d15 	stw	r2,-32140(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
8113af14:	e0bffe17 	ldw	r2,-8(fp)
8113af18:	10800a17 	ldw	r2,40(r2)
8113af1c:	10808404 	addi	r2,r2,528
8113af20:	d0a09e15 	stw	r2,-32136(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
8113af24:	e0bffe17 	ldw	r2,-8(fp)
8113af28:	10800a17 	ldw	r2,40(r2)
8113af2c:	10808c04 	addi	r2,r2,560
8113af30:	d0a09f15 	stw	r2,-32132(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
8113af34:	e0bffe17 	ldw	r2,-8(fp)
8113af38:	10800a17 	ldw	r2,40(r2)
8113af3c:	10808b04 	addi	r2,r2,556
8113af40:	d0a0a015 	stw	r2,-32128(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
8113af44:	e0bffe17 	ldw	r2,-8(fp)
8113af48:	10800a17 	ldw	r2,40(r2)
8113af4c:	d0a0a115 	stw	r2,-32124(gp)
		device_pointer = dev;
8113af50:	e0bffe17 	ldw	r2,-8(fp)
8113af54:	d0a0a415 	stw	r2,-32112(gp)
		initialized = false;
8113af58:	d0209a15 	stw	zero,-32152(gp)
		is_sd_card_formated_as_FAT16 = false;
8113af5c:	d0209b15 	stw	zero,-32148(gp)
		search_data.valid = false;
8113af60:	00a045b4 	movhi	r2,33046
8113af64:	10884a04 	addi	r2,r2,8488
8113af68:	10000415 	stw	zero,16(r2)
	}
	return dev;
8113af6c:	e0bffe17 	ldw	r2,-8(fp)
}
8113af70:	e037883a 	mov	sp,fp
8113af74:	dfc00117 	ldw	ra,4(sp)
8113af78:	df000017 	ldw	fp,0(sp)
8113af7c:	dec00204 	addi	sp,sp,8
8113af80:	f800283a 	ret

8113af84 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
8113af84:	defffd04 	addi	sp,sp,-12
8113af88:	de00012e 	bgeu	sp,et,8113af90 <alt_up_sd_card_is_Present+0xc>
8113af8c:	003b68fa 	trap	3
8113af90:	df000215 	stw	fp,8(sp)
8113af94:	df000204 	addi	fp,sp,8
    bool result = false;
8113af98:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
8113af9c:	d0a0a417 	ldw	r2,-32112(gp)
8113afa0:	10000826 	beq	r2,zero,8113afc4 <alt_up_sd_card_is_Present+0x40>
8113afa4:	d0a09c17 	ldw	r2,-32144(gp)
8113afa8:	1080002b 	ldhuio	r2,0(r2)
8113afac:	10bfffcc 	andi	r2,r2,65535
8113afb0:	1080008c 	andi	r2,r2,2
8113afb4:	10000326 	beq	r2,zero,8113afc4 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
8113afb8:	00800044 	movi	r2,1
8113afbc:	e0bffe15 	stw	r2,-8(fp)
8113afc0:	00001e06 	br	8113b03c <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
8113afc4:	d0a09a17 	ldw	r2,-32152(gp)
8113afc8:	10800058 	cmpnei	r2,r2,1
8113afcc:	10001b1e 	bne	r2,zero,8113b03c <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
8113afd0:	d0209a15 	stw	zero,-32152(gp)
		search_data.valid = false;
8113afd4:	00a045b4 	movhi	r2,33046
8113afd8:	10884a04 	addi	r2,r2,8488
8113afdc:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
8113afe0:	d0209b15 	stw	zero,-32148(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113afe4:	e03fff15 	stw	zero,-4(fp)
8113afe8:	00001106 	br	8113b030 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
8113afec:	00a045b4 	movhi	r2,33046
8113aff0:	10886404 	addi	r2,r2,8592
8113aff4:	e0ffff17 	ldw	r3,-4(fp)
8113aff8:	180691ba 	slli	r3,r3,6
8113affc:	10c5883a 	add	r2,r2,r3
8113b000:	10800f04 	addi	r2,r2,60
8113b004:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
8113b008:	00a045b4 	movhi	r2,33046
8113b00c:	10886404 	addi	r2,r2,8592
8113b010:	e0ffff17 	ldw	r3,-4(fp)
8113b014:	180691ba 	slli	r3,r3,6
8113b018:	10c5883a 	add	r2,r2,r3
8113b01c:	10800e04 	addi	r2,r2,56
8113b020:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113b024:	e0bfff17 	ldw	r2,-4(fp)
8113b028:	10800044 	addi	r2,r2,1
8113b02c:	e0bfff15 	stw	r2,-4(fp)
8113b030:	e0bfff17 	ldw	r2,-4(fp)
8113b034:	10800510 	cmplti	r2,r2,20
8113b038:	103fec1e 	bne	r2,zero,8113afec <__reset+0xfb11afec>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
8113b03c:	e0bffe17 	ldw	r2,-8(fp)
}
8113b040:	e037883a 	mov	sp,fp
8113b044:	df000017 	ldw	fp,0(sp)
8113b048:	dec00104 	addi	sp,sp,4
8113b04c:	f800283a 	ret

8113b050 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
8113b050:	defffd04 	addi	sp,sp,-12
8113b054:	de00012e 	bgeu	sp,et,8113b05c <alt_up_sd_card_is_FAT16+0xc>
8113b058:	003b68fa 	trap	3
8113b05c:	dfc00215 	stw	ra,8(sp)
8113b060:	df000115 	stw	fp,4(sp)
8113b064:	df000104 	addi	fp,sp,4
	bool result = false;
8113b068:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
8113b06c:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
8113b070:	10000c26 	beq	r2,zero,8113b0a4 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
8113b074:	d0a09a17 	ldw	r2,-32152(gp)
8113b078:	1000071e 	bne	r2,zero,8113b098 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
8113b07c:	113927c0 	call	8113927c <Look_for_FAT16>
8113b080:	d0a09b15 	stw	r2,-32148(gp)
			initialized = is_sd_card_formated_as_FAT16;
8113b084:	d0a09b17 	ldw	r2,-32148(gp)
8113b088:	d0a09a15 	stw	r2,-32152(gp)
			search_data.valid = false;
8113b08c:	00a045b4 	movhi	r2,33046
8113b090:	10884a04 	addi	r2,r2,8488
8113b094:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
8113b098:	d0a09b17 	ldw	r2,-32148(gp)
8113b09c:	e0bfff15 	stw	r2,-4(fp)
8113b0a0:	00000206 	br	8113b0ac <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
8113b0a4:	d0209a15 	stw	zero,-32152(gp)
		is_sd_card_formated_as_FAT16 = false;
8113b0a8:	d0209b15 	stw	zero,-32148(gp)
	}

	return result;
8113b0ac:	e0bfff17 	ldw	r2,-4(fp)
}
8113b0b0:	e037883a 	mov	sp,fp
8113b0b4:	dfc00117 	ldw	ra,4(sp)
8113b0b8:	df000017 	ldw	fp,0(sp)
8113b0bc:	dec00204 	addi	sp,sp,8
8113b0c0:	f800283a 	ret

8113b0c4 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
8113b0c4:	deffea04 	addi	sp,sp,-88
8113b0c8:	de00012e 	bgeu	sp,et,8113b0d0 <alt_up_sd_card_find_first+0xc>
8113b0cc:	003b68fa 	trap	3
8113b0d0:	dfc01515 	stw	ra,84(sp)
8113b0d4:	df001415 	stw	fp,80(sp)
8113b0d8:	df001404 	addi	fp,sp,80
8113b0dc:	e13ffe15 	stw	r4,-8(fp)
8113b0e0:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
8113b0e4:	00800084 	movi	r2,2
8113b0e8:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113b0ec:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
8113b0f0:	10002426 	beq	r2,zero,8113b184 <alt_up_sd_card_find_first+0xc0>
8113b0f4:	d0a09b17 	ldw	r2,-32148(gp)
8113b0f8:	10002226 	beq	r2,zero,8113b184 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
8113b0fc:	e0ffee04 	addi	r3,fp,-72
8113b100:	e0bfed04 	addi	r2,fp,-76
8113b104:	180d883a 	mov	r6,r3
8113b108:	100b883a 	mov	r5,r2
8113b10c:	e13ffe17 	ldw	r4,-8(fp)
8113b110:	1139a140 	call	81139a14 <get_home_directory_cluster_for_file>
8113b114:	10001926 	beq	r2,zero,8113b17c <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
8113b118:	e0bfed17 	ldw	r2,-76(fp)
8113b11c:	1007883a 	mov	r3,r2
8113b120:	00a045b4 	movhi	r2,33046
8113b124:	10884a04 	addi	r2,r2,8488
8113b128:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
8113b12c:	e0bfed17 	ldw	r2,-76(fp)
8113b130:	1007883a 	mov	r3,r2
8113b134:	00a045b4 	movhi	r2,33046
8113b138:	10884a04 	addi	r2,r2,8488
8113b13c:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
8113b140:	00a045b4 	movhi	r2,33046
8113b144:	10884a04 	addi	r2,r2,8488
8113b148:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
8113b14c:	00a045b4 	movhi	r2,33046
8113b150:	10884a04 	addi	r2,r2,8488
8113b154:	00ffffc4 	movi	r3,-1
8113b158:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
8113b15c:	00a045b4 	movhi	r2,33046
8113b160:	10884a04 	addi	r2,r2,8488
8113b164:	00c00044 	movi	r3,1
8113b168:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
8113b16c:	e13fff17 	ldw	r4,-4(fp)
8113b170:	113b19c0 	call	8113b19c <alt_up_sd_card_find_next>
8113b174:	e0bfec0d 	sth	r2,-80(fp)
8113b178:	00000206 	br	8113b184 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
8113b17c:	00800044 	movi	r2,1
8113b180:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
8113b184:	e0bfec0b 	ldhu	r2,-80(fp)
}
8113b188:	e037883a 	mov	sp,fp
8113b18c:	dfc00117 	ldw	ra,4(sp)
8113b190:	df000017 	ldw	fp,0(sp)
8113b194:	dec00204 	addi	sp,sp,8
8113b198:	f800283a 	ret

8113b19c <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
8113b19c:	deffe404 	addi	sp,sp,-112
8113b1a0:	de00012e 	bgeu	sp,et,8113b1a8 <alt_up_sd_card_find_next+0xc>
8113b1a4:	003b68fa 	trap	3
8113b1a8:	dfc01b15 	stw	ra,108(sp)
8113b1ac:	df001a15 	stw	fp,104(sp)
8113b1b0:	df001a04 	addi	fp,sp,104
8113b1b4:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
8113b1b8:	00800084 	movi	r2,2
8113b1bc:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113b1c0:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
8113b1c4:	1000df26 	beq	r2,zero,8113b544 <alt_up_sd_card_find_next+0x3a8>
8113b1c8:	d0a09b17 	ldw	r2,-32148(gp)
8113b1cc:	1000dd26 	beq	r2,zero,8113b544 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
8113b1d0:	00a045b4 	movhi	r2,33046
8113b1d4:	10884a04 	addi	r2,r2,8488
8113b1d8:	10800417 	ldw	r2,16(r2)
8113b1dc:	1000d726 	beq	r2,zero,8113b53c <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
8113b1e0:	00a045b4 	movhi	r2,33046
8113b1e4:	10884a04 	addi	r2,r2,8488
8113b1e8:	10800117 	ldw	r2,4(r2)
8113b1ec:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
8113b1f0:	e0bfe717 	ldw	r2,-100(fp)
8113b1f4:	1000561e 	bne	r2,zero,8113b350 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113b1f8:	00a045b4 	movhi	r2,33046
8113b1fc:	10884f04 	addi	r2,r2,8508
8113b200:	1080050b 	ldhu	r2,20(r2)
8113b204:	10bfffcc 	andi	r2,r2,65535
8113b208:	1006917a 	slli	r3,r2,5
8113b20c:	00a045b4 	movhi	r2,33046
8113b210:	10884f04 	addi	r2,r2,8508
8113b214:	1080030b 	ldhu	r2,12(r2)
8113b218:	10bfffcc 	andi	r2,r2,65535
8113b21c:	1885283a 	div	r2,r3,r2
8113b220:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
8113b224:	00a045b4 	movhi	r2,33046
8113b228:	10884a04 	addi	r2,r2,8488
8113b22c:	10800217 	ldw	r2,8(r2)
8113b230:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
8113b234:	00a045b4 	movhi	r2,33046
8113b238:	10884a04 	addi	r2,r2,8488
8113b23c:	1080030b 	ldhu	r2,12(r2)
8113b240:	10bfffcc 	andi	r2,r2,65535
8113b244:	10a0001c 	xori	r2,r2,32768
8113b248:	10a00004 	addi	r2,r2,-32768
8113b24c:	10800044 	addi	r2,r2,1
8113b250:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8113b254:	00003606 	br	8113b330 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113b258:	00a045b4 	movhi	r2,33046
8113b25c:	10884f04 	addi	r2,r2,8508
8113b260:	10c01317 	ldw	r3,76(r2)
8113b264:	e0bfe817 	ldw	r2,-96(fp)
8113b268:	1885883a 	add	r2,r3,r2
8113b26c:	1007883a 	mov	r3,r2
8113b270:	d0a0a217 	ldw	r2,-32120(gp)
8113b274:	100b883a 	mov	r5,r2
8113b278:	1809883a 	mov	r4,r3
8113b27c:	11382ac0 	call	811382ac <Read_Sector_Data>
8113b280:	10002f26 	beq	r2,zero,8113b340 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8113b284:	00002306 	br	8113b314 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
8113b288:	e0bfe917 	ldw	r2,-92(fp)
8113b28c:	1004917a 	slli	r2,r2,5
8113b290:	e13fe817 	ldw	r4,-96(fp)
8113b294:	e0ffef04 	addi	r3,fp,-68
8113b298:	200f883a 	mov	r7,r4
8113b29c:	000d883a 	mov	r6,zero
8113b2a0:	180b883a 	mov	r5,r3
8113b2a4:	1009883a 	mov	r4,r2
8113b2a8:	11386dc0 	call	811386dc <Read_File_Record_At_Offset>
8113b2ac:	10001626 	beq	r2,zero,8113b308 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
8113b2b0:	e0bfef03 	ldbu	r2,-68(fp)
8113b2b4:	10803fcc 	andi	r2,r2,255
8113b2b8:	10001326 	beq	r2,zero,8113b308 <alt_up_sd_card_find_next+0x16c>
8113b2bc:	e0bfef03 	ldbu	r2,-68(fp)
8113b2c0:	10803fcc 	andi	r2,r2,255
8113b2c4:	10803960 	cmpeqi	r2,r2,229
8113b2c8:	10000f1e 	bne	r2,zero,8113b308 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
8113b2cc:	e0bfe917 	ldw	r2,-92(fp)
8113b2d0:	1007883a 	mov	r3,r2
8113b2d4:	00a045b4 	movhi	r2,33046
8113b2d8:	10884a04 	addi	r2,r2,8488
8113b2dc:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
8113b2e0:	e0ffe817 	ldw	r3,-96(fp)
8113b2e4:	00a045b4 	movhi	r2,33046
8113b2e8:	10884a04 	addi	r2,r2,8488
8113b2ec:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
8113b2f0:	e0bfef04 	addi	r2,fp,-68
8113b2f4:	e17fff17 	ldw	r5,-4(fp)
8113b2f8:	1009883a 	mov	r4,r2
8113b2fc:	113ad700 	call	8113ad70 <copy_file_record_name_to_string>
									return 0;
8113b300:	0005883a 	mov	r2,zero
8113b304:	00009006 	br	8113b548 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8113b308:	e0bfe917 	ldw	r2,-92(fp)
8113b30c:	10800044 	addi	r2,r2,1
8113b310:	e0bfe915 	stw	r2,-92(fp)
8113b314:	e0bfe917 	ldw	r2,-92(fp)
8113b318:	10800410 	cmplti	r2,r2,16
8113b31c:	103fda1e 	bne	r2,zero,8113b288 <__reset+0xfb11b288>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
8113b320:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8113b324:	e0bfe817 	ldw	r2,-96(fp)
8113b328:	10800044 	addi	r2,r2,1
8113b32c:	e0bfe815 	stw	r2,-96(fp)
8113b330:	e0ffe817 	ldw	r3,-96(fp)
8113b334:	e0bfec17 	ldw	r2,-80(fp)
8113b338:	18bfc716 	blt	r3,r2,8113b258 <__reset+0xfb11b258>
8113b33c:	00000106 	br	8113b344 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
8113b340:	0001883a 	nop
					}
				}
				result = -1;
8113b344:	00bfffc4 	movi	r2,-1
8113b348:	e0bfe60d 	sth	r2,-104(fp)
8113b34c:	00007d06 	br	8113b544 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
8113b350:	00a045b4 	movhi	r2,33046
8113b354:	10884a04 	addi	r2,r2,8488
8113b358:	1080030b 	ldhu	r2,12(r2)
8113b35c:	10bfffcc 	andi	r2,r2,65535
8113b360:	10a0001c 	xori	r2,r2,32768
8113b364:	10a00004 	addi	r2,r2,-32768
8113b368:	10800044 	addi	r2,r2,1
8113b36c:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113b370:	e0bfe717 	ldw	r2,-100(fp)
8113b374:	10ffff84 	addi	r3,r2,-2
8113b378:	00a045b4 	movhi	r2,33046
8113b37c:	10884f04 	addi	r2,r2,8508
8113b380:	10800383 	ldbu	r2,14(r2)
8113b384:	10803fcc 	andi	r2,r2,255
8113b388:	1885383a 	mul	r2,r3,r2
8113b38c:	1007883a 	mov	r3,r2
8113b390:	00a045b4 	movhi	r2,33046
8113b394:	10884f04 	addi	r2,r2,8508
8113b398:	10801417 	ldw	r2,80(r2)
8113b39c:	1885883a 	add	r2,r3,r2
8113b3a0:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
8113b3a4:	00a045b4 	movhi	r2,33046
8113b3a8:	10884a04 	addi	r2,r2,8488
8113b3ac:	10800217 	ldw	r2,8(r2)
8113b3b0:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113b3b4:	00003806 	br	8113b498 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113b3b8:	e0ffeb17 	ldw	r3,-84(fp)
8113b3bc:	e0bfed17 	ldw	r2,-76(fp)
8113b3c0:	1885883a 	add	r2,r3,r2
8113b3c4:	d0e0a217 	ldw	r3,-32120(gp)
8113b3c8:	180b883a 	mov	r5,r3
8113b3cc:	1009883a 	mov	r4,r2
8113b3d0:	11382ac0 	call	811382ac <Read_Sector_Data>
8113b3d4:	10003726 	beq	r2,zero,8113b4b4 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
8113b3d8:	00002806 	br	8113b47c <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
8113b3dc:	e0bfea17 	ldw	r2,-88(fp)
8113b3e0:	1004917a 	slli	r2,r2,5
8113b3e4:	e13fe717 	ldw	r4,-100(fp)
8113b3e8:	e17feb17 	ldw	r5,-84(fp)
8113b3ec:	e0ffef04 	addi	r3,fp,-68
8113b3f0:	280f883a 	mov	r7,r5
8113b3f4:	200d883a 	mov	r6,r4
8113b3f8:	180b883a 	mov	r5,r3
8113b3fc:	1009883a 	mov	r4,r2
8113b400:	11386dc0 	call	811386dc <Read_File_Record_At_Offset>
8113b404:	10001a26 	beq	r2,zero,8113b470 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
8113b408:	e0bfef03 	ldbu	r2,-68(fp)
8113b40c:	10803fcc 	andi	r2,r2,255
8113b410:	10001726 	beq	r2,zero,8113b470 <alt_up_sd_card_find_next+0x2d4>
8113b414:	e0bfef03 	ldbu	r2,-68(fp)
8113b418:	10803fcc 	andi	r2,r2,255
8113b41c:	10803960 	cmpeqi	r2,r2,229
8113b420:	1000131e 	bne	r2,zero,8113b470 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
8113b424:	e0ffe717 	ldw	r3,-100(fp)
8113b428:	00a045b4 	movhi	r2,33046
8113b42c:	10884a04 	addi	r2,r2,8488
8113b430:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
8113b434:	e0bfea17 	ldw	r2,-88(fp)
8113b438:	1007883a 	mov	r3,r2
8113b43c:	00a045b4 	movhi	r2,33046
8113b440:	10884a04 	addi	r2,r2,8488
8113b444:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
8113b448:	e0ffeb17 	ldw	r3,-84(fp)
8113b44c:	00a045b4 	movhi	r2,33046
8113b450:	10884a04 	addi	r2,r2,8488
8113b454:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
8113b458:	e0bfef04 	addi	r2,fp,-68
8113b45c:	e17fff17 	ldw	r5,-4(fp)
8113b460:	1009883a 	mov	r4,r2
8113b464:	113ad700 	call	8113ad70 <copy_file_record_name_to_string>
										return 0;
8113b468:	0005883a 	mov	r2,zero
8113b46c:	00003606 	br	8113b548 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
8113b470:	e0bfea17 	ldw	r2,-88(fp)
8113b474:	10800044 	addi	r2,r2,1
8113b478:	e0bfea15 	stw	r2,-88(fp)
8113b47c:	e0bfea17 	ldw	r2,-88(fp)
8113b480:	10800410 	cmplti	r2,r2,16
8113b484:	103fd51e 	bne	r2,zero,8113b3dc <__reset+0xfb11b3dc>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
8113b488:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113b48c:	e0bfeb17 	ldw	r2,-84(fp)
8113b490:	10800044 	addi	r2,r2,1
8113b494:	e0bfeb15 	stw	r2,-84(fp)
8113b498:	00a045b4 	movhi	r2,33046
8113b49c:	10884f04 	addi	r2,r2,8508
8113b4a0:	10800383 	ldbu	r2,14(r2)
8113b4a4:	10803fcc 	andi	r2,r2,255
8113b4a8:	e0ffeb17 	ldw	r3,-84(fp)
8113b4ac:	18bfc216 	blt	r3,r2,8113b3b8 <__reset+0xfb11b3b8>
8113b4b0:	00000106 	br	8113b4b8 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
8113b4b4:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
8113b4b8:	00a045b4 	movhi	r2,33046
8113b4bc:	10884f04 	addi	r2,r2,8508
8113b4c0:	10800383 	ldbu	r2,14(r2)
8113b4c4:	10803fcc 	andi	r2,r2,255
8113b4c8:	e0ffeb17 	ldw	r3,-84(fp)
8113b4cc:	18801716 	blt	r3,r2,8113b52c <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
8113b4d0:	e0bfe717 	ldw	r2,-100(fp)
8113b4d4:	e0ffee04 	addi	r3,fp,-72
8113b4d8:	180b883a 	mov	r5,r3
8113b4dc:	1009883a 	mov	r4,r2
8113b4e0:	113838c0 	call	8113838c <get_cluster_flag>
8113b4e4:	10000f26 	beq	r2,zero,8113b524 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113b4e8:	e0bfee0b 	ldhu	r2,-72(fp)
8113b4ec:	10bfffcc 	andi	r2,r2,65535
8113b4f0:	10fffe0c 	andi	r3,r2,65528
8113b4f4:	00bffe14 	movui	r2,65528
8113b4f8:	1880051e 	bne	r3,r2,8113b510 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
8113b4fc:	00bfffc4 	movi	r2,-1
8113b500:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
8113b504:	00a045b4 	movhi	r2,33046
8113b508:	10884a04 	addi	r2,r2,8488
8113b50c:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
8113b510:	e0bfee0b 	ldhu	r2,-72(fp)
8113b514:	10bfffcc 	andi	r2,r2,65535
8113b518:	10bffe0c 	andi	r2,r2,65528
8113b51c:	e0bfe715 	stw	r2,-100(fp)
8113b520:	00000206 	br	8113b52c <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
8113b524:	00bfffc4 	movi	r2,-1
8113b528:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
8113b52c:	e0bfe717 	ldw	r2,-100(fp)
8113b530:	00fffdd4 	movui	r3,65527
8113b534:	18bf8e0e 	bge	r3,r2,8113b370 <__reset+0xfb11b370>
8113b538:	00000206 	br	8113b544 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
8113b53c:	008000c4 	movi	r2,3
8113b540:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
8113b544:	e0bfe60b 	ldhu	r2,-104(fp)
}
8113b548:	e037883a 	mov	sp,fp
8113b54c:	dfc00117 	ldw	ra,4(sp)
8113b550:	df000017 	ldw	fp,0(sp)
8113b554:	dec00204 	addi	sp,sp,8
8113b558:	f800283a 	ret

8113b55c <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
8113b55c:	deffe904 	addi	sp,sp,-92
8113b560:	de00012e 	bgeu	sp,et,8113b568 <alt_up_sd_card_fopen+0xc>
8113b564:	003b68fa 	trap	3
8113b568:	dfc01615 	stw	ra,88(sp)
8113b56c:	df001515 	stw	fp,84(sp)
8113b570:	df001504 	addi	fp,sp,84
8113b574:	e13ffe15 	stw	r4,-8(fp)
8113b578:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
8113b57c:	00bfffc4 	movi	r2,-1
8113b580:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113b584:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
8113b588:	1000cf26 	beq	r2,zero,8113b8c8 <alt_up_sd_card_fopen+0x36c>
8113b58c:	d0a09b17 	ldw	r2,-32148(gp)
8113b590:	1000cd26 	beq	r2,zero,8113b8c8 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
8113b594:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
8113b598:	e13ffe17 	ldw	r4,-8(fp)
8113b59c:	11393700 	call	81139370 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
8113b5a0:	e13ffe17 	ldw	r4,-8(fp)
8113b5a4:	113943c0 	call	8113943c <check_file_name_for_FAT16_compliance>
8113b5a8:	1000c726 	beq	r2,zero,8113b8c8 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
8113b5ac:	e0ffee04 	addi	r3,fp,-72
8113b5b0:	e0bfed04 	addi	r2,fp,-76
8113b5b4:	180d883a 	mov	r6,r3
8113b5b8:	100b883a 	mov	r5,r2
8113b5bc:	e13ffe17 	ldw	r4,-8(fp)
8113b5c0:	1139a140 	call	81139a14 <get_home_directory_cluster_for_file>
8113b5c4:	1000021e 	bne	r2,zero,8113b5d0 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
8113b5c8:	e0bfeb0b 	ldhu	r2,-84(fp)
8113b5cc:	0000bf06 	br	8113b8cc <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113b5d0:	e03fec15 	stw	zero,-80(fp)
8113b5d4:	00000e06 	br	8113b610 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
8113b5d8:	00a045b4 	movhi	r2,33046
8113b5dc:	10886404 	addi	r2,r2,8592
8113b5e0:	e0ffec17 	ldw	r3,-80(fp)
8113b5e4:	180691ba 	slli	r3,r3,6
8113b5e8:	10c5883a 	add	r2,r2,r3
8113b5ec:	10800f04 	addi	r2,r2,60
8113b5f0:	10800017 	ldw	r2,0(r2)
8113b5f4:	1000031e 	bne	r2,zero,8113b604 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
8113b5f8:	e0bfec17 	ldw	r2,-80(fp)
8113b5fc:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
8113b600:	00000606 	br	8113b61c <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113b604:	e0bfec17 	ldw	r2,-80(fp)
8113b608:	10800044 	addi	r2,r2,1
8113b60c:	e0bfec15 	stw	r2,-80(fp)
8113b610:	e0bfec17 	ldw	r2,-80(fp)
8113b614:	10800510 	cmplti	r2,r2,20
8113b618:	103fef1e 	bne	r2,zero,8113b5d8 <__reset+0xfb11b5d8>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
8113b61c:	e0bfeb0f 	ldh	r2,-84(fp)
8113b620:	1000a916 	blt	r2,zero,8113b8c8 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
8113b624:	e0bfed17 	ldw	r2,-76(fp)
8113b628:	1009883a 	mov	r4,r2
8113b62c:	e0bfeb0f 	ldh	r2,-84(fp)
8113b630:	100691ba 	slli	r3,r2,6
8113b634:	00a045b4 	movhi	r2,33046
8113b638:	10886404 	addi	r2,r2,8592
8113b63c:	1885883a 	add	r2,r3,r2
8113b640:	100d883a 	mov	r6,r2
8113b644:	e17ffe17 	ldw	r5,-8(fp)
8113b648:	1139f540 	call	81139f54 <find_file_in_directory>
8113b64c:	10007b26 	beq	r2,zero,8113b83c <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
8113b650:	e0bfff17 	ldw	r2,-4(fp)
8113b654:	10000226 	beq	r2,zero,8113b660 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
8113b658:	00bfffc4 	movi	r2,-1
8113b65c:	00009b06 	br	8113b8cc <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
8113b660:	e13feb0f 	ldh	r4,-84(fp)
8113b664:	e0ffeb0f 	ldh	r3,-84(fp)
8113b668:	00a045b4 	movhi	r2,33046
8113b66c:	10886404 	addi	r2,r2,8592
8113b670:	180691ba 	slli	r3,r3,6
8113b674:	10c5883a 	add	r2,r2,r3
8113b678:	10800584 	addi	r2,r2,22
8113b67c:	1080000b 	ldhu	r2,0(r2)
8113b680:	10ffffcc 	andi	r3,r2,65535
8113b684:	00a045b4 	movhi	r2,33046
8113b688:	10886404 	addi	r2,r2,8592
8113b68c:	200891ba 	slli	r4,r4,6
8113b690:	1105883a 	add	r2,r2,r4
8113b694:	10800704 	addi	r2,r2,28
8113b698:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
8113b69c:	e0ffeb0f 	ldh	r3,-84(fp)
8113b6a0:	00a045b4 	movhi	r2,33046
8113b6a4:	10886404 	addi	r2,r2,8592
8113b6a8:	180691ba 	slli	r3,r3,6
8113b6ac:	10c5883a 	add	r2,r2,r3
8113b6b0:	10800804 	addi	r2,r2,32
8113b6b4:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
8113b6b8:	e0ffeb0f 	ldh	r3,-84(fp)
8113b6bc:	00a045b4 	movhi	r2,33046
8113b6c0:	10886404 	addi	r2,r2,8592
8113b6c4:	180691ba 	slli	r3,r3,6
8113b6c8:	10c5883a 	add	r2,r2,r3
8113b6cc:	10800904 	addi	r2,r2,36
8113b6d0:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
8113b6d4:	e0ffeb0f 	ldh	r3,-84(fp)
8113b6d8:	00a045b4 	movhi	r2,33046
8113b6dc:	10886404 	addi	r2,r2,8592
8113b6e0:	180691ba 	slli	r3,r3,6
8113b6e4:	10c5883a 	add	r2,r2,r3
8113b6e8:	10800f04 	addi	r2,r2,60
8113b6ec:	00c00044 	movi	r3,1
8113b6f0:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
8113b6f4:	e0ffeb0f 	ldh	r3,-84(fp)
8113b6f8:	00a045b4 	movhi	r2,33046
8113b6fc:	10886404 	addi	r2,r2,8592
8113b700:	180691ba 	slli	r3,r3,6
8113b704:	10c5883a 	add	r2,r2,r3
8113b708:	10800e04 	addi	r2,r2,56
8113b70c:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113b710:	e03fec15 	stw	zero,-80(fp)
8113b714:	00004506 	br	8113b82c <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
8113b718:	e0ffeb0f 	ldh	r3,-84(fp)
8113b71c:	e0bfec17 	ldw	r2,-80(fp)
8113b720:	18803f26 	beq	r3,r2,8113b820 <alt_up_sd_card_fopen+0x2c4>
8113b724:	00a045b4 	movhi	r2,33046
8113b728:	10886404 	addi	r2,r2,8592
8113b72c:	e0ffec17 	ldw	r3,-80(fp)
8113b730:	180691ba 	slli	r3,r3,6
8113b734:	10c5883a 	add	r2,r2,r3
8113b738:	10800f04 	addi	r2,r2,60
8113b73c:	10800017 	ldw	r2,0(r2)
8113b740:	10800058 	cmpnei	r2,r2,1
8113b744:	1000361e 	bne	r2,zero,8113b820 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113b748:	e0ffeb0f 	ldh	r3,-84(fp)
8113b74c:	00a045b4 	movhi	r2,33046
8113b750:	10886404 	addi	r2,r2,8592
8113b754:	180691ba 	slli	r3,r3,6
8113b758:	10c5883a 	add	r2,r2,r3
8113b75c:	10800a04 	addi	r2,r2,40
8113b760:	10c00017 	ldw	r3,0(r2)
8113b764:	00a045b4 	movhi	r2,33046
8113b768:	10886404 	addi	r2,r2,8592
8113b76c:	e13fec17 	ldw	r4,-80(fp)
8113b770:	200891ba 	slli	r4,r4,6
8113b774:	1105883a 	add	r2,r2,r4
8113b778:	10800a04 	addi	r2,r2,40
8113b77c:	10800017 	ldw	r2,0(r2)
8113b780:	1880271e 	bne	r3,r2,8113b820 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113b784:	e0ffeb0f 	ldh	r3,-84(fp)
8113b788:	00a045b4 	movhi	r2,33046
8113b78c:	10886404 	addi	r2,r2,8592
8113b790:	180691ba 	slli	r3,r3,6
8113b794:	10c5883a 	add	r2,r2,r3
8113b798:	10800b04 	addi	r2,r2,44
8113b79c:	10c00017 	ldw	r3,0(r2)
8113b7a0:	00a045b4 	movhi	r2,33046
8113b7a4:	10886404 	addi	r2,r2,8592
8113b7a8:	e13fec17 	ldw	r4,-80(fp)
8113b7ac:	200891ba 	slli	r4,r4,6
8113b7b0:	1105883a 	add	r2,r2,r4
8113b7b4:	10800b04 	addi	r2,r2,44
8113b7b8:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113b7bc:	1880181e 	bne	r3,r2,8113b820 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
8113b7c0:	e0ffeb0f 	ldh	r3,-84(fp)
8113b7c4:	00a045b4 	movhi	r2,33046
8113b7c8:	10886404 	addi	r2,r2,8592
8113b7cc:	180691ba 	slli	r3,r3,6
8113b7d0:	10c5883a 	add	r2,r2,r3
8113b7d4:	10800c04 	addi	r2,r2,48
8113b7d8:	1100000b 	ldhu	r4,0(r2)
8113b7dc:	00a045b4 	movhi	r2,33046
8113b7e0:	10886404 	addi	r2,r2,8592
8113b7e4:	e0ffec17 	ldw	r3,-80(fp)
8113b7e8:	180691ba 	slli	r3,r3,6
8113b7ec:	10c5883a 	add	r2,r2,r3
8113b7f0:	10800c04 	addi	r2,r2,48
8113b7f4:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113b7f8:	20ffffcc 	andi	r3,r4,65535
8113b7fc:	18e0001c 	xori	r3,r3,32768
8113b800:	18e00004 	addi	r3,r3,-32768
8113b804:	10bfffcc 	andi	r2,r2,65535
8113b808:	10a0001c 	xori	r2,r2,32768
8113b80c:	10a00004 	addi	r2,r2,-32768
8113b810:	1880031e 	bne	r3,r2,8113b820 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
8113b814:	00bfff84 	movi	r2,-2
8113b818:	e0bfeb0d 	sth	r2,-84(fp)
								break;
8113b81c:	00002a06 	br	8113b8c8 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113b820:	e0bfec17 	ldw	r2,-80(fp)
8113b824:	10800044 	addi	r2,r2,1
8113b828:	e0bfec15 	stw	r2,-80(fp)
8113b82c:	e0bfec17 	ldw	r2,-80(fp)
8113b830:	10800510 	cmplti	r2,r2,20
8113b834:	103fb81e 	bne	r2,zero,8113b718 <__reset+0xfb11b718>
8113b838:	00002306 	br	8113b8c8 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
8113b83c:	e0bfff17 	ldw	r2,-4(fp)
8113b840:	10001f26 	beq	r2,zero,8113b8c0 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
8113b844:	e0bfeb0f 	ldh	r2,-84(fp)
8113b848:	100691ba 	slli	r3,r2,6
8113b84c:	00a045b4 	movhi	r2,33046
8113b850:	10886404 	addi	r2,r2,8592
8113b854:	1885883a 	add	r2,r3,r2
8113b858:	e0ffee04 	addi	r3,fp,-72
8113b85c:	180d883a 	mov	r6,r3
8113b860:	100b883a 	mov	r5,r2
8113b864:	e13ffe17 	ldw	r4,-8(fp)
8113b868:	113aaa00 	call	8113aaa0 <create_file>
8113b86c:	10001126 	beq	r2,zero,8113b8b4 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
8113b870:	e0ffeb0f 	ldh	r3,-84(fp)
8113b874:	00a045b4 	movhi	r2,33046
8113b878:	10886404 	addi	r2,r2,8592
8113b87c:	180691ba 	slli	r3,r3,6
8113b880:	10c5883a 	add	r2,r2,r3
8113b884:	10800f04 	addi	r2,r2,60
8113b888:	00c00044 	movi	r3,1
8113b88c:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
8113b890:	e0ffeb0f 	ldh	r3,-84(fp)
8113b894:	00a045b4 	movhi	r2,33046
8113b898:	10886404 	addi	r2,r2,8592
8113b89c:	180691ba 	slli	r3,r3,6
8113b8a0:	10c5883a 	add	r2,r2,r3
8113b8a4:	10800e04 	addi	r2,r2,56
8113b8a8:	00c00044 	movi	r3,1
8113b8ac:	10c00015 	stw	r3,0(r2)
8113b8b0:	00000506 	br	8113b8c8 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
8113b8b4:	00bfffc4 	movi	r2,-1
8113b8b8:	e0bfeb0d 	sth	r2,-84(fp)
8113b8bc:	00000206 	br	8113b8c8 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
8113b8c0:	00bfffc4 	movi	r2,-1
8113b8c4:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
8113b8c8:	e0bfeb0b 	ldhu	r2,-84(fp)
}
8113b8cc:	e037883a 	mov	sp,fp
8113b8d0:	dfc00117 	ldw	ra,4(sp)
8113b8d4:	df000017 	ldw	fp,0(sp)
8113b8d8:	dec00204 	addi	sp,sp,8
8113b8dc:	f800283a 	ret

8113b8e0 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8113b8e0:	defffd04 	addi	sp,sp,-12
8113b8e4:	de00012e 	bgeu	sp,et,8113b8ec <alt_up_sd_card_set_attributes+0xc>
8113b8e8:	003b68fa 	trap	3
8113b8ec:	df000215 	stw	fp,8(sp)
8113b8f0:	df000204 	addi	fp,sp,8
8113b8f4:	2007883a 	mov	r3,r4
8113b8f8:	2805883a 	mov	r2,r5
8113b8fc:	e0fffe0d 	sth	r3,-8(fp)
8113b900:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113b904:	e0bffe0f 	ldh	r2,-8(fp)
8113b908:	10001416 	blt	r2,zero,8113b95c <alt_up_sd_card_set_attributes+0x7c>
8113b90c:	e0bffe0f 	ldh	r2,-8(fp)
8113b910:	10800508 	cmpgei	r2,r2,20
8113b914:	1000111e 	bne	r2,zero,8113b95c <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8113b918:	e0fffe0f 	ldh	r3,-8(fp)
8113b91c:	00a045b4 	movhi	r2,33046
8113b920:	10886404 	addi	r2,r2,8592
8113b924:	180691ba 	slli	r3,r3,6
8113b928:	10c5883a 	add	r2,r2,r3
8113b92c:	10800f04 	addi	r2,r2,60
8113b930:	10800017 	ldw	r2,0(r2)
8113b934:	10000926 	beq	r2,zero,8113b95c <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
8113b938:	e0fffe0f 	ldh	r3,-8(fp)
8113b93c:	e0bfff0b 	ldhu	r2,-4(fp)
8113b940:	1009883a 	mov	r4,r2
8113b944:	00a045b4 	movhi	r2,33046
8113b948:	10886404 	addi	r2,r2,8592
8113b94c:	180691ba 	slli	r3,r3,6
8113b950:	10c5883a 	add	r2,r2,r3
8113b954:	108002c4 	addi	r2,r2,11
8113b958:	11000005 	stb	r4,0(r2)
        }
    }
}
8113b95c:	0001883a 	nop
8113b960:	e037883a 	mov	sp,fp
8113b964:	df000017 	ldw	fp,0(sp)
8113b968:	dec00104 	addi	sp,sp,4
8113b96c:	f800283a 	ret

8113b970 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8113b970:	defffd04 	addi	sp,sp,-12
8113b974:	de00012e 	bgeu	sp,et,8113b97c <alt_up_sd_card_get_attributes+0xc>
8113b978:	003b68fa 	trap	3
8113b97c:	df000215 	stw	fp,8(sp)
8113b980:	df000204 	addi	fp,sp,8
8113b984:	2005883a 	mov	r2,r4
8113b988:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
8113b98c:	00bfffc4 	movi	r2,-1
8113b990:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113b994:	e0bfff0f 	ldh	r2,-4(fp)
8113b998:	10001416 	blt	r2,zero,8113b9ec <alt_up_sd_card_get_attributes+0x7c>
8113b99c:	e0bfff0f 	ldh	r2,-4(fp)
8113b9a0:	10800508 	cmpgei	r2,r2,20
8113b9a4:	1000111e 	bne	r2,zero,8113b9ec <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8113b9a8:	e0ffff0f 	ldh	r3,-4(fp)
8113b9ac:	00a045b4 	movhi	r2,33046
8113b9b0:	10886404 	addi	r2,r2,8592
8113b9b4:	180691ba 	slli	r3,r3,6
8113b9b8:	10c5883a 	add	r2,r2,r3
8113b9bc:	10800f04 	addi	r2,r2,60
8113b9c0:	10800017 	ldw	r2,0(r2)
8113b9c4:	10000926 	beq	r2,zero,8113b9ec <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
8113b9c8:	e0ffff0f 	ldh	r3,-4(fp)
8113b9cc:	00a045b4 	movhi	r2,33046
8113b9d0:	10886404 	addi	r2,r2,8592
8113b9d4:	180691ba 	slli	r3,r3,6
8113b9d8:	10c5883a 	add	r2,r2,r3
8113b9dc:	108002c4 	addi	r2,r2,11
8113b9e0:	10800003 	ldbu	r2,0(r2)
8113b9e4:	10803fcc 	andi	r2,r2,255
8113b9e8:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
8113b9ec:	e0bffe0b 	ldhu	r2,-8(fp)
}
8113b9f0:	e037883a 	mov	sp,fp
8113b9f4:	df000017 	ldw	fp,0(sp)
8113b9f8:	dec00104 	addi	sp,sp,4
8113b9fc:	f800283a 	ret

8113ba00 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
8113ba00:	defffa04 	addi	sp,sp,-24
8113ba04:	de00012e 	bgeu	sp,et,8113ba0c <alt_up_sd_card_read+0xc>
8113ba08:	003b68fa 	trap	3
8113ba0c:	dfc00515 	stw	ra,20(sp)
8113ba10:	df000415 	stw	fp,16(sp)
8113ba14:	df000404 	addi	fp,sp,16
8113ba18:	2005883a 	mov	r2,r4
8113ba1c:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
8113ba20:	00bfffc4 	movi	r2,-1
8113ba24:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113ba28:	e0bfff0f 	ldh	r2,-4(fp)
8113ba2c:	1000ce16 	blt	r2,zero,8113bd68 <alt_up_sd_card_read+0x368>
8113ba30:	e0bfff0f 	ldh	r2,-4(fp)
8113ba34:	10800508 	cmpgei	r2,r2,20
8113ba38:	1000cb1e 	bne	r2,zero,8113bd68 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
8113ba3c:	e0ffff0f 	ldh	r3,-4(fp)
8113ba40:	00a045b4 	movhi	r2,33046
8113ba44:	10886404 	addi	r2,r2,8592
8113ba48:	180691ba 	slli	r3,r3,6
8113ba4c:	10c5883a 	add	r2,r2,r3
8113ba50:	10800f04 	addi	r2,r2,60
8113ba54:	10800017 	ldw	r2,0(r2)
8113ba58:	1000c326 	beq	r2,zero,8113bd68 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8113ba5c:	e0ffff0f 	ldh	r3,-4(fp)
8113ba60:	00a045b4 	movhi	r2,33046
8113ba64:	10886404 	addi	r2,r2,8592
8113ba68:	180691ba 	slli	r3,r3,6
8113ba6c:	10c5883a 	add	r2,r2,r3
8113ba70:	10800904 	addi	r2,r2,36
8113ba74:	10c00017 	ldw	r3,0(r2)
8113ba78:	e13fff0f 	ldh	r4,-4(fp)
8113ba7c:	00a045b4 	movhi	r2,33046
8113ba80:	10886404 	addi	r2,r2,8592
8113ba84:	200891ba 	slli	r4,r4,6
8113ba88:	1105883a 	add	r2,r2,r4
8113ba8c:	10800604 	addi	r2,r2,24
8113ba90:	10800017 	ldw	r2,0(r2)
8113ba94:	1880b42e 	bgeu	r3,r2,8113bd68 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113ba98:	00a045b4 	movhi	r2,33046
8113ba9c:	10884f04 	addi	r2,r2,8508
8113baa0:	10c01417 	ldw	r3,80(r2)
8113baa4:	e13fff0f 	ldh	r4,-4(fp)
8113baa8:	00a045b4 	movhi	r2,33046
8113baac:	10886404 	addi	r2,r2,8592
8113bab0:	200891ba 	slli	r4,r4,6
8113bab4:	1105883a 	add	r2,r2,r4
8113bab8:	10800704 	addi	r2,r2,28
8113babc:	10800017 	ldw	r2,0(r2)
8113bac0:	113fff84 	addi	r4,r2,-2
8113bac4:	00a045b4 	movhi	r2,33046
8113bac8:	10884f04 	addi	r2,r2,8508
8113bacc:	10800383 	ldbu	r2,14(r2)
8113bad0:	10803fcc 	andi	r2,r2,255
8113bad4:	2085383a 	mul	r2,r4,r2
8113bad8:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
8113badc:	e13fff0f 	ldh	r4,-4(fp)
8113bae0:	00a045b4 	movhi	r2,33046
8113bae4:	10886404 	addi	r2,r2,8592
8113bae8:	200891ba 	slli	r4,r4,6
8113baec:	1105883a 	add	r2,r2,r4
8113baf0:	10800804 	addi	r2,r2,32
8113baf4:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113baf8:	1885883a 	add	r2,r3,r2
8113bafc:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
8113bb00:	e0ffff0f 	ldh	r3,-4(fp)
8113bb04:	00a045b4 	movhi	r2,33046
8113bb08:	10886404 	addi	r2,r2,8592
8113bb0c:	180691ba 	slli	r3,r3,6
8113bb10:	10c5883a 	add	r2,r2,r3
8113bb14:	10800904 	addi	r2,r2,36
8113bb18:	10800017 	ldw	r2,0(r2)
8113bb1c:	10006826 	beq	r2,zero,8113bcc0 <alt_up_sd_card_read+0x2c0>
8113bb20:	e0ffff0f 	ldh	r3,-4(fp)
8113bb24:	00a045b4 	movhi	r2,33046
8113bb28:	10886404 	addi	r2,r2,8592
8113bb2c:	180691ba 	slli	r3,r3,6
8113bb30:	10c5883a 	add	r2,r2,r3
8113bb34:	10800904 	addi	r2,r2,36
8113bb38:	10800017 	ldw	r2,0(r2)
8113bb3c:	10807fcc 	andi	r2,r2,511
8113bb40:	10005f1e 	bne	r2,zero,8113bcc0 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113bb44:	e0ffff0f 	ldh	r3,-4(fp)
8113bb48:	00a045b4 	movhi	r2,33046
8113bb4c:	10886404 	addi	r2,r2,8592
8113bb50:	180691ba 	slli	r3,r3,6
8113bb54:	10c5883a 	add	r2,r2,r3
8113bb58:	10800804 	addi	r2,r2,32
8113bb5c:	10c00017 	ldw	r3,0(r2)
8113bb60:	00a045b4 	movhi	r2,33046
8113bb64:	10884f04 	addi	r2,r2,8508
8113bb68:	10800383 	ldbu	r2,14(r2)
8113bb6c:	10803fcc 	andi	r2,r2,255
8113bb70:	10bfffc4 	addi	r2,r2,-1
8113bb74:	1880401e 	bne	r3,r2,8113bc78 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8113bb78:	e0ffff0f 	ldh	r3,-4(fp)
8113bb7c:	00a045b4 	movhi	r2,33046
8113bb80:	10886404 	addi	r2,r2,8592
8113bb84:	180691ba 	slli	r3,r3,6
8113bb88:	10c5883a 	add	r2,r2,r3
8113bb8c:	10800704 	addi	r2,r2,28
8113bb90:	10800017 	ldw	r2,0(r2)
8113bb94:	e0fffe04 	addi	r3,fp,-8
8113bb98:	180b883a 	mov	r5,r3
8113bb9c:	1009883a 	mov	r4,r2
8113bba0:	113838c0 	call	8113838c <get_cluster_flag>
8113bba4:	10003226 	beq	r2,zero,8113bc70 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113bba8:	e0bffe0b 	ldhu	r2,-8(fp)
8113bbac:	10bfffcc 	andi	r2,r2,65535
8113bbb0:	10fffe0c 	andi	r3,r2,65528
8113bbb4:	00bffe14 	movui	r2,65528
8113bbb8:	1880021e 	bne	r3,r2,8113bbc4 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
8113bbbc:	00bfffc4 	movi	r2,-1
8113bbc0:	00006a06 	br	8113bd6c <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
8113bbc4:	e13fff0f 	ldh	r4,-4(fp)
8113bbc8:	e0bffe0b 	ldhu	r2,-8(fp)
8113bbcc:	10ffffcc 	andi	r3,r2,65535
8113bbd0:	00a045b4 	movhi	r2,33046
8113bbd4:	10886404 	addi	r2,r2,8592
8113bbd8:	200891ba 	slli	r4,r4,6
8113bbdc:	1105883a 	add	r2,r2,r4
8113bbe0:	10800704 	addi	r2,r2,28
8113bbe4:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8113bbe8:	e0ffff0f 	ldh	r3,-4(fp)
8113bbec:	00a045b4 	movhi	r2,33046
8113bbf0:	10886404 	addi	r2,r2,8592
8113bbf4:	180691ba 	slli	r3,r3,6
8113bbf8:	10c5883a 	add	r2,r2,r3
8113bbfc:	10800804 	addi	r2,r2,32
8113bc00:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113bc04:	00a045b4 	movhi	r2,33046
8113bc08:	10884f04 	addi	r2,r2,8508
8113bc0c:	10c01417 	ldw	r3,80(r2)
8113bc10:	e13fff0f 	ldh	r4,-4(fp)
8113bc14:	00a045b4 	movhi	r2,33046
8113bc18:	10886404 	addi	r2,r2,8592
8113bc1c:	200891ba 	slli	r4,r4,6
8113bc20:	1105883a 	add	r2,r2,r4
8113bc24:	10800704 	addi	r2,r2,28
8113bc28:	10800017 	ldw	r2,0(r2)
8113bc2c:	113fff84 	addi	r4,r2,-2
8113bc30:	00a045b4 	movhi	r2,33046
8113bc34:	10884f04 	addi	r2,r2,8508
8113bc38:	10800383 	ldbu	r2,14(r2)
8113bc3c:	10803fcc 	andi	r2,r2,255
8113bc40:	2085383a 	mul	r2,r4,r2
8113bc44:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
8113bc48:	e13fff0f 	ldh	r4,-4(fp)
8113bc4c:	00a045b4 	movhi	r2,33046
8113bc50:	10886404 	addi	r2,r2,8592
8113bc54:	200891ba 	slli	r4,r4,6
8113bc58:	1105883a 	add	r2,r2,r4
8113bc5c:	10800804 	addi	r2,r2,32
8113bc60:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113bc64:	1885883a 	add	r2,r3,r2
8113bc68:	e0bffd15 	stw	r2,-12(fp)
8113bc6c:	00001406 	br	8113bcc0 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
8113bc70:	00bfff84 	movi	r2,-2
8113bc74:	00003d06 	br	8113bd6c <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8113bc78:	e13fff0f 	ldh	r4,-4(fp)
8113bc7c:	e0ffff0f 	ldh	r3,-4(fp)
8113bc80:	00a045b4 	movhi	r2,33046
8113bc84:	10886404 	addi	r2,r2,8592
8113bc88:	180691ba 	slli	r3,r3,6
8113bc8c:	10c5883a 	add	r2,r2,r3
8113bc90:	10800804 	addi	r2,r2,32
8113bc94:	10800017 	ldw	r2,0(r2)
8113bc98:	10c00044 	addi	r3,r2,1
8113bc9c:	00a045b4 	movhi	r2,33046
8113bca0:	10886404 	addi	r2,r2,8592
8113bca4:	200891ba 	slli	r4,r4,6
8113bca8:	1105883a 	add	r2,r2,r4
8113bcac:	10800804 	addi	r2,r2,32
8113bcb0:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8113bcb4:	e0bffd17 	ldw	r2,-12(fp)
8113bcb8:	10800044 	addi	r2,r2,1
8113bcbc:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
8113bcc0:	d0e0a217 	ldw	r3,-32120(gp)
8113bcc4:	e0bffd17 	ldw	r2,-12(fp)
8113bcc8:	1885883a 	add	r2,r3,r2
8113bccc:	1007883a 	mov	r3,r2
8113bcd0:	d0a0a617 	ldw	r2,-32104(gp)
8113bcd4:	18800726 	beq	r3,r2,8113bcf4 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8113bcd8:	d0a0a217 	ldw	r2,-32120(gp)
8113bcdc:	100b883a 	mov	r5,r2
8113bce0:	e13ffd17 	ldw	r4,-12(fp)
8113bce4:	11382ac0 	call	811382ac <Read_Sector_Data>
8113bce8:	1000021e 	bne	r2,zero,8113bcf4 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
8113bcec:	00bfff84 	movi	r2,-2
8113bcf0:	00001e06 	br	8113bd6c <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
8113bcf4:	d0e0a117 	ldw	r3,-32124(gp)
8113bcf8:	e13fff0f 	ldh	r4,-4(fp)
8113bcfc:	00a045b4 	movhi	r2,33046
8113bd00:	10886404 	addi	r2,r2,8592
8113bd04:	200891ba 	slli	r4,r4,6
8113bd08:	1105883a 	add	r2,r2,r4
8113bd0c:	10800904 	addi	r2,r2,36
8113bd10:	10800017 	ldw	r2,0(r2)
8113bd14:	10807fcc 	andi	r2,r2,511
8113bd18:	1885883a 	add	r2,r3,r2
8113bd1c:	10800023 	ldbuio	r2,0(r2)
8113bd20:	10803fcc 	andi	r2,r2,255
8113bd24:	10803fcc 	andi	r2,r2,255
8113bd28:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8113bd2c:	e13fff0f 	ldh	r4,-4(fp)
8113bd30:	e0ffff0f 	ldh	r3,-4(fp)
8113bd34:	00a045b4 	movhi	r2,33046
8113bd38:	10886404 	addi	r2,r2,8592
8113bd3c:	180691ba 	slli	r3,r3,6
8113bd40:	10c5883a 	add	r2,r2,r3
8113bd44:	10800904 	addi	r2,r2,36
8113bd48:	10800017 	ldw	r2,0(r2)
8113bd4c:	10c00044 	addi	r3,r2,1
8113bd50:	00a045b4 	movhi	r2,33046
8113bd54:	10886404 	addi	r2,r2,8592
8113bd58:	200891ba 	slli	r4,r4,6
8113bd5c:	1105883a 	add	r2,r2,r4
8113bd60:	10800904 	addi	r2,r2,36
8113bd64:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
8113bd68:	e0bffc0b 	ldhu	r2,-16(fp)
}
8113bd6c:	e037883a 	mov	sp,fp
8113bd70:	dfc00117 	ldw	ra,4(sp)
8113bd74:	df000017 	ldw	fp,0(sp)
8113bd78:	dec00204 	addi	sp,sp,8
8113bd7c:	f800283a 	ret

8113bd80 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
8113bd80:	defff804 	addi	sp,sp,-32
8113bd84:	de00012e 	bgeu	sp,et,8113bd8c <alt_up_sd_card_write+0xc>
8113bd88:	003b68fa 	trap	3
8113bd8c:	dfc00715 	stw	ra,28(sp)
8113bd90:	df000615 	stw	fp,24(sp)
8113bd94:	df000604 	addi	fp,sp,24
8113bd98:	2007883a 	mov	r3,r4
8113bd9c:	2805883a 	mov	r2,r5
8113bda0:	e0fffe0d 	sth	r3,-8(fp)
8113bda4:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
8113bda8:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113bdac:	e0bffe0f 	ldh	r2,-8(fp)
8113bdb0:	10017716 	blt	r2,zero,8113c390 <alt_up_sd_card_write+0x610>
8113bdb4:	e0bffe0f 	ldh	r2,-8(fp)
8113bdb8:	10800508 	cmpgei	r2,r2,20
8113bdbc:	1001741e 	bne	r2,zero,8113c390 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
8113bdc0:	e0fffe0f 	ldh	r3,-8(fp)
8113bdc4:	00a045b4 	movhi	r2,33046
8113bdc8:	10886404 	addi	r2,r2,8592
8113bdcc:	180691ba 	slli	r3,r3,6
8113bdd0:	10c5883a 	add	r2,r2,r3
8113bdd4:	10800f04 	addi	r2,r2,60
8113bdd8:	10800017 	ldw	r2,0(r2)
8113bddc:	10016c26 	beq	r2,zero,8113c390 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113bde0:	00a045b4 	movhi	r2,33046
8113bde4:	10884f04 	addi	r2,r2,8508
8113bde8:	10c01417 	ldw	r3,80(r2)
8113bdec:	e13ffe0f 	ldh	r4,-8(fp)
8113bdf0:	00a045b4 	movhi	r2,33046
8113bdf4:	10886404 	addi	r2,r2,8592
8113bdf8:	200891ba 	slli	r4,r4,6
8113bdfc:	1105883a 	add	r2,r2,r4
8113be00:	10800704 	addi	r2,r2,28
8113be04:	10800017 	ldw	r2,0(r2)
8113be08:	113fff84 	addi	r4,r2,-2
8113be0c:	00a045b4 	movhi	r2,33046
8113be10:	10884f04 	addi	r2,r2,8508
8113be14:	10800383 	ldbu	r2,14(r2)
8113be18:	10803fcc 	andi	r2,r2,255
8113be1c:	2085383a 	mul	r2,r4,r2
8113be20:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
8113be24:	e13ffe0f 	ldh	r4,-8(fp)
8113be28:	00a045b4 	movhi	r2,33046
8113be2c:	10886404 	addi	r2,r2,8592
8113be30:	200891ba 	slli	r4,r4,6
8113be34:	1105883a 	add	r2,r2,r4
8113be38:	10800804 	addi	r2,r2,32
8113be3c:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113be40:	1885883a 	add	r2,r3,r2
8113be44:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
8113be48:	e0fffe0f 	ldh	r3,-8(fp)
8113be4c:	00a045b4 	movhi	r2,33046
8113be50:	10886404 	addi	r2,r2,8592
8113be54:	180691ba 	slli	r3,r3,6
8113be58:	10c5883a 	add	r2,r2,r3
8113be5c:	10800904 	addi	r2,r2,36
8113be60:	10c00017 	ldw	r3,0(r2)
8113be64:	00a045b4 	movhi	r2,33046
8113be68:	10884f04 	addi	r2,r2,8508
8113be6c:	1080030b 	ldhu	r2,12(r2)
8113be70:	10bfffcc 	andi	r2,r2,65535
8113be74:	1889203a 	divu	r4,r3,r2
8113be78:	2085383a 	mul	r2,r4,r2
8113be7c:	1885c83a 	sub	r2,r3,r2
8113be80:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8113be84:	e0fffe0f 	ldh	r3,-8(fp)
8113be88:	00a045b4 	movhi	r2,33046
8113be8c:	10886404 	addi	r2,r2,8592
8113be90:	180691ba 	slli	r3,r3,6
8113be94:	10c5883a 	add	r2,r2,r3
8113be98:	10800904 	addi	r2,r2,36
8113be9c:	10c00017 	ldw	r3,0(r2)
8113bea0:	e13ffe0f 	ldh	r4,-8(fp)
8113bea4:	00a045b4 	movhi	r2,33046
8113bea8:	10886404 	addi	r2,r2,8592
8113beac:	200891ba 	slli	r4,r4,6
8113beb0:	1105883a 	add	r2,r2,r4
8113beb4:	10800604 	addi	r2,r2,24
8113beb8:	10800017 	ldw	r2,0(r2)
8113bebc:	1880672e 	bgeu	r3,r2,8113c05c <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8113bec0:	e0fffe0f 	ldh	r3,-8(fp)
8113bec4:	00a045b4 	movhi	r2,33046
8113bec8:	10886404 	addi	r2,r2,8592
8113becc:	180691ba 	slli	r3,r3,6
8113bed0:	10c5883a 	add	r2,r2,r3
8113bed4:	10800904 	addi	r2,r2,36
8113bed8:	10800017 	ldw	r2,0(r2)
8113bedc:	1000e126 	beq	r2,zero,8113c264 <alt_up_sd_card_write+0x4e4>
8113bee0:	e0bffc0f 	ldh	r2,-16(fp)
8113bee4:	1000df1e 	bne	r2,zero,8113c264 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113bee8:	e0fffe0f 	ldh	r3,-8(fp)
8113beec:	00a045b4 	movhi	r2,33046
8113bef0:	10886404 	addi	r2,r2,8592
8113bef4:	180691ba 	slli	r3,r3,6
8113bef8:	10c5883a 	add	r2,r2,r3
8113befc:	10800804 	addi	r2,r2,32
8113bf00:	10c00017 	ldw	r3,0(r2)
8113bf04:	00a045b4 	movhi	r2,33046
8113bf08:	10884f04 	addi	r2,r2,8508
8113bf0c:	10800383 	ldbu	r2,14(r2)
8113bf10:	10803fcc 	andi	r2,r2,255
8113bf14:	10bfffc4 	addi	r2,r2,-1
8113bf18:	18803d1e 	bne	r3,r2,8113c010 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8113bf1c:	e0fffe0f 	ldh	r3,-8(fp)
8113bf20:	00a045b4 	movhi	r2,33046
8113bf24:	10886404 	addi	r2,r2,8592
8113bf28:	180691ba 	slli	r3,r3,6
8113bf2c:	10c5883a 	add	r2,r2,r3
8113bf30:	10800704 	addi	r2,r2,28
8113bf34:	10800017 	ldw	r2,0(r2)
8113bf38:	e0fffc84 	addi	r3,fp,-14
8113bf3c:	180b883a 	mov	r5,r3
8113bf40:	1009883a 	mov	r4,r2
8113bf44:	113838c0 	call	8113838c <get_cluster_flag>
8113bf48:	10002f26 	beq	r2,zero,8113c008 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
8113bf4c:	e0bffc8b 	ldhu	r2,-14(fp)
8113bf50:	10bfffcc 	andi	r2,r2,65535
8113bf54:	10bffe28 	cmpgeui	r2,r2,65528
8113bf58:	1000c21e 	bne	r2,zero,8113c264 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
8113bf5c:	e13ffe0f 	ldh	r4,-8(fp)
8113bf60:	e0bffc8b 	ldhu	r2,-14(fp)
8113bf64:	10ffffcc 	andi	r3,r2,65535
8113bf68:	00a045b4 	movhi	r2,33046
8113bf6c:	10886404 	addi	r2,r2,8592
8113bf70:	200891ba 	slli	r4,r4,6
8113bf74:	1105883a 	add	r2,r2,r4
8113bf78:	10800704 	addi	r2,r2,28
8113bf7c:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8113bf80:	e0fffe0f 	ldh	r3,-8(fp)
8113bf84:	00a045b4 	movhi	r2,33046
8113bf88:	10886404 	addi	r2,r2,8592
8113bf8c:	180691ba 	slli	r3,r3,6
8113bf90:	10c5883a 	add	r2,r2,r3
8113bf94:	10800804 	addi	r2,r2,32
8113bf98:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113bf9c:	00a045b4 	movhi	r2,33046
8113bfa0:	10884f04 	addi	r2,r2,8508
8113bfa4:	10c01417 	ldw	r3,80(r2)
8113bfa8:	e13ffe0f 	ldh	r4,-8(fp)
8113bfac:	00a045b4 	movhi	r2,33046
8113bfb0:	10886404 	addi	r2,r2,8592
8113bfb4:	200891ba 	slli	r4,r4,6
8113bfb8:	1105883a 	add	r2,r2,r4
8113bfbc:	10800704 	addi	r2,r2,28
8113bfc0:	10800017 	ldw	r2,0(r2)
8113bfc4:	113fff84 	addi	r4,r2,-2
8113bfc8:	00a045b4 	movhi	r2,33046
8113bfcc:	10884f04 	addi	r2,r2,8508
8113bfd0:	10800383 	ldbu	r2,14(r2)
8113bfd4:	10803fcc 	andi	r2,r2,255
8113bfd8:	2085383a 	mul	r2,r4,r2
8113bfdc:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
8113bfe0:	e13ffe0f 	ldh	r4,-8(fp)
8113bfe4:	00a045b4 	movhi	r2,33046
8113bfe8:	10886404 	addi	r2,r2,8592
8113bfec:	200891ba 	slli	r4,r4,6
8113bff0:	1105883a 	add	r2,r2,r4
8113bff4:	10800804 	addi	r2,r2,32
8113bff8:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113bffc:	1885883a 	add	r2,r3,r2
8113c000:	e0bffb15 	stw	r2,-20(fp)
8113c004:	00009706 	br	8113c264 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
8113c008:	0005883a 	mov	r2,zero
8113c00c:	0000e106 	br	8113c394 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8113c010:	e13ffe0f 	ldh	r4,-8(fp)
8113c014:	e0fffe0f 	ldh	r3,-8(fp)
8113c018:	00a045b4 	movhi	r2,33046
8113c01c:	10886404 	addi	r2,r2,8592
8113c020:	180691ba 	slli	r3,r3,6
8113c024:	10c5883a 	add	r2,r2,r3
8113c028:	10800804 	addi	r2,r2,32
8113c02c:	10800017 	ldw	r2,0(r2)
8113c030:	10c00044 	addi	r3,r2,1
8113c034:	00a045b4 	movhi	r2,33046
8113c038:	10886404 	addi	r2,r2,8592
8113c03c:	200891ba 	slli	r4,r4,6
8113c040:	1105883a 	add	r2,r2,r4
8113c044:	10800804 	addi	r2,r2,32
8113c048:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8113c04c:	e0bffb17 	ldw	r2,-20(fp)
8113c050:	10800044 	addi	r2,r2,1
8113c054:	e0bffb15 	stw	r2,-20(fp)
8113c058:	00008206 	br	8113c264 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8113c05c:	e0fffe0f 	ldh	r3,-8(fp)
8113c060:	00a045b4 	movhi	r2,33046
8113c064:	10886404 	addi	r2,r2,8592
8113c068:	180691ba 	slli	r3,r3,6
8113c06c:	10c5883a 	add	r2,r2,r3
8113c070:	10800904 	addi	r2,r2,36
8113c074:	10800017 	ldw	r2,0(r2)
8113c078:	10007a26 	beq	r2,zero,8113c264 <alt_up_sd_card_write+0x4e4>
8113c07c:	e0bffc0f 	ldh	r2,-16(fp)
8113c080:	1000781e 	bne	r2,zero,8113c264 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113c084:	e0fffe0f 	ldh	r3,-8(fp)
8113c088:	00a045b4 	movhi	r2,33046
8113c08c:	10886404 	addi	r2,r2,8592
8113c090:	180691ba 	slli	r3,r3,6
8113c094:	10c5883a 	add	r2,r2,r3
8113c098:	10800804 	addi	r2,r2,32
8113c09c:	10c00017 	ldw	r3,0(r2)
8113c0a0:	00a045b4 	movhi	r2,33046
8113c0a4:	10884f04 	addi	r2,r2,8508
8113c0a8:	10800383 	ldbu	r2,14(r2)
8113c0ac:	10803fcc 	andi	r2,r2,255
8113c0b0:	10bfffc4 	addi	r2,r2,-1
8113c0b4:	18803e1e 	bne	r3,r2,8113c1b0 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
8113c0b8:	e0bffd04 	addi	r2,fp,-12
8113c0bc:	1009883a 	mov	r4,r2
8113c0c0:	113a3d00 	call	8113a3d0 <find_first_empty_cluster>
8113c0c4:	10003826 	beq	r2,zero,8113c1a8 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
8113c0c8:	e0fffe0f 	ldh	r3,-8(fp)
8113c0cc:	00a045b4 	movhi	r2,33046
8113c0d0:	10886404 	addi	r2,r2,8592
8113c0d4:	180691ba 	slli	r3,r3,6
8113c0d8:	10c5883a 	add	r2,r2,r3
8113c0dc:	10800704 	addi	r2,r2,28
8113c0e0:	10800017 	ldw	r2,0(r2)
8113c0e4:	e0fffd17 	ldw	r3,-12(fp)
8113c0e8:	18ffffcc 	andi	r3,r3,65535
8113c0ec:	18e0001c 	xori	r3,r3,32768
8113c0f0:	18e00004 	addi	r3,r3,-32768
8113c0f4:	01800044 	movi	r6,1
8113c0f8:	180b883a 	mov	r5,r3
8113c0fc:	1009883a 	mov	r4,r2
8113c100:	11384480 	call	81138448 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
8113c104:	e0bffd17 	ldw	r2,-12(fp)
8113c108:	01800044 	movi	r6,1
8113c10c:	017fffc4 	movi	r5,-1
8113c110:	1009883a 	mov	r4,r2
8113c114:	11384480 	call	81138448 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
8113c118:	e0fffe0f 	ldh	r3,-8(fp)
8113c11c:	00a045b4 	movhi	r2,33046
8113c120:	10886404 	addi	r2,r2,8592
8113c124:	180691ba 	slli	r3,r3,6
8113c128:	10c5883a 	add	r2,r2,r3
8113c12c:	10800704 	addi	r2,r2,28
8113c130:	10800017 	ldw	r2,0(r2)
8113c134:	e0fffd17 	ldw	r3,-12(fp)
8113c138:	18ffffcc 	andi	r3,r3,65535
8113c13c:	18e0001c 	xori	r3,r3,32768
8113c140:	18e00004 	addi	r3,r3,-32768
8113c144:	000d883a 	mov	r6,zero
8113c148:	180b883a 	mov	r5,r3
8113c14c:	1009883a 	mov	r4,r2
8113c150:	11384480 	call	81138448 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
8113c154:	e0bffd17 	ldw	r2,-12(fp)
8113c158:	000d883a 	mov	r6,zero
8113c15c:	017fffc4 	movi	r5,-1
8113c160:	1009883a 	mov	r4,r2
8113c164:	11384480 	call	81138448 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
8113c168:	e13ffe0f 	ldh	r4,-8(fp)
8113c16c:	e0fffd17 	ldw	r3,-12(fp)
8113c170:	00a045b4 	movhi	r2,33046
8113c174:	10886404 	addi	r2,r2,8592
8113c178:	200891ba 	slli	r4,r4,6
8113c17c:	1105883a 	add	r2,r2,r4
8113c180:	10800704 	addi	r2,r2,28
8113c184:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
8113c188:	e0fffe0f 	ldh	r3,-8(fp)
8113c18c:	00a045b4 	movhi	r2,33046
8113c190:	10886404 	addi	r2,r2,8592
8113c194:	180691ba 	slli	r3,r3,6
8113c198:	10c5883a 	add	r2,r2,r3
8113c19c:	10800804 	addi	r2,r2,32
8113c1a0:	10000015 	stw	zero,0(r2)
8113c1a4:	00001506 	br	8113c1fc <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
8113c1a8:	0005883a 	mov	r2,zero
8113c1ac:	00007906 	br	8113c394 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
8113c1b0:	e13ffe0f 	ldh	r4,-8(fp)
8113c1b4:	e0fffe0f 	ldh	r3,-8(fp)
8113c1b8:	00a045b4 	movhi	r2,33046
8113c1bc:	10886404 	addi	r2,r2,8592
8113c1c0:	180691ba 	slli	r3,r3,6
8113c1c4:	10c5883a 	add	r2,r2,r3
8113c1c8:	10800904 	addi	r2,r2,36
8113c1cc:	10c00017 	ldw	r3,0(r2)
8113c1d0:	00a045b4 	movhi	r2,33046
8113c1d4:	10884f04 	addi	r2,r2,8508
8113c1d8:	1080030b 	ldhu	r2,12(r2)
8113c1dc:	10bfffcc 	andi	r2,r2,65535
8113c1e0:	1887203a 	divu	r3,r3,r2
8113c1e4:	00a045b4 	movhi	r2,33046
8113c1e8:	10886404 	addi	r2,r2,8592
8113c1ec:	200891ba 	slli	r4,r4,6
8113c1f0:	1105883a 	add	r2,r2,r4
8113c1f4:	10800804 	addi	r2,r2,32
8113c1f8:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113c1fc:	00a045b4 	movhi	r2,33046
8113c200:	10884f04 	addi	r2,r2,8508
8113c204:	10c01417 	ldw	r3,80(r2)
8113c208:	e13ffe0f 	ldh	r4,-8(fp)
8113c20c:	00a045b4 	movhi	r2,33046
8113c210:	10886404 	addi	r2,r2,8592
8113c214:	200891ba 	slli	r4,r4,6
8113c218:	1105883a 	add	r2,r2,r4
8113c21c:	10800704 	addi	r2,r2,28
8113c220:	10800017 	ldw	r2,0(r2)
8113c224:	113fff84 	addi	r4,r2,-2
8113c228:	00a045b4 	movhi	r2,33046
8113c22c:	10884f04 	addi	r2,r2,8508
8113c230:	10800383 	ldbu	r2,14(r2)
8113c234:	10803fcc 	andi	r2,r2,255
8113c238:	2085383a 	mul	r2,r4,r2
8113c23c:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
8113c240:	e13ffe0f 	ldh	r4,-8(fp)
8113c244:	00a045b4 	movhi	r2,33046
8113c248:	10886404 	addi	r2,r2,8592
8113c24c:	200891ba 	slli	r4,r4,6
8113c250:	1105883a 	add	r2,r2,r4
8113c254:	10800804 	addi	r2,r2,32
8113c258:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113c25c:	1885883a 	add	r2,r3,r2
8113c260:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
8113c264:	d0e0a217 	ldw	r3,-32120(gp)
8113c268:	e0bffb17 	ldw	r2,-20(fp)
8113c26c:	1885883a 	add	r2,r3,r2
8113c270:	1007883a 	mov	r3,r2
8113c274:	d0a0a617 	ldw	r2,-32104(gp)
8113c278:	18800726 	beq	r3,r2,8113c298 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8113c27c:	d0a0a217 	ldw	r2,-32120(gp)
8113c280:	100b883a 	mov	r5,r2
8113c284:	e13ffb17 	ldw	r4,-20(fp)
8113c288:	11382ac0 	call	811382ac <Read_Sector_Data>
8113c28c:	1000021e 	bne	r2,zero,8113c298 <alt_up_sd_card_write+0x518>
                {
					return false;
8113c290:	0005883a 	mov	r2,zero
8113c294:	00003f06 	br	8113c394 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
8113c298:	d0e0a117 	ldw	r3,-32124(gp)
8113c29c:	e0bffc0f 	ldh	r2,-16(fp)
8113c2a0:	1885883a 	add	r2,r3,r2
8113c2a4:	e0ffff07 	ldb	r3,-4(fp)
8113c2a8:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8113c2ac:	e13ffe0f 	ldh	r4,-8(fp)
8113c2b0:	e0fffe0f 	ldh	r3,-8(fp)
8113c2b4:	00a045b4 	movhi	r2,33046
8113c2b8:	10886404 	addi	r2,r2,8592
8113c2bc:	180691ba 	slli	r3,r3,6
8113c2c0:	10c5883a 	add	r2,r2,r3
8113c2c4:	10800904 	addi	r2,r2,36
8113c2c8:	10800017 	ldw	r2,0(r2)
8113c2cc:	10c00044 	addi	r3,r2,1
8113c2d0:	00a045b4 	movhi	r2,33046
8113c2d4:	10886404 	addi	r2,r2,8592
8113c2d8:	200891ba 	slli	r4,r4,6
8113c2dc:	1105883a 	add	r2,r2,r4
8113c2e0:	10800904 	addi	r2,r2,36
8113c2e4:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
8113c2e8:	e0fffe0f 	ldh	r3,-8(fp)
8113c2ec:	00a045b4 	movhi	r2,33046
8113c2f0:	10886404 	addi	r2,r2,8592
8113c2f4:	180691ba 	slli	r3,r3,6
8113c2f8:	10c5883a 	add	r2,r2,r3
8113c2fc:	10800904 	addi	r2,r2,36
8113c300:	10c00017 	ldw	r3,0(r2)
8113c304:	e13ffe0f 	ldh	r4,-8(fp)
8113c308:	00a045b4 	movhi	r2,33046
8113c30c:	10886404 	addi	r2,r2,8592
8113c310:	200891ba 	slli	r4,r4,6
8113c314:	1105883a 	add	r2,r2,r4
8113c318:	10800604 	addi	r2,r2,24
8113c31c:	10800017 	ldw	r2,0(r2)
8113c320:	18801736 	bltu	r3,r2,8113c380 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
8113c324:	e13ffe0f 	ldh	r4,-8(fp)
8113c328:	e0fffe0f 	ldh	r3,-8(fp)
8113c32c:	00a045b4 	movhi	r2,33046
8113c330:	10886404 	addi	r2,r2,8592
8113c334:	180691ba 	slli	r3,r3,6
8113c338:	10c5883a 	add	r2,r2,r3
8113c33c:	10800604 	addi	r2,r2,24
8113c340:	10800017 	ldw	r2,0(r2)
8113c344:	10c00044 	addi	r3,r2,1
8113c348:	00a045b4 	movhi	r2,33046
8113c34c:	10886404 	addi	r2,r2,8592
8113c350:	200891ba 	slli	r4,r4,6
8113c354:	1105883a 	add	r2,r2,r4
8113c358:	10800604 	addi	r2,r2,24
8113c35c:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
8113c360:	e0fffe0f 	ldh	r3,-8(fp)
8113c364:	00a045b4 	movhi	r2,33046
8113c368:	10886404 	addi	r2,r2,8592
8113c36c:	180691ba 	slli	r3,r3,6
8113c370:	10c5883a 	add	r2,r2,r3
8113c374:	10800e04 	addi	r2,r2,56
8113c378:	00c00044 	movi	r3,1
8113c37c:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
8113c380:	00800044 	movi	r2,1
8113c384:	d0a0a515 	stw	r2,-32108(gp)
			result = true;
8113c388:	00800044 	movi	r2,1
8113c38c:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
8113c390:	e0bffa17 	ldw	r2,-24(fp)
}
8113c394:	e037883a 	mov	sp,fp
8113c398:	dfc00117 	ldw	ra,4(sp)
8113c39c:	df000017 	ldw	fp,0(sp)
8113c3a0:	dec00204 	addi	sp,sp,8
8113c3a4:	f800283a 	ret

8113c3a8 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
8113c3a8:	defffb04 	addi	sp,sp,-20
8113c3ac:	de00012e 	bgeu	sp,et,8113c3b4 <alt_up_sd_card_fclose+0xc>
8113c3b0:	003b68fa 	trap	3
8113c3b4:	dfc00415 	stw	ra,16(sp)
8113c3b8:	df000315 	stw	fp,12(sp)
8113c3bc:	df000304 	addi	fp,sp,12
8113c3c0:	2005883a 	mov	r2,r4
8113c3c4:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
8113c3c8:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113c3cc:	113af840 	call	8113af84 <alt_up_sd_card_is_Present>
8113c3d0:	10006026 	beq	r2,zero,8113c554 <alt_up_sd_card_fclose+0x1ac>
8113c3d4:	d0a09b17 	ldw	r2,-32148(gp)
8113c3d8:	10005e26 	beq	r2,zero,8113c554 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
8113c3dc:	e0ffff0f 	ldh	r3,-4(fp)
8113c3e0:	00a045b4 	movhi	r2,33046
8113c3e4:	10886404 	addi	r2,r2,8592
8113c3e8:	180691ba 	slli	r3,r3,6
8113c3ec:	10c5883a 	add	r2,r2,r3
8113c3f0:	10800f04 	addi	r2,r2,60
8113c3f4:	10800017 	ldw	r2,0(r2)
8113c3f8:	10005626 	beq	r2,zero,8113c554 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
8113c3fc:	e0ffff0f 	ldh	r3,-4(fp)
8113c400:	00a045b4 	movhi	r2,33046
8113c404:	10886404 	addi	r2,r2,8592
8113c408:	180691ba 	slli	r3,r3,6
8113c40c:	10c5883a 	add	r2,r2,r3
8113c410:	10800e04 	addi	r2,r2,56
8113c414:	10800017 	ldw	r2,0(r2)
8113c418:	10004526 	beq	r2,zero,8113c530 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
8113c41c:	e0ffff0f 	ldh	r3,-4(fp)
8113c420:	00a045b4 	movhi	r2,33046
8113c424:	10886404 	addi	r2,r2,8592
8113c428:	180691ba 	slli	r3,r3,6
8113c42c:	10c5883a 	add	r2,r2,r3
8113c430:	10800b04 	addi	r2,r2,44
8113c434:	10800017 	ldw	r2,0(r2)
8113c438:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
8113c43c:	e0ffff0f 	ldh	r3,-4(fp)
8113c440:	00a045b4 	movhi	r2,33046
8113c444:	10886404 	addi	r2,r2,8592
8113c448:	180691ba 	slli	r3,r3,6
8113c44c:	10c5883a 	add	r2,r2,r3
8113c450:	10800a04 	addi	r2,r2,40
8113c454:	10800017 	ldw	r2,0(r2)
8113c458:	1000071e 	bne	r2,zero,8113c478 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
8113c45c:	00a045b4 	movhi	r2,33046
8113c460:	10884f04 	addi	r2,r2,8508
8113c464:	10801317 	ldw	r2,76(r2)
8113c468:	e0fffe17 	ldw	r3,-8(fp)
8113c46c:	1885883a 	add	r2,r3,r2
8113c470:	e0bffe15 	stw	r2,-8(fp)
8113c474:	00001406 	br	8113c4c8 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8113c478:	00a045b4 	movhi	r2,33046
8113c47c:	10884f04 	addi	r2,r2,8508
8113c480:	10c01417 	ldw	r3,80(r2)
8113c484:	e0bffe17 	ldw	r2,-8(fp)
8113c488:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
8113c48c:	e13fff0f 	ldh	r4,-4(fp)
8113c490:	00a045b4 	movhi	r2,33046
8113c494:	10886404 	addi	r2,r2,8592
8113c498:	200891ba 	slli	r4,r4,6
8113c49c:	1105883a 	add	r2,r2,r4
8113c4a0:	10800a04 	addi	r2,r2,40
8113c4a4:	10800017 	ldw	r2,0(r2)
8113c4a8:	113fff84 	addi	r4,r2,-2
8113c4ac:	00a045b4 	movhi	r2,33046
8113c4b0:	10884f04 	addi	r2,r2,8508
8113c4b4:	10800383 	ldbu	r2,14(r2)
8113c4b8:	10803fcc 	andi	r2,r2,255
8113c4bc:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8113c4c0:	1885883a 	add	r2,r3,r2
8113c4c4:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
8113c4c8:	e0bffe17 	ldw	r2,-8(fp)
8113c4cc:	d0e0a217 	ldw	r3,-32120(gp)
8113c4d0:	180b883a 	mov	r5,r3
8113c4d4:	1009883a 	mov	r4,r2
8113c4d8:	11382ac0 	call	811382ac <Read_Sector_Data>
8113c4dc:	10001426 	beq	r2,zero,8113c530 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
8113c4e0:	e0ffff0f 	ldh	r3,-4(fp)
8113c4e4:	00a045b4 	movhi	r2,33046
8113c4e8:	10886404 	addi	r2,r2,8592
8113c4ec:	180691ba 	slli	r3,r3,6
8113c4f0:	10c5883a 	add	r2,r2,r3
8113c4f4:	10800c04 	addi	r2,r2,48
8113c4f8:	1080000b 	ldhu	r2,0(r2)
8113c4fc:	113fffcc 	andi	r4,r2,65535
8113c500:	2120001c 	xori	r4,r4,32768
8113c504:	21200004 	addi	r4,r4,-32768
8113c508:	e0bfff0f 	ldh	r2,-4(fp)
8113c50c:	100691ba 	slli	r3,r2,6
8113c510:	00a045b4 	movhi	r2,33046
8113c514:	10886404 	addi	r2,r2,8592
8113c518:	1885883a 	add	r2,r3,r2
8113c51c:	100b883a 	mov	r5,r2
8113c520:	11389600 	call	81138960 <Write_File_Record_At_Offset>
8113c524:	10000226 	beq	r2,zero,8113c530 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
8113c528:	11382580 	call	81138258 <Save_Modified_Sector>
8113c52c:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
8113c530:	e0ffff0f 	ldh	r3,-4(fp)
8113c534:	00a045b4 	movhi	r2,33046
8113c538:	10886404 	addi	r2,r2,8592
8113c53c:	180691ba 	slli	r3,r3,6
8113c540:	10c5883a 	add	r2,r2,r3
8113c544:	10800f04 	addi	r2,r2,60
8113c548:	10000015 	stw	zero,0(r2)
			result = true;
8113c54c:	00800044 	movi	r2,1
8113c550:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
8113c554:	e0bffd17 	ldw	r2,-12(fp)
}
8113c558:	e037883a 	mov	sp,fp
8113c55c:	dfc00117 	ldw	ra,4(sp)
8113c560:	df000017 	ldw	fp,0(sp)
8113c564:	dec00204 	addi	sp,sp,8
8113c568:	f800283a 	ret

8113c56c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8113c56c:	defffa04 	addi	sp,sp,-24
8113c570:	de00012e 	bgeu	sp,et,8113c578 <altera_avalon_jtag_uart_read_fd+0xc>
8113c574:	003b68fa 	trap	3
8113c578:	dfc00515 	stw	ra,20(sp)
8113c57c:	df000415 	stw	fp,16(sp)
8113c580:	df000404 	addi	fp,sp,16
8113c584:	e13ffd15 	stw	r4,-12(fp)
8113c588:	e17ffe15 	stw	r5,-8(fp)
8113c58c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113c590:	e0bffd17 	ldw	r2,-12(fp)
8113c594:	10800017 	ldw	r2,0(r2)
8113c598:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
8113c59c:	e0bffc17 	ldw	r2,-16(fp)
8113c5a0:	10c00a04 	addi	r3,r2,40
8113c5a4:	e0bffd17 	ldw	r2,-12(fp)
8113c5a8:	10800217 	ldw	r2,8(r2)
8113c5ac:	100f883a 	mov	r7,r2
8113c5b0:	e1bfff17 	ldw	r6,-4(fp)
8113c5b4:	e17ffe17 	ldw	r5,-8(fp)
8113c5b8:	1809883a 	mov	r4,r3
8113c5bc:	113cdf00 	call	8113cdf0 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
8113c5c0:	e037883a 	mov	sp,fp
8113c5c4:	dfc00117 	ldw	ra,4(sp)
8113c5c8:	df000017 	ldw	fp,0(sp)
8113c5cc:	dec00204 	addi	sp,sp,8
8113c5d0:	f800283a 	ret

8113c5d4 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8113c5d4:	defffa04 	addi	sp,sp,-24
8113c5d8:	de00012e 	bgeu	sp,et,8113c5e0 <altera_avalon_jtag_uart_write_fd+0xc>
8113c5dc:	003b68fa 	trap	3
8113c5e0:	dfc00515 	stw	ra,20(sp)
8113c5e4:	df000415 	stw	fp,16(sp)
8113c5e8:	df000404 	addi	fp,sp,16
8113c5ec:	e13ffd15 	stw	r4,-12(fp)
8113c5f0:	e17ffe15 	stw	r5,-8(fp)
8113c5f4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113c5f8:	e0bffd17 	ldw	r2,-12(fp)
8113c5fc:	10800017 	ldw	r2,0(r2)
8113c600:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
8113c604:	e0bffc17 	ldw	r2,-16(fp)
8113c608:	10c00a04 	addi	r3,r2,40
8113c60c:	e0bffd17 	ldw	r2,-12(fp)
8113c610:	10800217 	ldw	r2,8(r2)
8113c614:	100f883a 	mov	r7,r2
8113c618:	e1bfff17 	ldw	r6,-4(fp)
8113c61c:	e17ffe17 	ldw	r5,-8(fp)
8113c620:	1809883a 	mov	r4,r3
8113c624:	113d0b40 	call	8113d0b4 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
8113c628:	e037883a 	mov	sp,fp
8113c62c:	dfc00117 	ldw	ra,4(sp)
8113c630:	df000017 	ldw	fp,0(sp)
8113c634:	dec00204 	addi	sp,sp,8
8113c638:	f800283a 	ret

8113c63c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
8113c63c:	defffc04 	addi	sp,sp,-16
8113c640:	de00012e 	bgeu	sp,et,8113c648 <altera_avalon_jtag_uart_close_fd+0xc>
8113c644:	003b68fa 	trap	3
8113c648:	dfc00315 	stw	ra,12(sp)
8113c64c:	df000215 	stw	fp,8(sp)
8113c650:	df000204 	addi	fp,sp,8
8113c654:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113c658:	e0bfff17 	ldw	r2,-4(fp)
8113c65c:	10800017 	ldw	r2,0(r2)
8113c660:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
8113c664:	e0bffe17 	ldw	r2,-8(fp)
8113c668:	10c00a04 	addi	r3,r2,40
8113c66c:	e0bfff17 	ldw	r2,-4(fp)
8113c670:	10800217 	ldw	r2,8(r2)
8113c674:	100b883a 	mov	r5,r2
8113c678:	1809883a 	mov	r4,r3
8113c67c:	113cc880 	call	8113cc88 <altera_avalon_jtag_uart_close>
}
8113c680:	e037883a 	mov	sp,fp
8113c684:	dfc00117 	ldw	ra,4(sp)
8113c688:	df000017 	ldw	fp,0(sp)
8113c68c:	dec00204 	addi	sp,sp,8
8113c690:	f800283a 	ret

8113c694 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
8113c694:	defffa04 	addi	sp,sp,-24
8113c698:	de00012e 	bgeu	sp,et,8113c6a0 <altera_avalon_jtag_uart_ioctl_fd+0xc>
8113c69c:	003b68fa 	trap	3
8113c6a0:	dfc00515 	stw	ra,20(sp)
8113c6a4:	df000415 	stw	fp,16(sp)
8113c6a8:	df000404 	addi	fp,sp,16
8113c6ac:	e13ffd15 	stw	r4,-12(fp)
8113c6b0:	e17ffe15 	stw	r5,-8(fp)
8113c6b4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
8113c6b8:	e0bffd17 	ldw	r2,-12(fp)
8113c6bc:	10800017 	ldw	r2,0(r2)
8113c6c0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
8113c6c4:	e0bffc17 	ldw	r2,-16(fp)
8113c6c8:	10800a04 	addi	r2,r2,40
8113c6cc:	e1bfff17 	ldw	r6,-4(fp)
8113c6d0:	e17ffe17 	ldw	r5,-8(fp)
8113c6d4:	1009883a 	mov	r4,r2
8113c6d8:	113ccf80 	call	8113ccf8 <altera_avalon_jtag_uart_ioctl>
}
8113c6dc:	e037883a 	mov	sp,fp
8113c6e0:	dfc00117 	ldw	ra,4(sp)
8113c6e4:	df000017 	ldw	fp,0(sp)
8113c6e8:	dec00204 	addi	sp,sp,8
8113c6ec:	f800283a 	ret

8113c6f0 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
8113c6f0:	deffef04 	addi	sp,sp,-68
8113c6f4:	de00012e 	bgeu	sp,et,8113c6fc <altera_avalon_jtag_uart_init+0xc>
8113c6f8:	003b68fa 	trap	3
8113c6fc:	dfc01015 	stw	ra,64(sp)
8113c700:	df000f15 	stw	fp,60(sp)
8113c704:	dc400e15 	stw	r17,56(sp)
8113c708:	dc000d15 	stw	r16,52(sp)
8113c70c:	df000f04 	addi	fp,sp,60
8113c710:	e13ff715 	stw	r4,-36(fp)
8113c714:	e17ff815 	stw	r5,-32(fp)
8113c718:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
8113c71c:	e0bff717 	ldw	r2,-36(fp)
8113c720:	10800c04 	addi	r2,r2,48
8113c724:	e0bff215 	stw	r2,-56(fp)
8113c728:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
8113c72c:	e0bff60b 	ldhu	r2,-40(fp)
8113c730:	e0fff684 	addi	r3,fp,-38
8113c734:	180b883a 	mov	r5,r3
8113c738:	1009883a 	mov	r4,r2
8113c73c:	1130a740 	call	81130a74 <OSFlagCreate>
8113c740:	1007883a 	mov	r3,r2
8113c744:	e0bff217 	ldw	r2,-56(fp)
8113c748:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
8113c74c:	e0bff717 	ldw	r2,-36(fp)
8113c750:	10800a04 	addi	r2,r2,40
8113c754:	e0bff315 	stw	r2,-52(fp)
8113c758:	00800044 	movi	r2,1
8113c75c:	e0bff58d 	sth	r2,-42(fp)
8113c760:	e0bff58b 	ldhu	r2,-42(fp)
8113c764:	1009883a 	mov	r4,r2
8113c768:	11349d00 	call	811349d0 <OSSemCreate>
8113c76c:	1007883a 	mov	r3,r2
8113c770:	e0bff317 	ldw	r2,-52(fp)
8113c774:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
8113c778:	e0bff717 	ldw	r2,-36(fp)
8113c77c:	10800b04 	addi	r2,r2,44
8113c780:	e0bff415 	stw	r2,-48(fp)
8113c784:	00800044 	movi	r2,1
8113c788:	e0bff50d 	sth	r2,-44(fp)
8113c78c:	e0bff50b 	ldhu	r2,-44(fp)
8113c790:	1009883a 	mov	r4,r2
8113c794:	11349d00 	call	811349d0 <OSSemCreate>
8113c798:	1007883a 	mov	r3,r2
8113c79c:	e0bff417 	ldw	r2,-48(fp)
8113c7a0:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113c7a4:	e0bff717 	ldw	r2,-36(fp)
8113c7a8:	00c00044 	movi	r3,1
8113c7ac:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
8113c7b0:	e0bff717 	ldw	r2,-36(fp)
8113c7b4:	10800017 	ldw	r2,0(r2)
8113c7b8:	10800104 	addi	r2,r2,4
8113c7bc:	1007883a 	mov	r3,r2
8113c7c0:	e0bff717 	ldw	r2,-36(fp)
8113c7c4:	10800817 	ldw	r2,32(r2)
8113c7c8:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
8113c7cc:	e0bff817 	ldw	r2,-32(fp)
8113c7d0:	e0fff917 	ldw	r3,-28(fp)
8113c7d4:	d8000015 	stw	zero,0(sp)
8113c7d8:	e1fff717 	ldw	r7,-36(fp)
8113c7dc:	01a04534 	movhi	r6,33044
8113c7e0:	31b23004 	addi	r6,r6,-14144
8113c7e4:	180b883a 	mov	r5,r3
8113c7e8:	1009883a 	mov	r4,r2
8113c7ec:	11406080 	call	81140608 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
8113c7f0:	e0bff717 	ldw	r2,-36(fp)
8113c7f4:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
8113c7f8:	e0bff717 	ldw	r2,-36(fp)
8113c7fc:	10800204 	addi	r2,r2,8
8113c800:	d0e07917 	ldw	r3,-32284(gp)
8113c804:	e1fff717 	ldw	r7,-36(fp)
8113c808:	01a04534 	movhi	r6,33044
8113c80c:	31b2df04 	addi	r6,r6,-13444
8113c810:	180b883a 	mov	r5,r3
8113c814:	1009883a 	mov	r4,r2
8113c818:	11401580 	call	81140158 <alt_alarm_start>
8113c81c:	1000040e 	bge	r2,zero,8113c830 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
8113c820:	e0fff717 	ldw	r3,-36(fp)
8113c824:	00a00034 	movhi	r2,32768
8113c828:	10bfffc4 	addi	r2,r2,-1
8113c82c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
8113c830:	d0a07283 	ldbu	r2,-32310(gp)
8113c834:	10803fcc 	andi	r2,r2,255
8113c838:	10800058 	cmpnei	r2,r2,1
8113c83c:	10000f1e 	bne	r2,zero,8113c87c <altera_avalon_jtag_uart_init+0x18c>
8113c840:	d0e07917 	ldw	r3,-32284(gp)
8113c844:	00b33374 	movhi	r2,52429
8113c848:	10b33344 	addi	r2,r2,-13107
8113c84c:	1888383a 	mulxuu	r4,r3,r2
8113c850:	1885383a 	mul	r2,r3,r2
8113c854:	1021883a 	mov	r16,r2
8113c858:	2023883a 	mov	r17,r4
8113c85c:	8804d0fa 	srli	r2,r17,3
8113c860:	e1fff717 	ldw	r7,-36(fp)
8113c864:	01a044f4 	movhi	r6,33043
8113c868:	31b46904 	addi	r6,r6,-11868
8113c86c:	100b883a 	mov	r5,r2
8113c870:	012045b4 	movhi	r4,33046
8113c874:	21320d04 	addi	r4,r4,-14284
8113c878:	11401580 	call	81140158 <alt_alarm_start>
8113c87c:	d0a07303 	ldbu	r2,-32308(gp)
8113c880:	10803fcc 	andi	r2,r2,255
8113c884:	10800058 	cmpnei	r2,r2,1
8113c888:	1000051e 	bne	r2,zero,8113c8a0 <altera_avalon_jtag_uart_init+0x1b0>
8113c88c:	e0bff717 	ldw	r2,-36(fp)
8113c890:	10800017 	ldw	r2,0(r2)
8113c894:	100b883a 	mov	r5,r2
8113c898:	e13ff717 	ldw	r4,-36(fp)
8113c89c:	112d33c0 	call	8112d33c <alt_log_jtag_uart_startup_info>
}
8113c8a0:	0001883a 	nop
8113c8a4:	e6fffe04 	addi	sp,fp,-8
8113c8a8:	dfc00317 	ldw	ra,12(sp)
8113c8ac:	df000217 	ldw	fp,8(sp)
8113c8b0:	dc400117 	ldw	r17,4(sp)
8113c8b4:	dc000017 	ldw	r16,0(sp)
8113c8b8:	dec00404 	addi	sp,sp,16
8113c8bc:	f800283a 	ret

8113c8c0 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
8113c8c0:	defff204 	addi	sp,sp,-56
8113c8c4:	de00012e 	bgeu	sp,et,8113c8cc <altera_avalon_jtag_uart_irq+0xc>
8113c8c8:	003b68fa 	trap	3
8113c8cc:	dfc00d15 	stw	ra,52(sp)
8113c8d0:	df000c15 	stw	fp,48(sp)
8113c8d4:	df000c04 	addi	fp,sp,48
8113c8d8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
8113c8dc:	e0bfff17 	ldw	r2,-4(fp)
8113c8e0:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
8113c8e4:	e0bff617 	ldw	r2,-40(fp)
8113c8e8:	10800017 	ldw	r2,0(r2)
8113c8ec:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
8113c8f0:	e0bff717 	ldw	r2,-36(fp)
8113c8f4:	e17ff617 	ldw	r5,-40(fp)
8113c8f8:	1009883a 	mov	r4,r2
8113c8fc:	112d3900 	call	8112d390 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113c900:	e0bff717 	ldw	r2,-36(fp)
8113c904:	10800104 	addi	r2,r2,4
8113c908:	10800037 	ldwio	r2,0(r2)
8113c90c:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
8113c910:	e0bff817 	ldw	r2,-32(fp)
8113c914:	1080c00c 	andi	r2,r2,768
8113c918:	10009126 	beq	r2,zero,8113cb60 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
8113c91c:	e0bff817 	ldw	r2,-32(fp)
8113c920:	1080400c 	andi	r2,r2,256
8113c924:	10004726 	beq	r2,zero,8113ca44 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
8113c928:	00800074 	movhi	r2,1
8113c92c:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113c930:	e0bff617 	ldw	r2,-40(fp)
8113c934:	10800d17 	ldw	r2,52(r2)
8113c938:	10800044 	addi	r2,r2,1
8113c93c:	1081ffcc 	andi	r2,r2,2047
8113c940:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
8113c944:	e0bff617 	ldw	r2,-40(fp)
8113c948:	10c00e17 	ldw	r3,56(r2)
8113c94c:	e0bff917 	ldw	r2,-28(fp)
8113c950:	18802726 	beq	r3,r2,8113c9f0 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
8113c954:	e0bff717 	ldw	r2,-36(fp)
8113c958:	10800037 	ldwio	r2,0(r2)
8113c95c:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
8113c960:	e0bff417 	ldw	r2,-48(fp)
8113c964:	10a0000c 	andi	r2,r2,32768
8113c968:	10002326 	beq	r2,zero,8113c9f8 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
8113c96c:	e0bff617 	ldw	r2,-40(fp)
8113c970:	10800d17 	ldw	r2,52(r2)
8113c974:	e0fff417 	ldw	r3,-48(fp)
8113c978:	1809883a 	mov	r4,r3
8113c97c:	e0fff617 	ldw	r3,-40(fp)
8113c980:	1885883a 	add	r2,r3,r2
8113c984:	10801104 	addi	r2,r2,68
8113c988:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113c98c:	e0bff617 	ldw	r2,-40(fp)
8113c990:	10800d17 	ldw	r2,52(r2)
8113c994:	10800044 	addi	r2,r2,1
8113c998:	10c1ffcc 	andi	r3,r2,2047
8113c99c:	e0bff617 	ldw	r2,-40(fp)
8113c9a0:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
8113c9a4:	e0bff617 	ldw	r2,-40(fp)
8113c9a8:	10800c17 	ldw	r2,48(r2)
8113c9ac:	e0bffb15 	stw	r2,-20(fp)
8113c9b0:	00800044 	movi	r2,1
8113c9b4:	e0bffc0d 	sth	r2,-16(fp)
8113c9b8:	00800044 	movi	r2,1
8113c9bc:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113c9c0:	d0a08203 	ldbu	r2,-32248(gp)
8113c9c4:	10803fcc 	andi	r2,r2,255
8113c9c8:	103fd926 	beq	r2,zero,8113c930 <__reset+0xfb11c930>
  {
    OSFlagPost (group, flags, opt, &err);
8113c9cc:	e0bffc0b 	ldhu	r2,-16(fp)
8113c9d0:	e0fffc83 	ldbu	r3,-14(fp)
8113c9d4:	e13ffdc4 	addi	r4,fp,-9
8113c9d8:	200f883a 	mov	r7,r4
8113c9dc:	180d883a 	mov	r6,r3
8113c9e0:	100b883a 	mov	r5,r2
8113c9e4:	e13ffb17 	ldw	r4,-20(fp)
8113c9e8:	11316800 	call	81131680 <OSFlagPost>
      }
8113c9ec:	003fd006 	br	8113c930 <__reset+0xfb11c930>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
8113c9f0:	0001883a 	nop
8113c9f4:	00000106 	br	8113c9fc <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
8113c9f8:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
8113c9fc:	e0bff417 	ldw	r2,-48(fp)
8113ca00:	10bfffec 	andhi	r2,r2,65535
8113ca04:	10000f26 	beq	r2,zero,8113ca44 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113ca08:	e0bff617 	ldw	r2,-40(fp)
8113ca0c:	10c00817 	ldw	r3,32(r2)
8113ca10:	00bfff84 	movi	r2,-2
8113ca14:	1886703a 	and	r3,r3,r2
8113ca18:	e0bff617 	ldw	r2,-40(fp)
8113ca1c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
8113ca20:	e0bff717 	ldw	r2,-36(fp)
8113ca24:	10800104 	addi	r2,r2,4
8113ca28:	1007883a 	mov	r3,r2
8113ca2c:	e0bff617 	ldw	r2,-40(fp)
8113ca30:	10800817 	ldw	r2,32(r2)
8113ca34:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113ca38:	e0bff717 	ldw	r2,-36(fp)
8113ca3c:	10800104 	addi	r2,r2,4
8113ca40:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
8113ca44:	e0bff817 	ldw	r2,-32(fp)
8113ca48:	1080800c 	andi	r2,r2,512
8113ca4c:	103fac26 	beq	r2,zero,8113c900 <__reset+0xfb11c900>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
8113ca50:	e0bff817 	ldw	r2,-32(fp)
8113ca54:	1004d43a 	srli	r2,r2,16
8113ca58:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
8113ca5c:	00002606 	br	8113caf8 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
8113ca60:	e0bff717 	ldw	r2,-36(fp)
8113ca64:	e0fff617 	ldw	r3,-40(fp)
8113ca68:	18c01017 	ldw	r3,64(r3)
8113ca6c:	e13ff617 	ldw	r4,-40(fp)
8113ca70:	20c7883a 	add	r3,r4,r3
8113ca74:	18c21104 	addi	r3,r3,2116
8113ca78:	18c00003 	ldbu	r3,0(r3)
8113ca7c:	18c03fcc 	andi	r3,r3,255
8113ca80:	18c0201c 	xori	r3,r3,128
8113ca84:	18ffe004 	addi	r3,r3,-128
8113ca88:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113ca8c:	e0bff617 	ldw	r2,-40(fp)
8113ca90:	10801017 	ldw	r2,64(r2)
8113ca94:	10800044 	addi	r2,r2,1
8113ca98:	10c1ffcc 	andi	r3,r2,2047
8113ca9c:	e0bff617 	ldw	r2,-40(fp)
8113caa0:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
8113caa4:	e0bff617 	ldw	r2,-40(fp)
8113caa8:	10800c17 	ldw	r2,48(r2)
8113caac:	e0bffa15 	stw	r2,-24(fp)
8113cab0:	00800084 	movi	r2,2
8113cab4:	e0bffd0d 	sth	r2,-12(fp)
8113cab8:	00800044 	movi	r2,1
8113cabc:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113cac0:	d0a08203 	ldbu	r2,-32248(gp)
8113cac4:	10803fcc 	andi	r2,r2,255
8113cac8:	10000826 	beq	r2,zero,8113caec <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
8113cacc:	e0bffd0b 	ldhu	r2,-12(fp)
8113cad0:	e0fffd83 	ldbu	r3,-10(fp)
8113cad4:	e13ffe04 	addi	r4,fp,-8
8113cad8:	200f883a 	mov	r7,r4
8113cadc:	180d883a 	mov	r6,r3
8113cae0:	100b883a 	mov	r5,r2
8113cae4:	e13ffa17 	ldw	r4,-24(fp)
8113cae8:	11316800 	call	81131680 <OSFlagPost>

        space--;
8113caec:	e0bff517 	ldw	r2,-44(fp)
8113caf0:	10bfffc4 	addi	r2,r2,-1
8113caf4:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
8113caf8:	e0bff517 	ldw	r2,-44(fp)
8113cafc:	10000526 	beq	r2,zero,8113cb14 <altera_avalon_jtag_uart_irq+0x254>
8113cb00:	e0bff617 	ldw	r2,-40(fp)
8113cb04:	10c01017 	ldw	r3,64(r2)
8113cb08:	e0bff617 	ldw	r2,-40(fp)
8113cb0c:	10800f17 	ldw	r2,60(r2)
8113cb10:	18bfd31e 	bne	r3,r2,8113ca60 <__reset+0xfb11ca60>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
8113cb14:	e0bff517 	ldw	r2,-44(fp)
8113cb18:	103f7926 	beq	r2,zero,8113c900 <__reset+0xfb11c900>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
8113cb1c:	e0bff617 	ldw	r2,-40(fp)
8113cb20:	10c00817 	ldw	r3,32(r2)
8113cb24:	00bfff44 	movi	r2,-3
8113cb28:	1886703a 	and	r3,r3,r2
8113cb2c:	e0bff617 	ldw	r2,-40(fp)
8113cb30:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8113cb34:	e0bff617 	ldw	r2,-40(fp)
8113cb38:	10800017 	ldw	r2,0(r2)
8113cb3c:	10800104 	addi	r2,r2,4
8113cb40:	1007883a 	mov	r3,r2
8113cb44:	e0bff617 	ldw	r2,-40(fp)
8113cb48:	10800817 	ldw	r2,32(r2)
8113cb4c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113cb50:	e0bff717 	ldw	r2,-36(fp)
8113cb54:	10800104 	addi	r2,r2,4
8113cb58:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
8113cb5c:	003f6806 	br	8113c900 <__reset+0xfb11c900>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
8113cb60:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
8113cb64:	0001883a 	nop
8113cb68:	e037883a 	mov	sp,fp
8113cb6c:	dfc00117 	ldw	ra,4(sp)
8113cb70:	df000017 	ldw	fp,0(sp)
8113cb74:	dec00204 	addi	sp,sp,8
8113cb78:	f800283a 	ret

8113cb7c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
8113cb7c:	defff904 	addi	sp,sp,-28
8113cb80:	de00012e 	bgeu	sp,et,8113cb88 <altera_avalon_jtag_uart_timeout+0xc>
8113cb84:	003b68fa 	trap	3
8113cb88:	dfc00615 	stw	ra,24(sp)
8113cb8c:	df000515 	stw	fp,20(sp)
8113cb90:	df000504 	addi	fp,sp,20
8113cb94:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
8113cb98:	e0bfff17 	ldw	r2,-4(fp)
8113cb9c:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
8113cba0:	e0bffb17 	ldw	r2,-20(fp)
8113cba4:	10800017 	ldw	r2,0(r2)
8113cba8:	10800104 	addi	r2,r2,4
8113cbac:	10800037 	ldwio	r2,0(r2)
8113cbb0:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
8113cbb4:	e0bffc17 	ldw	r2,-16(fp)
8113cbb8:	1081000c 	andi	r2,r2,1024
8113cbbc:	10000b26 	beq	r2,zero,8113cbec <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
8113cbc0:	e0bffb17 	ldw	r2,-20(fp)
8113cbc4:	10800017 	ldw	r2,0(r2)
8113cbc8:	10800104 	addi	r2,r2,4
8113cbcc:	1007883a 	mov	r3,r2
8113cbd0:	e0bffb17 	ldw	r2,-20(fp)
8113cbd4:	10800817 	ldw	r2,32(r2)
8113cbd8:	10810014 	ori	r2,r2,1024
8113cbdc:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
8113cbe0:	e0bffb17 	ldw	r2,-20(fp)
8113cbe4:	10000915 	stw	zero,36(r2)
8113cbe8:	00002106 	br	8113cc70 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
8113cbec:	e0bffb17 	ldw	r2,-20(fp)
8113cbf0:	10c00917 	ldw	r3,36(r2)
8113cbf4:	00a00034 	movhi	r2,32768
8113cbf8:	10bfff04 	addi	r2,r2,-4
8113cbfc:	10c01c36 	bltu	r2,r3,8113cc70 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
8113cc00:	e0bffb17 	ldw	r2,-20(fp)
8113cc04:	10800917 	ldw	r2,36(r2)
8113cc08:	10c00044 	addi	r3,r2,1
8113cc0c:	e0bffb17 	ldw	r2,-20(fp)
8113cc10:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
8113cc14:	e0bffb17 	ldw	r2,-20(fp)
8113cc18:	10c00917 	ldw	r3,36(r2)
8113cc1c:	e0bffb17 	ldw	r2,-20(fp)
8113cc20:	10800117 	ldw	r2,4(r2)
8113cc24:	18801236 	bltu	r3,r2,8113cc70 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
8113cc28:	e0bffb17 	ldw	r2,-20(fp)
8113cc2c:	10800c17 	ldw	r2,48(r2)
8113cc30:	e0bffd15 	stw	r2,-12(fp)
8113cc34:	00800104 	movi	r2,4
8113cc38:	e0bffe0d 	sth	r2,-8(fp)
8113cc3c:	00800044 	movi	r2,1
8113cc40:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113cc44:	d0a08203 	ldbu	r2,-32248(gp)
8113cc48:	10803fcc 	andi	r2,r2,255
8113cc4c:	10000826 	beq	r2,zero,8113cc70 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
8113cc50:	e0bffe0b 	ldhu	r2,-8(fp)
8113cc54:	e0fffe83 	ldbu	r3,-6(fp)
8113cc58:	e13ffec4 	addi	r4,fp,-5
8113cc5c:	200f883a 	mov	r7,r4
8113cc60:	180d883a 	mov	r6,r3
8113cc64:	100b883a 	mov	r5,r2
8113cc68:	e13ffd17 	ldw	r4,-12(fp)
8113cc6c:	11316800 	call	81131680 <OSFlagPost>
8113cc70:	d0a07917 	ldw	r2,-32284(gp)
    }
  }

  return alt_ticks_per_second();
}
8113cc74:	e037883a 	mov	sp,fp
8113cc78:	dfc00117 	ldw	ra,4(sp)
8113cc7c:	df000017 	ldw	fp,0(sp)
8113cc80:	dec00204 	addi	sp,sp,8
8113cc84:	f800283a 	ret

8113cc88 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
8113cc88:	defffd04 	addi	sp,sp,-12
8113cc8c:	de00012e 	bgeu	sp,et,8113cc94 <altera_avalon_jtag_uart_close+0xc>
8113cc90:	003b68fa 	trap	3
8113cc94:	df000215 	stw	fp,8(sp)
8113cc98:	df000204 	addi	fp,sp,8
8113cc9c:	e13ffe15 	stw	r4,-8(fp)
8113cca0:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
8113cca4:	00000506 	br	8113ccbc <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8113cca8:	e0bfff17 	ldw	r2,-4(fp)
8113ccac:	1090000c 	andi	r2,r2,16384
8113ccb0:	10000226 	beq	r2,zero,8113ccbc <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
8113ccb4:	00bffd44 	movi	r2,-11
8113ccb8:	00000b06 	br	8113cce8 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
8113ccbc:	e0bffe17 	ldw	r2,-8(fp)
8113ccc0:	10c01017 	ldw	r3,64(r2)
8113ccc4:	e0bffe17 	ldw	r2,-8(fp)
8113ccc8:	10800f17 	ldw	r2,60(r2)
8113cccc:	18800526 	beq	r3,r2,8113cce4 <altera_avalon_jtag_uart_close+0x5c>
8113ccd0:	e0bffe17 	ldw	r2,-8(fp)
8113ccd4:	10c00917 	ldw	r3,36(r2)
8113ccd8:	e0bffe17 	ldw	r2,-8(fp)
8113ccdc:	10800117 	ldw	r2,4(r2)
8113cce0:	18bff136 	bltu	r3,r2,8113cca8 <__reset+0xfb11cca8>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
8113cce4:	0005883a 	mov	r2,zero
}
8113cce8:	e037883a 	mov	sp,fp
8113ccec:	df000017 	ldw	fp,0(sp)
8113ccf0:	dec00104 	addi	sp,sp,4
8113ccf4:	f800283a 	ret

8113ccf8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
8113ccf8:	defffa04 	addi	sp,sp,-24
8113ccfc:	de00012e 	bgeu	sp,et,8113cd04 <altera_avalon_jtag_uart_ioctl+0xc>
8113cd00:	003b68fa 	trap	3
8113cd04:	df000515 	stw	fp,20(sp)
8113cd08:	df000504 	addi	fp,sp,20
8113cd0c:	e13ffd15 	stw	r4,-12(fp)
8113cd10:	e17ffe15 	stw	r5,-8(fp)
8113cd14:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
8113cd18:	00bff9c4 	movi	r2,-25
8113cd1c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
8113cd20:	e0bffe17 	ldw	r2,-8(fp)
8113cd24:	10da8060 	cmpeqi	r3,r2,27137
8113cd28:	1800031e 	bne	r3,zero,8113cd38 <altera_avalon_jtag_uart_ioctl+0x40>
8113cd2c:	109a80a0 	cmpeqi	r2,r2,27138
8113cd30:	1000181e 	bne	r2,zero,8113cd94 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
8113cd34:	00002906 	br	8113cddc <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
8113cd38:	e0bffd17 	ldw	r2,-12(fp)
8113cd3c:	10c00117 	ldw	r3,4(r2)
8113cd40:	00a00034 	movhi	r2,32768
8113cd44:	10bfffc4 	addi	r2,r2,-1
8113cd48:	18802126 	beq	r3,r2,8113cdd0 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
8113cd4c:	e0bfff17 	ldw	r2,-4(fp)
8113cd50:	10800017 	ldw	r2,0(r2)
8113cd54:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
8113cd58:	e0bffc17 	ldw	r2,-16(fp)
8113cd5c:	10800090 	cmplti	r2,r2,2
8113cd60:	1000061e 	bne	r2,zero,8113cd7c <altera_avalon_jtag_uart_ioctl+0x84>
8113cd64:	e0fffc17 	ldw	r3,-16(fp)
8113cd68:	00a00034 	movhi	r2,32768
8113cd6c:	10bfffc4 	addi	r2,r2,-1
8113cd70:	18800226 	beq	r3,r2,8113cd7c <altera_avalon_jtag_uart_ioctl+0x84>
8113cd74:	e0bffc17 	ldw	r2,-16(fp)
8113cd78:	00000206 	br	8113cd84 <altera_avalon_jtag_uart_ioctl+0x8c>
8113cd7c:	00a00034 	movhi	r2,32768
8113cd80:	10bfff84 	addi	r2,r2,-2
8113cd84:	e0fffd17 	ldw	r3,-12(fp)
8113cd88:	18800115 	stw	r2,4(r3)
      rc = 0;
8113cd8c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
8113cd90:	00000f06 	br	8113cdd0 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
8113cd94:	e0bffd17 	ldw	r2,-12(fp)
8113cd98:	10c00117 	ldw	r3,4(r2)
8113cd9c:	00a00034 	movhi	r2,32768
8113cda0:	10bfffc4 	addi	r2,r2,-1
8113cda4:	18800c26 	beq	r3,r2,8113cdd8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
8113cda8:	e0bffd17 	ldw	r2,-12(fp)
8113cdac:	10c00917 	ldw	r3,36(r2)
8113cdb0:	e0bffd17 	ldw	r2,-12(fp)
8113cdb4:	10800117 	ldw	r2,4(r2)
8113cdb8:	1885803a 	cmpltu	r2,r3,r2
8113cdbc:	10c03fcc 	andi	r3,r2,255
8113cdc0:	e0bfff17 	ldw	r2,-4(fp)
8113cdc4:	10c00015 	stw	r3,0(r2)
      rc = 0;
8113cdc8:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
8113cdcc:	00000206 	br	8113cdd8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
8113cdd0:	0001883a 	nop
8113cdd4:	00000106 	br	8113cddc <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
8113cdd8:	0001883a 	nop

  default:
    break;
  }

  return rc;
8113cddc:	e0bffb17 	ldw	r2,-20(fp)
}
8113cde0:	e037883a 	mov	sp,fp
8113cde4:	df000017 	ldw	fp,0(sp)
8113cde8:	dec00104 	addi	sp,sp,4
8113cdec:	f800283a 	ret

8113cdf0 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
8113cdf0:	deffed04 	addi	sp,sp,-76
8113cdf4:	de00012e 	bgeu	sp,et,8113cdfc <altera_avalon_jtag_uart_read+0xc>
8113cdf8:	003b68fa 	trap	3
8113cdfc:	dfc01215 	stw	ra,72(sp)
8113ce00:	df001115 	stw	fp,68(sp)
8113ce04:	df001104 	addi	fp,sp,68
8113ce08:	e13ffc15 	stw	r4,-16(fp)
8113ce0c:	e17ffd15 	stw	r5,-12(fp)
8113ce10:	e1bffe15 	stw	r6,-8(fp)
8113ce14:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
8113ce18:	e0bffd17 	ldw	r2,-12(fp)
8113ce1c:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
8113ce20:	e0bffc17 	ldw	r2,-16(fp)
8113ce24:	10800a17 	ldw	r2,40(r2)
8113ce28:	e0bff815 	stw	r2,-32(fp)
8113ce2c:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8113ce30:	e0bff90b 	ldhu	r2,-28(fp)
8113ce34:	e0fffb04 	addi	r3,fp,-20
8113ce38:	180d883a 	mov	r6,r3
8113ce3c:	100b883a 	mov	r5,r2
8113ce40:	e13ff817 	ldw	r4,-32(fp)
8113ce44:	1134cf80 	call	81134cf8 <OSSemPend>

  while (space > 0)
8113ce48:	00006106 	br	8113cfd0 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
8113ce4c:	e0bffc17 	ldw	r2,-16(fp)
8113ce50:	10800d17 	ldw	r2,52(r2)
8113ce54:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
8113ce58:	e0bffc17 	ldw	r2,-16(fp)
8113ce5c:	10800e17 	ldw	r2,56(r2)
8113ce60:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
8113ce64:	e0fff317 	ldw	r3,-52(fp)
8113ce68:	e0bff417 	ldw	r2,-48(fp)
8113ce6c:	18800536 	bltu	r3,r2,8113ce84 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
8113ce70:	e0fff317 	ldw	r3,-52(fp)
8113ce74:	e0bff417 	ldw	r2,-48(fp)
8113ce78:	1885c83a 	sub	r2,r3,r2
8113ce7c:	e0bff115 	stw	r2,-60(fp)
8113ce80:	00000406 	br	8113ce94 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
8113ce84:	00c20004 	movi	r3,2048
8113ce88:	e0bff417 	ldw	r2,-48(fp)
8113ce8c:	1885c83a 	sub	r2,r3,r2
8113ce90:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8113ce94:	e0bff117 	ldw	r2,-60(fp)
8113ce98:	10001e26 	beq	r2,zero,8113cf14 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
8113ce9c:	e0fffe17 	ldw	r3,-8(fp)
8113cea0:	e0bff117 	ldw	r2,-60(fp)
8113cea4:	1880022e 	bgeu	r3,r2,8113ceb0 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
8113cea8:	e0bffe17 	ldw	r2,-8(fp)
8113ceac:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
8113ceb0:	e0bffc17 	ldw	r2,-16(fp)
8113ceb4:	10c01104 	addi	r3,r2,68
8113ceb8:	e0bff417 	ldw	r2,-48(fp)
8113cebc:	1885883a 	add	r2,r3,r2
8113cec0:	e1bff117 	ldw	r6,-60(fp)
8113cec4:	100b883a 	mov	r5,r2
8113cec8:	e13ff017 	ldw	r4,-64(fp)
8113cecc:	1117ccc0 	call	81117ccc <memcpy>
      ptr   += n;
8113ced0:	e0fff017 	ldw	r3,-64(fp)
8113ced4:	e0bff117 	ldw	r2,-60(fp)
8113ced8:	1885883a 	add	r2,r3,r2
8113cedc:	e0bff015 	stw	r2,-64(fp)
      space -= n;
8113cee0:	e0fffe17 	ldw	r3,-8(fp)
8113cee4:	e0bff117 	ldw	r2,-60(fp)
8113cee8:	1885c83a 	sub	r2,r3,r2
8113ceec:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113cef0:	e0fff417 	ldw	r3,-48(fp)
8113cef4:	e0bff117 	ldw	r2,-60(fp)
8113cef8:	1885883a 	add	r2,r3,r2
8113cefc:	10c1ffcc 	andi	r3,r2,2047
8113cf00:	e0bffc17 	ldw	r2,-16(fp)
8113cf04:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
8113cf08:	e0bffe17 	ldw	r2,-8(fp)
8113cf0c:	00bfcf16 	blt	zero,r2,8113ce4c <__reset+0xfb11ce4c>
8113cf10:	00000106 	br	8113cf18 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
8113cf14:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
8113cf18:	e0fff017 	ldw	r3,-64(fp)
8113cf1c:	e0bffd17 	ldw	r2,-12(fp)
8113cf20:	18802e1e 	bne	r3,r2,8113cfdc <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
8113cf24:	e0bfff17 	ldw	r2,-4(fp)
8113cf28:	1090000c 	andi	r2,r2,16384
8113cf2c:	10002d1e 	bne	r2,zero,8113cfe4 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
8113cf30:	d0a08203 	ldbu	r2,-32248(gp)
8113cf34:	10803fcc 	andi	r2,r2,255
8113cf38:	10800058 	cmpnei	r2,r2,1
8113cf3c:	1000161e 	bne	r2,zero,8113cf98 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
8113cf40:	e0bffc17 	ldw	r2,-16(fp)
8113cf44:	10800c17 	ldw	r2,48(r2)
8113cf48:	e0bff215 	stw	r2,-56(fp)
8113cf4c:	00800144 	movi	r2,5
8113cf50:	e0bff98d 	sth	r2,-26(fp)
8113cf54:	00bfe0c4 	movi	r2,-125
8113cf58:	e0bffa05 	stb	r2,-24(fp)
8113cf5c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113cf60:	d0a08203 	ldbu	r2,-32248(gp)
8113cf64:	10803fcc 	andi	r2,r2,255
8113cf68:	10001526 	beq	r2,zero,8113cfc0 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113cf6c:	e0fff98b 	ldhu	r3,-26(fp)
8113cf70:	e13ffa03 	ldbu	r4,-24(fp)
8113cf74:	e17ffa8b 	ldhu	r5,-22(fp)
8113cf78:	e0bffb44 	addi	r2,fp,-19
8113cf7c:	d8800015 	stw	r2,0(sp)
8113cf80:	280f883a 	mov	r7,r5
8113cf84:	200d883a 	mov	r6,r4
8113cf88:	180b883a 	mov	r5,r3
8113cf8c:	e13ff217 	ldw	r4,-56(fp)
8113cf90:	11310580 	call	81131058 <OSFlagPend>
8113cf94:	00000a06 	br	8113cfc0 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
8113cf98:	0001883a 	nop
8113cf9c:	e0bffc17 	ldw	r2,-16(fp)
8113cfa0:	10c00d17 	ldw	r3,52(r2)
8113cfa4:	e0bff317 	ldw	r2,-52(fp)
8113cfa8:	1880051e 	bne	r3,r2,8113cfc0 <altera_avalon_jtag_uart_read+0x1d0>
8113cfac:	e0bffc17 	ldw	r2,-16(fp)
8113cfb0:	10c00917 	ldw	r3,36(r2)
8113cfb4:	e0bffc17 	ldw	r2,-16(fp)
8113cfb8:	10800117 	ldw	r2,4(r2)
8113cfbc:	18bff736 	bltu	r3,r2,8113cf9c <__reset+0xfb11cf9c>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
8113cfc0:	e0bffc17 	ldw	r2,-16(fp)
8113cfc4:	10c00d17 	ldw	r3,52(r2)
8113cfc8:	e0bff317 	ldw	r2,-52(fp)
8113cfcc:	18800726 	beq	r3,r2,8113cfec <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
8113cfd0:	e0bffe17 	ldw	r2,-8(fp)
8113cfd4:	00bf9d16 	blt	zero,r2,8113ce4c <__reset+0xfb11ce4c>
8113cfd8:	00000506 	br	8113cff0 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
8113cfdc:	0001883a 	nop
8113cfe0:	00000306 	br	8113cff0 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
8113cfe4:	0001883a 	nop
8113cfe8:	00000106 	br	8113cff0 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
8113cfec:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
8113cff0:	e0bffc17 	ldw	r2,-16(fp)
8113cff4:	10800a17 	ldw	r2,40(r2)
8113cff8:	1009883a 	mov	r4,r2
8113cffc:	11350800 	call	81135080 <OSSemPost>

  if (ptr != buffer)
8113d000:	e0fff017 	ldw	r3,-64(fp)
8113d004:	e0bffd17 	ldw	r2,-12(fp)
8113d008:	18801826 	beq	r3,r2,8113d06c <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d00c:	0005303a 	rdctl	r2,status
8113d010:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d014:	e0fff717 	ldw	r3,-36(fp)
8113d018:	00bfff84 	movi	r2,-2
8113d01c:	1884703a 	and	r2,r3,r2
8113d020:	1001703a 	wrctl	status,r2
  
  return context;
8113d024:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
8113d028:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113d02c:	e0bffc17 	ldw	r2,-16(fp)
8113d030:	10800817 	ldw	r2,32(r2)
8113d034:	10c00054 	ori	r3,r2,1
8113d038:	e0bffc17 	ldw	r2,-16(fp)
8113d03c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8113d040:	e0bffc17 	ldw	r2,-16(fp)
8113d044:	10800017 	ldw	r2,0(r2)
8113d048:	10800104 	addi	r2,r2,4
8113d04c:	1007883a 	mov	r3,r2
8113d050:	e0bffc17 	ldw	r2,-16(fp)
8113d054:	10800817 	ldw	r2,32(r2)
8113d058:	18800035 	stwio	r2,0(r3)
8113d05c:	e0bff617 	ldw	r2,-40(fp)
8113d060:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d064:	e0bff517 	ldw	r2,-44(fp)
8113d068:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
8113d06c:	e0fff017 	ldw	r3,-64(fp)
8113d070:	e0bffd17 	ldw	r2,-12(fp)
8113d074:	18800426 	beq	r3,r2,8113d088 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
8113d078:	e0fff017 	ldw	r3,-64(fp)
8113d07c:	e0bffd17 	ldw	r2,-12(fp)
8113d080:	1885c83a 	sub	r2,r3,r2
8113d084:	00000606 	br	8113d0a0 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
8113d088:	e0bfff17 	ldw	r2,-4(fp)
8113d08c:	1090000c 	andi	r2,r2,16384
8113d090:	10000226 	beq	r2,zero,8113d09c <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
8113d094:	00bffd44 	movi	r2,-11
8113d098:	00000106 	br	8113d0a0 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
8113d09c:	00bffec4 	movi	r2,-5
}
8113d0a0:	e037883a 	mov	sp,fp
8113d0a4:	dfc00117 	ldw	ra,4(sp)
8113d0a8:	df000017 	ldw	fp,0(sp)
8113d0ac:	dec00204 	addi	sp,sp,8
8113d0b0:	f800283a 	ret

8113d0b4 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
8113d0b4:	deffed04 	addi	sp,sp,-76
8113d0b8:	de00012e 	bgeu	sp,et,8113d0c0 <altera_avalon_jtag_uart_write+0xc>
8113d0bc:	003b68fa 	trap	3
8113d0c0:	dfc01215 	stw	ra,72(sp)
8113d0c4:	df001115 	stw	fp,68(sp)
8113d0c8:	df001104 	addi	fp,sp,68
8113d0cc:	e13ffc15 	stw	r4,-16(fp)
8113d0d0:	e17ffd15 	stw	r5,-12(fp)
8113d0d4:	e1bffe15 	stw	r6,-8(fp)
8113d0d8:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
8113d0dc:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
8113d0e0:	e0bffd17 	ldw	r2,-12(fp)
8113d0e4:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
8113d0e8:	e0bffc17 	ldw	r2,-16(fp)
8113d0ec:	10800b17 	ldw	r2,44(r2)
8113d0f0:	e0bff815 	stw	r2,-32(fp)
8113d0f4:	e03ff90d 	sth	zero,-28(fp)
8113d0f8:	e0bff90b 	ldhu	r2,-28(fp)
8113d0fc:	e0fffb44 	addi	r3,fp,-19
8113d100:	180d883a 	mov	r6,r3
8113d104:	100b883a 	mov	r5,r2
8113d108:	e13ff817 	ldw	r4,-32(fp)
8113d10c:	1134cf80 	call	81134cf8 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
8113d110:	00003706 	br	8113d1f0 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
8113d114:	e0bffc17 	ldw	r2,-16(fp)
8113d118:	10800f17 	ldw	r2,60(r2)
8113d11c:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
8113d120:	e0bffc17 	ldw	r2,-16(fp)
8113d124:	10801017 	ldw	r2,64(r2)
8113d128:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
8113d12c:	e0fff417 	ldw	r3,-48(fp)
8113d130:	e0bff017 	ldw	r2,-64(fp)
8113d134:	1880062e 	bgeu	r3,r2,8113d150 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
8113d138:	e0fff017 	ldw	r3,-64(fp)
8113d13c:	e0bff417 	ldw	r2,-48(fp)
8113d140:	1885c83a 	sub	r2,r3,r2
8113d144:	10bfffc4 	addi	r2,r2,-1
8113d148:	e0bff115 	stw	r2,-60(fp)
8113d14c:	00000b06 	br	8113d17c <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
8113d150:	e0bff017 	ldw	r2,-64(fp)
8113d154:	10000526 	beq	r2,zero,8113d16c <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
8113d158:	00c20004 	movi	r3,2048
8113d15c:	e0bff417 	ldw	r2,-48(fp)
8113d160:	1885c83a 	sub	r2,r3,r2
8113d164:	e0bff115 	stw	r2,-60(fp)
8113d168:	00000406 	br	8113d17c <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
8113d16c:	00c1ffc4 	movi	r3,2047
8113d170:	e0bff417 	ldw	r2,-48(fp)
8113d174:	1885c83a 	sub	r2,r3,r2
8113d178:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8113d17c:	e0bff117 	ldw	r2,-60(fp)
8113d180:	10001e26 	beq	r2,zero,8113d1fc <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
8113d184:	e0fffe17 	ldw	r3,-8(fp)
8113d188:	e0bff117 	ldw	r2,-60(fp)
8113d18c:	1880022e 	bgeu	r3,r2,8113d198 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
8113d190:	e0bffe17 	ldw	r2,-8(fp)
8113d194:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
8113d198:	e0bffc17 	ldw	r2,-16(fp)
8113d19c:	10c21104 	addi	r3,r2,2116
8113d1a0:	e0bff417 	ldw	r2,-48(fp)
8113d1a4:	1885883a 	add	r2,r3,r2
8113d1a8:	e1bff117 	ldw	r6,-60(fp)
8113d1ac:	e17ffd17 	ldw	r5,-12(fp)
8113d1b0:	1009883a 	mov	r4,r2
8113d1b4:	1117ccc0 	call	81117ccc <memcpy>
      ptr   += n;
8113d1b8:	e0fffd17 	ldw	r3,-12(fp)
8113d1bc:	e0bff117 	ldw	r2,-60(fp)
8113d1c0:	1885883a 	add	r2,r3,r2
8113d1c4:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
8113d1c8:	e0fffe17 	ldw	r3,-8(fp)
8113d1cc:	e0bff117 	ldw	r2,-60(fp)
8113d1d0:	1885c83a 	sub	r2,r3,r2
8113d1d4:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113d1d8:	e0fff417 	ldw	r3,-48(fp)
8113d1dc:	e0bff117 	ldw	r2,-60(fp)
8113d1e0:	1885883a 	add	r2,r3,r2
8113d1e4:	10c1ffcc 	andi	r3,r2,2047
8113d1e8:	e0bffc17 	ldw	r2,-16(fp)
8113d1ec:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
8113d1f0:	e0bffe17 	ldw	r2,-8(fp)
8113d1f4:	00bfc716 	blt	zero,r2,8113d114 <__reset+0xfb11d114>
8113d1f8:	00000106 	br	8113d200 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
8113d1fc:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d200:	0005303a 	rdctl	r2,status
8113d204:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d208:	e0fff717 	ldw	r3,-36(fp)
8113d20c:	00bfff84 	movi	r2,-2
8113d210:	1884703a 	and	r2,r3,r2
8113d214:	1001703a 	wrctl	status,r2
  
  return context;
8113d218:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
8113d21c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
8113d220:	e0bffc17 	ldw	r2,-16(fp)
8113d224:	10800817 	ldw	r2,32(r2)
8113d228:	10c00094 	ori	r3,r2,2
8113d22c:	e0bffc17 	ldw	r2,-16(fp)
8113d230:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8113d234:	e0bffc17 	ldw	r2,-16(fp)
8113d238:	10800017 	ldw	r2,0(r2)
8113d23c:	10800104 	addi	r2,r2,4
8113d240:	1007883a 	mov	r3,r2
8113d244:	e0bffc17 	ldw	r2,-16(fp)
8113d248:	10800817 	ldw	r2,32(r2)
8113d24c:	18800035 	stwio	r2,0(r3)
8113d250:	e0bff617 	ldw	r2,-40(fp)
8113d254:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d258:	e0bff317 	ldw	r2,-52(fp)
8113d25c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
8113d260:	e0bffe17 	ldw	r2,-8(fp)
8113d264:	00802a0e 	bge	zero,r2,8113d310 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
8113d268:	e0bfff17 	ldw	r2,-4(fp)
8113d26c:	1090000c 	andi	r2,r2,16384
8113d270:	10002a1e 	bne	r2,zero,8113d31c <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
8113d274:	d0a08203 	ldbu	r2,-32248(gp)
8113d278:	10803fcc 	andi	r2,r2,255
8113d27c:	10800058 	cmpnei	r2,r2,1
8113d280:	1000161e 	bne	r2,zero,8113d2dc <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
8113d284:	e0bffc17 	ldw	r2,-16(fp)
8113d288:	10800c17 	ldw	r2,48(r2)
8113d28c:	e0bff515 	stw	r2,-44(fp)
8113d290:	00800184 	movi	r2,6
8113d294:	e0bff98d 	sth	r2,-26(fp)
8113d298:	00bfe0c4 	movi	r2,-125
8113d29c:	e0bffa05 	stb	r2,-24(fp)
8113d2a0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113d2a4:	d0a08203 	ldbu	r2,-32248(gp)
8113d2a8:	10803fcc 	andi	r2,r2,255
8113d2ac:	10001526 	beq	r2,zero,8113d304 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113d2b0:	e0fff98b 	ldhu	r3,-26(fp)
8113d2b4:	e13ffa03 	ldbu	r4,-24(fp)
8113d2b8:	e17ffa8b 	ldhu	r5,-22(fp)
8113d2bc:	e0bffb04 	addi	r2,fp,-20
8113d2c0:	d8800015 	stw	r2,0(sp)
8113d2c4:	280f883a 	mov	r7,r5
8113d2c8:	200d883a 	mov	r6,r4
8113d2cc:	180b883a 	mov	r5,r3
8113d2d0:	e13ff517 	ldw	r4,-44(fp)
8113d2d4:	11310580 	call	81131058 <OSFlagPend>
8113d2d8:	00000a06 	br	8113d304 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
8113d2dc:	0001883a 	nop
8113d2e0:	e0bffc17 	ldw	r2,-16(fp)
8113d2e4:	10c01017 	ldw	r3,64(r2)
8113d2e8:	e0bff017 	ldw	r2,-64(fp)
8113d2ec:	1880051e 	bne	r3,r2,8113d304 <altera_avalon_jtag_uart_write+0x250>
8113d2f0:	e0bffc17 	ldw	r2,-16(fp)
8113d2f4:	10c00917 	ldw	r3,36(r2)
8113d2f8:	e0bffc17 	ldw	r2,-16(fp)
8113d2fc:	10800117 	ldw	r2,4(r2)
8113d300:	18bff736 	bltu	r3,r2,8113d2e0 <__reset+0xfb11d2e0>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
8113d304:	e0bffc17 	ldw	r2,-16(fp)
8113d308:	10800917 	ldw	r2,36(r2)
8113d30c:	1000051e 	bne	r2,zero,8113d324 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
8113d310:	e0bffe17 	ldw	r2,-8(fp)
8113d314:	00bfb616 	blt	zero,r2,8113d1f0 <__reset+0xfb11d1f0>
8113d318:	00000306 	br	8113d328 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
8113d31c:	0001883a 	nop
8113d320:	00000106 	br	8113d328 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
8113d324:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
8113d328:	e0bffc17 	ldw	r2,-16(fp)
8113d32c:	10800b17 	ldw	r2,44(r2)
8113d330:	1009883a 	mov	r4,r2
8113d334:	11350800 	call	81135080 <OSSemPost>

  if (ptr != start)
8113d338:	e0fffd17 	ldw	r3,-12(fp)
8113d33c:	e0bff217 	ldw	r2,-56(fp)
8113d340:	18800426 	beq	r3,r2,8113d354 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
8113d344:	e0fffd17 	ldw	r3,-12(fp)
8113d348:	e0bff217 	ldw	r2,-56(fp)
8113d34c:	1885c83a 	sub	r2,r3,r2
8113d350:	00000606 	br	8113d36c <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
8113d354:	e0bfff17 	ldw	r2,-4(fp)
8113d358:	1090000c 	andi	r2,r2,16384
8113d35c:	10000226 	beq	r2,zero,8113d368 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
8113d360:	00bffd44 	movi	r2,-11
8113d364:	00000106 	br	8113d36c <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
8113d368:	00bffec4 	movi	r2,-5
}
8113d36c:	e037883a 	mov	sp,fp
8113d370:	dfc00117 	ldw	ra,4(sp)
8113d374:	df000017 	ldw	fp,0(sp)
8113d378:	dec00204 	addi	sp,sp,8
8113d37c:	f800283a 	ret

8113d380 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
8113d380:	defffa04 	addi	sp,sp,-24
8113d384:	de00012e 	bgeu	sp,et,8113d38c <alt_avalon_timer_sc_irq+0xc>
8113d388:	003b68fa 	trap	3
8113d38c:	dfc00515 	stw	ra,20(sp)
8113d390:	df000415 	stw	fp,16(sp)
8113d394:	df000404 	addi	fp,sp,16
8113d398:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
8113d39c:	0007883a 	mov	r3,zero
8113d3a0:	e0bfff17 	ldw	r2,-4(fp)
8113d3a4:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
8113d3a8:	e0bfff17 	ldw	r2,-4(fp)
8113d3ac:	10800104 	addi	r2,r2,4
8113d3b0:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
8113d3b4:	112d5340 	call	8112d534 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d3b8:	0005303a 	rdctl	r2,status
8113d3bc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d3c0:	e0fffd17 	ldw	r3,-12(fp)
8113d3c4:	00bfff84 	movi	r2,-2
8113d3c8:	1884703a 	and	r2,r3,r2
8113d3cc:	1001703a 	wrctl	status,r2
  
  return context;
8113d3d0:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
8113d3d4:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
8113d3d8:	112dde40 	call	8112dde4 <alt_tick>
8113d3dc:	e0bffc17 	ldw	r2,-16(fp)
8113d3e0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d3e4:	e0bffe17 	ldw	r2,-8(fp)
8113d3e8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
8113d3ec:	0001883a 	nop
8113d3f0:	e037883a 	mov	sp,fp
8113d3f4:	dfc00117 	ldw	ra,4(sp)
8113d3f8:	df000017 	ldw	fp,0(sp)
8113d3fc:	dec00204 	addi	sp,sp,8
8113d400:	f800283a 	ret

8113d404 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
8113d404:	defff804 	addi	sp,sp,-32
8113d408:	de00012e 	bgeu	sp,et,8113d410 <alt_avalon_timer_sc_init+0xc>
8113d40c:	003b68fa 	trap	3
8113d410:	dfc00715 	stw	ra,28(sp)
8113d414:	df000615 	stw	fp,24(sp)
8113d418:	df000604 	addi	fp,sp,24
8113d41c:	e13ffc15 	stw	r4,-16(fp)
8113d420:	e17ffd15 	stw	r5,-12(fp)
8113d424:	e1bffe15 	stw	r6,-8(fp)
8113d428:	e1ffff15 	stw	r7,-4(fp)
8113d42c:	e0bfff17 	ldw	r2,-4(fp)
8113d430:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
8113d434:	d0a07917 	ldw	r2,-32284(gp)
8113d438:	1000021e 	bne	r2,zero,8113d444 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
8113d43c:	e0bffb17 	ldw	r2,-20(fp)
8113d440:	d0a07915 	stw	r2,-32284(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
8113d444:	e0bffc17 	ldw	r2,-16(fp)
8113d448:	10800104 	addi	r2,r2,4
8113d44c:	00c001c4 	movi	r3,7
8113d450:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
8113d454:	d8000015 	stw	zero,0(sp)
8113d458:	e1fffc17 	ldw	r7,-16(fp)
8113d45c:	01a04534 	movhi	r6,33044
8113d460:	31b4e004 	addi	r6,r6,-11392
8113d464:	e17ffe17 	ldw	r5,-8(fp)
8113d468:	e13ffd17 	ldw	r4,-12(fp)
8113d46c:	11406080 	call	81140608 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
8113d470:	0001883a 	nop
8113d474:	e037883a 	mov	sp,fp
8113d478:	dfc00117 	ldw	ra,4(sp)
8113d47c:	df000017 	ldw	fp,0(sp)
8113d480:	dec00204 	addi	sp,sp,8
8113d484:	f800283a 	ret

8113d488 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8113d488:	defffa04 	addi	sp,sp,-24
8113d48c:	de00012e 	bgeu	sp,et,8113d494 <altera_avalon_uart_read_fd+0xc>
8113d490:	003b68fa 	trap	3
8113d494:	dfc00515 	stw	ra,20(sp)
8113d498:	df000415 	stw	fp,16(sp)
8113d49c:	df000404 	addi	fp,sp,16
8113d4a0:	e13ffd15 	stw	r4,-12(fp)
8113d4a4:	e17ffe15 	stw	r5,-8(fp)
8113d4a8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113d4ac:	e0bffd17 	ldw	r2,-12(fp)
8113d4b0:	10800017 	ldw	r2,0(r2)
8113d4b4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
8113d4b8:	e0bffc17 	ldw	r2,-16(fp)
8113d4bc:	10c00a04 	addi	r3,r2,40
8113d4c0:	e0bffd17 	ldw	r2,-12(fp)
8113d4c4:	10800217 	ldw	r2,8(r2)
8113d4c8:	100f883a 	mov	r7,r2
8113d4cc:	e1bfff17 	ldw	r6,-4(fp)
8113d4d0:	e17ffe17 	ldw	r5,-8(fp)
8113d4d4:	1809883a 	mov	r4,r3
8113d4d8:	113db480 	call	8113db48 <altera_avalon_uart_read>
      fd->fd_flags);
}
8113d4dc:	e037883a 	mov	sp,fp
8113d4e0:	dfc00117 	ldw	ra,4(sp)
8113d4e4:	df000017 	ldw	fp,0(sp)
8113d4e8:	dec00204 	addi	sp,sp,8
8113d4ec:	f800283a 	ret

8113d4f0 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8113d4f0:	defffa04 	addi	sp,sp,-24
8113d4f4:	de00012e 	bgeu	sp,et,8113d4fc <altera_avalon_uart_write_fd+0xc>
8113d4f8:	003b68fa 	trap	3
8113d4fc:	dfc00515 	stw	ra,20(sp)
8113d500:	df000415 	stw	fp,16(sp)
8113d504:	df000404 	addi	fp,sp,16
8113d508:	e13ffd15 	stw	r4,-12(fp)
8113d50c:	e17ffe15 	stw	r5,-8(fp)
8113d510:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113d514:	e0bffd17 	ldw	r2,-12(fp)
8113d518:	10800017 	ldw	r2,0(r2)
8113d51c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
8113d520:	e0bffc17 	ldw	r2,-16(fp)
8113d524:	10c00a04 	addi	r3,r2,40
8113d528:	e0bffd17 	ldw	r2,-12(fp)
8113d52c:	10800217 	ldw	r2,8(r2)
8113d530:	100f883a 	mov	r7,r2
8113d534:	e1bfff17 	ldw	r6,-4(fp)
8113d538:	e17ffe17 	ldw	r5,-8(fp)
8113d53c:	1809883a 	mov	r4,r3
8113d540:	113ddfc0 	call	8113ddfc <altera_avalon_uart_write>
      fd->fd_flags);
}
8113d544:	e037883a 	mov	sp,fp
8113d548:	dfc00117 	ldw	ra,4(sp)
8113d54c:	df000017 	ldw	fp,0(sp)
8113d550:	dec00204 	addi	sp,sp,8
8113d554:	f800283a 	ret

8113d558 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
8113d558:	defffc04 	addi	sp,sp,-16
8113d55c:	de00012e 	bgeu	sp,et,8113d564 <altera_avalon_uart_close_fd+0xc>
8113d560:	003b68fa 	trap	3
8113d564:	dfc00315 	stw	ra,12(sp)
8113d568:	df000215 	stw	fp,8(sp)
8113d56c:	df000204 	addi	fp,sp,8
8113d570:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113d574:	e0bfff17 	ldw	r2,-4(fp)
8113d578:	10800017 	ldw	r2,0(r2)
8113d57c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
8113d580:	e0bffe17 	ldw	r2,-8(fp)
8113d584:	10c00a04 	addi	r3,r2,40
8113d588:	e0bfff17 	ldw	r2,-4(fp)
8113d58c:	10800217 	ldw	r2,8(r2)
8113d590:	100b883a 	mov	r5,r2
8113d594:	1809883a 	mov	r4,r3
8113d598:	113daa80 	call	8113daa8 <altera_avalon_uart_close>
}
8113d59c:	e037883a 	mov	sp,fp
8113d5a0:	dfc00117 	ldw	ra,4(sp)
8113d5a4:	df000017 	ldw	fp,0(sp)
8113d5a8:	dec00204 	addi	sp,sp,8
8113d5ac:	f800283a 	ret

8113d5b0 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
8113d5b0:	defff304 	addi	sp,sp,-52
8113d5b4:	de00012e 	bgeu	sp,et,8113d5bc <altera_avalon_uart_init+0xc>
8113d5b8:	003b68fa 	trap	3
8113d5bc:	dfc00c15 	stw	ra,48(sp)
8113d5c0:	df000b15 	stw	fp,44(sp)
8113d5c4:	df000b04 	addi	fp,sp,44
8113d5c8:	e13ffd15 	stw	r4,-12(fp)
8113d5cc:	e17ffe15 	stw	r5,-8(fp)
8113d5d0:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
8113d5d4:	e0bffd17 	ldw	r2,-12(fp)
8113d5d8:	10800017 	ldw	r2,0(r2)
8113d5dc:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8113d5e0:	e0bffd17 	ldw	r2,-12(fp)
8113d5e4:	10800704 	addi	r2,r2,28
8113d5e8:	e0bffa15 	stw	r2,-24(fp)
8113d5ec:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
8113d5f0:	e0bffb0b 	ldhu	r2,-20(fp)
8113d5f4:	e0fffc84 	addi	r3,fp,-14
8113d5f8:	180b883a 	mov	r5,r3
8113d5fc:	1009883a 	mov	r4,r2
8113d600:	1130a740 	call	81130a74 <OSFlagCreate>
8113d604:	1007883a 	mov	r3,r2
8113d608:	e0bffa17 	ldw	r2,-24(fp)
8113d60c:	10c00015 	stw	r3,0(r2)
  return err;
8113d610:	e0bffc83 	ldbu	r2,-14(fp)
8113d614:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
8113d618:	1000241e 	bne	r2,zero,8113d6ac <altera_avalon_uart_init+0xfc>
8113d61c:	e0bffd17 	ldw	r2,-12(fp)
8113d620:	10800804 	addi	r2,r2,32
8113d624:	e0bff715 	stw	r2,-36(fp)
8113d628:	00800044 	movi	r2,1
8113d62c:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8113d630:	e0bffb8b 	ldhu	r2,-18(fp)
8113d634:	1009883a 	mov	r4,r2
8113d638:	11349d00 	call	811349d0 <OSSemCreate>
8113d63c:	1007883a 	mov	r3,r2
8113d640:	e0bff717 	ldw	r2,-36(fp)
8113d644:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8113d648:	e0bff717 	ldw	r2,-36(fp)
8113d64c:	10800017 	ldw	r2,0(r2)
8113d650:	10000226 	beq	r2,zero,8113d65c <altera_avalon_uart_init+0xac>
8113d654:	0005883a 	mov	r2,zero
8113d658:	00000106 	br	8113d660 <altera_avalon_uart_init+0xb0>
8113d65c:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8113d660:	1000121e 	bne	r2,zero,8113d6ac <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
8113d664:	e0bffd17 	ldw	r2,-12(fp)
8113d668:	10800904 	addi	r2,r2,36
8113d66c:	e0bff815 	stw	r2,-32(fp)
8113d670:	00800044 	movi	r2,1
8113d674:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8113d678:	e0bffc0b 	ldhu	r2,-16(fp)
8113d67c:	1009883a 	mov	r4,r2
8113d680:	11349d00 	call	811349d0 <OSSemCreate>
8113d684:	1007883a 	mov	r3,r2
8113d688:	e0bff817 	ldw	r2,-32(fp)
8113d68c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8113d690:	e0bff817 	ldw	r2,-32(fp)
8113d694:	10800017 	ldw	r2,0(r2)
8113d698:	10000226 	beq	r2,zero,8113d6a4 <altera_avalon_uart_init+0xf4>
8113d69c:	0005883a 	mov	r2,zero
8113d6a0:	00000106 	br	8113d6a8 <altera_avalon_uart_init+0xf8>
8113d6a4:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
8113d6a8:	10000226 	beq	r2,zero,8113d6b4 <altera_avalon_uart_init+0x104>
8113d6ac:	00800044 	movi	r2,1
8113d6b0:	00000106 	br	8113d6b8 <altera_avalon_uart_init+0x108>
8113d6b4:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8113d6b8:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
8113d6bc:	e0bff917 	ldw	r2,-28(fp)
8113d6c0:	10000f1e 	bne	r2,zero,8113d700 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
8113d6c4:	e0bffd17 	ldw	r2,-12(fp)
8113d6c8:	00c32004 	movi	r3,3200
8113d6cc:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
8113d6d0:	e0bff617 	ldw	r2,-40(fp)
8113d6d4:	10800304 	addi	r2,r2,12
8113d6d8:	e0fffd17 	ldw	r3,-12(fp)
8113d6dc:	18c00117 	ldw	r3,4(r3)
8113d6e0:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
8113d6e4:	d8000015 	stw	zero,0(sp)
8113d6e8:	e1fffd17 	ldw	r7,-12(fp)
8113d6ec:	01a04534 	movhi	r6,33044
8113d6f0:	31b5c604 	addi	r6,r6,-10472
8113d6f4:	e17fff17 	ldw	r5,-4(fp)
8113d6f8:	e13ffe17 	ldw	r4,-8(fp)
8113d6fc:	11406080 	call	81140608 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
8113d700:	0001883a 	nop
8113d704:	e037883a 	mov	sp,fp
8113d708:	dfc00117 	ldw	ra,4(sp)
8113d70c:	df000017 	ldw	fp,0(sp)
8113d710:	dec00204 	addi	sp,sp,8
8113d714:	f800283a 	ret

8113d718 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
8113d718:	defffa04 	addi	sp,sp,-24
8113d71c:	de00012e 	bgeu	sp,et,8113d724 <altera_avalon_uart_irq+0xc>
8113d720:	003b68fa 	trap	3
8113d724:	dfc00515 	stw	ra,20(sp)
8113d728:	df000415 	stw	fp,16(sp)
8113d72c:	df000404 	addi	fp,sp,16
8113d730:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
8113d734:	e0bfff17 	ldw	r2,-4(fp)
8113d738:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
8113d73c:	e0bffc17 	ldw	r2,-16(fp)
8113d740:	10800017 	ldw	r2,0(r2)
8113d744:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
8113d748:	e0bffd17 	ldw	r2,-12(fp)
8113d74c:	10800204 	addi	r2,r2,8
8113d750:	10800037 	ldwio	r2,0(r2)
8113d754:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
8113d758:	e0bffd17 	ldw	r2,-12(fp)
8113d75c:	10800204 	addi	r2,r2,8
8113d760:	0007883a 	mov	r3,zero
8113d764:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
8113d768:	e0bffd17 	ldw	r2,-12(fp)
8113d76c:	10800204 	addi	r2,r2,8
8113d770:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
8113d774:	e0bffe17 	ldw	r2,-8(fp)
8113d778:	1080200c 	andi	r2,r2,128
8113d77c:	10000326 	beq	r2,zero,8113d78c <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
8113d780:	e17ffe17 	ldw	r5,-8(fp)
8113d784:	e13ffc17 	ldw	r4,-16(fp)
8113d788:	113d7bc0 	call	8113d7bc <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
8113d78c:	e0bffe17 	ldw	r2,-8(fp)
8113d790:	1081100c 	andi	r2,r2,1088
8113d794:	10000326 	beq	r2,zero,8113d7a4 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
8113d798:	e17ffe17 	ldw	r5,-8(fp)
8113d79c:	e13ffc17 	ldw	r4,-16(fp)
8113d7a0:	113d8fc0 	call	8113d8fc <altera_avalon_uart_txirq>
  }
  

}
8113d7a4:	0001883a 	nop
8113d7a8:	e037883a 	mov	sp,fp
8113d7ac:	dfc00117 	ldw	ra,4(sp)
8113d7b0:	df000017 	ldw	fp,0(sp)
8113d7b4:	dec00204 	addi	sp,sp,8
8113d7b8:	f800283a 	ret

8113d7bc <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8113d7bc:	defff904 	addi	sp,sp,-28
8113d7c0:	de00012e 	bgeu	sp,et,8113d7c8 <altera_avalon_uart_rxirq+0xc>
8113d7c4:	003b68fa 	trap	3
8113d7c8:	dfc00615 	stw	ra,24(sp)
8113d7cc:	df000515 	stw	fp,20(sp)
8113d7d0:	df000504 	addi	fp,sp,20
8113d7d4:	e13ffe15 	stw	r4,-8(fp)
8113d7d8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
8113d7dc:	e0bfff17 	ldw	r2,-4(fp)
8113d7e0:	108000cc 	andi	r2,r2,3
8113d7e4:	10003f1e 	bne	r2,zero,8113d8e4 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
8113d7e8:	e0bffe17 	ldw	r2,-8(fp)
8113d7ec:	10c00317 	ldw	r3,12(r2)
8113d7f0:	e0bffe17 	ldw	r2,-8(fp)
8113d7f4:	10800217 	ldw	r2,8(r2)
8113d7f8:	1880121e 	bne	r3,r2,8113d844 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
8113d7fc:	e0bffe17 	ldw	r2,-8(fp)
8113d800:	10800717 	ldw	r2,28(r2)
8113d804:	e0bffc15 	stw	r2,-16(fp)
8113d808:	00800044 	movi	r2,1
8113d80c:	e0bffd0d 	sth	r2,-12(fp)
8113d810:	00800044 	movi	r2,1
8113d814:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113d818:	d0a08203 	ldbu	r2,-32248(gp)
8113d81c:	10803fcc 	andi	r2,r2,255
8113d820:	10000826 	beq	r2,zero,8113d844 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
8113d824:	e0bffd0b 	ldhu	r2,-12(fp)
8113d828:	e0fffd83 	ldbu	r3,-10(fp)
8113d82c:	e13ffdc4 	addi	r4,fp,-9
8113d830:	200f883a 	mov	r7,r4
8113d834:	180d883a 	mov	r6,r3
8113d838:	100b883a 	mov	r5,r2
8113d83c:	e13ffc17 	ldw	r4,-16(fp)
8113d840:	11316800 	call	81131680 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8113d844:	e0bffe17 	ldw	r2,-8(fp)
8113d848:	10800317 	ldw	r2,12(r2)
8113d84c:	10800044 	addi	r2,r2,1
8113d850:	10800fcc 	andi	r2,r2,63
8113d854:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
8113d858:	e0bffe17 	ldw	r2,-8(fp)
8113d85c:	10800317 	ldw	r2,12(r2)
8113d860:	e0fffe17 	ldw	r3,-8(fp)
8113d864:	18c00017 	ldw	r3,0(r3)
8113d868:	18c00037 	ldwio	r3,0(r3)
8113d86c:	1809883a 	mov	r4,r3
8113d870:	e0fffe17 	ldw	r3,-8(fp)
8113d874:	1885883a 	add	r2,r3,r2
8113d878:	10800a04 	addi	r2,r2,40
8113d87c:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
8113d880:	e0bffe17 	ldw	r2,-8(fp)
8113d884:	e0fffb17 	ldw	r3,-20(fp)
8113d888:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8113d88c:	e0bffe17 	ldw	r2,-8(fp)
8113d890:	10800317 	ldw	r2,12(r2)
8113d894:	10800044 	addi	r2,r2,1
8113d898:	10800fcc 	andi	r2,r2,63
8113d89c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
8113d8a0:	e0bffe17 	ldw	r2,-8(fp)
8113d8a4:	10c00217 	ldw	r3,8(r2)
8113d8a8:	e0bffb17 	ldw	r2,-20(fp)
8113d8ac:	18800e1e 	bne	r3,r2,8113d8e8 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8113d8b0:	e0bffe17 	ldw	r2,-8(fp)
8113d8b4:	10c00117 	ldw	r3,4(r2)
8113d8b8:	00bfdfc4 	movi	r2,-129
8113d8bc:	1886703a 	and	r3,r3,r2
8113d8c0:	e0bffe17 	ldw	r2,-8(fp)
8113d8c4:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
8113d8c8:	e0bffe17 	ldw	r2,-8(fp)
8113d8cc:	10800017 	ldw	r2,0(r2)
8113d8d0:	10800304 	addi	r2,r2,12
8113d8d4:	e0fffe17 	ldw	r3,-8(fp)
8113d8d8:	18c00117 	ldw	r3,4(r3)
8113d8dc:	10c00035 	stwio	r3,0(r2)
8113d8e0:	00000106 	br	8113d8e8 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
8113d8e4:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
8113d8e8:	e037883a 	mov	sp,fp
8113d8ec:	dfc00117 	ldw	ra,4(sp)
8113d8f0:	df000017 	ldw	fp,0(sp)
8113d8f4:	dec00204 	addi	sp,sp,8
8113d8f8:	f800283a 	ret

8113d8fc <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8113d8fc:	defffa04 	addi	sp,sp,-24
8113d900:	de00012e 	bgeu	sp,et,8113d908 <altera_avalon_uart_txirq+0xc>
8113d904:	003b68fa 	trap	3
8113d908:	dfc00515 	stw	ra,20(sp)
8113d90c:	df000415 	stw	fp,16(sp)
8113d910:	df000404 	addi	fp,sp,16
8113d914:	e13ffe15 	stw	r4,-8(fp)
8113d918:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
8113d91c:	e0bffe17 	ldw	r2,-8(fp)
8113d920:	10c00417 	ldw	r3,16(r2)
8113d924:	e0bffe17 	ldw	r2,-8(fp)
8113d928:	10800517 	ldw	r2,20(r2)
8113d92c:	18804726 	beq	r3,r2,8113da4c <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
8113d930:	e0bffe17 	ldw	r2,-8(fp)
8113d934:	10800617 	ldw	r2,24(r2)
8113d938:	1080008c 	andi	r2,r2,2
8113d93c:	10000326 	beq	r2,zero,8113d94c <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
8113d940:	e0bfff17 	ldw	r2,-4(fp)
8113d944:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
8113d948:	10003226 	beq	r2,zero,8113da14 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
8113d94c:	e0bffe17 	ldw	r2,-8(fp)
8113d950:	10c00417 	ldw	r3,16(r2)
8113d954:	e0bffe17 	ldw	r2,-8(fp)
8113d958:	10800517 	ldw	r2,20(r2)
8113d95c:	10800044 	addi	r2,r2,1
8113d960:	10800fcc 	andi	r2,r2,63
8113d964:	1880121e 	bne	r3,r2,8113d9b0 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
8113d968:	e0bffe17 	ldw	r2,-8(fp)
8113d96c:	10800717 	ldw	r2,28(r2)
8113d970:	e0bffc15 	stw	r2,-16(fp)
8113d974:	00800084 	movi	r2,2
8113d978:	e0bffd0d 	sth	r2,-12(fp)
8113d97c:	00800044 	movi	r2,1
8113d980:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113d984:	d0a08203 	ldbu	r2,-32248(gp)
8113d988:	10803fcc 	andi	r2,r2,255
8113d98c:	10000826 	beq	r2,zero,8113d9b0 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
8113d990:	e0bffd0b 	ldhu	r2,-12(fp)
8113d994:	e0fffd83 	ldbu	r3,-10(fp)
8113d998:	e13ffdc4 	addi	r4,fp,-9
8113d99c:	200f883a 	mov	r7,r4
8113d9a0:	180d883a 	mov	r6,r3
8113d9a4:	100b883a 	mov	r5,r2
8113d9a8:	e13ffc17 	ldw	r4,-16(fp)
8113d9ac:	11316800 	call	81131680 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
8113d9b0:	e0bffe17 	ldw	r2,-8(fp)
8113d9b4:	10800017 	ldw	r2,0(r2)
8113d9b8:	10800104 	addi	r2,r2,4
8113d9bc:	e0fffe17 	ldw	r3,-8(fp)
8113d9c0:	18c00417 	ldw	r3,16(r3)
8113d9c4:	e13ffe17 	ldw	r4,-8(fp)
8113d9c8:	20c7883a 	add	r3,r4,r3
8113d9cc:	18c01a04 	addi	r3,r3,104
8113d9d0:	18c00003 	ldbu	r3,0(r3)
8113d9d4:	18c03fcc 	andi	r3,r3,255
8113d9d8:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
8113d9dc:	e0bffe17 	ldw	r2,-8(fp)
8113d9e0:	10800417 	ldw	r2,16(r2)
8113d9e4:	10800044 	addi	r2,r2,1
8113d9e8:	e0fffe17 	ldw	r3,-8(fp)
8113d9ec:	18800415 	stw	r2,16(r3)
8113d9f0:	10c00fcc 	andi	r3,r2,63
8113d9f4:	e0bffe17 	ldw	r2,-8(fp)
8113d9f8:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
8113d9fc:	e0bffe17 	ldw	r2,-8(fp)
8113da00:	10800117 	ldw	r2,4(r2)
8113da04:	10c01014 	ori	r3,r2,64
8113da08:	e0bffe17 	ldw	r2,-8(fp)
8113da0c:	10c00115 	stw	r3,4(r2)
8113da10:	00000e06 	br	8113da4c <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
8113da14:	e0bffe17 	ldw	r2,-8(fp)
8113da18:	10800017 	ldw	r2,0(r2)
8113da1c:	10800204 	addi	r2,r2,8
8113da20:	10800037 	ldwio	r2,0(r2)
8113da24:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
8113da28:	e0bfff17 	ldw	r2,-4(fp)
8113da2c:	1082000c 	andi	r2,r2,2048
8113da30:	1000061e 	bne	r2,zero,8113da4c <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
8113da34:	e0bffe17 	ldw	r2,-8(fp)
8113da38:	10c00117 	ldw	r3,4(r2)
8113da3c:	00bfefc4 	movi	r2,-65
8113da40:	1886703a 	and	r3,r3,r2
8113da44:	e0bffe17 	ldw	r2,-8(fp)
8113da48:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
8113da4c:	e0bffe17 	ldw	r2,-8(fp)
8113da50:	10c00417 	ldw	r3,16(r2)
8113da54:	e0bffe17 	ldw	r2,-8(fp)
8113da58:	10800517 	ldw	r2,20(r2)
8113da5c:	1880061e 	bne	r3,r2,8113da78 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8113da60:	e0bffe17 	ldw	r2,-8(fp)
8113da64:	10c00117 	ldw	r3,4(r2)
8113da68:	00beefc4 	movi	r2,-1089
8113da6c:	1886703a 	and	r3,r3,r2
8113da70:	e0bffe17 	ldw	r2,-8(fp)
8113da74:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113da78:	e0bffe17 	ldw	r2,-8(fp)
8113da7c:	10800017 	ldw	r2,0(r2)
8113da80:	10800304 	addi	r2,r2,12
8113da84:	e0fffe17 	ldw	r3,-8(fp)
8113da88:	18c00117 	ldw	r3,4(r3)
8113da8c:	10c00035 	stwio	r3,0(r2)
}
8113da90:	0001883a 	nop
8113da94:	e037883a 	mov	sp,fp
8113da98:	dfc00117 	ldw	ra,4(sp)
8113da9c:	df000017 	ldw	fp,0(sp)
8113daa0:	dec00204 	addi	sp,sp,8
8113daa4:	f800283a 	ret

8113daa8 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
8113daa8:	defffd04 	addi	sp,sp,-12
8113daac:	de00012e 	bgeu	sp,et,8113dab4 <altera_avalon_uart_close+0xc>
8113dab0:	003b68fa 	trap	3
8113dab4:	df000215 	stw	fp,8(sp)
8113dab8:	df000204 	addi	fp,sp,8
8113dabc:	e13ffe15 	stw	r4,-8(fp)
8113dac0:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
8113dac4:	00000506 	br	8113dadc <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8113dac8:	e0bfff17 	ldw	r2,-4(fp)
8113dacc:	1090000c 	andi	r2,r2,16384
8113dad0:	10000226 	beq	r2,zero,8113dadc <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
8113dad4:	00bffd44 	movi	r2,-11
8113dad8:	00000606 	br	8113daf4 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
8113dadc:	e0bffe17 	ldw	r2,-8(fp)
8113dae0:	10c00417 	ldw	r3,16(r2)
8113dae4:	e0bffe17 	ldw	r2,-8(fp)
8113dae8:	10800517 	ldw	r2,20(r2)
8113daec:	18bff61e 	bne	r3,r2,8113dac8 <__reset+0xfb11dac8>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
8113daf0:	0005883a 	mov	r2,zero
}
8113daf4:	e037883a 	mov	sp,fp
8113daf8:	df000017 	ldw	fp,0(sp)
8113dafc:	dec00104 	addi	sp,sp,4
8113db00:	f800283a 	ret

8113db04 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113db04:	defffe04 	addi	sp,sp,-8
8113db08:	de00012e 	bgeu	sp,et,8113db10 <alt_get_errno+0xc>
8113db0c:	003b68fa 	trap	3
8113db10:	dfc00115 	stw	ra,4(sp)
8113db14:	df000015 	stw	fp,0(sp)
8113db18:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113db1c:	d0a01017 	ldw	r2,-32704(gp)
8113db20:	10000326 	beq	r2,zero,8113db30 <alt_get_errno+0x2c>
8113db24:	d0a01017 	ldw	r2,-32704(gp)
8113db28:	103ee83a 	callr	r2
8113db2c:	00000106 	br	8113db34 <alt_get_errno+0x30>
8113db30:	d0a06904 	addi	r2,gp,-32348
}
8113db34:	e037883a 	mov	sp,fp
8113db38:	dfc00117 	ldw	ra,4(sp)
8113db3c:	df000017 	ldw	fp,0(sp)
8113db40:	dec00204 	addi	sp,sp,8
8113db44:	f800283a 	ret

8113db48 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
8113db48:	deffec04 	addi	sp,sp,-80
8113db4c:	de00012e 	bgeu	sp,et,8113db54 <altera_avalon_uart_read+0xc>
8113db50:	003b68fa 	trap	3
8113db54:	dfc01315 	stw	ra,76(sp)
8113db58:	df001215 	stw	fp,72(sp)
8113db5c:	df001204 	addi	fp,sp,72
8113db60:	e13ffc15 	stw	r4,-16(fp)
8113db64:	e17ffd15 	stw	r5,-12(fp)
8113db68:	e1bffe15 	stw	r6,-8(fp)
8113db6c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
8113db70:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
8113db74:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
8113db78:	e0bfff17 	ldw	r2,-4(fp)
8113db7c:	1090000c 	andi	r2,r2,16384
8113db80:	1005003a 	cmpeq	r2,r2,zero
8113db84:	10803fcc 	andi	r2,r2,255
8113db88:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
8113db8c:	e0bffc17 	ldw	r2,-16(fp)
8113db90:	10800817 	ldw	r2,32(r2)
8113db94:	e0bff815 	stw	r2,-32(fp)
8113db98:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8113db9c:	e0bff90b 	ldhu	r2,-28(fp)
8113dba0:	e0fffb44 	addi	r3,fp,-19
8113dba4:	180d883a 	mov	r6,r3
8113dba8:	100b883a 	mov	r5,r2
8113dbac:	e13ff817 	ldw	r4,-32(fp)
8113dbb0:	1134cf80 	call	81134cf8 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
8113dbb4:	00001306 	br	8113dc04 <altera_avalon_uart_read+0xbc>
    {
      count++;
8113dbb8:	e0bff017 	ldw	r2,-64(fp)
8113dbbc:	10800044 	addi	r2,r2,1
8113dbc0:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
8113dbc4:	e0bffd17 	ldw	r2,-12(fp)
8113dbc8:	10c00044 	addi	r3,r2,1
8113dbcc:	e0fffd15 	stw	r3,-12(fp)
8113dbd0:	e0fffc17 	ldw	r3,-16(fp)
8113dbd4:	18c00217 	ldw	r3,8(r3)
8113dbd8:	e13ffc17 	ldw	r4,-16(fp)
8113dbdc:	20c7883a 	add	r3,r4,r3
8113dbe0:	18c00a04 	addi	r3,r3,40
8113dbe4:	18c00003 	ldbu	r3,0(r3)
8113dbe8:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
8113dbec:	e0bffc17 	ldw	r2,-16(fp)
8113dbf0:	10800217 	ldw	r2,8(r2)
8113dbf4:	10800044 	addi	r2,r2,1
8113dbf8:	10c00fcc 	andi	r3,r2,63
8113dbfc:	e0bffc17 	ldw	r2,-16(fp)
8113dc00:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
8113dc04:	e0fff017 	ldw	r3,-64(fp)
8113dc08:	e0bffe17 	ldw	r2,-8(fp)
8113dc0c:	1880050e 	bge	r3,r2,8113dc24 <altera_avalon_uart_read+0xdc>
8113dc10:	e0bffc17 	ldw	r2,-16(fp)
8113dc14:	10c00217 	ldw	r3,8(r2)
8113dc18:	e0bffc17 	ldw	r2,-16(fp)
8113dc1c:	10800317 	ldw	r2,12(r2)
8113dc20:	18bfe51e 	bne	r3,r2,8113dbb8 <__reset+0xfb11dbb8>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
8113dc24:	e0bff017 	ldw	r2,-64(fp)
8113dc28:	10003a1e 	bne	r2,zero,8113dd14 <altera_avalon_uart_read+0x1cc>
8113dc2c:	e0bffc17 	ldw	r2,-16(fp)
8113dc30:	10c00217 	ldw	r3,8(r2)
8113dc34:	e0bffc17 	ldw	r2,-16(fp)
8113dc38:	10800317 	ldw	r2,12(r2)
8113dc3c:	1880351e 	bne	r3,r2,8113dd14 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
8113dc40:	e0bff117 	ldw	r2,-60(fp)
8113dc44:	1000071e 	bne	r2,zero,8113dc64 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
8113dc48:	113db040 	call	8113db04 <alt_get_errno>
8113dc4c:	1007883a 	mov	r3,r2
8113dc50:	008002c4 	movi	r2,11
8113dc54:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
8113dc58:	00800044 	movi	r2,1
8113dc5c:	e0bfef05 	stb	r2,-68(fp)
        break;
8113dc60:	00003006 	br	8113dd24 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dc64:	0005303a 	rdctl	r2,status
8113dc68:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dc6c:	e0fff517 	ldw	r3,-44(fp)
8113dc70:	00bfff84 	movi	r2,-2
8113dc74:	1884703a 	and	r2,r3,r2
8113dc78:	1001703a 	wrctl	status,r2
  
  return context;
8113dc7c:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
8113dc80:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8113dc84:	e0bffc17 	ldw	r2,-16(fp)
8113dc88:	10800117 	ldw	r2,4(r2)
8113dc8c:	10c02014 	ori	r3,r2,128
8113dc90:	e0bffc17 	ldw	r2,-16(fp)
8113dc94:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113dc98:	e0bffc17 	ldw	r2,-16(fp)
8113dc9c:	10800017 	ldw	r2,0(r2)
8113dca0:	10800304 	addi	r2,r2,12
8113dca4:	e0fffc17 	ldw	r3,-16(fp)
8113dca8:	18c00117 	ldw	r3,4(r3)
8113dcac:	10c00035 	stwio	r3,0(r2)
8113dcb0:	e0bff417 	ldw	r2,-48(fp)
8113dcb4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dcb8:	e0bff617 	ldw	r2,-40(fp)
8113dcbc:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
8113dcc0:	e0bffc17 	ldw	r2,-16(fp)
8113dcc4:	10800717 	ldw	r2,28(r2)
8113dcc8:	e0bff215 	stw	r2,-56(fp)
8113dccc:	00800044 	movi	r2,1
8113dcd0:	e0bff98d 	sth	r2,-26(fp)
8113dcd4:	00bfe0c4 	movi	r2,-125
8113dcd8:	e0bffa05 	stb	r2,-24(fp)
8113dcdc:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113dce0:	d0a08203 	ldbu	r2,-32248(gp)
8113dce4:	10803fcc 	andi	r2,r2,255
8113dce8:	10000a26 	beq	r2,zero,8113dd14 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113dcec:	e0fff98b 	ldhu	r3,-26(fp)
8113dcf0:	e13ffa03 	ldbu	r4,-24(fp)
8113dcf4:	e17ffa8b 	ldhu	r5,-22(fp)
8113dcf8:	e0bffb04 	addi	r2,fp,-20
8113dcfc:	d8800015 	stw	r2,0(sp)
8113dd00:	280f883a 	mov	r7,r5
8113dd04:	200d883a 	mov	r6,r4
8113dd08:	180b883a 	mov	r5,r3
8113dd0c:	e13ff217 	ldw	r4,-56(fp)
8113dd10:	11310580 	call	81131058 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
8113dd14:	e0bff017 	ldw	r2,-64(fp)
8113dd18:	1000021e 	bne	r2,zero,8113dd24 <altera_avalon_uart_read+0x1dc>
8113dd1c:	e0bffe17 	ldw	r2,-8(fp)
8113dd20:	103fb81e 	bne	r2,zero,8113dc04 <__reset+0xfb11dc04>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
8113dd24:	e0bffc17 	ldw	r2,-16(fp)
8113dd28:	10800817 	ldw	r2,32(r2)
8113dd2c:	1009883a 	mov	r4,r2
8113dd30:	11350800 	call	81135080 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dd34:	0005303a 	rdctl	r2,status
8113dd38:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dd3c:	e0fff717 	ldw	r3,-36(fp)
8113dd40:	00bfff84 	movi	r2,-2
8113dd44:	1884703a 	and	r2,r3,r2
8113dd48:	1001703a 	wrctl	status,r2
  
  return context;
8113dd4c:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
8113dd50:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8113dd54:	e0bffc17 	ldw	r2,-16(fp)
8113dd58:	10800117 	ldw	r2,4(r2)
8113dd5c:	10c02014 	ori	r3,r2,128
8113dd60:	e0bffc17 	ldw	r2,-16(fp)
8113dd64:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113dd68:	e0bffc17 	ldw	r2,-16(fp)
8113dd6c:	10800017 	ldw	r2,0(r2)
8113dd70:	10800304 	addi	r2,r2,12
8113dd74:	e0fffc17 	ldw	r3,-16(fp)
8113dd78:	18c00117 	ldw	r3,4(r3)
8113dd7c:	10c00035 	stwio	r3,0(r2)
8113dd80:	e0bff417 	ldw	r2,-48(fp)
8113dd84:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dd88:	e0bff317 	ldw	r2,-52(fp)
8113dd8c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
8113dd90:	e0bfef03 	ldbu	r2,-68(fp)
8113dd94:	10000226 	beq	r2,zero,8113dda0 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
8113dd98:	00bffd44 	movi	r2,-11
8113dd9c:	00000106 	br	8113dda4 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
8113dda0:	e0bff017 	ldw	r2,-64(fp)
  }
}
8113dda4:	e037883a 	mov	sp,fp
8113dda8:	dfc00117 	ldw	ra,4(sp)
8113ddac:	df000017 	ldw	fp,0(sp)
8113ddb0:	dec00204 	addi	sp,sp,8
8113ddb4:	f800283a 	ret

8113ddb8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113ddb8:	defffe04 	addi	sp,sp,-8
8113ddbc:	de00012e 	bgeu	sp,et,8113ddc4 <alt_get_errno+0xc>
8113ddc0:	003b68fa 	trap	3
8113ddc4:	dfc00115 	stw	ra,4(sp)
8113ddc8:	df000015 	stw	fp,0(sp)
8113ddcc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113ddd0:	d0a01017 	ldw	r2,-32704(gp)
8113ddd4:	10000326 	beq	r2,zero,8113dde4 <alt_get_errno+0x2c>
8113ddd8:	d0a01017 	ldw	r2,-32704(gp)
8113dddc:	103ee83a 	callr	r2
8113dde0:	00000106 	br	8113dde8 <alt_get_errno+0x30>
8113dde4:	d0a06904 	addi	r2,gp,-32348
}
8113dde8:	e037883a 	mov	sp,fp
8113ddec:	dfc00117 	ldw	ra,4(sp)
8113ddf0:	df000017 	ldw	fp,0(sp)
8113ddf4:	dec00204 	addi	sp,sp,8
8113ddf8:	f800283a 	ret

8113ddfc <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
8113ddfc:	deffec04 	addi	sp,sp,-80
8113de00:	de00012e 	bgeu	sp,et,8113de08 <altera_avalon_uart_write+0xc>
8113de04:	003b68fa 	trap	3
8113de08:	dfc01315 	stw	ra,76(sp)
8113de0c:	df001215 	stw	fp,72(sp)
8113de10:	df001204 	addi	fp,sp,72
8113de14:	e13ffc15 	stw	r4,-16(fp)
8113de18:	e17ffd15 	stw	r5,-12(fp)
8113de1c:	e1bffe15 	stw	r6,-8(fp)
8113de20:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
8113de24:	e0bffe17 	ldw	r2,-8(fp)
8113de28:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
8113de2c:	e0bfff17 	ldw	r2,-4(fp)
8113de30:	1090000c 	andi	r2,r2,16384
8113de34:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
8113de38:	e0bffc17 	ldw	r2,-16(fp)
8113de3c:	10800917 	ldw	r2,36(r2)
8113de40:	e0bff815 	stw	r2,-32(fp)
8113de44:	e03ff90d 	sth	zero,-28(fp)
8113de48:	e0bff90b 	ldhu	r2,-28(fp)
8113de4c:	e0fffb44 	addi	r3,fp,-19
8113de50:	180d883a 	mov	r6,r3
8113de54:	100b883a 	mov	r5,r2
8113de58:	e13ff817 	ldw	r4,-32(fp)
8113de5c:	1134cf80 	call	81134cf8 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
8113de60:	00005106 	br	8113dfa8 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8113de64:	e0bffc17 	ldw	r2,-16(fp)
8113de68:	10800517 	ldw	r2,20(r2)
8113de6c:	10800044 	addi	r2,r2,1
8113de70:	10800fcc 	andi	r2,r2,63
8113de74:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
8113de78:	e0bffc17 	ldw	r2,-16(fp)
8113de7c:	10c00417 	ldw	r3,16(r2)
8113de80:	e0bff217 	ldw	r2,-56(fp)
8113de84:	1880371e 	bne	r3,r2,8113df64 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
8113de88:	e0bff017 	ldw	r2,-64(fp)
8113de8c:	10000526 	beq	r2,zero,8113dea4 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
8113de90:	113ddb80 	call	8113ddb8 <alt_get_errno>
8113de94:	1007883a 	mov	r3,r2
8113de98:	008002c4 	movi	r2,11
8113de9c:	18800015 	stw	r2,0(r3)
        break;
8113dea0:	00004306 	br	8113dfb0 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dea4:	0005303a 	rdctl	r2,status
8113dea8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113deac:	e0fff517 	ldw	r3,-44(fp)
8113deb0:	00bfff84 	movi	r2,-2
8113deb4:	1884703a 	and	r2,r3,r2
8113deb8:	1001703a 	wrctl	status,r2
  
  return context;
8113debc:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
8113dec0:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8113dec4:	e0bffc17 	ldw	r2,-16(fp)
8113dec8:	10800117 	ldw	r2,4(r2)
8113decc:	10c11014 	ori	r3,r2,1088
8113ded0:	e0bffc17 	ldw	r2,-16(fp)
8113ded4:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113ded8:	e0bffc17 	ldw	r2,-16(fp)
8113dedc:	10800017 	ldw	r2,0(r2)
8113dee0:	10800304 	addi	r2,r2,12
8113dee4:	e0fffc17 	ldw	r3,-16(fp)
8113dee8:	18c00117 	ldw	r3,4(r3)
8113deec:	10c00035 	stwio	r3,0(r2)
8113def0:	e0bff417 	ldw	r2,-48(fp)
8113def4:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113def8:	e0bff117 	ldw	r2,-60(fp)
8113defc:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
8113df00:	e0bffc17 	ldw	r2,-16(fp)
8113df04:	10800717 	ldw	r2,28(r2)
8113df08:	e0bff315 	stw	r2,-52(fp)
8113df0c:	00800084 	movi	r2,2
8113df10:	e0bff98d 	sth	r2,-26(fp)
8113df14:	00bfe0c4 	movi	r2,-125
8113df18:	e0bffa05 	stb	r2,-24(fp)
8113df1c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113df20:	d0a08203 	ldbu	r2,-32248(gp)
8113df24:	10803fcc 	andi	r2,r2,255
8113df28:	10000a26 	beq	r2,zero,8113df54 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113df2c:	e0fff98b 	ldhu	r3,-26(fp)
8113df30:	e13ffa03 	ldbu	r4,-24(fp)
8113df34:	e17ffa8b 	ldhu	r5,-22(fp)
8113df38:	e0bffb04 	addi	r2,fp,-20
8113df3c:	d8800015 	stw	r2,0(sp)
8113df40:	280f883a 	mov	r7,r5
8113df44:	200d883a 	mov	r6,r4
8113df48:	180b883a 	mov	r5,r3
8113df4c:	e13ff317 	ldw	r4,-52(fp)
8113df50:	11310580 	call	81131058 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
8113df54:	e0bffc17 	ldw	r2,-16(fp)
8113df58:	10c00417 	ldw	r3,16(r2)
8113df5c:	e0bff217 	ldw	r2,-56(fp)
8113df60:	18bfe726 	beq	r3,r2,8113df00 <__reset+0xfb11df00>
      }
    }

    count--;
8113df64:	e0bfef17 	ldw	r2,-68(fp)
8113df68:	10bfffc4 	addi	r2,r2,-1
8113df6c:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
8113df70:	e0bffc17 	ldw	r2,-16(fp)
8113df74:	10c00517 	ldw	r3,20(r2)
8113df78:	e0bffd17 	ldw	r2,-12(fp)
8113df7c:	11000044 	addi	r4,r2,1
8113df80:	e13ffd15 	stw	r4,-12(fp)
8113df84:	10800003 	ldbu	r2,0(r2)
8113df88:	1009883a 	mov	r4,r2
8113df8c:	e0bffc17 	ldw	r2,-16(fp)
8113df90:	10c5883a 	add	r2,r2,r3
8113df94:	10801a04 	addi	r2,r2,104
8113df98:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
8113df9c:	e0bffc17 	ldw	r2,-16(fp)
8113dfa0:	e0fff217 	ldw	r3,-56(fp)
8113dfa4:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
8113dfa8:	e0bfef17 	ldw	r2,-68(fp)
8113dfac:	103fad1e 	bne	r2,zero,8113de64 <__reset+0xfb11de64>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
8113dfb0:	e0bffc17 	ldw	r2,-16(fp)
8113dfb4:	10800917 	ldw	r2,36(r2)
8113dfb8:	1009883a 	mov	r4,r2
8113dfbc:	11350800 	call	81135080 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dfc0:	0005303a 	rdctl	r2,status
8113dfc4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dfc8:	e0fff717 	ldw	r3,-36(fp)
8113dfcc:	00bfff84 	movi	r2,-2
8113dfd0:	1884703a 	and	r2,r3,r2
8113dfd4:	1001703a 	wrctl	status,r2
  
  return context;
8113dfd8:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
8113dfdc:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8113dfe0:	e0bffc17 	ldw	r2,-16(fp)
8113dfe4:	10800117 	ldw	r2,4(r2)
8113dfe8:	10c11014 	ori	r3,r2,1088
8113dfec:	e0bffc17 	ldw	r2,-16(fp)
8113dff0:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8113dff4:	e0bffc17 	ldw	r2,-16(fp)
8113dff8:	10800017 	ldw	r2,0(r2)
8113dffc:	10800304 	addi	r2,r2,12
8113e000:	e0fffc17 	ldw	r3,-16(fp)
8113e004:	18c00117 	ldw	r3,4(r3)
8113e008:	10c00035 	stwio	r3,0(r2)
8113e00c:	e0bff417 	ldw	r2,-48(fp)
8113e010:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e014:	e0bff617 	ldw	r2,-40(fp)
8113e018:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
8113e01c:	e0fffe17 	ldw	r3,-8(fp)
8113e020:	e0bfef17 	ldw	r2,-68(fp)
8113e024:	1885c83a 	sub	r2,r3,r2
}
8113e028:	e037883a 	mov	sp,fp
8113e02c:	dfc00117 	ldw	ra,4(sp)
8113e030:	df000017 	ldw	fp,0(sp)
8113e034:	dec00204 	addi	sp,sp,8
8113e038:	f800283a 	ret

8113e03c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113e03c:	defffe04 	addi	sp,sp,-8
8113e040:	de00012e 	bgeu	sp,et,8113e048 <alt_get_errno+0xc>
8113e044:	003b68fa 	trap	3
8113e048:	dfc00115 	stw	ra,4(sp)
8113e04c:	df000015 	stw	fp,0(sp)
8113e050:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113e054:	d0a01017 	ldw	r2,-32704(gp)
8113e058:	10000326 	beq	r2,zero,8113e068 <alt_get_errno+0x2c>
8113e05c:	d0a01017 	ldw	r2,-32704(gp)
8113e060:	103ee83a 	callr	r2
8113e064:	00000106 	br	8113e06c <alt_get_errno+0x30>
8113e068:	d0a06904 	addi	r2,gp,-32348
}
8113e06c:	e037883a 	mov	sp,fp
8113e070:	dfc00117 	ldw	ra,4(sp)
8113e074:	df000017 	ldw	fp,0(sp)
8113e078:	dec00204 	addi	sp,sp,8
8113e07c:	f800283a 	ret

8113e080 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
8113e080:	defffc04 	addi	sp,sp,-16
8113e084:	de00012e 	bgeu	sp,et,8113e08c <alt_msgdma_write_standard_descriptor+0xc>
8113e088:	003b68fa 	trap	3
8113e08c:	df000315 	stw	fp,12(sp)
8113e090:	df000304 	addi	fp,sp,12
8113e094:	e13ffd15 	stw	r4,-12(fp)
8113e098:	e17ffe15 	stw	r5,-8(fp)
8113e09c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
8113e0a0:	e0bffd17 	ldw	r2,-12(fp)
8113e0a4:	10800037 	ldwio	r2,0(r2)
8113e0a8:	1080010c 	andi	r2,r2,4
8113e0ac:	10000226 	beq	r2,zero,8113e0b8 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
8113e0b0:	00bff904 	movi	r2,-28
8113e0b4:	00001506 	br	8113e10c <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
8113e0b8:	e0bfff17 	ldw	r2,-4(fp)
8113e0bc:	10800017 	ldw	r2,0(r2)
8113e0c0:	1007883a 	mov	r3,r2
8113e0c4:	e0bffe17 	ldw	r2,-8(fp)
8113e0c8:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
8113e0cc:	e0bffe17 	ldw	r2,-8(fp)
8113e0d0:	10800104 	addi	r2,r2,4
8113e0d4:	e0ffff17 	ldw	r3,-4(fp)
8113e0d8:	18c00117 	ldw	r3,4(r3)
8113e0dc:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
8113e0e0:	e0bffe17 	ldw	r2,-8(fp)
8113e0e4:	10800204 	addi	r2,r2,8
8113e0e8:	e0ffff17 	ldw	r3,-4(fp)
8113e0ec:	18c00217 	ldw	r3,8(r3)
8113e0f0:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
8113e0f4:	e0bffe17 	ldw	r2,-8(fp)
8113e0f8:	10800304 	addi	r2,r2,12
8113e0fc:	e0ffff17 	ldw	r3,-4(fp)
8113e100:	18c00317 	ldw	r3,12(r3)
8113e104:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
8113e108:	0005883a 	mov	r2,zero
}
8113e10c:	e037883a 	mov	sp,fp
8113e110:	df000017 	ldw	fp,0(sp)
8113e114:	dec00104 	addi	sp,sp,4
8113e118:	f800283a 	ret

8113e11c <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
8113e11c:	defffc04 	addi	sp,sp,-16
8113e120:	de00012e 	bgeu	sp,et,8113e128 <alt_msgdma_write_extended_descriptor+0xc>
8113e124:	003b68fa 	trap	3
8113e128:	df000315 	stw	fp,12(sp)
8113e12c:	df000304 	addi	fp,sp,12
8113e130:	e13ffd15 	stw	r4,-12(fp)
8113e134:	e17ffe15 	stw	r5,-8(fp)
8113e138:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
8113e13c:	e0bffd17 	ldw	r2,-12(fp)
8113e140:	10800037 	ldwio	r2,0(r2)
8113e144:	1080010c 	andi	r2,r2,4
8113e148:	10000226 	beq	r2,zero,8113e154 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
8113e14c:	00bff904 	movi	r2,-28
8113e150:	00003b06 	br	8113e240 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
8113e154:	e0bfff17 	ldw	r2,-4(fp)
8113e158:	10800017 	ldw	r2,0(r2)
8113e15c:	1007883a 	mov	r3,r2
8113e160:	e0bffe17 	ldw	r2,-8(fp)
8113e164:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
8113e168:	e0bffe17 	ldw	r2,-8(fp)
8113e16c:	10800104 	addi	r2,r2,4
8113e170:	e0ffff17 	ldw	r3,-4(fp)
8113e174:	18c00117 	ldw	r3,4(r3)
8113e178:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
8113e17c:	e0bffe17 	ldw	r2,-8(fp)
8113e180:	10800204 	addi	r2,r2,8
8113e184:	e0ffff17 	ldw	r3,-4(fp)
8113e188:	18c00217 	ldw	r3,8(r3)
8113e18c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
8113e190:	e0bffe17 	ldw	r2,-8(fp)
8113e194:	10800304 	addi	r2,r2,12
8113e198:	e0ffff17 	ldw	r3,-4(fp)
8113e19c:	18c0030b 	ldhu	r3,12(r3)
8113e1a0:	18ffffcc 	andi	r3,r3,65535
8113e1a4:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
8113e1a8:	e0bffe17 	ldw	r2,-8(fp)
8113e1ac:	10800384 	addi	r2,r2,14
8113e1b0:	e0ffff17 	ldw	r3,-4(fp)
8113e1b4:	18c00383 	ldbu	r3,14(r3)
8113e1b8:	18c03fcc 	andi	r3,r3,255
8113e1bc:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
8113e1c0:	e0bffe17 	ldw	r2,-8(fp)
8113e1c4:	108003c4 	addi	r2,r2,15
8113e1c8:	e0ffff17 	ldw	r3,-4(fp)
8113e1cc:	18c003c3 	ldbu	r3,15(r3)
8113e1d0:	18c03fcc 	andi	r3,r3,255
8113e1d4:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
8113e1d8:	e0bffe17 	ldw	r2,-8(fp)
8113e1dc:	10800404 	addi	r2,r2,16
8113e1e0:	e0ffff17 	ldw	r3,-4(fp)
8113e1e4:	18c0040b 	ldhu	r3,16(r3)
8113e1e8:	18ffffcc 	andi	r3,r3,65535
8113e1ec:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
8113e1f0:	e0bffe17 	ldw	r2,-8(fp)
8113e1f4:	10800484 	addi	r2,r2,18
8113e1f8:	e0ffff17 	ldw	r3,-4(fp)
8113e1fc:	18c0048b 	ldhu	r3,18(r3)
8113e200:	18ffffcc 	andi	r3,r3,65535
8113e204:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
8113e208:	e0bffe17 	ldw	r2,-8(fp)
8113e20c:	10800504 	addi	r2,r2,20
8113e210:	0007883a 	mov	r3,zero
8113e214:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
8113e218:	e0bffe17 	ldw	r2,-8(fp)
8113e21c:	10800604 	addi	r2,r2,24
8113e220:	0007883a 	mov	r3,zero
8113e224:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
8113e228:	e0bffe17 	ldw	r2,-8(fp)
8113e22c:	10800704 	addi	r2,r2,28
8113e230:	e0ffff17 	ldw	r3,-4(fp)
8113e234:	18c00717 	ldw	r3,28(r3)
8113e238:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
8113e23c:	0005883a 	mov	r2,zero
}
8113e240:	e037883a 	mov	sp,fp
8113e244:	df000017 	ldw	fp,0(sp)
8113e248:	dec00104 	addi	sp,sp,4
8113e24c:	f800283a 	ret

8113e250 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
8113e250:	defff804 	addi	sp,sp,-32
8113e254:	de00012e 	bgeu	sp,et,8113e25c <alt_msgdma_irq+0xc>
8113e258:	003b68fa 	trap	3
8113e25c:	dfc00715 	stw	ra,28(sp)
8113e260:	df000615 	stw	fp,24(sp)
8113e264:	df000604 	addi	fp,sp,24
8113e268:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
8113e26c:	e0bfff17 	ldw	r2,-4(fp)
8113e270:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
8113e274:	e0bffa17 	ldw	r2,-24(fp)
8113e278:	10801783 	ldbu	r2,94(r2)
8113e27c:	10803fcc 	andi	r2,r2,255
8113e280:	10001126 	beq	r2,zero,8113e2c8 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
8113e284:	e0bffa17 	ldw	r2,-24(fp)
8113e288:	10800617 	ldw	r2,24(r2)
8113e28c:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
8113e290:	1007883a 	mov	r3,r2
8113e294:	00bffdc4 	movi	r2,-9
8113e298:	1884703a 	and	r2,r3,r2
8113e29c:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
8113e2a0:	e0bffa17 	ldw	r2,-24(fp)
8113e2a4:	10800617 	ldw	r2,24(r2)
8113e2a8:	e0fffb17 	ldw	r3,-20(fp)
8113e2ac:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
8113e2b0:	e0bffa17 	ldw	r2,-24(fp)
8113e2b4:	10800617 	ldw	r2,24(r2)
8113e2b8:	10800404 	addi	r2,r2,16
8113e2bc:	00c00044 	movi	r3,1
8113e2c0:	10c00035 	stwio	r3,0(r2)
8113e2c4:	00001106 	br	8113e30c <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8113e2c8:	e0bffa17 	ldw	r2,-24(fp)
8113e2cc:	10800317 	ldw	r2,12(r2)
8113e2d0:	10800104 	addi	r2,r2,4
8113e2d4:	10800037 	ldwio	r2,0(r2)
8113e2d8:	1007883a 	mov	r3,r2
8113e2dc:	00bffbc4 	movi	r2,-17
8113e2e0:	1884703a 	and	r2,r3,r2
8113e2e4:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8113e2e8:	e0bffa17 	ldw	r2,-24(fp)
8113e2ec:	10800317 	ldw	r2,12(r2)
8113e2f0:	10800104 	addi	r2,r2,4
8113e2f4:	e0fffb17 	ldw	r3,-20(fp)
8113e2f8:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8113e2fc:	e0bffa17 	ldw	r2,-24(fp)
8113e300:	10800317 	ldw	r2,12(r2)
8113e304:	00c08004 	movi	r3,512
8113e308:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
8113e30c:	e0bffa17 	ldw	r2,-24(fp)
8113e310:	10800b17 	ldw	r2,44(r2)
8113e314:	10001226 	beq	r2,zero,8113e360 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e318:	0005303a 	rdctl	r2,status
8113e31c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e320:	e0fffd17 	ldw	r3,-12(fp)
8113e324:	00bfff84 	movi	r2,-2
8113e328:	1884703a 	and	r2,r3,r2
8113e32c:	1001703a 	wrctl	status,r2
  
  return context;
8113e330:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
8113e334:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
8113e338:	e0bffa17 	ldw	r2,-24(fp)
8113e33c:	10800b17 	ldw	r2,44(r2)
8113e340:	e0fffa17 	ldw	r3,-24(fp)
8113e344:	18c00c17 	ldw	r3,48(r3)
8113e348:	1809883a 	mov	r4,r3
8113e34c:	103ee83a 	callr	r2
8113e350:	e0bffc17 	ldw	r2,-16(fp)
8113e354:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e358:	e0bffe17 	ldw	r2,-8(fp)
8113e35c:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
8113e360:	e0bffa17 	ldw	r2,-24(fp)
8113e364:	10801783 	ldbu	r2,94(r2)
8113e368:	10803fcc 	andi	r2,r2,255
8113e36c:	10000a26 	beq	r2,zero,8113e398 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
8113e370:	e0bffa17 	ldw	r2,-24(fp)
8113e374:	10800617 	ldw	r2,24(r2)
8113e378:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8113e37c:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
8113e380:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
8113e384:	e0bffa17 	ldw	r2,-24(fp)
8113e388:	10800617 	ldw	r2,24(r2)
8113e38c:	e0fffb17 	ldw	r3,-20(fp)
8113e390:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
8113e394:	00000c06 	br	8113e3c8 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8113e398:	e0bffa17 	ldw	r2,-24(fp)
8113e39c:	10800317 	ldw	r2,12(r2)
8113e3a0:	10800104 	addi	r2,r2,4
8113e3a4:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
8113e3a8:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8113e3ac:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8113e3b0:	e0bffa17 	ldw	r2,-24(fp)
8113e3b4:	10800317 	ldw	r2,12(r2)
8113e3b8:	10800104 	addi	r2,r2,4
8113e3bc:	e0fffb17 	ldw	r3,-20(fp)
8113e3c0:	10c00035 	stwio	r3,0(r2)
    }

    return;
8113e3c4:	0001883a 	nop
}
8113e3c8:	e037883a 	mov	sp,fp
8113e3cc:	dfc00117 	ldw	ra,4(sp)
8113e3d0:	df000017 	ldw	fp,0(sp)
8113e3d4:	dec00204 	addi	sp,sp,8
8113e3d8:	f800283a 	ret

8113e3dc <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113e3dc:	defffb04 	addi	sp,sp,-20
8113e3e0:	de00012e 	bgeu	sp,et,8113e3e8 <alt_msgdma_construct_standard_descriptor+0xc>
8113e3e4:	003b68fa 	trap	3
8113e3e8:	df000415 	stw	fp,16(sp)
8113e3ec:	df000404 	addi	fp,sp,16
8113e3f0:	e13ffc15 	stw	r4,-16(fp)
8113e3f4:	e17ffd15 	stw	r5,-12(fp)
8113e3f8:	e1bffe15 	stw	r6,-8(fp)
8113e3fc:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8113e400:	e0bffc17 	ldw	r2,-16(fp)
8113e404:	10c01217 	ldw	r3,72(r2)
8113e408:	e0800117 	ldw	r2,4(fp)
8113e40c:	18800436 	bltu	r3,r2,8113e420 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
8113e410:	e0bffc17 	ldw	r2,-16(fp)
8113e414:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8113e418:	10803fcc 	andi	r2,r2,255
8113e41c:	10000226 	beq	r2,zero,8113e428 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8113e420:	00bffa84 	movi	r2,-22
8113e424:	00000e06 	br	8113e460 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
8113e428:	e0bffd17 	ldw	r2,-12(fp)
8113e42c:	e0fffe17 	ldw	r3,-8(fp)
8113e430:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8113e434:	e0bffd17 	ldw	r2,-12(fp)
8113e438:	e0ffff17 	ldw	r3,-4(fp)
8113e43c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8113e440:	e0bffd17 	ldw	r2,-12(fp)
8113e444:	e0c00117 	ldw	r3,4(fp)
8113e448:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8113e44c:	e0800217 	ldw	r2,8(fp)
8113e450:	10e00034 	orhi	r3,r2,32768
8113e454:	e0bffd17 	ldw	r2,-12(fp)
8113e458:	10c00315 	stw	r3,12(r2)
    
    return 0;
8113e45c:	0005883a 	mov	r2,zero
}
8113e460:	e037883a 	mov	sp,fp
8113e464:	df000017 	ldw	fp,0(sp)
8113e468:	dec00104 	addi	sp,sp,4
8113e46c:	f800283a 	ret

8113e470 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8113e470:	defff604 	addi	sp,sp,-40
8113e474:	de00012e 	bgeu	sp,et,8113e47c <alt_msgdma_construct_extended_descriptor+0xc>
8113e478:	003b68fa 	trap	3
8113e47c:	df000915 	stw	fp,36(sp)
8113e480:	df000904 	addi	fp,sp,36
8113e484:	e13ff715 	stw	r4,-36(fp)
8113e488:	e17ff815 	stw	r5,-32(fp)
8113e48c:	e1bff915 	stw	r6,-28(fp)
8113e490:	e1fffa15 	stw	r7,-24(fp)
8113e494:	e1800317 	ldw	r6,12(fp)
8113e498:	e1400417 	ldw	r5,16(fp)
8113e49c:	e1000517 	ldw	r4,20(fp)
8113e4a0:	e0c00617 	ldw	r3,24(fp)
8113e4a4:	e0800717 	ldw	r2,28(fp)
8113e4a8:	e1bffb0d 	sth	r6,-20(fp)
8113e4ac:	e17ffc05 	stb	r5,-16(fp)
8113e4b0:	e13ffd05 	stb	r4,-12(fp)
8113e4b4:	e0fffe0d 	sth	r3,-8(fp)
8113e4b8:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
8113e4bc:	e0bff717 	ldw	r2,-36(fp)
8113e4c0:	10c01217 	ldw	r3,72(r2)
8113e4c4:	e0800117 	ldw	r2,4(fp)
8113e4c8:	18801936 	bltu	r3,r2,8113e530 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8113e4cc:	e13ff717 	ldw	r4,-36(fp)
8113e4d0:	20801317 	ldw	r2,76(r4)
8113e4d4:	20c01417 	ldw	r3,80(r4)
8113e4d8:	e13ffe0b 	ldhu	r4,-8(fp)
8113e4dc:	213fffcc 	andi	r4,r4,65535
8113e4e0:	2015883a 	mov	r10,r4
8113e4e4:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
8113e4e8:	1ac01136 	bltu	r3,r11,8113e530 <alt_msgdma_construct_extended_descriptor+0xc0>
8113e4ec:	58c0011e 	bne	r11,r3,8113e4f4 <alt_msgdma_construct_extended_descriptor+0x84>
8113e4f0:	12800f36 	bltu	r2,r10,8113e530 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8113e4f4:	e13ff717 	ldw	r4,-36(fp)
8113e4f8:	20801317 	ldw	r2,76(r4)
8113e4fc:	20c01417 	ldw	r3,80(r4)
8113e500:	e13fff0b 	ldhu	r4,-4(fp)
8113e504:	213fffcc 	andi	r4,r4,65535
8113e508:	2011883a 	mov	r8,r4
8113e50c:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8113e510:	1a400736 	bltu	r3,r9,8113e530 <alt_msgdma_construct_extended_descriptor+0xc0>
8113e514:	48c0011e 	bne	r9,r3,8113e51c <alt_msgdma_construct_extended_descriptor+0xac>
8113e518:	12000536 	bltu	r2,r8,8113e530 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8113e51c:	e0bff717 	ldw	r2,-36(fp)
8113e520:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8113e524:	10803fcc 	andi	r2,r2,255
8113e528:	10800060 	cmpeqi	r2,r2,1
8113e52c:	1000021e 	bne	r2,zero,8113e538 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8113e530:	00bffa84 	movi	r2,-22
8113e534:	00002106 	br	8113e5bc <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
8113e538:	e0bff817 	ldw	r2,-32(fp)
8113e53c:	e0fff917 	ldw	r3,-28(fp)
8113e540:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
8113e544:	e0bff817 	ldw	r2,-32(fp)
8113e548:	e0fffa17 	ldw	r3,-24(fp)
8113e54c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8113e550:	e0bff817 	ldw	r2,-32(fp)
8113e554:	e0c00117 	ldw	r3,4(fp)
8113e558:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8113e55c:	e0bff817 	ldw	r2,-32(fp)
8113e560:	e0fffb0b 	ldhu	r3,-20(fp)
8113e564:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
8113e568:	e0bff817 	ldw	r2,-32(fp)
8113e56c:	e0fffc03 	ldbu	r3,-16(fp)
8113e570:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
8113e574:	e0bff817 	ldw	r2,-32(fp)
8113e578:	e0fffd03 	ldbu	r3,-12(fp)
8113e57c:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
8113e580:	e0bff817 	ldw	r2,-32(fp)
8113e584:	e0fffe0b 	ldhu	r3,-8(fp)
8113e588:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
8113e58c:	e0bff817 	ldw	r2,-32(fp)
8113e590:	e0ffff0b 	ldhu	r3,-4(fp)
8113e594:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
8113e598:	e0bff817 	ldw	r2,-32(fp)
8113e59c:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
8113e5a0:	e0bff817 	ldw	r2,-32(fp)
8113e5a4:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8113e5a8:	e0800217 	ldw	r2,8(fp)
8113e5ac:	10e00034 	orhi	r3,r2,32768
8113e5b0:	e0bff817 	ldw	r2,-32(fp)
8113e5b4:	10c00715 	stw	r3,28(r2)

  return 0 ;
8113e5b8:	0005883a 	mov	r2,zero

}
8113e5bc:	e037883a 	mov	sp,fp
8113e5c0:	df000017 	ldw	fp,0(sp)
8113e5c4:	dec00104 	addi	sp,sp,4
8113e5c8:	f800283a 	ret

8113e5cc <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8113e5cc:	deffee04 	addi	sp,sp,-72
8113e5d0:	de00012e 	bgeu	sp,et,8113e5d8 <alt_msgdma_descriptor_async_transfer+0xc>
8113e5d4:	003b68fa 	trap	3
8113e5d8:	dfc01115 	stw	ra,68(sp)
8113e5dc:	df001015 	stw	fp,64(sp)
8113e5e0:	df001004 	addi	fp,sp,64
8113e5e4:	e13ffd15 	stw	r4,-12(fp)
8113e5e8:	e17ffe15 	stw	r5,-8(fp)
8113e5ec:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
8113e5f0:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
8113e5f4:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
8113e5f8:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113e5fc:	e0bffd17 	ldw	r2,-12(fp)
8113e600:	10800317 	ldw	r2,12(r2)
8113e604:	10800204 	addi	r2,r2,8
8113e608:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8113e60c:	10bfffcc 	andi	r2,r2,65535
8113e610:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113e614:	e0bffd17 	ldw	r2,-12(fp)
8113e618:	10800317 	ldw	r2,12(r2)
8113e61c:	10800204 	addi	r2,r2,8
8113e620:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8113e624:	1004d43a 	srli	r2,r2,16
8113e628:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113e62c:	e0bffd17 	ldw	r2,-12(fp)
8113e630:	10800917 	ldw	r2,36(r2)
8113e634:	e0fff417 	ldw	r3,-48(fp)
8113e638:	1880042e 	bgeu	r3,r2,8113e64c <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8113e63c:	e0bffd17 	ldw	r2,-12(fp)
8113e640:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113e644:	e0fff317 	ldw	r3,-52(fp)
8113e648:	18800236 	bltu	r3,r2,8113e654 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
8113e64c:	00bff904 	movi	r2,-28
8113e650:	0000a906 	br	8113e8f8 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
8113e654:	e0bffd17 	ldw	r2,-12(fp)
8113e658:	10801817 	ldw	r2,96(r2)
8113e65c:	e0bff615 	stw	r2,-40(fp)
8113e660:	e03ffc0d 	sth	zero,-16(fp)
8113e664:	e0bffc0b 	ldhu	r2,-16(fp)
8113e668:	e0fffc84 	addi	r3,fp,-14
8113e66c:	180d883a 	mov	r6,r3
8113e670:	100b883a 	mov	r5,r2
8113e674:	e13ff617 	ldw	r4,-40(fp)
8113e678:	1134cf80 	call	81134cf8 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8113e67c:	00800804 	movi	r2,32
8113e680:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e684:	0005303a 	rdctl	r2,status
8113e688:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e68c:	e0fff717 	ldw	r3,-36(fp)
8113e690:	00bfff84 	movi	r2,-2
8113e694:	1884703a 	and	r2,r3,r2
8113e698:	1001703a 	wrctl	status,r2
  
  return context;
8113e69c:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8113e6a0:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8113e6a4:	e0bffd17 	ldw	r2,-12(fp)
8113e6a8:	10800317 	ldw	r2,12(r2)
8113e6ac:	10800104 	addi	r2,r2,4
8113e6b0:	e0fff117 	ldw	r3,-60(fp)
8113e6b4:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
8113e6b8:	e0bffd17 	ldw	r2,-12(fp)
8113e6bc:	10800317 	ldw	r2,12(r2)
8113e6c0:	e0fffd17 	ldw	r3,-12(fp)
8113e6c4:	18c00317 	ldw	r3,12(r3)
8113e6c8:	18c00037 	ldwio	r3,0(r3)
8113e6cc:	10c00035 	stwio	r3,0(r2)
8113e6d0:	e0bff217 	ldw	r2,-56(fp)
8113e6d4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e6d8:	e0bffb17 	ldw	r2,-20(fp)
8113e6dc:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8113e6e0:	e0bffe17 	ldw	r2,-8(fp)
8113e6e4:	10001e26 	beq	r2,zero,8113e760 <alt_msgdma_descriptor_async_transfer+0x194>
8113e6e8:	e0bfff17 	ldw	r2,-4(fp)
8113e6ec:	10001c1e 	bne	r2,zero,8113e760 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8113e6f0:	00001106 	br	8113e738 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8113e6f4:	01000044 	movi	r4,1
8113e6f8:	112c4800 	call	8112c480 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113e6fc:	e0bff00b 	ldhu	r2,-64(fp)
8113e700:	1084e230 	cmpltui	r2,r2,5000
8113e704:	1000091e 	bne	r2,zero,8113e72c <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
8113e708:	01204534 	movhi	r4,33044
8113e70c:	21190704 	addi	r4,r4,25628
8113e710:	1140a200 	call	81140a20 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8113e714:	e0bffd17 	ldw	r2,-12(fp)
8113e718:	10801817 	ldw	r2,96(r2)
8113e71c:	1009883a 	mov	r4,r2
8113e720:	11350800 	call	81135080 <OSSemPost>
				
                return -ETIME;
8113e724:	00bff084 	movi	r2,-62
8113e728:	00007306 	br	8113e8f8 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8113e72c:	e0bff00b 	ldhu	r2,-64(fp)
8113e730:	10800044 	addi	r2,r2,1
8113e734:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8113e738:	e0bffd17 	ldw	r2,-12(fp)
8113e73c:	10c00317 	ldw	r3,12(r2)
8113e740:	e0bffd17 	ldw	r2,-12(fp)
8113e744:	10800417 	ldw	r2,16(r2)
8113e748:	e1bffe17 	ldw	r6,-8(fp)
8113e74c:	100b883a 	mov	r5,r2
8113e750:	1809883a 	mov	r4,r3
8113e754:	113e0800 	call	8113e080 <alt_msgdma_write_standard_descriptor>
8113e758:	103fe61e 	bne	r2,zero,8113e6f4 <__reset+0xfb11e6f4>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8113e75c:	00002706 	br	8113e7fc <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8113e760:	e0bffe17 	ldw	r2,-8(fp)
8113e764:	10001f1e 	bne	r2,zero,8113e7e4 <alt_msgdma_descriptor_async_transfer+0x218>
8113e768:	e0bfff17 	ldw	r2,-4(fp)
8113e76c:	10001d26 	beq	r2,zero,8113e7e4 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
8113e770:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113e774:	00001106 	br	8113e7bc <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8113e778:	01000044 	movi	r4,1
8113e77c:	112c4800 	call	8112c480 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113e780:	e0bff00b 	ldhu	r2,-64(fp)
8113e784:	1084e230 	cmpltui	r2,r2,5000
8113e788:	1000091e 	bne	r2,zero,8113e7b0 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
8113e78c:	01204534 	movhi	r4,33044
8113e790:	21191d04 	addi	r4,r4,25716
8113e794:	1140a200 	call	81140a20 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8113e798:	e0bffd17 	ldw	r2,-12(fp)
8113e79c:	10801817 	ldw	r2,96(r2)
8113e7a0:	1009883a 	mov	r4,r2
8113e7a4:	11350800 	call	81135080 <OSSemPost>
				
                return -ETIME;
8113e7a8:	00bff084 	movi	r2,-62
8113e7ac:	00005206 	br	8113e8f8 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
8113e7b0:	e0bff00b 	ldhu	r2,-64(fp)
8113e7b4:	10800044 	addi	r2,r2,1
8113e7b8:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113e7bc:	e0bffd17 	ldw	r2,-12(fp)
8113e7c0:	10c00317 	ldw	r3,12(r2)
8113e7c4:	e0bffd17 	ldw	r2,-12(fp)
8113e7c8:	10800417 	ldw	r2,16(r2)
8113e7cc:	e1bfff17 	ldw	r6,-4(fp)
8113e7d0:	100b883a 	mov	r5,r2
8113e7d4:	1809883a 	mov	r4,r3
8113e7d8:	113e11c0 	call	8113e11c <alt_msgdma_write_extended_descriptor>
8113e7dc:	103fe61e 	bne	r2,zero,8113e778 <__reset+0xfb11e778>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8113e7e0:	00000606 	br	8113e7fc <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8113e7e4:	e0bffd17 	ldw	r2,-12(fp)
8113e7e8:	10801817 	ldw	r2,96(r2)
8113e7ec:	1009883a 	mov	r4,r2
8113e7f0:	11350800 	call	81135080 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
8113e7f4:	00bfffc4 	movi	r2,-1
8113e7f8:	00003f06 	br	8113e8f8 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
8113e7fc:	e0bffd17 	ldw	r2,-12(fp)
8113e800:	10800b17 	ldw	r2,44(r2)
8113e804:	10001c26 	beq	r2,zero,8113e878 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
8113e808:	e0bffd17 	ldw	r2,-12(fp)
8113e80c:	10c00d17 	ldw	r3,52(r2)
8113e810:	e0bff117 	ldw	r2,-60(fp)
8113e814:	1884b03a 	or	r2,r3,r2
8113e818:	10800514 	ori	r2,r2,20
8113e81c:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8113e820:	e0fff117 	ldw	r3,-60(fp)
8113e824:	00bff7c4 	movi	r2,-33
8113e828:	1884703a 	and	r2,r3,r2
8113e82c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e830:	0005303a 	rdctl	r2,status
8113e834:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e838:	e0fff917 	ldw	r3,-28(fp)
8113e83c:	00bfff84 	movi	r2,-2
8113e840:	1884703a 	and	r2,r3,r2
8113e844:	1001703a 	wrctl	status,r2
  
  return context;
8113e848:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
8113e84c:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8113e850:	e0bffd17 	ldw	r2,-12(fp)
8113e854:	10800317 	ldw	r2,12(r2)
8113e858:	10800104 	addi	r2,r2,4
8113e85c:	e0fff117 	ldw	r3,-60(fp)
8113e860:	10c00035 	stwio	r3,0(r2)
8113e864:	e0bff217 	ldw	r2,-56(fp)
8113e868:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e86c:	e0bff517 	ldw	r2,-44(fp)
8113e870:	1001703a 	wrctl	status,r2
8113e874:	00001b06 	br	8113e8e4 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
8113e878:	e0bffd17 	ldw	r2,-12(fp)
8113e87c:	10c00d17 	ldw	r3,52(r2)
8113e880:	e0bff117 	ldw	r2,-60(fp)
8113e884:	1884b03a 	or	r2,r3,r2
8113e888:	10800114 	ori	r2,r2,4
8113e88c:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
8113e890:	e0fff117 	ldw	r3,-60(fp)
8113e894:	00bff3c4 	movi	r2,-49
8113e898:	1884703a 	and	r2,r3,r2
8113e89c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e8a0:	0005303a 	rdctl	r2,status
8113e8a4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e8a8:	e0fffa17 	ldw	r3,-24(fp)
8113e8ac:	00bfff84 	movi	r2,-2
8113e8b0:	1884703a 	and	r2,r3,r2
8113e8b4:	1001703a 	wrctl	status,r2
  
  return context;
8113e8b8:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
8113e8bc:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8113e8c0:	e0bffd17 	ldw	r2,-12(fp)
8113e8c4:	10800317 	ldw	r2,12(r2)
8113e8c8:	10800104 	addi	r2,r2,4
8113e8cc:	e0fff117 	ldw	r3,-60(fp)
8113e8d0:	10c00035 	stwio	r3,0(r2)
8113e8d4:	e0bff217 	ldw	r2,-56(fp)
8113e8d8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e8dc:	e0bff817 	ldw	r2,-32(fp)
8113e8e0:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
8113e8e4:	e0bffd17 	ldw	r2,-12(fp)
8113e8e8:	10801817 	ldw	r2,96(r2)
8113e8ec:	1009883a 	mov	r4,r2
8113e8f0:	11350800 	call	81135080 <OSSemPost>
    
    return 0;
8113e8f4:	0005883a 	mov	r2,zero
}
8113e8f8:	e037883a 	mov	sp,fp
8113e8fc:	dfc00117 	ldw	ra,4(sp)
8113e900:	df000017 	ldw	fp,0(sp)
8113e904:	dec00204 	addi	sp,sp,8
8113e908:	f800283a 	ret

8113e90c <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8113e90c:	deffee04 	addi	sp,sp,-72
8113e910:	de00012e 	bgeu	sp,et,8113e918 <alt_msgdma_descriptor_sync_transfer+0xc>
8113e914:	003b68fa 	trap	3
8113e918:	dfc01115 	stw	ra,68(sp)
8113e91c:	df001015 	stw	fp,64(sp)
8113e920:	df001004 	addi	fp,sp,64
8113e924:	e13ffd15 	stw	r4,-12(fp)
8113e928:	e17ffe15 	stw	r5,-8(fp)
8113e92c:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
8113e930:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
8113e934:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
8113e938:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
8113e93c:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113e940:	e0bffd17 	ldw	r2,-12(fp)
8113e944:	10800317 	ldw	r2,12(r2)
8113e948:	10800204 	addi	r2,r2,8
8113e94c:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8113e950:	10bfffcc 	andi	r2,r2,65535
8113e954:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113e958:	e0bffd17 	ldw	r2,-12(fp)
8113e95c:	10800317 	ldw	r2,12(r2)
8113e960:	10800204 	addi	r2,r2,8
8113e964:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8113e968:	1004d43a 	srli	r2,r2,16
8113e96c:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
8113e970:	00807804 	movi	r2,480
8113e974:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113e978:	00001906 	br	8113e9e0 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
8113e97c:	01000044 	movi	r4,1
8113e980:	112c4800 	call	8112c480 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113e984:	e0bff10b 	ldhu	r2,-60(fp)
8113e988:	1084e230 	cmpltui	r2,r2,5000
8113e98c:	1000051e 	bne	r2,zero,8113e9a4 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
8113e990:	01204534 	movhi	r4,33044
8113e994:	21193304 	addi	r4,r4,25804
8113e998:	1140a200 	call	81140a20 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
8113e99c:	00bff084 	movi	r2,-62
8113e9a0:	0000d706 	br	8113ed00 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
8113e9a4:	e0bff10b 	ldhu	r2,-60(fp)
8113e9a8:	10800044 	addi	r2,r2,1
8113e9ac:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113e9b0:	e0bffd17 	ldw	r2,-12(fp)
8113e9b4:	10800317 	ldw	r2,12(r2)
8113e9b8:	10800204 	addi	r2,r2,8
8113e9bc:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
8113e9c0:	10bfffcc 	andi	r2,r2,65535
8113e9c4:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8113e9c8:	e0bffd17 	ldw	r2,-12(fp)
8113e9cc:	10800317 	ldw	r2,12(r2)
8113e9d0:	10800204 	addi	r2,r2,8
8113e9d4:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
8113e9d8:	1004d43a 	srli	r2,r2,16
8113e9dc:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113e9e0:	e0bffd17 	ldw	r2,-12(fp)
8113e9e4:	10800917 	ldw	r2,36(r2)
8113e9e8:	e0fff317 	ldw	r3,-52(fp)
8113e9ec:	18bfe32e 	bgeu	r3,r2,8113e97c <__reset+0xfb11e97c>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
8113e9f0:	e0bffd17 	ldw	r2,-12(fp)
8113e9f4:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8113e9f8:	e0fff217 	ldw	r3,-56(fp)
8113e9fc:	18bfdf2e 	bgeu	r3,r2,8113e97c <__reset+0xfb11e97c>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
8113ea00:	e0bffd17 	ldw	r2,-12(fp)
8113ea04:	10801817 	ldw	r2,96(r2)
8113ea08:	e0bff815 	stw	r2,-32(fp)
8113ea0c:	e03ffc0d 	sth	zero,-16(fp)
8113ea10:	e0bffc0b 	ldhu	r2,-16(fp)
8113ea14:	e0fffc84 	addi	r3,fp,-14
8113ea18:	180d883a 	mov	r6,r3
8113ea1c:	100b883a 	mov	r5,r2
8113ea20:	e13ff817 	ldw	r4,-32(fp)
8113ea24:	1134cf80 	call	81134cf8 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ea28:	0005303a 	rdctl	r2,status
8113ea2c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ea30:	e0fffb17 	ldw	r3,-20(fp)
8113ea34:	00bfff84 	movi	r2,-2
8113ea38:	1884703a 	and	r2,r3,r2
8113ea3c:	1001703a 	wrctl	status,r2
  
  return context;
8113ea40:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
8113ea44:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8113ea48:	e0bffd17 	ldw	r2,-12(fp)
8113ea4c:	10800317 	ldw	r2,12(r2)
8113ea50:	10800104 	addi	r2,r2,4
8113ea54:	00c00804 	movi	r3,32
8113ea58:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
8113ea5c:	e0bffd17 	ldw	r2,-12(fp)
8113ea60:	10800317 	ldw	r2,12(r2)
8113ea64:	e0fffd17 	ldw	r3,-12(fp)
8113ea68:	18c00317 	ldw	r3,12(r3)
8113ea6c:	18c00037 	ldwio	r3,0(r3)
8113ea70:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
8113ea74:	e0bffe17 	ldw	r2,-8(fp)
8113ea78:	10001f26 	beq	r2,zero,8113eaf8 <alt_msgdma_descriptor_sync_transfer+0x1ec>
8113ea7c:	e0bfff17 	ldw	r2,-4(fp)
8113ea80:	10001d1e 	bne	r2,zero,8113eaf8 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
8113ea84:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8113ea88:	00001106 	br	8113ead0 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
8113ea8c:	01000044 	movi	r4,1
8113ea90:	112c4800 	call	8112c480 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113ea94:	e0bff10b 	ldhu	r2,-60(fp)
8113ea98:	1084e230 	cmpltui	r2,r2,5000
8113ea9c:	1000091e 	bne	r2,zero,8113eac4 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
8113eaa0:	01204534 	movhi	r4,33044
8113eaa4:	21194704 	addi	r4,r4,25884
8113eaa8:	1140a200 	call	81140a20 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8113eaac:	e0bffd17 	ldw	r2,-12(fp)
8113eab0:	10801817 	ldw	r2,96(r2)
8113eab4:	1009883a 	mov	r4,r2
8113eab8:	11350800 	call	81135080 <OSSemPost>
				
                return -ETIME;
8113eabc:	00bff084 	movi	r2,-62
8113eac0:	00008f06 	br	8113ed00 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
8113eac4:	e0bff10b 	ldhu	r2,-60(fp)
8113eac8:	10800044 	addi	r2,r2,1
8113eacc:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8113ead0:	e0bffd17 	ldw	r2,-12(fp)
8113ead4:	10c00317 	ldw	r3,12(r2)
8113ead8:	e0bffd17 	ldw	r2,-12(fp)
8113eadc:	10800417 	ldw	r2,16(r2)
8113eae0:	e1bffe17 	ldw	r6,-8(fp)
8113eae4:	100b883a 	mov	r5,r2
8113eae8:	1809883a 	mov	r4,r3
8113eaec:	113e0800 	call	8113e080 <alt_msgdma_write_standard_descriptor>
8113eaf0:	103fe61e 	bne	r2,zero,8113ea8c <__reset+0xfb11ea8c>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
8113eaf4:	00002706 	br	8113eb94 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8113eaf8:	e0bffe17 	ldw	r2,-8(fp)
8113eafc:	10001f1e 	bne	r2,zero,8113eb7c <alt_msgdma_descriptor_sync_transfer+0x270>
8113eb00:	e0bfff17 	ldw	r2,-4(fp)
8113eb04:	10001d26 	beq	r2,zero,8113eb7c <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
8113eb08:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113eb0c:	00001106 	br	8113eb54 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8113eb10:	01000044 	movi	r4,1
8113eb14:	112c4800 	call	8112c480 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113eb18:	e0bff10b 	ldhu	r2,-60(fp)
8113eb1c:	1084e230 	cmpltui	r2,r2,5000
8113eb20:	1000091e 	bne	r2,zero,8113eb48 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
8113eb24:	01204534 	movhi	r4,33044
8113eb28:	21195804 	addi	r4,r4,25952
8113eb2c:	1140a200 	call	81140a20 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8113eb30:	e0bffd17 	ldw	r2,-12(fp)
8113eb34:	10801817 	ldw	r2,96(r2)
8113eb38:	1009883a 	mov	r4,r2
8113eb3c:	11350800 	call	81135080 <OSSemPost>
				
                return -ETIME;
8113eb40:	00bff084 	movi	r2,-62
8113eb44:	00006e06 	br	8113ed00 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
8113eb48:	e0bff10b 	ldhu	r2,-60(fp)
8113eb4c:	10800044 	addi	r2,r2,1
8113eb50:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8113eb54:	e0bffd17 	ldw	r2,-12(fp)
8113eb58:	10c00317 	ldw	r3,12(r2)
8113eb5c:	e0bffd17 	ldw	r2,-12(fp)
8113eb60:	10800417 	ldw	r2,16(r2)
8113eb64:	e1bfff17 	ldw	r6,-4(fp)
8113eb68:	100b883a 	mov	r5,r2
8113eb6c:	1809883a 	mov	r4,r3
8113eb70:	113e11c0 	call	8113e11c <alt_msgdma_write_extended_descriptor>
8113eb74:	103fe61e 	bne	r2,zero,8113eb10 <__reset+0xfb11eb10>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8113eb78:	00000606 	br	8113eb94 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8113eb7c:	e0bffd17 	ldw	r2,-12(fp)
8113eb80:	10801817 	ldw	r2,96(r2)
8113eb84:	1009883a 	mov	r4,r2
8113eb88:	11350800 	call	81135080 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
8113eb8c:	00bfffc4 	movi	r2,-1
8113eb90:	00005b06 	br	8113ed00 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8113eb94:	e0bffd17 	ldw	r2,-12(fp)
8113eb98:	10800317 	ldw	r2,12(r2)
8113eb9c:	10800104 	addi	r2,r2,4
8113eba0:	e0fffd17 	ldw	r3,-12(fp)
8113eba4:	19000d17 	ldw	r4,52(r3)
8113eba8:	00fff2c4 	movi	r3,-53
8113ebac:	20c6703a 	and	r3,r4,r3
8113ebb0:	18c00114 	ori	r3,r3,4
8113ebb4:	10c00035 	stwio	r3,0(r2)
8113ebb8:	e0bff517 	ldw	r2,-44(fp)
8113ebbc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ebc0:	e0bff717 	ldw	r2,-36(fp)
8113ebc4:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
8113ebc8:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8113ebcc:	e0bffd17 	ldw	r2,-12(fp)
8113ebd0:	10800317 	ldw	r2,12(r2)
8113ebd4:	10800037 	ldwio	r2,0(r2)
8113ebd8:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
8113ebdc:	00001506 	br	8113ec34 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
8113ebe0:	01000044 	movi	r4,1
8113ebe4:	112c4800 	call	8112c480 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8113ebe8:	e0bff10b 	ldhu	r2,-60(fp)
8113ebec:	1084e230 	cmpltui	r2,r2,5000
8113ebf0:	1000091e 	bne	r2,zero,8113ec18 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
8113ebf4:	01204534 	movhi	r4,33044
8113ebf8:	21196904 	addi	r4,r4,26020
8113ebfc:	1140a200 	call	81140a20 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
8113ec00:	e0bffd17 	ldw	r2,-12(fp)
8113ec04:	10801817 	ldw	r2,96(r2)
8113ec08:	1009883a 	mov	r4,r2
8113ec0c:	11350800 	call	81135080 <OSSemPost>
			
            return -ETIME;
8113ec10:	00bff084 	movi	r2,-62
8113ec14:	00003a06 	br	8113ed00 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
8113ec18:	e0bff10b 	ldhu	r2,-60(fp)
8113ec1c:	10800044 	addi	r2,r2,1
8113ec20:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8113ec24:	e0bffd17 	ldw	r2,-12(fp)
8113ec28:	10800317 	ldw	r2,12(r2)
8113ec2c:	10800037 	ldwio	r2,0(r2)
8113ec30:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
8113ec34:	e0fff017 	ldw	r3,-64(fp)
8113ec38:	e0bff617 	ldw	r2,-40(fp)
8113ec3c:	1884703a 	and	r2,r3,r2
8113ec40:	1000031e 	bne	r2,zero,8113ec50 <alt_msgdma_descriptor_sync_transfer+0x344>
8113ec44:	e0bff017 	ldw	r2,-64(fp)
8113ec48:	1080004c 	andi	r2,r2,1
8113ec4c:	103fe41e 	bne	r2,zero,8113ebe0 <__reset+0xfb11ebe0>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
8113ec50:	e0fff017 	ldw	r3,-64(fp)
8113ec54:	e0bff617 	ldw	r2,-40(fp)
8113ec58:	1884703a 	and	r2,r3,r2
8113ec5c:	10000626 	beq	r2,zero,8113ec78 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8113ec60:	e0bffd17 	ldw	r2,-12(fp)
8113ec64:	10801817 	ldw	r2,96(r2)
8113ec68:	1009883a 	mov	r4,r2
8113ec6c:	11350800 	call	81135080 <OSSemPost>
		
        return error;
8113ec70:	e0bff617 	ldw	r2,-40(fp)
8113ec74:	00002206 	br	8113ed00 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
8113ec78:	e0bffd17 	ldw	r2,-12(fp)
8113ec7c:	10800317 	ldw	r2,12(r2)
8113ec80:	10800104 	addi	r2,r2,4
8113ec84:	10800037 	ldwio	r2,0(r2)
8113ec88:	10800814 	ori	r2,r2,32
8113ec8c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ec90:	0005303a 	rdctl	r2,status
8113ec94:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ec98:	e0fffa17 	ldw	r3,-24(fp)
8113ec9c:	00bfff84 	movi	r2,-2
8113eca0:	1884703a 	and	r2,r3,r2
8113eca4:	1001703a 	wrctl	status,r2
  
  return context;
8113eca8:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
8113ecac:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8113ecb0:	e0bffd17 	ldw	r2,-12(fp)
8113ecb4:	10800317 	ldw	r2,12(r2)
8113ecb8:	10800104 	addi	r2,r2,4
8113ecbc:	e0fff417 	ldw	r3,-48(fp)
8113ecc0:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
8113ecc4:	e0bffd17 	ldw	r2,-12(fp)
8113ecc8:	10800317 	ldw	r2,12(r2)
8113eccc:	e0fffd17 	ldw	r3,-12(fp)
8113ecd0:	18c00317 	ldw	r3,12(r3)
8113ecd4:	18c00037 	ldwio	r3,0(r3)
8113ecd8:	10c00035 	stwio	r3,0(r2)
8113ecdc:	e0bff517 	ldw	r2,-44(fp)
8113ece0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ece4:	e0bff917 	ldw	r2,-28(fp)
8113ece8:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
8113ecec:	e0bffd17 	ldw	r2,-12(fp)
8113ecf0:	10801817 	ldw	r2,96(r2)
8113ecf4:	1009883a 	mov	r4,r2
8113ecf8:	11350800 	call	81135080 <OSSemPost>
    
    return 0;
8113ecfc:	0005883a 	mov	r2,zero

}
8113ed00:	e037883a 	mov	sp,fp
8113ed04:	dfc00117 	ldw	ra,4(sp)
8113ed08:	df000017 	ldw	fp,0(sp)
8113ed0c:	dec00204 	addi	sp,sp,8
8113ed10:	f800283a 	ret

8113ed14 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
8113ed14:	defff804 	addi	sp,sp,-32
8113ed18:	de00012e 	bgeu	sp,et,8113ed20 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
8113ed1c:	003b68fa 	trap	3
8113ed20:	dfc00715 	stw	ra,28(sp)
8113ed24:	df000615 	stw	fp,24(sp)
8113ed28:	df000604 	addi	fp,sp,24
8113ed2c:	e13ffc15 	stw	r4,-16(fp)
8113ed30:	e17ffd15 	stw	r5,-12(fp)
8113ed34:	e1bffe15 	stw	r6,-8(fp)
8113ed38:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
8113ed3c:	e0800217 	ldw	r2,8(fp)
8113ed40:	d8800115 	stw	r2,4(sp)
8113ed44:	e0bfff17 	ldw	r2,-4(fp)
8113ed48:	d8800015 	stw	r2,0(sp)
8113ed4c:	e1fffe17 	ldw	r7,-8(fp)
8113ed50:	000d883a 	mov	r6,zero
8113ed54:	e17ffd17 	ldw	r5,-12(fp)
8113ed58:	e13ffc17 	ldw	r4,-16(fp)
8113ed5c:	113e3dc0 	call	8113e3dc <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8113ed60:	e037883a 	mov	sp,fp
8113ed64:	dfc00117 	ldw	ra,4(sp)
8113ed68:	df000017 	ldw	fp,0(sp)
8113ed6c:	dec00204 	addi	sp,sp,8
8113ed70:	f800283a 	ret

8113ed74 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
8113ed74:	defff804 	addi	sp,sp,-32
8113ed78:	de00012e 	bgeu	sp,et,8113ed80 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
8113ed7c:	003b68fa 	trap	3
8113ed80:	dfc00715 	stw	ra,28(sp)
8113ed84:	df000615 	stw	fp,24(sp)
8113ed88:	df000604 	addi	fp,sp,24
8113ed8c:	e13ffc15 	stw	r4,-16(fp)
8113ed90:	e17ffd15 	stw	r5,-12(fp)
8113ed94:	e1bffe15 	stw	r6,-8(fp)
8113ed98:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8113ed9c:	e0800217 	ldw	r2,8(fp)
8113eda0:	d8800115 	stw	r2,4(sp)
8113eda4:	e0bfff17 	ldw	r2,-4(fp)
8113eda8:	d8800015 	stw	r2,0(sp)
8113edac:	000f883a 	mov	r7,zero
8113edb0:	e1bffe17 	ldw	r6,-8(fp)
8113edb4:	e17ffd17 	ldw	r5,-12(fp)
8113edb8:	e13ffc17 	ldw	r4,-16(fp)
8113edbc:	113e3dc0 	call	8113e3dc <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
8113edc0:	e037883a 	mov	sp,fp
8113edc4:	dfc00117 	ldw	ra,4(sp)
8113edc8:	df000017 	ldw	fp,0(sp)
8113edcc:	dec00204 	addi	sp,sp,8
8113edd0:	f800283a 	ret

8113edd4 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113edd4:	defff804 	addi	sp,sp,-32
8113edd8:	de00012e 	bgeu	sp,et,8113ede0 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
8113eddc:	003b68fa 	trap	3
8113ede0:	dfc00715 	stw	ra,28(sp)
8113ede4:	df000615 	stw	fp,24(sp)
8113ede8:	df000604 	addi	fp,sp,24
8113edec:	e13ffc15 	stw	r4,-16(fp)
8113edf0:	e17ffd15 	stw	r5,-12(fp)
8113edf4:	e1bffe15 	stw	r6,-8(fp)
8113edf8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
8113edfc:	e0800317 	ldw	r2,12(fp)
8113ee00:	d8800115 	stw	r2,4(sp)
8113ee04:	e0800217 	ldw	r2,8(fp)
8113ee08:	d8800015 	stw	r2,0(sp)
8113ee0c:	e1ffff17 	ldw	r7,-4(fp)
8113ee10:	e1bffe17 	ldw	r6,-8(fp)
8113ee14:	e17ffd17 	ldw	r5,-12(fp)
8113ee18:	e13ffc17 	ldw	r4,-16(fp)
8113ee1c:	113e3dc0 	call	8113e3dc <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
8113ee20:	e037883a 	mov	sp,fp
8113ee24:	dfc00117 	ldw	ra,4(sp)
8113ee28:	df000017 	ldw	fp,0(sp)
8113ee2c:	dec00204 	addi	sp,sp,8
8113ee30:	f800283a 	ret

8113ee34 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
8113ee34:	defff004 	addi	sp,sp,-64
8113ee38:	de00012e 	bgeu	sp,et,8113ee40 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
8113ee3c:	003b68fa 	trap	3
8113ee40:	dfc00f15 	stw	ra,60(sp)
8113ee44:	df000e15 	stw	fp,56(sp)
8113ee48:	df000e04 	addi	fp,sp,56
8113ee4c:	e13ff915 	stw	r4,-28(fp)
8113ee50:	e17ffa15 	stw	r5,-24(fp)
8113ee54:	e1bffb15 	stw	r6,-20(fp)
8113ee58:	e1fffc15 	stw	r7,-16(fp)
8113ee5c:	e1000317 	ldw	r4,12(fp)
8113ee60:	e0c00417 	ldw	r3,16(fp)
8113ee64:	e0800517 	ldw	r2,20(fp)
8113ee68:	e13ffd0d 	sth	r4,-12(fp)
8113ee6c:	e0fffe05 	stb	r3,-8(fp)
8113ee70:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8113ee74:	e0bffd0b 	ldhu	r2,-12(fp)
8113ee78:	e0fffe03 	ldbu	r3,-8(fp)
8113ee7c:	e13fff0b 	ldhu	r4,-4(fp)
8113ee80:	d9000615 	stw	r4,24(sp)
8113ee84:	d8000515 	stw	zero,20(sp)
8113ee88:	d8c00415 	stw	r3,16(sp)
8113ee8c:	d8000315 	stw	zero,12(sp)
8113ee90:	d8800215 	stw	r2,8(sp)
8113ee94:	e0800217 	ldw	r2,8(fp)
8113ee98:	d8800115 	stw	r2,4(sp)
8113ee9c:	e0bffc17 	ldw	r2,-16(fp)
8113eea0:	d8800015 	stw	r2,0(sp)
8113eea4:	e1fffb17 	ldw	r7,-20(fp)
8113eea8:	000d883a 	mov	r6,zero
8113eeac:	e17ffa17 	ldw	r5,-24(fp)
8113eeb0:	e13ff917 	ldw	r4,-28(fp)
8113eeb4:	113e4700 	call	8113e470 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
8113eeb8:	e037883a 	mov	sp,fp
8113eebc:	dfc00117 	ldw	ra,4(sp)
8113eec0:	df000017 	ldw	fp,0(sp)
8113eec4:	dec00204 	addi	sp,sp,8
8113eec8:	f800283a 	ret

8113eecc <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8113eecc:	defff004 	addi	sp,sp,-64
8113eed0:	de00012e 	bgeu	sp,et,8113eed8 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
8113eed4:	003b68fa 	trap	3
8113eed8:	dfc00f15 	stw	ra,60(sp)
8113eedc:	df000e15 	stw	fp,56(sp)
8113eee0:	df000e04 	addi	fp,sp,56
8113eee4:	e13ff915 	stw	r4,-28(fp)
8113eee8:	e17ffa15 	stw	r5,-24(fp)
8113eeec:	e1bffb15 	stw	r6,-20(fp)
8113eef0:	e1fffc15 	stw	r7,-16(fp)
8113eef4:	e1000317 	ldw	r4,12(fp)
8113eef8:	e0c00417 	ldw	r3,16(fp)
8113eefc:	e0800517 	ldw	r2,20(fp)
8113ef00:	e13ffd0d 	sth	r4,-12(fp)
8113ef04:	e0fffe05 	stb	r3,-8(fp)
8113ef08:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
8113ef0c:	e0bffd0b 	ldhu	r2,-12(fp)
8113ef10:	e0fffe03 	ldbu	r3,-8(fp)
8113ef14:	e13fff0b 	ldhu	r4,-4(fp)
8113ef18:	d8000615 	stw	zero,24(sp)
8113ef1c:	d9000515 	stw	r4,20(sp)
8113ef20:	d8000415 	stw	zero,16(sp)
8113ef24:	d8c00315 	stw	r3,12(sp)
8113ef28:	d8800215 	stw	r2,8(sp)
8113ef2c:	e0800217 	ldw	r2,8(fp)
8113ef30:	d8800115 	stw	r2,4(sp)
8113ef34:	e0bffc17 	ldw	r2,-16(fp)
8113ef38:	d8800015 	stw	r2,0(sp)
8113ef3c:	000f883a 	mov	r7,zero
8113ef40:	e1bffb17 	ldw	r6,-20(fp)
8113ef44:	e17ffa17 	ldw	r5,-24(fp)
8113ef48:	e13ff917 	ldw	r4,-28(fp)
8113ef4c:	113e4700 	call	8113e470 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
8113ef50:	e037883a 	mov	sp,fp
8113ef54:	dfc00117 	ldw	ra,4(sp)
8113ef58:	df000017 	ldw	fp,0(sp)
8113ef5c:	dec00204 	addi	sp,sp,8
8113ef60:	f800283a 	ret

8113ef64 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
8113ef64:	deffee04 	addi	sp,sp,-72
8113ef68:	de00012e 	bgeu	sp,et,8113ef70 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
8113ef6c:	003b68fa 	trap	3
8113ef70:	dfc01115 	stw	ra,68(sp)
8113ef74:	df001015 	stw	fp,64(sp)
8113ef78:	df001004 	addi	fp,sp,64
8113ef7c:	e13ff715 	stw	r4,-36(fp)
8113ef80:	e17ff815 	stw	r5,-32(fp)
8113ef84:	e1bff915 	stw	r6,-28(fp)
8113ef88:	e1fffa15 	stw	r7,-24(fp)
8113ef8c:	e1800417 	ldw	r6,16(fp)
8113ef90:	e1400517 	ldw	r5,20(fp)
8113ef94:	e1000617 	ldw	r4,24(fp)
8113ef98:	e0c00717 	ldw	r3,28(fp)
8113ef9c:	e0800817 	ldw	r2,32(fp)
8113efa0:	e1bffb0d 	sth	r6,-20(fp)
8113efa4:	e17ffc05 	stb	r5,-16(fp)
8113efa8:	e13ffd05 	stb	r4,-12(fp)
8113efac:	e0fffe0d 	sth	r3,-8(fp)
8113efb0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8113efb4:	e0bffb0b 	ldhu	r2,-20(fp)
8113efb8:	e0fffc03 	ldbu	r3,-16(fp)
8113efbc:	e13ffd03 	ldbu	r4,-12(fp)
8113efc0:	e17ffe0b 	ldhu	r5,-8(fp)
8113efc4:	e1bfff0b 	ldhu	r6,-4(fp)
8113efc8:	d9800615 	stw	r6,24(sp)
8113efcc:	d9400515 	stw	r5,20(sp)
8113efd0:	d9000415 	stw	r4,16(sp)
8113efd4:	d8c00315 	stw	r3,12(sp)
8113efd8:	d8800215 	stw	r2,8(sp)
8113efdc:	e0800317 	ldw	r2,12(fp)
8113efe0:	d8800115 	stw	r2,4(sp)
8113efe4:	e0800217 	ldw	r2,8(fp)
8113efe8:	d8800015 	stw	r2,0(sp)
8113efec:	e1fffa17 	ldw	r7,-24(fp)
8113eff0:	e1bff917 	ldw	r6,-28(fp)
8113eff4:	e17ff817 	ldw	r5,-32(fp)
8113eff8:	e13ff717 	ldw	r4,-36(fp)
8113effc:	113e4700 	call	8113e470 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
8113f000:	e037883a 	mov	sp,fp
8113f004:	dfc00117 	ldw	ra,4(sp)
8113f008:	df000017 	ldw	fp,0(sp)
8113f00c:	dec00204 	addi	sp,sp,8
8113f010:	f800283a 	ret

8113f014 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113f014:	defffb04 	addi	sp,sp,-20
8113f018:	de00012e 	bgeu	sp,et,8113f020 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
8113f01c:	003b68fa 	trap	3
8113f020:	df000415 	stw	fp,16(sp)
8113f024:	df000404 	addi	fp,sp,16
8113f028:	e13ffc15 	stw	r4,-16(fp)
8113f02c:	e17ffd15 	stw	r5,-12(fp)
8113f030:	e1bffe15 	stw	r6,-8(fp)
8113f034:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8113f038:	e0bffc17 	ldw	r2,-16(fp)
8113f03c:	10c01217 	ldw	r3,72(r2)
8113f040:	e0800117 	ldw	r2,4(fp)
8113f044:	18800436 	bltu	r3,r2,8113f058 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
8113f048:	e0bffc17 	ldw	r2,-16(fp)
8113f04c:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8113f050:	10803fcc 	andi	r2,r2,255
8113f054:	10000226 	beq	r2,zero,8113f060 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8113f058:	00bffa84 	movi	r2,-22
8113f05c:	00001406 	br	8113f0b0 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
8113f060:	e0bffd17 	ldw	r2,-12(fp)
8113f064:	e0fffe17 	ldw	r3,-8(fp)
8113f068:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8113f06c:	e0bffd17 	ldw	r2,-12(fp)
8113f070:	e0ffff17 	ldw	r3,-4(fp)
8113f074:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8113f078:	e0bffd17 	ldw	r2,-12(fp)
8113f07c:	e0c00117 	ldw	r3,4(fp)
8113f080:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
8113f084:	e0fffd17 	ldw	r3,-12(fp)
8113f088:	e0bffd17 	ldw	r2,-12(fp)
8113f08c:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8113f090:	e0c00217 	ldw	r3,8(fp)
8113f094:	00900034 	movhi	r2,16384
8113f098:	10bfffc4 	addi	r2,r2,-1
8113f09c:	1884703a 	and	r2,r3,r2
8113f0a0:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
8113f0a4:	e0bffd17 	ldw	r2,-12(fp)
8113f0a8:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
8113f0ac:	0005883a 	mov	r2,zero
}
8113f0b0:	e037883a 	mov	sp,fp
8113f0b4:	df000017 	ldw	fp,0(sp)
8113f0b8:	dec00104 	addi	sp,sp,4
8113f0bc:	f800283a 	ret

8113f0c0 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8113f0c0:	defff404 	addi	sp,sp,-48
8113f0c4:	de00012e 	bgeu	sp,et,8113f0cc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8113f0c8:	003b68fa 	trap	3
8113f0cc:	df000b15 	stw	fp,44(sp)
8113f0d0:	df000b04 	addi	fp,sp,44
8113f0d4:	e13ff715 	stw	r4,-36(fp)
8113f0d8:	e17ff815 	stw	r5,-32(fp)
8113f0dc:	e1bff915 	stw	r6,-28(fp)
8113f0e0:	e1fffa15 	stw	r7,-24(fp)
8113f0e4:	e1800517 	ldw	r6,20(fp)
8113f0e8:	e1400617 	ldw	r5,24(fp)
8113f0ec:	e1000717 	ldw	r4,28(fp)
8113f0f0:	e0c00817 	ldw	r3,32(fp)
8113f0f4:	e0800917 	ldw	r2,36(fp)
8113f0f8:	e1bffb0d 	sth	r6,-20(fp)
8113f0fc:	e17ffc05 	stb	r5,-16(fp)
8113f100:	e13ffd05 	stb	r4,-12(fp)
8113f104:	e0fffe0d 	sth	r3,-8(fp)
8113f108:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8113f10c:	e0bff717 	ldw	r2,-36(fp)
8113f110:	10c01217 	ldw	r3,72(r2)
8113f114:	e0800317 	ldw	r2,12(fp)
8113f118:	18801936 	bltu	r3,r2,8113f180 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8113f11c:	e13ff717 	ldw	r4,-36(fp)
8113f120:	20801317 	ldw	r2,76(r4)
8113f124:	20c01417 	ldw	r3,80(r4)
8113f128:	e13ffe0b 	ldhu	r4,-8(fp)
8113f12c:	213fffcc 	andi	r4,r4,65535
8113f130:	2015883a 	mov	r10,r4
8113f134:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8113f138:	1ac01136 	bltu	r3,r11,8113f180 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8113f13c:	58c0011e 	bne	r11,r3,8113f144 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
8113f140:	12800f36 	bltu	r2,r10,8113f180 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8113f144:	e13ff717 	ldw	r4,-36(fp)
8113f148:	20801317 	ldw	r2,76(r4)
8113f14c:	20c01417 	ldw	r3,80(r4)
8113f150:	e13fff0b 	ldhu	r4,-4(fp)
8113f154:	213fffcc 	andi	r4,r4,65535
8113f158:	2011883a 	mov	r8,r4
8113f15c:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
8113f160:	1a400736 	bltu	r3,r9,8113f180 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8113f164:	48c0011e 	bne	r9,r3,8113f16c <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
8113f168:	12000536 	bltu	r2,r8,8113f180 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8113f16c:	e0bff717 	ldw	r2,-36(fp)
8113f170:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8113f174:	10803fcc 	andi	r2,r2,255
8113f178:	10800060 	cmpeqi	r2,r2,1
8113f17c:	1000021e 	bne	r2,zero,8113f188 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
8113f180:	00bffa84 	movi	r2,-22
8113f184:	00003106 	br	8113f24c <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8113f188:	e0bff817 	ldw	r2,-32(fp)
8113f18c:	e0fff917 	ldw	r3,-28(fp)
8113f190:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
8113f194:	e0bff817 	ldw	r2,-32(fp)
8113f198:	e0fffa17 	ldw	r3,-24(fp)
8113f19c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
8113f1a0:	e0bff817 	ldw	r2,-32(fp)
8113f1a4:	e0c00117 	ldw	r3,4(fp)
8113f1a8:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8113f1ac:	e0bff817 	ldw	r2,-32(fp)
8113f1b0:	e0c00217 	ldw	r3,8(fp)
8113f1b4:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8113f1b8:	e0bff817 	ldw	r2,-32(fp)
8113f1bc:	e0c00317 	ldw	r3,12(fp)
8113f1c0:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8113f1c4:	e0bff817 	ldw	r2,-32(fp)
8113f1c8:	e0fffb0b 	ldhu	r3,-20(fp)
8113f1cc:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
8113f1d0:	e0bff817 	ldw	r2,-32(fp)
8113f1d4:	e0fffc03 	ldbu	r3,-16(fp)
8113f1d8:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8113f1dc:	e0bff817 	ldw	r2,-32(fp)
8113f1e0:	e0fffd03 	ldbu	r3,-12(fp)
8113f1e4:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
8113f1e8:	e0bff817 	ldw	r2,-32(fp)
8113f1ec:	e0fffe0b 	ldhu	r3,-8(fp)
8113f1f0:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
8113f1f4:	e0bff817 	ldw	r2,-32(fp)
8113f1f8:	e0ffff0b 	ldhu	r3,-4(fp)
8113f1fc:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
8113f200:	e0bff817 	ldw	r2,-32(fp)
8113f204:	1019883a 	mov	r12,r2
8113f208:	001b883a 	mov	r13,zero
8113f20c:	e33ff515 	stw	r12,-44(fp)
8113f210:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
8113f214:	e0fff517 	ldw	r3,-44(fp)
8113f218:	e0bff817 	ldw	r2,-32(fp)
8113f21c:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
8113f220:	e0fff617 	ldw	r3,-40(fp)
8113f224:	e0bff817 	ldw	r2,-32(fp)
8113f228:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8113f22c:	e0c00417 	ldw	r3,16(fp)
8113f230:	00900034 	movhi	r2,16384
8113f234:	10bfffc4 	addi	r2,r2,-1
8113f238:	1884703a 	and	r2,r3,r2
8113f23c:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
8113f240:	e0bff817 	ldw	r2,-32(fp)
8113f244:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
8113f248:	0005883a 	mov	r2,zero
}
8113f24c:	e037883a 	mov	sp,fp
8113f250:	df000017 	ldw	fp,0(sp)
8113f254:	dec00104 	addi	sp,sp,4
8113f258:	f800283a 	ret

8113f25c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
8113f25c:	defff804 	addi	sp,sp,-32
8113f260:	de00012e 	bgeu	sp,et,8113f268 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
8113f264:	003b68fa 	trap	3
8113f268:	dfc00715 	stw	ra,28(sp)
8113f26c:	df000615 	stw	fp,24(sp)
8113f270:	df000604 	addi	fp,sp,24
8113f274:	e13ffc15 	stw	r4,-16(fp)
8113f278:	e17ffd15 	stw	r5,-12(fp)
8113f27c:	e1bffe15 	stw	r6,-8(fp)
8113f280:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8113f284:	e0800317 	ldw	r2,12(fp)
8113f288:	d8800115 	stw	r2,4(sp)
8113f28c:	e0800217 	ldw	r2,8(fp)
8113f290:	d8800015 	stw	r2,0(sp)
8113f294:	e1ffff17 	ldw	r7,-4(fp)
8113f298:	e1bffe17 	ldw	r6,-8(fp)
8113f29c:	e17ffd17 	ldw	r5,-12(fp)
8113f2a0:	e13ffc17 	ldw	r4,-16(fp)
8113f2a4:	113f0140 	call	8113f014 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8113f2a8:	e037883a 	mov	sp,fp
8113f2ac:	dfc00117 	ldw	ra,4(sp)
8113f2b0:	df000017 	ldw	fp,0(sp)
8113f2b4:	dec00204 	addi	sp,sp,8
8113f2b8:	f800283a 	ret

8113f2bc <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113f2bc:	defff804 	addi	sp,sp,-32
8113f2c0:	de00012e 	bgeu	sp,et,8113f2c8 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
8113f2c4:	003b68fa 	trap	3
8113f2c8:	dfc00715 	stw	ra,28(sp)
8113f2cc:	df000615 	stw	fp,24(sp)
8113f2d0:	df000604 	addi	fp,sp,24
8113f2d4:	e13ffc15 	stw	r4,-16(fp)
8113f2d8:	e17ffd15 	stw	r5,-12(fp)
8113f2dc:	e1bffe15 	stw	r6,-8(fp)
8113f2e0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8113f2e4:	e0800217 	ldw	r2,8(fp)
8113f2e8:	d8800115 	stw	r2,4(sp)
8113f2ec:	e0bfff17 	ldw	r2,-4(fp)
8113f2f0:	d8800015 	stw	r2,0(sp)
8113f2f4:	e1fffe17 	ldw	r7,-8(fp)
8113f2f8:	000d883a 	mov	r6,zero
8113f2fc:	e17ffd17 	ldw	r5,-12(fp)
8113f300:	e13ffc17 	ldw	r4,-16(fp)
8113f304:	113f0140 	call	8113f014 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
8113f308:	e037883a 	mov	sp,fp
8113f30c:	dfc00117 	ldw	ra,4(sp)
8113f310:	df000017 	ldw	fp,0(sp)
8113f314:	dec00204 	addi	sp,sp,8
8113f318:	f800283a 	ret

8113f31c <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
8113f31c:	defff804 	addi	sp,sp,-32
8113f320:	de00012e 	bgeu	sp,et,8113f328 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
8113f324:	003b68fa 	trap	3
8113f328:	dfc00715 	stw	ra,28(sp)
8113f32c:	df000615 	stw	fp,24(sp)
8113f330:	df000604 	addi	fp,sp,24
8113f334:	e13ffc15 	stw	r4,-16(fp)
8113f338:	e17ffd15 	stw	r5,-12(fp)
8113f33c:	e1bffe15 	stw	r6,-8(fp)
8113f340:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8113f344:	e0800217 	ldw	r2,8(fp)
8113f348:	d8800115 	stw	r2,4(sp)
8113f34c:	e0bfff17 	ldw	r2,-4(fp)
8113f350:	d8800015 	stw	r2,0(sp)
8113f354:	000f883a 	mov	r7,zero
8113f358:	e1bffe17 	ldw	r6,-8(fp)
8113f35c:	e17ffd17 	ldw	r5,-12(fp)
8113f360:	e13ffc17 	ldw	r4,-16(fp)
8113f364:	113f0140 	call	8113f014 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
8113f368:	e037883a 	mov	sp,fp
8113f36c:	dfc00117 	ldw	ra,4(sp)
8113f370:	df000017 	ldw	fp,0(sp)
8113f374:	dec00204 	addi	sp,sp,8
8113f378:	f800283a 	ret

8113f37c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
8113f37c:	deffee04 	addi	sp,sp,-72
8113f380:	de00012e 	bgeu	sp,et,8113f388 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
8113f384:	003b68fa 	trap	3
8113f388:	dfc01115 	stw	ra,68(sp)
8113f38c:	df001015 	stw	fp,64(sp)
8113f390:	df001004 	addi	fp,sp,64
8113f394:	e13ff915 	stw	r4,-28(fp)
8113f398:	e17ffa15 	stw	r5,-24(fp)
8113f39c:	e1bffb15 	stw	r6,-20(fp)
8113f3a0:	e1fffc15 	stw	r7,-16(fp)
8113f3a4:	e1000417 	ldw	r4,16(fp)
8113f3a8:	e0c00517 	ldw	r3,20(fp)
8113f3ac:	e0800617 	ldw	r2,24(fp)
8113f3b0:	e13ffd0d 	sth	r4,-12(fp)
8113f3b4:	e0fffe05 	stb	r3,-8(fp)
8113f3b8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8113f3bc:	e0bffd0b 	ldhu	r2,-12(fp)
8113f3c0:	e0fffe03 	ldbu	r3,-8(fp)
8113f3c4:	e13fff0b 	ldhu	r4,-4(fp)
8113f3c8:	d9000815 	stw	r4,32(sp)
8113f3cc:	d8000715 	stw	zero,28(sp)
8113f3d0:	d8c00615 	stw	r3,24(sp)
8113f3d4:	d8000515 	stw	zero,20(sp)
8113f3d8:	d8800415 	stw	r2,16(sp)
8113f3dc:	e0800317 	ldw	r2,12(fp)
8113f3e0:	d8800315 	stw	r2,12(sp)
8113f3e4:	e0800217 	ldw	r2,8(fp)
8113f3e8:	d8800215 	stw	r2,8(sp)
8113f3ec:	e0bffc17 	ldw	r2,-16(fp)
8113f3f0:	d8800115 	stw	r2,4(sp)
8113f3f4:	e0bffb17 	ldw	r2,-20(fp)
8113f3f8:	d8800015 	stw	r2,0(sp)
8113f3fc:	000f883a 	mov	r7,zero
8113f400:	000d883a 	mov	r6,zero
8113f404:	e17ffa17 	ldw	r5,-24(fp)
8113f408:	e13ff917 	ldw	r4,-28(fp)
8113f40c:	113f0c00 	call	8113f0c0 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
8113f410:	e037883a 	mov	sp,fp
8113f414:	dfc00117 	ldw	ra,4(sp)
8113f418:	df000017 	ldw	fp,0(sp)
8113f41c:	dec00204 	addi	sp,sp,8
8113f420:	f800283a 	ret

8113f424 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8113f424:	deffee04 	addi	sp,sp,-72
8113f428:	de00012e 	bgeu	sp,et,8113f430 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
8113f42c:	003b68fa 	trap	3
8113f430:	dfc01115 	stw	ra,68(sp)
8113f434:	df001015 	stw	fp,64(sp)
8113f438:	df001004 	addi	fp,sp,64
8113f43c:	e13ff915 	stw	r4,-28(fp)
8113f440:	e17ffa15 	stw	r5,-24(fp)
8113f444:	e1bffb15 	stw	r6,-20(fp)
8113f448:	e1fffc15 	stw	r7,-16(fp)
8113f44c:	e1000417 	ldw	r4,16(fp)
8113f450:	e0c00517 	ldw	r3,20(fp)
8113f454:	e0800617 	ldw	r2,24(fp)
8113f458:	e13ffd0d 	sth	r4,-12(fp)
8113f45c:	e0fffe05 	stb	r3,-8(fp)
8113f460:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8113f464:	e0bffd0b 	ldhu	r2,-12(fp)
8113f468:	e0fffe03 	ldbu	r3,-8(fp)
8113f46c:	e13fff0b 	ldhu	r4,-4(fp)
8113f470:	d8000815 	stw	zero,32(sp)
8113f474:	d9000715 	stw	r4,28(sp)
8113f478:	d8000615 	stw	zero,24(sp)
8113f47c:	d8c00515 	stw	r3,20(sp)
8113f480:	d8800415 	stw	r2,16(sp)
8113f484:	e0800317 	ldw	r2,12(fp)
8113f488:	d8800315 	stw	r2,12(sp)
8113f48c:	e0800217 	ldw	r2,8(fp)
8113f490:	d8800215 	stw	r2,8(sp)
8113f494:	d8000115 	stw	zero,4(sp)
8113f498:	d8000015 	stw	zero,0(sp)
8113f49c:	e1fffc17 	ldw	r7,-16(fp)
8113f4a0:	e1bffb17 	ldw	r6,-20(fp)
8113f4a4:	e17ffa17 	ldw	r5,-24(fp)
8113f4a8:	e13ff917 	ldw	r4,-28(fp)
8113f4ac:	113f0c00 	call	8113f0c0 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
8113f4b0:	e037883a 	mov	sp,fp
8113f4b4:	dfc00117 	ldw	ra,4(sp)
8113f4b8:	df000017 	ldw	fp,0(sp)
8113f4bc:	dec00204 	addi	sp,sp,8
8113f4c0:	f800283a 	ret

8113f4c4 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8113f4c4:	deffec04 	addi	sp,sp,-80
8113f4c8:	de00012e 	bgeu	sp,et,8113f4d0 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8113f4cc:	003b68fa 	trap	3
8113f4d0:	dfc01315 	stw	ra,76(sp)
8113f4d4:	df001215 	stw	fp,72(sp)
8113f4d8:	df001204 	addi	fp,sp,72
8113f4dc:	e13ff715 	stw	r4,-36(fp)
8113f4e0:	e17ff815 	stw	r5,-32(fp)
8113f4e4:	e1bff915 	stw	r6,-28(fp)
8113f4e8:	e1fffa15 	stw	r7,-24(fp)
8113f4ec:	e1800617 	ldw	r6,24(fp)
8113f4f0:	e1400717 	ldw	r5,28(fp)
8113f4f4:	e1000817 	ldw	r4,32(fp)
8113f4f8:	e0c00917 	ldw	r3,36(fp)
8113f4fc:	e0800a17 	ldw	r2,40(fp)
8113f500:	e1bffb0d 	sth	r6,-20(fp)
8113f504:	e17ffc05 	stb	r5,-16(fp)
8113f508:	e13ffd05 	stb	r4,-12(fp)
8113f50c:	e0fffe0d 	sth	r3,-8(fp)
8113f510:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8113f514:	e0bffb0b 	ldhu	r2,-20(fp)
8113f518:	e0fffc03 	ldbu	r3,-16(fp)
8113f51c:	e13ffd03 	ldbu	r4,-12(fp)
8113f520:	e17ffe0b 	ldhu	r5,-8(fp)
8113f524:	e1bfff0b 	ldhu	r6,-4(fp)
8113f528:	d9800815 	stw	r6,32(sp)
8113f52c:	d9400715 	stw	r5,28(sp)
8113f530:	d9000615 	stw	r4,24(sp)
8113f534:	d8c00515 	stw	r3,20(sp)
8113f538:	d8800415 	stw	r2,16(sp)
8113f53c:	e0800517 	ldw	r2,20(fp)
8113f540:	d8800315 	stw	r2,12(sp)
8113f544:	e0800417 	ldw	r2,16(fp)
8113f548:	d8800215 	stw	r2,8(sp)
8113f54c:	e0800317 	ldw	r2,12(fp)
8113f550:	d8800115 	stw	r2,4(sp)
8113f554:	e0800217 	ldw	r2,8(fp)
8113f558:	d8800015 	stw	r2,0(sp)
8113f55c:	e1fffa17 	ldw	r7,-24(fp)
8113f560:	e1bff917 	ldw	r6,-28(fp)
8113f564:	e17ff817 	ldw	r5,-32(fp)
8113f568:	e13ff717 	ldw	r4,-36(fp)
8113f56c:	113f0c00 	call	8113f0c0 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
8113f570:	e037883a 	mov	sp,fp
8113f574:	dfc00117 	ldw	ra,4(sp)
8113f578:	df000017 	ldw	fp,0(sp)
8113f57c:	dec00204 	addi	sp,sp,8
8113f580:	f800283a 	ret

8113f584 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
8113f584:	defffc04 	addi	sp,sp,-16
8113f588:	de00012e 	bgeu	sp,et,8113f590 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8113f58c:	003b68fa 	trap	3
8113f590:	df000315 	stw	fp,12(sp)
8113f594:	df000304 	addi	fp,sp,12
8113f598:	e13ffe15 	stw	r4,-8(fp)
8113f59c:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
8113f5a0:	e0bfff17 	ldw	r2,-4(fp)
8113f5a4:	1000021e 	bne	r2,zero,8113f5b0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8113f5a8:	00bffa84 	movi	r2,-22
8113f5ac:	00002f06 	br	8113f66c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
8113f5b0:	e0bfff17 	ldw	r2,-4(fp)
8113f5b4:	10c00317 	ldw	r3,12(r2)
8113f5b8:	e0bfff17 	ldw	r2,-4(fp)
8113f5bc:	18800226 	beq	r3,r2,8113f5c8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8113f5c0:	00bffa84 	movi	r2,-22
8113f5c4:	00002906 	br	8113f66c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8113f5c8:	e0bffe17 	ldw	r2,-8(fp)
8113f5cc:	10800017 	ldw	r2,0(r2)
8113f5d0:	1000051e 	bne	r2,zero,8113f5e8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
8113f5d4:	e0bffe17 	ldw	r2,-8(fp)
8113f5d8:	e0ffff17 	ldw	r3,-4(fp)
8113f5dc:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
8113f5e0:	0005883a 	mov	r2,zero
8113f5e4:	00002106 	br	8113f66c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
8113f5e8:	e0bffe17 	ldw	r2,-8(fp)
8113f5ec:	10c00017 	ldw	r3,0(r2)
8113f5f0:	e0bfff17 	ldw	r2,-4(fp)
8113f5f4:	1880021e 	bne	r3,r2,8113f600 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8113f5f8:	00bffa84 	movi	r2,-22
8113f5fc:	00001b06 	br	8113f66c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8113f600:	e0bffe17 	ldw	r2,-8(fp)
8113f604:	10800017 	ldw	r2,0(r2)
8113f608:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8113f60c:	00000906 	br	8113f634 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
8113f610:	e0bffd17 	ldw	r2,-12(fp)
8113f614:	10c00317 	ldw	r3,12(r2)
8113f618:	e0bfff17 	ldw	r2,-4(fp)
8113f61c:	1880021e 	bne	r3,r2,8113f628 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8113f620:	00bffa84 	movi	r2,-22
8113f624:	00001106 	br	8113f66c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8113f628:	e0bffd17 	ldw	r2,-12(fp)
8113f62c:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
8113f630:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8113f634:	e0bffd17 	ldw	r2,-12(fp)
8113f638:	10800317 	ldw	r2,12(r2)
8113f63c:	e0fffe17 	ldw	r3,-8(fp)
8113f640:	18c00017 	ldw	r3,0(r3)
8113f644:	10fff21e 	bne	r2,r3,8113f610 <__reset+0xfb11f610>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8113f648:	e0ffff17 	ldw	r3,-4(fp)
8113f64c:	e0bffd17 	ldw	r2,-12(fp)
8113f650:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
8113f654:	e0bffe17 	ldw	r2,-8(fp)
8113f658:	10800017 	ldw	r2,0(r2)
8113f65c:	1007883a 	mov	r3,r2
8113f660:	e0bfff17 	ldw	r2,-4(fp)
8113f664:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8113f668:	0005883a 	mov	r2,zero
}
8113f66c:	e037883a 	mov	sp,fp
8113f670:	df000017 	ldw	fp,0(sp)
8113f674:	dec00104 	addi	sp,sp,4
8113f678:	f800283a 	ret

8113f67c <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
8113f67c:	defff804 	addi	sp,sp,-32
8113f680:	de00012e 	bgeu	sp,et,8113f688 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
8113f684:	003b68fa 	trap	3
8113f688:	df000715 	stw	fp,28(sp)
8113f68c:	df000704 	addi	fp,sp,28
8113f690:	e13ffe15 	stw	r4,-8(fp)
8113f694:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
8113f698:	e13fff17 	ldw	r4,-4(fp)
8113f69c:	2000021e 	bne	r4,zero,8113f6a8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8113f6a0:	00bffa84 	movi	r2,-22
8113f6a4:	00005906 	br	8113f80c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
8113f6a8:	e13fff17 	ldw	r4,-4(fp)
8113f6ac:	2015883a 	mov	r10,r4
8113f6b0:	0017883a 	mov	r11,zero
8113f6b4:	e2bffc15 	stw	r10,-16(fp)
8113f6b8:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8113f6bc:	e13fff17 	ldw	r4,-4(fp)
8113f6c0:	21400317 	ldw	r5,12(r4)
8113f6c4:	e13ffc17 	ldw	r4,-16(fp)
8113f6c8:	29000626 	beq	r5,r4,8113f6e4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8113f6cc:	e13fff17 	ldw	r4,-4(fp)
8113f6d0:	21400b17 	ldw	r5,44(r4)
8113f6d4:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8113f6d8:	29000226 	beq	r5,r4,8113f6e4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8113f6dc:	00bffa84 	movi	r2,-22
8113f6e0:	00004a06 	br	8113f80c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
8113f6e4:	e13ffe17 	ldw	r4,-8(fp)
8113f6e8:	21000017 	ldw	r4,0(r4)
8113f6ec:	2000051e 	bne	r4,zero,8113f704 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
8113f6f0:	e0bffe17 	ldw	r2,-8(fp)
8113f6f4:	e0ffff17 	ldw	r3,-4(fp)
8113f6f8:	10c00015 	stw	r3,0(r2)
		return 0;
8113f6fc:	0005883a 	mov	r2,zero
8113f700:	00004206 	br	8113f80c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
8113f704:	e13ffe17 	ldw	r4,-8(fp)
8113f708:	21400017 	ldw	r5,0(r4)
8113f70c:	e13fff17 	ldw	r4,-4(fp)
8113f710:	2900021e 	bne	r5,r4,8113f71c <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8113f714:	00bffa84 	movi	r2,-22
8113f718:	00003c06 	br	8113f80c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8113f71c:	e13ffe17 	ldw	r4,-8(fp)
8113f720:	21000017 	ldw	r4,0(r4)
8113f724:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
8113f728:	e13ffe17 	ldw	r4,-8(fp)
8113f72c:	21000017 	ldw	r4,0(r4)
8113f730:	2011883a 	mov	r8,r4
8113f734:	0013883a 	mov	r9,zero
8113f738:	e23ffa15 	stw	r8,-24(fp)
8113f73c:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113f740:	00001806 	br	8113f7a4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
8113f744:	e13fff17 	ldw	r4,-4(fp)
8113f748:	200d883a 	mov	r6,r4
8113f74c:	000f883a 	mov	r7,zero
8113f750:	e1bffc15 	stw	r6,-16(fp)
8113f754:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8113f758:	e13ff917 	ldw	r4,-28(fp)
8113f75c:	21400317 	ldw	r5,12(r4)
8113f760:	e13ffc17 	ldw	r4,-16(fp)
8113f764:	2900061e 	bne	r5,r4,8113f780 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8113f768:	e13ff917 	ldw	r4,-28(fp)
8113f76c:	21400b17 	ldw	r5,44(r4)
8113f770:	e13ffd17 	ldw	r4,-12(fp)
8113f774:	2900021e 	bne	r5,r4,8113f780 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8113f778:	00bffa84 	movi	r2,-22
8113f77c:	00002306 	br	8113f80c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8113f780:	e13ff917 	ldw	r4,-28(fp)
8113f784:	21000317 	ldw	r4,12(r4)
8113f788:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8113f78c:	e13ff917 	ldw	r4,-28(fp)
8113f790:	21000b17 	ldw	r4,44(r4)
8113f794:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8113f798:	e13ffc17 	ldw	r4,-16(fp)
8113f79c:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8113f7a0:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113f7a4:	e13ff917 	ldw	r4,-28(fp)
8113f7a8:	21400317 	ldw	r5,12(r4)
8113f7ac:	e13ffa17 	ldw	r4,-24(fp)
8113f7b0:	29000426 	beq	r5,r4,8113f7c4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8113f7b4:	e13ff917 	ldw	r4,-28(fp)
8113f7b8:	21400b17 	ldw	r5,44(r4)
8113f7bc:	e13ffb17 	ldw	r4,-20(fp)
8113f7c0:	293fe01e 	bne	r5,r4,8113f744 <__reset+0xfb11f744>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
8113f7c4:	e13fff17 	ldw	r4,-4(fp)
8113f7c8:	2005883a 	mov	r2,r4
8113f7cc:	0007883a 	mov	r3,zero
8113f7d0:	e0bffc15 	stw	r2,-16(fp)
8113f7d4:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
8113f7d8:	e0fffc17 	ldw	r3,-16(fp)
8113f7dc:	e0bff917 	ldw	r2,-28(fp)
8113f7e0:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
8113f7e4:	e0fffd17 	ldw	r3,-12(fp)
8113f7e8:	e0bff917 	ldw	r2,-28(fp)
8113f7ec:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
8113f7f0:	e0fffa17 	ldw	r3,-24(fp)
8113f7f4:	e0bfff17 	ldw	r2,-4(fp)
8113f7f8:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
8113f7fc:	e0fffb17 	ldw	r3,-20(fp)
8113f800:	e0bfff17 	ldw	r2,-4(fp)
8113f804:	10c00b15 	stw	r3,44(r2)
	return 0;
8113f808:	0005883a 	mov	r2,zero
}
8113f80c:	e037883a 	mov	sp,fp
8113f810:	df000017 	ldw	fp,0(sp)
8113f814:	dec00104 	addi	sp,sp,4
8113f818:	f800283a 	ret

8113f81c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
8113f81c:	defffc04 	addi	sp,sp,-16
8113f820:	de00012e 	bgeu	sp,et,8113f828 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
8113f824:	003b68fa 	trap	3
8113f828:	df000315 	stw	fp,12(sp)
8113f82c:	df000304 	addi	fp,sp,12
8113f830:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8113f834:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8113f838:	e0bfff17 	ldw	r2,-4(fp)
8113f83c:	1000021e 	bne	r2,zero,8113f848 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8113f840:	00bffa84 	movi	r2,-22
8113f844:	00001906 	br	8113f8ac <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8113f848:	e0bfff17 	ldw	r2,-4(fp)
8113f84c:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8113f850:	00000a06 	br	8113f87c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
8113f854:	e0bffd17 	ldw	r2,-12(fp)
8113f858:	10800717 	ldw	r2,28(r2)
8113f85c:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113f860:	e0bffe17 	ldw	r2,-8(fp)
8113f864:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8113f868:	e0bffd17 	ldw	r2,-12(fp)
8113f86c:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8113f870:	e0bffd17 	ldw	r2,-12(fp)
8113f874:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
8113f878:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8113f87c:	e0bffd17 	ldw	r2,-12(fp)
8113f880:	10c00317 	ldw	r3,12(r2)
8113f884:	e0bfff17 	ldw	r2,-4(fp)
8113f888:	18bff21e 	bne	r3,r2,8113f854 <__reset+0xfb11f854>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
8113f88c:	e0bffd17 	ldw	r2,-12(fp)
8113f890:	10800717 	ldw	r2,28(r2)
8113f894:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113f898:	e0bffe17 	ldw	r2,-8(fp)
8113f89c:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8113f8a0:	e0bffd17 	ldw	r2,-12(fp)
8113f8a4:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8113f8a8:	0005883a 	mov	r2,zero
}
8113f8ac:	e037883a 	mov	sp,fp
8113f8b0:	df000017 	ldw	fp,0(sp)
8113f8b4:	dec00104 	addi	sp,sp,4
8113f8b8:	f800283a 	ret

8113f8bc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
8113f8bc:	defff804 	addi	sp,sp,-32
8113f8c0:	de00012e 	bgeu	sp,et,8113f8c8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
8113f8c4:	003b68fa 	trap	3
8113f8c8:	df000715 	stw	fp,28(sp)
8113f8cc:	df000704 	addi	fp,sp,28
8113f8d0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8113f8d4:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8113f8d8:	e13fff17 	ldw	r4,-4(fp)
8113f8dc:	2000021e 	bne	r4,zero,8113f8e8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
8113f8e0:	00bffa84 	movi	r2,-22
8113f8e4:	00002806 	br	8113f988 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8113f8e8:	e13fff17 	ldw	r4,-4(fp)
8113f8ec:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
8113f8f0:	e13fff17 	ldw	r4,-4(fp)
8113f8f4:	2005883a 	mov	r2,r4
8113f8f8:	0007883a 	mov	r3,zero
8113f8fc:	e0bffb15 	stw	r2,-20(fp)
8113f900:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113f904:	00001006 	br	8113f948 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8113f908:	e0bff917 	ldw	r2,-28(fp)
8113f90c:	10800f17 	ldw	r2,60(r2)
8113f910:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113f914:	e0bffa17 	ldw	r2,-24(fp)
8113f918:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8113f91c:	e0bff917 	ldw	r2,-28(fp)
8113f920:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8113f924:	e0bff917 	ldw	r2,-28(fp)
8113f928:	10800317 	ldw	r2,12(r2)
8113f92c:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8113f930:	e0bff917 	ldw	r2,-28(fp)
8113f934:	10800b17 	ldw	r2,44(r2)
8113f938:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8113f93c:	e0bffd17 	ldw	r2,-12(fp)
8113f940:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8113f944:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8113f948:	e0bff917 	ldw	r2,-28(fp)
8113f94c:	10c00317 	ldw	r3,12(r2)
8113f950:	e0bffb17 	ldw	r2,-20(fp)
8113f954:	18800426 	beq	r3,r2,8113f968 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8113f958:	e0bff917 	ldw	r2,-28(fp)
8113f95c:	10c00b17 	ldw	r3,44(r2)
8113f960:	e0bffc17 	ldw	r2,-16(fp)
8113f964:	18bfe81e 	bne	r3,r2,8113f908 <__reset+0xfb11f908>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8113f968:	e0bff917 	ldw	r2,-28(fp)
8113f96c:	10800f17 	ldw	r2,60(r2)
8113f970:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8113f974:	e0bffa17 	ldw	r2,-24(fp)
8113f978:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8113f97c:	e0bff917 	ldw	r2,-28(fp)
8113f980:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
8113f984:	0005883a 	mov	r2,zero
}
8113f988:	e037883a 	mov	sp,fp
8113f98c:	df000017 	ldw	fp,0(sp)
8113f990:	dec00104 	addi	sp,sp,4
8113f994:	f800283a 	ret

8113f998 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8113f998:	deffeb04 	addi	sp,sp,-84
8113f99c:	de00012e 	bgeu	sp,et,8113f9a4 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
8113f9a0:	003b68fa 	trap	3
8113f9a4:	dfc01415 	stw	ra,80(sp)
8113f9a8:	df001315 	stw	fp,76(sp)
8113f9ac:	df001304 	addi	fp,sp,76
8113f9b0:	e13ffb15 	stw	r4,-20(fp)
8113f9b4:	e17ffc15 	stw	r5,-16(fp)
8113f9b8:	e1bffd15 	stw	r6,-12(fp)
8113f9bc:	3807883a 	mov	r3,r7
8113f9c0:	e0800217 	ldw	r2,8(fp)
8113f9c4:	e0fffe05 	stb	r3,-8(fp)
8113f9c8:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
8113f9cc:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
8113f9d0:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
8113f9d4:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8113f9d8:	e0bffc17 	ldw	r2,-16(fp)
8113f9dc:	e0bff815 	stw	r2,-32(fp)
8113f9e0:	e0bffd17 	ldw	r2,-12(fp)
8113f9e4:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8113f9e8:	e0bffb17 	ldw	r2,-20(fp)
8113f9ec:	10801817 	ldw	r2,96(r2)
8113f9f0:	e0bff615 	stw	r2,-40(fp)
8113f9f4:	e03ff70d 	sth	zero,-36(fp)
8113f9f8:	e0bff70b 	ldhu	r2,-36(fp)
8113f9fc:	e0fffa04 	addi	r3,fp,-24
8113fa00:	180d883a 	mov	r6,r3
8113fa04:	100b883a 	mov	r5,r2
8113fa08:	e13ff617 	ldw	r4,-40(fp)
8113fa0c:	1134cf80 	call	81134cf8 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
8113fa10:	e0bffb17 	ldw	r2,-20(fp)
8113fa14:	10800617 	ldw	r2,24(r2)
8113fa18:	10800037 	ldwio	r2,0(r2)
8113fa1c:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
8113fa20:	e0bfed17 	ldw	r2,-76(fp)
8113fa24:	1080004c 	andi	r2,r2,1
8113fa28:	10000626 	beq	r2,zero,8113fa44 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
8113fa2c:	e0bffb17 	ldw	r2,-20(fp)
8113fa30:	10801817 	ldw	r2,96(r2)
8113fa34:	1009883a 	mov	r4,r2
8113fa38:	11350800 	call	81135080 <OSSemPost>
		return -EBUSY;
8113fa3c:	00bffc04 	movi	r2,-16
8113fa40:	00009606 	br	8113fc9c <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8113fa44:	00800804 	movi	r2,32
8113fa48:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fa4c:	0005303a 	rdctl	r2,status
8113fa50:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fa54:	e0fff217 	ldw	r3,-56(fp)
8113fa58:	00bfff84 	movi	r2,-2
8113fa5c:	1884703a 	and	r2,r3,r2
8113fa60:	1001703a 	wrctl	status,r2
  
  return context;
8113fa64:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8113fa68:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8113fa6c:	e0bffb17 	ldw	r2,-20(fp)
8113fa70:	10800317 	ldw	r2,12(r2)
8113fa74:	10800104 	addi	r2,r2,4
8113fa78:	e0ffee17 	ldw	r3,-72(fp)
8113fa7c:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
8113fa80:	e0bffb17 	ldw	r2,-20(fp)
8113fa84:	10800317 	ldw	r2,12(r2)
8113fa88:	e0fffb17 	ldw	r3,-20(fp)
8113fa8c:	18c00317 	ldw	r3,12(r3)
8113fa90:	18c00037 	ldwio	r3,0(r3)
8113fa94:	10c00035 	stwio	r3,0(r2)
8113fa98:	e0bfef17 	ldw	r2,-68(fp)
8113fa9c:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113faa0:	e0bff017 	ldw	r2,-64(fp)
8113faa4:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
8113faa8:	e0bffb17 	ldw	r2,-20(fp)
8113faac:	10800b17 	ldw	r2,44(r2)
8113fab0:	10002326 	beq	r2,zero,8113fb40 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
8113fab4:	e0bffb17 	ldw	r2,-20(fp)
8113fab8:	10c00d17 	ldw	r3,52(r2)
8113fabc:	e0bfee17 	ldw	r2,-72(fp)
8113fac0:	1884b03a 	or	r2,r3,r2
8113fac4:	10800514 	ori	r2,r2,20
8113fac8:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8113facc:	e0ffee17 	ldw	r3,-72(fp)
8113fad0:	00bff7c4 	movi	r2,-33
8113fad4:	1884703a 	and	r2,r3,r2
8113fad8:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8113fadc:	e0bfed17 	ldw	r2,-76(fp)
8113fae0:	10800214 	ori	r2,r2,8
8113fae4:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fae8:	0005303a 	rdctl	r2,status
8113faec:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113faf0:	e0fff417 	ldw	r3,-48(fp)
8113faf4:	00bfff84 	movi	r2,-2
8113faf8:	1884703a 	and	r2,r3,r2
8113fafc:	1001703a 	wrctl	status,r2
  
  return context;
8113fb00:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
8113fb04:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8113fb08:	e0bffb17 	ldw	r2,-20(fp)
8113fb0c:	10800317 	ldw	r2,12(r2)
8113fb10:	10800104 	addi	r2,r2,4
8113fb14:	e0ffee17 	ldw	r3,-72(fp)
8113fb18:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8113fb1c:	e0bffb17 	ldw	r2,-20(fp)
8113fb20:	10800617 	ldw	r2,24(r2)
8113fb24:	e0ffed17 	ldw	r3,-76(fp)
8113fb28:	10c00035 	stwio	r3,0(r2)
8113fb2c:	e0bfef17 	ldw	r2,-68(fp)
8113fb30:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fb34:	e0bff117 	ldw	r2,-60(fp)
8113fb38:	1001703a 	wrctl	status,r2
8113fb3c:	00002306 	br	8113fbcc <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
8113fb40:	e0bffb17 	ldw	r2,-20(fp)
8113fb44:	10c00d17 	ldw	r3,52(r2)
8113fb48:	e0bfee17 	ldw	r2,-72(fp)
8113fb4c:	1884b03a 	or	r2,r3,r2
8113fb50:	10800114 	ori	r2,r2,4
8113fb54:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8113fb58:	e0ffee17 	ldw	r3,-72(fp)
8113fb5c:	00bff3c4 	movi	r2,-49
8113fb60:	1884703a 	and	r2,r3,r2
8113fb64:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
8113fb68:	e0ffed17 	ldw	r3,-76(fp)
8113fb6c:	00bffdc4 	movi	r2,-9
8113fb70:	1884703a 	and	r2,r3,r2
8113fb74:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fb78:	0005303a 	rdctl	r2,status
8113fb7c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fb80:	e0fff517 	ldw	r3,-44(fp)
8113fb84:	00bfff84 	movi	r2,-2
8113fb88:	1884703a 	and	r2,r3,r2
8113fb8c:	1001703a 	wrctl	status,r2
  
  return context;
8113fb90:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
8113fb94:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8113fb98:	e0bffb17 	ldw	r2,-20(fp)
8113fb9c:	10800317 	ldw	r2,12(r2)
8113fba0:	10800104 	addi	r2,r2,4
8113fba4:	e0ffee17 	ldw	r3,-72(fp)
8113fba8:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8113fbac:	e0bffb17 	ldw	r2,-20(fp)
8113fbb0:	10800617 	ldw	r2,24(r2)
8113fbb4:	e0ffed17 	ldw	r3,-76(fp)
8113fbb8:	10c00035 	stwio	r3,0(r2)
8113fbbc:	e0bfef17 	ldw	r2,-68(fp)
8113fbc0:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fbc4:	e0bff317 	ldw	r2,-52(fp)
8113fbc8:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
8113fbcc:	e0bffb17 	ldw	r2,-20(fp)
8113fbd0:	10800617 	ldw	r2,24(r2)
8113fbd4:	10800104 	addi	r2,r2,4
8113fbd8:	e0fff817 	ldw	r3,-32(fp)
8113fbdc:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
8113fbe0:	e0bffb17 	ldw	r2,-20(fp)
8113fbe4:	10800617 	ldw	r2,24(r2)
8113fbe8:	10800204 	addi	r2,r2,8
8113fbec:	e0fff917 	ldw	r3,-28(fp)
8113fbf0:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
8113fbf4:	e0bffe03 	ldbu	r2,-8(fp)
8113fbf8:	10000426 	beq	r2,zero,8113fc0c <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
8113fbfc:	e0bfed17 	ldw	r2,-76(fp)
8113fc00:	10800414 	ori	r2,r2,16
8113fc04:	e0bfed15 	stw	r2,-76(fp)
8113fc08:	00000406 	br	8113fc1c <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
8113fc0c:	e0ffed17 	ldw	r3,-76(fp)
8113fc10:	00bffbc4 	movi	r2,-17
8113fc14:	1884703a 	and	r2,r3,r2
8113fc18:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
8113fc1c:	e0bfff03 	ldbu	r2,-4(fp)
8113fc20:	10000e26 	beq	r2,zero,8113fc5c <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
8113fc24:	e0bfed17 	ldw	r2,-76(fp)
8113fc28:	10800094 	ori	r2,r2,2
8113fc2c:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8113fc30:	e0bffb17 	ldw	r2,-20(fp)
8113fc34:	10800617 	ldw	r2,24(r2)
8113fc38:	10800304 	addi	r2,r2,12
8113fc3c:	10800037 	ldwio	r2,0(r2)
8113fc40:	10000a1e 	bne	r2,zero,8113fc6c <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8113fc44:	e0bffb17 	ldw	r2,-20(fp)
8113fc48:	10800617 	ldw	r2,24(r2)
8113fc4c:	10800304 	addi	r2,r2,12
8113fc50:	00c03fc4 	movi	r3,255
8113fc54:	10c00035 	stwio	r3,0(r2)
8113fc58:	00000406 	br	8113fc6c <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
8113fc5c:	e0ffed17 	ldw	r3,-76(fp)
8113fc60:	00bfff44 	movi	r2,-3
8113fc64:	1884703a 	and	r2,r3,r2
8113fc68:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
8113fc6c:	e0bfed17 	ldw	r2,-76(fp)
8113fc70:	10800054 	ori	r2,r2,1
8113fc74:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8113fc78:	e0bffb17 	ldw	r2,-20(fp)
8113fc7c:	10800617 	ldw	r2,24(r2)
8113fc80:	e0ffed17 	ldw	r3,-76(fp)
8113fc84:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
8113fc88:	e0bffb17 	ldw	r2,-20(fp)
8113fc8c:	10801817 	ldw	r2,96(r2)
8113fc90:	1009883a 	mov	r4,r2
8113fc94:	11350800 	call	81135080 <OSSemPost>
	 
	 return 0;
8113fc98:	0005883a 	mov	r2,zero
}
8113fc9c:	e037883a 	mov	sp,fp
8113fca0:	dfc00117 	ldw	ra,4(sp)
8113fca4:	df000017 	ldw	fp,0(sp)
8113fca8:	dec00204 	addi	sp,sp,8
8113fcac:	f800283a 	ret

8113fcb0 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
8113fcb0:	defff704 	addi	sp,sp,-36
8113fcb4:	de00012e 	bgeu	sp,et,8113fcbc <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
8113fcb8:	003b68fa 	trap	3
8113fcbc:	dfc00815 	stw	ra,32(sp)
8113fcc0:	df000715 	stw	fp,28(sp)
8113fcc4:	dc400615 	stw	r17,24(sp)
8113fcc8:	dc000515 	stw	r16,20(sp)
8113fccc:	df000704 	addi	fp,sp,28
8113fcd0:	e13ffa15 	stw	r4,-24(fp)
8113fcd4:	e17ffb15 	stw	r5,-20(fp)
8113fcd8:	3007883a 	mov	r3,r6
8113fcdc:	3805883a 	mov	r2,r7
8113fce0:	e0fffc05 	stb	r3,-16(fp)
8113fce4:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8113fce8:	e13ffb17 	ldw	r4,-20(fp)
8113fcec:	113f81c0 	call	8113f81c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
8113fcf0:	10000226 	beq	r2,zero,8113fcfc <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
8113fcf4:	00bffa84 	movi	r2,-22
8113fcf8:	00000b06 	br	8113fd28 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
8113fcfc:	e0bffb17 	ldw	r2,-20(fp)
8113fd00:	1021883a 	mov	r16,r2
8113fd04:	0023883a 	mov	r17,zero
8113fd08:	e0fffc03 	ldbu	r3,-16(fp)
8113fd0c:	e0bffd03 	ldbu	r2,-12(fp)
8113fd10:	d8800015 	stw	r2,0(sp)
8113fd14:	180f883a 	mov	r7,r3
8113fd18:	800b883a 	mov	r5,r16
8113fd1c:	880d883a 	mov	r6,r17
8113fd20:	e13ffa17 	ldw	r4,-24(fp)
8113fd24:	113f9980 	call	8113f998 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8113fd28:	e6fffe04 	addi	sp,fp,-8
8113fd2c:	dfc00317 	ldw	ra,12(sp)
8113fd30:	df000217 	ldw	fp,8(sp)
8113fd34:	dc400117 	ldw	r17,4(sp)
8113fd38:	dc000017 	ldw	r16,0(sp)
8113fd3c:	dec00404 	addi	sp,sp,16
8113fd40:	f800283a 	ret

8113fd44 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8113fd44:	defff704 	addi	sp,sp,-36
8113fd48:	de00012e 	bgeu	sp,et,8113fd50 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
8113fd4c:	003b68fa 	trap	3
8113fd50:	dfc00815 	stw	ra,32(sp)
8113fd54:	df000715 	stw	fp,28(sp)
8113fd58:	dc400615 	stw	r17,24(sp)
8113fd5c:	dc000515 	stw	r16,20(sp)
8113fd60:	df000704 	addi	fp,sp,28
8113fd64:	e13ffa15 	stw	r4,-24(fp)
8113fd68:	e17ffb15 	stw	r5,-20(fp)
8113fd6c:	3007883a 	mov	r3,r6
8113fd70:	3805883a 	mov	r2,r7
8113fd74:	e0fffc05 	stb	r3,-16(fp)
8113fd78:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
8113fd7c:	e13ffb17 	ldw	r4,-20(fp)
8113fd80:	113f8bc0 	call	8113f8bc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
8113fd84:	10000226 	beq	r2,zero,8113fd90 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
8113fd88:	00bffa84 	movi	r2,-22
8113fd8c:	00000b06 	br	8113fdbc <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
8113fd90:	e0bffb17 	ldw	r2,-20(fp)
8113fd94:	1021883a 	mov	r16,r2
8113fd98:	0023883a 	mov	r17,zero
8113fd9c:	e0fffc03 	ldbu	r3,-16(fp)
8113fda0:	e0bffd03 	ldbu	r2,-12(fp)
8113fda4:	d8800015 	stw	r2,0(sp)
8113fda8:	180f883a 	mov	r7,r3
8113fdac:	800b883a 	mov	r5,r16
8113fdb0:	880d883a 	mov	r6,r17
8113fdb4:	e13ffa17 	ldw	r4,-24(fp)
8113fdb8:	113f9980 	call	8113f998 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8113fdbc:	e6fffe04 	addi	sp,fp,-8
8113fdc0:	dfc00317 	ldw	ra,12(sp)
8113fdc4:	df000217 	ldw	fp,8(sp)
8113fdc8:	dc400117 	ldw	r17,4(sp)
8113fdcc:	dc000017 	ldw	r16,0(sp)
8113fdd0:	dec00404 	addi	sp,sp,16
8113fdd4:	f800283a 	ret

8113fdd8 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8113fdd8:	defffc04 	addi	sp,sp,-16
8113fddc:	de00012e 	bgeu	sp,et,8113fde4 <alt_msgdma_open+0xc>
8113fde0:	003b68fa 	trap	3
8113fde4:	dfc00315 	stw	ra,12(sp)
8113fde8:	df000215 	stw	fp,8(sp)
8113fdec:	df000204 	addi	fp,sp,8
8113fdf0:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
8113fdf4:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
8113fdf8:	d1603504 	addi	r5,gp,-32556
8113fdfc:	e13fff17 	ldw	r4,-4(fp)
8113fe00:	114037c0 	call	8114037c <alt_find_dev>
8113fe04:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
8113fe08:	e0bffe17 	ldw	r2,-8(fp)
8113fe0c:	1000041e 	bne	r2,zero,8113fe20 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
8113fe10:	113e03c0 	call	8113e03c <alt_get_errno>
8113fe14:	1007883a 	mov	r3,r2
8113fe18:	008004c4 	movi	r2,19
8113fe1c:	18800015 	stw	r2,0(r3)
    }

    return dev;
8113fe20:	e0bffe17 	ldw	r2,-8(fp)
}
8113fe24:	e037883a 	mov	sp,fp
8113fe28:	dfc00117 	ldw	ra,4(sp)
8113fe2c:	df000017 	ldw	fp,0(sp)
8113fe30:	dec00204 	addi	sp,sp,8
8113fe34:	f800283a 	ret

8113fe38 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
8113fe38:	defff604 	addi	sp,sp,-40
8113fe3c:	de00012e 	bgeu	sp,et,8113fe44 <alt_msgdma_init+0xc>
8113fe40:	003b68fa 	trap	3
8113fe44:	dfc00915 	stw	ra,36(sp)
8113fe48:	df000815 	stw	fp,32(sp)
8113fe4c:	df000804 	addi	fp,sp,32
8113fe50:	e13ffd15 	stw	r4,-12(fp)
8113fe54:	e17ffe15 	stw	r5,-8(fp)
8113fe58:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
8113fe5c:	e0bffd17 	ldw	r2,-12(fp)
8113fe60:	10801783 	ldbu	r2,94(r2)
8113fe64:	10803fcc 	andi	r2,r2,255
8113fe68:	10000b26 	beq	r2,zero,8113fe98 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
8113fe6c:	e0bffd17 	ldw	r2,-12(fp)
8113fe70:	10800617 	ldw	r2,24(r2)
8113fe74:	00c00104 	movi	r3,4
8113fe78:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
8113fe7c:	0001883a 	nop
8113fe80:	e0bffd17 	ldw	r2,-12(fp)
8113fe84:	10800617 	ldw	r2,24(r2)
8113fe88:	10800037 	ldwio	r2,0(r2)
8113fe8c:	1080010c 	andi	r2,r2,4
8113fe90:	1005d0ba 	srai	r2,r2,2
8113fe94:	103ffa1e 	bne	r2,zero,8113fe80 <__reset+0xfb11fe80>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8113fe98:	e0bffd17 	ldw	r2,-12(fp)
8113fe9c:	10800317 	ldw	r2,12(r2)
8113fea0:	10800104 	addi	r2,r2,4
8113fea4:	00c00084 	movi	r3,2
8113fea8:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8113feac:	0001883a 	nop
8113feb0:	e0bffd17 	ldw	r2,-12(fp)
8113feb4:	10800317 	ldw	r2,12(r2)
8113feb8:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
8113febc:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8113fec0:	103ffb1e 	bne	r2,zero,8113feb0 <__reset+0xfb11feb0>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8113fec4:	e0bffd17 	ldw	r2,-12(fp)
8113fec8:	10800317 	ldw	r2,12(r2)
8113fecc:	10800104 	addi	r2,r2,4
8113fed0:	10800037 	ldwio	r2,0(r2)
8113fed4:	1007883a 	mov	r3,r2
8113fed8:	00bffbc4 	movi	r2,-17
8113fedc:	1884703a 	and	r2,r3,r2
8113fee0:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8113fee4:	e0bff917 	ldw	r2,-28(fp)
8113fee8:	10800814 	ori	r2,r2,32
8113feec:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8113fef0:	e0bffd17 	ldw	r2,-12(fp)
8113fef4:	10800317 	ldw	r2,12(r2)
8113fef8:	10800104 	addi	r2,r2,4
8113fefc:	e0fff917 	ldw	r3,-28(fp)
8113ff00:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
8113ff04:	e0bffd17 	ldw	r2,-12(fp)
8113ff08:	10800317 	ldw	r2,12(r2)
8113ff0c:	e0fffd17 	ldw	r3,-12(fp)
8113ff10:	18c00317 	ldw	r3,12(r3)
8113ff14:	18c00037 	ldwio	r3,0(r3)
8113ff18:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
8113ff1c:	e0bffd17 	ldw	r2,-12(fp)
8113ff20:	10801783 	ldbu	r2,94(r2)
8113ff24:	10803fcc 	andi	r2,r2,255
8113ff28:	10000826 	beq	r2,zero,8113ff4c <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
8113ff2c:	e0bffd17 	ldw	r2,-12(fp)
8113ff30:	10800617 	ldw	r2,24(r2)
8113ff34:	10800404 	addi	r2,r2,16
8113ff38:	e0fffd17 	ldw	r3,-12(fp)
8113ff3c:	18c00617 	ldw	r3,24(r3)
8113ff40:	18c00404 	addi	r3,r3,16
8113ff44:	18c00037 	ldwio	r3,0(r3)
8113ff48:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
8113ff4c:	d1603504 	addi	r5,gp,-32556
8113ff50:	e13ffd17 	ldw	r4,-12(fp)
8113ff54:	11402d00 	call	811402d0 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
8113ff58:	e0bffd17 	ldw	r2,-12(fp)
8113ff5c:	10801804 	addi	r2,r2,96
8113ff60:	e0bffb15 	stw	r2,-20(fp)
8113ff64:	00800044 	movi	r2,1
8113ff68:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8113ff6c:	e0bffc0b 	ldhu	r2,-16(fp)
8113ff70:	1009883a 	mov	r4,r2
8113ff74:	11349d00 	call	811349d0 <OSSemCreate>
8113ff78:	1007883a 	mov	r3,r2
8113ff7c:	e0bffb17 	ldw	r2,-20(fp)
8113ff80:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8113ff84:	e0bffb17 	ldw	r2,-20(fp)
8113ff88:	10800017 	ldw	r2,0(r2)
8113ff8c:	10000226 	beq	r2,zero,8113ff98 <alt_msgdma_init+0x160>
8113ff90:	0005883a 	mov	r2,zero
8113ff94:	00000106 	br	8113ff9c <alt_msgdma_init+0x164>
8113ff98:	00bfffc4 	movi	r2,-1
8113ff9c:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
8113ffa0:	e0bffa17 	ldw	r2,-24(fp)
8113ffa4:	1000081e 	bne	r2,zero,8113ffc8 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
8113ffa8:	d8000015 	stw	zero,0(sp)
8113ffac:	e1fffd17 	ldw	r7,-12(fp)
8113ffb0:	01a04534 	movhi	r6,33044
8113ffb4:	31b89404 	addi	r6,r6,-7600
8113ffb8:	e17fff17 	ldw	r5,-4(fp)
8113ffbc:	e13ffe17 	ldw	r4,-8(fp)
8113ffc0:	11406080 	call	81140608 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
8113ffc4:	00000406 	br	8113ffd8 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
8113ffc8:	01204534 	movhi	r4,33044
8113ffcc:	21197b04 	addi	r4,r4,26092
8113ffd0:	1140a200 	call	81140a20 <alt_printf>
    }
    
    return;
8113ffd4:	0001883a 	nop

}
8113ffd8:	e037883a 	mov	sp,fp
8113ffdc:	dfc00117 	ldw	ra,4(sp)
8113ffe0:	df000017 	ldw	fp,0(sp)
8113ffe4:	dec00204 	addi	sp,sp,8
8113ffe8:	f800283a 	ret

8113ffec <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
8113ffec:	defffb04 	addi	sp,sp,-20
8113fff0:	de00012e 	bgeu	sp,et,8113fff8 <alt_msgdma_register_callback+0xc>
8113fff4:	003b68fa 	trap	3
8113fff8:	df000415 	stw	fp,16(sp)
8113fffc:	df000404 	addi	fp,sp,16
81140000:	e13ffc15 	stw	r4,-16(fp)
81140004:	e17ffd15 	stw	r5,-12(fp)
81140008:	e1bffe15 	stw	r6,-8(fp)
8114000c:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81140010:	e0bffc17 	ldw	r2,-16(fp)
81140014:	e0fffd17 	ldw	r3,-12(fp)
81140018:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
8114001c:	e0bffc17 	ldw	r2,-16(fp)
81140020:	e0ffff17 	ldw	r3,-4(fp)
81140024:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
81140028:	e0bffc17 	ldw	r2,-16(fp)
8114002c:	e0fffe17 	ldw	r3,-8(fp)
81140030:	10c00d15 	stw	r3,52(r2)

    return ;
81140034:	0001883a 	nop
}
81140038:	e037883a 	mov	sp,fp
8114003c:	df000017 	ldw	fp,0(sp)
81140040:	dec00104 	addi	sp,sp,4
81140044:	f800283a 	ret

81140048 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81140048:	defffc04 	addi	sp,sp,-16
8114004c:	de00012e 	bgeu	sp,et,81140054 <alt_msgdma_standard_descriptor_async_transfer+0xc>
81140050:	003b68fa 	trap	3
81140054:	dfc00315 	stw	ra,12(sp)
81140058:	df000215 	stw	fp,8(sp)
8114005c:	df000204 	addi	fp,sp,8
81140060:	e13ffe15 	stw	r4,-8(fp)
81140064:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
81140068:	000d883a 	mov	r6,zero
8114006c:	e17fff17 	ldw	r5,-4(fp)
81140070:	e13ffe17 	ldw	r4,-8(fp)
81140074:	113e5cc0 	call	8113e5cc <alt_msgdma_descriptor_async_transfer>

}
81140078:	e037883a 	mov	sp,fp
8114007c:	dfc00117 	ldw	ra,4(sp)
81140080:	df000017 	ldw	fp,0(sp)
81140084:	dec00204 	addi	sp,sp,8
81140088:	f800283a 	ret

8114008c <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114008c:	defffc04 	addi	sp,sp,-16
81140090:	de00012e 	bgeu	sp,et,81140098 <alt_msgdma_extended_descriptor_async_transfer+0xc>
81140094:	003b68fa 	trap	3
81140098:	dfc00315 	stw	ra,12(sp)
8114009c:	df000215 	stw	fp,8(sp)
811400a0:	df000204 	addi	fp,sp,8
811400a4:	e13ffe15 	stw	r4,-8(fp)
811400a8:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
811400ac:	e1bfff17 	ldw	r6,-4(fp)
811400b0:	000b883a 	mov	r5,zero
811400b4:	e13ffe17 	ldw	r4,-8(fp)
811400b8:	113e5cc0 	call	8113e5cc <alt_msgdma_descriptor_async_transfer>
}
811400bc:	e037883a 	mov	sp,fp
811400c0:	dfc00117 	ldw	ra,4(sp)
811400c4:	df000017 	ldw	fp,0(sp)
811400c8:	dec00204 	addi	sp,sp,8
811400cc:	f800283a 	ret

811400d0 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
811400d0:	defffc04 	addi	sp,sp,-16
811400d4:	de00012e 	bgeu	sp,et,811400dc <alt_msgdma_standard_descriptor_sync_transfer+0xc>
811400d8:	003b68fa 	trap	3
811400dc:	dfc00315 	stw	ra,12(sp)
811400e0:	df000215 	stw	fp,8(sp)
811400e4:	df000204 	addi	fp,sp,8
811400e8:	e13ffe15 	stw	r4,-8(fp)
811400ec:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
811400f0:	000d883a 	mov	r6,zero
811400f4:	e17fff17 	ldw	r5,-4(fp)
811400f8:	e13ffe17 	ldw	r4,-8(fp)
811400fc:	113e90c0 	call	8113e90c <alt_msgdma_descriptor_sync_transfer>
}
81140100:	e037883a 	mov	sp,fp
81140104:	dfc00117 	ldw	ra,4(sp)
81140108:	df000017 	ldw	fp,0(sp)
8114010c:	dec00204 	addi	sp,sp,8
81140110:	f800283a 	ret

81140114 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81140114:	defffc04 	addi	sp,sp,-16
81140118:	de00012e 	bgeu	sp,et,81140120 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
8114011c:	003b68fa 	trap	3
81140120:	dfc00315 	stw	ra,12(sp)
81140124:	df000215 	stw	fp,8(sp)
81140128:	df000204 	addi	fp,sp,8
8114012c:	e13ffe15 	stw	r4,-8(fp)
81140130:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
81140134:	e1bfff17 	ldw	r6,-4(fp)
81140138:	000b883a 	mov	r5,zero
8114013c:	e13ffe17 	ldw	r4,-8(fp)
81140140:	113e90c0 	call	8113e90c <alt_msgdma_descriptor_sync_transfer>
}
81140144:	e037883a 	mov	sp,fp
81140148:	dfc00117 	ldw	ra,4(sp)
8114014c:	df000017 	ldw	fp,0(sp)
81140150:	dec00204 	addi	sp,sp,8
81140154:	f800283a 	ret

81140158 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
81140158:	defff504 	addi	sp,sp,-44
8114015c:	de00012e 	bgeu	sp,et,81140164 <alt_alarm_start+0xc>
81140160:	003b68fa 	trap	3
81140164:	df000a15 	stw	fp,40(sp)
81140168:	df000a04 	addi	fp,sp,40
8114016c:	e13ffc15 	stw	r4,-16(fp)
81140170:	e17ffd15 	stw	r5,-12(fp)
81140174:	e1bffe15 	stw	r6,-8(fp)
81140178:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8114017c:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81140180:	d0a07917 	ldw	r2,-32284(gp)
  
  if (alt_ticks_per_second ())
81140184:	10003c26 	beq	r2,zero,81140278 <alt_alarm_start+0x120>
  {
    if (alarm)
81140188:	e0bffc17 	ldw	r2,-16(fp)
8114018c:	10003826 	beq	r2,zero,81140270 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81140190:	e0bffc17 	ldw	r2,-16(fp)
81140194:	e0fffe17 	ldw	r3,-8(fp)
81140198:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8114019c:	e0bffc17 	ldw	r2,-16(fp)
811401a0:	e0ffff17 	ldw	r3,-4(fp)
811401a4:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811401a8:	0005303a 	rdctl	r2,status
811401ac:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811401b0:	e0fff917 	ldw	r3,-28(fp)
811401b4:	00bfff84 	movi	r2,-2
811401b8:	1884703a 	and	r2,r3,r2
811401bc:	1001703a 	wrctl	status,r2
  
  return context;
811401c0:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
811401c4:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
811401c8:	d0a07a17 	ldw	r2,-32280(gp)
      
      current_nticks = alt_nticks();
811401cc:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
811401d0:	e0fffd17 	ldw	r3,-12(fp)
811401d4:	e0bff617 	ldw	r2,-40(fp)
811401d8:	1885883a 	add	r2,r3,r2
811401dc:	10c00044 	addi	r3,r2,1
811401e0:	e0bffc17 	ldw	r2,-16(fp)
811401e4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
811401e8:	e0bffc17 	ldw	r2,-16(fp)
811401ec:	10c00217 	ldw	r3,8(r2)
811401f0:	e0bff617 	ldw	r2,-40(fp)
811401f4:	1880042e 	bgeu	r3,r2,81140208 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
811401f8:	e0bffc17 	ldw	r2,-16(fp)
811401fc:	00c00044 	movi	r3,1
81140200:	10c00405 	stb	r3,16(r2)
81140204:	00000206 	br	81140210 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
81140208:	e0bffc17 	ldw	r2,-16(fp)
8114020c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
81140210:	e0bffc17 	ldw	r2,-16(fp)
81140214:	d0e01404 	addi	r3,gp,-32688
81140218:	e0fffa15 	stw	r3,-24(fp)
8114021c:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81140220:	e0bffb17 	ldw	r2,-20(fp)
81140224:	e0fffa17 	ldw	r3,-24(fp)
81140228:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114022c:	e0bffa17 	ldw	r2,-24(fp)
81140230:	10c00017 	ldw	r3,0(r2)
81140234:	e0bffb17 	ldw	r2,-20(fp)
81140238:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114023c:	e0bffa17 	ldw	r2,-24(fp)
81140240:	10800017 	ldw	r2,0(r2)
81140244:	e0fffb17 	ldw	r3,-20(fp)
81140248:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114024c:	e0bffa17 	ldw	r2,-24(fp)
81140250:	e0fffb17 	ldw	r3,-20(fp)
81140254:	10c00015 	stw	r3,0(r2)
81140258:	e0bff817 	ldw	r2,-32(fp)
8114025c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140260:	e0bff717 	ldw	r2,-36(fp)
81140264:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
81140268:	0005883a 	mov	r2,zero
8114026c:	00000306 	br	8114027c <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81140270:	00bffa84 	movi	r2,-22
81140274:	00000106 	br	8114027c <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
81140278:	00bfde84 	movi	r2,-134
  }
}
8114027c:	e037883a 	mov	sp,fp
81140280:	df000017 	ldw	fp,0(sp)
81140284:	dec00104 	addi	sp,sp,4
81140288:	f800283a 	ret

8114028c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114028c:	defffe04 	addi	sp,sp,-8
81140290:	de00012e 	bgeu	sp,et,81140298 <alt_get_errno+0xc>
81140294:	003b68fa 	trap	3
81140298:	dfc00115 	stw	ra,4(sp)
8114029c:	df000015 	stw	fp,0(sp)
811402a0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811402a4:	d0a01017 	ldw	r2,-32704(gp)
811402a8:	10000326 	beq	r2,zero,811402b8 <alt_get_errno+0x2c>
811402ac:	d0a01017 	ldw	r2,-32704(gp)
811402b0:	103ee83a 	callr	r2
811402b4:	00000106 	br	811402bc <alt_get_errno+0x30>
811402b8:	d0a06904 	addi	r2,gp,-32348
}
811402bc:	e037883a 	mov	sp,fp
811402c0:	dfc00117 	ldw	ra,4(sp)
811402c4:	df000017 	ldw	fp,0(sp)
811402c8:	dec00204 	addi	sp,sp,8
811402cc:	f800283a 	ret

811402d0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
811402d0:	defffa04 	addi	sp,sp,-24
811402d4:	de00012e 	bgeu	sp,et,811402dc <alt_dev_llist_insert+0xc>
811402d8:	003b68fa 	trap	3
811402dc:	dfc00515 	stw	ra,20(sp)
811402e0:	df000415 	stw	fp,16(sp)
811402e4:	df000404 	addi	fp,sp,16
811402e8:	e13ffe15 	stw	r4,-8(fp)
811402ec:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
811402f0:	e0bffe17 	ldw	r2,-8(fp)
811402f4:	10000326 	beq	r2,zero,81140304 <alt_dev_llist_insert+0x34>
811402f8:	e0bffe17 	ldw	r2,-8(fp)
811402fc:	10800217 	ldw	r2,8(r2)
81140300:	1000061e 	bne	r2,zero,8114031c <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
81140304:	114028c0 	call	8114028c <alt_get_errno>
81140308:	1007883a 	mov	r3,r2
8114030c:	00800584 	movi	r2,22
81140310:	18800015 	stw	r2,0(r3)
    return -EINVAL;
81140314:	00bffa84 	movi	r2,-22
81140318:	00001306 	br	81140368 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8114031c:	e0bffe17 	ldw	r2,-8(fp)
81140320:	e0ffff17 	ldw	r3,-4(fp)
81140324:	e0fffc15 	stw	r3,-16(fp)
81140328:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114032c:	e0bffd17 	ldw	r2,-12(fp)
81140330:	e0fffc17 	ldw	r3,-16(fp)
81140334:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81140338:	e0bffc17 	ldw	r2,-16(fp)
8114033c:	10c00017 	ldw	r3,0(r2)
81140340:	e0bffd17 	ldw	r2,-12(fp)
81140344:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81140348:	e0bffc17 	ldw	r2,-16(fp)
8114034c:	10800017 	ldw	r2,0(r2)
81140350:	e0fffd17 	ldw	r3,-12(fp)
81140354:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81140358:	e0bffc17 	ldw	r2,-16(fp)
8114035c:	e0fffd17 	ldw	r3,-12(fp)
81140360:	10c00015 	stw	r3,0(r2)

  return 0;  
81140364:	0005883a 	mov	r2,zero
}
81140368:	e037883a 	mov	sp,fp
8114036c:	dfc00117 	ldw	ra,4(sp)
81140370:	df000017 	ldw	fp,0(sp)
81140374:	dec00204 	addi	sp,sp,8
81140378:	f800283a 	ret

8114037c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8114037c:	defffa04 	addi	sp,sp,-24
81140380:	de00012e 	bgeu	sp,et,81140388 <alt_find_dev+0xc>
81140384:	003b68fa 	trap	3
81140388:	dfc00515 	stw	ra,20(sp)
8114038c:	df000415 	stw	fp,16(sp)
81140390:	df000404 	addi	fp,sp,16
81140394:	e13ffe15 	stw	r4,-8(fp)
81140398:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114039c:	e0bfff17 	ldw	r2,-4(fp)
811403a0:	10800017 	ldw	r2,0(r2)
811403a4:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
811403a8:	e13ffe17 	ldw	r4,-8(fp)
811403ac:	11187c00 	call	811187c0 <strlen>
811403b0:	10800044 	addi	r2,r2,1
811403b4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
811403b8:	00000d06 	br	811403f0 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
811403bc:	e0bffc17 	ldw	r2,-16(fp)
811403c0:	10800217 	ldw	r2,8(r2)
811403c4:	e0fffd17 	ldw	r3,-12(fp)
811403c8:	180d883a 	mov	r6,r3
811403cc:	e17ffe17 	ldw	r5,-8(fp)
811403d0:	1009883a 	mov	r4,r2
811403d4:	11411900 	call	81141190 <memcmp>
811403d8:	1000021e 	bne	r2,zero,811403e4 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
811403dc:	e0bffc17 	ldw	r2,-16(fp)
811403e0:	00000706 	br	81140400 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
811403e4:	e0bffc17 	ldw	r2,-16(fp)
811403e8:	10800017 	ldw	r2,0(r2)
811403ec:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
811403f0:	e0fffc17 	ldw	r3,-16(fp)
811403f4:	e0bfff17 	ldw	r2,-4(fp)
811403f8:	18bff01e 	bne	r3,r2,811403bc <__reset+0xfb1203bc>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
811403fc:	0005883a 	mov	r2,zero
}
81140400:	e037883a 	mov	sp,fp
81140404:	dfc00117 	ldw	ra,4(sp)
81140408:	df000017 	ldw	fp,0(sp)
8114040c:	dec00204 	addi	sp,sp,8
81140410:	f800283a 	ret

81140414 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
81140414:	defffb04 	addi	sp,sp,-20
81140418:	de00012e 	bgeu	sp,et,81140420 <alt_find_file+0xc>
8114041c:	003b68fa 	trap	3
81140420:	dfc00415 	stw	ra,16(sp)
81140424:	df000315 	stw	fp,12(sp)
81140428:	df000304 	addi	fp,sp,12
8114042c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
81140430:	d0a00b17 	ldw	r2,-32724(gp)
81140434:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81140438:	00003106 	br	81140500 <alt_find_file+0xec>
  {
    len = strlen(next->name);
8114043c:	e0bffd17 	ldw	r2,-12(fp)
81140440:	10800217 	ldw	r2,8(r2)
81140444:	1009883a 	mov	r4,r2
81140448:	11187c00 	call	811187c0 <strlen>
8114044c:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
81140450:	e0bffd17 	ldw	r2,-12(fp)
81140454:	10c00217 	ldw	r3,8(r2)
81140458:	e0bffe17 	ldw	r2,-8(fp)
8114045c:	10bfffc4 	addi	r2,r2,-1
81140460:	1885883a 	add	r2,r3,r2
81140464:	10800003 	ldbu	r2,0(r2)
81140468:	10803fcc 	andi	r2,r2,255
8114046c:	1080201c 	xori	r2,r2,128
81140470:	10bfe004 	addi	r2,r2,-128
81140474:	10800bd8 	cmpnei	r2,r2,47
81140478:	1000031e 	bne	r2,zero,81140488 <alt_find_file+0x74>
    {
      len -= 1;
8114047c:	e0bffe17 	ldw	r2,-8(fp)
81140480:	10bfffc4 	addi	r2,r2,-1
81140484:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81140488:	e0bffe17 	ldw	r2,-8(fp)
8114048c:	e0ffff17 	ldw	r3,-4(fp)
81140490:	1885883a 	add	r2,r3,r2
81140494:	10800003 	ldbu	r2,0(r2)
81140498:	10803fcc 	andi	r2,r2,255
8114049c:	1080201c 	xori	r2,r2,128
811404a0:	10bfe004 	addi	r2,r2,-128
811404a4:	10800be0 	cmpeqi	r2,r2,47
811404a8:	1000081e 	bne	r2,zero,811404cc <alt_find_file+0xb8>
811404ac:	e0bffe17 	ldw	r2,-8(fp)
811404b0:	e0ffff17 	ldw	r3,-4(fp)
811404b4:	1885883a 	add	r2,r3,r2
811404b8:	10800003 	ldbu	r2,0(r2)
811404bc:	10803fcc 	andi	r2,r2,255
811404c0:	1080201c 	xori	r2,r2,128
811404c4:	10bfe004 	addi	r2,r2,-128
811404c8:	10000a1e 	bne	r2,zero,811404f4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
811404cc:	e0bffd17 	ldw	r2,-12(fp)
811404d0:	10800217 	ldw	r2,8(r2)
811404d4:	e0fffe17 	ldw	r3,-8(fp)
811404d8:	180d883a 	mov	r6,r3
811404dc:	e17fff17 	ldw	r5,-4(fp)
811404e0:	1009883a 	mov	r4,r2
811404e4:	11411900 	call	81141190 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
811404e8:	1000021e 	bne	r2,zero,811404f4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
811404ec:	e0bffd17 	ldw	r2,-12(fp)
811404f0:	00000706 	br	81140510 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
811404f4:	e0bffd17 	ldw	r2,-12(fp)
811404f8:	10800017 	ldw	r2,0(r2)
811404fc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81140500:	e0fffd17 	ldw	r3,-12(fp)
81140504:	d0a00b04 	addi	r2,gp,-32724
81140508:	18bfcc1e 	bne	r3,r2,8114043c <__reset+0xfb12043c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8114050c:	0005883a 	mov	r2,zero
}
81140510:	e037883a 	mov	sp,fp
81140514:	dfc00117 	ldw	ra,4(sp)
81140518:	df000017 	ldw	fp,0(sp)
8114051c:	dec00204 	addi	sp,sp,8
81140520:	f800283a 	ret

81140524 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
81140524:	defff904 	addi	sp,sp,-28
81140528:	de00012e 	bgeu	sp,et,81140530 <alt_get_fd+0xc>
8114052c:	003b68fa 	trap	3
81140530:	dfc00615 	stw	ra,24(sp)
81140534:	df000515 	stw	fp,20(sp)
81140538:	df000504 	addi	fp,sp,20
8114053c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
81140540:	00bffa04 	movi	r2,-24
81140544:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
81140548:	d0a07017 	ldw	r2,-32320(gp)
8114054c:	e0bffd15 	stw	r2,-12(fp)
81140550:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81140554:	e0bffe0b 	ldhu	r2,-8(fp)
81140558:	e0fffe84 	addi	r3,fp,-6
8114055c:	180d883a 	mov	r6,r3
81140560:	100b883a 	mov	r5,r2
81140564:	e13ffd17 	ldw	r4,-12(fp)
81140568:	1134cf80 	call	81134cf8 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114056c:	e03ffb15 	stw	zero,-20(fp)
81140570:	00001906 	br	811405d8 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
81140574:	00a04534 	movhi	r2,33044
81140578:	109bea04 	addi	r2,r2,28584
8114057c:	e0fffb17 	ldw	r3,-20(fp)
81140580:	18c00324 	muli	r3,r3,12
81140584:	10c5883a 	add	r2,r2,r3
81140588:	10800017 	ldw	r2,0(r2)
8114058c:	10000f1e 	bne	r2,zero,811405cc <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
81140590:	00a04534 	movhi	r2,33044
81140594:	109bea04 	addi	r2,r2,28584
81140598:	e0fffb17 	ldw	r3,-20(fp)
8114059c:	18c00324 	muli	r3,r3,12
811405a0:	10c5883a 	add	r2,r2,r3
811405a4:	e0ffff17 	ldw	r3,-4(fp)
811405a8:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
811405ac:	d0e00f17 	ldw	r3,-32708(gp)
811405b0:	e0bffb17 	ldw	r2,-20(fp)
811405b4:	1880020e 	bge	r3,r2,811405c0 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
811405b8:	e0bffb17 	ldw	r2,-20(fp)
811405bc:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
811405c0:	e0bffb17 	ldw	r2,-20(fp)
811405c4:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
811405c8:	00000606 	br	811405e4 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
811405cc:	e0bffb17 	ldw	r2,-20(fp)
811405d0:	10800044 	addi	r2,r2,1
811405d4:	e0bffb15 	stw	r2,-20(fp)
811405d8:	e0bffb17 	ldw	r2,-20(fp)
811405dc:	10800810 	cmplti	r2,r2,32
811405e0:	103fe41e 	bne	r2,zero,81140574 <__reset+0xfb120574>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
811405e4:	d0a07017 	ldw	r2,-32320(gp)
811405e8:	1009883a 	mov	r4,r2
811405ec:	11350800 	call	81135080 <OSSemPost>

  return rc;
811405f0:	e0bffc17 	ldw	r2,-16(fp)
}
811405f4:	e037883a 	mov	sp,fp
811405f8:	dfc00117 	ldw	ra,4(sp)
811405fc:	df000017 	ldw	fp,0(sp)
81140600:	dec00204 	addi	sp,sp,8
81140604:	f800283a 	ret

81140608 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81140608:	defff904 	addi	sp,sp,-28
8114060c:	de00012e 	bgeu	sp,et,81140614 <alt_ic_isr_register+0xc>
81140610:	003b68fa 	trap	3
81140614:	dfc00615 	stw	ra,24(sp)
81140618:	df000515 	stw	fp,20(sp)
8114061c:	df000504 	addi	fp,sp,20
81140620:	e13ffc15 	stw	r4,-16(fp)
81140624:	e17ffd15 	stw	r5,-12(fp)
81140628:	e1bffe15 	stw	r6,-8(fp)
8114062c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
81140630:	e0800217 	ldw	r2,8(fp)
81140634:	d8800015 	stw	r2,0(sp)
81140638:	e1ffff17 	ldw	r7,-4(fp)
8114063c:	e1bffe17 	ldw	r6,-8(fp)
81140640:	e17ffd17 	ldw	r5,-12(fp)
81140644:	e13ffc17 	ldw	r4,-16(fp)
81140648:	11407d80 	call	811407d8 <alt_iic_isr_register>
}  
8114064c:	e037883a 	mov	sp,fp
81140650:	dfc00117 	ldw	ra,4(sp)
81140654:	df000017 	ldw	fp,0(sp)
81140658:	dec00204 	addi	sp,sp,8
8114065c:	f800283a 	ret

81140660 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
81140660:	defff904 	addi	sp,sp,-28
81140664:	de00012e 	bgeu	sp,et,8114066c <alt_ic_irq_enable+0xc>
81140668:	003b68fa 	trap	3
8114066c:	df000615 	stw	fp,24(sp)
81140670:	df000604 	addi	fp,sp,24
81140674:	e13ffe15 	stw	r4,-8(fp)
81140678:	e17fff15 	stw	r5,-4(fp)
8114067c:	e0bfff17 	ldw	r2,-4(fp)
81140680:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140684:	0005303a 	rdctl	r2,status
81140688:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114068c:	e0fffb17 	ldw	r3,-20(fp)
81140690:	00bfff84 	movi	r2,-2
81140694:	1884703a 	and	r2,r3,r2
81140698:	1001703a 	wrctl	status,r2
  
  return context;
8114069c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811406a0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
811406a4:	00c00044 	movi	r3,1
811406a8:	e0bffa17 	ldw	r2,-24(fp)
811406ac:	1884983a 	sll	r2,r3,r2
811406b0:	1007883a 	mov	r3,r2
811406b4:	d0a07117 	ldw	r2,-32316(gp)
811406b8:	1884b03a 	or	r2,r3,r2
811406bc:	d0a07115 	stw	r2,-32316(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811406c0:	d0a07117 	ldw	r2,-32316(gp)
811406c4:	100170fa 	wrctl	ienable,r2
811406c8:	e0bffc17 	ldw	r2,-16(fp)
811406cc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811406d0:	e0bffd17 	ldw	r2,-12(fp)
811406d4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811406d8:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
811406dc:	0001883a 	nop
}
811406e0:	e037883a 	mov	sp,fp
811406e4:	df000017 	ldw	fp,0(sp)
811406e8:	dec00104 	addi	sp,sp,4
811406ec:	f800283a 	ret

811406f0 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
811406f0:	defff904 	addi	sp,sp,-28
811406f4:	de00012e 	bgeu	sp,et,811406fc <alt_ic_irq_disable+0xc>
811406f8:	003b68fa 	trap	3
811406fc:	df000615 	stw	fp,24(sp)
81140700:	df000604 	addi	fp,sp,24
81140704:	e13ffe15 	stw	r4,-8(fp)
81140708:	e17fff15 	stw	r5,-4(fp)
8114070c:	e0bfff17 	ldw	r2,-4(fp)
81140710:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140714:	0005303a 	rdctl	r2,status
81140718:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114071c:	e0fffb17 	ldw	r3,-20(fp)
81140720:	00bfff84 	movi	r2,-2
81140724:	1884703a 	and	r2,r3,r2
81140728:	1001703a 	wrctl	status,r2
  
  return context;
8114072c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81140730:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
81140734:	00c00044 	movi	r3,1
81140738:	e0bffa17 	ldw	r2,-24(fp)
8114073c:	1884983a 	sll	r2,r3,r2
81140740:	0084303a 	nor	r2,zero,r2
81140744:	1007883a 	mov	r3,r2
81140748:	d0a07117 	ldw	r2,-32316(gp)
8114074c:	1884703a 	and	r2,r3,r2
81140750:	d0a07115 	stw	r2,-32316(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81140754:	d0a07117 	ldw	r2,-32316(gp)
81140758:	100170fa 	wrctl	ienable,r2
8114075c:	e0bffc17 	ldw	r2,-16(fp)
81140760:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140764:	e0bffd17 	ldw	r2,-12(fp)
81140768:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114076c:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
81140770:	0001883a 	nop
}
81140774:	e037883a 	mov	sp,fp
81140778:	df000017 	ldw	fp,0(sp)
8114077c:	dec00104 	addi	sp,sp,4
81140780:	f800283a 	ret

81140784 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
81140784:	defffc04 	addi	sp,sp,-16
81140788:	de00012e 	bgeu	sp,et,81140790 <alt_ic_irq_enabled+0xc>
8114078c:	003b68fa 	trap	3
81140790:	df000315 	stw	fp,12(sp)
81140794:	df000304 	addi	fp,sp,12
81140798:	e13ffe15 	stw	r4,-8(fp)
8114079c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
811407a0:	000530fa 	rdctl	r2,ienable
811407a4:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
811407a8:	00c00044 	movi	r3,1
811407ac:	e0bfff17 	ldw	r2,-4(fp)
811407b0:	1884983a 	sll	r2,r3,r2
811407b4:	1007883a 	mov	r3,r2
811407b8:	e0bffd17 	ldw	r2,-12(fp)
811407bc:	1884703a 	and	r2,r3,r2
811407c0:	1004c03a 	cmpne	r2,r2,zero
811407c4:	10803fcc 	andi	r2,r2,255
}
811407c8:	e037883a 	mov	sp,fp
811407cc:	df000017 	ldw	fp,0(sp)
811407d0:	dec00104 	addi	sp,sp,4
811407d4:	f800283a 	ret

811407d8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
811407d8:	defff504 	addi	sp,sp,-44
811407dc:	de00012e 	bgeu	sp,et,811407e4 <alt_iic_isr_register+0xc>
811407e0:	003b68fa 	trap	3
811407e4:	dfc00a15 	stw	ra,40(sp)
811407e8:	df000915 	stw	fp,36(sp)
811407ec:	df000904 	addi	fp,sp,36
811407f0:	e13ffc15 	stw	r4,-16(fp)
811407f4:	e17ffd15 	stw	r5,-12(fp)
811407f8:	e1bffe15 	stw	r6,-8(fp)
811407fc:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
81140800:	00bffa84 	movi	r2,-22
81140804:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
81140808:	e0bffd17 	ldw	r2,-12(fp)
8114080c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81140810:	e0bff817 	ldw	r2,-32(fp)
81140814:	10800808 	cmpgei	r2,r2,32
81140818:	1000271e 	bne	r2,zero,811408b8 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114081c:	0005303a 	rdctl	r2,status
81140820:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140824:	e0fffb17 	ldw	r3,-20(fp)
81140828:	00bfff84 	movi	r2,-2
8114082c:	1884703a 	and	r2,r3,r2
81140830:	1001703a 	wrctl	status,r2
  
  return context;
81140834:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
81140838:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8114083c:	00a045b4 	movhi	r2,33046
81140840:	1089a404 	addi	r2,r2,9872
81140844:	e0fff817 	ldw	r3,-32(fp)
81140848:	180690fa 	slli	r3,r3,3
8114084c:	10c5883a 	add	r2,r2,r3
81140850:	e0fffe17 	ldw	r3,-8(fp)
81140854:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
81140858:	00a045b4 	movhi	r2,33046
8114085c:	1089a404 	addi	r2,r2,9872
81140860:	e0fff817 	ldw	r3,-32(fp)
81140864:	180690fa 	slli	r3,r3,3
81140868:	10c5883a 	add	r2,r2,r3
8114086c:	10800104 	addi	r2,r2,4
81140870:	e0ffff17 	ldw	r3,-4(fp)
81140874:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
81140878:	e0bffe17 	ldw	r2,-8(fp)
8114087c:	10000526 	beq	r2,zero,81140894 <alt_iic_isr_register+0xbc>
81140880:	e0bff817 	ldw	r2,-32(fp)
81140884:	100b883a 	mov	r5,r2
81140888:	e13ffc17 	ldw	r4,-16(fp)
8114088c:	11406600 	call	81140660 <alt_ic_irq_enable>
81140890:	00000406 	br	811408a4 <alt_iic_isr_register+0xcc>
81140894:	e0bff817 	ldw	r2,-32(fp)
81140898:	100b883a 	mov	r5,r2
8114089c:	e13ffc17 	ldw	r4,-16(fp)
811408a0:	11406f00 	call	811406f0 <alt_ic_irq_disable>
811408a4:	e0bff715 	stw	r2,-36(fp)
811408a8:	e0bffa17 	ldw	r2,-24(fp)
811408ac:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811408b0:	e0bff917 	ldw	r2,-28(fp)
811408b4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
811408b8:	e0bff717 	ldw	r2,-36(fp)
}
811408bc:	e037883a 	mov	sp,fp
811408c0:	dfc00117 	ldw	ra,4(sp)
811408c4:	df000017 	ldw	fp,0(sp)
811408c8:	dec00204 	addi	sp,sp,8
811408cc:	f800283a 	ret

811408d0 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
811408d0:	defff904 	addi	sp,sp,-28
811408d4:	de00012e 	bgeu	sp,et,811408dc <alt_open_fd+0xc>
811408d8:	003b68fa 	trap	3
811408dc:	dfc00615 	stw	ra,24(sp)
811408e0:	df000515 	stw	fp,20(sp)
811408e4:	df000504 	addi	fp,sp,20
811408e8:	e13ffc15 	stw	r4,-16(fp)
811408ec:	e17ffd15 	stw	r5,-12(fp)
811408f0:	e1bffe15 	stw	r6,-8(fp)
811408f4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
811408f8:	e1bfff17 	ldw	r6,-4(fp)
811408fc:	e17ffe17 	ldw	r5,-8(fp)
81140900:	e13ffd17 	ldw	r4,-12(fp)
81140904:	112d9340 	call	8112d934 <open>
81140908:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114090c:	e0bffb17 	ldw	r2,-20(fp)
81140910:	10001c16 	blt	r2,zero,81140984 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
81140914:	00a04534 	movhi	r2,33044
81140918:	109bea04 	addi	r2,r2,28584
8114091c:	e0fffb17 	ldw	r3,-20(fp)
81140920:	18c00324 	muli	r3,r3,12
81140924:	10c5883a 	add	r2,r2,r3
81140928:	10c00017 	ldw	r3,0(r2)
8114092c:	e0bffc17 	ldw	r2,-16(fp)
81140930:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
81140934:	00a04534 	movhi	r2,33044
81140938:	109bea04 	addi	r2,r2,28584
8114093c:	e0fffb17 	ldw	r3,-20(fp)
81140940:	18c00324 	muli	r3,r3,12
81140944:	10c5883a 	add	r2,r2,r3
81140948:	10800104 	addi	r2,r2,4
8114094c:	10c00017 	ldw	r3,0(r2)
81140950:	e0bffc17 	ldw	r2,-16(fp)
81140954:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
81140958:	00a04534 	movhi	r2,33044
8114095c:	109bea04 	addi	r2,r2,28584
81140960:	e0fffb17 	ldw	r3,-20(fp)
81140964:	18c00324 	muli	r3,r3,12
81140968:	10c5883a 	add	r2,r2,r3
8114096c:	10800204 	addi	r2,r2,8
81140970:	10c00017 	ldw	r3,0(r2)
81140974:	e0bffc17 	ldw	r2,-16(fp)
81140978:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8114097c:	e13ffb17 	ldw	r4,-20(fp)
81140980:	112dbd80 	call	8112dbd8 <alt_release_fd>
  }
} 
81140984:	0001883a 	nop
81140988:	e037883a 	mov	sp,fp
8114098c:	dfc00117 	ldw	ra,4(sp)
81140990:	df000017 	ldw	fp,0(sp)
81140994:	dec00204 	addi	sp,sp,8
81140998:	f800283a 	ret

8114099c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114099c:	defffb04 	addi	sp,sp,-20
811409a0:	de00012e 	bgeu	sp,et,811409a8 <alt_io_redirect+0xc>
811409a4:	003b68fa 	trap	3
811409a8:	dfc00415 	stw	ra,16(sp)
811409ac:	df000315 	stw	fp,12(sp)
811409b0:	df000304 	addi	fp,sp,12
811409b4:	e13ffd15 	stw	r4,-12(fp)
811409b8:	e17ffe15 	stw	r5,-8(fp)
811409bc:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
811409c0:	01c07fc4 	movi	r7,511
811409c4:	01800044 	movi	r6,1
811409c8:	e17ffd17 	ldw	r5,-12(fp)
811409cc:	01204534 	movhi	r4,33044
811409d0:	211bed04 	addi	r4,r4,28596
811409d4:	11408d00 	call	811408d0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
811409d8:	01c07fc4 	movi	r7,511
811409dc:	000d883a 	mov	r6,zero
811409e0:	e17ffe17 	ldw	r5,-8(fp)
811409e4:	01204534 	movhi	r4,33044
811409e8:	211bea04 	addi	r4,r4,28584
811409ec:	11408d00 	call	811408d0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
811409f0:	01c07fc4 	movi	r7,511
811409f4:	01800044 	movi	r6,1
811409f8:	e17fff17 	ldw	r5,-4(fp)
811409fc:	01204534 	movhi	r4,33044
81140a00:	211bf004 	addi	r4,r4,28608
81140a04:	11408d00 	call	811408d0 <alt_open_fd>
}  
81140a08:	0001883a 	nop
81140a0c:	e037883a 	mov	sp,fp
81140a10:	dfc00117 	ldw	ra,4(sp)
81140a14:	df000017 	ldw	fp,0(sp)
81140a18:	dec00204 	addi	sp,sp,8
81140a1c:	f800283a 	ret

81140a20 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
81140a20:	defff204 	addi	sp,sp,-56
81140a24:	de00012e 	bgeu	sp,et,81140a2c <alt_printf+0xc>
81140a28:	003b68fa 	trap	3
81140a2c:	dfc00a15 	stw	ra,40(sp)
81140a30:	df000915 	stw	fp,36(sp)
81140a34:	df000904 	addi	fp,sp,36
81140a38:	e13fff15 	stw	r4,-4(fp)
81140a3c:	e1400215 	stw	r5,8(fp)
81140a40:	e1800315 	stw	r6,12(fp)
81140a44:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
81140a48:	e0800204 	addi	r2,fp,8
81140a4c:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
81140a50:	e0bfff17 	ldw	r2,-4(fp)
81140a54:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
81140a58:	00006f06 	br	81140c18 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
81140a5c:	e0bff807 	ldb	r2,-32(fp)
81140a60:	10800960 	cmpeqi	r2,r2,37
81140a64:	1000041e 	bne	r2,zero,81140a78 <alt_printf+0x58>
        {
            alt_putchar(c);
81140a68:	e0bff807 	ldb	r2,-32(fp)
81140a6c:	1009883a 	mov	r4,r2
81140a70:	1140c540 	call	81140c54 <alt_putchar>
81140a74:	00006806 	br	81140c18 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
81140a78:	e0bff717 	ldw	r2,-36(fp)
81140a7c:	10c00044 	addi	r3,r2,1
81140a80:	e0fff715 	stw	r3,-36(fp)
81140a84:	10800003 	ldbu	r2,0(r2)
81140a88:	e0bff805 	stb	r2,-32(fp)
81140a8c:	e0bff807 	ldb	r2,-32(fp)
81140a90:	10006926 	beq	r2,zero,81140c38 <alt_printf+0x218>
            {
                if (c == '%')
81140a94:	e0bff807 	ldb	r2,-32(fp)
81140a98:	10800958 	cmpnei	r2,r2,37
81140a9c:	1000041e 	bne	r2,zero,81140ab0 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
81140aa0:	e0bff807 	ldb	r2,-32(fp)
81140aa4:	1009883a 	mov	r4,r2
81140aa8:	1140c540 	call	81140c54 <alt_putchar>
81140aac:	00005a06 	br	81140c18 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
81140ab0:	e0bff807 	ldb	r2,-32(fp)
81140ab4:	108018d8 	cmpnei	r2,r2,99
81140ab8:	1000081e 	bne	r2,zero,81140adc <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
81140abc:	e0bffe17 	ldw	r2,-8(fp)
81140ac0:	10c00104 	addi	r3,r2,4
81140ac4:	e0fffe15 	stw	r3,-8(fp)
81140ac8:	10800017 	ldw	r2,0(r2)
81140acc:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
81140ad0:	e13ffd17 	ldw	r4,-12(fp)
81140ad4:	1140c540 	call	81140c54 <alt_putchar>
81140ad8:	00004f06 	br	81140c18 <alt_printf+0x1f8>
                }
                else if (c == 'x')
81140adc:	e0bff807 	ldb	r2,-32(fp)
81140ae0:	10801e18 	cmpnei	r2,r2,120
81140ae4:	1000341e 	bne	r2,zero,81140bb8 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
81140ae8:	e0bffe17 	ldw	r2,-8(fp)
81140aec:	10c00104 	addi	r3,r2,4
81140af0:	e0fffe15 	stw	r3,-8(fp)
81140af4:	10800017 	ldw	r2,0(r2)
81140af8:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
81140afc:	e0bffb17 	ldw	r2,-20(fp)
81140b00:	1000031e 	bne	r2,zero,81140b10 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
81140b04:	01000c04 	movi	r4,48
81140b08:	1140c540 	call	81140c54 <alt_putchar>
                        continue;
81140b0c:	00004206 	br	81140c18 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
81140b10:	00800704 	movi	r2,28
81140b14:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
81140b18:	00000306 	br	81140b28 <alt_printf+0x108>
                        digit_shift -= 4;
81140b1c:	e0bff917 	ldw	r2,-28(fp)
81140b20:	10bfff04 	addi	r2,r2,-4
81140b24:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
81140b28:	00c003c4 	movi	r3,15
81140b2c:	e0bff917 	ldw	r2,-28(fp)
81140b30:	1884983a 	sll	r2,r3,r2
81140b34:	1007883a 	mov	r3,r2
81140b38:	e0bffb17 	ldw	r2,-20(fp)
81140b3c:	1884703a 	and	r2,r3,r2
81140b40:	103ff626 	beq	r2,zero,81140b1c <__reset+0xfb120b1c>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81140b44:	00001906 	br	81140bac <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
81140b48:	00c003c4 	movi	r3,15
81140b4c:	e0bff917 	ldw	r2,-28(fp)
81140b50:	1884983a 	sll	r2,r3,r2
81140b54:	1007883a 	mov	r3,r2
81140b58:	e0bffb17 	ldw	r2,-20(fp)
81140b5c:	1886703a 	and	r3,r3,r2
81140b60:	e0bff917 	ldw	r2,-28(fp)
81140b64:	1884d83a 	srl	r2,r3,r2
81140b68:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
81140b6c:	e0bffc17 	ldw	r2,-16(fp)
81140b70:	108002a8 	cmpgeui	r2,r2,10
81140b74:	1000041e 	bne	r2,zero,81140b88 <alt_printf+0x168>
                            c = '0' + digit;
81140b78:	e0bffc17 	ldw	r2,-16(fp)
81140b7c:	10800c04 	addi	r2,r2,48
81140b80:	e0bff805 	stb	r2,-32(fp)
81140b84:	00000306 	br	81140b94 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
81140b88:	e0bffc17 	ldw	r2,-16(fp)
81140b8c:	108015c4 	addi	r2,r2,87
81140b90:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
81140b94:	e0bff807 	ldb	r2,-32(fp)
81140b98:	1009883a 	mov	r4,r2
81140b9c:	1140c540 	call	81140c54 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81140ba0:	e0bff917 	ldw	r2,-28(fp)
81140ba4:	10bfff04 	addi	r2,r2,-4
81140ba8:	e0bff915 	stw	r2,-28(fp)
81140bac:	e0bff917 	ldw	r2,-28(fp)
81140bb0:	103fe50e 	bge	r2,zero,81140b48 <__reset+0xfb120b48>
81140bb4:	00001806 	br	81140c18 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
81140bb8:	e0bff807 	ldb	r2,-32(fp)
81140bbc:	10801cd8 	cmpnei	r2,r2,115
81140bc0:	1000151e 	bne	r2,zero,81140c18 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81140bc4:	e0bffe17 	ldw	r2,-8(fp)
81140bc8:	10c00104 	addi	r3,r2,4
81140bcc:	e0fffe15 	stw	r3,-8(fp)
81140bd0:	10800017 	ldw	r2,0(r2)
81140bd4:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
81140bd8:	00000906 	br	81140c00 <alt_printf+0x1e0>
                      alt_putchar(*s++);
81140bdc:	e0bffa17 	ldw	r2,-24(fp)
81140be0:	10c00044 	addi	r3,r2,1
81140be4:	e0fffa15 	stw	r3,-24(fp)
81140be8:	10800003 	ldbu	r2,0(r2)
81140bec:	10803fcc 	andi	r2,r2,255
81140bf0:	1080201c 	xori	r2,r2,128
81140bf4:	10bfe004 	addi	r2,r2,-128
81140bf8:	1009883a 	mov	r4,r2
81140bfc:	1140c540 	call	81140c54 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
81140c00:	e0bffa17 	ldw	r2,-24(fp)
81140c04:	10800003 	ldbu	r2,0(r2)
81140c08:	10803fcc 	andi	r2,r2,255
81140c0c:	1080201c 	xori	r2,r2,128
81140c10:	10bfe004 	addi	r2,r2,-128
81140c14:	103ff11e 	bne	r2,zero,81140bdc <__reset+0xfb120bdc>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
81140c18:	e0bff717 	ldw	r2,-36(fp)
81140c1c:	10c00044 	addi	r3,r2,1
81140c20:	e0fff715 	stw	r3,-36(fp)
81140c24:	10800003 	ldbu	r2,0(r2)
81140c28:	e0bff805 	stb	r2,-32(fp)
81140c2c:	e0bff807 	ldb	r2,-32(fp)
81140c30:	103f8a1e 	bne	r2,zero,81140a5c <__reset+0xfb120a5c>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81140c34:	00000106 	br	81140c3c <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
81140c38:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81140c3c:	0001883a 	nop
81140c40:	e037883a 	mov	sp,fp
81140c44:	dfc00117 	ldw	ra,4(sp)
81140c48:	df000017 	ldw	fp,0(sp)
81140c4c:	dec00504 	addi	sp,sp,20
81140c50:	f800283a 	ret

81140c54 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
81140c54:	defffd04 	addi	sp,sp,-12
81140c58:	de00012e 	bgeu	sp,et,81140c60 <alt_putchar+0xc>
81140c5c:	003b68fa 	trap	3
81140c60:	dfc00215 	stw	ra,8(sp)
81140c64:	df000115 	stw	fp,4(sp)
81140c68:	df000104 	addi	fp,sp,4
81140c6c:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
81140c70:	d0a00517 	ldw	r2,-32748(gp)
81140c74:	10800217 	ldw	r2,8(r2)
81140c78:	100b883a 	mov	r5,r2
81140c7c:	e13fff17 	ldw	r4,-4(fp)
81140c80:	11180d00 	call	811180d0 <putc>
#endif
#endif
}
81140c84:	e037883a 	mov	sp,fp
81140c88:	dfc00117 	ldw	ra,4(sp)
81140c8c:	df000017 	ldw	fp,0(sp)
81140c90:	dec00204 	addi	sp,sp,8
81140c94:	f800283a 	ret

81140c98 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
81140c98:	deffff04 	addi	sp,sp,-4
81140c9c:	de00012e 	bgeu	sp,et,81140ca4 <altera_nios2_gen2_irq_init+0xc>
81140ca0:	003b68fa 	trap	3
81140ca4:	df000015 	stw	fp,0(sp)
81140ca8:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
81140cac:	000170fa 	wrctl	ienable,zero
}
81140cb0:	0001883a 	nop
81140cb4:	e037883a 	mov	sp,fp
81140cb8:	df000017 	ldw	fp,0(sp)
81140cbc:	dec00104 	addi	sp,sp,4
81140cc0:	f800283a 	ret

81140cc4 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81140cc4:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
81140cc8:	de002436 	bltu	sp,et,81140d5c <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81140ccc:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
81140cd0:	d1209317 	ldw	r4,-32180(gp)

      stw ra,  0(sp)
81140cd4:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
81140cd8:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81140cdc:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
81140ce0:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81140ce4:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
81140ce8:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
81140cec:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
81140cf0:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
81140cf4:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
81140cf8:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
81140cfc:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
81140d00:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81140d04:	1140f600 	call	81140f60 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
81140d08:	d1208d17 	ldw	r4,-32204(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
81140d0c:	d1608487 	ldb	r5,-32238(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
81140d10:	d1209315 	stw	r4,-32180(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
81140d14:	d16084c5 	stb	r5,-32237(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
81140d18:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
81140d1c:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
81140d20:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
81140d24:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
81140d28:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
81140d2c:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
81140d30:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
81140d34:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
81140d38:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
81140d3c:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
81140d40:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
81140d44:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
81140d48:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
81140d4c:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
81140d50:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
81140d54:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
81140d58:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
81140d5c:	003da0fa 	break	3

81140d60 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
81140d60:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
81140d64:	047fff84 	movi	r17,-2
      and   r18, r18, r17
81140d68:	9464703a 	and	r18,r18,r17
      wrctl status, r18
81140d6c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81140d70:	1140f600 	call	81140f60 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
81140d74:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
81140d78:	d4a08205 	stb	r18,-32248(gp)

      /*
       * start execution of the new task.
       */

      br 9b
81140d7c:	003fe206 	br	81140d08 <__reset+0xfb120d08>

81140d80 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
81140d80:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
81140d84:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
81140d88:	10800054 	ori	r2,r2,1
      wrctl status, r2
81140d8c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
81140d90:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81140d94:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
81140d98:	dec00204 	addi	sp,sp,8

      callr r2
81140d9c:	103ee83a 	callr	r2

      nop
81140da0:	0001883a 	nop

81140da4 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81140da4:	defff704 	addi	sp,sp,-36
81140da8:	de00012e 	bgeu	sp,et,81140db0 <OSTaskStkInit+0xc>
81140dac:	003b68fa 	trap	3
81140db0:	dfc00815 	stw	ra,32(sp)
81140db4:	df000715 	stw	fp,28(sp)
81140db8:	df000704 	addi	fp,sp,28
81140dbc:	e13ffc15 	stw	r4,-16(fp)
81140dc0:	e17ffd15 	stw	r5,-12(fp)
81140dc4:	e1bffe15 	stw	r6,-8(fp)
81140dc8:	3805883a 	mov	r2,r7
81140dcc:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
81140dd0:	e0fffe17 	ldw	r3,-8(fp)
81140dd4:	00bfff04 	movi	r2,-4
81140dd8:	1884703a 	and	r2,r3,r2
81140ddc:	10bef704 	addi	r2,r2,-1060
81140de0:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81140de4:	01810904 	movi	r6,1060
81140de8:	000b883a 	mov	r5,zero
81140dec:	e13ff917 	ldw	r4,-28(fp)
81140df0:	1117e1c0 	call	81117e1c <memset>
81140df4:	e0bff917 	ldw	r2,-28(fp)
81140df8:	10c0bb04 	addi	r3,r2,748
81140dfc:	e0bff917 	ldw	r2,-28(fp)
81140e00:	10c00115 	stw	r3,4(r2)
81140e04:	e0bff917 	ldw	r2,-28(fp)
81140e08:	10c0d504 	addi	r3,r2,852
81140e0c:	e0bff917 	ldw	r2,-28(fp)
81140e10:	10c00215 	stw	r3,8(r2)
81140e14:	e0bff917 	ldw	r2,-28(fp)
81140e18:	10c0ef04 	addi	r3,r2,956
81140e1c:	e0bff917 	ldw	r2,-28(fp)
81140e20:	10c00315 	stw	r3,12(r2)
81140e24:	e0fff917 	ldw	r3,-28(fp)
81140e28:	00a04534 	movhi	r2,33044
81140e2c:	10998304 	addi	r2,r2,26124
81140e30:	18800d15 	stw	r2,52(r3)
81140e34:	e0bff917 	ldw	r2,-28(fp)
81140e38:	00c00044 	movi	r3,1
81140e3c:	10c02915 	stw	r3,164(r2)
81140e40:	10002a15 	stw	zero,168(r2)
81140e44:	e0bff917 	ldw	r2,-28(fp)
81140e48:	00ccc384 	movi	r3,13070
81140e4c:	10c02b0d 	sth	r3,172(r2)
81140e50:	e0bff917 	ldw	r2,-28(fp)
81140e54:	00eaf344 	movi	r3,-21555
81140e58:	10c02b8d 	sth	r3,174(r2)
81140e5c:	e0bff917 	ldw	r2,-28(fp)
81140e60:	00c48d04 	movi	r3,4660
81140e64:	10c02c0d 	sth	r3,176(r2)
81140e68:	e0bff917 	ldw	r2,-28(fp)
81140e6c:	00f99b44 	movi	r3,-6547
81140e70:	10c02c8d 	sth	r3,178(r2)
81140e74:	e0bff917 	ldw	r2,-28(fp)
81140e78:	00f7bb04 	movi	r3,-8468
81140e7c:	10c02d0d 	sth	r3,180(r2)
81140e80:	e0bff917 	ldw	r2,-28(fp)
81140e84:	00c00144 	movi	r3,5
81140e88:	10c02d8d 	sth	r3,182(r2)
81140e8c:	e0bff917 	ldw	r2,-28(fp)
81140e90:	00c002c4 	movi	r3,11
81140e94:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
81140e98:	e0bff917 	ldw	r2,-28(fp)
81140e9c:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
81140ea0:	e0bffa17 	ldw	r2,-24(fp)
81140ea4:	10bff304 	addi	r2,r2,-52
81140ea8:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
81140eac:	e0bffb17 	ldw	r2,-20(fp)
81140eb0:	10800c04 	addi	r2,r2,48
81140eb4:	e0fffc17 	ldw	r3,-16(fp)
81140eb8:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
81140ebc:	e0bffb17 	ldw	r2,-20(fp)
81140ec0:	10800b04 	addi	r2,r2,44
81140ec4:	e0fffd17 	ldw	r3,-12(fp)
81140ec8:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
81140ecc:	e0bffb17 	ldw	r2,-20(fp)
81140ed0:	10800a04 	addi	r2,r2,40
81140ed4:	e0fff917 	ldw	r3,-28(fp)
81140ed8:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
81140edc:	00a04534 	movhi	r2,33044
81140ee0:	10836004 	addi	r2,r2,3456
81140ee4:	10c00104 	addi	r3,r2,4
81140ee8:	e0bffb17 	ldw	r2,-20(fp)
81140eec:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
81140ef0:	e0bffb17 	ldw	r2,-20(fp)
}
81140ef4:	e037883a 	mov	sp,fp
81140ef8:	dfc00117 	ldw	ra,4(sp)
81140efc:	df000017 	ldw	fp,0(sp)
81140f00:	dec00204 	addi	sp,sp,8
81140f04:	f800283a 	ret

81140f08 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
81140f08:	defffe04 	addi	sp,sp,-8
81140f0c:	de00012e 	bgeu	sp,et,81140f14 <OSTaskCreateHook+0xc>
81140f10:	003b68fa 	trap	3
81140f14:	df000115 	stw	fp,4(sp)
81140f18:	df000104 	addi	fp,sp,4
81140f1c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
81140f20:	0001883a 	nop
81140f24:	e037883a 	mov	sp,fp
81140f28:	df000017 	ldw	fp,0(sp)
81140f2c:	dec00104 	addi	sp,sp,4
81140f30:	f800283a 	ret

81140f34 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
81140f34:	defffe04 	addi	sp,sp,-8
81140f38:	de00012e 	bgeu	sp,et,81140f40 <OSTaskDelHook+0xc>
81140f3c:	003b68fa 	trap	3
81140f40:	df000115 	stw	fp,4(sp)
81140f44:	df000104 	addi	fp,sp,4
81140f48:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
81140f4c:	0001883a 	nop
81140f50:	e037883a 	mov	sp,fp
81140f54:	df000017 	ldw	fp,0(sp)
81140f58:	dec00104 	addi	sp,sp,4
81140f5c:	f800283a 	ret

81140f60 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
81140f60:	deffff04 	addi	sp,sp,-4
81140f64:	de00012e 	bgeu	sp,et,81140f6c <OSTaskSwHook+0xc>
81140f68:	003b68fa 	trap	3
81140f6c:	df000015 	stw	fp,0(sp)
81140f70:	d839883a 	mov	fp,sp
}
81140f74:	0001883a 	nop
81140f78:	e037883a 	mov	sp,fp
81140f7c:	df000017 	ldw	fp,0(sp)
81140f80:	dec00104 	addi	sp,sp,4
81140f84:	f800283a 	ret

81140f88 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
81140f88:	deffff04 	addi	sp,sp,-4
81140f8c:	de00012e 	bgeu	sp,et,81140f94 <OSTaskStatHook+0xc>
81140f90:	003b68fa 	trap	3
81140f94:	df000015 	stw	fp,0(sp)
81140f98:	d839883a 	mov	fp,sp
}
81140f9c:	0001883a 	nop
81140fa0:	e037883a 	mov	sp,fp
81140fa4:	df000017 	ldw	fp,0(sp)
81140fa8:	dec00104 	addi	sp,sp,4
81140fac:	f800283a 	ret

81140fb0 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
81140fb0:	defffe04 	addi	sp,sp,-8
81140fb4:	de00012e 	bgeu	sp,et,81140fbc <OSTimeTickHook+0xc>
81140fb8:	003b68fa 	trap	3
81140fbc:	dfc00115 	stw	ra,4(sp)
81140fc0:	df000015 	stw	fp,0(sp)
81140fc4:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
81140fc8:	d0a0a70b 	ldhu	r2,-32100(gp)
81140fcc:	10800044 	addi	r2,r2,1
81140fd0:	d0a0a70d 	sth	r2,-32100(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
81140fd4:	d0a0a70b 	ldhu	r2,-32100(gp)
81140fd8:	10bfffcc 	andi	r2,r2,65535
81140fdc:	10807d30 	cmpltui	r2,r2,500
81140fe0:	1000021e 	bne	r2,zero,81140fec <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
81140fe4:	d020a70d 	sth	zero,-32100(gp)
        OSTmrSignal();
81140fe8:	11379000 	call	81137900 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
81140fec:	0001883a 	nop
81140ff0:	e037883a 	mov	sp,fp
81140ff4:	dfc00117 	ldw	ra,4(sp)
81140ff8:	df000017 	ldw	fp,0(sp)
81140ffc:	dec00204 	addi	sp,sp,8
81141000:	f800283a 	ret

81141004 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
81141004:	deffff04 	addi	sp,sp,-4
81141008:	de00012e 	bgeu	sp,et,81141010 <OSInitHookBegin+0xc>
8114100c:	003b68fa 	trap	3
81141010:	df000015 	stw	fp,0(sp)
81141014:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
81141018:	d020a70d 	sth	zero,-32100(gp)
#endif
}
8114101c:	0001883a 	nop
81141020:	e037883a 	mov	sp,fp
81141024:	df000017 	ldw	fp,0(sp)
81141028:	dec00104 	addi	sp,sp,4
8114102c:	f800283a 	ret

81141030 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
81141030:	deffff04 	addi	sp,sp,-4
81141034:	de00012e 	bgeu	sp,et,8114103c <OSInitHookEnd+0xc>
81141038:	003b68fa 	trap	3
8114103c:	df000015 	stw	fp,0(sp)
81141040:	d839883a 	mov	fp,sp
}
81141044:	0001883a 	nop
81141048:	e037883a 	mov	sp,fp
8114104c:	df000017 	ldw	fp,0(sp)
81141050:	dec00104 	addi	sp,sp,4
81141054:	f800283a 	ret

81141058 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
81141058:	deffff04 	addi	sp,sp,-4
8114105c:	de00012e 	bgeu	sp,et,81141064 <OSTaskIdleHook+0xc>
81141060:	003b68fa 	trap	3
81141064:	df000015 	stw	fp,0(sp)
81141068:	d839883a 	mov	fp,sp
}
8114106c:	0001883a 	nop
81141070:	e037883a 	mov	sp,fp
81141074:	df000017 	ldw	fp,0(sp)
81141078:	dec00104 	addi	sp,sp,4
8114107c:	f800283a 	ret

81141080 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
81141080:	defffe04 	addi	sp,sp,-8
81141084:	de00012e 	bgeu	sp,et,8114108c <OSTCBInitHook+0xc>
81141088:	003b68fa 	trap	3
8114108c:	df000115 	stw	fp,4(sp)
81141090:	df000104 	addi	fp,sp,4
81141094:	e13fff15 	stw	r4,-4(fp)
}
81141098:	0001883a 	nop
8114109c:	e037883a 	mov	sp,fp
811410a0:	df000017 	ldw	fp,0(sp)
811410a4:	dec00104 	addi	sp,sp,4
811410a8:	f800283a 	ret

811410ac <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
811410ac:	defffe04 	addi	sp,sp,-8
811410b0:	de00012e 	bgeu	sp,et,811410b8 <alt_exception_cause_generated_bad_addr+0xc>
811410b4:	003b68fa 	trap	3
811410b8:	df000115 	stw	fp,4(sp)
811410bc:	df000104 	addi	fp,sp,4
811410c0:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
811410c4:	e0bfff17 	ldw	r2,-4(fp)
811410c8:	10bffe84 	addi	r2,r2,-6
811410cc:	10c00428 	cmpgeui	r3,r2,16
811410d0:	18001a1e 	bne	r3,zero,8114113c <alt_exception_cause_generated_bad_addr+0x90>
811410d4:	100690ba 	slli	r3,r2,2
811410d8:	00a04534 	movhi	r2,33044
811410dc:	10843b04 	addi	r2,r2,4332
811410e0:	1885883a 	add	r2,r3,r2
811410e4:	10800017 	ldw	r2,0(r2)
811410e8:	1000683a 	jmp	r2
811410ec:	8114112c 	andhi	r4,r16,20548
811410f0:	8114112c 	andhi	r4,r16,20548
811410f4:	8114113c 	xorhi	r4,r16,20548
811410f8:	8114113c 	xorhi	r4,r16,20548
811410fc:	8114113c 	xorhi	r4,r16,20548
81141100:	8114112c 	andhi	r4,r16,20548
81141104:	81141134 	orhi	r4,r16,20548
81141108:	8114113c 	xorhi	r4,r16,20548
8114110c:	8114112c 	andhi	r4,r16,20548
81141110:	8114112c 	andhi	r4,r16,20548
81141114:	8114113c 	xorhi	r4,r16,20548
81141118:	8114112c 	andhi	r4,r16,20548
8114111c:	81141134 	orhi	r4,r16,20548
81141120:	8114113c 	xorhi	r4,r16,20548
81141124:	8114113c 	xorhi	r4,r16,20548
81141128:	8114112c 	andhi	r4,r16,20548
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8114112c:	00800044 	movi	r2,1
81141130:	00000306 	br	81141140 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
81141134:	0005883a 	mov	r2,zero
81141138:	00000106 	br	81141140 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8114113c:	0005883a 	mov	r2,zero
  }
}
81141140:	e037883a 	mov	sp,fp
81141144:	df000017 	ldw	fp,0(sp)
81141148:	dec00104 	addi	sp,sp,4
8114114c:	f800283a 	ret

81141150 <exit>:
81141150:	defffe04 	addi	sp,sp,-8
81141154:	000b883a 	mov	r5,zero
81141158:	de00012e 	bgeu	sp,et,81141160 <exit+0x10>
8114115c:	003b68fa 	trap	3
81141160:	dc000015 	stw	r16,0(sp)
81141164:	dfc00115 	stw	ra,4(sp)
81141168:	2021883a 	mov	r16,r4
8114116c:	11412f80 	call	811412f8 <__call_exitprocs>
81141170:	00a04574 	movhi	r2,33045
81141174:	10a10104 	addi	r2,r2,-31740
81141178:	11000017 	ldw	r4,0(r2)
8114117c:	20800f17 	ldw	r2,60(r4)
81141180:	10000126 	beq	r2,zero,81141188 <exit+0x38>
81141184:	103ee83a 	callr	r2
81141188:	8009883a 	mov	r4,r16
8114118c:	11414800 	call	81141480 <_exit>

81141190 <memcmp>:
81141190:	01c000c4 	movi	r7,3
81141194:	3980192e 	bgeu	r7,r6,811411fc <memcmp+0x6c>
81141198:	2144b03a 	or	r2,r4,r5
8114119c:	11c4703a 	and	r2,r2,r7
811411a0:	10000f26 	beq	r2,zero,811411e0 <memcmp+0x50>
811411a4:	20800003 	ldbu	r2,0(r4)
811411a8:	28c00003 	ldbu	r3,0(r5)
811411ac:	10c0151e 	bne	r2,r3,81141204 <memcmp+0x74>
811411b0:	31bfff84 	addi	r6,r6,-2
811411b4:	01ffffc4 	movi	r7,-1
811411b8:	00000406 	br	811411cc <memcmp+0x3c>
811411bc:	20800003 	ldbu	r2,0(r4)
811411c0:	28c00003 	ldbu	r3,0(r5)
811411c4:	31bfffc4 	addi	r6,r6,-1
811411c8:	10c00e1e 	bne	r2,r3,81141204 <memcmp+0x74>
811411cc:	21000044 	addi	r4,r4,1
811411d0:	29400044 	addi	r5,r5,1
811411d4:	31fff91e 	bne	r6,r7,811411bc <__reset+0xfb1211bc>
811411d8:	0005883a 	mov	r2,zero
811411dc:	f800283a 	ret
811411e0:	20c00017 	ldw	r3,0(r4)
811411e4:	28800017 	ldw	r2,0(r5)
811411e8:	18bfee1e 	bne	r3,r2,811411a4 <__reset+0xfb1211a4>
811411ec:	31bfff04 	addi	r6,r6,-4
811411f0:	21000104 	addi	r4,r4,4
811411f4:	29400104 	addi	r5,r5,4
811411f8:	39bff936 	bltu	r7,r6,811411e0 <__reset+0xfb1211e0>
811411fc:	303fe91e 	bne	r6,zero,811411a4 <__reset+0xfb1211a4>
81141200:	003ff506 	br	811411d8 <__reset+0xfb1211d8>
81141204:	10c5c83a 	sub	r2,r2,r3
81141208:	f800283a 	ret

8114120c <strncpy>:
8114120c:	2906b03a 	or	r3,r5,r4
81141210:	18c000cc 	andi	r3,r3,3
81141214:	2005883a 	mov	r2,r4
81141218:	18002c1e 	bne	r3,zero,811412cc <strncpy+0xc0>
8114121c:	010000c4 	movi	r4,3
81141220:	21802a2e 	bgeu	r4,r6,811412cc <strncpy+0xc0>
81141224:	033fbff4 	movhi	r12,65279
81141228:	02e02074 	movhi	r11,32897
8114122c:	633fbfc4 	addi	r12,r12,-257
81141230:	5ae02004 	addi	r11,r11,-32640
81141234:	100f883a 	mov	r7,r2
81141238:	2a000017 	ldw	r8,0(r5)
8114123c:	3815883a 	mov	r10,r7
81141240:	4313883a 	add	r9,r8,r12
81141244:	0206303a 	nor	r3,zero,r8
81141248:	48c6703a 	and	r3,r9,r3
8114124c:	1ac6703a 	and	r3,r3,r11
81141250:	1800261e 	bne	r3,zero,811412ec <strncpy+0xe0>
81141254:	39c00104 	addi	r7,r7,4
81141258:	52000015 	stw	r8,0(r10)
8114125c:	31bfff04 	addi	r6,r6,-4
81141260:	3811883a 	mov	r8,r7
81141264:	29400104 	addi	r5,r5,4
81141268:	21bff336 	bltu	r4,r6,81141238 <__reset+0xfb121238>
8114126c:	30001e26 	beq	r6,zero,811412e8 <strncpy+0xdc>
81141270:	29c00003 	ldbu	r7,0(r5)
81141274:	31bfffc4 	addi	r6,r6,-1
81141278:	40c00044 	addi	r3,r8,1
8114127c:	41c00005 	stb	r7,0(r8)
81141280:	39c03fcc 	andi	r7,r7,255
81141284:	39c0201c 	xori	r7,r7,128
81141288:	39ffe004 	addi	r7,r7,-128
8114128c:	29400044 	addi	r5,r5,1
81141290:	38001026 	beq	r7,zero,811412d4 <strncpy+0xc8>
81141294:	1811883a 	mov	r8,r3
81141298:	00000906 	br	811412c0 <strncpy+0xb4>
8114129c:	29c00003 	ldbu	r7,0(r5)
811412a0:	31bfffc4 	addi	r6,r6,-1
811412a4:	29400044 	addi	r5,r5,1
811412a8:	41c00005 	stb	r7,0(r8)
811412ac:	39c03fcc 	andi	r7,r7,255
811412b0:	39c0201c 	xori	r7,r7,128
811412b4:	39ffe004 	addi	r7,r7,-128
811412b8:	1811883a 	mov	r8,r3
811412bc:	38000526 	beq	r7,zero,811412d4 <strncpy+0xc8>
811412c0:	18c00044 	addi	r3,r3,1
811412c4:	303ff51e 	bne	r6,zero,8114129c <__reset+0xfb12129c>
811412c8:	f800283a 	ret
811412cc:	1011883a 	mov	r8,r2
811412d0:	003fe606 	br	8114126c <__reset+0xfb12126c>
811412d4:	30000726 	beq	r6,zero,811412f4 <strncpy+0xe8>
811412d8:	198d883a 	add	r6,r3,r6
811412dc:	18000005 	stb	zero,0(r3)
811412e0:	18c00044 	addi	r3,r3,1
811412e4:	19bffd1e 	bne	r3,r6,811412dc <__reset+0xfb1212dc>
811412e8:	f800283a 	ret
811412ec:	3811883a 	mov	r8,r7
811412f0:	003fdf06 	br	81141270 <__reset+0xfb121270>
811412f4:	f800283a 	ret

811412f8 <__call_exitprocs>:
811412f8:	defff504 	addi	sp,sp,-44
811412fc:	de00012e 	bgeu	sp,et,81141304 <__call_exitprocs+0xc>
81141300:	003b68fa 	trap	3
81141304:	df000915 	stw	fp,36(sp)
81141308:	dd400615 	stw	r21,24(sp)
8114130c:	dc800315 	stw	r18,12(sp)
81141310:	dfc00a15 	stw	ra,40(sp)
81141314:	ddc00815 	stw	r23,32(sp)
81141318:	dd800715 	stw	r22,28(sp)
8114131c:	dd000515 	stw	r20,20(sp)
81141320:	dcc00415 	stw	r19,16(sp)
81141324:	dc400215 	stw	r17,8(sp)
81141328:	dc000115 	stw	r16,4(sp)
8114132c:	d9000015 	stw	r4,0(sp)
81141330:	2839883a 	mov	fp,r5
81141334:	04800044 	movi	r18,1
81141338:	057fffc4 	movi	r21,-1
8114133c:	00a04574 	movhi	r2,33045
81141340:	10a10104 	addi	r2,r2,-31740
81141344:	12000017 	ldw	r8,0(r2)
81141348:	45005217 	ldw	r20,328(r8)
8114134c:	44c05204 	addi	r19,r8,328
81141350:	a0001c26 	beq	r20,zero,811413c4 <__call_exitprocs+0xcc>
81141354:	a0800117 	ldw	r2,4(r20)
81141358:	15ffffc4 	addi	r23,r2,-1
8114135c:	b8000d16 	blt	r23,zero,81141394 <__call_exitprocs+0x9c>
81141360:	14000044 	addi	r16,r2,1
81141364:	8421883a 	add	r16,r16,r16
81141368:	8421883a 	add	r16,r16,r16
8114136c:	84402004 	addi	r17,r16,128
81141370:	a463883a 	add	r17,r20,r17
81141374:	a421883a 	add	r16,r20,r16
81141378:	e0001e26 	beq	fp,zero,811413f4 <__call_exitprocs+0xfc>
8114137c:	80804017 	ldw	r2,256(r16)
81141380:	e0801c26 	beq	fp,r2,811413f4 <__call_exitprocs+0xfc>
81141384:	bdffffc4 	addi	r23,r23,-1
81141388:	843fff04 	addi	r16,r16,-4
8114138c:	8c7fff04 	addi	r17,r17,-4
81141390:	bd7ff91e 	bne	r23,r21,81141378 <__reset+0xfb121378>
81141394:	00800034 	movhi	r2,0
81141398:	10800004 	addi	r2,r2,0
8114139c:	10000926 	beq	r2,zero,811413c4 <__call_exitprocs+0xcc>
811413a0:	a0800117 	ldw	r2,4(r20)
811413a4:	1000301e 	bne	r2,zero,81141468 <__call_exitprocs+0x170>
811413a8:	a0800017 	ldw	r2,0(r20)
811413ac:	10003226 	beq	r2,zero,81141478 <__call_exitprocs+0x180>
811413b0:	a009883a 	mov	r4,r20
811413b4:	98800015 	stw	r2,0(r19)
811413b8:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
811413bc:	9d000017 	ldw	r20,0(r19)
811413c0:	a03fe41e 	bne	r20,zero,81141354 <__reset+0xfb121354>
811413c4:	dfc00a17 	ldw	ra,40(sp)
811413c8:	df000917 	ldw	fp,36(sp)
811413cc:	ddc00817 	ldw	r23,32(sp)
811413d0:	dd800717 	ldw	r22,28(sp)
811413d4:	dd400617 	ldw	r21,24(sp)
811413d8:	dd000517 	ldw	r20,20(sp)
811413dc:	dcc00417 	ldw	r19,16(sp)
811413e0:	dc800317 	ldw	r18,12(sp)
811413e4:	dc400217 	ldw	r17,8(sp)
811413e8:	dc000117 	ldw	r16,4(sp)
811413ec:	dec00b04 	addi	sp,sp,44
811413f0:	f800283a 	ret
811413f4:	a0800117 	ldw	r2,4(r20)
811413f8:	80c00017 	ldw	r3,0(r16)
811413fc:	10bfffc4 	addi	r2,r2,-1
81141400:	15c01426 	beq	r2,r23,81141454 <__call_exitprocs+0x15c>
81141404:	80000015 	stw	zero,0(r16)
81141408:	183fde26 	beq	r3,zero,81141384 <__reset+0xfb121384>
8114140c:	95c8983a 	sll	r4,r18,r23
81141410:	a0806217 	ldw	r2,392(r20)
81141414:	a5800117 	ldw	r22,4(r20)
81141418:	2084703a 	and	r2,r4,r2
8114141c:	10000b26 	beq	r2,zero,8114144c <__call_exitprocs+0x154>
81141420:	a0806317 	ldw	r2,396(r20)
81141424:	2088703a 	and	r4,r4,r2
81141428:	20000c1e 	bne	r4,zero,8114145c <__call_exitprocs+0x164>
8114142c:	89400017 	ldw	r5,0(r17)
81141430:	d9000017 	ldw	r4,0(sp)
81141434:	183ee83a 	callr	r3
81141438:	a0800117 	ldw	r2,4(r20)
8114143c:	15bfbf1e 	bne	r2,r22,8114133c <__reset+0xfb12133c>
81141440:	98800017 	ldw	r2,0(r19)
81141444:	153fcf26 	beq	r2,r20,81141384 <__reset+0xfb121384>
81141448:	003fbc06 	br	8114133c <__reset+0xfb12133c>
8114144c:	183ee83a 	callr	r3
81141450:	003ff906 	br	81141438 <__reset+0xfb121438>
81141454:	a5c00115 	stw	r23,4(r20)
81141458:	003feb06 	br	81141408 <__reset+0xfb121408>
8114145c:	89000017 	ldw	r4,0(r17)
81141460:	183ee83a 	callr	r3
81141464:	003ff406 	br	81141438 <__reset+0xfb121438>
81141468:	a0800017 	ldw	r2,0(r20)
8114146c:	a027883a 	mov	r19,r20
81141470:	1029883a 	mov	r20,r2
81141474:	003fb606 	br	81141350 <__reset+0xfb121350>
81141478:	0005883a 	mov	r2,zero
8114147c:	003ffb06 	br	8114146c <__reset+0xfb12146c>

81141480 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
81141480:	defffc04 	addi	sp,sp,-16
81141484:	de00012e 	bgeu	sp,et,8114148c <_exit+0xc>
81141488:	003b68fa 	trap	3
8114148c:	dfc00315 	stw	ra,12(sp)
81141490:	df000215 	stw	fp,8(sp)
81141494:	df000204 	addi	fp,sp,8
81141498:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114149c:	d0a01217 	ldw	r2,-32696(gp)
811414a0:	10800058 	cmpnei	r2,r2,1
811414a4:	1000031e 	bne	r2,zero,811414b4 <_exit+0x34>
811414a8:	01204534 	movhi	r4,33044
811414ac:	21198404 	addi	r4,r4,26128
811414b0:	112d1440 	call	8112d144 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
811414b4:	d0a01217 	ldw	r2,-32696(gp)
811414b8:	10800058 	cmpnei	r2,r2,1
811414bc:	1000041e 	bne	r2,zero,811414d0 <_exit+0x50>
811414c0:	e17fff17 	ldw	r5,-4(fp)
811414c4:	01204534 	movhi	r4,33044
811414c8:	21198f04 	addi	r4,r4,26172
811414cc:	112d1440 	call	8112d144 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
811414d0:	d0a01217 	ldw	r2,-32696(gp)
811414d4:	10800058 	cmpnei	r2,r2,1
811414d8:	1000031e 	bne	r2,zero,811414e8 <_exit+0x68>
811414dc:	01204534 	movhi	r4,33044
811414e0:	21199a04 	addi	r4,r4,26216
811414e4:	112d1440 	call	8112d144 <alt_log_printf_proc>
  ALT_OS_STOP();
811414e8:	d0208205 	stb	zero,-32248(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
811414ec:	d0a01217 	ldw	r2,-32696(gp)
811414f0:	10800058 	cmpnei	r2,r2,1
811414f4:	1000031e 	bne	r2,zero,81141504 <_exit+0x84>
811414f8:	01204534 	movhi	r4,33044
811414fc:	2119a404 	addi	r4,r4,26256
81141500:	112d1440 	call	8112d144 <alt_log_printf_proc>
81141504:	e0bfff17 	ldw	r2,-4(fp)
81141508:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114150c:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
81141510:	10000226 	beq	r2,zero,8114151c <_exit+0x9c>
    ALT_SIM_FAIL();
81141514:	002af070 	cmpltui	zero,zero,43969
81141518:	00000106 	br	81141520 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114151c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
81141520:	d0a01217 	ldw	r2,-32696(gp)
81141524:	10800058 	cmpnei	r2,r2,1
81141528:	1000031e 	bne	r2,zero,81141538 <_exit+0xb8>
8114152c:	01204534 	movhi	r4,33044
81141530:	2119ae04 	addi	r4,r4,26296
81141534:	112d1440 	call	8112d144 <alt_log_printf_proc>
  while (1);
81141538:	003fff06 	br	81141538 <__reset+0xfb121538>
