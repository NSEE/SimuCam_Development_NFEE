
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x0004cde0 memsz 0x0006654c flags rwx
    LOAD off    0x0004e000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  0004e000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00045a54  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000535c  81145cb0  81145cb0  00046cb0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  8114b00c  8114b00c  0004c00c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001976c  8114ce00  8114ce00  0004de00  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116656c  8116656c  0004e000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  0004e000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0004e000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d58  00000000  00000000  0004e028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0006e61f  00000000  00000000  0004fd80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0001630b  00000000  00000000  000be39f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0002198a  00000000  00000000  000d46aa  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009414  00000000  00000000  000f6034  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000c4d4  00000000  00000000  000ff448  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  0010b91c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  001327e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  00132828  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00140991  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  00140997  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  001409a3  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  001409a4  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  001409a5  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  001409a9  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  001409ad  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  001409b1  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  001409bc  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  001409c6  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  001409d0  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  001409e1  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     002827ef  00000000  00000000  00140a20  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
81145cb0 l    d  .rodata	00000000 .rodata
8114b00c l    d  .rwdata	00000000 .rwdata
8114ce00 l    d  .bss	00000000 .bss
8116656c l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
00000000 l    df *ABS*	00000000 data_packet.c
81104d7c l     F .text	00000050 uliDpktReadReg
81104d28 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
8114ce1c l     O .bss	00000004 viCh1HoldContext
8114ce20 l     O .bss	00000004 viCh2HoldContext
8114ce24 l     O .bss	00000004 viCh3HoldContext
8114ce28 l     O .bss	00000004 viCh4HoldContext
8114ce2c l     O .bss	00000004 viCh5HoldContext
8114ce30 l     O .bss	00000004 viCh6HoldContext
8114ce34 l     O .bss	00000004 viCh7HoldContext
8114ce38 l     O .bss	00000004 viCh8HoldContext
81105d28 l     F .text	00000054 vFeebWriteReg
81105d7c l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
8114ce3c l     O .bss	00000004 viCh1HoldContext
8114ce40 l     O .bss	00000004 viCh2HoldContext
8114ce44 l     O .bss	00000004 viCh3HoldContext
8114ce48 l     O .bss	00000004 viCh4HoldContext
8114ce4c l     O .bss	00000004 viCh5HoldContext
8114ce50 l     O .bss	00000004 viCh6HoldContext
8114ce54 l     O .bss	00000004 viCh7HoldContext
8114ce58 l     O .bss	00000004 viCh8HoldContext
81108a94 l     F .text	00000054 vRmapWriteReg
81108ae8 l     F .text	00000050 uliRmapReadReg
81108b38 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110946c l     F .text	00000050 uliSpwcReadReg
81109418 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8114cd28 l     O .rwdata	00000001 ucIoValue
8110966c l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
81109f5c l     F .text	0000013c msgdma_write_extended_descriptor
8110a098 l     F .text	00000164 msgdma_construct_extended_descriptor
8110a1fc l     F .text	00000318 msgdma_descriptor_async_transfer
8110a514 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110b090 l     F .text	00000054 vRstcWriteReg
8110b0e4 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8114ce60 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
8114ce68 l     O .bss	00000004 pxNFee.5254
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
8114ce6c l     O .bss	00000004 xRAckLocal.5463
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
8114ce70 l     O .bss	00000004 bDmaBack.5410
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8114ce74 l     O .bss	00000004 xSAckLocal.5448
00000000 l    df *ABS*	00000000 parser_comm_task.c
8114cfec l     O .bss	0000004c PreParsedLocal.5541
8114d038 l     O .bss	00000054 xTcPusL.5540
00000000 l    df *ABS*	00000000 receiver_uart_task.c
8114d08c l     O .bss	0000004c xPreParsedReader.5529
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
8114d0d8 l     O .bss	00000054 xPusLocal.5726
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
81148a07 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
8114a44d l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
8114b00c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
8111c9f0 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114a61a l     O .rodata	00000010 zeroes.4389
8114a62a l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
8114a63a l     O .rodata	00000010 zeroes.4404
81121668 l     F .text	000000c4 __sbprintf
8114a64a l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
8114a662 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
81123350 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
81124ea0 l     F .text	00000008 __fp_unlock
81124eb4 l     F .text	000001a4 __sinit.part.1
81125058 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
8114b858 l     O .rwdata	00000020 lc_ctype_charset
8114b838 l     O .rwdata	00000020 lc_message_charset
8114b878 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8114a6a0 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
81127ec8 l     F .text	0000006c sulp
8114a7e8 l     O .rodata	00000014 fpi.2737
8114a7fc l     O .rodata	00000028 tinytens
8114a7d4 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114a834 l     O .rodata	00000010 blanks.4332
8114a824 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8112b538 l     F .text	00000104 __sprint_r.part.0
8114a854 l     O .rodata	00000010 blanks.4348
8114a844 l     O .rodata	00000010 zeroes.4349
8112cad4 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
8112cf88 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
81130d24 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81130e68 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81130e9c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
81131120 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
81131218 l       .text	00000000 tx_next_char
81131240 l       .text	00000000 end_tx
81131220 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
81131d1c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81131f98 l     F .text	00000044 alt_get_errno
81131fdc l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81132204 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
8114cd70 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
811327a4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
8114cd7c l     O .rwdata	00000004 lockid
8114cf34 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
8114cd80 l     O .rwdata	00000004 lockid
8114cf3c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
81134230 l     F .text	00000050 OS_InitMisc
81134280 l     F .text	00000074 OS_InitRdyList
81134404 l     F .text	000000ec OS_InitTCBList
81134148 l     F .text	000000e8 OS_InitEventList
811342f4 l     F .text	00000088 OS_InitTaskIdle
8113437c l     F .text	00000088 OS_InitTaskStat
81134694 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
811364ac l     F .text	000000fc OS_FlagTaskRdy
8113625c l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
81137d98 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8113c614 l     F .text	00000044 OSTmr_Lock
8113c0b4 l     F .text	00000074 OSTmr_Alloc
8113c658 l     F .text	0000003c OSTmr_Unlock
8113c518 l     F .text	000000fc OSTmr_Unlink
8113c128 l     F .text	000000a4 OSTmr_Free
8113c3c8 l     F .text	00000150 OSTmr_Link
8113c340 l     F .text	00000088 OSTmr_InitTask
8113c694 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
8113c7a4 l     F .text	0000003c alt_dev_reg
8114baf4 l     O .rwdata	0000106c jtag_uart_0
8114cb60 l     O .rwdata	000000d0 rs232_uart
8114cc30 l     O .rwdata	00000064 dma_DDR_M1
8114cc94 l     O .rwdata	00000064 dma_DDR_M2
8114ccf8 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81141034 l     F .text	000002bc altera_avalon_jtag_uart_irq
811412f0 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81141af4 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
81141e8c l     F .text	000000a4 altera_avalon_uart_irq
81141f30 l     F .text	00000140 altera_avalon_uart_rxirq
81142070 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81142278 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
8114252c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
811427b0 l     F .text	00000044 alt_get_errno
811427f4 l     F .text	0000009c alt_msgdma_write_standard_descriptor
81142890 l     F .text	00000134 alt_msgdma_write_extended_descriptor
811429c4 l     F .text	0000018c alt_msgdma_irq
81142b50 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81142be4 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
81142d40 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
81143080 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81143788 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81143834 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
81144a00 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
81145044 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
8114cfe4 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
8114cfe8 g     O .bss	00000004 alt_instruction_exception_handler
81106164 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
8114d654 g     O .bss	00001000 vFeeTask0_stk
81116bcc g     F .text	0000004c vFailDeleteInitialization
8114cfb8 g     O .bss	00000004 aux_status_register
8114e654 g     O .bss	00001000 vInAckHandlerTask_stk
811447bc g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
811064ac g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110b754 g     F .text	0000004c vSyncInitIrq
81112c80 g     F .text	00000284 vCheckRetransmission128
8112754c g     F .text	0000007c _mprec_log10
8110b95c g     F .text	00000040 bSyncSetMbt
81109850 g     F .text	00000108 I2C_Read
8114cdce g     O .rwdata	00000002 OSTaskNameSize
8114ce7c g     O .bss	00000004 xWaitSyncQFee
8114f654 g     O .bss	00000260 xBuffer64
81127640 g     F .text	0000008c __any_on
81126014 g     F .text	0000005c _isatty_r
8114a6ac g     O .rodata	00000028 __mprec_tinytens
81106454 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
81131e3c g     F .text	0000015c alt_main
8111c914 g     F .text	000000c8 _puts_r
8110529c g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
8114cf44 g     O .bss	00000004 OSTmrFreeList
8116646c g     O .bss	00000100 alt_irq
81126184 g     F .text	00000068 _lseek_r
81119180 g     F .text	00000030 vChangeDefaultAutoResetSync
81136d0c g     F .text	000000d4 OS_MemInit
811156b0 g     F .text	000009d4 vLoadDefaultETHConf
8110e2b8 g     F .text	0000014c bCheckInAck64
8114f8b4 g     O .bss	00000150 xPus
8113b5f4 g     F .text	00000068 OSTimeSet
8111192c g     F .text	0000008c vPusType250run
81125258 g     F .text	000000ac __sflags
81117b10 g     F .text	00000068 vCoudlNotCreateNFee2Task
81117efc g     F .text	0000004c vCouldNotGetMutexMebPus
8112fe84 g     F .text	00000088 .hidden __eqdf2
81111ff8 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111906c g     F .text	00000034 vLoadDefaultSyncSource
81116664 g     F .text	0000004c vFailCreateMutexDMA
8113cca4 g     F .text	000001ac Check_for_Master_Boot_Record
81160628 g     O .bss	00000010 OSTmrWheelTbl
8110654c g     F .text	00000050 uliRmapCh3WriteCmdAddress
81143548 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
8114fa04 g     O .bss	00000010 xFeeQueueTBL3
81132e94 g     F .text	00000594 OSEventPendMulti
8114ce80 g     O .bss	00000004 xNfeeSchedule
8116656c g       *ABS*	00000000 __alt_heap_start
8114567c g     F .text	0000002c OSTaskCreateHook
81140b1c g     F .text	000001c4 alt_up_sd_card_fclose
8114ce84 g     O .bss	00000004 xSemCountBuffer64
81106950 g     F .text	00000088 bRmapGetIrqControl
8111c758 g     F .text	00000044 printf
8114ce5d g     O .bss	00000001 SspdConfigControl
8110bd78 g     F .text	00000054 bSyncCtrReset
8114cda6 g     O .rwdata	00000002 OSMboxEn
81119c44 g     F .text	000000a4 aatoh
8113348c g     F .text	00000054 OSIntEnter
8112dbf4 g     F .text	000000a4 _wcrtomb_r
811051a8 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
81116b34 g     F .text	0000004c vFailReceiverCreate
8114ce88 g     O .bss	00000004 xQMaskDataCtrl
81104e0c g     F .text	00000040 vFeebCh2HandleIrq
8111ce7c g     F .text	00000064 __sseek
81125208 g     F .text	00000010 __sinit
8110a9d0 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
81122fd0 g     F .text	00000148 __swbuf_r
81113458 g     F .text	000004a4 bResourcesInitRTOS
81108fb8 g     F .text	000000f4 bSpwcGetLinkError
8114cdb6 g     O .rwdata	00000002 OSQEn
81105e8c g     F .text	00000040 vRmapCh4HandleIrq
811260a0 g     F .text	00000084 _setlocale_r
8114fa14 g     O .bss	00000010 SyncTBL2
8114cd2c g     O .rwdata	00000004 LedsPainelControl
8114d154 g     O .bss	00000100 cDebugBuffer
81125060 g     F .text	00000070 __sfmoreglue
8112b520 g     F .text	00000018 ungetc
81132b50 g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
811456fc g     F .text	00000028 OSTaskStatHook
81111e54 g     F .text	00000088 vSendCmdQToNFeeCTRL
811190dc g     F .text	00000030 vChangeDefaultSyncSource
8114cf48 g     O .bss	00000001 OSLockNesting
8114cf4c g     O .bss	00000004 OSTmrSemSignal
8111846c g     F .text	00000140 vNFeeStructureInit
8114ce8c g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
81127f34 g     F .text	00001600 _strtod_r
8114ce90 g     O .bss	00000004 xSemCountSenderACK
81119d80 g     F .text	00000448 .hidden __divsf3
8114cfdc g     O .bss	00000004 current_sector_modified
8114cdf4 g     O .rwdata	00000002 OSDataSize
8114cf50 g     O .bss	00000001 OSRunning
81109294 g     F .text	00000184 bSpwcInitCh
81131b04 g     F .text	00000064 alt_log_jtag_uart_isr_proc
8114fa24 g     O .bss	00001000 senderTask_stk
81107444 g     F .text	00000094 bRmapGetMemConfigStat
8114ce94 g     O .bss	00000004 fp
81150a24 g     O .bss	00000030 xNfeeScheduleTBL
8110e170 g     F .text	00000148 bCheckInAck128
81126514 g     F .text	0000015c memmove
81145778 g     F .text	0000002c OSInitHookBegin
8110c214 g     F .text	00000074 bSyncCtrCh8OutEnable
8110d3e8 g     F .text	0000006c bEnableDbBuffer
8114cdec g     O .rwdata	00000002 OSTmrSize
811251f0 g     F .text	00000018 _cleanup
811195a8 g     F .text	00000040 siCloseFile
81105ba4 g     F .text	00000184 bFeebInitCh
81126670 g     F .text	000000b0 _Balloc
8111910c g     F .text	00000038 vLoadDefaultAutoResetSync
81106a60 g     F .text	000000d8 bRmapSetCodecConfig
8113f6f8 g     F .text	000000cc alt_up_sd_card_is_Present
81143488 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8114ce08 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
8113c9cc g     F .text	00000054 Save_Modified_Sector
811053fc g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
8114cf54 g     O .bss	00000004 OSIdleCtr
8114cf10 g     O .bss	00000001 alt_log_write_on_flag
811094bc g     F .text	0000003c bEnableIsoDrivers
8112ff0c g     F .text	000000dc .hidden __gtdf2
8114540c g     F .text	0000002c altera_nios2_gen2_irq_init
811454f4 g       .text	00000000 OSStartTsk
8110bad0 g     F .text	00000070 bSyncSetNCycles
81134a04 g     F .text	000002dc OS_TCBInit
8114cf13 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
81118cf4 g     F .text	00000078 vInitSimucamBasicHW
81150a54 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110c12c g     F .text	00000074 bSyncCtrCh6OutEnable
81109bcc g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
8114cfd4 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
8114cf58 g     O .bss	00000002 OSTmrUsed
8114ce98 g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
811068a8 g     F .text	000000a8 bRmapSetIrqControl
81151a54 g     O .bss	00001000 vDataControlTask_stk
81104e8c g     F .text	00000040 vFeebCh4HandleIrq
8114cdf2 g     O .rwdata	00000002 OSTmrWheelTblSize
8111899c g     F .text	0000002c cFeeSpwChannelDisable
8114cd92 g     O .rwdata	00000002 OSEventSize
8114cf5a g     O .bss	00000001 OSPrioHighRdy
8111b8f4 g     F .text	00000064 _fstat_r
811456a8 g     F .text	0000002c OSTaskDelHook
8114ceec g     O .bss	00000004 errno
8110c508 g     F .text	0000003c uliSyncGetCtr
81122f60 g     F .text	0000001c __svfscanf
8111cdf0 g     F .text	00000008 __seofread
811454d4 g       .text	00000000 OSStartHighRdy
811183cc g     F .text	00000028 vEvtChangeFeeControllerMode
8110d4b8 g     F .text	00000968 vPrintConsoleNFee
8110f0b4 g     F .text	000000c8 bSendCmdQToNFeeInst
81105f4c g     F .text	00000040 vRmapCh7HandleIrq
8113a024 g     F .text	000001ec OSTaskCreateExt
811605fc g     O .bss	00000011 alt_log_write_buf
811047b8 g     F .text	0000012c bDpktGetPacketConfig
811066dc g     F .text	00000050 uliRmapCh8WriteCmdAddress
81116ef0 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
8112a064 g     F .text	00001244 ___svfiprintf_internal_r
81110b88 g     F .text	00000364 bPreParserV2
81135d8c g     F .text	00000068 OSFlagPendGetFlagsRdy
8114cdd2 g     O .rwdata	00000002 OSTaskStatStkSize
81134ed8 g     F .text	00000310 OSFlagAccept
811384b4 g     F .text	000000c0 OSQFlush
81137f30 g     F .text	00000148 OSQAccept
8114cf24 g     O .bss	00000004 alt_argv
81154d24 g       *ABS*	00000000 _gp
811167fc g     F .text	0000004c vFailSendPreAckReceiverSemaphore
81132668 g     F .text	0000013c usleep
8113fcd0 g     F .text	00000384 alt_up_sd_card_fopen
81119414 g     F .text	00000030 bSDcardIsPresent
81110eec g     F .text	00000178 vSenderComTask
8113f838 g     F .text	000000d8 alt_up_sd_card_find_first
81117090 g     F .text	00000068 vFailSendNack
8114cfc8 g     O .bss	00000004 command_argument_register
81139b2c g     F .text	000004f8 OSTaskChangePrio
811114f0 g     F .text	000000ac vPusMebInTaskConfigMode
81117808 g     F .text	00000088 vCouldNotSendTMPusCommand
8114cf40 g     O .bss	00000004 alt_heapsem
81109e64 g     F .text	00000080 bSetBoardLeds
81134ce0 g     F .text	000001f8 OSDebugInit
8113a210 g     F .text	0000034c OSTaskDel
81136de0 g     F .text	000001ac OSMutexAccept
81152a54 g     O .bss	000002b4 xSimMeb
81118bd8 g     F .text	00000040 vSetTimeCode
81144030 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
8114ce9c g     O .bss	00000004 xSemCountPreParsed
8114b8d8 g     O .rwdata	00000180 alt_fd_list
8110534c g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
8114ba74 g     O .rwdata	0000001d alt_log_msg_alt_main
81160638 g     O .bss	00000580 OSFlagTbl
811061ec g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
81116964 g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
811065ec g     F .text	00000050 uliRmapCh5WriteCmdAddress
81118fc4 g     F .text	0000003c vLoadDefaultRTValue
81133f10 g     F .text	000000c0 OS_EventTaskRemove
81152d08 g     O .bss	00001000 vFeeTask5_stk
8114cf12 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
8113ef4c g     F .text	00000134 find_first_empty_record_in_root_directory
81144af0 g     F .text	00000098 alt_find_dev
8111c440 g     F .text	00000150 memcpy
8112d8c0 g     F .text	00000264 __hexnan
81104bb4 g     F .text	00000174 bDpktInitCh
81153d08 g     O .bss	00000160 xBuffer32
8114cdbc g     O .rwdata	00000002 OSRdyTblSize
81160bb8 g     O .bss	000001a0 OSTmrTbl
81124ea8 g     F .text	0000000c _cleanup_r
81130a60 g     F .text	000000e4 .hidden __floatsidf
811152d8 g     F .text	000001a8 vSendPusTM64
8110b8cc g     F .text	0000004c ucSyncStatusErrorCode
81111f64 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
81118a98 g     F .text	00000034 cFeeRMAPLogDisable
8110f474 g     F .text	00000df0 vParserCommTask
81145110 g     F .text	00000084 alt_io_redirect
81118a2c g     F .text	00000034 cFeeRMAPEchoingDisable
8112ffe8 g     F .text	000000f4 .hidden __ltdf2
81117e48 g     F .text	0000004c vFailSendPUStoMebTask
811063fc g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
81105628 g     F .text	000000d4 bFeebSetIrqControl
81117600 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
8114cea0 g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
811444b8 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
81144800 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110be20 g     F .text	00000054 bSyncCtrErrInj
81144760 g     F .text	0000005c alt_msgdma_register_callback
81116084 g     F .text	00000330 vShowEthConfig
81118d6c g     F .text	00000030 bLogWriteSDCard
81116c80 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
8111c9dc g     F .text	00000014 puts
81119628 g     F .text	00000238 bInitSync
81145820 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110b5dc g     F .text	0000014c vSyncHandleIrq
81132c24 g     F .text	00000128 OSEventNameGet
81105010 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
8114cda0 g     O .rwdata	00000002 OSFlagMax
811262a0 g     F .text	000000e0 mbrtowc
8113eb44 g     F .text	000001b4 find_first_empty_cluster
81112080 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110c0b8 g     F .text	00000074 bSyncCtrCh5OutEnable
8114ce64 g     O .bss	00000001 vucN
81127ca0 g     F .text	00000074 __fpclassifyd
8110b82c g     F .text	00000054 bSyncStatusExtnIrq
81122f7c g     F .text	00000054 _vfscanf_r
81137460 g     F .text	000005a4 OSMutexPend
811274a0 g     F .text	000000ac __ratio
8113f634 g     F .text	000000c4 alt_up_sd_card_open_dev
81117890 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
811334e0 g     F .text	00000100 OSIntExit
8110b99c g     F .text	00000040 bSyncSetBt
8112cab8 g     F .text	0000001c __vfiprintf_internal
81117f48 g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
8114cdda g     O .rwdata	00000002 OSTCBSize
81104fcc g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
8114cf5b g     O .bss	00000001 OSPrioCur
81141564 g     F .text	000002c4 altera_avalon_jtag_uart_read
81143cf8 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
8111c720 g     F .text	00000038 _printf_r
8112ea28 g     F .text	00000064 .hidden __udivsi3
81131164 g     F .text	000000ac isatty
8114ce5c g     O .bss	00000001 LedsBoardControl
8114cea4 g     O .bss	00000004 xSemCountReceivedACK
8114cdc0 g     O .rwdata	00000002 OSStkWidth
81126070 g     F .text	00000030 iswspace
8114a6fc g     O .rodata	000000c8 __mprec_tens
8114cdb4 g     O .rwdata	00000002 OSPtrSize
81117cb0 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
81126124 g     F .text	0000000c __locale_charset
8110bfd0 g     F .text	00000074 bSyncCtrCh3OutEnable
8112ec18 g     F .text	000000c8 .hidden __lesf2
8114cd94 g     O .rwdata	00000002 OSEventTblSize
8112ddf4 g     F .text	0000007c .hidden __fixunsdfsi
81145438 g       .text	00000000 OSCtxSw
81109958 g     F .text	00000160 I2C_MultipleRead
81131ca8 g     F .text	00000074 alt_log_system_clock
8114cef8 g     O .bss	00000004 __malloc_top_pad
8114cf5c g     O .bss	00000004 OSTCBList
8113c074 g     F .text	00000040 OSTmrSignal
8114cf08 g     O .bss	00000004 alt_fd_list_lock
81129b90 g     F .text	0000001c strtoul
8114cd44 g     O .rwdata	00000004 __mb_cur_max
81126154 g     F .text	0000000c _localeconv_r
81129bac g     F .text	000002e0 _strtoull_r
8110b020 g     F .text	00000070 vRstcHoldDeviceReset
81126a94 g     F .text	00000044 __i2b
811259b8 g     F .text	000004c4 __sfvwrite_r
8113de24 g     F .text	000000c0 get_dir_divider_location
81106098 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
81160d58 g     O .bss	00000c30 OSMemTbl
8114cf60 g     O .bss	00000001 OSTickStepState
811318b8 g     F .text	00000060 alt_log_printf_proc
81104af0 g     F .text	000000c4 bDpktGetPixelDelay
81153e68 g     O .bss	00001800 vReceiverUartTask_stk
8111cbe8 g     F .text	0000005c _sbrk_r
8114cea8 g     O .bss	00000004 xSemTimeoutChecker
8113dae4 g     F .text	000000cc filename_to_upper_case
8114cf14 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
8114cdb8 g     O .rwdata	00000002 OSQMax
81140054 g     F .text	00000090 alt_up_sd_card_set_attributes
8113715c g     F .text	00000304 OSMutexDel
81161988 g     O .bss	00001000 OSTaskStatStk
81119444 g     F .text	00000030 bSDcardFAT16Check
81136928 g     F .text	000000f8 OSMemNameGet
81116604 g     F .text	00000060 vFailCreateMutexSResources
8113ce50 g     F .text	00000284 Read_File_Record_At_Offset
81155668 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
8114cd98 g     O .rwdata	00000002 OSFlagEn
811276cc g     F .text	00000068 _read_r
8114cdde g     O .rwdata	00000002 OSTimeTickHookEn
811365a8 g     F .text	000000ac OS_FlagUnlink
8113897c g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
8114cd60 g     O .rwdata	00000004 alt_max_fd
811173ac g     F .text	0000004c vFailTimeoutCheckerTaskCreate
8113454c g     F .text	00000070 OS_MemCopy
811345bc g     F .text	000000d8 OS_Sched
8113e6c8 g     F .text	0000047c find_file_in_directory
8112cc64 g     F .text	000000f8 _fclose_r
81136830 g     F .text	000000f8 OSMemGet
8113a854 g     F .text	000001bc OSTaskNameSet
81124e70 g     F .text	00000030 fflush
8114cef4 g     O .bss	00000004 __malloc_max_sbrked_mem
8114cf64 g     O .bss	00000004 OSCtxSwCtr
81145724 g     F .text	00000054 OSTimeTickHook
811556a8 g     O .bss	00001000 vOutAckHandlerTask_stk
81130f98 g     F .text	00000188 alt_irq_register
8114cda2 g     O .rwdata	00000002 OSFlagNameSize
8111af10 g     F .text	00000118 .hidden __extendsfdf2
81133fd0 g     F .text	00000108 OS_EventTaskRemoveMulti
811179d0 g     F .text	00000070 vFailCreateNFEESyncQueue
8113f7c4 g     F .text	00000074 alt_up_sd_card_is_FAT16
811096e8 g     F .text	00000088 I2C_TestAdress
8112ece0 g     F .text	000008b4 .hidden __adddf3
81160610 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
8112eae4 g     F .text	00000078 .hidden __nesf2
81106054 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
81133db8 g     F .text	00000158 OS_EventTaskWaitMulti
811566a8 g     O .bss	00000010 SyncTBL4
81127238 g     F .text	00000114 __b2d
81143a30 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
8114cdba g     O .rwdata	00000002 OSQSize
8112e3f0 g     F .text	00000540 .hidden __umoddi3
81131d60 g     F .text	000000dc lseek
8113946c g     F .text	00000214 OSSemPend
81117e94 g     F .text	00000068 vCouldNotGetCmdQueueMeb
81106bc4 g     F .text	00000160 bRmapGetCodecStatus
811090ac g     F .text	000000d0 bSpwcGetLinkStatus
81105984 g     F .text	00000088 bFeebGetWindowing
8114cd34 g     O .rwdata	00000004 _global_impure_ptr
8110b590 g     F .text	0000004c bSSDisplayUpdate
8113e188 g     F .text	00000540 get_home_directory_cluster_for_file
81127734 g     F .text	0000056c _realloc_r
8114cda4 g     O .rwdata	00000002 OSLowestPrio
8116656c g       *ABS*	00000000 __bss_end
81144f4c g     F .text	000000f8 alt_iic_isr_register
811457f4 g     F .text	0000002c OSTCBInitHook
8114cdea g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81132558 g     F .text	00000110 alt_tick
8110672c g     F .text	0000017c vRmapInitIrq
811168fc g     F .text	00000068 vFailGetMutexSenderTask
8110af40 g     F .text	0000006c vRstcSimucamReset
8114a864 g     O .rodata	00000100 __hexdig
811445ac g     F .text	000001b4 alt_msgdma_init
8112de70 g     F .text	00000580 .hidden __udivdi3
81110870 g     F .text	0000017c setPreAckSenderFreePos
8112cedc g     F .text	00000024 _fputwc_r
8114cd8c g     O .rwdata	00000002 OSEventEn
8114a6d4 g     O .rodata	00000028 __mprec_bigtens
81126870 g     F .text	0000010c __s2b
8114cde6 g     O .rwdata	00000002 OSTmrCfgNameSize
811566b8 g     O .bss	00000010 xFeeQueueTBL4
8110ba5c g     F .text	00000074 bSyncSetPolarity
81112f04 g     F .text	0000028c vCheckRetransmission64
81130b44 g     F .text	000000b0 .hidden __floatunsidf
8114cf18 g     O .bss	00000004 alt_system_clock_in_sec
81131ab0 g     F .text	00000054 alt_log_jtag_uart_startup_info
81116e88 g     F .text	00000068 vFailFoundBufferRetransmission
81126f70 g     F .text	00000060 __mcmp
8114cfe0 g     O .bss	00000004 current_sector_index
81141d24 g     F .text	00000168 altera_avalon_uart_init
81144888 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
8110409c g     F .text	00000414 bSdmaDmaM2Transfer
81118c18 g     F .text	00000034 vResetTimeCode
81118970 g     F .text	0000002c cFeeSpwChannelEnable
81125228 g     F .text	00000018 __fp_lock_all
81118228 g     F .text	0000004c vFailSendMsgDataCTRL
81144ef8 g     F .text	00000054 alt_ic_irq_enabled
81109770 g     F .text	000000e0 I2C_Write
8110629c g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
8114cf68 g     O .bss	00000002 OSTmrFree
811363c4 g     F .text	000000e8 OS_FlagInit
811324b4 g     F .text	000000a4 alt_alarm_stop
8111d250 g     F .text	0000001c strtol
8114cf11 g     O .bss	00000001 alt_log_sys_clk_on_flag
8113b820 g     F .text	00000140 OSTmrDel
8113cbbc g     F .text	000000e8 mark_cluster
8114cdc8 g     O .rwdata	00000002 OSTaskIdleStkSize
8114cf0c g     O .bss	00000004 alt_irq_active
8113908c g     F .text	000000b8 OSSemAccept
8111b48c g     F .text	0000044c _fseeko_r
81113d90 g     F .text	00000260 vFillMemmoryPattern
8111cfcc g     F .text	00000044 strnlen
81136b3c g     F .text	000000e0 OSMemPut
81136654 g     F .text	000001dc OSMemCreate
8114cf6c g     O .bss	00000004 OSIdleCtrMax
81115480 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
81131300 g     F .text	000005b8 alt_log_private_printf
8114b8b0 g     O .rwdata	00000028 alt_dev_null
81143640 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110ba1c g     F .text	00000040 bSyncSetOst
8114cddc g     O .rwdata	00000002 OSTicksPerSec
8114ba58 g     O .rwdata	00000019 alt_log_msg_bss
8113f080 g     F .text	00000194 convert_filename_to_name_extension
811074d8 g     F .text	00000c4c bRmapSetRmapMemHKArea
81111064 g     F .text	00000330 vSimMebTask
81109ab8 g     F .text	00000094 i2c_start
81145438 g       .text	00000000 OSIntCtxSw
8111813c g     F .text	00000054 vFailSendMsgSync
8110c044 g     F .text	00000074 bSyncCtrCh4OutEnable
81144424 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
81130e40 g     F .text	00000028 alt_dcache_flush_all
8112697c g     F .text	00000068 __hi0bits
811119b8 g     F .text	00000114 vPusType251run
8110663c g     F .text	00000050 uliRmapCh6WriteCmdAddress
81119000 g     F .text	0000003c vChangeRTValue
8114cfb4 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81112afc g     F .text	00000184 vCheck
8111841c g     F .text	00000050 vNFeeNotInUse
811309e0 g     F .text	00000080 .hidden __fixdfsi
81105a94 g     F .text	00000088 bFeebStopCh
8110ead4 g     F .text	000003ec vNFeeControlTask
811566c8 g     O .bss	00001000 vInitialTask_stk
8114ceac g     O .bss	00000002 usiIdCMD
811576c8 g     O .bss	00000010 SyncTBL3
8110bd24 g     F .text	00000054 bSyncCtrStart
8113ecf8 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
81129534 g     F .text	00000018 strtod
81105b1c g     F .text	00000088 bFeebClrCh
8114cf70 g     O .bss	00000004 OSTCBFreeList
811063a4 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
81139680 g     F .text	00000174 OSSemPendAbort
81116a9c g     F .text	0000004c vFailGetMacRTC
8110659c g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
81117314 g     F .text	0000004c vFailCreateTimerRetransmisison
81116e20 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
81114348 g     F .text	000002f0 bSendUART128v2
81118e34 g     F .text	000000ec vSimucamStructureInit
8114cd58 g     O .rwdata	00000008 alt_dev_list
8111b3bc g     F .text	0000004c _fputc_r
811327e8 g     F .text	0000010c write
8111c79c g     F .text	000000a8 _putc_r
8114cfd8 g     O .bss	00000004 device_pointer
8114cde0 g     O .rwdata	00000002 OSVersionNbr
8112eb5c g     F .text	000000bc .hidden __gtsf2
8111830c g     F .text	0000004c vFailFlushMEBQueue
81110264 g     F .text	00000118 getPreParsedPacket
8110d388 g     F .text	00000060 bEnableSPWChannel
81130ee0 g     F .text	000000b8 fstat
81118c80 g     F .text	00000040 vChangeIdNFEEMaster
8111b390 g     F .text	0000002c fprintf
81118a60 g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
811053a4 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
81117460 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
81119924 g     F .text	00000058 _reg_write
81118cc0 g     F .text	00000034 vChangeDefaultIdNFEEMaster
8112ffe8 g     F .text	000000f4 .hidden __ledf2
81105ecc g     F .text	00000040 vRmapCh5HandleIrq
8110d28c g     F .text	0000004c bDisableRmapIRQ
811576d8 g     O .bss	00001000 vStackMonitor_stk
811177a0 g     F .text	00000068 vCouldNotSendLog
8113baa0 g     F .text	000001b8 OSTmrRemainGet
8114cd88 g     O .rwdata	00000004 OSEndiannessTest
8110b134 g     F .text	00000058 v_spi_start
81126cd8 g     F .text	00000148 __pow5mult
811064fc g     F .text	00000050 uliRmapCh2WriteCmdAddress
8112b654 g     F .text	00001464 ___vfiprintf_internal_r
8114cf04 g     O .bss	00000004 __nlocale_changed
8112ea8c g     F .text	00000058 .hidden __umodsi3
8110be74 g     F .text	00000074 bSyncCtrSyncOutEnable
81119474 g     F .text	000000f8 bInitializeSDCard
81117230 g     F .text	0000004c vFailParserCommTaskCreate
81117738 g     F .text	00000068 vCouldNotSendReset
8111cc88 g     F .text	00000038 _scanf_r
811172c8 g     F .text	0000004c vFailOutAckHandlerTaskCreate
8114cd9a g     O .rwdata	00000002 OSFlagGrpSize
8111159c g     F .text	0000008c vPusType250conf
811586d8 g     O .bss	00000058 xInUseRetrans
8110b7dc g     F .text	00000050 bSyncIrqFlagSync
81143a90 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8113bc58 g     F .text	000000ec OSTmrStateGet
8116656c g       *ABS*	00000000 end
81104f0c g     F .text	00000040 vFeebCh6HandleIrq
81113ff0 g     F .text	00000260 vPrintMemmoryPattern
81116fc0 g     F .text	00000068 vNoContentInPreParsedBuffer
8111b8d8 g     F .text	0000001c fseeko
8111037c g     F .text	00000168 bSendMessagePUStoMebTask
81117960 g     F .text	00000070 vFailCreateNFEEQueue
8111b240 g     F .text	0000000c _atoi_r
81142570 g     F .text	00000240 altera_avalon_uart_write
81131244 g     F .text	00000054 alt_log_txchar
8111b470 g     F .text	0000001c fseek
811142b8 g     F .text	00000090 vCCDChangeValues
81140e64 g     F .text	000001d0 altera_avalon_jtag_uart_init
8113484c g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
811166fc g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
81141b78 g     F .text	00000084 alt_avalon_timer_sc_init
811058dc g     F .text	000000a8 bFeebSetWindowing
81141c64 g     F .text	00000068 altera_avalon_uart_write_fd
8111b1d0 g     F .text	00000064 .hidden __clzsi2
81141ccc g     F .text	00000058 altera_avalon_uart_close_fd
81158730 g     O .bss	00000020 xMebQTBL
81141828 g     F .text	000002cc altera_avalon_jtag_uart_write
8113c1cc g     F .text	00000174 OSTmr_Init
81158750 g     O .bss	00000348 xBuffer128
81125218 g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
81126430 g     F .text	000000e4 memchr
811344f0 g     F .text	0000005c OS_MemClr
8111f44c g     F .text	00002200 ___vfprintf_internal_r
81145518 g     F .text	00000164 OSTaskStkInit
8111ccc0 g     F .text	00000060 _sprintf_r
81107170 g     F .text	000002d4 bRmapGetMemConfigArea
8114ceae g     O .bss	00000001 SemCount32
811256a0 g     F .text	00000318 _free_r
81145194 g     F .text	00000234 alt_printf
81115288 g     F .text	00000050 vTimeoutCheck
811199d4 g     F .text	000001fc _print_codec_status
81126130 g     F .text	00000010 __locale_mb_cur_max
81133b00 g     F .text	000001a0 OS_EventTaskRdy
811069d8 g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
81145a6c g     F .text	00000188 __call_exitprocs
8110ef88 g     F .text	0000012c vPerformActionNFCRunning
8114cf74 g     O .bss	00000001 OSCPUUsage
81117be0 g     F .text	00000068 vCoudlNotCreateNFee4Task
8114cf00 g     O .bss	00000004 __mlocale_changed
8110eec0 g     F .text	000000c8 vPerformActionNFCConfig
8110bdcc g     F .text	00000054 bSyncCtrOneShot
8114cd3c g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110c544 g     F .text	0000003c uliSyncReadStatus
8114cf2c g     O .bss	00000004 _alt_tick_rate
81138574 g     F .text	00000294 OSQPend
81129654 g     F .text	000002e8 _strtoll_r
81158a98 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
8113b144 g     F .text	0000010c OSTimeDly
81111880 g     F .text	000000ac vPusMebInTaskRunningMode
8110b7a0 g     F .text	0000003c vSyncIrqFlagClrSync
81126e20 g     F .text	00000150 __lshift
8110f17c g     F .text	000002f8 vOutAckHandlerTask
811434e8 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
8114cf30 g     O .bss	00000004 _alt_nticks
81132248 g     F .text	00000104 read
8113c820 g     F .text	000000f0 alt_sys_init
8111a5cc g     F .text	0000012c .hidden __floatsisf
81106010 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
81129e8c g     F .text	000001d8 __ssprint_r
8111c6b8 g     F .text	00000068 _open_r
811198fc g     F .text	00000028 bTestSimucamCriticalHW
81105830 g     F .text	000000ac bFeebGetBuffersStatus
811163b4 g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
8114cf75 g     O .bss	00000001 OSTaskCtr
81131210 g       .text	00000000 tx_log_str
81111394 g     F .text	0000015c vPusMebTask
81115238 g     F .text	00000050 siPosStr
81111edc g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
8112db24 g     F .text	000000d0 strncmp
8110c580 g     F .text	0000005c bSyncWriteReg
8110634c g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
8113b250 g     F .text	00000164 OSTimeDlyHMSM
81126ad8 g     F .text	00000200 __multiply
811413fc g     F .text	00000070 altera_avalon_jtag_uart_close
8110b304 g     F .text	00000058 v_spi_end
811195e8 g     F .text	00000040 cGetNextChar
81145980 g     F .text	000000ec strncpy
8114d12c g     O .bss	00000028 __malloc_current_mallinfo
8114cd8e g     O .rwdata	00000002 OSEventMax
8112eae4 g     F .text	00000078 .hidden __eqsf2
8112734c g     F .text	00000154 __d2b
811397f4 g     F .text	00000118 OSSemPost
81105098 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111903c g     F .text	00000030 vChangeDefaultRTValue
81104f8c g     F .text	00000040 vFeebCh8HandleIrq
8114cfb0 g     O .bss	00000004 initialized
811150e8 g     F .text	00000100 vSendLog
81133674 g     F .text	000000e4 OSSchedUnlock
8110b35c g     F .text	00000164 RTCC_SPI_R_MAC
8114cd6c g     O .rwdata	00000004 alt_log_boot_on_flag
81140ce0 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112993c g     F .text	00000254 _strtoul_r
81158ad8 g     O .bss	00000010 xFeeQueueTBL5
81144c98 g     F .text	000000e4 alt_get_fd
8114cf78 g     O .bss	00000004 OSMemFreeList
811337d0 g     F .text	000000b8 OSStatInit
811198c8 g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
81165f04 g     O .bss	00000014 search_data
81108da0 g     F .text	00000134 bSpwcSetLink
81130bf4 g     F .text	00000130 alt_busy_sleep
81136190 g     F .text	000000cc OSFlagQuery
8110bee8 g     F .text	00000074 bSyncCtrCh1OutEnable
8114cdc4 g     O .rwdata	00000002 OSTaskCreateExtEn
81119bd0 g     F .text	00000074 _split_codec_status
811232f4 g     F .text	0000005c _close_r
81117028 g     F .text	00000068 vCouldNotSendEthConfUART
8110e550 g     F .text	00000584 vInitialTask
811319b8 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
811439d0 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
81145904 g     F .text	0000007c memcmp
81133ad8 g     F .text	00000028 OS_Dummy
81140db0 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116656c g       *ABS*	00000000 __alt_stack_base
81140e08 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
811050dc g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
8111b958 g     F .text	000000d4 _fwrite_r
81112210 g     F .text	000000a4 vReleaseSyncMessages
81143af0 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
811051ec g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
81123198 g     F .text	0000015c __swsetup_r
81162988 g     O .bss	00000180 OSQTbl
81118018 g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
811605e0 g     O .bss	0000001c xConfEth
8112f594 g     F .text	000008f0 .hidden __divdf3
811190a0 g     F .text	0000003c vChangeSyncSource
811250d0 g     F .text	00000120 __sfp
81165f18 g     O .bss	00000054 boot_sector_data
81117fb0 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
8110920c g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
811275c8 g     F .text	00000078 __copybits
8114b430 g     O .rwdata	00000408 __malloc_av_
81125224 g     F .text	00000004 __sinit_lock_release
8114ce00 g     O .bss	00000004 uliInitialState
81109b4c g     F .text	00000080 i2c_stop
81119ce8 g     F .text	00000064 Verif_Error
81119d4c g     F .text	00000034 toInt
81116848 g     F .text	0000004c vFailSendPreAckSenderSemaphore
8114cf7c g     O .bss	00000004 OSTCBHighRdy
8111a7f0 g     F .text	00000720 .hidden __muldf3
8111cd94 g     F .text	0000005c __sread
81125538 g     F .text	0000003c fread
8114cf80 g     O .bss	00000004 OSQFreeList
81144b88 g     F .text	00000110 alt_find_file
81144a44 g     F .text	000000ac alt_dev_llist_insert
81132a28 g     F .text	00000128 __malloc_lock
8111b360 g     F .text	00000030 _fprintf_r
811323b8 g     F .text	000000fc sbrk
811188ec g     F .text	0000002c vFeeSpwRMAPLoadDefault
81116db8 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
8111d26c g     F .text	000021e0 ___svfprintf_internal_r
81115628 g     F .text	00000088 vTMPusTestConnection
8114ceb0 g     O .bss	00000004 xMebQ
81132d4c g     F .text	00000148 OSEventNameSet
81124e0c g     F .text	00000064 _fflush_r
8112cb98 g     F .text	000000cc _calloc_r
8114cf84 g     O .bss	00000001 OSRdyGrp
811181dc g     F .text	0000004c vFailSendMsgFeeCTRL
8110b918 g     F .text	00000044 ucSyncStatusCycleNumber
81106b38 g     F .text	0000008c bRmapGetCodecConfig
8113bd44 g     F .text	00000148 OSTmrStart
81104ecc g     F .text	00000040 vFeebCh5HandleIrq
8111b348 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
8114ce00 g       *ABS*	00000000 __bss_start
8111c590 g     F .text	00000128 memset
81110734 g     F .text	0000013c setPreParsedFreePos
8110cf64 g     F .text	00000198 vQCmdFEEinStandBy
8114454c g     F .text	00000060 alt_msgdma_open
811191f8 g     F .text	0000021c pattern_createPattern
81113c10 g     F .text	00000180 main
811169cc g     F .text	00000068 vFailGetMutexReceiverTask
81158ae8 g     O .bss	00001000 vNFeeControlTask_stk
811061a8 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
81118f58 g     F .text	0000003c vChangeEPValue
811062f4 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
8114cf28 g     O .bss	00000004 alt_envp
81118274 g     F .text	0000004c vFailFlushQueue
8114cef0 g     O .bss	00000004 __malloc_max_total_mem
81143df0 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
81116458 g     F .text	0000005c ucCrc8wInit
81117360 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
81140d48 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
81109d04 g     F .text	00000160 i2c_read
81159ae8 g     O .bss	00000010 SyncTBL5
81123118 g     F .text	00000018 __swbuf
8114ab64 g     O .rodata	00000100 OSUnMapTbl
8112ec18 g     F .text	000000c8 .hidden __ltsf2
811400e4 g     F .text	00000090 alt_up_sd_card_get_attributes
81125304 g     F .text	00000234 _fread_r
81116894 g     F .text	00000068 vFailGetCountSemaphoreSenderTask
811094f8 g     F .text	0000003c bDisableIsoDrivers
8114cdbe g     O .rwdata	00000002 OSSemEn
8113c910 g     F .text	000000bc Write_Sector_Data
811404f4 g     F .text	00000628 alt_up_sd_card_write
8114ceb4 g     O .bss	00000004 xFeeQ
81135df4 g     F .text	0000039c OSFlagPost
8111cee0 g     F .text	00000008 __sclose
81117668 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
8112cd5c g     F .text	00000014 fclose
81133ca0 g     F .text	00000118 OS_EventTaskWait
81117530 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
8111d010 g     F .text	00000240 _strtol_r
8111b028 g     F .text	000001a8 .hidden __truncdfsf2
81159af8 g     O .bss	00000010 xFeeQueueTBL2
81134930 g     F .text	000000d4 OS_TaskStatStkChk
8113a55c g     F .text	00000158 OSTaskDelReq
811048e4 g     F .text	000000c4 bDpktGetPacketHeader
81105dcc g     F .text	00000040 vRmapCh1HandleIrq
81123558 g     F .text	00001690 _dtoa_r
8114410c g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
8111bc2c g     F .text	00000814 _malloc_r
8112dd60 g     F .text	00000030 __ascii_wctomb
81136f8c g     F .text	000001d0 OSMutexCreate
811174c8 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
8110e404 g     F .text	0000014c bCheckInAck32
8114cd64 g     O .rwdata	00000004 alt_errno
81143c38 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81133758 g     F .text	00000078 OSStart
81108ed4 g     F .text	000000e4 bSpwcGetLink
8110aa58 g     F .text	000004e8 POWER_SPI_RW
8112b2a8 g     F .text	000000dc __submore
81131918 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
811329c0 g     F .text	00000068 __env_unlock
81117aa8 g     F .text	00000068 vCoudlNotCreateNFee1Task
81125e7c g     F .text	000000cc _fwalk
8113aa10 g     F .text	000001dc OSTaskResume
81136c1c g     F .text	000000f0 OSMemQuery
8114cdd0 g     O .rwdata	00000002 OSTaskStatEn
8116656c g       *ABS*	00000000 __alt_stack_limit
8114ce18 g     O .bss	00000004 ECommSpwCh
81119144 g     F .text	0000003c vChangeAutoResetSync
811263cc g     F .text	00000064 _mbtowc_r
8110de20 g     F .text	00000350 vInAckHandlerTaskV2
8114cdaa g     O .rwdata	00000002 OSMemMax
81138aec g     F .text	00000178 OSQPostFront
8111c844 g     F .text	000000d0 putc
8112e930 g     F .text	00000084 .hidden __divsi3
8114cf85 g     O .bss	00000006 OSRdyTbl
8114cd84 g     O .rwdata	00000002 OSDebugEn
8114bac8 g     O .rwdata	0000002a alt_log_msg_cache
81125574 g     F .text	0000012c _malloc_trim_r
811088f0 g     F .text	000001a4 bRmapInitCh
8114cee4 g     O .bss	00000008 xSdHandle
8111a1c8 g     F .text	00000404 .hidden __mulsf3
8114cd9c g     O .rwdata	00000002 OSFlagNodeSize
8114ce04 g     O .bss	00000004 pnt_memory
811191b0 g     F .text	00000048 vSyncReset
8110b9dc g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
8114cfbc g     O .bss	00000004 status_register
8114cde4 g     O .rwdata	00000002 OSTmrCfgMax
8110c370 g     F .text	00000074 bSyncIrqFlagClrError
811170f8 g     F .text	00000068 vFailSetPreAckSenderBuffer
81127dec g     F .text	000000dc strcmp
8114cfc4 g     O .bss	00000004 command_register
81138078 g     F .text	000001b4 OSQCreate
8113a6b4 g     F .text	000001a0 OSTaskNameGet
81159b08 g     O .bss	00001000 vFeeTask4_stk
8115ab08 g     O .bss	00000018 xReceivedACK
81138c64 g     F .text	00000214 OSQPostOpt
81133888 g     F .text	00000228 OSTimeTick
8114cdcc g     O .rwdata	00000002 OSTaskMax
81139144 g     F .text	000000e0 OSSemCreate
8114cdf0 g     O .rwdata	00000002 OSTmrWheelSize
811178f8 g     F .text	00000068 vFailCreateScheduleQueue
8111997c g     F .text	00000058 _reg_read
81137c24 g     F .text	00000174 OSMutexQuery
8112fe84 g     F .text	00000088 .hidden __nedf2
8114cdc6 g     O .rwdata	00000002 OSTaskDelEn
81118f20 g     F .text	00000038 vLoadDefaultEPValue
8115ab20 g     O .bss	00001000 vFeeTask1_stk
8110c1a0 g     F .text	00000074 bSyncCtrCh7OutEnable
8113990c g     F .text	00000118 OSSemQuery
8113822c g     F .text	00000288 OSQDel
81138808 g     F .text	00000174 OSQPendAbort
8114ceb8 g     O .bss	00000004 xMutexPreParsed
8113c7e0 g     F .text	00000040 alt_irq_init
8113234c g     F .text	0000006c alt_release_fd
8113cb00 g     F .text	000000bc get_cluster_flag
8110c3e4 g     F .text	00000074 bSyncIrqFlagClrBlank
81144844 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110b728 g     F .text	0000002c vSyncClearCounter
8114ba94 g     O .rwdata	00000031 alt_log_msg_stackpointer
8111cd20 g     F .text	00000074 sprintf
8114a24c g     O .rodata	00000100 .hidden __clz_tab
8113d0d4 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
81116a34 g     F .text	00000068 vFailGetMutexTxUARTSenderTask
8114cefc g     O .bss	00000004 _PathLocale
8110c4b0 g     F .text	00000058 bSyncIrqFlagBlank
8110a910 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8113be8c g     F .text	000001e8 OSTmrStop
811151e8 g     F .text	00000050 usiGetIdCMD
8110c5dc g     F .text	00000058 uliSyncReadReg
8112954c g     F .text	00000108 strtof
81104e4c g     F .text	00000040 vFeebCh3HandleIrq
8112eb5c g     F .text	000000bc .hidden __gesf2
8111cee8 g     F .text	0000004c strcspn
81123130 g     F .text	00000068 _write_r
8110afac g     F .text	00000074 vRstcReleaseDeviceReset
8111727c g     F .text	0000004c vFailInAckHandlerTaskCreate
811335e0 g     F .text	00000094 OSSchedLock
81117b78 g     F .text	00000068 vCoudlNotCreateNFee3Task
81126160 g     F .text	00000018 setlocale
81143b98 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
81162b08 g     O .bss	00000800 OSTmrTaskStk
8111cc44 g     F .text	00000044 scanf
81117de8 g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
811351e8 g     F .text	00000110 OSFlagCreate
8113d368 g     F .text	00000688 Check_for_DOS_FAT
81112108 g     F .text	00000064 vMebInit
8113f214 g     F .text	000002d0 create_file
81127de4 g     F .text	00000008 nanf
8114cd38 g     O .rwdata	00000004 _impure_ptr
8114cfc0 g     O .bss	00000004 CSD_register_w0
8114cf20 g     O .bss	00000004 alt_argc
81116d50 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
81124be8 g     F .text	00000224 __sflush_r
811261ec g     F .text	000000b4 _mbrtowc_r
8110917c g     F .text	00000090 bSpwcGetTimecode
8112614c g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
8114ce10 g     O .bss	00000004 ESdmaBufferSide
8114cd96 g     O .rwdata	00000002 OSEventMultiEn
8111b46c g     F .text	00000004 _fseek_r
8115bb20 g     O .bss	00001800 vParserCommTask_stk
81116594 g     F .text	00000070 printErrorTask
81118f94 g     F .text	00000030 vChangeDefaultEPValue
81113190 g     F .text	000002c8 vCheckRetransmission32
8113b65c g     F .text	000001c4 OSTmrCreate
811122b4 g     F .text	000007dc vStackMonitor
8111ca0c g     F .text	000001dc __srefill_r
81109534 g     F .text	0000003c bEnableLvdsBoard
8114cebc g     O .bss	00000004 xMutexBuffer32
81105e0c g     F .text	00000040 vRmapCh2HandleIrq
811352f8 g     F .text	00000250 OSFlagDel
8114cf8c g     O .bss	00000004 OSEventFreeList
811095ac g     F .text	000000c0 bSetPreEmphasys
8110cdf4 g     F .text	00000170 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
81126380 g     F .text	0000004c __ascii_mbtowc
8110bcac g     F .text	00000078 bSyncCtrExtnIrq
811271d4 g     F .text	00000064 __ulp
81118acc g     F .text	0000010c vNFeeControlInit
8111216c g     F .text	000000a4 vSwapMemmory
811357cc g     F .text	000005c0 OSFlagPend
8114cde2 g     O .rwdata	00000002 OSTmrEn
81125240 g     F .text	00000018 __fp_unlock_all
8115d320 g     O .bss	00000010 xDma
8111b408 g     F .text	00000064 fputc
8110d2d8 g     F .text	00000050 bEnableRmapIRQ
81114930 g     F .text	000002f8 bSendUART32v2
811109ec g     F .text	0000019c setPreAckReceiverFreePos
8110bc6c g     F .text	00000040 bSyncErrInj
8114cd50 g     O .rwdata	00000008 alt_fs_list
8115d330 g     O .bss	00001000 vSimMebTask_stk
81117d80 g     F .text	00000068 vCoudlNotCreateMebTask
8113dbb0 g     F .text	00000274 check_file_name_for_FAT16_compliance
8115e330 g     O .bss	00001000 vFeeTask3_stk
8113b960 g     F .text	00000140 OSTmrNameGet
8114d254 g     O .bss	00000400 xSZData
8110d0fc g     F .text	00000190 vQCmdFEEinFullPattern
81134710 g     F .text	0000007c OS_StrCopy
8114cfcc g     O .bss	00000004 buffer_memory
81116f58 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
81118d9c g     F .text	00000098 vLogWriteNUC
8114cdac g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110c2fc g     F .text	00000074 bSyncIrqEnableBlank
811457a4 g     F .text	00000028 OSInitHookEnd
811185ac g     F .text	00000340 vUpdateMemMapFEE
811171c8 g     F .text	00000068 vFailSetPreAckReceiverBuffer
81105454 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
8114cdd8 g     O .rwdata	00000002 OSTCBPrioTblMax
81126178 g     F .text	0000000c localeconv
81117d18 g     F .text	00000068 vCoudlNotCreateDataControllerTask
8114cec0 g     O .bss	00000004 xTimerRetransmission
811104e4 g     F .text	00000250 vReceiverUartTask
8114cf1c g     O .bss	00000004 alt_log_sys_clk_count
8114cdd4 g     O .rwdata	00000002 OSTaskStatStkChkEn
81131b68 g     F .text	00000140 alt_log_write
8115f330 g     O .bss	00001000 vFeeTask2_stk
8114cec4 g     O .bss	00000004 xMutexBuffer128
81104dcc g     F .text	00000040 vFeebCh1HandleIrq
81119860 g     F .text	00000038 bStartSync
81104f4c g     F .text	00000040 vFeebCh7HandleIrq
81119898 g     F .text	00000030 bStopSync
81144d7c g     F .text	00000058 alt_ic_isr_register
8114cda8 g     O .rwdata	00000002 OSMemEn
81105e4c g     F .text	00000040 vRmapCh3HandleIrq
8114cd24 g     O .rwdata	00000004 alt_stack_limit_value
81111acc g     F .text	00000388 vPusType252run
81118190 g     F .text	0000004c vFailSendMsgMasterSyncMeb
8111ba2c g     F .text	0000003c fwrite
8114cfd0 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8114cdb2 g     O .rwdata	00000002 OSMutexEn
81118080 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
8114ce00 g       *ABS*	00000000 _edata
81141bfc g     F .text	00000068 altera_avalon_uart_read_fd
81118c4c g     F .text	00000034 vLoadDefaultIdNFEEMaster
8116656c g       *ABS*	00000000 _end
81165f6c g     O .bss	00000500 active_files
8114cf90 g     O .bss	00000001 OSIntNesting
81116ae8 g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
811189c8 g     F .text	0000002c cFeeRMAPDump
8114cec8 g     O .bss	00000004 xSemCountBuffer32
8112cd70 g     F .text	0000016c __fputwc
8114cecc g     O .bss	00000004 xQMaskFeeCtrl
81118918 g     F .text	0000002c vFeeSpwRMAPChangeConfig
81122ef0 g     F .text	00000070 vfscanf
8113f4e4 g     F .text	00000150 copy_file_record_name_to_string
8114146c g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
8113b3b4 g     F .text	000001dc OSTimeDlyResume
8113d9f0 g     F .text	000000f4 Look_for_FAT16
8110d328 g     F .text	00000060 bDisableSPWChannel
81135678 g     F .text	00000154 OSFlagNameSet
8110d454 g     F .text	00000064 bDisAndClrDbBuffer
8114ced0 g     O .bss	00000004 xMutexBuffer64
81106d24 g     F .text	00000160 bRmapGetCodecError
8113abec g     F .text	000001c8 OSTaskStkChk
81144e64 g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	0000040c bSdmaDmaM1Transfer
8114cdae g     O .rwdata	00000002 OSMemSize
8111167c g     F .text	00000204 vPusType252conf
81116c18 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
8111cdf8 g     F .text	00000084 __swrite
8114cd40 g     O .rwdata	00000004 __malloc_trim_threshold
81126140 g     F .text	0000000c __locale_msgcharset
81160330 g     O .bss	00000010 xFeeQueueTBL1
8114cf94 g     O .bss	00000004 OSTCBCur
81117598 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110aa14 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
811458c4 g     F .text	00000040 exit
81137a04 g     F .text	00000220 OSMutexPost
8110c458 g     F .text	00000058 bSyncIrqFlagError
8113f910 g     F .text	000003c0 alt_up_sd_card_find_next
8114cdb0 g     O .rwdata	00000002 OSMemTblSize
81125f48 g     F .text	000000cc _fwalk_reent
81143f90 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111a6f8 g     F .text	000000f8 .hidden __floatunsisf
81126fd0 g     F .text	00000204 __mdiff
81117a40 g     F .text	00000068 vCoudlNotCreateNFee0Task
811054ac g     F .text	0000017c vFeebInitIrq
8110458c g     F .text	0000022c bDpktSetPacketConfig
81116b80 g     F .text	0000004c vFailSenderCreate
8112e9b4 g     F .text	00000074 .hidden __modsi3
81117c48 g     F .text	00000068 vCoudlNotCreateNFee5Task
8110bbb8 g     F .text	0000003c uliSyncGetPer
81105f0c g     F .text	00000040 vRmapCh6HandleIrq
8114ced4 g     O .bss	00000004 xMutexSenderACK
811173f8 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
8114cd30 g     O .rwdata	00000004 __ctype_ptr__
81117160 g     F .text	00000068 vFailSetPreParsedBuffer
8113ca20 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8112521c g     F .text	00000004 __sfp_lock_release
811056fc g     F .text	000000ac bFeebGetIrqControl
811176d0 g     F .text	00000068 vCouldNotSendTurnOff
81133428 g     F .text	00000064 OSInit
81109ee4 g     F .text	00000078 bSetPainelLeds
811436d8 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
8114cf98 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81106e84 g     F .text	000002ec bRmapSetMemConfigArea
8113afa0 g     F .text	0000012c OSTaskQuery
8110c288 g     F .text	00000074 bSyncIrqEnableError
8114ced8 g     O .bss	00000004 xMutexPus
81138fdc g     F .text	000000b0 OS_QInit
81127d14 g     F .text	000000d0 __sccl
8111b234 g     F .text	0000000c atoi
8110c6d4 g     F .text	00000720 vFeeTask
8113478c g     F .text	0000005c OS_StrLen
81118358 g     F .text	0000004c vFailFlushNFEEQueue
81105244 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
811164b4 g     F .text	000000e0 vDataControllerInit
81136a20 g     F .text	0000011c OSMemNameSet
8114a34c g     O .rodata	00000101 _ctype_
8110bb7c g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
81116ce8 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
8114cdca g     O .rwdata	00000002 OSTaskProfileEn
811183a4 g     F .text	00000028 vEvtChangeMebMode
811435a8 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
8114cedc g     O .bss	00000004 xTxUARTMutex
8114cf9c g     O .bss	00000004 OSTime
8114cd48 g     O .rwdata	00000004 __mbtowc
8114221c g     F .text	0000005c altera_avalon_uart_close
8114cfa0 g     O .bss	00000004 OSTmrSem
81111628 g     F .text	00000054 vPusType251conf
81163308 g     O .bss	00001000 OSTaskIdleStk
8111b24c g     F .text	000000fc _fopen_r
8114ce78 g     O .bss	00000004 pdata
81145bf4 g     F .text	000000bc _exit
811448cc g     F .text	00000134 alt_alarm_start
81135548 g     F .text	00000130 OSFlagNameGet
8113b590 g     F .text	00000064 OSTimeGet
8114ce14 g     O .bss	00000004 ESdmaChBufferId
81140174 g     F .text	00000380 alt_up_sd_card_read
811060dc g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8111ba68 g     F .text	000001c4 __smakebuf_r
8114cee0 g     O .bss	00000001 SemCount64
81114638 g     F .text	000002f8 bSendUART64v2
811182c0 g     F .text	0000004c vFailFlushQueueData
811052f4 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
8114cdf8 g     O .rwdata	00000008 alt_msgdma_list
8111cf34 g     F .text	00000098 strlen
8110b250 g     F .text	000000b4 uc_spi_get_byte
81106120 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
811180e8 g     F .text	00000054 vFailSendMsgAccessDMA
811456d4 g     F .text	00000028 OSTaskSwHook
811320a8 g     F .text	0000015c open
81108124 g     F .text	000007cc bRmapGetRmapMemHKArea
81164308 g     O .bss	00000d00 OSEventTbl
81118944 g     F .text	0000002c vFeeSpwRMAPChangeDefault
8112ff0c g     F .text	000000dc .hidden __gedf2
81160340 g     O .bss	00000020 xSenderACK
811453c8 g     F .text	00000044 alt_putchar
81165008 g     O .bss	00000e58 OSTCBTbl
8112d088 g     F .text	00000838 __gethex
81139a24 g     F .text	00000108 OSSemSet
81112a90 g     F .text	0000006c vTimeoutCheckerTaskv2
811189f4 g     F .text	00000038 cFeeRMAPEchoingEnable
8114cd4c g     O .rwdata	00000004 __wctomb
811138fc g     F .text	00000314 vVariablesInitialization
8112b63c g     F .text	00000018 __sprint_r
811057a8 g     F .text	00000088 bFeebGetIrqFlags
8114ce0c g     O .bss	00000004 pxDmaM2Dev
811166b0 g     F .text	0000004c vFailCreateSemaphoreResources
8114cd68 g     O .rwdata	00000004 alt_priority_mask
81109570 g     F .text	0000003c bDisableLvdsBoard
81139224 g     F .text	00000248 OSSemDel
8114cfa4 g     O .bss	00000004 OSFlagFreeList
8110b18c g     F .text	000000c4 v_spi_send_byte
8110b4c0 g     F .text	000000d0 bSSDisplayConfig
81144dd4 g     F .text	00000090 alt_ic_irq_enable
8114cd90 g     O .rwdata	00000002 OSEventNameSize
8112164c g     F .text	0000001c __vfprintf_internal
8114cfa8 g     O .bss	00000001 OSStatRdy
8110bf5c g     F .text	00000074 bSyncCtrCh2OutEnable
81165e60 g     O .bss	000000a4 OSTCBPrioTbl
811422bc g     F .text	00000270 altera_avalon_uart_read
8112dd90 g     F .text	00000064 _wctomb_r
811328f4 g     F .text	000000cc __env_lock
8114cdd6 g     O .rwdata	00000002 OSTaskSwHookEn
81105054 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
811300dc g     F .text	00000904 .hidden __subdf3
81160360 g     O .bss	00000260 xPreParsed
8110bbf4 g     F .text	0000003c uliSyncGetOst
8114cee1 g     O .bss	00000001 SemCount128
81105f8c g     F .text	00000040 vRmapCh8HandleIrq
81105120 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81114c28 g     F .text	00000290 vSendEthConf
811044b0 g     F .text	000000dc bCommInitCh
811269e4 g     F .text	000000b0 __lo0bits
8112172c g     F .text	000017c4 __svfscanf_r
8114cd74 g     O .rwdata	00000008 alt_alarm_list
8112b384 g     F .text	0000019c _ungetc_r
8114cd9e g     O .rwdata	00000002 OSFlagWidth
81105fcc g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
8112dc98 g     F .text	000000c8 wcrtomb
811049a8 g     F .text	00000148 bDpktSetPixelDelay
81114250 g     F .text	00000068 vCCDLoadDefaultValues
81130d68 g     F .text	000000d8 close
8110bc30 g     F .text	0000003c uliSyncGetGeneral
811183f4 g     F .text	00000028 vEvtChangeDataControllerMode
8114cf38 g     O .bss	00000004 alt_envsem
81131298 g     F .text	00000068 alt_log_repchar
8114cfac g     O .bss	00000004 OSIdleCtrRun
81133ab0 g     F .text	00000028 OSVersion
8114cde8 g     O .rwdata	00000002 OSTmrCfgWheelSize
8113b0cc g     F .text	00000078 OS_TaskStkClr
8111956c g     F .text	0000003c siOpenFile
8110c634 g     F .text	000000a0 vDataControlTask
8114cdc2 g     O .rwdata	00000002 OSTaskCreateEn
81106244 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
8110668c g     F .text	00000050 uliRmapCh7WriteCmdAddress
81105a0c g     F .text	00000088 bFeebStartCh
81114eb8 g     F .text	00000118 vSendTurnOff
811167b0 g     F .text	0000004c vFailSendPreParsedSemaphore
8113dee4 g     F .text	000002a4 match_file_record_to_name_ext
811340d8 g     F .text	00000070 OS_EventWaitListInit
8112cf00 g     F .text	00000088 fputwc
811605c0 g     O .bss	00000010 xFeeQueueTBL0
81116748 g     F .text	00000068 vFailSendxSemCommInit
811457cc g     F .text	00000028 OSTaskIdleHook
81114fd0 g     F .text	00000118 vSendReset
81125220 g     F .text	00000004 __sinit_lock_acquire
81126748 g     F .text	00000128 __multadd
811605d0 g     O .bss	00000010 SyncTBL1
81105164 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110b880 g     F .text	0000004c ucSyncStatusState
8113adb4 g     F .text	000001ec OSTaskSuspend
81126720 g     F .text	00000028 _Bfree
8110bb40 g     F .text	0000003c uliSyncGetMbt
811347e8 g     F .text	00000064 OS_TaskIdle
8114cdee g     O .rwdata	00000002 OSTmrTblSize
81138e78 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	113348c0 	call	8113348c <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045b4 	movhi	r2,33046
81100150:	10991b04 	addi	r2,r2,25708
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045b4 	movhi	r2,33046
81100168:	10991b04 	addi	r2,r2,25708
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	11334e00 	call	811334e0 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b117 	ldw	r2,-32060(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b117 	ldw	r2,-32060(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	21335b04 	addi	r4,r4,-12948
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	212eb204 	addi	r4,r4,-17720
81100274:	11312100 	call	81131210 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	21335b04 	addi	r4,r4,-12948
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	212ea504 	addi	r4,r4,-17772
81100290:	11312100 	call	81131210 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6934914 	ori	gp,gp,19748
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	21335b04 	addi	r4,r4,-12948
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	212e9604 	addi	r4,r4,-17832
811002bc:	11312100 	call	81131210 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
811002c4:	10b38014 	ori	r2,r2,52736

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18d95b14 	ori	r3,r3,25964

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	21335b04 	addi	r4,r4,-12948
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	212e9d04 	addi	r4,r4,-17804
811002fc:	11312100 	call	81131210 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	1131e3c0 	call	81131e3c <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18f45504 	addi	r3,r3,-11948
81100330:	00a04534 	movhi	r2,33044
81100334:	10972c04 	addi	r2,r2,23728
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a05c17 	ldw	r2,-32400(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	29745504 	addi	r5,r5,-11948
8110035c:	1009883a 	mov	r4,r2
81100360:	111b3900 	call	8111b390 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18f45504 	addi	r3,r3,-11948
811003cc:	00a04534 	movhi	r2,33044
811003d0:	10973504 	addi	r2,r2,23764
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	111c4400 	call	8111c440 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a05c17 	ldw	r2,-32400(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	29745504 	addi	r5,r5,-11948
811003f8:	1009883a 	mov	r4,r2
811003fc:	111b3900 	call	8111b390 <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18f45504 	addi	r3,r3,-11948
81100410:	00a04534 	movhi	r2,33044
81100414:	10974104 	addi	r2,r2,23812
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a05c17 	ldw	r2,-32400(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	29745504 	addi	r5,r5,-11948
8110043c:	1009883a 	mov	r4,r2
81100440:	111b3900 	call	8111b390 <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	11326680 	call	81132668 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	11098500 	call	81109850 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604534 	movhi	r5,33044
811004b0:	29574704 	addi	r5,r5,23836
811004b4:	01204574 	movhi	r4,33045
811004b8:	21345504 	addi	r4,r4,-11948
811004bc:	111cd200 	call	8111cd20 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a05c17 	ldw	r2,-32400(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	29745504 	addi	r5,r5,-11948
811004cc:	1009883a 	mov	r4,r2
811004d0:	111b3900 	call	8111b390 <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18f45504 	addi	r3,r3,-11948
811004e0:	00a04534 	movhi	r2,33044
811004e4:	10974c04 	addi	r2,r2,23856
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	111c4400 	call	8111c440 <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a05c17 	ldw	r2,-32400(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	29745504 	addi	r5,r5,-11948
8110050c:	1009883a 	mov	r4,r2
81100510:	111b3900 	call	8111b390 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18f45504 	addi	r3,r3,-11948
81100544:	00a04534 	movhi	r2,33044
81100548:	10975204 	addi	r2,r2,23880
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a05c17 	ldw	r2,-32400(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	29745504 	addi	r5,r5,-11948
81100570:	1009883a 	mov	r4,r2
81100574:	111b3900 	call	8111b390 <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18f45504 	addi	r3,r3,-11948
81100584:	00a04534 	movhi	r2,33044
81100588:	10975b04 	addi	r2,r2,23916
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a05c17 	ldw	r2,-32400(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	29745504 	addi	r5,r5,-11948
811005b0:	1009883a 	mov	r4,r2
811005b4:	111b3900 	call	8111b390 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18f45504 	addi	r3,r3,-11948
811005c0:	00a04534 	movhi	r2,33044
811005c4:	10976304 	addi	r2,r2,23948
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a05c17 	ldw	r2,-32400(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	29745504 	addi	r5,r5,-11948
811005ec:	1009883a 	mov	r4,r2
811005f0:	111b3900 	call	8111b390 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	11326680 	call	81132668 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	11097700 	call	81109770 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18f45504 	addi	r3,r3,-11948
81100650:	00a04534 	movhi	r2,33044
81100654:	10976904 	addi	r2,r2,23972
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a05c17 	ldw	r2,-32400(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	29745504 	addi	r5,r5,-11948
8110067c:	1009883a 	mov	r4,r2
81100680:	111b3900 	call	8111b390 <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	11098500 	call	81109850 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18f45504 	addi	r3,r3,-11948
811006cc:	00a04534 	movhi	r2,33044
811006d0:	10976f04 	addi	r2,r2,23996
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	111c4400 	call	8111c440 <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a05c17 	ldw	r2,-32400(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	29745504 	addi	r5,r5,-11948
811006f8:	1009883a 	mov	r4,r2
811006fc:	111b3900 	call	8111b390 <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604534 	movhi	r5,33044
81100730:	29577804 	addi	r5,r5,24032
81100734:	01204574 	movhi	r4,33045
81100738:	21345504 	addi	r4,r4,-11948
8110073c:	111cd200 	call	8111cd20 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a05c17 	ldw	r2,-32400(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	29745504 	addi	r5,r5,-11948
8110074c:	1009883a 	mov	r4,r2
81100750:	111b3900 	call	8111b390 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18f45504 	addi	r3,r3,-11948
81100764:	00a04534 	movhi	r2,33044
81100768:	10978704 	addi	r2,r2,24092
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a05c17 	ldw	r2,-32400(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	29745504 	addi	r5,r5,-11948
81100790:	1009883a 	mov	r4,r2
81100794:	111b3900 	call	8111b390 <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18f45504 	addi	r3,r3,-11948
811007a4:	00a04534 	movhi	r2,33044
811007a8:	10979004 	addi	r2,r2,24128
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a05c17 	ldw	r2,-32400(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	29745504 	addi	r5,r5,-11948
811007d0:	1009883a 	mov	r4,r2
811007d4:	111b3900 	call	8111b390 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	10b45504 	addi	r2,r2,-11948
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a05c17 	ldw	r2,-32400(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	29745504 	addi	r5,r5,-11948
811007f8:	1009883a 	mov	r4,r2
811007fc:	111b3900 	call	8111b390 <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18f45504 	addi	r3,r3,-11948
81100840:	00a04534 	movhi	r2,33044
81100844:	10979804 	addi	r2,r2,24160
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a05c17 	ldw	r2,-32400(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	29745504 	addi	r5,r5,-11948
8110086c:	1009883a 	mov	r4,r2
81100870:	111b3900 	call	8111b390 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18f45504 	addi	r3,r3,-11948
811008dc:	00a04534 	movhi	r2,33044
811008e0:	1097a104 	addi	r2,r2,24196
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	111c4400 	call	8111c440 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a05c17 	ldw	r2,-32400(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	29745504 	addi	r5,r5,-11948
81100908:	1009883a 	mov	r4,r2
8110090c:	111b3900 	call	8111b390 <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	11099580 	call	81109958 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604534 	movhi	r5,33044
81100984:	2957ad04 	addi	r5,r5,24244
81100988:	01204574 	movhi	r4,33045
8110098c:	21345504 	addi	r4,r4,-11948
81100990:	111cd200 	call	8111cd20 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a05c17 	ldw	r2,-32400(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	29745504 	addi	r5,r5,-11948
811009a0:	1009883a 	mov	r4,r2
811009a4:	111b3900 	call	8111b390 <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18f45504 	addi	r3,r3,-11948
811009c0:	00a04534 	movhi	r2,33044
811009c4:	1097b904 	addi	r2,r2,24292
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	111c4400 	call	8111c440 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a05c17 	ldw	r2,-32400(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	29745504 	addi	r5,r5,-11948
811009ec:	1009883a 	mov	r4,r2
811009f0:	111b3900 	call	8111b390 <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18f45504 	addi	r3,r3,-11948
81100a0c:	00a04534 	movhi	r2,33044
81100a10:	1097c504 	addi	r2,r2,24340
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a05c17 	ldw	r2,-32400(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	29745504 	addi	r5,r5,-11948
81100a38:	1009883a 	mov	r4,r2
81100a3c:	111b3900 	call	8111b390 <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18f45504 	addi	r3,r3,-11948
81100a58:	00a04534 	movhi	r2,33044
81100a5c:	1097cd04 	addi	r2,r2,24372
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	111c4400 	call	8111c440 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a05c17 	ldw	r2,-32400(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	29745504 	addi	r5,r5,-11948
81100a84:	1009883a 	mov	r4,r2
81100a88:	111b3900 	call	8111b390 <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18f45504 	addi	r3,r3,-11948
81100aa4:	00a04534 	movhi	r2,33044
81100aa8:	1097d704 	addi	r2,r2,24412
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	111c4400 	call	8111c440 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a05c17 	ldw	r2,-32400(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	29745504 	addi	r5,r5,-11948
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	111b3900 	call	8111b390 <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18f45504 	addi	r3,r3,-11948
81100af0:	00a04534 	movhi	r2,33044
81100af4:	1097e204 	addi	r2,r2,24456
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	111c4400 	call	8111c440 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a05c17 	ldw	r2,-32400(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	29745504 	addi	r5,r5,-11948
81100b1c:	1009883a 	mov	r4,r2
81100b20:	111b3900 	call	8111b390 <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18f45504 	addi	r3,r3,-11948
81100b3c:	00a04534 	movhi	r2,33044
81100b40:	1097ee04 	addi	r2,r2,24504
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a05c17 	ldw	r2,-32400(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	29745504 	addi	r5,r5,-11948
81100b68:	1009883a 	mov	r4,r2
81100b6c:	111b3900 	call	8111b390 <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18f45504 	addi	r3,r3,-11948
81100b88:	00a04534 	movhi	r2,33044
81100b8c:	1097f404 	addi	r2,r2,24528
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a05c17 	ldw	r2,-32400(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	29745504 	addi	r5,r5,-11948
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	111b3900 	call	8111b390 <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18f45504 	addi	r3,r3,-11948
81100bd4:	00a04534 	movhi	r2,33044
81100bd8:	1097fc04 	addi	r2,r2,24560
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	111c4400 	call	8111c440 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a05c17 	ldw	r2,-32400(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	29745504 	addi	r5,r5,-11948
81100c00:	1009883a 	mov	r4,r2
81100c04:	111b3900 	call	8111b390 <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18f45504 	addi	r3,r3,-11948
81100c20:	00a04534 	movhi	r2,33044
81100c24:	10980904 	addi	r2,r2,24612
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a05c17 	ldw	r2,-32400(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	29745504 	addi	r5,r5,-11948
81100c4c:	1009883a 	mov	r4,r2
81100c50:	111b3900 	call	8111b390 <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18f45504 	addi	r3,r3,-11948
81100c6c:	00a04534 	movhi	r2,33044
81100c70:	10980f04 	addi	r2,r2,24636
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a05c17 	ldw	r2,-32400(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	29745504 	addi	r5,r5,-11948
81100c98:	1009883a 	mov	r4,r2
81100c9c:	111b3900 	call	8111b390 <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18f45504 	addi	r3,r3,-11948
81100cb8:	00a04534 	movhi	r2,33044
81100cbc:	10981404 	addi	r2,r2,24656
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a05c17 	ldw	r2,-32400(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	29745504 	addi	r5,r5,-11948
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	111b3900 	call	8111b390 <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18f45504 	addi	r3,r3,-11948
81100d04:	00a04534 	movhi	r2,33044
81100d08:	10981b04 	addi	r2,r2,24684
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	111c4400 	call	8111c440 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a05c17 	ldw	r2,-32400(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	29745504 	addi	r5,r5,-11948
81100d30:	1009883a 	mov	r4,r2
81100d34:	111b3900 	call	8111b390 <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18f45504 	addi	r3,r3,-11948
81100d50:	00a04534 	movhi	r2,33044
81100d54:	10982904 	addi	r2,r2,24740
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	111c4400 	call	8111c440 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a05c17 	ldw	r2,-32400(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	29745504 	addi	r5,r5,-11948
81100d7c:	1009883a 	mov	r4,r2
81100d80:	111b3900 	call	8111b390 <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18f45504 	addi	r3,r3,-11948
81100d9c:	00a04534 	movhi	r2,33044
81100da0:	10983b04 	addi	r2,r2,24812
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a05c17 	ldw	r2,-32400(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	29745504 	addi	r5,r5,-11948
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	111b3900 	call	8111b390 <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18f45504 	addi	r3,r3,-11948
81100de8:	00a04534 	movhi	r2,33044
81100dec:	10984304 	addi	r2,r2,24844
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	111c4400 	call	8111c440 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a05c17 	ldw	r2,-32400(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	29745504 	addi	r5,r5,-11948
81100e14:	1009883a 	mov	r4,r2
81100e18:	111b3900 	call	8111b390 <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18f45504 	addi	r3,r3,-11948
81100e34:	00a04534 	movhi	r2,33044
81100e38:	10984d04 	addi	r2,r2,24884
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	111c4400 	call	8111c440 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a05c17 	ldw	r2,-32400(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	29745504 	addi	r5,r5,-11948
81100e60:	1009883a 	mov	r4,r2
81100e64:	111b3900 	call	8111b390 <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18f45504 	addi	r3,r3,-11948
81100e80:	00a04534 	movhi	r2,33044
81100e84:	10985a04 	addi	r2,r2,24936
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	111c4400 	call	8111c440 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a05c17 	ldw	r2,-32400(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	29745504 	addi	r5,r5,-11948
81100eac:	1009883a 	mov	r4,r2
81100eb0:	111b3900 	call	8111b390 <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18f45504 	addi	r3,r3,-11948
81100ecc:	00a04534 	movhi	r2,33044
81100ed0:	10986404 	addi	r2,r2,24976
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	111c4400 	call	8111c440 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a05c17 	ldw	r2,-32400(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	29745504 	addi	r5,r5,-11948
81100ef8:	1009883a 	mov	r4,r2
81100efc:	111b3900 	call	8111b390 <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18f45504 	addi	r3,r3,-11948
81100f18:	00a04534 	movhi	r2,33044
81100f1c:	10986f04 	addi	r2,r2,25020
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	111c4400 	call	8111c440 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a05c17 	ldw	r2,-32400(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	29745504 	addi	r5,r5,-11948
81100f44:	1009883a 	mov	r4,r2
81100f48:	111b3900 	call	8111b390 <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18f45504 	addi	r3,r3,-11948
81100f64:	00a04534 	movhi	r2,33044
81100f68:	10988004 	addi	r2,r2,25088
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	111c4400 	call	8111c440 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a05c17 	ldw	r2,-32400(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	29745504 	addi	r5,r5,-11948
81100f90:	1009883a 	mov	r4,r2
81100f94:	111b3900 	call	8111b390 <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18f45504 	addi	r3,r3,-11948
81100fb0:	00a04534 	movhi	r2,33044
81100fb4:	10988b04 	addi	r2,r2,25132
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	111c4400 	call	8111c440 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a05c17 	ldw	r2,-32400(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	29745504 	addi	r5,r5,-11948
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	111b3900 	call	8111b390 <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18f45504 	addi	r3,r3,-11948
81100ffc:	00a04534 	movhi	r2,33044
81101000:	10989804 	addi	r2,r2,25184
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	111c4400 	call	8111c440 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a05c17 	ldw	r2,-32400(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	29745504 	addi	r5,r5,-11948
81101028:	1009883a 	mov	r4,r2
8110102c:	111b3900 	call	8111b390 <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18f45504 	addi	r3,r3,-11948
81101048:	00a04534 	movhi	r2,33044
8110104c:	1098a604 	addi	r2,r2,25240
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	111c4400 	call	8111c440 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a05c17 	ldw	r2,-32400(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	29745504 	addi	r5,r5,-11948
81101074:	1009883a 	mov	r4,r2
81101078:	111b3900 	call	8111b390 <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18f45504 	addi	r3,r3,-11948
81101094:	00a04534 	movhi	r2,33044
81101098:	1098b304 	addi	r2,r2,25292
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	111c4400 	call	8111c440 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a05c17 	ldw	r2,-32400(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	29745504 	addi	r5,r5,-11948
811010c0:	1009883a 	mov	r4,r2
811010c4:	111b3900 	call	8111b390 <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18f45504 	addi	r3,r3,-11948
811010e0:	00a04534 	movhi	r2,33044
811010e4:	1098c004 	addi	r2,r2,25344
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a05c17 	ldw	r2,-32400(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	29745504 	addi	r5,r5,-11948
8110110c:	1009883a 	mov	r4,r2
81101110:	111b3900 	call	8111b390 <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	10b45504 	addi	r2,r2,-11948
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a05c17 	ldw	r2,-32400(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	29745504 	addi	r5,r5,-11948
81101194:	1009883a 	mov	r4,r2
81101198:	111b3900 	call	8111b390 <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18f45504 	addi	r3,r3,-11948
811011b4:	00a04534 	movhi	r2,33044
811011b8:	1098c404 	addi	r2,r2,25360
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a05c17 	ldw	r2,-32400(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	29745504 	addi	r5,r5,-11948
811011e0:	1009883a 	mov	r4,r2
811011e4:	111b3900 	call	8111b390 <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18f45504 	addi	r3,r3,-11948
81101200:	00a04534 	movhi	r2,33044
81101204:	1098cc04 	addi	r2,r2,25392
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	111c4400 	call	8111c440 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a05c17 	ldw	r2,-32400(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	29745504 	addi	r5,r5,-11948
8110122c:	1009883a 	mov	r4,r2
81101230:	111b3900 	call	8111b390 <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18f45504 	addi	r3,r3,-11948
8110124c:	00a04534 	movhi	r2,33044
81101250:	1098da04 	addi	r2,r2,25448
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a05c17 	ldw	r2,-32400(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	29745504 	addi	r5,r5,-11948
81101278:	1009883a 	mov	r4,r2
8110127c:	111b3900 	call	8111b390 <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18f45504 	addi	r3,r3,-11948
81101298:	00a04534 	movhi	r2,33044
8110129c:	1098e204 	addi	r2,r2,25480
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a05c17 	ldw	r2,-32400(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	29745504 	addi	r5,r5,-11948
811012c4:	1009883a 	mov	r4,r2
811012c8:	111b3900 	call	8111b390 <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18f45504 	addi	r3,r3,-11948
811012e4:	00a04534 	movhi	r2,33044
811012e8:	1098ea04 	addi	r2,r2,25512
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	111c4400 	call	8111c440 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a05c17 	ldw	r2,-32400(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	29745504 	addi	r5,r5,-11948
81101310:	1009883a 	mov	r4,r2
81101314:	111b3900 	call	8111b390 <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18f45504 	addi	r3,r3,-11948
81101330:	00a04534 	movhi	r2,33044
81101334:	1098f404 	addi	r2,r2,25552
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a05c17 	ldw	r2,-32400(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	29745504 	addi	r5,r5,-11948
8110135c:	1009883a 	mov	r4,r2
81101360:	111b3900 	call	8111b390 <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18f45504 	addi	r3,r3,-11948
8110137c:	00a04534 	movhi	r2,33044
81101380:	1098fb04 	addi	r2,r2,25580
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	111c4400 	call	8111c440 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a05c17 	ldw	r2,-32400(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	29745504 	addi	r5,r5,-11948
811013a8:	1009883a 	mov	r4,r2
811013ac:	111b3900 	call	8111b390 <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18f45504 	addi	r3,r3,-11948
811013c8:	00a04534 	movhi	r2,33044
811013cc:	10990504 	addi	r2,r2,25620
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a05c17 	ldw	r2,-32400(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	29745504 	addi	r5,r5,-11948
811013f4:	1009883a 	mov	r4,r2
811013f8:	111b3900 	call	8111b390 <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	10b45504 	addi	r2,r2,-11948
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a05c17 	ldw	r2,-32400(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	29745504 	addi	r5,r5,-11948
81101420:	1009883a 	mov	r4,r2
81101424:	111b3900 	call	8111b390 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18f45504 	addi	r3,r3,-11948
81101454:	00a04534 	movhi	r2,33044
81101458:	10990f04 	addi	r2,r2,25660
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a05c17 	ldw	r2,-32400(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	29745504 	addi	r5,r5,-11948
81101480:	1009883a 	mov	r4,r2
81101484:	111b3900 	call	8111b390 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	10b45504 	addi	r2,r2,-11948
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a05c17 	ldw	r2,-32400(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	29745504 	addi	r5,r5,-11948
811014a8:	1009883a 	mov	r4,r2
811014ac:	111b3900 	call	8111b390 <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18f45504 	addi	r3,r3,-11948
81101538:	00a04534 	movhi	r2,33044
8110153c:	10991504 	addi	r2,r2,25684
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	111c4400 	call	8111c440 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a05c17 	ldw	r2,-32400(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	29745504 	addi	r5,r5,-11948
81101564:	1009883a 	mov	r4,r2
81101568:	111b3900 	call	8111b390 <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18f45504 	addi	r3,r3,-11948
811015b4:	00a04534 	movhi	r2,33044
811015b8:	10992404 	addi	r2,r2,25744
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a05c17 	ldw	r2,-32400(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	29745504 	addi	r5,r5,-11948
811015e0:	1009883a 	mov	r4,r2
811015e4:	111b3900 	call	8111b390 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18f45504 	addi	r3,r3,-11948
81101648:	00a04534 	movhi	r2,33044
8110164c:	10973504 	addi	r2,r2,23764
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	111c4400 	call	8111c440 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a05c17 	ldw	r2,-32400(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	29745504 	addi	r5,r5,-11948
81101674:	1009883a 	mov	r4,r2
81101678:	111b3900 	call	8111b390 <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604534 	movhi	r5,33044
81101694:	29592e04 	addi	r5,r5,25784
81101698:	01204574 	movhi	r4,33045
8110169c:	21345504 	addi	r4,r4,-11948
811016a0:	111cd200 	call	8111cd20 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a05c17 	ldw	r2,-32400(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	29745504 	addi	r5,r5,-11948
811016b0:	1009883a 	mov	r4,r2
811016b4:	111b3900 	call	8111b390 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08317 	ldw	r2,-32244(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10b49504 	addi	r2,r2,-11692
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10b49504 	addi	r2,r2,-11692
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10b49504 	addi	r2,r2,-11692
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10b49504 	addi	r2,r2,-11692
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10b49504 	addi	r2,r2,-11692
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10b49504 	addi	r2,r2,-11692
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10b49504 	addi	r2,r2,-11692
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18f45504 	addi	r3,r3,-11948
81101868:	00a04534 	movhi	r2,33044
8110186c:	10993404 	addi	r2,r2,25808
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a05c17 	ldw	r2,-32400(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	29745504 	addi	r5,r5,-11948
81101894:	1009883a 	mov	r4,r2
81101898:	111b3900 	call	8111b390 <fprintf>
8110189c:	d0a08317 	ldw	r2,-32244(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	29749504 	addi	r5,r5,-11692
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	111c4400 	call	8111c440 <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604534 	movhi	r5,33044
81101990:	29593904 	addi	r5,r5,25828
81101994:	01204574 	movhi	r4,33045
81101998:	21345504 	addi	r4,r4,-11948
8110199c:	111cd200 	call	8111cd20 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a05c17 	ldw	r2,-32400(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	29745504 	addi	r5,r5,-11948
811019ac:	1009883a 	mov	r4,r2
811019b0:	111b3900 	call	8111b390 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	1130e400 	call	81130e40 <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	10b45504 	addi	r2,r2,-11948
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a05c17 	ldw	r2,-32400(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	29745504 	addi	r5,r5,-11948
811019e4:	1009883a 	mov	r4,r2
811019e8:	111b3900 	call	8111b390 <fprintf>
811019ec:	d0e08317 	ldw	r3,-32244(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111a5cc0 	call	8111a5cc <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08217 	ldw	r2,-32248(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111a6f80 	call	8111a6f8 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	1119d800 	call	81119d80 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	111af100 	call	8111af10 <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604534 	movhi	r5,33044
81101a54:	29593b04 	addi	r5,r5,25836
81101a58:	01204574 	movhi	r4,33045
81101a5c:	21345504 	addi	r4,r4,-11948
81101a60:	111cd200 	call	8111cd20 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a05c17 	ldw	r2,-32400(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	29745504 	addi	r5,r5,-11948
81101a70:	1009883a 	mov	r4,r2
81101a74:	111b3900 	call	8111b390 <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18f45504 	addi	r3,r3,-11948
81101a84:	00a04534 	movhi	r2,33044
81101a88:	10994704 	addi	r2,r2,25884
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a05c17 	ldw	r2,-32400(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	29745504 	addi	r5,r5,-11948
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	111b3900 	call	8111b390 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	10b45504 	addi	r2,r2,-11948
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a05c17 	ldw	r2,-32400(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	29745504 	addi	r5,r5,-11948
81101ad8:	1009883a 	mov	r4,r2
81101adc:	111b3900 	call	8111b390 <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18f45504 	addi	r3,r3,-11948
81101b30:	00a04534 	movhi	r2,33044
81101b34:	10994d04 	addi	r2,r2,25908
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a05c17 	ldw	r2,-32400(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	29745504 	addi	r5,r5,-11948
81101b5c:	1009883a 	mov	r4,r2
81101b60:	111b3900 	call	8111b390 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18f45504 	addi	r3,r3,-11948
81101bc4:	00a04534 	movhi	r2,33044
81101bc8:	10973504 	addi	r2,r2,23764
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	111c4400 	call	8111c440 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a05c17 	ldw	r2,-32400(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	29745504 	addi	r5,r5,-11948
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	111b3900 	call	8111b390 <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604534 	movhi	r5,33044
81101c10:	29595704 	addi	r5,r5,25948
81101c14:	01204574 	movhi	r4,33045
81101c18:	21345504 	addi	r4,r4,-11948
81101c1c:	111cd200 	call	8111cd20 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a05c17 	ldw	r2,-32400(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	29745504 	addi	r5,r5,-11948
81101c2c:	1009883a 	mov	r4,r2
81101c30:	111b3900 	call	8111b390 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18f45504 	addi	r3,r3,-11948
81101cd0:	00a04534 	movhi	r2,33044
81101cd4:	10995d04 	addi	r2,r2,25972
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a05c17 	ldw	r2,-32400(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	29745504 	addi	r5,r5,-11948
81101cfc:	1009883a 	mov	r4,r2
81101d00:	111b3900 	call	8111b390 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08317 	ldw	r2,-32244(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10b49504 	addi	r2,r2,-11692
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10b49504 	addi	r2,r2,-11692
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604534 	movhi	r5,33044
81101df4:	29596404 	addi	r5,r5,26000
81101df8:	01204574 	movhi	r4,33045
81101dfc:	21345504 	addi	r4,r4,-11948
81101e00:	111cd200 	call	8111cd20 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a05c17 	ldw	r2,-32400(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	29745504 	addi	r5,r5,-11948
81101e10:	1009883a 	mov	r4,r2
81101e14:	111b3900 	call	8111b390 <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604534 	movhi	r5,33044
81101e98:	29593904 	addi	r5,r5,25828
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	21345504 	addi	r4,r4,-11948
81101ea4:	111cd200 	call	8111cd20 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a05c17 	ldw	r2,-32400(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	29745504 	addi	r5,r5,-11948
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	111b3900 	call	8111b390 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	10b45504 	addi	r2,r2,-11948
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a05c17 	ldw	r2,-32400(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	29745504 	addi	r5,r5,-11948
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	111b3900 	call	8111b390 <fprintf>
81101ef8:	d0e08317 	ldw	r3,-32244(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111a5cc0 	call	8111a5cc <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08217 	ldw	r2,-32248(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111a6f80 	call	8111a6f8 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	1119d800 	call	81119d80 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	111af100 	call	8111af10 <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604534 	movhi	r5,33044
81101f60:	29597204 	addi	r5,r5,26056
81101f64:	01204574 	movhi	r4,33045
81101f68:	21345504 	addi	r4,r4,-11948
81101f6c:	111cd200 	call	8111cd20 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a05c17 	ldw	r2,-32400(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	29745504 	addi	r5,r5,-11948
81101f7c:	1009883a 	mov	r4,r2
81101f80:	111b3900 	call	8111b390 <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18f45504 	addi	r3,r3,-11948
81101f90:	00a04534 	movhi	r2,33044
81101f94:	10997e04 	addi	r2,r2,26104
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a05c17 	ldw	r2,-32400(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	29745504 	addi	r5,r5,-11948
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	111b3900 	call	8111b390 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	10b45504 	addi	r2,r2,-11948
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a05c17 	ldw	r2,-32400(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	29745504 	addi	r5,r5,-11948
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	111b3900 	call	8111b390 <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18f45504 	addi	r3,r3,-11948
8110204c:	00a04534 	movhi	r2,33044
81102050:	10998404 	addi	r2,r2,26128
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a05c17 	ldw	r2,-32400(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	29745504 	addi	r5,r5,-11948
81102078:	1009883a 	mov	r4,r2
8110207c:	111b3900 	call	8111b390 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18f45504 	addi	r3,r3,-11948
811020e0:	00a04534 	movhi	r2,33044
811020e4:	10973504 	addi	r2,r2,23764
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	111c4400 	call	8111c440 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a05c17 	ldw	r2,-32400(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	29745504 	addi	r5,r5,-11948
8110210c:	1009883a 	mov	r4,r2
81102110:	111b3900 	call	8111b390 <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604534 	movhi	r5,33044
8110212c:	29592e04 	addi	r5,r5,25784
81102130:	01204574 	movhi	r4,33045
81102134:	21345504 	addi	r4,r4,-11948
81102138:	111cd200 	call	8111cd20 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a05c17 	ldw	r2,-32400(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	29745504 	addi	r5,r5,-11948
81102148:	1009883a 	mov	r4,r2
8110214c:	111b3900 	call	8111b390 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08317 	ldw	r2,-32244(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18f45504 	addi	r3,r3,-11948
811021ac:	00a04534 	movhi	r2,33044
811021b0:	10999004 	addi	r2,r2,26176
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a05c17 	ldw	r2,-32400(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	29745504 	addi	r5,r5,-11948
811021d8:	1009883a 	mov	r4,r2
811021dc:	111b3900 	call	8111b390 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604534 	movhi	r5,33044
811021f0:	29599604 	addi	r5,r5,26200
811021f4:	01204574 	movhi	r4,33045
811021f8:	21345504 	addi	r4,r4,-11948
811021fc:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a05c17 	ldw	r2,-32400(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	29745504 	addi	r5,r5,-11948
8110220c:	1009883a 	mov	r4,r2
81102210:	111b3900 	call	8111b390 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08317 	ldw	r2,-32244(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604534 	movhi	r5,33044
81102274:	29599804 	addi	r5,r5,26208
81102278:	01204574 	movhi	r4,33045
8110227c:	21345504 	addi	r4,r4,-11948
81102280:	111cd200 	call	8111cd20 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a05c17 	ldw	r2,-32400(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	29745504 	addi	r5,r5,-11948
81102290:	1009883a 	mov	r4,r2
81102294:	111b3900 	call	8111b390 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	1130e400 	call	81130e40 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604534 	movhi	r5,33044
811022fc:	29599b04 	addi	r5,r5,26220
81102300:	01204574 	movhi	r4,33045
81102304:	21345504 	addi	r4,r4,-11948
81102308:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a05c17 	ldw	r2,-32400(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	29745504 	addi	r5,r5,-11948
81102318:	1009883a 	mov	r4,r2
8110231c:	111b3900 	call	8111b390 <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08317 	ldw	r3,-32244(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111a5cc0 	call	8111a5cc <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08217 	ldw	r2,-32248(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111a6f80 	call	8111a6f8 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	1119d800 	call	81119d80 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	111af100 	call	8111af10 <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604534 	movhi	r5,33044
81102394:	29599e04 	addi	r5,r5,26232
81102398:	01204574 	movhi	r4,33045
8110239c:	21345504 	addi	r4,r4,-11948
811023a0:	111cd200 	call	8111cd20 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a05c17 	ldw	r2,-32400(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	29745504 	addi	r5,r5,-11948
811023b0:	1009883a 	mov	r4,r2
811023b4:	111b3900 	call	8111b390 <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604534 	movhi	r5,33044
811023c4:	2959aa04 	addi	r5,r5,26280
811023c8:	01204574 	movhi	r4,33045
811023cc:	21345504 	addi	r4,r4,-11948
811023d0:	111cd200 	call	8111cd20 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a05c17 	ldw	r2,-32400(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	29745504 	addi	r5,r5,-11948
811023e0:	1009883a 	mov	r4,r2
811023e4:	111b3900 	call	8111b390 <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18f45504 	addi	r3,r3,-11948
811023f4:	00a04534 	movhi	r2,33044
811023f8:	10994704 	addi	r2,r2,25884
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a05c17 	ldw	r2,-32400(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	29745504 	addi	r5,r5,-11948
81102420:	1009883a 	mov	r4,r2
81102424:	111b3900 	call	8111b390 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	10b45504 	addi	r2,r2,-11948
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a05c17 	ldw	r2,-32400(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	29745504 	addi	r5,r5,-11948
81102448:	1009883a 	mov	r4,r2
8110244c:	111b3900 	call	8111b390 <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18f45504 	addi	r3,r3,-11948
811024b8:	00a04534 	movhi	r2,33044
811024bc:	1099b404 	addi	r2,r2,26320
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a05c17 	ldw	r2,-32400(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	29745504 	addi	r5,r5,-11948
811024e4:	1009883a 	mov	r4,r2
811024e8:	111b3900 	call	8111b390 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18f45504 	addi	r3,r3,-11948
8110254c:	00a04534 	movhi	r2,33044
81102550:	10973504 	addi	r2,r2,23764
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	111c4400 	call	8111c440 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a05c17 	ldw	r2,-32400(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	29745504 	addi	r5,r5,-11948
81102578:	1009883a 	mov	r4,r2
8110257c:	111b3900 	call	8111b390 <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604534 	movhi	r5,33044
81102598:	29592e04 	addi	r5,r5,25784
8110259c:	01204574 	movhi	r4,33045
811025a0:	21345504 	addi	r4,r4,-11948
811025a4:	111cd200 	call	8111cd20 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a05c17 	ldw	r2,-32400(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	29745504 	addi	r5,r5,-11948
811025b4:	1009883a 	mov	r4,r2
811025b8:	111b3900 	call	8111b390 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18f45504 	addi	r3,r3,-11948
81102610:	00a04534 	movhi	r2,33044
81102614:	1099c004 	addi	r2,r2,26368
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a05c17 	ldw	r2,-32400(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	29745504 	addi	r5,r5,-11948
8110263c:	1009883a 	mov	r4,r2
81102640:	111b3900 	call	8111b390 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604534 	movhi	r5,33044
81102654:	29599604 	addi	r5,r5,26200
81102658:	01204574 	movhi	r4,33045
8110265c:	21345504 	addi	r4,r4,-11948
81102660:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a05c17 	ldw	r2,-32400(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	29745504 	addi	r5,r5,-11948
81102670:	1009883a 	mov	r4,r2
81102674:	111b3900 	call	8111b390 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08317 	ldw	r2,-32244(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604534 	movhi	r5,33044
811026c8:	2959c604 	addi	r5,r5,26392
811026cc:	01204574 	movhi	r4,33045
811026d0:	21345504 	addi	r4,r4,-11948
811026d4:	111cd200 	call	8111cd20 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a05c17 	ldw	r2,-32400(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	29745504 	addi	r5,r5,-11948
811026e4:	1009883a 	mov	r4,r2
811026e8:	111b3900 	call	8111b390 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604534 	movhi	r5,33044
81102710:	29599804 	addi	r5,r5,26208
81102714:	01204574 	movhi	r4,33045
81102718:	21345504 	addi	r4,r4,-11948
8110271c:	111cd200 	call	8111cd20 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a05c17 	ldw	r2,-32400(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	29745504 	addi	r5,r5,-11948
8110272c:	1009883a 	mov	r4,r2
81102730:	111b3900 	call	8111b390 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604534 	movhi	r5,33044
81102794:	29599b04 	addi	r5,r5,26220
81102798:	01204574 	movhi	r4,33045
8110279c:	21345504 	addi	r4,r4,-11948
811027a0:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a05c17 	ldw	r2,-32400(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	29745504 	addi	r5,r5,-11948
811027b0:	1009883a 	mov	r4,r2
811027b4:	111b3900 	call	8111b390 <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08317 	ldw	r3,-32244(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111a5cc0 	call	8111a5cc <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08217 	ldw	r2,-32248(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111a6f80 	call	8111a6f8 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	1119d800 	call	81119d80 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	111af100 	call	8111af10 <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604534 	movhi	r5,33044
8110282c:	2959ce04 	addi	r5,r5,26424
81102830:	01204574 	movhi	r4,33045
81102834:	21345504 	addi	r4,r4,-11948
81102838:	111cd200 	call	8111cd20 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a05c17 	ldw	r2,-32400(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	29745504 	addi	r5,r5,-11948
81102848:	1009883a 	mov	r4,r2
8110284c:	111b3900 	call	8111b390 <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604534 	movhi	r5,33044
8110285c:	2959da04 	addi	r5,r5,26472
81102860:	01204574 	movhi	r4,33045
81102864:	21345504 	addi	r4,r4,-11948
81102868:	111cd200 	call	8111cd20 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a05c17 	ldw	r2,-32400(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	29745504 	addi	r5,r5,-11948
81102878:	1009883a 	mov	r4,r2
8110287c:	111b3900 	call	8111b390 <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18f45504 	addi	r3,r3,-11948
8110288c:	00a04534 	movhi	r2,33044
81102890:	10997e04 	addi	r2,r2,26104
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	111c4400 	call	8111c440 <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a05c17 	ldw	r2,-32400(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	29745504 	addi	r5,r5,-11948
811028b8:	1009883a 	mov	r4,r2
811028bc:	111b3900 	call	8111b390 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	10b45504 	addi	r2,r2,-11948
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a05c17 	ldw	r2,-32400(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	29745504 	addi	r5,r5,-11948
811028e0:	1009883a 	mov	r4,r2
811028e4:	111b3900 	call	8111b390 <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	114454c0 	call	8114454c <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	11326680 	call	81132668 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	11326680 	call	81132668 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	11326680 	call	81132668 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	11326680 	call	81132668 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	11435480 	call	81143548 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	11447bc0 	call	811447bc <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	11326680 	call	81132668 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	11326680 	call	81132668 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	11435480 	call	81143548 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	11447bc0 	call	811447bc <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	11435480 	call	81143548 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	11447bc0 	call	811447bc <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	11326680 	call	81132668 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	11326680 	call	81132668 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110aa580 	call	8110aa58 <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110aa580 	call	8110aa58 <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604534 	movhi	r5,33044
811030d0:	2959e404 	addi	r5,r5,26512
811030d4:	01204574 	movhi	r4,33045
811030d8:	21345504 	addi	r4,r4,-11948
811030dc:	111cd200 	call	8111cd20 <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a05c17 	ldw	r2,-32400(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	29745504 	addi	r5,r5,-11948
811030ec:	1009883a 	mov	r4,r2
811030f0:	111b3900 	call	8111b390 <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604534 	movhi	r5,33044
8110311c:	2959ea04 	addi	r5,r5,26536
81103120:	01204574 	movhi	r4,33045
81103124:	21345504 	addi	r4,r4,-11948
81103128:	111cd200 	call	8111cd20 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a05c17 	ldw	r2,-32400(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	29745504 	addi	r5,r5,-11948
81103138:	1009883a 	mov	r4,r2
8110313c:	111b3900 	call	8111b390 <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604534 	movhi	r5,33044
8110315c:	2959f604 	addi	r5,r5,26584
81103160:	01204574 	movhi	r4,33045
81103164:	21345504 	addi	r4,r4,-11948
81103168:	111cd200 	call	8111cd20 <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a05c17 	ldw	r2,-32400(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	29745504 	addi	r5,r5,-11948
81103178:	1009883a 	mov	r4,r2
8110317c:	111b3900 	call	8111b390 <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18f45504 	addi	r3,r3,-11948
811031c0:	00a04534 	movhi	r2,33044
811031c4:	1099fc04 	addi	r2,r2,26608
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	111c4400 	call	8111c440 <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a05c17 	ldw	r2,-32400(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	29745504 	addi	r5,r5,-11948
811031ec:	1009883a 	mov	r4,r2
811031f0:	111b3900 	call	8111b390 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	11098500 	call	81109850 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	11098500 	call	81109850 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04534 	movhi	r2,33044
811034f0:	109a3304 	addi	r2,r2,26828
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	111c4400 	call	8111c440 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111a6f80 	call	8111a6f8 <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	1119d800 	call	81119d80 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111a1c80 	call	8111a1c8 <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	111af100 	call	8111af10 <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604534 	movhi	r5,33044
81103658:	295a0104 	addi	r5,r5,26628
8110365c:	01204574 	movhi	r4,33045
81103660:	21345504 	addi	r4,r4,-11948
81103664:	111cd200 	call	8111cd20 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a05c17 	ldw	r2,-32400(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	29745504 	addi	r5,r5,-11948
81103674:	1009883a 	mov	r4,r2
81103678:	111b3900 	call	8111b390 <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	111af100 	call	8111af10 <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111a7f00 	call	8111a7f0 <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	111af100 	call	8111af10 <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111a7f00 	call	8111a7f0 <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	111b0280 	call	8111b028 <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	1119d800 	call	81119d80 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111a1c80 	call	8111a1c8 <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	111af100 	call	8111af10 <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	111af100 	call	8111af10 <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	111af100 	call	8111af10 <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604534 	movhi	r5,33044
811037f0:	295a0a04 	addi	r5,r5,26664
811037f4:	01204574 	movhi	r4,33045
811037f8:	21345504 	addi	r4,r4,-11948
811037fc:	111cd200 	call	8111cd20 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a05c17 	ldw	r2,-32400(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	29745504 	addi	r5,r5,-11948
8110380c:	1009883a 	mov	r4,r2
81103810:	111b3900 	call	8111b390 <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	111af100 	call	8111af10 <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111a7f00 	call	8111a7f0 <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	111af100 	call	8111af10 <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111a7f00 	call	8111a7f0 <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	111b0280 	call	8111b028 <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	1119d800 	call	81119d80 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111a1c80 	call	8111a1c8 <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	111af100 	call	8111af10 <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	111af100 	call	8111af10 <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	111af100 	call	8111af10 <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604534 	movhi	r5,33044
81103988:	295a1a04 	addi	r5,r5,26728
8110398c:	01204574 	movhi	r4,33045
81103990:	21345504 	addi	r4,r4,-11948
81103994:	111cd200 	call	8111cd20 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a05c17 	ldw	r2,-32400(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	29745504 	addi	r5,r5,-11948
811039a4:	1009883a 	mov	r4,r2
811039a8:	111b3900 	call	8111b390 <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111a1c80 	call	8111a1c8 <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	111af100 	call	8111af10 <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604534 	movhi	r5,33044
81103a30:	295a2a04 	addi	r5,r5,26792
81103a34:	01204574 	movhi	r4,33045
81103a38:	21345504 	addi	r4,r4,-11948
81103a3c:	111cd200 	call	8111cd20 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a05c17 	ldw	r2,-32400(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	29745504 	addi	r5,r5,-11948
81103a4c:	1009883a 	mov	r4,r2
81103a50:	111b3900 	call	8111b390 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	10b45504 	addi	r2,r2,-11948
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a05c17 	ldw	r2,-32400(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	29745504 	addi	r5,r5,-11948
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	111b3900 	call	8111b390 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	10b45504 	addi	r2,r2,-11948
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a05c17 	ldw	r2,-32400(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	29745504 	addi	r5,r5,-11948
81103af8:	1009883a 	mov	r4,r2
81103afc:	111b3900 	call	8111b390 <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204534 	movhi	r4,33044
81103b58:	211af304 	addi	r4,r4,27596
81103b5c:	114454c0 	call	8114454c <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	11326680 	call	81132668 <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204534 	movhi	r4,33044
81103c08:	211af804 	addi	r4,r4,27616
81103c0c:	114454c0 	call	8114454c <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	11326680 	call	81132668 <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c90:	deffe904 	addi	sp,sp,-92
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01615 	stw	ra,88(sp)
81103ca0:	df001515 	stw	fp,84(sp)
81103ca4:	dc001415 	stw	r16,80(sp)
81103ca8:	df001504 	addi	fp,sp,84
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81103cfc:	e0bffe03 	ldbu	r2,-8(fp)
81103d00:	10c00228 	cmpgeui	r3,r2,8
81103d04:	18009c1e 	bne	r3,zero,81103f78 <bSdmaDmaM1Transfer+0x2e8>
81103d08:	100690ba 	slli	r3,r2,2
81103d0c:	00a04434 	movhi	r2,33040
81103d10:	108f4804 	addi	r2,r2,15648
81103d14:	1885883a 	add	r2,r3,r2
81103d18:	10800017 	ldw	r2,0(r2)
81103d1c:	1000683a 	jmp	r2
81103d20:	81103d40 	call	881103d4 <__reset+0x20f03d4>
81103d24:	81103d80 	call	881103d8 <__reset+0x20f03d8>
81103d28:	81103dc8 	cmpgei	r4,r16,16631
81103d2c:	81103e10 	cmplti	r4,r16,16632
81103d30:	81103e58 	cmpnei	r4,r16,16633
81103d34:	81103ea0 	cmpeqi	r4,r16,16634
81103d38:	81103ee8 	cmpgeui	r4,r16,16635
81103d3c:	81103f30 	cmpltui	r4,r16,16636
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d40:	e0bffd03 	ldbu	r2,-12(fp)
81103d44:	10000626 	beq	r2,zero,81103d60 <bSdmaDmaM1Transfer+0xd0>
81103d48:	10800060 	cmpeqi	r2,r2,1
81103d4c:	10000926 	beq	r2,zero,81103d74 <bSdmaDmaM1Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d50:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d54:	00800044 	movi	r2,1
81103d58:	e0bff715 	stw	r2,-36(fp)
			break;
81103d5c:	00000706 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d60:	00800074 	movhi	r2,1
81103d64:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d68:	00800044 	movi	r2,1
81103d6c:	e0bff715 	stw	r2,-36(fp)
			break;
81103d70:	00000206 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		default:
			bStatus = FALSE;
81103d74:	e03ff415 	stw	zero,-48(fp)
			break;
81103d78:	0001883a 	nop
		}
		break;
81103d7c:	00008006 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d80:	e0bffd03 	ldbu	r2,-12(fp)
81103d84:	10000726 	beq	r2,zero,81103da4 <bSdmaDmaM1Transfer+0x114>
81103d88:	10800060 	cmpeqi	r2,r2,1
81103d8c:	10000b26 	beq	r2,zero,81103dbc <bSdmaDmaM1Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103d90:	00880004 	movi	r2,8192
81103d94:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103d98:	00800044 	movi	r2,1
81103d9c:	e0bff715 	stw	r2,-36(fp)
			break;
81103da0:	00000806 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103da4:	00800074 	movhi	r2,1
81103da8:	10880004 	addi	r2,r2,8192
81103dac:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff715 	stw	r2,-36(fp)
			break;
81103db8:	00000206 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		default:
			bStatus = FALSE;
81103dbc:	e03ff415 	stw	zero,-48(fp)
			break;
81103dc0:	0001883a 	nop
		}
		break;
81103dc4:	00006e06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103dc8:	e0bffd03 	ldbu	r2,-12(fp)
81103dcc:	10000726 	beq	r2,zero,81103dec <bSdmaDmaM1Transfer+0x15c>
81103dd0:	10800060 	cmpeqi	r2,r2,1
81103dd4:	10000b26 	beq	r2,zero,81103e04 <bSdmaDmaM1Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103dd8:	00900004 	movi	r2,16384
81103ddc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103de0:	00800044 	movi	r2,1
81103de4:	e0bff715 	stw	r2,-36(fp)
			break;
81103de8:	00000806 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103dec:	00800074 	movhi	r2,1
81103df0:	10900004 	addi	r2,r2,16384
81103df4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103df8:	00800044 	movi	r2,1
81103dfc:	e0bff715 	stw	r2,-36(fp)
			break;
81103e00:	00000206 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		default:
			bStatus = FALSE;
81103e04:	e03ff415 	stw	zero,-48(fp)
			break;
81103e08:	0001883a 	nop
		}
		break;
81103e0c:	00005c06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e10:	e0bffd03 	ldbu	r2,-12(fp)
81103e14:	10000726 	beq	r2,zero,81103e34 <bSdmaDmaM1Transfer+0x1a4>
81103e18:	10800060 	cmpeqi	r2,r2,1
81103e1c:	10000b26 	beq	r2,zero,81103e4c <bSdmaDmaM1Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e20:	00980004 	movi	r2,24576
81103e24:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e30:	00000806 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e34:	00800074 	movhi	r2,1
81103e38:	10980004 	addi	r2,r2,24576
81103e3c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e40:	00800044 	movi	r2,1
81103e44:	e0bff715 	stw	r2,-36(fp)
			break;
81103e48:	00000206 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		default:
			bStatus = FALSE;
81103e4c:	e03ff415 	stw	zero,-48(fp)
			break;
81103e50:	0001883a 	nop
		}
		break;
81103e54:	00004a06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e58:	e0bffd03 	ldbu	r2,-12(fp)
81103e5c:	10000726 	beq	r2,zero,81103e7c <bSdmaDmaM1Transfer+0x1ec>
81103e60:	10800060 	cmpeqi	r2,r2,1
81103e64:	10000b26 	beq	r2,zero,81103e94 <bSdmaDmaM1Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103e68:	00a00014 	movui	r2,32768
81103e6c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103e70:	00800044 	movi	r2,1
81103e74:	e0bff715 	stw	r2,-36(fp)
			break;
81103e78:	00000806 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103e7c:	008000b4 	movhi	r2,2
81103e80:	10a00004 	addi	r2,r2,-32768
81103e84:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103e88:	00800044 	movi	r2,1
81103e8c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e90:	00000206 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		default:
			bStatus = FALSE;
81103e94:	e03ff415 	stw	zero,-48(fp)
			break;
81103e98:	0001883a 	nop
		}
		break;
81103e9c:	00003806 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ea0:	e0bffd03 	ldbu	r2,-12(fp)
81103ea4:	10000726 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea8:	10800060 	cmpeqi	r2,r2,1
81103eac:	10000b26 	beq	r2,zero,81103edc <bSdmaDmaM1Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103eb0:	00a80014 	movui	r2,40960
81103eb4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103eb8:	00800044 	movi	r2,1
81103ebc:	e0bff715 	stw	r2,-36(fp)
			break;
81103ec0:	00000806 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a80004 	addi	r2,r2,-24576
81103ecc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff715 	stw	r2,-36(fp)
			break;
81103ed8:	00000206 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		default:
			bStatus = FALSE;
81103edc:	e03ff415 	stw	zero,-48(fp)
			break;
81103ee0:	0001883a 	nop
		}
		break;
81103ee4:	00002606 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103ee8:	e0bffd03 	ldbu	r2,-12(fp)
81103eec:	10000726 	beq	r2,zero,81103f0c <bSdmaDmaM1Transfer+0x27c>
81103ef0:	10800060 	cmpeqi	r2,r2,1
81103ef4:	10000b26 	beq	r2,zero,81103f24 <bSdmaDmaM1Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103ef8:	00b00014 	movui	r2,49152
81103efc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f00:	00800044 	movi	r2,1
81103f04:	e0bff715 	stw	r2,-36(fp)
			break;
81103f08:	00000806 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f0c:	008000b4 	movhi	r2,2
81103f10:	10b00004 	addi	r2,r2,-16384
81103f14:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f18:	00800044 	movi	r2,1
81103f1c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f20:	00000206 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		default:
			bStatus = FALSE;
81103f24:	e03ff415 	stw	zero,-48(fp)
			break;
81103f28:	0001883a 	nop
		}
		break;
81103f2c:	00001406 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f30:	e0bffd03 	ldbu	r2,-12(fp)
81103f34:	10000726 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x2c4>
81103f38:	10800060 	cmpeqi	r2,r2,1
81103f3c:	10000b26 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103f40:	00b80014 	movui	r2,57344
81103f44:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103f48:	00800044 	movi	r2,1
81103f4c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f50:	00000806 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103f54:	008000b4 	movhi	r2,2
81103f58:	10b80004 	addi	r2,r2,-8192
81103f5c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103f60:	00800044 	movi	r2,1
81103f64:	e0bff715 	stw	r2,-36(fp)
			break;
81103f68:	00000206 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		default:
			bStatus = FALSE;
81103f6c:	e03ff415 	stw	zero,-48(fp)
			break;
81103f70:	0001883a 	nop
		}
		break;
81103f74:	00000206 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	default:
		bStatus = FALSE;
81103f78:	e03ff415 	stw	zero,-48(fp)
		break;
81103f7c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103f80:	e0bffb17 	ldw	r2,-20(fp)
81103f84:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103f88:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81103f8c:	e0bff417 	ldw	r2,-48(fp)
81103f90:	10003b26 	beq	r2,zero,81104080 <bSdmaDmaM1Transfer+0x3f0>
		if (pxDmaM1Dev == NULL) {
81103f94:	d0a03917 	ldw	r2,-32540(gp)
81103f98:	1000021e 	bne	r2,zero,81103fa4 <bSdmaDmaM1Transfer+0x314>
			bStatus = FALSE;
81103f9c:	e03ff415 	stw	zero,-48(fp)
81103fa0:	00003706 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81103fa4:	e03ff50d 	sth	zero,-44(fp)
81103fa8:	00003206 	br	81104074 <bSdmaDmaM1Transfer+0x3e4>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81103fac:	01000044 	movi	r4,1
81103fb0:	1130bf40 	call	81130bf4 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103fb4:	d0a03917 	ldw	r2,-32540(gp)
81103fb8:	10800317 	ldw	r2,12(r2)
81103fbc:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81103fc0:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81103fc4:	103ff91e 	bne	r2,zero,81103fac <__reset+0xfb0e3fac>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81103fc8:	d2203917 	ldw	r8,-32540(gp)
81103fcc:	e17ff817 	ldw	r5,-32(fp)
81103fd0:	e1bff617 	ldw	r6,-40(fp)
81103fd4:	e0bff917 	ldw	r2,-28(fp)
81103fd8:	e0fff717 	ldw	r3,-36(fp)
81103fdc:	01000044 	movi	r4,1
81103fe0:	d9000815 	stw	r4,32(sp)
81103fe4:	01000044 	movi	r4,1
81103fe8:	d9000715 	stw	r4,28(sp)
81103fec:	01000044 	movi	r4,1
81103ff0:	d9000615 	stw	r4,24(sp)
81103ff4:	01000044 	movi	r4,1
81103ff8:	d9000515 	stw	r4,20(sp)
81103ffc:	01000044 	movi	r4,1
81104000:	d9000415 	stw	r4,16(sp)
81104004:	d8c00315 	stw	r3,12(sp)
81104008:	d8800215 	stw	r2,8(sp)
8110400c:	e0bffa17 	ldw	r2,-24(fp)
81104010:	d8800115 	stw	r2,4(sp)
81104014:	00802204 	movi	r2,136
81104018:	d8800015 	stw	r2,0(sp)
8110401c:	300f883a 	mov	r7,r6
81104020:	280d883a 	mov	r6,r5
81104024:	800b883a 	mov	r5,r16
81104028:	4009883a 	mov	r4,r8
8110402c:	110a9100 	call	8110a910 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104030:	10000226 	beq	r2,zero,8110403c <bSdmaDmaM1Transfer+0x3ac>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104034:	e03ff415 	stw	zero,-48(fp)
					break;
81104038:	00001106 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
8110403c:	d0a03917 	ldw	r2,-32540(gp)
81104040:	800b883a 	mov	r5,r16
81104044:	1009883a 	mov	r4,r2
81104048:	110aa140 	call	8110aa14 <iMsgdmaExtendedDescriptorSyncTransfer>
8110404c:	10000226 	beq	r2,zero,81104058 <bSdmaDmaM1Transfer+0x3c8>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104050:	e03ff415 	stw	zero,-48(fp)
						break;
81104054:	00000a06 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
81104058:	e0bff817 	ldw	r2,-32(fp)
8110405c:	10802204 	addi	r2,r2,136
81104060:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104064:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104068:	e0bff50b 	ldhu	r2,-44(fp)
8110406c:	10800044 	addi	r2,r2,1
81104070:	e0bff50d 	sth	r2,-44(fp)
81104074:	e0fff50b 	ldhu	r3,-44(fp)
81104078:	e0bffc0b 	ldhu	r2,-16(fp)
8110407c:	18bfcd36 	bltu	r3,r2,81103fb4 <__reset+0xfb0e3fb4>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104080:	e0bff417 	ldw	r2,-48(fp)
}
81104084:	e6ffff04 	addi	sp,fp,-4
81104088:	dfc00217 	ldw	ra,8(sp)
8110408c:	df000117 	ldw	fp,4(sp)
81104090:	dc000017 	ldw	r16,0(sp)
81104094:	dec00304 	addi	sp,sp,12
81104098:	f800283a 	ret

8110409c <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
8110409c:	deffe904 	addi	sp,sp,-92
811040a0:	de00012e 	bgeu	sp,et,811040a8 <bSdmaDmaM2Transfer+0xc>
811040a4:	003b68fa 	trap	3
811040a8:	dfc01615 	stw	ra,88(sp)
811040ac:	df001515 	stw	fp,84(sp)
811040b0:	dc001415 	stw	r16,80(sp)
811040b4:	df001504 	addi	fp,sp,84
811040b8:	e13ffb15 	stw	r4,-20(fp)
811040bc:	2809883a 	mov	r4,r5
811040c0:	3007883a 	mov	r3,r6
811040c4:	3805883a 	mov	r2,r7
811040c8:	e13ffc0d 	sth	r4,-16(fp)
811040cc:	e0fffd05 	stb	r3,-12(fp)
811040d0:	e0bffe05 	stb	r2,-8(fp)
811040d4:	defff004 	addi	sp,sp,-64
811040d8:	d8800904 	addi	r2,sp,36
811040dc:	108007c4 	addi	r2,r2,31
811040e0:	1004d17a 	srli	r2,r2,5
811040e4:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
811040e8:	00800044 	movi	r2,1
811040ec:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
811040f0:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
811040f4:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
811040f8:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
811040fc:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104100:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104104:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81104108:	e0bffe03 	ldbu	r2,-8(fp)
8110410c:	10c00228 	cmpgeui	r3,r2,8
81104110:	18009c1e 	bne	r3,zero,81104384 <bSdmaDmaM2Transfer+0x2e8>
81104114:	100690ba 	slli	r3,r2,2
81104118:	00a04434 	movhi	r2,33040
8110411c:	10904b04 	addi	r2,r2,16684
81104120:	1885883a 	add	r2,r3,r2
81104124:	10800017 	ldw	r2,0(r2)
81104128:	1000683a 	jmp	r2
8110412c:	8110414c 	andi	r4,r16,16645
81104130:	8110418c 	andi	r4,r16,16646
81104134:	811041d4 	ori	r4,r16,16647
81104138:	8110421c 	xori	r4,r16,16648
8110413c:	81104264 	muli	r4,r16,16649
81104140:	811042ac 	andhi	r4,r16,16650
81104144:	811042f4 	orhi	r4,r16,16651
81104148:	8110433c 	xorhi	r4,r16,16652
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
8110414c:	e0bffd03 	ldbu	r2,-12(fp)
81104150:	10000626 	beq	r2,zero,8110416c <bSdmaDmaM2Transfer+0xd0>
81104154:	10800060 	cmpeqi	r2,r2,1
81104158:	10000926 	beq	r2,zero,81104180 <bSdmaDmaM2Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
8110415c:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104160:	00800044 	movi	r2,1
81104164:	e0bff715 	stw	r2,-36(fp)
			break;
81104168:	00000706 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
8110416c:	00800074 	movhi	r2,1
81104170:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81104174:	00800044 	movi	r2,1
81104178:	e0bff715 	stw	r2,-36(fp)
			break;
8110417c:	00000206 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		default:
			bStatus = FALSE;
81104180:	e03ff415 	stw	zero,-48(fp)
			break;
81104184:	0001883a 	nop
		}
		break;
81104188:	00008006 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
8110418c:	e0bffd03 	ldbu	r2,-12(fp)
81104190:	10000726 	beq	r2,zero,811041b0 <bSdmaDmaM2Transfer+0x114>
81104194:	10800060 	cmpeqi	r2,r2,1
81104198:	10000b26 	beq	r2,zero,811041c8 <bSdmaDmaM2Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
8110419c:	00880004 	movi	r2,8192
811041a0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811041a4:	00800044 	movi	r2,1
811041a8:	e0bff715 	stw	r2,-36(fp)
			break;
811041ac:	00000806 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811041b0:	00800074 	movhi	r2,1
811041b4:	10880004 	addi	r2,r2,8192
811041b8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
811041bc:	00800044 	movi	r2,1
811041c0:	e0bff715 	stw	r2,-36(fp)
			break;
811041c4:	00000206 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		default:
			bStatus = FALSE;
811041c8:	e03ff415 	stw	zero,-48(fp)
			break;
811041cc:	0001883a 	nop
		}
		break;
811041d0:	00006e06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811041d4:	e0bffd03 	ldbu	r2,-12(fp)
811041d8:	10000726 	beq	r2,zero,811041f8 <bSdmaDmaM2Transfer+0x15c>
811041dc:	10800060 	cmpeqi	r2,r2,1
811041e0:	10000b26 	beq	r2,zero,81104210 <bSdmaDmaM2Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
811041e4:	00900004 	movi	r2,16384
811041e8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
811041ec:	00800044 	movi	r2,1
811041f0:	e0bff715 	stw	r2,-36(fp)
			break;
811041f4:	00000806 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
811041f8:	00800074 	movhi	r2,1
811041fc:	10900004 	addi	r2,r2,16384
81104200:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104204:	00800044 	movi	r2,1
81104208:	e0bff715 	stw	r2,-36(fp)
			break;
8110420c:	00000206 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		default:
			bStatus = FALSE;
81104210:	e03ff415 	stw	zero,-48(fp)
			break;
81104214:	0001883a 	nop
		}
		break;
81104218:	00005c06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
8110421c:	e0bffd03 	ldbu	r2,-12(fp)
81104220:	10000726 	beq	r2,zero,81104240 <bSdmaDmaM2Transfer+0x1a4>
81104224:	10800060 	cmpeqi	r2,r2,1
81104228:	10000b26 	beq	r2,zero,81104258 <bSdmaDmaM2Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
8110422c:	00980004 	movi	r2,24576
81104230:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104234:	00800044 	movi	r2,1
81104238:	e0bff715 	stw	r2,-36(fp)
			break;
8110423c:	00000806 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104240:	00800074 	movhi	r2,1
81104244:	10980004 	addi	r2,r2,24576
81104248:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
8110424c:	00800044 	movi	r2,1
81104250:	e0bff715 	stw	r2,-36(fp)
			break;
81104254:	00000206 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		default:
			bStatus = FALSE;
81104258:	e03ff415 	stw	zero,-48(fp)
			break;
8110425c:	0001883a 	nop
		}
		break;
81104260:	00004a06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104264:	e0bffd03 	ldbu	r2,-12(fp)
81104268:	10000726 	beq	r2,zero,81104288 <bSdmaDmaM2Transfer+0x1ec>
8110426c:	10800060 	cmpeqi	r2,r2,1
81104270:	10000b26 	beq	r2,zero,811042a0 <bSdmaDmaM2Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104274:	00a00014 	movui	r2,32768
81104278:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
8110427c:	00800044 	movi	r2,1
81104280:	e0bff715 	stw	r2,-36(fp)
			break;
81104284:	00000806 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104288:	008000b4 	movhi	r2,2
8110428c:	10a00004 	addi	r2,r2,-32768
81104290:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104294:	00800044 	movi	r2,1
81104298:	e0bff715 	stw	r2,-36(fp)
			break;
8110429c:	00000206 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		default:
			bStatus = FALSE;
811042a0:	e03ff415 	stw	zero,-48(fp)
			break;
811042a4:	0001883a 	nop
		}
		break;
811042a8:	00003806 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811042ac:	e0bffd03 	ldbu	r2,-12(fp)
811042b0:	10000726 	beq	r2,zero,811042d0 <bSdmaDmaM2Transfer+0x234>
811042b4:	10800060 	cmpeqi	r2,r2,1
811042b8:	10000b26 	beq	r2,zero,811042e8 <bSdmaDmaM2Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811042bc:	00a80014 	movui	r2,40960
811042c0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811042c4:	00800044 	movi	r2,1
811042c8:	e0bff715 	stw	r2,-36(fp)
			break;
811042cc:	00000806 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
811042d0:	008000b4 	movhi	r2,2
811042d4:	10a80004 	addi	r2,r2,-24576
811042d8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
811042dc:	00800044 	movi	r2,1
811042e0:	e0bff715 	stw	r2,-36(fp)
			break;
811042e4:	00000206 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		default:
			bStatus = FALSE;
811042e8:	e03ff415 	stw	zero,-48(fp)
			break;
811042ec:	0001883a 	nop
		}
		break;
811042f0:	00002606 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811042f4:	e0bffd03 	ldbu	r2,-12(fp)
811042f8:	10000726 	beq	r2,zero,81104318 <bSdmaDmaM2Transfer+0x27c>
811042fc:	10800060 	cmpeqi	r2,r2,1
81104300:	10000b26 	beq	r2,zero,81104330 <bSdmaDmaM2Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104304:	00b00014 	movui	r2,49152
81104308:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
8110430c:	00800044 	movi	r2,1
81104310:	e0bff715 	stw	r2,-36(fp)
			break;
81104314:	00000806 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104318:	008000b4 	movhi	r2,2
8110431c:	10b00004 	addi	r2,r2,-16384
81104320:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104324:	00800044 	movi	r2,1
81104328:	e0bff715 	stw	r2,-36(fp)
			break;
8110432c:	00000206 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		default:
			bStatus = FALSE;
81104330:	e03ff415 	stw	zero,-48(fp)
			break;
81104334:	0001883a 	nop
		}
		break;
81104338:	00001406 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110433c:	e0bffd03 	ldbu	r2,-12(fp)
81104340:	10000726 	beq	r2,zero,81104360 <bSdmaDmaM2Transfer+0x2c4>
81104344:	10800060 	cmpeqi	r2,r2,1
81104348:	10000b26 	beq	r2,zero,81104378 <bSdmaDmaM2Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110434c:	00b80014 	movui	r2,57344
81104350:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104354:	00800044 	movi	r2,1
81104358:	e0bff715 	stw	r2,-36(fp)
			break;
8110435c:	00000806 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104360:	008000b4 	movhi	r2,2
81104364:	10b80004 	addi	r2,r2,-8192
81104368:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
8110436c:	00800044 	movi	r2,1
81104370:	e0bff715 	stw	r2,-36(fp)
			break;
81104374:	00000206 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		default:
			bStatus = FALSE;
81104378:	e03ff415 	stw	zero,-48(fp)
			break;
8110437c:	0001883a 	nop
		}
		break;
81104380:	00000206 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	default:
		bStatus = FALSE;
81104384:	e03ff415 	stw	zero,-48(fp)
		break;
81104388:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
8110438c:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
81104390:	00a00034 	movhi	r2,32768
81104394:	1885883a 	add	r2,r3,r2
81104398:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
8110439c:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
811043a0:	e0bff417 	ldw	r2,-48(fp)
811043a4:	10003b26 	beq	r2,zero,81104494 <bSdmaDmaM2Transfer+0x3f8>
		if (pxDmaM2Dev == NULL) {
811043a8:	d0a03a17 	ldw	r2,-32536(gp)
811043ac:	1000021e 	bne	r2,zero,811043b8 <bSdmaDmaM2Transfer+0x31c>
			bStatus = FALSE;
811043b0:	e03ff415 	stw	zero,-48(fp)
811043b4:	00003706 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811043b8:	e03ff50d 	sth	zero,-44(fp)
811043bc:	00003206 	br	81104488 <bSdmaDmaM2Transfer+0x3ec>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811043c0:	01000044 	movi	r4,1
811043c4:	1130bf40 	call	81130bf4 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
811043c8:	d0a03a17 	ldw	r2,-32536(gp)
811043cc:	10800317 	ldw	r2,12(r2)
811043d0:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811043d4:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
811043d8:	103ff91e 	bne	r2,zero,811043c0 <__reset+0xfb0e43c0>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811043dc:	d2203a17 	ldw	r8,-32536(gp)
811043e0:	e17ff817 	ldw	r5,-32(fp)
811043e4:	e1bff617 	ldw	r6,-40(fp)
811043e8:	e0bff917 	ldw	r2,-28(fp)
811043ec:	e0fff717 	ldw	r3,-36(fp)
811043f0:	01000044 	movi	r4,1
811043f4:	d9000815 	stw	r4,32(sp)
811043f8:	01000044 	movi	r4,1
811043fc:	d9000715 	stw	r4,28(sp)
81104400:	01000044 	movi	r4,1
81104404:	d9000615 	stw	r4,24(sp)
81104408:	01000044 	movi	r4,1
8110440c:	d9000515 	stw	r4,20(sp)
81104410:	01000044 	movi	r4,1
81104414:	d9000415 	stw	r4,16(sp)
81104418:	d8c00315 	stw	r3,12(sp)
8110441c:	d8800215 	stw	r2,8(sp)
81104420:	e0bffa17 	ldw	r2,-24(fp)
81104424:	d8800115 	stw	r2,4(sp)
81104428:	00802204 	movi	r2,136
8110442c:	d8800015 	stw	r2,0(sp)
81104430:	300f883a 	mov	r7,r6
81104434:	280d883a 	mov	r6,r5
81104438:	800b883a 	mov	r5,r16
8110443c:	4009883a 	mov	r4,r8
81104440:	110a9100 	call	8110a910 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104444:	10000226 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x3b4>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104448:	e03ff415 	stw	zero,-48(fp)
					break;
8110444c:	00001106 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104450:	d0a03a17 	ldw	r2,-32536(gp)
81104454:	800b883a 	mov	r5,r16
81104458:	1009883a 	mov	r4,r2
8110445c:	110aa140 	call	8110aa14 <iMsgdmaExtendedDescriptorSyncTransfer>
81104460:	10000226 	beq	r2,zero,8110446c <bSdmaDmaM2Transfer+0x3d0>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104464:	e03ff415 	stw	zero,-48(fp)
						break;
81104468:	00000a06 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
8110446c:	e0bff817 	ldw	r2,-32(fp)
81104470:	10802204 	addi	r2,r2,136
81104474:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104478:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
8110447c:	e0bff50b 	ldhu	r2,-44(fp)
81104480:	10800044 	addi	r2,r2,1
81104484:	e0bff50d 	sth	r2,-44(fp)
81104488:	e0fff50b 	ldhu	r3,-44(fp)
8110448c:	e0bffc0b 	ldhu	r2,-16(fp)
81104490:	18bfcd36 	bltu	r3,r2,811043c8 <__reset+0xfb0e43c8>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104494:	e0bff417 	ldw	r2,-48(fp)
}
81104498:	e6ffff04 	addi	sp,fp,-4
8110449c:	dfc00217 	ldw	ra,8(sp)
811044a0:	df000117 	ldw	fp,4(sp)
811044a4:	dc000017 	ldw	r16,0(sp)
811044a8:	dec00304 	addi	sp,sp,12
811044ac:	f800283a 	ret

811044b0 <bCommInitCh>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
811044b0:	defffb04 	addi	sp,sp,-20
811044b4:	de00012e 	bgeu	sp,et,811044bc <bCommInitCh+0xc>
811044b8:	003b68fa 	trap	3
811044bc:	dfc00415 	stw	ra,16(sp)
811044c0:	df000315 	stw	fp,12(sp)
811044c4:	df000304 	addi	fp,sp,12
811044c8:	e13ffe15 	stw	r4,-8(fp)
811044cc:	2805883a 	mov	r2,r5
811044d0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811044d4:	00800044 	movi	r2,1
811044d8:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
811044dc:	e0bffe17 	ldw	r2,-8(fp)
811044e0:	10805604 	addi	r2,r2,344
811044e4:	e0ffff03 	ldbu	r3,-4(fp)
811044e8:	180b883a 	mov	r5,r3
811044ec:	1009883a 	mov	r4,r2
811044f0:	11092940 	call	81109294 <bSpwcInitCh>
811044f4:	1000011e 	bne	r2,zero,811044fc <bCommInitCh+0x4c>
		bStatus = FALSE;
811044f8:	e03ffd15 	stw	zero,-12(fp)
	}
	vFeebInitIrq(ucCommCh);
811044fc:	e0bfff03 	ldbu	r2,-4(fp)
81104500:	1009883a 	mov	r4,r2
81104504:	11054ac0 	call	811054ac <vFeebInitIrq>

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104508:	e0bffe17 	ldw	r2,-8(fp)
8110450c:	10800904 	addi	r2,r2,36
81104510:	e0ffff03 	ldbu	r3,-4(fp)
81104514:	180b883a 	mov	r5,r3
81104518:	1009883a 	mov	r4,r2
8110451c:	1105ba40 	call	81105ba4 <bFeebInitCh>
81104520:	1000011e 	bne	r2,zero,81104528 <bCommInitCh+0x78>
		bStatus = FALSE;
81104524:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104528:	e0bffe17 	ldw	r2,-8(fp)
8110452c:	10801004 	addi	r2,r2,64
81104530:	e0ffff03 	ldbu	r3,-4(fp)
81104534:	180b883a 	mov	r5,r3
81104538:	1009883a 	mov	r4,r2
8110453c:	11088f00 	call	811088f0 <bRmapInitCh>
81104540:	1000011e 	bne	r2,zero,81104548 <bCommInitCh+0x98>
		bStatus = FALSE;
81104544:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81104548:	e0bfff03 	ldbu	r2,-4(fp)
8110454c:	1009883a 	mov	r4,r2
81104550:	110672c0 	call	8110672c <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81104554:	e0bffe17 	ldw	r2,-8(fp)
81104558:	10800104 	addi	r2,r2,4
8110455c:	e0ffff03 	ldbu	r3,-4(fp)
81104560:	180b883a 	mov	r5,r3
81104564:	1009883a 	mov	r4,r2
81104568:	1104bb40 	call	81104bb4 <bDpktInitCh>
8110456c:	1000011e 	bne	r2,zero,81104574 <bCommInitCh+0xc4>
		bStatus = FALSE;
81104570:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
81104574:	e0bffd17 	ldw	r2,-12(fp)
}
81104578:	e037883a 	mov	sp,fp
8110457c:	dfc00117 	ldw	ra,4(sp)
81104580:	df000017 	ldw	fp,0(sp)
81104584:	dec00204 	addi	sp,sp,8
81104588:	f800283a 	ret

8110458c <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
8110458c:	defffb04 	addi	sp,sp,-20
81104590:	de00012e 	bgeu	sp,et,81104598 <bDpktSetPacketConfig+0xc>
81104594:	003b68fa 	trap	3
81104598:	dfc00415 	stw	ra,16(sp)
8110459c:	df000315 	stw	fp,12(sp)
811045a0:	df000304 	addi	fp,sp,12
811045a4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811045a8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811045ac:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811045b0:	e0bfff17 	ldw	r2,-4(fp)
811045b4:	10007a26 	beq	r2,zero,811047a0 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811045b8:	e0bfff17 	ldw	r2,-4(fp)
811045bc:	10800017 	ldw	r2,0(r2)
811045c0:	01400204 	movi	r5,8
811045c4:	1009883a 	mov	r4,r2
811045c8:	1104d7c0 	call	81104d7c <uliDpktReadReg>
811045cc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
811045d0:	e0bffe17 	ldw	r2,-8(fp)
811045d4:	10bfffec 	andhi	r2,r2,65535
811045d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
811045dc:	e0bfff17 	ldw	r2,-4(fp)
811045e0:	1080010b 	ldhu	r2,4(r2)
811045e4:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
811045e8:	e0fffe17 	ldw	r3,-8(fp)
811045ec:	1884b03a 	or	r2,r3,r2
811045f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
811045f4:	e0bffe17 	ldw	r2,-8(fp)
811045f8:	10bfffcc 	andi	r2,r2,65535
811045fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
81104600:	e0bfff17 	ldw	r2,-4(fp)
81104604:	1080018b 	ldhu	r2,6(r2)
81104608:	10bfffcc 	andi	r2,r2,65535
8110460c:	1004943a 	slli	r2,r2,16
81104610:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
81104614:	e0bffe17 	ldw	r2,-8(fp)
81104618:	10c4b03a 	or	r2,r2,r3
8110461c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
81104620:	e0bfff17 	ldw	r2,-4(fp)
81104624:	10800017 	ldw	r2,0(r2)
81104628:	e1bffe17 	ldw	r6,-8(fp)
8110462c:	01400204 	movi	r5,8
81104630:	1009883a 	mov	r4,r2
81104634:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104638:	e0bfff17 	ldw	r2,-4(fp)
8110463c:	10800017 	ldw	r2,0(r2)
81104640:	01400244 	movi	r5,9
81104644:	1009883a 	mov	r4,r2
81104648:	1104d7c0 	call	81104d7c <uliDpktReadReg>
8110464c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81104650:	e0bffe17 	ldw	r2,-8(fp)
81104654:	10bfffec 	andhi	r2,r2,65535
81104658:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
8110465c:	e0bfff17 	ldw	r2,-4(fp)
81104660:	1080020b 	ldhu	r2,8(r2)
81104664:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81104668:	e0fffe17 	ldw	r3,-8(fp)
8110466c:	1884b03a 	or	r2,r3,r2
81104670:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104674:	e0bffe17 	ldw	r2,-8(fp)
81104678:	10bfffcc 	andi	r2,r2,65535
8110467c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104680:	e0bfff17 	ldw	r2,-4(fp)
81104684:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104688:	10bfffcc 	andi	r2,r2,65535
8110468c:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81104690:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104694:	e0bffe17 	ldw	r2,-8(fp)
81104698:	10c4b03a 	or	r2,r2,r3
8110469c:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
811046a0:	e0bfff17 	ldw	r2,-4(fp)
811046a4:	10800017 	ldw	r2,0(r2)
811046a8:	e1bffe17 	ldw	r6,-8(fp)
811046ac:	01400244 	movi	r5,9
811046b0:	1009883a 	mov	r4,r2
811046b4:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811046b8:	e0bfff17 	ldw	r2,-4(fp)
811046bc:	10800017 	ldw	r2,0(r2)
811046c0:	01400284 	movi	r5,10
811046c4:	1009883a 	mov	r4,r2
811046c8:	1104d7c0 	call	81104d7c <uliDpktReadReg>
811046cc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
811046d0:	e0bffe17 	ldw	r2,-8(fp)
811046d4:	10bfffec 	andhi	r2,r2,65535
811046d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
811046dc:	e0bfff17 	ldw	r2,-4(fp)
811046e0:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
811046e4:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
811046e8:	e0fffe17 	ldw	r3,-8(fp)
811046ec:	1884b03a 	or	r2,r3,r2
811046f0:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
811046f4:	e0bfff17 	ldw	r2,-4(fp)
811046f8:	10800017 	ldw	r2,0(r2)
811046fc:	e1bffe17 	ldw	r6,-8(fp)
81104700:	01400284 	movi	r5,10
81104704:	1009883a 	mov	r4,r2
81104708:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110470c:	e0bfff17 	ldw	r2,-4(fp)
81104710:	10800017 	ldw	r2,0(r2)
81104714:	014002c4 	movi	r5,11
81104718:	1009883a 	mov	r4,r2
8110471c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104720:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81104724:	e0fffe17 	ldw	r3,-8(fp)
81104728:	00bfc004 	movi	r2,-256
8110472c:	1884703a 	and	r2,r3,r2
81104730:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81104734:	e0bfff17 	ldw	r2,-4(fp)
81104738:	10800383 	ldbu	r2,14(r2)
8110473c:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
81104740:	e0fffe17 	ldw	r3,-8(fp)
81104744:	1884b03a 	or	r2,r3,r2
81104748:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
8110474c:	e0fffe17 	ldw	r3,-8(fp)
81104750:	00bffff4 	movhi	r2,65535
81104754:	10803fc4 	addi	r2,r2,255
81104758:	1884703a 	and	r2,r3,r2
8110475c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104760:	e0bfff17 	ldw	r2,-4(fp)
81104764:	108003c3 	ldbu	r2,15(r2)
81104768:	10803fcc 	andi	r2,r2,255
8110476c:	1004923a 	slli	r2,r2,8
81104770:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104774:	e0fffe17 	ldw	r3,-8(fp)
81104778:	1884b03a 	or	r2,r3,r2
8110477c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104780:	e0bfff17 	ldw	r2,-4(fp)
81104784:	10800017 	ldw	r2,0(r2)
81104788:	e1bffe17 	ldw	r6,-8(fp)
8110478c:	014002c4 	movi	r5,11
81104790:	1009883a 	mov	r4,r2
81104794:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104798:	00800044 	movi	r2,1
8110479c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811047a0:	e0bffd17 	ldw	r2,-12(fp)
}
811047a4:	e037883a 	mov	sp,fp
811047a8:	dfc00117 	ldw	ra,4(sp)
811047ac:	df000017 	ldw	fp,0(sp)
811047b0:	dec00204 	addi	sp,sp,8
811047b4:	f800283a 	ret

811047b8 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
811047b8:	defffb04 	addi	sp,sp,-20
811047bc:	de00012e 	bgeu	sp,et,811047c4 <bDpktGetPacketConfig+0xc>
811047c0:	003b68fa 	trap	3
811047c4:	dfc00415 	stw	ra,16(sp)
811047c8:	df000315 	stw	fp,12(sp)
811047cc:	df000304 	addi	fp,sp,12
811047d0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811047d4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811047d8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811047dc:	e0bfff17 	ldw	r2,-4(fp)
811047e0:	10003a26 	beq	r2,zero,811048cc <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811047e4:	e0bfff17 	ldw	r2,-4(fp)
811047e8:	10800017 	ldw	r2,0(r2)
811047ec:	01400204 	movi	r5,8
811047f0:	1009883a 	mov	r4,r2
811047f4:	1104d7c0 	call	81104d7c <uliDpktReadReg>
811047f8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
811047fc:	e0bffe17 	ldw	r2,-8(fp)
81104800:	1007883a 	mov	r3,r2
81104804:	e0bfff17 	ldw	r2,-4(fp)
81104808:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
8110480c:	e0bffe17 	ldw	r2,-8(fp)
81104810:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104814:	1007883a 	mov	r3,r2
81104818:	e0bfff17 	ldw	r2,-4(fp)
8110481c:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104820:	e0bfff17 	ldw	r2,-4(fp)
81104824:	10800017 	ldw	r2,0(r2)
81104828:	01400244 	movi	r5,9
8110482c:	1009883a 	mov	r4,r2
81104830:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104834:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104838:	e0bffe17 	ldw	r2,-8(fp)
8110483c:	1007883a 	mov	r3,r2
81104840:	e0bfff17 	ldw	r2,-4(fp)
81104844:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104848:	e0bffe17 	ldw	r2,-8(fp)
8110484c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104850:	1007883a 	mov	r3,r2
81104854:	e0bfff17 	ldw	r2,-4(fp)
81104858:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110485c:	e0bfff17 	ldw	r2,-4(fp)
81104860:	10800017 	ldw	r2,0(r2)
81104864:	01400284 	movi	r5,10
81104868:	1009883a 	mov	r4,r2
8110486c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104870:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104874:	e0bffe17 	ldw	r2,-8(fp)
81104878:	1007883a 	mov	r3,r2
8110487c:	e0bfff17 	ldw	r2,-4(fp)
81104880:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104884:	e0bfff17 	ldw	r2,-4(fp)
81104888:	10800017 	ldw	r2,0(r2)
8110488c:	014002c4 	movi	r5,11
81104890:	1009883a 	mov	r4,r2
81104894:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104898:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
8110489c:	e0bffe17 	ldw	r2,-8(fp)
811048a0:	1007883a 	mov	r3,r2
811048a4:	e0bfff17 	ldw	r2,-4(fp)
811048a8:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
811048ac:	e0bffe17 	ldw	r2,-8(fp)
811048b0:	10bfc00c 	andi	r2,r2,65280
811048b4:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
811048b8:	1007883a 	mov	r3,r2
811048bc:	e0bfff17 	ldw	r2,-4(fp)
811048c0:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
811048c4:	00800044 	movi	r2,1
811048c8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811048cc:	e0bffd17 	ldw	r2,-12(fp)
}
811048d0:	e037883a 	mov	sp,fp
811048d4:	dfc00117 	ldw	ra,4(sp)
811048d8:	df000017 	ldw	fp,0(sp)
811048dc:	dec00204 	addi	sp,sp,8
811048e0:	f800283a 	ret

811048e4 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
811048e4:	defffb04 	addi	sp,sp,-20
811048e8:	de00012e 	bgeu	sp,et,811048f0 <bDpktGetPacketHeader+0xc>
811048ec:	003b68fa 	trap	3
811048f0:	dfc00415 	stw	ra,16(sp)
811048f4:	df000315 	stw	fp,12(sp)
811048f8:	df000304 	addi	fp,sp,12
811048fc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104900:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104904:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104908:	e0bfff17 	ldw	r2,-4(fp)
8110490c:	10002026 	beq	r2,zero,81104990 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104910:	e0bfff17 	ldw	r2,-4(fp)
81104914:	10800017 	ldw	r2,0(r2)
81104918:	01400304 	movi	r5,12
8110491c:	1009883a 	mov	r4,r2
81104920:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104924:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104928:	e0bffe17 	ldw	r2,-8(fp)
8110492c:	1007883a 	mov	r3,r2
81104930:	e0bfff17 	ldw	r2,-4(fp)
81104934:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104938:	e0bffe17 	ldw	r2,-8(fp)
8110493c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104940:	1007883a 	mov	r3,r2
81104944:	e0bfff17 	ldw	r2,-4(fp)
81104948:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110494c:	e0bfff17 	ldw	r2,-4(fp)
81104950:	10800017 	ldw	r2,0(r2)
81104954:	01400344 	movi	r5,13
81104958:	1009883a 	mov	r4,r2
8110495c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104960:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104964:	e0bffe17 	ldw	r2,-8(fp)
81104968:	1007883a 	mov	r3,r2
8110496c:	e0bfff17 	ldw	r2,-4(fp)
81104970:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104974:	e0bffe17 	ldw	r2,-8(fp)
81104978:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
8110497c:	1007883a 	mov	r3,r2
81104980:	e0bfff17 	ldw	r2,-4(fp)
81104984:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104988:	00800044 	movi	r2,1
8110498c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104990:	e0bffd17 	ldw	r2,-12(fp)
}
81104994:	e037883a 	mov	sp,fp
81104998:	dfc00117 	ldw	ra,4(sp)
8110499c:	df000017 	ldw	fp,0(sp)
811049a0:	dec00204 	addi	sp,sp,8
811049a4:	f800283a 	ret

811049a8 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
811049a8:	defffb04 	addi	sp,sp,-20
811049ac:	de00012e 	bgeu	sp,et,811049b4 <bDpktSetPixelDelay+0xc>
811049b0:	003b68fa 	trap	3
811049b4:	dfc00415 	stw	ra,16(sp)
811049b8:	df000315 	stw	fp,12(sp)
811049bc:	df000304 	addi	fp,sp,12
811049c0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811049c4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811049c8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811049cc:	e0bfff17 	ldw	r2,-4(fp)
811049d0:	10004126 	beq	r2,zero,81104ad8 <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049d4:	e0bfff17 	ldw	r2,-4(fp)
811049d8:	10800017 	ldw	r2,0(r2)
811049dc:	01400384 	movi	r5,14
811049e0:	1009883a 	mov	r4,r2
811049e4:	1104d7c0 	call	81104d7c <uliDpktReadReg>
811049e8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
811049ec:	e0bffe17 	ldw	r2,-8(fp)
811049f0:	10bfffec 	andhi	r2,r2,65535
811049f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
811049f8:	e0bfff17 	ldw	r2,-4(fp)
811049fc:	1080060b 	ldhu	r2,24(r2)
81104a00:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104a04:	e0fffe17 	ldw	r3,-8(fp)
81104a08:	1884b03a 	or	r2,r3,r2
81104a0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104a10:	e0bfff17 	ldw	r2,-4(fp)
81104a14:	10800017 	ldw	r2,0(r2)
81104a18:	e1bffe17 	ldw	r6,-8(fp)
81104a1c:	01400384 	movi	r5,14
81104a20:	1009883a 	mov	r4,r2
81104a24:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a28:	e0bfff17 	ldw	r2,-4(fp)
81104a2c:	10800017 	ldw	r2,0(r2)
81104a30:	014003c4 	movi	r5,15
81104a34:	1009883a 	mov	r4,r2
81104a38:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104a3c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104a40:	e0bffe17 	ldw	r2,-8(fp)
81104a44:	10bfffec 	andhi	r2,r2,65535
81104a48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104a4c:	e0bfff17 	ldw	r2,-4(fp)
81104a50:	1080068b 	ldhu	r2,26(r2)
81104a54:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104a58:	e0fffe17 	ldw	r3,-8(fp)
81104a5c:	1884b03a 	or	r2,r3,r2
81104a60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104a64:	e0bfff17 	ldw	r2,-4(fp)
81104a68:	10800017 	ldw	r2,0(r2)
81104a6c:	e1bffe17 	ldw	r6,-8(fp)
81104a70:	014003c4 	movi	r5,15
81104a74:	1009883a 	mov	r4,r2
81104a78:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a7c:	e0bfff17 	ldw	r2,-4(fp)
81104a80:	10800017 	ldw	r2,0(r2)
81104a84:	01400404 	movi	r5,16
81104a88:	1009883a 	mov	r4,r2
81104a8c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104a90:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104a94:	e0bffe17 	ldw	r2,-8(fp)
81104a98:	10bfffec 	andhi	r2,r2,65535
81104a9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104aa0:	e0bfff17 	ldw	r2,-4(fp)
81104aa4:	1080070b 	ldhu	r2,28(r2)
81104aa8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104aac:	e0fffe17 	ldw	r3,-8(fp)
81104ab0:	1884b03a 	or	r2,r3,r2
81104ab4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104ab8:	e0bfff17 	ldw	r2,-4(fp)
81104abc:	10800017 	ldw	r2,0(r2)
81104ac0:	e1bffe17 	ldw	r6,-8(fp)
81104ac4:	01400404 	movi	r5,16
81104ac8:	1009883a 	mov	r4,r2
81104acc:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104ad0:	00800044 	movi	r2,1
81104ad4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ad8:	e0bffd17 	ldw	r2,-12(fp)
}
81104adc:	e037883a 	mov	sp,fp
81104ae0:	dfc00117 	ldw	ra,4(sp)
81104ae4:	df000017 	ldw	fp,0(sp)
81104ae8:	dec00204 	addi	sp,sp,8
81104aec:	f800283a 	ret

81104af0 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104af0:	defffb04 	addi	sp,sp,-20
81104af4:	de00012e 	bgeu	sp,et,81104afc <bDpktGetPixelDelay+0xc>
81104af8:	003b68fa 	trap	3
81104afc:	dfc00415 	stw	ra,16(sp)
81104b00:	df000315 	stw	fp,12(sp)
81104b04:	df000304 	addi	fp,sp,12
81104b08:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104b0c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104b10:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104b14:	e0bfff17 	ldw	r2,-4(fp)
81104b18:	10002026 	beq	r2,zero,81104b9c <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b1c:	e0bfff17 	ldw	r2,-4(fp)
81104b20:	10800017 	ldw	r2,0(r2)
81104b24:	01400384 	movi	r5,14
81104b28:	1009883a 	mov	r4,r2
81104b2c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104b30:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104b34:	e0bffe17 	ldw	r2,-8(fp)
81104b38:	1007883a 	mov	r3,r2
81104b3c:	e0bfff17 	ldw	r2,-4(fp)
81104b40:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b44:	e0bfff17 	ldw	r2,-4(fp)
81104b48:	10800017 	ldw	r2,0(r2)
81104b4c:	014003c4 	movi	r5,15
81104b50:	1009883a 	mov	r4,r2
81104b54:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104b58:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104b5c:	e0bffe17 	ldw	r2,-8(fp)
81104b60:	1007883a 	mov	r3,r2
81104b64:	e0bfff17 	ldw	r2,-4(fp)
81104b68:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b6c:	e0bfff17 	ldw	r2,-4(fp)
81104b70:	10800017 	ldw	r2,0(r2)
81104b74:	01400404 	movi	r5,16
81104b78:	1009883a 	mov	r4,r2
81104b7c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104b80:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104b84:	e0bffe17 	ldw	r2,-8(fp)
81104b88:	1007883a 	mov	r3,r2
81104b8c:	e0bfff17 	ldw	r2,-4(fp)
81104b90:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104b94:	00800044 	movi	r2,1
81104b98:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b9c:	e0bffd17 	ldw	r2,-12(fp)
}
81104ba0:	e037883a 	mov	sp,fp
81104ba4:	dfc00117 	ldw	ra,4(sp)
81104ba8:	df000017 	ldw	fp,0(sp)
81104bac:	dec00204 	addi	sp,sp,8
81104bb0:	f800283a 	ret

81104bb4 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104bb4:	defffb04 	addi	sp,sp,-20
81104bb8:	de00012e 	bgeu	sp,et,81104bc0 <bDpktInitCh+0xc>
81104bbc:	003b68fa 	trap	3
81104bc0:	dfc00415 	stw	ra,16(sp)
81104bc4:	df000315 	stw	fp,12(sp)
81104bc8:	df000304 	addi	fp,sp,12
81104bcc:	e13ffe15 	stw	r4,-8(fp)
81104bd0:	2805883a 	mov	r2,r5
81104bd4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104bd8:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104bdc:	e0bffe17 	ldw	r2,-8(fp)
81104be0:	10004b26 	beq	r2,zero,81104d10 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104be4:	00800044 	movi	r2,1
81104be8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104bec:	e0bfff03 	ldbu	r2,-4(fp)
81104bf0:	10c00228 	cmpgeui	r3,r2,8
81104bf4:	1800361e 	bne	r3,zero,81104cd0 <bDpktInitCh+0x11c>
81104bf8:	100690ba 	slli	r3,r2,2
81104bfc:	00a04434 	movhi	r2,33040
81104c00:	10930404 	addi	r2,r2,19472
81104c04:	1885883a 	add	r2,r3,r2
81104c08:	10800017 	ldw	r2,0(r2)
81104c0c:	1000683a 	jmp	r2
81104c10:	81104c30 	cmpltui	r4,r16,16688
81104c14:	81104c44 	addi	r4,r16,16689
81104c18:	81104c58 	cmpnei	r4,r16,16689
81104c1c:	81104c6c 	andhi	r4,r16,16689
81104c20:	81104c80 	call	881104c8 <__reset+0x20f04c8>
81104c24:	81104c94 	ori	r4,r16,16690
81104c28:	81104ca8 	cmpgeui	r4,r16,16690
81104c2c:	81104cbc 	xorhi	r4,r16,16690
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104c30:	e0fffe17 	ldw	r3,-8(fp)
81104c34:	00a04834 	movhi	r2,33056
81104c38:	108b0004 	addi	r2,r2,11264
81104c3c:	18800015 	stw	r2,0(r3)
			break;
81104c40:	00002506 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104c44:	e0fffe17 	ldw	r3,-8(fp)
81104c48:	00a04834 	movhi	r2,33056
81104c4c:	108a0004 	addi	r2,r2,10240
81104c50:	18800015 	stw	r2,0(r3)
			break;
81104c54:	00002006 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104c58:	e0fffe17 	ldw	r3,-8(fp)
81104c5c:	00a04834 	movhi	r2,33056
81104c60:	10890004 	addi	r2,r2,9216
81104c64:	18800015 	stw	r2,0(r3)
			break;
81104c68:	00001b06 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104c6c:	e0fffe17 	ldw	r3,-8(fp)
81104c70:	00a04834 	movhi	r2,33056
81104c74:	10880004 	addi	r2,r2,8192
81104c78:	18800015 	stw	r2,0(r3)
			break;
81104c7c:	00001606 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104c80:	e0fffe17 	ldw	r3,-8(fp)
81104c84:	00a04834 	movhi	r2,33056
81104c88:	10870004 	addi	r2,r2,7168
81104c8c:	18800015 	stw	r2,0(r3)
			break;
81104c90:	00001106 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104c94:	e0fffe17 	ldw	r3,-8(fp)
81104c98:	00a04834 	movhi	r2,33056
81104c9c:	10860004 	addi	r2,r2,6144
81104ca0:	18800015 	stw	r2,0(r3)
			break;
81104ca4:	00000c06 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104ca8:	e0fffe17 	ldw	r3,-8(fp)
81104cac:	00a04834 	movhi	r2,33056
81104cb0:	10850004 	addi	r2,r2,5120
81104cb4:	18800015 	stw	r2,0(r3)
			break;
81104cb8:	00000706 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104cbc:	e0fffe17 	ldw	r3,-8(fp)
81104cc0:	00a04834 	movhi	r2,33056
81104cc4:	10840004 	addi	r2,r2,4096
81104cc8:	18800015 	stw	r2,0(r3)
			break;
81104ccc:	00000206 	br	81104cd8 <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104cd0:	e03ffd15 	stw	zero,-12(fp)
			break;
81104cd4:	0001883a 	nop
		}

		if (bStatus) {
81104cd8:	e0bffd17 	ldw	r2,-12(fp)
81104cdc:	10000c26 	beq	r2,zero,81104d10 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104ce0:	e13ffe17 	ldw	r4,-8(fp)
81104ce4:	11047b80 	call	811047b8 <bDpktGetPacketConfig>
81104ce8:	1000011e 	bne	r2,zero,81104cf0 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104cec:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104cf0:	e13ffe17 	ldw	r4,-8(fp)
81104cf4:	11048e40 	call	811048e4 <bDpktGetPacketHeader>
81104cf8:	1000011e 	bne	r2,zero,81104d00 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104cfc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104d00:	e13ffe17 	ldw	r4,-8(fp)
81104d04:	1104af00 	call	81104af0 <bDpktGetPixelDelay>
81104d08:	1000011e 	bne	r2,zero,81104d10 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104d0c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104d10:	e0bffd17 	ldw	r2,-12(fp)
}
81104d14:	e037883a 	mov	sp,fp
81104d18:	dfc00117 	ldw	ra,4(sp)
81104d1c:	df000017 	ldw	fp,0(sp)
81104d20:	dec00204 	addi	sp,sp,8
81104d24:	f800283a 	ret

81104d28 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104d28:	defffc04 	addi	sp,sp,-16
81104d2c:	de00012e 	bgeu	sp,et,81104d34 <vDpktWriteReg+0xc>
81104d30:	003b68fa 	trap	3
81104d34:	df000315 	stw	fp,12(sp)
81104d38:	df000304 	addi	fp,sp,12
81104d3c:	e13ffd15 	stw	r4,-12(fp)
81104d40:	e17ffe15 	stw	r5,-8(fp)
81104d44:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104d48:	e0bffe17 	ldw	r2,-8(fp)
81104d4c:	1085883a 	add	r2,r2,r2
81104d50:	1085883a 	add	r2,r2,r2
81104d54:	1007883a 	mov	r3,r2
81104d58:	e0bffd17 	ldw	r2,-12(fp)
81104d5c:	10c5883a 	add	r2,r2,r3
81104d60:	e0ffff17 	ldw	r3,-4(fp)
81104d64:	10c00015 	stw	r3,0(r2)
}
81104d68:	0001883a 	nop
81104d6c:	e037883a 	mov	sp,fp
81104d70:	df000017 	ldw	fp,0(sp)
81104d74:	dec00104 	addi	sp,sp,4
81104d78:	f800283a 	ret

81104d7c <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81104d7c:	defffc04 	addi	sp,sp,-16
81104d80:	de00012e 	bgeu	sp,et,81104d88 <uliDpktReadReg+0xc>
81104d84:	003b68fa 	trap	3
81104d88:	df000315 	stw	fp,12(sp)
81104d8c:	df000304 	addi	fp,sp,12
81104d90:	e13ffe15 	stw	r4,-8(fp)
81104d94:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104d98:	e0bfff17 	ldw	r2,-4(fp)
81104d9c:	1085883a 	add	r2,r2,r2
81104da0:	1085883a 	add	r2,r2,r2
81104da4:	1007883a 	mov	r3,r2
81104da8:	e0bffe17 	ldw	r2,-8(fp)
81104dac:	10c5883a 	add	r2,r2,r3
81104db0:	10800017 	ldw	r2,0(r2)
81104db4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104db8:	e0bffd17 	ldw	r2,-12(fp)
}
81104dbc:	e037883a 	mov	sp,fp
81104dc0:	df000017 	ldw	fp,0(sp)
81104dc4:	dec00104 	addi	sp,sp,4
81104dc8:	f800283a 	ret

81104dcc <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81104dcc:	defffc04 	addi	sp,sp,-16
81104dd0:	de00012e 	bgeu	sp,et,81104dd8 <vFeebCh1HandleIrq+0xc>
81104dd4:	003b68fa 	trap	3
81104dd8:	dfc00315 	stw	ra,12(sp)
81104ddc:	df000215 	stw	fp,8(sp)
81104de0:	df000204 	addi	fp,sp,8
81104de4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104de8:	e0bfff17 	ldw	r2,-4(fp)
81104dec:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh1IrqFlagClrBufferEmpty();
81104df0:	1104fcc0 	call	81104fcc <vFeebCh1IrqFlagClrBufferEmpty>
}
81104df4:	0001883a 	nop
81104df8:	e037883a 	mov	sp,fp
81104dfc:	dfc00117 	ldw	ra,4(sp)
81104e00:	df000017 	ldw	fp,0(sp)
81104e04:	dec00204 	addi	sp,sp,8
81104e08:	f800283a 	ret

81104e0c <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
81104e0c:	defffc04 	addi	sp,sp,-16
81104e10:	de00012e 	bgeu	sp,et,81104e18 <vFeebCh2HandleIrq+0xc>
81104e14:	003b68fa 	trap	3
81104e18:	dfc00315 	stw	ra,12(sp)
81104e1c:	df000215 	stw	fp,8(sp)
81104e20:	df000204 	addi	fp,sp,8
81104e24:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104e28:	e0bfff17 	ldw	r2,-4(fp)
81104e2c:	e0bffe15 	stw	r2,-8(fp)

	vFeebCh2IrqFlagClrBufferEmpty();
81104e30:	11050100 	call	81105010 <vFeebCh2IrqFlagClrBufferEmpty>
}
81104e34:	0001883a 	nop
81104e38:	e037883a 	mov	sp,fp
81104e3c:	dfc00117 	ldw	ra,4(sp)
81104e40:	df000017 	ldw	fp,0(sp)
81104e44:	dec00204 	addi	sp,sp,8
81104e48:	f800283a 	ret

81104e4c <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81104e4c:	defffc04 	addi	sp,sp,-16
81104e50:	de00012e 	bgeu	sp,et,81104e58 <vFeebCh3HandleIrq+0xc>
81104e54:	003b68fa 	trap	3
81104e58:	dfc00315 	stw	ra,12(sp)
81104e5c:	df000215 	stw	fp,8(sp)
81104e60:	df000204 	addi	fp,sp,8
81104e64:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104e68:	e0bfff17 	ldw	r2,-4(fp)
81104e6c:	e0bffe15 	stw	r2,-8(fp)

	vFeebCh3IrqFlagClrBufferEmpty();
81104e70:	11050540 	call	81105054 <vFeebCh3IrqFlagClrBufferEmpty>
}
81104e74:	0001883a 	nop
81104e78:	e037883a 	mov	sp,fp
81104e7c:	dfc00117 	ldw	ra,4(sp)
81104e80:	df000017 	ldw	fp,0(sp)
81104e84:	dec00204 	addi	sp,sp,8
81104e88:	f800283a 	ret

81104e8c <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81104e8c:	defffc04 	addi	sp,sp,-16
81104e90:	de00012e 	bgeu	sp,et,81104e98 <vFeebCh4HandleIrq+0xc>
81104e94:	003b68fa 	trap	3
81104e98:	dfc00315 	stw	ra,12(sp)
81104e9c:	df000215 	stw	fp,8(sp)
81104ea0:	df000204 	addi	fp,sp,8
81104ea4:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104ea8:	e0bfff17 	ldw	r2,-4(fp)
81104eac:	e0bffe15 	stw	r2,-8(fp)

	vFeebCh4IrqFlagClrBufferEmpty();
81104eb0:	11050980 	call	81105098 <vFeebCh4IrqFlagClrBufferEmpty>
}
81104eb4:	0001883a 	nop
81104eb8:	e037883a 	mov	sp,fp
81104ebc:	dfc00117 	ldw	ra,4(sp)
81104ec0:	df000017 	ldw	fp,0(sp)
81104ec4:	dec00204 	addi	sp,sp,8
81104ec8:	f800283a 	ret

81104ecc <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81104ecc:	defffc04 	addi	sp,sp,-16
81104ed0:	de00012e 	bgeu	sp,et,81104ed8 <vFeebCh5HandleIrq+0xc>
81104ed4:	003b68fa 	trap	3
81104ed8:	dfc00315 	stw	ra,12(sp)
81104edc:	df000215 	stw	fp,8(sp)
81104ee0:	df000204 	addi	fp,sp,8
81104ee4:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104ee8:	e0bfff17 	ldw	r2,-4(fp)
81104eec:	e0bffe15 	stw	r2,-8(fp)

	vFeebCh5IrqFlagClrBufferEmpty();
81104ef0:	11050dc0 	call	811050dc <vFeebCh5IrqFlagClrBufferEmpty>
}
81104ef4:	0001883a 	nop
81104ef8:	e037883a 	mov	sp,fp
81104efc:	dfc00117 	ldw	ra,4(sp)
81104f00:	df000017 	ldw	fp,0(sp)
81104f04:	dec00204 	addi	sp,sp,8
81104f08:	f800283a 	ret

81104f0c <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
81104f0c:	defffc04 	addi	sp,sp,-16
81104f10:	de00012e 	bgeu	sp,et,81104f18 <vFeebCh6HandleIrq+0xc>
81104f14:	003b68fa 	trap	3
81104f18:	dfc00315 	stw	ra,12(sp)
81104f1c:	df000215 	stw	fp,8(sp)
81104f20:	df000204 	addi	fp,sp,8
81104f24:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104f28:	e0bfff17 	ldw	r2,-4(fp)
81104f2c:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh6IrqFlagClrBufferEmpty();
81104f30:	11051200 	call	81105120 <vFeebCh6IrqFlagClrBufferEmpty>
}
81104f34:	0001883a 	nop
81104f38:	e037883a 	mov	sp,fp
81104f3c:	dfc00117 	ldw	ra,4(sp)
81104f40:	df000017 	ldw	fp,0(sp)
81104f44:	dec00204 	addi	sp,sp,8
81104f48:	f800283a 	ret

81104f4c <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
81104f4c:	defffc04 	addi	sp,sp,-16
81104f50:	de00012e 	bgeu	sp,et,81104f58 <vFeebCh7HandleIrq+0xc>
81104f54:	003b68fa 	trap	3
81104f58:	dfc00315 	stw	ra,12(sp)
81104f5c:	df000215 	stw	fp,8(sp)
81104f60:	df000204 	addi	fp,sp,8
81104f64:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104f68:	e0bfff17 	ldw	r2,-4(fp)
81104f6c:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
81104f70:	11051640 	call	81105164 <vFeebCh7IrqFlagClrBufferEmpty>
}
81104f74:	0001883a 	nop
81104f78:	e037883a 	mov	sp,fp
81104f7c:	dfc00117 	ldw	ra,4(sp)
81104f80:	df000017 	ldw	fp,0(sp)
81104f84:	dec00204 	addi	sp,sp,8
81104f88:	f800283a 	ret

81104f8c <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81104f8c:	defffc04 	addi	sp,sp,-16
81104f90:	de00012e 	bgeu	sp,et,81104f98 <vFeebCh8HandleIrq+0xc>
81104f94:	003b68fa 	trap	3
81104f98:	dfc00315 	stw	ra,12(sp)
81104f9c:	df000215 	stw	fp,8(sp)
81104fa0:	df000204 	addi	fp,sp,8
81104fa4:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104fa8:	e0bfff17 	ldw	r2,-4(fp)
81104fac:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
81104fb0:	11051a80 	call	811051a8 <vFeebCh8IrqFlagClrBufferEmpty>
}
81104fb4:	0001883a 	nop
81104fb8:	e037883a 	mov	sp,fp
81104fbc:	dfc00117 	ldw	ra,4(sp)
81104fc0:	df000017 	ldw	fp,0(sp)
81104fc4:	dec00204 	addi	sp,sp,8
81104fc8:	f800283a 	ret

81104fcc <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81104fcc:	defffe04 	addi	sp,sp,-8
81104fd0:	de00012e 	bgeu	sp,et,81104fd8 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81104fd4:	003b68fa 	trap	3
81104fd8:	dfc00115 	stw	ra,4(sp)
81104fdc:	df000015 	stw	fp,0(sp)
81104fe0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81104fe4:	01804004 	movi	r6,256
81104fe8:	014004c4 	movi	r5,19
81104fec:	01204834 	movhi	r4,33056
81104ff0:	210b0004 	addi	r4,r4,11264
81104ff4:	1105d280 	call	81105d28 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81104ff8:	0001883a 	nop
81104ffc:	e037883a 	mov	sp,fp
81105000:	dfc00117 	ldw	ra,4(sp)
81105004:	df000017 	ldw	fp,0(sp)
81105008:	dec00204 	addi	sp,sp,8
8110500c:	f800283a 	ret

81105010 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
81105010:	defffe04 	addi	sp,sp,-8
81105014:	de00012e 	bgeu	sp,et,8110501c <vFeebCh2IrqFlagClrBufferEmpty+0xc>
81105018:	003b68fa 	trap	3
8110501c:	dfc00115 	stw	ra,4(sp)
81105020:	df000015 	stw	fp,0(sp)
81105024:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105028:	01804004 	movi	r6,256
8110502c:	014004c4 	movi	r5,19
81105030:	01204834 	movhi	r4,33056
81105034:	210a0004 	addi	r4,r4,10240
81105038:	1105d280 	call	81105d28 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110503c:	0001883a 	nop
81105040:	e037883a 	mov	sp,fp
81105044:	dfc00117 	ldw	ra,4(sp)
81105048:	df000017 	ldw	fp,0(sp)
8110504c:	dec00204 	addi	sp,sp,8
81105050:	f800283a 	ret

81105054 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
81105054:	defffe04 	addi	sp,sp,-8
81105058:	de00012e 	bgeu	sp,et,81105060 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
8110505c:	003b68fa 	trap	3
81105060:	dfc00115 	stw	ra,4(sp)
81105064:	df000015 	stw	fp,0(sp)
81105068:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110506c:	01804004 	movi	r6,256
81105070:	014004c4 	movi	r5,19
81105074:	01204834 	movhi	r4,33056
81105078:	21090004 	addi	r4,r4,9216
8110507c:	1105d280 	call	81105d28 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105080:	0001883a 	nop
81105084:	e037883a 	mov	sp,fp
81105088:	dfc00117 	ldw	ra,4(sp)
8110508c:	df000017 	ldw	fp,0(sp)
81105090:	dec00204 	addi	sp,sp,8
81105094:	f800283a 	ret

81105098 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81105098:	defffe04 	addi	sp,sp,-8
8110509c:	de00012e 	bgeu	sp,et,811050a4 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
811050a0:	003b68fa 	trap	3
811050a4:	dfc00115 	stw	ra,4(sp)
811050a8:	df000015 	stw	fp,0(sp)
811050ac:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811050b0:	01804004 	movi	r6,256
811050b4:	014004c4 	movi	r5,19
811050b8:	01204834 	movhi	r4,33056
811050bc:	21080004 	addi	r4,r4,8192
811050c0:	1105d280 	call	81105d28 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811050c4:	0001883a 	nop
811050c8:	e037883a 	mov	sp,fp
811050cc:	dfc00117 	ldw	ra,4(sp)
811050d0:	df000017 	ldw	fp,0(sp)
811050d4:	dec00204 	addi	sp,sp,8
811050d8:	f800283a 	ret

811050dc <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
811050dc:	defffe04 	addi	sp,sp,-8
811050e0:	de00012e 	bgeu	sp,et,811050e8 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
811050e4:	003b68fa 	trap	3
811050e8:	dfc00115 	stw	ra,4(sp)
811050ec:	df000015 	stw	fp,0(sp)
811050f0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811050f4:	01804004 	movi	r6,256
811050f8:	014004c4 	movi	r5,19
811050fc:	01204834 	movhi	r4,33056
81105100:	21070004 	addi	r4,r4,7168
81105104:	1105d280 	call	81105d28 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105108:	0001883a 	nop
8110510c:	e037883a 	mov	sp,fp
81105110:	dfc00117 	ldw	ra,4(sp)
81105114:	df000017 	ldw	fp,0(sp)
81105118:	dec00204 	addi	sp,sp,8
8110511c:	f800283a 	ret

81105120 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
81105120:	defffe04 	addi	sp,sp,-8
81105124:	de00012e 	bgeu	sp,et,8110512c <vFeebCh6IrqFlagClrBufferEmpty+0xc>
81105128:	003b68fa 	trap	3
8110512c:	dfc00115 	stw	ra,4(sp)
81105130:	df000015 	stw	fp,0(sp)
81105134:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105138:	01804004 	movi	r6,256
8110513c:	014004c4 	movi	r5,19
81105140:	01204834 	movhi	r4,33056
81105144:	21060004 	addi	r4,r4,6144
81105148:	1105d280 	call	81105d28 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110514c:	0001883a 	nop
81105150:	e037883a 	mov	sp,fp
81105154:	dfc00117 	ldw	ra,4(sp)
81105158:	df000017 	ldw	fp,0(sp)
8110515c:	dec00204 	addi	sp,sp,8
81105160:	f800283a 	ret

81105164 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
81105164:	defffe04 	addi	sp,sp,-8
81105168:	de00012e 	bgeu	sp,et,81105170 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
8110516c:	003b68fa 	trap	3
81105170:	dfc00115 	stw	ra,4(sp)
81105174:	df000015 	stw	fp,0(sp)
81105178:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110517c:	01804004 	movi	r6,256
81105180:	014004c4 	movi	r5,19
81105184:	01204834 	movhi	r4,33056
81105188:	21050004 	addi	r4,r4,5120
8110518c:	1105d280 	call	81105d28 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105190:	0001883a 	nop
81105194:	e037883a 	mov	sp,fp
81105198:	dfc00117 	ldw	ra,4(sp)
8110519c:	df000017 	ldw	fp,0(sp)
811051a0:	dec00204 	addi	sp,sp,8
811051a4:	f800283a 	ret

811051a8 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
811051a8:	defffe04 	addi	sp,sp,-8
811051ac:	de00012e 	bgeu	sp,et,811051b4 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
811051b0:	003b68fa 	trap	3
811051b4:	dfc00115 	stw	ra,4(sp)
811051b8:	df000015 	stw	fp,0(sp)
811051bc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811051c0:	01804004 	movi	r6,256
811051c4:	014004c4 	movi	r5,19
811051c8:	01204834 	movhi	r4,33056
811051cc:	21040004 	addi	r4,r4,4096
811051d0:	1105d280 	call	81105d28 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811051d4:	0001883a 	nop
811051d8:	e037883a 	mov	sp,fp
811051dc:	dfc00117 	ldw	ra,4(sp)
811051e0:	df000017 	ldw	fp,0(sp)
811051e4:	dec00204 	addi	sp,sp,8
811051e8:	f800283a 	ret

811051ec <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
811051ec:	defffd04 	addi	sp,sp,-12
811051f0:	de00012e 	bgeu	sp,et,811051f8 <bFeebCh1IrqFlagBufferEmpty+0xc>
811051f4:	003b68fa 	trap	3
811051f8:	dfc00215 	stw	ra,8(sp)
811051fc:	df000115 	stw	fp,4(sp)
81105200:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105204:	01400484 	movi	r5,18
81105208:	01204834 	movhi	r4,33056
8110520c:	210b0004 	addi	r4,r4,11264
81105210:	1105d7c0 	call	81105d7c <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105214:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105218:	10000326 	beq	r2,zero,81105228 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110521c:	00800044 	movi	r2,1
81105220:	e0bfff15 	stw	r2,-4(fp)
81105224:	00000106 	br	8110522c <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105228:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110522c:	e0bfff17 	ldw	r2,-4(fp)
}
81105230:	e037883a 	mov	sp,fp
81105234:	dfc00117 	ldw	ra,4(sp)
81105238:	df000017 	ldw	fp,0(sp)
8110523c:	dec00204 	addi	sp,sp,8
81105240:	f800283a 	ret

81105244 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
81105244:	defffd04 	addi	sp,sp,-12
81105248:	de00012e 	bgeu	sp,et,81105250 <bFeebCh2IrqFlagBufferEmpty+0xc>
8110524c:	003b68fa 	trap	3
81105250:	dfc00215 	stw	ra,8(sp)
81105254:	df000115 	stw	fp,4(sp)
81105258:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110525c:	01400484 	movi	r5,18
81105260:	01204834 	movhi	r4,33056
81105264:	210a0004 	addi	r4,r4,10240
81105268:	1105d7c0 	call	81105d7c <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110526c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105270:	10000326 	beq	r2,zero,81105280 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105274:	00800044 	movi	r2,1
81105278:	e0bfff15 	stw	r2,-4(fp)
8110527c:	00000106 	br	81105284 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105280:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105284:	e0bfff17 	ldw	r2,-4(fp)
}
81105288:	e037883a 	mov	sp,fp
8110528c:	dfc00117 	ldw	ra,4(sp)
81105290:	df000017 	ldw	fp,0(sp)
81105294:	dec00204 	addi	sp,sp,8
81105298:	f800283a 	ret

8110529c <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
8110529c:	defffd04 	addi	sp,sp,-12
811052a0:	de00012e 	bgeu	sp,et,811052a8 <bFeebCh3IrqFlagBufferEmpty+0xc>
811052a4:	003b68fa 	trap	3
811052a8:	dfc00215 	stw	ra,8(sp)
811052ac:	df000115 	stw	fp,4(sp)
811052b0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811052b4:	01400484 	movi	r5,18
811052b8:	01204834 	movhi	r4,33056
811052bc:	21090004 	addi	r4,r4,9216
811052c0:	1105d7c0 	call	81105d7c <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811052c4:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811052c8:	10000326 	beq	r2,zero,811052d8 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811052cc:	00800044 	movi	r2,1
811052d0:	e0bfff15 	stw	r2,-4(fp)
811052d4:	00000106 	br	811052dc <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811052d8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811052dc:	e0bfff17 	ldw	r2,-4(fp)
}
811052e0:	e037883a 	mov	sp,fp
811052e4:	dfc00117 	ldw	ra,4(sp)
811052e8:	df000017 	ldw	fp,0(sp)
811052ec:	dec00204 	addi	sp,sp,8
811052f0:	f800283a 	ret

811052f4 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
811052f4:	defffd04 	addi	sp,sp,-12
811052f8:	de00012e 	bgeu	sp,et,81105300 <bFeebCh4IrqFlagBufferEmpty+0xc>
811052fc:	003b68fa 	trap	3
81105300:	dfc00215 	stw	ra,8(sp)
81105304:	df000115 	stw	fp,4(sp)
81105308:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110530c:	01400484 	movi	r5,18
81105310:	01204834 	movhi	r4,33056
81105314:	21080004 	addi	r4,r4,8192
81105318:	1105d7c0 	call	81105d7c <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110531c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105320:	10000326 	beq	r2,zero,81105330 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105324:	00800044 	movi	r2,1
81105328:	e0bfff15 	stw	r2,-4(fp)
8110532c:	00000106 	br	81105334 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105330:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105334:	e0bfff17 	ldw	r2,-4(fp)
}
81105338:	e037883a 	mov	sp,fp
8110533c:	dfc00117 	ldw	ra,4(sp)
81105340:	df000017 	ldw	fp,0(sp)
81105344:	dec00204 	addi	sp,sp,8
81105348:	f800283a 	ret

8110534c <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
8110534c:	defffd04 	addi	sp,sp,-12
81105350:	de00012e 	bgeu	sp,et,81105358 <bFeebCh5IrqFlagBufferEmpty+0xc>
81105354:	003b68fa 	trap	3
81105358:	dfc00215 	stw	ra,8(sp)
8110535c:	df000115 	stw	fp,4(sp)
81105360:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105364:	01400484 	movi	r5,18
81105368:	01204834 	movhi	r4,33056
8110536c:	21070004 	addi	r4,r4,7168
81105370:	1105d7c0 	call	81105d7c <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105374:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105378:	10000326 	beq	r2,zero,81105388 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110537c:	00800044 	movi	r2,1
81105380:	e0bfff15 	stw	r2,-4(fp)
81105384:	00000106 	br	8110538c <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105388:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110538c:	e0bfff17 	ldw	r2,-4(fp)
}
81105390:	e037883a 	mov	sp,fp
81105394:	dfc00117 	ldw	ra,4(sp)
81105398:	df000017 	ldw	fp,0(sp)
8110539c:	dec00204 	addi	sp,sp,8
811053a0:	f800283a 	ret

811053a4 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
811053a4:	defffd04 	addi	sp,sp,-12
811053a8:	de00012e 	bgeu	sp,et,811053b0 <bFeebCh6IrqFlagBufferEmpty+0xc>
811053ac:	003b68fa 	trap	3
811053b0:	dfc00215 	stw	ra,8(sp)
811053b4:	df000115 	stw	fp,4(sp)
811053b8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811053bc:	01400484 	movi	r5,18
811053c0:	01204834 	movhi	r4,33056
811053c4:	21060004 	addi	r4,r4,6144
811053c8:	1105d7c0 	call	81105d7c <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811053cc:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811053d0:	10000326 	beq	r2,zero,811053e0 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811053d4:	00800044 	movi	r2,1
811053d8:	e0bfff15 	stw	r2,-4(fp)
811053dc:	00000106 	br	811053e4 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811053e0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811053e4:	e0bfff17 	ldw	r2,-4(fp)
}
811053e8:	e037883a 	mov	sp,fp
811053ec:	dfc00117 	ldw	ra,4(sp)
811053f0:	df000017 	ldw	fp,0(sp)
811053f4:	dec00204 	addi	sp,sp,8
811053f8:	f800283a 	ret

811053fc <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
811053fc:	defffd04 	addi	sp,sp,-12
81105400:	de00012e 	bgeu	sp,et,81105408 <bFeebCh7IrqFlagBufferEmpty+0xc>
81105404:	003b68fa 	trap	3
81105408:	dfc00215 	stw	ra,8(sp)
8110540c:	df000115 	stw	fp,4(sp)
81105410:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105414:	01400484 	movi	r5,18
81105418:	01204834 	movhi	r4,33056
8110541c:	21050004 	addi	r4,r4,5120
81105420:	1105d7c0 	call	81105d7c <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105424:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105428:	10000326 	beq	r2,zero,81105438 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110542c:	00800044 	movi	r2,1
81105430:	e0bfff15 	stw	r2,-4(fp)
81105434:	00000106 	br	8110543c <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105438:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110543c:	e0bfff17 	ldw	r2,-4(fp)
}
81105440:	e037883a 	mov	sp,fp
81105444:	dfc00117 	ldw	ra,4(sp)
81105448:	df000017 	ldw	fp,0(sp)
8110544c:	dec00204 	addi	sp,sp,8
81105450:	f800283a 	ret

81105454 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81105454:	defffd04 	addi	sp,sp,-12
81105458:	de00012e 	bgeu	sp,et,81105460 <bFeebCh8IrqFlagBufferEmpty+0xc>
8110545c:	003b68fa 	trap	3
81105460:	dfc00215 	stw	ra,8(sp)
81105464:	df000115 	stw	fp,4(sp)
81105468:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110546c:	01400484 	movi	r5,18
81105470:	01204834 	movhi	r4,33056
81105474:	21040004 	addi	r4,r4,4096
81105478:	1105d7c0 	call	81105d7c <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110547c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105480:	10000326 	beq	r2,zero,81105490 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105484:	00800044 	movi	r2,1
81105488:	e0bfff15 	stw	r2,-4(fp)
8110548c:	00000106 	br	81105494 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105490:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105494:	e0bfff17 	ldw	r2,-4(fp)
}
81105498:	e037883a 	mov	sp,fp
8110549c:	dfc00117 	ldw	ra,4(sp)
811054a0:	df000017 	ldw	fp,0(sp)
811054a4:	dec00204 	addi	sp,sp,8
811054a8:	f800283a 	ret

811054ac <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
811054ac:	defffc04 	addi	sp,sp,-16
811054b0:	de00012e 	bgeu	sp,et,811054b8 <vFeebInitIrq+0xc>
811054b4:	003b68fa 	trap	3
811054b8:	dfc00315 	stw	ra,12(sp)
811054bc:	df000215 	stw	fp,8(sp)
811054c0:	df000204 	addi	fp,sp,8
811054c4:	2005883a 	mov	r2,r4
811054c8:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
811054cc:	e0bfff03 	ldbu	r2,-4(fp)
811054d0:	10c00228 	cmpgeui	r3,r2,8
811054d4:	18004e1e 	bne	r3,zero,81105610 <vFeebInitIrq+0x164>
811054d8:	100690ba 	slli	r3,r2,2
811054dc:	00a04434 	movhi	r2,33040
811054e0:	10953c04 	addi	r2,r2,21744
811054e4:	1885883a 	add	r2,r3,r2
811054e8:	10800017 	ldw	r2,0(r2)
811054ec:	1000683a 	jmp	r2
811054f0:	81105510 	cmplti	r4,r16,16724
811054f4:	81105530 	cmpltui	r4,r16,16724
811054f8:	81105550 	cmplti	r4,r16,16725
811054fc:	81105570 	cmpltui	r4,r16,16725
81105500:	81105590 	cmplti	r4,r16,16726
81105504:	811055b0 	cmpltui	r4,r16,16726
81105508:	811055d0 	cmplti	r4,r16,16727
8110550c:	811055f0 	cmpltui	r4,r16,16727
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81105510:	d0a03e04 	addi	r2,gp,-32520
81105514:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81105518:	01a04434 	movhi	r6,33040
8110551c:	31937304 	addi	r6,r6,19916
81105520:	e17ffe17 	ldw	r5,-8(fp)
81105524:	01000584 	movi	r4,22
81105528:	1130f980 	call	81130f98 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
8110552c:	00003806 	br	81105610 <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81105530:	d0a03f04 	addi	r2,gp,-32516
81105534:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
81105538:	01a04434 	movhi	r6,33040
8110553c:	31938304 	addi	r6,r6,19980
81105540:	e17ffe17 	ldw	r5,-8(fp)
81105544:	01000504 	movi	r4,20
81105548:	1130f980 	call	81130f98 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
8110554c:	00003006 	br	81105610 <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81105550:	d0a04004 	addi	r2,gp,-32512
81105554:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
81105558:	01a04434 	movhi	r6,33040
8110555c:	31939304 	addi	r6,r6,20044
81105560:	e17ffe17 	ldw	r5,-8(fp)
81105564:	01000484 	movi	r4,18
81105568:	1130f980 	call	81130f98 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
8110556c:	00002806 	br	81105610 <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81105570:	d0a04104 	addi	r2,gp,-32508
81105574:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
81105578:	01a04434 	movhi	r6,33040
8110557c:	3193a304 	addi	r6,r6,20108
81105580:	e17ffe17 	ldw	r5,-8(fp)
81105584:	01000404 	movi	r4,16
81105588:	1130f980 	call	81130f98 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
8110558c:	00002006 	br	81105610 <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81105590:	d0a04204 	addi	r2,gp,-32504
81105594:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81105598:	01a04434 	movhi	r6,33040
8110559c:	3193b304 	addi	r6,r6,20172
811055a0:	e17ffe17 	ldw	r5,-8(fp)
811055a4:	01000204 	movi	r4,8
811055a8:	1130f980 	call	81130f98 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
811055ac:	00001806 	br	81105610 <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
811055b0:	d0a04304 	addi	r2,gp,-32500
811055b4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
811055b8:	01a04434 	movhi	r6,33040
811055bc:	3193c304 	addi	r6,r6,20236
811055c0:	e17ffe17 	ldw	r5,-8(fp)
811055c4:	01000184 	movi	r4,6
811055c8:	1130f980 	call	81130f98 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
811055cc:	00001006 	br	81105610 <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
811055d0:	d0a04404 	addi	r2,gp,-32496
811055d4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
811055d8:	01a04434 	movhi	r6,33040
811055dc:	3193d304 	addi	r6,r6,20300
811055e0:	e17ffe17 	ldw	r5,-8(fp)
811055e4:	01000144 	movi	r4,5
811055e8:	1130f980 	call	81130f98 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
811055ec:	00000806 	br	81105610 <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
811055f0:	d0a04504 	addi	r2,gp,-32492
811055f4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
811055f8:	01a04434 	movhi	r6,33040
811055fc:	3193e304 	addi	r6,r6,20364
81105600:	e17ffe17 	ldw	r5,-8(fp)
81105604:	01000084 	movi	r4,2
81105608:	1130f980 	call	81130f98 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
8110560c:	0001883a 	nop
	}
}
81105610:	0001883a 	nop
81105614:	e037883a 	mov	sp,fp
81105618:	dfc00117 	ldw	ra,4(sp)
8110561c:	df000017 	ldw	fp,0(sp)
81105620:	dec00204 	addi	sp,sp,8
81105624:	f800283a 	ret

81105628 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81105628:	defffb04 	addi	sp,sp,-20
8110562c:	de00012e 	bgeu	sp,et,81105634 <bFeebSetIrqControl+0xc>
81105630:	003b68fa 	trap	3
81105634:	dfc00415 	stw	ra,16(sp)
81105638:	df000315 	stw	fp,12(sp)
8110563c:	df000304 	addi	fp,sp,12
81105640:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105644:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105648:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110564c:	e0bfff17 	ldw	r2,-4(fp)
81105650:	10002426 	beq	r2,zero,811056e4 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105654:	e0bfff17 	ldw	r2,-4(fp)
81105658:	10800017 	ldw	r2,0(r2)
8110565c:	01400444 	movi	r5,17
81105660:	1009883a 	mov	r4,r2
81105664:	1105d7c0 	call	81105d7c <uliFeebReadReg>
81105668:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
8110566c:	e0bfff17 	ldw	r2,-4(fp)
81105670:	10800217 	ldw	r2,8(r2)
81105674:	10000426 	beq	r2,zero,81105688 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
81105678:	e0bffe17 	ldw	r2,-8(fp)
8110567c:	10808014 	ori	r2,r2,512
81105680:	e0bffe15 	stw	r2,-8(fp)
81105684:	00000406 	br	81105698 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
81105688:	e0fffe17 	ldw	r3,-8(fp)
8110568c:	00bf7fc4 	movi	r2,-513
81105690:	1884703a 	and	r2,r3,r2
81105694:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81105698:	e0bfff17 	ldw	r2,-4(fp)
8110569c:	10800317 	ldw	r2,12(r2)
811056a0:	10000426 	beq	r2,zero,811056b4 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
811056a4:	e0bffe17 	ldw	r2,-8(fp)
811056a8:	10804014 	ori	r2,r2,256
811056ac:	e0bffe15 	stw	r2,-8(fp)
811056b0:	00000406 	br	811056c4 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
811056b4:	e0fffe17 	ldw	r3,-8(fp)
811056b8:	00bfbfc4 	movi	r2,-257
811056bc:	1884703a 	and	r2,r3,r2
811056c0:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
811056c4:	e0bfff17 	ldw	r2,-4(fp)
811056c8:	10800017 	ldw	r2,0(r2)
811056cc:	e1bffe17 	ldw	r6,-8(fp)
811056d0:	01400444 	movi	r5,17
811056d4:	1009883a 	mov	r4,r2
811056d8:	1105d280 	call	81105d28 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
811056dc:	00800044 	movi	r2,1
811056e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811056e4:	e0bffd17 	ldw	r2,-12(fp)
}
811056e8:	e037883a 	mov	sp,fp
811056ec:	dfc00117 	ldw	ra,4(sp)
811056f0:	df000017 	ldw	fp,0(sp)
811056f4:	dec00204 	addi	sp,sp,8
811056f8:	f800283a 	ret

811056fc <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
811056fc:	defffb04 	addi	sp,sp,-20
81105700:	de00012e 	bgeu	sp,et,81105708 <bFeebGetIrqControl+0xc>
81105704:	003b68fa 	trap	3
81105708:	dfc00415 	stw	ra,16(sp)
8110570c:	df000315 	stw	fp,12(sp)
81105710:	df000304 	addi	fp,sp,12
81105714:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105718:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110571c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105720:	e0bfff17 	ldw	r2,-4(fp)
81105724:	10001a26 	beq	r2,zero,81105790 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105728:	e0bfff17 	ldw	r2,-4(fp)
8110572c:	10800017 	ldw	r2,0(r2)
81105730:	01400444 	movi	r5,17
81105734:	1009883a 	mov	r4,r2
81105738:	1105d7c0 	call	81105d7c <uliFeebReadReg>
8110573c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
81105740:	e0bffe17 	ldw	r2,-8(fp)
81105744:	1080800c 	andi	r2,r2,512
81105748:	10000426 	beq	r2,zero,8110575c <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
8110574c:	e0bfff17 	ldw	r2,-4(fp)
81105750:	00c00044 	movi	r3,1
81105754:	10c00215 	stw	r3,8(r2)
81105758:	00000206 	br	81105764 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
8110575c:	e0bfff17 	ldw	r2,-4(fp)
81105760:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81105764:	e0bffe17 	ldw	r2,-8(fp)
81105768:	1080400c 	andi	r2,r2,256
8110576c:	10000426 	beq	r2,zero,81105780 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81105770:	e0bfff17 	ldw	r2,-4(fp)
81105774:	00c00044 	movi	r3,1
81105778:	10c00315 	stw	r3,12(r2)
8110577c:	00000206 	br	81105788 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81105780:	e0bfff17 	ldw	r2,-4(fp)
81105784:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81105788:	00800044 	movi	r2,1
8110578c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105790:	e0bffd17 	ldw	r2,-12(fp)
}
81105794:	e037883a 	mov	sp,fp
81105798:	dfc00117 	ldw	ra,4(sp)
8110579c:	df000017 	ldw	fp,0(sp)
811057a0:	dec00204 	addi	sp,sp,8
811057a4:	f800283a 	ret

811057a8 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
811057a8:	defffb04 	addi	sp,sp,-20
811057ac:	de00012e 	bgeu	sp,et,811057b4 <bFeebGetIrqFlags+0xc>
811057b0:	003b68fa 	trap	3
811057b4:	dfc00415 	stw	ra,16(sp)
811057b8:	df000315 	stw	fp,12(sp)
811057bc:	df000304 	addi	fp,sp,12
811057c0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811057c4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811057c8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811057cc:	e0bfff17 	ldw	r2,-4(fp)
811057d0:	10001126 	beq	r2,zero,81105818 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811057d4:	e0bfff17 	ldw	r2,-4(fp)
811057d8:	10800017 	ldw	r2,0(r2)
811057dc:	01400484 	movi	r5,18
811057e0:	1009883a 	mov	r4,r2
811057e4:	1105d7c0 	call	81105d7c <uliFeebReadReg>
811057e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057ec:	e0bffe17 	ldw	r2,-8(fp)
811057f0:	1080400c 	andi	r2,r2,256
811057f4:	10000426 	beq	r2,zero,81105808 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
811057f8:	e0bfff17 	ldw	r2,-4(fp)
811057fc:	00c00044 	movi	r3,1
81105800:	10c00415 	stw	r3,16(r2)
81105804:	00000206 	br	81105810 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81105808:	e0bfff17 	ldw	r2,-4(fp)
8110580c:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
81105810:	00800044 	movi	r2,1
81105814:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105818:	e0bffd17 	ldw	r2,-12(fp)
}
8110581c:	e037883a 	mov	sp,fp
81105820:	dfc00117 	ldw	ra,4(sp)
81105824:	df000017 	ldw	fp,0(sp)
81105828:	dec00204 	addi	sp,sp,8
8110582c:	f800283a 	ret

81105830 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
81105830:	defffb04 	addi	sp,sp,-20
81105834:	de00012e 	bgeu	sp,et,8110583c <bFeebGetBuffersStatus+0xc>
81105838:	003b68fa 	trap	3
8110583c:	dfc00415 	stw	ra,16(sp)
81105840:	df000315 	stw	fp,12(sp)
81105844:	df000304 	addi	fp,sp,12
81105848:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110584c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105850:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105854:	e0bfff17 	ldw	r2,-4(fp)
81105858:	10001a26 	beq	r2,zero,811058c4 <bFeebGetBuffersStatus+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110585c:	e0bfff17 	ldw	r2,-4(fp)
81105860:	10800017 	ldw	r2,0(r2)
81105864:	014000c4 	movi	r5,3
81105868:	1009883a 	mov	r4,r2
8110586c:	1105d7c0 	call	81105d7c <uliFeebReadReg>
81105870:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81105874:	e0bffe17 	ldw	r2,-8(fp)
81105878:	1080008c 	andi	r2,r2,2
8110587c:	10000426 	beq	r2,zero,81105890 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
81105880:	e0bfff17 	ldw	r2,-4(fp)
81105884:	00c00044 	movi	r3,1
81105888:	10c00515 	stw	r3,20(r2)
8110588c:	00000206 	br	81105898 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
81105890:	e0bfff17 	ldw	r2,-4(fp)
81105894:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81105898:	e0bffe17 	ldw	r2,-8(fp)
8110589c:	1080004c 	andi	r2,r2,1
811058a0:	10000426 	beq	r2,zero,811058b4 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
811058a4:	e0bfff17 	ldw	r2,-4(fp)
811058a8:	00c00044 	movi	r3,1
811058ac:	10c00615 	stw	r3,24(r2)
811058b0:	00000206 	br	811058bc <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
811058b4:	e0bfff17 	ldw	r2,-4(fp)
811058b8:	10000615 	stw	zero,24(r2)
		}

		bStatus = TRUE;
811058bc:	00800044 	movi	r2,1
811058c0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811058c4:	e0bffd17 	ldw	r2,-12(fp)
}
811058c8:	e037883a 	mov	sp,fp
811058cc:	dfc00117 	ldw	ra,4(sp)
811058d0:	df000017 	ldw	fp,0(sp)
811058d4:	dec00204 	addi	sp,sp,8
811058d8:	f800283a 	ret

811058dc <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
811058dc:	defffb04 	addi	sp,sp,-20
811058e0:	de00012e 	bgeu	sp,et,811058e8 <bFeebSetWindowing+0xc>
811058e4:	003b68fa 	trap	3
811058e8:	dfc00415 	stw	ra,16(sp)
811058ec:	df000315 	stw	fp,12(sp)
811058f0:	df000304 	addi	fp,sp,12
811058f4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811058f8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811058fc:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105900:	e0bfff17 	ldw	r2,-4(fp)
81105904:	10001926 	beq	r2,zero,8110596c <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105908:	e0bfff17 	ldw	r2,-4(fp)
8110590c:	10800017 	ldw	r2,0(r2)
81105910:	01400084 	movi	r5,2
81105914:	1009883a 	mov	r4,r2
81105918:	1105d7c0 	call	81105d7c <uliFeebReadReg>
8110591c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81105920:	e0bfff17 	ldw	r2,-4(fp)
81105924:	10800117 	ldw	r2,4(r2)
81105928:	10000426 	beq	r2,zero,8110593c <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
8110592c:	e0bffe17 	ldw	r2,-8(fp)
81105930:	10800214 	ori	r2,r2,8
81105934:	e0bffe15 	stw	r2,-8(fp)
81105938:	00000406 	br	8110594c <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
8110593c:	e0fffe17 	ldw	r3,-8(fp)
81105940:	00bffdc4 	movi	r2,-9
81105944:	1884703a 	and	r2,r3,r2
81105948:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
8110594c:	e0bfff17 	ldw	r2,-4(fp)
81105950:	10800017 	ldw	r2,0(r2)
81105954:	e1bffe17 	ldw	r6,-8(fp)
81105958:	01400084 	movi	r5,2
8110595c:	1009883a 	mov	r4,r2
81105960:	1105d280 	call	81105d28 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105964:	00800044 	movi	r2,1
81105968:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110596c:	e0bffd17 	ldw	r2,-12(fp)
}
81105970:	e037883a 	mov	sp,fp
81105974:	dfc00117 	ldw	ra,4(sp)
81105978:	df000017 	ldw	fp,0(sp)
8110597c:	dec00204 	addi	sp,sp,8
81105980:	f800283a 	ret

81105984 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81105984:	defffb04 	addi	sp,sp,-20
81105988:	de00012e 	bgeu	sp,et,81105990 <bFeebGetWindowing+0xc>
8110598c:	003b68fa 	trap	3
81105990:	dfc00415 	stw	ra,16(sp)
81105994:	df000315 	stw	fp,12(sp)
81105998:	df000304 	addi	fp,sp,12
8110599c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811059a0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811059a4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811059a8:	e0bfff17 	ldw	r2,-4(fp)
811059ac:	10001126 	beq	r2,zero,811059f4 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811059b0:	e0bfff17 	ldw	r2,-4(fp)
811059b4:	10800017 	ldw	r2,0(r2)
811059b8:	01400084 	movi	r5,2
811059bc:	1009883a 	mov	r4,r2
811059c0:	1105d7c0 	call	81105d7c <uliFeebReadReg>
811059c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
811059c8:	e0bffe17 	ldw	r2,-8(fp)
811059cc:	1080020c 	andi	r2,r2,8
811059d0:	10000426 	beq	r2,zero,811059e4 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
811059d4:	e0bfff17 	ldw	r2,-4(fp)
811059d8:	00c00044 	movi	r3,1
811059dc:	10c00115 	stw	r3,4(r2)
811059e0:	00000206 	br	811059ec <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
811059e4:	e0bfff17 	ldw	r2,-4(fp)
811059e8:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
811059ec:	00800044 	movi	r2,1
811059f0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811059f4:	e0bffd17 	ldw	r2,-12(fp)
}
811059f8:	e037883a 	mov	sp,fp
811059fc:	dfc00117 	ldw	ra,4(sp)
81105a00:	df000017 	ldw	fp,0(sp)
81105a04:	dec00204 	addi	sp,sp,8
81105a08:	f800283a 	ret

81105a0c <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81105a0c:	defffb04 	addi	sp,sp,-20
81105a10:	de00012e 	bgeu	sp,et,81105a18 <bFeebStartCh+0xc>
81105a14:	003b68fa 	trap	3
81105a18:	dfc00415 	stw	ra,16(sp)
81105a1c:	df000315 	stw	fp,12(sp)
81105a20:	df000304 	addi	fp,sp,12
81105a24:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105a28:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105a2c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105a30:	e0bfff17 	ldw	r2,-4(fp)
81105a34:	10001126 	beq	r2,zero,81105a7c <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105a38:	e0bfff17 	ldw	r2,-4(fp)
81105a3c:	10800017 	ldw	r2,0(r2)
81105a40:	01400084 	movi	r5,2
81105a44:	1009883a 	mov	r4,r2
81105a48:	1105d7c0 	call	81105d7c <uliFeebReadReg>
81105a4c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
81105a50:	e0bffe17 	ldw	r2,-8(fp)
81105a54:	10800114 	ori	r2,r2,4
81105a58:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105a5c:	e0bfff17 	ldw	r2,-4(fp)
81105a60:	10800017 	ldw	r2,0(r2)
81105a64:	e1bffe17 	ldw	r6,-8(fp)
81105a68:	01400084 	movi	r5,2
81105a6c:	1009883a 	mov	r4,r2
81105a70:	1105d280 	call	81105d28 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105a74:	00800044 	movi	r2,1
81105a78:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105a7c:	e0bffd17 	ldw	r2,-12(fp)
}
81105a80:	e037883a 	mov	sp,fp
81105a84:	dfc00117 	ldw	ra,4(sp)
81105a88:	df000017 	ldw	fp,0(sp)
81105a8c:	dec00204 	addi	sp,sp,8
81105a90:	f800283a 	ret

81105a94 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81105a94:	defffb04 	addi	sp,sp,-20
81105a98:	de00012e 	bgeu	sp,et,81105aa0 <bFeebStopCh+0xc>
81105a9c:	003b68fa 	trap	3
81105aa0:	dfc00415 	stw	ra,16(sp)
81105aa4:	df000315 	stw	fp,12(sp)
81105aa8:	df000304 	addi	fp,sp,12
81105aac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105ab0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105ab4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105ab8:	e0bfff17 	ldw	r2,-4(fp)
81105abc:	10001126 	beq	r2,zero,81105b04 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105ac0:	e0bfff17 	ldw	r2,-4(fp)
81105ac4:	10800017 	ldw	r2,0(r2)
81105ac8:	01400084 	movi	r5,2
81105acc:	1009883a 	mov	r4,r2
81105ad0:	1105d7c0 	call	81105d7c <uliFeebReadReg>
81105ad4:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81105ad8:	e0bffe17 	ldw	r2,-8(fp)
81105adc:	10800094 	ori	r2,r2,2
81105ae0:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105ae4:	e0bfff17 	ldw	r2,-4(fp)
81105ae8:	10800017 	ldw	r2,0(r2)
81105aec:	e1bffe17 	ldw	r6,-8(fp)
81105af0:	01400084 	movi	r5,2
81105af4:	1009883a 	mov	r4,r2
81105af8:	1105d280 	call	81105d28 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105afc:	00800044 	movi	r2,1
81105b00:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105b04:	e0bffd17 	ldw	r2,-12(fp)
}
81105b08:	e037883a 	mov	sp,fp
81105b0c:	dfc00117 	ldw	ra,4(sp)
81105b10:	df000017 	ldw	fp,0(sp)
81105b14:	dec00204 	addi	sp,sp,8
81105b18:	f800283a 	ret

81105b1c <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81105b1c:	defffb04 	addi	sp,sp,-20
81105b20:	de00012e 	bgeu	sp,et,81105b28 <bFeebClrCh+0xc>
81105b24:	003b68fa 	trap	3
81105b28:	dfc00415 	stw	ra,16(sp)
81105b2c:	df000315 	stw	fp,12(sp)
81105b30:	df000304 	addi	fp,sp,12
81105b34:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105b38:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105b3c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105b40:	e0bfff17 	ldw	r2,-4(fp)
81105b44:	10001126 	beq	r2,zero,81105b8c <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105b48:	e0bfff17 	ldw	r2,-4(fp)
81105b4c:	10800017 	ldw	r2,0(r2)
81105b50:	01400084 	movi	r5,2
81105b54:	1009883a 	mov	r4,r2
81105b58:	1105d7c0 	call	81105d7c <uliFeebReadReg>
81105b5c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81105b60:	e0bffe17 	ldw	r2,-8(fp)
81105b64:	10800054 	ori	r2,r2,1
81105b68:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105b6c:	e0bfff17 	ldw	r2,-4(fp)
81105b70:	10800017 	ldw	r2,0(r2)
81105b74:	e1bffe17 	ldw	r6,-8(fp)
81105b78:	01400084 	movi	r5,2
81105b7c:	1009883a 	mov	r4,r2
81105b80:	1105d280 	call	81105d28 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105b84:	00800044 	movi	r2,1
81105b88:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105b8c:	e0bffd17 	ldw	r2,-12(fp)
}
81105b90:	e037883a 	mov	sp,fp
81105b94:	dfc00117 	ldw	ra,4(sp)
81105b98:	df000017 	ldw	fp,0(sp)
81105b9c:	dec00204 	addi	sp,sp,8
81105ba0:	f800283a 	ret

81105ba4 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81105ba4:	defffb04 	addi	sp,sp,-20
81105ba8:	de00012e 	bgeu	sp,et,81105bb0 <bFeebInitCh+0xc>
81105bac:	003b68fa 	trap	3
81105bb0:	dfc00415 	stw	ra,16(sp)
81105bb4:	df000315 	stw	fp,12(sp)
81105bb8:	df000304 	addi	fp,sp,12
81105bbc:	e13ffe15 	stw	r4,-8(fp)
81105bc0:	2805883a 	mov	r2,r5
81105bc4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105bc8:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81105bcc:	e0bffe17 	ldw	r2,-8(fp)
81105bd0:	10004f26 	beq	r2,zero,81105d10 <bFeebInitCh+0x16c>
		bStatus = TRUE;
81105bd4:	00800044 	movi	r2,1
81105bd8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81105bdc:	e0bfff03 	ldbu	r2,-4(fp)
81105be0:	10c00228 	cmpgeui	r3,r2,8
81105be4:	1800361e 	bne	r3,zero,81105cc0 <bFeebInitCh+0x11c>
81105be8:	100690ba 	slli	r3,r2,2
81105bec:	00a04434 	movhi	r2,33040
81105bf0:	10970004 	addi	r2,r2,23552
81105bf4:	1885883a 	add	r2,r3,r2
81105bf8:	10800017 	ldw	r2,0(r2)
81105bfc:	1000683a 	jmp	r2
81105c00:	81105c20 	cmpeqi	r4,r16,16752
81105c04:	81105c34 	orhi	r4,r16,16752
81105c08:	81105c48 	cmpgei	r4,r16,16753
81105c0c:	81105c5c 	xori	r4,r16,16753
81105c10:	81105c70 	cmpltui	r4,r16,16753
81105c14:	81105c84 	addi	r4,r16,16754
81105c18:	81105c98 	cmpnei	r4,r16,16754
81105c1c:	81105cac 	andhi	r4,r16,16754
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105c20:	e0fffe17 	ldw	r3,-8(fp)
81105c24:	00a04834 	movhi	r2,33056
81105c28:	108b0004 	addi	r2,r2,11264
81105c2c:	18800015 	stw	r2,0(r3)
			break;
81105c30:	00002506 	br	81105cc8 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81105c34:	e0fffe17 	ldw	r3,-8(fp)
81105c38:	00a04834 	movhi	r2,33056
81105c3c:	108a0004 	addi	r2,r2,10240
81105c40:	18800015 	stw	r2,0(r3)
			break;
81105c44:	00002006 	br	81105cc8 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81105c48:	e0fffe17 	ldw	r3,-8(fp)
81105c4c:	00a04834 	movhi	r2,33056
81105c50:	10890004 	addi	r2,r2,9216
81105c54:	18800015 	stw	r2,0(r3)
			break;
81105c58:	00001b06 	br	81105cc8 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81105c5c:	e0fffe17 	ldw	r3,-8(fp)
81105c60:	00a04834 	movhi	r2,33056
81105c64:	10880004 	addi	r2,r2,8192
81105c68:	18800015 	stw	r2,0(r3)
			break;
81105c6c:	00001606 	br	81105cc8 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81105c70:	e0fffe17 	ldw	r3,-8(fp)
81105c74:	00a04834 	movhi	r2,33056
81105c78:	10870004 	addi	r2,r2,7168
81105c7c:	18800015 	stw	r2,0(r3)
			break;
81105c80:	00001106 	br	81105cc8 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81105c84:	e0fffe17 	ldw	r3,-8(fp)
81105c88:	00a04834 	movhi	r2,33056
81105c8c:	10860004 	addi	r2,r2,6144
81105c90:	18800015 	stw	r2,0(r3)
			break;
81105c94:	00000c06 	br	81105cc8 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81105c98:	e0fffe17 	ldw	r3,-8(fp)
81105c9c:	00a04834 	movhi	r2,33056
81105ca0:	10850004 	addi	r2,r2,5120
81105ca4:	18800015 	stw	r2,0(r3)
			break;
81105ca8:	00000706 	br	81105cc8 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81105cac:	e0fffe17 	ldw	r3,-8(fp)
81105cb0:	00a04834 	movhi	r2,33056
81105cb4:	10840004 	addi	r2,r2,4096
81105cb8:	18800015 	stw	r2,0(r3)
			break;
81105cbc:	00000206 	br	81105cc8 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81105cc0:	e03ffd15 	stw	zero,-12(fp)
			break;
81105cc4:	0001883a 	nop
		}

		if (bStatus) {
81105cc8:	e0bffd17 	ldw	r2,-12(fp)
81105ccc:	10001026 	beq	r2,zero,81105d10 <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81105cd0:	e13ffe17 	ldw	r4,-8(fp)
81105cd4:	11056fc0 	call	811056fc <bFeebGetIrqControl>
81105cd8:	1000011e 	bne	r2,zero,81105ce0 <bFeebInitCh+0x13c>
				bStatus = FALSE;
81105cdc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81105ce0:	e13ffe17 	ldw	r4,-8(fp)
81105ce4:	11057a80 	call	811057a8 <bFeebGetIrqFlags>
81105ce8:	1000011e 	bne	r2,zero,81105cf0 <bFeebInitCh+0x14c>
				bStatus = FALSE;
81105cec:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81105cf0:	e13ffe17 	ldw	r4,-8(fp)
81105cf4:	11058300 	call	81105830 <bFeebGetBuffersStatus>
81105cf8:	1000011e 	bne	r2,zero,81105d00 <bFeebInitCh+0x15c>
				bStatus = FALSE;
81105cfc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81105d00:	e13ffe17 	ldw	r4,-8(fp)
81105d04:	11059840 	call	81105984 <bFeebGetWindowing>
81105d08:	1000011e 	bne	r2,zero,81105d10 <bFeebInitCh+0x16c>
				bStatus = FALSE;
81105d0c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81105d10:	e0bffd17 	ldw	r2,-12(fp)
}
81105d14:	e037883a 	mov	sp,fp
81105d18:	dfc00117 	ldw	ra,4(sp)
81105d1c:	df000017 	ldw	fp,0(sp)
81105d20:	dec00204 	addi	sp,sp,8
81105d24:	f800283a 	ret

81105d28 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81105d28:	defffc04 	addi	sp,sp,-16
81105d2c:	de00012e 	bgeu	sp,et,81105d34 <vFeebWriteReg+0xc>
81105d30:	003b68fa 	trap	3
81105d34:	df000315 	stw	fp,12(sp)
81105d38:	df000304 	addi	fp,sp,12
81105d3c:	e13ffd15 	stw	r4,-12(fp)
81105d40:	e17ffe15 	stw	r5,-8(fp)
81105d44:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81105d48:	e0bffe17 	ldw	r2,-8(fp)
81105d4c:	1085883a 	add	r2,r2,r2
81105d50:	1085883a 	add	r2,r2,r2
81105d54:	1007883a 	mov	r3,r2
81105d58:	e0bffd17 	ldw	r2,-12(fp)
81105d5c:	10c5883a 	add	r2,r2,r3
81105d60:	e0ffff17 	ldw	r3,-4(fp)
81105d64:	10c00015 	stw	r3,0(r2)
}
81105d68:	0001883a 	nop
81105d6c:	e037883a 	mov	sp,fp
81105d70:	df000017 	ldw	fp,0(sp)
81105d74:	dec00104 	addi	sp,sp,4
81105d78:	f800283a 	ret

81105d7c <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105d7c:	defffc04 	addi	sp,sp,-16
81105d80:	de00012e 	bgeu	sp,et,81105d88 <uliFeebReadReg+0xc>
81105d84:	003b68fa 	trap	3
81105d88:	df000315 	stw	fp,12(sp)
81105d8c:	df000304 	addi	fp,sp,12
81105d90:	e13ffe15 	stw	r4,-8(fp)
81105d94:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105d98:	e0bfff17 	ldw	r2,-4(fp)
81105d9c:	1085883a 	add	r2,r2,r2
81105da0:	1085883a 	add	r2,r2,r2
81105da4:	1007883a 	mov	r3,r2
81105da8:	e0bffe17 	ldw	r2,-8(fp)
81105dac:	10c5883a 	add	r2,r2,r3
81105db0:	10800017 	ldw	r2,0(r2)
81105db4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105db8:	e0bffd17 	ldw	r2,-12(fp)
}
81105dbc:	e037883a 	mov	sp,fp
81105dc0:	df000017 	ldw	fp,0(sp)
81105dc4:	dec00104 	addi	sp,sp,4
81105dc8:	f800283a 	ret

81105dcc <vRmapCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRmapCh1HandleIrq(void* pvContext) {
81105dcc:	defffc04 	addi	sp,sp,-16
81105dd0:	de00012e 	bgeu	sp,et,81105dd8 <vRmapCh1HandleIrq+0xc>
81105dd4:	003b68fa 	trap	3
81105dd8:	dfc00315 	stw	ra,12(sp)
81105ddc:	df000215 	stw	fp,8(sp)
81105de0:	df000204 	addi	fp,sp,8
81105de4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105de8:	e0bfff17 	ldw	r2,-4(fp)
81105dec:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh1IrqFlagClrWriteCmd();
81105df0:	1105fcc0 	call	81105fcc <vRmapCh1IrqFlagClrWriteCmd>
}
81105df4:	0001883a 	nop
81105df8:	e037883a 	mov	sp,fp
81105dfc:	dfc00117 	ldw	ra,4(sp)
81105e00:	df000017 	ldw	fp,0(sp)
81105e04:	dec00204 	addi	sp,sp,8
81105e08:	f800283a 	ret

81105e0c <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81105e0c:	defffc04 	addi	sp,sp,-16
81105e10:	de00012e 	bgeu	sp,et,81105e18 <vRmapCh2HandleIrq+0xc>
81105e14:	003b68fa 	trap	3
81105e18:	dfc00315 	stw	ra,12(sp)
81105e1c:	df000215 	stw	fp,8(sp)
81105e20:	df000204 	addi	fp,sp,8
81105e24:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105e28:	e0bfff17 	ldw	r2,-4(fp)
81105e2c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh2IrqFlagClrWriteCmd();
81105e30:	11060100 	call	81106010 <vRmapCh2IrqFlagClrWriteCmd>
}
81105e34:	0001883a 	nop
81105e38:	e037883a 	mov	sp,fp
81105e3c:	dfc00117 	ldw	ra,4(sp)
81105e40:	df000017 	ldw	fp,0(sp)
81105e44:	dec00204 	addi	sp,sp,8
81105e48:	f800283a 	ret

81105e4c <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81105e4c:	defffc04 	addi	sp,sp,-16
81105e50:	de00012e 	bgeu	sp,et,81105e58 <vRmapCh3HandleIrq+0xc>
81105e54:	003b68fa 	trap	3
81105e58:	dfc00315 	stw	ra,12(sp)
81105e5c:	df000215 	stw	fp,8(sp)
81105e60:	df000204 	addi	fp,sp,8
81105e64:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105e68:	e0bfff17 	ldw	r2,-4(fp)
81105e6c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81105e70:	11060540 	call	81106054 <vRmapCh3IrqFlagClrWriteCmd>
}
81105e74:	0001883a 	nop
81105e78:	e037883a 	mov	sp,fp
81105e7c:	dfc00117 	ldw	ra,4(sp)
81105e80:	df000017 	ldw	fp,0(sp)
81105e84:	dec00204 	addi	sp,sp,8
81105e88:	f800283a 	ret

81105e8c <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81105e8c:	defffc04 	addi	sp,sp,-16
81105e90:	de00012e 	bgeu	sp,et,81105e98 <vRmapCh4HandleIrq+0xc>
81105e94:	003b68fa 	trap	3
81105e98:	dfc00315 	stw	ra,12(sp)
81105e9c:	df000215 	stw	fp,8(sp)
81105ea0:	df000204 	addi	fp,sp,8
81105ea4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105ea8:	e0bfff17 	ldw	r2,-4(fp)
81105eac:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81105eb0:	11060980 	call	81106098 <vRmapCh4IrqFlagClrWriteCmd>
}
81105eb4:	0001883a 	nop
81105eb8:	e037883a 	mov	sp,fp
81105ebc:	dfc00117 	ldw	ra,4(sp)
81105ec0:	df000017 	ldw	fp,0(sp)
81105ec4:	dec00204 	addi	sp,sp,8
81105ec8:	f800283a 	ret

81105ecc <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81105ecc:	defffc04 	addi	sp,sp,-16
81105ed0:	de00012e 	bgeu	sp,et,81105ed8 <vRmapCh5HandleIrq+0xc>
81105ed4:	003b68fa 	trap	3
81105ed8:	dfc00315 	stw	ra,12(sp)
81105edc:	df000215 	stw	fp,8(sp)
81105ee0:	df000204 	addi	fp,sp,8
81105ee4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105ee8:	e0bfff17 	ldw	r2,-4(fp)
81105eec:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81105ef0:	11060dc0 	call	811060dc <vRmapCh5IrqFlagClrWriteCmd>
}
81105ef4:	0001883a 	nop
81105ef8:	e037883a 	mov	sp,fp
81105efc:	dfc00117 	ldw	ra,4(sp)
81105f00:	df000017 	ldw	fp,0(sp)
81105f04:	dec00204 	addi	sp,sp,8
81105f08:	f800283a 	ret

81105f0c <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81105f0c:	defffc04 	addi	sp,sp,-16
81105f10:	de00012e 	bgeu	sp,et,81105f18 <vRmapCh6HandleIrq+0xc>
81105f14:	003b68fa 	trap	3
81105f18:	dfc00315 	stw	ra,12(sp)
81105f1c:	df000215 	stw	fp,8(sp)
81105f20:	df000204 	addi	fp,sp,8
81105f24:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105f28:	e0bfff17 	ldw	r2,-4(fp)
81105f2c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81105f30:	11061200 	call	81106120 <vRmapCh6IrqFlagClrWriteCmd>
}
81105f34:	0001883a 	nop
81105f38:	e037883a 	mov	sp,fp
81105f3c:	dfc00117 	ldw	ra,4(sp)
81105f40:	df000017 	ldw	fp,0(sp)
81105f44:	dec00204 	addi	sp,sp,8
81105f48:	f800283a 	ret

81105f4c <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81105f4c:	defffc04 	addi	sp,sp,-16
81105f50:	de00012e 	bgeu	sp,et,81105f58 <vRmapCh7HandleIrq+0xc>
81105f54:	003b68fa 	trap	3
81105f58:	dfc00315 	stw	ra,12(sp)
81105f5c:	df000215 	stw	fp,8(sp)
81105f60:	df000204 	addi	fp,sp,8
81105f64:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105f68:	e0bfff17 	ldw	r2,-4(fp)
81105f6c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81105f70:	11061640 	call	81106164 <vRmapCh7IrqFlagClrWriteCmd>
}
81105f74:	0001883a 	nop
81105f78:	e037883a 	mov	sp,fp
81105f7c:	dfc00117 	ldw	ra,4(sp)
81105f80:	df000017 	ldw	fp,0(sp)
81105f84:	dec00204 	addi	sp,sp,8
81105f88:	f800283a 	ret

81105f8c <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81105f8c:	defffc04 	addi	sp,sp,-16
81105f90:	de00012e 	bgeu	sp,et,81105f98 <vRmapCh8HandleIrq+0xc>
81105f94:	003b68fa 	trap	3
81105f98:	dfc00315 	stw	ra,12(sp)
81105f9c:	df000215 	stw	fp,8(sp)
81105fa0:	df000204 	addi	fp,sp,8
81105fa4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105fa8:	e0bfff17 	ldw	r2,-4(fp)
81105fac:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81105fb0:	11061a80 	call	811061a8 <vRmapCh8IrqFlagClrWriteCmd>
}
81105fb4:	0001883a 	nop
81105fb8:	e037883a 	mov	sp,fp
81105fbc:	dfc00117 	ldw	ra,4(sp)
81105fc0:	df000017 	ldw	fp,0(sp)
81105fc4:	dec00204 	addi	sp,sp,8
81105fc8:	f800283a 	ret

81105fcc <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81105fcc:	defffe04 	addi	sp,sp,-8
81105fd0:	de00012e 	bgeu	sp,et,81105fd8 <vRmapCh1IrqFlagClrWriteCmd+0xc>
81105fd4:	003b68fa 	trap	3
81105fd8:	dfc00115 	stw	ra,4(sp)
81105fdc:	df000015 	stw	fp,0(sp)
81105fe0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105fe4:	01800044 	movi	r6,1
81105fe8:	014004c4 	movi	r5,19
81105fec:	01204834 	movhi	r4,33056
81105ff0:	210b0004 	addi	r4,r4,11264
81105ff4:	1108a940 	call	81108a94 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81105ff8:	0001883a 	nop
81105ffc:	e037883a 	mov	sp,fp
81106000:	dfc00117 	ldw	ra,4(sp)
81106004:	df000017 	ldw	fp,0(sp)
81106008:	dec00204 	addi	sp,sp,8
8110600c:	f800283a 	ret

81106010 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81106010:	defffe04 	addi	sp,sp,-8
81106014:	de00012e 	bgeu	sp,et,8110601c <vRmapCh2IrqFlagClrWriteCmd+0xc>
81106018:	003b68fa 	trap	3
8110601c:	dfc00115 	stw	ra,4(sp)
81106020:	df000015 	stw	fp,0(sp)
81106024:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106028:	01800044 	movi	r6,1
8110602c:	014004c4 	movi	r5,19
81106030:	01204834 	movhi	r4,33056
81106034:	210a0004 	addi	r4,r4,10240
81106038:	1108a940 	call	81108a94 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110603c:	0001883a 	nop
81106040:	e037883a 	mov	sp,fp
81106044:	dfc00117 	ldw	ra,4(sp)
81106048:	df000017 	ldw	fp,0(sp)
8110604c:	dec00204 	addi	sp,sp,8
81106050:	f800283a 	ret

81106054 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81106054:	defffe04 	addi	sp,sp,-8
81106058:	de00012e 	bgeu	sp,et,81106060 <vRmapCh3IrqFlagClrWriteCmd+0xc>
8110605c:	003b68fa 	trap	3
81106060:	dfc00115 	stw	ra,4(sp)
81106064:	df000015 	stw	fp,0(sp)
81106068:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110606c:	01800044 	movi	r6,1
81106070:	014004c4 	movi	r5,19
81106074:	01204834 	movhi	r4,33056
81106078:	21090004 	addi	r4,r4,9216
8110607c:	1108a940 	call	81108a94 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106080:	0001883a 	nop
81106084:	e037883a 	mov	sp,fp
81106088:	dfc00117 	ldw	ra,4(sp)
8110608c:	df000017 	ldw	fp,0(sp)
81106090:	dec00204 	addi	sp,sp,8
81106094:	f800283a 	ret

81106098 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81106098:	defffe04 	addi	sp,sp,-8
8110609c:	de00012e 	bgeu	sp,et,811060a4 <vRmapCh4IrqFlagClrWriteCmd+0xc>
811060a0:	003b68fa 	trap	3
811060a4:	dfc00115 	stw	ra,4(sp)
811060a8:	df000015 	stw	fp,0(sp)
811060ac:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811060b0:	01800044 	movi	r6,1
811060b4:	014004c4 	movi	r5,19
811060b8:	01204834 	movhi	r4,33056
811060bc:	21080004 	addi	r4,r4,8192
811060c0:	1108a940 	call	81108a94 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811060c4:	0001883a 	nop
811060c8:	e037883a 	mov	sp,fp
811060cc:	dfc00117 	ldw	ra,4(sp)
811060d0:	df000017 	ldw	fp,0(sp)
811060d4:	dec00204 	addi	sp,sp,8
811060d8:	f800283a 	ret

811060dc <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
811060dc:	defffe04 	addi	sp,sp,-8
811060e0:	de00012e 	bgeu	sp,et,811060e8 <vRmapCh5IrqFlagClrWriteCmd+0xc>
811060e4:	003b68fa 	trap	3
811060e8:	dfc00115 	stw	ra,4(sp)
811060ec:	df000015 	stw	fp,0(sp)
811060f0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811060f4:	01800044 	movi	r6,1
811060f8:	014004c4 	movi	r5,19
811060fc:	01204834 	movhi	r4,33056
81106100:	21070004 	addi	r4,r4,7168
81106104:	1108a940 	call	81108a94 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106108:	0001883a 	nop
8110610c:	e037883a 	mov	sp,fp
81106110:	dfc00117 	ldw	ra,4(sp)
81106114:	df000017 	ldw	fp,0(sp)
81106118:	dec00204 	addi	sp,sp,8
8110611c:	f800283a 	ret

81106120 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
81106120:	defffe04 	addi	sp,sp,-8
81106124:	de00012e 	bgeu	sp,et,8110612c <vRmapCh6IrqFlagClrWriteCmd+0xc>
81106128:	003b68fa 	trap	3
8110612c:	dfc00115 	stw	ra,4(sp)
81106130:	df000015 	stw	fp,0(sp)
81106134:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81106138:	01800044 	movi	r6,1
8110613c:	014004c4 	movi	r5,19
81106140:	01204834 	movhi	r4,33056
81106144:	21060004 	addi	r4,r4,6144
81106148:	1108a940 	call	81108a94 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110614c:	0001883a 	nop
81106150:	e037883a 	mov	sp,fp
81106154:	dfc00117 	ldw	ra,4(sp)
81106158:	df000017 	ldw	fp,0(sp)
8110615c:	dec00204 	addi	sp,sp,8
81106160:	f800283a 	ret

81106164 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81106164:	defffe04 	addi	sp,sp,-8
81106168:	de00012e 	bgeu	sp,et,81106170 <vRmapCh7IrqFlagClrWriteCmd+0xc>
8110616c:	003b68fa 	trap	3
81106170:	dfc00115 	stw	ra,4(sp)
81106174:	df000015 	stw	fp,0(sp)
81106178:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110617c:	01800044 	movi	r6,1
81106180:	014004c4 	movi	r5,19
81106184:	01204834 	movhi	r4,33056
81106188:	21050004 	addi	r4,r4,5120
8110618c:	1108a940 	call	81108a94 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106190:	0001883a 	nop
81106194:	e037883a 	mov	sp,fp
81106198:	dfc00117 	ldw	ra,4(sp)
8110619c:	df000017 	ldw	fp,0(sp)
811061a0:	dec00204 	addi	sp,sp,8
811061a4:	f800283a 	ret

811061a8 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
811061a8:	defffe04 	addi	sp,sp,-8
811061ac:	de00012e 	bgeu	sp,et,811061b4 <vRmapCh8IrqFlagClrWriteCmd+0xc>
811061b0:	003b68fa 	trap	3
811061b4:	dfc00115 	stw	ra,4(sp)
811061b8:	df000015 	stw	fp,0(sp)
811061bc:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811061c0:	01800044 	movi	r6,1
811061c4:	014004c4 	movi	r5,19
811061c8:	01204834 	movhi	r4,33056
811061cc:	21040004 	addi	r4,r4,4096
811061d0:	1108a940 	call	81108a94 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811061d4:	0001883a 	nop
811061d8:	e037883a 	mov	sp,fp
811061dc:	dfc00117 	ldw	ra,4(sp)
811061e0:	df000017 	ldw	fp,0(sp)
811061e4:	dec00204 	addi	sp,sp,8
811061e8:	f800283a 	ret

811061ec <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
811061ec:	defffd04 	addi	sp,sp,-12
811061f0:	de00012e 	bgeu	sp,et,811061f8 <bRmapCh1IrqFlagWriteCmd+0xc>
811061f4:	003b68fa 	trap	3
811061f8:	dfc00215 	stw	ra,8(sp)
811061fc:	df000115 	stw	fp,4(sp)
81106200:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106204:	01400484 	movi	r5,18
81106208:	01204834 	movhi	r4,33056
8110620c:	210b0004 	addi	r4,r4,11264
81106210:	1108ae80 	call	81108ae8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106214:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106218:	10000326 	beq	r2,zero,81106228 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110621c:	00800044 	movi	r2,1
81106220:	e0bfff15 	stw	r2,-4(fp)
81106224:	00000106 	br	8110622c <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106228:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110622c:	e0bfff17 	ldw	r2,-4(fp)
}
81106230:	e037883a 	mov	sp,fp
81106234:	dfc00117 	ldw	ra,4(sp)
81106238:	df000017 	ldw	fp,0(sp)
8110623c:	dec00204 	addi	sp,sp,8
81106240:	f800283a 	ret

81106244 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81106244:	defffd04 	addi	sp,sp,-12
81106248:	de00012e 	bgeu	sp,et,81106250 <bRmapCh2IrqFlagWriteCmd+0xc>
8110624c:	003b68fa 	trap	3
81106250:	dfc00215 	stw	ra,8(sp)
81106254:	df000115 	stw	fp,4(sp)
81106258:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110625c:	01400484 	movi	r5,18
81106260:	01204834 	movhi	r4,33056
81106264:	210a0004 	addi	r4,r4,10240
81106268:	1108ae80 	call	81108ae8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110626c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106270:	10000326 	beq	r2,zero,81106280 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106274:	00800044 	movi	r2,1
81106278:	e0bfff15 	stw	r2,-4(fp)
8110627c:	00000106 	br	81106284 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106280:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106284:	e0bfff17 	ldw	r2,-4(fp)
}
81106288:	e037883a 	mov	sp,fp
8110628c:	dfc00117 	ldw	ra,4(sp)
81106290:	df000017 	ldw	fp,0(sp)
81106294:	dec00204 	addi	sp,sp,8
81106298:	f800283a 	ret

8110629c <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
8110629c:	defffd04 	addi	sp,sp,-12
811062a0:	de00012e 	bgeu	sp,et,811062a8 <bRmapCh3IrqFlagWriteCmd+0xc>
811062a4:	003b68fa 	trap	3
811062a8:	dfc00215 	stw	ra,8(sp)
811062ac:	df000115 	stw	fp,4(sp)
811062b0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811062b4:	01400484 	movi	r5,18
811062b8:	01204834 	movhi	r4,33056
811062bc:	21090004 	addi	r4,r4,9216
811062c0:	1108ae80 	call	81108ae8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811062c4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811062c8:	10000326 	beq	r2,zero,811062d8 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811062cc:	00800044 	movi	r2,1
811062d0:	e0bfff15 	stw	r2,-4(fp)
811062d4:	00000106 	br	811062dc <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811062d8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811062dc:	e0bfff17 	ldw	r2,-4(fp)
}
811062e0:	e037883a 	mov	sp,fp
811062e4:	dfc00117 	ldw	ra,4(sp)
811062e8:	df000017 	ldw	fp,0(sp)
811062ec:	dec00204 	addi	sp,sp,8
811062f0:	f800283a 	ret

811062f4 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
811062f4:	defffd04 	addi	sp,sp,-12
811062f8:	de00012e 	bgeu	sp,et,81106300 <bRmapCh4IrqFlagWriteCmd+0xc>
811062fc:	003b68fa 	trap	3
81106300:	dfc00215 	stw	ra,8(sp)
81106304:	df000115 	stw	fp,4(sp)
81106308:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110630c:	01400484 	movi	r5,18
81106310:	01204834 	movhi	r4,33056
81106314:	21080004 	addi	r4,r4,8192
81106318:	1108ae80 	call	81108ae8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110631c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106320:	10000326 	beq	r2,zero,81106330 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106324:	00800044 	movi	r2,1
81106328:	e0bfff15 	stw	r2,-4(fp)
8110632c:	00000106 	br	81106334 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106330:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106334:	e0bfff17 	ldw	r2,-4(fp)
}
81106338:	e037883a 	mov	sp,fp
8110633c:	dfc00117 	ldw	ra,4(sp)
81106340:	df000017 	ldw	fp,0(sp)
81106344:	dec00204 	addi	sp,sp,8
81106348:	f800283a 	ret

8110634c <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
8110634c:	defffd04 	addi	sp,sp,-12
81106350:	de00012e 	bgeu	sp,et,81106358 <bRmapCh5IrqFlagWriteCmd+0xc>
81106354:	003b68fa 	trap	3
81106358:	dfc00215 	stw	ra,8(sp)
8110635c:	df000115 	stw	fp,4(sp)
81106360:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106364:	01400484 	movi	r5,18
81106368:	01204834 	movhi	r4,33056
8110636c:	21070004 	addi	r4,r4,7168
81106370:	1108ae80 	call	81108ae8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106374:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106378:	10000326 	beq	r2,zero,81106388 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110637c:	00800044 	movi	r2,1
81106380:	e0bfff15 	stw	r2,-4(fp)
81106384:	00000106 	br	8110638c <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106388:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110638c:	e0bfff17 	ldw	r2,-4(fp)
}
81106390:	e037883a 	mov	sp,fp
81106394:	dfc00117 	ldw	ra,4(sp)
81106398:	df000017 	ldw	fp,0(sp)
8110639c:	dec00204 	addi	sp,sp,8
811063a0:	f800283a 	ret

811063a4 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
811063a4:	defffd04 	addi	sp,sp,-12
811063a8:	de00012e 	bgeu	sp,et,811063b0 <bRmapCh6IrqFlagWriteCmd+0xc>
811063ac:	003b68fa 	trap	3
811063b0:	dfc00215 	stw	ra,8(sp)
811063b4:	df000115 	stw	fp,4(sp)
811063b8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811063bc:	01400484 	movi	r5,18
811063c0:	01204834 	movhi	r4,33056
811063c4:	21060004 	addi	r4,r4,6144
811063c8:	1108ae80 	call	81108ae8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811063cc:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811063d0:	10000326 	beq	r2,zero,811063e0 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811063d4:	00800044 	movi	r2,1
811063d8:	e0bfff15 	stw	r2,-4(fp)
811063dc:	00000106 	br	811063e4 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811063e0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811063e4:	e0bfff17 	ldw	r2,-4(fp)
}
811063e8:	e037883a 	mov	sp,fp
811063ec:	dfc00117 	ldw	ra,4(sp)
811063f0:	df000017 	ldw	fp,0(sp)
811063f4:	dec00204 	addi	sp,sp,8
811063f8:	f800283a 	ret

811063fc <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
811063fc:	defffd04 	addi	sp,sp,-12
81106400:	de00012e 	bgeu	sp,et,81106408 <bRmapCh7IrqFlagWriteCmd+0xc>
81106404:	003b68fa 	trap	3
81106408:	dfc00215 	stw	ra,8(sp)
8110640c:	df000115 	stw	fp,4(sp)
81106410:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106414:	01400484 	movi	r5,18
81106418:	01204834 	movhi	r4,33056
8110641c:	21050004 	addi	r4,r4,5120
81106420:	1108ae80 	call	81108ae8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106424:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106428:	10000326 	beq	r2,zero,81106438 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110642c:	00800044 	movi	r2,1
81106430:	e0bfff15 	stw	r2,-4(fp)
81106434:	00000106 	br	8110643c <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106438:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110643c:	e0bfff17 	ldw	r2,-4(fp)
}
81106440:	e037883a 	mov	sp,fp
81106444:	dfc00117 	ldw	ra,4(sp)
81106448:	df000017 	ldw	fp,0(sp)
8110644c:	dec00204 	addi	sp,sp,8
81106450:	f800283a 	ret

81106454 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81106454:	defffd04 	addi	sp,sp,-12
81106458:	de00012e 	bgeu	sp,et,81106460 <bRmapCh8IrqFlagWriteCmd+0xc>
8110645c:	003b68fa 	trap	3
81106460:	dfc00215 	stw	ra,8(sp)
81106464:	df000115 	stw	fp,4(sp)
81106468:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110646c:	01400484 	movi	r5,18
81106470:	01204834 	movhi	r4,33056
81106474:	21040004 	addi	r4,r4,4096
81106478:	1108ae80 	call	81108ae8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110647c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106480:	10000326 	beq	r2,zero,81106490 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106484:	00800044 	movi	r2,1
81106488:	e0bfff15 	stw	r2,-4(fp)
8110648c:	00000106 	br	81106494 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106490:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106494:	e0bfff17 	ldw	r2,-4(fp)
}
81106498:	e037883a 	mov	sp,fp
8110649c:	dfc00117 	ldw	ra,4(sp)
811064a0:	df000017 	ldw	fp,0(sp)
811064a4:	dec00204 	addi	sp,sp,8
811064a8:	f800283a 	ret

811064ac <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
811064ac:	defffd04 	addi	sp,sp,-12
811064b0:	de00012e 	bgeu	sp,et,811064b8 <uliRmapCh1WriteCmdAddress+0xc>
811064b4:	003b68fa 	trap	3
811064b8:	dfc00215 	stw	ra,8(sp)
811064bc:	df000115 	stw	fp,4(sp)
811064c0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811064c4:	01400184 	movi	r5,6
811064c8:	01204834 	movhi	r4,33056
811064cc:	210b0004 	addi	r4,r4,11264
811064d0:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811064d4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811064d8:	e13fff17 	ldw	r4,-4(fp)
811064dc:	1108b380 	call	81108b38 <uliConvRmapCfgAddr>
811064e0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811064e4:	e0bfff17 	ldw	r2,-4(fp)
}
811064e8:	e037883a 	mov	sp,fp
811064ec:	dfc00117 	ldw	ra,4(sp)
811064f0:	df000017 	ldw	fp,0(sp)
811064f4:	dec00204 	addi	sp,sp,8
811064f8:	f800283a 	ret

811064fc <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
811064fc:	defffd04 	addi	sp,sp,-12
81106500:	de00012e 	bgeu	sp,et,81106508 <uliRmapCh2WriteCmdAddress+0xc>
81106504:	003b68fa 	trap	3
81106508:	dfc00215 	stw	ra,8(sp)
8110650c:	df000115 	stw	fp,4(sp)
81106510:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106514:	01400184 	movi	r5,6
81106518:	01204834 	movhi	r4,33056
8110651c:	210a0004 	addi	r4,r4,10240
81106520:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106524:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106528:	e13fff17 	ldw	r4,-4(fp)
8110652c:	1108b380 	call	81108b38 <uliConvRmapCfgAddr>
81106530:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106534:	e0bfff17 	ldw	r2,-4(fp)
}
81106538:	e037883a 	mov	sp,fp
8110653c:	dfc00117 	ldw	ra,4(sp)
81106540:	df000017 	ldw	fp,0(sp)
81106544:	dec00204 	addi	sp,sp,8
81106548:	f800283a 	ret

8110654c <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
8110654c:	defffd04 	addi	sp,sp,-12
81106550:	de00012e 	bgeu	sp,et,81106558 <uliRmapCh3WriteCmdAddress+0xc>
81106554:	003b68fa 	trap	3
81106558:	dfc00215 	stw	ra,8(sp)
8110655c:	df000115 	stw	fp,4(sp)
81106560:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106564:	01400184 	movi	r5,6
81106568:	01204834 	movhi	r4,33056
8110656c:	21090004 	addi	r4,r4,9216
81106570:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106574:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106578:	e13fff17 	ldw	r4,-4(fp)
8110657c:	1108b380 	call	81108b38 <uliConvRmapCfgAddr>
81106580:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106584:	e0bfff17 	ldw	r2,-4(fp)
}
81106588:	e037883a 	mov	sp,fp
8110658c:	dfc00117 	ldw	ra,4(sp)
81106590:	df000017 	ldw	fp,0(sp)
81106594:	dec00204 	addi	sp,sp,8
81106598:	f800283a 	ret

8110659c <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
8110659c:	defffd04 	addi	sp,sp,-12
811065a0:	de00012e 	bgeu	sp,et,811065a8 <uliRmapCh4WriteCmdAddress+0xc>
811065a4:	003b68fa 	trap	3
811065a8:	dfc00215 	stw	ra,8(sp)
811065ac:	df000115 	stw	fp,4(sp)
811065b0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811065b4:	01400184 	movi	r5,6
811065b8:	01204834 	movhi	r4,33056
811065bc:	21080004 	addi	r4,r4,8192
811065c0:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811065c4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811065c8:	e13fff17 	ldw	r4,-4(fp)
811065cc:	1108b380 	call	81108b38 <uliConvRmapCfgAddr>
811065d0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811065d4:	e0bfff17 	ldw	r2,-4(fp)
}
811065d8:	e037883a 	mov	sp,fp
811065dc:	dfc00117 	ldw	ra,4(sp)
811065e0:	df000017 	ldw	fp,0(sp)
811065e4:	dec00204 	addi	sp,sp,8
811065e8:	f800283a 	ret

811065ec <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
811065ec:	defffd04 	addi	sp,sp,-12
811065f0:	de00012e 	bgeu	sp,et,811065f8 <uliRmapCh5WriteCmdAddress+0xc>
811065f4:	003b68fa 	trap	3
811065f8:	dfc00215 	stw	ra,8(sp)
811065fc:	df000115 	stw	fp,4(sp)
81106600:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106604:	01400184 	movi	r5,6
81106608:	01204834 	movhi	r4,33056
8110660c:	21070004 	addi	r4,r4,7168
81106610:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106614:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106618:	e13fff17 	ldw	r4,-4(fp)
8110661c:	1108b380 	call	81108b38 <uliConvRmapCfgAddr>
81106620:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106624:	e0bfff17 	ldw	r2,-4(fp)
}
81106628:	e037883a 	mov	sp,fp
8110662c:	dfc00117 	ldw	ra,4(sp)
81106630:	df000017 	ldw	fp,0(sp)
81106634:	dec00204 	addi	sp,sp,8
81106638:	f800283a 	ret

8110663c <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
8110663c:	defffd04 	addi	sp,sp,-12
81106640:	de00012e 	bgeu	sp,et,81106648 <uliRmapCh6WriteCmdAddress+0xc>
81106644:	003b68fa 	trap	3
81106648:	dfc00215 	stw	ra,8(sp)
8110664c:	df000115 	stw	fp,4(sp)
81106650:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106654:	01400184 	movi	r5,6
81106658:	01204834 	movhi	r4,33056
8110665c:	21060004 	addi	r4,r4,6144
81106660:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106664:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106668:	e13fff17 	ldw	r4,-4(fp)
8110666c:	1108b380 	call	81108b38 <uliConvRmapCfgAddr>
81106670:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106674:	e0bfff17 	ldw	r2,-4(fp)
}
81106678:	e037883a 	mov	sp,fp
8110667c:	dfc00117 	ldw	ra,4(sp)
81106680:	df000017 	ldw	fp,0(sp)
81106684:	dec00204 	addi	sp,sp,8
81106688:	f800283a 	ret

8110668c <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
8110668c:	defffd04 	addi	sp,sp,-12
81106690:	de00012e 	bgeu	sp,et,81106698 <uliRmapCh7WriteCmdAddress+0xc>
81106694:	003b68fa 	trap	3
81106698:	dfc00215 	stw	ra,8(sp)
8110669c:	df000115 	stw	fp,4(sp)
811066a0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811066a4:	01400184 	movi	r5,6
811066a8:	01204834 	movhi	r4,33056
811066ac:	21050004 	addi	r4,r4,5120
811066b0:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811066b4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811066b8:	e13fff17 	ldw	r4,-4(fp)
811066bc:	1108b380 	call	81108b38 <uliConvRmapCfgAddr>
811066c0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811066c4:	e0bfff17 	ldw	r2,-4(fp)
}
811066c8:	e037883a 	mov	sp,fp
811066cc:	dfc00117 	ldw	ra,4(sp)
811066d0:	df000017 	ldw	fp,0(sp)
811066d4:	dec00204 	addi	sp,sp,8
811066d8:	f800283a 	ret

811066dc <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
811066dc:	defffd04 	addi	sp,sp,-12
811066e0:	de00012e 	bgeu	sp,et,811066e8 <uliRmapCh8WriteCmdAddress+0xc>
811066e4:	003b68fa 	trap	3
811066e8:	dfc00215 	stw	ra,8(sp)
811066ec:	df000115 	stw	fp,4(sp)
811066f0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811066f4:	01400184 	movi	r5,6
811066f8:	01204834 	movhi	r4,33056
811066fc:	21040004 	addi	r4,r4,4096
81106700:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106704:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106708:	e13fff17 	ldw	r4,-4(fp)
8110670c:	1108b380 	call	81108b38 <uliConvRmapCfgAddr>
81106710:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106714:	e0bfff17 	ldw	r2,-4(fp)
}
81106718:	e037883a 	mov	sp,fp
8110671c:	dfc00117 	ldw	ra,4(sp)
81106720:	df000017 	ldw	fp,0(sp)
81106724:	dec00204 	addi	sp,sp,8
81106728:	f800283a 	ret

8110672c <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
8110672c:	defffc04 	addi	sp,sp,-16
81106730:	de00012e 	bgeu	sp,et,81106738 <vRmapInitIrq+0xc>
81106734:	003b68fa 	trap	3
81106738:	dfc00315 	stw	ra,12(sp)
8110673c:	df000215 	stw	fp,8(sp)
81106740:	df000204 	addi	fp,sp,8
81106744:	2005883a 	mov	r2,r4
81106748:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
8110674c:	e0bfff03 	ldbu	r2,-4(fp)
81106750:	10c00228 	cmpgeui	r3,r2,8
81106754:	18004e1e 	bne	r3,zero,81106890 <vRmapInitIrq+0x164>
81106758:	100690ba 	slli	r3,r2,2
8110675c:	00a04434 	movhi	r2,33040
81106760:	1099dc04 	addi	r2,r2,26480
81106764:	1885883a 	add	r2,r3,r2
81106768:	10800017 	ldw	r2,0(r2)
8110676c:	1000683a 	jmp	r2
81106770:	81106790 	cmplti	r4,r16,16798
81106774:	811067b0 	cmpltui	r4,r16,16798
81106778:	811067d0 	cmplti	r4,r16,16799
8110677c:	811067f0 	cmpltui	r4,r16,16799
81106780:	81106810 	cmplti	r4,r16,16800
81106784:	81106830 	cmpltui	r4,r16,16800
81106788:	81106850 	cmplti	r4,r16,16801
8110678c:	81106870 	cmpltui	r4,r16,16801
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81106790:	d0a04604 	addi	r2,gp,-32488
81106794:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
81106798:	01a04434 	movhi	r6,33040
8110679c:	31977304 	addi	r6,r6,24012
811067a0:	e17ffe17 	ldw	r5,-8(fp)
811067a4:	010005c4 	movi	r4,23
811067a8:	1130f980 	call	81130f98 <alt_irq_register>
		break;
811067ac:	00003806 	br	81106890 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811067b0:	d0a04704 	addi	r2,gp,-32484
811067b4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
811067b8:	01a04434 	movhi	r6,33040
811067bc:	31978304 	addi	r6,r6,24076
811067c0:	e17ffe17 	ldw	r5,-8(fp)
811067c4:	01000544 	movi	r4,21
811067c8:	1130f980 	call	81130f98 <alt_irq_register>
		break;
811067cc:	00003006 	br	81106890 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811067d0:	d0a04804 	addi	r2,gp,-32480
811067d4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
811067d8:	01a04434 	movhi	r6,33040
811067dc:	31979304 	addi	r6,r6,24140
811067e0:	e17ffe17 	ldw	r5,-8(fp)
811067e4:	010004c4 	movi	r4,19
811067e8:	1130f980 	call	81130f98 <alt_irq_register>
		break;
811067ec:	00002806 	br	81106890 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
811067f0:	d0a04904 	addi	r2,gp,-32476
811067f4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
811067f8:	01a04434 	movhi	r6,33040
811067fc:	3197a304 	addi	r6,r6,24204
81106800:	e17ffe17 	ldw	r5,-8(fp)
81106804:	01000444 	movi	r4,17
81106808:	1130f980 	call	81130f98 <alt_irq_register>
		break;
8110680c:	00002006 	br	81106890 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81106810:	d0a04a04 	addi	r2,gp,-32472
81106814:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81106818:	01a04434 	movhi	r6,33040
8110681c:	3197b304 	addi	r6,r6,24268
81106820:	e17ffe17 	ldw	r5,-8(fp)
81106824:	01000244 	movi	r4,9
81106828:	1130f980 	call	81130f98 <alt_irq_register>
		break;
8110682c:	00001806 	br	81106890 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81106830:	d0a04b04 	addi	r2,gp,-32468
81106834:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81106838:	01a04434 	movhi	r6,33040
8110683c:	3197c304 	addi	r6,r6,24332
81106840:	e17ffe17 	ldw	r5,-8(fp)
81106844:	010001c4 	movi	r4,7
81106848:	1130f980 	call	81130f98 <alt_irq_register>
		break;
8110684c:	00001006 	br	81106890 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81106850:	d0a04c04 	addi	r2,gp,-32464
81106854:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81106858:	01a04434 	movhi	r6,33040
8110685c:	3197d304 	addi	r6,r6,24396
81106860:	e17ffe17 	ldw	r5,-8(fp)
81106864:	01000104 	movi	r4,4
81106868:	1130f980 	call	81130f98 <alt_irq_register>
		break;
8110686c:	00000806 	br	81106890 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81106870:	d0a04d04 	addi	r2,gp,-32460
81106874:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
81106878:	01a04434 	movhi	r6,33040
8110687c:	3197e304 	addi	r6,r6,24460
81106880:	e17ffe17 	ldw	r5,-8(fp)
81106884:	010000c4 	movi	r4,3
81106888:	1130f980 	call	81130f98 <alt_irq_register>
		break;
8110688c:	0001883a 	nop
	}
}
81106890:	0001883a 	nop
81106894:	e037883a 	mov	sp,fp
81106898:	dfc00117 	ldw	ra,4(sp)
8110689c:	df000017 	ldw	fp,0(sp)
811068a0:	dec00204 	addi	sp,sp,8
811068a4:	f800283a 	ret

811068a8 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
811068a8:	defffb04 	addi	sp,sp,-20
811068ac:	de00012e 	bgeu	sp,et,811068b4 <bRmapSetIrqControl+0xc>
811068b0:	003b68fa 	trap	3
811068b4:	dfc00415 	stw	ra,16(sp)
811068b8:	df000315 	stw	fp,12(sp)
811068bc:	df000304 	addi	fp,sp,12
811068c0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811068c4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811068c8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811068cc:	e0bfff17 	ldw	r2,-4(fp)
811068d0:	10001926 	beq	r2,zero,81106938 <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811068d4:	e0bfff17 	ldw	r2,-4(fp)
811068d8:	10800017 	ldw	r2,0(r2)
811068dc:	01400444 	movi	r5,17
811068e0:	1009883a 	mov	r4,r2
811068e4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811068e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
811068ec:	e0bfff17 	ldw	r2,-4(fp)
811068f0:	10801017 	ldw	r2,64(r2)
811068f4:	10000426 	beq	r2,zero,81106908 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
811068f8:	e0bffe17 	ldw	r2,-8(fp)
811068fc:	10800054 	ori	r2,r2,1
81106900:	e0bffe15 	stw	r2,-8(fp)
81106904:	00000406 	br	81106918 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81106908:	e0fffe17 	ldw	r3,-8(fp)
8110690c:	00bfff84 	movi	r2,-2
81106910:	1884703a 	and	r2,r3,r2
81106914:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106918:	e0bfff17 	ldw	r2,-4(fp)
8110691c:	10800017 	ldw	r2,0(r2)
81106920:	e1bffe17 	ldw	r6,-8(fp)
81106924:	01400444 	movi	r5,17
81106928:	1009883a 	mov	r4,r2
8110692c:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81106930:	00800044 	movi	r2,1
81106934:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106938:	e0bffd17 	ldw	r2,-12(fp)
}
8110693c:	e037883a 	mov	sp,fp
81106940:	dfc00117 	ldw	ra,4(sp)
81106944:	df000017 	ldw	fp,0(sp)
81106948:	dec00204 	addi	sp,sp,8
8110694c:	f800283a 	ret

81106950 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81106950:	defffb04 	addi	sp,sp,-20
81106954:	de00012e 	bgeu	sp,et,8110695c <bRmapGetIrqControl+0xc>
81106958:	003b68fa 	trap	3
8110695c:	dfc00415 	stw	ra,16(sp)
81106960:	df000315 	stw	fp,12(sp)
81106964:	df000304 	addi	fp,sp,12
81106968:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110696c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106970:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106974:	e0bfff17 	ldw	r2,-4(fp)
81106978:	10001126 	beq	r2,zero,811069c0 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110697c:	e0bfff17 	ldw	r2,-4(fp)
81106980:	10800017 	ldw	r2,0(r2)
81106984:	01400444 	movi	r5,17
81106988:	1009883a 	mov	r4,r2
8110698c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106990:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
81106994:	e0bffe17 	ldw	r2,-8(fp)
81106998:	1080004c 	andi	r2,r2,1
8110699c:	10000426 	beq	r2,zero,811069b0 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811069a0:	e0bfff17 	ldw	r2,-4(fp)
811069a4:	00c00044 	movi	r3,1
811069a8:	10c01015 	stw	r3,64(r2)
811069ac:	00000206 	br	811069b8 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811069b0:	e0bfff17 	ldw	r2,-4(fp)
811069b4:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
811069b8:	00800044 	movi	r2,1
811069bc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811069c0:	e0bffd17 	ldw	r2,-12(fp)
}
811069c4:	e037883a 	mov	sp,fp
811069c8:	dfc00117 	ldw	ra,4(sp)
811069cc:	df000017 	ldw	fp,0(sp)
811069d0:	dec00204 	addi	sp,sp,8
811069d4:	f800283a 	ret

811069d8 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
811069d8:	defffb04 	addi	sp,sp,-20
811069dc:	de00012e 	bgeu	sp,et,811069e4 <bRmapGetIrqFlags+0xc>
811069e0:	003b68fa 	trap	3
811069e4:	dfc00415 	stw	ra,16(sp)
811069e8:	df000315 	stw	fp,12(sp)
811069ec:	df000304 	addi	fp,sp,12
811069f0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811069f4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811069f8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811069fc:	e0bfff17 	ldw	r2,-4(fp)
81106a00:	10001126 	beq	r2,zero,81106a48 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106a04:	e0bfff17 	ldw	r2,-4(fp)
81106a08:	10800017 	ldw	r2,0(r2)
81106a0c:	01400484 	movi	r5,18
81106a10:	1009883a 	mov	r4,r2
81106a14:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106a18:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106a1c:	e0bffe17 	ldw	r2,-8(fp)
81106a20:	1080004c 	andi	r2,r2,1
81106a24:	10000426 	beq	r2,zero,81106a38 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81106a28:	e0bfff17 	ldw	r2,-4(fp)
81106a2c:	00c00044 	movi	r3,1
81106a30:	10c01115 	stw	r3,68(r2)
81106a34:	00000206 	br	81106a40 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81106a38:	e0bfff17 	ldw	r2,-4(fp)
81106a3c:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81106a40:	00800044 	movi	r2,1
81106a44:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106a48:	e0bffd17 	ldw	r2,-12(fp)
}
81106a4c:	e037883a 	mov	sp,fp
81106a50:	dfc00117 	ldw	ra,4(sp)
81106a54:	df000017 	ldw	fp,0(sp)
81106a58:	dec00204 	addi	sp,sp,8
81106a5c:	f800283a 	ret

81106a60 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81106a60:	defffb04 	addi	sp,sp,-20
81106a64:	de00012e 	bgeu	sp,et,81106a6c <bRmapSetCodecConfig+0xc>
81106a68:	003b68fa 	trap	3
81106a6c:	dfc00415 	stw	ra,16(sp)
81106a70:	df000315 	stw	fp,12(sp)
81106a74:	df000304 	addi	fp,sp,12
81106a78:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106a7c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106a80:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106a84:	e0bfff17 	ldw	r2,-4(fp)
81106a88:	10002526 	beq	r2,zero,81106b20 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106a8c:	e0bfff17 	ldw	r2,-4(fp)
81106a90:	10800017 	ldw	r2,0(r2)
81106a94:	01400104 	movi	r5,4
81106a98:	1009883a 	mov	r4,r2
81106a9c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106aa0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81106aa4:	e0fffe17 	ldw	r3,-8(fp)
81106aa8:	00bfc004 	movi	r2,-256
81106aac:	1884703a 	and	r2,r3,r2
81106ab0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81106ab4:	e0bfff17 	ldw	r2,-4(fp)
81106ab8:	10800143 	ldbu	r2,5(r2)
81106abc:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81106ac0:	e0fffe17 	ldw	r3,-8(fp)
81106ac4:	1884b03a 	or	r2,r3,r2
81106ac8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81106acc:	e0fffe17 	ldw	r3,-8(fp)
81106ad0:	00bffff4 	movhi	r2,65535
81106ad4:	10803fc4 	addi	r2,r2,255
81106ad8:	1884703a 	and	r2,r3,r2
81106adc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81106ae0:	e0bfff17 	ldw	r2,-4(fp)
81106ae4:	10800103 	ldbu	r2,4(r2)
81106ae8:	10803fcc 	andi	r2,r2,255
81106aec:	1004923a 	slli	r2,r2,8
81106af0:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81106af4:	e0fffe17 	ldw	r3,-8(fp)
81106af8:	1884b03a 	or	r2,r3,r2
81106afc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81106b00:	e0bfff17 	ldw	r2,-4(fp)
81106b04:	10800017 	ldw	r2,0(r2)
81106b08:	e1bffe17 	ldw	r6,-8(fp)
81106b0c:	01400104 	movi	r5,4
81106b10:	1009883a 	mov	r4,r2
81106b14:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81106b18:	00800044 	movi	r2,1
81106b1c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106b20:	e0bffd17 	ldw	r2,-12(fp)
}
81106b24:	e037883a 	mov	sp,fp
81106b28:	dfc00117 	ldw	ra,4(sp)
81106b2c:	df000017 	ldw	fp,0(sp)
81106b30:	dec00204 	addi	sp,sp,8
81106b34:	f800283a 	ret

81106b38 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81106b38:	defffb04 	addi	sp,sp,-20
81106b3c:	de00012e 	bgeu	sp,et,81106b44 <bRmapGetCodecConfig+0xc>
81106b40:	003b68fa 	trap	3
81106b44:	dfc00415 	stw	ra,16(sp)
81106b48:	df000315 	stw	fp,12(sp)
81106b4c:	df000304 	addi	fp,sp,12
81106b50:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106b54:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106b58:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106b5c:	e0bfff17 	ldw	r2,-4(fp)
81106b60:	10001226 	beq	r2,zero,81106bac <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106b64:	e0bfff17 	ldw	r2,-4(fp)
81106b68:	10800017 	ldw	r2,0(r2)
81106b6c:	01400104 	movi	r5,4
81106b70:	1009883a 	mov	r4,r2
81106b74:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106b78:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81106b7c:	e0bffe17 	ldw	r2,-8(fp)
81106b80:	1007883a 	mov	r3,r2
81106b84:	e0bfff17 	ldw	r2,-4(fp)
81106b88:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81106b8c:	e0bffe17 	ldw	r2,-8(fp)
81106b90:	10bfc00c 	andi	r2,r2,65280
81106b94:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81106b98:	1007883a 	mov	r3,r2
81106b9c:	e0bfff17 	ldw	r2,-4(fp)
81106ba0:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81106ba4:	00800044 	movi	r2,1
81106ba8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106bac:	e0bffd17 	ldw	r2,-12(fp)
}
81106bb0:	e037883a 	mov	sp,fp
81106bb4:	dfc00117 	ldw	ra,4(sp)
81106bb8:	df000017 	ldw	fp,0(sp)
81106bbc:	dec00204 	addi	sp,sp,8
81106bc0:	f800283a 	ret

81106bc4 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81106bc4:	defffb04 	addi	sp,sp,-20
81106bc8:	de00012e 	bgeu	sp,et,81106bd0 <bRmapGetCodecStatus+0xc>
81106bcc:	003b68fa 	trap	3
81106bd0:	dfc00415 	stw	ra,16(sp)
81106bd4:	df000315 	stw	fp,12(sp)
81106bd8:	df000304 	addi	fp,sp,12
81106bdc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106be0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106be4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106be8:	e0bfff17 	ldw	r2,-4(fp)
81106bec:	10004726 	beq	r2,zero,81106d0c <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106bf0:	e0bfff17 	ldw	r2,-4(fp)
81106bf4:	10800017 	ldw	r2,0(r2)
81106bf8:	01400144 	movi	r5,5
81106bfc:	1009883a 	mov	r4,r2
81106c00:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106c04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81106c08:	e0bffe17 	ldw	r2,-8(fp)
81106c0c:	1080004c 	andi	r2,r2,1
81106c10:	10000426 	beq	r2,zero,81106c24 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81106c14:	e0bfff17 	ldw	r2,-4(fp)
81106c18:	00c00044 	movi	r3,1
81106c1c:	10c00215 	stw	r3,8(r2)
81106c20:	00000206 	br	81106c2c <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81106c24:	e0bfff17 	ldw	r2,-4(fp)
81106c28:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81106c2c:	e0bffe17 	ldw	r2,-8(fp)
81106c30:	1080008c 	andi	r2,r2,2
81106c34:	10000426 	beq	r2,zero,81106c48 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81106c38:	e0bfff17 	ldw	r2,-4(fp)
81106c3c:	00c00044 	movi	r3,1
81106c40:	10c00315 	stw	r3,12(r2)
81106c44:	00000206 	br	81106c50 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81106c48:	e0bfff17 	ldw	r2,-4(fp)
81106c4c:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81106c50:	e0bffe17 	ldw	r2,-8(fp)
81106c54:	1080010c 	andi	r2,r2,4
81106c58:	10000426 	beq	r2,zero,81106c6c <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81106c5c:	e0bfff17 	ldw	r2,-4(fp)
81106c60:	00c00044 	movi	r3,1
81106c64:	10c00415 	stw	r3,16(r2)
81106c68:	00000206 	br	81106c74 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81106c6c:	e0bfff17 	ldw	r2,-4(fp)
81106c70:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81106c74:	e0bffe17 	ldw	r2,-8(fp)
81106c78:	1080020c 	andi	r2,r2,8
81106c7c:	10000426 	beq	r2,zero,81106c90 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81106c80:	e0bfff17 	ldw	r2,-4(fp)
81106c84:	00c00044 	movi	r3,1
81106c88:	10c00515 	stw	r3,20(r2)
81106c8c:	00000206 	br	81106c98 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81106c90:	e0bfff17 	ldw	r2,-4(fp)
81106c94:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81106c98:	e0bffe17 	ldw	r2,-8(fp)
81106c9c:	1080040c 	andi	r2,r2,16
81106ca0:	10000426 	beq	r2,zero,81106cb4 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81106ca4:	e0bfff17 	ldw	r2,-4(fp)
81106ca8:	00c00044 	movi	r3,1
81106cac:	10c00615 	stw	r3,24(r2)
81106cb0:	00000206 	br	81106cbc <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81106cb4:	e0bfff17 	ldw	r2,-4(fp)
81106cb8:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81106cbc:	e0bffe17 	ldw	r2,-8(fp)
81106cc0:	1080080c 	andi	r2,r2,32
81106cc4:	10000426 	beq	r2,zero,81106cd8 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81106cc8:	e0bfff17 	ldw	r2,-4(fp)
81106ccc:	00c00044 	movi	r3,1
81106cd0:	10c00715 	stw	r3,28(r2)
81106cd4:	00000206 	br	81106ce0 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81106cd8:	e0bfff17 	ldw	r2,-4(fp)
81106cdc:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81106ce0:	e0bffe17 	ldw	r2,-8(fp)
81106ce4:	1080100c 	andi	r2,r2,64
81106ce8:	10000426 	beq	r2,zero,81106cfc <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81106cec:	e0bfff17 	ldw	r2,-4(fp)
81106cf0:	00c00044 	movi	r3,1
81106cf4:	10c00815 	stw	r3,32(r2)
81106cf8:	00000206 	br	81106d04 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81106cfc:	e0bfff17 	ldw	r2,-4(fp)
81106d00:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81106d04:	00800044 	movi	r2,1
81106d08:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106d0c:	e0bffd17 	ldw	r2,-12(fp)
}
81106d10:	e037883a 	mov	sp,fp
81106d14:	dfc00117 	ldw	ra,4(sp)
81106d18:	df000017 	ldw	fp,0(sp)
81106d1c:	dec00204 	addi	sp,sp,8
81106d20:	f800283a 	ret

81106d24 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81106d24:	defffb04 	addi	sp,sp,-20
81106d28:	de00012e 	bgeu	sp,et,81106d30 <bRmapGetCodecError+0xc>
81106d2c:	003b68fa 	trap	3
81106d30:	dfc00415 	stw	ra,16(sp)
81106d34:	df000315 	stw	fp,12(sp)
81106d38:	df000304 	addi	fp,sp,12
81106d3c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106d40:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106d44:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106d48:	e0bfff17 	ldw	r2,-4(fp)
81106d4c:	10004726 	beq	r2,zero,81106e6c <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106d50:	e0bfff17 	ldw	r2,-4(fp)
81106d54:	10800017 	ldw	r2,0(r2)
81106d58:	01400144 	movi	r5,5
81106d5c:	1009883a 	mov	r4,r2
81106d60:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81106d64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81106d68:	e0bffe17 	ldw	r2,-8(fp)
81106d6c:	1080006c 	andhi	r2,r2,1
81106d70:	10000426 	beq	r2,zero,81106d84 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81106d74:	e0bfff17 	ldw	r2,-4(fp)
81106d78:	00c00044 	movi	r3,1
81106d7c:	10c00915 	stw	r3,36(r2)
81106d80:	00000206 	br	81106d8c <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81106d84:	e0bfff17 	ldw	r2,-4(fp)
81106d88:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81106d8c:	e0bffe17 	ldw	r2,-8(fp)
81106d90:	108000ac 	andhi	r2,r2,2
81106d94:	10000426 	beq	r2,zero,81106da8 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81106d98:	e0bfff17 	ldw	r2,-4(fp)
81106d9c:	00c00044 	movi	r3,1
81106da0:	10c00a15 	stw	r3,40(r2)
81106da4:	00000206 	br	81106db0 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81106da8:	e0bfff17 	ldw	r2,-4(fp)
81106dac:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81106db0:	e0bffe17 	ldw	r2,-8(fp)
81106db4:	1080012c 	andhi	r2,r2,4
81106db8:	10000426 	beq	r2,zero,81106dcc <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81106dbc:	e0bfff17 	ldw	r2,-4(fp)
81106dc0:	00c00044 	movi	r3,1
81106dc4:	10c00b15 	stw	r3,44(r2)
81106dc8:	00000206 	br	81106dd4 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81106dcc:	e0bfff17 	ldw	r2,-4(fp)
81106dd0:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81106dd4:	e0bffe17 	ldw	r2,-8(fp)
81106dd8:	1080022c 	andhi	r2,r2,8
81106ddc:	10000426 	beq	r2,zero,81106df0 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81106de0:	e0bfff17 	ldw	r2,-4(fp)
81106de4:	00c00044 	movi	r3,1
81106de8:	10c00c15 	stw	r3,48(r2)
81106dec:	00000206 	br	81106df8 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81106df0:	e0bfff17 	ldw	r2,-4(fp)
81106df4:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81106df8:	e0bffe17 	ldw	r2,-8(fp)
81106dfc:	1080042c 	andhi	r2,r2,16
81106e00:	10000426 	beq	r2,zero,81106e14 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81106e04:	e0bfff17 	ldw	r2,-4(fp)
81106e08:	00c00044 	movi	r3,1
81106e0c:	10c00d15 	stw	r3,52(r2)
81106e10:	00000206 	br	81106e1c <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81106e14:	e0bfff17 	ldw	r2,-4(fp)
81106e18:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81106e1c:	e0bffe17 	ldw	r2,-8(fp)
81106e20:	1080082c 	andhi	r2,r2,32
81106e24:	10000426 	beq	r2,zero,81106e38 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81106e28:	e0bfff17 	ldw	r2,-4(fp)
81106e2c:	00c00044 	movi	r3,1
81106e30:	10c00e15 	stw	r3,56(r2)
81106e34:	00000206 	br	81106e40 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81106e38:	e0bfff17 	ldw	r2,-4(fp)
81106e3c:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81106e40:	e0bffe17 	ldw	r2,-8(fp)
81106e44:	1080102c 	andhi	r2,r2,64
81106e48:	10000426 	beq	r2,zero,81106e5c <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81106e4c:	e0bfff17 	ldw	r2,-4(fp)
81106e50:	00c00044 	movi	r3,1
81106e54:	10c00f15 	stw	r3,60(r2)
81106e58:	00000206 	br	81106e64 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81106e5c:	e0bfff17 	ldw	r2,-4(fp)
81106e60:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81106e64:	00800044 	movi	r2,1
81106e68:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106e6c:	e0bffd17 	ldw	r2,-12(fp)
}
81106e70:	e037883a 	mov	sp,fp
81106e74:	dfc00117 	ldw	ra,4(sp)
81106e78:	df000017 	ldw	fp,0(sp)
81106e7c:	dec00204 	addi	sp,sp,8
81106e80:	f800283a 	ret

81106e84 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81106e84:	defffb04 	addi	sp,sp,-20
81106e88:	de00012e 	bgeu	sp,et,81106e90 <bRmapSetMemConfigArea+0xc>
81106e8c:	003b68fa 	trap	3
81106e90:	dfc00415 	stw	ra,16(sp)
81106e94:	df000315 	stw	fp,12(sp)
81106e98:	df000304 	addi	fp,sp,12
81106e9c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106ea0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106ea4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106ea8:	e0bfff17 	ldw	r2,-4(fp)
81106eac:	1000aa26 	beq	r2,zero,81107158 <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81106eb0:	e0bfff17 	ldw	r2,-4(fp)
81106eb4:	10801217 	ldw	r2,72(r2)
81106eb8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106ebc:	e0bfff17 	ldw	r2,-4(fp)
81106ec0:	10800017 	ldw	r2,0(r2)
81106ec4:	e1bffe17 	ldw	r6,-8(fp)
81106ec8:	01401004 	movi	r5,64
81106ecc:	1009883a 	mov	r4,r2
81106ed0:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81106ed4:	e0bfff17 	ldw	r2,-4(fp)
81106ed8:	10801317 	ldw	r2,76(r2)
81106edc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106ee0:	e0bfff17 	ldw	r2,-4(fp)
81106ee4:	10800017 	ldw	r2,0(r2)
81106ee8:	e1bffe17 	ldw	r6,-8(fp)
81106eec:	01401044 	movi	r5,65
81106ef0:	1009883a 	mov	r4,r2
81106ef4:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81106ef8:	e0bfff17 	ldw	r2,-4(fp)
81106efc:	10801417 	ldw	r2,80(r2)
81106f00:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f04:	e0bfff17 	ldw	r2,-4(fp)
81106f08:	10800017 	ldw	r2,0(r2)
81106f0c:	e1bffe17 	ldw	r6,-8(fp)
81106f10:	01401084 	movi	r5,66
81106f14:	1009883a 	mov	r4,r2
81106f18:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
81106f1c:	e0bfff17 	ldw	r2,-4(fp)
81106f20:	10801517 	ldw	r2,84(r2)
81106f24:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f28:	e0bfff17 	ldw	r2,-4(fp)
81106f2c:	10800017 	ldw	r2,0(r2)
81106f30:	e1bffe17 	ldw	r6,-8(fp)
81106f34:	014010c4 	movi	r5,67
81106f38:	1009883a 	mov	r4,r2
81106f3c:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81106f40:	e0bfff17 	ldw	r2,-4(fp)
81106f44:	10802217 	ldw	r2,136(r2)
81106f48:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f4c:	e0bfff17 	ldw	r2,-4(fp)
81106f50:	10800017 	ldw	r2,0(r2)
81106f54:	e1bffe17 	ldw	r6,-8(fp)
81106f58:	01401104 	movi	r5,68
81106f5c:	1009883a 	mov	r4,r2
81106f60:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81106f64:	e0bfff17 	ldw	r2,-4(fp)
81106f68:	10801717 	ldw	r2,92(r2)
81106f6c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f70:	e0bfff17 	ldw	r2,-4(fp)
81106f74:	10800017 	ldw	r2,0(r2)
81106f78:	e1bffe17 	ldw	r6,-8(fp)
81106f7c:	01401144 	movi	r5,69
81106f80:	1009883a 	mov	r4,r2
81106f84:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81106f88:	e0bfff17 	ldw	r2,-4(fp)
81106f8c:	10801817 	ldw	r2,96(r2)
81106f90:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f94:	e0bfff17 	ldw	r2,-4(fp)
81106f98:	10800017 	ldw	r2,0(r2)
81106f9c:	e1bffe17 	ldw	r6,-8(fp)
81106fa0:	01401184 	movi	r5,70
81106fa4:	1009883a 	mov	r4,r2
81106fa8:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81106fac:	e0bfff17 	ldw	r2,-4(fp)
81106fb0:	10801917 	ldw	r2,100(r2)
81106fb4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106fb8:	e0bfff17 	ldw	r2,-4(fp)
81106fbc:	10800017 	ldw	r2,0(r2)
81106fc0:	e1bffe17 	ldw	r6,-8(fp)
81106fc4:	014011c4 	movi	r5,71
81106fc8:	1009883a 	mov	r4,r2
81106fcc:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81106fd0:	e0bfff17 	ldw	r2,-4(fp)
81106fd4:	10801a17 	ldw	r2,104(r2)
81106fd8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106fdc:	e0bfff17 	ldw	r2,-4(fp)
81106fe0:	10800017 	ldw	r2,0(r2)
81106fe4:	e1bffe17 	ldw	r6,-8(fp)
81106fe8:	01401204 	movi	r5,72
81106fec:	1009883a 	mov	r4,r2
81106ff0:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81106ff4:	e0bfff17 	ldw	r2,-4(fp)
81106ff8:	10801b17 	ldw	r2,108(r2)
81106ffc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107000:	e0bfff17 	ldw	r2,-4(fp)
81107004:	10800017 	ldw	r2,0(r2)
81107008:	e1bffe17 	ldw	r6,-8(fp)
8110700c:	01401244 	movi	r5,73
81107010:	1009883a 	mov	r4,r2
81107014:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107018:	e0bfff17 	ldw	r2,-4(fp)
8110701c:	10800017 	ldw	r2,0(r2)
81107020:	01401284 	movi	r5,74
81107024:	1009883a 	mov	r4,r2
81107028:	1108ae80 	call	81108ae8 <uliRmapReadReg>
8110702c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
81107030:	e0bfff17 	ldw	r2,-4(fp)
81107034:	10801c17 	ldw	r2,112(r2)
81107038:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110703c:	e0bfff17 	ldw	r2,-4(fp)
81107040:	10800017 	ldw	r2,0(r2)
81107044:	e1bffe17 	ldw	r6,-8(fp)
81107048:	01401284 	movi	r5,74
8110704c:	1009883a 	mov	r4,r2
81107050:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81107054:	e0bfff17 	ldw	r2,-4(fp)
81107058:	10801d17 	ldw	r2,116(r2)
8110705c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107060:	e0bfff17 	ldw	r2,-4(fp)
81107064:	10800017 	ldw	r2,0(r2)
81107068:	e1bffe17 	ldw	r6,-8(fp)
8110706c:	014012c4 	movi	r5,75
81107070:	1009883a 	mov	r4,r2
81107074:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81107078:	e0bfff17 	ldw	r2,-4(fp)
8110707c:	10801e17 	ldw	r2,120(r2)
81107080:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81107084:	e0bfff17 	ldw	r2,-4(fp)
81107088:	10800017 	ldw	r2,0(r2)
8110708c:	e1bffe17 	ldw	r6,-8(fp)
81107090:	01401304 	movi	r5,76
81107094:	1009883a 	mov	r4,r2
81107098:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
8110709c:	e0bfff17 	ldw	r2,-4(fp)
811070a0:	10801f17 	ldw	r2,124(r2)
811070a4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
811070a8:	e0bfff17 	ldw	r2,-4(fp)
811070ac:	10800017 	ldw	r2,0(r2)
811070b0:	e1bffe17 	ldw	r6,-8(fp)
811070b4:	01401344 	movi	r5,77
811070b8:	1009883a 	mov	r4,r2
811070bc:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
811070c0:	e0bfff17 	ldw	r2,-4(fp)
811070c4:	10802017 	ldw	r2,128(r2)
811070c8:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
811070cc:	e0bfff17 	ldw	r2,-4(fp)
811070d0:	10800017 	ldw	r2,0(r2)
811070d4:	e1bffe17 	ldw	r6,-8(fp)
811070d8:	01401384 	movi	r5,78
811070dc:	1009883a 	mov	r4,r2
811070e0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811070e4:	e0bfff17 	ldw	r2,-4(fp)
811070e8:	10802217 	ldw	r2,136(r2)
811070ec:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811070f0:	e0bfff17 	ldw	r2,-4(fp)
811070f4:	10800017 	ldw	r2,0(r2)
811070f8:	e1bffe17 	ldw	r6,-8(fp)
811070fc:	014013c4 	movi	r5,79
81107100:	1009883a 	mov	r4,r2
81107104:	1108a940 	call	81108a94 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107108:	e0bfff17 	ldw	r2,-4(fp)
8110710c:	10802217 	ldw	r2,136(r2)
81107110:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81107114:	e0bfff17 	ldw	r2,-4(fp)
81107118:	10800017 	ldw	r2,0(r2)
8110711c:	e1bffe17 	ldw	r6,-8(fp)
81107120:	01401404 	movi	r5,80
81107124:	1009883a 	mov	r4,r2
81107128:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
8110712c:	e0bfff17 	ldw	r2,-4(fp)
81107130:	10802317 	ldw	r2,140(r2)
81107134:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
81107138:	e0bfff17 	ldw	r2,-4(fp)
8110713c:	10800017 	ldw	r2,0(r2)
81107140:	e1bffe17 	ldw	r6,-8(fp)
81107144:	01401444 	movi	r5,81
81107148:	1009883a 	mov	r4,r2
8110714c:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107150:	00800044 	movi	r2,1
81107154:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107158:	e0bffd17 	ldw	r2,-12(fp)
}
8110715c:	e037883a 	mov	sp,fp
81107160:	dfc00117 	ldw	ra,4(sp)
81107164:	df000017 	ldw	fp,0(sp)
81107168:	dec00204 	addi	sp,sp,8
8110716c:	f800283a 	ret

81107170 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81107170:	defffb04 	addi	sp,sp,-20
81107174:	de00012e 	bgeu	sp,et,8110717c <bRmapGetMemConfigArea+0xc>
81107178:	003b68fa 	trap	3
8110717c:	dfc00415 	stw	ra,16(sp)
81107180:	df000315 	stw	fp,12(sp)
81107184:	df000304 	addi	fp,sp,12
81107188:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110718c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107190:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107194:	e0bfff17 	ldw	r2,-4(fp)
81107198:	1000a426 	beq	r2,zero,8110742c <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110719c:	e0bfff17 	ldw	r2,-4(fp)
811071a0:	10800017 	ldw	r2,0(r2)
811071a4:	01401004 	movi	r5,64
811071a8:	1009883a 	mov	r4,r2
811071ac:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811071b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
811071b4:	e0bfff17 	ldw	r2,-4(fp)
811071b8:	e0fffe17 	ldw	r3,-8(fp)
811071bc:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811071c0:	e0bfff17 	ldw	r2,-4(fp)
811071c4:	10800017 	ldw	r2,0(r2)
811071c8:	01401044 	movi	r5,65
811071cc:	1009883a 	mov	r4,r2
811071d0:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811071d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
811071d8:	e0bfff17 	ldw	r2,-4(fp)
811071dc:	e0fffe17 	ldw	r3,-8(fp)
811071e0:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811071e4:	e0bfff17 	ldw	r2,-4(fp)
811071e8:	10800017 	ldw	r2,0(r2)
811071ec:	01401084 	movi	r5,66
811071f0:	1009883a 	mov	r4,r2
811071f4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811071f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
811071fc:	e0bfff17 	ldw	r2,-4(fp)
81107200:	e0fffe17 	ldw	r3,-8(fp)
81107204:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107208:	e0bfff17 	ldw	r2,-4(fp)
8110720c:	10800017 	ldw	r2,0(r2)
81107210:	014010c4 	movi	r5,67
81107214:	1009883a 	mov	r4,r2
81107218:	1108ae80 	call	81108ae8 <uliRmapReadReg>
8110721c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
81107220:	e0bfff17 	ldw	r2,-4(fp)
81107224:	e0fffe17 	ldw	r3,-8(fp)
81107228:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110722c:	e0bfff17 	ldw	r2,-4(fp)
81107230:	10800017 	ldw	r2,0(r2)
81107234:	01401104 	movi	r5,68
81107238:	1009883a 	mov	r4,r2
8110723c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107240:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107244:	e0bfff17 	ldw	r2,-4(fp)
81107248:	e0fffe17 	ldw	r3,-8(fp)
8110724c:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107250:	e0bfff17 	ldw	r2,-4(fp)
81107254:	10800017 	ldw	r2,0(r2)
81107258:	01401144 	movi	r5,69
8110725c:	1009883a 	mov	r4,r2
81107260:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107264:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81107268:	e0bfff17 	ldw	r2,-4(fp)
8110726c:	e0fffe17 	ldw	r3,-8(fp)
81107270:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107274:	e0bfff17 	ldw	r2,-4(fp)
81107278:	10800017 	ldw	r2,0(r2)
8110727c:	01401184 	movi	r5,70
81107280:	1009883a 	mov	r4,r2
81107284:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107288:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
8110728c:	e0bfff17 	ldw	r2,-4(fp)
81107290:	e0fffe17 	ldw	r3,-8(fp)
81107294:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107298:	e0bfff17 	ldw	r2,-4(fp)
8110729c:	10800017 	ldw	r2,0(r2)
811072a0:	014011c4 	movi	r5,71
811072a4:	1009883a 	mov	r4,r2
811072a8:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811072ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
811072b0:	e0bfff17 	ldw	r2,-4(fp)
811072b4:	e0fffe17 	ldw	r3,-8(fp)
811072b8:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811072bc:	e0bfff17 	ldw	r2,-4(fp)
811072c0:	10800017 	ldw	r2,0(r2)
811072c4:	01401204 	movi	r5,72
811072c8:	1009883a 	mov	r4,r2
811072cc:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811072d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
811072d4:	e0bfff17 	ldw	r2,-4(fp)
811072d8:	e0fffe17 	ldw	r3,-8(fp)
811072dc:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811072e0:	e0bfff17 	ldw	r2,-4(fp)
811072e4:	10800017 	ldw	r2,0(r2)
811072e8:	01401244 	movi	r5,73
811072ec:	1009883a 	mov	r4,r2
811072f0:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811072f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
811072f8:	e0bfff17 	ldw	r2,-4(fp)
811072fc:	e0fffe17 	ldw	r3,-8(fp)
81107300:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107304:	e0bfff17 	ldw	r2,-4(fp)
81107308:	10800017 	ldw	r2,0(r2)
8110730c:	01401284 	movi	r5,74
81107310:	1009883a 	mov	r4,r2
81107314:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107318:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
8110731c:	e0bfff17 	ldw	r2,-4(fp)
81107320:	e0fffe17 	ldw	r3,-8(fp)
81107324:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107328:	e0bfff17 	ldw	r2,-4(fp)
8110732c:	10800017 	ldw	r2,0(r2)
81107330:	014012c4 	movi	r5,75
81107334:	1009883a 	mov	r4,r2
81107338:	1108ae80 	call	81108ae8 <uliRmapReadReg>
8110733c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81107340:	e0bfff17 	ldw	r2,-4(fp)
81107344:	e0fffe17 	ldw	r3,-8(fp)
81107348:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110734c:	e0bfff17 	ldw	r2,-4(fp)
81107350:	10800017 	ldw	r2,0(r2)
81107354:	01401304 	movi	r5,76
81107358:	1009883a 	mov	r4,r2
8110735c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107360:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81107364:	e0bfff17 	ldw	r2,-4(fp)
81107368:	e0fffe17 	ldw	r3,-8(fp)
8110736c:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107370:	e0bfff17 	ldw	r2,-4(fp)
81107374:	10800017 	ldw	r2,0(r2)
81107378:	01401344 	movi	r5,77
8110737c:	1009883a 	mov	r4,r2
81107380:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107384:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
81107388:	e0bfff17 	ldw	r2,-4(fp)
8110738c:	e0fffe17 	ldw	r3,-8(fp)
81107390:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107394:	e0bfff17 	ldw	r2,-4(fp)
81107398:	10800017 	ldw	r2,0(r2)
8110739c:	01401384 	movi	r5,78
811073a0:	1009883a 	mov	r4,r2
811073a4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811073a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
811073ac:	e0bfff17 	ldw	r2,-4(fp)
811073b0:	e0fffe17 	ldw	r3,-8(fp)
811073b4:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811073b8:	e0bfff17 	ldw	r2,-4(fp)
811073bc:	10800017 	ldw	r2,0(r2)
811073c0:	014013c4 	movi	r5,79
811073c4:	1009883a 	mov	r4,r2
811073c8:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811073cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811073d0:	e0bfff17 	ldw	r2,-4(fp)
811073d4:	e0fffe17 	ldw	r3,-8(fp)
811073d8:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811073dc:	e0bfff17 	ldw	r2,-4(fp)
811073e0:	10800017 	ldw	r2,0(r2)
811073e4:	01401404 	movi	r5,80
811073e8:	1009883a 	mov	r4,r2
811073ec:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811073f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811073f4:	e0bfff17 	ldw	r2,-4(fp)
811073f8:	e0fffe17 	ldw	r3,-8(fp)
811073fc:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107400:	e0bfff17 	ldw	r2,-4(fp)
81107404:	10800017 	ldw	r2,0(r2)
81107408:	01401444 	movi	r5,81
8110740c:	1009883a 	mov	r4,r2
81107410:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107414:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
81107418:	e0bfff17 	ldw	r2,-4(fp)
8110741c:	e0fffe17 	ldw	r3,-8(fp)
81107420:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
81107424:	00800044 	movi	r2,1
81107428:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110742c:	e0bffd17 	ldw	r2,-12(fp)
}
81107430:	e037883a 	mov	sp,fp
81107434:	dfc00117 	ldw	ra,4(sp)
81107438:	df000017 	ldw	fp,0(sp)
8110743c:	dec00204 	addi	sp,sp,8
81107440:	f800283a 	ret

81107444 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81107444:	defffb04 	addi	sp,sp,-20
81107448:	de00012e 	bgeu	sp,et,81107450 <bRmapGetMemConfigStat+0xc>
8110744c:	003b68fa 	trap	3
81107450:	dfc00415 	stw	ra,16(sp)
81107454:	df000315 	stw	fp,12(sp)
81107458:	df000304 	addi	fp,sp,12
8110745c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107460:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107464:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107468:	e0bfff17 	ldw	r2,-4(fp)
8110746c:	10001426 	beq	r2,zero,811074c0 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107470:	e0bfff17 	ldw	r2,-4(fp)
81107474:	10800017 	ldw	r2,0(r2)
81107478:	014001c4 	movi	r5,7
8110747c:	1009883a 	mov	r4,r2
81107480:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107484:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
81107488:	e0bfff17 	ldw	r2,-4(fp)
8110748c:	e0fffe17 	ldw	r3,-8(fp)
81107490:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107494:	e0bfff17 	ldw	r2,-4(fp)
81107498:	10800017 	ldw	r2,0(r2)
8110749c:	01400184 	movi	r5,6
811074a0:	1009883a 	mov	r4,r2
811074a4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811074a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
811074ac:	e0bfff17 	ldw	r2,-4(fp)
811074b0:	e0fffe17 	ldw	r3,-8(fp)
811074b4:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
811074b8:	00800044 	movi	r2,1
811074bc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811074c0:	e0bffd17 	ldw	r2,-12(fp)
}
811074c4:	e037883a 	mov	sp,fp
811074c8:	dfc00117 	ldw	ra,4(sp)
811074cc:	df000017 	ldw	fp,0(sp)
811074d0:	dec00204 	addi	sp,sp,8
811074d4:	f800283a 	ret

811074d8 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811074d8:	defffb04 	addi	sp,sp,-20
811074dc:	de00012e 	bgeu	sp,et,811074e4 <bRmapSetRmapMemHKArea+0xc>
811074e0:	003b68fa 	trap	3
811074e4:	dfc00415 	stw	ra,16(sp)
811074e8:	df000315 	stw	fp,12(sp)
811074ec:	df000304 	addi	fp,sp,12
811074f0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811074f4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811074f8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811074fc:	e0bfff17 	ldw	r2,-4(fp)
81107500:	10030226 	beq	r2,zero,8110810c <bRmapSetRmapMemHKArea+0xc34>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107504:	e0bfff17 	ldw	r2,-4(fp)
81107508:	10800017 	ldw	r2,0(r2)
8110750c:	01402804 	movi	r5,160
81107510:	1009883a 	mov	r4,r2
81107514:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107518:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
8110751c:	e0bffe17 	ldw	r2,-8(fp)
81107520:	10bfffec 	andhi	r2,r2,65535
81107524:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
81107528:	e0bfff17 	ldw	r2,-4(fp)
8110752c:	1080260b 	ldhu	r2,152(r2)
81107530:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81107534:	e0fffe17 	ldw	r3,-8(fp)
81107538:	1884b03a 	or	r2,r3,r2
8110753c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81107540:	e0bffe17 	ldw	r2,-8(fp)
81107544:	10bfffcc 	andi	r2,r2,65535
81107548:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
8110754c:	e0bfff17 	ldw	r2,-4(fp)
81107550:	10800017 	ldw	r2,0(r2)
81107554:	e1bffe17 	ldw	r6,-8(fp)
81107558:	01402804 	movi	r5,160
8110755c:	1009883a 	mov	r4,r2
81107560:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107564:	e0bfff17 	ldw	r2,-4(fp)
81107568:	10800017 	ldw	r2,0(r2)
8110756c:	01402844 	movi	r5,161
81107570:	1009883a 	mov	r4,r2
81107574:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107578:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
8110757c:	e0bffe17 	ldw	r2,-8(fp)
81107580:	10bfffec 	andhi	r2,r2,65535
81107584:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
81107588:	e0bfff17 	ldw	r2,-4(fp)
8110758c:	1080270b 	ldhu	r2,156(r2)
81107590:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
81107594:	e0fffe17 	ldw	r3,-8(fp)
81107598:	1884b03a 	or	r2,r3,r2
8110759c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
811075a0:	e0bffe17 	ldw	r2,-8(fp)
811075a4:	10bfffcc 	andi	r2,r2,65535
811075a8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
811075ac:	e0bfff17 	ldw	r2,-4(fp)
811075b0:	10800017 	ldw	r2,0(r2)
811075b4:	e1bffe17 	ldw	r6,-8(fp)
811075b8:	01402844 	movi	r5,161
811075bc:	1009883a 	mov	r4,r2
811075c0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075c4:	e0bfff17 	ldw	r2,-4(fp)
811075c8:	10800017 	ldw	r2,0(r2)
811075cc:	01402884 	movi	r5,162
811075d0:	1009883a 	mov	r4,r2
811075d4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811075d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
811075dc:	e0bffe17 	ldw	r2,-8(fp)
811075e0:	10bfffec 	andhi	r2,r2,65535
811075e4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
811075e8:	e0bfff17 	ldw	r2,-4(fp)
811075ec:	1080280b 	ldhu	r2,160(r2)
811075f0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
811075f4:	e0fffe17 	ldw	r3,-8(fp)
811075f8:	1884b03a 	or	r2,r3,r2
811075fc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81107600:	e0bffe17 	ldw	r2,-8(fp)
81107604:	10bfffcc 	andi	r2,r2,65535
81107608:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
8110760c:	e0bfff17 	ldw	r2,-4(fp)
81107610:	10800017 	ldw	r2,0(r2)
81107614:	e1bffe17 	ldw	r6,-8(fp)
81107618:	01402884 	movi	r5,162
8110761c:	1009883a 	mov	r4,r2
81107620:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107624:	e0bfff17 	ldw	r2,-4(fp)
81107628:	10800017 	ldw	r2,0(r2)
8110762c:	014028c4 	movi	r5,163
81107630:	1009883a 	mov	r4,r2
81107634:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107638:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
8110763c:	e0bffe17 	ldw	r2,-8(fp)
81107640:	10bfffec 	andhi	r2,r2,65535
81107644:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
81107648:	e0bfff17 	ldw	r2,-4(fp)
8110764c:	1080290b 	ldhu	r2,164(r2)
81107650:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
81107654:	e0fffe17 	ldw	r3,-8(fp)
81107658:	1884b03a 	or	r2,r3,r2
8110765c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
81107660:	e0bffe17 	ldw	r2,-8(fp)
81107664:	10bfffcc 	andi	r2,r2,65535
81107668:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
8110766c:	e0bfff17 	ldw	r2,-4(fp)
81107670:	10800017 	ldw	r2,0(r2)
81107674:	e1bffe17 	ldw	r6,-8(fp)
81107678:	014028c4 	movi	r5,163
8110767c:	1009883a 	mov	r4,r2
81107680:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107684:	e0bfff17 	ldw	r2,-4(fp)
81107688:	10800017 	ldw	r2,0(r2)
8110768c:	01402904 	movi	r5,164
81107690:	1009883a 	mov	r4,r2
81107694:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107698:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
8110769c:	e0bffe17 	ldw	r2,-8(fp)
811076a0:	10bfffec 	andhi	r2,r2,65535
811076a4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
811076a8:	e0bfff17 	ldw	r2,-4(fp)
811076ac:	10802a0b 	ldhu	r2,168(r2)
811076b0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
811076b4:	e0fffe17 	ldw	r3,-8(fp)
811076b8:	1884b03a 	or	r2,r3,r2
811076bc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
811076c0:	e0bffe17 	ldw	r2,-8(fp)
811076c4:	10bfffcc 	andi	r2,r2,65535
811076c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
811076cc:	e0bfff17 	ldw	r2,-4(fp)
811076d0:	10800017 	ldw	r2,0(r2)
811076d4:	e1bffe17 	ldw	r6,-8(fp)
811076d8:	01402904 	movi	r5,164
811076dc:	1009883a 	mov	r4,r2
811076e0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076e4:	e0bfff17 	ldw	r2,-4(fp)
811076e8:	10800017 	ldw	r2,0(r2)
811076ec:	01402944 	movi	r5,165
811076f0:	1009883a 	mov	r4,r2
811076f4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811076f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
811076fc:	e0bffe17 	ldw	r2,-8(fp)
81107700:	10bfffec 	andhi	r2,r2,65535
81107704:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81107708:	e0bfff17 	ldw	r2,-4(fp)
8110770c:	10802b0b 	ldhu	r2,172(r2)
81107710:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
81107714:	e0fffe17 	ldw	r3,-8(fp)
81107718:	1884b03a 	or	r2,r3,r2
8110771c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
81107720:	e0bffe17 	ldw	r2,-8(fp)
81107724:	10bfffcc 	andi	r2,r2,65535
81107728:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
8110772c:	e0bfff17 	ldw	r2,-4(fp)
81107730:	10800017 	ldw	r2,0(r2)
81107734:	e1bffe17 	ldw	r6,-8(fp)
81107738:	01402944 	movi	r5,165
8110773c:	1009883a 	mov	r4,r2
81107740:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107744:	e0bfff17 	ldw	r2,-4(fp)
81107748:	10800017 	ldw	r2,0(r2)
8110774c:	01402984 	movi	r5,166
81107750:	1009883a 	mov	r4,r2
81107754:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107758:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
8110775c:	e0bffe17 	ldw	r2,-8(fp)
81107760:	10bfffec 	andhi	r2,r2,65535
81107764:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81107768:	e0bfff17 	ldw	r2,-4(fp)
8110776c:	10802c0b 	ldhu	r2,176(r2)
81107770:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81107774:	e0fffe17 	ldw	r3,-8(fp)
81107778:	1884b03a 	or	r2,r3,r2
8110777c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81107780:	e0bffe17 	ldw	r2,-8(fp)
81107784:	10bfffcc 	andi	r2,r2,65535
81107788:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
8110778c:	e0bfff17 	ldw	r2,-4(fp)
81107790:	10800017 	ldw	r2,0(r2)
81107794:	e1bffe17 	ldw	r6,-8(fp)
81107798:	01402984 	movi	r5,166
8110779c:	1009883a 	mov	r4,r2
811077a0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077a4:	e0bfff17 	ldw	r2,-4(fp)
811077a8:	10800017 	ldw	r2,0(r2)
811077ac:	014029c4 	movi	r5,167
811077b0:	1009883a 	mov	r4,r2
811077b4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811077b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
811077bc:	e0bffe17 	ldw	r2,-8(fp)
811077c0:	10bfffec 	andhi	r2,r2,65535
811077c4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
811077c8:	e0bfff17 	ldw	r2,-4(fp)
811077cc:	10802d0b 	ldhu	r2,180(r2)
811077d0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
811077d4:	e0fffe17 	ldw	r3,-8(fp)
811077d8:	1884b03a 	or	r2,r3,r2
811077dc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
811077e0:	e0bffe17 	ldw	r2,-8(fp)
811077e4:	10bfffcc 	andi	r2,r2,65535
811077e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
811077ec:	e0bfff17 	ldw	r2,-4(fp)
811077f0:	10800017 	ldw	r2,0(r2)
811077f4:	e1bffe17 	ldw	r6,-8(fp)
811077f8:	014029c4 	movi	r5,167
811077fc:	1009883a 	mov	r4,r2
81107800:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107804:	e0bfff17 	ldw	r2,-4(fp)
81107808:	10800017 	ldw	r2,0(r2)
8110780c:	01402a04 	movi	r5,168
81107810:	1009883a 	mov	r4,r2
81107814:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107818:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
8110781c:	e0bffe17 	ldw	r2,-8(fp)
81107820:	10bfffec 	andhi	r2,r2,65535
81107824:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81107828:	e0bfff17 	ldw	r2,-4(fp)
8110782c:	10802e0b 	ldhu	r2,184(r2)
81107830:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81107834:	e0fffe17 	ldw	r3,-8(fp)
81107838:	1884b03a 	or	r2,r3,r2
8110783c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81107840:	e0bffe17 	ldw	r2,-8(fp)
81107844:	10bfffcc 	andi	r2,r2,65535
81107848:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
8110784c:	e0bfff17 	ldw	r2,-4(fp)
81107850:	10800017 	ldw	r2,0(r2)
81107854:	e1bffe17 	ldw	r6,-8(fp)
81107858:	01402a04 	movi	r5,168
8110785c:	1009883a 	mov	r4,r2
81107860:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107864:	e0bfff17 	ldw	r2,-4(fp)
81107868:	10800017 	ldw	r2,0(r2)
8110786c:	01402a44 	movi	r5,169
81107870:	1009883a 	mov	r4,r2
81107874:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107878:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
8110787c:	e0bffe17 	ldw	r2,-8(fp)
81107880:	10bfffec 	andhi	r2,r2,65535
81107884:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
81107888:	e0bfff17 	ldw	r2,-4(fp)
8110788c:	10802f0b 	ldhu	r2,188(r2)
81107890:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
81107894:	e0fffe17 	ldw	r3,-8(fp)
81107898:	1884b03a 	or	r2,r3,r2
8110789c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
811078a0:	e0bffe17 	ldw	r2,-8(fp)
811078a4:	10bfffcc 	andi	r2,r2,65535
811078a8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
811078ac:	e0bfff17 	ldw	r2,-4(fp)
811078b0:	10800017 	ldw	r2,0(r2)
811078b4:	e1bffe17 	ldw	r6,-8(fp)
811078b8:	01402a44 	movi	r5,169
811078bc:	1009883a 	mov	r4,r2
811078c0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078c4:	e0bfff17 	ldw	r2,-4(fp)
811078c8:	10800017 	ldw	r2,0(r2)
811078cc:	01402a84 	movi	r5,170
811078d0:	1009883a 	mov	r4,r2
811078d4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811078d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
811078dc:	e0bffe17 	ldw	r2,-8(fp)
811078e0:	10bfffec 	andhi	r2,r2,65535
811078e4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
811078e8:	e0bfff17 	ldw	r2,-4(fp)
811078ec:	1080300b 	ldhu	r2,192(r2)
811078f0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
811078f4:	e0fffe17 	ldw	r3,-8(fp)
811078f8:	1884b03a 	or	r2,r3,r2
811078fc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81107900:	e0bffe17 	ldw	r2,-8(fp)
81107904:	10bfffcc 	andi	r2,r2,65535
81107908:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
8110790c:	e0bfff17 	ldw	r2,-4(fp)
81107910:	10800017 	ldw	r2,0(r2)
81107914:	e1bffe17 	ldw	r6,-8(fp)
81107918:	01402a84 	movi	r5,170
8110791c:	1009883a 	mov	r4,r2
81107920:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107924:	e0bfff17 	ldw	r2,-4(fp)
81107928:	10800017 	ldw	r2,0(r2)
8110792c:	01402ac4 	movi	r5,171
81107930:	1009883a 	mov	r4,r2
81107934:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107938:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
8110793c:	e0bffe17 	ldw	r2,-8(fp)
81107940:	10bfffec 	andhi	r2,r2,65535
81107944:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81107948:	e0bfff17 	ldw	r2,-4(fp)
8110794c:	1080310b 	ldhu	r2,196(r2)
81107950:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81107954:	e0fffe17 	ldw	r3,-8(fp)
81107958:	1884b03a 	or	r2,r3,r2
8110795c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81107960:	e0bffe17 	ldw	r2,-8(fp)
81107964:	10bfffcc 	andi	r2,r2,65535
81107968:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
8110796c:	e0bfff17 	ldw	r2,-4(fp)
81107970:	10800017 	ldw	r2,0(r2)
81107974:	e1bffe17 	ldw	r6,-8(fp)
81107978:	01402ac4 	movi	r5,171
8110797c:	1009883a 	mov	r4,r2
81107980:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107984:	e0bfff17 	ldw	r2,-4(fp)
81107988:	10800017 	ldw	r2,0(r2)
8110798c:	01402b04 	movi	r5,172
81107990:	1009883a 	mov	r4,r2
81107994:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107998:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
8110799c:	e0bffe17 	ldw	r2,-8(fp)
811079a0:	10bfffec 	andhi	r2,r2,65535
811079a4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
811079a8:	e0bfff17 	ldw	r2,-4(fp)
811079ac:	1080320b 	ldhu	r2,200(r2)
811079b0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
811079b4:	e0fffe17 	ldw	r3,-8(fp)
811079b8:	1884b03a 	or	r2,r3,r2
811079bc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
811079c0:	e0bffe17 	ldw	r2,-8(fp)
811079c4:	10bfffcc 	andi	r2,r2,65535
811079c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
811079cc:	e0bfff17 	ldw	r2,-4(fp)
811079d0:	10800017 	ldw	r2,0(r2)
811079d4:	e1bffe17 	ldw	r6,-8(fp)
811079d8:	01402b04 	movi	r5,172
811079dc:	1009883a 	mov	r4,r2
811079e0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079e4:	e0bfff17 	ldw	r2,-4(fp)
811079e8:	10800017 	ldw	r2,0(r2)
811079ec:	01402b44 	movi	r5,173
811079f0:	1009883a 	mov	r4,r2
811079f4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811079f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
811079fc:	e0bffe17 	ldw	r2,-8(fp)
81107a00:	10bfffec 	andhi	r2,r2,65535
81107a04:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81107a08:	e0bfff17 	ldw	r2,-4(fp)
81107a0c:	1080330b 	ldhu	r2,204(r2)
81107a10:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81107a14:	e0fffe17 	ldw	r3,-8(fp)
81107a18:	1884b03a 	or	r2,r3,r2
81107a1c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81107a20:	e0bffe17 	ldw	r2,-8(fp)
81107a24:	10bfffcc 	andi	r2,r2,65535
81107a28:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81107a2c:	e0bfff17 	ldw	r2,-4(fp)
81107a30:	10800017 	ldw	r2,0(r2)
81107a34:	e1bffe17 	ldw	r6,-8(fp)
81107a38:	01402b44 	movi	r5,173
81107a3c:	1009883a 	mov	r4,r2
81107a40:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a44:	e0bfff17 	ldw	r2,-4(fp)
81107a48:	10800017 	ldw	r2,0(r2)
81107a4c:	01402b84 	movi	r5,174
81107a50:	1009883a 	mov	r4,r2
81107a54:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107a58:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81107a5c:	e0bffe17 	ldw	r2,-8(fp)
81107a60:	10bfffec 	andhi	r2,r2,65535
81107a64:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81107a68:	e0bfff17 	ldw	r2,-4(fp)
81107a6c:	1080340b 	ldhu	r2,208(r2)
81107a70:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81107a74:	e0fffe17 	ldw	r3,-8(fp)
81107a78:	1884b03a 	or	r2,r3,r2
81107a7c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81107a80:	e0bffe17 	ldw	r2,-8(fp)
81107a84:	10bfffcc 	andi	r2,r2,65535
81107a88:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81107a8c:	e0bfff17 	ldw	r2,-4(fp)
81107a90:	10800017 	ldw	r2,0(r2)
81107a94:	e1bffe17 	ldw	r6,-8(fp)
81107a98:	01402b84 	movi	r5,174
81107a9c:	1009883a 	mov	r4,r2
81107aa0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107aa4:	e0bfff17 	ldw	r2,-4(fp)
81107aa8:	10800017 	ldw	r2,0(r2)
81107aac:	01402bc4 	movi	r5,175
81107ab0:	1009883a 	mov	r4,r2
81107ab4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107ab8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81107abc:	e0bffe17 	ldw	r2,-8(fp)
81107ac0:	10bfffec 	andhi	r2,r2,65535
81107ac4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81107ac8:	e0bfff17 	ldw	r2,-4(fp)
81107acc:	1080350b 	ldhu	r2,212(r2)
81107ad0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81107ad4:	e0fffe17 	ldw	r3,-8(fp)
81107ad8:	1884b03a 	or	r2,r3,r2
81107adc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81107ae0:	e0bffe17 	ldw	r2,-8(fp)
81107ae4:	10bfffcc 	andi	r2,r2,65535
81107ae8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81107aec:	e0bfff17 	ldw	r2,-4(fp)
81107af0:	10800017 	ldw	r2,0(r2)
81107af4:	e1bffe17 	ldw	r6,-8(fp)
81107af8:	01402bc4 	movi	r5,175
81107afc:	1009883a 	mov	r4,r2
81107b00:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b04:	e0bfff17 	ldw	r2,-4(fp)
81107b08:	10800017 	ldw	r2,0(r2)
81107b0c:	01402c04 	movi	r5,176
81107b10:	1009883a 	mov	r4,r2
81107b14:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107b18:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81107b1c:	e0bffe17 	ldw	r2,-8(fp)
81107b20:	10bfffec 	andhi	r2,r2,65535
81107b24:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81107b28:	e0bfff17 	ldw	r2,-4(fp)
81107b2c:	1080360b 	ldhu	r2,216(r2)
81107b30:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81107b34:	e0fffe17 	ldw	r3,-8(fp)
81107b38:	1884b03a 	or	r2,r3,r2
81107b3c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81107b40:	e0bffe17 	ldw	r2,-8(fp)
81107b44:	10bfffcc 	andi	r2,r2,65535
81107b48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81107b4c:	e0bfff17 	ldw	r2,-4(fp)
81107b50:	10800017 	ldw	r2,0(r2)
81107b54:	e1bffe17 	ldw	r6,-8(fp)
81107b58:	01402c04 	movi	r5,176
81107b5c:	1009883a 	mov	r4,r2
81107b60:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b64:	e0bfff17 	ldw	r2,-4(fp)
81107b68:	10800017 	ldw	r2,0(r2)
81107b6c:	01402c44 	movi	r5,177
81107b70:	1009883a 	mov	r4,r2
81107b74:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107b78:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81107b7c:	e0bffe17 	ldw	r2,-8(fp)
81107b80:	10bfffec 	andhi	r2,r2,65535
81107b84:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81107b88:	e0bfff17 	ldw	r2,-4(fp)
81107b8c:	1080370b 	ldhu	r2,220(r2)
81107b90:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81107b94:	e0fffe17 	ldw	r3,-8(fp)
81107b98:	1884b03a 	or	r2,r3,r2
81107b9c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81107ba0:	e0bffe17 	ldw	r2,-8(fp)
81107ba4:	10bfffcc 	andi	r2,r2,65535
81107ba8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81107bac:	e0bfff17 	ldw	r2,-4(fp)
81107bb0:	10800017 	ldw	r2,0(r2)
81107bb4:	e1bffe17 	ldw	r6,-8(fp)
81107bb8:	01402c44 	movi	r5,177
81107bbc:	1009883a 	mov	r4,r2
81107bc0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107bc4:	e0bfff17 	ldw	r2,-4(fp)
81107bc8:	10800017 	ldw	r2,0(r2)
81107bcc:	01402c84 	movi	r5,178
81107bd0:	1009883a 	mov	r4,r2
81107bd4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107bd8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81107bdc:	e0bffe17 	ldw	r2,-8(fp)
81107be0:	10bfffec 	andhi	r2,r2,65535
81107be4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81107be8:	e0bfff17 	ldw	r2,-4(fp)
81107bec:	1080380b 	ldhu	r2,224(r2)
81107bf0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81107bf4:	e0fffe17 	ldw	r3,-8(fp)
81107bf8:	1884b03a 	or	r2,r3,r2
81107bfc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81107c00:	e0bffe17 	ldw	r2,-8(fp)
81107c04:	10bfffcc 	andi	r2,r2,65535
81107c08:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81107c0c:	e0bfff17 	ldw	r2,-4(fp)
81107c10:	10800017 	ldw	r2,0(r2)
81107c14:	e1bffe17 	ldw	r6,-8(fp)
81107c18:	01402c84 	movi	r5,178
81107c1c:	1009883a 	mov	r4,r2
81107c20:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c24:	e0bfff17 	ldw	r2,-4(fp)
81107c28:	10800017 	ldw	r2,0(r2)
81107c2c:	01402cc4 	movi	r5,179
81107c30:	1009883a 	mov	r4,r2
81107c34:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107c38:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81107c3c:	e0bffe17 	ldw	r2,-8(fp)
81107c40:	10bfffec 	andhi	r2,r2,65535
81107c44:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81107c48:	e0bfff17 	ldw	r2,-4(fp)
81107c4c:	1080390b 	ldhu	r2,228(r2)
81107c50:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81107c54:	e0fffe17 	ldw	r3,-8(fp)
81107c58:	1884b03a 	or	r2,r3,r2
81107c5c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81107c60:	e0bffe17 	ldw	r2,-8(fp)
81107c64:	10bfffcc 	andi	r2,r2,65535
81107c68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81107c6c:	e0bfff17 	ldw	r2,-4(fp)
81107c70:	10800017 	ldw	r2,0(r2)
81107c74:	e1bffe17 	ldw	r6,-8(fp)
81107c78:	01402cc4 	movi	r5,179
81107c7c:	1009883a 	mov	r4,r2
81107c80:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c84:	e0bfff17 	ldw	r2,-4(fp)
81107c88:	10800017 	ldw	r2,0(r2)
81107c8c:	01402d04 	movi	r5,180
81107c90:	1009883a 	mov	r4,r2
81107c94:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107c98:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81107c9c:	e0bffe17 	ldw	r2,-8(fp)
81107ca0:	10bfffec 	andhi	r2,r2,65535
81107ca4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81107ca8:	e0bfff17 	ldw	r2,-4(fp)
81107cac:	10803a0b 	ldhu	r2,232(r2)
81107cb0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81107cb4:	e0fffe17 	ldw	r3,-8(fp)
81107cb8:	1884b03a 	or	r2,r3,r2
81107cbc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81107cc0:	e0bffe17 	ldw	r2,-8(fp)
81107cc4:	10bfffcc 	andi	r2,r2,65535
81107cc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81107ccc:	e0bfff17 	ldw	r2,-4(fp)
81107cd0:	10800017 	ldw	r2,0(r2)
81107cd4:	e1bffe17 	ldw	r6,-8(fp)
81107cd8:	01402d04 	movi	r5,180
81107cdc:	1009883a 	mov	r4,r2
81107ce0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ce4:	e0bfff17 	ldw	r2,-4(fp)
81107ce8:	10800017 	ldw	r2,0(r2)
81107cec:	01402d44 	movi	r5,181
81107cf0:	1009883a 	mov	r4,r2
81107cf4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107cf8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81107cfc:	e0bffe17 	ldw	r2,-8(fp)
81107d00:	10bfffec 	andhi	r2,r2,65535
81107d04:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81107d08:	e0bfff17 	ldw	r2,-4(fp)
81107d0c:	10803b0b 	ldhu	r2,236(r2)
81107d10:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81107d14:	e0fffe17 	ldw	r3,-8(fp)
81107d18:	1884b03a 	or	r2,r3,r2
81107d1c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81107d20:	e0bffe17 	ldw	r2,-8(fp)
81107d24:	10bfffcc 	andi	r2,r2,65535
81107d28:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81107d2c:	e0bfff17 	ldw	r2,-4(fp)
81107d30:	10800017 	ldw	r2,0(r2)
81107d34:	e1bffe17 	ldw	r6,-8(fp)
81107d38:	01402d44 	movi	r5,181
81107d3c:	1009883a 	mov	r4,r2
81107d40:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d44:	e0bfff17 	ldw	r2,-4(fp)
81107d48:	10800017 	ldw	r2,0(r2)
81107d4c:	01402d84 	movi	r5,182
81107d50:	1009883a 	mov	r4,r2
81107d54:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107d58:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
81107d5c:	e0bffe17 	ldw	r2,-8(fp)
81107d60:	10bfffec 	andhi	r2,r2,65535
81107d64:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81107d68:	e0bfff17 	ldw	r2,-4(fp)
81107d6c:	10803c0b 	ldhu	r2,240(r2)
81107d70:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81107d74:	e0fffe17 	ldw	r3,-8(fp)
81107d78:	1884b03a 	or	r2,r3,r2
81107d7c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81107d80:	e0bffe17 	ldw	r2,-8(fp)
81107d84:	10bfffcc 	andi	r2,r2,65535
81107d88:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81107d8c:	e0bfff17 	ldw	r2,-4(fp)
81107d90:	10800017 	ldw	r2,0(r2)
81107d94:	e1bffe17 	ldw	r6,-8(fp)
81107d98:	01402d84 	movi	r5,182
81107d9c:	1009883a 	mov	r4,r2
81107da0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107da4:	e0bfff17 	ldw	r2,-4(fp)
81107da8:	10800017 	ldw	r2,0(r2)
81107dac:	01402dc4 	movi	r5,183
81107db0:	1009883a 	mov	r4,r2
81107db4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107db8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81107dbc:	e0bffe17 	ldw	r2,-8(fp)
81107dc0:	10bfffec 	andhi	r2,r2,65535
81107dc4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81107dc8:	e0bfff17 	ldw	r2,-4(fp)
81107dcc:	10803d0b 	ldhu	r2,244(r2)
81107dd0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
81107dd4:	e0fffe17 	ldw	r3,-8(fp)
81107dd8:	1884b03a 	or	r2,r3,r2
81107ddc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
81107de0:	e0bffe17 	ldw	r2,-8(fp)
81107de4:	10bfffcc 	andi	r2,r2,65535
81107de8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
81107dec:	e0bfff17 	ldw	r2,-4(fp)
81107df0:	10800017 	ldw	r2,0(r2)
81107df4:	e1bffe17 	ldw	r6,-8(fp)
81107df8:	01402dc4 	movi	r5,183
81107dfc:	1009883a 	mov	r4,r2
81107e00:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e04:	e0bfff17 	ldw	r2,-4(fp)
81107e08:	10800017 	ldw	r2,0(r2)
81107e0c:	01402e04 	movi	r5,184
81107e10:	1009883a 	mov	r4,r2
81107e14:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107e18:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81107e1c:	e0bffe17 	ldw	r2,-8(fp)
81107e20:	10bfffec 	andhi	r2,r2,65535
81107e24:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81107e28:	e0bfff17 	ldw	r2,-4(fp)
81107e2c:	10803e0b 	ldhu	r2,248(r2)
81107e30:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81107e34:	e0fffe17 	ldw	r3,-8(fp)
81107e38:	1884b03a 	or	r2,r3,r2
81107e3c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81107e40:	e0bffe17 	ldw	r2,-8(fp)
81107e44:	10bfffcc 	andi	r2,r2,65535
81107e48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81107e4c:	e0bfff17 	ldw	r2,-4(fp)
81107e50:	10800017 	ldw	r2,0(r2)
81107e54:	e1bffe17 	ldw	r6,-8(fp)
81107e58:	01402e04 	movi	r5,184
81107e5c:	1009883a 	mov	r4,r2
81107e60:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e64:	e0bfff17 	ldw	r2,-4(fp)
81107e68:	10800017 	ldw	r2,0(r2)
81107e6c:	01402e44 	movi	r5,185
81107e70:	1009883a 	mov	r4,r2
81107e74:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107e78:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
81107e7c:	e0bffe17 	ldw	r2,-8(fp)
81107e80:	10bfffec 	andhi	r2,r2,65535
81107e84:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
81107e88:	e0bfff17 	ldw	r2,-4(fp)
81107e8c:	10803f0b 	ldhu	r2,252(r2)
81107e90:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
81107e94:	e0fffe17 	ldw	r3,-8(fp)
81107e98:	1884b03a 	or	r2,r3,r2
81107e9c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
81107ea0:	e0bffe17 	ldw	r2,-8(fp)
81107ea4:	10bfffcc 	andi	r2,r2,65535
81107ea8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
81107eac:	e0bfff17 	ldw	r2,-4(fp)
81107eb0:	10800017 	ldw	r2,0(r2)
81107eb4:	e1bffe17 	ldw	r6,-8(fp)
81107eb8:	01402e44 	movi	r5,185
81107ebc:	1009883a 	mov	r4,r2
81107ec0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ec4:	e0bfff17 	ldw	r2,-4(fp)
81107ec8:	10800017 	ldw	r2,0(r2)
81107ecc:	01402e84 	movi	r5,186
81107ed0:	1009883a 	mov	r4,r2
81107ed4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107ed8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81107edc:	e0bffe17 	ldw	r2,-8(fp)
81107ee0:	10bfffec 	andhi	r2,r2,65535
81107ee4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81107ee8:	e0bfff17 	ldw	r2,-4(fp)
81107eec:	1080400b 	ldhu	r2,256(r2)
81107ef0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81107ef4:	e0fffe17 	ldw	r3,-8(fp)
81107ef8:	1884b03a 	or	r2,r3,r2
81107efc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81107f00:	e0bffe17 	ldw	r2,-8(fp)
81107f04:	10bfffcc 	andi	r2,r2,65535
81107f08:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81107f0c:	e0bfff17 	ldw	r2,-4(fp)
81107f10:	10800017 	ldw	r2,0(r2)
81107f14:	e1bffe17 	ldw	r6,-8(fp)
81107f18:	01402e84 	movi	r5,186
81107f1c:	1009883a 	mov	r4,r2
81107f20:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f24:	e0bfff17 	ldw	r2,-4(fp)
81107f28:	10800017 	ldw	r2,0(r2)
81107f2c:	01402ec4 	movi	r5,187
81107f30:	1009883a 	mov	r4,r2
81107f34:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107f38:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
81107f3c:	e0bffe17 	ldw	r2,-8(fp)
81107f40:	10bfffec 	andhi	r2,r2,65535
81107f44:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
81107f48:	e0bfff17 	ldw	r2,-4(fp)
81107f4c:	1080410b 	ldhu	r2,260(r2)
81107f50:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
81107f54:	e0fffe17 	ldw	r3,-8(fp)
81107f58:	1884b03a 	or	r2,r3,r2
81107f5c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
81107f60:	e0bffe17 	ldw	r2,-8(fp)
81107f64:	10bfffcc 	andi	r2,r2,65535
81107f68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81107f6c:	e0bfff17 	ldw	r2,-4(fp)
81107f70:	10800017 	ldw	r2,0(r2)
81107f74:	e1bffe17 	ldw	r6,-8(fp)
81107f78:	01402ec4 	movi	r5,187
81107f7c:	1009883a 	mov	r4,r2
81107f80:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f84:	e0bfff17 	ldw	r2,-4(fp)
81107f88:	10800017 	ldw	r2,0(r2)
81107f8c:	01402f04 	movi	r5,188
81107f90:	1009883a 	mov	r4,r2
81107f94:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107f98:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81107f9c:	e0bffe17 	ldw	r2,-8(fp)
81107fa0:	10bfffec 	andhi	r2,r2,65535
81107fa4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81107fa8:	e0bfff17 	ldw	r2,-4(fp)
81107fac:	1080420b 	ldhu	r2,264(r2)
81107fb0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81107fb4:	e0fffe17 	ldw	r3,-8(fp)
81107fb8:	1884b03a 	or	r2,r3,r2
81107fbc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81107fc0:	e0bffe17 	ldw	r2,-8(fp)
81107fc4:	10bfffcc 	andi	r2,r2,65535
81107fc8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81107fcc:	e0bfff17 	ldw	r2,-4(fp)
81107fd0:	10800017 	ldw	r2,0(r2)
81107fd4:	e1bffe17 	ldw	r6,-8(fp)
81107fd8:	01402f04 	movi	r5,188
81107fdc:	1009883a 	mov	r4,r2
81107fe0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107fe4:	e0bfff17 	ldw	r2,-4(fp)
81107fe8:	10800017 	ldw	r2,0(r2)
81107fec:	01402f44 	movi	r5,189
81107ff0:	1009883a 	mov	r4,r2
81107ff4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81107ff8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
81107ffc:	e0bffe17 	ldw	r2,-8(fp)
81108000:	10bfffec 	andhi	r2,r2,65535
81108004:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
81108008:	e0bfff17 	ldw	r2,-4(fp)
8110800c:	1080430b 	ldhu	r2,268(r2)
81108010:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
81108014:	e0fffe17 	ldw	r3,-8(fp)
81108018:	1884b03a 	or	r2,r3,r2
8110801c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
81108020:	e0bffe17 	ldw	r2,-8(fp)
81108024:	10bfffcc 	andi	r2,r2,65535
81108028:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
8110802c:	e0bfff17 	ldw	r2,-4(fp)
81108030:	10800017 	ldw	r2,0(r2)
81108034:	e1bffe17 	ldw	r6,-8(fp)
81108038:	01402f44 	movi	r5,189
8110803c:	1009883a 	mov	r4,r2
81108040:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108044:	e0bfff17 	ldw	r2,-4(fp)
81108048:	10800017 	ldw	r2,0(r2)
8110804c:	01402f84 	movi	r5,190
81108050:	1009883a 	mov	r4,r2
81108054:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108058:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
8110805c:	e0bffe17 	ldw	r2,-8(fp)
81108060:	10bfffec 	andhi	r2,r2,65535
81108064:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81108068:	e0bfff17 	ldw	r2,-4(fp)
8110806c:	1080440b 	ldhu	r2,272(r2)
81108070:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81108074:	e0fffe17 	ldw	r3,-8(fp)
81108078:	1884b03a 	or	r2,r3,r2
8110807c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81108080:	e0bffe17 	ldw	r2,-8(fp)
81108084:	10bfffcc 	andi	r2,r2,65535
81108088:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
8110808c:	e0bfff17 	ldw	r2,-4(fp)
81108090:	10800017 	ldw	r2,0(r2)
81108094:	e1bffe17 	ldw	r6,-8(fp)
81108098:	01402f84 	movi	r5,190
8110809c:	1009883a 	mov	r4,r2
811080a0:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080a4:	e0bfff17 	ldw	r2,-4(fp)
811080a8:	10800017 	ldw	r2,0(r2)
811080ac:	01402fc4 	movi	r5,191
811080b0:	1009883a 	mov	r4,r2
811080b4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811080b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
811080bc:	e0bffe17 	ldw	r2,-8(fp)
811080c0:	10bfffec 	andhi	r2,r2,65535
811080c4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
811080c8:	e0bfff17 	ldw	r2,-4(fp)
811080cc:	1080450b 	ldhu	r2,276(r2)
811080d0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
811080d4:	e0fffe17 	ldw	r3,-8(fp)
811080d8:	1884b03a 	or	r2,r3,r2
811080dc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
811080e0:	e0bffe17 	ldw	r2,-8(fp)
811080e4:	10bfffcc 	andi	r2,r2,65535
811080e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
811080ec:	e0bfff17 	ldw	r2,-4(fp)
811080f0:	10800017 	ldw	r2,0(r2)
811080f4:	e1bffe17 	ldw	r6,-8(fp)
811080f8:	01402fc4 	movi	r5,191
811080fc:	1009883a 	mov	r4,r2
81108100:	1108a940 	call	81108a94 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108104:	00800044 	movi	r2,1
81108108:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110810c:	e0bffd17 	ldw	r2,-12(fp)
}
81108110:	e037883a 	mov	sp,fp
81108114:	dfc00117 	ldw	ra,4(sp)
81108118:	df000017 	ldw	fp,0(sp)
8110811c:	dec00204 	addi	sp,sp,8
81108120:	f800283a 	ret

81108124 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81108124:	defffb04 	addi	sp,sp,-20
81108128:	de00012e 	bgeu	sp,et,81108130 <bRmapGetRmapMemHKArea+0xc>
8110812c:	003b68fa 	trap	3
81108130:	dfc00415 	stw	ra,16(sp)
81108134:	df000315 	stw	fp,12(sp)
81108138:	df000304 	addi	fp,sp,12
8110813c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108140:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108144:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108148:	e0bfff17 	ldw	r2,-4(fp)
8110814c:	1001e226 	beq	r2,zero,811088d8 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108150:	e0bfff17 	ldw	r2,-4(fp)
81108154:	10800017 	ldw	r2,0(r2)
81108158:	01402804 	movi	r5,160
8110815c:	1009883a 	mov	r4,r2
81108160:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108164:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81108168:	e0bffe17 	ldw	r2,-8(fp)
8110816c:	1007883a 	mov	r3,r2
81108170:	e0bfff17 	ldw	r2,-4(fp)
81108174:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
81108178:	e0bffe17 	ldw	r2,-8(fp)
8110817c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81108180:	1007883a 	mov	r3,r2
81108184:	e0bfff17 	ldw	r2,-4(fp)
81108188:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110818c:	e0bfff17 	ldw	r2,-4(fp)
81108190:	10800017 	ldw	r2,0(r2)
81108194:	01402844 	movi	r5,161
81108198:	1009883a 	mov	r4,r2
8110819c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811081a0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
811081a4:	e0bffe17 	ldw	r2,-8(fp)
811081a8:	1007883a 	mov	r3,r2
811081ac:	e0bfff17 	ldw	r2,-4(fp)
811081b0:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
811081b4:	e0bffe17 	ldw	r2,-8(fp)
811081b8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
811081bc:	1007883a 	mov	r3,r2
811081c0:	e0bfff17 	ldw	r2,-4(fp)
811081c4:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081c8:	e0bfff17 	ldw	r2,-4(fp)
811081cc:	10800017 	ldw	r2,0(r2)
811081d0:	01402884 	movi	r5,162
811081d4:	1009883a 	mov	r4,r2
811081d8:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811081dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
811081e0:	e0bffe17 	ldw	r2,-8(fp)
811081e4:	1007883a 	mov	r3,r2
811081e8:	e0bfff17 	ldw	r2,-4(fp)
811081ec:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
811081f0:	e0bffe17 	ldw	r2,-8(fp)
811081f4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
811081f8:	1007883a 	mov	r3,r2
811081fc:	e0bfff17 	ldw	r2,-4(fp)
81108200:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108204:	e0bfff17 	ldw	r2,-4(fp)
81108208:	10800017 	ldw	r2,0(r2)
8110820c:	014028c4 	movi	r5,163
81108210:	1009883a 	mov	r4,r2
81108214:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108218:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
8110821c:	e0bffe17 	ldw	r2,-8(fp)
81108220:	1007883a 	mov	r3,r2
81108224:	e0bfff17 	ldw	r2,-4(fp)
81108228:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
8110822c:	e0bffe17 	ldw	r2,-8(fp)
81108230:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81108234:	1007883a 	mov	r3,r2
81108238:	e0bfff17 	ldw	r2,-4(fp)
8110823c:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108240:	e0bfff17 	ldw	r2,-4(fp)
81108244:	10800017 	ldw	r2,0(r2)
81108248:	01402904 	movi	r5,164
8110824c:	1009883a 	mov	r4,r2
81108250:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108254:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81108258:	e0bffe17 	ldw	r2,-8(fp)
8110825c:	1007883a 	mov	r3,r2
81108260:	e0bfff17 	ldw	r2,-4(fp)
81108264:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81108268:	e0bffe17 	ldw	r2,-8(fp)
8110826c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81108270:	1007883a 	mov	r3,r2
81108274:	e0bfff17 	ldw	r2,-4(fp)
81108278:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110827c:	e0bfff17 	ldw	r2,-4(fp)
81108280:	10800017 	ldw	r2,0(r2)
81108284:	01402944 	movi	r5,165
81108288:	1009883a 	mov	r4,r2
8110828c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108290:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81108294:	e0bffe17 	ldw	r2,-8(fp)
81108298:	1007883a 	mov	r3,r2
8110829c:	e0bfff17 	ldw	r2,-4(fp)
811082a0:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
811082a4:	e0bffe17 	ldw	r2,-8(fp)
811082a8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
811082ac:	1007883a 	mov	r3,r2
811082b0:	e0bfff17 	ldw	r2,-4(fp)
811082b4:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082b8:	e0bfff17 	ldw	r2,-4(fp)
811082bc:	10800017 	ldw	r2,0(r2)
811082c0:	01402984 	movi	r5,166
811082c4:	1009883a 	mov	r4,r2
811082c8:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811082cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811082d0:	e0bffe17 	ldw	r2,-8(fp)
811082d4:	1007883a 	mov	r3,r2
811082d8:	e0bfff17 	ldw	r2,-4(fp)
811082dc:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
811082e0:	e0bffe17 	ldw	r2,-8(fp)
811082e4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
811082e8:	1007883a 	mov	r3,r2
811082ec:	e0bfff17 	ldw	r2,-4(fp)
811082f0:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082f4:	e0bfff17 	ldw	r2,-4(fp)
811082f8:	10800017 	ldw	r2,0(r2)
811082fc:	014029c4 	movi	r5,167
81108300:	1009883a 	mov	r4,r2
81108304:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108308:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
8110830c:	e0bffe17 	ldw	r2,-8(fp)
81108310:	1007883a 	mov	r3,r2
81108314:	e0bfff17 	ldw	r2,-4(fp)
81108318:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
8110831c:	e0bffe17 	ldw	r2,-8(fp)
81108320:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
81108324:	1007883a 	mov	r3,r2
81108328:	e0bfff17 	ldw	r2,-4(fp)
8110832c:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108330:	e0bfff17 	ldw	r2,-4(fp)
81108334:	10800017 	ldw	r2,0(r2)
81108338:	01402a04 	movi	r5,168
8110833c:	1009883a 	mov	r4,r2
81108340:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108344:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81108348:	e0bffe17 	ldw	r2,-8(fp)
8110834c:	1007883a 	mov	r3,r2
81108350:	e0bfff17 	ldw	r2,-4(fp)
81108354:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81108358:	e0bffe17 	ldw	r2,-8(fp)
8110835c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81108360:	1007883a 	mov	r3,r2
81108364:	e0bfff17 	ldw	r2,-4(fp)
81108368:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110836c:	e0bfff17 	ldw	r2,-4(fp)
81108370:	10800017 	ldw	r2,0(r2)
81108374:	01402a44 	movi	r5,169
81108378:	1009883a 	mov	r4,r2
8110837c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108380:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81108384:	e0bffe17 	ldw	r2,-8(fp)
81108388:	1007883a 	mov	r3,r2
8110838c:	e0bfff17 	ldw	r2,-4(fp)
81108390:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
81108394:	e0bffe17 	ldw	r2,-8(fp)
81108398:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
8110839c:	1007883a 	mov	r3,r2
811083a0:	e0bfff17 	ldw	r2,-4(fp)
811083a4:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083a8:	e0bfff17 	ldw	r2,-4(fp)
811083ac:	10800017 	ldw	r2,0(r2)
811083b0:	01402a84 	movi	r5,170
811083b4:	1009883a 	mov	r4,r2
811083b8:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811083bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
811083c0:	e0bffe17 	ldw	r2,-8(fp)
811083c4:	1007883a 	mov	r3,r2
811083c8:	e0bfff17 	ldw	r2,-4(fp)
811083cc:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811083d0:	e0bffe17 	ldw	r2,-8(fp)
811083d4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
811083d8:	1007883a 	mov	r3,r2
811083dc:	e0bfff17 	ldw	r2,-4(fp)
811083e0:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083e4:	e0bfff17 	ldw	r2,-4(fp)
811083e8:	10800017 	ldw	r2,0(r2)
811083ec:	01402ac4 	movi	r5,171
811083f0:	1009883a 	mov	r4,r2
811083f4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811083f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
811083fc:	e0bffe17 	ldw	r2,-8(fp)
81108400:	1007883a 	mov	r3,r2
81108404:	e0bfff17 	ldw	r2,-4(fp)
81108408:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
8110840c:	e0bffe17 	ldw	r2,-8(fp)
81108410:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81108414:	1007883a 	mov	r3,r2
81108418:	e0bfff17 	ldw	r2,-4(fp)
8110841c:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108420:	e0bfff17 	ldw	r2,-4(fp)
81108424:	10800017 	ldw	r2,0(r2)
81108428:	01402b04 	movi	r5,172
8110842c:	1009883a 	mov	r4,r2
81108430:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108434:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81108438:	e0bffe17 	ldw	r2,-8(fp)
8110843c:	1007883a 	mov	r3,r2
81108440:	e0bfff17 	ldw	r2,-4(fp)
81108444:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81108448:	e0bffe17 	ldw	r2,-8(fp)
8110844c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81108450:	1007883a 	mov	r3,r2
81108454:	e0bfff17 	ldw	r2,-4(fp)
81108458:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110845c:	e0bfff17 	ldw	r2,-4(fp)
81108460:	10800017 	ldw	r2,0(r2)
81108464:	01402b44 	movi	r5,173
81108468:	1009883a 	mov	r4,r2
8110846c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108470:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81108474:	e0bffe17 	ldw	r2,-8(fp)
81108478:	1007883a 	mov	r3,r2
8110847c:	e0bfff17 	ldw	r2,-4(fp)
81108480:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81108484:	e0bffe17 	ldw	r2,-8(fp)
81108488:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
8110848c:	1007883a 	mov	r3,r2
81108490:	e0bfff17 	ldw	r2,-4(fp)
81108494:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108498:	e0bfff17 	ldw	r2,-4(fp)
8110849c:	10800017 	ldw	r2,0(r2)
811084a0:	01402b84 	movi	r5,174
811084a4:	1009883a 	mov	r4,r2
811084a8:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811084ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
811084b0:	e0bffe17 	ldw	r2,-8(fp)
811084b4:	1007883a 	mov	r3,r2
811084b8:	e0bfff17 	ldw	r2,-4(fp)
811084bc:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
811084c0:	e0bffe17 	ldw	r2,-8(fp)
811084c4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
811084c8:	1007883a 	mov	r3,r2
811084cc:	e0bfff17 	ldw	r2,-4(fp)
811084d0:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084d4:	e0bfff17 	ldw	r2,-4(fp)
811084d8:	10800017 	ldw	r2,0(r2)
811084dc:	01402bc4 	movi	r5,175
811084e0:	1009883a 	mov	r4,r2
811084e4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811084e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
811084ec:	e0bffe17 	ldw	r2,-8(fp)
811084f0:	1007883a 	mov	r3,r2
811084f4:	e0bfff17 	ldw	r2,-4(fp)
811084f8:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
811084fc:	e0bffe17 	ldw	r2,-8(fp)
81108500:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81108504:	1007883a 	mov	r3,r2
81108508:	e0bfff17 	ldw	r2,-4(fp)
8110850c:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108510:	e0bfff17 	ldw	r2,-4(fp)
81108514:	10800017 	ldw	r2,0(r2)
81108518:	01402c04 	movi	r5,176
8110851c:	1009883a 	mov	r4,r2
81108520:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108524:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81108528:	e0bffe17 	ldw	r2,-8(fp)
8110852c:	1007883a 	mov	r3,r2
81108530:	e0bfff17 	ldw	r2,-4(fp)
81108534:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81108538:	e0bffe17 	ldw	r2,-8(fp)
8110853c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81108540:	1007883a 	mov	r3,r2
81108544:	e0bfff17 	ldw	r2,-4(fp)
81108548:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110854c:	e0bfff17 	ldw	r2,-4(fp)
81108550:	10800017 	ldw	r2,0(r2)
81108554:	01402c44 	movi	r5,177
81108558:	1009883a 	mov	r4,r2
8110855c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108560:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81108564:	e0bffe17 	ldw	r2,-8(fp)
81108568:	1007883a 	mov	r3,r2
8110856c:	e0bfff17 	ldw	r2,-4(fp)
81108570:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81108574:	e0bffe17 	ldw	r2,-8(fp)
81108578:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
8110857c:	1007883a 	mov	r3,r2
81108580:	e0bfff17 	ldw	r2,-4(fp)
81108584:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108588:	e0bfff17 	ldw	r2,-4(fp)
8110858c:	10800017 	ldw	r2,0(r2)
81108590:	01402c84 	movi	r5,178
81108594:	1009883a 	mov	r4,r2
81108598:	1108ae80 	call	81108ae8 <uliRmapReadReg>
8110859c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
811085a0:	e0bffe17 	ldw	r2,-8(fp)
811085a4:	1007883a 	mov	r3,r2
811085a8:	e0bfff17 	ldw	r2,-4(fp)
811085ac:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
811085b0:	e0bffe17 	ldw	r2,-8(fp)
811085b4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
811085b8:	1007883a 	mov	r3,r2
811085bc:	e0bfff17 	ldw	r2,-4(fp)
811085c0:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085c4:	e0bfff17 	ldw	r2,-4(fp)
811085c8:	10800017 	ldw	r2,0(r2)
811085cc:	01402cc4 	movi	r5,179
811085d0:	1009883a 	mov	r4,r2
811085d4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811085d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
811085dc:	e0bffe17 	ldw	r2,-8(fp)
811085e0:	1007883a 	mov	r3,r2
811085e4:	e0bfff17 	ldw	r2,-4(fp)
811085e8:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
811085ec:	e0bffe17 	ldw	r2,-8(fp)
811085f0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
811085f4:	1007883a 	mov	r3,r2
811085f8:	e0bfff17 	ldw	r2,-4(fp)
811085fc:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108600:	e0bfff17 	ldw	r2,-4(fp)
81108604:	10800017 	ldw	r2,0(r2)
81108608:	01402d04 	movi	r5,180
8110860c:	1009883a 	mov	r4,r2
81108610:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108614:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81108618:	e0bffe17 	ldw	r2,-8(fp)
8110861c:	1007883a 	mov	r3,r2
81108620:	e0bfff17 	ldw	r2,-4(fp)
81108624:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81108628:	e0bffe17 	ldw	r2,-8(fp)
8110862c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81108630:	1007883a 	mov	r3,r2
81108634:	e0bfff17 	ldw	r2,-4(fp)
81108638:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110863c:	e0bfff17 	ldw	r2,-4(fp)
81108640:	10800017 	ldw	r2,0(r2)
81108644:	01402d44 	movi	r5,181
81108648:	1009883a 	mov	r4,r2
8110864c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108650:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81108654:	e0bffe17 	ldw	r2,-8(fp)
81108658:	1007883a 	mov	r3,r2
8110865c:	e0bfff17 	ldw	r2,-4(fp)
81108660:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81108664:	e0bffe17 	ldw	r2,-8(fp)
81108668:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
8110866c:	1007883a 	mov	r3,r2
81108670:	e0bfff17 	ldw	r2,-4(fp)
81108674:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108678:	e0bfff17 	ldw	r2,-4(fp)
8110867c:	10800017 	ldw	r2,0(r2)
81108680:	01402d84 	movi	r5,182
81108684:	1009883a 	mov	r4,r2
81108688:	1108ae80 	call	81108ae8 <uliRmapReadReg>
8110868c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81108690:	e0bffe17 	ldw	r2,-8(fp)
81108694:	1007883a 	mov	r3,r2
81108698:	e0bfff17 	ldw	r2,-4(fp)
8110869c:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
811086a0:	e0bffe17 	ldw	r2,-8(fp)
811086a4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
811086a8:	1007883a 	mov	r3,r2
811086ac:	e0bfff17 	ldw	r2,-4(fp)
811086b0:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086b4:	e0bfff17 	ldw	r2,-4(fp)
811086b8:	10800017 	ldw	r2,0(r2)
811086bc:	01402dc4 	movi	r5,183
811086c0:	1009883a 	mov	r4,r2
811086c4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811086c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
811086cc:	e0bffe17 	ldw	r2,-8(fp)
811086d0:	1007883a 	mov	r3,r2
811086d4:	e0bfff17 	ldw	r2,-4(fp)
811086d8:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
811086dc:	e0bffe17 	ldw	r2,-8(fp)
811086e0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
811086e4:	1007883a 	mov	r3,r2
811086e8:	e0bfff17 	ldw	r2,-4(fp)
811086ec:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086f0:	e0bfff17 	ldw	r2,-4(fp)
811086f4:	10800017 	ldw	r2,0(r2)
811086f8:	01402e04 	movi	r5,184
811086fc:	1009883a 	mov	r4,r2
81108700:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108704:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81108708:	e0bffe17 	ldw	r2,-8(fp)
8110870c:	1007883a 	mov	r3,r2
81108710:	e0bfff17 	ldw	r2,-4(fp)
81108714:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81108718:	e0bffe17 	ldw	r2,-8(fp)
8110871c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81108720:	1007883a 	mov	r3,r2
81108724:	e0bfff17 	ldw	r2,-4(fp)
81108728:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110872c:	e0bfff17 	ldw	r2,-4(fp)
81108730:	10800017 	ldw	r2,0(r2)
81108734:	01402e44 	movi	r5,185
81108738:	1009883a 	mov	r4,r2
8110873c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108740:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81108744:	e0bffe17 	ldw	r2,-8(fp)
81108748:	1007883a 	mov	r3,r2
8110874c:	e0bfff17 	ldw	r2,-4(fp)
81108750:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81108754:	e0bffe17 	ldw	r2,-8(fp)
81108758:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
8110875c:	1007883a 	mov	r3,r2
81108760:	e0bfff17 	ldw	r2,-4(fp)
81108764:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108768:	e0bfff17 	ldw	r2,-4(fp)
8110876c:	10800017 	ldw	r2,0(r2)
81108770:	01402e84 	movi	r5,186
81108774:	1009883a 	mov	r4,r2
81108778:	1108ae80 	call	81108ae8 <uliRmapReadReg>
8110877c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81108780:	e0bffe17 	ldw	r2,-8(fp)
81108784:	1007883a 	mov	r3,r2
81108788:	e0bfff17 	ldw	r2,-4(fp)
8110878c:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81108790:	e0bffe17 	ldw	r2,-8(fp)
81108794:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81108798:	1007883a 	mov	r3,r2
8110879c:	e0bfff17 	ldw	r2,-4(fp)
811087a0:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087a4:	e0bfff17 	ldw	r2,-4(fp)
811087a8:	10800017 	ldw	r2,0(r2)
811087ac:	01402ec4 	movi	r5,187
811087b0:	1009883a 	mov	r4,r2
811087b4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811087b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
811087bc:	e0bffe17 	ldw	r2,-8(fp)
811087c0:	1007883a 	mov	r3,r2
811087c4:	e0bfff17 	ldw	r2,-4(fp)
811087c8:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
811087cc:	e0bffe17 	ldw	r2,-8(fp)
811087d0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
811087d4:	1007883a 	mov	r3,r2
811087d8:	e0bfff17 	ldw	r2,-4(fp)
811087dc:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087e0:	e0bfff17 	ldw	r2,-4(fp)
811087e4:	10800017 	ldw	r2,0(r2)
811087e8:	01402f04 	movi	r5,188
811087ec:	1009883a 	mov	r4,r2
811087f0:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811087f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
811087f8:	e0bffe17 	ldw	r2,-8(fp)
811087fc:	1007883a 	mov	r3,r2
81108800:	e0bfff17 	ldw	r2,-4(fp)
81108804:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81108808:	e0bffe17 	ldw	r2,-8(fp)
8110880c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81108810:	1007883a 	mov	r3,r2
81108814:	e0bfff17 	ldw	r2,-4(fp)
81108818:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110881c:	e0bfff17 	ldw	r2,-4(fp)
81108820:	10800017 	ldw	r2,0(r2)
81108824:	01402f44 	movi	r5,189
81108828:	1009883a 	mov	r4,r2
8110882c:	1108ae80 	call	81108ae8 <uliRmapReadReg>
81108830:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81108834:	e0bffe17 	ldw	r2,-8(fp)
81108838:	1007883a 	mov	r3,r2
8110883c:	e0bfff17 	ldw	r2,-4(fp)
81108840:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81108844:	e0bffe17 	ldw	r2,-8(fp)
81108848:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
8110884c:	1007883a 	mov	r3,r2
81108850:	e0bfff17 	ldw	r2,-4(fp)
81108854:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108858:	e0bfff17 	ldw	r2,-4(fp)
8110885c:	10800017 	ldw	r2,0(r2)
81108860:	01402f84 	movi	r5,190
81108864:	1009883a 	mov	r4,r2
81108868:	1108ae80 	call	81108ae8 <uliRmapReadReg>
8110886c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81108870:	e0bffe17 	ldw	r2,-8(fp)
81108874:	1007883a 	mov	r3,r2
81108878:	e0bfff17 	ldw	r2,-4(fp)
8110887c:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81108880:	e0bffe17 	ldw	r2,-8(fp)
81108884:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81108888:	1007883a 	mov	r3,r2
8110888c:	e0bfff17 	ldw	r2,-4(fp)
81108890:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108894:	e0bfff17 	ldw	r2,-4(fp)
81108898:	10800017 	ldw	r2,0(r2)
8110889c:	01402fc4 	movi	r5,191
811088a0:	1009883a 	mov	r4,r2
811088a4:	1108ae80 	call	81108ae8 <uliRmapReadReg>
811088a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
811088ac:	e0bffe17 	ldw	r2,-8(fp)
811088b0:	1007883a 	mov	r3,r2
811088b4:	e0bfff17 	ldw	r2,-4(fp)
811088b8:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
811088bc:	e0bffe17 	ldw	r2,-8(fp)
811088c0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
811088c4:	1007883a 	mov	r3,r2
811088c8:	e0bfff17 	ldw	r2,-4(fp)
811088cc:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
811088d0:	00800044 	movi	r2,1
811088d4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811088d8:	e0bffd17 	ldw	r2,-12(fp)
}
811088dc:	e037883a 	mov	sp,fp
811088e0:	dfc00117 	ldw	ra,4(sp)
811088e4:	df000017 	ldw	fp,0(sp)
811088e8:	dec00204 	addi	sp,sp,8
811088ec:	f800283a 	ret

811088f0 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
811088f0:	defffb04 	addi	sp,sp,-20
811088f4:	de00012e 	bgeu	sp,et,811088fc <bRmapInitCh+0xc>
811088f8:	003b68fa 	trap	3
811088fc:	dfc00415 	stw	ra,16(sp)
81108900:	df000315 	stw	fp,12(sp)
81108904:	df000304 	addi	fp,sp,12
81108908:	e13ffe15 	stw	r4,-8(fp)
8110890c:	2805883a 	mov	r2,r5
81108910:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81108914:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81108918:	e0bffe17 	ldw	r2,-8(fp)
8110891c:	10005726 	beq	r2,zero,81108a7c <bRmapInitCh+0x18c>
		bStatus = TRUE;
81108920:	00800044 	movi	r2,1
81108924:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81108928:	e0bfff03 	ldbu	r2,-4(fp)
8110892c:	10c00228 	cmpgeui	r3,r2,8
81108930:	1800361e 	bne	r3,zero,81108a0c <bRmapInitCh+0x11c>
81108934:	100690ba 	slli	r3,r2,2
81108938:	00a04474 	movhi	r2,33041
8110893c:	10a25304 	addi	r2,r2,-30388
81108940:	1885883a 	add	r2,r3,r2
81108944:	10800017 	ldw	r2,0(r2)
81108948:	1000683a 	jmp	r2
8110894c:	8110896c 	andhi	r4,r16,16933
81108950:	81108980 	call	88110898 <__reset+0x20f0898>
81108954:	81108994 	ori	r4,r16,16934
81108958:	811089a8 	cmpgeui	r4,r16,16934
8110895c:	811089bc 	xorhi	r4,r16,16934
81108960:	811089d0 	cmplti	r4,r16,16935
81108964:	811089e4 	muli	r4,r16,16935
81108968:	811089f8 	rdprs	r4,r16,16935
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110896c:	e0fffe17 	ldw	r3,-8(fp)
81108970:	00a04834 	movhi	r2,33056
81108974:	108b0004 	addi	r2,r2,11264
81108978:	18800015 	stw	r2,0(r3)
			break;
8110897c:	00002506 	br	81108a14 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81108980:	e0fffe17 	ldw	r3,-8(fp)
81108984:	00a04834 	movhi	r2,33056
81108988:	108a0004 	addi	r2,r2,10240
8110898c:	18800015 	stw	r2,0(r3)
			break;
81108990:	00002006 	br	81108a14 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81108994:	e0fffe17 	ldw	r3,-8(fp)
81108998:	00a04834 	movhi	r2,33056
8110899c:	10890004 	addi	r2,r2,9216
811089a0:	18800015 	stw	r2,0(r3)
			break;
811089a4:	00001b06 	br	81108a14 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811089a8:	e0fffe17 	ldw	r3,-8(fp)
811089ac:	00a04834 	movhi	r2,33056
811089b0:	10880004 	addi	r2,r2,8192
811089b4:	18800015 	stw	r2,0(r3)
			break;
811089b8:	00001606 	br	81108a14 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811089bc:	e0fffe17 	ldw	r3,-8(fp)
811089c0:	00a04834 	movhi	r2,33056
811089c4:	10870004 	addi	r2,r2,7168
811089c8:	18800015 	stw	r2,0(r3)
			break;
811089cc:	00001106 	br	81108a14 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811089d0:	e0fffe17 	ldw	r3,-8(fp)
811089d4:	00a04834 	movhi	r2,33056
811089d8:	10860004 	addi	r2,r2,6144
811089dc:	18800015 	stw	r2,0(r3)
			break;
811089e0:	00000c06 	br	81108a14 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
811089e4:	e0fffe17 	ldw	r3,-8(fp)
811089e8:	00a04834 	movhi	r2,33056
811089ec:	10850004 	addi	r2,r2,5120
811089f0:	18800015 	stw	r2,0(r3)
			break;
811089f4:	00000706 	br	81108a14 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
811089f8:	e0fffe17 	ldw	r3,-8(fp)
811089fc:	00a04834 	movhi	r2,33056
81108a00:	10840004 	addi	r2,r2,4096
81108a04:	18800015 	stw	r2,0(r3)
			break;
81108a08:	00000206 	br	81108a14 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81108a0c:	e03ffd15 	stw	zero,-12(fp)
			break;
81108a10:	0001883a 	nop
		}

		if (bStatus) {
81108a14:	e0bffd17 	ldw	r2,-12(fp)
81108a18:	10001826 	beq	r2,zero,81108a7c <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81108a1c:	e13ffe17 	ldw	r4,-8(fp)
81108a20:	11069500 	call	81106950 <bRmapGetIrqControl>
81108a24:	1000011e 	bne	r2,zero,81108a2c <bRmapInitCh+0x13c>
				bStatus = FALSE;
81108a28:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81108a2c:	e13ffe17 	ldw	r4,-8(fp)
81108a30:	1106b380 	call	81106b38 <bRmapGetCodecConfig>
81108a34:	1000011e 	bne	r2,zero,81108a3c <bRmapInitCh+0x14c>
				bStatus = FALSE;
81108a38:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81108a3c:	e13ffe17 	ldw	r4,-8(fp)
81108a40:	1106bc40 	call	81106bc4 <bRmapGetCodecStatus>
81108a44:	1000011e 	bne	r2,zero,81108a4c <bRmapInitCh+0x15c>
				bStatus = FALSE;
81108a48:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81108a4c:	e13ffe17 	ldw	r4,-8(fp)
81108a50:	11071700 	call	81107170 <bRmapGetMemConfigArea>
81108a54:	1000011e 	bne	r2,zero,81108a5c <bRmapInitCh+0x16c>
				bStatus = FALSE;
81108a58:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81108a5c:	e13ffe17 	ldw	r4,-8(fp)
81108a60:	11074440 	call	81107444 <bRmapGetMemConfigStat>
81108a64:	1000011e 	bne	r2,zero,81108a6c <bRmapInitCh+0x17c>
				bStatus = FALSE;
81108a68:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81108a6c:	e13ffe17 	ldw	r4,-8(fp)
81108a70:	11081240 	call	81108124 <bRmapGetRmapMemHKArea>
81108a74:	1000011e 	bne	r2,zero,81108a7c <bRmapInitCh+0x18c>
				bStatus = FALSE;
81108a78:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81108a7c:	e0bffd17 	ldw	r2,-12(fp)
}
81108a80:	e037883a 	mov	sp,fp
81108a84:	dfc00117 	ldw	ra,4(sp)
81108a88:	df000017 	ldw	fp,0(sp)
81108a8c:	dec00204 	addi	sp,sp,8
81108a90:	f800283a 	ret

81108a94 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81108a94:	defffc04 	addi	sp,sp,-16
81108a98:	de00012e 	bgeu	sp,et,81108aa0 <vRmapWriteReg+0xc>
81108a9c:	003b68fa 	trap	3
81108aa0:	df000315 	stw	fp,12(sp)
81108aa4:	df000304 	addi	fp,sp,12
81108aa8:	e13ffd15 	stw	r4,-12(fp)
81108aac:	e17ffe15 	stw	r5,-8(fp)
81108ab0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81108ab4:	e0bffe17 	ldw	r2,-8(fp)
81108ab8:	1085883a 	add	r2,r2,r2
81108abc:	1085883a 	add	r2,r2,r2
81108ac0:	1007883a 	mov	r3,r2
81108ac4:	e0bffd17 	ldw	r2,-12(fp)
81108ac8:	10c5883a 	add	r2,r2,r3
81108acc:	e0ffff17 	ldw	r3,-4(fp)
81108ad0:	10c00015 	stw	r3,0(r2)
}
81108ad4:	0001883a 	nop
81108ad8:	e037883a 	mov	sp,fp
81108adc:	df000017 	ldw	fp,0(sp)
81108ae0:	dec00104 	addi	sp,sp,4
81108ae4:	f800283a 	ret

81108ae8 <uliRmapReadReg>:

static alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81108ae8:	defffc04 	addi	sp,sp,-16
81108aec:	de00012e 	bgeu	sp,et,81108af4 <uliRmapReadReg+0xc>
81108af0:	003b68fa 	trap	3
81108af4:	df000315 	stw	fp,12(sp)
81108af8:	df000304 	addi	fp,sp,12
81108afc:	e13ffe15 	stw	r4,-8(fp)
81108b00:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81108b04:	e0bfff17 	ldw	r2,-4(fp)
81108b08:	1085883a 	add	r2,r2,r2
81108b0c:	1085883a 	add	r2,r2,r2
81108b10:	1007883a 	mov	r3,r2
81108b14:	e0bffe17 	ldw	r2,-8(fp)
81108b18:	10c5883a 	add	r2,r2,r3
81108b1c:	10800017 	ldw	r2,0(r2)
81108b20:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81108b24:	e0bffd17 	ldw	r2,-12(fp)
}
81108b28:	e037883a 	mov	sp,fp
81108b2c:	df000017 	ldw	fp,0(sp)
81108b30:	dec00104 	addi	sp,sp,4
81108b34:	f800283a 	ret

81108b38 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81108b38:	defffd04 	addi	sp,sp,-12
81108b3c:	de00012e 	bgeu	sp,et,81108b44 <uliConvRmapCfgAddr+0xc>
81108b40:	003b68fa 	trap	3
81108b44:	df000215 	stw	fp,8(sp)
81108b48:	df000204 	addi	fp,sp,8
81108b4c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81108b50:	e0bfff17 	ldw	r2,-4(fp)
81108b54:	10801368 	cmpgeui	r2,r2,77
81108b58:	10008a1e 	bne	r2,zero,81108d84 <uliConvRmapCfgAddr+0x24c>
81108b5c:	e0bfff17 	ldw	r2,-4(fp)
81108b60:	100690ba 	slli	r3,r2,2
81108b64:	00a04474 	movhi	r2,33041
81108b68:	10a2de04 	addi	r2,r2,-29832
81108b6c:	1885883a 	add	r2,r3,r2
81108b70:	10800017 	ldw	r2,0(r2)
81108b74:	1000683a 	jmp	r2
81108b78:	81108cac 	andhi	r4,r16,16946
81108b7c:	81108d84 	addi	r4,r16,16950
81108b80:	81108d84 	addi	r4,r16,16950
81108b84:	81108d84 	addi	r4,r16,16950
81108b88:	81108cb8 	rdprs	r4,r16,16946
81108b8c:	81108d84 	addi	r4,r16,16950
81108b90:	81108d84 	addi	r4,r16,16950
81108b94:	81108d84 	addi	r4,r16,16950
81108b98:	81108cc4 	addi	r4,r16,16947
81108b9c:	81108d84 	addi	r4,r16,16950
81108ba0:	81108d84 	addi	r4,r16,16950
81108ba4:	81108d84 	addi	r4,r16,16950
81108ba8:	81108cd0 	cmplti	r4,r16,16947
81108bac:	81108d84 	addi	r4,r16,16950
81108bb0:	81108d84 	addi	r4,r16,16950
81108bb4:	81108d84 	addi	r4,r16,16950
81108bb8:	81108cdc 	xori	r4,r16,16947
81108bbc:	81108d84 	addi	r4,r16,16950
81108bc0:	81108d84 	addi	r4,r16,16950
81108bc4:	81108d84 	addi	r4,r16,16950
81108bc8:	81108ce8 	cmpgeui	r4,r16,16947
81108bcc:	81108d84 	addi	r4,r16,16950
81108bd0:	81108d84 	addi	r4,r16,16950
81108bd4:	81108d84 	addi	r4,r16,16950
81108bd8:	81108cf4 	orhi	r4,r16,16947
81108bdc:	81108d84 	addi	r4,r16,16950
81108be0:	81108d84 	addi	r4,r16,16950
81108be4:	81108d84 	addi	r4,r16,16950
81108be8:	81108d00 	call	881108d0 <__reset+0x20f08d0>
81108bec:	81108d84 	addi	r4,r16,16950
81108bf0:	81108d84 	addi	r4,r16,16950
81108bf4:	81108d84 	addi	r4,r16,16950
81108bf8:	81108d0c 	andi	r4,r16,16948
81108bfc:	81108d84 	addi	r4,r16,16950
81108c00:	81108d84 	addi	r4,r16,16950
81108c04:	81108d84 	addi	r4,r16,16950
81108c08:	81108d18 	cmpnei	r4,r16,16948
81108c0c:	81108d84 	addi	r4,r16,16950
81108c10:	81108d84 	addi	r4,r16,16950
81108c14:	81108d84 	addi	r4,r16,16950
81108c18:	81108d24 	muli	r4,r16,16948
81108c1c:	81108d84 	addi	r4,r16,16950
81108c20:	81108d84 	addi	r4,r16,16950
81108c24:	81108d84 	addi	r4,r16,16950
81108c28:	81108d30 	cmpltui	r4,r16,16948
81108c2c:	81108d84 	addi	r4,r16,16950
81108c30:	81108d84 	addi	r4,r16,16950
81108c34:	81108d84 	addi	r4,r16,16950
81108c38:	81108d84 	addi	r4,r16,16950
81108c3c:	81108d84 	addi	r4,r16,16950
81108c40:	81108d84 	addi	r4,r16,16950
81108c44:	81108d84 	addi	r4,r16,16950
81108c48:	81108d84 	addi	r4,r16,16950
81108c4c:	81108d84 	addi	r4,r16,16950
81108c50:	81108d84 	addi	r4,r16,16950
81108c54:	81108d84 	addi	r4,r16,16950
81108c58:	81108d3c 	xorhi	r4,r16,16948
81108c5c:	81108d84 	addi	r4,r16,16950
81108c60:	81108d84 	addi	r4,r16,16950
81108c64:	81108d84 	addi	r4,r16,16950
81108c68:	81108d48 	cmpgei	r4,r16,16949
81108c6c:	81108d84 	addi	r4,r16,16950
81108c70:	81108d84 	addi	r4,r16,16950
81108c74:	81108d84 	addi	r4,r16,16950
81108c78:	81108d54 	ori	r4,r16,16949
81108c7c:	81108d84 	addi	r4,r16,16950
81108c80:	81108d84 	addi	r4,r16,16950
81108c84:	81108d84 	addi	r4,r16,16950
81108c88:	81108d60 	cmpeqi	r4,r16,16949
81108c8c:	81108d84 	addi	r4,r16,16950
81108c90:	81108d84 	addi	r4,r16,16950
81108c94:	81108d84 	addi	r4,r16,16950
81108c98:	81108d6c 	andhi	r4,r16,16949
81108c9c:	81108d84 	addi	r4,r16,16950
81108ca0:	81108d84 	addi	r4,r16,16950
81108ca4:	81108d84 	addi	r4,r16,16950
81108ca8:	81108d78 	rdprs	r4,r16,16949
	case 0x00000000:
		uliValue = 0x00000040;
81108cac:	00801004 	movi	r2,64
81108cb0:	e0bffe15 	stw	r2,-8(fp)
		break;
81108cb4:	00003506 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
81108cb8:	00801044 	movi	r2,65
81108cbc:	e0bffe15 	stw	r2,-8(fp)
		break;
81108cc0:	00003206 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
81108cc4:	00801084 	movi	r2,66
81108cc8:	e0bffe15 	stw	r2,-8(fp)
		break;
81108ccc:	00002f06 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
81108cd0:	008010c4 	movi	r2,67
81108cd4:	e0bffe15 	stw	r2,-8(fp)
		break;
81108cd8:	00002c06 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
81108cdc:	00801104 	movi	r2,68
81108ce0:	e0bffe15 	stw	r2,-8(fp)
		break;
81108ce4:	00002906 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
81108ce8:	00801144 	movi	r2,69
81108cec:	e0bffe15 	stw	r2,-8(fp)
		break;
81108cf0:	00002606 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
81108cf4:	00801184 	movi	r2,70
81108cf8:	e0bffe15 	stw	r2,-8(fp)
		break;
81108cfc:	00002306 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
81108d00:	008011c4 	movi	r2,71
81108d04:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d08:	00002006 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
81108d0c:	00801204 	movi	r2,72
81108d10:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d14:	00001d06 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
81108d18:	00801244 	movi	r2,73
81108d1c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d20:	00001a06 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
81108d24:	00801284 	movi	r2,74
81108d28:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d2c:	00001706 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
81108d30:	008012c4 	movi	r2,75
81108d34:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d38:	00001406 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
81108d3c:	00801304 	movi	r2,76
81108d40:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d44:	00001106 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
81108d48:	00801344 	movi	r2,77
81108d4c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d50:	00000e06 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
81108d54:	00801384 	movi	r2,78
81108d58:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d5c:	00000b06 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
81108d60:	008013c4 	movi	r2,79
81108d64:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d68:	00000806 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
81108d6c:	00801404 	movi	r2,80
81108d70:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d74:	00000506 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
81108d78:	00801444 	movi	r2,81
81108d7c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d80:	00000206 	br	81108d8c <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
81108d84:	e03ffe15 	stw	zero,-8(fp)
		break;
81108d88:	0001883a 	nop
	}

	return uliValue;
81108d8c:	e0bffe17 	ldw	r2,-8(fp)
}
81108d90:	e037883a 	mov	sp,fp
81108d94:	df000017 	ldw	fp,0(sp)
81108d98:	dec00104 	addi	sp,sp,4
81108d9c:	f800283a 	ret

81108da0 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
81108da0:	defffb04 	addi	sp,sp,-20
81108da4:	de00012e 	bgeu	sp,et,81108dac <bSpwcSetLink+0xc>
81108da8:	003b68fa 	trap	3
81108dac:	dfc00415 	stw	ra,16(sp)
81108db0:	df000315 	stw	fp,12(sp)
81108db4:	df000304 	addi	fp,sp,12
81108db8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108dbc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108dc0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81108dc4:	e0bfff17 	ldw	r2,-4(fp)
81108dc8:	10003c26 	beq	r2,zero,81108ebc <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81108dcc:	e0bfff17 	ldw	r2,-4(fp)
81108dd0:	10800017 	ldw	r2,0(r2)
81108dd4:	000b883a 	mov	r5,zero
81108dd8:	1009883a 	mov	r4,r2
81108ddc:	110946c0 	call	8110946c <uliSpwcReadReg>
81108de0:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
81108de4:	e0bfff17 	ldw	r2,-4(fp)
81108de8:	10800117 	ldw	r2,4(r2)
81108dec:	10000426 	beq	r2,zero,81108e00 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
81108df0:	e0bffe17 	ldw	r2,-8(fp)
81108df4:	10800114 	ori	r2,r2,4
81108df8:	e0bffe15 	stw	r2,-8(fp)
81108dfc:	00000406 	br	81108e10 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
81108e00:	e0fffe17 	ldw	r3,-8(fp)
81108e04:	00bffec4 	movi	r2,-5
81108e08:	1884703a 	and	r2,r3,r2
81108e0c:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
81108e10:	e0bfff17 	ldw	r2,-4(fp)
81108e14:	10800217 	ldw	r2,8(r2)
81108e18:	10000426 	beq	r2,zero,81108e2c <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
81108e1c:	e0bffe17 	ldw	r2,-8(fp)
81108e20:	10800094 	ori	r2,r2,2
81108e24:	e0bffe15 	stw	r2,-8(fp)
81108e28:	00000406 	br	81108e3c <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
81108e2c:	e0fffe17 	ldw	r3,-8(fp)
81108e30:	00bfff44 	movi	r2,-3
81108e34:	1884703a 	and	r2,r3,r2
81108e38:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
81108e3c:	e0bfff17 	ldw	r2,-4(fp)
81108e40:	10800317 	ldw	r2,12(r2)
81108e44:	10000426 	beq	r2,zero,81108e58 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
81108e48:	e0bffe17 	ldw	r2,-8(fp)
81108e4c:	10800054 	ori	r2,r2,1
81108e50:	e0bffe15 	stw	r2,-8(fp)
81108e54:	00000406 	br	81108e68 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
81108e58:	e0fffe17 	ldw	r3,-8(fp)
81108e5c:	00bfff84 	movi	r2,-2
81108e60:	1884703a 	and	r2,r3,r2
81108e64:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
81108e68:	e0fffe17 	ldw	r3,-8(fp)
81108e6c:	00804034 	movhi	r2,256
81108e70:	10bfffc4 	addi	r2,r2,-1
81108e74:	1884703a 	and	r2,r3,r2
81108e78:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
81108e7c:	e0bfff17 	ldw	r2,-4(fp)
81108e80:	10800403 	ldbu	r2,16(r2)
81108e84:	10803fcc 	andi	r2,r2,255
81108e88:	1004963a 	slli	r2,r2,24
81108e8c:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
81108e90:	e0bffe17 	ldw	r2,-8(fp)
81108e94:	10c4b03a 	or	r2,r2,r3
81108e98:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
81108e9c:	e0bfff17 	ldw	r2,-4(fp)
81108ea0:	10800017 	ldw	r2,0(r2)
81108ea4:	e1bffe17 	ldw	r6,-8(fp)
81108ea8:	000b883a 	mov	r5,zero
81108eac:	1009883a 	mov	r4,r2
81108eb0:	11094180 	call	81109418 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
81108eb4:	00800044 	movi	r2,1
81108eb8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108ebc:	e0bffd17 	ldw	r2,-12(fp)
}
81108ec0:	e037883a 	mov	sp,fp
81108ec4:	dfc00117 	ldw	ra,4(sp)
81108ec8:	df000017 	ldw	fp,0(sp)
81108ecc:	dec00204 	addi	sp,sp,8
81108ed0:	f800283a 	ret

81108ed4 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
81108ed4:	defffb04 	addi	sp,sp,-20
81108ed8:	de00012e 	bgeu	sp,et,81108ee0 <bSpwcGetLink+0xc>
81108edc:	003b68fa 	trap	3
81108ee0:	dfc00415 	stw	ra,16(sp)
81108ee4:	df000315 	stw	fp,12(sp)
81108ee8:	df000304 	addi	fp,sp,12
81108eec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108ef0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108ef4:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81108ef8:	e0bfff17 	ldw	r2,-4(fp)
81108efc:	10002826 	beq	r2,zero,81108fa0 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81108f00:	e0bfff17 	ldw	r2,-4(fp)
81108f04:	10800017 	ldw	r2,0(r2)
81108f08:	000b883a 	mov	r5,zero
81108f0c:	1009883a 	mov	r4,r2
81108f10:	110946c0 	call	8110946c <uliSpwcReadReg>
81108f14:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
81108f18:	e0bffe17 	ldw	r2,-8(fp)
81108f1c:	1080010c 	andi	r2,r2,4
81108f20:	10000426 	beq	r2,zero,81108f34 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
81108f24:	e0bfff17 	ldw	r2,-4(fp)
81108f28:	00c00044 	movi	r3,1
81108f2c:	10c00115 	stw	r3,4(r2)
81108f30:	00000206 	br	81108f3c <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
81108f34:	e0bfff17 	ldw	r2,-4(fp)
81108f38:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
81108f3c:	e0bffe17 	ldw	r2,-8(fp)
81108f40:	1080008c 	andi	r2,r2,2
81108f44:	10000426 	beq	r2,zero,81108f58 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
81108f48:	e0bfff17 	ldw	r2,-4(fp)
81108f4c:	00c00044 	movi	r3,1
81108f50:	10c00215 	stw	r3,8(r2)
81108f54:	00000206 	br	81108f60 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
81108f58:	e0bfff17 	ldw	r2,-4(fp)
81108f5c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
81108f60:	e0bffe17 	ldw	r2,-8(fp)
81108f64:	1080004c 	andi	r2,r2,1
81108f68:	10000426 	beq	r2,zero,81108f7c <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
81108f6c:	e0bfff17 	ldw	r2,-4(fp)
81108f70:	00c00044 	movi	r3,1
81108f74:	10c00315 	stw	r3,12(r2)
81108f78:	00000206 	br	81108f84 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
81108f7c:	e0bfff17 	ldw	r2,-4(fp)
81108f80:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
81108f84:	e0bffe17 	ldw	r2,-8(fp)
81108f88:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
81108f8c:	1007883a 	mov	r3,r2
81108f90:	e0bfff17 	ldw	r2,-4(fp)
81108f94:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
81108f98:	00800044 	movi	r2,1
81108f9c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108fa0:	e0bffd17 	ldw	r2,-12(fp)
}
81108fa4:	e037883a 	mov	sp,fp
81108fa8:	dfc00117 	ldw	ra,4(sp)
81108fac:	df000017 	ldw	fp,0(sp)
81108fb0:	dec00204 	addi	sp,sp,8
81108fb4:	f800283a 	ret

81108fb8 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
81108fb8:	defffb04 	addi	sp,sp,-20
81108fbc:	de00012e 	bgeu	sp,et,81108fc4 <bSpwcGetLinkError+0xc>
81108fc0:	003b68fa 	trap	3
81108fc4:	dfc00415 	stw	ra,16(sp)
81108fc8:	df000315 	stw	fp,12(sp)
81108fcc:	df000304 	addi	fp,sp,12
81108fd0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108fd4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108fd8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81108fdc:	e0bfff17 	ldw	r2,-4(fp)
81108fe0:	10002c26 	beq	r2,zero,81109094 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81108fe4:	e0bfff17 	ldw	r2,-4(fp)
81108fe8:	10800017 	ldw	r2,0(r2)
81108fec:	000b883a 	mov	r5,zero
81108ff0:	1009883a 	mov	r4,r2
81108ff4:	110946c0 	call	8110946c <uliSpwcReadReg>
81108ff8:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
81108ffc:	e0bffe17 	ldw	r2,-8(fp)
81109000:	1080006c 	andhi	r2,r2,1
81109004:	10000426 	beq	r2,zero,81109018 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
81109008:	e0bfff17 	ldw	r2,-4(fp)
8110900c:	00c00044 	movi	r3,1
81109010:	10c00515 	stw	r3,20(r2)
81109014:	00000206 	br	81109020 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
81109018:	e0bfff17 	ldw	r2,-4(fp)
8110901c:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
81109020:	e0bffe17 	ldw	r2,-8(fp)
81109024:	108000ac 	andhi	r2,r2,2
81109028:	10000426 	beq	r2,zero,8110903c <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110902c:	e0bfff17 	ldw	r2,-4(fp)
81109030:	00c00044 	movi	r3,1
81109034:	10c00615 	stw	r3,24(r2)
81109038:	00000206 	br	81109044 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110903c:	e0bfff17 	ldw	r2,-4(fp)
81109040:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
81109044:	e0bffe17 	ldw	r2,-8(fp)
81109048:	1080012c 	andhi	r2,r2,4
8110904c:	10000426 	beq	r2,zero,81109060 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
81109050:	e0bfff17 	ldw	r2,-4(fp)
81109054:	00c00044 	movi	r3,1
81109058:	10c00715 	stw	r3,28(r2)
8110905c:	00000206 	br	81109068 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
81109060:	e0bfff17 	ldw	r2,-4(fp)
81109064:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
81109068:	e0bffe17 	ldw	r2,-8(fp)
8110906c:	1080022c 	andhi	r2,r2,8
81109070:	10000426 	beq	r2,zero,81109084 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
81109074:	e0bfff17 	ldw	r2,-4(fp)
81109078:	00c00044 	movi	r3,1
8110907c:	10c00815 	stw	r3,32(r2)
81109080:	00000206 	br	8110908c <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81109084:	e0bfff17 	ldw	r2,-4(fp)
81109088:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110908c:	00800044 	movi	r2,1
81109090:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109094:	e0bffd17 	ldw	r2,-12(fp)
}
81109098:	e037883a 	mov	sp,fp
8110909c:	dfc00117 	ldw	ra,4(sp)
811090a0:	df000017 	ldw	fp,0(sp)
811090a4:	dec00204 	addi	sp,sp,8
811090a8:	f800283a 	ret

811090ac <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
811090ac:	defffb04 	addi	sp,sp,-20
811090b0:	de00012e 	bgeu	sp,et,811090b8 <bSpwcGetLinkStatus+0xc>
811090b4:	003b68fa 	trap	3
811090b8:	dfc00415 	stw	ra,16(sp)
811090bc:	df000315 	stw	fp,12(sp)
811090c0:	df000304 	addi	fp,sp,12
811090c4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811090c8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811090cc:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811090d0:	e0bfff17 	ldw	r2,-4(fp)
811090d4:	10002326 	beq	r2,zero,81109164 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811090d8:	e0bfff17 	ldw	r2,-4(fp)
811090dc:	10800017 	ldw	r2,0(r2)
811090e0:	000b883a 	mov	r5,zero
811090e4:	1009883a 	mov	r4,r2
811090e8:	110946c0 	call	8110946c <uliSpwcReadReg>
811090ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
811090f0:	e0bffe17 	ldw	r2,-8(fp)
811090f4:	1081000c 	andi	r2,r2,1024
811090f8:	10000426 	beq	r2,zero,8110910c <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
811090fc:	e0bfff17 	ldw	r2,-4(fp)
81109100:	00c00044 	movi	r3,1
81109104:	10c00915 	stw	r3,36(r2)
81109108:	00000206 	br	81109114 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110910c:	e0bfff17 	ldw	r2,-4(fp)
81109110:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
81109114:	e0bffe17 	ldw	r2,-8(fp)
81109118:	1080800c 	andi	r2,r2,512
8110911c:	10000426 	beq	r2,zero,81109130 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
81109120:	e0bfff17 	ldw	r2,-4(fp)
81109124:	00c00044 	movi	r3,1
81109128:	10c00a15 	stw	r3,40(r2)
8110912c:	00000206 	br	81109138 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
81109130:	e0bfff17 	ldw	r2,-4(fp)
81109134:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
81109138:	e0bffe17 	ldw	r2,-8(fp)
8110913c:	1080400c 	andi	r2,r2,256
81109140:	10000426 	beq	r2,zero,81109154 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
81109144:	e0bfff17 	ldw	r2,-4(fp)
81109148:	00c00044 	movi	r3,1
8110914c:	10c00b15 	stw	r3,44(r2)
81109150:	00000206 	br	8110915c <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
81109154:	e0bfff17 	ldw	r2,-4(fp)
81109158:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110915c:	00800044 	movi	r2,1
81109160:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109164:	e0bffd17 	ldw	r2,-12(fp)
}
81109168:	e037883a 	mov	sp,fp
8110916c:	dfc00117 	ldw	ra,4(sp)
81109170:	df000017 	ldw	fp,0(sp)
81109174:	dec00204 	addi	sp,sp,8
81109178:	f800283a 	ret

8110917c <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110917c:	defffb04 	addi	sp,sp,-20
81109180:	de00012e 	bgeu	sp,et,81109188 <bSpwcGetTimecode+0xc>
81109184:	003b68fa 	trap	3
81109188:	dfc00415 	stw	ra,16(sp)
8110918c:	df000315 	stw	fp,12(sp)
81109190:	df000304 	addi	fp,sp,12
81109194:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109198:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110919c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811091a0:	e0bfff17 	ldw	r2,-4(fp)
811091a4:	10001326 	beq	r2,zero,811091f4 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811091a8:	e0bfff17 	ldw	r2,-4(fp)
811091ac:	10800017 	ldw	r2,0(r2)
811091b0:	01400044 	movi	r5,1
811091b4:	1009883a 	mov	r4,r2
811091b8:	110946c0 	call	8110946c <uliSpwcReadReg>
811091bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
811091c0:	e0bffe17 	ldw	r2,-8(fp)
811091c4:	1080300c 	andi	r2,r2,192
811091c8:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
811091cc:	1007883a 	mov	r3,r2
811091d0:	e0bfff17 	ldw	r2,-4(fp)
811091d4:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
811091d8:	e0bffe17 	ldw	r2,-8(fp)
811091dc:	10800fcc 	andi	r2,r2,63
811091e0:	1007883a 	mov	r3,r2
811091e4:	e0bfff17 	ldw	r2,-4(fp)
811091e8:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
811091ec:	00800044 	movi	r2,1
811091f0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811091f4:	e0bffd17 	ldw	r2,-12(fp)
}
811091f8:	e037883a 	mov	sp,fp
811091fc:	dfc00117 	ldw	ra,4(sp)
81109200:	df000017 	ldw	fp,0(sp)
81109204:	dec00204 	addi	sp,sp,8
81109208:	f800283a 	ret

8110920c <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110920c:	defffb04 	addi	sp,sp,-20
81109210:	de00012e 	bgeu	sp,et,81109218 <bSpwcClearTimecode+0xc>
81109214:	003b68fa 	trap	3
81109218:	dfc00415 	stw	ra,16(sp)
8110921c:	df000315 	stw	fp,12(sp)
81109220:	df000304 	addi	fp,sp,12
81109224:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109228:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110922c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109230:	e0bfff17 	ldw	r2,-4(fp)
81109234:	10001126 	beq	r2,zero,8110927c <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109238:	e0bfff17 	ldw	r2,-4(fp)
8110923c:	10800017 	ldw	r2,0(r2)
81109240:	01400044 	movi	r5,1
81109244:	1009883a 	mov	r4,r2
81109248:	110946c0 	call	8110946c <uliSpwcReadReg>
8110924c:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
81109250:	e0bffe17 	ldw	r2,-8(fp)
81109254:	10804014 	ori	r2,r2,256
81109258:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110925c:	e0bfff17 	ldw	r2,-4(fp)
81109260:	10800017 	ldw	r2,0(r2)
81109264:	e1bffe17 	ldw	r6,-8(fp)
81109268:	01400044 	movi	r5,1
8110926c:	1009883a 	mov	r4,r2
81109270:	11094180 	call	81109418 <vSpwcWriteReg>
		bStatus = TRUE;
81109274:	00800044 	movi	r2,1
81109278:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110927c:	e0bffd17 	ldw	r2,-12(fp)
}
81109280:	e037883a 	mov	sp,fp
81109284:	dfc00117 	ldw	ra,4(sp)
81109288:	df000017 	ldw	fp,0(sp)
8110928c:	dec00204 	addi	sp,sp,8
81109290:	f800283a 	ret

81109294 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
81109294:	defffb04 	addi	sp,sp,-20
81109298:	de00012e 	bgeu	sp,et,811092a0 <bSpwcInitCh+0xc>
8110929c:	003b68fa 	trap	3
811092a0:	dfc00415 	stw	ra,16(sp)
811092a4:	df000315 	stw	fp,12(sp)
811092a8:	df000304 	addi	fp,sp,12
811092ac:	e13ffe15 	stw	r4,-8(fp)
811092b0:	2805883a 	mov	r2,r5
811092b4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811092b8:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
811092bc:	e0bffe17 	ldw	r2,-8(fp)
811092c0:	10004f26 	beq	r2,zero,81109400 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
811092c4:	00800044 	movi	r2,1
811092c8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
811092cc:	e0bfff03 	ldbu	r2,-4(fp)
811092d0:	10c00228 	cmpgeui	r3,r2,8
811092d4:	1800361e 	bne	r3,zero,811093b0 <bSpwcInitCh+0x11c>
811092d8:	100690ba 	slli	r3,r2,2
811092dc:	00a04474 	movhi	r2,33041
811092e0:	10a4bc04 	addi	r2,r2,-27920
811092e4:	1885883a 	add	r2,r3,r2
811092e8:	10800017 	ldw	r2,0(r2)
811092ec:	1000683a 	jmp	r2
811092f0:	81109310 	cmplti	r4,r16,16972
811092f4:	81109324 	muli	r4,r16,16972
811092f8:	81109338 	rdprs	r4,r16,16972
811092fc:	8110934c 	andi	r4,r16,16973
81109300:	81109360 	cmpeqi	r4,r16,16973
81109304:	81109374 	orhi	r4,r16,16973
81109308:	81109388 	cmpgei	r4,r16,16974
8110930c:	8110939c 	xori	r4,r16,16974
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109310:	e0fffe17 	ldw	r3,-8(fp)
81109314:	00a04834 	movhi	r2,33056
81109318:	108b0004 	addi	r2,r2,11264
8110931c:	18800015 	stw	r2,0(r3)
			break;
81109320:	00002506 	br	811093b8 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109324:	e0fffe17 	ldw	r3,-8(fp)
81109328:	00a04834 	movhi	r2,33056
8110932c:	108a0004 	addi	r2,r2,10240
81109330:	18800015 	stw	r2,0(r3)
			break;
81109334:	00002006 	br	811093b8 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109338:	e0fffe17 	ldw	r3,-8(fp)
8110933c:	00a04834 	movhi	r2,33056
81109340:	10890004 	addi	r2,r2,9216
81109344:	18800015 	stw	r2,0(r3)
			break;
81109348:	00001b06 	br	811093b8 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110934c:	e0fffe17 	ldw	r3,-8(fp)
81109350:	00a04834 	movhi	r2,33056
81109354:	10880004 	addi	r2,r2,8192
81109358:	18800015 	stw	r2,0(r3)
			break;
8110935c:	00001606 	br	811093b8 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109360:	e0fffe17 	ldw	r3,-8(fp)
81109364:	00a04834 	movhi	r2,33056
81109368:	10870004 	addi	r2,r2,7168
8110936c:	18800015 	stw	r2,0(r3)
			break;
81109370:	00001106 	br	811093b8 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109374:	e0fffe17 	ldw	r3,-8(fp)
81109378:	00a04834 	movhi	r2,33056
8110937c:	10860004 	addi	r2,r2,6144
81109380:	18800015 	stw	r2,0(r3)
			break;
81109384:	00000c06 	br	811093b8 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109388:	e0fffe17 	ldw	r3,-8(fp)
8110938c:	00a04834 	movhi	r2,33056
81109390:	10850004 	addi	r2,r2,5120
81109394:	18800015 	stw	r2,0(r3)
			break;
81109398:	00000706 	br	811093b8 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110939c:	e0fffe17 	ldw	r3,-8(fp)
811093a0:	00a04834 	movhi	r2,33056
811093a4:	10840004 	addi	r2,r2,4096
811093a8:	18800015 	stw	r2,0(r3)
			break;
811093ac:	00000206 	br	811093b8 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
811093b0:	e03ffd15 	stw	zero,-12(fp)
			break;
811093b4:	0001883a 	nop
		}

		if (bStatus) {
811093b8:	e0bffd17 	ldw	r2,-12(fp)
811093bc:	10001026 	beq	r2,zero,81109400 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
811093c0:	e13ffe17 	ldw	r4,-8(fp)
811093c4:	1108ed40 	call	81108ed4 <bSpwcGetLink>
811093c8:	1000011e 	bne	r2,zero,811093d0 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
811093cc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
811093d0:	e13ffe17 	ldw	r4,-8(fp)
811093d4:	1108fb80 	call	81108fb8 <bSpwcGetLinkError>
811093d8:	1000011e 	bne	r2,zero,811093e0 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
811093dc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
811093e0:	e13ffe17 	ldw	r4,-8(fp)
811093e4:	11090ac0 	call	811090ac <bSpwcGetLinkStatus>
811093e8:	1000011e 	bne	r2,zero,811093f0 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
811093ec:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
811093f0:	e13ffe17 	ldw	r4,-8(fp)
811093f4:	110917c0 	call	8110917c <bSpwcGetTimecode>
811093f8:	1000011e 	bne	r2,zero,81109400 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
811093fc:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109400:	e0bffd17 	ldw	r2,-12(fp)
}
81109404:	e037883a 	mov	sp,fp
81109408:	dfc00117 	ldw	ra,4(sp)
8110940c:	df000017 	ldw	fp,0(sp)
81109410:	dec00204 	addi	sp,sp,8
81109414:	f800283a 	ret

81109418 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109418:	defffc04 	addi	sp,sp,-16
8110941c:	de00012e 	bgeu	sp,et,81109424 <vSpwcWriteReg+0xc>
81109420:	003b68fa 	trap	3
81109424:	df000315 	stw	fp,12(sp)
81109428:	df000304 	addi	fp,sp,12
8110942c:	e13ffd15 	stw	r4,-12(fp)
81109430:	e17ffe15 	stw	r5,-8(fp)
81109434:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109438:	e0bffe17 	ldw	r2,-8(fp)
8110943c:	1085883a 	add	r2,r2,r2
81109440:	1085883a 	add	r2,r2,r2
81109444:	1007883a 	mov	r3,r2
81109448:	e0bffd17 	ldw	r2,-12(fp)
8110944c:	10c5883a 	add	r2,r2,r3
81109450:	e0ffff17 	ldw	r3,-4(fp)
81109454:	10c00015 	stw	r3,0(r2)
}
81109458:	0001883a 	nop
8110945c:	e037883a 	mov	sp,fp
81109460:	df000017 	ldw	fp,0(sp)
81109464:	dec00104 	addi	sp,sp,4
81109468:	f800283a 	ret

8110946c <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110946c:	defffc04 	addi	sp,sp,-16
81109470:	de00012e 	bgeu	sp,et,81109478 <uliSpwcReadReg+0xc>
81109474:	003b68fa 	trap	3
81109478:	df000315 	stw	fp,12(sp)
8110947c:	df000304 	addi	fp,sp,12
81109480:	e13ffe15 	stw	r4,-8(fp)
81109484:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109488:	e0bfff17 	ldw	r2,-4(fp)
8110948c:	1085883a 	add	r2,r2,r2
81109490:	1085883a 	add	r2,r2,r2
81109494:	1007883a 	mov	r3,r2
81109498:	e0bffe17 	ldw	r2,-8(fp)
8110949c:	10c5883a 	add	r2,r2,r3
811094a0:	10800017 	ldw	r2,0(r2)
811094a4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
811094a8:	e0bffd17 	ldw	r2,-12(fp)
}
811094ac:	e037883a 	mov	sp,fp
811094b0:	df000017 	ldw	fp,0(sp)
811094b4:	dec00104 	addi	sp,sp,4
811094b8:	f800283a 	ret

811094bc <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
811094bc:	defffe04 	addi	sp,sp,-8
811094c0:	de00012e 	bgeu	sp,et,811094c8 <bEnableIsoDrivers+0xc>
811094c4:	003b68fa 	trap	3
811094c8:	dfc00115 	stw	ra,4(sp)
811094cc:	df000015 	stw	fp,0(sp)
811094d0:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
811094d4:	01400204 	movi	r5,8
811094d8:	01000044 	movi	r4,1
811094dc:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
  return  TRUE;
811094e0:	00800044 	movi	r2,1
}
811094e4:	e037883a 	mov	sp,fp
811094e8:	dfc00117 	ldw	ra,4(sp)
811094ec:	df000017 	ldw	fp,0(sp)
811094f0:	dec00204 	addi	sp,sp,8
811094f4:	f800283a 	ret

811094f8 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
811094f8:	defffe04 	addi	sp,sp,-8
811094fc:	de00012e 	bgeu	sp,et,81109504 <bDisableIsoDrivers+0xc>
81109500:	003b68fa 	trap	3
81109504:	dfc00115 	stw	ra,4(sp)
81109508:	df000015 	stw	fp,0(sp)
8110950c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
81109510:	01400204 	movi	r5,8
81109514:	0009883a 	mov	r4,zero
81109518:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
  return  TRUE;
8110951c:	00800044 	movi	r2,1
}
81109520:	e037883a 	mov	sp,fp
81109524:	dfc00117 	ldw	ra,4(sp)
81109528:	df000017 	ldw	fp,0(sp)
8110952c:	dec00204 	addi	sp,sp,8
81109530:	f800283a 	ret

81109534 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
81109534:	defffe04 	addi	sp,sp,-8
81109538:	de00012e 	bgeu	sp,et,81109540 <bEnableLvdsBoard+0xc>
8110953c:	003b68fa 	trap	3
81109540:	dfc00115 	stw	ra,4(sp)
81109544:	df000015 	stw	fp,0(sp)
81109548:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110954c:	01400104 	movi	r5,4
81109550:	01000044 	movi	r4,1
81109554:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
  return  TRUE;
81109558:	00800044 	movi	r2,1
}
8110955c:	e037883a 	mov	sp,fp
81109560:	dfc00117 	ldw	ra,4(sp)
81109564:	df000017 	ldw	fp,0(sp)
81109568:	dec00204 	addi	sp,sp,8
8110956c:	f800283a 	ret

81109570 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
81109570:	defffe04 	addi	sp,sp,-8
81109574:	de00012e 	bgeu	sp,et,8110957c <bDisableLvdsBoard+0xc>
81109578:	003b68fa 	trap	3
8110957c:	dfc00115 	stw	ra,4(sp)
81109580:	df000015 	stw	fp,0(sp)
81109584:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
81109588:	01400104 	movi	r5,4
8110958c:	0009883a 	mov	r4,zero
81109590:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
  return  TRUE;
81109594:	00800044 	movi	r2,1
}
81109598:	e037883a 	mov	sp,fp
8110959c:	dfc00117 	ldw	ra,4(sp)
811095a0:	df000017 	ldw	fp,0(sp)
811095a4:	dec00204 	addi	sp,sp,8
811095a8:	f800283a 	ret

811095ac <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
811095ac:	defffd04 	addi	sp,sp,-12
811095b0:	de00012e 	bgeu	sp,et,811095b8 <bSetPreEmphasys+0xc>
811095b4:	003b68fa 	trap	3
811095b8:	dfc00215 	stw	ra,8(sp)
811095bc:	df000115 	stw	fp,4(sp)
811095c0:	df000104 	addi	fp,sp,4
811095c4:	2005883a 	mov	r2,r4
811095c8:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
811095cc:	e0bfff03 	ldbu	r2,-4(fp)
811095d0:	10c00060 	cmpeqi	r3,r2,1
811095d4:	18000d1e 	bne	r3,zero,8110960c <bSetPreEmphasys+0x60>
811095d8:	10c00088 	cmpgei	r3,r2,2
811095dc:	1800021e 	bne	r3,zero,811095e8 <bSetPreEmphasys+0x3c>
811095e0:	10000626 	beq	r2,zero,811095fc <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
811095e4:	00001b06 	br	81109654 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
811095e8:	10c000a0 	cmpeqi	r3,r2,2
811095ec:	18000e1e 	bne	r3,zero,81109628 <bSetPreEmphasys+0x7c>
811095f0:	108000e0 	cmpeqi	r2,r2,3
811095f4:	1000131e 	bne	r2,zero,81109644 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
811095f8:	00001606 	br	81109654 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
811095fc:	014000c4 	movi	r5,3
81109600:	0009883a 	mov	r4,zero
81109604:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
      break;
81109608:	00001206 	br	81109654 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110960c:	01400084 	movi	r5,2
81109610:	0009883a 	mov	r4,zero
81109614:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
81109618:	01400044 	movi	r5,1
8110961c:	01000044 	movi	r4,1
81109620:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
      break;
81109624:	00000b06 	br	81109654 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
81109628:	01400044 	movi	r5,1
8110962c:	0009883a 	mov	r4,zero
81109630:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
81109634:	01400084 	movi	r5,2
81109638:	01000044 	movi	r4,1
8110963c:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
      break;
81109640:	00000406 	br	81109654 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
81109644:	014000c4 	movi	r5,3
81109648:	01000044 	movi	r4,1
8110964c:	110966c0 	call	8110966c <bCtrlIoLvdsDrive>
      break;
81109650:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
81109654:	00800044 	movi	r2,1
}
81109658:	e037883a 	mov	sp,fp
8110965c:	dfc00117 	ldw	ra,4(sp)
81109660:	df000017 	ldw	fp,0(sp)
81109664:	dec00204 	addi	sp,sp,8
81109668:	f800283a 	ret

8110966c <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110966c:	defffd04 	addi	sp,sp,-12
81109670:	de00012e 	bgeu	sp,et,81109678 <bCtrlIoLvdsDrive+0xc>
81109674:	003b68fa 	trap	3
81109678:	df000215 	stw	fp,8(sp)
8110967c:	df000204 	addi	fp,sp,8
81109680:	e13ffe15 	stw	r4,-8(fp)
81109684:	2805883a 	mov	r2,r5
81109688:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110968c:	e0bffe17 	ldw	r2,-8(fp)
81109690:	1000071e 	bne	r2,zero,811096b0 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
81109694:	e0bfff03 	ldbu	r2,-4(fp)
81109698:	0084303a 	nor	r2,zero,r2
8110969c:	1007883a 	mov	r3,r2
811096a0:	d0a00103 	ldbu	r2,-32764(gp)
811096a4:	1884703a 	and	r2,r3,r2
811096a8:	d0a00105 	stb	r2,-32764(gp)
811096ac:	00000406 	br	811096c0 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
811096b0:	d0e00103 	ldbu	r3,-32764(gp)
811096b4:	e0bfff03 	ldbu	r2,-4(fp)
811096b8:	1884b03a 	or	r2,r3,r2
811096bc:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
811096c0:	d0a00103 	ldbu	r2,-32764(gp)
811096c4:	10c03fcc 	andi	r3,r2,255
811096c8:	00a00034 	movhi	r2,32768
811096cc:	10822804 	addi	r2,r2,2208
811096d0:	10c00035 	stwio	r3,0(r2)
  return TRUE;
811096d4:	00800044 	movi	r2,1
}
811096d8:	e037883a 	mov	sp,fp
811096dc:	df000017 	ldw	fp,0(sp)
811096e0:	dec00104 	addi	sp,sp,4
811096e4:	f800283a 	ret

811096e8 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
811096e8:	defffa04 	addi	sp,sp,-24
811096ec:	de00012e 	bgeu	sp,et,811096f4 <I2C_TestAdress+0xc>
811096f0:	003b68fa 	trap	3
811096f4:	dfc00515 	stw	ra,20(sp)
811096f8:	df000415 	stw	fp,16(sp)
811096fc:	df000404 	addi	fp,sp,16
81109700:	e13ffd15 	stw	r4,-12(fp)
81109704:	e17ffe15 	stw	r5,-8(fp)
81109708:	3005883a 	mov	r2,r6
8110970c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81109710:	00800044 	movi	r2,1
81109714:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109718:	e17ffe17 	ldw	r5,-8(fp)
8110971c:	e13ffd17 	ldw	r4,-12(fp)
81109720:	1109ab80 	call	81109ab8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109724:	e0bfff03 	ldbu	r2,-4(fp)
81109728:	10803fcc 	andi	r2,r2,255
8110972c:	100d883a 	mov	r6,r2
81109730:	e17ffe17 	ldw	r5,-8(fp)
81109734:	e13ffd17 	ldw	r4,-12(fp)
81109738:	1109bcc0 	call	81109bcc <i2c_write>
8110973c:	1000011e 	bne	r2,zero,81109744 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
81109740:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81109744:	e17ffe17 	ldw	r5,-8(fp)
81109748:	e13ffd17 	ldw	r4,-12(fp)
8110974c:	1109b4c0 	call	81109b4c <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81109750:	0106d604 	movi	r4,7000
81109754:	11326680 	call	81132668 <usleep>
    
    return bSuccess;
81109758:	e0bffc17 	ldw	r2,-16(fp)

}
8110975c:	e037883a 	mov	sp,fp
81109760:	dfc00117 	ldw	ra,4(sp)
81109764:	df000017 	ldw	fp,0(sp)
81109768:	dec00204 	addi	sp,sp,8
8110976c:	f800283a 	ret

81109770 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
81109770:	defff804 	addi	sp,sp,-32
81109774:	de00012e 	bgeu	sp,et,8110977c <I2C_Write+0xc>
81109778:	003b68fa 	trap	3
8110977c:	dfc00715 	stw	ra,28(sp)
81109780:	df000615 	stw	fp,24(sp)
81109784:	df000604 	addi	fp,sp,24
81109788:	e13ffb15 	stw	r4,-20(fp)
8110978c:	e17ffc15 	stw	r5,-16(fp)
81109790:	3009883a 	mov	r4,r6
81109794:	3807883a 	mov	r3,r7
81109798:	e0800217 	ldw	r2,8(fp)
8110979c:	e13ffd05 	stb	r4,-12(fp)
811097a0:	e0fffe05 	stb	r3,-8(fp)
811097a4:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
811097a8:	00800044 	movi	r2,1
811097ac:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
811097b0:	e17ffc17 	ldw	r5,-16(fp)
811097b4:	e13ffb17 	ldw	r4,-20(fp)
811097b8:	1109ab80 	call	81109ab8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
811097bc:	e0bffd03 	ldbu	r2,-12(fp)
811097c0:	10803fcc 	andi	r2,r2,255
811097c4:	100d883a 	mov	r6,r2
811097c8:	e17ffc17 	ldw	r5,-16(fp)
811097cc:	e13ffb17 	ldw	r4,-20(fp)
811097d0:	1109bcc0 	call	81109bcc <i2c_write>
811097d4:	1000011e 	bne	r2,zero,811097dc <I2C_Write+0x6c>
        bSuccess = FALSE;
811097d8:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
811097dc:	e0bffa17 	ldw	r2,-24(fp)
811097e0:	10000726 	beq	r2,zero,81109800 <I2C_Write+0x90>
811097e4:	e0bffe03 	ldbu	r2,-8(fp)
811097e8:	100d883a 	mov	r6,r2
811097ec:	e17ffc17 	ldw	r5,-16(fp)
811097f0:	e13ffb17 	ldw	r4,-20(fp)
811097f4:	1109bcc0 	call	81109bcc <i2c_write>
811097f8:	1000011e 	bne	r2,zero,81109800 <I2C_Write+0x90>
        bSuccess = FALSE;
811097fc:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
81109800:	e0bffa17 	ldw	r2,-24(fp)
81109804:	10000726 	beq	r2,zero,81109824 <I2C_Write+0xb4>
81109808:	e0bfff03 	ldbu	r2,-4(fp)
8110980c:	100d883a 	mov	r6,r2
81109810:	e17ffc17 	ldw	r5,-16(fp)
81109814:	e13ffb17 	ldw	r4,-20(fp)
81109818:	1109bcc0 	call	81109bcc <i2c_write>
8110981c:	1000011e 	bne	r2,zero,81109824 <I2C_Write+0xb4>
        bSuccess = FALSE;
81109820:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81109824:	e17ffc17 	ldw	r5,-16(fp)
81109828:	e13ffb17 	ldw	r4,-20(fp)
8110982c:	1109b4c0 	call	81109b4c <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81109830:	0106d604 	movi	r4,7000
81109834:	11326680 	call	81132668 <usleep>
    
    return bSuccess;
81109838:	e0bffa17 	ldw	r2,-24(fp)

}
8110983c:	e037883a 	mov	sp,fp
81109840:	dfc00117 	ldw	ra,4(sp)
81109844:	df000017 	ldw	fp,0(sp)
81109848:	dec00204 	addi	sp,sp,8
8110984c:	f800283a 	ret

81109850 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
81109850:	defff904 	addi	sp,sp,-28
81109854:	de00012e 	bgeu	sp,et,8110985c <I2C_Read+0xc>
81109858:	003b68fa 	trap	3
8110985c:	dfc00615 	stw	ra,24(sp)
81109860:	df000515 	stw	fp,20(sp)
81109864:	df000504 	addi	fp,sp,20
81109868:	e13ffc15 	stw	r4,-16(fp)
8110986c:	e17ffd15 	stw	r5,-12(fp)
81109870:	3007883a 	mov	r3,r6
81109874:	3805883a 	mov	r2,r7
81109878:	e0fffe05 	stb	r3,-8(fp)
8110987c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81109880:	00800044 	movi	r2,1
81109884:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109888:	e17ffd17 	ldw	r5,-12(fp)
8110988c:	e13ffc17 	ldw	r4,-16(fp)
81109890:	1109ab80 	call	81109ab8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109894:	e0bffe03 	ldbu	r2,-8(fp)
81109898:	10803fcc 	andi	r2,r2,255
8110989c:	100d883a 	mov	r6,r2
811098a0:	e17ffd17 	ldw	r5,-12(fp)
811098a4:	e13ffc17 	ldw	r4,-16(fp)
811098a8:	1109bcc0 	call	81109bcc <i2c_write>
811098ac:	1000011e 	bne	r2,zero,811098b4 <I2C_Read+0x64>
        bSuccess = FALSE;
811098b0:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
811098b4:	e0bffb17 	ldw	r2,-20(fp)
811098b8:	10000726 	beq	r2,zero,811098d8 <I2C_Read+0x88>
811098bc:	e0bfff03 	ldbu	r2,-4(fp)
811098c0:	100d883a 	mov	r6,r2
811098c4:	e17ffd17 	ldw	r5,-12(fp)
811098c8:	e13ffc17 	ldw	r4,-16(fp)
811098cc:	1109bcc0 	call	81109bcc <i2c_write>
811098d0:	1000011e 	bne	r2,zero,811098d8 <I2C_Read+0x88>
        bSuccess = FALSE;
811098d4:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
811098d8:	e17ffd17 	ldw	r5,-12(fp)
811098dc:	e13ffc17 	ldw	r4,-16(fp)
811098e0:	1109ab80 	call	81109ab8 <i2c_start>
    DeviceAddr |= 1; // Read
811098e4:	e0bffe03 	ldbu	r2,-8(fp)
811098e8:	10800054 	ori	r2,r2,1
811098ec:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
811098f0:	e0bffb17 	ldw	r2,-20(fp)
811098f4:	10000826 	beq	r2,zero,81109918 <I2C_Read+0xc8>
811098f8:	e0bffe03 	ldbu	r2,-8(fp)
811098fc:	10803fcc 	andi	r2,r2,255
81109900:	100d883a 	mov	r6,r2
81109904:	e17ffd17 	ldw	r5,-12(fp)
81109908:	e13ffc17 	ldw	r4,-16(fp)
8110990c:	1109bcc0 	call	81109bcc <i2c_write>
81109910:	1000011e 	bne	r2,zero,81109918 <I2C_Read+0xc8>
        bSuccess = FALSE;
81109914:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109918:	e0bffb17 	ldw	r2,-20(fp)
8110991c:	10000526 	beq	r2,zero,81109934 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
81109920:	000f883a 	mov	r7,zero
81109924:	e1800217 	ldw	r6,8(fp)
81109928:	e17ffd17 	ldw	r5,-12(fp)
8110992c:	e13ffc17 	ldw	r4,-16(fp)
81109930:	1109d040 	call	81109d04 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
81109934:	e17ffd17 	ldw	r5,-12(fp)
81109938:	e13ffc17 	ldw	r4,-16(fp)
8110993c:	1109b4c0 	call	81109b4c <i2c_stop>
    
    return bSuccess;
81109940:	e0bffb17 	ldw	r2,-20(fp)
}
81109944:	e037883a 	mov	sp,fp
81109948:	dfc00117 	ldw	ra,4(sp)
8110994c:	df000017 	ldw	fp,0(sp)
81109950:	dec00204 	addi	sp,sp,8
81109954:	f800283a 	ret

81109958 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
81109958:	defff604 	addi	sp,sp,-40
8110995c:	de00012e 	bgeu	sp,et,81109964 <I2C_MultipleRead+0xc>
81109960:	003b68fa 	trap	3
81109964:	dfc00915 	stw	ra,36(sp)
81109968:	df000815 	stw	fp,32(sp)
8110996c:	df000804 	addi	fp,sp,32
81109970:	e13ffb15 	stw	r4,-20(fp)
81109974:	e17ffc15 	stw	r5,-16(fp)
81109978:	3007883a 	mov	r3,r6
8110997c:	e1fffe15 	stw	r7,-8(fp)
81109980:	e0800217 	ldw	r2,8(fp)
81109984:	e0fffd05 	stb	r3,-12(fp)
81109988:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110998c:	00800044 	movi	r2,1
81109990:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
81109994:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109998:	e17ffc17 	ldw	r5,-16(fp)
8110999c:	e13ffb17 	ldw	r4,-20(fp)
811099a0:	1109ab80 	call	81109ab8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
811099a4:	e0bffd03 	ldbu	r2,-12(fp)
811099a8:	10803fcc 	andi	r2,r2,255
811099ac:	100d883a 	mov	r6,r2
811099b0:	e17ffc17 	ldw	r5,-16(fp)
811099b4:	e13ffb17 	ldw	r4,-20(fp)
811099b8:	1109bcc0 	call	81109bcc <i2c_write>
811099bc:	1000011e 	bne	r2,zero,811099c4 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
811099c0:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
811099c4:	e0bff917 	ldw	r2,-28(fp)
811099c8:	10000726 	beq	r2,zero,811099e8 <I2C_MultipleRead+0x90>
811099cc:	e0bffa03 	ldbu	r2,-24(fp)
811099d0:	100d883a 	mov	r6,r2
811099d4:	e17ffc17 	ldw	r5,-16(fp)
811099d8:	e13ffb17 	ldw	r4,-20(fp)
811099dc:	1109bcc0 	call	81109bcc <i2c_write>
811099e0:	1000011e 	bne	r2,zero,811099e8 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
811099e4:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
811099e8:	e0bff917 	ldw	r2,-28(fp)
811099ec:	10000326 	beq	r2,zero,811099fc <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
811099f0:	e17ffc17 	ldw	r5,-16(fp)
811099f4:	e13ffb17 	ldw	r4,-20(fp)
811099f8:	1109ab80 	call	81109ab8 <i2c_start>
    DeviceAddr |= 1; // Read
811099fc:	e0bffd03 	ldbu	r2,-12(fp)
81109a00:	10800054 	ori	r2,r2,1
81109a04:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81109a08:	e0bff917 	ldw	r2,-28(fp)
81109a0c:	10000826 	beq	r2,zero,81109a30 <I2C_MultipleRead+0xd8>
81109a10:	e0bffd03 	ldbu	r2,-12(fp)
81109a14:	10803fcc 	andi	r2,r2,255
81109a18:	100d883a 	mov	r6,r2
81109a1c:	e17ffc17 	ldw	r5,-16(fp)
81109a20:	e13ffb17 	ldw	r4,-20(fp)
81109a24:	1109bcc0 	call	81109bcc <i2c_write>
81109a28:	1000011e 	bne	r2,zero,81109a30 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
81109a2c:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109a30:	e0bff917 	ldw	r2,-28(fp)
81109a34:	10001726 	beq	r2,zero,81109a94 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
81109a38:	e03ff815 	stw	zero,-32(fp)
81109a3c:	00001006 	br	81109a80 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
81109a40:	e0bff817 	ldw	r2,-32(fp)
81109a44:	e0fffe17 	ldw	r3,-8(fp)
81109a48:	1889883a 	add	r4,r3,r2
81109a4c:	e0bfff0b 	ldhu	r2,-4(fp)
81109a50:	10ffffc4 	addi	r3,r2,-1
81109a54:	e0bff817 	ldw	r2,-32(fp)
81109a58:	1884c03a 	cmpne	r2,r3,r2
81109a5c:	10803fcc 	andi	r2,r2,255
81109a60:	100f883a 	mov	r7,r2
81109a64:	200d883a 	mov	r6,r4
81109a68:	e17ffc17 	ldw	r5,-16(fp)
81109a6c:	e13ffb17 	ldw	r4,-20(fp)
81109a70:	1109d040 	call	81109d04 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
81109a74:	e0bff817 	ldw	r2,-32(fp)
81109a78:	10800044 	addi	r2,r2,1
81109a7c:	e0bff815 	stw	r2,-32(fp)
81109a80:	e0bfff0b 	ldhu	r2,-4(fp)
81109a84:	e0fff817 	ldw	r3,-32(fp)
81109a88:	1880020e 	bge	r3,r2,81109a94 <I2C_MultipleRead+0x13c>
81109a8c:	e0bff917 	ldw	r2,-28(fp)
81109a90:	103feb1e 	bne	r2,zero,81109a40 <__reset+0xfb0e9a40>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
81109a94:	e17ffc17 	ldw	r5,-16(fp)
81109a98:	e13ffb17 	ldw	r4,-20(fp)
81109a9c:	1109b4c0 	call	81109b4c <i2c_stop>
    
    return bSuccess;    
81109aa0:	e0bff917 	ldw	r2,-28(fp)
    
}
81109aa4:	e037883a 	mov	sp,fp
81109aa8:	dfc00117 	ldw	ra,4(sp)
81109aac:	df000017 	ldw	fp,0(sp)
81109ab0:	dec00204 	addi	sp,sp,8
81109ab4:	f800283a 	ret

81109ab8 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
81109ab8:	defffc04 	addi	sp,sp,-16
81109abc:	de00012e 	bgeu	sp,et,81109ac4 <i2c_start+0xc>
81109ac0:	003b68fa 	trap	3
81109ac4:	dfc00315 	stw	ra,12(sp)
81109ac8:	df000215 	stw	fp,8(sp)
81109acc:	df000204 	addi	fp,sp,8
81109ad0:	e13ffe15 	stw	r4,-8(fp)
81109ad4:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
81109ad8:	e0bfff17 	ldw	r2,-4(fp)
81109adc:	10800104 	addi	r2,r2,4
81109ae0:	1007883a 	mov	r3,r2
81109ae4:	00800044 	movi	r2,1
81109ae8:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
81109aec:	e0bfff17 	ldw	r2,-4(fp)
81109af0:	00c00044 	movi	r3,1
81109af4:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
81109af8:	e0bffe17 	ldw	r2,-8(fp)
81109afc:	00c00044 	movi	r3,1
81109b00:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109b04:	01000044 	movi	r4,1
81109b08:	11326680 	call	81132668 <usleep>
     
    SDA_LOW(data_base); // data low
81109b0c:	e0bfff17 	ldw	r2,-4(fp)
81109b10:	0007883a 	mov	r3,zero
81109b14:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
81109b18:	01000044 	movi	r4,1
81109b1c:	11326680 	call	81132668 <usleep>
    SCL_LOW(clk_base); // clock low
81109b20:	e0bffe17 	ldw	r2,-8(fp)
81109b24:	0007883a 	mov	r3,zero
81109b28:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109b2c:	01000044 	movi	r4,1
81109b30:	11326680 	call	81132668 <usleep>
}
81109b34:	0001883a 	nop
81109b38:	e037883a 	mov	sp,fp
81109b3c:	dfc00117 	ldw	ra,4(sp)
81109b40:	df000017 	ldw	fp,0(sp)
81109b44:	dec00204 	addi	sp,sp,8
81109b48:	f800283a 	ret

81109b4c <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
81109b4c:	defffc04 	addi	sp,sp,-16
81109b50:	de00012e 	bgeu	sp,et,81109b58 <i2c_stop+0xc>
81109b54:	003b68fa 	trap	3
81109b58:	dfc00315 	stw	ra,12(sp)
81109b5c:	df000215 	stw	fp,8(sp)
81109b60:	df000204 	addi	fp,sp,8
81109b64:	e13ffe15 	stw	r4,-8(fp)
81109b68:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
81109b6c:	e0bfff17 	ldw	r2,-4(fp)
81109b70:	10800104 	addi	r2,r2,4
81109b74:	1007883a 	mov	r3,r2
81109b78:	00800044 	movi	r2,1
81109b7c:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
81109b80:	e0bfff17 	ldw	r2,-4(fp)
81109b84:	0007883a 	mov	r3,zero
81109b88:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
81109b8c:	e0bffe17 	ldw	r2,-8(fp)
81109b90:	00c00044 	movi	r3,1
81109b94:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
81109b98:	01000044 	movi	r4,1
81109b9c:	11326680 	call	81132668 <usleep>
    SDA_HIGH(data_base); // data high
81109ba0:	e0bfff17 	ldw	r2,-4(fp)
81109ba4:	00c00044 	movi	r3,1
81109ba8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
81109bac:	01000044 	movi	r4,1
81109bb0:	11326680 	call	81132668 <usleep>
    

    
}
81109bb4:	0001883a 	nop
81109bb8:	e037883a 	mov	sp,fp
81109bbc:	dfc00117 	ldw	ra,4(sp)
81109bc0:	df000017 	ldw	fp,0(sp)
81109bc4:	dec00204 	addi	sp,sp,8
81109bc8:	f800283a 	ret

81109bcc <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
81109bcc:	defff804 	addi	sp,sp,-32
81109bd0:	de00012e 	bgeu	sp,et,81109bd8 <i2c_write+0xc>
81109bd4:	003b68fa 	trap	3
81109bd8:	dfc00715 	stw	ra,28(sp)
81109bdc:	df000615 	stw	fp,24(sp)
81109be0:	df000604 	addi	fp,sp,24
81109be4:	e13ffd15 	stw	r4,-12(fp)
81109be8:	e17ffe15 	stw	r5,-8(fp)
81109bec:	3005883a 	mov	r2,r6
81109bf0:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
81109bf4:	00bfe004 	movi	r2,-128
81109bf8:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
81109bfc:	e0bffe17 	ldw	r2,-8(fp)
81109c00:	10800104 	addi	r2,r2,4
81109c04:	1007883a 	mov	r3,r2
81109c08:	00800044 	movi	r2,1
81109c0c:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
81109c10:	e03ffb15 	stw	zero,-20(fp)
81109c14:	00001f06 	br	81109c94 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
81109c18:	e0bffd17 	ldw	r2,-12(fp)
81109c1c:	0007883a 	mov	r3,zero
81109c20:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
81109c24:	e0ffff03 	ldbu	r3,-4(fp)
81109c28:	e0bffa03 	ldbu	r2,-24(fp)
81109c2c:	1884703a 	and	r2,r3,r2
81109c30:	10803fcc 	andi	r2,r2,255
81109c34:	10000426 	beq	r2,zero,81109c48 <i2c_write+0x7c>
            SDA_HIGH(data_base);
81109c38:	e0bffe17 	ldw	r2,-8(fp)
81109c3c:	00c00044 	movi	r3,1
81109c40:	10c00035 	stwio	r3,0(r2)
81109c44:	00000306 	br	81109c54 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
81109c48:	e0bffe17 	ldw	r2,-8(fp)
81109c4c:	0007883a 	mov	r3,zero
81109c50:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
81109c54:	e0bffa03 	ldbu	r2,-24(fp)
81109c58:	1004d07a 	srli	r2,r2,1
81109c5c:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
81109c60:	e0bffd17 	ldw	r2,-12(fp)
81109c64:	00c00044 	movi	r3,1
81109c68:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109c6c:	01000044 	movi	r4,1
81109c70:	11326680 	call	81132668 <usleep>
        SCL_LOW(clk_base);
81109c74:	e0bffd17 	ldw	r2,-12(fp)
81109c78:	0007883a 	mov	r3,zero
81109c7c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109c80:	01000044 	movi	r4,1
81109c84:	11326680 	call	81132668 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
81109c88:	e0bffb17 	ldw	r2,-20(fp)
81109c8c:	10800044 	addi	r2,r2,1
81109c90:	e0bffb15 	stw	r2,-20(fp)
81109c94:	e0bffb17 	ldw	r2,-20(fp)
81109c98:	10800210 	cmplti	r2,r2,8
81109c9c:	103fde1e 	bne	r2,zero,81109c18 <__reset+0xfb0e9c18>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
81109ca0:	e0bffe17 	ldw	r2,-8(fp)
81109ca4:	10800104 	addi	r2,r2,4
81109ca8:	0007883a 	mov	r3,zero
81109cac:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
81109cb0:	e0bffd17 	ldw	r2,-12(fp)
81109cb4:	00c00044 	movi	r3,1
81109cb8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
81109cbc:	01000044 	movi	r4,1
81109cc0:	11326680 	call	81132668 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
81109cc4:	e0bffe17 	ldw	r2,-8(fp)
81109cc8:	10800037 	ldwio	r2,0(r2)
81109ccc:	1005003a 	cmpeq	r2,r2,zero
81109cd0:	10803fcc 	andi	r2,r2,255
81109cd4:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
81109cd8:	e0bffd17 	ldw	r2,-12(fp)
81109cdc:	0007883a 	mov	r3,zero
81109ce0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109ce4:	01000044 	movi	r4,1
81109ce8:	11326680 	call	81132668 <usleep>
    return bAck;
81109cec:	e0bffc17 	ldw	r2,-16(fp)
}    
81109cf0:	e037883a 	mov	sp,fp
81109cf4:	dfc00117 	ldw	ra,4(sp)
81109cf8:	df000017 	ldw	fp,0(sp)
81109cfc:	dec00204 	addi	sp,sp,8
81109d00:	f800283a 	ret

81109d04 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
81109d04:	defff804 	addi	sp,sp,-32
81109d08:	de00012e 	bgeu	sp,et,81109d10 <i2c_read+0xc>
81109d0c:	003b68fa 	trap	3
81109d10:	dfc00715 	stw	ra,28(sp)
81109d14:	df000615 	stw	fp,24(sp)
81109d18:	df000604 	addi	fp,sp,24
81109d1c:	e13ffc15 	stw	r4,-16(fp)
81109d20:	e17ffd15 	stw	r5,-12(fp)
81109d24:	e1bffe15 	stw	r6,-8(fp)
81109d28:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
81109d2c:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
81109d30:	e0bffd17 	ldw	r2,-12(fp)
81109d34:	10800104 	addi	r2,r2,4
81109d38:	0007883a 	mov	r3,zero
81109d3c:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
81109d40:	e0bffc17 	ldw	r2,-16(fp)
81109d44:	0007883a 	mov	r3,zero
81109d48:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109d4c:	01000044 	movi	r4,1
81109d50:	11326680 	call	81132668 <usleep>

    for(i=0;i<8;i++){
81109d54:	e03ffb15 	stw	zero,-20(fp)
81109d58:	00001606 	br	81109db4 <i2c_read+0xb0>
        Data <<= 1;
81109d5c:	e0bffa03 	ldbu	r2,-24(fp)
81109d60:	1085883a 	add	r2,r2,r2
81109d64:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
81109d68:	e0bffc17 	ldw	r2,-16(fp)
81109d6c:	00c00044 	movi	r3,1
81109d70:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109d74:	01000044 	movi	r4,1
81109d78:	11326680 	call	81132668 <usleep>
        if (SDA_READ(data_base))  // read data   
81109d7c:	e0bffd17 	ldw	r2,-12(fp)
81109d80:	10800037 	ldwio	r2,0(r2)
81109d84:	10000326 	beq	r2,zero,81109d94 <i2c_read+0x90>
            Data |= 0x01;
81109d88:	e0bffa03 	ldbu	r2,-24(fp)
81109d8c:	10800054 	ori	r2,r2,1
81109d90:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
81109d94:	e0bffc17 	ldw	r2,-16(fp)
81109d98:	0007883a 	mov	r3,zero
81109d9c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109da0:	01000044 	movi	r4,1
81109da4:	11326680 	call	81132668 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
81109da8:	e0bffb17 	ldw	r2,-20(fp)
81109dac:	10800044 	addi	r2,r2,1
81109db0:	e0bffb15 	stw	r2,-20(fp)
81109db4:	e0bffb17 	ldw	r2,-20(fp)
81109db8:	10800210 	cmplti	r2,r2,8
81109dbc:	103fe71e 	bne	r2,zero,81109d5c <__reset+0xfb0e9d5c>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
81109dc0:	e0bffc17 	ldw	r2,-16(fp)
81109dc4:	0007883a 	mov	r3,zero
81109dc8:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
81109dcc:	e0bffd17 	ldw	r2,-12(fp)
81109dd0:	10800104 	addi	r2,r2,4
81109dd4:	1007883a 	mov	r3,r2
81109dd8:	00800044 	movi	r2,1
81109ddc:	18800035 	stwio	r2,0(r3)
    if (bAck)
81109de0:	e0bfff17 	ldw	r2,-4(fp)
81109de4:	10000426 	beq	r2,zero,81109df8 <i2c_read+0xf4>
        SDA_LOW(data_base);
81109de8:	e0bffd17 	ldw	r2,-12(fp)
81109dec:	0007883a 	mov	r3,zero
81109df0:	10c00035 	stwio	r3,0(r2)
81109df4:	00000306 	br	81109e04 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
81109df8:	e0bffd17 	ldw	r2,-12(fp)
81109dfc:	00c00044 	movi	r3,1
81109e00:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
81109e04:	e0bffc17 	ldw	r2,-16(fp)
81109e08:	00c00044 	movi	r3,1
81109e0c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
81109e10:	01000044 	movi	r4,1
81109e14:	11326680 	call	81132668 <usleep>
    SCL_LOW(clk_base); // clock low
81109e18:	e0bffc17 	ldw	r2,-16(fp)
81109e1c:	0007883a 	mov	r3,zero
81109e20:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109e24:	01000044 	movi	r4,1
81109e28:	11326680 	call	81132668 <usleep>
    SDA_LOW(data_base);  // data low
81109e2c:	e0bffd17 	ldw	r2,-12(fp)
81109e30:	0007883a 	mov	r3,zero
81109e34:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
81109e38:	01000044 	movi	r4,1
81109e3c:	11326680 	call	81132668 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
81109e40:	e0bffe17 	ldw	r2,-8(fp)
81109e44:	e0fffa03 	ldbu	r3,-24(fp)
81109e48:	10c00005 	stb	r3,0(r2)
}
81109e4c:	0001883a 	nop
81109e50:	e037883a 	mov	sp,fp
81109e54:	dfc00117 	ldw	ra,4(sp)
81109e58:	df000017 	ldw	fp,0(sp)
81109e5c:	dec00204 	addi	sp,sp,8
81109e60:	f800283a 	ret

81109e64 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
81109e64:	defffd04 	addi	sp,sp,-12
81109e68:	de00012e 	bgeu	sp,et,81109e70 <bSetBoardLeds+0xc>
81109e6c:	003b68fa 	trap	3
81109e70:	df000215 	stw	fp,8(sp)
81109e74:	df000204 	addi	fp,sp,8
81109e78:	e13ffe15 	stw	r4,-8(fp)
81109e7c:	2805883a 	mov	r2,r5
81109e80:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
81109e84:	e0bffe17 	ldw	r2,-8(fp)
81109e88:	10800058 	cmpnei	r2,r2,1
81109e8c:	1000071e 	bne	r2,zero,81109eac <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
81109e90:	e0bfff03 	ldbu	r2,-4(fp)
81109e94:	0084303a 	nor	r2,zero,r2
81109e98:	1007883a 	mov	r3,r2
81109e9c:	d0a04e03 	ldbu	r2,-32456(gp)
81109ea0:	1884703a 	and	r2,r3,r2
81109ea4:	d0a04e05 	stb	r2,-32456(gp)
81109ea8:	00000406 	br	81109ebc <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
81109eac:	d0e04e03 	ldbu	r3,-32456(gp)
81109eb0:	e0bfff03 	ldbu	r2,-4(fp)
81109eb4:	1884b03a 	or	r2,r3,r2
81109eb8:	d0a04e05 	stb	r2,-32456(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
81109ebc:	d0a04e03 	ldbu	r2,-32456(gp)
81109ec0:	10c03fcc 	andi	r3,r2,255
81109ec4:	00a00034 	movhi	r2,32768
81109ec8:	10827404 	addi	r2,r2,2512
81109ecc:	10c00035 	stwio	r3,0(r2)

  return TRUE;
81109ed0:	00800044 	movi	r2,1
}
81109ed4:	e037883a 	mov	sp,fp
81109ed8:	df000017 	ldw	fp,0(sp)
81109edc:	dec00104 	addi	sp,sp,4
81109ee0:	f800283a 	ret

81109ee4 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
81109ee4:	defffd04 	addi	sp,sp,-12
81109ee8:	de00012e 	bgeu	sp,et,81109ef0 <bSetPainelLeds+0xc>
81109eec:	003b68fa 	trap	3
81109ef0:	df000215 	stw	fp,8(sp)
81109ef4:	df000204 	addi	fp,sp,8
81109ef8:	e13ffe15 	stw	r4,-8(fp)
81109efc:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
81109f00:	e0bffe17 	ldw	r2,-8(fp)
81109f04:	10800058 	cmpnei	r2,r2,1
81109f08:	1000051e 	bne	r2,zero,81109f20 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
81109f0c:	d0e00217 	ldw	r3,-32760(gp)
81109f10:	e0bfff17 	ldw	r2,-4(fp)
81109f14:	1884b03a 	or	r2,r3,r2
81109f18:	d0a00215 	stw	r2,-32760(gp)
81109f1c:	00000506 	br	81109f34 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
81109f20:	e0bfff17 	ldw	r2,-4(fp)
81109f24:	0086303a 	nor	r3,zero,r2
81109f28:	d0a00217 	ldw	r2,-32760(gp)
81109f2c:	1884703a 	and	r2,r3,r2
81109f30:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
81109f34:	d0a00217 	ldw	r2,-32760(gp)
81109f38:	1007883a 	mov	r3,r2
81109f3c:	00a00034 	movhi	r2,32768
81109f40:	10824004 	addi	r2,r2,2304
81109f44:	10c00035 	stwio	r3,0(r2)

  return TRUE;
81109f48:	00800044 	movi	r2,1
}
81109f4c:	e037883a 	mov	sp,fp
81109f50:	df000017 	ldw	fp,0(sp)
81109f54:	dec00104 	addi	sp,sp,4
81109f58:	f800283a 	ret

81109f5c <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
81109f5c:	defffc04 	addi	sp,sp,-16
81109f60:	de00012e 	bgeu	sp,et,81109f68 <msgdma_write_extended_descriptor+0xc>
81109f64:	003b68fa 	trap	3
81109f68:	df000315 	stw	fp,12(sp)
81109f6c:	df000304 	addi	fp,sp,12
81109f70:	e13ffd15 	stw	r4,-12(fp)
81109f74:	e17ffe15 	stw	r5,-8(fp)
81109f78:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
81109f7c:	e0bffd17 	ldw	r2,-12(fp)
81109f80:	10800037 	ldwio	r2,0(r2)
81109f84:	1080010c 	andi	r2,r2,4
81109f88:	10000226 	beq	r2,zero,81109f94 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
81109f8c:	00bff904 	movi	r2,-28
81109f90:	00003d06 	br	8110a088 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
81109f94:	e0bfff17 	ldw	r2,-4(fp)
81109f98:	10800017 	ldw	r2,0(r2)
81109f9c:	1007883a 	mov	r3,r2
81109fa0:	e0bffe17 	ldw	r2,-8(fp)
81109fa4:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
81109fa8:	e0bffe17 	ldw	r2,-8(fp)
81109fac:	10800104 	addi	r2,r2,4
81109fb0:	e0ffff17 	ldw	r3,-4(fp)
81109fb4:	18c00117 	ldw	r3,4(r3)
81109fb8:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
81109fbc:	e0bffe17 	ldw	r2,-8(fp)
81109fc0:	10800204 	addi	r2,r2,8
81109fc4:	e0ffff17 	ldw	r3,-4(fp)
81109fc8:	18c00217 	ldw	r3,8(r3)
81109fcc:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
81109fd0:	e0bffe17 	ldw	r2,-8(fp)
81109fd4:	10800304 	addi	r2,r2,12
81109fd8:	e0ffff17 	ldw	r3,-4(fp)
81109fdc:	18c0030b 	ldhu	r3,12(r3)
81109fe0:	18ffffcc 	andi	r3,r3,65535
81109fe4:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
81109fe8:	e0bffe17 	ldw	r2,-8(fp)
81109fec:	10800384 	addi	r2,r2,14
81109ff0:	e0ffff17 	ldw	r3,-4(fp)
81109ff4:	18c00383 	ldbu	r3,14(r3)
81109ff8:	18c03fcc 	andi	r3,r3,255
81109ffc:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110a000:	e0bffe17 	ldw	r2,-8(fp)
8110a004:	108003c4 	addi	r2,r2,15
8110a008:	e0ffff17 	ldw	r3,-4(fp)
8110a00c:	18c003c3 	ldbu	r3,15(r3)
8110a010:	18c03fcc 	andi	r3,r3,255
8110a014:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110a018:	e0bffe17 	ldw	r2,-8(fp)
8110a01c:	10800404 	addi	r2,r2,16
8110a020:	e0ffff17 	ldw	r3,-4(fp)
8110a024:	18c0040b 	ldhu	r3,16(r3)
8110a028:	18ffffcc 	andi	r3,r3,65535
8110a02c:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110a030:	e0bffe17 	ldw	r2,-8(fp)
8110a034:	10800484 	addi	r2,r2,18
8110a038:	e0ffff17 	ldw	r3,-4(fp)
8110a03c:	18c0048b 	ldhu	r3,18(r3)
8110a040:	18ffffcc 	andi	r3,r3,65535
8110a044:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110a048:	e0bffe17 	ldw	r2,-8(fp)
8110a04c:	10800504 	addi	r2,r2,20
8110a050:	e0ffff17 	ldw	r3,-4(fp)
8110a054:	18c00517 	ldw	r3,20(r3)
8110a058:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110a05c:	e0bffe17 	ldw	r2,-8(fp)
8110a060:	10800604 	addi	r2,r2,24
8110a064:	e0ffff17 	ldw	r3,-4(fp)
8110a068:	18c00617 	ldw	r3,24(r3)
8110a06c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110a070:	e0bffe17 	ldw	r2,-8(fp)
8110a074:	10800704 	addi	r2,r2,28
8110a078:	e0ffff17 	ldw	r3,-4(fp)
8110a07c:	18c00717 	ldw	r3,28(r3)
8110a080:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110a084:	0005883a 	mov	r2,zero
}
8110a088:	e037883a 	mov	sp,fp
8110a08c:	df000017 	ldw	fp,0(sp)
8110a090:	dec00104 	addi	sp,sp,4
8110a094:	f800283a 	ret

8110a098 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110a098:	defff604 	addi	sp,sp,-40
8110a09c:	de00012e 	bgeu	sp,et,8110a0a4 <msgdma_construct_extended_descriptor+0xc>
8110a0a0:	003b68fa 	trap	3
8110a0a4:	df000915 	stw	fp,36(sp)
8110a0a8:	df000904 	addi	fp,sp,36
8110a0ac:	e13ff715 	stw	r4,-36(fp)
8110a0b0:	e17ff815 	stw	r5,-32(fp)
8110a0b4:	e1bff915 	stw	r6,-28(fp)
8110a0b8:	e1fffa15 	stw	r7,-24(fp)
8110a0bc:	e1800517 	ldw	r6,20(fp)
8110a0c0:	e1400617 	ldw	r5,24(fp)
8110a0c4:	e1000717 	ldw	r4,28(fp)
8110a0c8:	e0c00817 	ldw	r3,32(fp)
8110a0cc:	e0800917 	ldw	r2,36(fp)
8110a0d0:	e1bffb0d 	sth	r6,-20(fp)
8110a0d4:	e17ffc05 	stb	r5,-16(fp)
8110a0d8:	e13ffd05 	stb	r4,-12(fp)
8110a0dc:	e0fffe0d 	sth	r3,-8(fp)
8110a0e0:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110a0e4:	e0bff717 	ldw	r2,-36(fp)
8110a0e8:	10c01217 	ldw	r3,72(r2)
8110a0ec:	e0800117 	ldw	r2,4(fp)
8110a0f0:	18801936 	bltu	r3,r2,8110a158 <msgdma_construct_extended_descriptor+0xc0>
8110a0f4:	e13ff717 	ldw	r4,-36(fp)
8110a0f8:	20801317 	ldw	r2,76(r4)
8110a0fc:	20c01417 	ldw	r3,80(r4)
8110a100:	e13ffe0b 	ldhu	r4,-8(fp)
8110a104:	213fffcc 	andi	r4,r4,65535
8110a108:	2015883a 	mov	r10,r4
8110a10c:	0017883a 	mov	r11,zero
8110a110:	1ac01136 	bltu	r3,r11,8110a158 <msgdma_construct_extended_descriptor+0xc0>
8110a114:	58c0011e 	bne	r11,r3,8110a11c <msgdma_construct_extended_descriptor+0x84>
8110a118:	12800f36 	bltu	r2,r10,8110a158 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110a11c:	e13ff717 	ldw	r4,-36(fp)
8110a120:	20801317 	ldw	r2,76(r4)
8110a124:	20c01417 	ldw	r3,80(r4)
8110a128:	e13fff0b 	ldhu	r4,-4(fp)
8110a12c:	213fffcc 	andi	r4,r4,65535
8110a130:	2011883a 	mov	r8,r4
8110a134:	0013883a 	mov	r9,zero
8110a138:	1a400736 	bltu	r3,r9,8110a158 <msgdma_construct_extended_descriptor+0xc0>
8110a13c:	48c0011e 	bne	r9,r3,8110a144 <msgdma_construct_extended_descriptor+0xac>
8110a140:	12000536 	bltu	r2,r8,8110a158 <msgdma_construct_extended_descriptor+0xc0>
8110a144:	e0bff717 	ldw	r2,-36(fp)
8110a148:	10801703 	ldbu	r2,92(r2)
8110a14c:	10803fcc 	andi	r2,r2,255
8110a150:	10800060 	cmpeqi	r2,r2,1
8110a154:	1000021e 	bne	r2,zero,8110a160 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110a158:	00bffa84 	movi	r2,-22
8110a15c:	00002306 	br	8110a1ec <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110a160:	e0bff817 	ldw	r2,-32(fp)
8110a164:	e0fff917 	ldw	r3,-28(fp)
8110a168:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110a16c:	e0bff817 	ldw	r2,-32(fp)
8110a170:	e0fffa17 	ldw	r3,-24(fp)
8110a174:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110a178:	e0bff817 	ldw	r2,-32(fp)
8110a17c:	e0c00117 	ldw	r3,4(fp)
8110a180:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110a184:	e0bff817 	ldw	r2,-32(fp)
8110a188:	e0fffb0b 	ldhu	r3,-20(fp)
8110a18c:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110a190:	e0bff817 	ldw	r2,-32(fp)
8110a194:	e0fffc03 	ldbu	r3,-16(fp)
8110a198:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110a19c:	e0bff817 	ldw	r2,-32(fp)
8110a1a0:	e0fffd03 	ldbu	r3,-12(fp)
8110a1a4:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110a1a8:	e0bff817 	ldw	r2,-32(fp)
8110a1ac:	e0fffe0b 	ldhu	r3,-8(fp)
8110a1b0:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110a1b4:	e0bff817 	ldw	r2,-32(fp)
8110a1b8:	e0ffff0b 	ldhu	r3,-4(fp)
8110a1bc:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110a1c0:	e0bff817 	ldw	r2,-32(fp)
8110a1c4:	e0c00317 	ldw	r3,12(fp)
8110a1c8:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110a1cc:	e0bff817 	ldw	r2,-32(fp)
8110a1d0:	e0c00417 	ldw	r3,16(fp)
8110a1d4:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110a1d8:	e0800217 	ldw	r2,8(fp)
8110a1dc:	10e00034 	orhi	r3,r2,32768
8110a1e0:	e0bff817 	ldw	r2,-32(fp)
8110a1e4:	10c00715 	stw	r3,28(r2)

	return 0;
8110a1e8:	0005883a 	mov	r2,zero

}
8110a1ec:	e037883a 	mov	sp,fp
8110a1f0:	df000017 	ldw	fp,0(sp)
8110a1f4:	dec00104 	addi	sp,sp,4
8110a1f8:	f800283a 	ret

8110a1fc <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a1fc:	deffee04 	addi	sp,sp,-72
8110a200:	de00012e 	bgeu	sp,et,8110a208 <msgdma_descriptor_async_transfer+0xc>
8110a204:	003b68fa 	trap	3
8110a208:	dfc01115 	stw	ra,68(sp)
8110a20c:	df001015 	stw	fp,64(sp)
8110a210:	df001004 	addi	fp,sp,64
8110a214:	e13ffd15 	stw	r4,-12(fp)
8110a218:	e17ffe15 	stw	r5,-8(fp)
8110a21c:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a220:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110a224:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110a228:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a22c:	e0bffd17 	ldw	r2,-12(fp)
8110a230:	10800317 	ldw	r2,12(r2)
8110a234:	10800204 	addi	r2,r2,8
8110a238:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a23c:	10bfffcc 	andi	r2,r2,65535
8110a240:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a244:	e0bffd17 	ldw	r2,-12(fp)
8110a248:	10800317 	ldw	r2,12(r2)
8110a24c:	10800204 	addi	r2,r2,8
8110a250:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a254:	1004d43a 	srli	r2,r2,16
8110a258:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a25c:	e0bffd17 	ldw	r2,-12(fp)
8110a260:	10800917 	ldw	r2,36(r2)
8110a264:	e0fff417 	ldw	r3,-48(fp)
8110a268:	1880042e 	bgeu	r3,r2,8110a27c <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a26c:	e0bffd17 	ldw	r2,-12(fp)
8110a270:	10800917 	ldw	r2,36(r2)
8110a274:	e0fff317 	ldw	r3,-52(fp)
8110a278:	18800236 	bltu	r3,r2,8110a284 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110a27c:	00bff904 	movi	r2,-28
8110a280:	00009f06 	br	8110a500 <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110a284:	e0bffd17 	ldw	r2,-12(fp)
8110a288:	10801817 	ldw	r2,96(r2)
8110a28c:	e0bff615 	stw	r2,-40(fp)
8110a290:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110a294:	e0bffc0b 	ldhu	r2,-16(fp)
8110a298:	e0fffc84 	addi	r3,fp,-14
8110a29c:	180d883a 	mov	r6,r3
8110a2a0:	100b883a 	mov	r5,r2
8110a2a4:	e13ff617 	ldw	r4,-40(fp)
8110a2a8:	113946c0 	call	8113946c <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110a2ac:	00800804 	movi	r2,32
8110a2b0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a2b4:	0005303a 	rdctl	r2,status
8110a2b8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a2bc:	e0fff717 	ldw	r3,-36(fp)
8110a2c0:	00bfff84 	movi	r2,-2
8110a2c4:	1884703a 	and	r2,r3,r2
8110a2c8:	1001703a 	wrctl	status,r2
  
  return context;
8110a2cc:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a2d0:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a2d4:	e0bffd17 	ldw	r2,-12(fp)
8110a2d8:	10800317 	ldw	r2,12(r2)
8110a2dc:	10800104 	addi	r2,r2,4
8110a2e0:	e0fff117 	ldw	r3,-60(fp)
8110a2e4:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a2e8:	e0bffd17 	ldw	r2,-12(fp)
8110a2ec:	10800317 	ldw	r2,12(r2)
8110a2f0:	e0fffd17 	ldw	r3,-12(fp)
8110a2f4:	18c00317 	ldw	r3,12(r3)
8110a2f8:	18c00037 	ldwio	r3,0(r3)
8110a2fc:	10c00035 	stwio	r3,0(r2)
8110a300:	e0bff217 	ldw	r2,-56(fp)
8110a304:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a308:	e0bffb17 	ldw	r2,-20(fp)
8110a30c:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110a310:	e0bffe17 	ldw	r2,-8(fp)
8110a314:	10001026 	beq	r2,zero,8110a358 <msgdma_descriptor_async_transfer+0x15c>
8110a318:	e0bfff17 	ldw	r2,-4(fp)
8110a31c:	10000e1e 	bne	r2,zero,8110a358 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
8110a320:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110a324:	d0a05c17 	ldw	r2,-32400(gp)
8110a328:	100f883a 	mov	r7,r2
8110a32c:	01800784 	movi	r6,30
8110a330:	01400044 	movi	r5,1
8110a334:	01204534 	movhi	r4,33044
8110a338:	211afd04 	addi	r4,r4,27636
8110a33c:	111ba2c0 	call	8111ba2c <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a340:	e0bffd17 	ldw	r2,-12(fp)
8110a344:	10801817 	ldw	r2,96(r2)
8110a348:	1009883a 	mov	r4,r2
8110a34c:	11397f40 	call	811397f4 <OSSemPost>

		return -ETIME;
8110a350:	00bff084 	movi	r2,-62
8110a354:	00006a06 	br	8110a500 <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a358:	e0bffe17 	ldw	r2,-8(fp)
8110a35c:	1000231e 	bne	r2,zero,8110a3ec <msgdma_descriptor_async_transfer+0x1f0>
8110a360:	e0bfff17 	ldw	r2,-4(fp)
8110a364:	10002126 	beq	r2,zero,8110a3ec <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
8110a368:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a36c:	00001506 	br	8110a3c4 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110a370:	01000044 	movi	r4,1
8110a374:	1130bf40 	call	81130bf4 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a378:	e0bff00b 	ldhu	r2,-64(fp)
8110a37c:	1084e230 	cmpltui	r2,r2,5000
8110a380:	10000d1e 	bne	r2,zero,8110a3b8 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
8110a384:	d0a05c17 	ldw	r2,-32400(gp)
8110a388:	100f883a 	mov	r7,r2
8110a38c:	01801544 	movi	r6,85
8110a390:	01400044 	movi	r5,1
8110a394:	01204534 	movhi	r4,33044
8110a398:	211b0504 	addi	r4,r4,27668
8110a39c:	111ba2c0 	call	8111ba2c <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110a3a0:	e0bffd17 	ldw	r2,-12(fp)
8110a3a4:	10801817 	ldw	r2,96(r2)
8110a3a8:	1009883a 	mov	r4,r2
8110a3ac:	11397f40 	call	811397f4 <OSSemPost>

				return -ETIME;
8110a3b0:	00bff084 	movi	r2,-62
8110a3b4:	00005206 	br	8110a500 <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
8110a3b8:	e0bff00b 	ldhu	r2,-64(fp)
8110a3bc:	10800044 	addi	r2,r2,1
8110a3c0:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110a3c4:	e0bffd17 	ldw	r2,-12(fp)
8110a3c8:	10c00317 	ldw	r3,12(r2)
8110a3cc:	e0bffd17 	ldw	r2,-12(fp)
8110a3d0:	10800417 	ldw	r2,16(r2)
8110a3d4:	e1bfff17 	ldw	r6,-4(fp)
8110a3d8:	100b883a 	mov	r5,r2
8110a3dc:	1809883a 	mov	r4,r3
8110a3e0:	1109f5c0 	call	81109f5c <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a3e4:	103fe21e 	bne	r2,zero,8110a370 <__reset+0xfb0ea370>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a3e8:	00000606 	br	8110a404 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a3ec:	e0bffd17 	ldw	r2,-12(fp)
8110a3f0:	10801817 	ldw	r2,96(r2)
8110a3f4:	1009883a 	mov	r4,r2
8110a3f8:	11397f40 	call	811397f4 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110a3fc:	00bfffc4 	movi	r2,-1
8110a400:	00003f06 	br	8110a500 <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110a404:	e0bffd17 	ldw	r2,-12(fp)
8110a408:	10800b17 	ldw	r2,44(r2)
8110a40c:	10001c26 	beq	r2,zero,8110a480 <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
8110a410:	e0bffd17 	ldw	r2,-12(fp)
8110a414:	10c00d17 	ldw	r3,52(r2)
8110a418:	e0bff117 	ldw	r2,-60(fp)
8110a41c:	1884b03a 	or	r2,r3,r2
8110a420:	10800514 	ori	r2,r2,20
8110a424:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110a428:	e0fff117 	ldw	r3,-60(fp)
8110a42c:	00bff7c4 	movi	r2,-33
8110a430:	1884703a 	and	r2,r3,r2
8110a434:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a438:	0005303a 	rdctl	r2,status
8110a43c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a440:	e0fff917 	ldw	r3,-28(fp)
8110a444:	00bfff84 	movi	r2,-2
8110a448:	1884703a 	and	r2,r3,r2
8110a44c:	1001703a 	wrctl	status,r2
  
  return context;
8110a450:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a454:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a458:	e0bffd17 	ldw	r2,-12(fp)
8110a45c:	10800317 	ldw	r2,12(r2)
8110a460:	10800104 	addi	r2,r2,4
8110a464:	e0fff117 	ldw	r3,-60(fp)
8110a468:	10c00035 	stwio	r3,0(r2)
8110a46c:	e0bff217 	ldw	r2,-56(fp)
8110a470:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a474:	e0bff517 	ldw	r2,-44(fp)
8110a478:	1001703a 	wrctl	status,r2
8110a47c:	00001b06 	br	8110a4ec <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110a480:	e0bffd17 	ldw	r2,-12(fp)
8110a484:	10c00d17 	ldw	r3,52(r2)
8110a488:	e0bff117 	ldw	r2,-60(fp)
8110a48c:	1884b03a 	or	r2,r3,r2
8110a490:	10800114 	ori	r2,r2,4
8110a494:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110a498:	e0fff117 	ldw	r3,-60(fp)
8110a49c:	00bff3c4 	movi	r2,-49
8110a4a0:	1884703a 	and	r2,r3,r2
8110a4a4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a4a8:	0005303a 	rdctl	r2,status
8110a4ac:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a4b0:	e0fffa17 	ldw	r3,-24(fp)
8110a4b4:	00bfff84 	movi	r2,-2
8110a4b8:	1884703a 	and	r2,r3,r2
8110a4bc:	1001703a 	wrctl	status,r2
  
  return context;
8110a4c0:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a4c4:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a4c8:	e0bffd17 	ldw	r2,-12(fp)
8110a4cc:	10800317 	ldw	r2,12(r2)
8110a4d0:	10800104 	addi	r2,r2,4
8110a4d4:	e0fff117 	ldw	r3,-60(fp)
8110a4d8:	10c00035 	stwio	r3,0(r2)
8110a4dc:	e0bff217 	ldw	r2,-56(fp)
8110a4e0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a4e4:	e0bff817 	ldw	r2,-32(fp)
8110a4e8:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110a4ec:	e0bffd17 	ldw	r2,-12(fp)
8110a4f0:	10801817 	ldw	r2,96(r2)
8110a4f4:	1009883a 	mov	r4,r2
8110a4f8:	11397f40 	call	811397f4 <OSSemPost>

	return 0;
8110a4fc:	0005883a 	mov	r2,zero
}
8110a500:	e037883a 	mov	sp,fp
8110a504:	dfc00117 	ldw	ra,4(sp)
8110a508:	df000017 	ldw	fp,0(sp)
8110a50c:	dec00204 	addi	sp,sp,8
8110a510:	f800283a 	ret

8110a514 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a514:	deffee04 	addi	sp,sp,-72
8110a518:	de00012e 	bgeu	sp,et,8110a520 <msgdma_descriptor_sync_transfer+0xc>
8110a51c:	003b68fa 	trap	3
8110a520:	dfc01115 	stw	ra,68(sp)
8110a524:	df001015 	stw	fp,64(sp)
8110a528:	df001004 	addi	fp,sp,64
8110a52c:	e13ffd15 	stw	r4,-12(fp)
8110a530:	e17ffe15 	stw	r5,-8(fp)
8110a534:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a538:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110a53c:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110a540:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110a544:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a548:	e0bffd17 	ldw	r2,-12(fp)
8110a54c:	10800317 	ldw	r2,12(r2)
8110a550:	10800204 	addi	r2,r2,8
8110a554:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a558:	10bfffcc 	andi	r2,r2,65535
8110a55c:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a560:	e0bffd17 	ldw	r2,-12(fp)
8110a564:	10800317 	ldw	r2,12(r2)
8110a568:	10800204 	addi	r2,r2,8
8110a56c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a570:	1004d43a 	srli	r2,r2,16
8110a574:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110a578:	00807804 	movi	r2,480
8110a57c:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a580:	00001d06 	br	8110a5f8 <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110a584:	01000044 	movi	r4,1
8110a588:	1130bf40 	call	81130bf4 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a58c:	e0bff10b 	ldhu	r2,-60(fp)
8110a590:	1084e230 	cmpltui	r2,r2,5000
8110a594:	1000091e 	bne	r2,zero,8110a5bc <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
8110a598:	d0a05c17 	ldw	r2,-32400(gp)
8110a59c:	100f883a 	mov	r7,r2
8110a5a0:	01801304 	movi	r6,76
8110a5a4:	01400044 	movi	r5,1
8110a5a8:	01204534 	movhi	r4,33044
8110a5ac:	211b1b04 	addi	r4,r4,27756
8110a5b0:	111ba2c0 	call	8111ba2c <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110a5b4:	00bff084 	movi	r2,-62
8110a5b8:	0000d006 	br	8110a8fc <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110a5bc:	e0bff10b 	ldhu	r2,-60(fp)
8110a5c0:	10800044 	addi	r2,r2,1
8110a5c4:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a5c8:	e0bffd17 	ldw	r2,-12(fp)
8110a5cc:	10800317 	ldw	r2,12(r2)
8110a5d0:	10800204 	addi	r2,r2,8
8110a5d4:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110a5d8:	10bfffcc 	andi	r2,r2,65535
8110a5dc:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a5e0:	e0bffd17 	ldw	r2,-12(fp)
8110a5e4:	10800317 	ldw	r2,12(r2)
8110a5e8:	10800204 	addi	r2,r2,8
8110a5ec:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110a5f0:	1004d43a 	srli	r2,r2,16
8110a5f4:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a5f8:	e0bffd17 	ldw	r2,-12(fp)
8110a5fc:	10800917 	ldw	r2,36(r2)
8110a600:	e0fff317 	ldw	r3,-52(fp)
8110a604:	18bfdf2e 	bgeu	r3,r2,8110a584 <__reset+0xfb0ea584>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a608:	e0bffd17 	ldw	r2,-12(fp)
8110a60c:	10800917 	ldw	r2,36(r2)
8110a610:	e0fff217 	ldw	r3,-56(fp)
8110a614:	18bfdb2e 	bgeu	r3,r2,8110a584 <__reset+0xfb0ea584>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110a618:	e0bffd17 	ldw	r2,-12(fp)
8110a61c:	10801817 	ldw	r2,96(r2)
8110a620:	e0bff815 	stw	r2,-32(fp)
8110a624:	e03ffc0d 	sth	zero,-16(fp)
8110a628:	e0bffc0b 	ldhu	r2,-16(fp)
8110a62c:	e0fffc84 	addi	r3,fp,-14
8110a630:	180d883a 	mov	r6,r3
8110a634:	100b883a 	mov	r5,r2
8110a638:	e13ff817 	ldw	r4,-32(fp)
8110a63c:	113946c0 	call	8113946c <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a640:	0005303a 	rdctl	r2,status
8110a644:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a648:	e0fffb17 	ldw	r3,-20(fp)
8110a64c:	00bfff84 	movi	r2,-2
8110a650:	1884703a 	and	r2,r3,r2
8110a654:	1001703a 	wrctl	status,r2
  
  return context;
8110a658:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a65c:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110a660:	e0bffd17 	ldw	r2,-12(fp)
8110a664:	10800317 	ldw	r2,12(r2)
8110a668:	10800104 	addi	r2,r2,4
8110a66c:	00c00804 	movi	r3,32
8110a670:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a674:	e0bffd17 	ldw	r2,-12(fp)
8110a678:	10800317 	ldw	r2,12(r2)
8110a67c:	e0fffd17 	ldw	r3,-12(fp)
8110a680:	18c00317 	ldw	r3,12(r3)
8110a684:	18c00037 	ldwio	r3,0(r3)
8110a688:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110a68c:	e0bffe17 	ldw	r2,-8(fp)
8110a690:	10001026 	beq	r2,zero,8110a6d4 <msgdma_descriptor_sync_transfer+0x1c0>
8110a694:	e0bfff17 	ldw	r2,-4(fp)
8110a698:	10000e1e 	bne	r2,zero,8110a6d4 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110a69c:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110a6a0:	d0a05c17 	ldw	r2,-32400(gp)
8110a6a4:	100f883a 	mov	r7,r2
8110a6a8:	01800784 	movi	r6,30
8110a6ac:	01400044 	movi	r5,1
8110a6b0:	01204534 	movhi	r4,33044
8110a6b4:	211afd04 	addi	r4,r4,27636
8110a6b8:	111ba2c0 	call	8111ba2c <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a6bc:	e0bffd17 	ldw	r2,-12(fp)
8110a6c0:	10801817 	ldw	r2,96(r2)
8110a6c4:	1009883a 	mov	r4,r2
8110a6c8:	11397f40 	call	811397f4 <OSSemPost>

		return -ETIME;
8110a6cc:	00bff084 	movi	r2,-62
8110a6d0:	00008a06 	br	8110a8fc <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a6d4:	e0bffe17 	ldw	r2,-8(fp)
8110a6d8:	1000231e 	bne	r2,zero,8110a768 <msgdma_descriptor_sync_transfer+0x254>
8110a6dc:	e0bfff17 	ldw	r2,-4(fp)
8110a6e0:	10002126 	beq	r2,zero,8110a768 <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
8110a6e4:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a6e8:	00001506 	br	8110a740 <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110a6ec:	01000044 	movi	r4,1
8110a6f0:	1130bf40 	call	81130bf4 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a6f4:	e0bff10b 	ldhu	r2,-60(fp)
8110a6f8:	1084e230 	cmpltui	r2,r2,5000
8110a6fc:	10000d1e 	bne	r2,zero,8110a734 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
8110a700:	d0a05c17 	ldw	r2,-32400(gp)
8110a704:	100f883a 	mov	r7,r2
8110a708:	01801004 	movi	r6,64
8110a70c:	01400044 	movi	r5,1
8110a710:	01204534 	movhi	r4,33044
8110a714:	211b2f04 	addi	r4,r4,27836
8110a718:	111ba2c0 	call	8111ba2c <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110a71c:	e0bffd17 	ldw	r2,-12(fp)
8110a720:	10801817 	ldw	r2,96(r2)
8110a724:	1009883a 	mov	r4,r2
8110a728:	11397f40 	call	811397f4 <OSSemPost>

				return -ETIME;
8110a72c:	00bff084 	movi	r2,-62
8110a730:	00007206 	br	8110a8fc <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
8110a734:	e0bff10b 	ldhu	r2,-60(fp)
8110a738:	10800044 	addi	r2,r2,1
8110a73c:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110a740:	e0bffd17 	ldw	r2,-12(fp)
8110a744:	10c00317 	ldw	r3,12(r2)
8110a748:	e0bffd17 	ldw	r2,-12(fp)
8110a74c:	10800417 	ldw	r2,16(r2)
8110a750:	e1bfff17 	ldw	r6,-4(fp)
8110a754:	100b883a 	mov	r5,r2
8110a758:	1809883a 	mov	r4,r3
8110a75c:	1109f5c0 	call	81109f5c <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a760:	103fe21e 	bne	r2,zero,8110a6ec <__reset+0xfb0ea6ec>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a764:	00000606 	br	8110a780 <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a768:	e0bffd17 	ldw	r2,-12(fp)
8110a76c:	10801817 	ldw	r2,96(r2)
8110a770:	1009883a 	mov	r4,r2
8110a774:	11397f40 	call	811397f4 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110a778:	00bfffc4 	movi	r2,-1
8110a77c:	00005f06 	br	8110a8fc <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110a780:	e0bffd17 	ldw	r2,-12(fp)
8110a784:	10800317 	ldw	r2,12(r2)
8110a788:	10800104 	addi	r2,r2,4
8110a78c:	e0fffd17 	ldw	r3,-12(fp)
8110a790:	19000d17 	ldw	r4,52(r3)
8110a794:	00fff2c4 	movi	r3,-53
8110a798:	20c6703a 	and	r3,r4,r3
8110a79c:	18c00114 	ori	r3,r3,4
8110a7a0:	10c00035 	stwio	r3,0(r2)
8110a7a4:	e0bff517 	ldw	r2,-44(fp)
8110a7a8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a7ac:	e0bff717 	ldw	r2,-36(fp)
8110a7b0:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110a7b4:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110a7b8:	e0bffd17 	ldw	r2,-12(fp)
8110a7bc:	10800317 	ldw	r2,12(r2)
8110a7c0:	10800037 	ldwio	r2,0(r2)
8110a7c4:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110a7c8:	00001906 	br	8110a830 <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
8110a7cc:	01000044 	movi	r4,1
8110a7d0:	1130bf40 	call	81130bf4 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a7d4:	e0bff10b 	ldhu	r2,-60(fp)
8110a7d8:	1084e230 	cmpltui	r2,r2,5000
8110a7dc:	10000d1e 	bne	r2,zero,8110a814 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
8110a7e0:	d0a05c17 	ldw	r2,-32400(gp)
8110a7e4:	100f883a 	mov	r7,r2
8110a7e8:	01801184 	movi	r6,70
8110a7ec:	01400044 	movi	r5,1
8110a7f0:	01204534 	movhi	r4,33044
8110a7f4:	211b4004 	addi	r4,r4,27904
8110a7f8:	111ba2c0 	call	8111ba2c <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110a7fc:	e0bffd17 	ldw	r2,-12(fp)
8110a800:	10801817 	ldw	r2,96(r2)
8110a804:	1009883a 	mov	r4,r2
8110a808:	11397f40 	call	811397f4 <OSSemPost>

			return -ETIME;
8110a80c:	00bff084 	movi	r2,-62
8110a810:	00003a06 	br	8110a8fc <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110a814:	e0bff10b 	ldhu	r2,-60(fp)
8110a818:	10800044 	addi	r2,r2,1
8110a81c:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110a820:	e0bffd17 	ldw	r2,-12(fp)
8110a824:	10800317 	ldw	r2,12(r2)
8110a828:	10800037 	ldwio	r2,0(r2)
8110a82c:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110a830:	e0fff017 	ldw	r3,-64(fp)
8110a834:	e0bff617 	ldw	r2,-40(fp)
8110a838:	1884703a 	and	r2,r3,r2
8110a83c:	1000031e 	bne	r2,zero,8110a84c <msgdma_descriptor_sync_transfer+0x338>
8110a840:	e0bff017 	ldw	r2,-64(fp)
8110a844:	1080004c 	andi	r2,r2,1
8110a848:	103fe01e 	bne	r2,zero,8110a7cc <__reset+0xfb0ea7cc>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110a84c:	e0fff017 	ldw	r3,-64(fp)
8110a850:	e0bff617 	ldw	r2,-40(fp)
8110a854:	1884703a 	and	r2,r3,r2
8110a858:	10000626 	beq	r2,zero,8110a874 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a85c:	e0bffd17 	ldw	r2,-12(fp)
8110a860:	10801817 	ldw	r2,96(r2)
8110a864:	1009883a 	mov	r4,r2
8110a868:	11397f40 	call	811397f4 <OSSemPost>

		return error;
8110a86c:	e0bff617 	ldw	r2,-40(fp)
8110a870:	00002206 	br	8110a8fc <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110a874:	e0bffd17 	ldw	r2,-12(fp)
8110a878:	10800317 	ldw	r2,12(r2)
8110a87c:	10800104 	addi	r2,r2,4
8110a880:	10800037 	ldwio	r2,0(r2)
8110a884:	10800814 	ori	r2,r2,32
8110a888:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a88c:	0005303a 	rdctl	r2,status
8110a890:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a894:	e0fffa17 	ldw	r3,-24(fp)
8110a898:	00bfff84 	movi	r2,-2
8110a89c:	1884703a 	and	r2,r3,r2
8110a8a0:	1001703a 	wrctl	status,r2
  
  return context;
8110a8a4:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a8a8:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a8ac:	e0bffd17 	ldw	r2,-12(fp)
8110a8b0:	10800317 	ldw	r2,12(r2)
8110a8b4:	10800104 	addi	r2,r2,4
8110a8b8:	e0fff417 	ldw	r3,-48(fp)
8110a8bc:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a8c0:	e0bffd17 	ldw	r2,-12(fp)
8110a8c4:	10800317 	ldw	r2,12(r2)
8110a8c8:	e0fffd17 	ldw	r3,-12(fp)
8110a8cc:	18c00317 	ldw	r3,12(r3)
8110a8d0:	18c00037 	ldwio	r3,0(r3)
8110a8d4:	10c00035 	stwio	r3,0(r2)
8110a8d8:	e0bff517 	ldw	r2,-44(fp)
8110a8dc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a8e0:	e0bff917 	ldw	r2,-28(fp)
8110a8e4:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110a8e8:	e0bffd17 	ldw	r2,-12(fp)
8110a8ec:	10801817 	ldw	r2,96(r2)
8110a8f0:	1009883a 	mov	r4,r2
8110a8f4:	11397f40 	call	811397f4 <OSSemPost>

	return 0;
8110a8f8:	0005883a 	mov	r2,zero

}
8110a8fc:	e037883a 	mov	sp,fp
8110a900:	dfc00117 	ldw	ra,4(sp)
8110a904:	df000017 	ldw	fp,0(sp)
8110a908:	dec00204 	addi	sp,sp,8
8110a90c:	f800283a 	ret

8110a910 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110a910:	deffec04 	addi	sp,sp,-80
8110a914:	de00012e 	bgeu	sp,et,8110a91c <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110a918:	003b68fa 	trap	3
8110a91c:	dfc01315 	stw	ra,76(sp)
8110a920:	df001215 	stw	fp,72(sp)
8110a924:	df001204 	addi	fp,sp,72
8110a928:	e13ff715 	stw	r4,-36(fp)
8110a92c:	e17ff815 	stw	r5,-32(fp)
8110a930:	e1bff915 	stw	r6,-28(fp)
8110a934:	e1fffa15 	stw	r7,-24(fp)
8110a938:	e1800617 	ldw	r6,24(fp)
8110a93c:	e1400717 	ldw	r5,28(fp)
8110a940:	e1000817 	ldw	r4,32(fp)
8110a944:	e0c00917 	ldw	r3,36(fp)
8110a948:	e0800a17 	ldw	r2,40(fp)
8110a94c:	e1bffb0d 	sth	r6,-20(fp)
8110a950:	e17ffc05 	stb	r5,-16(fp)
8110a954:	e13ffd05 	stb	r4,-12(fp)
8110a958:	e0fffe0d 	sth	r3,-8(fp)
8110a95c:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110a960:	e0bffb0b 	ldhu	r2,-20(fp)
8110a964:	e0fffc03 	ldbu	r3,-16(fp)
8110a968:	e13ffd03 	ldbu	r4,-12(fp)
8110a96c:	e17ffe0b 	ldhu	r5,-8(fp)
8110a970:	e1bfff0b 	ldhu	r6,-4(fp)
8110a974:	d9800815 	stw	r6,32(sp)
8110a978:	d9400715 	stw	r5,28(sp)
8110a97c:	d9000615 	stw	r4,24(sp)
8110a980:	d8c00515 	stw	r3,20(sp)
8110a984:	d8800415 	stw	r2,16(sp)
8110a988:	e0800517 	ldw	r2,20(fp)
8110a98c:	d8800315 	stw	r2,12(sp)
8110a990:	e0800417 	ldw	r2,16(fp)
8110a994:	d8800215 	stw	r2,8(sp)
8110a998:	e0800317 	ldw	r2,12(fp)
8110a99c:	d8800115 	stw	r2,4(sp)
8110a9a0:	e0800217 	ldw	r2,8(fp)
8110a9a4:	d8800015 	stw	r2,0(sp)
8110a9a8:	e1fffa17 	ldw	r7,-24(fp)
8110a9ac:	e1bff917 	ldw	r6,-28(fp)
8110a9b0:	e17ff817 	ldw	r5,-32(fp)
8110a9b4:	e13ff717 	ldw	r4,-36(fp)
8110a9b8:	110a0980 	call	8110a098 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110a9bc:	e037883a 	mov	sp,fp
8110a9c0:	dfc00117 	ldw	ra,4(sp)
8110a9c4:	df000017 	ldw	fp,0(sp)
8110a9c8:	dec00204 	addi	sp,sp,8
8110a9cc:	f800283a 	ret

8110a9d0 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110a9d0:	defffc04 	addi	sp,sp,-16
8110a9d4:	de00012e 	bgeu	sp,et,8110a9dc <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110a9d8:	003b68fa 	trap	3
8110a9dc:	dfc00315 	stw	ra,12(sp)
8110a9e0:	df000215 	stw	fp,8(sp)
8110a9e4:	df000204 	addi	fp,sp,8
8110a9e8:	e13ffe15 	stw	r4,-8(fp)
8110a9ec:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110a9f0:	e1bfff17 	ldw	r6,-4(fp)
8110a9f4:	000b883a 	mov	r5,zero
8110a9f8:	e13ffe17 	ldw	r4,-8(fp)
8110a9fc:	110a1fc0 	call	8110a1fc <msgdma_descriptor_async_transfer>
}
8110aa00:	e037883a 	mov	sp,fp
8110aa04:	dfc00117 	ldw	ra,4(sp)
8110aa08:	df000017 	ldw	fp,0(sp)
8110aa0c:	dec00204 	addi	sp,sp,8
8110aa10:	f800283a 	ret

8110aa14 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110aa14:	defffc04 	addi	sp,sp,-16
8110aa18:	de00012e 	bgeu	sp,et,8110aa20 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110aa1c:	003b68fa 	trap	3
8110aa20:	dfc00315 	stw	ra,12(sp)
8110aa24:	df000215 	stw	fp,8(sp)
8110aa28:	df000204 	addi	fp,sp,8
8110aa2c:	e13ffe15 	stw	r4,-8(fp)
8110aa30:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110aa34:	e1bfff17 	ldw	r6,-4(fp)
8110aa38:	000b883a 	mov	r5,zero
8110aa3c:	e13ffe17 	ldw	r4,-8(fp)
8110aa40:	110a5140 	call	8110a514 <msgdma_descriptor_sync_transfer>
}
8110aa44:	e037883a 	mov	sp,fp
8110aa48:	dfc00117 	ldw	ra,4(sp)
8110aa4c:	df000017 	ldw	fp,0(sp)
8110aa50:	dec00204 	addi	sp,sp,8
8110aa54:	f800283a 	ret

8110aa58 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110aa58:	defff204 	addi	sp,sp,-56
8110aa5c:	de00012e 	bgeu	sp,et,8110aa64 <POWER_SPI_RW+0xc>
8110aa60:	003b68fa 	trap	3
8110aa64:	dfc00d15 	stw	ra,52(sp)
8110aa68:	df000c15 	stw	fp,48(sp)
8110aa6c:	df000c04 	addi	fp,sp,48
8110aa70:	2007883a 	mov	r3,r4
8110aa74:	2805883a 	mov	r2,r5
8110aa78:	e1bffe15 	stw	r6,-8(fp)
8110aa7c:	e1ffff15 	stw	r7,-4(fp)
8110aa80:	e0fffc05 	stb	r3,-16(fp)
8110aa84:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110aa88:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110aa8c:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110aa90:	008003f4 	movhi	r2,15
8110aa94:	10909004 	addi	r2,r2,16960
8110aa98:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110aa9c:	00bfe004 	movi	r2,-128
8110aaa0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110aaa4:	e0bffe17 	ldw	r2,-8(fp)
8110aaa8:	10000226 	beq	r2,zero,8110aab4 <POWER_SPI_RW+0x5c>
8110aaac:	00800804 	movi	r2,32
8110aab0:	00000106 	br	8110aab8 <POWER_SPI_RW+0x60>
8110aab4:	0005883a 	mov	r2,zero
8110aab8:	e0fff403 	ldbu	r3,-48(fp)
8110aabc:	10c4b03a 	or	r2,r2,r3
8110aac0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110aac4:	e0800217 	ldw	r2,8(fp)
8110aac8:	10000226 	beq	r2,zero,8110aad4 <POWER_SPI_RW+0x7c>
8110aacc:	00800404 	movi	r2,16
8110aad0:	00000106 	br	8110aad8 <POWER_SPI_RW+0x80>
8110aad4:	0005883a 	mov	r2,zero
8110aad8:	e0fff403 	ldbu	r3,-48(fp)
8110aadc:	10c4b03a 	or	r2,r2,r3
8110aae0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110aae4:	e0bfff17 	ldw	r2,-4(fp)
8110aae8:	10000226 	beq	r2,zero,8110aaf4 <POWER_SPI_RW+0x9c>
8110aaec:	00800204 	movi	r2,8
8110aaf0:	00000106 	br	8110aaf8 <POWER_SPI_RW+0xa0>
8110aaf4:	0005883a 	mov	r2,zero
8110aaf8:	e0fff403 	ldbu	r3,-48(fp)
8110aafc:	10c4b03a 	or	r2,r2,r3
8110ab00:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110ab04:	e0bffd03 	ldbu	r2,-12(fp)
8110ab08:	108001cc 	andi	r2,r2,7
8110ab0c:	1007883a 	mov	r3,r2
8110ab10:	e0bff403 	ldbu	r2,-48(fp)
8110ab14:	1884b03a 	or	r2,r3,r2
8110ab18:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110ab1c:	0007883a 	mov	r3,zero
8110ab20:	00a00034 	movhi	r2,32768
8110ab24:	10824404 	addi	r2,r2,2320
8110ab28:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110ab2c:	0007883a 	mov	r3,zero
8110ab30:	00a00034 	movhi	r2,32768
8110ab34:	10824c04 	addi	r2,r2,2352
8110ab38:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110ab3c:	e0bffc03 	ldbu	r2,-16(fp)
8110ab40:	1000021e 	bne	r2,zero,8110ab4c <POWER_SPI_RW+0xf4>
8110ab44:	00c00084 	movi	r3,2
8110ab48:	00000106 	br	8110ab50 <POWER_SPI_RW+0xf8>
8110ab4c:	00c00044 	movi	r3,1
8110ab50:	00a00034 	movhi	r2,32768
8110ab54:	10824804 	addi	r2,r2,2336
8110ab58:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110ab5c:	010003c4 	movi	r4,15
8110ab60:	11326680 	call	81132668 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110ab64:	00000306 	br	8110ab74 <POWER_SPI_RW+0x11c>
		nWait++;
8110ab68:	e0bff817 	ldw	r2,-32(fp)
8110ab6c:	10800044 	addi	r2,r2,1
8110ab70:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110ab74:	00a00034 	movhi	r2,32768
8110ab78:	10825404 	addi	r2,r2,2384
8110ab7c:	10800037 	ldwio	r2,0(r2)
8110ab80:	1080004c 	andi	r2,r2,1
8110ab84:	10000326 	beq	r2,zero,8110ab94 <POWER_SPI_RW+0x13c>
8110ab88:	e0fff817 	ldw	r3,-32(fp)
8110ab8c:	e0bffa17 	ldw	r2,-24(fp)
8110ab90:	18bff516 	blt	r3,r2,8110ab68 <__reset+0xfb0eab68>
		nWait++;
	}

	if (SPI_SDO) {
8110ab94:	00a00034 	movhi	r2,32768
8110ab98:	10825404 	addi	r2,r2,2384
8110ab9c:	10800037 	ldwio	r2,0(r2)
8110aba0:	1080004c 	andi	r2,r2,1
8110aba4:	10000626 	beq	r2,zero,8110abc0 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110aba8:	00c000c4 	movi	r3,3
8110abac:	00a00034 	movhi	r2,32768
8110abb0:	10824804 	addi	r2,r2,2336
8110abb4:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110abb8:	0005883a 	mov	r2,zero
8110abbc:	0000db06 	br	8110af2c <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110abc0:	e03ff715 	stw	zero,-36(fp)
8110abc4:	00002406 	br	8110ac58 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110abc8:	e0bff403 	ldbu	r2,-48(fp)
8110abcc:	10803fcc 	andi	r2,r2,255
8110abd0:	1004d1fa 	srli	r2,r2,7
8110abd4:	10c03fcc 	andi	r3,r2,255
8110abd8:	00a00034 	movhi	r2,32768
8110abdc:	10825004 	addi	r2,r2,2368
8110abe0:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110abe4:	e0bff403 	ldbu	r2,-48(fp)
8110abe8:	1085883a 	add	r2,r2,r2
8110abec:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110abf0:	e0bff517 	ldw	r2,-44(fp)
8110abf4:	1085883a 	add	r2,r2,r2
8110abf8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110abfc:	00a00034 	movhi	r2,32768
8110ac00:	10825404 	addi	r2,r2,2384
8110ac04:	10800037 	ldwio	r2,0(r2)
8110ac08:	1080004c 	andi	r2,r2,1
8110ac0c:	1007883a 	mov	r3,r2
8110ac10:	e0bff517 	ldw	r2,-44(fp)
8110ac14:	10c4b03a 	or	r2,r2,r3
8110ac18:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110ac1c:	00c00044 	movi	r3,1
8110ac20:	00a00034 	movhi	r2,32768
8110ac24:	10824c04 	addi	r2,r2,2352
8110ac28:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ac2c:	010003c4 	movi	r4,15
8110ac30:	11326680 	call	81132668 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110ac34:	0007883a 	mov	r3,zero
8110ac38:	00a00034 	movhi	r2,32768
8110ac3c:	10824c04 	addi	r2,r2,2352
8110ac40:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ac44:	010003c4 	movi	r4,15
8110ac48:	11326680 	call	81132668 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110ac4c:	e0bff717 	ldw	r2,-36(fp)
8110ac50:	10800044 	addi	r2,r2,1
8110ac54:	e0bff715 	stw	r2,-36(fp)
8110ac58:	e0bff717 	ldw	r2,-36(fp)
8110ac5c:	10800090 	cmplti	r2,r2,2
8110ac60:	103fd91e 	bne	r2,zero,8110abc8 <__reset+0xfb0eabc8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110ac64:	e03ff715 	stw	zero,-36(fp)
8110ac68:	00002406 	br	8110acfc <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110ac6c:	e0bff403 	ldbu	r2,-48(fp)
8110ac70:	10803fcc 	andi	r2,r2,255
8110ac74:	1004d1fa 	srli	r2,r2,7
8110ac78:	10c03fcc 	andi	r3,r2,255
8110ac7c:	00a00034 	movhi	r2,32768
8110ac80:	10825004 	addi	r2,r2,2368
8110ac84:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110ac88:	e0bff403 	ldbu	r2,-48(fp)
8110ac8c:	1085883a 	add	r2,r2,r2
8110ac90:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110ac94:	e0bff517 	ldw	r2,-44(fp)
8110ac98:	1085883a 	add	r2,r2,r2
8110ac9c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110aca0:	00a00034 	movhi	r2,32768
8110aca4:	10825404 	addi	r2,r2,2384
8110aca8:	10800037 	ldwio	r2,0(r2)
8110acac:	1080004c 	andi	r2,r2,1
8110acb0:	1007883a 	mov	r3,r2
8110acb4:	e0bff517 	ldw	r2,-44(fp)
8110acb8:	10c4b03a 	or	r2,r2,r3
8110acbc:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110acc0:	00c00044 	movi	r3,1
8110acc4:	00a00034 	movhi	r2,32768
8110acc8:	10824c04 	addi	r2,r2,2352
8110accc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110acd0:	010003c4 	movi	r4,15
8110acd4:	11326680 	call	81132668 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110acd8:	0007883a 	mov	r3,zero
8110acdc:	00a00034 	movhi	r2,32768
8110ace0:	10824c04 	addi	r2,r2,2352
8110ace4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ace8:	010003c4 	movi	r4,15
8110acec:	11326680 	call	81132668 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110acf0:	e0bff717 	ldw	r2,-36(fp)
8110acf4:	10800044 	addi	r2,r2,1
8110acf8:	e0bff715 	stw	r2,-36(fp)
8110acfc:	e0bff717 	ldw	r2,-36(fp)
8110ad00:	10800210 	cmplti	r2,r2,8
8110ad04:	103fd91e 	bne	r2,zero,8110ac6c <__reset+0xfb0eac6c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110ad08:	e03ff715 	stw	zero,-36(fp)
8110ad0c:	00001a06 	br	8110ad78 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110ad10:	e0bff517 	ldw	r2,-44(fp)
8110ad14:	1085883a 	add	r2,r2,r2
8110ad18:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110ad1c:	00a00034 	movhi	r2,32768
8110ad20:	10825404 	addi	r2,r2,2384
8110ad24:	10800037 	ldwio	r2,0(r2)
8110ad28:	1080004c 	andi	r2,r2,1
8110ad2c:	1007883a 	mov	r3,r2
8110ad30:	e0bff517 	ldw	r2,-44(fp)
8110ad34:	10c4b03a 	or	r2,r2,r3
8110ad38:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110ad3c:	00c00044 	movi	r3,1
8110ad40:	00a00034 	movhi	r2,32768
8110ad44:	10824c04 	addi	r2,r2,2352
8110ad48:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ad4c:	010003c4 	movi	r4,15
8110ad50:	11326680 	call	81132668 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110ad54:	0007883a 	mov	r3,zero
8110ad58:	00a00034 	movhi	r2,32768
8110ad5c:	10824c04 	addi	r2,r2,2352
8110ad60:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ad64:	010003c4 	movi	r4,15
8110ad68:	11326680 	call	81132668 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110ad6c:	e0bff717 	ldw	r2,-36(fp)
8110ad70:	10800044 	addi	r2,r2,1
8110ad74:	e0bff715 	stw	r2,-36(fp)
8110ad78:	e0bff717 	ldw	r2,-36(fp)
8110ad7c:	10800210 	cmplti	r2,r2,8
8110ad80:	103fe31e 	bne	r2,zero,8110ad10 <__reset+0xfb0ead10>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110ad84:	e03ff715 	stw	zero,-36(fp)
8110ad88:	00001a06 	br	8110adf4 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110ad8c:	e0bff517 	ldw	r2,-44(fp)
8110ad90:	1085883a 	add	r2,r2,r2
8110ad94:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110ad98:	00a00034 	movhi	r2,32768
8110ad9c:	10825404 	addi	r2,r2,2384
8110ada0:	10800037 	ldwio	r2,0(r2)
8110ada4:	1080004c 	andi	r2,r2,1
8110ada8:	1007883a 	mov	r3,r2
8110adac:	e0bff517 	ldw	r2,-44(fp)
8110adb0:	10c4b03a 	or	r2,r2,r3
8110adb4:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110adb8:	00c00044 	movi	r3,1
8110adbc:	00a00034 	movhi	r2,32768
8110adc0:	10824c04 	addi	r2,r2,2352
8110adc4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110adc8:	010003c4 	movi	r4,15
8110adcc:	11326680 	call	81132668 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110add0:	0007883a 	mov	r3,zero
8110add4:	00a00034 	movhi	r2,32768
8110add8:	10824c04 	addi	r2,r2,2352
8110addc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ade0:	010003c4 	movi	r4,15
8110ade4:	11326680 	call	81132668 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110ade8:	e0bff717 	ldw	r2,-36(fp)
8110adec:	10800044 	addi	r2,r2,1
8110adf0:	e0bff715 	stw	r2,-36(fp)
8110adf4:	e0bff717 	ldw	r2,-36(fp)
8110adf8:	10800210 	cmplti	r2,r2,8
8110adfc:	103fe31e 	bne	r2,zero,8110ad8c <__reset+0xfb0ead8c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110ae00:	e03ff715 	stw	zero,-36(fp)
8110ae04:	00001a06 	br	8110ae70 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110ae08:	e0bff517 	ldw	r2,-44(fp)
8110ae0c:	1085883a 	add	r2,r2,r2
8110ae10:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110ae14:	00a00034 	movhi	r2,32768
8110ae18:	10825404 	addi	r2,r2,2384
8110ae1c:	10800037 	ldwio	r2,0(r2)
8110ae20:	1080004c 	andi	r2,r2,1
8110ae24:	1007883a 	mov	r3,r2
8110ae28:	e0bff517 	ldw	r2,-44(fp)
8110ae2c:	10c4b03a 	or	r2,r2,r3
8110ae30:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110ae34:	00c00044 	movi	r3,1
8110ae38:	00a00034 	movhi	r2,32768
8110ae3c:	10824c04 	addi	r2,r2,2352
8110ae40:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ae44:	010003c4 	movi	r4,15
8110ae48:	11326680 	call	81132668 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110ae4c:	0007883a 	mov	r3,zero
8110ae50:	00a00034 	movhi	r2,32768
8110ae54:	10824c04 	addi	r2,r2,2352
8110ae58:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ae5c:	010003c4 	movi	r4,15
8110ae60:	11326680 	call	81132668 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110ae64:	e0bff717 	ldw	r2,-36(fp)
8110ae68:	10800044 	addi	r2,r2,1
8110ae6c:	e0bff715 	stw	r2,-36(fp)
8110ae70:	e0bff717 	ldw	r2,-36(fp)
8110ae74:	10800190 	cmplti	r2,r2,6
8110ae78:	103fe31e 	bne	r2,zero,8110ae08 <__reset+0xfb0eae08>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110ae7c:	00c00044 	movi	r3,1
8110ae80:	00a00034 	movhi	r2,32768
8110ae84:	10824c04 	addi	r2,r2,2352
8110ae88:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110ae8c:	010003c4 	movi	r4,15
8110ae90:	11326680 	call	81132668 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110ae94:	00c000c4 	movi	r3,3
8110ae98:	00a00034 	movhi	r2,32768
8110ae9c:	10824804 	addi	r2,r2,2336
8110aea0:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110aea4:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110aea8:	00800044 	movi	r2,1
8110aeac:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110aeb0:	e03ff715 	stw	zero,-36(fp)
8110aeb4:	00000d06 	br	8110aeec <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110aeb8:	e0fff517 	ldw	r3,-44(fp)
8110aebc:	e0bff617 	ldw	r2,-40(fp)
8110aec0:	1884703a 	and	r2,r3,r2
8110aec4:	1000031e 	bne	r2,zero,8110aed4 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110aec8:	e0bff917 	ldw	r2,-28(fp)
8110aecc:	10800044 	addi	r2,r2,1
8110aed0:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110aed4:	e0bff617 	ldw	r2,-40(fp)
8110aed8:	1085883a 	add	r2,r2,r2
8110aedc:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110aee0:	e0bff717 	ldw	r2,-36(fp)
8110aee4:	10800044 	addi	r2,r2,1
8110aee8:	e0bff715 	stw	r2,-36(fp)
8110aeec:	e0bff717 	ldw	r2,-36(fp)
8110aef0:	10800810 	cmplti	r2,r2,32
8110aef4:	103ff01e 	bne	r2,zero,8110aeb8 <__reset+0xfb0eaeb8>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110aef8:	e0bff917 	ldw	r2,-28(fp)
8110aefc:	1080004c 	andi	r2,r2,1
8110af00:	1005003a 	cmpeq	r2,r2,zero
8110af04:	10803fcc 	andi	r2,r2,255
8110af08:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110af0c:	e0bffb17 	ldw	r2,-20(fp)
8110af10:	1000021e 	bne	r2,zero,8110af1c <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110af14:	0005883a 	mov	r2,zero
8110af18:	00000406 	br	8110af2c <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110af1c:	e0800317 	ldw	r2,12(fp)
8110af20:	e0fff517 	ldw	r3,-44(fp)
8110af24:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110af28:	e0bffb17 	ldw	r2,-20(fp)
}
8110af2c:	e037883a 	mov	sp,fp
8110af30:	dfc00117 	ldw	ra,4(sp)
8110af34:	df000017 	ldw	fp,0(sp)
8110af38:	dec00204 	addi	sp,sp,8
8110af3c:	f800283a 	ret

8110af40 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110af40:	defffc04 	addi	sp,sp,-16
8110af44:	de00012e 	bgeu	sp,et,8110af4c <vRstcSimucamReset+0xc>
8110af48:	003b68fa 	trap	3
8110af4c:	dfc00315 	stw	ra,12(sp)
8110af50:	df000215 	stw	fp,8(sp)
8110af54:	df000204 	addi	fp,sp,8
8110af58:	2005883a 	mov	r2,r4
8110af5c:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110af60:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110af64:	e0bfff0b 	ldhu	r2,-4(fp)
8110af68:	e0fffe17 	ldw	r3,-8(fp)
8110af6c:	1884b03a 	or	r2,r3,r2
8110af70:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110af74:	e0bffe17 	ldw	r2,-8(fp)
8110af78:	10800074 	orhi	r2,r2,1
8110af7c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110af80:	e1bffe17 	ldw	r6,-8(fp)
8110af84:	000b883a 	mov	r5,zero
8110af88:	01200034 	movhi	r4,32768
8110af8c:	21020004 	addi	r4,r4,2048
8110af90:	110b0900 	call	8110b090 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110af94:	0001883a 	nop
8110af98:	e037883a 	mov	sp,fp
8110af9c:	dfc00117 	ldw	ra,4(sp)
8110afa0:	df000017 	ldw	fp,0(sp)
8110afa4:	dec00204 	addi	sp,sp,8
8110afa8:	f800283a 	ret

8110afac <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110afac:	defffc04 	addi	sp,sp,-16
8110afb0:	de00012e 	bgeu	sp,et,8110afb8 <vRstcReleaseDeviceReset+0xc>
8110afb4:	003b68fa 	trap	3
8110afb8:	dfc00315 	stw	ra,12(sp)
8110afbc:	df000215 	stw	fp,8(sp)
8110afc0:	df000204 	addi	fp,sp,8
8110afc4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110afc8:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110afcc:	01400044 	movi	r5,1
8110afd0:	01200034 	movhi	r4,32768
8110afd4:	21020004 	addi	r4,r4,2048
8110afd8:	110b0e40 	call	8110b0e4 <uliRstReadReg>
8110afdc:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110afe0:	e0bfff17 	ldw	r2,-4(fp)
8110afe4:	0084303a 	nor	r2,zero,r2
8110afe8:	e0fffe17 	ldw	r3,-8(fp)
8110afec:	1884703a 	and	r2,r3,r2
8110aff0:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110aff4:	e1bffe17 	ldw	r6,-8(fp)
8110aff8:	01400044 	movi	r5,1
8110affc:	01200034 	movhi	r4,32768
8110b000:	21020004 	addi	r4,r4,2048
8110b004:	110b0900 	call	8110b090 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b008:	0001883a 	nop
8110b00c:	e037883a 	mov	sp,fp
8110b010:	dfc00117 	ldw	ra,4(sp)
8110b014:	df000017 	ldw	fp,0(sp)
8110b018:	dec00204 	addi	sp,sp,8
8110b01c:	f800283a 	ret

8110b020 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110b020:	defffc04 	addi	sp,sp,-16
8110b024:	de00012e 	bgeu	sp,et,8110b02c <vRstcHoldDeviceReset+0xc>
8110b028:	003b68fa 	trap	3
8110b02c:	dfc00315 	stw	ra,12(sp)
8110b030:	df000215 	stw	fp,8(sp)
8110b034:	df000204 	addi	fp,sp,8
8110b038:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110b03c:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b040:	01400044 	movi	r5,1
8110b044:	01200034 	movhi	r4,32768
8110b048:	21020004 	addi	r4,r4,2048
8110b04c:	110b0e40 	call	8110b0e4 <uliRstReadReg>
8110b050:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110b054:	e0fffe17 	ldw	r3,-8(fp)
8110b058:	e0bfff17 	ldw	r2,-4(fp)
8110b05c:	1884b03a 	or	r2,r3,r2
8110b060:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b064:	e1bffe17 	ldw	r6,-8(fp)
8110b068:	01400044 	movi	r5,1
8110b06c:	01200034 	movhi	r4,32768
8110b070:	21020004 	addi	r4,r4,2048
8110b074:	110b0900 	call	8110b090 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b078:	0001883a 	nop
8110b07c:	e037883a 	mov	sp,fp
8110b080:	dfc00117 	ldw	ra,4(sp)
8110b084:	df000017 	ldw	fp,0(sp)
8110b088:	dec00204 	addi	sp,sp,8
8110b08c:	f800283a 	ret

8110b090 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110b090:	defffc04 	addi	sp,sp,-16
8110b094:	de00012e 	bgeu	sp,et,8110b09c <vRstcWriteReg+0xc>
8110b098:	003b68fa 	trap	3
8110b09c:	df000315 	stw	fp,12(sp)
8110b0a0:	df000304 	addi	fp,sp,12
8110b0a4:	e13ffd15 	stw	r4,-12(fp)
8110b0a8:	e17ffe15 	stw	r5,-8(fp)
8110b0ac:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110b0b0:	e0bffe17 	ldw	r2,-8(fp)
8110b0b4:	1085883a 	add	r2,r2,r2
8110b0b8:	1085883a 	add	r2,r2,r2
8110b0bc:	1007883a 	mov	r3,r2
8110b0c0:	e0bffd17 	ldw	r2,-12(fp)
8110b0c4:	10c5883a 	add	r2,r2,r3
8110b0c8:	e0ffff17 	ldw	r3,-4(fp)
8110b0cc:	10c00015 	stw	r3,0(r2)
}
8110b0d0:	0001883a 	nop
8110b0d4:	e037883a 	mov	sp,fp
8110b0d8:	df000017 	ldw	fp,0(sp)
8110b0dc:	dec00104 	addi	sp,sp,4
8110b0e0:	f800283a 	ret

8110b0e4 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110b0e4:	defffc04 	addi	sp,sp,-16
8110b0e8:	de00012e 	bgeu	sp,et,8110b0f0 <uliRstReadReg+0xc>
8110b0ec:	003b68fa 	trap	3
8110b0f0:	df000315 	stw	fp,12(sp)
8110b0f4:	df000304 	addi	fp,sp,12
8110b0f8:	e13ffe15 	stw	r4,-8(fp)
8110b0fc:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110b100:	e0bfff17 	ldw	r2,-4(fp)
8110b104:	1085883a 	add	r2,r2,r2
8110b108:	1085883a 	add	r2,r2,r2
8110b10c:	1007883a 	mov	r3,r2
8110b110:	e0bffe17 	ldw	r2,-8(fp)
8110b114:	10c5883a 	add	r2,r2,r3
8110b118:	10800017 	ldw	r2,0(r2)
8110b11c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110b120:	e0bffd17 	ldw	r2,-12(fp)
}
8110b124:	e037883a 	mov	sp,fp
8110b128:	df000017 	ldw	fp,0(sp)
8110b12c:	dec00104 	addi	sp,sp,4
8110b130:	f800283a 	ret

8110b134 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110b134:	defffe04 	addi	sp,sp,-8
8110b138:	de00012e 	bgeu	sp,et,8110b140 <v_spi_start+0xc>
8110b13c:	003b68fa 	trap	3
8110b140:	dfc00115 	stw	ra,4(sp)
8110b144:	df000015 	stw	fp,0(sp)
8110b148:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110b14c:	0007883a 	mov	r3,zero
8110b150:	00a00034 	movhi	r2,32768
8110b154:	10823004 	addi	r2,r2,2240
8110b158:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110b15c:	0007883a 	mov	r3,zero
8110b160:	00a00034 	movhi	r2,32768
8110b164:	10822c04 	addi	r2,r2,2224
8110b168:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b16c:	01002584 	movi	r4,150
8110b170:	11326680 	call	81132668 <usleep>
}
8110b174:	0001883a 	nop
8110b178:	e037883a 	mov	sp,fp
8110b17c:	dfc00117 	ldw	ra,4(sp)
8110b180:	df000017 	ldw	fp,0(sp)
8110b184:	dec00204 	addi	sp,sp,8
8110b188:	f800283a 	ret

8110b18c <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110b18c:	defffc04 	addi	sp,sp,-16
8110b190:	de00012e 	bgeu	sp,et,8110b198 <v_spi_send_byte+0xc>
8110b194:	003b68fa 	trap	3
8110b198:	dfc00315 	stw	ra,12(sp)
8110b19c:	df000215 	stw	fp,8(sp)
8110b1a0:	df000204 	addi	fp,sp,8
8110b1a4:	2005883a 	mov	r2,r4
8110b1a8:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110b1ac:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110b1b0:	00bfe004 	movi	r2,-128
8110b1b4:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110b1b8:	e03ffe05 	stb	zero,-8(fp)
8110b1bc:	00001b06 	br	8110b22c <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110b1c0:	e0ffff03 	ldbu	r3,-4(fp)
8110b1c4:	e0bffe43 	ldbu	r2,-7(fp)
8110b1c8:	1884703a 	and	r2,r3,r2
8110b1cc:	10803fcc 	andi	r2,r2,255
8110b1d0:	1004c03a 	cmpne	r2,r2,zero
8110b1d4:	10c03fcc 	andi	r3,r2,255
8110b1d8:	00a00034 	movhi	r2,32768
8110b1dc:	10823404 	addi	r2,r2,2256
8110b1e0:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110b1e4:	e0bffe43 	ldbu	r2,-7(fp)
8110b1e8:	1004d07a 	srli	r2,r2,1
8110b1ec:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b1f0:	00c00044 	movi	r3,1
8110b1f4:	00a00034 	movhi	r2,32768
8110b1f8:	10823004 	addi	r2,r2,2240
8110b1fc:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b200:	01002584 	movi	r4,150
8110b204:	11326680 	call	81132668 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b208:	0007883a 	mov	r3,zero
8110b20c:	00a00034 	movhi	r2,32768
8110b210:	10823004 	addi	r2,r2,2240
8110b214:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b218:	01002584 	movi	r4,150
8110b21c:	11326680 	call	81132668 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110b220:	e0bffe03 	ldbu	r2,-8(fp)
8110b224:	10800044 	addi	r2,r2,1
8110b228:	e0bffe05 	stb	r2,-8(fp)
8110b22c:	e0bffe03 	ldbu	r2,-8(fp)
8110b230:	10800230 	cmpltui	r2,r2,8
8110b234:	103fe21e 	bne	r2,zero,8110b1c0 <__reset+0xfb0eb1c0>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110b238:	0001883a 	nop
8110b23c:	e037883a 	mov	sp,fp
8110b240:	dfc00117 	ldw	ra,4(sp)
8110b244:	df000017 	ldw	fp,0(sp)
8110b248:	dec00204 	addi	sp,sp,8
8110b24c:	f800283a 	ret

8110b250 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110b250:	defffd04 	addi	sp,sp,-12
8110b254:	de00012e 	bgeu	sp,et,8110b25c <uc_spi_get_byte+0xc>
8110b258:	003b68fa 	trap	3
8110b25c:	dfc00215 	stw	ra,8(sp)
8110b260:	df000115 	stw	fp,4(sp)
8110b264:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110b268:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110b26c:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110b270:	e03fff05 	stb	zero,-4(fp)
8110b274:	00001a06 	br	8110b2e0 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110b278:	e0bfff43 	ldbu	r2,-3(fp)
8110b27c:	1085883a 	add	r2,r2,r2
8110b280:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110b284:	00a00034 	movhi	r2,32768
8110b288:	10823804 	addi	r2,r2,2272
8110b28c:	10800037 	ldwio	r2,0(r2)
8110b290:	1080004c 	andi	r2,r2,1
8110b294:	1007883a 	mov	r3,r2
8110b298:	e0bfff43 	ldbu	r2,-3(fp)
8110b29c:	1884b03a 	or	r2,r3,r2
8110b2a0:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b2a4:	00c00044 	movi	r3,1
8110b2a8:	00a00034 	movhi	r2,32768
8110b2ac:	10823004 	addi	r2,r2,2240
8110b2b0:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b2b4:	01002584 	movi	r4,150
8110b2b8:	11326680 	call	81132668 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b2bc:	0007883a 	mov	r3,zero
8110b2c0:	00a00034 	movhi	r2,32768
8110b2c4:	10823004 	addi	r2,r2,2240
8110b2c8:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b2cc:	01002584 	movi	r4,150
8110b2d0:	11326680 	call	81132668 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110b2d4:	e0bfff03 	ldbu	r2,-4(fp)
8110b2d8:	10800044 	addi	r2,r2,1
8110b2dc:	e0bfff05 	stb	r2,-4(fp)
8110b2e0:	e0bfff03 	ldbu	r2,-4(fp)
8110b2e4:	10800230 	cmpltui	r2,r2,8
8110b2e8:	103fe31e 	bne	r2,zero,8110b278 <__reset+0xfb0eb278>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110b2ec:	e0bfff43 	ldbu	r2,-3(fp)
}
8110b2f0:	e037883a 	mov	sp,fp
8110b2f4:	dfc00117 	ldw	ra,4(sp)
8110b2f8:	df000017 	ldw	fp,0(sp)
8110b2fc:	dec00204 	addi	sp,sp,8
8110b300:	f800283a 	ret

8110b304 <v_spi_end>:

void v_spi_end(void){
8110b304:	defffe04 	addi	sp,sp,-8
8110b308:	de00012e 	bgeu	sp,et,8110b310 <v_spi_end+0xc>
8110b30c:	003b68fa 	trap	3
8110b310:	dfc00115 	stw	ra,4(sp)
8110b314:	df000015 	stw	fp,0(sp)
8110b318:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110b31c:	0007883a 	mov	r3,zero
8110b320:	00a00034 	movhi	r2,32768
8110b324:	10823004 	addi	r2,r2,2240
8110b328:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b32c:	01002584 	movi	r4,150
8110b330:	11326680 	call	81132668 <usleep>
    SPI_CS_N(1);
8110b334:	00c00044 	movi	r3,1
8110b338:	00a00034 	movhi	r2,32768
8110b33c:	10822c04 	addi	r2,r2,2224
8110b340:	10c00035 	stwio	r3,0(r2)
}
8110b344:	0001883a 	nop
8110b348:	e037883a 	mov	sp,fp
8110b34c:	dfc00117 	ldw	ra,4(sp)
8110b350:	df000017 	ldw	fp,0(sp)
8110b354:	dec00204 	addi	sp,sp,8
8110b358:	f800283a 	ret

8110b35c <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110b35c:	defff604 	addi	sp,sp,-40
8110b360:	de00012e 	bgeu	sp,et,8110b368 <RTCC_SPI_R_MAC+0xc>
8110b364:	003b68fa 	trap	3
8110b368:	dfc00915 	stw	ra,36(sp)
8110b36c:	df000815 	stw	fp,32(sp)
8110b370:	df000804 	addi	fp,sp,32
8110b374:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110b378:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110b37c:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110b380:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110b384:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110b388:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110b38c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110b390:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110b394:	00800084 	movi	r2,2
8110b398:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110b39c:	00800cc4 	movi	r2,51
8110b3a0:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110b3a4:	110b1340 	call	8110b134 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110b3a8:	e0bffec3 	ldbu	r2,-5(fp)
8110b3ac:	1009883a 	mov	r4,r2
8110b3b0:	110b18c0 	call	8110b18c <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110b3b4:	e0bffe83 	ldbu	r2,-6(fp)
8110b3b8:	1009883a 	mov	r4,r2
8110b3bc:	110b18c0 	call	8110b18c <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110b3c0:	110b2500 	call	8110b250 <uc_spi_get_byte>
8110b3c4:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110b3c8:	110b2500 	call	8110b250 <uc_spi_get_byte>
8110b3cc:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110b3d0:	110b2500 	call	8110b250 <uc_spi_get_byte>
8110b3d4:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110b3d8:	110b2500 	call	8110b250 <uc_spi_get_byte>
8110b3dc:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110b3e0:	110b2500 	call	8110b250 <uc_spi_get_byte>
8110b3e4:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110b3e8:	110b2500 	call	8110b250 <uc_spi_get_byte>
8110b3ec:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110b3f0:	110b3040 	call	8110b304 <v_spi_end>

    bSuccess = TRUE;
8110b3f4:	00800044 	movi	r2,1
8110b3f8:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110b3fc:	e0bfff17 	ldw	r2,-4(fp)
8110b400:	e0fffd03 	ldbu	r3,-12(fp)
8110b404:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110b408:	e0bfff17 	ldw	r2,-4(fp)
8110b40c:	10800044 	addi	r2,r2,1
8110b410:	e0fffd43 	ldbu	r3,-11(fp)
8110b414:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110b418:	e0bfff17 	ldw	r2,-4(fp)
8110b41c:	10800084 	addi	r2,r2,2
8110b420:	e0fffd83 	ldbu	r3,-10(fp)
8110b424:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110b428:	e0bfff17 	ldw	r2,-4(fp)
8110b42c:	108000c4 	addi	r2,r2,3
8110b430:	e0fffdc3 	ldbu	r3,-9(fp)
8110b434:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110b438:	e0bfff17 	ldw	r2,-4(fp)
8110b43c:	10800104 	addi	r2,r2,4
8110b440:	e0fffe03 	ldbu	r3,-8(fp)
8110b444:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110b448:	e0bfff17 	ldw	r2,-4(fp)
8110b44c:	10800144 	addi	r2,r2,5
8110b450:	e0fffe43 	ldbu	r3,-7(fp)
8110b454:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110b458:	e1bffd03 	ldbu	r6,-12(fp)
8110b45c:	e1fffd43 	ldbu	r7,-11(fp)
8110b460:	e0bffd83 	ldbu	r2,-10(fp)
8110b464:	e0fffdc3 	ldbu	r3,-9(fp)
8110b468:	e13ffe03 	ldbu	r4,-8(fp)
8110b46c:	e17ffe43 	ldbu	r5,-7(fp)
8110b470:	d9400315 	stw	r5,12(sp)
8110b474:	d9000215 	stw	r4,8(sp)
8110b478:	d8c00115 	stw	r3,4(sp)
8110b47c:	d8800015 	stw	r2,0(sp)
8110b480:	01604534 	movhi	r5,33044
8110b484:	295b5204 	addi	r5,r5,27976
8110b488:	01204574 	movhi	r4,33045
8110b48c:	21345504 	addi	r4,r4,-11948
8110b490:	111cd200 	call	8111cd20 <sprintf>
	debug(fp, cDebugBuffer);
8110b494:	d0a05c17 	ldw	r2,-32400(gp)
8110b498:	01604574 	movhi	r5,33045
8110b49c:	29745504 	addi	r5,r5,-11948
8110b4a0:	1009883a 	mov	r4,r2
8110b4a4:	111b3900 	call	8111b390 <fprintf>
#endif

    return bSuccess;
8110b4a8:	e0bffc17 	ldw	r2,-16(fp)
}
8110b4ac:	e037883a 	mov	sp,fp
8110b4b0:	dfc00117 	ldw	ra,4(sp)
8110b4b4:	df000017 	ldw	fp,0(sp)
8110b4b8:	dec00204 	addi	sp,sp,8
8110b4bc:	f800283a 	ret

8110b4c0 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110b4c0:	defffd04 	addi	sp,sp,-12
8110b4c4:	de00012e 	bgeu	sp,et,8110b4cc <bSSDisplayConfig+0xc>
8110b4c8:	003b68fa 	trap	3
8110b4cc:	df000215 	stw	fp,8(sp)
8110b4d0:	df000204 	addi	fp,sp,8
8110b4d4:	2005883a 	mov	r2,r4
8110b4d8:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110b4dc:	e0bfff03 	ldbu	r2,-4(fp)
8110b4e0:	10c00168 	cmpgeui	r3,r2,5
8110b4e4:	18001c1e 	bne	r3,zero,8110b558 <bSSDisplayConfig+0x98>
8110b4e8:	100690ba 	slli	r3,r2,2
8110b4ec:	00a04474 	movhi	r2,33041
8110b4f0:	10ad4004 	addi	r2,r2,-19200
8110b4f4:	1885883a 	add	r2,r3,r2
8110b4f8:	10800017 	ldw	r2,0(r2)
8110b4fc:	1000683a 	jmp	r2
8110b500:	8110b514 	ori	r4,r16,17108
8110b504:	8110b520 	cmpeqi	r4,r16,17108
8110b508:	8110b52c 	andhi	r4,r16,17108
8110b50c:	8110b540 	call	88110b54 <__reset+0x20f0b54>
8110b510:	8110b550 	cmplti	r4,r16,17109
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110b514:	00800cc4 	movi	r2,51
8110b518:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b51c:	00001006 	br	8110b560 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110b520:	00801544 	movi	r2,85
8110b524:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b528:	00000d06 	br	8110b560 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110b52c:	d0e04e43 	ldbu	r3,-32455(gp)
8110b530:	00bff744 	movi	r2,-35
8110b534:	1884703a 	and	r2,r3,r2
8110b538:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b53c:	00000806 	br	8110b560 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110b540:	d0a04e43 	ldbu	r2,-32455(gp)
8110b544:	10800894 	ori	r2,r2,34
8110b548:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b54c:	00000406 	br	8110b560 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110b550:	d0204e45 	stb	zero,-32455(gp)
	    break;
8110b554:	00000206 	br	8110b560 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110b558:	0005883a 	mov	r2,zero
8110b55c:	00000806 	br	8110b580 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b560:	00a00034 	movhi	r2,32768
8110b564:	10828404 	addi	r2,r2,2576
8110b568:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110b56c:	d0a04e43 	ldbu	r2,-32455(gp)
8110b570:	10c03fcc 	andi	r3,r2,255
8110b574:	e0bffe17 	ldw	r2,-8(fp)
8110b578:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b57c:	00800044 	movi	r2,1
}
8110b580:	e037883a 	mov	sp,fp
8110b584:	df000017 	ldw	fp,0(sp)
8110b588:	dec00104 	addi	sp,sp,4
8110b58c:	f800283a 	ret

8110b590 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110b590:	defffd04 	addi	sp,sp,-12
8110b594:	de00012e 	bgeu	sp,et,8110b59c <bSSDisplayUpdate+0xc>
8110b598:	003b68fa 	trap	3
8110b59c:	df000215 	stw	fp,8(sp)
8110b5a0:	df000204 	addi	fp,sp,8
8110b5a4:	2005883a 	mov	r2,r4
8110b5a8:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b5ac:	00a00034 	movhi	r2,32768
8110b5b0:	10828404 	addi	r2,r2,2576
8110b5b4:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110b5b8:	e0bffe17 	ldw	r2,-8(fp)
8110b5bc:	10800104 	addi	r2,r2,4
8110b5c0:	e0ffff03 	ldbu	r3,-4(fp)
8110b5c4:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b5c8:	00800044 	movi	r2,1
}
8110b5cc:	e037883a 	mov	sp,fp
8110b5d0:	df000017 	ldw	fp,0(sp)
8110b5d4:	dec00104 	addi	sp,sp,4
8110b5d8:	f800283a 	ret

8110b5dc <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110b5dc:	defff904 	addi	sp,sp,-28
8110b5e0:	de00012e 	bgeu	sp,et,8110b5e8 <vSyncHandleIrq+0xc>
8110b5e4:	003b68fa 	trap	3
8110b5e8:	dfc00615 	stw	ra,24(sp)
8110b5ec:	df000515 	stw	fp,20(sp)
8110b5f0:	df000504 	addi	fp,sp,20
8110b5f4:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110b5f8:	e0bfff17 	ldw	r2,-4(fp)
8110b5fc:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110b600:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110b604:	d0a05003 	ldbu	r2,-32448(gp)
8110b608:	108000cc 	andi	r2,r2,3
8110b60c:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 ) {
8110b610:	e0bffd03 	ldbu	r2,-12(fp)
8110b614:	10000e1e 	bne	r2,zero,8110b650 <vSyncHandleIrq+0x74>

		uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110b618:	00800044 	movi	r2,1
8110b61c:	e0bffec5 	stb	r2,-5(fp)
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110b620:	00bff804 	movi	r2,-32
8110b624:	e0bffe85 	stb	r2,-6(fp)

		/* Send Priority message to the Meb Task to indicate the Master Sync */
		error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110b628:	d0a06317 	ldw	r2,-32372(gp)
8110b62c:	e0fffe17 	ldw	r3,-8(fp)
8110b630:	180b883a 	mov	r5,r3
8110b634:	1009883a 	mov	r4,r2
8110b638:	1138aec0 	call	81138aec <OSQPostFront>
8110b63c:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110b640:	e0bffd43 	ldbu	r2,-11(fp)
8110b644:	10000426 	beq	r2,zero,8110b658 <vSyncHandleIrq+0x7c>
			vFailSendMsgMasterSyncMeb( );
8110b648:	11181900 	call	81118190 <vFailSendMsgMasterSyncMeb>
8110b64c:	00000206 	br	8110b658 <vSyncHandleIrq+0x7c>
		}

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110b650:	00bff844 	movi	r2,-31
8110b654:	e0bffe85 	stb	r2,-6(fp)


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110b658:	e03ffb05 	stb	zero,-20(fp)
8110b65c:	00001f06 	br	8110b6dc <vSyncHandleIrq+0x100>

		if ( xSimMeb.xFeeControl.xNfee[ucIL].xControl.bWatingSync == TRUE ) {
8110b660:	e0fffb03 	ldbu	r3,-20(fp)
8110b664:	00a04574 	movhi	r2,33045
8110b668:	108a9504 	addi	r2,r2,10836
8110b66c:	18c09524 	muli	r3,r3,596
8110b670:	10c5883a 	add	r2,r2,r3
8110b674:	10803a04 	addi	r2,r2,232
8110b678:	10800017 	ldw	r2,0(r2)
8110b67c:	10800058 	cmpnei	r2,r2,1
8110b680:	1000131e 	bne	r2,zero,8110b6d0 <vSyncHandleIrq+0xf4>
			uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110b684:	e0bffb03 	ldbu	r2,-20(fp)
8110b688:	10800444 	addi	r2,r2,17
8110b68c:	e0bffec5 	stb	r2,-5(fp)
			error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110b690:	e0bffb03 	ldbu	r2,-20(fp)
8110b694:	1085883a 	add	r2,r2,r2
8110b698:	1087883a 	add	r3,r2,r2
8110b69c:	d0a05604 	addi	r2,gp,-32424
8110b6a0:	1885883a 	add	r2,r3,r2
8110b6a4:	10800017 	ldw	r2,0(r2)
8110b6a8:	e0fffe17 	ldw	r3,-8(fp)
8110b6ac:	180b883a 	mov	r5,r3
8110b6b0:	1009883a 	mov	r4,r2
8110b6b4:	113897c0 	call	8113897c <OSQPost>
8110b6b8:	e0bffd45 	stb	r2,-11(fp)
			if ( error_codel != OS_ERR_NONE ) {
8110b6bc:	e0bffd43 	ldbu	r2,-11(fp)
8110b6c0:	10000326 	beq	r2,zero,8110b6d0 <vSyncHandleIrq+0xf4>
				vFailSendMsgSync( ucIL );
8110b6c4:	e0bffb03 	ldbu	r2,-20(fp)
8110b6c8:	1009883a 	mov	r4,r2
8110b6cc:	111813c0 	call	8111813c <vFailSendMsgSync>

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110b6d0:	e0bffb03 	ldbu	r2,-20(fp)
8110b6d4:	10800044 	addi	r2,r2,1
8110b6d8:	e0bffb05 	stb	r2,-20(fp)
8110b6dc:	e0bffb03 	ldbu	r2,-20(fp)
8110b6e0:	103fdf26 	beq	r2,zero,8110b660 <__reset+0xfb0eb660>
				vFailSendMsgSync( ucIL );
			}
		}
	}

	vucN += 1;
8110b6e4:	d0a05003 	ldbu	r2,-32448(gp)
8110b6e8:	10800044 	addi	r2,r2,1
8110b6ec:	d0a05005 	stb	r2,-32448(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110b6f0:	d0a05c17 	ldw	r2,-32400(gp)
8110b6f4:	e0fffd03 	ldbu	r3,-12(fp)
8110b6f8:	180d883a 	mov	r6,r3
8110b6fc:	01604534 	movhi	r5,33044
8110b700:	295b6104 	addi	r5,r5,28036
8110b704:	1009883a 	mov	r4,r2
8110b708:	111b3900 	call	8111b390 <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110b70c:	110b7a00 	call	8110b7a0 <vSyncIrqFlagClrSync>
}
8110b710:	0001883a 	nop
8110b714:	e037883a 	mov	sp,fp
8110b718:	dfc00117 	ldw	ra,4(sp)
8110b71c:	df000017 	ldw	fp,0(sp)
8110b720:	dec00204 	addi	sp,sp,8
8110b724:	f800283a 	ret

8110b728 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110b728:	deffff04 	addi	sp,sp,-4
8110b72c:	de00012e 	bgeu	sp,et,8110b734 <vSyncClearCounter+0xc>
8110b730:	003b68fa 	trap	3
8110b734:	df000015 	stw	fp,0(sp)
8110b738:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110b73c:	d0205005 	stb	zero,-32448(gp)
}
8110b740:	0001883a 	nop
8110b744:	e037883a 	mov	sp,fp
8110b748:	df000017 	ldw	fp,0(sp)
8110b74c:	dec00104 	addi	sp,sp,4
8110b750:	f800283a 	ret

8110b754 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110b754:	defffd04 	addi	sp,sp,-12
8110b758:	de00012e 	bgeu	sp,et,8110b760 <vSyncInitIrq+0xc>
8110b75c:	003b68fa 	trap	3
8110b760:	dfc00215 	stw	ra,8(sp)
8110b764:	df000115 	stw	fp,4(sp)
8110b768:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110b76c:	d0a04f04 	addi	r2,gp,-32452
8110b770:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110b774:	01a04474 	movhi	r6,33041
8110b778:	31ad7704 	addi	r6,r6,-18980
8110b77c:	e17fff17 	ldw	r5,-4(fp)
8110b780:	01000284 	movi	r4,10
8110b784:	1130f980 	call	81130f98 <alt_irq_register>
}
8110b788:	0001883a 	nop
8110b78c:	e037883a 	mov	sp,fp
8110b790:	dfc00117 	ldw	ra,4(sp)
8110b794:	df000017 	ldw	fp,0(sp)
8110b798:	dec00204 	addi	sp,sp,8
8110b79c:	f800283a 	ret

8110b7a0 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110b7a0:	defffe04 	addi	sp,sp,-8
8110b7a4:	de00012e 	bgeu	sp,et,8110b7ac <vSyncIrqFlagClrSync+0xc>
8110b7a8:	003b68fa 	trap	3
8110b7ac:	dfc00115 	stw	ra,4(sp)
8110b7b0:	df000015 	stw	fp,0(sp)
8110b7b4:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110b7b8:	01400044 	movi	r5,1
8110b7bc:	010002c4 	movi	r4,11
8110b7c0:	110c5800 	call	8110c580 <bSyncWriteReg>
}
8110b7c4:	0001883a 	nop
8110b7c8:	e037883a 	mov	sp,fp
8110b7cc:	dfc00117 	ldw	ra,4(sp)
8110b7d0:	df000017 	ldw	fp,0(sp)
8110b7d4:	dec00204 	addi	sp,sp,8
8110b7d8:	f800283a 	ret

8110b7dc <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110b7dc:	defffd04 	addi	sp,sp,-12
8110b7e0:	de00012e 	bgeu	sp,et,8110b7e8 <bSyncIrqFlagSync+0xc>
8110b7e4:	003b68fa 	trap	3
8110b7e8:	dfc00215 	stw	ra,8(sp)
8110b7ec:	df000115 	stw	fp,4(sp)
8110b7f0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110b7f4:	01000304 	movi	r4,12
8110b7f8:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110b7fc:	1080004c 	andi	r2,r2,1
8110b800:	10000326 	beq	r2,zero,8110b810 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110b804:	00800044 	movi	r2,1
8110b808:	e0bfff15 	stw	r2,-4(fp)
8110b80c:	00000106 	br	8110b814 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110b810:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110b814:	e0bfff17 	ldw	r2,-4(fp)
}
8110b818:	e037883a 	mov	sp,fp
8110b81c:	dfc00117 	ldw	ra,4(sp)
8110b820:	df000017 	ldw	fp,0(sp)
8110b824:	dec00204 	addi	sp,sp,8
8110b828:	f800283a 	ret

8110b82c <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110b82c:	defffc04 	addi	sp,sp,-16
8110b830:	de00012e 	bgeu	sp,et,8110b838 <bSyncStatusExtnIrq+0xc>
8110b834:	003b68fa 	trap	3
8110b838:	dfc00315 	stw	ra,12(sp)
8110b83c:	df000215 	stw	fp,8(sp)
8110b840:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110b844:	0009883a 	mov	r4,zero
8110b848:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110b84c:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110b850:	e0bfff17 	ldw	r2,-4(fp)
8110b854:	1000030e 	bge	r2,zero,8110b864 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110b858:	00800044 	movi	r2,1
8110b85c:	e0bffe15 	stw	r2,-8(fp)
8110b860:	00000106 	br	8110b868 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110b864:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110b868:	e0bffe17 	ldw	r2,-8(fp)
}
8110b86c:	e037883a 	mov	sp,fp
8110b870:	dfc00117 	ldw	ra,4(sp)
8110b874:	df000017 	ldw	fp,0(sp)
8110b878:	dec00204 	addi	sp,sp,8
8110b87c:	f800283a 	ret

8110b880 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110b880:	defffc04 	addi	sp,sp,-16
8110b884:	de00012e 	bgeu	sp,et,8110b88c <ucSyncStatusState+0xc>
8110b888:	003b68fa 	trap	3
8110b88c:	dfc00315 	stw	ra,12(sp)
8110b890:	df000215 	stw	fp,8(sp)
8110b894:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110b898:	0009883a 	mov	r4,zero
8110b89c:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110b8a0:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110b8a4:	e0bffe17 	ldw	r2,-8(fp)
8110b8a8:	10803fec 	andhi	r2,r2,255
8110b8ac:	1004d43a 	srli	r2,r2,16
8110b8b0:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110b8b4:	e0bfff03 	ldbu	r2,-4(fp)
}
8110b8b8:	e037883a 	mov	sp,fp
8110b8bc:	dfc00117 	ldw	ra,4(sp)
8110b8c0:	df000017 	ldw	fp,0(sp)
8110b8c4:	dec00204 	addi	sp,sp,8
8110b8c8:	f800283a 	ret

8110b8cc <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110b8cc:	defffc04 	addi	sp,sp,-16
8110b8d0:	de00012e 	bgeu	sp,et,8110b8d8 <ucSyncStatusErrorCode+0xc>
8110b8d4:	003b68fa 	trap	3
8110b8d8:	dfc00315 	stw	ra,12(sp)
8110b8dc:	df000215 	stw	fp,8(sp)
8110b8e0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110b8e4:	0009883a 	mov	r4,zero
8110b8e8:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110b8ec:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110b8f0:	e0bffe17 	ldw	r2,-8(fp)
8110b8f4:	10bfc00c 	andi	r2,r2,65280
8110b8f8:	1004d23a 	srli	r2,r2,8
8110b8fc:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110b900:	e0bfff03 	ldbu	r2,-4(fp)
}
8110b904:	e037883a 	mov	sp,fp
8110b908:	dfc00117 	ldw	ra,4(sp)
8110b90c:	df000017 	ldw	fp,0(sp)
8110b910:	dec00204 	addi	sp,sp,8
8110b914:	f800283a 	ret

8110b918 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110b918:	defffc04 	addi	sp,sp,-16
8110b91c:	de00012e 	bgeu	sp,et,8110b924 <ucSyncStatusCycleNumber+0xc>
8110b920:	003b68fa 	trap	3
8110b924:	dfc00315 	stw	ra,12(sp)
8110b928:	df000215 	stw	fp,8(sp)
8110b92c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110b930:	0009883a 	mov	r4,zero
8110b934:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110b938:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110b93c:	e0bffe17 	ldw	r2,-8(fp)
8110b940:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110b944:	e0bfff03 	ldbu	r2,-4(fp)
}
8110b948:	e037883a 	mov	sp,fp
8110b94c:	dfc00117 	ldw	ra,4(sp)
8110b950:	df000017 	ldw	fp,0(sp)
8110b954:	dec00204 	addi	sp,sp,8
8110b958:	f800283a 	ret

8110b95c <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110b95c:	defffd04 	addi	sp,sp,-12
8110b960:	de00012e 	bgeu	sp,et,8110b968 <bSyncSetMbt+0xc>
8110b964:	003b68fa 	trap	3
8110b968:	dfc00215 	stw	ra,8(sp)
8110b96c:	df000115 	stw	fp,4(sp)
8110b970:	df000104 	addi	fp,sp,4
8110b974:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110b978:	e17fff17 	ldw	r5,-4(fp)
8110b97c:	01000104 	movi	r4,4
8110b980:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110b984:	00800044 	movi	r2,1
}
8110b988:	e037883a 	mov	sp,fp
8110b98c:	dfc00117 	ldw	ra,4(sp)
8110b990:	df000017 	ldw	fp,0(sp)
8110b994:	dec00204 	addi	sp,sp,8
8110b998:	f800283a 	ret

8110b99c <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110b99c:	defffd04 	addi	sp,sp,-12
8110b9a0:	de00012e 	bgeu	sp,et,8110b9a8 <bSyncSetBt+0xc>
8110b9a4:	003b68fa 	trap	3
8110b9a8:	dfc00215 	stw	ra,8(sp)
8110b9ac:	df000115 	stw	fp,4(sp)
8110b9b0:	df000104 	addi	fp,sp,4
8110b9b4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110b9b8:	e17fff17 	ldw	r5,-4(fp)
8110b9bc:	01000144 	movi	r4,5
8110b9c0:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110b9c4:	00800044 	movi	r2,1
}
8110b9c8:	e037883a 	mov	sp,fp
8110b9cc:	dfc00117 	ldw	ra,4(sp)
8110b9d0:	df000017 	ldw	fp,0(sp)
8110b9d4:	dec00204 	addi	sp,sp,8
8110b9d8:	f800283a 	ret

8110b9dc <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110b9dc:	defffd04 	addi	sp,sp,-12
8110b9e0:	de00012e 	bgeu	sp,et,8110b9e8 <bSyncSetPer+0xc>
8110b9e4:	003b68fa 	trap	3
8110b9e8:	dfc00215 	stw	ra,8(sp)
8110b9ec:	df000115 	stw	fp,4(sp)
8110b9f0:	df000104 	addi	fp,sp,4
8110b9f4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110b9f8:	e17fff17 	ldw	r5,-4(fp)
8110b9fc:	01000184 	movi	r4,6
8110ba00:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110ba04:	00800044 	movi	r2,1
}
8110ba08:	e037883a 	mov	sp,fp
8110ba0c:	dfc00117 	ldw	ra,4(sp)
8110ba10:	df000017 	ldw	fp,0(sp)
8110ba14:	dec00204 	addi	sp,sp,8
8110ba18:	f800283a 	ret

8110ba1c <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110ba1c:	defffd04 	addi	sp,sp,-12
8110ba20:	de00012e 	bgeu	sp,et,8110ba28 <bSyncSetOst+0xc>
8110ba24:	003b68fa 	trap	3
8110ba28:	dfc00215 	stw	ra,8(sp)
8110ba2c:	df000115 	stw	fp,4(sp)
8110ba30:	df000104 	addi	fp,sp,4
8110ba34:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110ba38:	e17fff17 	ldw	r5,-4(fp)
8110ba3c:	010001c4 	movi	r4,7
8110ba40:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110ba44:	00800044 	movi	r2,1
}
8110ba48:	e037883a 	mov	sp,fp
8110ba4c:	dfc00117 	ldw	ra,4(sp)
8110ba50:	df000017 	ldw	fp,0(sp)
8110ba54:	dec00204 	addi	sp,sp,8
8110ba58:	f800283a 	ret

8110ba5c <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110ba5c:	defffc04 	addi	sp,sp,-16
8110ba60:	de00012e 	bgeu	sp,et,8110ba68 <bSyncSetPolarity+0xc>
8110ba64:	003b68fa 	trap	3
8110ba68:	dfc00315 	stw	ra,12(sp)
8110ba6c:	df000215 	stw	fp,8(sp)
8110ba70:	df000204 	addi	fp,sp,8
8110ba74:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110ba78:	01000204 	movi	r4,8
8110ba7c:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110ba80:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ba84:	e0bfff17 	ldw	r2,-4(fp)
8110ba88:	1000051e 	bne	r2,zero,8110baa0 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110ba8c:	e0fffe17 	ldw	r3,-8(fp)
8110ba90:	00bfbfc4 	movi	r2,-257
8110ba94:	1884703a 	and	r2,r3,r2
8110ba98:	e0bffe15 	stw	r2,-8(fp)
8110ba9c:	00000306 	br	8110baac <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110baa0:	e0bffe17 	ldw	r2,-8(fp)
8110baa4:	10804014 	ori	r2,r2,256
8110baa8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110baac:	e17ffe17 	ldw	r5,-8(fp)
8110bab0:	01000204 	movi	r4,8
8110bab4:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110bab8:	00800044 	movi	r2,1
}
8110babc:	e037883a 	mov	sp,fp
8110bac0:	dfc00117 	ldw	ra,4(sp)
8110bac4:	df000017 	ldw	fp,0(sp)
8110bac8:	dec00204 	addi	sp,sp,8
8110bacc:	f800283a 	ret

8110bad0 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110bad0:	defffc04 	addi	sp,sp,-16
8110bad4:	de00012e 	bgeu	sp,et,8110badc <bSyncSetNCycles+0xc>
8110bad8:	003b68fa 	trap	3
8110badc:	dfc00315 	stw	ra,12(sp)
8110bae0:	df000215 	stw	fp,8(sp)
8110bae4:	df000204 	addi	fp,sp,8
8110bae8:	2005883a 	mov	r2,r4
8110baec:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110baf0:	01000204 	movi	r4,8
8110baf4:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110baf8:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110bafc:	e0fffe17 	ldw	r3,-8(fp)
8110bb00:	00bfc004 	movi	r2,-256
8110bb04:	1884703a 	and	r2,r3,r2
8110bb08:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110bb0c:	e0bfff03 	ldbu	r2,-4(fp)
8110bb10:	e0fffe17 	ldw	r3,-8(fp)
8110bb14:	1884b03a 	or	r2,r3,r2
8110bb18:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110bb1c:	e17ffe17 	ldw	r5,-8(fp)
8110bb20:	01000204 	movi	r4,8
8110bb24:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110bb28:	00800044 	movi	r2,1
}
8110bb2c:	e037883a 	mov	sp,fp
8110bb30:	dfc00117 	ldw	ra,4(sp)
8110bb34:	df000017 	ldw	fp,0(sp)
8110bb38:	dec00204 	addi	sp,sp,8
8110bb3c:	f800283a 	ret

8110bb40 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110bb40:	defffd04 	addi	sp,sp,-12
8110bb44:	de00012e 	bgeu	sp,et,8110bb4c <uliSyncGetMbt+0xc>
8110bb48:	003b68fa 	trap	3
8110bb4c:	dfc00215 	stw	ra,8(sp)
8110bb50:	df000115 	stw	fp,4(sp)
8110bb54:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110bb58:	01000104 	movi	r4,4
8110bb5c:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bb60:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bb64:	e0bfff17 	ldw	r2,-4(fp)
}
8110bb68:	e037883a 	mov	sp,fp
8110bb6c:	dfc00117 	ldw	ra,4(sp)
8110bb70:	df000017 	ldw	fp,0(sp)
8110bb74:	dec00204 	addi	sp,sp,8
8110bb78:	f800283a 	ret

8110bb7c <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110bb7c:	defffd04 	addi	sp,sp,-12
8110bb80:	de00012e 	bgeu	sp,et,8110bb88 <uliSyncGetBt+0xc>
8110bb84:	003b68fa 	trap	3
8110bb88:	dfc00215 	stw	ra,8(sp)
8110bb8c:	df000115 	stw	fp,4(sp)
8110bb90:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110bb94:	01000144 	movi	r4,5
8110bb98:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bb9c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bba0:	e0bfff17 	ldw	r2,-4(fp)
}
8110bba4:	e037883a 	mov	sp,fp
8110bba8:	dfc00117 	ldw	ra,4(sp)
8110bbac:	df000017 	ldw	fp,0(sp)
8110bbb0:	dec00204 	addi	sp,sp,8
8110bbb4:	f800283a 	ret

8110bbb8 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110bbb8:	defffd04 	addi	sp,sp,-12
8110bbbc:	de00012e 	bgeu	sp,et,8110bbc4 <uliSyncGetPer+0xc>
8110bbc0:	003b68fa 	trap	3
8110bbc4:	dfc00215 	stw	ra,8(sp)
8110bbc8:	df000115 	stw	fp,4(sp)
8110bbcc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110bbd0:	01000184 	movi	r4,6
8110bbd4:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bbd8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bbdc:	e0bfff17 	ldw	r2,-4(fp)
}
8110bbe0:	e037883a 	mov	sp,fp
8110bbe4:	dfc00117 	ldw	ra,4(sp)
8110bbe8:	df000017 	ldw	fp,0(sp)
8110bbec:	dec00204 	addi	sp,sp,8
8110bbf0:	f800283a 	ret

8110bbf4 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110bbf4:	defffd04 	addi	sp,sp,-12
8110bbf8:	de00012e 	bgeu	sp,et,8110bc00 <uliSyncGetOst+0xc>
8110bbfc:	003b68fa 	trap	3
8110bc00:	dfc00215 	stw	ra,8(sp)
8110bc04:	df000115 	stw	fp,4(sp)
8110bc08:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110bc0c:	010001c4 	movi	r4,7
8110bc10:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bc14:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bc18:	e0bfff17 	ldw	r2,-4(fp)
}
8110bc1c:	e037883a 	mov	sp,fp
8110bc20:	dfc00117 	ldw	ra,4(sp)
8110bc24:	df000017 	ldw	fp,0(sp)
8110bc28:	dec00204 	addi	sp,sp,8
8110bc2c:	f800283a 	ret

8110bc30 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110bc30:	defffd04 	addi	sp,sp,-12
8110bc34:	de00012e 	bgeu	sp,et,8110bc3c <uliSyncGetGeneral+0xc>
8110bc38:	003b68fa 	trap	3
8110bc3c:	dfc00215 	stw	ra,8(sp)
8110bc40:	df000115 	stw	fp,4(sp)
8110bc44:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110bc48:	01000204 	movi	r4,8
8110bc4c:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bc50:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bc54:	e0bfff17 	ldw	r2,-4(fp)
}
8110bc58:	e037883a 	mov	sp,fp
8110bc5c:	dfc00117 	ldw	ra,4(sp)
8110bc60:	df000017 	ldw	fp,0(sp)
8110bc64:	dec00204 	addi	sp,sp,8
8110bc68:	f800283a 	ret

8110bc6c <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110bc6c:	defffd04 	addi	sp,sp,-12
8110bc70:	de00012e 	bgeu	sp,et,8110bc78 <bSyncErrInj+0xc>
8110bc74:	003b68fa 	trap	3
8110bc78:	dfc00215 	stw	ra,8(sp)
8110bc7c:	df000115 	stw	fp,4(sp)
8110bc80:	df000104 	addi	fp,sp,4
8110bc84:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110bc88:	e17fff17 	ldw	r5,-4(fp)
8110bc8c:	01000244 	movi	r4,9
8110bc90:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110bc94:	00800044 	movi	r2,1
}
8110bc98:	e037883a 	mov	sp,fp
8110bc9c:	dfc00117 	ldw	ra,4(sp)
8110bca0:	df000017 	ldw	fp,0(sp)
8110bca4:	dec00204 	addi	sp,sp,8
8110bca8:	f800283a 	ret

8110bcac <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110bcac:	defffc04 	addi	sp,sp,-16
8110bcb0:	de00012e 	bgeu	sp,et,8110bcb8 <bSyncCtrExtnIrq+0xc>
8110bcb4:	003b68fa 	trap	3
8110bcb8:	dfc00315 	stw	ra,12(sp)
8110bcbc:	df000215 	stw	fp,8(sp)
8110bcc0:	df000204 	addi	fp,sp,8
8110bcc4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bcc8:	01000284 	movi	r4,10
8110bccc:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bcd0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110bcd4:	e0bfff17 	ldw	r2,-4(fp)
8110bcd8:	1000061e 	bne	r2,zero,8110bcf4 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110bcdc:	e0fffe17 	ldw	r3,-8(fp)
8110bce0:	00a00034 	movhi	r2,32768
8110bce4:	10bfffc4 	addi	r2,r2,-1
8110bce8:	1884703a 	and	r2,r3,r2
8110bcec:	e0bffe15 	stw	r2,-8(fp)
8110bcf0:	00000306 	br	8110bd00 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110bcf4:	e0bffe17 	ldw	r2,-8(fp)
8110bcf8:	10a00034 	orhi	r2,r2,32768
8110bcfc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bd00:	e17ffe17 	ldw	r5,-8(fp)
8110bd04:	01000284 	movi	r4,10
8110bd08:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110bd0c:	00800044 	movi	r2,1
}
8110bd10:	e037883a 	mov	sp,fp
8110bd14:	dfc00117 	ldw	ra,4(sp)
8110bd18:	df000017 	ldw	fp,0(sp)
8110bd1c:	dec00204 	addi	sp,sp,8
8110bd20:	f800283a 	ret

8110bd24 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110bd24:	defffd04 	addi	sp,sp,-12
8110bd28:	de00012e 	bgeu	sp,et,8110bd30 <bSyncCtrStart+0xc>
8110bd2c:	003b68fa 	trap	3
8110bd30:	dfc00215 	stw	ra,8(sp)
8110bd34:	df000115 	stw	fp,4(sp)
8110bd38:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bd3c:	01000284 	movi	r4,10
8110bd40:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bd44:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110bd48:	e0bfff17 	ldw	r2,-4(fp)
8110bd4c:	10800234 	orhi	r2,r2,8
8110bd50:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bd54:	e17fff17 	ldw	r5,-4(fp)
8110bd58:	01000284 	movi	r4,10
8110bd5c:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110bd60:	00800044 	movi	r2,1
}
8110bd64:	e037883a 	mov	sp,fp
8110bd68:	dfc00117 	ldw	ra,4(sp)
8110bd6c:	df000017 	ldw	fp,0(sp)
8110bd70:	dec00204 	addi	sp,sp,8
8110bd74:	f800283a 	ret

8110bd78 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110bd78:	defffd04 	addi	sp,sp,-12
8110bd7c:	de00012e 	bgeu	sp,et,8110bd84 <bSyncCtrReset+0xc>
8110bd80:	003b68fa 	trap	3
8110bd84:	dfc00215 	stw	ra,8(sp)
8110bd88:	df000115 	stw	fp,4(sp)
8110bd8c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bd90:	01000284 	movi	r4,10
8110bd94:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bd98:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110bd9c:	e0bfff17 	ldw	r2,-4(fp)
8110bda0:	10800134 	orhi	r2,r2,4
8110bda4:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bda8:	e17fff17 	ldw	r5,-4(fp)
8110bdac:	01000284 	movi	r4,10
8110bdb0:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110bdb4:	00800044 	movi	r2,1
}
8110bdb8:	e037883a 	mov	sp,fp
8110bdbc:	dfc00117 	ldw	ra,4(sp)
8110bdc0:	df000017 	ldw	fp,0(sp)
8110bdc4:	dec00204 	addi	sp,sp,8
8110bdc8:	f800283a 	ret

8110bdcc <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110bdcc:	defffd04 	addi	sp,sp,-12
8110bdd0:	de00012e 	bgeu	sp,et,8110bdd8 <bSyncCtrOneShot+0xc>
8110bdd4:	003b68fa 	trap	3
8110bdd8:	dfc00215 	stw	ra,8(sp)
8110bddc:	df000115 	stw	fp,4(sp)
8110bde0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bde4:	01000284 	movi	r4,10
8110bde8:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bdec:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110bdf0:	e0bfff17 	ldw	r2,-4(fp)
8110bdf4:	108000b4 	orhi	r2,r2,2
8110bdf8:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bdfc:	e17fff17 	ldw	r5,-4(fp)
8110be00:	01000284 	movi	r4,10
8110be04:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110be08:	00800044 	movi	r2,1
}
8110be0c:	e037883a 	mov	sp,fp
8110be10:	dfc00117 	ldw	ra,4(sp)
8110be14:	df000017 	ldw	fp,0(sp)
8110be18:	dec00204 	addi	sp,sp,8
8110be1c:	f800283a 	ret

8110be20 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110be20:	defffd04 	addi	sp,sp,-12
8110be24:	de00012e 	bgeu	sp,et,8110be2c <bSyncCtrErrInj+0xc>
8110be28:	003b68fa 	trap	3
8110be2c:	dfc00215 	stw	ra,8(sp)
8110be30:	df000115 	stw	fp,4(sp)
8110be34:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110be38:	01000284 	movi	r4,10
8110be3c:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110be40:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110be44:	e0bfff17 	ldw	r2,-4(fp)
8110be48:	10800074 	orhi	r2,r2,1
8110be4c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110be50:	e17fff17 	ldw	r5,-4(fp)
8110be54:	01000284 	movi	r4,10
8110be58:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110be5c:	00800044 	movi	r2,1
}
8110be60:	e037883a 	mov	sp,fp
8110be64:	dfc00117 	ldw	ra,4(sp)
8110be68:	df000017 	ldw	fp,0(sp)
8110be6c:	dec00204 	addi	sp,sp,8
8110be70:	f800283a 	ret

8110be74 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110be74:	defffc04 	addi	sp,sp,-16
8110be78:	de00012e 	bgeu	sp,et,8110be80 <bSyncCtrSyncOutEnable+0xc>
8110be7c:	003b68fa 	trap	3
8110be80:	dfc00315 	stw	ra,12(sp)
8110be84:	df000215 	stw	fp,8(sp)
8110be88:	df000204 	addi	fp,sp,8
8110be8c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110be90:	01000284 	movi	r4,10
8110be94:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110be98:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110be9c:	e0bfff17 	ldw	r2,-4(fp)
8110bea0:	1000051e 	bne	r2,zero,8110beb8 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110bea4:	e0fffe17 	ldw	r3,-8(fp)
8110bea8:	00bfbfc4 	movi	r2,-257
8110beac:	1884703a 	and	r2,r3,r2
8110beb0:	e0bffe15 	stw	r2,-8(fp)
8110beb4:	00000306 	br	8110bec4 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110beb8:	e0bffe17 	ldw	r2,-8(fp)
8110bebc:	10804014 	ori	r2,r2,256
8110bec0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bec4:	e17ffe17 	ldw	r5,-8(fp)
8110bec8:	01000284 	movi	r4,10
8110becc:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110bed0:	00800044 	movi	r2,1
}
8110bed4:	e037883a 	mov	sp,fp
8110bed8:	dfc00117 	ldw	ra,4(sp)
8110bedc:	df000017 	ldw	fp,0(sp)
8110bee0:	dec00204 	addi	sp,sp,8
8110bee4:	f800283a 	ret

8110bee8 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110bee8:	defffc04 	addi	sp,sp,-16
8110beec:	de00012e 	bgeu	sp,et,8110bef4 <bSyncCtrCh1OutEnable+0xc>
8110bef0:	003b68fa 	trap	3
8110bef4:	dfc00315 	stw	ra,12(sp)
8110bef8:	df000215 	stw	fp,8(sp)
8110befc:	df000204 	addi	fp,sp,8
8110bf00:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bf04:	01000284 	movi	r4,10
8110bf08:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bf0c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110bf10:	e0bfff17 	ldw	r2,-4(fp)
8110bf14:	1000051e 	bne	r2,zero,8110bf2c <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110bf18:	e0fffe17 	ldw	r3,-8(fp)
8110bf1c:	00bfff84 	movi	r2,-2
8110bf20:	1884703a 	and	r2,r3,r2
8110bf24:	e0bffe15 	stw	r2,-8(fp)
8110bf28:	00000306 	br	8110bf38 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110bf2c:	e0bffe17 	ldw	r2,-8(fp)
8110bf30:	10800054 	ori	r2,r2,1
8110bf34:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bf38:	e17ffe17 	ldw	r5,-8(fp)
8110bf3c:	01000284 	movi	r4,10
8110bf40:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110bf44:	00800044 	movi	r2,1
}
8110bf48:	e037883a 	mov	sp,fp
8110bf4c:	dfc00117 	ldw	ra,4(sp)
8110bf50:	df000017 	ldw	fp,0(sp)
8110bf54:	dec00204 	addi	sp,sp,8
8110bf58:	f800283a 	ret

8110bf5c <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110bf5c:	defffc04 	addi	sp,sp,-16
8110bf60:	de00012e 	bgeu	sp,et,8110bf68 <bSyncCtrCh2OutEnable+0xc>
8110bf64:	003b68fa 	trap	3
8110bf68:	dfc00315 	stw	ra,12(sp)
8110bf6c:	df000215 	stw	fp,8(sp)
8110bf70:	df000204 	addi	fp,sp,8
8110bf74:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bf78:	01000284 	movi	r4,10
8110bf7c:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bf80:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110bf84:	e0bfff17 	ldw	r2,-4(fp)
8110bf88:	1000051e 	bne	r2,zero,8110bfa0 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110bf8c:	e0fffe17 	ldw	r3,-8(fp)
8110bf90:	00bfff44 	movi	r2,-3
8110bf94:	1884703a 	and	r2,r3,r2
8110bf98:	e0bffe15 	stw	r2,-8(fp)
8110bf9c:	00000306 	br	8110bfac <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110bfa0:	e0bffe17 	ldw	r2,-8(fp)
8110bfa4:	10800094 	ori	r2,r2,2
8110bfa8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bfac:	e17ffe17 	ldw	r5,-8(fp)
8110bfb0:	01000284 	movi	r4,10
8110bfb4:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110bfb8:	00800044 	movi	r2,1
}
8110bfbc:	e037883a 	mov	sp,fp
8110bfc0:	dfc00117 	ldw	ra,4(sp)
8110bfc4:	df000017 	ldw	fp,0(sp)
8110bfc8:	dec00204 	addi	sp,sp,8
8110bfcc:	f800283a 	ret

8110bfd0 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110bfd0:	defffc04 	addi	sp,sp,-16
8110bfd4:	de00012e 	bgeu	sp,et,8110bfdc <bSyncCtrCh3OutEnable+0xc>
8110bfd8:	003b68fa 	trap	3
8110bfdc:	dfc00315 	stw	ra,12(sp)
8110bfe0:	df000215 	stw	fp,8(sp)
8110bfe4:	df000204 	addi	fp,sp,8
8110bfe8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bfec:	01000284 	movi	r4,10
8110bff0:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110bff4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110bff8:	e0bfff17 	ldw	r2,-4(fp)
8110bffc:	1000051e 	bne	r2,zero,8110c014 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110c000:	e0fffe17 	ldw	r3,-8(fp)
8110c004:	00bffec4 	movi	r2,-5
8110c008:	1884703a 	and	r2,r3,r2
8110c00c:	e0bffe15 	stw	r2,-8(fp)
8110c010:	00000306 	br	8110c020 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110c014:	e0bffe17 	ldw	r2,-8(fp)
8110c018:	10800114 	ori	r2,r2,4
8110c01c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c020:	e17ffe17 	ldw	r5,-8(fp)
8110c024:	01000284 	movi	r4,10
8110c028:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c02c:	00800044 	movi	r2,1
}
8110c030:	e037883a 	mov	sp,fp
8110c034:	dfc00117 	ldw	ra,4(sp)
8110c038:	df000017 	ldw	fp,0(sp)
8110c03c:	dec00204 	addi	sp,sp,8
8110c040:	f800283a 	ret

8110c044 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110c044:	defffc04 	addi	sp,sp,-16
8110c048:	de00012e 	bgeu	sp,et,8110c050 <bSyncCtrCh4OutEnable+0xc>
8110c04c:	003b68fa 	trap	3
8110c050:	dfc00315 	stw	ra,12(sp)
8110c054:	df000215 	stw	fp,8(sp)
8110c058:	df000204 	addi	fp,sp,8
8110c05c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c060:	01000284 	movi	r4,10
8110c064:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c068:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c06c:	e0bfff17 	ldw	r2,-4(fp)
8110c070:	1000051e 	bne	r2,zero,8110c088 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110c074:	e0fffe17 	ldw	r3,-8(fp)
8110c078:	00bffdc4 	movi	r2,-9
8110c07c:	1884703a 	and	r2,r3,r2
8110c080:	e0bffe15 	stw	r2,-8(fp)
8110c084:	00000306 	br	8110c094 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110c088:	e0bffe17 	ldw	r2,-8(fp)
8110c08c:	10800214 	ori	r2,r2,8
8110c090:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c094:	e17ffe17 	ldw	r5,-8(fp)
8110c098:	01000284 	movi	r4,10
8110c09c:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c0a0:	00800044 	movi	r2,1
}
8110c0a4:	e037883a 	mov	sp,fp
8110c0a8:	dfc00117 	ldw	ra,4(sp)
8110c0ac:	df000017 	ldw	fp,0(sp)
8110c0b0:	dec00204 	addi	sp,sp,8
8110c0b4:	f800283a 	ret

8110c0b8 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110c0b8:	defffc04 	addi	sp,sp,-16
8110c0bc:	de00012e 	bgeu	sp,et,8110c0c4 <bSyncCtrCh5OutEnable+0xc>
8110c0c0:	003b68fa 	trap	3
8110c0c4:	dfc00315 	stw	ra,12(sp)
8110c0c8:	df000215 	stw	fp,8(sp)
8110c0cc:	df000204 	addi	fp,sp,8
8110c0d0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c0d4:	01000284 	movi	r4,10
8110c0d8:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c0dc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c0e0:	e0bfff17 	ldw	r2,-4(fp)
8110c0e4:	1000051e 	bne	r2,zero,8110c0fc <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110c0e8:	e0fffe17 	ldw	r3,-8(fp)
8110c0ec:	00bffbc4 	movi	r2,-17
8110c0f0:	1884703a 	and	r2,r3,r2
8110c0f4:	e0bffe15 	stw	r2,-8(fp)
8110c0f8:	00000306 	br	8110c108 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110c0fc:	e0bffe17 	ldw	r2,-8(fp)
8110c100:	10800414 	ori	r2,r2,16
8110c104:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c108:	e17ffe17 	ldw	r5,-8(fp)
8110c10c:	01000284 	movi	r4,10
8110c110:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c114:	00800044 	movi	r2,1
}
8110c118:	e037883a 	mov	sp,fp
8110c11c:	dfc00117 	ldw	ra,4(sp)
8110c120:	df000017 	ldw	fp,0(sp)
8110c124:	dec00204 	addi	sp,sp,8
8110c128:	f800283a 	ret

8110c12c <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110c12c:	defffc04 	addi	sp,sp,-16
8110c130:	de00012e 	bgeu	sp,et,8110c138 <bSyncCtrCh6OutEnable+0xc>
8110c134:	003b68fa 	trap	3
8110c138:	dfc00315 	stw	ra,12(sp)
8110c13c:	df000215 	stw	fp,8(sp)
8110c140:	df000204 	addi	fp,sp,8
8110c144:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c148:	01000284 	movi	r4,10
8110c14c:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c150:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c154:	e0bfff17 	ldw	r2,-4(fp)
8110c158:	1000051e 	bne	r2,zero,8110c170 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110c15c:	e0fffe17 	ldw	r3,-8(fp)
8110c160:	00bff7c4 	movi	r2,-33
8110c164:	1884703a 	and	r2,r3,r2
8110c168:	e0bffe15 	stw	r2,-8(fp)
8110c16c:	00000306 	br	8110c17c <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110c170:	e0bffe17 	ldw	r2,-8(fp)
8110c174:	10800814 	ori	r2,r2,32
8110c178:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c17c:	e17ffe17 	ldw	r5,-8(fp)
8110c180:	01000284 	movi	r4,10
8110c184:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c188:	00800044 	movi	r2,1
}
8110c18c:	e037883a 	mov	sp,fp
8110c190:	dfc00117 	ldw	ra,4(sp)
8110c194:	df000017 	ldw	fp,0(sp)
8110c198:	dec00204 	addi	sp,sp,8
8110c19c:	f800283a 	ret

8110c1a0 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110c1a0:	defffc04 	addi	sp,sp,-16
8110c1a4:	de00012e 	bgeu	sp,et,8110c1ac <bSyncCtrCh7OutEnable+0xc>
8110c1a8:	003b68fa 	trap	3
8110c1ac:	dfc00315 	stw	ra,12(sp)
8110c1b0:	df000215 	stw	fp,8(sp)
8110c1b4:	df000204 	addi	fp,sp,8
8110c1b8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c1bc:	01000284 	movi	r4,10
8110c1c0:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c1c4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c1c8:	e0bfff17 	ldw	r2,-4(fp)
8110c1cc:	1000051e 	bne	r2,zero,8110c1e4 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110c1d0:	e0fffe17 	ldw	r3,-8(fp)
8110c1d4:	00bfefc4 	movi	r2,-65
8110c1d8:	1884703a 	and	r2,r3,r2
8110c1dc:	e0bffe15 	stw	r2,-8(fp)
8110c1e0:	00000306 	br	8110c1f0 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110c1e4:	e0bffe17 	ldw	r2,-8(fp)
8110c1e8:	10801014 	ori	r2,r2,64
8110c1ec:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c1f0:	e17ffe17 	ldw	r5,-8(fp)
8110c1f4:	01000284 	movi	r4,10
8110c1f8:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c1fc:	00800044 	movi	r2,1
}
8110c200:	e037883a 	mov	sp,fp
8110c204:	dfc00117 	ldw	ra,4(sp)
8110c208:	df000017 	ldw	fp,0(sp)
8110c20c:	dec00204 	addi	sp,sp,8
8110c210:	f800283a 	ret

8110c214 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110c214:	defffc04 	addi	sp,sp,-16
8110c218:	de00012e 	bgeu	sp,et,8110c220 <bSyncCtrCh8OutEnable+0xc>
8110c21c:	003b68fa 	trap	3
8110c220:	dfc00315 	stw	ra,12(sp)
8110c224:	df000215 	stw	fp,8(sp)
8110c228:	df000204 	addi	fp,sp,8
8110c22c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c230:	01000284 	movi	r4,10
8110c234:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c238:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c23c:	e0bfff17 	ldw	r2,-4(fp)
8110c240:	1000051e 	bne	r2,zero,8110c258 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110c244:	e0fffe17 	ldw	r3,-8(fp)
8110c248:	00bfdfc4 	movi	r2,-129
8110c24c:	1884703a 	and	r2,r3,r2
8110c250:	e0bffe15 	stw	r2,-8(fp)
8110c254:	00000306 	br	8110c264 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110c258:	e0bffe17 	ldw	r2,-8(fp)
8110c25c:	10802014 	ori	r2,r2,128
8110c260:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c264:	e17ffe17 	ldw	r5,-8(fp)
8110c268:	01000284 	movi	r4,10
8110c26c:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c270:	00800044 	movi	r2,1
}
8110c274:	e037883a 	mov	sp,fp
8110c278:	dfc00117 	ldw	ra,4(sp)
8110c27c:	df000017 	ldw	fp,0(sp)
8110c280:	dec00204 	addi	sp,sp,8
8110c284:	f800283a 	ret

8110c288 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110c288:	defffc04 	addi	sp,sp,-16
8110c28c:	de00012e 	bgeu	sp,et,8110c294 <bSyncIrqEnableError+0xc>
8110c290:	003b68fa 	trap	3
8110c294:	dfc00315 	stw	ra,12(sp)
8110c298:	df000215 	stw	fp,8(sp)
8110c29c:	df000204 	addi	fp,sp,8
8110c2a0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c2a4:	01000044 	movi	r4,1
8110c2a8:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c2ac:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c2b0:	e0bfff17 	ldw	r2,-4(fp)
8110c2b4:	1000051e 	bne	r2,zero,8110c2cc <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110c2b8:	e0fffe17 	ldw	r3,-8(fp)
8110c2bc:	00bfff44 	movi	r2,-3
8110c2c0:	1884703a 	and	r2,r3,r2
8110c2c4:	e0bffe15 	stw	r2,-8(fp)
8110c2c8:	00000306 	br	8110c2d8 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110c2cc:	e0bffe17 	ldw	r2,-8(fp)
8110c2d0:	10800094 	ori	r2,r2,2
8110c2d4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c2d8:	e17ffe17 	ldw	r5,-8(fp)
8110c2dc:	01000044 	movi	r4,1
8110c2e0:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c2e4:	00800044 	movi	r2,1
}
8110c2e8:	e037883a 	mov	sp,fp
8110c2ec:	dfc00117 	ldw	ra,4(sp)
8110c2f0:	df000017 	ldw	fp,0(sp)
8110c2f4:	dec00204 	addi	sp,sp,8
8110c2f8:	f800283a 	ret

8110c2fc <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110c2fc:	defffc04 	addi	sp,sp,-16
8110c300:	de00012e 	bgeu	sp,et,8110c308 <bSyncIrqEnableBlank+0xc>
8110c304:	003b68fa 	trap	3
8110c308:	dfc00315 	stw	ra,12(sp)
8110c30c:	df000215 	stw	fp,8(sp)
8110c310:	df000204 	addi	fp,sp,8
8110c314:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c318:	01000044 	movi	r4,1
8110c31c:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c320:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c324:	e0bfff17 	ldw	r2,-4(fp)
8110c328:	1000051e 	bne	r2,zero,8110c340 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110c32c:	e0fffe17 	ldw	r3,-8(fp)
8110c330:	00bfff84 	movi	r2,-2
8110c334:	1884703a 	and	r2,r3,r2
8110c338:	e0bffe15 	stw	r2,-8(fp)
8110c33c:	00000306 	br	8110c34c <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110c340:	e0bffe17 	ldw	r2,-8(fp)
8110c344:	10800054 	ori	r2,r2,1
8110c348:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c34c:	e17ffe17 	ldw	r5,-8(fp)
8110c350:	01000044 	movi	r4,1
8110c354:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c358:	00800044 	movi	r2,1
}
8110c35c:	e037883a 	mov	sp,fp
8110c360:	dfc00117 	ldw	ra,4(sp)
8110c364:	df000017 	ldw	fp,0(sp)
8110c368:	dec00204 	addi	sp,sp,8
8110c36c:	f800283a 	ret

8110c370 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110c370:	defffc04 	addi	sp,sp,-16
8110c374:	de00012e 	bgeu	sp,et,8110c37c <bSyncIrqFlagClrError+0xc>
8110c378:	003b68fa 	trap	3
8110c37c:	dfc00315 	stw	ra,12(sp)
8110c380:	df000215 	stw	fp,8(sp)
8110c384:	df000204 	addi	fp,sp,8
8110c388:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c38c:	01000084 	movi	r4,2
8110c390:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c394:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c398:	e0bfff17 	ldw	r2,-4(fp)
8110c39c:	1000051e 	bne	r2,zero,8110c3b4 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c3a0:	e0fffe17 	ldw	r3,-8(fp)
8110c3a4:	00bfff44 	movi	r2,-3
8110c3a8:	1884703a 	and	r2,r3,r2
8110c3ac:	e0bffe15 	stw	r2,-8(fp)
8110c3b0:	00000306 	br	8110c3c0 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c3b4:	e0bffe17 	ldw	r2,-8(fp)
8110c3b8:	10800094 	ori	r2,r2,2
8110c3bc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c3c0:	e17ffe17 	ldw	r5,-8(fp)
8110c3c4:	01000084 	movi	r4,2
8110c3c8:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c3cc:	00800044 	movi	r2,1
}
8110c3d0:	e037883a 	mov	sp,fp
8110c3d4:	dfc00117 	ldw	ra,4(sp)
8110c3d8:	df000017 	ldw	fp,0(sp)
8110c3dc:	dec00204 	addi	sp,sp,8
8110c3e0:	f800283a 	ret

8110c3e4 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110c3e4:	defffc04 	addi	sp,sp,-16
8110c3e8:	de00012e 	bgeu	sp,et,8110c3f0 <bSyncIrqFlagClrBlank+0xc>
8110c3ec:	003b68fa 	trap	3
8110c3f0:	dfc00315 	stw	ra,12(sp)
8110c3f4:	df000215 	stw	fp,8(sp)
8110c3f8:	df000204 	addi	fp,sp,8
8110c3fc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c400:	01000084 	movi	r4,2
8110c404:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c408:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c40c:	e0bfff17 	ldw	r2,-4(fp)
8110c410:	1000051e 	bne	r2,zero,8110c428 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c414:	e0fffe17 	ldw	r3,-8(fp)
8110c418:	00bfff84 	movi	r2,-2
8110c41c:	1884703a 	and	r2,r3,r2
8110c420:	e0bffe15 	stw	r2,-8(fp)
8110c424:	00000306 	br	8110c434 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c428:	e0bffe17 	ldw	r2,-8(fp)
8110c42c:	10800054 	ori	r2,r2,1
8110c430:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c434:	e17ffe17 	ldw	r5,-8(fp)
8110c438:	01000084 	movi	r4,2
8110c43c:	110c5800 	call	8110c580 <bSyncWriteReg>
	return TRUE;
8110c440:	00800044 	movi	r2,1
}
8110c444:	e037883a 	mov	sp,fp
8110c448:	dfc00117 	ldw	ra,4(sp)
8110c44c:	df000017 	ldw	fp,0(sp)
8110c450:	dec00204 	addi	sp,sp,8
8110c454:	f800283a 	ret

8110c458 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110c458:	defffc04 	addi	sp,sp,-16
8110c45c:	de00012e 	bgeu	sp,et,8110c464 <bSyncIrqFlagError+0xc>
8110c460:	003b68fa 	trap	3
8110c464:	dfc00315 	stw	ra,12(sp)
8110c468:	df000215 	stw	fp,8(sp)
8110c46c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c470:	010000c4 	movi	r4,3
8110c474:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c478:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110c47c:	e0bfff17 	ldw	r2,-4(fp)
8110c480:	1080008c 	andi	r2,r2,2
8110c484:	10000326 	beq	r2,zero,8110c494 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110c488:	00800044 	movi	r2,1
8110c48c:	e0bffe15 	stw	r2,-8(fp)
8110c490:	00000106 	br	8110c498 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110c494:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c498:	e0bffe17 	ldw	r2,-8(fp)
}
8110c49c:	e037883a 	mov	sp,fp
8110c4a0:	dfc00117 	ldw	ra,4(sp)
8110c4a4:	df000017 	ldw	fp,0(sp)
8110c4a8:	dec00204 	addi	sp,sp,8
8110c4ac:	f800283a 	ret

8110c4b0 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110c4b0:	defffc04 	addi	sp,sp,-16
8110c4b4:	de00012e 	bgeu	sp,et,8110c4bc <bSyncIrqFlagBlank+0xc>
8110c4b8:	003b68fa 	trap	3
8110c4bc:	dfc00315 	stw	ra,12(sp)
8110c4c0:	df000215 	stw	fp,8(sp)
8110c4c4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c4c8:	010000c4 	movi	r4,3
8110c4cc:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c4d0:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110c4d4:	e0bfff17 	ldw	r2,-4(fp)
8110c4d8:	1080004c 	andi	r2,r2,1
8110c4dc:	10000326 	beq	r2,zero,8110c4ec <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110c4e0:	00800044 	movi	r2,1
8110c4e4:	e0bffe15 	stw	r2,-8(fp)
8110c4e8:	00000106 	br	8110c4f0 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110c4ec:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c4f0:	e0bffe17 	ldw	r2,-8(fp)
}
8110c4f4:	e037883a 	mov	sp,fp
8110c4f8:	dfc00117 	ldw	ra,4(sp)
8110c4fc:	df000017 	ldw	fp,0(sp)
8110c500:	dec00204 	addi	sp,sp,8
8110c504:	f800283a 	ret

8110c508 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110c508:	defffd04 	addi	sp,sp,-12
8110c50c:	de00012e 	bgeu	sp,et,8110c514 <uliSyncGetCtr+0xc>
8110c510:	003b68fa 	trap	3
8110c514:	dfc00215 	stw	ra,8(sp)
8110c518:	df000115 	stw	fp,4(sp)
8110c51c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c520:	01000284 	movi	r4,10
8110c524:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c528:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c52c:	e0bfff17 	ldw	r2,-4(fp)
}
8110c530:	e037883a 	mov	sp,fp
8110c534:	dfc00117 	ldw	ra,4(sp)
8110c538:	df000017 	ldw	fp,0(sp)
8110c53c:	dec00204 	addi	sp,sp,8
8110c540:	f800283a 	ret

8110c544 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110c544:	defffd04 	addi	sp,sp,-12
8110c548:	de00012e 	bgeu	sp,et,8110c550 <uliSyncReadStatus+0xc>
8110c54c:	003b68fa 	trap	3
8110c550:	dfc00215 	stw	ra,8(sp)
8110c554:	df000115 	stw	fp,4(sp)
8110c558:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c55c:	0009883a 	mov	r4,zero
8110c560:	110c5dc0 	call	8110c5dc <uliSyncReadReg>
8110c564:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110c568:	e0bfff17 	ldw	r2,-4(fp)
}
8110c56c:	e037883a 	mov	sp,fp
8110c570:	dfc00117 	ldw	ra,4(sp)
8110c574:	df000017 	ldw	fp,0(sp)
8110c578:	dec00204 	addi	sp,sp,8
8110c57c:	f800283a 	ret

8110c580 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110c580:	defffc04 	addi	sp,sp,-16
8110c584:	de00012e 	bgeu	sp,et,8110c58c <bSyncWriteReg+0xc>
8110c588:	003b68fa 	trap	3
8110c58c:	df000315 	stw	fp,12(sp)
8110c590:	df000304 	addi	fp,sp,12
8110c594:	e13ffe15 	stw	r4,-8(fp)
8110c598:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c59c:	00a00034 	movhi	r2,32768
8110c5a0:	10810004 	addi	r2,r2,1024
8110c5a4:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110c5a8:	e0bffe17 	ldw	r2,-8(fp)
8110c5ac:	1085883a 	add	r2,r2,r2
8110c5b0:	1085883a 	add	r2,r2,r2
8110c5b4:	1007883a 	mov	r3,r2
8110c5b8:	e0bffd17 	ldw	r2,-12(fp)
8110c5bc:	10c5883a 	add	r2,r2,r3
8110c5c0:	e0ffff17 	ldw	r3,-4(fp)
8110c5c4:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110c5c8:	00800044 	movi	r2,1
}
8110c5cc:	e037883a 	mov	sp,fp
8110c5d0:	df000017 	ldw	fp,0(sp)
8110c5d4:	dec00104 	addi	sp,sp,4
8110c5d8:	f800283a 	ret

8110c5dc <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110c5dc:	defffc04 	addi	sp,sp,-16
8110c5e0:	de00012e 	bgeu	sp,et,8110c5e8 <uliSyncReadReg+0xc>
8110c5e4:	003b68fa 	trap	3
8110c5e8:	df000315 	stw	fp,12(sp)
8110c5ec:	df000304 	addi	fp,sp,12
8110c5f0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c5f4:	00a00034 	movhi	r2,32768
8110c5f8:	10810004 	addi	r2,r2,1024
8110c5fc:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110c600:	e0bfff17 	ldw	r2,-4(fp)
8110c604:	1085883a 	add	r2,r2,r2
8110c608:	1085883a 	add	r2,r2,r2
8110c60c:	1007883a 	mov	r3,r2
8110c610:	e0bffd17 	ldw	r2,-12(fp)
8110c614:	10c5883a 	add	r2,r2,r3
8110c618:	10800017 	ldw	r2,0(r2)
8110c61c:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110c620:	e0bffe17 	ldw	r2,-8(fp)
}
8110c624:	e037883a 	mov	sp,fp
8110c628:	df000017 	ldw	fp,0(sp)
8110c62c:	dec00104 	addi	sp,sp,4
8110c630:	f800283a 	ret

8110c634 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110c634:	defff804 	addi	sp,sp,-32
8110c638:	de00012e 	bgeu	sp,et,8110c640 <vDataControlTask+0xc>
8110c63c:	003b68fa 	trap	3
8110c640:	dfc00715 	stw	ra,28(sp)
8110c644:	df000615 	stw	fp,24(sp)
8110c648:	df000604 	addi	fp,sp,24
8110c64c:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110c650:	e0bffd17 	ldw	r2,-12(fp)
8110c654:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110c658:	d0a05c17 	ldw	r2,-32400(gp)
8110c65c:	100f883a 	mov	r7,r2
8110c660:	01800804 	movi	r6,32
8110c664:	01400044 	movi	r5,1
8110c668:	01204534 	movhi	r4,33044
8110c66c:	211b6404 	addi	r4,r4,28048
8110c670:	111ba2c0 	call	8111ba2c <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110c674:	e0bffa17 	ldw	r2,-24(fp)
8110c678:	00c00044 	movi	r3,1
8110c67c:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110c680:	d0a05917 	ldw	r2,-32412(gp)
8110c684:	1009883a 	mov	r4,r2
8110c688:	11384b40 	call	811384b4 <OSQFlush>
8110c68c:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110c690:	e0bffc03 	ldbu	r2,-16(fp)
8110c694:	10803fcc 	andi	r2,r2,255
8110c698:	10000126 	beq	r2,zero,8110c6a0 <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110c69c:	11182c00 	call	811182c0 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskCMDNDataCtrlTBL, 0, &error_code); /* Blocking operation */
8110c6a0:	e0bffc04 	addi	r2,fp,-16
8110c6a4:	100d883a 	mov	r6,r2
8110c6a8:	000b883a 	mov	r5,zero
8110c6ac:	01204574 	movhi	r4,33045
8110c6b0:	21159a04 	addi	r4,r4,22120
8110c6b4:	11385740 	call	81138574 <OSQPend>
8110c6b8:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110c6bc:	000f883a 	mov	r7,zero
8110c6c0:	01800144 	movi	r6,5
8110c6c4:	000b883a 	mov	r5,zero
8110c6c8:	0009883a 	mov	r4,zero
8110c6cc:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
	}
8110c6d0:	003ff306 	br	8110c6a0 <__reset+0xfb0ec6a0>

8110c6d4 <vFeeTask>:

#include "fee_task.h"



void vFeeTask(void *task_data) {
8110c6d4:	defff904 	addi	sp,sp,-28
8110c6d8:	de00012e 	bgeu	sp,et,8110c6e0 <vFeeTask+0xc>
8110c6dc:	003b68fa 	trap	3
8110c6e0:	dfc00615 	stw	ra,24(sp)
8110c6e4:	df000515 	stw	fp,20(sp)
8110c6e8:	df000504 	addi	fp,sp,20
8110c6ec:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110c6f0:	e03ffb15 	stw	zero,-20(fp)
	alt_u32 tCodeNext;
	alt_u32 tCode;
	tQMask uiCmdFEE;


	pxNFee = ( TNFee * ) task_data;
8110c6f4:	e0bfff17 	ldw	r2,-4(fp)
8110c6f8:	d0a05115 	stw	r2,-32444(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110c6fc:	d0e05c17 	ldw	r3,-32400(gp)
8110c700:	d0a05117 	ldw	r2,-32444(gp)
8110c704:	10800003 	ldbu	r2,0(r2)
8110c708:	10803fcc 	andi	r2,r2,255
8110c70c:	100d883a 	mov	r6,r2
8110c710:	01604534 	movhi	r5,33044
8110c714:	295b6d04 	addi	r5,r5,28084
8110c718:	1809883a 	mov	r4,r3
8110c71c:	111b3900 	call	8111b390 <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110c720:	d0a05117 	ldw	r2,-32444(gp)
8110c724:	1009883a 	mov	r4,r2
8110c728:	110d4b80 	call	8110d4b8 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110c72c:	d0a05117 	ldw	r2,-32444(gp)
8110c730:	10802c17 	ldw	r2,176(r2)
8110c734:	10c00328 	cmpgeui	r3,r2,12
8110c738:	18019f1e 	bne	r3,zero,8110cdb8 <vFeeTask+0x6e4>
8110c73c:	100690ba 	slli	r3,r2,2
8110c740:	00a04474 	movhi	r2,33041
8110c744:	10b1d504 	addi	r2,r2,-14508
8110c748:	1885883a 	add	r2,r3,r2
8110c74c:	10800017 	ldw	r2,0(r2)
8110c750:	1000683a 	jmp	r2
8110c754:	8110c784 	addi	r4,r16,17182
8110c758:	8110c92c 	andhi	r4,r16,17188
8110c75c:	8110c9b0 	cmpltui	r4,r16,17190
8110c760:	8110ca44 	addi	r4,r16,17193
8110c764:	8110cc08 	cmpgei	r4,r16,17200
8110c768:	8110c80c 	andi	r4,r16,17184
8110c76c:	8110c9c0 	call	88110c9c <__reset+0x20f0c9c>
8110c770:	8110cb9c 	xori	r4,r16,17198
8110c774:	8110cdb8 	rdprs	r4,r16,17206
8110c778:	8110cdec 	andhi	r4,r16,17207
8110c77c:	8110cac8 	cmpgei	r4,r16,17195
8110c780:	8110cc8c 	andi	r4,r16,17202
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110c784:	d0a05117 	ldw	r2,-32444(gp)
8110c788:	10800003 	ldbu	r2,0(r2)
8110c78c:	10803fcc 	andi	r2,r2,255
8110c790:	1085883a 	add	r2,r2,r2
8110c794:	1087883a 	add	r3,r2,r2
8110c798:	d0a06404 	addi	r2,gp,-32368
8110c79c:	1885883a 	add	r2,r3,r2
8110c7a0:	10800017 	ldw	r2,0(r2)
8110c7a4:	1009883a 	mov	r4,r2
8110c7a8:	11384b40 	call	811384b4 <OSQFlush>
8110c7ac:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110c7b0:	e0bffd43 	ldbu	r2,-11(fp)
8110c7b4:	10803fcc 	andi	r2,r2,255
8110c7b8:	10000126 	beq	r2,zero,8110c7c0 <vFeeTask+0xec>
					vFailFlushNFEEQueue();
8110c7bc:	11183580 	call	81118358 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110c7c0:	d0a05117 	ldw	r2,-32444(gp)
8110c7c4:	10800003 	ldbu	r2,0(r2)
8110c7c8:	10803fcc 	andi	r2,r2,255
8110c7cc:	1085883a 	add	r2,r2,r2
8110c7d0:	1087883a 	add	r3,r2,r2
8110c7d4:	d0a05604 	addi	r2,gp,-32424
8110c7d8:	1885883a 	add	r2,r3,r2
8110c7dc:	10800017 	ldw	r2,0(r2)
8110c7e0:	1009883a 	mov	r4,r2
8110c7e4:	11384b40 	call	811384b4 <OSQFlush>
8110c7e8:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110c7ec:	e0bffd43 	ldbu	r2,-11(fp)
8110c7f0:	10803fcc 	andi	r2,r2,255
8110c7f4:	10000126 	beq	r2,zero,8110c7fc <vFeeTask+0x128>
					vFailFlushNFEEQueue();
8110c7f8:	11183580 	call	81118358 <vFailFlushNFEEQueue>
				}				

				pxNFee->xControl.eMode = sToFeeConfig;
8110c7fc:	d0a05117 	ldw	r2,-32444(gp)
8110c800:	00c00144 	movi	r3,5
8110c804:	10c02c15 	stw	r3,176(r2)

				break;
8110c808:	00017906 	br	8110cdf0 <vFeeTask+0x71c>
			case sToFeeConfig: /* Transition */
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110c80c:	d0e05c17 	ldw	r3,-32400(gp)
8110c810:	d0a05117 	ldw	r2,-32444(gp)
8110c814:	10800003 	ldbu	r2,0(r2)
8110c818:	10803fcc 	andi	r2,r2,255
8110c81c:	100d883a 	mov	r6,r2
8110c820:	01604534 	movhi	r5,33044
8110c824:	295b7404 	addi	r5,r5,28112
8110c828:	1809883a 	mov	r4,r3
8110c82c:	111b3900 	call	8111b390 <fprintf>
					//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

				}

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110c830:	d0a05117 	ldw	r2,-32444(gp)
8110c834:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110c838:	d0a05117 	ldw	r2,-32444(gp)
8110c83c:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110c840:	d0a05117 	ldw	r2,-32444(gp)
8110c844:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110c848:	d0a05117 	ldw	r2,-32444(gp)
8110c84c:	00c00044 	movi	r3,1
8110c850:	10c02115 	stw	r3,132(r2)
				pxNFee->xControl.ucTimeCode = 0;
8110c854:	d0a05117 	ldw	r2,-32444(gp)
8110c858:	10002a05 	stb	zero,168(r2)

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110c85c:	d0a05117 	ldw	r2,-32444(gp)
8110c860:	10800003 	ldbu	r2,0(r2)
8110c864:	10803fcc 	andi	r2,r2,255
8110c868:	1085883a 	add	r2,r2,r2
8110c86c:	1087883a 	add	r3,r2,r2
8110c870:	d0a06404 	addi	r2,gp,-32368
8110c874:	1885883a 	add	r2,r3,r2
8110c878:	10800017 	ldw	r2,0(r2)
8110c87c:	1009883a 	mov	r4,r2
8110c880:	11384b40 	call	811384b4 <OSQFlush>
8110c884:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110c888:	e0bffd43 	ldbu	r2,-11(fp)
8110c88c:	10803fcc 	andi	r2,r2,255
8110c890:	10000126 	beq	r2,zero,8110c898 <vFeeTask+0x1c4>
					vFailFlushNFEEQueue();
8110c894:	11183580 	call	81118358 <vFailFlushNFEEQueue>
				}

				/* Clear the Queue that indicates when Sync Signals occours */
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110c898:	d0a05117 	ldw	r2,-32444(gp)
8110c89c:	10800003 	ldbu	r2,0(r2)
8110c8a0:	10803fcc 	andi	r2,r2,255
8110c8a4:	1085883a 	add	r2,r2,r2
8110c8a8:	1087883a 	add	r3,r2,r2
8110c8ac:	d0a05604 	addi	r2,gp,-32424
8110c8b0:	1885883a 	add	r2,r3,r2
8110c8b4:	10800017 	ldw	r2,0(r2)
8110c8b8:	1009883a 	mov	r4,r2
8110c8bc:	11384b40 	call	811384b4 <OSQFlush>
8110c8c0:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110c8c4:	e0bffd43 	ldbu	r2,-11(fp)
8110c8c8:	10803fcc 	andi	r2,r2,255
8110c8cc:	10000126 	beq	r2,zero,8110c8d4 <vFeeTask+0x200>
					vFailFlushNFEEQueue();
8110c8d0:	11183580 	call	81118358 <vFailFlushNFEEQueue>
				}

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110c8d4:	d0a05117 	ldw	r2,-32444(gp)
8110c8d8:	10808804 	addi	r2,r2,544
8110c8dc:	1009883a 	mov	r4,r2
8110c8e0:	110d3280 	call	8110d328 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110c8e4:	d0a05117 	ldw	r2,-32444(gp)
8110c8e8:	10002615 	stw	zero,152(r2)


				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap);
8110c8ec:	d0a05117 	ldw	r2,-32444(gp)
8110c8f0:	10804204 	addi	r2,r2,264
8110c8f4:	1009883a 	mov	r4,r2
8110c8f8:	110d28c0 	call	8110d28c <bDisableRmapIRQ>


				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110c8fc:	d0a05117 	ldw	r2,-32444(gp)
8110c900:	10803b04 	addi	r2,r2,236
8110c904:	1009883a 	mov	r4,r2
8110c908:	110d4540 	call	8110d454 <bDisAndClrDbBuffer>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				bSpwcClearTimecode(&pxNFee->xChannel.xSpacewire);
8110c90c:	d0a05117 	ldw	r2,-32444(gp)
8110c910:	10808804 	addi	r2,r2,544
8110c914:	1009883a 	mov	r4,r2
8110c918:	110920c0 	call	8110920c <bSpwcClearTimecode>

				pxNFee->xControl.eMode = sFeeConfig;
8110c91c:	d0a05117 	ldw	r2,-32444(gp)
8110c920:	00c00044 	movi	r3,1
8110c924:	10c02c15 	stw	r3,176(r2)
				break;
8110c928:	00013106 	br	8110cdf0 <vFeeTask+0x71c>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110c92c:	d0a05117 	ldw	r2,-32444(gp)
8110c930:	10800003 	ldbu	r2,0(r2)
8110c934:	10803fcc 	andi	r2,r2,255
8110c938:	1085883a 	add	r2,r2,r2
8110c93c:	1087883a 	add	r3,r2,r2
8110c940:	d0a06404 	addi	r2,gp,-32368
8110c944:	1885883a 	add	r2,r3,r2
8110c948:	10800017 	ldw	r2,0(r2)
8110c94c:	e0fffd44 	addi	r3,fp,-11
8110c950:	180d883a 	mov	r6,r3
8110c954:	000b883a 	mov	r5,zero
8110c958:	1009883a 	mov	r4,r2
8110c95c:	11385740 	call	81138574 <OSQPend>
8110c960:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110c964:	e0bffd43 	ldbu	r2,-11(fp)
8110c968:	10803fcc 	andi	r2,r2,255
8110c96c:	1000061e 	bne	r2,zero,8110c988 <vFeeTask+0x2b4>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110c970:	d0a05117 	ldw	r2,-32444(gp)
8110c974:	e0fffe17 	ldw	r3,-8(fp)
8110c978:	180b883a 	mov	r5,r3
8110c97c:	1009883a 	mov	r4,r2
8110c980:	110cdf40 	call	8110cdf4 <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110c984:	00011a06 	br	8110cdf0 <vFeeTask+0x71c>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110c988:	d0e05c17 	ldw	r3,-32400(gp)
8110c98c:	d0a05117 	ldw	r2,-32444(gp)
8110c990:	10800003 	ldbu	r2,0(r2)
8110c994:	10803fcc 	andi	r2,r2,255
8110c998:	100d883a 	mov	r6,r2
8110c99c:	01604534 	movhi	r5,33044
8110c9a0:	295b7b04 	addi	r5,r5,28140
8110c9a4:	1809883a 	mov	r4,r3
8110c9a8:	111b3900 	call	8111b390 <fprintf>
					#endif
				}

				break;
8110c9ac:	00011006 	br	8110cdf0 <vFeeTask+0x71c>
			case sFeeOn: /* Real mode */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110c9b0:	d0a05117 	ldw	r2,-32444(gp)
8110c9b4:	00c00184 	movi	r3,6
8110c9b8:	10c02c15 	stw	r3,176(r2)
				break;
8110c9bc:	00010c06 	br	8110cdf0 <vFeeTask+0x71c>
				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
			case sToFeeStandBy: /* Transition */
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110c9c0:	d0e05c17 	ldw	r3,-32400(gp)
8110c9c4:	d0a05117 	ldw	r2,-32444(gp)
8110c9c8:	10800003 	ldbu	r2,0(r2)
8110c9cc:	10803fcc 	andi	r2,r2,255
8110c9d0:	100d883a 	mov	r6,r2
8110c9d4:	01604534 	movhi	r5,33044
8110c9d8:	295b8704 	addi	r5,r5,28188
8110c9dc:	1809883a 	mov	r4,r3
8110c9e0:	111b3900 	call	8111b390 <fprintf>
				#endif

				pxNFee->xControl.bSimulating = TRUE;
8110c9e4:	d0a05117 	ldw	r2,-32444(gp)
8110c9e8:	00c00044 	movi	r3,1
8110c9ec:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110c9f0:	d0a05117 	ldw	r2,-32444(gp)
8110c9f4:	10002315 	stw	zero,140(r2)

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110c9f8:	d0a05117 	ldw	r2,-32444(gp)
8110c9fc:	10803b04 	addi	r2,r2,236
8110ca00:	1009883a 	mov	r4,r2
8110ca04:	110d4540 	call	8110d454 <bDisAndClrDbBuffer>


				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap);
8110ca08:	d0a05117 	ldw	r2,-32444(gp)
8110ca0c:	10804204 	addi	r2,r2,264
8110ca10:	1009883a 	mov	r4,r2
8110ca14:	110d2d80 	call	8110d2d8 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110ca18:	d0a05117 	ldw	r2,-32444(gp)
8110ca1c:	10808804 	addi	r2,r2,544
8110ca20:	1009883a 	mov	r4,r2
8110ca24:	110d3880 	call	8110d388 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110ca28:	d0a05117 	ldw	r2,-32444(gp)
8110ca2c:	00c00044 	movi	r3,1
8110ca30:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.eMode = sFeeStandBy;
8110ca34:	d0a05117 	ldw	r2,-32444(gp)
8110ca38:	00c000c4 	movi	r3,3
8110ca3c:	10c02c15 	stw	r3,176(r2)
				break;
8110ca40:	0000eb06 	br	8110cdf0 <vFeeTask+0x71c>

			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ca44:	d0a05117 	ldw	r2,-32444(gp)
8110ca48:	10800003 	ldbu	r2,0(r2)
8110ca4c:	10803fcc 	andi	r2,r2,255
8110ca50:	1085883a 	add	r2,r2,r2
8110ca54:	1087883a 	add	r3,r2,r2
8110ca58:	d0a06404 	addi	r2,gp,-32368
8110ca5c:	1885883a 	add	r2,r3,r2
8110ca60:	10800017 	ldw	r2,0(r2)
8110ca64:	e0fffd44 	addi	r3,fp,-11
8110ca68:	180d883a 	mov	r6,r3
8110ca6c:	000b883a 	mov	r5,zero
8110ca70:	1009883a 	mov	r4,r2
8110ca74:	11385740 	call	81138574 <OSQPend>
8110ca78:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ca7c:	e0bffd43 	ldbu	r2,-11(fp)
8110ca80:	10803fcc 	andi	r2,r2,255
8110ca84:	1000061e 	bne	r2,zero,8110caa0 <vFeeTask+0x3cc>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110ca88:	d0a05117 	ldw	r2,-32444(gp)
8110ca8c:	e0fffe17 	ldw	r3,-8(fp)
8110ca90:	180b883a 	mov	r5,r3
8110ca94:	1009883a 	mov	r4,r2
8110ca98:	110cf640 	call	8110cf64 <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110ca9c:	0000d406 	br	8110cdf0 <vFeeTask+0x71c>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110caa0:	d0e05c17 	ldw	r3,-32400(gp)
8110caa4:	d0a05117 	ldw	r2,-32444(gp)
8110caa8:	10800003 	ldbu	r2,0(r2)
8110caac:	10803fcc 	andi	r2,r2,255
8110cab0:	100d883a 	mov	r6,r2
8110cab4:	01604534 	movhi	r5,33044
8110cab8:	295b7b04 	addi	r5,r5,28140
8110cabc:	1809883a 	mov	r4,r3
8110cac0:	111b3900 	call	8111b390 <fprintf>
					#endif
				}

				break;
8110cac4:	0000ca06 	br	8110cdf0 <vFeeTask+0x71c>
			case sSIMTestFullPattern:

				pxNFee->xControl.bUsingDMA = TRUE;
8110cac8:	d0a05117 	ldw	r2,-32444(gp)
8110cacc:	00c00044 	movi	r3,1
8110cad0:	10c02315 	stw	r3,140(r2)

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110cad4:	d0a05117 	ldw	r2,-32444(gp)
8110cad8:	10803b04 	addi	r2,r2,236
8110cadc:	1009883a 	mov	r4,r2
8110cae0:	110d3e80 	call	8110d3e8 <bEnableDbBuffer>

				tCodeNext = (bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire) + 1) % 4;
8110cae4:	d0a05117 	ldw	r2,-32444(gp)
8110cae8:	10808804 	addi	r2,r2,544
8110caec:	1009883a 	mov	r4,r2
8110caf0:	110917c0 	call	8110917c <bSpwcGetTimecode>
8110caf4:	10800044 	addi	r2,r2,1
8110caf8:	108000cc 	andi	r2,r2,3
8110cafc:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110cb00:	e0bffc17 	ldw	r2,-16(fp)
8110cb04:	10000f1e 	bne	r2,zero,8110cb44 <vFeeTask+0x470>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110cb08:	d0a05117 	ldw	r2,-32444(gp)
8110cb0c:	10802917 	ldw	r2,164(r2)
8110cb10:	10800003 	ldbu	r2,0(r2)
8110cb14:	10803fcc 	andi	r2,r2,255
8110cb18:	10c00044 	addi	r3,r2,1
8110cb1c:	00a00034 	movhi	r2,32768
8110cb20:	10800044 	addi	r2,r2,1
8110cb24:	1884703a 	and	r2,r3,r2
8110cb28:	1000040e 	bge	r2,zero,8110cb3c <vFeeTask+0x468>
8110cb2c:	10bfffc4 	addi	r2,r2,-1
8110cb30:	00ffff84 	movi	r3,-2
8110cb34:	10c4b03a 	or	r2,r2,r3
8110cb38:	10800044 	addi	r2,r2,1
8110cb3c:	e0bffd05 	stb	r2,-12(fp)
8110cb40:	00000406 	br	8110cb54 <vFeeTask+0x480>
				} else {
					ucMemUsing = (unsigned char) *pxNFee->xControl.pActualMem ; /* Select the of the data control (te future)*/
8110cb44:	d0a05117 	ldw	r2,-32444(gp)
8110cb48:	10802917 	ldw	r2,164(r2)
8110cb4c:	10800003 	ldbu	r2,0(r2)
8110cb50:	e0bffd05 	stb	r2,-12(fp)





				if (pxNFee->xControl.bWatingSync==TRUE) {
8110cb54:	d0a05117 	ldw	r2,-32444(gp)
8110cb58:	10802817 	ldw	r2,160(r2)
8110cb5c:	10800058 	cmpnei	r2,r2,1
8110cb60:	1000071e 	bne	r2,zero,8110cb80 <vFeeTask+0x4ac>
					pxNFee->xControl.eNextMode = sToTestFullPattern;
8110cb64:	d0a05117 	ldw	r2,-32444(gp)
8110cb68:	00c001c4 	movi	r3,7
8110cb6c:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eMode = sFeeWaitingSync;
8110cb70:	d0a05117 	ldw	r2,-32444(gp)
8110cb74:	00c002c4 	movi	r3,11
8110cb78:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode = sToTestFullPattern;
					pxNFee->xControl.eMode = sToTestFullPattern;
				}


				break;
8110cb7c:	00009c06 	br	8110cdf0 <vFeeTask+0x71c>

				if (pxNFee->xControl.bWatingSync==TRUE) {
					pxNFee->xControl.eNextMode = sToTestFullPattern;
					pxNFee->xControl.eMode = sFeeWaitingSync;
				} else {
					pxNFee->xControl.eNextMode = sToTestFullPattern;
8110cb80:	d0a05117 	ldw	r2,-32444(gp)
8110cb84:	00c001c4 	movi	r3,7
8110cb88:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eMode = sToTestFullPattern;
8110cb8c:	d0a05117 	ldw	r2,-32444(gp)
8110cb90:	00c001c4 	movi	r3,7
8110cb94:	10c02c15 	stw	r3,176(r2)
				}


				break;
8110cb98:	00009506 	br	8110cdf0 <vFeeTask+0x71c>
			case sToTestFullPattern: /* Transition */
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110cb9c:	d0e05c17 	ldw	r3,-32400(gp)
8110cba0:	d0a05117 	ldw	r2,-32444(gp)
8110cba4:	10800003 	ldbu	r2,0(r2)
8110cba8:	10803fcc 	andi	r2,r2,255
8110cbac:	100d883a 	mov	r6,r2
8110cbb0:	01604534 	movhi	r5,33044
8110cbb4:	295b8f04 	addi	r5,r5,28220
8110cbb8:	1809883a 	mov	r4,r3
8110cbbc:	111b3900 	call	8111b390 <fprintf>
				#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110cbc0:	d0a05117 	ldw	r2,-32444(gp)
8110cbc4:	00c00044 	movi	r3,1
8110cbc8:	10c02315 	stw	r3,140(r2)

				if (pxNFee->xControl.bWatingSync==TRUE)
8110cbcc:	d0a05117 	ldw	r2,-32444(gp)
8110cbd0:	10802817 	ldw	r2,160(r2)
8110cbd4:	10800058 	cmpnei	r2,r2,1
8110cbd8:	1000031e 	bne	r2,zero,8110cbe8 <vFeeTask+0x514>
					pxNFee->xControl.eMode = sFeeWaitingSync;
8110cbdc:	d0a05117 	ldw	r2,-32444(gp)
8110cbe0:	00c002c4 	movi	r3,11
8110cbe4:	10c02c15 	stw	r3,176(r2)

				/* Disable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110cbe8:	d0a05117 	ldw	r2,-32444(gp)
8110cbec:	10803b04 	addi	r2,r2,236
8110cbf0:	1009883a 	mov	r4,r2
8110cbf4:	110d3e80 	call	8110d3e8 <bEnableDbBuffer>
				/* Preciso enviar daqui o id para o schedule do FEE? Pois a interrupo do buffer comea desabilitada */
				/* Esperar QUEUE para DMA
				 * PEGAR MUTEX DMA */


				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110cbf8:	d0a05117 	ldw	r2,-32444(gp)
8110cbfc:	00c00104 	movi	r3,4
8110cc00:	10c02c15 	stw	r3,176(r2)
				break;
8110cc04:	00007a06 	br	8110cdf0 <vFeeTask+0x71c>
			case sFeeTestFullPattern: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110cc08:	d0a05117 	ldw	r2,-32444(gp)
8110cc0c:	10800003 	ldbu	r2,0(r2)
8110cc10:	10803fcc 	andi	r2,r2,255
8110cc14:	1085883a 	add	r2,r2,r2
8110cc18:	1087883a 	add	r3,r2,r2
8110cc1c:	d0a06404 	addi	r2,gp,-32368
8110cc20:	1885883a 	add	r2,r3,r2
8110cc24:	10800017 	ldw	r2,0(r2)
8110cc28:	e0fffd44 	addi	r3,fp,-11
8110cc2c:	180d883a 	mov	r6,r3
8110cc30:	000b883a 	mov	r5,zero
8110cc34:	1009883a 	mov	r4,r2
8110cc38:	11385740 	call	81138574 <OSQPend>
8110cc3c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110cc40:	e0bffd43 	ldbu	r2,-11(fp)
8110cc44:	10803fcc 	andi	r2,r2,255
8110cc48:	1000061e 	bne	r2,zero,8110cc64 <vFeeTask+0x590>

					vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110cc4c:	d0a05117 	ldw	r2,-32444(gp)
8110cc50:	e0fffe17 	ldw	r3,-8(fp)
8110cc54:	180b883a 	mov	r5,r3
8110cc58:	1009883a 	mov	r4,r2
8110cc5c:	110d0fc0 	call	8110d0fc <vQCmdFEEinFullPattern>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110cc60:	00006306 	br	8110cdf0 <vFeeTask+0x71c>

					vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110cc64:	d0e05c17 	ldw	r3,-32400(gp)
8110cc68:	d0a05117 	ldw	r2,-32444(gp)
8110cc6c:	10800003 	ldbu	r2,0(r2)
8110cc70:	10803fcc 	andi	r2,r2,255
8110cc74:	100d883a 	mov	r6,r2
8110cc78:	01604534 	movhi	r5,33044
8110cc7c:	295b7b04 	addi	r5,r5,28140
8110cc80:	1809883a 	mov	r4,r3
8110cc84:	111b3900 	call	8111b390 <fprintf>
					#endif
				}

				break;
8110cc88:	00005906 	br	8110cdf0 <vFeeTask+0x71c>

			case sFeeWaitingSync:

				pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110cc8c:	d0a05117 	ldw	r2,-32444(gp)
8110cc90:	d0e05117 	ldw	r3,-32444(gp)
8110cc94:	18c02d17 	ldw	r3,180(r3)
8110cc98:	10c02c15 	stw	r3,176(r2)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xWaitSyncQFee[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110cc9c:	d0a05117 	ldw	r2,-32444(gp)
8110cca0:	10800003 	ldbu	r2,0(r2)
8110cca4:	10803fcc 	andi	r2,r2,255
8110cca8:	1085883a 	add	r2,r2,r2
8110ccac:	1087883a 	add	r3,r2,r2
8110ccb0:	d0a05604 	addi	r2,gp,-32424
8110ccb4:	1885883a 	add	r2,r3,r2
8110ccb8:	10800017 	ldw	r2,0(r2)
8110ccbc:	e0fffd44 	addi	r3,fp,-11
8110ccc0:	180d883a 	mov	r6,r3
8110ccc4:	000b883a 	mov	r5,zero
8110ccc8:	1009883a 	mov	r4,r2
8110cccc:	11385740 	call	81138574 <OSQPend>
8110ccd0:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ccd4:	e0bffd43 	ldbu	r2,-11(fp)
8110ccd8:	10803fcc 	andi	r2,r2,255
8110ccdc:	10002a1e 	bne	r2,zero,8110cd88 <vFeeTask+0x6b4>

					/* todo: Write in the RMAP */


					bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110cce0:	d0a05117 	ldw	r2,-32444(gp)
8110cce4:	10804204 	addi	r2,r2,264
8110cce8:	1009883a 	mov	r4,r2
8110ccec:	11071700 	call	81107170 <bRmapGetMemConfigArea>

					/* UCL- NFEE ICD p. 49 */
					switch ( pxNFee->xControl.eNextMode ) {
8110ccf0:	d0a05117 	ldw	r2,-32444(gp)
8110ccf4:	10802d17 	ldw	r2,180(r2)
8110ccf8:	10c002e8 	cmpgeui	r3,r2,11
8110ccfc:	18001c1e 	bne	r3,zero,8110cd70 <vFeeTask+0x69c>
8110cd00:	100690ba 	slli	r3,r2,2
8110cd04:	00a04474 	movhi	r2,33041
8110cd08:	10b34604 	addi	r2,r2,-13032
8110cd0c:	1885883a 	add	r2,r3,r2
8110cd10:	10800017 	ldw	r2,0(r2)
8110cd14:	1000683a 	jmp	r2
8110cd18:	8110cd70 	cmpltui	r4,r16,17205
8110cd1c:	8110cd44 	addi	r4,r16,17205
8110cd20:	8110cd70 	cmpltui	r4,r16,17205
8110cd24:	8110cd54 	ori	r4,r16,17205
8110cd28:	8110cd60 	cmpeqi	r4,r16,17205
8110cd2c:	8110cd44 	addi	r4,r16,17205
8110cd30:	8110cd54 	ori	r4,r16,17205
8110cd34:	8110cd60 	cmpeqi	r4,r16,17205
8110cd38:	8110cd70 	cmpltui	r4,r16,17205
8110cd3c:	8110cd70 	cmpltui	r4,r16,17205
8110cd40:	8110cd60 	cmpeqi	r4,r16,17205
						case sToFeeConfig:
						case sFeeConfig:
							pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /* Off-Mode */
8110cd44:	d0a05117 	ldw	r2,-32444(gp)
8110cd48:	00c00184 	movi	r3,6
8110cd4c:	10c06515 	stw	r3,404(r2)
							break;
8110cd50:	00000806 	br	8110cd74 <vFeeTask+0x6a0>
						case sFeeStandBy:
						case sToFeeStandBy:
							pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00;
8110cd54:	d0a05117 	ldw	r2,-32444(gp)
8110cd58:	10006515 	stw	zero,404(r2)
							break;
8110cd5c:	00000506 	br	8110cd74 <vFeeTask+0x6a0>
						case sSIMTestFullPattern:
						case sToTestFullPattern:
						case sFeeTestFullPattern:
							pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02;
8110cd60:	d0a05117 	ldw	r2,-32444(gp)
8110cd64:	00c00084 	movi	r3,2
8110cd68:	10c06515 	stw	r3,404(r2)
							break;
8110cd6c:	00000106 	br	8110cd74 <vFeeTask+0x6a0>
						default:
							break;
8110cd70:	0001883a 	nop
					}

					bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110cd74:	d0a05117 	ldw	r2,-32444(gp)
8110cd78:	10804204 	addi	r2,r2,264
8110cd7c:	1009883a 	mov	r4,r2
8110cd80:	1106e840 	call	81106e84 <bRmapSetMemConfigArea>
8110cd84:	00000906 	br	8110cdac <vFeeTask+0x6d8>

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xWaitSyncQFee\n", pxNFee->ucId);
8110cd88:	d0e05c17 	ldw	r3,-32400(gp)
8110cd8c:	d0a05117 	ldw	r2,-32444(gp)
8110cd90:	10800003 	ldbu	r2,0(r2)
8110cd94:	10803fcc 	andi	r2,r2,255
8110cd98:	100d883a 	mov	r6,r2
8110cd9c:	01604534 	movhi	r5,33044
8110cda0:	295b9904 	addi	r5,r5,28260
8110cda4:	1809883a 	mov	r4,r3
8110cda8:	111b3900 	call	8111b390 <fprintf>
					#endif
				}

				pxNFee->xControl.bWatingSync = FALSE;
8110cdac:	d0a05117 	ldw	r2,-32444(gp)
8110cdb0:	10002815 	stw	zero,160(r2)
				break;
8110cdb4:	00000e06 	br	8110cdf0 <vFeeTask+0x71c>
			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110cdb8:	d0a05117 	ldw	r2,-32444(gp)
8110cdbc:	00c00144 	movi	r3,5
8110cdc0:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110cdc4:	d0e05c17 	ldw	r3,-32400(gp)
8110cdc8:	d0a05117 	ldw	r2,-32444(gp)
8110cdcc:	10800003 	ldbu	r2,0(r2)
8110cdd0:	10803fcc 	andi	r2,r2,255
8110cdd4:	100d883a 	mov	r6,r2
8110cdd8:	01604534 	movhi	r5,33044
8110cddc:	295ba704 	addi	r5,r5,28316
8110cde0:	1809883a 	mov	r4,r3
8110cde4:	111b3900 	call	8111b390 <fprintf>
				#endif
				break;
8110cde8:	00000106 	br	8110cdf0 <vFeeTask+0x71c>
				break;
			case sSIMFeeStandBy:

				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
8110cdec:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110cdf0:	003e4e06 	br	8110c72c <__reset+0xfb0ec72c>

8110cdf4 <vQCmdFEEinConfig>:


}


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110cdf4:	defffb04 	addi	sp,sp,-20
8110cdf8:	de00012e 	bgeu	sp,et,8110ce00 <vQCmdFEEinConfig+0xc>
8110cdfc:	003b68fa 	trap	3
8110ce00:	dfc00415 	stw	ra,16(sp)
8110ce04:	df000315 	stw	fp,12(sp)
8110ce08:	df000304 	addi	fp,sp,12
8110ce0c:	e13ffe15 	stw	r4,-8(fp)
8110ce10:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110ce14:	e0bfff17 	ldw	r2,-4(fp)
8110ce18:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110ce1c:	e0bffdc3 	ldbu	r2,-9(fp)
8110ce20:	10c03fcc 	andi	r3,r2,255
8110ce24:	e0bffe17 	ldw	r2,-8(fp)
8110ce28:	10800003 	ldbu	r2,0(r2)
8110ce2c:	10803fcc 	andi	r2,r2,255
8110ce30:	10800444 	addi	r2,r2,17
8110ce34:	1880451e 	bne	r3,r2,8110cf4c <vQCmdFEEinConfig+0x158>

		switch (uiCmdFEEL.ucByte[2]) {
8110ce38:	e0bffd83 	ldbu	r2,-10(fp)
8110ce3c:	10803fcc 	andi	r2,r2,255
8110ce40:	10c00220 	cmpeqi	r3,r2,8
8110ce44:	18002c1e 	bne	r3,zero,8110cef8 <vQCmdFEEinConfig+0x104>
8110ce48:	10c00248 	cmpgei	r3,r2,9
8110ce4c:	1800071e 	bne	r3,zero,8110ce6c <vQCmdFEEinConfig+0x78>
8110ce50:	10c000a0 	cmpeqi	r3,r2,2
8110ce54:	18003c1e 	bne	r3,zero,8110cf48 <vQCmdFEEinConfig+0x154>
8110ce58:	10c00120 	cmpeqi	r3,r2,4
8110ce5c:	1800131e 	bne	r3,zero,8110ceac <vQCmdFEEinConfig+0xb8>
8110ce60:	10800060 	cmpeqi	r2,r2,1
8110ce64:	1000071e 	bne	r2,zero,8110ce84 <vQCmdFEEinConfig+0x90>
8110ce68:	00002d06 	br	8110cf20 <vQCmdFEEinConfig+0x12c>
8110ce6c:	10c02920 	cmpeqi	r3,r2,164
8110ce70:	1800181e 	bne	r3,zero,8110ced4 <vQCmdFEEinConfig+0xe0>
8110ce74:	10c02a20 	cmpeqi	r3,r2,168
8110ce78:	18001f1e 	bne	r3,zero,8110cef8 <vQCmdFEEinConfig+0x104>
8110ce7c:	10802860 	cmpeqi	r2,r2,161
8110ce80:	10002726 	beq	r2,zero,8110cf20 <vQCmdFEEinConfig+0x12c>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110ce84:	d0e05c17 	ldw	r3,-32400(gp)
8110ce88:	e0bffe17 	ldw	r2,-8(fp)
8110ce8c:	10800003 	ldbu	r2,0(r2)
8110ce90:	10803fcc 	andi	r2,r2,255
8110ce94:	100d883a 	mov	r6,r2
8110ce98:	01604534 	movhi	r5,33044
8110ce9c:	295bb204 	addi	r5,r5,28360
8110cea0:	1809883a 	mov	r4,r3
8110cea4:	111b3900 	call	8111b390 <fprintf>
				#endif
				break;
8110cea8:	00002806 	br	8110cf4c <vQCmdFEEinConfig+0x158>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110ceac:	e0bffe17 	ldw	r2,-8(fp)
8110ceb0:	00c00044 	movi	r3,1
8110ceb4:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110ceb8:	e0bffe17 	ldw	r2,-8(fp)
8110cebc:	00c002c4 	movi	r3,11
8110cec0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110cec4:	e0bffe17 	ldw	r2,-8(fp)
8110cec8:	00c00184 	movi	r3,6
8110cecc:	10c02d15 	stw	r3,180(r2)
				break;
8110ced0:	00001e06 	br	8110cf4c <vQCmdFEEinConfig+0x158>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110ced4:	e0bffe17 	ldw	r2,-8(fp)
8110ced8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110cedc:	e0bffe17 	ldw	r2,-8(fp)
8110cee0:	00c00184 	movi	r3,6
8110cee4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110cee8:	e0bffe17 	ldw	r2,-8(fp)
8110ceec:	00c00184 	movi	r3,6
8110cef0:	10c02d15 	stw	r3,180(r2)
				break;				
8110cef4:	00001506 	br	8110cf4c <vQCmdFEEinConfig+0x158>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110cef8:	d0e05c17 	ldw	r3,-32400(gp)
8110cefc:	e0bffe17 	ldw	r2,-8(fp)
8110cf00:	10800003 	ldbu	r2,0(r2)
8110cf04:	10803fcc 	andi	r2,r2,255
8110cf08:	100d883a 	mov	r6,r2
8110cf0c:	01604534 	movhi	r5,33044
8110cf10:	295bbd04 	addi	r5,r5,28404
8110cf14:	1809883a 	mov	r4,r3
8110cf18:	111b3900 	call	8111b390 <fprintf>
				#endif
				break;											
8110cf1c:	00000b06 	br	8110cf4c <vQCmdFEEinConfig+0x158>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110cf20:	d0e05c17 	ldw	r3,-32400(gp)
8110cf24:	e0bffe17 	ldw	r2,-8(fp)
8110cf28:	10800003 	ldbu	r2,0(r2)
8110cf2c:	10803fcc 	andi	r2,r2,255
8110cf30:	100d883a 	mov	r6,r2
8110cf34:	01604534 	movhi	r5,33044
8110cf38:	295bce04 	addi	r5,r5,28472
8110cf3c:	1809883a 	mov	r4,r3
8110cf40:	111b3900 	call	8111b390 <fprintf>
				#endif
				break;
8110cf44:	00000106 	br	8110cf4c <vQCmdFEEinConfig+0x158>
				break;
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110cf48:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110cf4c:	0001883a 	nop
8110cf50:	e037883a 	mov	sp,fp
8110cf54:	dfc00117 	ldw	ra,4(sp)
8110cf58:	df000017 	ldw	fp,0(sp)
8110cf5c:	dec00204 	addi	sp,sp,8
8110cf60:	f800283a 	ret

8110cf64 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110cf64:	defffb04 	addi	sp,sp,-20
8110cf68:	de00012e 	bgeu	sp,et,8110cf70 <vQCmdFEEinStandBy+0xc>
8110cf6c:	003b68fa 	trap	3
8110cf70:	dfc00415 	stw	ra,16(sp)
8110cf74:	df000315 	stw	fp,12(sp)
8110cf78:	df000304 	addi	fp,sp,12
8110cf7c:	e13ffe15 	stw	r4,-8(fp)
8110cf80:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110cf84:	e0bfff17 	ldw	r2,-4(fp)
8110cf88:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110cf8c:	e0bffdc3 	ldbu	r2,-9(fp)
8110cf90:	10c03fcc 	andi	r3,r2,255
8110cf94:	e0bffe17 	ldw	r2,-8(fp)
8110cf98:	10800003 	ldbu	r2,0(r2)
8110cf9c:	10803fcc 	andi	r2,r2,255
8110cfa0:	10800444 	addi	r2,r2,17
8110cfa4:	18804f1e 	bne	r3,r2,8110d0e4 <vQCmdFEEinStandBy+0x180>

		switch (uiCmdFEEL.ucByte[2]) {
8110cfa8:	e0bffd83 	ldbu	r2,-10(fp)
8110cfac:	10803fcc 	andi	r2,r2,255
8110cfb0:	10c00220 	cmpeqi	r3,r2,8
8110cfb4:	18002d1e 	bne	r3,zero,8110d06c <vQCmdFEEinStandBy+0x108>
8110cfb8:	10c00248 	cmpgei	r3,r2,9
8110cfbc:	1800071e 	bne	r3,zero,8110cfdc <vQCmdFEEinStandBy+0x78>
8110cfc0:	10c000a0 	cmpeqi	r3,r2,2
8110cfc4:	1800461e 	bne	r3,zero,8110d0e0 <vQCmdFEEinStandBy+0x17c>
8110cfc8:	10c00120 	cmpeqi	r3,r2,4
8110cfcc:	18001d1e 	bne	r3,zero,8110d044 <vQCmdFEEinStandBy+0xe0>
8110cfd0:	10800060 	cmpeqi	r2,r2,1
8110cfd4:	1000081e 	bne	r2,zero,8110cff8 <vQCmdFEEinStandBy+0x94>
8110cfd8:	00003706 	br	8110d0b8 <vQCmdFEEinStandBy+0x154>
8110cfdc:	10c02920 	cmpeqi	r3,r2,164
8110cfe0:	1800181e 	bne	r3,zero,8110d044 <vQCmdFEEinStandBy+0xe0>
8110cfe4:	10c02a20 	cmpeqi	r3,r2,168
8110cfe8:	18002a1e 	bne	r3,zero,8110d094 <vQCmdFEEinStandBy+0x130>
8110cfec:	10802860 	cmpeqi	r2,r2,161
8110cff0:	10000b1e 	bne	r2,zero,8110d020 <vQCmdFEEinStandBy+0xbc>
8110cff4:	00003006 	br	8110d0b8 <vQCmdFEEinStandBy+0x154>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110cff8:	e0bffe17 	ldw	r2,-8(fp)
8110cffc:	00c00044 	movi	r3,1
8110d000:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d004:	e0bffe17 	ldw	r2,-8(fp)
8110d008:	00c002c4 	movi	r3,11
8110d00c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110d010:	e0bffe17 	ldw	r2,-8(fp)
8110d014:	00c00144 	movi	r3,5
8110d018:	10c02d15 	stw	r3,180(r2)
				break;
8110d01c:	00003106 	br	8110d0e4 <vQCmdFEEinStandBy+0x180>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d020:	e0bffe17 	ldw	r2,-8(fp)
8110d024:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110d028:	e0bffe17 	ldw	r2,-8(fp)
8110d02c:	00c00144 	movi	r3,5
8110d030:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110d034:	e0bffe17 	ldw	r2,-8(fp)
8110d038:	00c00144 	movi	r3,5
8110d03c:	10c02d15 	stw	r3,180(r2)
				break;				
8110d040:	00002806 	br	8110d0e4 <vQCmdFEEinStandBy+0x180>
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110d044:	d0e05c17 	ldw	r3,-32400(gp)
8110d048:	e0bffe17 	ldw	r2,-8(fp)
8110d04c:	10800003 	ldbu	r2,0(r2)
8110d050:	10803fcc 	andi	r2,r2,255
8110d054:	100d883a 	mov	r6,r2
8110d058:	01604534 	movhi	r5,33044
8110d05c:	295bdf04 	addi	r5,r5,28540
8110d060:	1809883a 	mov	r4,r3
8110d064:	111b3900 	call	8111b390 <fprintf>
				#endif
				break;
8110d068:	00001e06 	br	8110d0e4 <vQCmdFEEinStandBy+0x180>
			case M_FEE_FULL_PATTERN:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d06c:	e0bffe17 	ldw	r2,-8(fp)
8110d070:	00c00044 	movi	r3,1
8110d074:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sSIMTestFullPattern; /*sSIMTestFullPattern*/
8110d078:	e0bffe17 	ldw	r2,-8(fp)
8110d07c:	00c00284 	movi	r3,10
8110d080:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sSIMTestFullPattern;
8110d084:	e0bffe17 	ldw	r2,-8(fp)
8110d088:	00c00284 	movi	r3,10
8110d08c:	10c02d15 	stw	r3,180(r2)
				break;
8110d090:	00001406 	br	8110d0e4 <vQCmdFEEinStandBy+0x180>
			case M_FEE_FULL_PATTERN_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d094:	e0bffe17 	ldw	r2,-8(fp)
8110d098:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sSIMTestFullPattern;
8110d09c:	e0bffe17 	ldw	r2,-8(fp)
8110d0a0:	00c00284 	movi	r3,10
8110d0a4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sSIMTestFullPattern;
8110d0a8:	e0bffe17 	ldw	r2,-8(fp)
8110d0ac:	00c00284 	movi	r3,10
8110d0b0:	10c02d15 	stw	r3,180(r2)
				break;				
8110d0b4:	00000b06 	br	8110d0e4 <vQCmdFEEinStandBy+0x180>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110d0b8:	d0e05c17 	ldw	r3,-32400(gp)
8110d0bc:	e0bffe17 	ldw	r2,-8(fp)
8110d0c0:	10800003 	ldbu	r2,0(r2)
8110d0c4:	10803fcc 	andi	r2,r2,255
8110d0c8:	100d883a 	mov	r6,r2
8110d0cc:	01604534 	movhi	r5,33044
8110d0d0:	295bce04 	addi	r5,r5,28472
8110d0d4:	1809883a 	mov	r4,r3
8110d0d8:	111b3900 	call	8111b390 <fprintf>
				#endif
				break;
8110d0dc:	00000106 	br	8110d0e4 <vQCmdFEEinStandBy+0x180>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110d0e0:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110d0e4:	0001883a 	nop
8110d0e8:	e037883a 	mov	sp,fp
8110d0ec:	dfc00117 	ldw	ra,4(sp)
8110d0f0:	df000017 	ldw	fp,0(sp)
8110d0f4:	dec00204 	addi	sp,sp,8
8110d0f8:	f800283a 	ret

8110d0fc <vQCmdFEEinFullPattern>:

void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110d0fc:	defffb04 	addi	sp,sp,-20
8110d100:	de00012e 	bgeu	sp,et,8110d108 <vQCmdFEEinFullPattern+0xc>
8110d104:	003b68fa 	trap	3
8110d108:	dfc00415 	stw	ra,16(sp)
8110d10c:	df000315 	stw	fp,12(sp)
8110d110:	df000304 	addi	fp,sp,12
8110d114:	e13ffe15 	stw	r4,-8(fp)
8110d118:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110d11c:	e0bfff17 	ldw	r2,-4(fp)
8110d120:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110d124:	e0bffdc3 	ldbu	r2,-9(fp)
8110d128:	10c03fcc 	andi	r3,r2,255
8110d12c:	e0bffe17 	ldw	r2,-8(fp)
8110d130:	10800003 	ldbu	r2,0(r2)
8110d134:	10803fcc 	andi	r2,r2,255
8110d138:	10800444 	addi	r2,r2,17
8110d13c:	18804d1e 	bne	r3,r2,8110d274 <vQCmdFEEinFullPattern+0x178>

		switch (uiCmdFEEL.ucByte[2]) {
8110d140:	e0bffd83 	ldbu	r2,-10(fp)
8110d144:	10803fcc 	andi	r2,r2,255
8110d148:	10c00120 	cmpeqi	r3,r2,4
8110d14c:	1800211e 	bne	r3,zero,8110d1d4 <vQCmdFEEinFullPattern+0xd8>
8110d150:	10c00148 	cmpgei	r3,r2,5
8110d154:	1800051e 	bne	r3,zero,8110d16c <vQCmdFEEinFullPattern+0x70>
8110d158:	10c00060 	cmpeqi	r3,r2,1
8110d15c:	18000a1e 	bne	r3,zero,8110d188 <vQCmdFEEinFullPattern+0x8c>
8110d160:	108000a0 	cmpeqi	r2,r2,2
8110d164:	1000421e 	bne	r2,zero,8110d270 <vQCmdFEEinFullPattern+0x174>
8110d168:	00003706 	br	8110d248 <vQCmdFEEinFullPattern+0x14c>
8110d16c:	10c02860 	cmpeqi	r3,r2,161
8110d170:	18000f1e 	bne	r3,zero,8110d1b0 <vQCmdFEEinFullPattern+0xb4>
8110d174:	10c02920 	cmpeqi	r3,r2,164
8110d178:	1800201e 	bne	r3,zero,8110d1fc <vQCmdFEEinFullPattern+0x100>
8110d17c:	10800220 	cmpeqi	r2,r2,8
8110d180:	1000271e 	bne	r2,zero,8110d220 <vQCmdFEEinFullPattern+0x124>
8110d184:	00003006 	br	8110d248 <vQCmdFEEinFullPattern+0x14c>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d188:	e0bffe17 	ldw	r2,-8(fp)
8110d18c:	00c00044 	movi	r3,1
8110d190:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d194:	e0bffe17 	ldw	r2,-8(fp)
8110d198:	00c002c4 	movi	r3,11
8110d19c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110d1a0:	e0bffe17 	ldw	r2,-8(fp)
8110d1a4:	00c00144 	movi	r3,5
8110d1a8:	10c02d15 	stw	r3,180(r2)
				break;
8110d1ac:	00003106 	br	8110d274 <vQCmdFEEinFullPattern+0x178>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d1b0:	e0bffe17 	ldw	r2,-8(fp)
8110d1b4:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110d1b8:	e0bffe17 	ldw	r2,-8(fp)
8110d1bc:	00c00144 	movi	r3,5
8110d1c0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110d1c4:	e0bffe17 	ldw	r2,-8(fp)
8110d1c8:	00c00144 	movi	r3,5
8110d1cc:	10c02d15 	stw	r3,180(r2)
				break;				
8110d1d0:	00002806 	br	8110d274 <vQCmdFEEinFullPattern+0x178>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d1d4:	e0bffe17 	ldw	r2,-8(fp)
8110d1d8:	00c00044 	movi	r3,1
8110d1dc:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d1e0:	e0bffe17 	ldw	r2,-8(fp)
8110d1e4:	00c002c4 	movi	r3,11
8110d1e8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110d1ec:	e0bffe17 	ldw	r2,-8(fp)
8110d1f0:	00c00184 	movi	r3,6
8110d1f4:	10c02d15 	stw	r3,180(r2)
				break;
8110d1f8:	00001e06 	br	8110d274 <vQCmdFEEinFullPattern+0x178>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d1fc:	e0bffe17 	ldw	r2,-8(fp)
8110d200:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110d204:	e0bffe17 	ldw	r2,-8(fp)
8110d208:	00c00184 	movi	r3,6
8110d20c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110d210:	e0bffe17 	ldw	r2,-8(fp)
8110d214:	00c00184 	movi	r3,6
8110d218:	10c02d15 	stw	r3,180(r2)
				break;				
8110d21c:	00001506 	br	8110d274 <vQCmdFEEinFullPattern+0x178>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110d220:	d0e05c17 	ldw	r3,-32400(gp)
8110d224:	e0bffe17 	ldw	r2,-8(fp)
8110d228:	10800003 	ldbu	r2,0(r2)
8110d22c:	10803fcc 	andi	r2,r2,255
8110d230:	100d883a 	mov	r6,r2
8110d234:	01604534 	movhi	r5,33044
8110d238:	295bea04 	addi	r5,r5,28584
8110d23c:	1809883a 	mov	r4,r3
8110d240:	111b3900 	call	8111b390 <fprintf>
				#endif
				break;
8110d244:	00000b06 	br	8110d274 <vQCmdFEEinFullPattern+0x178>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110d248:	d0e05c17 	ldw	r3,-32400(gp)
8110d24c:	e0bffe17 	ldw	r2,-8(fp)
8110d250:	10800003 	ldbu	r2,0(r2)
8110d254:	10803fcc 	andi	r2,r2,255
8110d258:	100d883a 	mov	r6,r2
8110d25c:	01604534 	movhi	r5,33044
8110d260:	295bce04 	addi	r5,r5,28472
8110d264:	1809883a 	mov	r4,r3
8110d268:	111b3900 	call	8111b390 <fprintf>
				#endif
				break;
8110d26c:	00000106 	br	8110d274 <vQCmdFEEinFullPattern+0x178>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110d270:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110d274:	0001883a 	nop
8110d278:	e037883a 	mov	sp,fp
8110d27c:	dfc00117 	ldw	ra,4(sp)
8110d280:	df000017 	ldw	fp,0(sp)
8110d284:	dec00204 	addi	sp,sp,8
8110d288:	f800283a 	ret

8110d28c <bDisableRmapIRQ>:

bool bDisableRmapIRQ( TRmapChannel *pxRmapCh ) {
8110d28c:	defffd04 	addi	sp,sp,-12
8110d290:	de00012e 	bgeu	sp,et,8110d298 <bDisableRmapIRQ+0xc>
8110d294:	003b68fa 	trap	3
8110d298:	dfc00215 	stw	ra,8(sp)
8110d29c:	df000115 	stw	fp,4(sp)
8110d2a0:	df000104 	addi	fp,sp,4
8110d2a4:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bRmapGetIrqControl(pxRmapCh);
8110d2a8:	e13fff17 	ldw	r4,-4(fp)
8110d2ac:	11069500 	call	81106950 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
8110d2b0:	e0bfff17 	ldw	r2,-4(fp)
8110d2b4:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110d2b8:	e13fff17 	ldw	r4,-4(fp)
8110d2bc:	11068a80 	call	811068a8 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110d2c0:	00800044 	movi	r2,1
}
8110d2c4:	e037883a 	mov	sp,fp
8110d2c8:	dfc00117 	ldw	ra,4(sp)
8110d2cc:	df000017 	ldw	fp,0(sp)
8110d2d0:	dec00204 	addi	sp,sp,8
8110d2d4:	f800283a 	ret

8110d2d8 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh ) {
8110d2d8:	defffd04 	addi	sp,sp,-12
8110d2dc:	de00012e 	bgeu	sp,et,8110d2e4 <bEnableRmapIRQ+0xc>
8110d2e0:	003b68fa 	trap	3
8110d2e4:	dfc00215 	stw	ra,8(sp)
8110d2e8:	df000115 	stw	fp,4(sp)
8110d2ec:	df000104 	addi	fp,sp,4
8110d2f0:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bRmapGetIrqControl(pxRmapCh);
8110d2f4:	e13fff17 	ldw	r4,-4(fp)
8110d2f8:	11069500 	call	81106950 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8110d2fc:	e0bfff17 	ldw	r2,-4(fp)
8110d300:	00c00044 	movi	r3,1
8110d304:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110d308:	e13fff17 	ldw	r4,-4(fp)
8110d30c:	11068a80 	call	811068a8 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110d310:	00800044 	movi	r2,1
}
8110d314:	e037883a 	mov	sp,fp
8110d318:	dfc00117 	ldw	ra,4(sp)
8110d31c:	df000017 	ldw	fp,0(sp)
8110d320:	dec00204 	addi	sp,sp,8
8110d324:	f800283a 	ret

8110d328 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
8110d328:	defffd04 	addi	sp,sp,-12
8110d32c:	de00012e 	bgeu	sp,et,8110d334 <bDisableSPWChannel+0xc>
8110d330:	003b68fa 	trap	3
8110d334:	dfc00215 	stw	ra,8(sp)
8110d338:	df000115 	stw	fp,4(sp)
8110d33c:	df000104 	addi	fp,sp,4
8110d340:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
8110d344:	e13fff17 	ldw	r4,-4(fp)
8110d348:	1108ed40 	call	81108ed4 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110d34c:	e0bfff17 	ldw	r2,-4(fp)
8110d350:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
8110d354:	e0bfff17 	ldw	r2,-4(fp)
8110d358:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
8110d35c:	e0bfff17 	ldw	r2,-4(fp)
8110d360:	00c00044 	movi	r3,1
8110d364:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
8110d368:	e13fff17 	ldw	r4,-4(fp)
8110d36c:	1108da00 	call	81108da0 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110d370:	00800044 	movi	r2,1
}
8110d374:	e037883a 	mov	sp,fp
8110d378:	dfc00117 	ldw	ra,4(sp)
8110d37c:	df000017 	ldw	fp,0(sp)
8110d380:	dec00204 	addi	sp,sp,8
8110d384:	f800283a 	ret

8110d388 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
8110d388:	defffd04 	addi	sp,sp,-12
8110d38c:	de00012e 	bgeu	sp,et,8110d394 <bEnableSPWChannel+0xc>
8110d390:	003b68fa 	trap	3
8110d394:	dfc00215 	stw	ra,8(sp)
8110d398:	df000115 	stw	fp,4(sp)
8110d39c:	df000104 	addi	fp,sp,4
8110d3a0:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
8110d3a4:	e13fff17 	ldw	r4,-4(fp)
8110d3a8:	1108ed40 	call	81108ed4 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110d3ac:	e0bfff17 	ldw	r2,-4(fp)
8110d3b0:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
8110d3b4:	e0bfff17 	ldw	r2,-4(fp)
8110d3b8:	00c00044 	movi	r3,1
8110d3bc:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
8110d3c0:	e0bfff17 	ldw	r2,-4(fp)
8110d3c4:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
8110d3c8:	e13fff17 	ldw	r4,-4(fp)
8110d3cc:	1108da00 	call	81108da0 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110d3d0:	00800044 	movi	r2,1
}
8110d3d4:	e037883a 	mov	sp,fp
8110d3d8:	dfc00117 	ldw	ra,4(sp)
8110d3dc:	df000017 	ldw	fp,0(sp)
8110d3e0:	dec00204 	addi	sp,sp,8
8110d3e4:	f800283a 	ret

8110d3e8 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
8110d3e8:	defffd04 	addi	sp,sp,-12
8110d3ec:	de00012e 	bgeu	sp,et,8110d3f4 <bEnableDbBuffer+0xc>
8110d3f0:	003b68fa 	trap	3
8110d3f4:	dfc00215 	stw	ra,8(sp)
8110d3f8:	df000115 	stw	fp,4(sp)
8110d3fc:	df000104 	addi	fp,sp,4
8110d400:	e13fff15 	stw	r4,-4(fp)

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110d404:	e13fff17 	ldw	r4,-4(fp)
8110d408:	1105b1c0 	call	81105b1c <bFeebClrCh>

	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
8110d40c:	e13fff17 	ldw	r4,-4(fp)
8110d410:	1105a0c0 	call	81105a0c <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110d414:	e13fff17 	ldw	r4,-4(fp)
8110d418:	11056fc0 	call	811056fc <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
8110d41c:	e0bfff17 	ldw	r2,-4(fp)
8110d420:	00c00044 	movi	r3,1
8110d424:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110d428:	e0bfff17 	ldw	r2,-4(fp)
8110d42c:	00c00044 	movi	r3,1
8110d430:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110d434:	e13fff17 	ldw	r4,-4(fp)
8110d438:	11056280 	call	81105628 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110d43c:	00800044 	movi	r2,1
}
8110d440:	e037883a 	mov	sp,fp
8110d444:	dfc00117 	ldw	ra,4(sp)
8110d448:	df000017 	ldw	fp,0(sp)
8110d44c:	dec00204 	addi	sp,sp,8
8110d450:	f800283a 	ret

8110d454 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
8110d454:	defffd04 	addi	sp,sp,-12
8110d458:	de00012e 	bgeu	sp,et,8110d460 <bDisAndClrDbBuffer+0xc>
8110d45c:	003b68fa 	trap	3
8110d460:	dfc00215 	stw	ra,8(sp)
8110d464:	df000115 	stw	fp,4(sp)
8110d468:	df000104 	addi	fp,sp,4
8110d46c:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110d470:	e13fff17 	ldw	r4,-4(fp)
8110d474:	11056fc0 	call	811056fc <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
8110d478:	e0bfff17 	ldw	r2,-4(fp)
8110d47c:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8110d480:	e0bfff17 	ldw	r2,-4(fp)
8110d484:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110d488:	e13fff17 	ldw	r4,-4(fp)
8110d48c:	11056280 	call	81105628 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8110d490:	e13fff17 	ldw	r4,-4(fp)
8110d494:	1105a940 	call	81105a94 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110d498:	e13fff17 	ldw	r4,-4(fp)
8110d49c:	1105b1c0 	call	81105b1c <bFeebClrCh>

	/*todo: No treatment for now  */
	return TRUE;
8110d4a0:	00800044 	movi	r2,1
}
8110d4a4:	e037883a 	mov	sp,fp
8110d4a8:	dfc00117 	ldw	ra,4(sp)
8110d4ac:	df000017 	ldw	fp,0(sp)
8110d4b0:	dec00204 	addi	sp,sp,8
8110d4b4:	f800283a 	ret

8110d4b8 <vPrintConsoleNFee>:



#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
8110d4b8:	defffa04 	addi	sp,sp,-24
8110d4bc:	de00012e 	bgeu	sp,et,8110d4c4 <vPrintConsoleNFee+0xc>
8110d4c0:	003b68fa 	trap	3
8110d4c4:	dfc00515 	stw	ra,20(sp)
8110d4c8:	df000415 	stw	fp,16(sp)
8110d4cc:	df000404 	addi	fp,sp,16
8110d4d0:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
8110d4d4:	e0bfff17 	ldw	r2,-4(fp)
8110d4d8:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
8110d4dc:	d0e05c17 	ldw	r3,-32400(gp)
8110d4e0:	e0bffe17 	ldw	r2,-8(fp)
8110d4e4:	10800003 	ldbu	r2,0(r2)
8110d4e8:	10803fcc 	andi	r2,r2,255
8110d4ec:	100d883a 	mov	r6,r2
8110d4f0:	01604534 	movhi	r5,33044
8110d4f4:	295bf804 	addi	r5,r5,28640
8110d4f8:	1809883a 	mov	r4,r3
8110d4fc:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"\n");
8110d500:	d0a05c17 	ldw	r2,-32400(gp)
8110d504:	100b883a 	mov	r5,r2
8110d508:	01000284 	movi	r4,10
8110d50c:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
8110d510:	d0e05c17 	ldw	r3,-32400(gp)
8110d514:	e0bffe17 	ldw	r2,-8(fp)
8110d518:	10800003 	ldbu	r2,0(r2)
8110d51c:	10803fcc 	andi	r2,r2,255
8110d520:	100d883a 	mov	r6,r2
8110d524:	01604534 	movhi	r5,33044
8110d528:	295c0d04 	addi	r5,r5,28724
8110d52c:	1809883a 	mov	r4,r3
8110d530:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
8110d534:	d0e05c17 	ldw	r3,-32400(gp)
8110d538:	e0bffe17 	ldw	r2,-8(fp)
8110d53c:	10802f0b 	ldhu	r2,188(r2)
8110d540:	10bfffcc 	andi	r2,r2,65535
8110d544:	100d883a 	mov	r6,r2
8110d548:	01604534 	movhi	r5,33044
8110d54c:	295c1304 	addi	r5,r5,28748
8110d550:	1809883a 	mov	r4,r3
8110d554:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
8110d558:	d0e05c17 	ldw	r3,-32400(gp)
8110d55c:	e0bffe17 	ldw	r2,-8(fp)
8110d560:	10802f8b 	ldhu	r2,190(r2)
8110d564:	10bfffcc 	andi	r2,r2,65535
8110d568:	100d883a 	mov	r6,r2
8110d56c:	01604534 	movhi	r5,33044
8110d570:	295c1804 	addi	r5,r5,28768
8110d574:	1809883a 	mov	r4,r3
8110d578:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
8110d57c:	d0e05c17 	ldw	r3,-32400(gp)
8110d580:	e0bffe17 	ldw	r2,-8(fp)
8110d584:	1080300b 	ldhu	r2,192(r2)
8110d588:	10bfffcc 	andi	r2,r2,65535
8110d58c:	100d883a 	mov	r6,r2
8110d590:	01604534 	movhi	r5,33044
8110d594:	295c1e04 	addi	r5,r5,28792
8110d598:	1809883a 	mov	r4,r3
8110d59c:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
8110d5a0:	d0e05c17 	ldw	r3,-32400(gp)
8110d5a4:	e0bffe17 	ldw	r2,-8(fp)
8110d5a8:	1080308b 	ldhu	r2,194(r2)
8110d5ac:	10bfffcc 	andi	r2,r2,65535
8110d5b0:	100d883a 	mov	r6,r2
8110d5b4:	01604534 	movhi	r5,33044
8110d5b8:	295c2204 	addi	r5,r5,28808
8110d5bc:	1809883a 	mov	r4,r3
8110d5c0:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
8110d5c4:	d0e05c17 	ldw	r3,-32400(gp)
8110d5c8:	e0bffe17 	ldw	r2,-8(fp)
8110d5cc:	1080310b 	ldhu	r2,196(r2)
8110d5d0:	10bfffcc 	andi	r2,r2,65535
8110d5d4:	100d883a 	mov	r6,r2
8110d5d8:	01604534 	movhi	r5,33044
8110d5dc:	295c2804 	addi	r5,r5,28832
8110d5e0:	1809883a 	mov	r4,r3
8110d5e4:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"\n");
8110d5e8:	d0a05c17 	ldw	r2,-32400(gp)
8110d5ec:	100b883a 	mov	r5,r2
8110d5f0:	01000284 	movi	r4,10
8110d5f4:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
8110d5f8:	d0e05c17 	ldw	r3,-32400(gp)
8110d5fc:	e0bffe17 	ldw	r2,-8(fp)
8110d600:	10800003 	ldbu	r2,0(r2)
8110d604:	10803fcc 	andi	r2,r2,255
8110d608:	100d883a 	mov	r6,r2
8110d60c:	01604534 	movhi	r5,33044
8110d610:	295c2d04 	addi	r5,r5,28852
8110d614:	1809883a 	mov	r4,r3
8110d618:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
8110d61c:	d0e05c17 	ldw	r3,-32400(gp)
8110d620:	e0bffe17 	ldw	r2,-8(fp)
8110d624:	10802c17 	ldw	r2,176(r2)
8110d628:	100d883a 	mov	r6,r2
8110d62c:	01604534 	movhi	r5,33044
8110d630:	295c3304 	addi	r5,r5,28876
8110d634:	1809883a 	mov	r4,r3
8110d638:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
8110d63c:	d0e05c17 	ldw	r3,-32400(gp)
8110d640:	e0bffe17 	ldw	r2,-8(fp)
8110d644:	10802117 	ldw	r2,132(r2)
8110d648:	100d883a 	mov	r6,r2
8110d64c:	01604534 	movhi	r5,33044
8110d650:	295c3904 	addi	r5,r5,28900
8110d654:	1809883a 	mov	r4,r3
8110d658:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
8110d65c:	d0e05c17 	ldw	r3,-32400(gp)
8110d660:	e0bffe17 	ldw	r2,-8(fp)
8110d664:	10802317 	ldw	r2,140(r2)
8110d668:	100d883a 	mov	r6,r2
8110d66c:	01604534 	movhi	r5,33044
8110d670:	295c4004 	addi	r5,r5,28928
8110d674:	1809883a 	mov	r4,r3
8110d678:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
8110d67c:	d0e05c17 	ldw	r3,-32400(gp)
8110d680:	e0bffe17 	ldw	r2,-8(fp)
8110d684:	10802417 	ldw	r2,144(r2)
8110d688:	100d883a 	mov	r6,r2
8110d68c:	01604534 	movhi	r5,33044
8110d690:	295c4704 	addi	r5,r5,28956
8110d694:	1809883a 	mov	r4,r3
8110d698:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
8110d69c:	d0e05c17 	ldw	r3,-32400(gp)
8110d6a0:	e0bffe17 	ldw	r2,-8(fp)
8110d6a4:	10802517 	ldw	r2,148(r2)
8110d6a8:	100d883a 	mov	r6,r2
8110d6ac:	01604534 	movhi	r5,33044
8110d6b0:	295c4e04 	addi	r5,r5,28984
8110d6b4:	1809883a 	mov	r4,r3
8110d6b8:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
8110d6bc:	d0e05c17 	ldw	r3,-32400(gp)
8110d6c0:	e0bffe17 	ldw	r2,-8(fp)
8110d6c4:	10802617 	ldw	r2,152(r2)
8110d6c8:	100d883a 	mov	r6,r2
8110d6cc:	01604534 	movhi	r5,33044
8110d6d0:	295c5504 	addi	r5,r5,29012
8110d6d4:	1809883a 	mov	r4,r3
8110d6d8:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
8110d6dc:	d1205c17 	ldw	r4,-32400(gp)
8110d6e0:	e0bffe17 	ldw	r2,-8(fp)
8110d6e4:	10802a43 	ldbu	r2,169(r2)
8110d6e8:	11403fcc 	andi	r5,r2,255
8110d6ec:	e0bffe17 	ldw	r2,-8(fp)
8110d6f0:	10802a83 	ldbu	r2,170(r2)
8110d6f4:	11803fcc 	andi	r6,r2,255
8110d6f8:	e0bffe17 	ldw	r2,-8(fp)
8110d6fc:	10802ac3 	ldbu	r2,171(r2)
8110d700:	10803fcc 	andi	r2,r2,255
8110d704:	e0fffe17 	ldw	r3,-8(fp)
8110d708:	18c02b03 	ldbu	r3,172(r3)
8110d70c:	18c03fcc 	andi	r3,r3,255
8110d710:	d8c00115 	stw	r3,4(sp)
8110d714:	d8800015 	stw	r2,0(sp)
8110d718:	300f883a 	mov	r7,r6
8110d71c:	280d883a 	mov	r6,r5
8110d720:	01604534 	movhi	r5,33044
8110d724:	295c5c04 	addi	r5,r5,29040
8110d728:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
8110d72c:	d0e05c17 	ldw	r3,-32400(gp)
8110d730:	e0bffe17 	ldw	r2,-8(fp)
8110d734:	10802e17 	ldw	r2,184(r2)
8110d738:	100d883a 	mov	r6,r2
8110d73c:	01604534 	movhi	r5,33044
8110d740:	295c6904 	addi	r5,r5,29092
8110d744:	1809883a 	mov	r4,r3
8110d748:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"\n\n");
8110d74c:	d0a05c17 	ldw	r2,-32400(gp)
8110d750:	100f883a 	mov	r7,r2
8110d754:	01800084 	movi	r6,2
8110d758:	01400044 	movi	r5,1
8110d75c:	01204534 	movhi	r4,33044
8110d760:	211c6f04 	addi	r4,r4,29116
8110d764:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
8110d768:	d0e05c17 	ldw	r3,-32400(gp)
8110d76c:	e0bffe17 	ldw	r2,-8(fp)
8110d770:	10800003 	ldbu	r2,0(r2)
8110d774:	10803fcc 	andi	r2,r2,255
8110d778:	100d883a 	mov	r6,r2
8110d77c:	01604534 	movhi	r5,33044
8110d780:	295c7004 	addi	r5,r5,29120
8110d784:	1809883a 	mov	r4,r3
8110d788:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    General Info: \n");
8110d78c:	d0a05c17 	ldw	r2,-32400(gp)
8110d790:	100f883a 	mov	r7,r2
8110d794:	018004c4 	movi	r6,19
8110d798:	01400044 	movi	r5,1
8110d79c:	01204534 	movhi	r4,33044
8110d7a0:	211c7604 	addi	r4,r4,29144
8110d7a4:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
8110d7a8:	d0e05c17 	ldw	r3,-32400(gp)
8110d7ac:	e0bffe17 	ldw	r2,-8(fp)
8110d7b0:	10800117 	ldw	r2,4(r2)
8110d7b4:	100d883a 	mov	r6,r2
8110d7b8:	01604534 	movhi	r5,33044
8110d7bc:	295c7b04 	addi	r5,r5,29164
8110d7c0:	1809883a 	mov	r4,r3
8110d7c4:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
8110d7c8:	d0e05c17 	ldw	r3,-32400(gp)
8110d7cc:	e0bffe17 	ldw	r2,-8(fp)
8110d7d0:	10800217 	ldw	r2,8(r2)
8110d7d4:	100d883a 	mov	r6,r2
8110d7d8:	01604534 	movhi	r5,33044
8110d7dc:	295c8304 	addi	r5,r5,29196
8110d7e0:	1809883a 	mov	r4,r3
8110d7e4:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
8110d7e8:	d0e05c17 	ldw	r3,-32400(gp)
8110d7ec:	e0bffe17 	ldw	r2,-8(fp)
8110d7f0:	10800317 	ldw	r2,12(r2)
8110d7f4:	100d883a 	mov	r6,r2
8110d7f8:	01604534 	movhi	r5,33044
8110d7fc:	295c8b04 	addi	r5,r5,29228
8110d800:	1809883a 	mov	r4,r3
8110d804:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
8110d808:	d0a05c17 	ldw	r2,-32400(gp)
8110d80c:	100f883a 	mov	r7,r2
8110d810:	01800644 	movi	r6,25
8110d814:	01400044 	movi	r5,1
8110d818:	01204534 	movhi	r4,33044
8110d81c:	211c9204 	addi	r4,r4,29256
8110d820:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
8110d824:	d0e05c17 	ldw	r3,-32400(gp)
8110d828:	e0bffe17 	ldw	r2,-8(fp)
8110d82c:	10800517 	ldw	r2,20(r2)
8110d830:	100d883a 	mov	r6,r2
8110d834:	01604534 	movhi	r5,33044
8110d838:	295c9904 	addi	r5,r5,29284
8110d83c:	1809883a 	mov	r4,r3
8110d840:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
8110d844:	d0e05c17 	ldw	r3,-32400(gp)
8110d848:	e0bffe17 	ldw	r2,-8(fp)
8110d84c:	10800417 	ldw	r2,16(r2)
8110d850:	100d883a 	mov	r6,r2
8110d854:	01604534 	movhi	r5,33044
8110d858:	295ca104 	addi	r5,r5,29316
8110d85c:	1809883a 	mov	r4,r3
8110d860:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
8110d864:	d0e05c17 	ldw	r3,-32400(gp)
8110d868:	e0bffe17 	ldw	r2,-8(fp)
8110d86c:	10800603 	ldbu	r2,24(r2)
8110d870:	10803fcc 	andi	r2,r2,255
8110d874:	100d883a 	mov	r6,r2
8110d878:	01604534 	movhi	r5,33044
8110d87c:	295ca904 	addi	r5,r5,29348
8110d880:	1809883a 	mov	r4,r3
8110d884:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
8110d888:	d2205c17 	ldw	r8,-32400(gp)
8110d88c:	e13ffe17 	ldw	r4,-8(fp)
8110d890:	20800717 	ldw	r2,28(r4)
8110d894:	20c00817 	ldw	r3,32(r4)
8110d898:	100d883a 	mov	r6,r2
8110d89c:	180f883a 	mov	r7,r3
8110d8a0:	01604534 	movhi	r5,33044
8110d8a4:	295cb104 	addi	r5,r5,29380
8110d8a8:	4009883a 	mov	r4,r8
8110d8ac:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"\n");
8110d8b0:	d0a05c17 	ldw	r2,-32400(gp)
8110d8b4:	100b883a 	mov	r5,r2
8110d8b8:	01000284 	movi	r4,10
8110d8bc:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
8110d8c0:	d0e05c17 	ldw	r3,-32400(gp)
8110d8c4:	e0bffe17 	ldw	r2,-8(fp)
8110d8c8:	10800003 	ldbu	r2,0(r2)
8110d8cc:	10803fcc 	andi	r2,r2,255
8110d8d0:	100f883a 	mov	r7,r2
8110d8d4:	000d883a 	mov	r6,zero
8110d8d8:	01604534 	movhi	r5,33044
8110d8dc:	295cb904 	addi	r5,r5,29412
8110d8e0:	1809883a 	mov	r4,r3
8110d8e4:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Left side \n");
8110d8e8:	d0a05c17 	ldw	r2,-32400(gp)
8110d8ec:	100f883a 	mov	r7,r2
8110d8f0:	018004c4 	movi	r6,19
8110d8f4:	01400044 	movi	r5,1
8110d8f8:	01204534 	movhi	r4,33044
8110d8fc:	211cc304 	addi	r4,r4,29452
8110d900:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
8110d904:	d0e05c17 	ldw	r3,-32400(gp)
8110d908:	e0bffe17 	ldw	r2,-8(fp)
8110d90c:	10800917 	ldw	r2,36(r2)
8110d910:	100d883a 	mov	r6,r2
8110d914:	01604534 	movhi	r5,33044
8110d918:	295cc804 	addi	r5,r5,29472
8110d91c:	1809883a 	mov	r4,r3
8110d920:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
8110d924:	d0e05c17 	ldw	r3,-32400(gp)
8110d928:	e0bffe17 	ldw	r2,-8(fp)
8110d92c:	10800a17 	ldw	r2,40(r2)
8110d930:	100d883a 	mov	r6,r2
8110d934:	01604534 	movhi	r5,33044
8110d938:	295cd104 	addi	r5,r5,29508
8110d93c:	1809883a 	mov	r4,r3
8110d940:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
8110d944:	d0e05c17 	ldw	r3,-32400(gp)
8110d948:	e0bffe17 	ldw	r2,-8(fp)
8110d94c:	10800b17 	ldw	r2,44(r2)
8110d950:	100d883a 	mov	r6,r2
8110d954:	01604534 	movhi	r5,33044
8110d958:	295cdc04 	addi	r5,r5,29552
8110d95c:	1809883a 	mov	r4,r3
8110d960:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Right side \n");
8110d964:	d0a05c17 	ldw	r2,-32400(gp)
8110d968:	100f883a 	mov	r7,r2
8110d96c:	01800504 	movi	r6,20
8110d970:	01400044 	movi	r5,1
8110d974:	01204534 	movhi	r4,33044
8110d978:	211ce804 	addi	r4,r4,29600
8110d97c:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
8110d980:	d0e05c17 	ldw	r3,-32400(gp)
8110d984:	e0bffe17 	ldw	r2,-8(fp)
8110d988:	10800c17 	ldw	r2,48(r2)
8110d98c:	100d883a 	mov	r6,r2
8110d990:	01604534 	movhi	r5,33044
8110d994:	295cc804 	addi	r5,r5,29472
8110d998:	1809883a 	mov	r4,r3
8110d99c:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
8110d9a0:	d0e05c17 	ldw	r3,-32400(gp)
8110d9a4:	e0bffe17 	ldw	r2,-8(fp)
8110d9a8:	10800d17 	ldw	r2,52(r2)
8110d9ac:	100d883a 	mov	r6,r2
8110d9b0:	01604534 	movhi	r5,33044
8110d9b4:	295cd104 	addi	r5,r5,29508
8110d9b8:	1809883a 	mov	r4,r3
8110d9bc:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
8110d9c0:	d0e05c17 	ldw	r3,-32400(gp)
8110d9c4:	e0bffe17 	ldw	r2,-8(fp)
8110d9c8:	10800e17 	ldw	r2,56(r2)
8110d9cc:	100d883a 	mov	r6,r2
8110d9d0:	01604534 	movhi	r5,33044
8110d9d4:	295cdc04 	addi	r5,r5,29552
8110d9d8:	1809883a 	mov	r4,r3
8110d9dc:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"\n");
8110d9e0:	d0a05c17 	ldw	r2,-32400(gp)
8110d9e4:	100b883a 	mov	r5,r2
8110d9e8:	01000284 	movi	r4,10
8110d9ec:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
8110d9f0:	d0e05c17 	ldw	r3,-32400(gp)
8110d9f4:	e0bffe17 	ldw	r2,-8(fp)
8110d9f8:	10800003 	ldbu	r2,0(r2)
8110d9fc:	10803fcc 	andi	r2,r2,255
8110da00:	100f883a 	mov	r7,r2
8110da04:	01800044 	movi	r6,1
8110da08:	01604534 	movhi	r5,33044
8110da0c:	295cb904 	addi	r5,r5,29412
8110da10:	1809883a 	mov	r4,r3
8110da14:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Left side \n");
8110da18:	d0a05c17 	ldw	r2,-32400(gp)
8110da1c:	100f883a 	mov	r7,r2
8110da20:	018004c4 	movi	r6,19
8110da24:	01400044 	movi	r5,1
8110da28:	01204534 	movhi	r4,33044
8110da2c:	211cc304 	addi	r4,r4,29452
8110da30:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
8110da34:	d0e05c17 	ldw	r3,-32400(gp)
8110da38:	e0bffe17 	ldw	r2,-8(fp)
8110da3c:	10800f17 	ldw	r2,60(r2)
8110da40:	100d883a 	mov	r6,r2
8110da44:	01604534 	movhi	r5,33044
8110da48:	295cc804 	addi	r5,r5,29472
8110da4c:	1809883a 	mov	r4,r3
8110da50:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
8110da54:	d0e05c17 	ldw	r3,-32400(gp)
8110da58:	e0bffe17 	ldw	r2,-8(fp)
8110da5c:	10801017 	ldw	r2,64(r2)
8110da60:	100d883a 	mov	r6,r2
8110da64:	01604534 	movhi	r5,33044
8110da68:	295cd104 	addi	r5,r5,29508
8110da6c:	1809883a 	mov	r4,r3
8110da70:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
8110da74:	d0e05c17 	ldw	r3,-32400(gp)
8110da78:	e0bffe17 	ldw	r2,-8(fp)
8110da7c:	10801117 	ldw	r2,68(r2)
8110da80:	100d883a 	mov	r6,r2
8110da84:	01604534 	movhi	r5,33044
8110da88:	295cdc04 	addi	r5,r5,29552
8110da8c:	1809883a 	mov	r4,r3
8110da90:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Right side \n");
8110da94:	d0a05c17 	ldw	r2,-32400(gp)
8110da98:	100f883a 	mov	r7,r2
8110da9c:	01800504 	movi	r6,20
8110daa0:	01400044 	movi	r5,1
8110daa4:	01204534 	movhi	r4,33044
8110daa8:	211ce804 	addi	r4,r4,29600
8110daac:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
8110dab0:	d0e05c17 	ldw	r3,-32400(gp)
8110dab4:	e0bffe17 	ldw	r2,-8(fp)
8110dab8:	10801217 	ldw	r2,72(r2)
8110dabc:	100d883a 	mov	r6,r2
8110dac0:	01604534 	movhi	r5,33044
8110dac4:	295cc804 	addi	r5,r5,29472
8110dac8:	1809883a 	mov	r4,r3
8110dacc:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
8110dad0:	d0e05c17 	ldw	r3,-32400(gp)
8110dad4:	e0bffe17 	ldw	r2,-8(fp)
8110dad8:	10801317 	ldw	r2,76(r2)
8110dadc:	100d883a 	mov	r6,r2
8110dae0:	01604534 	movhi	r5,33044
8110dae4:	295cd104 	addi	r5,r5,29508
8110dae8:	1809883a 	mov	r4,r3
8110daec:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
8110daf0:	d0e05c17 	ldw	r3,-32400(gp)
8110daf4:	e0bffe17 	ldw	r2,-8(fp)
8110daf8:	10801417 	ldw	r2,80(r2)
8110dafc:	100d883a 	mov	r6,r2
8110db00:	01604534 	movhi	r5,33044
8110db04:	295cdc04 	addi	r5,r5,29552
8110db08:	1809883a 	mov	r4,r3
8110db0c:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"\n");
8110db10:	d0a05c17 	ldw	r2,-32400(gp)
8110db14:	100b883a 	mov	r5,r2
8110db18:	01000284 	movi	r4,10
8110db1c:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
8110db20:	d0e05c17 	ldw	r3,-32400(gp)
8110db24:	e0bffe17 	ldw	r2,-8(fp)
8110db28:	10800003 	ldbu	r2,0(r2)
8110db2c:	10803fcc 	andi	r2,r2,255
8110db30:	100f883a 	mov	r7,r2
8110db34:	01800084 	movi	r6,2
8110db38:	01604534 	movhi	r5,33044
8110db3c:	295cb904 	addi	r5,r5,29412
8110db40:	1809883a 	mov	r4,r3
8110db44:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Left side \n");
8110db48:	d0a05c17 	ldw	r2,-32400(gp)
8110db4c:	100f883a 	mov	r7,r2
8110db50:	018004c4 	movi	r6,19
8110db54:	01400044 	movi	r5,1
8110db58:	01204534 	movhi	r4,33044
8110db5c:	211cc304 	addi	r4,r4,29452
8110db60:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
8110db64:	d0e05c17 	ldw	r3,-32400(gp)
8110db68:	e0bffe17 	ldw	r2,-8(fp)
8110db6c:	10801517 	ldw	r2,84(r2)
8110db70:	100d883a 	mov	r6,r2
8110db74:	01604534 	movhi	r5,33044
8110db78:	295cc804 	addi	r5,r5,29472
8110db7c:	1809883a 	mov	r4,r3
8110db80:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
8110db84:	d0e05c17 	ldw	r3,-32400(gp)
8110db88:	e0bffe17 	ldw	r2,-8(fp)
8110db8c:	10801617 	ldw	r2,88(r2)
8110db90:	100d883a 	mov	r6,r2
8110db94:	01604534 	movhi	r5,33044
8110db98:	295cd104 	addi	r5,r5,29508
8110db9c:	1809883a 	mov	r4,r3
8110dba0:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
8110dba4:	d0e05c17 	ldw	r3,-32400(gp)
8110dba8:	e0bffe17 	ldw	r2,-8(fp)
8110dbac:	10801717 	ldw	r2,92(r2)
8110dbb0:	100d883a 	mov	r6,r2
8110dbb4:	01604534 	movhi	r5,33044
8110dbb8:	295cdc04 	addi	r5,r5,29552
8110dbbc:	1809883a 	mov	r4,r3
8110dbc0:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Right side \n");
8110dbc4:	d0a05c17 	ldw	r2,-32400(gp)
8110dbc8:	100f883a 	mov	r7,r2
8110dbcc:	01800504 	movi	r6,20
8110dbd0:	01400044 	movi	r5,1
8110dbd4:	01204534 	movhi	r4,33044
8110dbd8:	211ce804 	addi	r4,r4,29600
8110dbdc:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
8110dbe0:	d0e05c17 	ldw	r3,-32400(gp)
8110dbe4:	e0bffe17 	ldw	r2,-8(fp)
8110dbe8:	10801817 	ldw	r2,96(r2)
8110dbec:	100d883a 	mov	r6,r2
8110dbf0:	01604534 	movhi	r5,33044
8110dbf4:	295cc804 	addi	r5,r5,29472
8110dbf8:	1809883a 	mov	r4,r3
8110dbfc:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
8110dc00:	d0e05c17 	ldw	r3,-32400(gp)
8110dc04:	e0bffe17 	ldw	r2,-8(fp)
8110dc08:	10801917 	ldw	r2,100(r2)
8110dc0c:	100d883a 	mov	r6,r2
8110dc10:	01604534 	movhi	r5,33044
8110dc14:	295cd104 	addi	r5,r5,29508
8110dc18:	1809883a 	mov	r4,r3
8110dc1c:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
8110dc20:	d0e05c17 	ldw	r3,-32400(gp)
8110dc24:	e0bffe17 	ldw	r2,-8(fp)
8110dc28:	10801a17 	ldw	r2,104(r2)
8110dc2c:	100d883a 	mov	r6,r2
8110dc30:	01604534 	movhi	r5,33044
8110dc34:	295cdc04 	addi	r5,r5,29552
8110dc38:	1809883a 	mov	r4,r3
8110dc3c:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"\n");
8110dc40:	d0a05c17 	ldw	r2,-32400(gp)
8110dc44:	100b883a 	mov	r5,r2
8110dc48:	01000284 	movi	r4,10
8110dc4c:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8110dc50:	d0e05c17 	ldw	r3,-32400(gp)
8110dc54:	e0bffe17 	ldw	r2,-8(fp)
8110dc58:	10800003 	ldbu	r2,0(r2)
8110dc5c:	10803fcc 	andi	r2,r2,255
8110dc60:	100f883a 	mov	r7,r2
8110dc64:	018000c4 	movi	r6,3
8110dc68:	01604534 	movhi	r5,33044
8110dc6c:	295cb904 	addi	r5,r5,29412
8110dc70:	1809883a 	mov	r4,r3
8110dc74:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Left side \n");
8110dc78:	d0a05c17 	ldw	r2,-32400(gp)
8110dc7c:	100f883a 	mov	r7,r2
8110dc80:	018004c4 	movi	r6,19
8110dc84:	01400044 	movi	r5,1
8110dc88:	01204534 	movhi	r4,33044
8110dc8c:	211cc304 	addi	r4,r4,29452
8110dc90:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
8110dc94:	d0e05c17 	ldw	r3,-32400(gp)
8110dc98:	e0bffe17 	ldw	r2,-8(fp)
8110dc9c:	10801b17 	ldw	r2,108(r2)
8110dca0:	100d883a 	mov	r6,r2
8110dca4:	01604534 	movhi	r5,33044
8110dca8:	295cc804 	addi	r5,r5,29472
8110dcac:	1809883a 	mov	r4,r3
8110dcb0:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
8110dcb4:	d0e05c17 	ldw	r3,-32400(gp)
8110dcb8:	e0bffe17 	ldw	r2,-8(fp)
8110dcbc:	10801c17 	ldw	r2,112(r2)
8110dcc0:	100d883a 	mov	r6,r2
8110dcc4:	01604534 	movhi	r5,33044
8110dcc8:	295cd104 	addi	r5,r5,29508
8110dccc:	1809883a 	mov	r4,r3
8110dcd0:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
8110dcd4:	d0e05c17 	ldw	r3,-32400(gp)
8110dcd8:	e0bffe17 	ldw	r2,-8(fp)
8110dcdc:	10801d17 	ldw	r2,116(r2)
8110dce0:	100d883a 	mov	r6,r2
8110dce4:	01604534 	movhi	r5,33044
8110dce8:	295cdc04 	addi	r5,r5,29552
8110dcec:	1809883a 	mov	r4,r3
8110dcf0:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"        Right side \n");
8110dcf4:	d0a05c17 	ldw	r2,-32400(gp)
8110dcf8:	100f883a 	mov	r7,r2
8110dcfc:	01800504 	movi	r6,20
8110dd00:	01400044 	movi	r5,1
8110dd04:	01204534 	movhi	r4,33044
8110dd08:	211ce804 	addi	r4,r4,29600
8110dd0c:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
8110dd10:	d0e05c17 	ldw	r3,-32400(gp)
8110dd14:	e0bffe17 	ldw	r2,-8(fp)
8110dd18:	10801e17 	ldw	r2,120(r2)
8110dd1c:	100d883a 	mov	r6,r2
8110dd20:	01604534 	movhi	r5,33044
8110dd24:	295cc804 	addi	r5,r5,29472
8110dd28:	1809883a 	mov	r4,r3
8110dd2c:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
8110dd30:	d0e05c17 	ldw	r3,-32400(gp)
8110dd34:	e0bffe17 	ldw	r2,-8(fp)
8110dd38:	10801f17 	ldw	r2,124(r2)
8110dd3c:	100d883a 	mov	r6,r2
8110dd40:	01604534 	movhi	r5,33044
8110dd44:	295cd104 	addi	r5,r5,29508
8110dd48:	1809883a 	mov	r4,r3
8110dd4c:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
8110dd50:	d0e05c17 	ldw	r3,-32400(gp)
8110dd54:	e0bffe17 	ldw	r2,-8(fp)
8110dd58:	10802017 	ldw	r2,128(r2)
8110dd5c:	100d883a 	mov	r6,r2
8110dd60:	01604534 	movhi	r5,33044
8110dd64:	295cdc04 	addi	r5,r5,29552
8110dd68:	1809883a 	mov	r4,r3
8110dd6c:	111b3900 	call	8111b390 <fprintf>
		fprintf(fp,"\n");
8110dd70:	d0a05c17 	ldw	r2,-32400(gp)
8110dd74:	100b883a 	mov	r5,r2
8110dd78:	01000284 	movi	r4,10
8110dd7c:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"==============================================================================\n");
8110dd80:	d0a05c17 	ldw	r2,-32400(gp)
8110dd84:	100f883a 	mov	r7,r2
8110dd88:	018013c4 	movi	r6,79
8110dd8c:	01400044 	movi	r5,1
8110dd90:	01204534 	movhi	r4,33044
8110dd94:	211cee04 	addi	r4,r4,29624
8110dd98:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"==============================================================================\n");
8110dd9c:	d0a05c17 	ldw	r2,-32400(gp)
8110dda0:	100f883a 	mov	r7,r2
8110dda4:	018013c4 	movi	r6,79
8110dda8:	01400044 	movi	r5,1
8110ddac:	01204534 	movhi	r4,33044
8110ddb0:	211cee04 	addi	r4,r4,29624
8110ddb4:	111ba2c0 	call	8111ba2c <fwrite>
		fprintf(fp,"\n");
8110ddb8:	d0a05c17 	ldw	r2,-32400(gp)
8110ddbc:	100b883a 	mov	r5,r2
8110ddc0:	01000284 	movi	r4,10
8110ddc4:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"\n");
8110ddc8:	d0a05c17 	ldw	r2,-32400(gp)
8110ddcc:	100b883a 	mov	r5,r2
8110ddd0:	01000284 	movi	r4,10
8110ddd4:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"\n");
8110ddd8:	d0a05c17 	ldw	r2,-32400(gp)
8110dddc:	100b883a 	mov	r5,r2
8110dde0:	01000284 	movi	r4,10
8110dde4:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"\n");
8110dde8:	d0a05c17 	ldw	r2,-32400(gp)
8110ddec:	100b883a 	mov	r5,r2
8110ddf0:	01000284 	movi	r4,10
8110ddf4:	111b4080 	call	8111b408 <fputc>
		fprintf(fp,"\n");
8110ddf8:	d0a05c17 	ldw	r2,-32400(gp)
8110ddfc:	100b883a 	mov	r5,r2
8110de00:	01000284 	movi	r4,10
8110de04:	111b4080 	call	8111b408 <fputc>
	}
8110de08:	0001883a 	nop
8110de0c:	e037883a 	mov	sp,fp
8110de10:	dfc00117 	ldw	ra,4(sp)
8110de14:	df000017 	ldw	fp,0(sp)
8110de18:	dec00204 	addi	sp,sp,8
8110de1c:	f800283a 	ret

8110de20 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
8110de20:	defff604 	addi	sp,sp,-40
8110de24:	de00012e 	bgeu	sp,et,8110de2c <vInAckHandlerTaskV2+0xc>
8110de28:	003b68fa 	trap	3
8110de2c:	dfc00915 	stw	ra,36(sp)
8110de30:	df000815 	stw	fp,32(sp)
8110de34:	df000804 	addi	fp,sp,32
8110de38:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8110de3c:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
8110de40:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
8110de44:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
8110de48:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8110de4c:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
8110de50:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
8110de54:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
8110de58:	d0a05c17 	ldw	r2,-32400(gp)
8110de5c:	100f883a 	mov	r7,r2
8110de60:	018007c4 	movi	r6,31
8110de64:	01400044 	movi	r5,1
8110de68:	01204534 	movhi	r4,33044
8110de6c:	211d0204 	addi	r4,r4,29704
8110de70:	111ba2c0 	call	8111ba2c <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
8110de74:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
8110de78:	e0bff917 	ldw	r2,-28(fp)
8110de7c:	10c00060 	cmpeqi	r3,r2,1
8110de80:	1800071e 	bne	r3,zero,8110dea0 <vInAckHandlerTaskV2+0x80>
8110de84:	0080032e 	bgeu	zero,r2,8110de94 <vInAckHandlerTaskV2+0x74>
8110de88:	108000a0 	cmpeqi	r2,r2,2
8110de8c:	10004a1e 	bne	r2,zero,8110dfb8 <vInAckHandlerTaskV2+0x198>
8110de90:	0000ac06 	br	8110e144 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
8110de94:	00800044 	movi	r2,1
8110de98:	e0bff915 	stw	r2,-28(fp)
				break;
8110de9c:	0000b306 	br	8110e16c <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
8110dea0:	00800044 	movi	r2,1
8110dea4:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
8110dea8:	d0a06017 	ldw	r2,-32384(gp)
8110deac:	e0fffe04 	addi	r3,fp,-8
8110deb0:	180d883a 	mov	r6,r3
8110deb4:	000b883a 	mov	r5,zero
8110deb8:	1009883a 	mov	r4,r2
8110debc:	113946c0 	call	8113946c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110dec0:	e0bffe03 	ldbu	r2,-8(fp)
8110dec4:	10803fcc 	andi	r2,r2,255
8110dec8:	1000391e 	bne	r2,zero,8110dfb0 <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
8110decc:	d0a05f17 	ldw	r2,-32388(gp)
8110ded0:	e0fffe04 	addi	r3,fp,-8
8110ded4:	180d883a 	mov	r6,r3
8110ded8:	000b883a 	mov	r5,zero
8110dedc:	1009883a 	mov	r4,r2
8110dee0:	11374600 	call	81137460 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110dee4:	e0bffe03 	ldbu	r2,-8(fp)
8110dee8:	10803fcc 	andi	r2,r2,255
8110deec:	10002b1e 	bne	r2,zero,8110df9c <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110def0:	e03ffa45 	stb	zero,-23(fp)
8110def4:	00002206 	br	8110df80 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
8110def8:	e0fffa43 	ldbu	r3,-23(fp)
8110defc:	00a045b4 	movhi	r2,33046
8110df00:	10aac204 	addi	r2,r2,-21752
8110df04:	18c7883a 	add	r3,r3,r3
8110df08:	18c7883a 	add	r3,r3,r3
8110df0c:	10c5883a 	add	r2,r2,r3
8110df10:	10800003 	ldbu	r2,0(r2)
8110df14:	10803fcc 	andi	r2,r2,255
8110df18:	1080201c 	xori	r2,r2,128
8110df1c:	10bfe004 	addi	r2,r2,-128
8110df20:	10001426 	beq	r2,zero,8110df74 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8110df24:	e0fffa43 	ldbu	r3,-23(fp)
8110df28:	00a045b4 	movhi	r2,33046
8110df2c:	10aac204 	addi	r2,r2,-21752
8110df30:	18c7883a 	add	r3,r3,r3
8110df34:	18c7883a 	add	r3,r3,r3
8110df38:	10c5883a 	add	r2,r2,r3
8110df3c:	10c0000b 	ldhu	r3,0(r2)
8110df40:	d0e0520d 	sth	r3,-32440(gp)
8110df44:	1080008b 	ldhu	r2,2(r2)
8110df48:	d0a0528d 	sth	r2,-32438(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110df4c:	e0fffa43 	ldbu	r3,-23(fp)
8110df50:	00a045b4 	movhi	r2,33046
8110df54:	10aac204 	addi	r2,r2,-21752
8110df58:	18c7883a 	add	r3,r3,r3
8110df5c:	18c7883a 	add	r3,r3,r3
8110df60:	10c5883a 	add	r2,r2,r3
8110df64:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
8110df68:	00800084 	movi	r2,2
8110df6c:	e0bff915 	stw	r2,-28(fp)
                                break;                                
8110df70:	00000606 	br	8110df8c <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110df74:	e0bffa43 	ldbu	r2,-23(fp)
8110df78:	10800044 	addi	r2,r2,1
8110df7c:	e0bffa45 	stb	r2,-23(fp)
8110df80:	e0bffa43 	ldbu	r2,-23(fp)
8110df84:	108001b0 	cmpltui	r2,r2,6
8110df88:	103fdb1e 	bne	r2,zero,8110def8 <__reset+0xfb0edef8>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
8110df8c:	d0a05f17 	ldw	r2,-32388(gp)
8110df90:	1009883a 	mov	r4,r2
8110df94:	1137a040 	call	81137a04 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110df98:	00007406 	br	8110e16c <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
8110df9c:	d0a06017 	ldw	r2,-32384(gp)
8110dfa0:	1009883a 	mov	r4,r2
8110dfa4:	11397f40 	call	811397f4 <OSSemPost>
                    	vFailGetMutexReceiverTask();
8110dfa8:	11169cc0 	call	811169cc <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110dfac:	00006f06 	br	8110e16c <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
8110dfb0:	11169640 	call	81116964 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
8110dfb4:	00006d06 	br	8110e16c <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
8110dfb8:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110dfbc:	d0a06283 	ldbu	r2,-32374(gp)
8110dfc0:	10803fcc 	andi	r2,r2,255
8110dfc4:	10800218 	cmpnei	r2,r2,8
8110dfc8:	1000021e 	bne	r2,zero,8110dfd4 <vInAckHandlerTaskV2+0x1b4>
8110dfcc:	00c00104 	movi	r3,4
8110dfd0:	00000106 	br	8110dfd8 <vInAckHandlerTaskV2+0x1b8>
8110dfd4:	0007883a 	mov	r3,zero
8110dfd8:	d0a06f03 	ldbu	r2,-32324(gp)
8110dfdc:	10803fcc 	andi	r2,r2,255
8110dfe0:	10800218 	cmpnei	r2,r2,8
8110dfe4:	1000021e 	bne	r2,zero,8110dff0 <vInAckHandlerTaskV2+0x1d0>
8110dfe8:	00800084 	movi	r2,2
8110dfec:	00000106 	br	8110dff4 <vInAckHandlerTaskV2+0x1d4>
8110dff0:	0005883a 	mov	r2,zero
8110dff4:	1884b03a 	or	r2,r3,r2
8110dff8:	1007883a 	mov	r3,r2
8110dffc:	d0a06f43 	ldbu	r2,-32323(gp)
8110e000:	10803fcc 	andi	r2,r2,255
8110e004:	108001a0 	cmpeqi	r2,r2,6
8110e008:	1884b03a 	or	r2,r3,r2
8110e00c:	1007883a 	mov	r3,r2
8110e010:	e0bffa83 	ldbu	r2,-22(fp)
8110e014:	1884b03a 	or	r2,r3,r2
8110e018:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
8110e01c:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
8110e020:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8110e024:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8110e028:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
8110e02c:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
8110e030:	e0bffa03 	ldbu	r2,-24(fp)
8110e034:	10800044 	addi	r2,r2,1
8110e038:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8110e03c:	e0bffa83 	ldbu	r2,-22(fp)
8110e040:	1080004c 	andi	r2,r2,1
8110e044:	10803fcc 	andi	r2,r2,255
8110e048:	1000061e 	bne	r2,zero,8110e064 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
8110e04c:	e0bffd04 	addi	r2,fp,-12
8110e050:	100b883a 	mov	r5,r2
8110e054:	d1205204 	addi	r4,gp,-32440
8110e058:	110e1700 	call	8110e170 <bCheckInAck128>
8110e05c:	e0bff815 	stw	r2,-32(fp)
8110e060:	00000206 	br	8110e06c <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
8110e064:	00800044 	movi	r2,1
8110e068:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
8110e06c:	e0bffa83 	ldbu	r2,-22(fp)
8110e070:	1080008c 	andi	r2,r2,2
8110e074:	10803fcc 	andi	r2,r2,255
8110e078:	1000081e 	bne	r2,zero,8110e09c <vInAckHandlerTaskV2+0x27c>
8110e07c:	e0bff817 	ldw	r2,-32(fp)
8110e080:	1000061e 	bne	r2,zero,8110e09c <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8110e084:	e0bffc04 	addi	r2,fp,-16
8110e088:	100b883a 	mov	r5,r2
8110e08c:	d1205204 	addi	r4,gp,-32440
8110e090:	110e2b80 	call	8110e2b8 <bCheckInAck64>
8110e094:	e0bff815 	stw	r2,-32(fp)
8110e098:	00000206 	br	8110e0a4 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
8110e09c:	00800044 	movi	r2,1
8110e0a0:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
8110e0a4:	e0bffa83 	ldbu	r2,-22(fp)
8110e0a8:	1080010c 	andi	r2,r2,4
8110e0ac:	10803fcc 	andi	r2,r2,255
8110e0b0:	1000081e 	bne	r2,zero,8110e0d4 <vInAckHandlerTaskV2+0x2b4>
8110e0b4:	e0bff817 	ldw	r2,-32(fp)
8110e0b8:	1000061e 	bne	r2,zero,8110e0d4 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
8110e0bc:	e0bffb04 	addi	r2,fp,-20
8110e0c0:	100b883a 	mov	r5,r2
8110e0c4:	d1205204 	addi	r4,gp,-32440
8110e0c8:	110e4040 	call	8110e404 <bCheckInAck32>
8110e0cc:	e0bff815 	stw	r2,-32(fp)
8110e0d0:	00000206 	br	8110e0dc <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
8110e0d4:	00800044 	movi	r2,1
8110e0d8:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
8110e0dc:	e0bffa03 	ldbu	r2,-24(fp)
8110e0e0:	10c00044 	addi	r3,r2,1
8110e0e4:	e0fffa05 	stb	r3,-24(fp)
8110e0e8:	10803fcc 	andi	r2,r2,255
8110e0ec:	10800ca8 	cmpgeui	r2,r2,50
8110e0f0:	10000e1e 	bne	r2,zero,8110e12c <vInAckHandlerTaskV2+0x30c>
8110e0f4:	e0bff817 	ldw	r2,-32(fp)
8110e0f8:	10000c1e 	bne	r2,zero,8110e12c <vInAckHandlerTaskV2+0x30c>
8110e0fc:	e0bffb17 	ldw	r2,-20(fp)
8110e100:	1005003a 	cmpeq	r2,r2,zero
8110e104:	1007883a 	mov	r3,r2
8110e108:	e0bffc17 	ldw	r2,-16(fp)
8110e10c:	1005003a 	cmpeq	r2,r2,zero
8110e110:	1884b03a 	or	r2,r3,r2
8110e114:	10c03fcc 	andi	r3,r2,255
8110e118:	e0bffd17 	ldw	r2,-12(fp)
8110e11c:	1005003a 	cmpeq	r2,r2,zero
8110e120:	10803fcc 	andi	r2,r2,255
8110e124:	1884b03a 	or	r2,r3,r2
8110e128:	103fc11e 	bne	r2,zero,8110e030 <__reset+0xfb0ee030>
                
                if (bFound == FALSE) {
8110e12c:	e0bff817 	ldw	r2,-32(fp)
8110e130:	1000011e 	bne	r2,zero,8110e138 <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8110e134:	1116e880 	call	81116e88 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
8110e138:	00800044 	movi	r2,1
8110e13c:	e0bff915 	stw	r2,-28(fp)
				break;
8110e140:	00000a06 	br	8110e16c <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
8110e144:	d0a05c17 	ldw	r2,-32400(gp)
8110e148:	100f883a 	mov	r7,r2
8110e14c:	01801144 	movi	r6,69
8110e150:	01400044 	movi	r5,1
8110e154:	01204534 	movhi	r4,33044
8110e158:	211d0a04 	addi	r4,r4,29736
8110e15c:	111ba2c0 	call	8111ba2c <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
8110e160:	00800044 	movi	r2,1
8110e164:	e0bff915 	stw	r2,-28(fp)
				break;
8110e168:	0001883a 	nop
		}
	}
8110e16c:	003f4206 	br	8110de78 <__reset+0xfb0ede78>

8110e170 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
8110e170:	defffa04 	addi	sp,sp,-24
8110e174:	de00012e 	bgeu	sp,et,8110e17c <bCheckInAck128+0xc>
8110e178:	003b68fa 	trap	3
8110e17c:	dfc00515 	stw	ra,20(sp)
8110e180:	df000415 	stw	fp,16(sp)
8110e184:	df000404 	addi	fp,sp,16
8110e188:	e13ffe15 	stw	r4,-8(fp)
8110e18c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110e190:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110e194:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110e198:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110e19c:	e0bfff17 	ldw	r2,-4(fp)
8110e1a0:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
8110e1a4:	d0a06817 	ldw	r2,-32352(gp)
8110e1a8:	e0fffd44 	addi	r3,fp,-11
8110e1ac:	180d883a 	mov	r6,r3
8110e1b0:	01400144 	movi	r5,5
8110e1b4:	1009883a 	mov	r4,r2
8110e1b8:	11374600 	call	81137460 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110e1bc:	e0bffd43 	ldbu	r2,-11(fp)
8110e1c0:	10803fcc 	andi	r2,r2,255
8110e1c4:	10000226 	beq	r2,zero,8110e1d0 <bCheckInAck128+0x60>
        return bFound;
8110e1c8:	e0bffc17 	ldw	r2,-16(fp)
8110e1cc:	00003506 	br	8110e2a4 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110e1d0:	e03ffd05 	stb	zero,-12(fp)
8110e1d4:	00002706 	br	8110e274 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
8110e1d8:	e0fffd03 	ldbu	r3,-12(fp)
8110e1dc:	00a045b4 	movhi	r2,33046
8110e1e0:	10a1d404 	addi	r2,r2,-30896
8110e1e4:	18c02324 	muli	r3,r3,140
8110e1e8:	10c5883a 	add	r2,r2,r3
8110e1ec:	10802104 	addi	r2,r2,132
8110e1f0:	10c0000b 	ldhu	r3,0(r2)
8110e1f4:	e0bffe17 	ldw	r2,-8(fp)
8110e1f8:	1080008b 	ldhu	r2,2(r2)
8110e1fc:	18ffffcc 	andi	r3,r3,65535
8110e200:	10bfffcc 	andi	r2,r2,65535
8110e204:	1880181e 	bne	r3,r2,8110e268 <bCheckInAck128+0xf8>
            bFound = TRUE;
8110e208:	00800044 	movi	r2,1
8110e20c:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
8110e210:	e0fffd03 	ldbu	r3,-12(fp)
8110e214:	00a045b4 	movhi	r2,33046
8110e218:	10a1b604 	addi	r2,r2,-31016
8110e21c:	18c7883a 	add	r3,r3,r3
8110e220:	18c7883a 	add	r3,r3,r3
8110e224:	10c5883a 	add	r2,r2,r3
8110e228:	10000015 	stw	zero,0(r2)
            SemCount128++;
8110e22c:	d0a06f43 	ldbu	r2,-32323(gp)
8110e230:	10800044 	addi	r2,r2,1
8110e234:	d0a06f45 	stb	r2,-32323(gp)
            error_code = OSSemPost(xSemCountBuffer128);
8110e238:	d0a05d17 	ldw	r2,-32396(gp)
8110e23c:	1009883a 	mov	r4,r2
8110e240:	11397f40 	call	811397f4 <OSSemPost>
8110e244:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110e248:	e0bffd43 	ldbu	r2,-11(fp)
8110e24c:	10803fcc 	andi	r2,r2,255
8110e250:	10000c26 	beq	r2,zero,8110e284 <bCheckInAck128+0x114>
                SemCount128--;
8110e254:	d0a06f43 	ldbu	r2,-32323(gp)
8110e258:	10bfffc4 	addi	r2,r2,-1
8110e25c:	d0a06f45 	stb	r2,-32323(gp)
                vFailSetCountSemaphorexBuffer128();
8110e260:	1116ce80 	call	81116ce8 <vFailSetCountSemaphorexBuffer128>
            }
            break;
8110e264:	00000706 	br	8110e284 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110e268:	e0bffd03 	ldbu	r2,-12(fp)
8110e26c:	10800044 	addi	r2,r2,1
8110e270:	e0bffd05 	stb	r2,-12(fp)
8110e274:	e0bffd03 	ldbu	r2,-12(fp)
8110e278:	108001b0 	cmpltui	r2,r2,6
8110e27c:	103fd61e 	bne	r2,zero,8110e1d8 <__reset+0xfb0ee1d8>
8110e280:	00000106 	br	8110e288 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
8110e284:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8110e288:	d0a06817 	ldw	r2,-32352(gp)
8110e28c:	1009883a 	mov	r4,r2
8110e290:	1137a040 	call	81137a04 <OSMutexPost>
    (*bFinished) = TRUE;
8110e294:	e0bfff17 	ldw	r2,-4(fp)
8110e298:	00c00044 	movi	r3,1
8110e29c:	10c00015 	stw	r3,0(r2)

    return bFound;
8110e2a0:	e0bffc17 	ldw	r2,-16(fp)
}
8110e2a4:	e037883a 	mov	sp,fp
8110e2a8:	dfc00117 	ldw	ra,4(sp)
8110e2ac:	df000017 	ldw	fp,0(sp)
8110e2b0:	dec00204 	addi	sp,sp,8
8110e2b4:	f800283a 	ret

8110e2b8 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
8110e2b8:	defffa04 	addi	sp,sp,-24
8110e2bc:	de00012e 	bgeu	sp,et,8110e2c4 <bCheckInAck64+0xc>
8110e2c0:	003b68fa 	trap	3
8110e2c4:	dfc00515 	stw	ra,20(sp)
8110e2c8:	df000415 	stw	fp,16(sp)
8110e2cc:	df000404 	addi	fp,sp,16
8110e2d0:	e13ffe15 	stw	r4,-8(fp)
8110e2d4:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110e2d8:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110e2dc:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110e2e0:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110e2e4:	e0bfff17 	ldw	r2,-4(fp)
8110e2e8:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110e2ec:	d0a06b17 	ldw	r2,-32340(gp)
8110e2f0:	e0fffd44 	addi	r3,fp,-11
8110e2f4:	180d883a 	mov	r6,r3
8110e2f8:	01400044 	movi	r5,1
8110e2fc:	1009883a 	mov	r4,r2
8110e300:	11374600 	call	81137460 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110e304:	e0bffd43 	ldbu	r2,-11(fp)
8110e308:	10803fcc 	andi	r2,r2,255
8110e30c:	10000226 	beq	r2,zero,8110e318 <bCheckInAck64+0x60>
        return bFound;
8110e310:	e0bffc17 	ldw	r2,-16(fp)
8110e314:	00003606 	br	8110e3f0 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110e318:	e03ffd05 	stb	zero,-12(fp)
8110e31c:	00002806 	br	8110e3c0 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
8110e320:	e0fffd03 	ldbu	r3,-12(fp)
8110e324:	00a04574 	movhi	r2,33045
8110e328:	10bd9504 	addi	r2,r2,-2476
8110e32c:	18c01324 	muli	r3,r3,76
8110e330:	10c5883a 	add	r2,r2,r3
8110e334:	10801104 	addi	r2,r2,68
8110e338:	10c0000b 	ldhu	r3,0(r2)
8110e33c:	e0bffe17 	ldw	r2,-8(fp)
8110e340:	1080008b 	ldhu	r2,2(r2)
8110e344:	18ffffcc 	andi	r3,r3,65535
8110e348:	10bfffcc 	andi	r2,r2,65535
8110e34c:	1880191e 	bne	r3,r2,8110e3b4 <bCheckInAck64+0xfc>
            bFound = TRUE;
8110e350:	00800044 	movi	r2,1
8110e354:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
8110e358:	e0fffd03 	ldbu	r3,-12(fp)
8110e35c:	00a045b4 	movhi	r2,33046
8110e360:	10a1b604 	addi	r2,r2,-31016
8110e364:	18c00184 	addi	r3,r3,6
8110e368:	18c7883a 	add	r3,r3,r3
8110e36c:	18c7883a 	add	r3,r3,r3
8110e370:	10c5883a 	add	r2,r2,r3
8110e374:	10000015 	stw	zero,0(r2)
            SemCount64++;
8110e378:	d0a06f03 	ldbu	r2,-32324(gp)
8110e37c:	10800044 	addi	r2,r2,1
8110e380:	d0a06f05 	stb	r2,-32324(gp)
            error_code = OSSemPost(xSemCountBuffer64);
8110e384:	d0a05817 	ldw	r2,-32416(gp)
8110e388:	1009883a 	mov	r4,r2
8110e38c:	11397f40 	call	811397f4 <OSSemPost>
8110e390:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110e394:	e0bffd43 	ldbu	r2,-11(fp)
8110e398:	10803fcc 	andi	r2,r2,255
8110e39c:	10000c26 	beq	r2,zero,8110e3d0 <bCheckInAck64+0x118>
                SemCount64--;
8110e3a0:	d0a06f03 	ldbu	r2,-32324(gp)
8110e3a4:	10bfffc4 	addi	r2,r2,-1
8110e3a8:	d0a06f05 	stb	r2,-32324(gp)
                vFailSetCountSemaphorexBuffer64();
8110e3ac:	1116c800 	call	81116c80 <vFailSetCountSemaphorexBuffer64>
            }
            break;
8110e3b0:	00000706 	br	8110e3d0 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110e3b4:	e0bffd03 	ldbu	r2,-12(fp)
8110e3b8:	10800044 	addi	r2,r2,1
8110e3bc:	e0bffd05 	stb	r2,-12(fp)
8110e3c0:	e0bffd03 	ldbu	r2,-12(fp)
8110e3c4:	10800230 	cmpltui	r2,r2,8
8110e3c8:	103fd51e 	bne	r2,zero,8110e320 <__reset+0xfb0ee320>
8110e3cc:	00000106 	br	8110e3d4 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
8110e3d0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
8110e3d4:	d0a06b17 	ldw	r2,-32340(gp)
8110e3d8:	1009883a 	mov	r4,r2
8110e3dc:	1137a040 	call	81137a04 <OSMutexPost>
    (*bFinished) = TRUE;
8110e3e0:	e0bfff17 	ldw	r2,-4(fp)
8110e3e4:	00c00044 	movi	r3,1
8110e3e8:	10c00015 	stw	r3,0(r2)

    return bFound;
8110e3ec:	e0bffc17 	ldw	r2,-16(fp)
}
8110e3f0:	e037883a 	mov	sp,fp
8110e3f4:	dfc00117 	ldw	ra,4(sp)
8110e3f8:	df000017 	ldw	fp,0(sp)
8110e3fc:	dec00204 	addi	sp,sp,8
8110e400:	f800283a 	ret

8110e404 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
8110e404:	defffa04 	addi	sp,sp,-24
8110e408:	de00012e 	bgeu	sp,et,8110e410 <bCheckInAck32+0xc>
8110e40c:	003b68fa 	trap	3
8110e410:	dfc00515 	stw	ra,20(sp)
8110e414:	df000415 	stw	fp,16(sp)
8110e418:	df000404 	addi	fp,sp,16
8110e41c:	e13ffe15 	stw	r4,-8(fp)
8110e420:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110e424:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110e428:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110e42c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110e430:	e0bfff17 	ldw	r2,-4(fp)
8110e434:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110e438:	d0a06617 	ldw	r2,-32360(gp)
8110e43c:	e0fffd44 	addi	r3,fp,-11
8110e440:	180d883a 	mov	r6,r3
8110e444:	01400044 	movi	r5,1
8110e448:	1009883a 	mov	r4,r2
8110e44c:	11374600 	call	81137460 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110e450:	e0bffd43 	ldbu	r2,-11(fp)
8110e454:	10803fcc 	andi	r2,r2,255
8110e458:	10000226 	beq	r2,zero,8110e464 <bCheckInAck32+0x60>
        return bFound;
8110e45c:	e0bffc17 	ldw	r2,-16(fp)
8110e460:	00003606 	br	8110e53c <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110e464:	e03ffd05 	stb	zero,-12(fp)
8110e468:	00002806 	br	8110e50c <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
8110e46c:	e0fffd03 	ldbu	r3,-12(fp)
8110e470:	00a04574 	movhi	r2,33045
8110e474:	108f4204 	addi	r2,r2,15624
8110e478:	18c00b24 	muli	r3,r3,44
8110e47c:	10c5883a 	add	r2,r2,r3
8110e480:	10800904 	addi	r2,r2,36
8110e484:	10c0000b 	ldhu	r3,0(r2)
8110e488:	e0bffe17 	ldw	r2,-8(fp)
8110e48c:	1080008b 	ldhu	r2,2(r2)
8110e490:	18ffffcc 	andi	r3,r3,65535
8110e494:	10bfffcc 	andi	r2,r2,65535
8110e498:	1880191e 	bne	r3,r2,8110e500 <bCheckInAck32+0xfc>
            bFound = TRUE;
8110e49c:	00800044 	movi	r2,1
8110e4a0:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
8110e4a4:	e0fffd03 	ldbu	r3,-12(fp)
8110e4a8:	00a045b4 	movhi	r2,33046
8110e4ac:	10a1b604 	addi	r2,r2,-31016
8110e4b0:	18c00384 	addi	r3,r3,14
8110e4b4:	18c7883a 	add	r3,r3,r3
8110e4b8:	18c7883a 	add	r3,r3,r3
8110e4bc:	10c5883a 	add	r2,r2,r3
8110e4c0:	10000015 	stw	zero,0(r2)
            SemCount32++;
8110e4c4:	d0a06283 	ldbu	r2,-32374(gp)
8110e4c8:	10800044 	addi	r2,r2,1
8110e4cc:	d0a06285 	stb	r2,-32374(gp)
            error_code = OSSemPost(xSemCountBuffer32);
8110e4d0:	d0a06917 	ldw	r2,-32348(gp)
8110e4d4:	1009883a 	mov	r4,r2
8110e4d8:	11397f40 	call	811397f4 <OSSemPost>
8110e4dc:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110e4e0:	e0bffd43 	ldbu	r2,-11(fp)
8110e4e4:	10803fcc 	andi	r2,r2,255
8110e4e8:	10000c26 	beq	r2,zero,8110e51c <bCheckInAck32+0x118>
                SemCount32--;
8110e4ec:	d0a06283 	ldbu	r2,-32374(gp)
8110e4f0:	10bfffc4 	addi	r2,r2,-1
8110e4f4:	d0a06285 	stb	r2,-32374(gp)
                vFailSetCountSemaphorexBuffer32();
8110e4f8:	1116c180 	call	81116c18 <vFailSetCountSemaphorexBuffer32>
            }
            break;
8110e4fc:	00000706 	br	8110e51c <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110e500:	e0bffd03 	ldbu	r2,-12(fp)
8110e504:	10800044 	addi	r2,r2,1
8110e508:	e0bffd05 	stb	r2,-12(fp)
8110e50c:	e0bffd03 	ldbu	r2,-12(fp)
8110e510:	10800230 	cmpltui	r2,r2,8
8110e514:	103fd51e 	bne	r2,zero,8110e46c <__reset+0xfb0ee46c>
8110e518:	00000106 	br	8110e520 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
8110e51c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
8110e520:	d0a06617 	ldw	r2,-32360(gp)
8110e524:	1009883a 	mov	r4,r2
8110e528:	1137a040 	call	81137a04 <OSMutexPost>
    (*bFinished) = TRUE;
8110e52c:	e0bfff17 	ldw	r2,-4(fp)
8110e530:	00c00044 	movi	r3,1
8110e534:	10c00015 	stw	r3,0(r2)

    return bFound;
8110e538:	e0bffc17 	ldw	r2,-16(fp)
}
8110e53c:	e037883a 	mov	sp,fp
8110e540:	dfc00117 	ldw	ra,4(sp)
8110e544:	df000017 	ldw	fp,0(sp)
8110e548:	dec00204 	addi	sp,sp,8
8110e54c:	f800283a 	ret

8110e550 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
8110e550:	defff704 	addi	sp,sp,-36
8110e554:	de00012e 	bgeu	sp,et,8110e55c <vInitialTask+0xc>
8110e558:	003b68fa 	trap	3
8110e55c:	dfc00815 	stw	ra,32(sp)
8110e560:	df000715 	stw	fp,28(sp)
8110e564:	df000704 	addi	fp,sp,28
8110e568:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
8110e56c:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110e570:	d8000415 	stw	zero,16(sp)
8110e574:	d8000315 	stw	zero,12(sp)
8110e578:	00810004 	movi	r2,1024
8110e57c:	d8800215 	stw	r2,8(sp)
8110e580:	00a04574 	movhi	r2,33045
8110e584:	10b59504 	addi	r2,r2,-10668
8110e588:	d8800115 	stw	r2,4(sp)
8110e58c:	00800244 	movi	r2,9
8110e590:	d8800015 	stw	r2,0(sp)
8110e594:	01c00244 	movi	r7,9
8110e598:	01a04574 	movhi	r6,33045
8110e59c:	31b99404 	addi	r6,r6,-6576
8110e5a0:	01604574 	movhi	r5,33045
8110e5a4:	294aa704 	addi	r5,r5,10908
8110e5a8:	01204474 	movhi	r4,33041
8110e5ac:	2131b504 	addi	r4,r4,-14636
8110e5b0:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e5b4:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e5b8:	e0bffe03 	ldbu	r2,-8(fp)
8110e5bc:	10803fcc 	andi	r2,r2,255
8110e5c0:	10000526 	beq	r2,zero,8110e5d8 <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e5c4:	e0bffe03 	ldbu	r2,-8(fp)
8110e5c8:	10803fcc 	andi	r2,r2,255
8110e5cc:	1009883a 	mov	r4,r2
8110e5d0:	11165940 	call	81116594 <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
8110e5d4:	1117a400 	call	81117a40 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110e5d8:	01c17704 	movi	r7,1500
8110e5dc:	000d883a 	mov	r6,zero
8110e5e0:	000b883a 	mov	r5,zero
8110e5e4:	0009883a 	mov	r4,zero
8110e5e8:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
8110e5ec:	d8000415 	stw	zero,16(sp)
8110e5f0:	d8000315 	stw	zero,12(sp)
8110e5f4:	00810004 	movi	r2,1024
8110e5f8:	d8800215 	stw	r2,8(sp)
8110e5fc:	00a04574 	movhi	r2,33045
8110e600:	10869504 	addi	r2,r2,6740
8110e604:	d8800115 	stw	r2,4(sp)
8110e608:	00800204 	movi	r2,8
8110e60c:	d8800015 	stw	r2,0(sp)
8110e610:	01c00204 	movi	r7,8
8110e614:	01a04574 	movhi	r6,33045
8110e618:	318a9404 	addi	r6,r6,10832
8110e61c:	01604574 	movhi	r5,33045
8110e620:	294a9f04 	addi	r5,r5,10876
8110e624:	01204474 	movhi	r4,33041
8110e628:	21318d04 	addi	r4,r4,-14796
8110e62c:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e630:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e634:	e0bffe03 	ldbu	r2,-8(fp)
8110e638:	10803fcc 	andi	r2,r2,255
8110e63c:	10000526 	beq	r2,zero,8110e654 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e640:	e0bffe03 	ldbu	r2,-8(fp)
8110e644:	10803fcc 	andi	r2,r2,255
8110e648:	1009883a 	mov	r4,r2
8110e64c:	11165940 	call	81116594 <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
8110e650:	1117d180 	call	81117d18 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110e654:	01c17704 	movi	r7,1500
8110e658:	000d883a 	mov	r6,zero
8110e65c:	000b883a 	mov	r5,zero
8110e660:	0009883a 	mov	r4,zero
8110e664:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
8110e668:	d8000415 	stw	zero,16(sp)
8110e66c:	d8000315 	stw	zero,12(sp)
8110e670:	00810004 	movi	r2,1024
8110e674:	d8800215 	stw	r2,8(sp)
8110e678:	00a045b4 	movhi	r2,33046
8110e67c:	10a2ba04 	addi	r2,r2,-29976
8110e680:	d8800115 	stw	r2,4(sp)
8110e684:	008001c4 	movi	r2,7
8110e688:	d8800015 	stw	r2,0(sp)
8110e68c:	01c001c4 	movi	r7,7
8110e690:	01a045b4 	movhi	r6,33046
8110e694:	31a6b904 	addi	r6,r6,-25884
8110e698:	01604574 	movhi	r5,33045
8110e69c:	294aa704 	addi	r5,r5,10908
8110e6a0:	01204474 	movhi	r4,33041
8110e6a4:	213ab504 	addi	r4,r4,-5420
8110e6a8:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e6ac:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e6b0:	e0bffe03 	ldbu	r2,-8(fp)
8110e6b4:	10803fcc 	andi	r2,r2,255
8110e6b8:	10000526 	beq	r2,zero,8110e6d0 <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e6bc:	e0bffe03 	ldbu	r2,-8(fp)
8110e6c0:	10803fcc 	andi	r2,r2,255
8110e6c4:	1009883a 	mov	r4,r2
8110e6c8:	11165940 	call	81116594 <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
8110e6cc:	1117cb00 	call	81117cb0 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110e6d0:	01c17704 	movi	r7,1500
8110e6d4:	000d883a 	mov	r6,zero
8110e6d8:	000b883a 	mov	r5,zero
8110e6dc:	0009883a 	mov	r4,zero
8110e6e0:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
8110e6e4:	d8000415 	stw	zero,16(sp)
8110e6e8:	d8000315 	stw	zero,12(sp)
8110e6ec:	00810004 	movi	r2,1024
8110e6f0:	d8800215 	stw	r2,8(sp)
8110e6f4:	00a045b4 	movhi	r2,33046
8110e6f8:	10b4cc04 	addi	r2,r2,-11472
8110e6fc:	d8800115 	stw	r2,4(sp)
8110e700:	00800184 	movi	r2,6
8110e704:	d8800015 	stw	r2,0(sp)
8110e708:	01c00184 	movi	r7,6
8110e70c:	01a045b4 	movhi	r6,33046
8110e710:	31b8cb04 	addi	r6,r6,-7380
8110e714:	01604574 	movhi	r5,33045
8110e718:	294a9504 	addi	r5,r5,10836
8110e71c:	01204474 	movhi	r4,33041
8110e720:	21041904 	addi	r4,r4,4196
8110e724:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e728:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e72c:	e0bffe03 	ldbu	r2,-8(fp)
8110e730:	10803fcc 	andi	r2,r2,255
8110e734:	10000526 	beq	r2,zero,8110e74c <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e738:	e0bffe03 	ldbu	r2,-8(fp)
8110e73c:	10803fcc 	andi	r2,r2,255
8110e740:	1009883a 	mov	r4,r2
8110e744:	11165940 	call	81116594 <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
8110e748:	1117d800 	call	81117d80 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110e74c:	01c17704 	movi	r7,1500
8110e750:	000d883a 	mov	r6,zero
8110e754:	000b883a 	mov	r5,zero
8110e758:	0009883a 	mov	r4,zero
8110e75c:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
8110e760:	d8000415 	stw	zero,16(sp)
8110e764:	d8000315 	stw	zero,12(sp)
8110e768:	00810004 	movi	r2,1024
8110e76c:	d8800215 	stw	r2,8(sp)
8110e770:	00a04574 	movhi	r2,33045
8110e774:	10829504 	addi	r2,r2,2644
8110e778:	d8800115 	stw	r2,4(sp)
8110e77c:	00800784 	movi	r2,30
8110e780:	d8800015 	stw	r2,0(sp)
8110e784:	01c00784 	movi	r7,30
8110e788:	01a04574 	movhi	r6,33045
8110e78c:	31869404 	addi	r6,r6,6736
8110e790:	000b883a 	mov	r5,zero
8110e794:	01204474 	movhi	r4,33041
8110e798:	210aa404 	addi	r4,r4,10896
8110e79c:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e7a0:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e7a4:	e0bffe03 	ldbu	r2,-8(fp)
8110e7a8:	10803fcc 	andi	r2,r2,255
8110e7ac:	10000526 	beq	r2,zero,8110e7c4 <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e7b0:	e0bffe03 	ldbu	r2,-8(fp)
8110e7b4:	10803fcc 	andi	r2,r2,255
8110e7b8:	1009883a 	mov	r4,r2
8110e7bc:	11165940 	call	81116594 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
8110e7c0:	11173ac0 	call	811173ac <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e7c4:	01c03204 	movi	r7,200
8110e7c8:	000d883a 	mov	r6,zero
8110e7cc:	000b883a 	mov	r5,zero
8110e7d0:	0009883a 	mov	r4,zero
8110e7d4:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
8110e7d8:	d8000415 	stw	zero,16(sp)
8110e7dc:	d8000315 	stw	zero,12(sp)
8110e7e0:	00810004 	movi	r2,1024
8110e7e4:	d8800215 	stw	r2,8(sp)
8110e7e8:	00a04574 	movhi	r2,33045
8110e7ec:	1095aa04 	addi	r2,r2,22184
8110e7f0:	d8800115 	stw	r2,4(sp)
8110e7f4:	008006c4 	movi	r2,27
8110e7f8:	d8800015 	stw	r2,0(sp)
8110e7fc:	01c006c4 	movi	r7,27
8110e800:	01a04574 	movhi	r6,33045
8110e804:	3199a904 	addi	r6,r6,26276
8110e808:	000b883a 	mov	r5,zero
8110e80c:	01204474 	movhi	r4,33041
8110e810:	213c5f04 	addi	r4,r4,-3716
8110e814:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e818:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e81c:	e0bffe03 	ldbu	r2,-8(fp)
8110e820:	10803fcc 	andi	r2,r2,255
8110e824:	10000526 	beq	r2,zero,8110e83c <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e828:	e0bffe03 	ldbu	r2,-8(fp)
8110e82c:	10803fcc 	andi	r2,r2,255
8110e830:	1009883a 	mov	r4,r2
8110e834:	11165940 	call	81116594 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
8110e838:	11172c80 	call	811172c8 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e83c:	01c03204 	movi	r7,200
8110e840:	000d883a 	mov	r6,zero
8110e844:	000b883a 	mov	r5,zero
8110e848:	0009883a 	mov	r4,zero
8110e84c:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
8110e850:	d8000415 	stw	zero,16(sp)
8110e854:	d8000315 	stw	zero,12(sp)
8110e858:	00810004 	movi	r2,1024
8110e85c:	d8800215 	stw	r2,8(sp)
8110e860:	00a04574 	movhi	r2,33045
8110e864:	10b99504 	addi	r2,r2,-6572
8110e868:	d8800115 	stw	r2,4(sp)
8110e86c:	00800644 	movi	r2,25
8110e870:	d8800015 	stw	r2,0(sp)
8110e874:	01c00644 	movi	r7,25
8110e878:	01a04574 	movhi	r6,33045
8110e87c:	31bd9404 	addi	r6,r6,-2480
8110e880:	000b883a 	mov	r5,zero
8110e884:	01204474 	movhi	r4,33041
8110e888:	21378804 	addi	r4,r4,-8672
8110e88c:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e890:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e894:	e0bffe03 	ldbu	r2,-8(fp)
8110e898:	10803fcc 	andi	r2,r2,255
8110e89c:	10000526 	beq	r2,zero,8110e8b4 <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e8a0:	e0bffe03 	ldbu	r2,-8(fp)
8110e8a4:	10803fcc 	andi	r2,r2,255
8110e8a8:	1009883a 	mov	r4,r2
8110e8ac:	11165940 	call	81116594 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
8110e8b0:	111727c0 	call	8111727c <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e8b4:	01c03204 	movi	r7,200
8110e8b8:	000d883a 	mov	r6,zero
8110e8bc:	000b883a 	mov	r5,zero
8110e8c0:	0009883a 	mov	r4,zero
8110e8c4:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
8110e8c8:	d8000415 	stw	zero,16(sp)
8110e8cc:	d8000315 	stw	zero,12(sp)
8110e8d0:	00818004 	movi	r2,1536
8110e8d4:	d8800215 	stw	r2,8(sp)
8110e8d8:	00a045b4 	movhi	r2,33046
8110e8dc:	10aec804 	addi	r2,r2,-17632
8110e8e0:	d8800115 	stw	r2,4(sp)
8110e8e4:	00800704 	movi	r2,28
8110e8e8:	d8800015 	stw	r2,0(sp)
8110e8ec:	01c00704 	movi	r7,28
8110e8f0:	01a045b4 	movhi	r6,33046
8110e8f4:	31b4c704 	addi	r6,r6,-11492
8110e8f8:	000b883a 	mov	r5,zero
8110e8fc:	01204474 	movhi	r4,33041
8110e900:	213d1d04 	addi	r4,r4,-2956
8110e904:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e908:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e90c:	e0bffe03 	ldbu	r2,-8(fp)
8110e910:	10803fcc 	andi	r2,r2,255
8110e914:	10000526 	beq	r2,zero,8110e92c <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e918:	e0bffe03 	ldbu	r2,-8(fp)
8110e91c:	10803fcc 	andi	r2,r2,255
8110e920:	1009883a 	mov	r4,r2
8110e924:	11165940 	call	81116594 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
8110e928:	11172300 	call	81117230 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e92c:	01c03204 	movi	r7,200
8110e930:	000d883a 	mov	r6,zero
8110e934:	000b883a 	mov	r5,zero
8110e938:	0009883a 	mov	r4,zero
8110e93c:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
8110e940:	d8000415 	stw	zero,16(sp)
8110e944:	d8000315 	stw	zero,12(sp)
8110e948:	00818004 	movi	r2,1536
8110e94c:	d8800215 	stw	r2,8(sp)
8110e950:	00a04574 	movhi	r2,33045
8110e954:	108f9a04 	addi	r2,r2,15976
8110e958:	d8800115 	stw	r2,4(sp)
8110e95c:	00800804 	movi	r2,32
8110e960:	d8800015 	stw	r2,0(sp)
8110e964:	01c00804 	movi	r7,32
8110e968:	01a04574 	movhi	r6,33045
8110e96c:	31959904 	addi	r6,r6,22116
8110e970:	000b883a 	mov	r5,zero
8110e974:	01204474 	movhi	r4,33041
8110e978:	21013904 	addi	r4,r4,1252
8110e97c:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e980:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e984:	e0bffe03 	ldbu	r2,-8(fp)
8110e988:	10803fcc 	andi	r2,r2,255
8110e98c:	10000526 	beq	r2,zero,8110e9a4 <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110e990:	e0bffe03 	ldbu	r2,-8(fp)
8110e994:	10803fcc 	andi	r2,r2,255
8110e998:	1009883a 	mov	r4,r2
8110e99c:	11165940 	call	81116594 <printErrorTask>
		#endif
		vFailReceiverCreate();
8110e9a0:	1116b340 	call	81116b34 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e9a4:	01c03204 	movi	r7,200
8110e9a8:	000d883a 	mov	r6,zero
8110e9ac:	000b883a 	mov	r5,zero
8110e9b0:	0009883a 	mov	r4,zero
8110e9b4:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
8110e9b8:	d8000415 	stw	zero,16(sp)
8110e9bc:	d8000315 	stw	zero,12(sp)
8110e9c0:	00810004 	movi	r2,1024
8110e9c4:	d8800215 	stw	r2,8(sp)
8110e9c8:	00a04574 	movhi	r2,33045
8110e9cc:	10be8904 	addi	r2,r2,-1500
8110e9d0:	d8800115 	stw	r2,4(sp)
8110e9d4:	00800684 	movi	r2,26
8110e9d8:	d8800015 	stw	r2,0(sp)
8110e9dc:	01c00684 	movi	r7,26
8110e9e0:	01a04574 	movhi	r6,33045
8110e9e4:	31828804 	addi	r6,r6,2592
8110e9e8:	000b883a 	mov	r5,zero
8110e9ec:	01204474 	movhi	r4,33041
8110e9f0:	2103bb04 	addi	r4,r4,3820
8110e9f4:	113a0240 	call	8113a024 <OSTaskCreateExt>
8110e9f8:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
8110e9fc:	01c03204 	movi	r7,200
8110ea00:	000d883a 	mov	r6,zero
8110ea04:	000b883a 	mov	r5,zero
8110ea08:	0009883a 	mov	r4,zero
8110ea0c:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
8110ea10:	e0bffe03 	ldbu	r2,-8(fp)
8110ea14:	10803fcc 	andi	r2,r2,255
8110ea18:	10000526 	beq	r2,zero,8110ea30 <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110ea1c:	e0bffe03 	ldbu	r2,-8(fp)
8110ea20:	10803fcc 	andi	r2,r2,255
8110ea24:	1009883a 	mov	r4,r2
8110ea28:	11165940 	call	81116594 <printErrorTask>
		#endif
		vFailSenderCreate();
8110ea2c:	1116b800 	call	81116b80 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8110ea30:	d0a06717 	ldw	r2,-32356(gp)
8110ea34:	e17ffe04 	addi	r5,fp,-8
8110ea38:	1009883a 	mov	r4,r2
8110ea3c:	113bd440 	call	8113bd44 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8110ea40:	e0bffe03 	ldbu	r2,-8(fp)
8110ea44:	10803fcc 	andi	r2,r2,255
8110ea48:	10000126 	beq	r2,zero,8110ea50 <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8110ea4c:	11176680 	call	81117668 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8110ea50:	01c00084 	movi	r7,2
8110ea54:	01800784 	movi	r6,30
8110ea58:	000b883a 	mov	r5,zero
8110ea5c:	0009883a 	mov	r4,zero
8110ea60:	113b2500 	call	8113b250 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
8110ea64:	01003fc4 	movi	r4,255
8110ea68:	113a2100 	call	8113a210 <OSTaskDel>
8110ea6c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
8110ea70:	e0bffe03 	ldbu	r2,-8(fp)
8110ea74:	10803fcc 	andi	r2,r2,255
8110ea78:	10001026 	beq	r2,zero,8110eabc <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110ea7c:	e0bffe03 	ldbu	r2,-8(fp)
8110ea80:	10803fcc 	andi	r2,r2,255
8110ea84:	1009883a 	mov	r4,r2
8110ea88:	11165940 	call	81116594 <printErrorTask>
		#endif
		vFailDeleteInitialization();
8110ea8c:	1116bcc0 	call	81116bcc <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
8110ea90:	014009c4 	movi	r5,39
8110ea94:	01000044 	movi	r4,1
8110ea98:	1139b2c0 	call	81139b2c <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8110ea9c:	01003fc4 	movi	r4,255
8110eaa0:	113a2100 	call	8113a210 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
8110eaa4:	000f883a 	mov	r7,zero
8110eaa8:	01800284 	movi	r6,10
8110eaac:	000b883a 	mov	r5,zero
8110eab0:	0009883a 	mov	r4,zero
8110eab4:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
		}
8110eab8:	003ff806 	br	8110ea9c <__reset+0xfb0eea9c>
	}

}
8110eabc:	0001883a 	nop
8110eac0:	e037883a 	mov	sp,fp
8110eac4:	dfc00117 	ldw	ra,4(sp)
8110eac8:	df000017 	ldw	fp,0(sp)
8110eacc:	dec00204 	addi	sp,sp,8
8110ead0:	f800283a 	ret

8110ead4 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8110ead4:	defff704 	addi	sp,sp,-36
8110ead8:	de00012e 	bgeu	sp,et,8110eae0 <vNFeeControlTask+0xc>
8110eadc:	003b68fa 	trap	3
8110eae0:	dfc00815 	stw	ra,32(sp)
8110eae4:	df000715 	stw	fp,28(sp)
8110eae8:	df000704 	addi	fp,sp,28
8110eaec:	e13fff15 	stw	r4,-4(fp)
	INT8U error_codeCtrl;
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
8110eaf0:	e0bfff17 	ldw	r2,-4(fp)
8110eaf4:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
8110eaf8:	d0a05c17 	ldw	r2,-32400(gp)
8110eafc:	100f883a 	mov	r7,r2
8110eb00:	01800804 	movi	r6,32
8110eb04:	01400044 	movi	r5,1
8110eb08:	01204534 	movhi	r4,33044
8110eb0c:	211d1c04 	addi	r4,r4,29808
8110eb10:	111ba2c0 	call	8111ba2c <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
8110eb14:	e0bffa17 	ldw	r2,-24(fp)
8110eb18:	10809917 	ldw	r2,612(r2)
8110eb1c:	10c00168 	cmpgeui	r3,r2,5
8110eb20:	1800da1e 	bne	r3,zero,8110ee8c <vNFeeControlTask+0x3b8>
8110eb24:	100690ba 	slli	r3,r2,2
8110eb28:	00a04474 	movhi	r2,33041
8110eb2c:	10bacf04 	addi	r2,r2,-5316
8110eb30:	1885883a 	add	r2,r3,r2
8110eb34:	10800017 	ldw	r2,0(r2)
8110eb38:	1000683a 	jmp	r2
8110eb3c:	8110eb50 	cmplti	r4,r16,17325
8110eb40:	8110eb8c 	andi	r4,r16,17326
8110eb44:	8110ebe0 	cmpeqi	r4,r16,17327
8110eb48:	8110ec94 	ori	r4,r16,17330
8110eb4c:	8110ed10 	cmplti	r4,r16,17332
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
8110eb50:	d0a06a17 	ldw	r2,-32344(gp)
8110eb54:	1009883a 	mov	r4,r2
8110eb58:	11384b40 	call	811384b4 <OSQFlush>
8110eb5c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110eb60:	e0bffe03 	ldbu	r2,-8(fp)
8110eb64:	10803fcc 	andi	r2,r2,255
8110eb68:	10000126 	beq	r2,zero,8110eb70 <vNFeeControlTask+0x9c>
					vFailFlushQueue();
8110eb6c:	11182740 	call	81118274 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
8110eb70:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
8110eb74:	00800044 	movi	r2,1
8110eb78:	d0a05315 	stw	r2,-32436(gp)
				pxFeeC->sMode = sMebToConfig;
8110eb7c:	e0bffa17 	ldw	r2,-24(fp)
8110eb80:	00c00044 	movi	r3,1
8110eb84:	10c09915 	stw	r3,612(r2)
				break;
8110eb88:	0000cc06 	br	8110eebc <vNFeeControlTask+0x3e8>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
8110eb8c:	d0a05c17 	ldw	r2,-32400(gp)
8110eb90:	100f883a 	mov	r7,r2
8110eb94:	018008c4 	movi	r6,35
8110eb98:	01400044 	movi	r5,1
8110eb9c:	01204534 	movhi	r4,33044
8110eba0:	211d2504 	addi	r4,r4,29844
8110eba4:	111ba2c0 	call	8111ba2c <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8110eba8:	d0a05717 	ldw	r2,-32420(gp)
8110ebac:	1009883a 	mov	r4,r2
8110ebb0:	11384b40 	call	811384b4 <OSQFlush>
8110ebb4:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110ebb8:	e0bffe03 	ldbu	r2,-8(fp)
8110ebbc:	10803fcc 	andi	r2,r2,255
8110ebc0:	10000126 	beq	r2,zero,8110ebc8 <vNFeeControlTask+0xf4>
					vFailFlushQueue();
8110ebc4:	11182740 	call	81118274 <vFailFlushQueue>
				}

				pxFeeC->ucTimeCode = 0;
8110ebc8:	e0bffa17 	ldw	r2,-24(fp)
8110ebcc:	10009805 	stb	zero,608(r2)
				pxFeeC->sMode = sMebConfig;
8110ebd0:	e0bffa17 	ldw	r2,-24(fp)
8110ebd4:	00c000c4 	movi	r3,3
8110ebd8:	10c09915 	stw	r3,612(r2)
				break;
8110ebdc:	0000b706 	br	8110eebc <vNFeeControlTask+0x3e8>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
8110ebe0:	11183cc0 	call	811183cc <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
8110ebe4:	d0a05c17 	ldw	r2,-32400(gp)
8110ebe8:	100f883a 	mov	r7,r2
8110ebec:	01800804 	movi	r6,32
8110ebf0:	01400044 	movi	r5,1
8110ebf4:	01204534 	movhi	r4,33044
8110ebf8:	211d2e04 	addi	r4,r4,29880
8110ebfc:	111ba2c0 	call	8111ba2c <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8110ec00:	d0a05717 	ldw	r2,-32420(gp)
8110ec04:	1009883a 	mov	r4,r2
8110ec08:	11384b40 	call	811384b4 <OSQFlush>
8110ec0c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110ec10:	e0bffe03 	ldbu	r2,-8(fp)
8110ec14:	10803fcc 	andi	r2,r2,255
8110ec18:	10000126 	beq	r2,zero,8110ec20 <vNFeeControlTask+0x14c>
					vFailFlushQueue();
8110ec1c:	11182740 	call	81118274 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8110ec20:	e03ff905 	stb	zero,-28(fp)
8110ec24:	00001006 	br	8110ec68 <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
8110ec28:	e0bff903 	ldbu	r2,-28(fp)
8110ec2c:	1085883a 	add	r2,r2,r2
8110ec30:	1087883a 	add	r3,r2,r2
8110ec34:	d0a06404 	addi	r2,gp,-32368
8110ec38:	1885883a 	add	r2,r3,r2
8110ec3c:	10800017 	ldw	r2,0(r2)
8110ec40:	1009883a 	mov	r4,r2
8110ec44:	11384b40 	call	811384b4 <OSQFlush>
8110ec48:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
8110ec4c:	e0bffe03 	ldbu	r2,-8(fp)
8110ec50:	10803fcc 	andi	r2,r2,255
8110ec54:	10000126 	beq	r2,zero,8110ec5c <vNFeeControlTask+0x188>
						vFailFlushQueue();
8110ec58:	11182740 	call	81118274 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8110ec5c:	e0bff903 	ldbu	r2,-28(fp)
8110ec60:	10800044 	addi	r2,r2,1
8110ec64:	e0bff905 	stb	r2,-28(fp)
8110ec68:	e0bff903 	ldbu	r2,-28(fp)
8110ec6c:	103fee26 	beq	r2,zero,8110ec28 <__reset+0xfb0eec28>
						vFailFlushQueue();
					}
				}


				pxFeeC->ucTimeCode = 0;
8110ec70:	e0bffa17 	ldw	r2,-24(fp)
8110ec74:	10009805 	stb	zero,608(r2)

				bCmdSent = FALSE;
8110ec78:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
8110ec7c:	00800044 	movi	r2,1
8110ec80:	d0a05315 	stw	r2,-32436(gp)
				pxFeeC->sMode = sMebRun;
8110ec84:	e0bffa17 	ldw	r2,-24(fp)
8110ec88:	00c00104 	movi	r3,4
8110ec8c:	10c09915 	stw	r3,612(r2)
				break;
8110ec90:	00008a06 	br	8110eebc <vNFeeControlTask+0x3e8>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
8110ec94:	d0a06a17 	ldw	r2,-32344(gp)
8110ec98:	e0fffe04 	addi	r3,fp,-8
8110ec9c:	180d883a 	mov	r6,r3
8110eca0:	000b883a 	mov	r5,zero
8110eca4:	1009883a 	mov	r4,r2
8110eca8:	11385740 	call	81138574 <OSQPend>
8110ecac:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
8110ecb0:	e0bffe03 	ldbu	r2,-8(fp)
8110ecb4:	10803fcc 	andi	r2,r2,255
8110ecb8:	1000131e 	bne	r2,zero,8110ed08 <vNFeeControlTask+0x234>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110ecbc:	e0bffdc3 	ldbu	r2,-9(fp)
8110ecc0:	10803fcc 	andi	r2,r2,255
8110ecc4:	10800418 	cmpnei	r2,r2,16
8110ecc8:	1000051e 	bne	r2,zero,8110ece0 <vNFeeControlTask+0x20c>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8110eccc:	e0bffd17 	ldw	r2,-12(fp)
8110ecd0:	e17ffa17 	ldw	r5,-24(fp)
8110ecd4:	1009883a 	mov	r4,r2
8110ecd8:	110eec00 	call	8110eec0 <vPerformActionNFCConfig>
8110ecdc:	00000706 	br	8110ecfc <vNFeeControlTask+0x228>

					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"Provavel para FEE (Remover)\n");
8110ece0:	d0a05c17 	ldw	r2,-32400(gp)
8110ece4:	100f883a 	mov	r7,r2
8110ece8:	01800704 	movi	r6,28
8110ecec:	01400044 	movi	r5,1
8110ecf0:	01204534 	movhi	r4,33044
8110ecf4:	211d3704 	addi	r4,r4,29916
8110ecf8:	111ba2c0 	call	8111ba2c <fwrite>
						#endif
					}

					bDmaBack = TRUE;
8110ecfc:	00800044 	movi	r2,1
8110ed00:	d0a05315 	stw	r2,-32436(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
8110ed04:	00006d06 	br	8110eebc <vNFeeControlTask+0x3e8>
					}

					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8110ed08:	11180180 	call	81118018 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
8110ed0c:	00006b06 	br	8110eebc <vNFeeControlTask+0x3e8>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
8110ed10:	d0a05317 	ldw	r2,-32436(gp)
8110ed14:	10800058 	cmpnei	r2,r2,1
8110ed18:	1000201e 	bne	r2,zero,8110ed9c <vNFeeControlTask+0x2c8>
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 2, &error_codeCtrl);
8110ed1c:	d0a05717 	ldw	r2,-32420(gp)
8110ed20:	e0fffe04 	addi	r3,fp,-8
8110ed24:	180d883a 	mov	r6,r3
8110ed28:	01400084 	movi	r5,2
8110ed2c:	1009883a 	mov	r4,r2
8110ed30:	11385740 	call	81138574 <OSQPend>
8110ed34:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
8110ed38:	e0bffe03 	ldbu	r2,-8(fp)
8110ed3c:	10803fcc 	andi	r2,r2,255
8110ed40:	1000161e 	bne	r2,zero,8110ed9c <vNFeeControlTask+0x2c8>
						ucFeeInstL = uiCmdNFC.ucByte[0];
8110ed44:	e0bffd03 	ldbu	r2,-12(fp)
8110ed48:	e0bffc05 	stb	r2,-16(fp)
						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
8110ed4c:	e0bffc03 	ldbu	r2,-16(fp)
8110ed50:	e0fffa17 	ldw	r3,-24(fp)
8110ed54:	10809524 	muli	r2,r2,596
8110ed58:	1885883a 	add	r2,r3,r2
8110ed5c:	10802304 	addi	r2,r2,140
8110ed60:	10800017 	ldw	r2,0(r2)
8110ed64:	10800058 	cmpnei	r2,r2,1
8110ed68:	10000c1e 	bne	r2,zero,8110ed9c <vNFeeControlTask+0x2c8>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
8110ed6c:	e0bffc03 	ldbu	r2,-16(fp)
8110ed70:	e0fffc03 	ldbu	r3,-16(fp)
8110ed74:	180f883a 	mov	r7,r3
8110ed78:	000d883a 	mov	r6,zero
8110ed7c:	014023c4 	movi	r5,143
8110ed80:	1009883a 	mov	r4,r2
8110ed84:	110f0b40 	call	8110f0b4 <bSendCmdQToNFeeInst>
8110ed88:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE )
8110ed8c:	e0bffb17 	ldw	r2,-20(fp)
8110ed90:	10800058 	cmpnei	r2,r2,1
8110ed94:	1000011e 	bne	r2,zero,8110ed9c <vNFeeControlTask+0x2c8>
								bDmaBack = FALSE;
8110ed98:	d0205315 	stw	zero,-32436(gp)
						}
					}
				} 

				if ( bDmaBack == FALSE )
8110ed9c:	d0a05317 	ldw	r2,-32436(gp)
8110eda0:	1000081e 	bne	r2,zero,8110edc4 <vNFeeControlTask+0x2f0>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
8110eda4:	d0a06a17 	ldw	r2,-32344(gp)
8110eda8:	e0fffe04 	addi	r3,fp,-8
8110edac:	180d883a 	mov	r6,r3
8110edb0:	000b883a 	mov	r5,zero
8110edb4:	1009883a 	mov	r4,r2
8110edb8:	11385740 	call	81138574 <OSQPend>
8110edbc:	e0bffd15 	stw	r2,-12(fp)
8110edc0:	00000706 	br	8110ede0 <vNFeeControlTask+0x30c>
				else
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 2, &error_codeCtrl);
8110edc4:	d0a06a17 	ldw	r2,-32344(gp)
8110edc8:	e0fffe04 	addi	r3,fp,-8
8110edcc:	180d883a 	mov	r6,r3
8110edd0:	01400084 	movi	r5,2
8110edd4:	1009883a 	mov	r4,r2
8110edd8:	11385740 	call	81138574 <OSQPend>
8110eddc:	e0bffd15 	stw	r2,-12(fp)

				if ( error_codeCtrl == OS_ERR_NONE ){
8110ede0:	e0bffe03 	ldbu	r2,-8(fp)
8110ede4:	10803fcc 	andi	r2,r2,255
8110ede8:	1000331e 	bne	r2,zero,8110eeb8 <vNFeeControlTask+0x3e4>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
8110edec:	e0bffd83 	ldbu	r2,-10(fp)
8110edf0:	10803fcc 	andi	r2,r2,255
8110edf4:	10802058 	cmpnei	r2,r2,129
8110edf8:	1000031e 	bne	r2,zero,8110ee08 <vNFeeControlTask+0x334>
						bDmaBack = TRUE;
8110edfc:	00800044 	movi	r2,1
8110ee00:	d0a05315 	stw	r2,-32436(gp)
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110ee04:	00002c06 	br	8110eeb8 <vNFeeControlTask+0x3e4>
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
						bDmaBack = TRUE;
					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110ee08:	e0bffdc3 	ldbu	r2,-9(fp)
8110ee0c:	10803fcc 	andi	r2,r2,255
8110ee10:	10800418 	cmpnei	r2,r2,16
8110ee14:	1000051e 	bne	r2,zero,8110ee2c <vNFeeControlTask+0x358>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
8110ee18:	e0bffd17 	ldw	r2,-12(fp)
8110ee1c:	e17ffa17 	ldw	r5,-24(fp)
8110ee20:	1009883a 	mov	r4,r2
8110ee24:	110ef880 	call	8110ef88 <vPerformActionNFCRunning>
8110ee28:	00001606 	br	8110ee84 <vNFeeControlTask+0x3b0>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
8110ee2c:	e0bffdc3 	ldbu	r2,-9(fp)
8110ee30:	10803fcc 	andi	r2,r2,255
8110ee34:	10800470 	cmpltui	r2,r2,17
8110ee38:	1000121e 	bne	r2,zero,8110ee84 <vNFeeControlTask+0x3b0>
8110ee3c:	e0bffdc3 	ldbu	r2,-9(fp)
8110ee40:	10803fcc 	andi	r2,r2,255
8110ee44:	108004e8 	cmpgeui	r2,r2,19
8110ee48:	10000e1e 	bne	r2,zero,8110ee84 <vNFeeControlTask+0x3b0>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
8110ee4c:	e0bffdc3 	ldbu	r2,-9(fp)
8110ee50:	10bffbc4 	addi	r2,r2,-17
8110ee54:	10803fcc 	andi	r2,r2,255
8110ee58:	e0fffd83 	ldbu	r3,-10(fp)
8110ee5c:	18c03fcc 	andi	r3,r3,255
8110ee60:	e13ffd43 	ldbu	r4,-11(fp)
8110ee64:	21003fcc 	andi	r4,r4,255
8110ee68:	e17ffd03 	ldbu	r5,-12(fp)
8110ee6c:	29403fcc 	andi	r5,r5,255
8110ee70:	280f883a 	mov	r7,r5
8110ee74:	200d883a 	mov	r6,r4
8110ee78:	180b883a 	mov	r5,r3
8110ee7c:	1009883a 	mov	r4,r2
8110ee80:	110f0b40 	call	8110f0b4 <bSendCmdQToNFeeInst>

							}
						}
						bDmaBack = FALSE;
8110ee84:	d0205315 	stw	zero,-32436(gp)
					}
				}
				
				break;		
8110ee88:	00000b06 	br	8110eeb8 <vNFeeControlTask+0x3e4>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
8110ee8c:	d0a05c17 	ldw	r2,-32400(gp)
8110ee90:	100f883a 	mov	r7,r2
8110ee94:	01800f44 	movi	r6,61
8110ee98:	01400044 	movi	r5,1
8110ee9c:	01204534 	movhi	r4,33044
8110eea0:	211d3f04 	addi	r4,r4,29948
8110eea4:	111ba2c0 	call	8111ba2c <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
8110eea8:	e0bffa17 	ldw	r2,-24(fp)
8110eeac:	00c000c4 	movi	r3,3
8110eeb0:	10c09915 	stw	r3,612(r2)
				break;
8110eeb4:	00000106 	br	8110eebc <vNFeeControlTask+0x3e8>
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110eeb8:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
8110eebc:	003f1506 	br	8110eb14 <__reset+0xfb0eeb14>

8110eec0 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110eec0:	defffb04 	addi	sp,sp,-20
8110eec4:	de00012e 	bgeu	sp,et,8110eecc <vPerformActionNFCConfig+0xc>
8110eec8:	003b68fa 	trap	3
8110eecc:	dfc00415 	stw	ra,16(sp)
8110eed0:	df000315 	stw	fp,12(sp)
8110eed4:	df000304 	addi	fp,sp,12
8110eed8:	e13ffe15 	stw	r4,-8(fp)
8110eedc:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
8110eee0:	e0bffe17 	ldw	r2,-8(fp)
8110eee4:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110eee8:	e0bffd83 	ldbu	r2,-10(fp)
8110eeec:	10803fcc 	andi	r2,r2,255
8110eef0:	10c000a0 	cmpeqi	r3,r2,2
8110eef4:	1800121e 	bne	r3,zero,8110ef40 <vPerformActionNFCConfig+0x80>
8110eef8:	10c000c8 	cmpgei	r3,r2,3
8110eefc:	1800031e 	bne	r3,zero,8110ef0c <vPerformActionNFCConfig+0x4c>
8110ef00:	10800060 	cmpeqi	r2,r2,1
8110ef04:	1000061e 	bne	r2,zero,8110ef20 <vPerformActionNFCConfig+0x60>
8110ef08:	00001106 	br	8110ef50 <vPerformActionNFCConfig+0x90>
8110ef0c:	10c02860 	cmpeqi	r3,r2,161
8110ef10:	1800031e 	bne	r3,zero,8110ef20 <vPerformActionNFCConfig+0x60>
8110ef14:	108028a0 	cmpeqi	r2,r2,162
8110ef18:	1000091e 	bne	r2,zero,8110ef40 <vPerformActionNFCConfig+0x80>
8110ef1c:	00000c06 	br	8110ef50 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
8110ef20:	d0a05c17 	ldw	r2,-32400(gp)
8110ef24:	100f883a 	mov	r7,r2
8110ef28:	01800d44 	movi	r6,53
8110ef2c:	01400044 	movi	r5,1
8110ef30:	01204534 	movhi	r4,33044
8110ef34:	211d4f04 	addi	r4,r4,30012
8110ef38:	111ba2c0 	call	8111ba2c <fwrite>
			#endif
			/* Do nothing for now */
			break;
8110ef3c:	00000c06 	br	8110ef70 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
8110ef40:	e0bfff17 	ldw	r2,-4(fp)
8110ef44:	00c00084 	movi	r3,2
8110ef48:	10c09915 	stw	r3,612(r2)
			break;
8110ef4c:	00000806 	br	8110ef70 <vPerformActionNFCConfig+0xb0>

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
8110ef50:	d0a05c17 	ldw	r2,-32400(gp)
8110ef54:	100f883a 	mov	r7,r2
8110ef58:	018009c4 	movi	r6,39
8110ef5c:	01400044 	movi	r5,1
8110ef60:	01204534 	movhi	r4,33044
8110ef64:	211d5d04 	addi	r4,r4,30068
8110ef68:	111ba2c0 	call	8111ba2c <fwrite>
			#endif	
			break;
8110ef6c:	0001883a 	nop
	}

}
8110ef70:	0001883a 	nop
8110ef74:	e037883a 	mov	sp,fp
8110ef78:	dfc00117 	ldw	ra,4(sp)
8110ef7c:	df000017 	ldw	fp,0(sp)
8110ef80:	dec00204 	addi	sp,sp,8
8110ef84:	f800283a 	ret

8110ef88 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110ef88:	defffa04 	addi	sp,sp,-24
8110ef8c:	de00012e 	bgeu	sp,et,8110ef94 <vPerformActionNFCRunning+0xc>
8110ef90:	003b68fa 	trap	3
8110ef94:	dfc00515 	stw	ra,20(sp)
8110ef98:	df000415 	stw	fp,16(sp)
8110ef9c:	df000404 	addi	fp,sp,16
8110efa0:	e13ffe15 	stw	r4,-8(fp)
8110efa4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
8110efa8:	e0bffe17 	ldw	r2,-8(fp)
8110efac:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110efb0:	e0bffd83 	ldbu	r2,-10(fp)
8110efb4:	10803fcc 	andi	r2,r2,255
8110efb8:	10c000a0 	cmpeqi	r3,r2,2
8110efbc:	1800271e 	bne	r3,zero,8110f05c <vPerformActionNFCRunning+0xd4>
8110efc0:	10c02860 	cmpeqi	r3,r2,161
8110efc4:	1800021e 	bne	r3,zero,8110efd0 <vPerformActionNFCRunning+0x48>
8110efc8:	10800060 	cmpeqi	r2,r2,1
8110efcc:	10002b26 	beq	r2,zero,8110f07c <vPerformActionNFCRunning+0xf4>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to Config Mode\n");
8110efd0:	d0a05c17 	ldw	r2,-32400(gp)
8110efd4:	100f883a 	mov	r7,r2
8110efd8:	01800b84 	movi	r6,46
8110efdc:	01400044 	movi	r5,1
8110efe0:	01204534 	movhi	r4,33044
8110efe4:	211d6704 	addi	r4,r4,30108
8110efe8:	111ba2c0 	call	8111ba2c <fwrite>
			#endif

			pxFeeCP->sMode = sMebToConfig;
8110efec:	e0bfff17 	ldw	r2,-4(fp)
8110eff0:	00c00044 	movi	r3,1
8110eff4:	10c09915 	stw	r3,612(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8110eff8:	e03ffc05 	stb	zero,-16(fp)
8110effc:	00001406 	br	8110f050 <vPerformActionNFCRunning+0xc8>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
8110f000:	e0bffc03 	ldbu	r2,-16(fp)
8110f004:	e0ffff17 	ldw	r3,-4(fp)
8110f008:	10802584 	addi	r2,r2,150
8110f00c:	1085883a 	add	r2,r2,r2
8110f010:	1085883a 	add	r2,r2,r2
8110f014:	1885883a 	add	r2,r3,r2
8110f018:	10800017 	ldw	r2,0(r2)
8110f01c:	10800017 	ldw	r2,0(r2)
8110f020:	10800058 	cmpnei	r2,r2,1
8110f024:	1000071e 	bne	r2,zero,8110f044 <vPerformActionNFCRunning+0xbc>
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
8110f028:	e0bffc03 	ldbu	r2,-16(fp)
8110f02c:	e0fffc03 	ldbu	r3,-16(fp)
8110f030:	180f883a 	mov	r7,r3
8110f034:	000d883a 	mov	r6,zero
8110f038:	01402844 	movi	r5,161
8110f03c:	1009883a 	mov	r4,r2
8110f040:	110f0b40 	call	8110f0b4 <bSendCmdQToNFeeInst>
			#endif

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8110f044:	e0bffc03 	ldbu	r2,-16(fp)
8110f048:	10800044 	addi	r2,r2,1
8110f04c:	e0bffc05 	stb	r2,-16(fp)
8110f050:	e0bffc03 	ldbu	r2,-16(fp)
8110f054:	103fea26 	beq	r2,zero,8110f000 <__reset+0xfb0ef000>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
8110f058:	00001006 	br	8110f09c <vPerformActionNFCRunning+0x114>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
8110f05c:	d0a05c17 	ldw	r2,-32400(gp)
8110f060:	100f883a 	mov	r7,r2
8110f064:	01800d84 	movi	r6,54
8110f068:	01400044 	movi	r5,1
8110f06c:	01204534 	movhi	r4,33044
8110f070:	211d7304 	addi	r4,r4,30156
8110f074:	111ba2c0 	call	8111ba2c <fwrite>
			#endif		
			/* Do nothing for now */

			break;		
8110f078:	00000806 	br	8110f09c <vPerformActionNFCRunning+0x114>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
8110f07c:	d0a05c17 	ldw	r2,-32400(gp)
8110f080:	100f883a 	mov	r7,r2
8110f084:	01800984 	movi	r6,38
8110f088:	01400044 	movi	r5,1
8110f08c:	01204534 	movhi	r4,33044
8110f090:	211d8104 	addi	r4,r4,30212
8110f094:	111ba2c0 	call	8111ba2c <fwrite>
			#endif	
			break;
8110f098:	0001883a 	nop
	}
}
8110f09c:	0001883a 	nop
8110f0a0:	e037883a 	mov	sp,fp
8110f0a4:	dfc00117 	ldw	ra,4(sp)
8110f0a8:	df000017 	ldw	fp,0(sp)
8110f0ac:	dec00204 	addi	sp,sp,8
8110f0b0:	f800283a 	ret

8110f0b4 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110f0b4:	defff704 	addi	sp,sp,-36
8110f0b8:	de00012e 	bgeu	sp,et,8110f0c0 <bSendCmdQToNFeeInst+0xc>
8110f0bc:	003b68fa 	trap	3
8110f0c0:	dfc00815 	stw	ra,32(sp)
8110f0c4:	df000715 	stw	fp,28(sp)
8110f0c8:	df000704 	addi	fp,sp,28
8110f0cc:	2011883a 	mov	r8,r4
8110f0d0:	2809883a 	mov	r4,r5
8110f0d4:	3007883a 	mov	r3,r6
8110f0d8:	3805883a 	mov	r2,r7
8110f0dc:	e23ffc05 	stb	r8,-16(fp)
8110f0e0:	e13ffd05 	stb	r4,-12(fp)
8110f0e4:	e0fffe05 	stb	r3,-8(fp)
8110f0e8:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
8110f0ec:	e0bffc03 	ldbu	r2,-16(fp)
8110f0f0:	10800444 	addi	r2,r2,17
8110f0f4:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110f0f8:	e0bffd03 	ldbu	r2,-12(fp)
8110f0fc:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110f100:	e0bffe03 	ldbu	r2,-8(fp)
8110f104:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110f108:	e0bfff03 	ldbu	r2,-4(fp)
8110f10c:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110f110:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8110f114:	e0bffc03 	ldbu	r2,-16(fp)
8110f118:	1085883a 	add	r2,r2,r2
8110f11c:	1087883a 	add	r3,r2,r2
8110f120:	d0a06404 	addi	r2,gp,-32368
8110f124:	1885883a 	add	r2,r3,r2
8110f128:	10800017 	ldw	r2,0(r2)
8110f12c:	e0fffb17 	ldw	r3,-20(fp)
8110f130:	180b883a 	mov	r5,r3
8110f134:	1009883a 	mov	r4,r2
8110f138:	113897c0 	call	8113897c <OSQPost>
8110f13c:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110f140:	e0bffa03 	ldbu	r2,-24(fp)
8110f144:	10000526 	beq	r2,zero,8110f15c <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8110f148:	e0bffc03 	ldbu	r2,-16(fp)
8110f14c:	1009883a 	mov	r4,r2
8110f150:	11180e80 	call	811180e8 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8110f154:	e03ff915 	stw	zero,-28(fp)
8110f158:	00000206 	br	8110f164 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
8110f15c:	00800044 	movi	r2,1
8110f160:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
8110f164:	e0bff917 	ldw	r2,-28(fp)
}
8110f168:	e037883a 	mov	sp,fp
8110f16c:	dfc00117 	ldw	ra,4(sp)
8110f170:	df000017 	ldw	fp,0(sp)
8110f174:	dec00204 	addi	sp,sp,8
8110f178:	f800283a 	ret

8110f17c <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
8110f17c:	defff704 	addi	sp,sp,-36
8110f180:	de00012e 	bgeu	sp,et,8110f188 <vOutAckHandlerTask+0xc>
8110f184:	003b68fa 	trap	3
8110f188:	dfc00815 	stw	ra,32(sp)
8110f18c:	df000715 	stw	fp,28(sp)
8110f190:	df000704 	addi	fp,sp,28
8110f194:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
8110f198:	e03ffac5 	stb	zero,-21(fp)
8110f19c:	e03ffb05 	stb	zero,-20(fp)
8110f1a0:	e03ffb45 	stb	zero,-19(fp)
8110f1a4:	e03ffb85 	stb	zero,-18(fp)
8110f1a8:	e03ffbc5 	stb	zero,-17(fp)
8110f1ac:	e03ffc05 	stb	zero,-16(fp)
8110f1b0:	e03ffc45 	stb	zero,-15(fp)
8110f1b4:	e03ffc85 	stb	zero,-14(fp)
8110f1b8:	e03ffcc5 	stb	zero,-13(fp)
8110f1bc:	e03ffd05 	stb	zero,-12(fp)
8110f1c0:	e03ffd45 	stb	zero,-11(fp)
8110f1c4:	e03ffd85 	stb	zero,-10(fp)
8110f1c8:	e03ffdc5 	stb	zero,-9(fp)
8110f1cc:	e03ffe05 	stb	zero,-8(fp)
8110f1d0:	e03ffe45 	stb	zero,-7(fp)
8110f1d4:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8110f1d8:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
8110f1dc:	d0a05c17 	ldw	r2,-32400(gp)
8110f1e0:	100f883a 	mov	r7,r2
8110f1e4:	01800804 	movi	r6,32
8110f1e8:	01400044 	movi	r5,1
8110f1ec:	01204534 	movhi	r4,33044
8110f1f0:	211d8b04 	addi	r4,r4,30252
8110f1f4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
8110f1f8:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
8110f1fc:	e0bff917 	ldw	r2,-28(fp)
8110f200:	10c00060 	cmpeqi	r3,r2,1
8110f204:	1800071e 	bne	r3,zero,8110f224 <vOutAckHandlerTask+0xa8>
8110f208:	0080032e 	bgeu	zero,r2,8110f218 <vOutAckHandlerTask+0x9c>
8110f20c:	108000a0 	cmpeqi	r2,r2,2
8110f210:	1000471e 	bne	r2,zero,8110f330 <vOutAckHandlerTask+0x1b4>
8110f214:	00008c06 	br	8110f448 <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
8110f218:	00800044 	movi	r2,1
8110f21c:	e0bff915 	stw	r2,-28(fp)
				break;
8110f220:	00009306 	br	8110f470 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
8110f224:	00800044 	movi	r2,1
8110f228:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
8110f22c:	d0a05b17 	ldw	r2,-32404(gp)
8110f230:	e0fffa84 	addi	r3,fp,-22
8110f234:	180d883a 	mov	r6,r3
8110f238:	000b883a 	mov	r5,zero
8110f23c:	1009883a 	mov	r4,r2
8110f240:	113946c0 	call	8113946c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110f244:	e0bffa83 	ldbu	r2,-22(fp)
8110f248:	10803fcc 	andi	r2,r2,255
8110f24c:	1000361e 	bne	r2,zero,8110f328 <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
8110f250:	d0a06c17 	ldw	r2,-32336(gp)
8110f254:	e0fffa84 	addi	r3,fp,-22
8110f258:	180d883a 	mov	r6,r3
8110f25c:	000b883a 	mov	r5,zero
8110f260:	1009883a 	mov	r4,r2
8110f264:	11374600 	call	81137460 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110f268:	e0bffa83 	ldbu	r2,-22(fp)
8110f26c:	10803fcc 	andi	r2,r2,255
8110f270:	10002b1e 	bne	r2,zero,8110f320 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110f274:	e03ffa05 	stb	zero,-24(fp)
8110f278:	00002206 	br	8110f304 <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
8110f27c:	e0fffa03 	ldbu	r3,-24(fp)
8110f280:	00a045b4 	movhi	r2,33046
8110f284:	1080d004 	addi	r2,r2,832
8110f288:	18c7883a 	add	r3,r3,r3
8110f28c:	18c7883a 	add	r3,r3,r3
8110f290:	10c5883a 	add	r2,r2,r3
8110f294:	10800003 	ldbu	r2,0(r2)
8110f298:	10803fcc 	andi	r2,r2,255
8110f29c:	1080201c 	xori	r2,r2,128
8110f2a0:	10bfe004 	addi	r2,r2,-128
8110f2a4:	10001426 	beq	r2,zero,8110f2f8 <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8110f2a8:	e0fffa03 	ldbu	r3,-24(fp)
8110f2ac:	00a045b4 	movhi	r2,33046
8110f2b0:	1080d004 	addi	r2,r2,832
8110f2b4:	18c7883a 	add	r3,r3,r3
8110f2b8:	18c7883a 	add	r3,r3,r3
8110f2bc:	10c5883a 	add	r2,r2,r3
8110f2c0:	10c0000b 	ldhu	r3,0(r2)
8110f2c4:	d0e0540d 	sth	r3,-32432(gp)
8110f2c8:	1080008b 	ldhu	r2,2(r2)
8110f2cc:	d0a0548d 	sth	r2,-32430(gp)
                                eSenderAckState = sSASending;
8110f2d0:	00800084 	movi	r2,2
8110f2d4:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110f2d8:	e0fffa03 	ldbu	r3,-24(fp)
8110f2dc:	00a045b4 	movhi	r2,33046
8110f2e0:	1080d004 	addi	r2,r2,832
8110f2e4:	18c7883a 	add	r3,r3,r3
8110f2e8:	18c7883a 	add	r3,r3,r3
8110f2ec:	10c5883a 	add	r2,r2,r3
8110f2f0:	10000005 	stb	zero,0(r2)
                                break;
8110f2f4:	00000606 	br	8110f310 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110f2f8:	e0bffa03 	ldbu	r2,-24(fp)
8110f2fc:	10800044 	addi	r2,r2,1
8110f300:	e0bffa05 	stb	r2,-24(fp)
8110f304:	e0bffa03 	ldbu	r2,-24(fp)
8110f308:	10800230 	cmpltui	r2,r2,8
8110f30c:	103fdb1e 	bne	r2,zero,8110f27c <__reset+0xfb0ef27c>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
8110f310:	d0a06c17 	ldw	r2,-32336(gp)
8110f314:	1009883a 	mov	r4,r2
8110f318:	1137a040 	call	81137a04 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110f31c:	00005406 	br	8110f470 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
8110f320:	11168fc0 	call	811168fc <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110f324:	00005206 	br	8110f470 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8110f328:	11168940 	call	81116894 <vFailGetCountSemaphoreSenderTask>
                }

                break;
8110f32c:	00005006 	br	8110f470 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
8110f330:	d0a05403 	ldbu	r2,-32432(gp)
8110f334:	10803fcc 	andi	r2,r2,255
8110f338:	1080201c 	xori	r2,r2,128
8110f33c:	10bfe004 	addi	r2,r2,-128
8110f340:	108008e0 	cmpeqi	r2,r2,35
8110f344:	1000201e 	bne	r2,zero,8110f3c8 <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
8110f348:	d0a05443 	ldbu	r2,-32431(gp)
8110f34c:	10c03fcc 	andi	r3,r2,255
8110f350:	18c0201c 	xori	r3,r3,128
8110f354:	18ffe004 	addi	r3,r3,-128
8110f358:	d0a0548b 	ldhu	r2,-32430(gp)
8110f35c:	113fffcc 	andi	r4,r2,65535
8110f360:	e0bffac4 	addi	r2,fp,-21
8110f364:	200f883a 	mov	r7,r4
8110f368:	180d883a 	mov	r6,r3
8110f36c:	01604534 	movhi	r5,33044
8110f370:	295d9404 	addi	r5,r5,30288
8110f374:	1009883a 	mov	r4,r2
8110f378:	111cd200 	call	8111cd20 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
8110f37c:	e0bffac4 	addi	r2,fp,-21
8110f380:	1009883a 	mov	r4,r2
8110f384:	111cf340 	call	8111cf34 <strlen>
8110f388:	1007883a 	mov	r3,r2
8110f38c:	e0bffac4 	addi	r2,fp,-21
8110f390:	180b883a 	mov	r5,r3
8110f394:	1009883a 	mov	r4,r2
8110f398:	11164580 	call	81116458 <ucCrc8wInit>
8110f39c:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
8110f3a0:	e13ffa43 	ldbu	r4,-23(fp)
8110f3a4:	e0fffac4 	addi	r3,fp,-21
8110f3a8:	e0bffac4 	addi	r2,fp,-21
8110f3ac:	200f883a 	mov	r7,r4
8110f3b0:	180d883a 	mov	r6,r3
8110f3b4:	01604534 	movhi	r5,33044
8110f3b8:	295d9604 	addi	r5,r5,30296
8110f3bc:	1009883a 	mov	r4,r2
8110f3c0:	111cd200 	call	8111cd20 <sprintf>
8110f3c4:	00000c06 	br	8110f3f8 <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
8110f3c8:	e0bffac4 	addi	r2,fp,-21
8110f3cc:	00c008c4 	movi	r3,35
8110f3d0:	10c00005 	stb	r3,0(r2)
8110f3d4:	00c01f04 	movi	r3,124
8110f3d8:	10c00045 	stb	r3,1(r2)
8110f3dc:	00c00d44 	movi	r3,53
8110f3e0:	10c00085 	stb	r3,2(r2)
8110f3e4:	00c00d04 	movi	r3,52
8110f3e8:	10c000c5 	stb	r3,3(r2)
8110f3ec:	00c00ec4 	movi	r3,59
8110f3f0:	10c00105 	stb	r3,4(r2)
8110f3f4:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
8110f3f8:	d0a06e17 	ldw	r2,-32328(gp)
8110f3fc:	e0fffa84 	addi	r3,fp,-22
8110f400:	180d883a 	mov	r6,r3
8110f404:	01401904 	movi	r5,100
8110f408:	1009883a 	mov	r4,r2
8110f40c:	11374600 	call	81137460 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8110f410:	e0bffa83 	ldbu	r2,-22(fp)
8110f414:	10803fcc 	andi	r2,r2,255
8110f418:	1000071e 	bne	r2,zero,8110f438 <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
8110f41c:	e0bffac4 	addi	r2,fp,-21
8110f420:	1009883a 	mov	r4,r2
8110f424:	111c9dc0 	call	8111c9dc <puts>
                    OSMutexPost(xTxUARTMutex);
8110f428:	d0a06e17 	ldw	r2,-32328(gp)
8110f42c:	1009883a 	mov	r4,r2
8110f430:	1137a040 	call	81137a04 <OSMutexPost>
8110f434:	00000106 	br	8110f43c <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8110f438:	1116a340 	call	81116a34 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
8110f43c:	00800044 	movi	r2,1
8110f440:	e0bff915 	stw	r2,-28(fp)
                
				break;
8110f444:	00000a06 	br	8110f470 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
8110f448:	d0a05c17 	ldw	r2,-32400(gp)
8110f44c:	100f883a 	mov	r7,r2
8110f450:	01801104 	movi	r6,68
8110f454:	01400044 	movi	r5,1
8110f458:	01204534 	movhi	r4,33044
8110f45c:	211d9904 	addi	r4,r4,30308
8110f460:	111ba2c0 	call	8111ba2c <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
8110f464:	00800044 	movi	r2,1
8110f468:	e0bff915 	stw	r2,-28(fp)
				break;
8110f46c:	0001883a 	nop
		}
	}
8110f470:	003f6206 	br	8110f1fc <__reset+0xfb0ef1fc>

8110f474 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
8110f474:	deffd704 	addi	sp,sp,-164
8110f478:	de00012e 	bgeu	sp,et,8110f480 <vParserCommTask+0xc>
8110f47c:	003b68fa 	trap	3
8110f480:	dfc02815 	stw	ra,160(sp)
8110f484:	df002715 	stw	fp,156(sp)
8110f488:	df002704 	addi	fp,sp,156
8110f48c:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
8110f490:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
8110f494:	d0a05c17 	ldw	r2,-32400(gp)
8110f498:	100f883a 	mov	r7,r2
8110f49c:	01800704 	movi	r6,28
8110f4a0:	01400044 	movi	r5,1
8110f4a4:	01204534 	movhi	r4,33044
8110f4a8:	211dab04 	addi	r4,r4,30380
8110f4ac:	111ba2c0 	call	8111ba2c <fwrite>
    #endif

	eParserMode = sConfiguring;
8110f4b0:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
8110f4b4:	e0bfdc17 	ldw	r2,-144(fp)
8110f4b8:	10800168 	cmpgeui	r2,r2,5
8110f4bc:	1003651e 	bne	r2,zero,81110254 <vParserCommTask+0xde0>
8110f4c0:	e0bfdc17 	ldw	r2,-144(fp)
8110f4c4:	100690ba 	slli	r3,r2,2
8110f4c8:	00a04474 	movhi	r2,33041
8110f4cc:	10bd3704 	addi	r2,r2,-2852
8110f4d0:	1885883a 	add	r2,r3,r2
8110f4d4:	10800017 	ldw	r2,0(r2)
8110f4d8:	1000683a 	jmp	r2
8110f4dc:	8110f4f0 	cmpltui	r4,r16,17363
8110f4e0:	8110f4fc 	xorhi	r4,r16,17363
8110f4e4:	8110f590 	cmplti	r4,r16,17366
8110f4e8:	8110f6f4 	orhi	r4,r16,17371
8110f4ec:	8110f738 	rdprs	r4,r16,17372
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
8110f4f0:	00800044 	movi	r2,1
8110f4f4:	e0bfdc15 	stw	r2,-144(fp)
				break;
8110f4f8:	00035906 	br	81110260 <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
8110f4fc:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
8110f500:	00800044 	movi	r2,1
8110f504:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
8110f508:	d0a05e17 	ldw	r2,-32392(gp)
8110f50c:	e0ffde84 	addi	r3,fp,-134
8110f510:	180d883a 	mov	r6,r3
8110f514:	000b883a 	mov	r5,zero
8110f518:	1009883a 	mov	r4,r2
8110f51c:	113946c0 	call	8113946c <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
8110f520:	e0bfde83 	ldbu	r2,-134(fp)
8110f524:	10803fcc 	andi	r2,r2,255
8110f528:	1000171e 	bne	r2,zero,8110f588 <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
8110f52c:	01204574 	movhi	r4,33045
8110f530:	2133fb04 	addi	r4,r4,-12308
8110f534:	11102640 	call	81110264 <getPreParsedPacket>
8110f538:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
8110f53c:	e0bfdd17 	ldw	r2,-140(fp)
8110f540:	10800058 	cmpnei	r2,r2,1
8110f544:	10000e1e 	bne	r2,zero,8110f580 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
8110f548:	00a04574 	movhi	r2,33045
8110f54c:	10b3fb04 	addi	r2,r2,-12308
8110f550:	10800103 	ldbu	r2,4(r2)
8110f554:	10803fcc 	andi	r2,r2,255
8110f558:	1080201c 	xori	r2,r2,128
8110f55c:	10bfe004 	addi	r2,r2,-128
8110f560:	10800858 	cmpnei	r2,r2,33
8110f564:	1000031e 	bne	r2,zero,8110f574 <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
8110f568:	008000c4 	movi	r2,3
8110f56c:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110f570:	00033b06 	br	81110260 <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
8110f574:	00800084 	movi	r2,2
8110f578:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110f57c:	00033806 	br	81110260 <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
8110f580:	1116fc00 	call	81116fc0 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110f584:	00033606 	br	81110260 <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8110f588:	1116ef00 	call	81116ef0 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
8110f58c:	00033406 	br	81110260 <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
8110f590:	00a04574 	movhi	r2,33045
8110f594:	10b3fb04 	addi	r2,r2,-12308
8110f598:	10800143 	ldbu	r2,5(r2)
8110f59c:	10803fcc 	andi	r2,r2,255
8110f5a0:	1080201c 	xori	r2,r2,128
8110f5a4:	10bfe004 	addi	r2,r2,-128
8110f5a8:	10c010e0 	cmpeqi	r3,r2,67
8110f5ac:	1800031e 	bne	r3,zero,8110f5bc <vParserCommTask+0x148>
8110f5b0:	10801420 	cmpeqi	r2,r2,80
8110f5b4:	1000051e 	bne	r2,zero,8110f5cc <vParserCommTask+0x158>
8110f5b8:	00004a06 	br	8110f6e4 <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
8110f5bc:	1114c280 	call	81114c28 <vSendEthConf>
						eParserMode = sWaitingMessage;
8110f5c0:	00800044 	movi	r2,1
8110f5c4:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110f5c8:	00004906 	br	8110f6f0 <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
8110f5cc:	e0bfdec4 	addi	r2,fp,-133
8110f5d0:	01802004 	movi	r6,128
8110f5d4:	000b883a 	mov	r5,zero
8110f5d8:	1009883a 	mov	r4,r2
8110f5dc:	111c5900 	call	8111c590 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
8110f5e0:	00a04574 	movhi	r2,33045
8110f5e4:	10b3fb04 	addi	r2,r2,-12308
8110f5e8:	1080028b 	ldhu	r2,10(r2)
8110f5ec:	117fffcc 	andi	r5,r2,65535
8110f5f0:	00a04574 	movhi	r2,33045
8110f5f4:	10b3fb04 	addi	r2,r2,-12308
8110f5f8:	1080030b 	ldhu	r2,12(r2)
8110f5fc:	11bfffcc 	andi	r6,r2,65535
8110f600:	00a04574 	movhi	r2,33045
8110f604:	10b3fb04 	addi	r2,r2,-12308
8110f608:	1080038b 	ldhu	r2,14(r2)
8110f60c:	10ffffcc 	andi	r3,r2,65535
8110f610:	00a04574 	movhi	r2,33045
8110f614:	10b3fb04 	addi	r2,r2,-12308
8110f618:	1080040b 	ldhu	r2,16(r2)
8110f61c:	113fffcc 	andi	r4,r2,65535
8110f620:	00a04574 	movhi	r2,33045
8110f624:	10b3fb04 	addi	r2,r2,-12308
8110f628:	1080048b 	ldhu	r2,18(r2)
8110f62c:	10bfffcc 	andi	r2,r2,65535
8110f630:	e23fdec4 	addi	r8,fp,-133
8110f634:	d8800215 	stw	r2,8(sp)
8110f638:	d9000115 	stw	r4,4(sp)
8110f63c:	d8c00015 	stw	r3,0(sp)
8110f640:	300f883a 	mov	r7,r6
8110f644:	280d883a 	mov	r6,r5
8110f648:	01604534 	movhi	r5,33044
8110f64c:	295db304 	addi	r5,r5,30412
8110f650:	4009883a 	mov	r4,r8
8110f654:	111cd200 	call	8111cd20 <sprintf>
							debug(fp, cPUSDebug );
8110f658:	d0a05c17 	ldw	r2,-32400(gp)
8110f65c:	e0ffdec4 	addi	r3,fp,-133
8110f660:	180b883a 	mov	r5,r3
8110f664:	1009883a 	mov	r4,r2
8110f668:	111b3900 	call	8111b390 <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
8110f66c:	00a04574 	movhi	r2,33045
8110f670:	10b3fb04 	addi	r2,r2,-12308
8110f674:	10c0030b 	ldhu	r3,12(r2)
8110f678:	00a04574 	movhi	r2,33045
8110f67c:	10b40e04 	addi	r2,r2,-12232
8110f680:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
8110f684:	00a04574 	movhi	r2,33045
8110f688:	10b3fb04 	addi	r2,r2,-12308
8110f68c:	10c0038b 	ldhu	r3,14(r2)
8110f690:	00a04574 	movhi	r2,33045
8110f694:	10b40e04 	addi	r2,r2,-12232
8110f698:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
8110f69c:	00a04574 	movhi	r2,33045
8110f6a0:	10b3fb04 	addi	r2,r2,-12308
8110f6a4:	10c0040b 	ldhu	r3,16(r2)
8110f6a8:	00a04574 	movhi	r2,33045
8110f6ac:	10b40e04 	addi	r2,r2,-12232
8110f6b0:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
8110f6b4:	00a04574 	movhi	r2,33045
8110f6b8:	10b3fb04 	addi	r2,r2,-12308
8110f6bc:	10c0048b 	ldhu	r3,18(r2)
8110f6c0:	00a04574 	movhi	r2,33045
8110f6c4:	10b40e04 	addi	r2,r2,-12232
8110f6c8:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
8110f6cc:	00a04574 	movhi	r2,33045
8110f6d0:	10b40e04 	addi	r2,r2,-12232
8110f6d4:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
8110f6d8:	00800104 	movi	r2,4
8110f6dc:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
8110f6e0:	00000306 	br	8110f6f0 <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
8110f6e4:	00800044 	movi	r2,1
8110f6e8:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110f6ec:	0001883a 	nop
				}
				break;
8110f6f0:	0002db06 	br	81110260 <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
8110f6f4:	00800044 	movi	r2,1
8110f6f8:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
8110f6fc:	00a04574 	movhi	r2,33045
8110f700:	10b40e04 	addi	r2,r2,-12232
8110f704:	1080030b 	ldhu	r2,12(r2)
8110f708:	10bfffcc 	andi	r2,r2,65535
8110f70c:	10c01220 	cmpeqi	r3,r2,72
8110f710:	1800051e 	bne	r3,zero,8110f728 <vParserCommTask+0x2b4>
8110f714:	108014e0 	cmpeqi	r2,r2,83
8110f718:	1000051e 	bne	r2,zero,8110f730 <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
8110f71c:	00800044 	movi	r2,1
8110f720:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8110f724:	00000306 	br	8110f734 <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
8110f728:	0001883a 	nop
8110f72c:	0002cc06 	br	81110260 <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
8110f730:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
8110f734:	0002ca06 	br	81110260 <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
8110f738:	00800044 	movi	r2,1
8110f73c:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
8110f740:	00a04574 	movhi	r2,33045
8110f744:	10b40e04 	addi	r2,r2,-12232
8110f748:	1080030b 	ldhu	r2,12(r2)
8110f74c:	10bfffcc 	andi	r2,r2,65535
8110f750:	10c03ea0 	cmpeqi	r3,r2,250
8110f754:	1800401e 	bne	r3,zero,8110f858 <vParserCommTask+0x3e4>
8110f758:	10c03ec8 	cmpgei	r3,r2,251
8110f75c:	1800031e 	bne	r3,zero,8110f76c <vParserCommTask+0x2f8>
8110f760:	10800460 	cmpeqi	r2,r2,17
8110f764:	1000061e 	bne	r2,zero,8110f780 <vParserCommTask+0x30c>
8110f768:	0002b606 	br	81110244 <vParserCommTask+0xdd0>
8110f76c:	10c03ee0 	cmpeqi	r3,r2,251
8110f770:	18009d1e 	bne	r3,zero,8110f9e8 <vParserCommTask+0x574>
8110f774:	10803f20 	cmpeqi	r2,r2,252
8110f778:	1001321e 	bne	r2,zero,8110fc44 <vParserCommTask+0x7d0>
8110f77c:	0002b106 	br	81110244 <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
8110f780:	00a04574 	movhi	r2,33045
8110f784:	10b40e04 	addi	r2,r2,-12232
8110f788:	1080038b 	ldhu	r2,14(r2)
8110f78c:	10bfffcc 	andi	r2,r2,65535
8110f790:	10800060 	cmpeqi	r2,r2,1
8110f794:	10000e26 	beq	r2,zero,8110f7d0 <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
8110f798:	d0a05c17 	ldw	r2,-32400(gp)
8110f79c:	100f883a 	mov	r7,r2
8110f7a0:	01800944 	movi	r6,37
8110f7a4:	01400044 	movi	r5,1
8110f7a8:	01204534 	movhi	r4,33044
8110f7ac:	211dc904 	addi	r4,r4,30500
8110f7b0:	111ba2c0 	call	8111ba2c <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
8110f7b4:	00a04574 	movhi	r2,33045
8110f7b8:	10b40e04 	addi	r2,r2,-12232
8110f7bc:	1080040b 	ldhu	r2,16(r2)
8110f7c0:	10bfffcc 	andi	r2,r2,65535
8110f7c4:	1009883a 	mov	r4,r2
8110f7c8:	11156280 	call	81115628 <vTMPusTestConnection>

								break;
8110f7cc:	00002106 	br	8110f854 <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110f7d0:	e0bfdec4 	addi	r2,fp,-133
8110f7d4:	01802004 	movi	r6,128
8110f7d8:	000b883a 	mov	r5,zero
8110f7dc:	1009883a 	mov	r4,r2
8110f7e0:	111c5900 	call	8111c590 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110f7e4:	00a04574 	movhi	r2,33045
8110f7e8:	10b40e04 	addi	r2,r2,-12232
8110f7ec:	1080030b 	ldhu	r2,12(r2)
8110f7f0:	113fffcc 	andi	r4,r2,65535
8110f7f4:	00a04574 	movhi	r2,33045
8110f7f8:	10b40e04 	addi	r2,r2,-12232
8110f7fc:	1080038b 	ldhu	r2,14(r2)
8110f800:	117fffcc 	andi	r5,r2,65535
8110f804:	00a04574 	movhi	r2,33045
8110f808:	10b40e04 	addi	r2,r2,-12232
8110f80c:	1080040b 	ldhu	r2,16(r2)
8110f810:	10bfffcc 	andi	r2,r2,65535
8110f814:	e0ffdec4 	addi	r3,fp,-133
8110f818:	d8800015 	stw	r2,0(sp)
8110f81c:	280f883a 	mov	r7,r5
8110f820:	200d883a 	mov	r6,r4
8110f824:	01604534 	movhi	r5,33044
8110f828:	295dd304 	addi	r5,r5,30540
8110f82c:	1809883a 	mov	r4,r3
8110f830:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
8110f834:	d0a05c17 	ldw	r2,-32400(gp)
8110f838:	e0ffdec4 	addi	r3,fp,-133
8110f83c:	180b883a 	mov	r5,r3
8110f840:	1009883a 	mov	r4,r2
8110f844:	111b3900 	call	8111b390 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
8110f848:	00800044 	movi	r2,1
8110f84c:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110f850:	0001883a 	nop
						}
                        break;
8110f854:	00027e06 	br	81110250 <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
8110f858:	00a04574 	movhi	r2,33045
8110f85c:	10b40e04 	addi	r2,r2,-12232
8110f860:	1080038b 	ldhu	r2,14(r2)
8110f864:	10bfffcc 	andi	r2,r2,65535
8110f868:	10c00f20 	cmpeqi	r3,r2,60
8110f86c:	18001a1e 	bne	r3,zero,8110f8d8 <vParserCommTask+0x464>
8110f870:	10c00f48 	cmpgei	r3,r2,61
8110f874:	1800031e 	bne	r3,zero,8110f884 <vParserCommTask+0x410>
8110f878:	10800ee0 	cmpeqi	r2,r2,59
8110f87c:	1000061e 	bne	r2,zero,8110f898 <vParserCommTask+0x424>
8110f880:	00003706 	br	8110f960 <vParserCommTask+0x4ec>
8110f884:	10c00f60 	cmpeqi	r3,r2,61
8110f888:	18001e1e 	bne	r3,zero,8110f904 <vParserCommTask+0x490>
8110f88c:	10800fa0 	cmpeqi	r2,r2,62
8110f890:	1000271e 	bne	r2,zero,8110f930 <vParserCommTask+0x4bc>
8110f894:	00003206 	br	8110f960 <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
8110f898:	d0a05c17 	ldw	r2,-32400(gp)
8110f89c:	100f883a 	mov	r7,r2
8110f8a0:	018006c4 	movi	r6,27
8110f8a4:	01400044 	movi	r5,1
8110f8a8:	01204534 	movhi	r4,33044
8110f8ac:	211de604 	addi	r4,r4,30616
8110f8b0:	111ba2c0 	call	8111ba2c <fwrite>
								#endif
								vSendReset();
8110f8b4:	1114fd00 	call	81114fd0 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
8110f8b8:	000f883a 	mov	r7,zero
8110f8bc:	018000c4 	movi	r6,3
8110f8c0:	000b883a 	mov	r5,zero
8110f8c4:	0009883a 	mov	r4,zero
8110f8c8:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
8110f8cc:	0104e204 	movi	r4,5000
8110f8d0:	110af400 	call	8110af40 <vRstcSimucamReset>

								break;
8110f8d4:	00004306 	br	8110f9e4 <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
8110f8d8:	d0a05c17 	ldw	r2,-32400(gp)
8110f8dc:	100f883a 	mov	r7,r2
8110f8e0:	01800704 	movi	r6,28
8110f8e4:	01400044 	movi	r5,1
8110f8e8:	01204534 	movhi	r4,33044
8110f8ec:	211ded04 	addi	r4,r4,30644
8110f8f0:	111ba2c0 	call	8111ba2c <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110f8f4:	01204574 	movhi	r4,33045
8110f8f8:	21340e04 	addi	r4,r4,-12232
8110f8fc:	111037c0 	call	8111037c <bSendMessagePUStoMebTask>

								break;
8110f900:	00003806 	br	8110f9e4 <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
8110f904:	d0a05c17 	ldw	r2,-32400(gp)
8110f908:	100f883a 	mov	r7,r2
8110f90c:	01800644 	movi	r6,25
8110f910:	01400044 	movi	r5,1
8110f914:	01204534 	movhi	r4,33044
8110f918:	211df504 	addi	r4,r4,30676
8110f91c:	111ba2c0 	call	8111ba2c <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110f920:	01204574 	movhi	r4,33045
8110f924:	21340e04 	addi	r4,r4,-12232
8110f928:	111037c0 	call	8111037c <bSendMessagePUStoMebTask>

								break;
8110f92c:	00002d06 	br	8110f9e4 <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
8110f930:	d0a05c17 	ldw	r2,-32400(gp)
8110f934:	100f883a 	mov	r7,r2
8110f938:	01800744 	movi	r6,29
8110f93c:	01400044 	movi	r5,1
8110f940:	01204534 	movhi	r4,33044
8110f944:	211dfc04 	addi	r4,r4,30704
8110f948:	111ba2c0 	call	8111ba2c <fwrite>
								#endif
								vSendTurnOff();
8110f94c:	1114eb80 	call	81114eb8 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
8110f950:	01204574 	movhi	r4,33045
8110f954:	21340e04 	addi	r4,r4,-12232
8110f958:	111037c0 	call	8111037c <bSendMessagePUStoMebTask>

								break;
8110f95c:	00002106 	br	8110f9e4 <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110f960:	e0bfdec4 	addi	r2,fp,-133
8110f964:	01802004 	movi	r6,128
8110f968:	000b883a 	mov	r5,zero
8110f96c:	1009883a 	mov	r4,r2
8110f970:	111c5900 	call	8111c590 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110f974:	00a04574 	movhi	r2,33045
8110f978:	10b40e04 	addi	r2,r2,-12232
8110f97c:	1080030b 	ldhu	r2,12(r2)
8110f980:	113fffcc 	andi	r4,r2,65535
8110f984:	00a04574 	movhi	r2,33045
8110f988:	10b40e04 	addi	r2,r2,-12232
8110f98c:	1080038b 	ldhu	r2,14(r2)
8110f990:	117fffcc 	andi	r5,r2,65535
8110f994:	00a04574 	movhi	r2,33045
8110f998:	10b40e04 	addi	r2,r2,-12232
8110f99c:	1080040b 	ldhu	r2,16(r2)
8110f9a0:	10bfffcc 	andi	r2,r2,65535
8110f9a4:	e0ffdec4 	addi	r3,fp,-133
8110f9a8:	d8800015 	stw	r2,0(sp)
8110f9ac:	280f883a 	mov	r7,r5
8110f9b0:	200d883a 	mov	r6,r4
8110f9b4:	01604534 	movhi	r5,33044
8110f9b8:	295dd304 	addi	r5,r5,30540
8110f9bc:	1809883a 	mov	r4,r3
8110f9c0:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
8110f9c4:	d0a05c17 	ldw	r2,-32400(gp)
8110f9c8:	e0ffdec4 	addi	r3,fp,-133
8110f9cc:	180b883a 	mov	r5,r3
8110f9d0:	1009883a 	mov	r4,r2
8110f9d4:	111b3900 	call	8111b390 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8110f9d8:	00800044 	movi	r2,1
8110f9dc:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110f9e0:	0001883a 	nop
						}
                        break;
8110f9e4:	00021a06 	br	81110250 <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8110f9e8:	00a04574 	movhi	r2,33045
8110f9ec:	10b3fb04 	addi	r2,r2,-12308
8110f9f0:	1080050b 	ldhu	r2,20(r2)
8110f9f4:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
8110f9f8:	e0bfde0b 	ldhu	r2,-136(fp)
8110f9fc:	108000b0 	cmpltui	r2,r2,2
8110fa00:	1000121e 	bne	r2,zero,8110fa4c <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
8110fa04:	e0bfdec4 	addi	r2,fp,-133
8110fa08:	01802004 	movi	r6,128
8110fa0c:	000b883a 	mov	r5,zero
8110fa10:	1009883a 	mov	r4,r2
8110fa14:	111c5900 	call	8111c590 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
8110fa18:	e0ffde0b 	ldhu	r3,-136(fp)
8110fa1c:	e0bfdec4 	addi	r2,fp,-133
8110fa20:	180d883a 	mov	r6,r3
8110fa24:	01604534 	movhi	r5,33044
8110fa28:	295e0404 	addi	r5,r5,30736
8110fa2c:	1009883a 	mov	r4,r2
8110fa30:	111cd200 	call	8111cd20 <sprintf>
								debug(fp, cPUSDebug );
8110fa34:	d0a05c17 	ldw	r2,-32400(gp)
8110fa38:	e0ffdec4 	addi	r3,fp,-133
8110fa3c:	180b883a 	mov	r5,r3
8110fa40:	1009883a 	mov	r4,r2
8110fa44:	111b3900 	call	8111b390 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
8110fa48:	00020106 	br	81110250 <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8110fa4c:	00a04574 	movhi	r2,33045
8110fa50:	10b40e04 	addi	r2,r2,-12232
8110fa54:	10800483 	ldbu	r2,18(r2)
8110fa58:	10c03fcc 	andi	r3,r2,255
8110fa5c:	00a04574 	movhi	r2,33045
8110fa60:	10b40e04 	addi	r2,r2,-12232
8110fa64:	18c00284 	addi	r3,r3,10
8110fa68:	18c7883a 	add	r3,r3,r3
8110fa6c:	10c5883a 	add	r2,r2,r3
8110fa70:	e0ffde0b 	ldhu	r3,-136(fp)
8110fa74:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
8110fa78:	00a04574 	movhi	r2,33045
8110fa7c:	10b40e04 	addi	r2,r2,-12232
8110fa80:	10800483 	ldbu	r2,18(r2)
8110fa84:	10800044 	addi	r2,r2,1
8110fa88:	1007883a 	mov	r3,r2
8110fa8c:	00a04574 	movhi	r2,33045
8110fa90:	10b40e04 	addi	r2,r2,-12232
8110fa94:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
8110fa98:	00a04574 	movhi	r2,33045
8110fa9c:	10b40e04 	addi	r2,r2,-12232
8110faa0:	1080038b 	ldhu	r2,14(r2)
8110faa4:	10bfffcc 	andi	r2,r2,65535
8110faa8:	10c000a0 	cmpeqi	r3,r2,2
8110faac:	1800191e 	bne	r3,zero,8110fb14 <vParserCommTask+0x6a0>
8110fab0:	10c00160 	cmpeqi	r3,r2,5
8110fab4:	18002c1e 	bne	r3,zero,8110fb68 <vParserCommTask+0x6f4>
8110fab8:	10800060 	cmpeqi	r2,r2,1
8110fabc:	10003f26 	beq	r2,zero,8110fbbc <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110fac0:	e0bfdec4 	addi	r2,fp,-133
8110fac4:	01802004 	movi	r6,128
8110fac8:	000b883a 	mov	r5,zero
8110facc:	1009883a 	mov	r4,r2
8110fad0:	111c5900 	call	8111c590 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8110fad4:	e0ffde0b 	ldhu	r3,-136(fp)
8110fad8:	e0bfdec4 	addi	r2,fp,-133
8110fadc:	180d883a 	mov	r6,r3
8110fae0:	01604534 	movhi	r5,33044
8110fae4:	295e1304 	addi	r5,r5,30796
8110fae8:	1009883a 	mov	r4,r2
8110faec:	111cd200 	call	8111cd20 <sprintf>
										debug(fp, cPUSDebug );
8110faf0:	d0a05c17 	ldw	r2,-32400(gp)
8110faf4:	e0ffdec4 	addi	r3,fp,-133
8110faf8:	180b883a 	mov	r5,r3
8110fafc:	1009883a 	mov	r4,r2
8110fb00:	111b3900 	call	8111b390 <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
8110fb04:	01204574 	movhi	r4,33045
8110fb08:	21340e04 	addi	r4,r4,-12232
8110fb0c:	111037c0 	call	8111037c <bSendMessagePUStoMebTask>

									break;
8110fb10:	00004b06 	br	8110fc40 <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110fb14:	e0bfdec4 	addi	r2,fp,-133
8110fb18:	01802004 	movi	r6,128
8110fb1c:	000b883a 	mov	r5,zero
8110fb20:	1009883a 	mov	r4,r2
8110fb24:	111c5900 	call	8111c590 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8110fb28:	e0ffde0b 	ldhu	r3,-136(fp)
8110fb2c:	e0bfdec4 	addi	r2,fp,-133
8110fb30:	180d883a 	mov	r6,r3
8110fb34:	01604534 	movhi	r5,33044
8110fb38:	295e2304 	addi	r5,r5,30860
8110fb3c:	1009883a 	mov	r4,r2
8110fb40:	111cd200 	call	8111cd20 <sprintf>
										debug(fp, cPUSDebug );
8110fb44:	d0a05c17 	ldw	r2,-32400(gp)
8110fb48:	e0ffdec4 	addi	r3,fp,-133
8110fb4c:	180b883a 	mov	r5,r3
8110fb50:	1009883a 	mov	r4,r2
8110fb54:	111b3900 	call	8111b390 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8110fb58:	01204574 	movhi	r4,33045
8110fb5c:	21340e04 	addi	r4,r4,-12232
8110fb60:	111037c0 	call	8111037c <bSendMessagePUStoMebTask>

									break;
8110fb64:	00003606 	br	8110fc40 <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110fb68:	e0bfdec4 	addi	r2,fp,-133
8110fb6c:	01802004 	movi	r6,128
8110fb70:	000b883a 	mov	r5,zero
8110fb74:	1009883a 	mov	r4,r2
8110fb78:	111c5900 	call	8111c590 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8110fb7c:	e0ffde0b 	ldhu	r3,-136(fp)
8110fb80:	e0bfdec4 	addi	r2,fp,-133
8110fb84:	180d883a 	mov	r6,r3
8110fb88:	01604534 	movhi	r5,33044
8110fb8c:	295e3304 	addi	r5,r5,30924
8110fb90:	1009883a 	mov	r4,r2
8110fb94:	111cd200 	call	8111cd20 <sprintf>
										debug(fp, cPUSDebug );
8110fb98:	d0a05c17 	ldw	r2,-32400(gp)
8110fb9c:	e0ffdec4 	addi	r3,fp,-133
8110fba0:	180b883a 	mov	r5,r3
8110fba4:	1009883a 	mov	r4,r2
8110fba8:	111b3900 	call	8111b390 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8110fbac:	01204574 	movhi	r4,33045
8110fbb0:	21340e04 	addi	r4,r4,-12232
8110fbb4:	111037c0 	call	8111037c <bSendMessagePUStoMebTask>

									break;
8110fbb8:	00002106 	br	8110fc40 <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110fbbc:	e0bfdec4 	addi	r2,fp,-133
8110fbc0:	01802004 	movi	r6,128
8110fbc4:	000b883a 	mov	r5,zero
8110fbc8:	1009883a 	mov	r4,r2
8110fbcc:	111c5900 	call	8111c590 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110fbd0:	00a04574 	movhi	r2,33045
8110fbd4:	10b40e04 	addi	r2,r2,-12232
8110fbd8:	1080030b 	ldhu	r2,12(r2)
8110fbdc:	113fffcc 	andi	r4,r2,65535
8110fbe0:	00a04574 	movhi	r2,33045
8110fbe4:	10b40e04 	addi	r2,r2,-12232
8110fbe8:	1080038b 	ldhu	r2,14(r2)
8110fbec:	117fffcc 	andi	r5,r2,65535
8110fbf0:	00a04574 	movhi	r2,33045
8110fbf4:	10b40e04 	addi	r2,r2,-12232
8110fbf8:	1080040b 	ldhu	r2,16(r2)
8110fbfc:	10bfffcc 	andi	r2,r2,65535
8110fc00:	e0ffdec4 	addi	r3,fp,-133
8110fc04:	d8800015 	stw	r2,0(sp)
8110fc08:	280f883a 	mov	r7,r5
8110fc0c:	200d883a 	mov	r6,r4
8110fc10:	01604534 	movhi	r5,33044
8110fc14:	295dd304 	addi	r5,r5,30540
8110fc18:	1809883a 	mov	r4,r3
8110fc1c:	111cd200 	call	8111cd20 <sprintf>
										debug(fp, cPUSDebug );
8110fc20:	d0a05c17 	ldw	r2,-32400(gp)
8110fc24:	e0ffdec4 	addi	r3,fp,-133
8110fc28:	180b883a 	mov	r5,r3
8110fc2c:	1009883a 	mov	r4,r2
8110fc30:	111b3900 	call	8111b390 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
8110fc34:	00800044 	movi	r2,1
8110fc38:	e0bfdc15 	stw	r2,-144(fp)
									break;
8110fc3c:	0001883a 	nop
							}
						}
                        break;
8110fc40:	00018306 	br	81110250 <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8110fc44:	00a04574 	movhi	r2,33045
8110fc48:	10b3fb04 	addi	r2,r2,-12308
8110fc4c:	1080050b 	ldhu	r2,20(r2)
8110fc50:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8110fc54:	00a04574 	movhi	r2,33045
8110fc58:	10b40e04 	addi	r2,r2,-12232
8110fc5c:	10800483 	ldbu	r2,18(r2)
8110fc60:	10c03fcc 	andi	r3,r2,255
8110fc64:	00a04574 	movhi	r2,33045
8110fc68:	10b40e04 	addi	r2,r2,-12232
8110fc6c:	18c00284 	addi	r3,r3,10
8110fc70:	18c7883a 	add	r3,r3,r3
8110fc74:	10c5883a 	add	r2,r2,r3
8110fc78:	e0ffde0b 	ldhu	r3,-136(fp)
8110fc7c:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
8110fc80:	00a04574 	movhi	r2,33045
8110fc84:	10b40e04 	addi	r2,r2,-12232
8110fc88:	10800483 	ldbu	r2,18(r2)
8110fc8c:	10800044 	addi	r2,r2,1
8110fc90:	1007883a 	mov	r3,r2
8110fc94:	00a04574 	movhi	r2,33045
8110fc98:	10b40e04 	addi	r2,r2,-12232
8110fc9c:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
8110fca0:	00a04574 	movhi	r2,33045
8110fca4:	10b40e04 	addi	r2,r2,-12232
8110fca8:	1080038b 	ldhu	r2,14(r2)
8110fcac:	10bfffcc 	andi	r2,r2,65535
8110fcb0:	10c000e0 	cmpeqi	r3,r2,3
8110fcb4:	18000a1e 	bne	r3,zero,8110fce0 <vParserCommTask+0x86c>
8110fcb8:	10c00108 	cmpgei	r3,r2,4
8110fcbc:	1800031e 	bne	r3,zero,8110fccc <vParserCommTask+0x858>
8110fcc0:	108000a0 	cmpeqi	r2,r2,2
8110fcc4:	1000451e 	bne	r2,zero,8110fddc <vParserCommTask+0x968>
8110fcc8:	00013c06 	br	811101bc <vParserCommTask+0xd48>
8110fccc:	10c00120 	cmpeqi	r3,r2,4
8110fcd0:	1800181e 	bne	r3,zero,8110fd34 <vParserCommTask+0x8c0>
8110fcd4:	10800160 	cmpeqi	r2,r2,5
8110fcd8:	10002b1e 	bne	r2,zero,8110fd88 <vParserCommTask+0x914>
8110fcdc:	00013706 	br	811101bc <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110fce0:	e0bfdec4 	addi	r2,fp,-133
8110fce4:	01802004 	movi	r6,128
8110fce8:	000b883a 	mov	r5,zero
8110fcec:	1009883a 	mov	r4,r2
8110fcf0:	111c5900 	call	8111c590 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8110fcf4:	e0ffde0b 	ldhu	r3,-136(fp)
8110fcf8:	e0bfdec4 	addi	r2,fp,-133
8110fcfc:	180d883a 	mov	r6,r3
8110fd00:	01604534 	movhi	r5,33044
8110fd04:	295e4504 	addi	r5,r5,30996
8110fd08:	1009883a 	mov	r4,r2
8110fd0c:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
8110fd10:	d0a05c17 	ldw	r2,-32400(gp)
8110fd14:	e0ffdec4 	addi	r3,fp,-133
8110fd18:	180b883a 	mov	r5,r3
8110fd1c:	1009883a 	mov	r4,r2
8110fd20:	111b3900 	call	8111b390 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110fd24:	01204574 	movhi	r4,33045
8110fd28:	21340e04 	addi	r4,r4,-12232
8110fd2c:	111037c0 	call	8111037c <bSendMessagePUStoMebTask>

								break;
8110fd30:	00014306 	br	81110240 <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110fd34:	e0bfdec4 	addi	r2,fp,-133
8110fd38:	01802004 	movi	r6,128
8110fd3c:	000b883a 	mov	r5,zero
8110fd40:	1009883a 	mov	r4,r2
8110fd44:	111c5900 	call	8111c590 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8110fd48:	e0ffde0b 	ldhu	r3,-136(fp)
8110fd4c:	e0bfdec4 	addi	r2,fp,-133
8110fd50:	180d883a 	mov	r6,r3
8110fd54:	01604534 	movhi	r5,33044
8110fd58:	295e5504 	addi	r5,r5,31060
8110fd5c:	1009883a 	mov	r4,r2
8110fd60:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
8110fd64:	d0a05c17 	ldw	r2,-32400(gp)
8110fd68:	e0ffdec4 	addi	r3,fp,-133
8110fd6c:	180b883a 	mov	r5,r3
8110fd70:	1009883a 	mov	r4,r2
8110fd74:	111b3900 	call	8111b390 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110fd78:	01204574 	movhi	r4,33045
8110fd7c:	21340e04 	addi	r4,r4,-12232
8110fd80:	111037c0 	call	8111037c <bSendMessagePUStoMebTask>

								break;
8110fd84:	00012e06 	br	81110240 <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110fd88:	e0bfdec4 	addi	r2,fp,-133
8110fd8c:	01802004 	movi	r6,128
8110fd90:	000b883a 	mov	r5,zero
8110fd94:	1009883a 	mov	r4,r2
8110fd98:	111c5900 	call	8111c590 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8110fd9c:	e0ffde0b 	ldhu	r3,-136(fp)
8110fda0:	e0bfdec4 	addi	r2,fp,-133
8110fda4:	180d883a 	mov	r6,r3
8110fda8:	01604534 	movhi	r5,33044
8110fdac:	295e6504 	addi	r5,r5,31124
8110fdb0:	1009883a 	mov	r4,r2
8110fdb4:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
8110fdb8:	d0a05c17 	ldw	r2,-32400(gp)
8110fdbc:	e0ffdec4 	addi	r3,fp,-133
8110fdc0:	180b883a 	mov	r5,r3
8110fdc4:	1009883a 	mov	r4,r2
8110fdc8:	111b3900 	call	8111b390 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110fdcc:	01204574 	movhi	r4,33045
8110fdd0:	21340e04 	addi	r4,r4,-12232
8110fdd4:	111037c0 	call	8111037c <bSendMessagePUStoMebTask>

								break;
8110fdd8:	00011906 	br	81110240 <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
8110fddc:	00a04574 	movhi	r2,33045
8110fde0:	10b40e04 	addi	r2,r2,-12232
8110fde4:	10800483 	ldbu	r2,18(r2)
8110fde8:	10c03fcc 	andi	r3,r2,255
8110fdec:	00a04574 	movhi	r2,33045
8110fdf0:	10b3fb04 	addi	r2,r2,-12308
8110fdf4:	1100058b 	ldhu	r4,22(r2)
8110fdf8:	00a04574 	movhi	r2,33045
8110fdfc:	10b40e04 	addi	r2,r2,-12232
8110fe00:	18c00284 	addi	r3,r3,10
8110fe04:	18c7883a 	add	r3,r3,r3
8110fe08:	10c5883a 	add	r2,r2,r3
8110fe0c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110fe10:	00a04574 	movhi	r2,33045
8110fe14:	10b40e04 	addi	r2,r2,-12232
8110fe18:	10800483 	ldbu	r2,18(r2)
8110fe1c:	10800044 	addi	r2,r2,1
8110fe20:	1007883a 	mov	r3,r2
8110fe24:	00a04574 	movhi	r2,33045
8110fe28:	10b40e04 	addi	r2,r2,-12232
8110fe2c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
8110fe30:	00a04574 	movhi	r2,33045
8110fe34:	10b40e04 	addi	r2,r2,-12232
8110fe38:	10800483 	ldbu	r2,18(r2)
8110fe3c:	10c03fcc 	andi	r3,r2,255
8110fe40:	00a04574 	movhi	r2,33045
8110fe44:	10b3fb04 	addi	r2,r2,-12308
8110fe48:	1100060b 	ldhu	r4,24(r2)
8110fe4c:	00a04574 	movhi	r2,33045
8110fe50:	10b40e04 	addi	r2,r2,-12232
8110fe54:	18c00284 	addi	r3,r3,10
8110fe58:	18c7883a 	add	r3,r3,r3
8110fe5c:	10c5883a 	add	r2,r2,r3
8110fe60:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110fe64:	00a04574 	movhi	r2,33045
8110fe68:	10b40e04 	addi	r2,r2,-12232
8110fe6c:	10800483 	ldbu	r2,18(r2)
8110fe70:	10800044 	addi	r2,r2,1
8110fe74:	1007883a 	mov	r3,r2
8110fe78:	00a04574 	movhi	r2,33045
8110fe7c:	10b40e04 	addi	r2,r2,-12232
8110fe80:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
8110fe84:	00a04574 	movhi	r2,33045
8110fe88:	10b40e04 	addi	r2,r2,-12232
8110fe8c:	10800483 	ldbu	r2,18(r2)
8110fe90:	10c03fcc 	andi	r3,r2,255
8110fe94:	00a04574 	movhi	r2,33045
8110fe98:	10b3fb04 	addi	r2,r2,-12308
8110fe9c:	1100068b 	ldhu	r4,26(r2)
8110fea0:	00a04574 	movhi	r2,33045
8110fea4:	10b40e04 	addi	r2,r2,-12232
8110fea8:	18c00284 	addi	r3,r3,10
8110feac:	18c7883a 	add	r3,r3,r3
8110feb0:	10c5883a 	add	r2,r2,r3
8110feb4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110feb8:	00a04574 	movhi	r2,33045
8110febc:	10b40e04 	addi	r2,r2,-12232
8110fec0:	10800483 	ldbu	r2,18(r2)
8110fec4:	10800044 	addi	r2,r2,1
8110fec8:	1007883a 	mov	r3,r2
8110fecc:	00a04574 	movhi	r2,33045
8110fed0:	10b40e04 	addi	r2,r2,-12232
8110fed4:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
8110fed8:	00a04574 	movhi	r2,33045
8110fedc:	10b40e04 	addi	r2,r2,-12232
8110fee0:	10800483 	ldbu	r2,18(r2)
8110fee4:	10c03fcc 	andi	r3,r2,255
8110fee8:	00a04574 	movhi	r2,33045
8110feec:	10b3fb04 	addi	r2,r2,-12308
8110fef0:	1100070b 	ldhu	r4,28(r2)
8110fef4:	00a04574 	movhi	r2,33045
8110fef8:	10b40e04 	addi	r2,r2,-12232
8110fefc:	18c00284 	addi	r3,r3,10
8110ff00:	18c7883a 	add	r3,r3,r3
8110ff04:	10c5883a 	add	r2,r2,r3
8110ff08:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110ff0c:	00a04574 	movhi	r2,33045
8110ff10:	10b40e04 	addi	r2,r2,-12232
8110ff14:	10800483 	ldbu	r2,18(r2)
8110ff18:	10800044 	addi	r2,r2,1
8110ff1c:	1007883a 	mov	r3,r2
8110ff20:	00a04574 	movhi	r2,33045
8110ff24:	10b40e04 	addi	r2,r2,-12232
8110ff28:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
8110ff2c:	00a04574 	movhi	r2,33045
8110ff30:	10b40e04 	addi	r2,r2,-12232
8110ff34:	10800483 	ldbu	r2,18(r2)
8110ff38:	10c03fcc 	andi	r3,r2,255
8110ff3c:	00a04574 	movhi	r2,33045
8110ff40:	10b3fb04 	addi	r2,r2,-12308
8110ff44:	1100078b 	ldhu	r4,30(r2)
8110ff48:	00a04574 	movhi	r2,33045
8110ff4c:	10b40e04 	addi	r2,r2,-12232
8110ff50:	18c00284 	addi	r3,r3,10
8110ff54:	18c7883a 	add	r3,r3,r3
8110ff58:	10c5883a 	add	r2,r2,r3
8110ff5c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110ff60:	00a04574 	movhi	r2,33045
8110ff64:	10b40e04 	addi	r2,r2,-12232
8110ff68:	10800483 	ldbu	r2,18(r2)
8110ff6c:	10800044 	addi	r2,r2,1
8110ff70:	1007883a 	mov	r3,r2
8110ff74:	00a04574 	movhi	r2,33045
8110ff78:	10b40e04 	addi	r2,r2,-12232
8110ff7c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
8110ff80:	00a04574 	movhi	r2,33045
8110ff84:	10b40e04 	addi	r2,r2,-12232
8110ff88:	10800483 	ldbu	r2,18(r2)
8110ff8c:	10c03fcc 	andi	r3,r2,255
8110ff90:	00a04574 	movhi	r2,33045
8110ff94:	10b3fb04 	addi	r2,r2,-12308
8110ff98:	1100080b 	ldhu	r4,32(r2)
8110ff9c:	00a04574 	movhi	r2,33045
8110ffa0:	10b40e04 	addi	r2,r2,-12232
8110ffa4:	18c00284 	addi	r3,r3,10
8110ffa8:	18c7883a 	add	r3,r3,r3
8110ffac:	10c5883a 	add	r2,r2,r3
8110ffb0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110ffb4:	00a04574 	movhi	r2,33045
8110ffb8:	10b40e04 	addi	r2,r2,-12232
8110ffbc:	10800483 	ldbu	r2,18(r2)
8110ffc0:	10800044 	addi	r2,r2,1
8110ffc4:	1007883a 	mov	r3,r2
8110ffc8:	00a04574 	movhi	r2,33045
8110ffcc:	10b40e04 	addi	r2,r2,-12232
8110ffd0:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110ffd4:	e0bfdec4 	addi	r2,fp,-133
8110ffd8:	01802004 	movi	r6,128
8110ffdc:	000b883a 	mov	r5,zero
8110ffe0:	1009883a 	mov	r4,r2
8110ffe4:	111c5900 	call	8111c590 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
8110ffe8:	e0ffdec4 	addi	r3,fp,-133
8110ffec:	00a04534 	movhi	r2,33044
8110fff0:	109e7404 	addi	r2,r2,31184
8110fff4:	1009883a 	mov	r4,r2
8110fff8:	00800b84 	movi	r2,46
8110fffc:	100d883a 	mov	r6,r2
81110000:	200b883a 	mov	r5,r4
81110004:	1809883a 	mov	r4,r3
81110008:	111c4400 	call	8111c440 <memcpy>
									debug(fp, cPUSDebug );
8111000c:	d0a05c17 	ldw	r2,-32400(gp)
81110010:	e0ffdec4 	addi	r3,fp,-133
81110014:	180b883a 	mov	r5,r3
81110018:	1009883a 	mov	r4,r2
8111001c:	111b3900 	call	8111b390 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81110020:	e0ffde0b 	ldhu	r3,-136(fp)
81110024:	e0bfdec4 	addi	r2,fp,-133
81110028:	180d883a 	mov	r6,r3
8111002c:	01604534 	movhi	r5,33044
81110030:	295e8004 	addi	r5,r5,31232
81110034:	1009883a 	mov	r4,r2
81110038:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
8111003c:	d0a05c17 	ldw	r2,-32400(gp)
81110040:	e0ffdec4 	addi	r3,fp,-133
81110044:	180b883a 	mov	r5,r3
81110048:	1009883a 	mov	r4,r2
8111004c:	111b3900 	call	8111b390 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81110050:	00a04574 	movhi	r2,33045
81110054:	10b3fb04 	addi	r2,r2,-12308
81110058:	1080058b 	ldhu	r2,22(r2)
8111005c:	10ffffcc 	andi	r3,r2,65535
81110060:	e0bfdec4 	addi	r2,fp,-133
81110064:	180d883a 	mov	r6,r3
81110068:	01604534 	movhi	r5,33044
8111006c:	295e8704 	addi	r5,r5,31260
81110070:	1009883a 	mov	r4,r2
81110074:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
81110078:	d0a05c17 	ldw	r2,-32400(gp)
8111007c:	e0ffdec4 	addi	r3,fp,-133
81110080:	180b883a 	mov	r5,r3
81110084:	1009883a 	mov	r4,r2
81110088:	111b3900 	call	8111b390 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
8111008c:	00a04574 	movhi	r2,33045
81110090:	10b3fb04 	addi	r2,r2,-12308
81110094:	1080060b 	ldhu	r2,24(r2)
81110098:	10ffffcc 	andi	r3,r2,65535
8111009c:	e0bfdec4 	addi	r2,fp,-133
811100a0:	180d883a 	mov	r6,r3
811100a4:	01604534 	movhi	r5,33044
811100a8:	295e8b04 	addi	r5,r5,31276
811100ac:	1009883a 	mov	r4,r2
811100b0:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
811100b4:	d0a05c17 	ldw	r2,-32400(gp)
811100b8:	e0ffdec4 	addi	r3,fp,-133
811100bc:	180b883a 	mov	r5,r3
811100c0:	1009883a 	mov	r4,r2
811100c4:	111b3900 	call	8111b390 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
811100c8:	00a04574 	movhi	r2,33045
811100cc:	10b3fb04 	addi	r2,r2,-12308
811100d0:	1080068b 	ldhu	r2,26(r2)
811100d4:	10ffffcc 	andi	r3,r2,65535
811100d8:	e0bfdec4 	addi	r2,fp,-133
811100dc:	180d883a 	mov	r6,r3
811100e0:	01604534 	movhi	r5,33044
811100e4:	295e9004 	addi	r5,r5,31296
811100e8:	1009883a 	mov	r4,r2
811100ec:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
811100f0:	d0a05c17 	ldw	r2,-32400(gp)
811100f4:	e0ffdec4 	addi	r3,fp,-133
811100f8:	180b883a 	mov	r5,r3
811100fc:	1009883a 	mov	r4,r2
81110100:	111b3900 	call	8111b390 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81110104:	00a04574 	movhi	r2,33045
81110108:	10b3fb04 	addi	r2,r2,-12308
8111010c:	1080070b 	ldhu	r2,28(r2)
81110110:	10ffffcc 	andi	r3,r2,65535
81110114:	e0bfdec4 	addi	r2,fp,-133
81110118:	180d883a 	mov	r6,r3
8111011c:	01604534 	movhi	r5,33044
81110120:	295e9704 	addi	r5,r5,31324
81110124:	1009883a 	mov	r4,r2
81110128:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
8111012c:	d0a05c17 	ldw	r2,-32400(gp)
81110130:	e0ffdec4 	addi	r3,fp,-133
81110134:	180b883a 	mov	r5,r3
81110138:	1009883a 	mov	r4,r2
8111013c:	111b3900 	call	8111b390 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81110140:	00a04574 	movhi	r2,33045
81110144:	10b3fb04 	addi	r2,r2,-12308
81110148:	1080078b 	ldhu	r2,30(r2)
8111014c:	10ffffcc 	andi	r3,r2,65535
81110150:	e0bfdec4 	addi	r2,fp,-133
81110154:	180d883a 	mov	r6,r3
81110158:	01604534 	movhi	r5,33044
8111015c:	295e9e04 	addi	r5,r5,31352
81110160:	1009883a 	mov	r4,r2
81110164:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
81110168:	d0a05c17 	ldw	r2,-32400(gp)
8111016c:	e0ffdec4 	addi	r3,fp,-133
81110170:	180b883a 	mov	r5,r3
81110174:	1009883a 	mov	r4,r2
81110178:	111b3900 	call	8111b390 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
8111017c:	00a04574 	movhi	r2,33045
81110180:	10b3fb04 	addi	r2,r2,-12308
81110184:	1080080b 	ldhu	r2,32(r2)
81110188:	10ffffcc 	andi	r3,r2,65535
8111018c:	e0bfdec4 	addi	r2,fp,-133
81110190:	180d883a 	mov	r6,r3
81110194:	01604534 	movhi	r5,33044
81110198:	295ea404 	addi	r5,r5,31376
8111019c:	1009883a 	mov	r4,r2
811101a0:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
811101a4:	d0a05c17 	ldw	r2,-32400(gp)
811101a8:	e0ffdec4 	addi	r3,fp,-133
811101ac:	180b883a 	mov	r5,r3
811101b0:	1009883a 	mov	r4,r2
811101b4:	111b3900 	call	8111b390 <fprintf>
								#endif

								break;
811101b8:	00002106 	br	81110240 <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811101bc:	e0bfdec4 	addi	r2,fp,-133
811101c0:	01802004 	movi	r6,128
811101c4:	000b883a 	mov	r5,zero
811101c8:	1009883a 	mov	r4,r2
811101cc:	111c5900 	call	8111c590 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811101d0:	00a04574 	movhi	r2,33045
811101d4:	10b40e04 	addi	r2,r2,-12232
811101d8:	1080030b 	ldhu	r2,12(r2)
811101dc:	113fffcc 	andi	r4,r2,65535
811101e0:	00a04574 	movhi	r2,33045
811101e4:	10b40e04 	addi	r2,r2,-12232
811101e8:	1080038b 	ldhu	r2,14(r2)
811101ec:	117fffcc 	andi	r5,r2,65535
811101f0:	00a04574 	movhi	r2,33045
811101f4:	10b40e04 	addi	r2,r2,-12232
811101f8:	1080040b 	ldhu	r2,16(r2)
811101fc:	10bfffcc 	andi	r2,r2,65535
81110200:	e0ffdec4 	addi	r3,fp,-133
81110204:	d8800015 	stw	r2,0(sp)
81110208:	280f883a 	mov	r7,r5
8111020c:	200d883a 	mov	r6,r4
81110210:	01604534 	movhi	r5,33044
81110214:	295dd304 	addi	r5,r5,30540
81110218:	1809883a 	mov	r4,r3
8111021c:	111cd200 	call	8111cd20 <sprintf>
									debug(fp, cPUSDebug );
81110220:	d0a05c17 	ldw	r2,-32400(gp)
81110224:	e0ffdec4 	addi	r3,fp,-133
81110228:	180b883a 	mov	r5,r3
8111022c:	1009883a 	mov	r4,r2
81110230:	111b3900 	call	8111b390 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81110234:	00800044 	movi	r2,1
81110238:	e0bfdc15 	stw	r2,-144(fp)
								break;
8111023c:	0001883a 	nop
						}
                        break;
81110240:	00000306 	br	81110250 <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
81110244:	00800044 	movi	r2,1
81110248:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8111024c:	0001883a 	nop
                }
				break;				
81110250:	00000306 	br	81110260 <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
81110254:	00800044 	movi	r2,1
81110258:	e0bfdc15 	stw	r2,-144(fp)
				break;
8111025c:	0001883a 	nop
		}
	}
81110260:	003c9406 	br	8110f4b4 <__reset+0xfb0ef4b4>

81110264 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81110264:	defffb04 	addi	sp,sp,-20
81110268:	de00012e 	bgeu	sp,et,81110270 <getPreParsedPacket+0xc>
8111026c:	003b68fa 	trap	3
81110270:	dfc00415 	stw	ra,16(sp)
81110274:	df000315 	stw	fp,12(sp)
81110278:	df000304 	addi	fp,sp,12
8111027c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110280:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81110284:	d0a06517 	ldw	r2,-32364(gp)
81110288:	e0fffe44 	addi	r3,fp,-7
8111028c:	180d883a 	mov	r6,r3
81110290:	000b883a 	mov	r5,zero
81110294:	1009883a 	mov	r4,r2
81110298:	11374600 	call	81137460 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
8111029c:	e0bffe43 	ldbu	r2,-7(fp)
811102a0:	10803fcc 	andi	r2,r2,255
811102a4:	10002e1e 	bne	r2,zero,81110360 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
811102a8:	e03ffe05 	stb	zero,-8(fp)
811102ac:	00002506 	br	81110344 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
811102b0:	e0fffe03 	ldbu	r3,-8(fp)
811102b4:	00a045b4 	movhi	r2,33046
811102b8:	1080d804 	addi	r2,r2,864
811102bc:	18c01324 	muli	r3,r3,76
811102c0:	10c5883a 	add	r2,r2,r3
811102c4:	10800104 	addi	r2,r2,4
811102c8:	10800003 	ldbu	r2,0(r2)
811102cc:	10803fcc 	andi	r2,r2,255
811102d0:	1080201c 	xori	r2,r2,128
811102d4:	10bfe004 	addi	r2,r2,-128
811102d8:	10001726 	beq	r2,zero,81110338 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
811102dc:	e0fffe03 	ldbu	r3,-8(fp)
811102e0:	e13fff17 	ldw	r4,-4(fp)
811102e4:	00a045b4 	movhi	r2,33046
811102e8:	1080d804 	addi	r2,r2,864
811102ec:	18c01324 	muli	r3,r3,76
811102f0:	10c5883a 	add	r2,r2,r3
811102f4:	2007883a 	mov	r3,r4
811102f8:	1009883a 	mov	r4,r2
811102fc:	00801304 	movi	r2,76
81110300:	100d883a 	mov	r6,r2
81110304:	200b883a 	mov	r5,r4
81110308:	1809883a 	mov	r4,r3
8111030c:	111c4400 	call	8111c440 <memcpy>
                bSuccess = TRUE;
81110310:	00800044 	movi	r2,1
81110314:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81110318:	e0fffe03 	ldbu	r3,-8(fp)
8111031c:	00a045b4 	movhi	r2,33046
81110320:	1080d804 	addi	r2,r2,864
81110324:	18c01324 	muli	r3,r3,76
81110328:	10c5883a 	add	r2,r2,r3
8111032c:	10800104 	addi	r2,r2,4
81110330:	10000005 	stb	zero,0(r2)
                break;
81110334:	00000606 	br	81110350 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81110338:	e0bffe03 	ldbu	r2,-8(fp)
8111033c:	10800044 	addi	r2,r2,1
81110340:	e0bffe05 	stb	r2,-8(fp)
81110344:	e0bffe03 	ldbu	r2,-8(fp)
81110348:	10800230 	cmpltui	r2,r2,8
8111034c:	103fd81e 	bne	r2,zero,811102b0 <__reset+0xfb0f02b0>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81110350:	d0a06517 	ldw	r2,-32364(gp)
81110354:	1009883a 	mov	r4,r2
81110358:	1137a040 	call	81137a04 <OSMutexPost>
8111035c:	00000106 	br	81110364 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81110360:	1116f580 	call	81116f58 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81110364:	e0bffd17 	ldw	r2,-12(fp)
}
81110368:	e037883a 	mov	sp,fp
8111036c:	dfc00117 	ldw	ra,4(sp)
81110370:	df000017 	ldw	fp,0(sp)
81110374:	dec00204 	addi	sp,sp,8
81110378:	f800283a 	ret

8111037c <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
8111037c:	defffa04 	addi	sp,sp,-24
81110380:	de00012e 	bgeu	sp,et,81110388 <bSendMessagePUStoMebTask+0xc>
81110384:	003b68fa 	trap	3
81110388:	dfc00515 	stw	ra,20(sp)
8111038c:	df000415 	stw	fp,16(sp)
81110390:	df000404 	addi	fp,sp,16
81110394:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110398:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
8111039c:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
811103a0:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
811103a4:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
811103a8:	d0a06d17 	ldw	r2,-32332(gp)
811103ac:	e0fffd44 	addi	r3,fp,-11
811103b0:	180d883a 	mov	r6,r3
811103b4:	01400284 	movi	r5,10
811103b8:	1009883a 	mov	r4,r2
811103bc:	11374600 	call	81137460 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811103c0:	e0bffd43 	ldbu	r2,-11(fp)
811103c4:	10803fcc 	andi	r2,r2,255
811103c8:	1000401e 	bne	r2,zero,811104cc <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
811103cc:	e03ffd05 	stb	zero,-12(fp)
811103d0:	00003806 	br	811104b4 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
811103d4:	e0fffd03 	ldbu	r3,-12(fp)
811103d8:	00a04574 	movhi	r2,33045
811103dc:	10be2d04 	addi	r2,r2,-1868
811103e0:	18c01524 	muli	r3,r3,84
811103e4:	10c5883a 	add	r2,r2,r3
811103e8:	10800104 	addi	r2,r2,4
811103ec:	10800017 	ldw	r2,0(r2)
811103f0:	10002d1e 	bne	r2,zero,811104a8 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
811103f4:	e0fffd03 	ldbu	r3,-12(fp)
811103f8:	00a04574 	movhi	r2,33045
811103fc:	10be2d04 	addi	r2,r2,-1868
81110400:	18c01524 	muli	r3,r3,84
81110404:	10c7883a 	add	r3,r2,r3
81110408:	e0bfff17 	ldw	r2,-4(fp)
8111040c:	1009883a 	mov	r4,r2
81110410:	00801504 	movi	r2,84
81110414:	100d883a 	mov	r6,r2
81110418:	200b883a 	mov	r5,r4
8111041c:	1809883a 	mov	r4,r3
81110420:	111c4400 	call	8111c440 <memcpy>
            	xPus[i].bInUse = TRUE;
81110424:	e0fffd03 	ldbu	r3,-12(fp)
81110428:	00a04574 	movhi	r2,33045
8111042c:	10be2d04 	addi	r2,r2,-1868
81110430:	18c01524 	muli	r3,r3,84
81110434:	10c5883a 	add	r2,r2,r3
81110438:	10800104 	addi	r2,r2,4
8111043c:	00c00044 	movi	r3,1
81110440:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81110444:	00800044 	movi	r2,1
81110448:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
8111044c:	00800044 	movi	r2,1
81110450:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81110454:	d0a06317 	ldw	r2,-32372(gp)
81110458:	e0fffe17 	ldw	r3,-8(fp)
8111045c:	180b883a 	mov	r5,r3
81110460:	1009883a 	mov	r4,r2
81110464:	113897c0 	call	8113897c <OSQPost>
81110468:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
8111046c:	e0bffd43 	ldbu	r2,-11(fp)
81110470:	10803fcc 	andi	r2,r2,255
81110474:	10000926 	beq	r2,zero,8111049c <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
81110478:	1117e480 	call	81117e48 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
8111047c:	e0fffd03 	ldbu	r3,-12(fp)
81110480:	00a04574 	movhi	r2,33045
81110484:	10be2d04 	addi	r2,r2,-1868
81110488:	18c01524 	muli	r3,r3,84
8111048c:	10c5883a 	add	r2,r2,r3
81110490:	10800104 	addi	r2,r2,4
81110494:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81110498:	00000906 	br	811104c0 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
8111049c:	00800044 	movi	r2,1
811104a0:	e0bffc15 	stw	r2,-16(fp)
                break;
811104a4:	00000606 	br	811104c0 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
811104a8:	e0bffd03 	ldbu	r2,-12(fp)
811104ac:	10800044 	addi	r2,r2,1
811104b0:	e0bffd05 	stb	r2,-12(fp)
811104b4:	e0bffd03 	ldbu	r2,-12(fp)
811104b8:	10800130 	cmpltui	r2,r2,4
811104bc:	103fc51e 	bne	r2,zero,811103d4 <__reset+0xfb0f03d4>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
811104c0:	d0a06d17 	ldw	r2,-32332(gp)
811104c4:	1009883a 	mov	r4,r2
811104c8:	1137a040 	call	81137a04 <OSMutexPost>
    }

    return bSuccess;
811104cc:	e0bffc17 	ldw	r2,-16(fp)
}
811104d0:	e037883a 	mov	sp,fp
811104d4:	dfc00117 	ldw	ra,4(sp)
811104d8:	df000017 	ldw	fp,0(sp)
811104dc:	dec00204 	addi	sp,sp,8
811104e0:	f800283a 	ret

811104e4 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
811104e4:	deffab04 	addi	sp,sp,-340
811104e8:	de00012e 	bgeu	sp,et,811104f0 <vReceiverUartTask+0xc>
811104ec:	003b68fa 	trap	3
811104f0:	dfc05415 	stw	ra,336(sp)
811104f4:	df005315 	stw	fp,332(sp)
811104f8:	df005304 	addi	fp,sp,332
811104fc:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110500:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
81110504:	d0a05c17 	ldw	r2,-32400(gp)
81110508:	100f883a 	mov	r7,r2
8111050c:	01800784 	movi	r6,30
81110510:	01400044 	movi	r5,1
81110514:	01204534 	movhi	r4,33044
81110518:	211eaa04 	addi	r4,r4,31400
8111051c:	111ba2c0 	call	8111ba2c <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
81110520:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81110524:	e0bfad17 	ldw	r2,-332(fp)
81110528:	10c00060 	cmpeqi	r3,r2,1
8111052c:	1800091e 	bne	r3,zero,81110554 <vReceiverUartTask+0x70>
81110530:	0080052e 	bgeu	zero,r2,81110548 <vReceiverUartTask+0x64>
81110534:	10c000a0 	cmpeqi	r3,r2,2
81110538:	18005d1e 	bne	r3,zero,811106b0 <vReceiverUartTask+0x1cc>
8111053c:	108000e0 	cmpeqi	r2,r2,3
81110540:	10006e1e 	bne	r2,zero,811106fc <vReceiverUartTask+0x218>
81110544:	00007706 	br	81110724 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
81110548:	00800044 	movi	r2,1
8111054c:	e0bfad15 	stw	r2,-332(fp)
                break;
81110550:	00007706 	br	81110730 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81110554:	e0bfaf04 	addi	r2,fp,-324
81110558:	01802004 	movi	r6,128
8111055c:	000b883a 	mov	r5,zero
81110560:	1009883a 	mov	r4,r2
81110564:	111c5900 	call	8111c590 <memset>
                scanf("%s", cReceive);
81110568:	e0bfcf04 	addi	r2,fp,-196
8111056c:	100b883a 	mov	r5,r2
81110570:	01204534 	movhi	r4,33044
81110574:	211eb204 	addi	r4,r4,31432
81110578:	111cc440 	call	8111cc44 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
8111057c:	e0ffcf04 	addi	r3,fp,-196
81110580:	e0bfaf04 	addi	r2,fp,-324
81110584:	01801fc4 	movi	r6,127
81110588:	180b883a 	mov	r5,r3
8111058c:	1009883a 	mov	r4,r2
81110590:	111c4400 	call	8111c440 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81110594:	e0bfaf04 	addi	r2,fp,-324
81110598:	01604574 	movhi	r5,33045
8111059c:	29742304 	addi	r5,r5,-12148
811105a0:	1009883a 	mov	r4,r2
811105a4:	1110b880 	call	81110b88 <bPreParserV2>
811105a8:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
811105ac:	e0bfae17 	ldw	r2,-328(fp)
811105b0:	10800058 	cmpnei	r2,r2,1
811105b4:	1000281e 	bne	r2,zero,81110658 <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
811105b8:	00a04574 	movhi	r2,33045
811105bc:	10b42304 	addi	r2,r2,-12148
811105c0:	10800103 	ldbu	r2,4(r2)
811105c4:	10803fcc 	andi	r2,r2,255
811105c8:	1080201c 	xori	r2,r2,128
811105cc:	10bfe004 	addi	r2,r2,-128
811105d0:	10800fe0 	cmpeqi	r2,r2,63
811105d4:	1000081e 	bne	r2,zero,811105f8 <vReceiverUartTask+0x114>
811105d8:	00a04574 	movhi	r2,33045
811105dc:	10b42304 	addi	r2,r2,-12148
811105e0:	10800103 	ldbu	r2,4(r2)
811105e4:	10803fcc 	andi	r2,r2,255
811105e8:	1080201c 	xori	r2,r2,128
811105ec:	10bfe004 	addi	r2,r2,-128
811105f0:	10800858 	cmpnei	r2,r2,33
811105f4:	1000031e 	bne	r2,zero,81110604 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
811105f8:	00800084 	movi	r2,2
811105fc:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81110600:	00004b06 	br	81110730 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81110604:	00a04574 	movhi	r2,33045
81110608:	10b42304 	addi	r2,r2,-12148
8111060c:	10800103 	ldbu	r2,4(r2)
81110610:	10803fcc 	andi	r2,r2,255
81110614:	1080201c 	xori	r2,r2,128
81110618:	10bfe004 	addi	r2,r2,-128
8111061c:	108008d8 	cmpnei	r2,r2,35
81110620:	10000a1e 	bne	r2,zero,8111064c <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
81110624:	00800044 	movi	r2,1
81110628:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
8111062c:	d0a05c17 	ldw	r2,-32400(gp)
81110630:	100f883a 	mov	r7,r2
81110634:	018006c4 	movi	r6,27
81110638:	01400044 	movi	r5,1
8111063c:	01204534 	movhi	r4,33044
81110640:	211eb304 	addi	r4,r4,31436
81110644:	111ba2c0 	call	8111ba2c <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81110648:	00003906 	br	81110730 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
8111064c:	008000c4 	movi	r2,3
81110650:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81110654:	00003606 	br	81110730 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81110658:	00a04574 	movhi	r2,33045
8111065c:	10b42304 	addi	r2,r2,-12148
81110660:	00c008c4 	movi	r3,35
81110664:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81110668:	00a04574 	movhi	r2,33045
8111066c:	10b42304 	addi	r2,r2,-12148
81110670:	00c00b84 	movi	r3,46
81110674:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81110678:	00a04574 	movhi	r2,33045
8111067c:	10b42304 	addi	r2,r2,-12148
81110680:	00c00044 	movi	r3,1
81110684:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81110688:	01204574 	movhi	r4,33045
8111068c:	21342304 	addi	r4,r4,-12148
81110690:	11108700 	call	81110870 <setPreAckSenderFreePos>
81110694:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81110698:	e0bfae17 	ldw	r2,-328(fp)
8111069c:	1000011e 	bne	r2,zero,811106a4 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
811106a0:	11170900 	call	81117090 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
811106a4:	00800044 	movi	r2,1
811106a8:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
811106ac:	00002006 	br	81110730 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
811106b0:	01204574 	movhi	r4,33045
811106b4:	21342304 	addi	r4,r4,-12148
811106b8:	11108700 	call	81110870 <setPreAckSenderFreePos>
811106bc:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
811106c0:	e0bfae17 	ldw	r2,-328(fp)
811106c4:	10800058 	cmpnei	r2,r2,1
811106c8:	1000081e 	bne	r2,zero,811106ec <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
811106cc:	01204574 	movhi	r4,33045
811106d0:	21342304 	addi	r4,r4,-12148
811106d4:	11107340 	call	81110734 <setPreParsedFreePos>
811106d8:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811106dc:	e0bfae17 	ldw	r2,-328(fp)
811106e0:	1000031e 	bne	r2,zero,811106f0 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
811106e4:	11171600 	call	81117160 <vFailSetPreParsedBuffer>
811106e8:	00000106 	br	811106f0 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
811106ec:	11170f80 	call	811170f8 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
811106f0:	00800044 	movi	r2,1
811106f4:	e0bfad15 	stw	r2,-332(fp)
                break;
811106f8:	00000d06 	br	81110730 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
811106fc:	01204574 	movhi	r4,33045
81110700:	21342304 	addi	r4,r4,-12148
81110704:	11109ec0 	call	811109ec <setPreAckReceiverFreePos>
81110708:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
8111070c:	e0bfae17 	ldw	r2,-328(fp)
81110710:	1000011e 	bne	r2,zero,81110718 <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81110714:	11171c80 	call	811171c8 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81110718:	00800044 	movi	r2,1
8111071c:	e0bfad15 	stw	r2,-332(fp)
                break;
81110720:	00000306 	br	81110730 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
81110724:	00800044 	movi	r2,1
81110728:	e0bfad15 	stw	r2,-332(fp)
                break;
8111072c:	0001883a 	nop
        }

    }
81110730:	003f7c06 	br	81110524 <__reset+0xfb0f0524>

81110734 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81110734:	defffb04 	addi	sp,sp,-20
81110738:	de00012e 	bgeu	sp,et,81110740 <setPreParsedFreePos+0xc>
8111073c:	003b68fa 	trap	3
81110740:	dfc00415 	stw	ra,16(sp)
81110744:	df000315 	stw	fp,12(sp)
81110748:	df000304 	addi	fp,sp,12
8111074c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110750:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110754:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110758:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8111075c:	d0a06517 	ldw	r2,-32364(gp)
81110760:	e0fffe44 	addi	r3,fp,-7
81110764:	180d883a 	mov	r6,r3
81110768:	01400284 	movi	r5,10
8111076c:	1009883a 	mov	r4,r2
81110770:	11374600 	call	81137460 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81110774:	e0bffe43 	ldbu	r2,-7(fp)
81110778:	10803fcc 	andi	r2,r2,255
8111077c:	1000361e 	bne	r2,zero,81110858 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81110780:	e03ffe05 	stb	zero,-8(fp)
81110784:	00002e06 	br	81110840 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81110788:	e0fffe03 	ldbu	r3,-8(fp)
8111078c:	00a045b4 	movhi	r2,33046
81110790:	1080d804 	addi	r2,r2,864
81110794:	18c01324 	muli	r3,r3,76
81110798:	10c5883a 	add	r2,r2,r3
8111079c:	10800104 	addi	r2,r2,4
811107a0:	10800003 	ldbu	r2,0(r2)
811107a4:	10803fcc 	andi	r2,r2,255
811107a8:	1080201c 	xori	r2,r2,128
811107ac:	10bfe004 	addi	r2,r2,-128
811107b0:	1000201e 	bne	r2,zero,81110834 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
811107b4:	e0fffe03 	ldbu	r3,-8(fp)
811107b8:	00a045b4 	movhi	r2,33046
811107bc:	1080d804 	addi	r2,r2,864
811107c0:	18c01324 	muli	r3,r3,76
811107c4:	10c7883a 	add	r3,r2,r3
811107c8:	e0bfff17 	ldw	r2,-4(fp)
811107cc:	1009883a 	mov	r4,r2
811107d0:	00801304 	movi	r2,76
811107d4:	100d883a 	mov	r6,r2
811107d8:	200b883a 	mov	r5,r4
811107dc:	1809883a 	mov	r4,r3
811107e0:	111c4400 	call	8111c440 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
811107e4:	d0a05e17 	ldw	r2,-32392(gp)
811107e8:	1009883a 	mov	r4,r2
811107ec:	11397f40 	call	811397f4 <OSSemPost>
811107f0:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811107f4:	e0bffe43 	ldbu	r2,-7(fp)
811107f8:	10803fcc 	andi	r2,r2,255
811107fc:	1000031e 	bne	r2,zero,8111080c <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81110800:	00800044 	movi	r2,1
81110804:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81110808:	00001006 	br	8111084c <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
8111080c:	11167b00 	call	811167b0 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81110810:	e0fffe03 	ldbu	r3,-8(fp)
81110814:	00a045b4 	movhi	r2,33046
81110818:	1080d804 	addi	r2,r2,864
8111081c:	18c01324 	muli	r3,r3,76
81110820:	10c5883a 	add	r2,r2,r3
81110824:	10800104 	addi	r2,r2,4
81110828:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
8111082c:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81110830:	00000606 	br	8111084c <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81110834:	e0bffe03 	ldbu	r2,-8(fp)
81110838:	10800044 	addi	r2,r2,1
8111083c:	e0bffe05 	stb	r2,-8(fp)
81110840:	e0bffe03 	ldbu	r2,-8(fp)
81110844:	10800230 	cmpltui	r2,r2,8
81110848:	103fcf1e 	bne	r2,zero,81110788 <__reset+0xfb0f0788>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
8111084c:	d0a06517 	ldw	r2,-32364(gp)
81110850:	1009883a 	mov	r4,r2
81110854:	1137a040 	call	81137a04 <OSMutexPost>
    }
    return bSuccess;
81110858:	e0bffd17 	ldw	r2,-12(fp)
}
8111085c:	e037883a 	mov	sp,fp
81110860:	dfc00117 	ldw	ra,4(sp)
81110864:	df000017 	ldw	fp,0(sp)
81110868:	dec00204 	addi	sp,sp,8
8111086c:	f800283a 	ret

81110870 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81110870:	defffb04 	addi	sp,sp,-20
81110874:	de00012e 	bgeu	sp,et,8111087c <setPreAckSenderFreePos+0xc>
81110878:	003b68fa 	trap	3
8111087c:	dfc00415 	stw	ra,16(sp)
81110880:	df000315 	stw	fp,12(sp)
81110884:	df000304 	addi	fp,sp,12
81110888:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111088c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110890:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110894:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81110898:	d0a06c17 	ldw	r2,-32336(gp)
8111089c:	e0fffe44 	addi	r3,fp,-7
811108a0:	180d883a 	mov	r6,r3
811108a4:	01400284 	movi	r5,10
811108a8:	1009883a 	mov	r4,r2
811108ac:	11374600 	call	81137460 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811108b0:	e0bffe43 	ldbu	r2,-7(fp)
811108b4:	10803fcc 	andi	r2,r2,255
811108b8:	1000461e 	bne	r2,zero,811109d4 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811108bc:	e03ffe05 	stb	zero,-8(fp)
811108c0:	00003e06 	br	811109bc <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
811108c4:	e0fffe03 	ldbu	r3,-8(fp)
811108c8:	00a045b4 	movhi	r2,33046
811108cc:	1080d004 	addi	r2,r2,832
811108d0:	18c7883a 	add	r3,r3,r3
811108d4:	18c7883a 	add	r3,r3,r3
811108d8:	10c5883a 	add	r2,r2,r3
811108dc:	10800003 	ldbu	r2,0(r2)
811108e0:	10803fcc 	andi	r2,r2,255
811108e4:	1080201c 	xori	r2,r2,128
811108e8:	10bfe004 	addi	r2,r2,-128
811108ec:	1000301e 	bne	r2,zero,811109b0 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
811108f0:	e0fffe03 	ldbu	r3,-8(fp)
811108f4:	e0bfff17 	ldw	r2,-4(fp)
811108f8:	11000103 	ldbu	r4,4(r2)
811108fc:	00a045b4 	movhi	r2,33046
81110900:	1080d004 	addi	r2,r2,832
81110904:	18c7883a 	add	r3,r3,r3
81110908:	18c7883a 	add	r3,r3,r3
8111090c:	10c5883a 	add	r2,r2,r3
81110910:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81110914:	e0fffe03 	ldbu	r3,-8(fp)
81110918:	e0bfff17 	ldw	r2,-4(fp)
8111091c:	11000143 	ldbu	r4,5(r2)
81110920:	00a045b4 	movhi	r2,33046
81110924:	1080d004 	addi	r2,r2,832
81110928:	18c7883a 	add	r3,r3,r3
8111092c:	18c7883a 	add	r3,r3,r3
81110930:	10c5883a 	add	r2,r2,r3
81110934:	10800044 	addi	r2,r2,1
81110938:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
8111093c:	e0fffe03 	ldbu	r3,-8(fp)
81110940:	e0bfff17 	ldw	r2,-4(fp)
81110944:	1100020b 	ldhu	r4,8(r2)
81110948:	00a045b4 	movhi	r2,33046
8111094c:	1080d004 	addi	r2,r2,832
81110950:	18c7883a 	add	r3,r3,r3
81110954:	18c7883a 	add	r3,r3,r3
81110958:	10c5883a 	add	r2,r2,r3
8111095c:	10800084 	addi	r2,r2,2
81110960:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81110964:	d0a05b17 	ldw	r2,-32404(gp)
81110968:	1009883a 	mov	r4,r2
8111096c:	11397f40 	call	811397f4 <OSSemPost>
81110970:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81110974:	e0bffe43 	ldbu	r2,-7(fp)
81110978:	10803fcc 	andi	r2,r2,255
8111097c:	10000926 	beq	r2,zero,811109a4 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81110980:	11168480 	call	81116848 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81110984:	e0fffe03 	ldbu	r3,-8(fp)
81110988:	00a045b4 	movhi	r2,33046
8111098c:	1080d004 	addi	r2,r2,832
81110990:	18c7883a 	add	r3,r3,r3
81110994:	18c7883a 	add	r3,r3,r3
81110998:	10c5883a 	add	r2,r2,r3
8111099c:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
811109a0:	00000906 	br	811109c8 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
811109a4:	00800044 	movi	r2,1
811109a8:	e0bffd15 	stw	r2,-12(fp)
                break;
811109ac:	00000606 	br	811109c8 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811109b0:	e0bffe03 	ldbu	r2,-8(fp)
811109b4:	10800044 	addi	r2,r2,1
811109b8:	e0bffe05 	stb	r2,-8(fp)
811109bc:	e0bffe03 	ldbu	r2,-8(fp)
811109c0:	10800230 	cmpltui	r2,r2,8
811109c4:	103fbf1e 	bne	r2,zero,811108c4 <__reset+0xfb0f08c4>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
811109c8:	d0a06c17 	ldw	r2,-32336(gp)
811109cc:	1009883a 	mov	r4,r2
811109d0:	1137a040 	call	81137a04 <OSMutexPost>
    }

    return bSuccess;
811109d4:	e0bffd17 	ldw	r2,-12(fp)
}
811109d8:	e037883a 	mov	sp,fp
811109dc:	dfc00117 	ldw	ra,4(sp)
811109e0:	df000017 	ldw	fp,0(sp)
811109e4:	dec00204 	addi	sp,sp,8
811109e8:	f800283a 	ret

811109ec <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
811109ec:	defffb04 	addi	sp,sp,-20
811109f0:	de00012e 	bgeu	sp,et,811109f8 <setPreAckReceiverFreePos+0xc>
811109f4:	003b68fa 	trap	3
811109f8:	dfc00415 	stw	ra,16(sp)
811109fc:	df000315 	stw	fp,12(sp)
81110a00:	df000304 	addi	fp,sp,12
81110a04:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110a08:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110a0c:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110a10:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81110a14:	d0a05f17 	ldw	r2,-32388(gp)
81110a18:	e0fffe44 	addi	r3,fp,-7
81110a1c:	180d883a 	mov	r6,r3
81110a20:	01400504 	movi	r5,20
81110a24:	1009883a 	mov	r4,r2
81110a28:	11374600 	call	81137460 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81110a2c:	e0bffe43 	ldbu	r2,-7(fp)
81110a30:	10803fcc 	andi	r2,r2,255
81110a34:	1000471e 	bne	r2,zero,81110b54 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81110a38:	e03ffe05 	stb	zero,-8(fp)
81110a3c:	00003e06 	br	81110b38 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81110a40:	e0fffe03 	ldbu	r3,-8(fp)
81110a44:	00a045b4 	movhi	r2,33046
81110a48:	10aac204 	addi	r2,r2,-21752
81110a4c:	18c7883a 	add	r3,r3,r3
81110a50:	18c7883a 	add	r3,r3,r3
81110a54:	10c5883a 	add	r2,r2,r3
81110a58:	10800003 	ldbu	r2,0(r2)
81110a5c:	10803fcc 	andi	r2,r2,255
81110a60:	1080201c 	xori	r2,r2,128
81110a64:	10bfe004 	addi	r2,r2,-128
81110a68:	1000301e 	bne	r2,zero,81110b2c <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
81110a6c:	e0fffe03 	ldbu	r3,-8(fp)
81110a70:	e0bfff17 	ldw	r2,-4(fp)
81110a74:	11000103 	ldbu	r4,4(r2)
81110a78:	00a045b4 	movhi	r2,33046
81110a7c:	10aac204 	addi	r2,r2,-21752
81110a80:	18c7883a 	add	r3,r3,r3
81110a84:	18c7883a 	add	r3,r3,r3
81110a88:	10c5883a 	add	r2,r2,r3
81110a8c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81110a90:	e0fffe03 	ldbu	r3,-8(fp)
81110a94:	e0bfff17 	ldw	r2,-4(fp)
81110a98:	11000143 	ldbu	r4,5(r2)
81110a9c:	00a045b4 	movhi	r2,33046
81110aa0:	10aac204 	addi	r2,r2,-21752
81110aa4:	18c7883a 	add	r3,r3,r3
81110aa8:	18c7883a 	add	r3,r3,r3
81110aac:	10c5883a 	add	r2,r2,r3
81110ab0:	10800044 	addi	r2,r2,1
81110ab4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
81110ab8:	e0fffe03 	ldbu	r3,-8(fp)
81110abc:	e0bfff17 	ldw	r2,-4(fp)
81110ac0:	1100020b 	ldhu	r4,8(r2)
81110ac4:	00a045b4 	movhi	r2,33046
81110ac8:	10aac204 	addi	r2,r2,-21752
81110acc:	18c7883a 	add	r3,r3,r3
81110ad0:	18c7883a 	add	r3,r3,r3
81110ad4:	10c5883a 	add	r2,r2,r3
81110ad8:	10800084 	addi	r2,r2,2
81110adc:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81110ae0:	d0a06017 	ldw	r2,-32384(gp)
81110ae4:	1009883a 	mov	r4,r2
81110ae8:	11397f40 	call	811397f4 <OSSemPost>
81110aec:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81110af0:	e0bffe43 	ldbu	r2,-7(fp)
81110af4:	10803fcc 	andi	r2,r2,255
81110af8:	1000031e 	bne	r2,zero,81110b08 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81110afc:	00800044 	movi	r2,1
81110b00:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81110b04:	00000f06 	br	81110b44 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
81110b08:	11167fc0 	call	811167fc <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81110b0c:	e0fffe03 	ldbu	r3,-8(fp)
81110b10:	00a045b4 	movhi	r2,33046
81110b14:	10aac204 	addi	r2,r2,-21752
81110b18:	18c7883a 	add	r3,r3,r3
81110b1c:	18c7883a 	add	r3,r3,r3
81110b20:	10c5883a 	add	r2,r2,r3
81110b24:	10000005 	stb	zero,0(r2)
                }
                break;
81110b28:	00000606 	br	81110b44 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81110b2c:	e0bffe03 	ldbu	r2,-8(fp)
81110b30:	10800044 	addi	r2,r2,1
81110b34:	e0bffe05 	stb	r2,-8(fp)
81110b38:	e0bffe03 	ldbu	r2,-8(fp)
81110b3c:	108001b0 	cmpltui	r2,r2,6
81110b40:	103fbf1e 	bne	r2,zero,81110a40 <__reset+0xfb0f0a40>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81110b44:	d0a05f17 	ldw	r2,-32388(gp)
81110b48:	1009883a 	mov	r4,r2
81110b4c:	1137a040 	call	81137a04 <OSMutexPost>
81110b50:	00000706 	br	81110b70 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
81110b54:	d0a05c17 	ldw	r2,-32400(gp)
81110b58:	100f883a 	mov	r7,r2
81110b5c:	01801404 	movi	r6,80
81110b60:	01400044 	movi	r5,1
81110b64:	01204534 	movhi	r4,33044
81110b68:	211eba04 	addi	r4,r4,31464
81110b6c:	111ba2c0 	call	8111ba2c <fwrite>
        #endif
    }

    return bSuccess;
81110b70:	e0bffd17 	ldw	r2,-12(fp)
}
81110b74:	e037883a 	mov	sp,fp
81110b78:	dfc00117 	ldw	ra,4(sp)
81110b7c:	df000017 	ldw	fp,0(sp)
81110b80:	dec00204 	addi	sp,sp,8
81110b84:	f800283a 	ret

81110b88 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
81110b88:	defff404 	addi	sp,sp,-48
81110b8c:	de00012e 	bgeu	sp,et,81110b94 <bPreParserV2+0xc>
81110b90:	003b68fa 	trap	3
81110b94:	dfc00b15 	stw	ra,44(sp)
81110b98:	df000a15 	stw	fp,40(sp)
81110b9c:	dc000915 	stw	r16,36(sp)
81110ba0:	df000a04 	addi	fp,sp,40
81110ba4:	e13ffd15 	stw	r4,-12(fp)
81110ba8:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81110bac:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81110bb0:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81110bb4:	01402004 	movi	r5,128
81110bb8:	e13ffd17 	ldw	r4,-12(fp)
81110bbc:	111cfcc0 	call	8111cfcc <strnlen>
81110bc0:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81110bc4:	01400ec4 	movi	r5,59
81110bc8:	e13ffd17 	ldw	r4,-12(fp)
81110bcc:	11152380 	call	81115238 <siPosStr>
81110bd0:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81110bd4:	e0fff98f 	ldh	r3,-26(fp)
81110bd8:	e0bff90f 	ldh	r2,-28(fp)
81110bdc:	10bfffc4 	addi	r2,r2,-1
81110be0:	18800226 	beq	r3,r2,81110bec <bPreParserV2+0x64>
        return bSuccess;
81110be4:	e0bff617 	ldw	r2,-40(fp)
81110be8:	0000ba06 	br	81110ed4 <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81110bec:	01401f04 	movi	r5,124
81110bf0:	e13ffd17 	ldw	r4,-12(fp)
81110bf4:	11152380 	call	81115238 <siPosStr>
81110bf8:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81110bfc:	e0bffa0f 	ldh	r2,-24(fp)
81110c00:	e0fff98f 	ldh	r3,-26(fp)
81110c04:	1880020e 	bge	r3,r2,81110c10 <bPreParserV2+0x88>
        return bSuccess;
81110c08:	e0bff617 	ldw	r2,-40(fp)
81110c0c:	0000b106 	br	81110ed4 <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81110c10:	01604534 	movhi	r5,33044
81110c14:	295ecf04 	addi	r5,r5,31548
81110c18:	e13ffd17 	ldw	r4,-12(fp)
81110c1c:	111cee80 	call	8111cee8 <strcspn>
81110c20:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
81110c24:	e0bffa8f 	ldh	r2,-22(fp)
81110c28:	e0fffa0f 	ldh	r3,-24(fp)
81110c2c:	1880020e 	bge	r3,r2,81110c38 <bPreParserV2+0xb0>
        return bSuccess;
81110c30:	e0bff617 	ldw	r2,-40(fp)
81110c34:	0000a706 	br	81110ed4 <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81110c38:	e0bffa8f 	ldh	r2,-22(fp)
81110c3c:	e0fffd17 	ldw	r3,-12(fp)
81110c40:	1885883a 	add	r2,r3,r2
81110c44:	10c00003 	ldbu	r3,0(r2)
81110c48:	e0bffe17 	ldw	r2,-8(fp)
81110c4c:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81110c50:	e0bffe17 	ldw	r2,-8(fp)
81110c54:	10800103 	ldbu	r2,4(r2)
81110c58:	10803fcc 	andi	r2,r2,255
81110c5c:	1080201c 	xori	r2,r2,128
81110c60:	10bfe004 	addi	r2,r2,-128
81110c64:	108008d8 	cmpnei	r2,r2,35
81110c68:	1000041e 	bne	r2,zero,81110c7c <bPreParserV2+0xf4>
        bSuccess = TRUE;
81110c6c:	00800044 	movi	r2,1
81110c70:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81110c74:	e0bff617 	ldw	r2,-40(fp)
81110c78:	00009606 	br	81110ed4 <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81110c7c:	e0bffa8f 	ldh	r2,-22(fp)
81110c80:	e0fffd17 	ldw	r3,-12(fp)
81110c84:	1889883a 	add	r4,r3,r2
81110c88:	e0fffa0f 	ldh	r3,-24(fp)
81110c8c:	e0bffa8f 	ldh	r2,-22(fp)
81110c90:	1885c83a 	sub	r2,r3,r2
81110c94:	100b883a 	mov	r5,r2
81110c98:	11164580 	call	81116458 <ucCrc8wInit>
81110c9c:	1007883a 	mov	r3,r2
81110ca0:	e0bffe17 	ldw	r2,-8(fp)
81110ca4:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
81110ca8:	e0bffa8f 	ldh	r2,-22(fp)
81110cac:	10800044 	addi	r2,r2,1
81110cb0:	e0fffd17 	ldw	r3,-12(fp)
81110cb4:	1885883a 	add	r2,r3,r2
81110cb8:	10c00003 	ldbu	r3,0(r2)
81110cbc:	e0bffe17 	ldw	r2,-8(fp)
81110cc0:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81110cc4:	e0bffe17 	ldw	r2,-8(fp)
81110cc8:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81110ccc:	e0bffe17 	ldw	r2,-8(fp)
81110cd0:	10800204 	addi	r2,r2,8
81110cd4:	01801004 	movi	r6,64
81110cd8:	000b883a 	mov	r5,zero
81110cdc:	1009883a 	mov	r4,r2
81110ce0:	111c5900 	call	8111c590 <memset>

    i = siIni + 3; /* "?C:i..." */
81110ce4:	e0bffa8b 	ldhu	r2,-22(fp)
81110ce8:	108000c4 	addi	r2,r2,3
81110cec:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81110cf0:	e0bffb44 	addi	r2,fp,-19
81110cf4:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81110cf8:	e0bffb44 	addi	r2,fp,-19
81110cfc:	01800184 	movi	r6,6
81110d00:	000b883a 	mov	r5,zero
81110d04:	1009883a 	mov	r4,r2
81110d08:	111c5900 	call	8111c590 <memset>
        do {
            c = buffer[i];
81110d0c:	e0bff703 	ldbu	r2,-36(fp)
81110d10:	e0fffd17 	ldw	r3,-12(fp)
81110d14:	1885883a 	add	r2,r3,r2
81110d18:	10800003 	ldbu	r2,0(r2)
81110d1c:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81110d20:	d0e00317 	ldw	r3,-32756(gp)
81110d24:	e0bffb07 	ldb	r2,-20(fp)
81110d28:	10800044 	addi	r2,r2,1
81110d2c:	1885883a 	add	r2,r3,r2
81110d30:	10800003 	ldbu	r2,0(r2)
81110d34:	10803fcc 	andi	r2,r2,255
81110d38:	1080010c 	andi	r2,r2,4
81110d3c:	10000626 	beq	r2,zero,81110d58 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81110d40:	e0bff817 	ldw	r2,-32(fp)
81110d44:	e0fffb03 	ldbu	r3,-20(fp)
81110d48:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81110d4c:	e0bff817 	ldw	r2,-32(fp)
81110d50:	10800044 	addi	r2,r2,1
81110d54:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81110d58:	e0bff703 	ldbu	r2,-36(fp)
81110d5c:	10800044 	addi	r2,r2,1
81110d60:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81110d64:	e0bff90f 	ldh	r2,-28(fp)
81110d68:	e0fff703 	ldbu	r3,-36(fp)
81110d6c:	1880090e 	bge	r3,r2,81110d94 <bPreParserV2+0x20c>
81110d70:	e0bffb07 	ldb	r2,-20(fp)
81110d74:	10800ea0 	cmpeqi	r2,r2,58
81110d78:	1000061e 	bne	r2,zero,81110d94 <bPreParserV2+0x20c>
81110d7c:	e0bffb07 	ldb	r2,-20(fp)
81110d80:	10800ee0 	cmpeqi	r2,r2,59
81110d84:	1000031e 	bne	r2,zero,81110d94 <bPreParserV2+0x20c>
81110d88:	e0bffb07 	ldb	r2,-20(fp)
81110d8c:	10801f18 	cmpnei	r2,r2,124
81110d90:	103fde1e 	bne	r2,zero,81110d0c <__reset+0xfb0f0d0c>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81110d94:	e0bff817 	ldw	r2,-32(fp)
81110d98:	00c00284 	movi	r3,10
81110d9c:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81110da0:	e0bffb07 	ldb	r2,-20(fp)
81110da4:	10800ea0 	cmpeqi	r2,r2,58
81110da8:	1000031e 	bne	r2,zero,81110db8 <bPreParserV2+0x230>
81110dac:	e0bffb07 	ldb	r2,-20(fp)
81110db0:	10801f18 	cmpnei	r2,r2,124
81110db4:	10001a1e 	bne	r2,zero,81110e20 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
81110db8:	e0bffe17 	ldw	r2,-8(fp)
81110dbc:	10800183 	ldbu	r2,6(r2)
81110dc0:	10803fcc 	andi	r2,r2,255
81110dc4:	10800828 	cmpgeui	r2,r2,32
81110dc8:	1000041e 	bne	r2,zero,81110ddc <bPreParserV2+0x254>
81110dcc:	e0bffe17 	ldw	r2,-8(fp)
81110dd0:	10800183 	ldbu	r2,6(r2)
81110dd4:	14003fcc 	andi	r16,r2,255
81110dd8:	00000106 	br	81110de0 <bPreParserV2+0x258>
81110ddc:	04000804 	movi	r16,32
81110de0:	e0bffb44 	addi	r2,fp,-19
81110de4:	1009883a 	mov	r4,r2
81110de8:	111b2340 	call	8111b234 <atoi>
81110dec:	1009883a 	mov	r4,r2
81110df0:	e0fffe17 	ldw	r3,-8(fp)
81110df4:	80800104 	addi	r2,r16,4
81110df8:	1085883a 	add	r2,r2,r2
81110dfc:	1885883a 	add	r2,r3,r2
81110e00:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
81110e04:	e0bffe17 	ldw	r2,-8(fp)
81110e08:	10800183 	ldbu	r2,6(r2)
81110e0c:	10800044 	addi	r2,r2,1
81110e10:	1007883a 	mov	r3,r2
81110e14:	e0bffe17 	ldw	r2,-8(fp)
81110e18:	10c00185 	stb	r3,6(r2)
81110e1c:	00000906 	br	81110e44 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81110e20:	e0bffb07 	ldb	r2,-20(fp)
81110e24:	10800ed8 	cmpnei	r2,r2,59
81110e28:	1000061e 	bne	r2,zero,81110e44 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81110e2c:	e0bffb44 	addi	r2,fp,-19
81110e30:	1009883a 	mov	r4,r2
81110e34:	111b2340 	call	8111b234 <atoi>
81110e38:	1007883a 	mov	r3,r2
81110e3c:	e0bffe17 	ldw	r2,-8(fp)
81110e40:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
81110e44:	e0bffb07 	ldb	r2,-20(fp)
81110e48:	10800ee0 	cmpeqi	r2,r2,59
81110e4c:	1000031e 	bne	r2,zero,81110e5c <bPreParserV2+0x2d4>
81110e50:	e0bff90f 	ldh	r2,-28(fp)
81110e54:	e0fff703 	ldbu	r3,-36(fp)
81110e58:	18bfa516 	blt	r3,r2,81110cf0 <__reset+0xfb0f0cf0>


    if ( c == FINAL_CHAR )
81110e5c:	e0bffb07 	ldb	r2,-20(fp)
81110e60:	10800ed8 	cmpnei	r2,r2,59
81110e64:	1000191e 	bne	r2,zero,81110ecc <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81110e68:	e0bffe17 	ldw	r2,-8(fp)
81110e6c:	10c01243 	ldbu	r3,73(r2)
81110e70:	e0bffe17 	ldw	r2,-8(fp)
81110e74:	10801203 	ldbu	r2,72(r2)
81110e78:	18c03fcc 	andi	r3,r3,255
81110e7c:	10803fcc 	andi	r2,r2,255
81110e80:	1880031e 	bne	r3,r2,81110e90 <bPreParserV2+0x308>
            bSuccess = TRUE;
81110e84:	00800044 	movi	r2,1
81110e88:	e0bff615 	stw	r2,-40(fp)
81110e8c:	00001006 	br	81110ed0 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81110e90:	d0e05c17 	ldw	r3,-32400(gp)
81110e94:	e0bffe17 	ldw	r2,-8(fp)
81110e98:	10801203 	ldbu	r2,72(r2)
81110e9c:	11003fcc 	andi	r4,r2,255
81110ea0:	e0bffe17 	ldw	r2,-8(fp)
81110ea4:	10801243 	ldbu	r2,73(r2)
81110ea8:	10803fcc 	andi	r2,r2,255
81110eac:	100f883a 	mov	r7,r2
81110eb0:	200d883a 	mov	r6,r4
81110eb4:	01604534 	movhi	r5,33044
81110eb8:	295ed104 	addi	r5,r5,31556
81110ebc:	1809883a 	mov	r4,r3
81110ec0:	111b3900 	call	8111b390 <fprintf>
            #endif
            bSuccess = FALSE;
81110ec4:	e03ff615 	stw	zero,-40(fp)
81110ec8:	00000106 	br	81110ed0 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81110ecc:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81110ed0:	e0bff617 	ldw	r2,-40(fp)
}
81110ed4:	e6ffff04 	addi	sp,fp,-4
81110ed8:	dfc00217 	ldw	ra,8(sp)
81110edc:	df000117 	ldw	fp,4(sp)
81110ee0:	dc000017 	ldw	r16,0(sp)
81110ee4:	dec00304 	addi	sp,sp,12
81110ee8:	f800283a 	ret

81110eec <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81110eec:	defffb04 	addi	sp,sp,-20
81110ef0:	de00012e 	bgeu	sp,et,81110ef8 <vSenderComTask+0xc>
81110ef4:	003b68fa 	trap	3
81110ef8:	dfc00415 	stw	ra,16(sp)
81110efc:	df000315 	stw	fp,12(sp)
81110f00:	df000304 	addi	fp,sp,12
81110f04:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81110f08:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81110f0c:	d0a05c17 	ldw	r2,-32400(gp)
81110f10:	100f883a 	mov	r7,r2
81110f14:	01800704 	movi	r6,28
81110f18:	01400044 	movi	r5,1
81110f1c:	01204534 	movhi	r4,33044
81110f20:	211edd04 	addi	r4,r4,31604
81110f24:	111ba2c0 	call	8111ba2c <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
81110f28:	e0bffd17 	ldw	r2,-12(fp)
81110f2c:	10c00060 	cmpeqi	r3,r2,1
81110f30:	1800091e 	bne	r3,zero,81110f58 <vSenderComTask+0x6c>
81110f34:	0080052e 	bgeu	zero,r2,81110f4c <vSenderComTask+0x60>
81110f38:	10c000a0 	cmpeqi	r3,r2,2
81110f3c:	1800471e 	bne	r3,zero,8111105c <vSenderComTask+0x170>
81110f40:	10800160 	cmpeqi	r2,r2,5
81110f44:	10002c1e 	bne	r2,zero,81110ff8 <vSenderComTask+0x10c>
81110f48:	00003a06 	br	81111034 <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81110f4c:	00800044 	movi	r2,1
81110f50:	e0bffd15 	stw	r2,-12(fp)
                break;
81110f54:	00004206 	br	81111060 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
81110f58:	d0a05c17 	ldw	r2,-32400(gp)
81110f5c:	100f883a 	mov	r7,r2
81110f60:	01800784 	movi	r6,30
81110f64:	01400044 	movi	r5,1
81110f68:	01204534 	movhi	r4,33044
81110f6c:	211ee504 	addi	r4,r4,31636
81110f70:	111ba2c0 	call	8111ba2c <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81110f74:	01400044 	movi	r5,1
81110f78:	01204534 	movhi	r4,33044
81110f7c:	211eed04 	addi	r4,r4,31668
81110f80:	11149300 	call	81114930 <bSendUART32v2>
81110f84:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
81110f88:	e0bffe17 	ldw	r2,-8(fp)
81110f8c:	10800058 	cmpnei	r2,r2,1
81110f90:	10000a1e 	bne	r2,zero,81110fbc <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
81110f94:	00800144 	movi	r2,5
81110f98:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81110f9c:	d0a05c17 	ldw	r2,-32400(gp)
81110fa0:	100f883a 	mov	r7,r2
81110fa4:	01800d44 	movi	r6,53
81110fa8:	01400044 	movi	r5,1
81110fac:	01204534 	movhi	r4,33044
81110fb0:	211ef004 	addi	r4,r4,31680
81110fb4:	111ba2c0 	call	8111ba2c <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81110fb8:	00002906 	br	81111060 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
81110fbc:	d0a05c17 	ldw	r2,-32400(gp)
81110fc0:	100f883a 	mov	r7,r2
81110fc4:	01800784 	movi	r6,30
81110fc8:	01400044 	movi	r5,1
81110fcc:	01204534 	movhi	r4,33044
81110fd0:	211efe04 	addi	r4,r4,31736
81110fd4:	111ba2c0 	call	8111ba2c <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
81110fd8:	00800044 	movi	r2,1
81110fdc:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81110fe0:	000f883a 	mov	r7,zero
81110fe4:	01800144 	movi	r6,5
81110fe8:	000b883a 	mov	r5,zero
81110fec:	0009883a 	mov	r4,zero
81110ff0:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
                }
                break;
81110ff4:	00001a06 	br	81111060 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81110ff8:	00800144 	movi	r2,5
81110ffc:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
81111000:	d0a05c17 	ldw	r2,-32400(gp)
81111004:	100f883a 	mov	r7,r2
81111008:	018002c4 	movi	r6,11
8111100c:	01400044 	movi	r5,1
81111010:	01204534 	movhi	r4,33044
81111014:	211f0604 	addi	r4,r4,31768
81111018:	111ba2c0 	call	8111ba2c <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
8111101c:	000f883a 	mov	r7,zero
81111020:	01800644 	movi	r6,25
81111024:	000b883a 	mov	r5,zero
81111028:	0009883a 	mov	r4,zero
8111102c:	113b2500 	call	8113b250 <OSTimeDlyHMSM>

                break;
81111030:	00000b06 	br	81111060 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
81111034:	d0a05c17 	ldw	r2,-32400(gp)
81111038:	100f883a 	mov	r7,r2
8111103c:	018003c4 	movi	r6,15
81111040:	01400044 	movi	r5,1
81111044:	01204534 	movhi	r4,33044
81111048:	211f0904 	addi	r4,r4,31780
8111104c:	111ba2c0 	call	8111ba2c <fwrite>
                #endif
                eSenderMode = sDummySender;
81111050:	00800144 	movi	r2,5
81111054:	e0bffd15 	stw	r2,-12(fp)
                break;
81111058:	00000106 	br	81111060 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
8111105c:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81111060:	003fb106 	br	81110f28 <__reset+0xfb0f0f28>

81111064 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81111064:	defffa04 	addi	sp,sp,-24
81111068:	de00012e 	bgeu	sp,et,81111070 <vSimMebTask+0xc>
8111106c:	003b68fa 	trap	3
81111070:	dfc00515 	stw	ra,20(sp)
81111074:	df000415 	stw	fp,16(sp)
81111078:	df000404 	addi	fp,sp,16
8111107c:	e13fff15 	stw	r4,-4(fp)
	TSimucam_MEB *pxMebC;
	tQMask uiCmdMeb;
	INT8U error_code;

	pxMebC = (TSimucam_MEB *) task_data;
81111080:	e0bfff17 	ldw	r2,-4(fp)
81111084:	e0bffc15 	stw	r2,-16(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
81111088:	d0a05c17 	ldw	r2,-32400(gp)
8111108c:	100f883a 	mov	r7,r2
81111090:	018008c4 	movi	r6,35
81111094:	01400044 	movi	r5,1
81111098:	01204534 	movhi	r4,33044
8111109c:	211f0d04 	addi	r4,r4,31796
811110a0:	111ba2c0 	call	8111ba2c <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
811110a4:	e0bffc17 	ldw	r2,-16(fp)
811110a8:	10800117 	ldw	r2,4(r2)
811110ac:	10c00168 	cmpgeui	r3,r2,5
811110b0:	1800ac1e 	bne	r3,zero,81111364 <vSimMebTask+0x300>
811110b4:	100690ba 	slli	r3,r2,2
811110b8:	00a04474 	movhi	r2,33041
811110bc:	10843304 	addi	r2,r2,4300
811110c0:	1885883a 	add	r2,r3,r2
811110c4:	10800017 	ldw	r2,0(r2)
811110c8:	1000683a 	jmp	r2
811110cc:	811110e0 	cmpeqi	r4,r16,17475
811110d0:	811110f8 	rdprs	r4,r16,17475
811110d4:	81111178 	rdprs	r4,r16,17477
811110d8:	811111f0 	cmpltui	r4,r16,17479
811110dc:	811112c8 	cmpgei	r4,r16,17483
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
811110e0:	e13ffc17 	ldw	r4,-16(fp)
811110e4:	11121080 	call	81112108 <vMebInit>
				pxMebC->eMode = sMebToConfig;
811110e8:	e0bffc17 	ldw	r2,-16(fp)
811110ec:	00c00044 	movi	r3,1
811110f0:	10c00115 	stw	r3,4(r2)
				break;
811110f4:	0000a606 	br	81111390 <vSimMebTask+0x32c>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
811110f8:	d0a05c17 	ldw	r2,-32400(gp)
811110fc:	100f883a 	mov	r7,r2
81111100:	01800584 	movi	r6,22
81111104:	01400044 	movi	r5,1
81111108:	01204534 	movhi	r4,33044
8111110c:	211f1604 	addi	r4,r4,31832
81111110:	111ba2c0 	call	8111ba2c <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81111114:	11198980 	call	81119898 <bStopSync>
				vSyncClearCounter();
81111118:	110b7280 	call	8110b728 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
8111111c:	11122100 	call	81112210 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81111120:	01c00284 	movi	r7,10
81111124:	000d883a 	mov	r6,zero
81111128:	000b883a 	mov	r5,zero
8111112c:	0009883a 	mov	r4,zero
81111130:	113b2500 	call	8113b250 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81111134:	000d883a 	mov	r6,zero
81111138:	000b883a 	mov	r5,zero
8111113c:	01002844 	movi	r4,161
81111140:	1111edc0 	call	81111edc <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81111144:	000d883a 	mov	r6,zero
81111148:	000b883a 	mov	r5,zero
8111114c:	01002844 	movi	r4,161
81111150:	11120800 	call	81112080 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81111154:	01c03e84 	movi	r7,250
81111158:	000d883a 	mov	r6,zero
8111115c:	000b883a 	mov	r5,zero
81111160:	0009883a 	mov	r4,zero
81111164:	113b2500 	call	8113b250 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81111168:	e0bffc17 	ldw	r2,-16(fp)
8111116c:	00c000c4 	movi	r3,3
81111170:	10c00115 	stw	r3,4(r2)
				break;
81111174:	00008606 	br	81111390 <vSimMebTask+0x32c>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
81111178:	d0a05c17 	ldw	r2,-32400(gp)
8111117c:	100f883a 	mov	r7,r2
81111180:	018004c4 	movi	r6,19
81111184:	01400044 	movi	r5,1
81111188:	01204534 	movhi	r4,33044
8111118c:	211f1c04 	addi	r4,r4,31856
81111190:	111ba2c0 	call	8111ba2c <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81111194:	000d883a 	mov	r6,zero
81111198:	000b883a 	mov	r5,zero
8111119c:	01002884 	movi	r4,162
811111a0:	1111edc0 	call	81111edc <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
811111a4:	000d883a 	mov	r6,zero
811111a8:	000b883a 	mov	r5,zero
811111ac:	01002884 	movi	r4,162
811111b0:	11120800 	call	81112080 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
811111b4:	e0bffc17 	ldw	r2,-16(fp)
811111b8:	1080050b 	ldhu	r2,20(r2)
811111bc:	10bfffcc 	andi	r2,r2,65535
811111c0:	100f883a 	mov	r7,r2
811111c4:	000d883a 	mov	r6,zero
811111c8:	000b883a 	mov	r5,zero
811111cc:	0009883a 	mov	r4,zero
811111d0:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
				vSyncClearCounter();
811111d4:	110b7280 	call	8110b728 <vSyncClearCounter>
				bStartSync();
811111d8:	11198600 	call	81119860 <bStartSync>

				vEvtChangeMebMode();
811111dc:	11183a40 	call	811183a4 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
811111e0:	e0bffc17 	ldw	r2,-16(fp)
811111e4:	00c00104 	movi	r3,4
811111e8:	10c00115 	stw	r3,4(r2)
				break;
811111ec:	00006806 	br	81111390 <vSimMebTask+0x32c>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811111f0:	d0a06317 	ldw	r2,-32372(gp)
811111f4:	e0fffe04 	addi	r3,fp,-8
811111f8:	180d883a 	mov	r6,r3
811111fc:	000b883a 	mov	r5,zero
81111200:	1009883a 	mov	r4,r2
81111204:	11385740 	call	81138574 <OSQPend>
81111208:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8111120c:	e0bffe03 	ldbu	r2,-8(fp)
81111210:	10803fcc 	andi	r2,r2,255
81111214:	1000291e 	bne	r2,zero,811112bc <vSimMebTask+0x258>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81111218:	e0bffdc3 	ldbu	r2,-9(fp)
8111121c:	10803fcc 	andi	r2,r2,255
81111220:	10800058 	cmpnei	r2,r2,1
81111224:	10001c1e 	bne	r2,zero,81111298 <vSimMebTask+0x234>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
81111228:	e0bffd83 	ldbu	r2,-10(fp)
8111122c:	10803fcc 	andi	r2,r2,255
81111230:	10c00060 	cmpeqi	r3,r2,1
81111234:	1800031e 	bne	r3,zero,81111244 <vSimMebTask+0x1e0>
81111238:	10803820 	cmpeqi	r2,r2,224
8111123c:	1000041e 	bne	r2,zero,81111250 <vSimMebTask+0x1ec>
81111240:	00000b06 	br	81111270 <vSimMebTask+0x20c>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81111244:	e13ffc17 	ldw	r4,-16(fp)
81111248:	11113940 	call	81111394 <vPusMebTask>
								break;
8111124c:	00001d06 	br	811112c4 <vSimMebTask+0x260>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81111250:	d0a05c17 	ldw	r2,-32400(gp)
81111254:	100f883a 	mov	r7,r2
81111258:	018012c4 	movi	r6,75
8111125c:	01400044 	movi	r5,1
81111260:	01204534 	movhi	r4,33044
81111264:	211f2104 	addi	r4,r4,31876
81111268:	111ba2c0 	call	8111ba2c <fwrite>
								#endif
								break;
8111126c:	00001506 	br	811112c4 <vSimMebTask+0x260>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81111270:	d0a05c17 	ldw	r2,-32400(gp)
81111274:	e0fffd83 	ldbu	r3,-10(fp)
81111278:	18c03fcc 	andi	r3,r3,255
8111127c:	180d883a 	mov	r6,r3
81111280:	01604534 	movhi	r5,33044
81111284:	295f3404 	addi	r5,r5,31952
81111288:	1009883a 	mov	r4,r2
8111128c:	111b3900 	call	8111b390 <fprintf>
								#endif
								break;
81111290:	0001883a 	nop
81111294:	00000b06 	br	811112c4 <vSimMebTask+0x260>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81111298:	d0a05c17 	ldw	r2,-32400(gp)
8111129c:	e0fffdc3 	ldbu	r3,-9(fp)
811112a0:	18c03fcc 	andi	r3,r3,255
811112a4:	180d883a 	mov	r6,r3
811112a8:	01604534 	movhi	r5,33044
811112ac:	295f4604 	addi	r5,r5,32024
811112b0:	1009883a 	mov	r4,r2
811112b4:	111b3900 	call	8111b390 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
811112b8:	00003506 	br	81111390 <vSimMebTask+0x32c>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811112bc:	1117e940 	call	81117e94 <vCouldNotGetCmdQueueMeb>
				}

				break;
811112c0:	00003306 	br	81111390 <vSimMebTask+0x32c>
811112c4:	00003206 	br	81111390 <vSimMebTask+0x32c>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811112c8:	d0a06317 	ldw	r2,-32372(gp)
811112cc:	e0fffe04 	addi	r3,fp,-8
811112d0:	180d883a 	mov	r6,r3
811112d4:	000b883a 	mov	r5,zero
811112d8:	1009883a 	mov	r4,r2
811112dc:	11385740 	call	81138574 <OSQPend>
811112e0:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
811112e4:	e0bffe03 	ldbu	r2,-8(fp)
811112e8:	10803fcc 	andi	r2,r2,255
811112ec:	10001a1e 	bne	r2,zero,81111358 <vSimMebTask+0x2f4>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
811112f0:	e0bffdc3 	ldbu	r2,-9(fp)
811112f4:	10803fcc 	andi	r2,r2,255
811112f8:	10800058 	cmpnei	r2,r2,1
811112fc:	10000d1e 	bne	r2,zero,81111334 <vSimMebTask+0x2d0>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81111300:	e0bffd83 	ldbu	r2,-10(fp)
81111304:	10803fcc 	andi	r2,r2,255
81111308:	10c00060 	cmpeqi	r3,r2,1
8111130c:	1800031e 	bne	r3,zero,8111131c <vSimMebTask+0x2b8>
81111310:	10803820 	cmpeqi	r2,r2,224
81111314:	1000041e 	bne	r2,zero,81111328 <vSimMebTask+0x2c4>
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);

								break;
							default:
								break;
81111318:	00001106 	br	81111360 <vSimMebTask+0x2fc>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
8111131c:	e13ffc17 	ldw	r4,-16(fp)
81111320:	11113940 	call	81111394 <vPusMebTask>
								break;
81111324:	00000e06 	br	81111360 <vSimMebTask+0x2fc>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
81111328:	e13ffc17 	ldw	r4,-16(fp)
8111132c:	111216c0 	call	8111216c <vSwapMemmory>

								break;
81111330:	00000b06 	br	81111360 <vSimMebTask+0x2fc>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81111334:	d0a05c17 	ldw	r2,-32400(gp)
81111338:	e0fffdc3 	ldbu	r3,-9(fp)
8111133c:	18c03fcc 	andi	r3,r3,255
81111340:	180d883a 	mov	r6,r3
81111344:	01604534 	movhi	r5,33044
81111348:	295f4604 	addi	r5,r5,32024
8111134c:	1009883a 	mov	r4,r2
81111350:	111b3900 	call	8111b390 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81111354:	00000e06 	br	81111390 <vSimMebTask+0x32c>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81111358:	1117e940 	call	81117e94 <vCouldNotGetCmdQueueMeb>
				}			
				break;
8111135c:	00000c06 	br	81111390 <vSimMebTask+0x32c>
81111360:	00000b06 	br	81111390 <vSimMebTask+0x32c>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
81111364:	d0a05c17 	ldw	r2,-32400(gp)
81111368:	100f883a 	mov	r7,r2
8111136c:	01800bc4 	movi	r6,47
81111370:	01400044 	movi	r5,1
81111374:	01204534 	movhi	r4,33044
81111378:	211f5404 	addi	r4,r4,32080
8111137c:	111ba2c0 	call	8111ba2c <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
81111380:	e0bffc17 	ldw	r2,-16(fp)
81111384:	00c00044 	movi	r3,1
81111388:	10c00115 	stw	r3,4(r2)
				break;
8111138c:	0001883a 	nop
		}
	}
81111390:	003f4406 	br	811110a4 <__reset+0xfb0f10a4>

81111394 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81111394:	defffb04 	addi	sp,sp,-20
81111398:	de00012e 	bgeu	sp,et,811113a0 <vPusMebTask+0xc>
8111139c:	003b68fa 	trap	3
811113a0:	dfc00415 	stw	ra,16(sp)
811113a4:	df000315 	stw	fp,12(sp)
811113a8:	df000304 	addi	fp,sp,12
811113ac:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
811113b0:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
811113b4:	d0a06d17 	ldw	r2,-32332(gp)
811113b8:	e0fffe44 	addi	r3,fp,-7
811113bc:	180d883a 	mov	r6,r3
811113c0:	01400084 	movi	r5,2
811113c4:	1009883a 	mov	r4,r2
811113c8:	11374600 	call	81137460 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
811113cc:	e0bffe43 	ldbu	r2,-7(fp)
811113d0:	10803fcc 	andi	r2,r2,255
811113d4:	10002c1e 	bne	r2,zero,81111488 <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811113d8:	e03ffe05 	stb	zero,-8(fp)
811113dc:	00002306 	br	8111146c <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
811113e0:	e0fffe03 	ldbu	r3,-8(fp)
811113e4:	00a04574 	movhi	r2,33045
811113e8:	10be2d04 	addi	r2,r2,-1868
811113ec:	18c01524 	muli	r3,r3,84
811113f0:	10c5883a 	add	r2,r2,r3
811113f4:	10800104 	addi	r2,r2,4
811113f8:	10800017 	ldw	r2,0(r2)
811113fc:	10800058 	cmpnei	r2,r2,1
81111400:	1000171e 	bne	r2,zero,81111460 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81111404:	e13ffe03 	ldbu	r4,-8(fp)
81111408:	00e04574 	movhi	r3,33045
8111140c:	18f43604 	addi	r3,r3,-12072
81111410:	00a04574 	movhi	r2,33045
81111414:	10be2d04 	addi	r2,r2,-1868
81111418:	21001524 	muli	r4,r4,84
8111141c:	1105883a 	add	r2,r2,r4
81111420:	1009883a 	mov	r4,r2
81111424:	00801504 	movi	r2,84
81111428:	100d883a 	mov	r6,r2
8111142c:	200b883a 	mov	r5,r4
81111430:	1809883a 	mov	r4,r3
81111434:	111c4400 	call	8111c440 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
81111438:	e0fffe03 	ldbu	r3,-8(fp)
8111143c:	00a04574 	movhi	r2,33045
81111440:	10be2d04 	addi	r2,r2,-1868
81111444:	18c01524 	muli	r3,r3,84
81111448:	10c5883a 	add	r2,r2,r3
8111144c:	10800104 	addi	r2,r2,4
81111450:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81111454:	00800044 	movi	r2,1
81111458:	e0bffd15 	stw	r2,-12(fp)
                break;
8111145c:	00000606 	br	81111478 <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81111460:	e0bffe03 	ldbu	r2,-8(fp)
81111464:	10800044 	addi	r2,r2,1
81111468:	e0bffe05 	stb	r2,-8(fp)
8111146c:	e0bffe03 	ldbu	r2,-8(fp)
81111470:	10800130 	cmpltui	r2,r2,4
81111474:	103fda1e 	bne	r2,zero,811113e0 <__reset+0xfb0f13e0>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
81111478:	d0a06d17 	ldw	r2,-32332(gp)
8111147c:	1009883a 	mov	r4,r2
81111480:	1137a040 	call	81137a04 <OSMutexPost>
81111484:	00000106 	br	8111148c <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
81111488:	1117efc0 	call	81117efc <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
8111148c:	e0bffd17 	ldw	r2,-12(fp)
81111490:	10001126 	beq	r2,zero,811114d8 <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81111494:	e0bfff17 	ldw	r2,-4(fp)
81111498:	10800117 	ldw	r2,4(r2)
8111149c:	10c000e0 	cmpeqi	r3,r2,3
811114a0:	1800031e 	bne	r3,zero,811114b0 <vPusMebTask+0x11c>
811114a4:	10800120 	cmpeqi	r2,r2,4
811114a8:	1000061e 	bne	r2,zero,811114c4 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
811114ac:	00000a06 	br	811114d8 <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
811114b0:	01604574 	movhi	r5,33045
811114b4:	29743604 	addi	r5,r5,-12072
811114b8:	e13fff17 	ldw	r4,-4(fp)
811114bc:	11114f00 	call	811114f0 <vPusMebInTaskConfigMode>
				break;
811114c0:	00000506 	br	811114d8 <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
811114c4:	01604574 	movhi	r5,33045
811114c8:	29743604 	addi	r5,r5,-12072
811114cc:	e13fff17 	ldw	r4,-4(fp)
811114d0:	11118800 	call	81111880 <vPusMebInTaskRunningMode>
				break;
811114d4:	0001883a 	nop
			default:
				break;
		}
	}
}
811114d8:	0001883a 	nop
811114dc:	e037883a 	mov	sp,fp
811114e0:	dfc00117 	ldw	ra,4(sp)
811114e4:	df000017 	ldw	fp,0(sp)
811114e8:	dec00204 	addi	sp,sp,8
811114ec:	f800283a 	ret

811114f0 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811114f0:	defffc04 	addi	sp,sp,-16
811114f4:	de00012e 	bgeu	sp,et,811114fc <vPusMebInTaskConfigMode+0xc>
811114f8:	003b68fa 	trap	3
811114fc:	dfc00315 	stw	ra,12(sp)
81111500:	df000215 	stw	fp,8(sp)
81111504:	df000204 	addi	fp,sp,8
81111508:	e13ffe15 	stw	r4,-8(fp)
8111150c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81111510:	e0bfff17 	ldw	r2,-4(fp)
81111514:	1080030b 	ldhu	r2,12(r2)
81111518:	10bfffcc 	andi	r2,r2,65535
8111151c:	10c03ee0 	cmpeqi	r3,r2,251
81111520:	1800081e 	bne	r3,zero,81111544 <vPusMebInTaskConfigMode+0x54>
81111524:	10c03f20 	cmpeqi	r3,r2,252
81111528:	18000a1e 	bne	r3,zero,81111554 <vPusMebInTaskConfigMode+0x64>
8111152c:	10803ea0 	cmpeqi	r2,r2,250
81111530:	10000c26 	beq	r2,zero,81111564 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81111534:	e17fff17 	ldw	r5,-4(fp)
81111538:	e13ffe17 	ldw	r4,-8(fp)
8111153c:	111159c0 	call	8111159c <vPusType250conf>
			break;
81111540:	00001006 	br	81111584 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81111544:	e17fff17 	ldw	r5,-4(fp)
81111548:	e13ffe17 	ldw	r4,-8(fp)
8111154c:	11116280 	call	81111628 <vPusType251conf>
			break;
81111550:	00000c06 	br	81111584 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81111554:	e17fff17 	ldw	r5,-4(fp)
81111558:	e13ffe17 	ldw	r4,-8(fp)
8111155c:	111167c0 	call	8111167c <vPusType252conf>
			break;
81111560:	00000806 	br	81111584 <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
81111564:	d0a05c17 	ldw	r2,-32400(gp)
81111568:	100f883a 	mov	r7,r2
8111156c:	01800d84 	movi	r6,54
81111570:	01400044 	movi	r5,1
81111574:	01204534 	movhi	r4,33044
81111578:	211f6004 	addi	r4,r4,32128
8111157c:	111ba2c0 	call	8111ba2c <fwrite>
			#endif
			break;
81111580:	0001883a 	nop
	}
}
81111584:	0001883a 	nop
81111588:	e037883a 	mov	sp,fp
8111158c:	dfc00117 	ldw	ra,4(sp)
81111590:	df000017 	ldw	fp,0(sp)
81111594:	dec00204 	addi	sp,sp,8
81111598:	f800283a 	ret

8111159c <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111159c:	defffc04 	addi	sp,sp,-16
811115a0:	de00012e 	bgeu	sp,et,811115a8 <vPusType250conf+0xc>
811115a4:	003b68fa 	trap	3
811115a8:	dfc00315 	stw	ra,12(sp)
811115ac:	df000215 	stw	fp,8(sp)
811115b0:	df000204 	addi	fp,sp,8
811115b4:	e13ffe15 	stw	r4,-8(fp)
811115b8:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811115bc:	e0bfff17 	ldw	r2,-4(fp)
811115c0:	1080038b 	ldhu	r2,14(r2)
811115c4:	10bfffcc 	andi	r2,r2,65535
811115c8:	10c00f60 	cmpeqi	r3,r2,61
811115cc:	1800031e 	bne	r3,zero,811115dc <vPusType250conf+0x40>
811115d0:	10800fa0 	cmpeqi	r2,r2,62
811115d4:	10000d1e 	bne	r2,zero,8111160c <vPusType250conf+0x70>
811115d8:	00000406 	br	811115ec <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
811115dc:	e0bffe17 	ldw	r2,-8(fp)
811115e0:	00c00084 	movi	r3,2
811115e4:	10c00115 	stw	r3,4(r2)
			break;
811115e8:	00000906 	br	81111610 <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
811115ec:	d0a05c17 	ldw	r2,-32400(gp)
811115f0:	100f883a 	mov	r7,r2
811115f4:	01800b04 	movi	r6,44
811115f8:	01400044 	movi	r5,1
811115fc:	01204534 	movhi	r4,33044
81111600:	211f6e04 	addi	r4,r4,32184
81111604:	111ba2c0 	call	8111ba2c <fwrite>
			#endif
			break;
81111608:	00000106 	br	81111610 <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
8111160c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
81111610:	0001883a 	nop
81111614:	e037883a 	mov	sp,fp
81111618:	dfc00117 	ldw	ra,4(sp)
8111161c:	df000017 	ldw	fp,0(sp)
81111620:	dec00204 	addi	sp,sp,8
81111624:	f800283a 	ret

81111628 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111628:	defffc04 	addi	sp,sp,-16
8111162c:	de00012e 	bgeu	sp,et,81111634 <vPusType251conf+0xc>
81111630:	003b68fa 	trap	3
81111634:	dfc00315 	stw	ra,12(sp)
81111638:	df000215 	stw	fp,8(sp)
8111163c:	df000204 	addi	fp,sp,8
81111640:	e13ffe15 	stw	r4,-8(fp)
81111644:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
81111648:	d0a05c17 	ldw	r2,-32400(gp)
8111164c:	100f883a 	mov	r7,r2
81111650:	01801184 	movi	r6,70
81111654:	01400044 	movi	r5,1
81111658:	01204534 	movhi	r4,33044
8111165c:	211f7a04 	addi	r4,r4,32232
81111660:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
}
81111664:	0001883a 	nop
81111668:	e037883a 	mov	sp,fp
8111166c:	dfc00117 	ldw	ra,4(sp)
81111670:	df000017 	ldw	fp,0(sp)
81111674:	dec00204 	addi	sp,sp,8
81111678:	f800283a 	ret

8111167c <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111167c:	defffb04 	addi	sp,sp,-20
81111680:	de00012e 	bgeu	sp,et,81111688 <vPusType252conf+0xc>
81111684:	003b68fa 	trap	3
81111688:	dfc00415 	stw	ra,16(sp)
8111168c:	df000315 	stw	fp,12(sp)
81111690:	df000304 	addi	fp,sp,12
81111694:	e13ffe15 	stw	r4,-8(fp)
81111698:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
8111169c:	e0bfff17 	ldw	r2,-4(fp)
811116a0:	1080050b 	ldhu	r2,20(r2)
811116a4:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811116a8:	e0bfff17 	ldw	r2,-4(fp)
811116ac:	1080038b 	ldhu	r2,14(r2)
811116b0:	10bfffcc 	andi	r2,r2,65535
811116b4:	10c000a0 	cmpeqi	r3,r2,2
811116b8:	18000c1e 	bne	r3,zero,811116ec <vPusType252conf+0x70>
811116bc:	10c00090 	cmplti	r3,r2,2
811116c0:	1800611e 	bne	r3,zero,81111848 <vPusType252conf+0x1cc>
811116c4:	10800188 	cmpgei	r2,r2,6
811116c8:	10005f1e 	bne	r2,zero,81111848 <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
811116cc:	d0a05c17 	ldw	r2,-32400(gp)
811116d0:	100f883a 	mov	r7,r2
811116d4:	01801384 	movi	r6,78
811116d8:	01400044 	movi	r5,1
811116dc:	01204534 	movhi	r4,33044
811116e0:	211f8c04 	addi	r4,r4,32304
811116e4:	111ba2c0 	call	8111ba2c <fwrite>
			#endif
			break;
811116e8:	00005f06 	br	81111868 <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811116ec:	e0bffd0b 	ldhu	r2,-12(fp)
811116f0:	10809524 	muli	r2,r2,596
811116f4:	10805404 	addi	r2,r2,336
811116f8:	e0fffe17 	ldw	r3,-8(fp)
811116fc:	1885883a 	add	r2,r3,r2
81111700:	1009883a 	mov	r4,r2
81111704:	11069500 	call	81106950 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81111708:	e0bffd0b 	ldhu	r2,-12(fp)
8111170c:	e0fffe17 	ldw	r3,-8(fp)
81111710:	10809524 	muli	r2,r2,596
81111714:	1885883a 	add	r2,r3,r2
81111718:	10806404 	addi	r2,r2,400
8111171c:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111720:	e0bffd0b 	ldhu	r2,-12(fp)
81111724:	10809524 	muli	r2,r2,596
81111728:	10805404 	addi	r2,r2,336
8111172c:	e0fffe17 	ldw	r3,-8(fp)
81111730:	1885883a 	add	r2,r3,r2
81111734:	1009883a 	mov	r4,r2
81111738:	11068a80 	call	811068a8 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
8111173c:	e0bffd0b 	ldhu	r2,-12(fp)
81111740:	10809524 	muli	r2,r2,596
81111744:	10805404 	addi	r2,r2,336
81111748:	e0fffe17 	ldw	r3,-8(fp)
8111174c:	1885883a 	add	r2,r3,r2
81111750:	1009883a 	mov	r4,r2
81111754:	1106b380 	call	81106b38 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81111758:	e0bffd0b 	ldhu	r2,-12(fp)
8111175c:	e0ffff17 	ldw	r3,-4(fp)
81111760:	18c00b0b 	ldhu	r3,44(r3)
81111764:	1809883a 	mov	r4,r3
81111768:	e0fffe17 	ldw	r3,-8(fp)
8111176c:	10809524 	muli	r2,r2,596
81111770:	1885883a 	add	r2,r3,r2
81111774:	10805504 	addi	r2,r2,340
81111778:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
8111177c:	e0bffd0b 	ldhu	r2,-12(fp)
81111780:	e0ffff17 	ldw	r3,-4(fp)
81111784:	18c0098b 	ldhu	r3,38(r3)
81111788:	1809883a 	mov	r4,r3
8111178c:	e0fffe17 	ldw	r3,-8(fp)
81111790:	10809524 	muli	r2,r2,596
81111794:	1885883a 	add	r2,r3,r2
81111798:	10805544 	addi	r2,r2,341
8111179c:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811117a0:	e0bffd0b 	ldhu	r2,-12(fp)
811117a4:	10809524 	muli	r2,r2,596
811117a8:	10805404 	addi	r2,r2,336
811117ac:	e0fffe17 	ldw	r3,-8(fp)
811117b0:	1885883a 	add	r2,r3,r2
811117b4:	1009883a 	mov	r4,r2
811117b8:	1106a600 	call	81106a60 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811117bc:	e0bffd0b 	ldhu	r2,-12(fp)
811117c0:	10809524 	muli	r2,r2,596
811117c4:	10805404 	addi	r2,r2,336
811117c8:	e0fffe17 	ldw	r3,-8(fp)
811117cc:	1885883a 	add	r2,r3,r2
811117d0:	1009883a 	mov	r4,r2
811117d4:	11069500 	call	81106950 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
811117d8:	e0bffd0b 	ldhu	r2,-12(fp)
811117dc:	e0fffe17 	ldw	r3,-8(fp)
811117e0:	10809524 	muli	r2,r2,596
811117e4:	1885883a 	add	r2,r3,r2
811117e8:	10806404 	addi	r2,r2,400
811117ec:	00c00044 	movi	r3,1
811117f0:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811117f4:	e0bffd0b 	ldhu	r2,-12(fp)
811117f8:	10809524 	muli	r2,r2,596
811117fc:	10805404 	addi	r2,r2,336
81111800:	e0fffe17 	ldw	r3,-8(fp)
81111804:	1885883a 	add	r2,r3,r2
81111808:	1009883a 	mov	r4,r2
8111180c:	11068a80 	call	811068a8 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81111810:	d0e05c17 	ldw	r3,-32400(gp)
81111814:	e0bfff17 	ldw	r2,-4(fp)
81111818:	10800b0b 	ldhu	r2,44(r2)
8111181c:	113fffcc 	andi	r4,r2,65535
81111820:	e0bfff17 	ldw	r2,-4(fp)
81111824:	1080098b 	ldhu	r2,38(r2)
81111828:	10bfffcc 	andi	r2,r2,65535
8111182c:	100f883a 	mov	r7,r2
81111830:	200d883a 	mov	r6,r4
81111834:	01604534 	movhi	r5,33044
81111838:	295fa004 	addi	r5,r5,32384
8111183c:	1809883a 	mov	r4,r3
81111840:	111b3900 	call	8111b390 <fprintf>
			#endif

			break;
81111844:	00000806 	br	81111868 <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81111848:	d0a05c17 	ldw	r2,-32400(gp)
8111184c:	100f883a 	mov	r7,r2
81111850:	01800b04 	movi	r6,44
81111854:	01400044 	movi	r5,1
81111858:	01204534 	movhi	r4,33044
8111185c:	211f6e04 	addi	r4,r4,32184
81111860:	111ba2c0 	call	8111ba2c <fwrite>
			#endif
			break;
81111864:	0001883a 	nop
	}
}
81111868:	0001883a 	nop
8111186c:	e037883a 	mov	sp,fp
81111870:	dfc00117 	ldw	ra,4(sp)
81111874:	df000017 	ldw	fp,0(sp)
81111878:	dec00204 	addi	sp,sp,8
8111187c:	f800283a 	ret

81111880 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111880:	defffc04 	addi	sp,sp,-16
81111884:	de00012e 	bgeu	sp,et,8111188c <vPusMebInTaskRunningMode+0xc>
81111888:	003b68fa 	trap	3
8111188c:	dfc00315 	stw	ra,12(sp)
81111890:	df000215 	stw	fp,8(sp)
81111894:	df000204 	addi	fp,sp,8
81111898:	e13ffe15 	stw	r4,-8(fp)
8111189c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
811118a0:	e0bfff17 	ldw	r2,-4(fp)
811118a4:	1080030b 	ldhu	r2,12(r2)
811118a8:	10bfffcc 	andi	r2,r2,65535
811118ac:	10c03ee0 	cmpeqi	r3,r2,251
811118b0:	1800081e 	bne	r3,zero,811118d4 <vPusMebInTaskRunningMode+0x54>
811118b4:	10c03f20 	cmpeqi	r3,r2,252
811118b8:	18000a1e 	bne	r3,zero,811118e4 <vPusMebInTaskRunningMode+0x64>
811118bc:	10803ea0 	cmpeqi	r2,r2,250
811118c0:	10000c26 	beq	r2,zero,811118f4 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
811118c4:	e17fff17 	ldw	r5,-4(fp)
811118c8:	e13ffe17 	ldw	r4,-8(fp)
811118cc:	111192c0 	call	8111192c <vPusType250run>
			break;
811118d0:	00001006 	br	81111914 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
811118d4:	e17fff17 	ldw	r5,-4(fp)
811118d8:	e13ffe17 	ldw	r4,-8(fp)
811118dc:	11119b80 	call	811119b8 <vPusType251run>
			break;
811118e0:	00000c06 	br	81111914 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
811118e4:	e17fff17 	ldw	r5,-4(fp)
811118e8:	e13ffe17 	ldw	r4,-8(fp)
811118ec:	1111acc0 	call	81111acc <vPusType252run>
			break;
811118f0:	00000806 	br	81111914 <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
811118f4:	d0a05c17 	ldw	r2,-32400(gp)
811118f8:	100f883a 	mov	r7,r2
811118fc:	01800cc4 	movi	r6,51
81111900:	01400044 	movi	r5,1
81111904:	01204534 	movhi	r4,33044
81111908:	211fb004 	addi	r4,r4,32448
8111190c:	111ba2c0 	call	8111ba2c <fwrite>
			#endif
			break;
81111910:	0001883a 	nop
	}
}
81111914:	0001883a 	nop
81111918:	e037883a 	mov	sp,fp
8111191c:	dfc00117 	ldw	ra,4(sp)
81111920:	df000017 	ldw	fp,0(sp)
81111924:	dec00204 	addi	sp,sp,8
81111928:	f800283a 	ret

8111192c <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111192c:	defffc04 	addi	sp,sp,-16
81111930:	de00012e 	bgeu	sp,et,81111938 <vPusType250run+0xc>
81111934:	003b68fa 	trap	3
81111938:	dfc00315 	stw	ra,12(sp)
8111193c:	df000215 	stw	fp,8(sp)
81111940:	df000204 	addi	fp,sp,8
81111944:	e13ffe15 	stw	r4,-8(fp)
81111948:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
8111194c:	e0bfff17 	ldw	r2,-4(fp)
81111950:	1080038b 	ldhu	r2,14(r2)
81111954:	10bfffcc 	andi	r2,r2,65535
81111958:	10c00f20 	cmpeqi	r3,r2,60
8111195c:	1800031e 	bne	r3,zero,8111196c <vPusType250run+0x40>
81111960:	10800fa0 	cmpeqi	r2,r2,62
81111964:	10000d1e 	bne	r2,zero,8111199c <vPusType250run+0x70>
81111968:	00000406 	br	8111197c <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
8111196c:	e0bffe17 	ldw	r2,-8(fp)
81111970:	00c00044 	movi	r3,1
81111974:	10c00115 	stw	r3,4(r2)
			break;
81111978:	00000906 	br	811119a0 <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
8111197c:	d0a05c17 	ldw	r2,-32400(gp)
81111980:	100f883a 	mov	r7,r2
81111984:	01800c84 	movi	r6,50
81111988:	01400044 	movi	r5,1
8111198c:	01204534 	movhi	r4,33044
81111990:	211fbd04 	addi	r4,r4,32500
81111994:	111ba2c0 	call	8111ba2c <fwrite>
			#endif
			break;
81111998:	00000106 	br	811119a0 <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
8111199c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
811119a0:	0001883a 	nop
811119a4:	e037883a 	mov	sp,fp
811119a8:	dfc00117 	ldw	ra,4(sp)
811119ac:	df000017 	ldw	fp,0(sp)
811119b0:	dec00204 	addi	sp,sp,8
811119b4:	f800283a 	ret

811119b8 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811119b8:	defffb04 	addi	sp,sp,-20
811119bc:	de00012e 	bgeu	sp,et,811119c4 <vPusType251run+0xc>
811119c0:	003b68fa 	trap	3
811119c4:	dfc00415 	stw	ra,16(sp)
811119c8:	df000315 	stw	fp,12(sp)
811119cc:	df000304 	addi	fp,sp,12
811119d0:	e13ffe15 	stw	r4,-8(fp)
811119d4:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811119d8:	e0bfff17 	ldw	r2,-4(fp)
811119dc:	1080050b 	ldhu	r2,20(r2)
811119e0:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811119e4:	e0bfff17 	ldw	r2,-4(fp)
811119e8:	1080038b 	ldhu	r2,14(r2)
811119ec:	10bfffcc 	andi	r2,r2,65535
811119f0:	10c000a0 	cmpeqi	r3,r2,2
811119f4:	18000f1e 	bne	r3,zero,81111a34 <vPusType251run+0x7c>
811119f8:	10c00160 	cmpeqi	r3,r2,5
811119fc:	1800181e 	bne	r3,zero,81111a60 <vPusType251run+0xa8>
81111a00:	10800060 	cmpeqi	r2,r2,1
81111a04:	10002126 	beq	r2,zero,81111a8c <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81111a08:	e0bffd0b 	ldhu	r2,-12(fp)
81111a0c:	10800444 	addi	r2,r2,17
81111a10:	10803fcc 	andi	r2,r2,255
81111a14:	e0fffd0b 	ldhu	r3,-12(fp)
81111a18:	18c03fcc 	andi	r3,r3,255
81111a1c:	180f883a 	mov	r7,r3
81111a20:	000d883a 	mov	r6,zero
81111a24:	01400044 	movi	r5,1
81111a28:	1009883a 	mov	r4,r2
81111a2c:	1111f640 	call	81111f64 <vSendCmdQToNFeeCTRL_GEN>
			break;
81111a30:	00002006 	br	81111ab4 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
81111a34:	e0bffd0b 	ldhu	r2,-12(fp)
81111a38:	10800444 	addi	r2,r2,17
81111a3c:	10803fcc 	andi	r2,r2,255
81111a40:	e0fffd0b 	ldhu	r3,-12(fp)
81111a44:	18c03fcc 	andi	r3,r3,255
81111a48:	180f883a 	mov	r7,r3
81111a4c:	000d883a 	mov	r6,zero
81111a50:	01400104 	movi	r5,4
81111a54:	1009883a 	mov	r4,r2
81111a58:	1111f640 	call	81111f64 <vSendCmdQToNFeeCTRL_GEN>
			break;
81111a5c:	00001506 	br	81111ab4 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81111a60:	e0bffd0b 	ldhu	r2,-12(fp)
81111a64:	10800444 	addi	r2,r2,17
81111a68:	10803fcc 	andi	r2,r2,255
81111a6c:	e0fffd0b 	ldhu	r3,-12(fp)
81111a70:	18c03fcc 	andi	r3,r3,255
81111a74:	180f883a 	mov	r7,r3
81111a78:	000d883a 	mov	r6,zero
81111a7c:	01400204 	movi	r5,8
81111a80:	1009883a 	mov	r4,r2
81111a84:	1111f640 	call	81111f64 <vSendCmdQToNFeeCTRL_GEN>
			break;
81111a88:	00000a06 	br	81111ab4 <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
81111a8c:	d0e05c17 	ldw	r3,-32400(gp)
81111a90:	e0bfff17 	ldw	r2,-4(fp)
81111a94:	1080038b 	ldhu	r2,14(r2)
81111a98:	10bfffcc 	andi	r2,r2,65535
81111a9c:	100d883a 	mov	r6,r2
81111aa0:	01604534 	movhi	r5,33044
81111aa4:	295fca04 	addi	r5,r5,32552
81111aa8:	1809883a 	mov	r4,r3
81111aac:	111b3900 	call	8111b390 <fprintf>
			#endif
			break;
81111ab0:	0001883a 	nop
	}
}
81111ab4:	0001883a 	nop
81111ab8:	e037883a 	mov	sp,fp
81111abc:	dfc00117 	ldw	ra,4(sp)
81111ac0:	df000017 	ldw	fp,0(sp)
81111ac4:	dec00204 	addi	sp,sp,8
81111ac8:	f800283a 	ret

81111acc <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111acc:	defffb04 	addi	sp,sp,-20
81111ad0:	de00012e 	bgeu	sp,et,81111ad8 <vPusType252run+0xc>
81111ad4:	003b68fa 	trap	3
81111ad8:	dfc00415 	stw	ra,16(sp)
81111adc:	df000315 	stw	fp,12(sp)
81111ae0:	df000304 	addi	fp,sp,12
81111ae4:	e13ffe15 	stw	r4,-8(fp)
81111ae8:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81111aec:	e0bfff17 	ldw	r2,-4(fp)
81111af0:	1080050b 	ldhu	r2,20(r2)
81111af4:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81111af8:	e0bfff17 	ldw	r2,-4(fp)
81111afc:	1080038b 	ldhu	r2,14(r2)
81111b00:	10bfffcc 	andi	r2,r2,65535
81111b04:	10c000e0 	cmpeqi	r3,r2,3
81111b08:	18000a1e 	bne	r3,zero,81111b34 <vPusType252run+0x68>
81111b0c:	10c00108 	cmpgei	r3,r2,4
81111b10:	1800031e 	bne	r3,zero,81111b20 <vPusType252run+0x54>
81111b14:	108000a0 	cmpeqi	r2,r2,2
81111b18:	1000581e 	bne	r2,zero,81111c7c <vPusType252run+0x1b0>
81111b1c:	0000be06 	br	81111e18 <vPusType252run+0x34c>
81111b20:	10c00120 	cmpeqi	r3,r2,4
81111b24:	18002c1e 	bne	r3,zero,81111bd8 <vPusType252run+0x10c>
81111b28:	10800160 	cmpeqi	r2,r2,5
81111b2c:	1000c21e 	bne	r2,zero,81111e38 <vPusType252run+0x36c>
81111b30:	0000b906 	br	81111e18 <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81111b34:	e0bffd0b 	ldhu	r2,-12(fp)
81111b38:	10809524 	muli	r2,r2,596
81111b3c:	10809a04 	addi	r2,r2,616
81111b40:	e0fffe17 	ldw	r3,-8(fp)
81111b44:	1885883a 	add	r2,r3,r2
81111b48:	1009883a 	mov	r4,r2
81111b4c:	1108ed40 	call	81108ed4 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81111b50:	e0bffd0b 	ldhu	r2,-12(fp)
81111b54:	e0fffe17 	ldw	r3,-8(fp)
81111b58:	10809524 	muli	r2,r2,596
81111b5c:	1885883a 	add	r2,r3,r2
81111b60:	10809c04 	addi	r2,r2,624
81111b64:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81111b68:	e0bffd0b 	ldhu	r2,-12(fp)
81111b6c:	e0fffe17 	ldw	r3,-8(fp)
81111b70:	10809524 	muli	r2,r2,596
81111b74:	1885883a 	add	r2,r3,r2
81111b78:	10809b04 	addi	r2,r2,620
81111b7c:	00c00044 	movi	r3,1
81111b80:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81111b84:	e0bffd0b 	ldhu	r2,-12(fp)
81111b88:	e0fffe17 	ldw	r3,-8(fp)
81111b8c:	10809524 	muli	r2,r2,596
81111b90:	1885883a 	add	r2,r3,r2
81111b94:	10809d04 	addi	r2,r2,628
81111b98:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81111b9c:	e0bffd0b 	ldhu	r2,-12(fp)
81111ba0:	10809524 	muli	r2,r2,596
81111ba4:	10809a04 	addi	r2,r2,616
81111ba8:	e0fffe17 	ldw	r3,-8(fp)
81111bac:	1885883a 	add	r2,r3,r2
81111bb0:	1009883a 	mov	r4,r2
81111bb4:	1108da00 	call	81108da0 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81111bb8:	d0a05c17 	ldw	r2,-32400(gp)
81111bbc:	e0fffd0b 	ldhu	r3,-12(fp)
81111bc0:	180d883a 	mov	r6,r3
81111bc4:	01604534 	movhi	r5,33044
81111bc8:	295fd804 	addi	r5,r5,32608
81111bcc:	1009883a 	mov	r4,r2
81111bd0:	111b3900 	call	8111b390 <fprintf>
			#endif

			break;
81111bd4:	00009906 	br	81111e3c <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81111bd8:	e0bffd0b 	ldhu	r2,-12(fp)
81111bdc:	10809524 	muli	r2,r2,596
81111be0:	10809a04 	addi	r2,r2,616
81111be4:	e0fffe17 	ldw	r3,-8(fp)
81111be8:	1885883a 	add	r2,r3,r2
81111bec:	1009883a 	mov	r4,r2
81111bf0:	1108ed40 	call	81108ed4 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81111bf4:	e0bffd0b 	ldhu	r2,-12(fp)
81111bf8:	e0fffe17 	ldw	r3,-8(fp)
81111bfc:	10809524 	muli	r2,r2,596
81111c00:	1885883a 	add	r2,r3,r2
81111c04:	10809c04 	addi	r2,r2,624
81111c08:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81111c0c:	e0bffd0b 	ldhu	r2,-12(fp)
81111c10:	e0fffe17 	ldw	r3,-8(fp)
81111c14:	10809524 	muli	r2,r2,596
81111c18:	1885883a 	add	r2,r3,r2
81111c1c:	10809b04 	addi	r2,r2,620
81111c20:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81111c24:	e0bffd0b 	ldhu	r2,-12(fp)
81111c28:	e0fffe17 	ldw	r3,-8(fp)
81111c2c:	10809524 	muli	r2,r2,596
81111c30:	1885883a 	add	r2,r3,r2
81111c34:	10809d04 	addi	r2,r2,628
81111c38:	00c00044 	movi	r3,1
81111c3c:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81111c40:	e0bffd0b 	ldhu	r2,-12(fp)
81111c44:	10809524 	muli	r2,r2,596
81111c48:	10809a04 	addi	r2,r2,616
81111c4c:	e0fffe17 	ldw	r3,-8(fp)
81111c50:	1885883a 	add	r2,r3,r2
81111c54:	1009883a 	mov	r4,r2
81111c58:	1108da00 	call	81108da0 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81111c5c:	d0a05c17 	ldw	r2,-32400(gp)
81111c60:	e0fffd0b 	ldhu	r3,-12(fp)
81111c64:	180d883a 	mov	r6,r3
81111c68:	01604534 	movhi	r5,33044
81111c6c:	295fe104 	addi	r5,r5,32644
81111c70:	1009883a 	mov	r4,r2
81111c74:	111b3900 	call	8111b390 <fprintf>
			#endif

			break;
81111c78:	00007006 	br	81111e3c <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81111c7c:	e0bffd0b 	ldhu	r2,-12(fp)
81111c80:	e0fffe17 	ldw	r3,-8(fp)
81111c84:	10809524 	muli	r2,r2,596
81111c88:	1885883a 	add	r2,r3,r2
81111c8c:	10803e04 	addi	r2,r2,248
81111c90:	10800017 	ldw	r2,0(r2)
81111c94:	10800058 	cmpnei	r2,r2,1
81111c98:	10004a1e 	bne	r2,zero,81111dc4 <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111c9c:	e0bffd0b 	ldhu	r2,-12(fp)
81111ca0:	10809524 	muli	r2,r2,596
81111ca4:	10805404 	addi	r2,r2,336
81111ca8:	e0fffe17 	ldw	r3,-8(fp)
81111cac:	1885883a 	add	r2,r3,r2
81111cb0:	1009883a 	mov	r4,r2
81111cb4:	11069500 	call	81106950 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81111cb8:	e0bffd0b 	ldhu	r2,-12(fp)
81111cbc:	e0fffe17 	ldw	r3,-8(fp)
81111cc0:	10809524 	muli	r2,r2,596
81111cc4:	1885883a 	add	r2,r3,r2
81111cc8:	10806404 	addi	r2,r2,400
81111ccc:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111cd0:	e0bffd0b 	ldhu	r2,-12(fp)
81111cd4:	10809524 	muli	r2,r2,596
81111cd8:	10805404 	addi	r2,r2,336
81111cdc:	e0fffe17 	ldw	r3,-8(fp)
81111ce0:	1885883a 	add	r2,r3,r2
81111ce4:	1009883a 	mov	r4,r2
81111ce8:	11068a80 	call	811068a8 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81111cec:	e0bffd0b 	ldhu	r2,-12(fp)
81111cf0:	10809524 	muli	r2,r2,596
81111cf4:	10805404 	addi	r2,r2,336
81111cf8:	e0fffe17 	ldw	r3,-8(fp)
81111cfc:	1885883a 	add	r2,r3,r2
81111d00:	1009883a 	mov	r4,r2
81111d04:	1106b380 	call	81106b38 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81111d08:	e0bffd0b 	ldhu	r2,-12(fp)
81111d0c:	e0ffff17 	ldw	r3,-4(fp)
81111d10:	18c00b0b 	ldhu	r3,44(r3)
81111d14:	1809883a 	mov	r4,r3
81111d18:	e0fffe17 	ldw	r3,-8(fp)
81111d1c:	10809524 	muli	r2,r2,596
81111d20:	1885883a 	add	r2,r3,r2
81111d24:	10805504 	addi	r2,r2,340
81111d28:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81111d2c:	e0bffd0b 	ldhu	r2,-12(fp)
81111d30:	e0ffff17 	ldw	r3,-4(fp)
81111d34:	18c0098b 	ldhu	r3,38(r3)
81111d38:	1809883a 	mov	r4,r3
81111d3c:	e0fffe17 	ldw	r3,-8(fp)
81111d40:	10809524 	muli	r2,r2,596
81111d44:	1885883a 	add	r2,r3,r2
81111d48:	10805544 	addi	r2,r2,341
81111d4c:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81111d50:	e0bffd0b 	ldhu	r2,-12(fp)
81111d54:	10809524 	muli	r2,r2,596
81111d58:	10805404 	addi	r2,r2,336
81111d5c:	e0fffe17 	ldw	r3,-8(fp)
81111d60:	1885883a 	add	r2,r3,r2
81111d64:	1009883a 	mov	r4,r2
81111d68:	1106a600 	call	81106a60 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111d6c:	e0bffd0b 	ldhu	r2,-12(fp)
81111d70:	10809524 	muli	r2,r2,596
81111d74:	10805404 	addi	r2,r2,336
81111d78:	e0fffe17 	ldw	r3,-8(fp)
81111d7c:	1885883a 	add	r2,r3,r2
81111d80:	1009883a 	mov	r4,r2
81111d84:	11069500 	call	81106950 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81111d88:	e0bffd0b 	ldhu	r2,-12(fp)
81111d8c:	e0fffe17 	ldw	r3,-8(fp)
81111d90:	10809524 	muli	r2,r2,596
81111d94:	1885883a 	add	r2,r3,r2
81111d98:	10806404 	addi	r2,r2,400
81111d9c:	00c00044 	movi	r3,1
81111da0:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111da4:	e0bffd0b 	ldhu	r2,-12(fp)
81111da8:	10809524 	muli	r2,r2,596
81111dac:	10805404 	addi	r2,r2,336
81111db0:	e0fffe17 	ldw	r3,-8(fp)
81111db4:	1885883a 	add	r2,r3,r2
81111db8:	1009883a 	mov	r4,r2
81111dbc:	11068a80 	call	811068a8 <bRmapSetIrqControl>
81111dc0:	00000706 	br	81111de0 <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
81111dc4:	d0a05c17 	ldw	r2,-32400(gp)
81111dc8:	e0fffd0b 	ldhu	r3,-12(fp)
81111dcc:	180d883a 	mov	r6,r3
81111dd0:	01604534 	movhi	r5,33044
81111dd4:	295fea04 	addi	r5,r5,32680
81111dd8:	1009883a 	mov	r4,r2
81111ddc:	111b3900 	call	8111b390 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81111de0:	d0e05c17 	ldw	r3,-32400(gp)
81111de4:	e0bfff17 	ldw	r2,-4(fp)
81111de8:	10800b0b 	ldhu	r2,44(r2)
81111dec:	113fffcc 	andi	r4,r2,65535
81111df0:	e0bfff17 	ldw	r2,-4(fp)
81111df4:	1080098b 	ldhu	r2,38(r2)
81111df8:	10bfffcc 	andi	r2,r2,65535
81111dfc:	100f883a 	mov	r7,r2
81111e00:	200d883a 	mov	r6,r4
81111e04:	01604534 	movhi	r5,33044
81111e08:	295fa004 	addi	r5,r5,32384
81111e0c:	1809883a 	mov	r4,r3
81111e10:	111b3900 	call	8111b390 <fprintf>
			#endif
			break;
81111e14:	00000906 	br	81111e3c <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81111e18:	d0a05c17 	ldw	r2,-32400(gp)
81111e1c:	100f883a 	mov	r7,r2
81111e20:	01800c84 	movi	r6,50
81111e24:	01400044 	movi	r5,1
81111e28:	01204534 	movhi	r4,33044
81111e2c:	211fbd04 	addi	r4,r4,32500
81111e30:	111ba2c0 	call	8111ba2c <fwrite>
			#endif
			break;
81111e34:	00000106 	br	81111e3c <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81111e38:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81111e3c:	0001883a 	nop
81111e40:	e037883a 	mov	sp,fp
81111e44:	dfc00117 	ldw	ra,4(sp)
81111e48:	df000017 	ldw	fp,0(sp)
81111e4c:	dec00204 	addi	sp,sp,8
81111e50:	f800283a 	ret

81111e54 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111e54:	defff904 	addi	sp,sp,-28
81111e58:	de00012e 	bgeu	sp,et,81111e60 <vSendCmdQToNFeeCTRL+0xc>
81111e5c:	003b68fa 	trap	3
81111e60:	dfc00615 	stw	ra,24(sp)
81111e64:	df000515 	stw	fp,20(sp)
81111e68:	df000504 	addi	fp,sp,20
81111e6c:	2807883a 	mov	r3,r5
81111e70:	3005883a 	mov	r2,r6
81111e74:	e13ffd05 	stb	r4,-12(fp)
81111e78:	e0fffe05 	stb	r3,-8(fp)
81111e7c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81111e80:	00800404 	movi	r2,16
81111e84:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111e88:	e0bffd03 	ldbu	r2,-12(fp)
81111e8c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111e90:	e0bffe03 	ldbu	r2,-8(fp)
81111e94:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111e98:	e0bfff03 	ldbu	r2,-4(fp)
81111e9c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81111ea0:	d0a06a17 	ldw	r2,-32344(gp)
81111ea4:	e0fffc17 	ldw	r3,-16(fp)
81111ea8:	180b883a 	mov	r5,r3
81111eac:	1009883a 	mov	r4,r2
81111eb0:	113897c0 	call	8113897c <OSQPost>
81111eb4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111eb8:	e0bffb03 	ldbu	r2,-20(fp)
81111ebc:	10000126 	beq	r2,zero,81111ec4 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81111ec0:	11181dc0 	call	811181dc <vFailSendMsgFeeCTRL>
	}
}
81111ec4:	0001883a 	nop
81111ec8:	e037883a 	mov	sp,fp
81111ecc:	dfc00117 	ldw	ra,4(sp)
81111ed0:	df000017 	ldw	fp,0(sp)
81111ed4:	dec00204 	addi	sp,sp,8
81111ed8:	f800283a 	ret

81111edc <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111edc:	defff904 	addi	sp,sp,-28
81111ee0:	de00012e 	bgeu	sp,et,81111ee8 <vSendCmdQToNFeeCTRL_PRIO+0xc>
81111ee4:	003b68fa 	trap	3
81111ee8:	dfc00615 	stw	ra,24(sp)
81111eec:	df000515 	stw	fp,20(sp)
81111ef0:	df000504 	addi	fp,sp,20
81111ef4:	2807883a 	mov	r3,r5
81111ef8:	3005883a 	mov	r2,r6
81111efc:	e13ffd05 	stb	r4,-12(fp)
81111f00:	e0fffe05 	stb	r3,-8(fp)
81111f04:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81111f08:	00800404 	movi	r2,16
81111f0c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111f10:	e0bffd03 	ldbu	r2,-12(fp)
81111f14:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111f18:	e0bffe03 	ldbu	r2,-8(fp)
81111f1c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111f20:	e0bfff03 	ldbu	r2,-4(fp)
81111f24:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81111f28:	d0a06a17 	ldw	r2,-32344(gp)
81111f2c:	e0fffc17 	ldw	r3,-16(fp)
81111f30:	180b883a 	mov	r5,r3
81111f34:	1009883a 	mov	r4,r2
81111f38:	1138aec0 	call	81138aec <OSQPostFront>
81111f3c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111f40:	e0bffb03 	ldbu	r2,-20(fp)
81111f44:	10000126 	beq	r2,zero,81111f4c <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81111f48:	11181dc0 	call	811181dc <vFailSendMsgFeeCTRL>
	}
}
81111f4c:	0001883a 	nop
81111f50:	e037883a 	mov	sp,fp
81111f54:	dfc00117 	ldw	ra,4(sp)
81111f58:	df000017 	ldw	fp,0(sp)
81111f5c:	dec00204 	addi	sp,sp,8
81111f60:	f800283a 	ret

81111f64 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111f64:	defff804 	addi	sp,sp,-32
81111f68:	de00012e 	bgeu	sp,et,81111f70 <vSendCmdQToNFeeCTRL_GEN+0xc>
81111f6c:	003b68fa 	trap	3
81111f70:	dfc00715 	stw	ra,28(sp)
81111f74:	df000615 	stw	fp,24(sp)
81111f78:	df000604 	addi	fp,sp,24
81111f7c:	2011883a 	mov	r8,r4
81111f80:	2809883a 	mov	r4,r5
81111f84:	3007883a 	mov	r3,r6
81111f88:	3805883a 	mov	r2,r7
81111f8c:	e23ffc05 	stb	r8,-16(fp)
81111f90:	e13ffd05 	stb	r4,-12(fp)
81111f94:	e0fffe05 	stb	r3,-8(fp)
81111f98:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81111f9c:	e0bffc03 	ldbu	r2,-16(fp)
81111fa0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111fa4:	e0bffd03 	ldbu	r2,-12(fp)
81111fa8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111fac:	e0bffe03 	ldbu	r2,-8(fp)
81111fb0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111fb4:	e0bfff03 	ldbu	r2,-4(fp)
81111fb8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81111fbc:	d0a06a17 	ldw	r2,-32344(gp)
81111fc0:	e0fffb17 	ldw	r3,-20(fp)
81111fc4:	180b883a 	mov	r5,r3
81111fc8:	1009883a 	mov	r4,r2
81111fcc:	113897c0 	call	8113897c <OSQPost>
81111fd0:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111fd4:	e0bffa03 	ldbu	r2,-24(fp)
81111fd8:	10000126 	beq	r2,zero,81111fe0 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81111fdc:	11181dc0 	call	811181dc <vFailSendMsgFeeCTRL>
	}
}
81111fe0:	0001883a 	nop
81111fe4:	e037883a 	mov	sp,fp
81111fe8:	dfc00117 	ldw	ra,4(sp)
81111fec:	df000017 	ldw	fp,0(sp)
81111ff0:	dec00204 	addi	sp,sp,8
81111ff4:	f800283a 	ret

81111ff8 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111ff8:	defff904 	addi	sp,sp,-28
81111ffc:	de00012e 	bgeu	sp,et,81112004 <vSendCmdQToDataCTRL+0xc>
81112000:	003b68fa 	trap	3
81112004:	dfc00615 	stw	ra,24(sp)
81112008:	df000515 	stw	fp,20(sp)
8111200c:	df000504 	addi	fp,sp,20
81112010:	2807883a 	mov	r3,r5
81112014:	3005883a 	mov	r2,r6
81112018:	e13ffd05 	stb	r4,-12(fp)
8111201c:	e0fffe05 	stb	r3,-8(fp)
81112020:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81112024:	00800804 	movi	r2,32
81112028:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111202c:	e0bffd03 	ldbu	r2,-12(fp)
81112030:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112034:	e0bffe03 	ldbu	r2,-8(fp)
81112038:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111203c:	e0bfff03 	ldbu	r2,-4(fp)
81112040:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81112044:	d0a05917 	ldw	r2,-32412(gp)
81112048:	e0fffc17 	ldw	r3,-16(fp)
8111204c:	180b883a 	mov	r5,r3
81112050:	1009883a 	mov	r4,r2
81112054:	113897c0 	call	8113897c <OSQPost>
81112058:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111205c:	e0bffb03 	ldbu	r2,-20(fp)
81112060:	10000126 	beq	r2,zero,81112068 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81112064:	11182280 	call	81118228 <vFailSendMsgDataCTRL>
	}
}
81112068:	0001883a 	nop
8111206c:	e037883a 	mov	sp,fp
81112070:	dfc00117 	ldw	ra,4(sp)
81112074:	df000017 	ldw	fp,0(sp)
81112078:	dec00204 	addi	sp,sp,8
8111207c:	f800283a 	ret

81112080 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112080:	defff904 	addi	sp,sp,-28
81112084:	de00012e 	bgeu	sp,et,8111208c <vSendCmdQToDataCTRL_PRIO+0xc>
81112088:	003b68fa 	trap	3
8111208c:	dfc00615 	stw	ra,24(sp)
81112090:	df000515 	stw	fp,20(sp)
81112094:	df000504 	addi	fp,sp,20
81112098:	2807883a 	mov	r3,r5
8111209c:	3005883a 	mov	r2,r6
811120a0:	e13ffd05 	stb	r4,-12(fp)
811120a4:	e0fffe05 	stb	r3,-8(fp)
811120a8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811120ac:	00800404 	movi	r2,16
811120b0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811120b4:	e0bffd03 	ldbu	r2,-12(fp)
811120b8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811120bc:	e0bffe03 	ldbu	r2,-8(fp)
811120c0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811120c4:	e0bfff03 	ldbu	r2,-4(fp)
811120c8:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
811120cc:	d0a05917 	ldw	r2,-32412(gp)
811120d0:	e0fffc17 	ldw	r3,-16(fp)
811120d4:	180b883a 	mov	r5,r3
811120d8:	1009883a 	mov	r4,r2
811120dc:	1138aec0 	call	81138aec <OSQPostFront>
811120e0:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811120e4:	e0bffb03 	ldbu	r2,-20(fp)
811120e8:	10000126 	beq	r2,zero,811120f0 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
811120ec:	11181dc0 	call	811181dc <vFailSendMsgFeeCTRL>
	}
}
811120f0:	0001883a 	nop
811120f4:	e037883a 	mov	sp,fp
811120f8:	dfc00117 	ldw	ra,4(sp)
811120fc:	df000017 	ldw	fp,0(sp)
81112100:	dec00204 	addi	sp,sp,8
81112104:	f800283a 	ret

81112108 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81112108:	defffc04 	addi	sp,sp,-16
8111210c:	de00012e 	bgeu	sp,et,81112114 <vMebInit+0xc>
81112110:	003b68fa 	trap	3
81112114:	dfc00315 	stw	ra,12(sp)
81112118:	df000215 	stw	fp,8(sp)
8111211c:	df000204 	addi	fp,sp,8
81112120:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81112124:	e0bfff17 	ldw	r2,-4(fp)
81112128:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
8111212c:	e0bfff17 	ldw	r2,-4(fp)
81112130:	00c00044 	movi	r3,1
81112134:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
81112138:	d0a06317 	ldw	r2,-32372(gp)
8111213c:	1009883a 	mov	r4,r2
81112140:	11384b40 	call	811384b4 <OSQFlush>
81112144:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
81112148:	e0bffe03 	ldbu	r2,-8(fp)
8111214c:	10000126 	beq	r2,zero,81112154 <vMebInit+0x4c>
		vFailFlushMEBQueue();
81112150:	111830c0 	call	8111830c <vFailFlushMEBQueue>
	}
}
81112154:	0001883a 	nop
81112158:	e037883a 	mov	sp,fp
8111215c:	dfc00117 	ldw	ra,4(sp)
81112160:	df000017 	ldw	fp,0(sp)
81112164:	dec00204 	addi	sp,sp,8
81112168:	f800283a 	ret

8111216c <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
8111216c:	defffe04 	addi	sp,sp,-8
81112170:	de00012e 	bgeu	sp,et,81112178 <vSwapMemmory+0xc>
81112174:	003b68fa 	trap	3
81112178:	df000115 	stw	fp,4(sp)
8111217c:	df000104 	addi	fp,sp,4
81112180:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
81112184:	e0bfff17 	ldw	r2,-4(fp)
81112188:	10800203 	ldbu	r2,8(r2)
8111218c:	10803fcc 	andi	r2,r2,255
81112190:	10c00044 	addi	r3,r2,1
81112194:	00a00034 	movhi	r2,32768
81112198:	10800044 	addi	r2,r2,1
8111219c:	1884703a 	and	r2,r3,r2
811121a0:	1000040e 	bge	r2,zero,811121b4 <vSwapMemmory+0x48>
811121a4:	10bfffc4 	addi	r2,r2,-1
811121a8:	00ffff84 	movi	r3,-2
811121ac:	10c4b03a 	or	r2,r2,r3
811121b0:	10800044 	addi	r2,r2,1
811121b4:	1007883a 	mov	r3,r2
811121b8:	e0bfff17 	ldw	r2,-4(fp)
811121bc:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
811121c0:	e0bfff17 	ldw	r2,-4(fp)
811121c4:	10800243 	ldbu	r2,9(r2)
811121c8:	10803fcc 	andi	r2,r2,255
811121cc:	10c00044 	addi	r3,r2,1
811121d0:	00a00034 	movhi	r2,32768
811121d4:	10800044 	addi	r2,r2,1
811121d8:	1884703a 	and	r2,r3,r2
811121dc:	1000040e 	bge	r2,zero,811121f0 <vSwapMemmory+0x84>
811121e0:	10bfffc4 	addi	r2,r2,-1
811121e4:	00ffff84 	movi	r3,-2
811121e8:	10c4b03a 	or	r2,r2,r3
811121ec:	10800044 	addi	r2,r2,1
811121f0:	1007883a 	mov	r3,r2
811121f4:	e0bfff17 	ldw	r2,-4(fp)
811121f8:	10c00245 	stb	r3,9(r2)

}
811121fc:	0001883a 	nop
81112200:	e037883a 	mov	sp,fp
81112204:	df000017 	ldw	fp,0(sp)
81112208:	dec00104 	addi	sp,sp,4
8111220c:	f800283a 	ret

81112210 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
81112210:	defffc04 	addi	sp,sp,-16
81112214:	de00012e 	bgeu	sp,et,8111221c <vReleaseSyncMessages+0xc>
81112218:	003b68fa 	trap	3
8111221c:	dfc00315 	stw	ra,12(sp)
81112220:	df000215 	stw	fp,8(sp)
81112224:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81112228:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
8111222c:	00bff844 	movi	r2,-31
81112230:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81112234:	e03ffe05 	stb	zero,-8(fp)
81112238:	00001606 	br	81112294 <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8111223c:	e0bffe03 	ldbu	r2,-8(fp)
81112240:	10800444 	addi	r2,r2,17
81112244:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
81112248:	e0bffe03 	ldbu	r2,-8(fp)
8111224c:	1085883a 	add	r2,r2,r2
81112250:	1087883a 	add	r3,r2,r2
81112254:	d0a05604 	addi	r2,gp,-32424
81112258:	1885883a 	add	r2,r3,r2
8111225c:	10800017 	ldw	r2,0(r2)
81112260:	e0ffff17 	ldw	r3,-4(fp)
81112264:	180b883a 	mov	r5,r3
81112268:	1009883a 	mov	r4,r2
8111226c:	113897c0 	call	8113897c <OSQPost>
81112270:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
81112274:	e0bffe43 	ldbu	r2,-7(fp)
81112278:	10000326 	beq	r2,zero,81112288 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
8111227c:	e0bffe03 	ldbu	r2,-8(fp)
81112280:	1009883a 	mov	r4,r2
81112284:	111813c0 	call	8111813c <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81112288:	e0bffe03 	ldbu	r2,-8(fp)
8111228c:	10800044 	addi	r2,r2,1
81112290:	e0bffe05 	stb	r2,-8(fp)
81112294:	e0bffe03 	ldbu	r2,-8(fp)
81112298:	103fe826 	beq	r2,zero,8111223c <__reset+0xfb0f223c>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
8111229c:	0001883a 	nop
811122a0:	e037883a 	mov	sp,fp
811122a4:	dfc00117 	ldw	ra,4(sp)
811122a8:	df000017 	ldw	fp,0(sp)
811122ac:	dec00204 	addi	sp,sp,8
811122b0:	f800283a 	ret

811122b4 <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
811122b4:	defff804 	addi	sp,sp,-32
811122b8:	de00012e 	bgeu	sp,et,811122c0 <vStackMonitor+0xc>
811122bc:	003b68fa 	trap	3
811122c0:	dfc00715 	stw	ra,28(sp)
811122c4:	df000615 	stw	fp,24(sp)
811122c8:	df000604 	addi	fp,sp,24
811122cc:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
811122d0:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
811122d4:	d0a05c17 	ldw	r2,-32400(gp)
811122d8:	100f883a 	mov	r7,r2
811122dc:	018006c4 	movi	r6,27
811122e0:	01400044 	movi	r5,1
811122e4:	01204534 	movhi	r4,33044
811122e8:	211ffd04 	addi	r4,r4,32756
811122ec:	111ba2c0 	call	8111ba2c <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
811122f0:	d0a05c17 	ldw	r2,-32400(gp)
811122f4:	100f883a 	mov	r7,r2
811122f8:	01800b04 	movi	r6,44
811122fc:	01400044 	movi	r5,1
81112300:	01204574 	movhi	r4,33045
81112304:	21200404 	addi	r4,r4,-32752
81112308:	111ba2c0 	call	8111ba2c <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
8111230c:	d0a05c17 	ldw	r2,-32400(gp)
81112310:	100f883a 	mov	r7,r2
81112314:	01800f84 	movi	r6,62
81112318:	01400044 	movi	r5,1
8111231c:	01204574 	movhi	r4,33045
81112320:	21201004 	addi	r4,r4,-32704
81112324:	111ba2c0 	call	8111ba2c <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81112328:	e0bffd04 	addi	r2,fp,-12
8111232c:	100b883a 	mov	r5,r2
81112330:	01000804 	movi	r4,32
81112334:	113abec0 	call	8113abec <OSTaskStkChk>
81112338:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
8111233c:	e0bffc03 	ldbu	r2,-16(fp)
81112340:	10000f1e 	bne	r2,zero,81112380 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112344:	d1205c17 	ldw	r4,-32400(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81112348:	e0fffd17 	ldw	r3,-12(fp)
8111234c:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112350:	188b883a 	add	r5,r3,r2
81112354:	e0bffd17 	ldw	r2,-12(fp)
81112358:	e0fffe17 	ldw	r3,-8(fp)
8111235c:	d8c00115 	stw	r3,4(sp)
81112360:	d8800015 	stw	r2,0(sp)
81112364:	280f883a 	mov	r7,r5
81112368:	01a04574 	movhi	r6,33045
8111236c:	31a02004 	addi	r6,r6,-32640
81112370:	01604574 	movhi	r5,33045
81112374:	29602404 	addi	r5,r5,-32624
81112378:	111b3900 	call	8111b390 <fprintf>
8111237c:	00000706 	br	8111239c <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81112380:	d0a05c17 	ldw	r2,-32400(gp)
81112384:	100f883a 	mov	r7,r2
81112388:	01800904 	movi	r6,36
8111238c:	01400044 	movi	r5,1
81112390:	01204574 	movhi	r4,33045
81112394:	21203304 	addi	r4,r4,-32564
81112398:	111ba2c0 	call	8111ba2c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
8111239c:	e0bffd04 	addi	r2,fp,-12
811123a0:	100b883a 	mov	r5,r2
811123a4:	01000784 	movi	r4,30
811123a8:	113abec0 	call	8113abec <OSTaskStkChk>
811123ac:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811123b0:	e0bffc03 	ldbu	r2,-16(fp)
811123b4:	10000f1e 	bne	r2,zero,811123f4 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811123b8:	d1205c17 	ldw	r4,-32400(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
811123bc:	e0fffd17 	ldw	r3,-12(fp)
811123c0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811123c4:	188b883a 	add	r5,r3,r2
811123c8:	e0bffd17 	ldw	r2,-12(fp)
811123cc:	e0fffe17 	ldw	r3,-8(fp)
811123d0:	d8c00115 	stw	r3,4(sp)
811123d4:	d8800015 	stw	r2,0(sp)
811123d8:	280f883a 	mov	r7,r5
811123dc:	01a04574 	movhi	r6,33045
811123e0:	31a03d04 	addi	r6,r6,-32524
811123e4:	01604574 	movhi	r5,33045
811123e8:	29602404 	addi	r5,r5,-32624
811123ec:	111b3900 	call	8111b390 <fprintf>
811123f0:	00000706 	br	81112410 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
811123f4:	d0a05c17 	ldw	r2,-32400(gp)
811123f8:	100f883a 	mov	r7,r2
811123fc:	01800984 	movi	r6,38
81112400:	01400044 	movi	r5,1
81112404:	01204574 	movhi	r4,33045
81112408:	21204104 	addi	r4,r4,-32508
8111240c:	111ba2c0 	call	8111ba2c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
81112410:	e0bffd04 	addi	r2,fp,-12
81112414:	100b883a 	mov	r5,r2
81112418:	01000704 	movi	r4,28
8111241c:	113abec0 	call	8113abec <OSTaskStkChk>
81112420:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112424:	e0bffc03 	ldbu	r2,-16(fp)
81112428:	10000f1e 	bne	r2,zero,81112468 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111242c:	d1205c17 	ldw	r4,-32400(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81112430:	e0fffd17 	ldw	r3,-12(fp)
81112434:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112438:	188b883a 	add	r5,r3,r2
8111243c:	e0bffd17 	ldw	r2,-12(fp)
81112440:	e0fffe17 	ldw	r3,-8(fp)
81112444:	d8c00115 	stw	r3,4(sp)
81112448:	d8800015 	stw	r2,0(sp)
8111244c:	280f883a 	mov	r7,r5
81112450:	01a04574 	movhi	r6,33045
81112454:	31a04b04 	addi	r6,r6,-32468
81112458:	01604574 	movhi	r5,33045
8111245c:	29602404 	addi	r5,r5,-32624
81112460:	111b3900 	call	8111b390 <fprintf>
81112464:	00000706 	br	81112484 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81112468:	d0a05c17 	ldw	r2,-32400(gp)
8111246c:	100f883a 	mov	r7,r2
81112470:	01800884 	movi	r6,34
81112474:	01400044 	movi	r5,1
81112478:	01204574 	movhi	r4,33045
8111247c:	21204e04 	addi	r4,r4,-32456
81112480:	111ba2c0 	call	8111ba2c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
81112484:	e0bffd04 	addi	r2,fp,-12
81112488:	100b883a 	mov	r5,r2
8111248c:	010006c4 	movi	r4,27
81112490:	113abec0 	call	8113abec <OSTaskStkChk>
81112494:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112498:	e0bffc03 	ldbu	r2,-16(fp)
8111249c:	10000f1e 	bne	r2,zero,811124dc <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811124a0:	d1205c17 	ldw	r4,-32400(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
811124a4:	e0fffd17 	ldw	r3,-12(fp)
811124a8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811124ac:	188b883a 	add	r5,r3,r2
811124b0:	e0bffd17 	ldw	r2,-12(fp)
811124b4:	e0fffe17 	ldw	r3,-8(fp)
811124b8:	d8c00115 	stw	r3,4(sp)
811124bc:	d8800015 	stw	r2,0(sp)
811124c0:	280f883a 	mov	r7,r5
811124c4:	01a04574 	movhi	r6,33045
811124c8:	31a05704 	addi	r6,r6,-32420
811124cc:	01604574 	movhi	r5,33045
811124d0:	29602404 	addi	r5,r5,-32624
811124d4:	111b3900 	call	8111b390 <fprintf>
811124d8:	00000706 	br	811124f8 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
811124dc:	d0a05c17 	ldw	r2,-32400(gp)
811124e0:	100f883a 	mov	r7,r2
811124e4:	018008c4 	movi	r6,35
811124e8:	01400044 	movi	r5,1
811124ec:	01204574 	movhi	r4,33045
811124f0:	21205b04 	addi	r4,r4,-32404
811124f4:	111ba2c0 	call	8111ba2c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
811124f8:	e0bffd04 	addi	r2,fp,-12
811124fc:	100b883a 	mov	r5,r2
81112500:	01000684 	movi	r4,26
81112504:	113abec0 	call	8113abec <OSTaskStkChk>
81112508:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111250c:	e0bffc03 	ldbu	r2,-16(fp)
81112510:	10000f1e 	bne	r2,zero,81112550 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112514:	d1205c17 	ldw	r4,-32400(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81112518:	e0fffd17 	ldw	r3,-12(fp)
8111251c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112520:	188b883a 	add	r5,r3,r2
81112524:	e0bffd17 	ldw	r2,-12(fp)
81112528:	e0fffe17 	ldw	r3,-8(fp)
8111252c:	d8c00115 	stw	r3,4(sp)
81112530:	d8800015 	stw	r2,0(sp)
81112534:	280f883a 	mov	r7,r5
81112538:	01a04574 	movhi	r6,33045
8111253c:	31a06404 	addi	r6,r6,-32368
81112540:	01604574 	movhi	r5,33045
81112544:	29602404 	addi	r5,r5,-32624
81112548:	111b3900 	call	8111b390 <fprintf>
8111254c:	00000706 	br	8111256c <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81112550:	d0a05c17 	ldw	r2,-32400(gp)
81112554:	100f883a 	mov	r7,r2
81112558:	01800884 	movi	r6,34
8111255c:	01400044 	movi	r5,1
81112560:	01204574 	movhi	r4,33045
81112564:	21206704 	addi	r4,r4,-32356
81112568:	111ba2c0 	call	8111ba2c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
8111256c:	e0bffd04 	addi	r2,fp,-12
81112570:	100b883a 	mov	r5,r2
81112574:	01000644 	movi	r4,25
81112578:	113abec0 	call	8113abec <OSTaskStkChk>
8111257c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112580:	e0bffc03 	ldbu	r2,-16(fp)
81112584:	10000f1e 	bne	r2,zero,811125c4 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112588:	d1205c17 	ldw	r4,-32400(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
8111258c:	e0fffd17 	ldw	r3,-12(fp)
81112590:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112594:	188b883a 	add	r5,r3,r2
81112598:	e0bffd17 	ldw	r2,-12(fp)
8111259c:	e0fffe17 	ldw	r3,-8(fp)
811125a0:	d8c00115 	stw	r3,4(sp)
811125a4:	d8800015 	stw	r2,0(sp)
811125a8:	280f883a 	mov	r7,r5
811125ac:	01a04574 	movhi	r6,33045
811125b0:	31a07004 	addi	r6,r6,-32320
811125b4:	01604574 	movhi	r5,33045
811125b8:	29602404 	addi	r5,r5,-32624
811125bc:	111b3900 	call	8111b390 <fprintf>
811125c0:	00000706 	br	811125e0 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
811125c4:	d0a05c17 	ldw	r2,-32400(gp)
811125c8:	100f883a 	mov	r7,r2
811125cc:	01800884 	movi	r6,34
811125d0:	01400044 	movi	r5,1
811125d4:	01204574 	movhi	r4,33045
811125d8:	21207304 	addi	r4,r4,-32308
811125dc:	111ba2c0 	call	8111ba2c <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
811125e0:	e0bffd04 	addi	r2,fp,-12
811125e4:	100b883a 	mov	r5,r2
811125e8:	01000044 	movi	r4,1
811125ec:	113abec0 	call	8113abec <OSTaskStkChk>
811125f0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811125f4:	e0bffc03 	ldbu	r2,-16(fp)
811125f8:	10000f1e 	bne	r2,zero,81112638 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811125fc:	d1205c17 	ldw	r4,-32400(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81112600:	e0fffd17 	ldw	r3,-12(fp)
81112604:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112608:	188b883a 	add	r5,r3,r2
8111260c:	e0bffd17 	ldw	r2,-12(fp)
81112610:	e0fffe17 	ldw	r3,-8(fp)
81112614:	d8c00115 	stw	r3,4(sp)
81112618:	d8800015 	stw	r2,0(sp)
8111261c:	280f883a 	mov	r7,r5
81112620:	01a04574 	movhi	r6,33045
81112624:	31a07c04 	addi	r6,r6,-32272
81112628:	01604574 	movhi	r5,33045
8111262c:	29602404 	addi	r5,r5,-32624
81112630:	111b3900 	call	8111b390 <fprintf>
81112634:	00000706 	br	81112654 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81112638:	d0a05c17 	ldw	r2,-32400(gp)
8111263c:	100f883a 	mov	r7,r2
81112640:	01800804 	movi	r6,32
81112644:	01400044 	movi	r5,1
81112648:	01204574 	movhi	r4,33045
8111264c:	21207f04 	addi	r4,r4,-32260
81112650:	111ba2c0 	call	8111ba2c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
81112654:	e0bffd04 	addi	r2,fp,-12
81112658:	100b883a 	mov	r5,r2
8111265c:	01000244 	movi	r4,9
81112660:	113abec0 	call	8113abec <OSTaskStkChk>
81112664:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112668:	e0bffc03 	ldbu	r2,-16(fp)
8111266c:	10000f1e 	bne	r2,zero,811126ac <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112670:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
81112674:	e0fffd17 	ldw	r3,-12(fp)
81112678:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111267c:	188b883a 	add	r5,r3,r2
81112680:	e0bffd17 	ldw	r2,-12(fp)
81112684:	e0fffe17 	ldw	r3,-8(fp)
81112688:	d8c00115 	stw	r3,4(sp)
8111268c:	d8800015 	stw	r2,0(sp)
81112690:	280f883a 	mov	r7,r5
81112694:	01a04574 	movhi	r6,33045
81112698:	31a08804 	addi	r6,r6,-32224
8111269c:	01604574 	movhi	r5,33045
811126a0:	29602404 	addi	r5,r5,-32624
811126a4:	111b3900 	call	8111b390 <fprintf>
811126a8:	00000706 	br	811126c8 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
811126ac:	d0a05c17 	ldw	r2,-32400(gp)
811126b0:	100f883a 	mov	r7,r2
811126b4:	018008c4 	movi	r6,35
811126b8:	01400044 	movi	r5,1
811126bc:	01204574 	movhi	r4,33045
811126c0:	21208b04 	addi	r4,r4,-32212
811126c4:	111ba2c0 	call	8111ba2c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
811126c8:	e0bffd04 	addi	r2,fp,-12
811126cc:	100b883a 	mov	r5,r2
811126d0:	01000284 	movi	r4,10
811126d4:	113abec0 	call	8113abec <OSTaskStkChk>
811126d8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811126dc:	e0bffc03 	ldbu	r2,-16(fp)
811126e0:	10000f1e 	bne	r2,zero,81112720 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811126e4:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
811126e8:	e0fffd17 	ldw	r3,-12(fp)
811126ec:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811126f0:	188b883a 	add	r5,r3,r2
811126f4:	e0bffd17 	ldw	r2,-12(fp)
811126f8:	e0fffe17 	ldw	r3,-8(fp)
811126fc:	d8c00115 	stw	r3,4(sp)
81112700:	d8800015 	stw	r2,0(sp)
81112704:	280f883a 	mov	r7,r5
81112708:	01a04574 	movhi	r6,33045
8111270c:	31a09404 	addi	r6,r6,-32176
81112710:	01604574 	movhi	r5,33045
81112714:	29602404 	addi	r5,r5,-32624
81112718:	111b3900 	call	8111b390 <fprintf>
8111271c:	00000706 	br	8111273c <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
81112720:	d0a05c17 	ldw	r2,-32400(gp)
81112724:	100f883a 	mov	r7,r2
81112728:	018008c4 	movi	r6,35
8111272c:	01400044 	movi	r5,1
81112730:	01204574 	movhi	r4,33045
81112734:	21209704 	addi	r4,r4,-32164
81112738:	111ba2c0 	call	8111ba2c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
8111273c:	e0bffd04 	addi	r2,fp,-12
81112740:	100b883a 	mov	r5,r2
81112744:	010002c4 	movi	r4,11
81112748:	113abec0 	call	8113abec <OSTaskStkChk>
8111274c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112750:	e0bffc03 	ldbu	r2,-16(fp)
81112754:	10000f1e 	bne	r2,zero,81112794 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112758:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
8111275c:	e0fffd17 	ldw	r3,-12(fp)
81112760:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112764:	188b883a 	add	r5,r3,r2
81112768:	e0bffd17 	ldw	r2,-12(fp)
8111276c:	e0fffe17 	ldw	r3,-8(fp)
81112770:	d8c00115 	stw	r3,4(sp)
81112774:	d8800015 	stw	r2,0(sp)
81112778:	280f883a 	mov	r7,r5
8111277c:	01a04574 	movhi	r6,33045
81112780:	31a0a004 	addi	r6,r6,-32128
81112784:	01604574 	movhi	r5,33045
81112788:	29602404 	addi	r5,r5,-32624
8111278c:	111b3900 	call	8111b390 <fprintf>
81112790:	00000706 	br	811127b0 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
81112794:	d0a05c17 	ldw	r2,-32400(gp)
81112798:	100f883a 	mov	r7,r2
8111279c:	018008c4 	movi	r6,35
811127a0:	01400044 	movi	r5,1
811127a4:	01204574 	movhi	r4,33045
811127a8:	2120a304 	addi	r4,r4,-32116
811127ac:	111ba2c0 	call	8111ba2c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
811127b0:	e0bffd04 	addi	r2,fp,-12
811127b4:	100b883a 	mov	r5,r2
811127b8:	01000304 	movi	r4,12
811127bc:	113abec0 	call	8113abec <OSTaskStkChk>
811127c0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811127c4:	e0bffc03 	ldbu	r2,-16(fp)
811127c8:	10000f1e 	bne	r2,zero,81112808 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811127cc:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
811127d0:	e0fffd17 	ldw	r3,-12(fp)
811127d4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811127d8:	188b883a 	add	r5,r3,r2
811127dc:	e0bffd17 	ldw	r2,-12(fp)
811127e0:	e0fffe17 	ldw	r3,-8(fp)
811127e4:	d8c00115 	stw	r3,4(sp)
811127e8:	d8800015 	stw	r2,0(sp)
811127ec:	280f883a 	mov	r7,r5
811127f0:	01a04574 	movhi	r6,33045
811127f4:	31a0ac04 	addi	r6,r6,-32080
811127f8:	01604574 	movhi	r5,33045
811127fc:	29602404 	addi	r5,r5,-32624
81112800:	111b3900 	call	8111b390 <fprintf>
81112804:	00000706 	br	81112824 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81112808:	d0a05c17 	ldw	r2,-32400(gp)
8111280c:	100f883a 	mov	r7,r2
81112810:	018008c4 	movi	r6,35
81112814:	01400044 	movi	r5,1
81112818:	01204574 	movhi	r4,33045
8111281c:	2120af04 	addi	r4,r4,-32068
81112820:	111ba2c0 	call	8111ba2c <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81112824:	e0bffd04 	addi	r2,fp,-12
81112828:	100b883a 	mov	r5,r2
8111282c:	01000344 	movi	r4,13
81112830:	113abec0 	call	8113abec <OSTaskStkChk>
81112834:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112838:	e0bffc03 	ldbu	r2,-16(fp)
8111283c:	10000f1e 	bne	r2,zero,8111287c <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112840:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
81112844:	e0fffd17 	ldw	r3,-12(fp)
81112848:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111284c:	188b883a 	add	r5,r3,r2
81112850:	e0bffd17 	ldw	r2,-12(fp)
81112854:	e0fffe17 	ldw	r3,-8(fp)
81112858:	d8c00115 	stw	r3,4(sp)
8111285c:	d8800015 	stw	r2,0(sp)
81112860:	280f883a 	mov	r7,r5
81112864:	01a04574 	movhi	r6,33045
81112868:	31a0b804 	addi	r6,r6,-32032
8111286c:	01604574 	movhi	r5,33045
81112870:	29602404 	addi	r5,r5,-32624
81112874:	111b3900 	call	8111b390 <fprintf>
81112878:	00000706 	br	81112898 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
8111287c:	d0a05c17 	ldw	r2,-32400(gp)
81112880:	100f883a 	mov	r7,r2
81112884:	018008c4 	movi	r6,35
81112888:	01400044 	movi	r5,1
8111288c:	01204574 	movhi	r4,33045
81112890:	2120bb04 	addi	r4,r4,-32020
81112894:	111ba2c0 	call	8111ba2c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81112898:	e0bffd04 	addi	r2,fp,-12
8111289c:	100b883a 	mov	r5,r2
811128a0:	01000384 	movi	r4,14
811128a4:	113abec0 	call	8113abec <OSTaskStkChk>
811128a8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811128ac:	e0bffc03 	ldbu	r2,-16(fp)
811128b0:	10000f1e 	bne	r2,zero,811128f0 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811128b4:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
811128b8:	e0fffd17 	ldw	r3,-12(fp)
811128bc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811128c0:	188b883a 	add	r5,r3,r2
811128c4:	e0bffd17 	ldw	r2,-12(fp)
811128c8:	e0fffe17 	ldw	r3,-8(fp)
811128cc:	d8c00115 	stw	r3,4(sp)
811128d0:	d8800015 	stw	r2,0(sp)
811128d4:	280f883a 	mov	r7,r5
811128d8:	01a04574 	movhi	r6,33045
811128dc:	31a0c404 	addi	r6,r6,-31984
811128e0:	01604574 	movhi	r5,33045
811128e4:	29602404 	addi	r5,r5,-32624
811128e8:	111b3900 	call	8111b390 <fprintf>
811128ec:	00000706 	br	8111290c <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
811128f0:	d0a05c17 	ldw	r2,-32400(gp)
811128f4:	100f883a 	mov	r7,r2
811128f8:	018008c4 	movi	r6,35
811128fc:	01400044 	movi	r5,1
81112900:	01204574 	movhi	r4,33045
81112904:	2120c704 	addi	r4,r4,-31972
81112908:	111ba2c0 	call	8111ba2c <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
8111290c:	e0bffd04 	addi	r2,fp,-12
81112910:	100b883a 	mov	r5,r2
81112914:	01000204 	movi	r4,8
81112918:	113abec0 	call	8113abec <OSTaskStkChk>
8111291c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112920:	e0bffc03 	ldbu	r2,-16(fp)
81112924:	10000f1e 	bne	r2,zero,81112964 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112928:	d1205c17 	ldw	r4,-32400(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
8111292c:	e0fffd17 	ldw	r3,-12(fp)
81112930:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112934:	188b883a 	add	r5,r3,r2
81112938:	e0bffd17 	ldw	r2,-12(fp)
8111293c:	e0fffe17 	ldw	r3,-8(fp)
81112940:	d8c00115 	stw	r3,4(sp)
81112944:	d8800015 	stw	r2,0(sp)
81112948:	280f883a 	mov	r7,r5
8111294c:	01a04574 	movhi	r6,33045
81112950:	31a0d004 	addi	r6,r6,-31936
81112954:	01604574 	movhi	r5,33045
81112958:	29602404 	addi	r5,r5,-32624
8111295c:	111b3900 	call	8111b390 <fprintf>
81112960:	00000706 	br	81112980 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
81112964:	d0a05c17 	ldw	r2,-32400(gp)
81112968:	100f883a 	mov	r7,r2
8111296c:	01800884 	movi	r6,34
81112970:	01400044 	movi	r5,1
81112974:	01204574 	movhi	r4,33045
81112978:	2120d304 	addi	r4,r4,-31924
8111297c:	111ba2c0 	call	8111ba2c <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81112980:	e0bffd04 	addi	r2,fp,-12
81112984:	100b883a 	mov	r5,r2
81112988:	010001c4 	movi	r4,7
8111298c:	113abec0 	call	8113abec <OSTaskStkChk>
81112990:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112994:	e0bffc03 	ldbu	r2,-16(fp)
81112998:	10000f1e 	bne	r2,zero,811129d8 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111299c:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
811129a0:	e0fffd17 	ldw	r3,-12(fp)
811129a4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811129a8:	188b883a 	add	r5,r3,r2
811129ac:	e0bffd17 	ldw	r2,-12(fp)
811129b0:	e0fffe17 	ldw	r3,-8(fp)
811129b4:	d8c00115 	stw	r3,4(sp)
811129b8:	d8800015 	stw	r2,0(sp)
811129bc:	280f883a 	mov	r7,r5
811129c0:	01a04574 	movhi	r6,33045
811129c4:	31a0dc04 	addi	r6,r6,-31888
811129c8:	01604574 	movhi	r5,33045
811129cc:	29602404 	addi	r5,r5,-32624
811129d0:	111b3900 	call	8111b390 <fprintf>
811129d4:	00000706 	br	811129f4 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
811129d8:	d0a05c17 	ldw	r2,-32400(gp)
811129dc:	100f883a 	mov	r7,r2
811129e0:	01800844 	movi	r6,33
811129e4:	01400044 	movi	r5,1
811129e8:	01204574 	movhi	r4,33045
811129ec:	2120df04 	addi	r4,r4,-31876
811129f0:	111ba2c0 	call	8111ba2c <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
811129f4:	e0bffd04 	addi	r2,fp,-12
811129f8:	100b883a 	mov	r5,r2
811129fc:	01000184 	movi	r4,6
81112a00:	113abec0 	call	8113abec <OSTaskStkChk>
81112a04:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112a08:	e0bffc03 	ldbu	r2,-16(fp)
81112a0c:	10000f1e 	bne	r2,zero,81112a4c <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112a10:	d1205c17 	ldw	r4,-32400(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
81112a14:	e0fffd17 	ldw	r3,-12(fp)
81112a18:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112a1c:	188b883a 	add	r5,r3,r2
81112a20:	e0bffd17 	ldw	r2,-12(fp)
81112a24:	e0fffe17 	ldw	r3,-8(fp)
81112a28:	d8c00115 	stw	r3,4(sp)
81112a2c:	d8800015 	stw	r2,0(sp)
81112a30:	280f883a 	mov	r7,r5
81112a34:	01a04574 	movhi	r6,33045
81112a38:	31a0e804 	addi	r6,r6,-31840
81112a3c:	01604574 	movhi	r5,33045
81112a40:	29602404 	addi	r5,r5,-32624
81112a44:	111b3900 	call	8111b390 <fprintf>
81112a48:	00000706 	br	81112a68 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
81112a4c:	d0a05c17 	ldw	r2,-32400(gp)
81112a50:	100f883a 	mov	r7,r2
81112a54:	018007c4 	movi	r6,31
81112a58:	01400044 	movi	r5,1
81112a5c:	01204574 	movhi	r4,33045
81112a60:	2120eb04 	addi	r4,r4,-31828
81112a64:	111ba2c0 	call	8111ba2c <fwrite>
    	}		


    	fprintf(fp, "\n" );
81112a68:	d0a05c17 	ldw	r2,-32400(gp)
81112a6c:	100b883a 	mov	r5,r2
81112a70:	01000284 	movi	r4,10
81112a74:	111b4080 	call	8111b408 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81112a78:	000f883a 	mov	r7,zero
81112a7c:	01800284 	movi	r6,10
81112a80:	000b883a 	mov	r5,zero
81112a84:	0009883a 	mov	r4,zero
81112a88:	113b2500 	call	8113b250 <OSTimeDlyHMSM>
    }
81112a8c:	003e1806 	br	811122f0 <__reset+0xfb0f22f0>

81112a90 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81112a90:	defffc04 	addi	sp,sp,-16
81112a94:	de00012e 	bgeu	sp,et,81112a9c <vTimeoutCheckerTaskv2+0xc>
81112a98:	003b68fa 	trap	3
81112a9c:	dfc00315 	stw	ra,12(sp)
81112aa0:	df000215 	stw	fp,8(sp)
81112aa4:	df000204 	addi	fp,sp,8
81112aa8:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81112aac:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81112ab0:	d0a05c17 	ldw	r2,-32400(gp)
81112ab4:	100f883a 	mov	r7,r2
81112ab8:	01800844 	movi	r6,33
81112abc:	01400044 	movi	r5,1
81112ac0:	01204574 	movhi	r4,33045
81112ac4:	2120f304 	addi	r4,r4,-31796
81112ac8:	111ba2c0 	call	8111ba2c <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81112acc:	d0a06117 	ldw	r2,-32380(gp)
81112ad0:	e1bffe04 	addi	r6,fp,-8
81112ad4:	000b883a 	mov	r5,zero
81112ad8:	1009883a 	mov	r4,r2
81112adc:	113946c0 	call	8113946c <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81112ae0:	e0bffe03 	ldbu	r2,-8(fp)
81112ae4:	10803fcc 	andi	r2,r2,255
81112ae8:	1000021e 	bne	r2,zero,81112af4 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
81112aec:	1112afc0 	call	81112afc <vCheck>
81112af0:	003ff606 	br	81112acc <__reset+0xfb0f2acc>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81112af4:	11173f80 	call	811173f8 <vFailGetBlockingSemTimeoutTask>
        }
    }
81112af8:	003ff406 	br	81112acc <__reset+0xfb0f2acc>

81112afc <vCheck>:
}


void vCheck( void ) {
81112afc:	defffd04 	addi	sp,sp,-12
81112b00:	de00012e 	bgeu	sp,et,81112b08 <vCheck+0xc>
81112b04:	003b68fa 	trap	3
81112b08:	dfc00215 	stw	ra,8(sp)
81112b0c:	df000115 	stw	fp,4(sp)
81112b10:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81112b14:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81112b18:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81112b1c:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81112b20:	d0a06283 	ldbu	r2,-32374(gp)
81112b24:	10803fcc 	andi	r2,r2,255
81112b28:	10800218 	cmpnei	r2,r2,8
81112b2c:	1000021e 	bne	r2,zero,81112b38 <vCheck+0x3c>
81112b30:	00c00104 	movi	r3,4
81112b34:	00000106 	br	81112b3c <vCheck+0x40>
81112b38:	0007883a 	mov	r3,zero
81112b3c:	d0a06f03 	ldbu	r2,-32324(gp)
81112b40:	10803fcc 	andi	r2,r2,255
81112b44:	10800218 	cmpnei	r2,r2,8
81112b48:	1000021e 	bne	r2,zero,81112b54 <vCheck+0x58>
81112b4c:	00800084 	movi	r2,2
81112b50:	00000106 	br	81112b58 <vCheck+0x5c>
81112b54:	0005883a 	mov	r2,zero
81112b58:	1884b03a 	or	r2,r3,r2
81112b5c:	1007883a 	mov	r3,r2
81112b60:	d0a06f43 	ldbu	r2,-32323(gp)
81112b64:	10803fcc 	andi	r2,r2,255
81112b68:	108001a0 	cmpeqi	r2,r2,6
81112b6c:	1884b03a 	or	r2,r3,r2
81112b70:	1007883a 	mov	r3,r2
81112b74:	e0bfff03 	ldbu	r2,-4(fp)
81112b78:	1884b03a 	or	r2,r3,r2
81112b7c:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81112b80:	e0bfff03 	ldbu	r2,-4(fp)
81112b84:	108001d8 	cmpnei	r2,r2,7
81112b88:	10003726 	beq	r2,zero,81112c68 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81112b8c:	d0a06e17 	ldw	r2,-32328(gp)
81112b90:	e0ffff44 	addi	r3,fp,-3
81112b94:	180d883a 	mov	r6,r3
81112b98:	000b883a 	mov	r5,zero
81112b9c:	1009883a 	mov	r4,r2
81112ba0:	11374600 	call	81137460 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81112ba4:	e0bfff43 	ldbu	r2,-3(fp)
81112ba8:	10803fcc 	andi	r2,r2,255
81112bac:	10000826 	beq	r2,zero,81112bd0 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81112bb0:	d0a05c17 	ldw	r2,-32400(gp)
81112bb4:	100f883a 	mov	r7,r2
81112bb8:	01800f04 	movi	r6,60
81112bbc:	01400044 	movi	r5,1
81112bc0:	01204574 	movhi	r4,33045
81112bc4:	2120fc04 	addi	r4,r4,-31760
81112bc8:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
        return;
81112bcc:	00002706 	br	81112c6c <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81112bd0:	e0bfff03 	ldbu	r2,-4(fp)
81112bd4:	1080004c 	andi	r2,r2,1
81112bd8:	10803fcc 	andi	r2,r2,255
81112bdc:	1000021e 	bne	r2,zero,81112be8 <vCheck+0xec>
        vCheckRetransmission128();
81112be0:	1112c800 	call	81112c80 <vCheckRetransmission128>
81112be4:	00000506 	br	81112bfc <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81112be8:	01800604 	movi	r6,24
81112bec:	000b883a 	mov	r5,zero
81112bf0:	012045b4 	movhi	r4,33046
81112bf4:	2121b604 	addi	r4,r4,-31016
81112bf8:	111c5900 	call	8111c590 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81112bfc:	e0bfff03 	ldbu	r2,-4(fp)
81112c00:	1080008c 	andi	r2,r2,2
81112c04:	10803fcc 	andi	r2,r2,255
81112c08:	1000021e 	bne	r2,zero,81112c14 <vCheck+0x118>
        vCheckRetransmission64();
81112c0c:	1112f040 	call	81112f04 <vCheckRetransmission64>
81112c10:	00000506 	br	81112c28 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81112c14:	01800804 	movi	r6,32
81112c18:	000b883a 	mov	r5,zero
81112c1c:	012045b4 	movhi	r4,33046
81112c20:	2121bc04 	addi	r4,r4,-30992
81112c24:	111c5900 	call	8111c590 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81112c28:	e0bfff03 	ldbu	r2,-4(fp)
81112c2c:	1080010c 	andi	r2,r2,4
81112c30:	10803fcc 	andi	r2,r2,255
81112c34:	1000021e 	bne	r2,zero,81112c40 <vCheck+0x144>
        vCheckRetransmission32();
81112c38:	11131900 	call	81113190 <vCheckRetransmission32>
81112c3c:	00000506 	br	81112c54 <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81112c40:	01800804 	movi	r6,32
81112c44:	000b883a 	mov	r5,zero
81112c48:	012045b4 	movhi	r4,33046
81112c4c:	2121c404 	addi	r4,r4,-30960
81112c50:	111c5900 	call	8111c590 <memset>


    OSMutexPost(xTxUARTMutex);
81112c54:	d0a06e17 	ldw	r2,-32328(gp)
81112c58:	1009883a 	mov	r4,r2
81112c5c:	1137a040 	call	81137a04 <OSMutexPost>

    return;
81112c60:	0001883a 	nop
81112c64:	00000106 	br	81112c6c <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81112c68:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81112c6c:	e037883a 	mov	sp,fp
81112c70:	dfc00117 	ldw	ra,4(sp)
81112c74:	df000017 	ldw	fp,0(sp)
81112c78:	dec00204 	addi	sp,sp,8
81112c7c:	f800283a 	ret

81112c80 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81112c80:	defffd04 	addi	sp,sp,-12
81112c84:	de00012e 	bgeu	sp,et,81112c8c <vCheckRetransmission128+0xc>
81112c88:	003b68fa 	trap	3
81112c8c:	dfc00215 	stw	ra,8(sp)
81112c90:	df000115 	stw	fp,4(sp)
81112c94:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81112c98:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81112c9c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81112ca0:	d0a06817 	ldw	r2,-32352(gp)
81112ca4:	e0ffff44 	addi	r3,fp,-3
81112ca8:	180b883a 	mov	r5,r3
81112cac:	1009883a 	mov	r4,r2
81112cb0:	1136de00 	call	81136de0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81112cb4:	e0bfff43 	ldbu	r2,-3(fp)
81112cb8:	10803fcc 	andi	r2,r2,255
81112cbc:	10008b1e 	bne	r2,zero,81112eec <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81112cc0:	e03fff05 	stb	zero,-4(fp)
81112cc4:	00008106 	br	81112ecc <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81112cc8:	e0ffff03 	ldbu	r3,-4(fp)
81112ccc:	00a045b4 	movhi	r2,33046
81112cd0:	10a1b604 	addi	r2,r2,-31016
81112cd4:	18c7883a 	add	r3,r3,r3
81112cd8:	18c7883a 	add	r3,r3,r3
81112cdc:	10c5883a 	add	r2,r2,r3
81112ce0:	10800017 	ldw	r2,0(r2)
81112ce4:	10800058 	cmpnei	r2,r2,1
81112ce8:	1000751e 	bne	r2,zero,81112ec0 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81112cec:	e0ffff03 	ldbu	r3,-4(fp)
81112cf0:	00a045b4 	movhi	r2,33046
81112cf4:	10a1d404 	addi	r2,r2,-30896
81112cf8:	18c02324 	muli	r3,r3,140
81112cfc:	10c5883a 	add	r2,r2,r3
81112d00:	10802004 	addi	r2,r2,128
81112d04:	10800017 	ldw	r2,0(r2)
81112d08:	10800058 	cmpnei	r2,r2,1
81112d0c:	1000211e 	bne	r2,zero,81112d94 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81112d10:	e0ffff03 	ldbu	r3,-4(fp)
81112d14:	00a045b4 	movhi	r2,33046
81112d18:	10a1d404 	addi	r2,r2,-30896
81112d1c:	19002324 	muli	r4,r3,140
81112d20:	1105883a 	add	r2,r2,r4
81112d24:	10802184 	addi	r2,r2,134
81112d28:	1080000b 	ldhu	r2,0(r2)
81112d2c:	10800044 	addi	r2,r2,1
81112d30:	100b883a 	mov	r5,r2
81112d34:	00a045b4 	movhi	r2,33046
81112d38:	10a1d404 	addi	r2,r2,-30896
81112d3c:	19002324 	muli	r4,r3,140
81112d40:	1105883a 	add	r2,r2,r4
81112d44:	10802184 	addi	r2,r2,134
81112d48:	1140000d 	sth	r5,0(r2)
81112d4c:	00a045b4 	movhi	r2,33046
81112d50:	10a1d404 	addi	r2,r2,-30896
81112d54:	18c02324 	muli	r3,r3,140
81112d58:	10c5883a 	add	r2,r2,r3
81112d5c:	10802184 	addi	r2,r2,134
81112d60:	1080000b 	ldhu	r2,0(r2)
81112d64:	10bfffcc 	andi	r2,r2,65535
81112d68:	10a0001c 	xori	r2,r2,32768
81112d6c:	10a00004 	addi	r2,r2,-32768
81112d70:	10800090 	cmplti	r2,r2,2
81112d74:	1000071e 	bne	r2,zero,81112d94 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81112d78:	e0ffff03 	ldbu	r3,-4(fp)
81112d7c:	00a045b4 	movhi	r2,33046
81112d80:	10a1d404 	addi	r2,r2,-30896
81112d84:	18c02324 	muli	r3,r3,140
81112d88:	10c5883a 	add	r2,r2,r3
81112d8c:	10802004 	addi	r2,r2,128
81112d90:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81112d94:	e0ffff03 	ldbu	r3,-4(fp)
81112d98:	00a045b4 	movhi	r2,33046
81112d9c:	10a1d404 	addi	r2,r2,-30896
81112da0:	18c02324 	muli	r3,r3,140
81112da4:	10c5883a 	add	r2,r2,r3
81112da8:	10802004 	addi	r2,r2,128
81112dac:	10800017 	ldw	r2,0(r2)
81112db0:	1000431e 	bne	r2,zero,81112ec0 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81112db4:	e0bfff03 	ldbu	r2,-4(fp)
81112db8:	10c02324 	muli	r3,r2,140
81112dbc:	00a045b4 	movhi	r2,33046
81112dc0:	10a1d404 	addi	r2,r2,-30896
81112dc4:	1885883a 	add	r2,r3,r2
81112dc8:	1009883a 	mov	r4,r2
81112dcc:	111c9dc0 	call	8111c9dc <puts>
                xBuffer128[ucIL].bSent = TRUE;
81112dd0:	e0ffff03 	ldbu	r3,-4(fp)
81112dd4:	00a045b4 	movhi	r2,33046
81112dd8:	10a1d404 	addi	r2,r2,-30896
81112ddc:	18c02324 	muli	r3,r3,140
81112de0:	10c5883a 	add	r2,r2,r3
81112de4:	10802004 	addi	r2,r2,128
81112de8:	00c00044 	movi	r3,1
81112dec:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81112df0:	e0ffff03 	ldbu	r3,-4(fp)
81112df4:	00a045b4 	movhi	r2,33046
81112df8:	10a1d404 	addi	r2,r2,-30896
81112dfc:	18c02324 	muli	r3,r3,140
81112e00:	10c5883a 	add	r2,r2,r3
81112e04:	10802184 	addi	r2,r2,134
81112e08:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81112e0c:	e0ffff03 	ldbu	r3,-4(fp)
81112e10:	00a045b4 	movhi	r2,33046
81112e14:	10a1d404 	addi	r2,r2,-30896
81112e18:	19002324 	muli	r4,r3,140
81112e1c:	1105883a 	add	r2,r2,r4
81112e20:	10802204 	addi	r2,r2,136
81112e24:	10800003 	ldbu	r2,0(r2)
81112e28:	10800044 	addi	r2,r2,1
81112e2c:	100b883a 	mov	r5,r2
81112e30:	00a045b4 	movhi	r2,33046
81112e34:	10a1d404 	addi	r2,r2,-30896
81112e38:	19002324 	muli	r4,r3,140
81112e3c:	1105883a 	add	r2,r2,r4
81112e40:	10802204 	addi	r2,r2,136
81112e44:	11400005 	stb	r5,0(r2)
81112e48:	00a045b4 	movhi	r2,33046
81112e4c:	10a1d404 	addi	r2,r2,-30896
81112e50:	18c02324 	muli	r3,r3,140
81112e54:	10c5883a 	add	r2,r2,r3
81112e58:	10802204 	addi	r2,r2,136
81112e5c:	10800003 	ldbu	r2,0(r2)
81112e60:	10803fcc 	andi	r2,r2,255
81112e64:	108000b0 	cmpltui	r2,r2,2
81112e68:	1000151e 	bne	r2,zero,81112ec0 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81112e6c:	e0ffff03 	ldbu	r3,-4(fp)
81112e70:	00a045b4 	movhi	r2,33046
81112e74:	10a1b604 	addi	r2,r2,-31016
81112e78:	18c7883a 	add	r3,r3,r3
81112e7c:	18c7883a 	add	r3,r3,r3
81112e80:	10c5883a 	add	r2,r2,r3
81112e84:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81112e88:	d0a06f43 	ldbu	r2,-32323(gp)
81112e8c:	10800044 	addi	r2,r2,1
81112e90:	d0a06f45 	stb	r2,-32323(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81112e94:	d0a05d17 	ldw	r2,-32396(gp)
81112e98:	1009883a 	mov	r4,r2
81112e9c:	11397f40 	call	811397f4 <OSSemPost>
81112ea0:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81112ea4:	e0bfff43 	ldbu	r2,-3(fp)
81112ea8:	10803fcc 	andi	r2,r2,255
81112eac:	10000426 	beq	r2,zero,81112ec0 <vCheckRetransmission128+0x240>
                        SemCount128--;
81112eb0:	d0a06f43 	ldbu	r2,-32323(gp)
81112eb4:	10bfffc4 	addi	r2,r2,-1
81112eb8:	d0a06f45 	stb	r2,-32323(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81112ebc:	1116ce80 	call	81116ce8 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81112ec0:	e0bfff03 	ldbu	r2,-4(fp)
81112ec4:	10800044 	addi	r2,r2,1
81112ec8:	e0bfff05 	stb	r2,-4(fp)
81112ecc:	e0bfff03 	ldbu	r2,-4(fp)
81112ed0:	108001b0 	cmpltui	r2,r2,6
81112ed4:	103f7c1e 	bne	r2,zero,81112cc8 <__reset+0xfb0f2cc8>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81112ed8:	d0a06817 	ldw	r2,-32352(gp)
81112edc:	1009883a 	mov	r4,r2
81112ee0:	1137a040 	call	81137a04 <OSMutexPost>

    return;
81112ee4:	0001883a 	nop
81112ee8:	00000106 	br	81112ef0 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81112eec:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81112ef0:	e037883a 	mov	sp,fp
81112ef4:	dfc00117 	ldw	ra,4(sp)
81112ef8:	df000017 	ldw	fp,0(sp)
81112efc:	dec00204 	addi	sp,sp,8
81112f00:	f800283a 	ret

81112f04 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81112f04:	defffd04 	addi	sp,sp,-12
81112f08:	de00012e 	bgeu	sp,et,81112f10 <vCheckRetransmission64+0xc>
81112f0c:	003b68fa 	trap	3
81112f10:	dfc00215 	stw	ra,8(sp)
81112f14:	df000115 	stw	fp,4(sp)
81112f18:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81112f1c:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81112f20:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81112f24:	d0a06b17 	ldw	r2,-32340(gp)
81112f28:	e0ffff44 	addi	r3,fp,-3
81112f2c:	180b883a 	mov	r5,r3
81112f30:	1009883a 	mov	r4,r2
81112f34:	1136de00 	call	81136de0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81112f38:	e0bfff43 	ldbu	r2,-3(fp)
81112f3c:	10803fcc 	andi	r2,r2,255
81112f40:	10008d1e 	bne	r2,zero,81113178 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81112f44:	e03fff05 	stb	zero,-4(fp)
81112f48:	00008306 	br	81113158 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81112f4c:	e0ffff03 	ldbu	r3,-4(fp)
81112f50:	00a045b4 	movhi	r2,33046
81112f54:	10a1b604 	addi	r2,r2,-31016
81112f58:	18c00184 	addi	r3,r3,6
81112f5c:	18c7883a 	add	r3,r3,r3
81112f60:	18c7883a 	add	r3,r3,r3
81112f64:	10c5883a 	add	r2,r2,r3
81112f68:	10800017 	ldw	r2,0(r2)
81112f6c:	10800058 	cmpnei	r2,r2,1
81112f70:	1000761e 	bne	r2,zero,8111314c <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81112f74:	e0ffff03 	ldbu	r3,-4(fp)
81112f78:	00a04574 	movhi	r2,33045
81112f7c:	10bd9504 	addi	r2,r2,-2476
81112f80:	18c01324 	muli	r3,r3,76
81112f84:	10c5883a 	add	r2,r2,r3
81112f88:	10801004 	addi	r2,r2,64
81112f8c:	10800017 	ldw	r2,0(r2)
81112f90:	10800058 	cmpnei	r2,r2,1
81112f94:	1000211e 	bne	r2,zero,8111301c <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81112f98:	e0ffff03 	ldbu	r3,-4(fp)
81112f9c:	00a04574 	movhi	r2,33045
81112fa0:	10bd9504 	addi	r2,r2,-2476
81112fa4:	19001324 	muli	r4,r3,76
81112fa8:	1105883a 	add	r2,r2,r4
81112fac:	10801184 	addi	r2,r2,70
81112fb0:	1080000b 	ldhu	r2,0(r2)
81112fb4:	10800044 	addi	r2,r2,1
81112fb8:	100b883a 	mov	r5,r2
81112fbc:	00a04574 	movhi	r2,33045
81112fc0:	10bd9504 	addi	r2,r2,-2476
81112fc4:	19001324 	muli	r4,r3,76
81112fc8:	1105883a 	add	r2,r2,r4
81112fcc:	10801184 	addi	r2,r2,70
81112fd0:	1140000d 	sth	r5,0(r2)
81112fd4:	00a04574 	movhi	r2,33045
81112fd8:	10bd9504 	addi	r2,r2,-2476
81112fdc:	18c01324 	muli	r3,r3,76
81112fe0:	10c5883a 	add	r2,r2,r3
81112fe4:	10801184 	addi	r2,r2,70
81112fe8:	1080000b 	ldhu	r2,0(r2)
81112fec:	10bfffcc 	andi	r2,r2,65535
81112ff0:	10a0001c 	xori	r2,r2,32768
81112ff4:	10a00004 	addi	r2,r2,-32768
81112ff8:	10800090 	cmplti	r2,r2,2
81112ffc:	1000071e 	bne	r2,zero,8111301c <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81113000:	e0ffff03 	ldbu	r3,-4(fp)
81113004:	00a04574 	movhi	r2,33045
81113008:	10bd9504 	addi	r2,r2,-2476
8111300c:	18c01324 	muli	r3,r3,76
81113010:	10c5883a 	add	r2,r2,r3
81113014:	10801004 	addi	r2,r2,64
81113018:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
8111301c:	e0ffff03 	ldbu	r3,-4(fp)
81113020:	00a04574 	movhi	r2,33045
81113024:	10bd9504 	addi	r2,r2,-2476
81113028:	18c01324 	muli	r3,r3,76
8111302c:	10c5883a 	add	r2,r2,r3
81113030:	10801004 	addi	r2,r2,64
81113034:	10800017 	ldw	r2,0(r2)
81113038:	1000441e 	bne	r2,zero,8111314c <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
8111303c:	e0bfff03 	ldbu	r2,-4(fp)
81113040:	10c01324 	muli	r3,r2,76
81113044:	00a04574 	movhi	r2,33045
81113048:	10bd9504 	addi	r2,r2,-2476
8111304c:	1885883a 	add	r2,r3,r2
81113050:	1009883a 	mov	r4,r2
81113054:	111c9dc0 	call	8111c9dc <puts>
                xBuffer64[ucIL].bSent = TRUE;
81113058:	e0ffff03 	ldbu	r3,-4(fp)
8111305c:	00a04574 	movhi	r2,33045
81113060:	10bd9504 	addi	r2,r2,-2476
81113064:	18c01324 	muli	r3,r3,76
81113068:	10c5883a 	add	r2,r2,r3
8111306c:	10801004 	addi	r2,r2,64
81113070:	00c00044 	movi	r3,1
81113074:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81113078:	e0ffff03 	ldbu	r3,-4(fp)
8111307c:	00a04574 	movhi	r2,33045
81113080:	10bd9504 	addi	r2,r2,-2476
81113084:	18c01324 	muli	r3,r3,76
81113088:	10c5883a 	add	r2,r2,r3
8111308c:	10801184 	addi	r2,r2,70
81113090:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81113094:	e0ffff03 	ldbu	r3,-4(fp)
81113098:	00a04574 	movhi	r2,33045
8111309c:	10bd9504 	addi	r2,r2,-2476
811130a0:	19001324 	muli	r4,r3,76
811130a4:	1105883a 	add	r2,r2,r4
811130a8:	10801204 	addi	r2,r2,72
811130ac:	10800003 	ldbu	r2,0(r2)
811130b0:	10800044 	addi	r2,r2,1
811130b4:	100b883a 	mov	r5,r2
811130b8:	00a04574 	movhi	r2,33045
811130bc:	10bd9504 	addi	r2,r2,-2476
811130c0:	19001324 	muli	r4,r3,76
811130c4:	1105883a 	add	r2,r2,r4
811130c8:	10801204 	addi	r2,r2,72
811130cc:	11400005 	stb	r5,0(r2)
811130d0:	00a04574 	movhi	r2,33045
811130d4:	10bd9504 	addi	r2,r2,-2476
811130d8:	18c01324 	muli	r3,r3,76
811130dc:	10c5883a 	add	r2,r2,r3
811130e0:	10801204 	addi	r2,r2,72
811130e4:	10800003 	ldbu	r2,0(r2)
811130e8:	10803fcc 	andi	r2,r2,255
811130ec:	108000b0 	cmpltui	r2,r2,2
811130f0:	1000161e 	bne	r2,zero,8111314c <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
811130f4:	e0ffff03 	ldbu	r3,-4(fp)
811130f8:	00a045b4 	movhi	r2,33046
811130fc:	10a1b604 	addi	r2,r2,-31016
81113100:	18c00184 	addi	r3,r3,6
81113104:	18c7883a 	add	r3,r3,r3
81113108:	18c7883a 	add	r3,r3,r3
8111310c:	10c5883a 	add	r2,r2,r3
81113110:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81113114:	d0a06f03 	ldbu	r2,-32324(gp)
81113118:	10800044 	addi	r2,r2,1
8111311c:	d0a06f05 	stb	r2,-32324(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81113120:	d0a05817 	ldw	r2,-32416(gp)
81113124:	1009883a 	mov	r4,r2
81113128:	11397f40 	call	811397f4 <OSSemPost>
8111312c:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81113130:	e0bfff43 	ldbu	r2,-3(fp)
81113134:	10803fcc 	andi	r2,r2,255
81113138:	10000426 	beq	r2,zero,8111314c <vCheckRetransmission64+0x248>
                        SemCount64--;
8111313c:	d0a06f03 	ldbu	r2,-32324(gp)
81113140:	10bfffc4 	addi	r2,r2,-1
81113144:	d0a06f05 	stb	r2,-32324(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81113148:	1116c800 	call	81116c80 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8111314c:	e0bfff03 	ldbu	r2,-4(fp)
81113150:	10800044 	addi	r2,r2,1
81113154:	e0bfff05 	stb	r2,-4(fp)
81113158:	e0bfff03 	ldbu	r2,-4(fp)
8111315c:	10800230 	cmpltui	r2,r2,8
81113160:	103f7a1e 	bne	r2,zero,81112f4c <__reset+0xfb0f2f4c>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
81113164:	d0a06b17 	ldw	r2,-32340(gp)
81113168:	1009883a 	mov	r4,r2
8111316c:	1137a040 	call	81137a04 <OSMutexPost>

    return;
81113170:	0001883a 	nop
81113174:	00000106 	br	8111317c <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81113178:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
8111317c:	e037883a 	mov	sp,fp
81113180:	dfc00117 	ldw	ra,4(sp)
81113184:	df000017 	ldw	fp,0(sp)
81113188:	dec00204 	addi	sp,sp,8
8111318c:	f800283a 	ret

81113190 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81113190:	defffd04 	addi	sp,sp,-12
81113194:	de00012e 	bgeu	sp,et,8111319c <vCheckRetransmission32+0xc>
81113198:	003b68fa 	trap	3
8111319c:	dfc00215 	stw	ra,8(sp)
811131a0:	df000115 	stw	fp,4(sp)
811131a4:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811131a8:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
811131ac:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
811131b0:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811131b4:	d0a06617 	ldw	r2,-32360(gp)
811131b8:	e0ffff84 	addi	r3,fp,-2
811131bc:	180b883a 	mov	r5,r3
811131c0:	1009883a 	mov	r4,r2
811131c4:	1136de00 	call	81136de0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811131c8:	e0bfff83 	ldbu	r2,-2(fp)
811131cc:	10803fcc 	andi	r2,r2,255
811131d0:	10009b1e 	bne	r2,zero,81113440 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811131d4:	e03fff05 	stb	zero,-4(fp)
811131d8:	00009106 	br	81113420 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
811131dc:	e0ffff03 	ldbu	r3,-4(fp)
811131e0:	00a045b4 	movhi	r2,33046
811131e4:	10a1b604 	addi	r2,r2,-31016
811131e8:	18c00384 	addi	r3,r3,14
811131ec:	18c7883a 	add	r3,r3,r3
811131f0:	18c7883a 	add	r3,r3,r3
811131f4:	10c5883a 	add	r2,r2,r3
811131f8:	10800017 	ldw	r2,0(r2)
811131fc:	10800058 	cmpnei	r2,r2,1
81113200:	1000841e 	bne	r2,zero,81113414 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
81113204:	e0ffff03 	ldbu	r3,-4(fp)
81113208:	00a04574 	movhi	r2,33045
8111320c:	108f4204 	addi	r2,r2,15624
81113210:	18c00b24 	muli	r3,r3,44
81113214:	10c5883a 	add	r2,r2,r3
81113218:	10800804 	addi	r2,r2,32
8111321c:	10800017 	ldw	r2,0(r2)
81113220:	10800058 	cmpnei	r2,r2,1
81113224:	1000211e 	bne	r2,zero,811132ac <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81113228:	e0ffff03 	ldbu	r3,-4(fp)
8111322c:	00a04574 	movhi	r2,33045
81113230:	108f4204 	addi	r2,r2,15624
81113234:	19000b24 	muli	r4,r3,44
81113238:	1105883a 	add	r2,r2,r4
8111323c:	10800984 	addi	r2,r2,38
81113240:	1080000b 	ldhu	r2,0(r2)
81113244:	10800044 	addi	r2,r2,1
81113248:	100b883a 	mov	r5,r2
8111324c:	00a04574 	movhi	r2,33045
81113250:	108f4204 	addi	r2,r2,15624
81113254:	19000b24 	muli	r4,r3,44
81113258:	1105883a 	add	r2,r2,r4
8111325c:	10800984 	addi	r2,r2,38
81113260:	1140000d 	sth	r5,0(r2)
81113264:	00a04574 	movhi	r2,33045
81113268:	108f4204 	addi	r2,r2,15624
8111326c:	18c00b24 	muli	r3,r3,44
81113270:	10c5883a 	add	r2,r2,r3
81113274:	10800984 	addi	r2,r2,38
81113278:	1080000b 	ldhu	r2,0(r2)
8111327c:	10bfffcc 	andi	r2,r2,65535
81113280:	10a0001c 	xori	r2,r2,32768
81113284:	10a00004 	addi	r2,r2,-32768
81113288:	10800090 	cmplti	r2,r2,2
8111328c:	1000071e 	bne	r2,zero,811132ac <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81113290:	e0ffff03 	ldbu	r3,-4(fp)
81113294:	00a04574 	movhi	r2,33045
81113298:	108f4204 	addi	r2,r2,15624
8111329c:	18c00b24 	muli	r3,r3,44
811132a0:	10c5883a 	add	r2,r2,r3
811132a4:	10800804 	addi	r2,r2,32
811132a8:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
811132ac:	e0ffff03 	ldbu	r3,-4(fp)
811132b0:	00a04574 	movhi	r2,33045
811132b4:	108f4204 	addi	r2,r2,15624
811132b8:	18c00b24 	muli	r3,r3,44
811132bc:	10c5883a 	add	r2,r2,r3
811132c0:	10800804 	addi	r2,r2,32
811132c4:	10800017 	ldw	r2,0(r2)
811132c8:	1000521e 	bne	r2,zero,81113414 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
811132cc:	e0bfff03 	ldbu	r2,-4(fp)
811132d0:	10c00b24 	muli	r3,r2,44
811132d4:	00a04574 	movhi	r2,33045
811132d8:	108f4204 	addi	r2,r2,15624
811132dc:	1885883a 	add	r2,r3,r2
811132e0:	1009883a 	mov	r4,r2
811132e4:	111c9dc0 	call	8111c9dc <puts>
                xBuffer32[ucIL].bSent = TRUE;
811132e8:	e0ffff03 	ldbu	r3,-4(fp)
811132ec:	00a04574 	movhi	r2,33045
811132f0:	108f4204 	addi	r2,r2,15624
811132f4:	18c00b24 	muli	r3,r3,44
811132f8:	10c5883a 	add	r2,r2,r3
811132fc:	10800804 	addi	r2,r2,32
81113300:	00c00044 	movi	r3,1
81113304:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81113308:	e0ffff03 	ldbu	r3,-4(fp)
8111330c:	00a04574 	movhi	r2,33045
81113310:	108f4204 	addi	r2,r2,15624
81113314:	18c00b24 	muli	r3,r3,44
81113318:	10c5883a 	add	r2,r2,r3
8111331c:	10800984 	addi	r2,r2,38
81113320:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81113324:	e0ffff03 	ldbu	r3,-4(fp)
81113328:	00a04574 	movhi	r2,33045
8111332c:	108f4204 	addi	r2,r2,15624
81113330:	18c00b24 	muli	r3,r3,44
81113334:	10c5883a 	add	r2,r2,r3
81113338:	10800904 	addi	r2,r2,36
8111333c:	1080000b 	ldhu	r2,0(r2)
81113340:	10bfffcc 	andi	r2,r2,65535
81113344:	10800058 	cmpnei	r2,r2,1
81113348:	1000021e 	bne	r2,zero,81113354 <vCheckRetransmission32+0x1c4>
8111334c:	00bffe84 	movi	r2,-6
81113350:	00000106 	br	81113358 <vCheckRetransmission32+0x1c8>
81113354:	00800044 	movi	r2,1
81113358:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
8111335c:	e0ffff03 	ldbu	r3,-4(fp)
81113360:	00a04574 	movhi	r2,33045
81113364:	108f4204 	addi	r2,r2,15624
81113368:	19000b24 	muli	r4,r3,44
8111336c:	1105883a 	add	r2,r2,r4
81113370:	10800a04 	addi	r2,r2,40
81113374:	10800003 	ldbu	r2,0(r2)
81113378:	10800044 	addi	r2,r2,1
8111337c:	100b883a 	mov	r5,r2
81113380:	00a04574 	movhi	r2,33045
81113384:	108f4204 	addi	r2,r2,15624
81113388:	19000b24 	muli	r4,r3,44
8111338c:	1105883a 	add	r2,r2,r4
81113390:	10800a04 	addi	r2,r2,40
81113394:	11400005 	stb	r5,0(r2)
81113398:	00a04574 	movhi	r2,33045
8111339c:	108f4204 	addi	r2,r2,15624
811133a0:	18c00b24 	muli	r3,r3,44
811133a4:	10c5883a 	add	r2,r2,r3
811133a8:	10800a04 	addi	r2,r2,40
811133ac:	10800003 	ldbu	r2,0(r2)
811133b0:	10803fcc 	andi	r2,r2,255
811133b4:	e0ffff43 	ldbu	r3,-3(fp)
811133b8:	1880162e 	bgeu	r3,r2,81113414 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
811133bc:	e0ffff03 	ldbu	r3,-4(fp)
811133c0:	00a045b4 	movhi	r2,33046
811133c4:	10a1b604 	addi	r2,r2,-31016
811133c8:	18c00384 	addi	r3,r3,14
811133cc:	18c7883a 	add	r3,r3,r3
811133d0:	18c7883a 	add	r3,r3,r3
811133d4:	10c5883a 	add	r2,r2,r3
811133d8:	10000015 	stw	zero,0(r2)
                    SemCount32++;
811133dc:	d0a06283 	ldbu	r2,-32374(gp)
811133e0:	10800044 	addi	r2,r2,1
811133e4:	d0a06285 	stb	r2,-32374(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
811133e8:	d0a06917 	ldw	r2,-32348(gp)
811133ec:	1009883a 	mov	r4,r2
811133f0:	11397f40 	call	811397f4 <OSSemPost>
811133f4:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811133f8:	e0bfff83 	ldbu	r2,-2(fp)
811133fc:	10803fcc 	andi	r2,r2,255
81113400:	10000426 	beq	r2,zero,81113414 <vCheckRetransmission32+0x284>
                        SemCount32--;
81113404:	d0a06283 	ldbu	r2,-32374(gp)
81113408:	10bfffc4 	addi	r2,r2,-1
8111340c:	d0a06285 	stb	r2,-32374(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81113410:	1116c180 	call	81116c18 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81113414:	e0bfff03 	ldbu	r2,-4(fp)
81113418:	10800044 	addi	r2,r2,1
8111341c:	e0bfff05 	stb	r2,-4(fp)
81113420:	e0bfff03 	ldbu	r2,-4(fp)
81113424:	10800230 	cmpltui	r2,r2,8
81113428:	103f6c1e 	bne	r2,zero,811131dc <__reset+0xfb0f31dc>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
8111342c:	d0a06617 	ldw	r2,-32360(gp)
81113430:	1009883a 	mov	r4,r2
81113434:	1137a040 	call	81137a04 <OSMutexPost>

    return;
81113438:	0001883a 	nop
8111343c:	00000106 	br	81113444 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81113440:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81113444:	e037883a 	mov	sp,fp
81113448:	dfc00117 	ldw	ra,4(sp)
8111344c:	df000017 	ldw	fp,0(sp)
81113450:	dec00204 	addi	sp,sp,8
81113454:	f800283a 	ret

81113458 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81113458:	defff904 	addi	sp,sp,-28
8111345c:	de00012e 	bgeu	sp,et,81113464 <bResourcesInitRTOS+0xc>
81113460:	003b68fa 	trap	3
81113464:	dfc00615 	stw	ra,24(sp)
81113468:	df000515 	stw	fp,20(sp)
8111346c:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81113470:	00800044 	movi	r2,1
81113474:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81113478:	0009883a 	mov	r4,zero
8111347c:	11391440 	call	81139144 <OSSemCreate>
81113480:	d0a05a15 	stw	r2,-32408(gp)
	if (!xSemCommInit) {
81113484:	d0a05a17 	ldw	r2,-32408(gp)
81113488:	1000021e 	bne	r2,zero,81113494 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
8111348c:	11166b00 	call	811166b0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113490:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81113494:	e0bfff04 	addi	r2,fp,-4
81113498:	100b883a 	mov	r5,r2
8111349c:	01000444 	movi	r4,17
811134a0:	1136f8c0 	call	81136f8c <OSMutexCreate>
811134a4:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
811134a8:	e0bfff03 	ldbu	r2,-4(fp)
811134ac:	10803fcc 	andi	r2,r2,255
811134b0:	10000526 	beq	r2,zero,811134c8 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
811134b4:	e0bfff03 	ldbu	r2,-4(fp)
811134b8:	10803fcc 	andi	r2,r2,255
811134bc:	1009883a 	mov	r4,r2
811134c0:	11166040 	call	81116604 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811134c4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
811134c8:	e0bfff04 	addi	r2,fp,-4
811134cc:	100b883a 	mov	r5,r2
811134d0:	01000504 	movi	r4,20
811134d4:	1136f8c0 	call	81136f8c <OSMutexCreate>
811134d8:	d0a06815 	stw	r2,-32352(gp)
	if ( err != OS_ERR_NONE ) {
811134dc:	e0bfff03 	ldbu	r2,-4(fp)
811134e0:	10803fcc 	andi	r2,r2,255
811134e4:	10000526 	beq	r2,zero,811134fc <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
811134e8:	e0bfff03 	ldbu	r2,-4(fp)
811134ec:	10803fcc 	andi	r2,r2,255
811134f0:	1009883a 	mov	r4,r2
811134f4:	11166040 	call	81116604 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811134f8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
811134fc:	e0bfff04 	addi	r2,fp,-4
81113500:	100b883a 	mov	r5,r2
81113504:	01000544 	movi	r4,21
81113508:	1136f8c0 	call	81136f8c <OSMutexCreate>
8111350c:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81113510:	e0bfff03 	ldbu	r2,-4(fp)
81113514:	10803fcc 	andi	r2,r2,255
81113518:	10000526 	beq	r2,zero,81113530 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
8111351c:	e0bfff03 	ldbu	r2,-4(fp)
81113520:	10803fcc 	andi	r2,r2,255
81113524:	1009883a 	mov	r4,r2
81113528:	11166040 	call	81116604 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111352c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81113530:	e0bfff04 	addi	r2,fp,-4
81113534:	100b883a 	mov	r5,r2
81113538:	01000584 	movi	r4,22
8111353c:	1136f8c0 	call	81136f8c <OSMutexCreate>
81113540:	d0a06615 	stw	r2,-32360(gp)
	if ( err != OS_ERR_NONE ) {
81113544:	e0bfff03 	ldbu	r2,-4(fp)
81113548:	10803fcc 	andi	r2,r2,255
8111354c:	10000526 	beq	r2,zero,81113564 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81113550:	e0bfff03 	ldbu	r2,-4(fp)
81113554:	10803fcc 	andi	r2,r2,255
81113558:	1009883a 	mov	r4,r2
8111355c:	11166040 	call	81116604 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113560:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81113564:	00800184 	movi	r2,6
81113568:	d0a06f45 	stb	r2,-32323(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
8111356c:	01000184 	movi	r4,6
81113570:	11391440 	call	81139144 <OSSemCreate>
81113574:	d0a05d15 	stw	r2,-32396(gp)
	if (!xSemCountBuffer128) {
81113578:	d0a05d17 	ldw	r2,-32396(gp)
8111357c:	1000031e 	bne	r2,zero,8111358c <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81113580:	d0206f45 	stb	zero,-32323(gp)
		vFailCreateSemaphoreResources();
81113584:	11166b00 	call	811166b0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113588:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
8111358c:	00800204 	movi	r2,8
81113590:	d0a06f05 	stb	r2,-32324(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81113594:	01000204 	movi	r4,8
81113598:	11391440 	call	81139144 <OSSemCreate>
8111359c:	d0a05815 	stw	r2,-32416(gp)
	if (!xSemCountBuffer64) {
811135a0:	d0a05817 	ldw	r2,-32416(gp)
811135a4:	1000031e 	bne	r2,zero,811135b4 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
811135a8:	d0206f05 	stb	zero,-32324(gp)
		vFailCreateSemaphoreResources();
811135ac:	11166b00 	call	811166b0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811135b0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
811135b4:	00800204 	movi	r2,8
811135b8:	d0a06285 	stb	r2,-32374(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
811135bc:	01000204 	movi	r4,8
811135c0:	11391440 	call	81139144 <OSSemCreate>
811135c4:	d0a06915 	stw	r2,-32348(gp)
	if (!xSemCountBuffer32) {
811135c8:	d0a06917 	ldw	r2,-32348(gp)
811135cc:	1000031e 	bne	r2,zero,811135dc <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
811135d0:	d0206285 	stb	zero,-32374(gp)
		vFailCreateSemaphoreResources();
811135d4:	11166b00 	call	811166b0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811135d8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
811135dc:	e0bfff04 	addi	r2,fp,-4
811135e0:	100b883a 	mov	r5,r2
811135e4:	010004c4 	movi	r4,19
811135e8:	1136f8c0 	call	81136f8c <OSMutexCreate>
811135ec:	d0a05f15 	stw	r2,-32388(gp)
	if ( err != OS_ERR_NONE ) {
811135f0:	e0bfff03 	ldbu	r2,-4(fp)
811135f4:	10803fcc 	andi	r2,r2,255
811135f8:	10000526 	beq	r2,zero,81113610 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
811135fc:	e0bfff03 	ldbu	r2,-4(fp)
81113600:	10803fcc 	andi	r2,r2,255
81113604:	1009883a 	mov	r4,r2
81113608:	11166040 	call	81116604 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111360c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81113610:	e0bfff04 	addi	r2,fp,-4
81113614:	100b883a 	mov	r5,r2
81113618:	010005c4 	movi	r4,23
8111361c:	1136f8c0 	call	81136f8c <OSMutexCreate>
81113620:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
81113624:	e0bfff03 	ldbu	r2,-4(fp)
81113628:	10803fcc 	andi	r2,r2,255
8111362c:	10000526 	beq	r2,zero,81113644 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81113630:	e0bfff03 	ldbu	r2,-4(fp)
81113634:	10803fcc 	andi	r2,r2,255
81113638:	1009883a 	mov	r4,r2
8111363c:	11166040 	call	81116604 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113640:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81113644:	0009883a 	mov	r4,zero
81113648:	11391440 	call	81139144 <OSSemCreate>
8111364c:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCountReceivedACK) {
81113650:	d0a06017 	ldw	r2,-32384(gp)
81113654:	1000021e 	bne	r2,zero,81113660 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81113658:	11166b00 	call	811166b0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8111365c:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81113660:	0009883a 	mov	r4,zero
81113664:	11391440 	call	81139144 <OSSemCreate>
81113668:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountPreParsed) {
8111366c:	d0a05e17 	ldw	r2,-32392(gp)
81113670:	1000021e 	bne	r2,zero,8111367c <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81113674:	11166b00 	call	811166b0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113678:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
8111367c:	0009883a 	mov	r4,zero
81113680:	11391440 	call	81139144 <OSSemCreate>
81113684:	d0a05b15 	stw	r2,-32404(gp)
	if (!xSemCountSenderACK) {
81113688:	d0a05b17 	ldw	r2,-32404(gp)
8111368c:	1000021e 	bne	r2,zero,81113698 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81113690:	11166b00 	call	811166b0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113694:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81113698:	e0bfff04 	addi	r2,fp,-4
8111369c:	100b883a 	mov	r5,r2
811136a0:	01000484 	movi	r4,18
811136a4:	1136f8c0 	call	81136f8c <OSMutexCreate>
811136a8:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
811136ac:	e0bfff03 	ldbu	r2,-4(fp)
811136b0:	10803fcc 	andi	r2,r2,255
811136b4:	10000526 	beq	r2,zero,811136cc <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
811136b8:	e0bfff03 	ldbu	r2,-4(fp)
811136bc:	10803fcc 	andi	r2,r2,255
811136c0:	1009883a 	mov	r4,r2
811136c4:	11166040 	call	81116604 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811136c8:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
811136cc:	0009883a 	mov	r4,zero
811136d0:	11391440 	call	81139144 <OSSemCreate>
811136d4:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemTimeoutChecker) {
811136d8:	d0a06117 	ldw	r2,-32380(gp)
811136dc:	1000021e 	bne	r2,zero,811136e8 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
811136e0:	11166b00 	call	811166b0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811136e4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
811136e8:	e0bfff04 	addi	r2,fp,-4
811136ec:	d8800215 	stw	r2,8(sp)
811136f0:	00a04574 	movhi	r2,33045
811136f4:	10a10c04 	addi	r2,r2,-31696
811136f8:	d8800115 	stw	r2,4(sp)
811136fc:	d8000015 	stw	zero,0(sp)
81113700:	01e04474 	movhi	r7,33041
81113704:	39d4a204 	addi	r7,r7,21128
81113708:	01800084 	movi	r6,2
8111370c:	01400104 	movi	r5,4
81113710:	01000284 	movi	r4,10
81113714:	113b65c0 	call	8113b65c <OSTmrCreate>
81113718:	d0a06715 	stw	r2,-32356(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
8111371c:	e0bfff03 	ldbu	r2,-4(fp)
81113720:	10803fcc 	andi	r2,r2,255
81113724:	10000226 	beq	r2,zero,81113730 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81113728:	11173140 	call	81117314 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
8111372c:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81113730:	01400304 	movi	r5,12
81113734:	01204574 	movhi	r4,33045
81113738:	21028904 	addi	r4,r4,2596
8111373c:	11380780 	call	81138078 <OSQCreate>
81113740:	d0a05715 	stw	r2,-32420(gp)
	if ( xNfeeSchedule == NULL ) {
81113744:	d0a05717 	ldw	r2,-32420(gp)
81113748:	1000021e 	bne	r2,zero,81113754 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
8111374c:	11178f80 	call	811178f8 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81113750:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81113754:	01400104 	movi	r5,4
81113758:	012045b4 	movhi	r4,33046
8111375c:	21017004 	addi	r4,r4,1472
81113760:	11380780 	call	81138078 <OSQCreate>
81113764:	d0a06415 	stw	r2,-32368(gp)
	if ( xFeeQ[0] == NULL ) {
81113768:	d0a06417 	ldw	r2,-32368(gp)
8111376c:	1000031e 	bne	r2,zero,8111377c <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81113770:	0009883a 	mov	r4,zero
81113774:	11179600 	call	81117960 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81113778:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL1[0], N_MSG_SYNC);
8111377c:	01400104 	movi	r5,4
81113780:	012045b4 	movhi	r4,33046
81113784:	21017404 	addi	r4,r4,1488
81113788:	11380780 	call	81138078 <OSQCreate>
8111378c:	d0a05615 	stw	r2,-32424(gp)
	if ( xFeeQ[0] == NULL ) {
81113790:	d0a06417 	ldw	r2,-32368(gp)
81113794:	1000031e 	bne	r2,zero,811137a4 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81113798:	0009883a 	mov	r4,zero
8111379c:	11179d00 	call	811179d0 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
811137a0:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
811137a4:	01400204 	movi	r5,8
811137a8:	012045b4 	movhi	r4,33046
811137ac:	2121cc04 	addi	r4,r4,-30928
811137b0:	11380780 	call	81138078 <OSQCreate>
811137b4:	d0a06315 	stw	r2,-32372(gp)
	if ( xFeeQ[5] == NULL ) {
811137b8:	d0a06917 	ldw	r2,-32348(gp)
811137bc:	1000031e 	bne	r2,zero,811137cc <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
811137c0:	01000144 	movi	r4,5
811137c4:	11179600 	call	81117960 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
811137c8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
811137cc:	e0bfff04 	addi	r2,fp,-4
811137d0:	100b883a 	mov	r5,r2
811137d4:	01000144 	movi	r4,5
811137d8:	1136f8c0 	call	81136f8c <OSMutexCreate>
811137dc:	d0a06d15 	stw	r2,-32332(gp)
	if ( err != OS_ERR_NONE ) {
811137e0:	e0bfff03 	ldbu	r2,-4(fp)
811137e4:	10803fcc 	andi	r2,r2,255
811137e8:	10000526 	beq	r2,zero,81113800 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
811137ec:	e0bfff03 	ldbu	r2,-4(fp)
811137f0:	10803fcc 	andi	r2,r2,255
811137f4:	1009883a 	mov	r4,r2
811137f8:	1117de80 	call	81117de8 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
811137fc:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81113800:	01400404 	movi	r5,16
81113804:	012045b4 	movhi	r4,33046
81113808:	2122a604 	addi	r4,r4,-30056
8111380c:	11380780 	call	81138078 <OSQCreate>
81113810:	d0a06a15 	stw	r2,-32344(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81113814:	d0a06a17 	ldw	r2,-32344(gp)
81113818:	1000021e 	bne	r2,zero,81113824 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
8111381c:	1117f480 	call	81117f48 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81113820:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81113824:	01400404 	movi	r5,16
81113828:	01204574 	movhi	r4,33045
8111382c:	21159a04 	addi	r4,r4,22120
81113830:	11380780 	call	81138078 <OSQCreate>
81113834:	d0a05915 	stw	r2,-32412(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81113838:	d0a06a17 	ldw	r2,-32344(gp)
8111383c:	1000021e 	bne	r2,zero,81113848 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81113840:	1117fb00 	call	81117fb0 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81113844:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81113848:	e0bfff04 	addi	r2,fp,-4
8111384c:	100b883a 	mov	r5,r2
81113850:	01000484 	movi	r4,18
81113854:	1136f8c0 	call	81136f8c <OSMutexCreate>
81113858:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
8111385c:	e0bfff03 	ldbu	r2,-4(fp)
81113860:	10803fcc 	andi	r2,r2,255
81113864:	10000526 	beq	r2,zero,8111387c <bResourcesInitRTOS+0x424>
		vFailCreateMutexSResources(err);
81113868:	e0bfff03 	ldbu	r2,-4(fp)
8111386c:	10803fcc 	andi	r2,r2,255
81113870:	1009883a 	mov	r4,r2
81113874:	11166040 	call	81116604 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113878:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
8111387c:	e0bfff04 	addi	r2,fp,-4
81113880:	100b883a 	mov	r5,r2
81113884:	010000c4 	movi	r4,3
81113888:	1136f8c0 	call	81136f8c <OSMutexCreate>
8111388c:	1007883a 	mov	r3,r2
81113890:	00a045b4 	movhi	r2,33046
81113894:	10b4c804 	addi	r2,r2,-11488
81113898:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
8111389c:	e0bfff03 	ldbu	r2,-4(fp)
811138a0:	10803fcc 	andi	r2,r2,255
811138a4:	10000226 	beq	r2,zero,811138b0 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
811138a8:	11166640 	call	81116664 <vFailCreateMutexDMA>
		bSuccess = FALSE;
811138ac:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
811138b0:	e0bfff04 	addi	r2,fp,-4
811138b4:	100b883a 	mov	r5,r2
811138b8:	01000104 	movi	r4,4
811138bc:	1136f8c0 	call	81136f8c <OSMutexCreate>
811138c0:	1007883a 	mov	r3,r2
811138c4:	00a045b4 	movhi	r2,33046
811138c8:	10b4c804 	addi	r2,r2,-11488
811138cc:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
811138d0:	e0bfff03 	ldbu	r2,-4(fp)
811138d4:	10803fcc 	andi	r2,r2,255
811138d8:	10000226 	beq	r2,zero,811138e4 <bResourcesInitRTOS+0x48c>
		vFailCreateMutexDMA();
811138dc:	11166640 	call	81116664 <vFailCreateMutexDMA>
		bSuccess = FALSE;
811138e0:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
811138e4:	e0bffe17 	ldw	r2,-8(fp)
}
811138e8:	e037883a 	mov	sp,fp
811138ec:	dfc00117 	ldw	ra,4(sp)
811138f0:	df000017 	ldw	fp,0(sp)
811138f4:	dec00204 	addi	sp,sp,8
811138f8:	f800283a 	ret

811138fc <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
811138fc:	defffd04 	addi	sp,sp,-12
81113900:	de00012e 	bgeu	sp,et,81113908 <vVariablesInitialization+0xc>
81113904:	003b68fa 	trap	3
81113908:	dfc00215 	stw	ra,8(sp)
8111390c:	df000115 	stw	fp,4(sp)
81113910:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
81113914:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
81113918:	00800084 	movi	r2,2
8111391c:	d0a0620d 	sth	r2,-32376(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81113920:	01800604 	movi	r6,24
81113924:	000b883a 	mov	r5,zero
81113928:	012045b4 	movhi	r4,33046
8111392c:	2121b604 	addi	r4,r4,-31016
81113930:	111c5900 	call	8111c590 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
81113934:	01800804 	movi	r6,32
81113938:	000b883a 	mov	r5,zero
8111393c:	012045b4 	movhi	r4,33046
81113940:	2121bc04 	addi	r4,r4,-30992
81113944:	111c5900 	call	8111c590 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81113948:	01800804 	movi	r6,32
8111394c:	000b883a 	mov	r5,zero
81113950:	012045b4 	movhi	r4,33046
81113954:	2121c404 	addi	r4,r4,-30960
81113958:	111c5900 	call	8111c590 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111395c:	e03fff05 	stb	zero,-4(fp)
81113960:	00002806 	br	81113a04 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81113964:	e0bfff03 	ldbu	r2,-4(fp)
81113968:	10c02324 	muli	r3,r2,140
8111396c:	00a045b4 	movhi	r2,33046
81113970:	10a1d404 	addi	r2,r2,-30896
81113974:	1885883a 	add	r2,r3,r2
81113978:	01802004 	movi	r6,128
8111397c:	000b883a 	mov	r5,zero
81113980:	1009883a 	mov	r4,r2
81113984:	111c5900 	call	8111c590 <memset>
		xBuffer128[ucIL].bSent = FALSE;
81113988:	e0ffff03 	ldbu	r3,-4(fp)
8111398c:	00a045b4 	movhi	r2,33046
81113990:	10a1d404 	addi	r2,r2,-30896
81113994:	18c02324 	muli	r3,r3,140
81113998:	10c5883a 	add	r2,r2,r3
8111399c:	10802004 	addi	r2,r2,128
811139a0:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
811139a4:	e0ffff03 	ldbu	r3,-4(fp)
811139a8:	00a045b4 	movhi	r2,33046
811139ac:	10a1d404 	addi	r2,r2,-30896
811139b0:	18c02324 	muli	r3,r3,140
811139b4:	10c5883a 	add	r2,r2,r3
811139b8:	10802104 	addi	r2,r2,132
811139bc:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
811139c0:	e0ffff03 	ldbu	r3,-4(fp)
811139c4:	00a045b4 	movhi	r2,33046
811139c8:	10a1d404 	addi	r2,r2,-30896
811139cc:	18c02324 	muli	r3,r3,140
811139d0:	10c5883a 	add	r2,r2,r3
811139d4:	10802184 	addi	r2,r2,134
811139d8:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
811139dc:	e0ffff03 	ldbu	r3,-4(fp)
811139e0:	00a045b4 	movhi	r2,33046
811139e4:	10a1d404 	addi	r2,r2,-30896
811139e8:	18c02324 	muli	r3,r3,140
811139ec:	10c5883a 	add	r2,r2,r3
811139f0:	10802204 	addi	r2,r2,136
811139f4:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
811139f8:	e0bfff03 	ldbu	r2,-4(fp)
811139fc:	10800044 	addi	r2,r2,1
81113a00:	e0bfff05 	stb	r2,-4(fp)
81113a04:	e0bfff03 	ldbu	r2,-4(fp)
81113a08:	108001b0 	cmpltui	r2,r2,6
81113a0c:	103fd51e 	bne	r2,zero,81113964 <__reset+0xfb0f3964>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81113a10:	e03fff05 	stb	zero,-4(fp)
81113a14:	00002806 	br	81113ab8 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
81113a18:	e0bfff03 	ldbu	r2,-4(fp)
81113a1c:	10c01324 	muli	r3,r2,76
81113a20:	00a04574 	movhi	r2,33045
81113a24:	10bd9504 	addi	r2,r2,-2476
81113a28:	1885883a 	add	r2,r3,r2
81113a2c:	01801004 	movi	r6,64
81113a30:	000b883a 	mov	r5,zero
81113a34:	1009883a 	mov	r4,r2
81113a38:	111c5900 	call	8111c590 <memset>
		xBuffer64[ucIL].bSent = FALSE;
81113a3c:	e0ffff03 	ldbu	r3,-4(fp)
81113a40:	00a04574 	movhi	r2,33045
81113a44:	10bd9504 	addi	r2,r2,-2476
81113a48:	18c01324 	muli	r3,r3,76
81113a4c:	10c5883a 	add	r2,r2,r3
81113a50:	10801004 	addi	r2,r2,64
81113a54:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
81113a58:	e0ffff03 	ldbu	r3,-4(fp)
81113a5c:	00a04574 	movhi	r2,33045
81113a60:	10bd9504 	addi	r2,r2,-2476
81113a64:	18c01324 	muli	r3,r3,76
81113a68:	10c5883a 	add	r2,r2,r3
81113a6c:	10801104 	addi	r2,r2,68
81113a70:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81113a74:	e0ffff03 	ldbu	r3,-4(fp)
81113a78:	00a04574 	movhi	r2,33045
81113a7c:	10bd9504 	addi	r2,r2,-2476
81113a80:	18c01324 	muli	r3,r3,76
81113a84:	10c5883a 	add	r2,r2,r3
81113a88:	10801184 	addi	r2,r2,70
81113a8c:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81113a90:	e0ffff03 	ldbu	r3,-4(fp)
81113a94:	00a04574 	movhi	r2,33045
81113a98:	10bd9504 	addi	r2,r2,-2476
81113a9c:	18c01324 	muli	r3,r3,76
81113aa0:	10c5883a 	add	r2,r2,r3
81113aa4:	10801204 	addi	r2,r2,72
81113aa8:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81113aac:	e0bfff03 	ldbu	r2,-4(fp)
81113ab0:	10800044 	addi	r2,r2,1
81113ab4:	e0bfff05 	stb	r2,-4(fp)
81113ab8:	e0bfff03 	ldbu	r2,-4(fp)
81113abc:	10800230 	cmpltui	r2,r2,8
81113ac0:	103fd51e 	bne	r2,zero,81113a18 <__reset+0xfb0f3a18>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81113ac4:	e03fff05 	stb	zero,-4(fp)
81113ac8:	00002806 	br	81113b6c <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81113acc:	e0bfff03 	ldbu	r2,-4(fp)
81113ad0:	10c00b24 	muli	r3,r2,44
81113ad4:	00a04574 	movhi	r2,33045
81113ad8:	108f4204 	addi	r2,r2,15624
81113adc:	1885883a 	add	r2,r3,r2
81113ae0:	01800804 	movi	r6,32
81113ae4:	000b883a 	mov	r5,zero
81113ae8:	1009883a 	mov	r4,r2
81113aec:	111c5900 	call	8111c590 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81113af0:	e0ffff03 	ldbu	r3,-4(fp)
81113af4:	00a04574 	movhi	r2,33045
81113af8:	108f4204 	addi	r2,r2,15624
81113afc:	18c00b24 	muli	r3,r3,44
81113b00:	10c5883a 	add	r2,r2,r3
81113b04:	10800804 	addi	r2,r2,32
81113b08:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81113b0c:	e0ffff03 	ldbu	r3,-4(fp)
81113b10:	00a04574 	movhi	r2,33045
81113b14:	108f4204 	addi	r2,r2,15624
81113b18:	18c00b24 	muli	r3,r3,44
81113b1c:	10c5883a 	add	r2,r2,r3
81113b20:	10800904 	addi	r2,r2,36
81113b24:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81113b28:	e0ffff03 	ldbu	r3,-4(fp)
81113b2c:	00a04574 	movhi	r2,33045
81113b30:	108f4204 	addi	r2,r2,15624
81113b34:	18c00b24 	muli	r3,r3,44
81113b38:	10c5883a 	add	r2,r2,r3
81113b3c:	10800984 	addi	r2,r2,38
81113b40:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81113b44:	e0ffff03 	ldbu	r3,-4(fp)
81113b48:	00a04574 	movhi	r2,33045
81113b4c:	108f4204 	addi	r2,r2,15624
81113b50:	18c00b24 	muli	r3,r3,44
81113b54:	10c5883a 	add	r2,r2,r3
81113b58:	10800a04 	addi	r2,r2,40
81113b5c:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81113b60:	e0bfff03 	ldbu	r2,-4(fp)
81113b64:	10800044 	addi	r2,r2,1
81113b68:	e0bfff05 	stb	r2,-4(fp)
81113b6c:	e0bfff03 	ldbu	r2,-4(fp)
81113b70:	10800230 	cmpltui	r2,r2,8
81113b74:	103fd51e 	bne	r2,zero,81113acc <__reset+0xfb0f3acc>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81113b78:	e03fff05 	stb	zero,-4(fp)
81113b7c:	00001b06 	br	81113bec <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81113b80:	e0ffff03 	ldbu	r3,-4(fp)
81113b84:	00a04574 	movhi	r2,33045
81113b88:	10be2d04 	addi	r2,r2,-1868
81113b8c:	18c01524 	muli	r3,r3,84
81113b90:	10c5883a 	add	r2,r2,r3
81113b94:	10800104 	addi	r2,r2,4
81113b98:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81113b9c:	e0ffff03 	ldbu	r3,-4(fp)
81113ba0:	00a04574 	movhi	r2,33045
81113ba4:	10be2d04 	addi	r2,r2,-1868
81113ba8:	18c01524 	muli	r3,r3,84
81113bac:	10c5883a 	add	r2,r2,r3
81113bb0:	10800484 	addi	r2,r2,18
81113bb4:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81113bb8:	e0bfff03 	ldbu	r2,-4(fp)
81113bbc:	10801524 	muli	r2,r2,84
81113bc0:	10c00504 	addi	r3,r2,20
81113bc4:	00a04574 	movhi	r2,33045
81113bc8:	10be2d04 	addi	r2,r2,-1868
81113bcc:	1885883a 	add	r2,r3,r2
81113bd0:	01801004 	movi	r6,64
81113bd4:	000b883a 	mov	r5,zero
81113bd8:	1009883a 	mov	r4,r2
81113bdc:	111c5900 	call	8111c590 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81113be0:	e0bfff03 	ldbu	r2,-4(fp)
81113be4:	10800044 	addi	r2,r2,1
81113be8:	e0bfff05 	stb	r2,-4(fp)
81113bec:	e0bfff03 	ldbu	r2,-4(fp)
81113bf0:	10800130 	cmpltui	r2,r2,4
81113bf4:	103fe21e 	bne	r2,zero,81113b80 <__reset+0xfb0f3b80>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81113bf8:	0001883a 	nop
81113bfc:	e037883a 	mov	sp,fp
81113c00:	dfc00117 	ldw	ra,4(sp)
81113c04:	df000017 	ldw	fp,0(sp)
81113c08:	dec00204 	addi	sp,sp,8
81113c0c:	f800283a 	ret

81113c10 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81113c10:	defff704 	addi	sp,sp,-36
81113c14:	de00012e 	bgeu	sp,et,81113c1c <main+0xc>
81113c18:	003b68fa 	trap	3
81113c1c:	dfc00815 	stw	ra,32(sp)
81113c20:	df000715 	stw	fp,28(sp)
81113c24:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81113c28:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81113c2c:	11334280 	call	81133428 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81113c30:	01604574 	movhi	r5,33045
81113c34:	29611004 	addi	r5,r5,-31680
81113c38:	01204574 	movhi	r4,33045
81113c3c:	21211104 	addi	r4,r4,-31676
81113c40:	111b3480 	call	8111b348 <fopen>
81113c44:	d0a05c15 	stw	r2,-32400(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
81113c48:	d0a05c17 	ldw	r2,-32400(gp)
81113c4c:	100f883a 	mov	r7,r2
81113c50:	01800484 	movi	r6,18
81113c54:	01400044 	movi	r5,1
81113c58:	01204574 	movhi	r4,33045
81113c5c:	21211604 	addi	r4,r4,-31656
81113c60:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81113c64:	1118cf40 	call	81118cf4 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81113c68:	11198fc0 	call	811198fc <bTestSimucamCriticalHW>
81113c6c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81113c70:	e0bffe17 	ldw	r2,-8(fp)
81113c74:	1000031e 	bne	r2,zero,81113c84 <main+0x74>
		vFailTestCriticasParts();
81113c78:	11166fc0 	call	811166fc <vFailTestCriticasParts>
		return -1;
81113c7c:	00bfffc4 	movi	r2,-1
81113c80:	00003e06 	br	81113d7c <main+0x16c>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81113c84:	11194740 	call	81119474 <bInitializeSDCard>
81113c88:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81113c8c:	e0bffe17 	ldw	r2,-8(fp)
81113c90:	1000031e 	bne	r2,zero,81113ca0 <main+0x90>
		vFailTestCriticasParts();
81113c94:	11166fc0 	call	811166fc <vFailTestCriticasParts>
		return -1;
81113c98:	00bfffc4 	movi	r2,-1
81113c9c:	00003706 	br	81113d7c <main+0x16c>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81113ca0:	11156b00 	call	811156b0 <vLoadDefaultETHConf>
81113ca4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81113ca8:	e0bffe17 	ldw	r2,-8(fp)
81113cac:	1000091e 	bne	r2,zero,81113cd4 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. (exit) \n");
81113cb0:	d0a05c17 	ldw	r2,-32400(gp)
81113cb4:	100f883a 	mov	r7,r2
81113cb8:	01801644 	movi	r6,89
81113cbc:	01400044 	movi	r5,1
81113cc0:	01204574 	movhi	r4,33045
81113cc4:	21211b04 	addi	r4,r4,-31636
81113cc8:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		return -1;
81113ccc:	00bfffc4 	movi	r2,-1
81113cd0:	00002a06 	br	81113d7c <main+0x16c>
	}

	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
81113cd4:	11160840 	call	81116084 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81113cd8:	11134580 	call	81113458 <bResourcesInitRTOS>
81113cdc:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81113ce0:	e0bffe17 	ldw	r2,-8(fp)
81113ce4:	1000091e 	bne	r2,zero,81113d0c <main+0xfc>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81113ce8:	d0a05c17 	ldw	r2,-32400(gp)
81113cec:	100f883a 	mov	r7,r2
81113cf0:	01800ac4 	movi	r6,43
81113cf4:	01400044 	movi	r5,1
81113cf8:	01204574 	movhi	r4,33045
81113cfc:	21213204 	addi	r4,r4,-31544
81113d00:	111ba2c0 	call	8111ba2c <fwrite>
		return -1;
81113d04:	00bfffc4 	movi	r2,-1
81113d08:	00001c06 	br	81113d7c <main+0x16c>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81113d0c:	01204574 	movhi	r4,33045
81113d10:	210a9504 	addi	r4,r4,10836
81113d14:	1118e340 	call	81118e34 <vSimucamStructureInit>

	vVariablesInitialization();
81113d18:	11138fc0 	call	811138fc <vVariablesInitialization>

	bInitSync();
81113d1c:	11196280 	call	81119628 <bInitSync>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81113d20:	d8000415 	stw	zero,16(sp)
81113d24:	d8000315 	stw	zero,12(sp)
81113d28:	00810004 	movi	r2,1024
81113d2c:	d8800215 	stw	r2,8(sp)
81113d30:	00a04574 	movhi	r2,33045
81113d34:	1099b204 	addi	r2,r2,26312
81113d38:	d8800115 	stw	r2,4(sp)
81113d3c:	00800044 	movi	r2,1
81113d40:	d8800015 	stw	r2,0(sp)
81113d44:	01c00044 	movi	r7,1
81113d48:	01a04574 	movhi	r6,33045
81113d4c:	319db104 	addi	r6,r6,30404
81113d50:	000b883a 	mov	r5,zero
81113d54:	01204474 	movhi	r4,33041
81113d58:	21395404 	addi	r4,r4,-6832
81113d5c:	113a0240 	call	8113a024 <OSTaskCreateExt>
81113d60:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81113d64:	e0bfff03 	ldbu	r2,-4(fp)
81113d68:	1000021e 	bne	r2,zero,81113d74 <main+0x164>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81113d6c:	11337580 	call	81133758 <OSStart>
81113d70:	00000106 	br	81113d78 <main+0x168>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81113d74:	1116ae80 	call	81116ae8 <vFailInitialization>
	}
  
	return 0;
81113d78:	0005883a 	mov	r2,zero
}
81113d7c:	e037883a 	mov	sp,fp
81113d80:	dfc00117 	ldw	ra,4(sp)
81113d84:	df000017 	ldw	fp,0(sp)
81113d88:	dec00204 	addi	sp,sp,8
81113d8c:	f800283a 	ret

81113d90 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81113d90:	defff604 	addi	sp,sp,-40
81113d94:	de00012e 	bgeu	sp,et,81113d9c <vFillMemmoryPattern+0xc>
81113d98:	003b68fa 	trap	3
81113d9c:	dfc00915 	stw	ra,36(sp)
81113da0:	df000815 	stw	fp,32(sp)
81113da4:	df000804 	addi	fp,sp,32
81113da8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81113dac:	00800044 	movi	r2,1
81113db0:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81113db4:	d0a05c17 	ldw	r2,-32400(gp)
81113db8:	100f883a 	mov	r7,r2
81113dbc:	018009c4 	movi	r6,39
81113dc0:	01400044 	movi	r5,1
81113dc4:	01204574 	movhi	r4,33045
81113dc8:	21213d04 	addi	r4,r4,-31500
81113dcc:	111ba2c0 	call	8111ba2c <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81113dd0:	e03ffa05 	stb	zero,-24(fp)
81113dd4:	00007606 	br	81113fb0 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81113dd8:	e03ffc85 	stb	zero,-14(fp)
81113ddc:	00006706 	br	81113f7c <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81113de0:	e0bffc83 	ldbu	r2,-14(fp)
81113de4:	e0ffff17 	ldw	r3,-4(fp)
81113de8:	10809524 	muli	r2,r2,596
81113dec:	1885883a 	add	r2,r3,r2
81113df0:	10804304 	addi	r2,r2,268
81113df4:	1080000b 	ldhu	r2,0(r2)
81113df8:	10ffffcc 	andi	r3,r2,65535
81113dfc:	e0bffc83 	ldbu	r2,-14(fp)
81113e00:	e13fff17 	ldw	r4,-4(fp)
81113e04:	10809524 	muli	r2,r2,596
81113e08:	2085883a 	add	r2,r4,r2
81113e0c:	10804204 	addi	r2,r2,264
81113e10:	1080000b 	ldhu	r2,0(r2)
81113e14:	10bfffcc 	andi	r2,r2,65535
81113e18:	1885883a 	add	r2,r3,r2
81113e1c:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81113e20:	e0bffc83 	ldbu	r2,-14(fp)
81113e24:	e0ffff17 	ldw	r3,-4(fp)
81113e28:	10809524 	muli	r2,r2,596
81113e2c:	1885883a 	add	r2,r3,r2
81113e30:	10804284 	addi	r2,r2,266
81113e34:	1080000b 	ldhu	r2,0(r2)
81113e38:	10ffffcc 	andi	r3,r2,65535
81113e3c:	e0bffc83 	ldbu	r2,-14(fp)
81113e40:	e13fff17 	ldw	r4,-4(fp)
81113e44:	10809524 	muli	r2,r2,596
81113e48:	2085883a 	add	r2,r4,r2
81113e4c:	10804184 	addi	r2,r2,262
81113e50:	1080000b 	ldhu	r2,0(r2)
81113e54:	10bfffcc 	andi	r2,r2,65535
81113e58:	1887883a 	add	r3,r3,r2
81113e5c:	e0bffc83 	ldbu	r2,-14(fp)
81113e60:	e13fff17 	ldw	r4,-4(fp)
81113e64:	10809524 	muli	r2,r2,596
81113e68:	2085883a 	add	r2,r4,r2
81113e6c:	10804104 	addi	r2,r2,260
81113e70:	1080000b 	ldhu	r2,0(r2)
81113e74:	10bfffcc 	andi	r2,r2,65535
81113e78:	1885883a 	add	r2,r3,r2
81113e7c:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81113e80:	e03ffc05 	stb	zero,-16(fp)
81113e84:	00003706 	br	81113f64 <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81113e88:	e03ffc45 	stb	zero,-15(fp)
81113e8c:	00002606 	br	81113f28 <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
81113e90:	e0bffc43 	ldbu	r2,-15(fp)
81113e94:	10000b1e 	bne	r2,zero,81113ec4 <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81113e98:	e0bffc83 	ldbu	r2,-14(fp)
81113e9c:	e13ffc03 	ldbu	r4,-16(fp)
81113ea0:	e0ffff17 	ldw	r3,-4(fp)
81113ea4:	21000624 	muli	r4,r4,24
81113ea8:	10809524 	muli	r2,r2,596
81113eac:	2085883a 	add	r2,r4,r2
81113eb0:	1885883a 	add	r2,r3,r2
81113eb4:	10801b04 	addi	r2,r2,108
81113eb8:	10800017 	ldw	r2,0(r2)
81113ebc:	e0bffb15 	stw	r2,-20(fp)
81113ec0:	00000a06 	br	81113eec <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81113ec4:	e0bffc83 	ldbu	r2,-14(fp)
81113ec8:	e13ffc03 	ldbu	r4,-16(fp)
81113ecc:	e0ffff17 	ldw	r3,-4(fp)
81113ed0:	21000624 	muli	r4,r4,24
81113ed4:	10809524 	muli	r2,r2,596
81113ed8:	2085883a 	add	r2,r4,r2
81113edc:	1885883a 	add	r2,r3,r2
81113ee0:	10801e04 	addi	r2,r2,120
81113ee4:	10800017 	ldw	r2,0(r2)
81113ee8:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81113eec:	e0fffa03 	ldbu	r3,-24(fp)
81113ef0:	e13ffc03 	ldbu	r4,-16(fp)
81113ef4:	e17ffc43 	ldbu	r5,-15(fp)
81113ef8:	e0bffe17 	ldw	r2,-8(fp)
81113efc:	d8800115 	stw	r2,4(sp)
81113f00:	e0bffd17 	ldw	r2,-12(fp)
81113f04:	d8800015 	stw	r2,0(sp)
81113f08:	280f883a 	mov	r7,r5
81113f0c:	200d883a 	mov	r6,r4
81113f10:	e17ffb17 	ldw	r5,-20(fp)
81113f14:	1809883a 	mov	r4,r3
81113f18:	11191f80 	call	811191f8 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81113f1c:	e0bffc43 	ldbu	r2,-15(fp)
81113f20:	10800044 	addi	r2,r2,1
81113f24:	e0bffc45 	stb	r2,-15(fp)
81113f28:	e0bffc43 	ldbu	r2,-15(fp)
81113f2c:	108000b0 	cmpltui	r2,r2,2
81113f30:	103fd71e 	bne	r2,zero,81113e90 <__reset+0xfb0f3e90>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81113f34:	d0a05c17 	ldw	r2,-32400(gp)
81113f38:	e0fffc83 	ldbu	r3,-14(fp)
81113f3c:	e13ffc03 	ldbu	r4,-16(fp)
81113f40:	200f883a 	mov	r7,r4
81113f44:	180d883a 	mov	r6,r3
81113f48:	01604574 	movhi	r5,33045
81113f4c:	29614704 	addi	r5,r5,-31460
81113f50:	1009883a 	mov	r4,r2
81113f54:	111b3900 	call	8111b390 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81113f58:	e0bffc03 	ldbu	r2,-16(fp)
81113f5c:	10800044 	addi	r2,r2,1
81113f60:	e0bffc05 	stb	r2,-16(fp)
81113f64:	e0bffc03 	ldbu	r2,-16(fp)
81113f68:	10800130 	cmpltui	r2,r2,4
81113f6c:	103fc61e 	bne	r2,zero,81113e88 <__reset+0xfb0f3e88>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81113f70:	e0bffc83 	ldbu	r2,-14(fp)
81113f74:	10800044 	addi	r2,r2,1
81113f78:	e0bffc85 	stb	r2,-14(fp)
81113f7c:	e0fffc83 	ldbu	r3,-14(fp)
81113f80:	e0bffcc3 	ldbu	r2,-13(fp)
81113f84:	18bf9636 	bltu	r3,r2,81113de0 <__reset+0xfb0f3de0>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81113f88:	d0a05c17 	ldw	r2,-32400(gp)
81113f8c:	e0fffa03 	ldbu	r3,-24(fp)
81113f90:	180d883a 	mov	r6,r3
81113f94:	01604574 	movhi	r5,33045
81113f98:	29614c04 	addi	r5,r5,-31440
81113f9c:	1009883a 	mov	r4,r2
81113fa0:	111b3900 	call	8111b390 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81113fa4:	e0bffa03 	ldbu	r2,-24(fp)
81113fa8:	10800044 	addi	r2,r2,1
81113fac:	e0bffa05 	stb	r2,-24(fp)
81113fb0:	e0bffa03 	ldbu	r2,-24(fp)
81113fb4:	108000b0 	cmpltui	r2,r2,2
81113fb8:	103f871e 	bne	r2,zero,81113dd8 <__reset+0xfb0f3dd8>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81113fbc:	d0a05c17 	ldw	r2,-32400(gp)
81113fc0:	100f883a 	mov	r7,r2
81113fc4:	01800404 	movi	r6,16
81113fc8:	01400044 	movi	r5,1
81113fcc:	01204574 	movhi	r4,33045
81113fd0:	21215004 	addi	r4,r4,-31424
81113fd4:	111ba2c0 	call	8111ba2c <fwrite>
#endif


}
81113fd8:	0001883a 	nop
81113fdc:	e037883a 	mov	sp,fp
81113fe0:	dfc00117 	ldw	ra,4(sp)
81113fe4:	df000017 	ldw	fp,0(sp)
81113fe8:	dec00204 	addi	sp,sp,8
81113fec:	f800283a 	ret

81113ff0 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81113ff0:	defff604 	addi	sp,sp,-40
81113ff4:	de00012e 	bgeu	sp,et,81113ffc <vPrintMemmoryPattern+0xc>
81113ff8:	003b68fa 	trap	3
81113ffc:	dfc00915 	stw	ra,36(sp)
81114000:	df000815 	stw	fp,32(sp)
81114004:	df000804 	addi	fp,sp,32
81114008:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
8111400c:	00800044 	movi	r2,1
81114010:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81114014:	d0a05c17 	ldw	r2,-32400(gp)
81114018:	100f883a 	mov	r7,r2
8111401c:	018009c4 	movi	r6,39
81114020:	01400044 	movi	r5,1
81114024:	01204574 	movhi	r4,33045
81114028:	21213d04 	addi	r4,r4,-31500
8111402c:	111ba2c0 	call	8111ba2c <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81114030:	e03ffa05 	stb	zero,-24(fp)
81114034:	00007606 	br	81114210 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81114038:	e03ffc85 	stb	zero,-14(fp)
8111403c:	00006706 	br	811141dc <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81114040:	e0bffc83 	ldbu	r2,-14(fp)
81114044:	e0ffff17 	ldw	r3,-4(fp)
81114048:	10809524 	muli	r2,r2,596
8111404c:	1885883a 	add	r2,r3,r2
81114050:	10804304 	addi	r2,r2,268
81114054:	1080000b 	ldhu	r2,0(r2)
81114058:	10ffffcc 	andi	r3,r2,65535
8111405c:	e0bffc83 	ldbu	r2,-14(fp)
81114060:	e13fff17 	ldw	r4,-4(fp)
81114064:	10809524 	muli	r2,r2,596
81114068:	2085883a 	add	r2,r4,r2
8111406c:	10804204 	addi	r2,r2,264
81114070:	1080000b 	ldhu	r2,0(r2)
81114074:	10bfffcc 	andi	r2,r2,65535
81114078:	1885883a 	add	r2,r3,r2
8111407c:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81114080:	e0bffc83 	ldbu	r2,-14(fp)
81114084:	e0ffff17 	ldw	r3,-4(fp)
81114088:	10809524 	muli	r2,r2,596
8111408c:	1885883a 	add	r2,r3,r2
81114090:	10804284 	addi	r2,r2,266
81114094:	1080000b 	ldhu	r2,0(r2)
81114098:	10ffffcc 	andi	r3,r2,65535
8111409c:	e0bffc83 	ldbu	r2,-14(fp)
811140a0:	e13fff17 	ldw	r4,-4(fp)
811140a4:	10809524 	muli	r2,r2,596
811140a8:	2085883a 	add	r2,r4,r2
811140ac:	10804184 	addi	r2,r2,262
811140b0:	1080000b 	ldhu	r2,0(r2)
811140b4:	10bfffcc 	andi	r2,r2,65535
811140b8:	1887883a 	add	r3,r3,r2
811140bc:	e0bffc83 	ldbu	r2,-14(fp)
811140c0:	e13fff17 	ldw	r4,-4(fp)
811140c4:	10809524 	muli	r2,r2,596
811140c8:	2085883a 	add	r2,r4,r2
811140cc:	10804104 	addi	r2,r2,260
811140d0:	1080000b 	ldhu	r2,0(r2)
811140d4:	10bfffcc 	andi	r2,r2,65535
811140d8:	1885883a 	add	r2,r3,r2
811140dc:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811140e0:	e03ffc05 	stb	zero,-16(fp)
811140e4:	00003706 	br	811141c4 <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811140e8:	e03ffc45 	stb	zero,-15(fp)
811140ec:	00002606 	br	81114188 <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
811140f0:	e0bffc43 	ldbu	r2,-15(fp)
811140f4:	10000b1e 	bne	r2,zero,81114124 <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
811140f8:	e0bffc83 	ldbu	r2,-14(fp)
811140fc:	e13ffc03 	ldbu	r4,-16(fp)
81114100:	e0ffff17 	ldw	r3,-4(fp)
81114104:	21000624 	muli	r4,r4,24
81114108:	10809524 	muli	r2,r2,596
8111410c:	2085883a 	add	r2,r4,r2
81114110:	1885883a 	add	r2,r3,r2
81114114:	10801b04 	addi	r2,r2,108
81114118:	10800017 	ldw	r2,0(r2)
8111411c:	e0bffb15 	stw	r2,-20(fp)
81114120:	00000a06 	br	8111414c <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81114124:	e0bffc83 	ldbu	r2,-14(fp)
81114128:	e13ffc03 	ldbu	r4,-16(fp)
8111412c:	e0ffff17 	ldw	r3,-4(fp)
81114130:	21000624 	muli	r4,r4,24
81114134:	10809524 	muli	r2,r2,596
81114138:	2085883a 	add	r2,r4,r2
8111413c:	1885883a 	add	r2,r3,r2
81114140:	10801e04 	addi	r2,r2,120
81114144:	10800017 	ldw	r2,0(r2)
81114148:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
8111414c:	e0fffa03 	ldbu	r3,-24(fp)
81114150:	e13ffc03 	ldbu	r4,-16(fp)
81114154:	e17ffc43 	ldbu	r5,-15(fp)
81114158:	e0bffe17 	ldw	r2,-8(fp)
8111415c:	d8800115 	stw	r2,4(sp)
81114160:	e0bffd17 	ldw	r2,-12(fp)
81114164:	d8800015 	stw	r2,0(sp)
81114168:	280f883a 	mov	r7,r5
8111416c:	200d883a 	mov	r6,r4
81114170:	e17ffb17 	ldw	r5,-20(fp)
81114174:	1809883a 	mov	r4,r3
81114178:	11191f80 	call	811191f8 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8111417c:	e0bffc43 	ldbu	r2,-15(fp)
81114180:	10800044 	addi	r2,r2,1
81114184:	e0bffc45 	stb	r2,-15(fp)
81114188:	e0bffc43 	ldbu	r2,-15(fp)
8111418c:	108000b0 	cmpltui	r2,r2,2
81114190:	103fd71e 	bne	r2,zero,811140f0 <__reset+0xfb0f40f0>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81114194:	d0a05c17 	ldw	r2,-32400(gp)
81114198:	e0fffc83 	ldbu	r3,-14(fp)
8111419c:	e13ffc03 	ldbu	r4,-16(fp)
811141a0:	200f883a 	mov	r7,r4
811141a4:	180d883a 	mov	r6,r3
811141a8:	01604574 	movhi	r5,33045
811141ac:	29614704 	addi	r5,r5,-31460
811141b0:	1009883a 	mov	r4,r2
811141b4:	111b3900 	call	8111b390 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811141b8:	e0bffc03 	ldbu	r2,-16(fp)
811141bc:	10800044 	addi	r2,r2,1
811141c0:	e0bffc05 	stb	r2,-16(fp)
811141c4:	e0bffc03 	ldbu	r2,-16(fp)
811141c8:	10800130 	cmpltui	r2,r2,4
811141cc:	103fc61e 	bne	r2,zero,811140e8 <__reset+0xfb0f40e8>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811141d0:	e0bffc83 	ldbu	r2,-14(fp)
811141d4:	10800044 	addi	r2,r2,1
811141d8:	e0bffc85 	stb	r2,-14(fp)
811141dc:	e0fffc83 	ldbu	r3,-14(fp)
811141e0:	e0bffcc3 	ldbu	r2,-13(fp)
811141e4:	18bf9636 	bltu	r3,r2,81114040 <__reset+0xfb0f4040>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
811141e8:	d0a05c17 	ldw	r2,-32400(gp)
811141ec:	e0fffa03 	ldbu	r3,-24(fp)
811141f0:	180d883a 	mov	r6,r3
811141f4:	01604574 	movhi	r5,33045
811141f8:	29614c04 	addi	r5,r5,-31440
811141fc:	1009883a 	mov	r4,r2
81114200:	111b3900 	call	8111b390 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81114204:	e0bffa03 	ldbu	r2,-24(fp)
81114208:	10800044 	addi	r2,r2,1
8111420c:	e0bffa05 	stb	r2,-24(fp)
81114210:	e0bffa03 	ldbu	r2,-24(fp)
81114214:	108000b0 	cmpltui	r2,r2,2
81114218:	103f871e 	bne	r2,zero,81114038 <__reset+0xfb0f4038>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
8111421c:	d0a05c17 	ldw	r2,-32400(gp)
81114220:	100f883a 	mov	r7,r2
81114224:	01800404 	movi	r6,16
81114228:	01400044 	movi	r5,1
8111422c:	01204574 	movhi	r4,33045
81114230:	21215004 	addi	r4,r4,-31424
81114234:	111ba2c0 	call	8111ba2c <fwrite>
#endif


}
81114238:	0001883a 	nop
8111423c:	e037883a 	mov	sp,fp
81114240:	dfc00117 	ldw	ra,4(sp)
81114244:	df000017 	ldw	fp,0(sp)
81114248:	dec00204 	addi	sp,sp,8
8111424c:	f800283a 	ret

81114250 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81114250:	defffe04 	addi	sp,sp,-8
81114254:	de00012e 	bgeu	sp,et,8111425c <vCCDLoadDefaultValues+0xc>
81114258:	003b68fa 	trap	3
8111425c:	df000115 	stw	fp,4(sp)
81114260:	df000104 	addi	fp,sp,4
81114264:	e13fff15 	stw	r4,-4(fp)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadCcdDefsSDCard();

	ccdDef->usiHeight = 4510;
81114268:	e0bfff17 	ldw	r2,-4(fp)
8111426c:	00c46784 	movi	r3,4510
81114270:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = 30;
81114274:	e0bfff17 	ldw	r2,-4(fp)
81114278:	00c00784 	movi	r3,30
8111427c:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = 2255;
81114280:	e0bfff17 	ldw	r2,-4(fp)
81114284:	00c233c4 	movi	r3,2255
81114288:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = 15;
8111428c:	e0bfff17 	ldw	r2,-4(fp)
81114290:	00c003c4 	movi	r3,15
81114294:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = 25;
81114298:	e0bfff17 	ldw	r2,-4(fp)
8111429c:	00c00644 	movi	r3,25
811142a0:	10c0000d 	sth	r3,0(r2)
}
811142a4:	0001883a 	nop
811142a8:	e037883a 	mov	sp,fp
811142ac:	df000017 	ldw	fp,0(sp)
811142b0:	dec00104 	addi	sp,sp,4
811142b4:	f800283a 	ret

811142b8 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
811142b8:	defff904 	addi	sp,sp,-28
811142bc:	de00012e 	bgeu	sp,et,811142c4 <vCCDChangeValues+0xc>
811142c0:	003b68fa 	trap	3
811142c4:	df000615 	stw	fp,24(sp)
811142c8:	df000604 	addi	fp,sp,24
811142cc:	e13ffa15 	stw	r4,-24(fp)
811142d0:	2811883a 	mov	r8,r5
811142d4:	300b883a 	mov	r5,r6
811142d8:	3809883a 	mov	r4,r7
811142dc:	e0c00117 	ldw	r3,4(fp)
811142e0:	e0800217 	ldw	r2,8(fp)
811142e4:	e23ffb0d 	sth	r8,-20(fp)
811142e8:	e17ffc0d 	sth	r5,-16(fp)
811142ec:	e13ffd0d 	sth	r4,-12(fp)
811142f0:	e0fffe0d 	sth	r3,-8(fp)
811142f4:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
811142f8:	e0bffa17 	ldw	r2,-24(fp)
811142fc:	e0fffb0b 	ldhu	r3,-20(fp)
81114300:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
81114304:	e0bffa17 	ldw	r2,-24(fp)
81114308:	e0fffc0b 	ldhu	r3,-16(fp)
8111430c:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81114310:	e0bffa17 	ldw	r2,-24(fp)
81114314:	e0fffd0b 	ldhu	r3,-12(fp)
81114318:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
8111431c:	e0bffa17 	ldw	r2,-24(fp)
81114320:	e0fffe0b 	ldhu	r3,-8(fp)
81114324:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81114328:	e0bffa17 	ldw	r2,-24(fp)
8111432c:	e0ffff0b 	ldhu	r3,-4(fp)
81114330:	10c0000d 	sth	r3,0(r2)
}
81114334:	0001883a 	nop
81114338:	e037883a 	mov	sp,fp
8111433c:	df000017 	ldw	fp,0(sp)
81114340:	dec00104 	addi	sp,sp,4
81114344:	f800283a 	ret

81114348 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81114348:	defff904 	addi	sp,sp,-28
8111434c:	de00012e 	bgeu	sp,et,81114354 <bSendUART128v2+0xc>
81114350:	003b68fa 	trap	3
81114354:	dfc00615 	stw	ra,24(sp)
81114358:	df000515 	stw	fp,20(sp)
8111435c:	df000504 	addi	fp,sp,20
81114360:	e13ffe15 	stw	r4,-8(fp)
81114364:	2805883a 	mov	r2,r5
81114368:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
8111436c:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81114370:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81114374:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81114378:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8111437c:	d0a05d17 	ldw	r2,-32396(gp)
81114380:	e0fffd04 	addi	r3,fp,-12
81114384:	180d883a 	mov	r6,r3
81114388:	01400504 	movi	r5,20
8111438c:	1009883a 	mov	r4,r2
81114390:	113946c0 	call	8113946c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81114394:	e0bffd03 	ldbu	r2,-12(fp)
81114398:	10803fcc 	andi	r2,r2,255
8111439c:	10000326 	beq	r2,zero,811143ac <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811143a0:	1116d500 	call	81116d50 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
811143a4:	e0bffc17 	ldw	r2,-16(fp)
811143a8:	00009e06 	br	81114624 <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811143ac:	d0a06817 	ldw	r2,-32352(gp)
811143b0:	e0fffd04 	addi	r3,fp,-12
811143b4:	180d883a 	mov	r6,r3
811143b8:	01400104 	movi	r5,4
811143bc:	1009883a 	mov	r4,r2
811143c0:	11374600 	call	81137460 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811143c4:	e0bffd03 	ldbu	r2,-12(fp)
811143c8:	10803fcc 	andi	r2,r2,255
811143cc:	10001126 	beq	r2,zero,81114414 <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
811143d0:	d0a05c17 	ldw	r2,-32400(gp)
811143d4:	100f883a 	mov	r7,r2
811143d8:	01801484 	movi	r6,82
811143dc:	01400044 	movi	r5,1
811143e0:	01204574 	movhi	r4,33045
811143e4:	21215504 	addi	r4,r4,-31404
811143e8:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
811143ec:	d0a05d17 	ldw	r2,-32396(gp)
811143f0:	1009883a 	mov	r4,r2
811143f4:	11397f40 	call	811397f4 <OSSemPost>
811143f8:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811143fc:	e0bffd03 	ldbu	r2,-12(fp)
81114400:	10803fcc 	andi	r2,r2,255
81114404:	10000126 	beq	r2,zero,8111440c <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81114408:	1116ce80 	call	81116ce8 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
8111440c:	e0bffc17 	ldw	r2,-16(fp)
81114410:	00008406 	br	81114624 <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81114414:	e03ffb05 	stb	zero,-20(fp)
81114418:	00004306 	br	81114528 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
8111441c:	e0fffb03 	ldbu	r3,-20(fp)
81114420:	00a045b4 	movhi	r2,33046
81114424:	10a1b604 	addi	r2,r2,-31016
81114428:	18c7883a 	add	r3,r3,r3
8111442c:	18c7883a 	add	r3,r3,r3
81114430:	10c5883a 	add	r2,r2,r3
81114434:	10800017 	ldw	r2,0(r2)
81114438:	1000381e 	bne	r2,zero,8111451c <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
8111443c:	e0bffb03 	ldbu	r2,-20(fp)
81114440:	10c02324 	muli	r3,r2,140
81114444:	00a045b4 	movhi	r2,33046
81114448:	10a1d404 	addi	r2,r2,-30896
8111444c:	1885883a 	add	r2,r3,r2
81114450:	01802004 	movi	r6,128
81114454:	000b883a 	mov	r5,zero
81114458:	1009883a 	mov	r4,r2
8111445c:	111c5900 	call	8111c590 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81114460:	e0bffb03 	ldbu	r2,-20(fp)
81114464:	10c02324 	muli	r3,r2,140
81114468:	00a045b4 	movhi	r2,33046
8111446c:	10a1d404 	addi	r2,r2,-30896
81114470:	1885883a 	add	r2,r3,r2
81114474:	01801fc4 	movi	r6,127
81114478:	e17ffe17 	ldw	r5,-8(fp)
8111447c:	1009883a 	mov	r4,r2
81114480:	111c4400 	call	8111c440 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81114484:	e13ffb03 	ldbu	r4,-20(fp)
81114488:	e0ffff0b 	ldhu	r3,-4(fp)
8111448c:	00a045b4 	movhi	r2,33046
81114490:	10a1d404 	addi	r2,r2,-30896
81114494:	21002324 	muli	r4,r4,140
81114498:	1105883a 	add	r2,r2,r4
8111449c:	10802104 	addi	r2,r2,132
811144a0:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
811144a4:	e0fffb03 	ldbu	r3,-20(fp)
811144a8:	00a045b4 	movhi	r2,33046
811144ac:	10a1d404 	addi	r2,r2,-30896
811144b0:	18c02324 	muli	r3,r3,140
811144b4:	10c5883a 	add	r2,r2,r3
811144b8:	10802204 	addi	r2,r2,136
811144bc:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
811144c0:	e0fffb03 	ldbu	r3,-20(fp)
811144c4:	00a045b4 	movhi	r2,33046
811144c8:	10a1d404 	addi	r2,r2,-30896
811144cc:	18c02324 	muli	r3,r3,140
811144d0:	10c5883a 	add	r2,r2,r3
811144d4:	10802184 	addi	r2,r2,134
811144d8:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
811144dc:	e0fffb03 	ldbu	r3,-20(fp)
811144e0:	00a045b4 	movhi	r2,33046
811144e4:	10a1d404 	addi	r2,r2,-30896
811144e8:	18c02324 	muli	r3,r3,140
811144ec:	10c5883a 	add	r2,r2,r3
811144f0:	10802004 	addi	r2,r2,128
811144f4:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
811144f8:	e0fffb03 	ldbu	r3,-20(fp)
811144fc:	00a045b4 	movhi	r2,33046
81114500:	10a1b604 	addi	r2,r2,-31016
81114504:	18c7883a 	add	r3,r3,r3
81114508:	18c7883a 	add	r3,r3,r3
8111450c:	10c5883a 	add	r2,r2,r3
81114510:	00c00044 	movi	r3,1
81114514:	10c00015 	stw	r3,0(r2)
			break;
81114518:	00000606 	br	81114534 <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111451c:	e0bffb03 	ldbu	r2,-20(fp)
81114520:	10800044 	addi	r2,r2,1
81114524:	e0bffb05 	stb	r2,-20(fp)
81114528:	e0bffb03 	ldbu	r2,-20(fp)
8111452c:	108001b0 	cmpltui	r2,r2,6
81114530:	103fba1e 	bne	r2,zero,8111441c <__reset+0xfb0f441c>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81114534:	e0bffb03 	ldbu	r2,-20(fp)
81114538:	108001b0 	cmpltui	r2,r2,6
8111453c:	1000091e 	bne	r2,zero,81114564 <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81114540:	d0a05d17 	ldw	r2,-32396(gp)
81114544:	1009883a 	mov	r4,r2
81114548:	11397f40 	call	811397f4 <OSSemPost>
8111454c:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81114550:	d0a06817 	ldw	r2,-32352(gp)
81114554:	1009883a 	mov	r4,r2
81114558:	1137a040 	call	81137a04 <OSMutexPost>
		return bSuccessL;
8111455c:	e0bffc17 	ldw	r2,-16(fp)
81114560:	00003006 	br	81114624 <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
81114564:	00800044 	movi	r2,1
81114568:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
8111456c:	d0a06f43 	ldbu	r2,-32323(gp)
81114570:	10bfffc4 	addi	r2,r2,-1
81114574:	d0a06f45 	stb	r2,-32323(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81114578:	d0a06e17 	ldw	r2,-32328(gp)
8111457c:	e0fffd04 	addi	r3,fp,-12
81114580:	180d883a 	mov	r6,r3
81114584:	01400084 	movi	r5,2
81114588:	1009883a 	mov	r4,r2
8111458c:	11374600 	call	81137460 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81114590:	e0bffd03 	ldbu	r2,-12(fp)
81114594:	10803fcc 	andi	r2,r2,255
81114598:	10000c26 	beq	r2,zero,811145cc <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
8111459c:	d0a05c17 	ldw	r2,-32400(gp)
811145a0:	100f883a 	mov	r7,r2
811145a4:	01801c04 	movi	r6,112
811145a8:	01400044 	movi	r5,1
811145ac:	01204574 	movhi	r4,33045
811145b0:	21216a04 	addi	r4,r4,-31320
811145b4:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
811145b8:	d0a06817 	ldw	r2,-32352(gp)
811145bc:	1009883a 	mov	r4,r2
811145c0:	1137a040 	call	81137a04 <OSMutexPost>
		return bSuccessL;
811145c4:	e0bffc17 	ldw	r2,-16(fp)
811145c8:	00001606 	br	81114624 <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
811145cc:	e0bffb03 	ldbu	r2,-20(fp)
811145d0:	10c02324 	muli	r3,r2,140
811145d4:	00a045b4 	movhi	r2,33046
811145d8:	10a1d404 	addi	r2,r2,-30896
811145dc:	1885883a 	add	r2,r3,r2
811145e0:	1009883a 	mov	r4,r2
811145e4:	111c9dc0 	call	8111c9dc <puts>
	xBuffer128[ucIL].bSent = TRUE;
811145e8:	e0fffb03 	ldbu	r3,-20(fp)
811145ec:	00a045b4 	movhi	r2,33046
811145f0:	10a1d404 	addi	r2,r2,-30896
811145f4:	18c02324 	muli	r3,r3,140
811145f8:	10c5883a 	add	r2,r2,r3
811145fc:	10802004 	addi	r2,r2,128
81114600:	00c00044 	movi	r3,1
81114604:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81114608:	d0a06e17 	ldw	r2,-32328(gp)
8111460c:	1009883a 	mov	r4,r2
81114610:	1137a040 	call	81137a04 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81114614:	d0a06817 	ldw	r2,-32352(gp)
81114618:	1009883a 	mov	r4,r2
8111461c:	1137a040 	call	81137a04 <OSMutexPost>

	return bSuccessL;
81114620:	e0bffc17 	ldw	r2,-16(fp)
}
81114624:	e037883a 	mov	sp,fp
81114628:	dfc00117 	ldw	ra,4(sp)
8111462c:	df000017 	ldw	fp,0(sp)
81114630:	dec00204 	addi	sp,sp,8
81114634:	f800283a 	ret

81114638 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81114638:	defff904 	addi	sp,sp,-28
8111463c:	de00012e 	bgeu	sp,et,81114644 <bSendUART64v2+0xc>
81114640:	003b68fa 	trap	3
81114644:	dfc00615 	stw	ra,24(sp)
81114648:	df000515 	stw	fp,20(sp)
8111464c:	df000504 	addi	fp,sp,20
81114650:	e13ffe15 	stw	r4,-8(fp)
81114654:	2805883a 	mov	r2,r5
81114658:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8111465c:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81114660:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81114664:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81114668:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
8111466c:	d0a05817 	ldw	r2,-32416(gp)
81114670:	e0fffd04 	addi	r3,fp,-12
81114674:	180d883a 	mov	r6,r3
81114678:	01400504 	movi	r5,20
8111467c:	1009883a 	mov	r4,r2
81114680:	113946c0 	call	8113946c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81114684:	e0bffd03 	ldbu	r2,-12(fp)
81114688:	10803fcc 	andi	r2,r2,255
8111468c:	10000326 	beq	r2,zero,8111469c <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81114690:	1116db80 	call	81116db8 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81114694:	e0bffc17 	ldw	r2,-16(fp)
81114698:	0000a006 	br	8111491c <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
8111469c:	d0a06b17 	ldw	r2,-32340(gp)
811146a0:	e0fffd04 	addi	r3,fp,-12
811146a4:	180d883a 	mov	r6,r3
811146a8:	01400104 	movi	r5,4
811146ac:	1009883a 	mov	r4,r2
811146b0:	11374600 	call	81137460 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811146b4:	e0bffd03 	ldbu	r2,-12(fp)
811146b8:	10803fcc 	andi	r2,r2,255
811146bc:	10001126 	beq	r2,zero,81114704 <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
811146c0:	d0a05c17 	ldw	r2,-32400(gp)
811146c4:	100f883a 	mov	r7,r2
811146c8:	018013c4 	movi	r6,79
811146cc:	01400044 	movi	r5,1
811146d0:	01204574 	movhi	r4,33045
811146d4:	21218704 	addi	r4,r4,-31204
811146d8:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
811146dc:	d0a05817 	ldw	r2,-32416(gp)
811146e0:	1009883a 	mov	r4,r2
811146e4:	11397f40 	call	811397f4 <OSSemPost>
811146e8:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811146ec:	e0bffd03 	ldbu	r2,-12(fp)
811146f0:	10803fcc 	andi	r2,r2,255
811146f4:	10000126 	beq	r2,zero,811146fc <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811146f8:	1116c800 	call	81116c80 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
811146fc:	e0bffc17 	ldw	r2,-16(fp)
81114700:	00008606 	br	8111491c <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81114704:	e03ffb05 	stb	zero,-20(fp)
81114708:	00004506 	br	81114820 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
8111470c:	e0fffb03 	ldbu	r3,-20(fp)
81114710:	00a045b4 	movhi	r2,33046
81114714:	10a1b604 	addi	r2,r2,-31016
81114718:	18c00184 	addi	r3,r3,6
8111471c:	18c7883a 	add	r3,r3,r3
81114720:	18c7883a 	add	r3,r3,r3
81114724:	10c5883a 	add	r2,r2,r3
81114728:	10800017 	ldw	r2,0(r2)
8111472c:	1000391e 	bne	r2,zero,81114814 <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81114730:	e0bffb03 	ldbu	r2,-20(fp)
81114734:	10c01324 	muli	r3,r2,76
81114738:	00a04574 	movhi	r2,33045
8111473c:	10bd9504 	addi	r2,r2,-2476
81114740:	1885883a 	add	r2,r3,r2
81114744:	01801004 	movi	r6,64
81114748:	000b883a 	mov	r5,zero
8111474c:	1009883a 	mov	r4,r2
81114750:	111c5900 	call	8111c590 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81114754:	e0bffb03 	ldbu	r2,-20(fp)
81114758:	10c01324 	muli	r3,r2,76
8111475c:	00a04574 	movhi	r2,33045
81114760:	10bd9504 	addi	r2,r2,-2476
81114764:	1885883a 	add	r2,r3,r2
81114768:	01800fc4 	movi	r6,63
8111476c:	e17ffe17 	ldw	r5,-8(fp)
81114770:	1009883a 	mov	r4,r2
81114774:	111c4400 	call	8111c440 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
81114778:	e13ffb03 	ldbu	r4,-20(fp)
8111477c:	e0ffff0b 	ldhu	r3,-4(fp)
81114780:	00a04574 	movhi	r2,33045
81114784:	10bd9504 	addi	r2,r2,-2476
81114788:	21001324 	muli	r4,r4,76
8111478c:	1105883a 	add	r2,r2,r4
81114790:	10801104 	addi	r2,r2,68
81114794:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81114798:	e0fffb03 	ldbu	r3,-20(fp)
8111479c:	00a04574 	movhi	r2,33045
811147a0:	10bd9504 	addi	r2,r2,-2476
811147a4:	18c01324 	muli	r3,r3,76
811147a8:	10c5883a 	add	r2,r2,r3
811147ac:	10801204 	addi	r2,r2,72
811147b0:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
811147b4:	e0fffb03 	ldbu	r3,-20(fp)
811147b8:	00a04574 	movhi	r2,33045
811147bc:	10bd9504 	addi	r2,r2,-2476
811147c0:	18c01324 	muli	r3,r3,76
811147c4:	10c5883a 	add	r2,r2,r3
811147c8:	10801184 	addi	r2,r2,70
811147cc:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
811147d0:	e0fffb03 	ldbu	r3,-20(fp)
811147d4:	00a04574 	movhi	r2,33045
811147d8:	10bd9504 	addi	r2,r2,-2476
811147dc:	18c01324 	muli	r3,r3,76
811147e0:	10c5883a 	add	r2,r2,r3
811147e4:	10801004 	addi	r2,r2,64
811147e8:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
811147ec:	e0fffb03 	ldbu	r3,-20(fp)
811147f0:	00a045b4 	movhi	r2,33046
811147f4:	10a1b604 	addi	r2,r2,-31016
811147f8:	18c00184 	addi	r3,r3,6
811147fc:	18c7883a 	add	r3,r3,r3
81114800:	18c7883a 	add	r3,r3,r3
81114804:	10c5883a 	add	r2,r2,r3
81114808:	00c00044 	movi	r3,1
8111480c:	10c00015 	stw	r3,0(r2)
			break;
81114810:	00000606 	br	8111482c <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81114814:	e0bffb03 	ldbu	r2,-20(fp)
81114818:	10800044 	addi	r2,r2,1
8111481c:	e0bffb05 	stb	r2,-20(fp)
81114820:	e0bffb03 	ldbu	r2,-20(fp)
81114824:	10800230 	cmpltui	r2,r2,8
81114828:	103fb81e 	bne	r2,zero,8111470c <__reset+0xfb0f470c>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
8111482c:	e0bffb03 	ldbu	r2,-20(fp)
81114830:	10800230 	cmpltui	r2,r2,8
81114834:	1000091e 	bne	r2,zero,8111485c <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81114838:	d0a05817 	ldw	r2,-32416(gp)
8111483c:	1009883a 	mov	r4,r2
81114840:	11397f40 	call	811397f4 <OSSemPost>
81114844:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
81114848:	d0a06b17 	ldw	r2,-32340(gp)
8111484c:	1009883a 	mov	r4,r2
81114850:	1137a040 	call	81137a04 <OSMutexPost>
		return bSuccessL;
81114854:	e0bffc17 	ldw	r2,-16(fp)
81114858:	00003006 	br	8111491c <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
8111485c:	00800044 	movi	r2,1
81114860:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81114864:	d0a06f03 	ldbu	r2,-32324(gp)
81114868:	10bfffc4 	addi	r2,r2,-1
8111486c:	d0a06f05 	stb	r2,-32324(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81114870:	d0a06e17 	ldw	r2,-32328(gp)
81114874:	e0fffd04 	addi	r3,fp,-12
81114878:	180d883a 	mov	r6,r3
8111487c:	01400084 	movi	r5,2
81114880:	1009883a 	mov	r4,r2
81114884:	11374600 	call	81137460 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81114888:	e0bffd03 	ldbu	r2,-12(fp)
8111488c:	10803fcc 	andi	r2,r2,255
81114890:	10000c26 	beq	r2,zero,811148c4 <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
81114894:	d0a05c17 	ldw	r2,-32400(gp)
81114898:	100f883a 	mov	r7,r2
8111489c:	01801bc4 	movi	r6,111
811148a0:	01400044 	movi	r5,1
811148a4:	01204574 	movhi	r4,33045
811148a8:	21219b04 	addi	r4,r4,-31124
811148ac:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
811148b0:	d0a06b17 	ldw	r2,-32340(gp)
811148b4:	1009883a 	mov	r4,r2
811148b8:	1137a040 	call	81137a04 <OSMutexPost>
		return bSuccessL;
811148bc:	e0bffc17 	ldw	r2,-16(fp)
811148c0:	00001606 	br	8111491c <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
811148c4:	e0bffb03 	ldbu	r2,-20(fp)
811148c8:	10c01324 	muli	r3,r2,76
811148cc:	00a04574 	movhi	r2,33045
811148d0:	10bd9504 	addi	r2,r2,-2476
811148d4:	1885883a 	add	r2,r3,r2
811148d8:	1009883a 	mov	r4,r2
811148dc:	111c9dc0 	call	8111c9dc <puts>
	xBuffer64[ucIL].bSent = TRUE;
811148e0:	e0fffb03 	ldbu	r3,-20(fp)
811148e4:	00a04574 	movhi	r2,33045
811148e8:	10bd9504 	addi	r2,r2,-2476
811148ec:	18c01324 	muli	r3,r3,76
811148f0:	10c5883a 	add	r2,r2,r3
811148f4:	10801004 	addi	r2,r2,64
811148f8:	00c00044 	movi	r3,1
811148fc:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81114900:	d0a06e17 	ldw	r2,-32328(gp)
81114904:	1009883a 	mov	r4,r2
81114908:	1137a040 	call	81137a04 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
8111490c:	d0a06b17 	ldw	r2,-32340(gp)
81114910:	1009883a 	mov	r4,r2
81114914:	1137a040 	call	81137a04 <OSMutexPost>

	return bSuccessL;
81114918:	e0bffc17 	ldw	r2,-16(fp)
}
8111491c:	e037883a 	mov	sp,fp
81114920:	dfc00117 	ldw	ra,4(sp)
81114924:	df000017 	ldw	fp,0(sp)
81114928:	dec00204 	addi	sp,sp,8
8111492c:	f800283a 	ret

81114930 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81114930:	defff904 	addi	sp,sp,-28
81114934:	de00012e 	bgeu	sp,et,8111493c <bSendUART32v2+0xc>
81114938:	003b68fa 	trap	3
8111493c:	dfc00615 	stw	ra,24(sp)
81114940:	df000515 	stw	fp,20(sp)
81114944:	df000504 	addi	fp,sp,20
81114948:	e13ffe15 	stw	r4,-8(fp)
8111494c:	2805883a 	mov	r2,r5
81114950:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81114954:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81114958:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8111495c:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81114960:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81114964:	d0a06917 	ldw	r2,-32348(gp)
81114968:	e0fffd04 	addi	r3,fp,-12
8111496c:	180d883a 	mov	r6,r3
81114970:	01400504 	movi	r5,20
81114974:	1009883a 	mov	r4,r2
81114978:	113946c0 	call	8113946c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8111497c:	e0bffd03 	ldbu	r2,-12(fp)
81114980:	10803fcc 	andi	r2,r2,255
81114984:	10000326 	beq	r2,zero,81114994 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81114988:	1116e200 	call	81116e20 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
8111498c:	e0bffc17 	ldw	r2,-16(fp)
81114990:	0000a006 	br	81114c14 <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81114994:	d0a06617 	ldw	r2,-32360(gp)
81114998:	e0fffd04 	addi	r3,fp,-12
8111499c:	180d883a 	mov	r6,r3
811149a0:	01400104 	movi	r5,4
811149a4:	1009883a 	mov	r4,r2
811149a8:	11374600 	call	81137460 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811149ac:	e0bffd03 	ldbu	r2,-12(fp)
811149b0:	10803fcc 	andi	r2,r2,255
811149b4:	10001126 	beq	r2,zero,811149fc <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
811149b8:	d0a05c17 	ldw	r2,-32400(gp)
811149bc:	100f883a 	mov	r7,r2
811149c0:	018013c4 	movi	r6,79
811149c4:	01400044 	movi	r5,1
811149c8:	01204574 	movhi	r4,33045
811149cc:	2121b704 	addi	r4,r4,-31012
811149d0:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
811149d4:	d0a06917 	ldw	r2,-32348(gp)
811149d8:	1009883a 	mov	r4,r2
811149dc:	11397f40 	call	811397f4 <OSSemPost>
811149e0:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811149e4:	e0bffd03 	ldbu	r2,-12(fp)
811149e8:	10803fcc 	andi	r2,r2,255
811149ec:	10000126 	beq	r2,zero,811149f4 <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811149f0:	1116c180 	call	81116c18 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
811149f4:	e0bffc17 	ldw	r2,-16(fp)
811149f8:	00008606 	br	81114c14 <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
811149fc:	e03ffb05 	stb	zero,-20(fp)
81114a00:	00004506 	br	81114b18 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81114a04:	e0fffb03 	ldbu	r3,-20(fp)
81114a08:	00a045b4 	movhi	r2,33046
81114a0c:	10a1b604 	addi	r2,r2,-31016
81114a10:	18c00384 	addi	r3,r3,14
81114a14:	18c7883a 	add	r3,r3,r3
81114a18:	18c7883a 	add	r3,r3,r3
81114a1c:	10c5883a 	add	r2,r2,r3
81114a20:	10800017 	ldw	r2,0(r2)
81114a24:	1000391e 	bne	r2,zero,81114b0c <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81114a28:	e0bffb03 	ldbu	r2,-20(fp)
81114a2c:	10c00b24 	muli	r3,r2,44
81114a30:	00a04574 	movhi	r2,33045
81114a34:	108f4204 	addi	r2,r2,15624
81114a38:	1885883a 	add	r2,r3,r2
81114a3c:	01800804 	movi	r6,32
81114a40:	000b883a 	mov	r5,zero
81114a44:	1009883a 	mov	r4,r2
81114a48:	111c5900 	call	8111c590 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81114a4c:	e0bffb03 	ldbu	r2,-20(fp)
81114a50:	10c00b24 	muli	r3,r2,44
81114a54:	00a04574 	movhi	r2,33045
81114a58:	108f4204 	addi	r2,r2,15624
81114a5c:	1885883a 	add	r2,r3,r2
81114a60:	018007c4 	movi	r6,31
81114a64:	e17ffe17 	ldw	r5,-8(fp)
81114a68:	1009883a 	mov	r4,r2
81114a6c:	111c4400 	call	8111c440 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81114a70:	e13ffb03 	ldbu	r4,-20(fp)
81114a74:	e0ffff0b 	ldhu	r3,-4(fp)
81114a78:	00a04574 	movhi	r2,33045
81114a7c:	108f4204 	addi	r2,r2,15624
81114a80:	21000b24 	muli	r4,r4,44
81114a84:	1105883a 	add	r2,r2,r4
81114a88:	10800904 	addi	r2,r2,36
81114a8c:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81114a90:	e0fffb03 	ldbu	r3,-20(fp)
81114a94:	00a04574 	movhi	r2,33045
81114a98:	108f4204 	addi	r2,r2,15624
81114a9c:	18c00b24 	muli	r3,r3,44
81114aa0:	10c5883a 	add	r2,r2,r3
81114aa4:	10800a04 	addi	r2,r2,40
81114aa8:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81114aac:	e0fffb03 	ldbu	r3,-20(fp)
81114ab0:	00a04574 	movhi	r2,33045
81114ab4:	108f4204 	addi	r2,r2,15624
81114ab8:	18c00b24 	muli	r3,r3,44
81114abc:	10c5883a 	add	r2,r2,r3
81114ac0:	10800984 	addi	r2,r2,38
81114ac4:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81114ac8:	e0fffb03 	ldbu	r3,-20(fp)
81114acc:	00a04574 	movhi	r2,33045
81114ad0:	108f4204 	addi	r2,r2,15624
81114ad4:	18c00b24 	muli	r3,r3,44
81114ad8:	10c5883a 	add	r2,r2,r3
81114adc:	10800804 	addi	r2,r2,32
81114ae0:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81114ae4:	e0fffb03 	ldbu	r3,-20(fp)
81114ae8:	00a045b4 	movhi	r2,33046
81114aec:	10a1b604 	addi	r2,r2,-31016
81114af0:	18c00384 	addi	r3,r3,14
81114af4:	18c7883a 	add	r3,r3,r3
81114af8:	18c7883a 	add	r3,r3,r3
81114afc:	10c5883a 	add	r2,r2,r3
81114b00:	00c00044 	movi	r3,1
81114b04:	10c00015 	stw	r3,0(r2)
			break;
81114b08:	00000606 	br	81114b24 <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81114b0c:	e0bffb03 	ldbu	r2,-20(fp)
81114b10:	10800044 	addi	r2,r2,1
81114b14:	e0bffb05 	stb	r2,-20(fp)
81114b18:	e0bffb03 	ldbu	r2,-20(fp)
81114b1c:	10800230 	cmpltui	r2,r2,8
81114b20:	103fb81e 	bne	r2,zero,81114a04 <__reset+0xfb0f4a04>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81114b24:	e0bffb03 	ldbu	r2,-20(fp)
81114b28:	10800230 	cmpltui	r2,r2,8
81114b2c:	1000091e 	bne	r2,zero,81114b54 <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81114b30:	d0a06917 	ldw	r2,-32348(gp)
81114b34:	1009883a 	mov	r4,r2
81114b38:	11397f40 	call	811397f4 <OSSemPost>
81114b3c:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81114b40:	d0a06617 	ldw	r2,-32360(gp)
81114b44:	1009883a 	mov	r4,r2
81114b48:	1137a040 	call	81137a04 <OSMutexPost>
		return bSuccessL;
81114b4c:	e0bffc17 	ldw	r2,-16(fp)
81114b50:	00003006 	br	81114c14 <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
81114b54:	00800044 	movi	r2,1
81114b58:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81114b5c:	d0a06283 	ldbu	r2,-32374(gp)
81114b60:	10bfffc4 	addi	r2,r2,-1
81114b64:	d0a06285 	stb	r2,-32374(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81114b68:	d0a06e17 	ldw	r2,-32328(gp)
81114b6c:	e0fffd04 	addi	r3,fp,-12
81114b70:	180d883a 	mov	r6,r3
81114b74:	01400084 	movi	r5,2
81114b78:	1009883a 	mov	r4,r2
81114b7c:	11374600 	call	81137460 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81114b80:	e0bffd03 	ldbu	r2,-12(fp)
81114b84:	10803fcc 	andi	r2,r2,255
81114b88:	10000c26 	beq	r2,zero,81114bbc <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81114b8c:	d0a05c17 	ldw	r2,-32400(gp)
81114b90:	100f883a 	mov	r7,r2
81114b94:	01801bc4 	movi	r6,111
81114b98:	01400044 	movi	r5,1
81114b9c:	01204574 	movhi	r4,33045
81114ba0:	2121cb04 	addi	r4,r4,-30932
81114ba4:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81114ba8:	d0a06617 	ldw	r2,-32360(gp)
81114bac:	1009883a 	mov	r4,r2
81114bb0:	1137a040 	call	81137a04 <OSMutexPost>
		return bSuccessL;
81114bb4:	e0bffc17 	ldw	r2,-16(fp)
81114bb8:	00001606 	br	81114c14 <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81114bbc:	e0bffb03 	ldbu	r2,-20(fp)
81114bc0:	10c00b24 	muli	r3,r2,44
81114bc4:	00a04574 	movhi	r2,33045
81114bc8:	108f4204 	addi	r2,r2,15624
81114bcc:	1885883a 	add	r2,r3,r2
81114bd0:	1009883a 	mov	r4,r2
81114bd4:	111c9dc0 	call	8111c9dc <puts>
	xBuffer32[ucIL].bSent = TRUE;
81114bd8:	e0fffb03 	ldbu	r3,-20(fp)
81114bdc:	00a04574 	movhi	r2,33045
81114be0:	108f4204 	addi	r2,r2,15624
81114be4:	18c00b24 	muli	r3,r3,44
81114be8:	10c5883a 	add	r2,r2,r3
81114bec:	10800804 	addi	r2,r2,32
81114bf0:	00c00044 	movi	r3,1
81114bf4:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81114bf8:	d0a06e17 	ldw	r2,-32328(gp)
81114bfc:	1009883a 	mov	r4,r2
81114c00:	1137a040 	call	81137a04 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81114c04:	d0a06617 	ldw	r2,-32360(gp)
81114c08:	1009883a 	mov	r4,r2
81114c0c:	1137a040 	call	81137a04 <OSMutexPost>

	return bSuccessL;
81114c10:	e0bffc17 	ldw	r2,-16(fp)
}
81114c14:	e037883a 	mov	sp,fp
81114c18:	dfc00117 	ldw	ra,4(sp)
81114c1c:	df000017 	ldw	fp,0(sp)
81114c20:	dec00204 	addi	sp,sp,8
81114c24:	f800283a 	ret

81114c28 <vSendEthConf>:


void vSendEthConf ( void ) {
81114c28:	deffc304 	addi	sp,sp,-244
81114c2c:	de00012e 	bgeu	sp,et,81114c34 <vSendEthConf+0xc>
81114c30:	003b68fa 	trap	3
81114c34:	dfc03c15 	stw	ra,240(sp)
81114c38:	df003b15 	stw	fp,236(sp)
81114c3c:	dd403a15 	stw	r21,232(sp)
81114c40:	dd003915 	stw	r20,228(sp)
81114c44:	dcc03815 	stw	r19,224(sp)
81114c48:	dc803715 	stw	r18,220(sp)
81114c4c:	dc403615 	stw	r17,216(sp)
81114c50:	dc003515 	stw	r16,212(sp)
81114c54:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
81114c58:	e03fd98d 	sth	zero,-154(fp)
81114c5c:	e03fda0d 	sth	zero,-152(fp)
81114c60:	e0bfda84 	addi	r2,fp,-150
81114c64:	00c01f04 	movi	r3,124
81114c68:	180d883a 	mov	r6,r3
81114c6c:	000b883a 	mov	r5,zero
81114c70:	1009883a 	mov	r4,r2
81114c74:	111c5900 	call	8111c590 <memset>
    unsigned char crc = 0;
81114c78:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81114c7c:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81114c80:	11151e80 	call	811151e8 <usiGetIdCMD>
81114c84:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114c88:	e57fd90b 	ldhu	r21,-156(fp)
81114c8c:	00a045b4 	movhi	r2,33046
81114c90:	10817804 	addi	r2,r2,1504
81114c94:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114c98:	00a045b4 	movhi	r2,33046
81114c9c:	10817804 	addi	r2,r2,1504
81114ca0:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114ca4:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114ca8:	00a045b4 	movhi	r2,33046
81114cac:	10817804 	addi	r2,r2,1504
81114cb0:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114cb4:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114cb8:	00a045b4 	movhi	r2,33046
81114cbc:	10817804 	addi	r2,r2,1504
81114cc0:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114cc4:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114cc8:	00a045b4 	movhi	r2,33046
81114ccc:	10817804 	addi	r2,r2,1504
81114cd0:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114cd4:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114cd8:	00a045b4 	movhi	r2,33046
81114cdc:	10817804 	addi	r2,r2,1504
81114ce0:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114ce4:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114ce8:	00a045b4 	movhi	r2,33046
81114cec:	10817804 	addi	r2,r2,1504
81114cf0:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114cf4:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114cf8:	00a045b4 	movhi	r2,33046
81114cfc:	10817804 	addi	r2,r2,1504
81114d00:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d04:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114d08:	00a045b4 	movhi	r2,33046
81114d0c:	10817804 	addi	r2,r2,1504
81114d10:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d14:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114d18:	00a045b4 	movhi	r2,33046
81114d1c:	10817804 	addi	r2,r2,1504
81114d20:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d24:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114d28:	00a045b4 	movhi	r2,33046
81114d2c:	10817804 	addi	r2,r2,1504
81114d30:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d34:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114d38:	00a045b4 	movhi	r2,33046
81114d3c:	10817804 	addi	r2,r2,1504
81114d40:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d44:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114d48:	00a045b4 	movhi	r2,33046
81114d4c:	10817804 	addi	r2,r2,1504
81114d50:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d54:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81114d58:	00a045b4 	movhi	r2,33046
81114d5c:	10817804 	addi	r2,r2,1504
81114d60:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d64:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81114d68:	00a045b4 	movhi	r2,33046
81114d6c:	10817804 	addi	r2,r2,1504
81114d70:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d74:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81114d78:	00a045b4 	movhi	r2,33046
81114d7c:	10817804 	addi	r2,r2,1504
81114d80:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d84:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81114d88:	00a045b4 	movhi	r2,33046
81114d8c:	10817804 	addi	r2,r2,1504
81114d90:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114d94:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81114d98:	00a045b4 	movhi	r2,33046
81114d9c:	10817804 	addi	r2,r2,1504
81114da0:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114da4:	10bfffcc 	andi	r2,r2,65535
81114da8:	e53fd984 	addi	r20,fp,-154
81114dac:	d8801115 	stw	r2,68(sp)
81114db0:	dcc01015 	stw	r19,64(sp)
81114db4:	dc800f15 	stw	r18,60(sp)
81114db8:	dc400e15 	stw	r17,56(sp)
81114dbc:	dc000d15 	stw	r16,52(sp)
81114dc0:	dbc00c15 	stw	r15,48(sp)
81114dc4:	db800b15 	stw	r14,44(sp)
81114dc8:	db400a15 	stw	r13,40(sp)
81114dcc:	db000915 	stw	r12,36(sp)
81114dd0:	dac00815 	stw	r11,32(sp)
81114dd4:	da800715 	stw	r10,28(sp)
81114dd8:	da400615 	stw	r9,24(sp)
81114ddc:	da000515 	stw	r8,20(sp)
81114de0:	d9c00415 	stw	r7,16(sp)
81114de4:	d9800315 	stw	r6,12(sp)
81114de8:	d9400215 	stw	r5,8(sp)
81114dec:	d9000115 	stw	r4,4(sp)
81114df0:	d8c00015 	stw	r3,0(sp)
81114df4:	a80f883a 	mov	r7,r21
81114df8:	018010c4 	movi	r6,67
81114dfc:	01604574 	movhi	r5,33045
81114e00:	2961e704 	addi	r5,r5,-30820
81114e04:	a009883a 	mov	r4,r20
81114e08:	111cd200 	call	8111cd20 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81114e0c:	e0bfd984 	addi	r2,fp,-154
81114e10:	1009883a 	mov	r4,r2
81114e14:	111cf340 	call	8111cf34 <strlen>
81114e18:	1007883a 	mov	r3,r2
81114e1c:	e0bfd984 	addi	r2,fp,-154
81114e20:	180b883a 	mov	r5,r3
81114e24:	1009883a 	mov	r4,r2
81114e28:	11164580 	call	81116458 <ucCrc8wInit>
81114e2c:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81114e30:	e13fd703 	ldbu	r4,-164(fp)
81114e34:	e0ffd984 	addi	r3,fp,-154
81114e38:	e0bfd984 	addi	r2,fp,-154
81114e3c:	200f883a 	mov	r7,r4
81114e40:	180d883a 	mov	r6,r3
81114e44:	01604574 	movhi	r5,33045
81114e48:	2961ff04 	addi	r5,r5,-30724
81114e4c:	1009883a 	mov	r4,r2
81114e50:	111cd200 	call	8111cd20 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81114e54:	e0bfd90b 	ldhu	r2,-156(fp)
81114e58:	10ffffcc 	andi	r3,r2,65535
81114e5c:	18e0001c 	xori	r3,r3,32768
81114e60:	18e00004 	addi	r3,r3,-32768
81114e64:	e0bfd984 	addi	r2,fp,-154
81114e68:	180b883a 	mov	r5,r3
81114e6c:	1009883a 	mov	r4,r2
81114e70:	11143480 	call	81114348 <bSendUART128v2>
81114e74:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
81114e78:	e0bfd817 	ldw	r2,-160(fp)
81114e7c:	10800060 	cmpeqi	r2,r2,1
81114e80:	1000011e 	bne	r2,zero,81114e88 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81114e84:	11170280 	call	81117028 <vCouldNotSendEthConfUART>
	}
}
81114e88:	0001883a 	nop
81114e8c:	e6fffa04 	addi	sp,fp,-24
81114e90:	dfc00717 	ldw	ra,28(sp)
81114e94:	df000617 	ldw	fp,24(sp)
81114e98:	dd400517 	ldw	r21,20(sp)
81114e9c:	dd000417 	ldw	r20,16(sp)
81114ea0:	dcc00317 	ldw	r19,12(sp)
81114ea4:	dc800217 	ldw	r18,8(sp)
81114ea8:	dc400117 	ldw	r17,4(sp)
81114eac:	dc000017 	ldw	r16,0(sp)
81114eb0:	dec00804 	addi	sp,sp,32
81114eb4:	f800283a 	ret

81114eb8 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81114eb8:	defff304 	addi	sp,sp,-52
81114ebc:	de00012e 	bgeu	sp,et,81114ec4 <vSendTurnOff+0xc>
81114ec0:	003b68fa 	trap	3
81114ec4:	dfc00c15 	stw	ra,48(sp)
81114ec8:	df000b15 	stw	fp,44(sp)
81114ecc:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81114ed0:	e03ff78d 	sth	zero,-34(fp)
81114ed4:	e03ff80d 	sth	zero,-32(fp)
81114ed8:	e03ff88d 	sth	zero,-30(fp)
81114edc:	e03ff90d 	sth	zero,-28(fp)
81114ee0:	e03ff98d 	sth	zero,-26(fp)
81114ee4:	e03ffa0d 	sth	zero,-24(fp)
81114ee8:	e03ffa8d 	sth	zero,-22(fp)
81114eec:	e03ffb0d 	sth	zero,-20(fp)
81114ef0:	e03ffb8d 	sth	zero,-18(fp)
81114ef4:	e03ffc0d 	sth	zero,-16(fp)
81114ef8:	e03ffc8d 	sth	zero,-14(fp)
81114efc:	e03ffd0d 	sth	zero,-12(fp)
81114f00:	e03ffd8d 	sth	zero,-10(fp)
81114f04:	e03ffe0d 	sth	zero,-8(fp)
81114f08:	e03ffe8d 	sth	zero,-6(fp)
81114f0c:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81114f10:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81114f14:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81114f18:	11151e80 	call	811151e8 <usiGetIdCMD>
81114f1c:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81114f20:	e0fff70b 	ldhu	r3,-36(fp)
81114f24:	e0bff784 	addi	r2,fp,-34
81114f28:	180d883a 	mov	r6,r3
81114f2c:	01604574 	movhi	r5,33045
81114f30:	29620204 	addi	r5,r5,-30712
81114f34:	1009883a 	mov	r4,r2
81114f38:	111cd200 	call	8111cd20 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81114f3c:	e0bff784 	addi	r2,fp,-34
81114f40:	1009883a 	mov	r4,r2
81114f44:	111cf340 	call	8111cf34 <strlen>
81114f48:	1007883a 	mov	r3,r2
81114f4c:	e0bff784 	addi	r2,fp,-34
81114f50:	180b883a 	mov	r5,r3
81114f54:	1009883a 	mov	r4,r2
81114f58:	11164580 	call	81116458 <ucCrc8wInit>
81114f5c:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81114f60:	e13ff503 	ldbu	r4,-44(fp)
81114f64:	e0fff784 	addi	r3,fp,-34
81114f68:	e0bff784 	addi	r2,fp,-34
81114f6c:	200f883a 	mov	r7,r4
81114f70:	180d883a 	mov	r6,r3
81114f74:	01604574 	movhi	r5,33045
81114f78:	2961ff04 	addi	r5,r5,-30724
81114f7c:	1009883a 	mov	r4,r2
81114f80:	111cd200 	call	8111cd20 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81114f84:	e0bff70b 	ldhu	r2,-36(fp)
81114f88:	10ffffcc 	andi	r3,r2,65535
81114f8c:	18e0001c 	xori	r3,r3,32768
81114f90:	18e00004 	addi	r3,r3,-32768
81114f94:	e0bff784 	addi	r2,fp,-34
81114f98:	180b883a 	mov	r5,r3
81114f9c:	1009883a 	mov	r4,r2
81114fa0:	11149300 	call	81114930 <bSendUART32v2>
81114fa4:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81114fa8:	e0bff617 	ldw	r2,-40(fp)
81114fac:	10800060 	cmpeqi	r2,r2,1
81114fb0:	1000011e 	bne	r2,zero,81114fb8 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81114fb4:	11176d00 	call	811176d0 <vCouldNotSendTurnOff>
	}
}
81114fb8:	0001883a 	nop
81114fbc:	e037883a 	mov	sp,fp
81114fc0:	dfc00117 	ldw	ra,4(sp)
81114fc4:	df000017 	ldw	fp,0(sp)
81114fc8:	dec00204 	addi	sp,sp,8
81114fcc:	f800283a 	ret

81114fd0 <vSendReset>:

void vSendReset ( void ) {
81114fd0:	defff304 	addi	sp,sp,-52
81114fd4:	de00012e 	bgeu	sp,et,81114fdc <vSendReset+0xc>
81114fd8:	003b68fa 	trap	3
81114fdc:	dfc00c15 	stw	ra,48(sp)
81114fe0:	df000b15 	stw	fp,44(sp)
81114fe4:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81114fe8:	e03ff78d 	sth	zero,-34(fp)
81114fec:	e03ff80d 	sth	zero,-32(fp)
81114ff0:	e03ff88d 	sth	zero,-30(fp)
81114ff4:	e03ff90d 	sth	zero,-28(fp)
81114ff8:	e03ff98d 	sth	zero,-26(fp)
81114ffc:	e03ffa0d 	sth	zero,-24(fp)
81115000:	e03ffa8d 	sth	zero,-22(fp)
81115004:	e03ffb0d 	sth	zero,-20(fp)
81115008:	e03ffb8d 	sth	zero,-18(fp)
8111500c:	e03ffc0d 	sth	zero,-16(fp)
81115010:	e03ffc8d 	sth	zero,-14(fp)
81115014:	e03ffd0d 	sth	zero,-12(fp)
81115018:	e03ffd8d 	sth	zero,-10(fp)
8111501c:	e03ffe0d 	sth	zero,-8(fp)
81115020:	e03ffe8d 	sth	zero,-6(fp)
81115024:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81115028:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111502c:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115030:	11151e80 	call	811151e8 <usiGetIdCMD>
81115034:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
81115038:	e0fff70b 	ldhu	r3,-36(fp)
8111503c:	e0bff784 	addi	r2,fp,-34
81115040:	180d883a 	mov	r6,r3
81115044:	01604574 	movhi	r5,33045
81115048:	29620404 	addi	r5,r5,-30704
8111504c:	1009883a 	mov	r4,r2
81115050:	111cd200 	call	8111cd20 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81115054:	e0bff784 	addi	r2,fp,-34
81115058:	1009883a 	mov	r4,r2
8111505c:	111cf340 	call	8111cf34 <strlen>
81115060:	1007883a 	mov	r3,r2
81115064:	e0bff784 	addi	r2,fp,-34
81115068:	180b883a 	mov	r5,r3
8111506c:	1009883a 	mov	r4,r2
81115070:	11164580 	call	81116458 <ucCrc8wInit>
81115074:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81115078:	e13ff503 	ldbu	r4,-44(fp)
8111507c:	e0fff784 	addi	r3,fp,-34
81115080:	e0bff784 	addi	r2,fp,-34
81115084:	200f883a 	mov	r7,r4
81115088:	180d883a 	mov	r6,r3
8111508c:	01604574 	movhi	r5,33045
81115090:	2961ff04 	addi	r5,r5,-30724
81115094:	1009883a 	mov	r4,r2
81115098:	111cd200 	call	8111cd20 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111509c:	e0bff70b 	ldhu	r2,-36(fp)
811150a0:	10ffffcc 	andi	r3,r2,65535
811150a4:	18e0001c 	xori	r3,r3,32768
811150a8:	18e00004 	addi	r3,r3,-32768
811150ac:	e0bff784 	addi	r2,fp,-34
811150b0:	180b883a 	mov	r5,r3
811150b4:	1009883a 	mov	r4,r2
811150b8:	11149300 	call	81114930 <bSendUART32v2>
811150bc:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
811150c0:	e0bff617 	ldw	r2,-40(fp)
811150c4:	10800060 	cmpeqi	r2,r2,1
811150c8:	1000011e 	bne	r2,zero,811150d0 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
811150cc:	11176d00 	call	811176d0 <vCouldNotSendTurnOff>
	}
}
811150d0:	0001883a 	nop
811150d4:	e037883a 	mov	sp,fp
811150d8:	dfc00117 	ldw	ra,4(sp)
811150dc:	df000017 	ldw	fp,0(sp)
811150e0:	dec00204 	addi	sp,sp,8
811150e4:	f800283a 	ret

811150e8 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
811150e8:	deffda04 	addi	sp,sp,-152
811150ec:	de00012e 	bgeu	sp,et,811150f4 <vSendLog+0xc>
811150f0:	003b68fa 	trap	3
811150f4:	dfc02515 	stw	ra,148(sp)
811150f8:	df002415 	stw	fp,144(sp)
811150fc:	df002404 	addi	fp,sp,144
81115100:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
81115104:	e03fde8d 	sth	zero,-134(fp)
81115108:	e03fdf0d 	sth	zero,-132(fp)
8111510c:	e0bfdf84 	addi	r2,fp,-130
81115110:	00c01f04 	movi	r3,124
81115114:	180d883a 	mov	r6,r3
81115118:	000b883a 	mov	r5,zero
8111511c:	1009883a 	mov	r4,r2
81115120:	111c5900 	call	8111c590 <memset>
    unsigned char crc = 0;
81115124:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115128:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111512c:	11151e80 	call	811151e8 <usiGetIdCMD>
81115130:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
81115134:	e0ffde0b 	ldhu	r3,-136(fp)
81115138:	e0bfde84 	addi	r2,fp,-134
8111513c:	e1ffff17 	ldw	r7,-4(fp)
81115140:	180d883a 	mov	r6,r3
81115144:	01604574 	movhi	r5,33045
81115148:	29620604 	addi	r5,r5,-30696
8111514c:	1009883a 	mov	r4,r2
81115150:	111cd200 	call	8111cd20 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
81115154:	e0bfde84 	addi	r2,fp,-134
81115158:	1009883a 	mov	r4,r2
8111515c:	111cf340 	call	8111cf34 <strlen>
81115160:	1007883a 	mov	r3,r2
81115164:	e0bfde84 	addi	r2,fp,-134
81115168:	180b883a 	mov	r5,r3
8111516c:	1009883a 	mov	r4,r2
81115170:	11164580 	call	81116458 <ucCrc8wInit>
81115174:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
81115178:	e13fdc03 	ldbu	r4,-144(fp)
8111517c:	e0ffde84 	addi	r3,fp,-134
81115180:	e0bfde84 	addi	r2,fp,-134
81115184:	200f883a 	mov	r7,r4
81115188:	180d883a 	mov	r6,r3
8111518c:	01604574 	movhi	r5,33045
81115190:	2961ff04 	addi	r5,r5,-30724
81115194:	1009883a 	mov	r4,r2
81115198:	111cd200 	call	8111cd20 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8111519c:	e0bfde0b 	ldhu	r2,-136(fp)
811151a0:	10ffffcc 	andi	r3,r2,65535
811151a4:	18e0001c 	xori	r3,r3,32768
811151a8:	18e00004 	addi	r3,r3,-32768
811151ac:	e0bfde84 	addi	r2,fp,-134
811151b0:	180b883a 	mov	r5,r3
811151b4:	1009883a 	mov	r4,r2
811151b8:	11143480 	call	81114348 <bSendUART128v2>
811151bc:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
811151c0:	e0bfdd17 	ldw	r2,-140(fp)
811151c4:	10800060 	cmpeqi	r2,r2,1
811151c8:	1000011e 	bne	r2,zero,811151d0 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
811151cc:	11177a00 	call	811177a0 <vCouldNotSendLog>
	}
}
811151d0:	0001883a 	nop
811151d4:	e037883a 	mov	sp,fp
811151d8:	dfc00117 	ldw	ra,4(sp)
811151dc:	df000017 	ldw	fp,0(sp)
811151e0:	dec00204 	addi	sp,sp,8
811151e4:	f800283a 	ret

811151e8 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
811151e8:	deffff04 	addi	sp,sp,-4
811151ec:	de00012e 	bgeu	sp,et,811151f4 <usiGetIdCMD+0xc>
811151f0:	003b68fa 	trap	3
811151f4:	df000015 	stw	fp,0(sp)
811151f8:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
811151fc:	d0a0620b 	ldhu	r2,-32376(gp)
81115200:	10ffffcc 	andi	r3,r2,65535
81115204:	00bfffd4 	movui	r2,65535
81115208:	1880031e 	bne	r3,r2,81115218 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8111520c:	00800084 	movi	r2,2
81115210:	d0a0620d 	sth	r2,-32376(gp)
81115214:	00000306 	br	81115224 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
81115218:	d0a0620b 	ldhu	r2,-32376(gp)
8111521c:	10800044 	addi	r2,r2,1
81115220:	d0a0620d 	sth	r2,-32376(gp)

    return usiIdCMD;
81115224:	d0a0620b 	ldhu	r2,-32376(gp)
}
81115228:	e037883a 	mov	sp,fp
8111522c:	df000017 	ldw	fp,0(sp)
81115230:	dec00104 	addi	sp,sp,4
81115234:	f800283a 	ret

81115238 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
81115238:	defffb04 	addi	sp,sp,-20
8111523c:	de00012e 	bgeu	sp,et,81115244 <siPosStr+0xc>
81115240:	003b68fa 	trap	3
81115244:	dfc00415 	stw	ra,16(sp)
81115248:	df000315 	stw	fp,12(sp)
8111524c:	df000304 	addi	fp,sp,12
81115250:	e13ffe15 	stw	r4,-8(fp)
81115254:	2805883a 	mov	r2,r5
81115258:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
8111525c:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
81115260:	e0bfff03 	ldbu	r2,-4(fp)
81115264:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
81115268:	e17ffd04 	addi	r5,fp,-12
8111526c:	e13ffe17 	ldw	r4,-8(fp)
81115270:	111cee80 	call	8111cee8 <strcspn>
}
81115274:	e037883a 	mov	sp,fp
81115278:	dfc00117 	ldw	ra,4(sp)
8111527c:	df000017 	ldw	fp,0(sp)
81115280:	dec00204 	addi	sp,sp,8
81115284:	f800283a 	ret

81115288 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
81115288:	defffc04 	addi	sp,sp,-16
8111528c:	de00012e 	bgeu	sp,et,81115294 <vTimeoutCheck+0xc>
81115290:	003b68fa 	trap	3
81115294:	dfc00315 	stw	ra,12(sp)
81115298:	df000215 	stw	fp,8(sp)
8111529c:	df000204 	addi	fp,sp,8
811152a0:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
811152a4:	d0a06117 	ldw	r2,-32380(gp)
811152a8:	1009883a 	mov	r4,r2
811152ac:	11397f40 	call	811397f4 <OSSemPost>
811152b0:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
811152b4:	e0bffe03 	ldbu	r2,-8(fp)
811152b8:	10000126 	beq	r2,zero,811152c0 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
811152bc:	11174600 	call	81117460 <vFailPostBlockingSemTimeoutTask>
	}
}
811152c0:	0001883a 	nop
811152c4:	e037883a 	mov	sp,fp
811152c8:	dfc00117 	ldw	ra,4(sp)
811152cc:	df000017 	ldw	fp,0(sp)
811152d0:	dec00204 	addi	sp,sp,8
811152d4:	f800283a 	ret

811152d8 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
811152d8:	deffe304 	addi	sp,sp,-116
811152dc:	de00012e 	bgeu	sp,et,811152e4 <vSendPusTM64+0xc>
811152e0:	003b68fa 	trap	3
811152e4:	dfc01815 	stw	ra,96(sp)
811152e8:	df001715 	stw	fp,92(sp)
811152ec:	df001704 	addi	fp,sp,92
811152f0:	e1000215 	stw	r4,8(fp)
811152f4:	e1400315 	stw	r5,12(fp)
811152f8:	e1800415 	stw	r6,16(fp)
811152fc:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81115300:	e03fef8d 	sth	zero,-66(fp)
81115304:	e03ff00d 	sth	zero,-64(fp)
81115308:	e0bff084 	addi	r2,fp,-62
8111530c:	00c00f04 	movi	r3,60
81115310:	180d883a 	mov	r6,r3
81115314:	000b883a 	mov	r5,zero
81115318:	1009883a 	mov	r4,r2
8111531c:	111c5900 	call	8111c590 <memset>
    unsigned char crc = 0;
81115320:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
81115324:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115328:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111532c:	11151e80 	call	811151e8 <usiGetIdCMD>
81115330:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81115334:	e1bfef0b 	ldhu	r6,-68(fp)
81115338:	e080040b 	ldhu	r2,16(fp)
8111533c:	11ffffcc 	andi	r7,r2,65535
81115340:	e080048b 	ldhu	r2,18(fp)
81115344:	10bfffcc 	andi	r2,r2,65535
81115348:	e0c0050b 	ldhu	r3,20(fp)
8111534c:	18ffffcc 	andi	r3,r3,65535
81115350:	e100058b 	ldhu	r4,22(fp)
81115354:	213fffcc 	andi	r4,r4,65535
81115358:	e140060b 	ldhu	r5,24(fp)
8111535c:	297fffcc 	andi	r5,r5,65535
81115360:	e23fef84 	addi	r8,fp,-66
81115364:	d9400315 	stw	r5,12(sp)
81115368:	d9000215 	stw	r4,8(sp)
8111536c:	d8c00115 	stw	r3,4(sp)
81115370:	d8800015 	stw	r2,0(sp)
81115374:	01604574 	movhi	r5,33045
81115378:	29620904 	addi	r5,r5,-30684
8111537c:	4009883a 	mov	r4,r8
81115380:	111cd200 	call	8111cd20 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81115384:	e03fed05 	stb	zero,-76(fp)
81115388:	00001206 	br	811153d4 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111538c:	e0bfed03 	ldbu	r2,-76(fp)
81115390:	10800284 	addi	r2,r2,10
81115394:	1085883a 	add	r2,r2,r2
81115398:	e0c00204 	addi	r3,fp,8
8111539c:	1885883a 	add	r2,r3,r2
811153a0:	1080000b 	ldhu	r2,0(r2)
811153a4:	113fffcc 	andi	r4,r2,65535
811153a8:	e0ffef84 	addi	r3,fp,-66
811153ac:	e0bfef84 	addi	r2,fp,-66
811153b0:	200f883a 	mov	r7,r4
811153b4:	180d883a 	mov	r6,r3
811153b8:	01604574 	movhi	r5,33045
811153bc:	29621004 	addi	r5,r5,-30656
811153c0:	1009883a 	mov	r4,r2
811153c4:	111cd200 	call	8111cd20 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811153c8:	e0bfed03 	ldbu	r2,-76(fp)
811153cc:	10800044 	addi	r2,r2,1
811153d0:	e0bfed05 	stb	r2,-76(fp)
811153d4:	e0800683 	ldbu	r2,26(fp)
811153d8:	10803fcc 	andi	r2,r2,255
811153dc:	e0ffed03 	ldbu	r3,-76(fp)
811153e0:	18bfea36 	bltu	r3,r2,8111538c <__reset+0xfb0f538c>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
811153e4:	e0bfef84 	addi	r2,fp,-66
811153e8:	1009883a 	mov	r4,r2
811153ec:	111cf340 	call	8111cf34 <strlen>
811153f0:	1007883a 	mov	r3,r2
811153f4:	e0bfef84 	addi	r2,fp,-66
811153f8:	180b883a 	mov	r5,r3
811153fc:	1009883a 	mov	r4,r2
81115400:	11164580 	call	81116458 <ucCrc8wInit>
81115404:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81115408:	e13fed43 	ldbu	r4,-75(fp)
8111540c:	e0ffef84 	addi	r3,fp,-66
81115410:	e0bfef84 	addi	r2,fp,-66
81115414:	200f883a 	mov	r7,r4
81115418:	180d883a 	mov	r6,r3
8111541c:	01604574 	movhi	r5,33045
81115420:	2961ff04 	addi	r5,r5,-30724
81115424:	1009883a 	mov	r4,r2
81115428:	111cd200 	call	8111cd20 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
8111542c:	e0bfef0b 	ldhu	r2,-68(fp)
81115430:	10ffffcc 	andi	r3,r2,65535
81115434:	18e0001c 	xori	r3,r3,32768
81115438:	18e00004 	addi	r3,r3,-32768
8111543c:	e0bfef84 	addi	r2,fp,-66
81115440:	180b883a 	mov	r5,r3
81115444:	1009883a 	mov	r4,r2
81115448:	11146380 	call	81114638 <bSendUART64v2>
8111544c:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
81115450:	e0bfee17 	ldw	r2,-72(fp)
81115454:	10800060 	cmpeqi	r2,r2,1
81115458:	1000031e 	bne	r2,zero,81115468 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111545c:	e0bfef84 	addi	r2,fp,-66
81115460:	1009883a 	mov	r4,r2
81115464:	11178080 	call	81117808 <vCouldNotSendTMPusCommand>
	}
}
81115468:	0001883a 	nop
8111546c:	e037883a 	mov	sp,fp
81115470:	dfc00117 	ldw	ra,4(sp)
81115474:	df000017 	ldw	fp,0(sp)
81115478:	dec00604 	addi	sp,sp,24
8111547c:	f800283a 	ret

81115480 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
81115480:	deffd304 	addi	sp,sp,-180
81115484:	de00012e 	bgeu	sp,et,8111548c <vSendPusTM128+0xc>
81115488:	003b68fa 	trap	3
8111548c:	dfc02815 	stw	ra,160(sp)
81115490:	df002715 	stw	fp,156(sp)
81115494:	df002704 	addi	fp,sp,156
81115498:	e1000215 	stw	r4,8(fp)
8111549c:	e1400315 	stw	r5,12(fp)
811154a0:	e1800415 	stw	r6,16(fp)
811154a4:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
811154a8:	e03fdf8d 	sth	zero,-130(fp)
811154ac:	e03fe00d 	sth	zero,-128(fp)
811154b0:	e0bfe084 	addi	r2,fp,-126
811154b4:	00c01f04 	movi	r3,124
811154b8:	180d883a 	mov	r6,r3
811154bc:	000b883a 	mov	r5,zero
811154c0:	1009883a 	mov	r4,r2
811154c4:	111c5900 	call	8111c590 <memset>
    unsigned char crc = 0;
811154c8:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
811154cc:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
811154d0:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
811154d4:	11151e80 	call	811151e8 <usiGetIdCMD>
811154d8:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
811154dc:	e1bfdf0b 	ldhu	r6,-132(fp)
811154e0:	e080040b 	ldhu	r2,16(fp)
811154e4:	11ffffcc 	andi	r7,r2,65535
811154e8:	e080048b 	ldhu	r2,18(fp)
811154ec:	10bfffcc 	andi	r2,r2,65535
811154f0:	e0c0050b 	ldhu	r3,20(fp)
811154f4:	18ffffcc 	andi	r3,r3,65535
811154f8:	e100058b 	ldhu	r4,22(fp)
811154fc:	213fffcc 	andi	r4,r4,65535
81115500:	e140060b 	ldhu	r5,24(fp)
81115504:	297fffcc 	andi	r5,r5,65535
81115508:	e23fdf84 	addi	r8,fp,-130
8111550c:	d9400315 	stw	r5,12(sp)
81115510:	d9000215 	stw	r4,8(sp)
81115514:	d8c00115 	stw	r3,4(sp)
81115518:	d8800015 	stw	r2,0(sp)
8111551c:	01604574 	movhi	r5,33045
81115520:	29620904 	addi	r5,r5,-30684
81115524:	4009883a 	mov	r4,r8
81115528:	111cd200 	call	8111cd20 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8111552c:	e03fdd05 	stb	zero,-140(fp)
81115530:	00001206 	br	8111557c <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81115534:	e0bfdd03 	ldbu	r2,-140(fp)
81115538:	10800284 	addi	r2,r2,10
8111553c:	1085883a 	add	r2,r2,r2
81115540:	e0c00204 	addi	r3,fp,8
81115544:	1885883a 	add	r2,r3,r2
81115548:	1080000b 	ldhu	r2,0(r2)
8111554c:	113fffcc 	andi	r4,r2,65535
81115550:	e0ffdf84 	addi	r3,fp,-130
81115554:	e0bfdf84 	addi	r2,fp,-130
81115558:	200f883a 	mov	r7,r4
8111555c:	180d883a 	mov	r6,r3
81115560:	01604574 	movhi	r5,33045
81115564:	29621004 	addi	r5,r5,-30656
81115568:	1009883a 	mov	r4,r2
8111556c:	111cd200 	call	8111cd20 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81115570:	e0bfdd03 	ldbu	r2,-140(fp)
81115574:	10800044 	addi	r2,r2,1
81115578:	e0bfdd05 	stb	r2,-140(fp)
8111557c:	e0800683 	ldbu	r2,26(fp)
81115580:	10803fcc 	andi	r2,r2,255
81115584:	e0ffdd03 	ldbu	r3,-140(fp)
81115588:	18bfea36 	bltu	r3,r2,81115534 <__reset+0xfb0f5534>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111558c:	e0bfdf84 	addi	r2,fp,-130
81115590:	1009883a 	mov	r4,r2
81115594:	111cf340 	call	8111cf34 <strlen>
81115598:	1007883a 	mov	r3,r2
8111559c:	e0bfdf84 	addi	r2,fp,-130
811155a0:	180b883a 	mov	r5,r3
811155a4:	1009883a 	mov	r4,r2
811155a8:	11164580 	call	81116458 <ucCrc8wInit>
811155ac:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
811155b0:	e13fdd43 	ldbu	r4,-139(fp)
811155b4:	e0ffdf84 	addi	r3,fp,-130
811155b8:	e0bfdf84 	addi	r2,fp,-130
811155bc:	200f883a 	mov	r7,r4
811155c0:	180d883a 	mov	r6,r3
811155c4:	01604574 	movhi	r5,33045
811155c8:	2961ff04 	addi	r5,r5,-30724
811155cc:	1009883a 	mov	r4,r2
811155d0:	111cd200 	call	8111cd20 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
811155d4:	e0bfdf0b 	ldhu	r2,-132(fp)
811155d8:	10ffffcc 	andi	r3,r2,65535
811155dc:	18e0001c 	xori	r3,r3,32768
811155e0:	18e00004 	addi	r3,r3,-32768
811155e4:	e0bfdf84 	addi	r2,fp,-130
811155e8:	180b883a 	mov	r5,r3
811155ec:	1009883a 	mov	r4,r2
811155f0:	11143480 	call	81114348 <bSendUART128v2>
811155f4:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
811155f8:	e0bfde17 	ldw	r2,-136(fp)
811155fc:	10800060 	cmpeqi	r2,r2,1
81115600:	1000031e 	bne	r2,zero,81115610 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81115604:	e0bfdf84 	addi	r2,fp,-130
81115608:	1009883a 	mov	r4,r2
8111560c:	11178080 	call	81117808 <vCouldNotSendTMPusCommand>
	}
}
81115610:	0001883a 	nop
81115614:	e037883a 	mov	sp,fp
81115618:	dfc00117 	ldw	ra,4(sp)
8111561c:	df000017 	ldw	fp,0(sp)
81115620:	dec00604 	addi	sp,sp,24
81115624:	f800283a 	ret

81115628 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
81115628:	deffd704 	addi	sp,sp,-164
8111562c:	de00012e 	bgeu	sp,et,81115634 <vTMPusTestConnection+0xc>
81115630:	003b68fa 	trap	3
81115634:	dfc02815 	stw	ra,160(sp)
81115638:	df002715 	stw	fp,156(sp)
8111563c:	df002704 	addi	fp,sp,156
81115640:	2005883a 	mov	r2,r4
81115644:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
81115648:	e0bfff0b 	ldhu	r2,-4(fp)
8111564c:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81115650:	00801c04 	movi	r2,112
81115654:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
81115658:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
8111565c:	00800444 	movi	r2,17
81115660:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81115664:	00800084 	movi	r2,2
81115668:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
8111566c:	d809883a 	mov	r4,sp
81115670:	e0bfee04 	addi	r2,fp,-72
81115674:	00c01104 	movi	r3,68
81115678:	180d883a 	mov	r6,r3
8111567c:	100b883a 	mov	r5,r2
81115680:	111c4400 	call	8111c440 <memcpy>
81115684:	e13fea17 	ldw	r4,-88(fp)
81115688:	e17feb17 	ldw	r5,-84(fp)
8111568c:	e1bfec17 	ldw	r6,-80(fp)
81115690:	e1ffed17 	ldw	r7,-76(fp)
81115694:	11152d80 	call	811152d8 <vSendPusTM64>
}
81115698:	0001883a 	nop
8111569c:	e037883a 	mov	sp,fp
811156a0:	dfc00117 	ldw	ra,4(sp)
811156a4:	df000017 	ldw	fp,0(sp)
811156a8:	dec00204 	addi	sp,sp,8
811156ac:	f800283a 	ret

811156b0 <vLoadDefaultETHConf>:

/*Configuration related to the eth connection*/
TConfEth xConfEth;


bool vLoadDefaultETHConf( void ){
811156b0:	defff504 	addi	sp,sp,-44
811156b4:	de00012e 	bgeu	sp,et,811156bc <vLoadDefaultETHConf+0xc>
811156b8:	003b68fa 	trap	3
811156bc:	dfc00a15 	stw	ra,40(sp)
811156c0:	df000915 	stw	fp,36(sp)
811156c4:	dc000815 	stw	r16,32(sp)
811156c8:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
811156cc:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
811156d0:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
811156d4:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
811156d8:	d0a07017 	ldw	r2,-32320(gp)
811156dc:	10800058 	cmpnei	r2,r2,1
811156e0:	1002041e 	bne	r2,zero,81115ef4 <vLoadDefaultETHConf+0x844>
811156e4:	11194140 	call	81119414 <bSDcardIsPresent>
811156e8:	10020226 	beq	r2,zero,81115ef4 <vLoadDefaultETHConf+0x844>
811156ec:	11194440 	call	81119444 <bSDcardFAT16Check>
811156f0:	10020026 	beq	r2,zero,81115ef4 <vLoadDefaultETHConf+0x844>

		siFile = siOpenFile( ETH_FILE_NAME );
811156f4:	01204574 	movhi	r4,33045
811156f8:	21221204 	addi	r4,r4,-30648
811156fc:	111956c0 	call	8111956c <siOpenFile>
81115700:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81115704:	e0bffc0f 	ldh	r2,-16(fp)
81115708:	1001f216 	blt	r2,zero,81115ed4 <vLoadDefaultETHConf+0x824>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111570c:	e0bffd04 	addi	r2,fp,-12
81115710:	01800204 	movi	r6,8
81115714:	01400284 	movi	r5,10
81115718:	1009883a 	mov	r4,r2
8111571c:	111c5900 	call	8111c590 <memset>
			p_inteiro = inteiro;
81115720:	e0bffd04 	addi	r2,fp,-12
81115724:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81115728:	e0bffc0f 	ldh	r2,-16(fp)
8111572c:	1009883a 	mov	r4,r2
81115730:	11195e80 	call	811195e8 <cGetNextChar>
81115734:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81115738:	e0bff947 	ldb	r2,-27(fp)
8111573c:	10800084 	addi	r2,r2,2
81115740:	10c015a8 	cmpgeui	r3,r2,86
81115744:	1801d71e 	bne	r3,zero,81115ea4 <vLoadDefaultETHConf+0x7f4>
81115748:	100690ba 	slli	r3,r2,2
8111574c:	00a04474 	movhi	r2,33041
81115750:	1095d804 	addi	r2,r2,22368
81115754:	1885883a 	add	r2,r3,r2
81115758:	10800017 	ldw	r2,0(r2)
8111575c:	1000683a 	jmp	r2
81115760:	811158f8 	rdprs	r4,r16,17763
81115764:	811158ec 	andhi	r4,r16,17763
81115768:	81115ea4 	muli	r4,r16,17786
8111576c:	81115ea4 	muli	r4,r16,17786
81115770:	81115ea4 	muli	r4,r16,17786
81115774:	81115ea4 	muli	r4,r16,17786
81115778:	81115ea4 	muli	r4,r16,17786
8111577c:	81115ea4 	muli	r4,r16,17786
81115780:	81115ea4 	muli	r4,r16,17786
81115784:	81115ea4 	muli	r4,r16,17786
81115788:	81115ea4 	muli	r4,r16,17786
8111578c:	81115ea4 	muli	r4,r16,17786
81115790:	81115ec4 	addi	r4,r16,17787
81115794:	81115ea4 	muli	r4,r16,17786
81115798:	81115ea4 	muli	r4,r16,17786
8111579c:	81115ec4 	addi	r4,r16,17787
811157a0:	81115ea4 	muli	r4,r16,17786
811157a4:	81115ea4 	muli	r4,r16,17786
811157a8:	81115ea4 	muli	r4,r16,17786
811157ac:	81115ea4 	muli	r4,r16,17786
811157b0:	81115ea4 	muli	r4,r16,17786
811157b4:	81115ea4 	muli	r4,r16,17786
811157b8:	81115ea4 	muli	r4,r16,17786
811157bc:	81115ea4 	muli	r4,r16,17786
811157c0:	81115ea4 	muli	r4,r16,17786
811157c4:	81115ea4 	muli	r4,r16,17786
811157c8:	81115ea4 	muli	r4,r16,17786
811157cc:	81115ea4 	muli	r4,r16,17786
811157d0:	81115ea4 	muli	r4,r16,17786
811157d4:	81115ea4 	muli	r4,r16,17786
811157d8:	81115ea4 	muli	r4,r16,17786
811157dc:	81115ea4 	muli	r4,r16,17786
811157e0:	81115ea4 	muli	r4,r16,17786
811157e4:	81115ea4 	muli	r4,r16,17786
811157e8:	81115ec4 	addi	r4,r16,17787
811157ec:	81115ea4 	muli	r4,r16,17786
811157f0:	81115ea4 	muli	r4,r16,17786
811157f4:	81115ea4 	muli	r4,r16,17786
811157f8:	81115ea4 	muli	r4,r16,17786
811157fc:	81115ea4 	muli	r4,r16,17786
81115800:	81115ea4 	muli	r4,r16,17786
81115804:	811158b8 	rdprs	r4,r16,17762
81115808:	81115ea4 	muli	r4,r16,17786
8111580c:	81115ea4 	muli	r4,r16,17786
81115810:	81115ea4 	muli	r4,r16,17786
81115814:	81115ea4 	muli	r4,r16,17786
81115818:	81115ea4 	muli	r4,r16,17786
8111581c:	81115ea4 	muli	r4,r16,17786
81115820:	81115ea4 	muli	r4,r16,17786
81115824:	81115ea4 	muli	r4,r16,17786
81115828:	81115ea4 	muli	r4,r16,17786
8111582c:	81115ea4 	muli	r4,r16,17786
81115830:	81115ea4 	muli	r4,r16,17786
81115834:	81115ea4 	muli	r4,r16,17786
81115838:	81115ea4 	muli	r4,r16,17786
8111583c:	81115ea4 	muli	r4,r16,17786
81115840:	81115ea4 	muli	r4,r16,17786
81115844:	81115ea4 	muli	r4,r16,17786
81115848:	81115ea4 	muli	r4,r16,17786
8111584c:	81115ea4 	muli	r4,r16,17786
81115850:	81115ea4 	muli	r4,r16,17786
81115854:	81115ea4 	muli	r4,r16,17786
81115858:	81115e5c 	xori	r4,r16,17785
8111585c:	81115ea4 	muli	r4,r16,17786
81115860:	81115ea4 	muli	r4,r16,17786
81115864:	81115ea4 	muli	r4,r16,17786
81115868:	81115ea4 	muli	r4,r16,17786
8111586c:	81115ea4 	muli	r4,r16,17786
81115870:	81115ea4 	muli	r4,r16,17786
81115874:	81115ea4 	muli	r4,r16,17786
81115878:	81115c5c 	xori	r4,r16,17777
8111587c:	81115ea4 	muli	r4,r16,17786
81115880:	81115ea4 	muli	r4,r16,17786
81115884:	81115abc 	xorhi	r4,r16,17770
81115888:	81115db4 	orhi	r4,r16,17782
8111588c:	811159f0 	cmpltui	r4,r16,17767
81115890:	81115ea4 	muli	r4,r16,17786
81115894:	81115ea4 	muli	r4,r16,17786
81115898:	81115ea4 	muli	r4,r16,17786
8111589c:	81115920 	cmpeqi	r4,r16,17764
811158a0:	81115ea4 	muli	r4,r16,17786
811158a4:	81115ea4 	muli	r4,r16,17786
811158a8:	81115d2c 	andhi	r4,r16,17780
811158ac:	81115ea4 	muli	r4,r16,17786
811158b0:	81115ea4 	muli	r4,r16,17786
811158b4:	81115b8c 	andi	r4,r16,17774
					case 39:// single quote '
						c = cGetNextChar(siFile);
811158b8:	e0bffc0f 	ldh	r2,-16(fp)
811158bc:	1009883a 	mov	r4,r2
811158c0:	11195e80 	call	811195e8 <cGetNextChar>
811158c4:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
811158c8:	00000406 	br	811158dc <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
811158cc:	e0bffc0f 	ldh	r2,-16(fp)
811158d0:	1009883a 	mov	r4,r2
811158d4:	11195e80 	call	811195e8 <cGetNextChar>
811158d8:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
811158dc:	e0bff947 	ldb	r2,-27(fp)
811158e0:	108009d8 	cmpnei	r2,r2,39
811158e4:	103ff91e 	bne	r2,zero,811158cc <__reset+0xfb0f58cc>
							c = cGetNextChar(siFile);
						}
						break;
811158e8:	00017706 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case -1: 	//EOF
						bEOF = TRUE;
811158ec:	00800044 	movi	r2,1
811158f0:	e0bff815 	stw	r2,-32(fp)
						break;
811158f4:	00017406 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
811158f8:	d0a05c17 	ldw	r2,-32400(gp)
811158fc:	100f883a 	mov	r7,r2
81115900:	018006c4 	movi	r6,27
81115904:	01400044 	movi	r5,1
81115908:	01204574 	movhi	r4,33045
8111590c:	21221404 	addi	r4,r4,-30640
81115910:	111ba2c0 	call	8111ba2c <fwrite>
						#endif
						bEOF = TRUE;
81115914:	00800044 	movi	r2,1
81115918:	e0bff815 	stw	r2,-32(fp)
						break;
8111591c:	00016a06 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81115920:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115924:	e0bffc0f 	ldh	r2,-16(fp)
81115928:	1009883a 	mov	r4,r2
8111592c:	11195e80 	call	811195e8 <cGetNextChar>
81115930:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115934:	d0e00317 	ldw	r3,-32756(gp)
81115938:	e0bff947 	ldb	r2,-27(fp)
8111593c:	10800044 	addi	r2,r2,1
81115940:	1885883a 	add	r2,r3,r2
81115944:	10800003 	ldbu	r2,0(r2)
81115948:	10803fcc 	andi	r2,r2,255
8111594c:	1080010c 	andi	r2,r2,4
81115950:	10000626 	beq	r2,zero,8111596c <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
81115954:	e0bffa17 	ldw	r2,-24(fp)
81115958:	e0fff943 	ldbu	r3,-27(fp)
8111595c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115960:	e0bffa17 	ldw	r2,-24(fp)
81115964:	10800044 	addi	r2,r2,1
81115968:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8111596c:	e0bff947 	ldb	r2,-27(fp)
81115970:	10800ea0 	cmpeqi	r2,r2,58
81115974:	1000031e 	bne	r2,zero,81115984 <vLoadDefaultETHConf+0x2d4>
81115978:	e0bff947 	ldb	r2,-27(fp)
8111597c:	10800ed8 	cmpnei	r2,r2,59
81115980:	103fe81e 	bne	r2,zero,81115924 <__reset+0xfb0f5924>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115984:	e0bffa17 	ldw	r2,-24(fp)
81115988:	00c00284 	movi	r3,10
8111598c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
81115990:	e0bff903 	ldbu	r2,-28(fp)
81115994:	10800168 	cmpgeui	r2,r2,5
81115998:	1000021e 	bne	r2,zero,811159a4 <vLoadDefaultETHConf+0x2f4>
8111599c:	e43ff903 	ldbu	r16,-28(fp)
811159a0:	00000106 	br	811159a8 <vLoadDefaultETHConf+0x2f8>
811159a4:	04000144 	movi	r16,5
811159a8:	e0bffd04 	addi	r2,fp,-12
811159ac:	1009883a 	mov	r4,r2
811159b0:	111b2340 	call	8111b234 <atoi>
811159b4:	1007883a 	mov	r3,r2
811159b8:	00a045b4 	movhi	r2,33046
811159bc:	10817804 	addi	r2,r2,1504
811159c0:	1405883a 	add	r2,r2,r16
811159c4:	10800404 	addi	r2,r2,16
811159c8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811159cc:	e0bffd04 	addi	r2,fp,-12
811159d0:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811159d4:	e0bff903 	ldbu	r2,-28(fp)
811159d8:	10800044 	addi	r2,r2,1
811159dc:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811159e0:	e0bff947 	ldb	r2,-27(fp)
811159e4:	10800ed8 	cmpnei	r2,r2,59
811159e8:	103fce1e 	bne	r2,zero,81115924 <__reset+0xfb0f5924>

						break;
811159ec:	00013606 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case 'I':

						ucParser = 0;
811159f0:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811159f4:	e0bffc0f 	ldh	r2,-16(fp)
811159f8:	1009883a 	mov	r4,r2
811159fc:	11195e80 	call	811195e8 <cGetNextChar>
81115a00:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115a04:	d0e00317 	ldw	r3,-32756(gp)
81115a08:	e0bff947 	ldb	r2,-27(fp)
81115a0c:	10800044 	addi	r2,r2,1
81115a10:	1885883a 	add	r2,r3,r2
81115a14:	10800003 	ldbu	r2,0(r2)
81115a18:	10803fcc 	andi	r2,r2,255
81115a1c:	1080010c 	andi	r2,r2,4
81115a20:	10000626 	beq	r2,zero,81115a3c <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
81115a24:	e0bffa17 	ldw	r2,-24(fp)
81115a28:	e0fff943 	ldbu	r3,-27(fp)
81115a2c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115a30:	e0bffa17 	ldw	r2,-24(fp)
81115a34:	10800044 	addi	r2,r2,1
81115a38:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115a3c:	e0bff947 	ldb	r2,-27(fp)
81115a40:	10800ba0 	cmpeqi	r2,r2,46
81115a44:	1000031e 	bne	r2,zero,81115a54 <vLoadDefaultETHConf+0x3a4>
81115a48:	e0bff947 	ldb	r2,-27(fp)
81115a4c:	10800ed8 	cmpnei	r2,r2,59
81115a50:	103fe81e 	bne	r2,zero,811159f4 <__reset+0xfb0f59f4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115a54:	e0bffa17 	ldw	r2,-24(fp)
81115a58:	00c00284 	movi	r3,10
81115a5c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81115a60:	e0bff903 	ldbu	r2,-28(fp)
81115a64:	108000e8 	cmpgeui	r2,r2,3
81115a68:	1000021e 	bne	r2,zero,81115a74 <vLoadDefaultETHConf+0x3c4>
81115a6c:	e43ff903 	ldbu	r16,-28(fp)
81115a70:	00000106 	br	81115a78 <vLoadDefaultETHConf+0x3c8>
81115a74:	040000c4 	movi	r16,3
81115a78:	e0bffd04 	addi	r2,fp,-12
81115a7c:	1009883a 	mov	r4,r2
81115a80:	111b2340 	call	8111b234 <atoi>
81115a84:	1007883a 	mov	r3,r2
81115a88:	00a045b4 	movhi	r2,33046
81115a8c:	10817804 	addi	r2,r2,1504
81115a90:	1405883a 	add	r2,r2,r16
81115a94:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115a98:	e0bffd04 	addi	r2,fp,-12
81115a9c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81115aa0:	e0bff903 	ldbu	r2,-28(fp)
81115aa4:	10800044 	addi	r2,r2,1
81115aa8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81115aac:	e0bff947 	ldb	r2,-27(fp)
81115ab0:	10800ed8 	cmpnei	r2,r2,59
81115ab4:	103fcf1e 	bne	r2,zero,811159f4 <__reset+0xfb0f59f4>

						break;
81115ab8:	00010306 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case 'G':

						ucParser = 0;
81115abc:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115ac0:	e0bffc0f 	ldh	r2,-16(fp)
81115ac4:	1009883a 	mov	r4,r2
81115ac8:	11195e80 	call	811195e8 <cGetNextChar>
81115acc:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115ad0:	d0e00317 	ldw	r3,-32756(gp)
81115ad4:	e0bff947 	ldb	r2,-27(fp)
81115ad8:	10800044 	addi	r2,r2,1
81115adc:	1885883a 	add	r2,r3,r2
81115ae0:	10800003 	ldbu	r2,0(r2)
81115ae4:	10803fcc 	andi	r2,r2,255
81115ae8:	1080010c 	andi	r2,r2,4
81115aec:	10000626 	beq	r2,zero,81115b08 <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81115af0:	e0bffa17 	ldw	r2,-24(fp)
81115af4:	e0fff943 	ldbu	r3,-27(fp)
81115af8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115afc:	e0bffa17 	ldw	r2,-24(fp)
81115b00:	10800044 	addi	r2,r2,1
81115b04:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115b08:	e0bff947 	ldb	r2,-27(fp)
81115b0c:	10800ba0 	cmpeqi	r2,r2,46
81115b10:	1000031e 	bne	r2,zero,81115b20 <vLoadDefaultETHConf+0x470>
81115b14:	e0bff947 	ldb	r2,-27(fp)
81115b18:	10800ed8 	cmpnei	r2,r2,59
81115b1c:	103fe81e 	bne	r2,zero,81115ac0 <__reset+0xfb0f5ac0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115b20:	e0bffa17 	ldw	r2,-24(fp)
81115b24:	00c00284 	movi	r3,10
81115b28:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
81115b2c:	e0bff903 	ldbu	r2,-28(fp)
81115b30:	108000e8 	cmpgeui	r2,r2,3
81115b34:	1000021e 	bne	r2,zero,81115b40 <vLoadDefaultETHConf+0x490>
81115b38:	e43ff903 	ldbu	r16,-28(fp)
81115b3c:	00000106 	br	81115b44 <vLoadDefaultETHConf+0x494>
81115b40:	040000c4 	movi	r16,3
81115b44:	e0bffd04 	addi	r2,fp,-12
81115b48:	1009883a 	mov	r4,r2
81115b4c:	111b2340 	call	8111b234 <atoi>
81115b50:	1007883a 	mov	r3,r2
81115b54:	00a045b4 	movhi	r2,33046
81115b58:	10817804 	addi	r2,r2,1504
81115b5c:	1405883a 	add	r2,r2,r16
81115b60:	10800104 	addi	r2,r2,4
81115b64:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115b68:	e0bffd04 	addi	r2,fp,-12
81115b6c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81115b70:	e0bff903 	ldbu	r2,-28(fp)
81115b74:	10800044 	addi	r2,r2,1
81115b78:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81115b7c:	e0bff947 	ldb	r2,-27(fp)
81115b80:	10800ed8 	cmpnei	r2,r2,59
81115b84:	103fce1e 	bne	r2,zero,81115ac0 <__reset+0xfb0f5ac0>

						break;
81115b88:	0000cf06 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case 'S':

						ucParser = 0;
81115b8c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115b90:	e0bffc0f 	ldh	r2,-16(fp)
81115b94:	1009883a 	mov	r4,r2
81115b98:	11195e80 	call	811195e8 <cGetNextChar>
81115b9c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115ba0:	d0e00317 	ldw	r3,-32756(gp)
81115ba4:	e0bff947 	ldb	r2,-27(fp)
81115ba8:	10800044 	addi	r2,r2,1
81115bac:	1885883a 	add	r2,r3,r2
81115bb0:	10800003 	ldbu	r2,0(r2)
81115bb4:	10803fcc 	andi	r2,r2,255
81115bb8:	1080010c 	andi	r2,r2,4
81115bbc:	10000626 	beq	r2,zero,81115bd8 <vLoadDefaultETHConf+0x528>
									(*p_inteiro) = c;
81115bc0:	e0bffa17 	ldw	r2,-24(fp)
81115bc4:	e0fff943 	ldbu	r3,-27(fp)
81115bc8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115bcc:	e0bffa17 	ldw	r2,-24(fp)
81115bd0:	10800044 	addi	r2,r2,1
81115bd4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115bd8:	e0bff947 	ldb	r2,-27(fp)
81115bdc:	10800ba0 	cmpeqi	r2,r2,46
81115be0:	1000031e 	bne	r2,zero,81115bf0 <vLoadDefaultETHConf+0x540>
81115be4:	e0bff947 	ldb	r2,-27(fp)
81115be8:	10800ed8 	cmpnei	r2,r2,59
81115bec:	103fe81e 	bne	r2,zero,81115b90 <__reset+0xfb0f5b90>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115bf0:	e0bffa17 	ldw	r2,-24(fp)
81115bf4:	00c00284 	movi	r3,10
81115bf8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81115bfc:	e0bff903 	ldbu	r2,-28(fp)
81115c00:	108000e8 	cmpgeui	r2,r2,3
81115c04:	1000021e 	bne	r2,zero,81115c10 <vLoadDefaultETHConf+0x560>
81115c08:	e43ff903 	ldbu	r16,-28(fp)
81115c0c:	00000106 	br	81115c14 <vLoadDefaultETHConf+0x564>
81115c10:	040000c4 	movi	r16,3
81115c14:	e0bffd04 	addi	r2,fp,-12
81115c18:	1009883a 	mov	r4,r2
81115c1c:	111b2340 	call	8111b234 <atoi>
81115c20:	1007883a 	mov	r3,r2
81115c24:	00a045b4 	movhi	r2,33046
81115c28:	10817804 	addi	r2,r2,1504
81115c2c:	1405883a 	add	r2,r2,r16
81115c30:	10800204 	addi	r2,r2,8
81115c34:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115c38:	e0bffd04 	addi	r2,fp,-12
81115c3c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81115c40:	e0bff903 	ldbu	r2,-28(fp)
81115c44:	10800044 	addi	r2,r2,1
81115c48:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81115c4c:	e0bff947 	ldb	r2,-27(fp)
81115c50:	10800ed8 	cmpnei	r2,r2,59
81115c54:	103fce1e 	bne	r2,zero,81115b90 <__reset+0xfb0f5b90>

						break;
81115c58:	00009b06 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case 'D':

						ucParser = 0;
81115c5c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115c60:	e0bffc0f 	ldh	r2,-16(fp)
81115c64:	1009883a 	mov	r4,r2
81115c68:	11195e80 	call	811195e8 <cGetNextChar>
81115c6c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115c70:	d0e00317 	ldw	r3,-32756(gp)
81115c74:	e0bff947 	ldb	r2,-27(fp)
81115c78:	10800044 	addi	r2,r2,1
81115c7c:	1885883a 	add	r2,r3,r2
81115c80:	10800003 	ldbu	r2,0(r2)
81115c84:	10803fcc 	andi	r2,r2,255
81115c88:	1080010c 	andi	r2,r2,4
81115c8c:	10000626 	beq	r2,zero,81115ca8 <vLoadDefaultETHConf+0x5f8>
									(*p_inteiro) = c;
81115c90:	e0bffa17 	ldw	r2,-24(fp)
81115c94:	e0fff943 	ldbu	r3,-27(fp)
81115c98:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115c9c:	e0bffa17 	ldw	r2,-24(fp)
81115ca0:	10800044 	addi	r2,r2,1
81115ca4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115ca8:	e0bff947 	ldb	r2,-27(fp)
81115cac:	10800ba0 	cmpeqi	r2,r2,46
81115cb0:	1000031e 	bne	r2,zero,81115cc0 <vLoadDefaultETHConf+0x610>
81115cb4:	e0bff947 	ldb	r2,-27(fp)
81115cb8:	10800ed8 	cmpnei	r2,r2,59
81115cbc:	103fe81e 	bne	r2,zero,81115c60 <__reset+0xfb0f5c60>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115cc0:	e0bffa17 	ldw	r2,-24(fp)
81115cc4:	00c00284 	movi	r3,10
81115cc8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
81115ccc:	e0bff903 	ldbu	r2,-28(fp)
81115cd0:	108000e8 	cmpgeui	r2,r2,3
81115cd4:	1000021e 	bne	r2,zero,81115ce0 <vLoadDefaultETHConf+0x630>
81115cd8:	e43ff903 	ldbu	r16,-28(fp)
81115cdc:	00000106 	br	81115ce4 <vLoadDefaultETHConf+0x634>
81115ce0:	040000c4 	movi	r16,3
81115ce4:	e0bffd04 	addi	r2,fp,-12
81115ce8:	1009883a 	mov	r4,r2
81115cec:	111b2340 	call	8111b234 <atoi>
81115cf0:	1007883a 	mov	r3,r2
81115cf4:	00a045b4 	movhi	r2,33046
81115cf8:	10817804 	addi	r2,r2,1504
81115cfc:	1405883a 	add	r2,r2,r16
81115d00:	10800304 	addi	r2,r2,12
81115d04:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115d08:	e0bffd04 	addi	r2,fp,-12
81115d0c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81115d10:	e0bff903 	ldbu	r2,-28(fp)
81115d14:	10800044 	addi	r2,r2,1
81115d18:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81115d1c:	e0bff947 	ldb	r2,-27(fp)
81115d20:	10800ed8 	cmpnei	r2,r2,59
81115d24:	103fce1e 	bne	r2,zero,81115c60 <__reset+0xfb0f5c60>

						break;						
81115d28:	00006706 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case 'P':

						do {
							c = cGetNextChar(siFile);
81115d2c:	e0bffc0f 	ldh	r2,-16(fp)
81115d30:	1009883a 	mov	r4,r2
81115d34:	11195e80 	call	811195e8 <cGetNextChar>
81115d38:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81115d3c:	d0e00317 	ldw	r3,-32756(gp)
81115d40:	e0bff947 	ldb	r2,-27(fp)
81115d44:	10800044 	addi	r2,r2,1
81115d48:	1885883a 	add	r2,r3,r2
81115d4c:	10800003 	ldbu	r2,0(r2)
81115d50:	10803fcc 	andi	r2,r2,255
81115d54:	1080010c 	andi	r2,r2,4
81115d58:	10000626 	beq	r2,zero,81115d74 <vLoadDefaultETHConf+0x6c4>
								(*p_inteiro) = c;
81115d5c:	e0bffa17 	ldw	r2,-24(fp)
81115d60:	e0fff943 	ldbu	r3,-27(fp)
81115d64:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81115d68:	e0bffa17 	ldw	r2,-24(fp)
81115d6c:	10800044 	addi	r2,r2,1
81115d70:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81115d74:	e0bff947 	ldb	r2,-27(fp)
81115d78:	10800ed8 	cmpnei	r2,r2,59
81115d7c:	103feb1e 	bne	r2,zero,81115d2c <__reset+0xfb0f5d2c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115d80:	e0bffa17 	ldw	r2,-24(fp)
81115d84:	00c00284 	movi	r3,10
81115d88:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
81115d8c:	e0bffd04 	addi	r2,fp,-12
81115d90:	1009883a 	mov	r4,r2
81115d94:	111b2340 	call	8111b234 <atoi>
81115d98:	1007883a 	mov	r3,r2
81115d9c:	00a045b4 	movhi	r2,33046
81115da0:	10817804 	addi	r2,r2,1504
81115da4:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81115da8:	e0bffd04 	addi	r2,fp,-12
81115dac:	e0bffa15 	stw	r2,-24(fp)

						break;
81115db0:	00004506 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case 'H':

						do {
							c = cGetNextChar(siFile);
81115db4:	e0bffc0f 	ldh	r2,-16(fp)
81115db8:	1009883a 	mov	r4,r2
81115dbc:	11195e80 	call	811195e8 <cGetNextChar>
81115dc0:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81115dc4:	d0e00317 	ldw	r3,-32756(gp)
81115dc8:	e0bff947 	ldb	r2,-27(fp)
81115dcc:	10800044 	addi	r2,r2,1
81115dd0:	1885883a 	add	r2,r3,r2
81115dd4:	10800003 	ldbu	r2,0(r2)
81115dd8:	10803fcc 	andi	r2,r2,255
81115ddc:	1080010c 	andi	r2,r2,4
81115de0:	10000626 	beq	r2,zero,81115dfc <vLoadDefaultETHConf+0x74c>
								(*p_inteiro) = c;
81115de4:	e0bffa17 	ldw	r2,-24(fp)
81115de8:	e0fff943 	ldbu	r3,-27(fp)
81115dec:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81115df0:	e0bffa17 	ldw	r2,-24(fp)
81115df4:	10800044 	addi	r2,r2,1
81115df8:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81115dfc:	e0bff947 	ldb	r2,-27(fp)
81115e00:	10800ed8 	cmpnei	r2,r2,59
81115e04:	103feb1e 	bne	r2,zero,81115db4 <__reset+0xfb0f5db4>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115e08:	e0bffa17 	ldw	r2,-24(fp)
81115e0c:	00c00284 	movi	r3,10
81115e10:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81115e14:	e0bffd04 	addi	r2,fp,-12
81115e18:	1009883a 	mov	r4,r2
81115e1c:	111b2340 	call	8111b234 <atoi>
81115e20:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81115e24:	e0bffc8f 	ldh	r2,-14(fp)
81115e28:	10800058 	cmpnei	r2,r2,1
81115e2c:	1000051e 	bne	r2,zero,81115e44 <vLoadDefaultETHConf+0x794>
							xConfEth.bDHCP = TRUE;
81115e30:	00a045b4 	movhi	r2,33046
81115e34:	10817804 	addi	r2,r2,1504
81115e38:	00c00044 	movi	r3,1
81115e3c:	10c00615 	stw	r3,24(r2)
81115e40:	00000306 	br	81115e50 <vLoadDefaultETHConf+0x7a0>
						else
							xConfEth.bDHCP = FALSE;
81115e44:	00a045b4 	movhi	r2,33046
81115e48:	10817804 	addi	r2,r2,1504
81115e4c:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81115e50:	e0bffd04 	addi	r2,fp,-12
81115e54:	e0bffa15 	stw	r2,-24(fp)

						break;
81115e58:	00001b06 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
81115e5c:	e0bffc0f 	ldh	r2,-16(fp)
81115e60:	1009883a 	mov	r4,r2
81115e64:	11195a80 	call	811195a8 <siCloseFile>
81115e68:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
81115e6c:	e0bffb17 	ldw	r2,-20(fp)
81115e70:	1000071e 	bne	r2,zero,81115e90 <vLoadDefaultETHConf+0x7e0>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
81115e74:	d0a05c17 	ldw	r2,-32400(gp)
81115e78:	100f883a 	mov	r7,r2
81115e7c:	01800784 	movi	r6,30
81115e80:	01400044 	movi	r5,1
81115e84:	01204574 	movhi	r4,33045
81115e88:	21221b04 	addi	r4,r4,-30612
81115e8c:	111ba2c0 	call	8111ba2c <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81115e90:	00800044 	movi	r2,1
81115e94:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81115e98:	00800044 	movi	r2,1
81115e9c:	e0bff715 	stw	r2,-36(fp)
						break;
81115ea0:	00000906 	br	81115ec8 <vLoadDefaultETHConf+0x818>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
81115ea4:	d0a05c17 	ldw	r2,-32400(gp)
81115ea8:	100f883a 	mov	r7,r2
81115eac:	01800844 	movi	r6,33
81115eb0:	01400044 	movi	r5,1
81115eb4:	01204574 	movhi	r4,33045
81115eb8:	21222304 	addi	r4,r4,-30580
81115ebc:	111ba2c0 	call	8111ba2c <fwrite>
						#endif
						break;
81115ec0:	00000106 	br	81115ec8 <vLoadDefaultETHConf+0x818>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
81115ec4:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81115ec8:	e0bff817 	ldw	r2,-32(fp)
81115ecc:	103e1626 	beq	r2,zero,81115728 <__reset+0xfb0f5728>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81115ed0:	00000f06 	br	81115f10 <vLoadDefaultETHConf+0x860>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
81115ed4:	d0a05c17 	ldw	r2,-32400(gp)
81115ed8:	100f883a 	mov	r7,r2
81115edc:	01800604 	movi	r6,24
81115ee0:	01400044 	movi	r5,1
81115ee4:	01204574 	movhi	r4,33045
81115ee8:	21222c04 	addi	r4,r4,-30544
81115eec:	111ba2c0 	call	8111ba2c <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81115ef0:	00000706 	br	81115f10 <vLoadDefaultETHConf+0x860>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
81115ef4:	d0a05c17 	ldw	r2,-32400(gp)
81115ef8:	100f883a 	mov	r7,r2
81115efc:	018004c4 	movi	r6,19
81115f00:	01400044 	movi	r5,1
81115f04:	01204574 	movhi	r4,33045
81115f08:	21223304 	addi	r4,r4,-30516
81115f0c:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81115f10:	e0bff717 	ldw	r2,-36(fp)
81115f14:	1000541e 	bne	r2,zero,81116068 <vLoadDefaultETHConf+0x9b8>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
81115f18:	01204574 	movhi	r4,33045
81115f1c:	21223804 	addi	r4,r4,-30496
81115f20:	111c9dc0 	call	8111c9dc <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
81115f24:	01604574 	movhi	r5,33045
81115f28:	29621204 	addi	r5,r5,-30648
81115f2c:	01204574 	movhi	r4,33045
81115f30:	21224c04 	addi	r4,r4,-30416
81115f34:	111c7580 	call	8111c758 <printf>


		xConfEth.siPortPUS = 17000;
81115f38:	00a045b4 	movhi	r2,33046
81115f3c:	10817804 	addi	r2,r2,1504
81115f40:	00d09a04 	movi	r3,17000
81115f44:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
81115f48:	00a045b4 	movhi	r2,33046
81115f4c:	10817804 	addi	r2,r2,1504
81115f50:	00fff004 	movi	r3,-64
81115f54:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
81115f58:	00a045b4 	movhi	r2,33046
81115f5c:	10817804 	addi	r2,r2,1504
81115f60:	00ffea04 	movi	r3,-88
81115f64:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
81115f68:	00a045b4 	movhi	r2,33046
81115f6c:	10817804 	addi	r2,r2,1504
81115f70:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81115f74:	00a045b4 	movhi	r2,33046
81115f78:	10817804 	addi	r2,r2,1504
81115f7c:	00c00144 	movi	r3,5
81115f80:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81115f84:	00a045b4 	movhi	r2,33046
81115f88:	10817804 	addi	r2,r2,1504
81115f8c:	00fff004 	movi	r3,-64
81115f90:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81115f94:	00a045b4 	movhi	r2,33046
81115f98:	10817804 	addi	r2,r2,1504
81115f9c:	00ffea04 	movi	r3,-88
81115fa0:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
81115fa4:	00a045b4 	movhi	r2,33046
81115fa8:	10817804 	addi	r2,r2,1504
81115fac:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
81115fb0:	00a045b4 	movhi	r2,33046
81115fb4:	10817804 	addi	r2,r2,1504
81115fb8:	00c00044 	movi	r3,1
81115fbc:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
81115fc0:	00a045b4 	movhi	r2,33046
81115fc4:	10817804 	addi	r2,r2,1504
81115fc8:	00ffffc4 	movi	r3,-1
81115fcc:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
81115fd0:	00a045b4 	movhi	r2,33046
81115fd4:	10817804 	addi	r2,r2,1504
81115fd8:	00ffffc4 	movi	r3,-1
81115fdc:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
81115fe0:	00a045b4 	movhi	r2,33046
81115fe4:	10817804 	addi	r2,r2,1504
81115fe8:	00ffffc4 	movi	r3,-1
81115fec:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
81115ff0:	00a045b4 	movhi	r2,33046
81115ff4:	10817804 	addi	r2,r2,1504
81115ff8:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
81115ffc:	00a045b4 	movhi	r2,33046
81116000:	10817804 	addi	r2,r2,1504
81116004:	00ffff04 	movi	r3,-4
81116008:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111600c:	00a045b4 	movhi	r2,33046
81116010:	10817804 	addi	r2,r2,1504
81116014:	00fffdc4 	movi	r3,-9
81116018:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111601c:	00a045b4 	movhi	r2,33046
81116020:	10817804 	addi	r2,r2,1504
81116024:	00c018c4 	movi	r3,99
81116028:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111602c:	00a045b4 	movhi	r2,33046
81116030:	10817804 	addi	r2,r2,1504
81116034:	00c01344 	movi	r3,77
81116038:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111603c:	00a045b4 	movhi	r2,33046
81116040:	10817804 	addi	r2,r2,1504
81116044:	00c007c4 	movi	r3,31
81116048:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111604c:	00a045b4 	movhi	r2,33046
81116050:	10817804 	addi	r2,r2,1504
81116054:	00c01084 	movi	r3,66
81116058:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111605c:	00a045b4 	movhi	r2,33046
81116060:	10817804 	addi	r2,r2,1504
81116064:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
81116068:	e0bff717 	ldw	r2,-36(fp)
}
8111606c:	e6ffff04 	addi	sp,fp,-4
81116070:	dfc00217 	ldw	ra,8(sp)
81116074:	df000117 	ldw	fp,4(sp)
81116078:	dc000017 	ldw	r16,0(sp)
8111607c:	dec00304 	addi	sp,sp,12
81116080:	f800283a 	ret

81116084 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
81116084:	defff004 	addi	sp,sp,-64
81116088:	de00012e 	bgeu	sp,et,81116090 <vShowEthConfig+0xc>
8111608c:	003b68fa 	trap	3
81116090:	dfc00f15 	stw	ra,60(sp)
81116094:	df000e15 	stw	fp,56(sp)
81116098:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111609c:	d0a05c17 	ldw	r2,-32400(gp)
811160a0:	100f883a 	mov	r7,r2
811160a4:	018007c4 	movi	r6,31
811160a8:	01400044 	movi	r5,1
811160ac:	01204574 	movhi	r4,33045
811160b0:	21225204 	addi	r4,r4,-30392
811160b4:	111ba2c0 	call	8111ba2c <fwrite>

		memset(buffer,0,40);
811160b8:	01800a04 	movi	r6,40
811160bc:	000b883a 	mov	r5,zero
811160c0:	e13ff604 	addi	r4,fp,-40
811160c4:	111c5900 	call	8111c590 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
811160c8:	00a045b4 	movhi	r2,33046
811160cc:	10817804 	addi	r2,r2,1504
811160d0:	10800403 	ldbu	r2,16(r2)
811160d4:	11803fcc 	andi	r6,r2,255
811160d8:	00a045b4 	movhi	r2,33046
811160dc:	10817804 	addi	r2,r2,1504
811160e0:	10800443 	ldbu	r2,17(r2)
811160e4:	11c03fcc 	andi	r7,r2,255
811160e8:	00a045b4 	movhi	r2,33046
811160ec:	10817804 	addi	r2,r2,1504
811160f0:	10800483 	ldbu	r2,18(r2)
811160f4:	10c03fcc 	andi	r3,r2,255
811160f8:	00a045b4 	movhi	r2,33046
811160fc:	10817804 	addi	r2,r2,1504
81116100:	108004c3 	ldbu	r2,19(r2)
81116104:	11003fcc 	andi	r4,r2,255
81116108:	00a045b4 	movhi	r2,33046
8111610c:	10817804 	addi	r2,r2,1504
81116110:	10800503 	ldbu	r2,20(r2)
81116114:	11403fcc 	andi	r5,r2,255
81116118:	00a045b4 	movhi	r2,33046
8111611c:	10817804 	addi	r2,r2,1504
81116120:	10800543 	ldbu	r2,21(r2)
81116124:	10803fcc 	andi	r2,r2,255
81116128:	d8800315 	stw	r2,12(sp)
8111612c:	d9400215 	stw	r5,8(sp)
81116130:	d9000115 	stw	r4,4(sp)
81116134:	d8c00015 	stw	r3,0(sp)
81116138:	01604574 	movhi	r5,33045
8111613c:	29625a04 	addi	r5,r5,-30360
81116140:	e13ff604 	addi	r4,fp,-40
81116144:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, buffer );
81116148:	d0a05c17 	ldw	r2,-32400(gp)
8111614c:	e17ff604 	addi	r5,fp,-40
81116150:	1009883a 	mov	r4,r2
81116154:	111b3900 	call	8111b390 <fprintf>

		memset(buffer,0,40);
81116158:	01800a04 	movi	r6,40
8111615c:	000b883a 	mov	r5,zero
81116160:	e13ff604 	addi	r4,fp,-40
81116164:	111c5900 	call	8111c590 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
81116168:	00a045b4 	movhi	r2,33046
8111616c:	10817804 	addi	r2,r2,1504
81116170:	10800003 	ldbu	r2,0(r2)
81116174:	11003fcc 	andi	r4,r2,255
81116178:	00a045b4 	movhi	r2,33046
8111617c:	10817804 	addi	r2,r2,1504
81116180:	10800043 	ldbu	r2,1(r2)
81116184:	11403fcc 	andi	r5,r2,255
81116188:	00a045b4 	movhi	r2,33046
8111618c:	10817804 	addi	r2,r2,1504
81116190:	10800083 	ldbu	r2,2(r2)
81116194:	10c03fcc 	andi	r3,r2,255
81116198:	00a045b4 	movhi	r2,33046
8111619c:	10817804 	addi	r2,r2,1504
811161a0:	108000c3 	ldbu	r2,3(r2)
811161a4:	10803fcc 	andi	r2,r2,255
811161a8:	d8800115 	stw	r2,4(sp)
811161ac:	d8c00015 	stw	r3,0(sp)
811161b0:	280f883a 	mov	r7,r5
811161b4:	200d883a 	mov	r6,r4
811161b8:	01604574 	movhi	r5,33045
811161bc:	29626304 	addi	r5,r5,-30324
811161c0:	e13ff604 	addi	r4,fp,-40
811161c4:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, buffer );
811161c8:	d0a05c17 	ldw	r2,-32400(gp)
811161cc:	e17ff604 	addi	r5,fp,-40
811161d0:	1009883a 	mov	r4,r2
811161d4:	111b3900 	call	8111b390 <fprintf>

		memset(buffer,0,40);
811161d8:	01800a04 	movi	r6,40
811161dc:	000b883a 	mov	r5,zero
811161e0:	e13ff604 	addi	r4,fp,-40
811161e4:	111c5900 	call	8111c590 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
811161e8:	00a045b4 	movhi	r2,33046
811161ec:	10817804 	addi	r2,r2,1504
811161f0:	10800103 	ldbu	r2,4(r2)
811161f4:	11003fcc 	andi	r4,r2,255
811161f8:	00a045b4 	movhi	r2,33046
811161fc:	10817804 	addi	r2,r2,1504
81116200:	10800143 	ldbu	r2,5(r2)
81116204:	11403fcc 	andi	r5,r2,255
81116208:	00a045b4 	movhi	r2,33046
8111620c:	10817804 	addi	r2,r2,1504
81116210:	10800183 	ldbu	r2,6(r2)
81116214:	10c03fcc 	andi	r3,r2,255
81116218:	00a045b4 	movhi	r2,33046
8111621c:	10817804 	addi	r2,r2,1504
81116220:	108001c3 	ldbu	r2,7(r2)
81116224:	10803fcc 	andi	r2,r2,255
81116228:	d8800115 	stw	r2,4(sp)
8111622c:	d8c00015 	stw	r3,0(sp)
81116230:	280f883a 	mov	r7,r5
81116234:	200d883a 	mov	r6,r4
81116238:	01604574 	movhi	r5,33045
8111623c:	29626904 	addi	r5,r5,-30300
81116240:	e13ff604 	addi	r4,fp,-40
81116244:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, buffer );
81116248:	d0a05c17 	ldw	r2,-32400(gp)
8111624c:	e17ff604 	addi	r5,fp,-40
81116250:	1009883a 	mov	r4,r2
81116254:	111b3900 	call	8111b390 <fprintf>

		memset(buffer,0,40);
81116258:	01800a04 	movi	r6,40
8111625c:	000b883a 	mov	r5,zero
81116260:	e13ff604 	addi	r4,fp,-40
81116264:	111c5900 	call	8111c590 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
81116268:	00a045b4 	movhi	r2,33046
8111626c:	10817804 	addi	r2,r2,1504
81116270:	10800203 	ldbu	r2,8(r2)
81116274:	11003fcc 	andi	r4,r2,255
81116278:	00a045b4 	movhi	r2,33046
8111627c:	10817804 	addi	r2,r2,1504
81116280:	10800243 	ldbu	r2,9(r2)
81116284:	11403fcc 	andi	r5,r2,255
81116288:	00a045b4 	movhi	r2,33046
8111628c:	10817804 	addi	r2,r2,1504
81116290:	10800283 	ldbu	r2,10(r2)
81116294:	10c03fcc 	andi	r3,r2,255
81116298:	00a045b4 	movhi	r2,33046
8111629c:	10817804 	addi	r2,r2,1504
811162a0:	108002c3 	ldbu	r2,11(r2)
811162a4:	10803fcc 	andi	r2,r2,255
811162a8:	d8800115 	stw	r2,4(sp)
811162ac:	d8c00015 	stw	r3,0(sp)
811162b0:	280f883a 	mov	r7,r5
811162b4:	200d883a 	mov	r6,r4
811162b8:	01604574 	movhi	r5,33045
811162bc:	29627004 	addi	r5,r5,-30272
811162c0:	e13ff604 	addi	r4,fp,-40
811162c4:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, buffer );
811162c8:	d0a05c17 	ldw	r2,-32400(gp)
811162cc:	e17ff604 	addi	r5,fp,-40
811162d0:	1009883a 	mov	r4,r2
811162d4:	111b3900 	call	8111b390 <fprintf>

		memset(buffer,0,40);
811162d8:	01800a04 	movi	r6,40
811162dc:	000b883a 	mov	r5,zero
811162e0:	e13ff604 	addi	r4,fp,-40
811162e4:	111c5900 	call	8111c590 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
811162e8:	00a045b4 	movhi	r2,33046
811162ec:	10817804 	addi	r2,r2,1504
811162f0:	10800303 	ldbu	r2,12(r2)
811162f4:	11003fcc 	andi	r4,r2,255
811162f8:	00a045b4 	movhi	r2,33046
811162fc:	10817804 	addi	r2,r2,1504
81116300:	10800343 	ldbu	r2,13(r2)
81116304:	11403fcc 	andi	r5,r2,255
81116308:	00a045b4 	movhi	r2,33046
8111630c:	10817804 	addi	r2,r2,1504
81116310:	10800383 	ldbu	r2,14(r2)
81116314:	10c03fcc 	andi	r3,r2,255
81116318:	00a045b4 	movhi	r2,33046
8111631c:	10817804 	addi	r2,r2,1504
81116320:	108003c3 	ldbu	r2,15(r2)
81116324:	10803fcc 	andi	r2,r2,255
81116328:	d8800115 	stw	r2,4(sp)
8111632c:	d8c00015 	stw	r3,0(sp)
81116330:	280f883a 	mov	r7,r5
81116334:	200d883a 	mov	r6,r4
81116338:	01604574 	movhi	r5,33045
8111633c:	29627704 	addi	r5,r5,-30244
81116340:	e13ff604 	addi	r4,fp,-40
81116344:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, buffer );
81116348:	d0a05c17 	ldw	r2,-32400(gp)
8111634c:	e17ff604 	addi	r5,fp,-40
81116350:	1009883a 	mov	r4,r2
81116354:	111b3900 	call	8111b390 <fprintf>

		memset(buffer,0,40);
81116358:	01800a04 	movi	r6,40
8111635c:	000b883a 	mov	r5,zero
81116360:	e13ff604 	addi	r4,fp,-40
81116364:	111c5900 	call	8111c590 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
81116368:	00a045b4 	movhi	r2,33046
8111636c:	10817804 	addi	r2,r2,1504
81116370:	1080058b 	ldhu	r2,22(r2)
81116374:	10bfffcc 	andi	r2,r2,65535
81116378:	100d883a 	mov	r6,r2
8111637c:	01604574 	movhi	r5,33045
81116380:	29627e04 	addi	r5,r5,-30216
81116384:	e13ff604 	addi	r4,fp,-40
81116388:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, buffer );
8111638c:	d0a05c17 	ldw	r2,-32400(gp)
81116390:	e17ff604 	addi	r5,fp,-40
81116394:	1009883a 	mov	r4,r2
81116398:	111b3900 	call	8111b390 <fprintf>

	}
8111639c:	0001883a 	nop
811163a0:	e037883a 	mov	sp,fp
811163a4:	dfc00117 	ldw	ra,4(sp)
811163a8:	df000017 	ldw	fp,0(sp)
811163ac:	dec00204 	addi	sp,sp,8
811163b0:	f800283a 	ret

811163b4 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
811163b4:	defffb04 	addi	sp,sp,-20
811163b8:	de00012e 	bgeu	sp,et,811163c0 <ucCrc8+0xc>
811163bc:	003b68fa 	trap	3
811163c0:	df000415 	stw	fp,16(sp)
811163c4:	df000404 	addi	fp,sp,16
811163c8:	e13ffd15 	stw	r4,-12(fp)
811163cc:	e17ffe15 	stw	r5,-8(fp)
811163d0:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
811163d4:	e0bffe17 	ldw	r2,-8(fp)
811163d8:	1000021e 	bne	r2,zero,811163e4 <ucCrc8+0x30>
        return 0;
811163dc:	0005883a 	mov	r2,zero
811163e0:	00001906 	br	81116448 <ucCrc8+0x94>
    crc &= 0xff;
811163e4:	e0bffd17 	ldw	r2,-12(fp)
811163e8:	10803fcc 	andi	r2,r2,255
811163ec:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
811163f0:	e0fffe17 	ldw	r3,-8(fp)
811163f4:	e0bfff17 	ldw	r2,-4(fp)
811163f8:	1885883a 	add	r2,r3,r2
811163fc:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
81116400:	00000d06 	br	81116438 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
81116404:	e0bffe17 	ldw	r2,-8(fp)
81116408:	10c00044 	addi	r3,r2,1
8111640c:	e0fffe15 	stw	r3,-8(fp)
81116410:	10800003 	ldbu	r2,0(r2)
81116414:	10c03fcc 	andi	r3,r2,255
81116418:	e0bffd17 	ldw	r2,-12(fp)
8111641c:	1886f03a 	xor	r3,r3,r2
81116420:	00a04574 	movhi	r2,33045
81116424:	10a281c4 	addi	r2,r2,-30201
81116428:	10c5883a 	add	r2,r2,r3
8111642c:	10800003 	ldbu	r2,0(r2)
81116430:	10803fcc 	andi	r2,r2,255
81116434:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
81116438:	e0fffe17 	ldw	r3,-8(fp)
8111643c:	e0bffc17 	ldw	r2,-16(fp)
81116440:	18bff036 	bltu	r3,r2,81116404 <__reset+0xfb0f6404>
        crc = crc8_table[crc ^ *data++];
    return crc;
81116444:	e0bffd17 	ldw	r2,-12(fp)
}
81116448:	e037883a 	mov	sp,fp
8111644c:	df000017 	ldw	fp,0(sp)
81116450:	dec00104 	addi	sp,sp,4
81116454:	f800283a 	ret

81116458 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
81116458:	defffb04 	addi	sp,sp,-20
8111645c:	de00012e 	bgeu	sp,et,81116464 <ucCrc8wInit+0xc>
81116460:	003b68fa 	trap	3
81116464:	dfc00415 	stw	ra,16(sp)
81116468:	df000315 	stw	fp,12(sp)
8111646c:	df000304 	addi	fp,sp,12
81116470:	e13ffe15 	stw	r4,-8(fp)
81116474:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
81116478:	000d883a 	mov	r6,zero
8111647c:	000b883a 	mov	r5,zero
81116480:	0009883a 	mov	r4,zero
81116484:	11163b40 	call	811163b4 <ucCrc8>
81116488:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111648c:	e0bffd03 	ldbu	r2,-12(fp)
81116490:	e1bfff17 	ldw	r6,-4(fp)
81116494:	e17ffe17 	ldw	r5,-8(fp)
81116498:	1009883a 	mov	r4,r2
8111649c:	11163b40 	call	811163b4 <ucCrc8>
}
811164a0:	e037883a 	mov	sp,fp
811164a4:	dfc00117 	ldw	ra,4(sp)
811164a8:	df000017 	ldw	fp,0(sp)
811164ac:	dec00204 	addi	sp,sp,8
811164b0:	f800283a 	ret

811164b4 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
811164b4:	defffc04 	addi	sp,sp,-16
811164b8:	de00012e 	bgeu	sp,et,811164c0 <vDataControllerInit+0xc>
811164bc:	003b68fa 	trap	3
811164c0:	df000315 	stw	fp,12(sp)
811164c4:	df000304 	addi	fp,sp,12
811164c8:	e13ffe15 	stw	r4,-8(fp)
811164cc:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
811164d0:	e0bffe17 	ldw	r2,-8(fp)
811164d4:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
811164d8:	e03ffd05 	stb	zero,-12(fp)
811164dc:	00001c06 	br	81116550 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
811164e0:	e0bffd03 	ldbu	r2,-12(fp)
811164e4:	e0fffd03 	ldbu	r3,-12(fp)
811164e8:	18c09524 	muli	r3,r3,596
811164ec:	e13fff17 	ldw	r4,-4(fp)
811164f0:	20c7883a 	add	r3,r4,r3
811164f4:	e13ffe17 	ldw	r4,-8(fp)
811164f8:	10800084 	addi	r2,r2,2
811164fc:	1085883a 	add	r2,r2,r2
81116500:	1085883a 	add	r2,r2,r2
81116504:	2085883a 	add	r2,r4,r2
81116508:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111650c:	e17ffd03 	ldbu	r5,-12(fp)
81116510:	e0bffd03 	ldbu	r2,-12(fp)
81116514:	e0ffff17 	ldw	r3,-4(fp)
81116518:	10802584 	addi	r2,r2,150
8111651c:	1085883a 	add	r2,r2,r2
81116520:	1085883a 	add	r2,r2,r2
81116524:	1885883a 	add	r2,r3,r2
81116528:	10c00017 	ldw	r3,0(r2)
8111652c:	e13ffe17 	ldw	r4,-8(fp)
81116530:	288000c4 	addi	r2,r5,3
81116534:	1085883a 	add	r2,r2,r2
81116538:	1085883a 	add	r2,r2,r2
8111653c:	2085883a 	add	r2,r4,r2
81116540:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81116544:	e0bffd03 	ldbu	r2,-12(fp)
81116548:	10800044 	addi	r2,r2,1
8111654c:	e0bffd05 	stb	r2,-12(fp)
81116550:	e0bffd03 	ldbu	r2,-12(fp)
81116554:	103fe226 	beq	r2,zero,811164e0 <__reset+0xfb0f64e0>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
81116558:	e0bfff17 	ldw	r2,-4(fp)
8111655c:	10c09804 	addi	r3,r2,608
81116560:	e0bffe17 	ldw	r2,-8(fp)
81116564:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
81116568:	e0bffe17 	ldw	r2,-8(fp)
8111656c:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
81116570:	e0bffe17 	ldw	r2,-8(fp)
81116574:	10c00504 	addi	r3,r2,20
81116578:	e0bfff17 	ldw	r2,-4(fp)
8111657c:	10c09a15 	stw	r3,616(r2)
}
81116580:	0001883a 	nop
81116584:	e037883a 	mov	sp,fp
81116588:	df000017 	ldw	fp,0(sp)
8111658c:	dec00104 	addi	sp,sp,4
81116590:	f800283a 	ret

81116594 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
81116594:	defff904 	addi	sp,sp,-28
81116598:	de00012e 	bgeu	sp,et,811165a0 <printErrorTask+0xc>
8111659c:	003b68fa 	trap	3
811165a0:	dfc00615 	stw	ra,24(sp)
811165a4:	df000515 	stw	fp,20(sp)
811165a8:	df000504 	addi	fp,sp,20
811165ac:	2005883a 	mov	r2,r4
811165b0:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
811165b4:	e03ffb15 	stw	zero,-20(fp)
811165b8:	e03ffc15 	stw	zero,-16(fp)
811165bc:	e03ffd15 	stw	zero,-12(fp)
811165c0:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
811165c4:	e0bfff03 	ldbu	r2,-4(fp)
811165c8:	100d883a 	mov	r6,r2
811165cc:	01604574 	movhi	r5,33045
811165d0:	2962c204 	addi	r5,r5,-29944
811165d4:	e13ffb04 	addi	r4,fp,-20
811165d8:	111cd200 	call	8111cd20 <sprintf>
		debug(fp, buffer);
811165dc:	d0a05c17 	ldw	r2,-32400(gp)
811165e0:	e17ffb04 	addi	r5,fp,-20
811165e4:	1009883a 	mov	r4,r2
811165e8:	111b3900 	call	8111b390 <fprintf>
	}
811165ec:	0001883a 	nop
811165f0:	e037883a 	mov	sp,fp
811165f4:	dfc00117 	ldw	ra,4(sp)
811165f8:	df000017 	ldw	fp,0(sp)
811165fc:	dec00204 	addi	sp,sp,8
81116600:	f800283a 	ret

81116604 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
81116604:	defffd04 	addi	sp,sp,-12
81116608:	de00012e 	bgeu	sp,et,81116610 <vFailCreateMutexSResources+0xc>
8111660c:	003b68fa 	trap	3
81116610:	dfc00215 	stw	ra,8(sp)
81116614:	df000115 	stw	fp,4(sp)
81116618:	df000104 	addi	fp,sp,4
8111661c:	2005883a 	mov	r2,r4
81116620:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
81116624:	d0a05c17 	ldw	r2,-32400(gp)
81116628:	100f883a 	mov	r7,r2
8111662c:	018008c4 	movi	r6,35
81116630:	01400044 	movi	r5,1
81116634:	01204574 	movhi	r4,33045
81116638:	2122c504 	addi	r4,r4,-29932
8111663c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81116640:	e0bfff03 	ldbu	r2,-4(fp)
81116644:	1009883a 	mov	r4,r2
81116648:	11165940 	call	81116594 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111664c:	0001883a 	nop
81116650:	e037883a 	mov	sp,fp
81116654:	dfc00117 	ldw	ra,4(sp)
81116658:	df000017 	ldw	fp,0(sp)
8111665c:	dec00204 	addi	sp,sp,8
81116660:	f800283a 	ret

81116664 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
81116664:	defffe04 	addi	sp,sp,-8
81116668:	de00012e 	bgeu	sp,et,81116670 <vFailCreateMutexDMA+0xc>
8111666c:	003b68fa 	trap	3
81116670:	dfc00115 	stw	ra,4(sp)
81116674:	df000015 	stw	fp,0(sp)
81116678:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111667c:	d0a05c17 	ldw	r2,-32400(gp)
81116680:	100f883a 	mov	r7,r2
81116684:	018009c4 	movi	r6,39
81116688:	01400044 	movi	r5,1
8111668c:	01204574 	movhi	r4,33045
81116690:	2122ce04 	addi	r4,r4,-29896
81116694:	111ba2c0 	call	8111ba2c <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116698:	0001883a 	nop
8111669c:	e037883a 	mov	sp,fp
811166a0:	dfc00117 	ldw	ra,4(sp)
811166a4:	df000017 	ldw	fp,0(sp)
811166a8:	dec00204 	addi	sp,sp,8
811166ac:	f800283a 	ret

811166b0 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
811166b0:	defffe04 	addi	sp,sp,-8
811166b4:	de00012e 	bgeu	sp,et,811166bc <vFailCreateSemaphoreResources+0xc>
811166b8:	003b68fa 	trap	3
811166bc:	dfc00115 	stw	ra,4(sp)
811166c0:	df000015 	stw	fp,0(sp)
811166c4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
811166c8:	d0a05c17 	ldw	r2,-32400(gp)
811166cc:	100f883a 	mov	r7,r2
811166d0:	01800984 	movi	r6,38
811166d4:	01400044 	movi	r5,1
811166d8:	01204574 	movhi	r4,33045
811166dc:	2122d804 	addi	r4,r4,-29856
811166e0:	111ba2c0 	call	8111ba2c <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811166e4:	0001883a 	nop
811166e8:	e037883a 	mov	sp,fp
811166ec:	dfc00117 	ldw	ra,4(sp)
811166f0:	df000017 	ldw	fp,0(sp)
811166f4:	dec00204 	addi	sp,sp,8
811166f8:	f800283a 	ret

811166fc <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
811166fc:	defffe04 	addi	sp,sp,-8
81116700:	de00012e 	bgeu	sp,et,81116708 <vFailTestCriticasParts+0xc>
81116704:	003b68fa 	trap	3
81116708:	dfc00115 	stw	ra,4(sp)
8111670c:	df000015 	stw	fp,0(sp)
81116710:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
81116714:	d0a05c17 	ldw	r2,-32400(gp)
81116718:	100f883a 	mov	r7,r2
8111671c:	018007c4 	movi	r6,31
81116720:	01400044 	movi	r5,1
81116724:	01204574 	movhi	r4,33045
81116728:	2122e204 	addi	r4,r4,-29816
8111672c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116730:	0001883a 	nop
81116734:	e037883a 	mov	sp,fp
81116738:	dfc00117 	ldw	ra,4(sp)
8111673c:	df000017 	ldw	fp,0(sp)
81116740:	dec00204 	addi	sp,sp,8
81116744:	f800283a 	ret

81116748 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
81116748:	defffe04 	addi	sp,sp,-8
8111674c:	de00012e 	bgeu	sp,et,81116754 <vFailSendxSemCommInit+0xc>
81116750:	003b68fa 	trap	3
81116754:	dfc00115 	stw	ra,4(sp)
81116758:	df000015 	stw	fp,0(sp)
8111675c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
81116760:	d0a05c17 	ldw	r2,-32400(gp)
81116764:	100f883a 	mov	r7,r2
81116768:	01800744 	movi	r6,29
8111676c:	01400044 	movi	r5,1
81116770:	01204574 	movhi	r4,33045
81116774:	2122ea04 	addi	r4,r4,-29784
81116778:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111677c:	d0a05c17 	ldw	r2,-32400(gp)
81116780:	100f883a 	mov	r7,r2
81116784:	01800a44 	movi	r6,41
81116788:	01400044 	movi	r5,1
8111678c:	01204574 	movhi	r4,33045
81116790:	2122f204 	addi	r4,r4,-29752
81116794:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116798:	0001883a 	nop
8111679c:	e037883a 	mov	sp,fp
811167a0:	dfc00117 	ldw	ra,4(sp)
811167a4:	df000017 	ldw	fp,0(sp)
811167a8:	dec00204 	addi	sp,sp,8
811167ac:	f800283a 	ret

811167b0 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
811167b0:	defffe04 	addi	sp,sp,-8
811167b4:	de00012e 	bgeu	sp,et,811167bc <vFailSendPreParsedSemaphore+0xc>
811167b8:	003b68fa 	trap	3
811167bc:	dfc00115 	stw	ra,4(sp)
811167c0:	df000015 	stw	fp,0(sp)
811167c4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
811167c8:	d0a05c17 	ldw	r2,-32400(gp)
811167cc:	100f883a 	mov	r7,r2
811167d0:	01800904 	movi	r6,36
811167d4:	01400044 	movi	r5,1
811167d8:	01204574 	movhi	r4,33045
811167dc:	2122fd04 	addi	r4,r4,-29708
811167e0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811167e4:	0001883a 	nop
811167e8:	e037883a 	mov	sp,fp
811167ec:	dfc00117 	ldw	ra,4(sp)
811167f0:	df000017 	ldw	fp,0(sp)
811167f4:	dec00204 	addi	sp,sp,8
811167f8:	f800283a 	ret

811167fc <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
811167fc:	defffe04 	addi	sp,sp,-8
81116800:	de00012e 	bgeu	sp,et,81116808 <vFailSendPreAckReceiverSemaphore+0xc>
81116804:	003b68fa 	trap	3
81116808:	dfc00115 	stw	ra,4(sp)
8111680c:	df000015 	stw	fp,0(sp)
81116810:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
81116814:	d0a05c17 	ldw	r2,-32400(gp)
81116818:	100f883a 	mov	r7,r2
8111681c:	01800a44 	movi	r6,41
81116820:	01400044 	movi	r5,1
81116824:	01204574 	movhi	r4,33045
81116828:	21230704 	addi	r4,r4,-29668
8111682c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116830:	0001883a 	nop
81116834:	e037883a 	mov	sp,fp
81116838:	dfc00117 	ldw	ra,4(sp)
8111683c:	df000017 	ldw	fp,0(sp)
81116840:	dec00204 	addi	sp,sp,8
81116844:	f800283a 	ret

81116848 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
81116848:	defffe04 	addi	sp,sp,-8
8111684c:	de00012e 	bgeu	sp,et,81116854 <vFailSendPreAckSenderSemaphore+0xc>
81116850:	003b68fa 	trap	3
81116854:	dfc00115 	stw	ra,4(sp)
81116858:	df000015 	stw	fp,0(sp)
8111685c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
81116860:	d0a05c17 	ldw	r2,-32400(gp)
81116864:	100f883a 	mov	r7,r2
81116868:	018009c4 	movi	r6,39
8111686c:	01400044 	movi	r5,1
81116870:	01204574 	movhi	r4,33045
81116874:	21231204 	addi	r4,r4,-29624
81116878:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111687c:	0001883a 	nop
81116880:	e037883a 	mov	sp,fp
81116884:	dfc00117 	ldw	ra,4(sp)
81116888:	df000017 	ldw	fp,0(sp)
8111688c:	dec00204 	addi	sp,sp,8
81116890:	f800283a 	ret

81116894 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
81116894:	defffe04 	addi	sp,sp,-8
81116898:	de00012e 	bgeu	sp,et,811168a0 <vFailGetCountSemaphoreSenderTask+0xc>
8111689c:	003b68fa 	trap	3
811168a0:	dfc00115 	stw	ra,4(sp)
811168a4:	df000015 	stw	fp,0(sp)
811168a8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
811168ac:	d0a05c17 	ldw	r2,-32400(gp)
811168b0:	100f883a 	mov	r7,r2
811168b4:	01800a44 	movi	r6,41
811168b8:	01400044 	movi	r5,1
811168bc:	01204574 	movhi	r4,33045
811168c0:	21231c04 	addi	r4,r4,-29584
811168c4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
811168c8:	d0a05c17 	ldw	r2,-32400(gp)
811168cc:	100f883a 	mov	r7,r2
811168d0:	01801104 	movi	r6,68
811168d4:	01400044 	movi	r5,1
811168d8:	01204574 	movhi	r4,33045
811168dc:	21232704 	addi	r4,r4,-29540
811168e0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811168e4:	0001883a 	nop
811168e8:	e037883a 	mov	sp,fp
811168ec:	dfc00117 	ldw	ra,4(sp)
811168f0:	df000017 	ldw	fp,0(sp)
811168f4:	dec00204 	addi	sp,sp,8
811168f8:	f800283a 	ret

811168fc <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
811168fc:	defffe04 	addi	sp,sp,-8
81116900:	de00012e 	bgeu	sp,et,81116908 <vFailGetMutexSenderTask+0xc>
81116904:	003b68fa 	trap	3
81116908:	dfc00115 	stw	ra,4(sp)
8111690c:	df000015 	stw	fp,0(sp)
81116910:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
81116914:	d0a05c17 	ldw	r2,-32400(gp)
81116918:	100f883a 	mov	r7,r2
8111691c:	01800804 	movi	r6,32
81116920:	01400044 	movi	r5,1
81116924:	01204574 	movhi	r4,33045
81116928:	21233904 	addi	r4,r4,-29468
8111692c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
81116930:	d0a05c17 	ldw	r2,-32400(gp)
81116934:	100f883a 	mov	r7,r2
81116938:	01801084 	movi	r6,66
8111693c:	01400044 	movi	r5,1
81116940:	01204574 	movhi	r4,33045
81116944:	21234204 	addi	r4,r4,-29432
81116948:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111694c:	0001883a 	nop
81116950:	e037883a 	mov	sp,fp
81116954:	dfc00117 	ldw	ra,4(sp)
81116958:	df000017 	ldw	fp,0(sp)
8111695c:	dec00204 	addi	sp,sp,8
81116960:	f800283a 	ret

81116964 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
81116964:	defffe04 	addi	sp,sp,-8
81116968:	de00012e 	bgeu	sp,et,81116970 <vFailGetCountSemaphoreReceiverTask+0xc>
8111696c:	003b68fa 	trap	3
81116970:	dfc00115 	stw	ra,4(sp)
81116974:	df000015 	stw	fp,0(sp)
81116978:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111697c:	d0a05c17 	ldw	r2,-32400(gp)
81116980:	100f883a 	mov	r7,r2
81116984:	01800ac4 	movi	r6,43
81116988:	01400044 	movi	r5,1
8111698c:	01204574 	movhi	r4,33045
81116990:	21235304 	addi	r4,r4,-29364
81116994:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
81116998:	d0a05c17 	ldw	r2,-32400(gp)
8111699c:	100f883a 	mov	r7,r2
811169a0:	01801184 	movi	r6,70
811169a4:	01400044 	movi	r5,1
811169a8:	01204574 	movhi	r4,33045
811169ac:	21235e04 	addi	r4,r4,-29320
811169b0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811169b4:	0001883a 	nop
811169b8:	e037883a 	mov	sp,fp
811169bc:	dfc00117 	ldw	ra,4(sp)
811169c0:	df000017 	ldw	fp,0(sp)
811169c4:	dec00204 	addi	sp,sp,8
811169c8:	f800283a 	ret

811169cc <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
811169cc:	defffe04 	addi	sp,sp,-8
811169d0:	de00012e 	bgeu	sp,et,811169d8 <vFailGetMutexReceiverTask+0xc>
811169d4:	003b68fa 	trap	3
811169d8:	dfc00115 	stw	ra,4(sp)
811169dc:	df000015 	stw	fp,0(sp)
811169e0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
811169e4:	d0a05c17 	ldw	r2,-32400(gp)
811169e8:	100f883a 	mov	r7,r2
811169ec:	01800884 	movi	r6,34
811169f0:	01400044 	movi	r5,1
811169f4:	01204574 	movhi	r4,33045
811169f8:	21237004 	addi	r4,r4,-29248
811169fc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
81116a00:	d0a05c17 	ldw	r2,-32400(gp)
81116a04:	100f883a 	mov	r7,r2
81116a08:	01801104 	movi	r6,68
81116a0c:	01400044 	movi	r5,1
81116a10:	01204574 	movhi	r4,33045
81116a14:	21237904 	addi	r4,r4,-29212
81116a18:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116a1c:	0001883a 	nop
81116a20:	e037883a 	mov	sp,fp
81116a24:	dfc00117 	ldw	ra,4(sp)
81116a28:	df000017 	ldw	fp,0(sp)
81116a2c:	dec00204 	addi	sp,sp,8
81116a30:	f800283a 	ret

81116a34 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
81116a34:	defffe04 	addi	sp,sp,-8
81116a38:	de00012e 	bgeu	sp,et,81116a40 <vFailGetMutexTxUARTSenderTask+0xc>
81116a3c:	003b68fa 	trap	3
81116a40:	dfc00115 	stw	ra,4(sp)
81116a44:	df000015 	stw	fp,0(sp)
81116a48:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
81116a4c:	d0a05c17 	ldw	r2,-32400(gp)
81116a50:	100f883a 	mov	r7,r2
81116a54:	01800984 	movi	r6,38
81116a58:	01400044 	movi	r5,1
81116a5c:	01204574 	movhi	r4,33045
81116a60:	21238b04 	addi	r4,r4,-29140
81116a64:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
81116a68:	d0a05c17 	ldw	r2,-32400(gp)
81116a6c:	100f883a 	mov	r7,r2
81116a70:	01801044 	movi	r6,65
81116a74:	01400044 	movi	r5,1
81116a78:	01204574 	movhi	r4,33045
81116a7c:	21239504 	addi	r4,r4,-29100
81116a80:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116a84:	0001883a 	nop
81116a88:	e037883a 	mov	sp,fp
81116a8c:	dfc00117 	ldw	ra,4(sp)
81116a90:	df000017 	ldw	fp,0(sp)
81116a94:	dec00204 	addi	sp,sp,8
81116a98:	f800283a 	ret

81116a9c <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
81116a9c:	defffe04 	addi	sp,sp,-8
81116aa0:	de00012e 	bgeu	sp,et,81116aa8 <vFailGetMacRTC+0xc>
81116aa4:	003b68fa 	trap	3
81116aa8:	dfc00115 	stw	ra,4(sp)
81116aac:	df000015 	stw	fp,0(sp)
81116ab0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
81116ab4:	d0a05c17 	ldw	r2,-32400(gp)
81116ab8:	100f883a 	mov	r7,r2
81116abc:	018003c4 	movi	r6,15
81116ac0:	01400044 	movi	r5,1
81116ac4:	01204574 	movhi	r4,33045
81116ac8:	2123a604 	addi	r4,r4,-29032
81116acc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116ad0:	0001883a 	nop
81116ad4:	e037883a 	mov	sp,fp
81116ad8:	dfc00117 	ldw	ra,4(sp)
81116adc:	df000017 	ldw	fp,0(sp)
81116ae0:	dec00204 	addi	sp,sp,8
81116ae4:	f800283a 	ret

81116ae8 <vFailInitialization>:


void vFailInitialization( void )
{
81116ae8:	defffe04 	addi	sp,sp,-8
81116aec:	de00012e 	bgeu	sp,et,81116af4 <vFailInitialization+0xc>
81116af0:	003b68fa 	trap	3
81116af4:	dfc00115 	stw	ra,4(sp)
81116af8:	df000015 	stw	fp,0(sp)
81116afc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
81116b00:	d0a05c17 	ldw	r2,-32400(gp)
81116b04:	100f883a 	mov	r7,r2
81116b08:	01800504 	movi	r6,20
81116b0c:	01400044 	movi	r5,1
81116b10:	01204574 	movhi	r4,33045
81116b14:	2123aa04 	addi	r4,r4,-29016
81116b18:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116b1c:	0001883a 	nop
81116b20:	e037883a 	mov	sp,fp
81116b24:	dfc00117 	ldw	ra,4(sp)
81116b28:	df000017 	ldw	fp,0(sp)
81116b2c:	dec00204 	addi	sp,sp,8
81116b30:	f800283a 	ret

81116b34 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
81116b34:	defffe04 	addi	sp,sp,-8
81116b38:	de00012e 	bgeu	sp,et,81116b40 <vFailReceiverCreate+0xc>
81116b3c:	003b68fa 	trap	3
81116b40:	dfc00115 	stw	ra,4(sp)
81116b44:	df000015 	stw	fp,0(sp)
81116b48:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
81116b4c:	d0a05c17 	ldw	r2,-32400(gp)
81116b50:	100f883a 	mov	r7,r2
81116b54:	01800484 	movi	r6,18
81116b58:	01400044 	movi	r5,1
81116b5c:	01204574 	movhi	r4,33045
81116b60:	2123b004 	addi	r4,r4,-28992
81116b64:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116b68:	0001883a 	nop
81116b6c:	e037883a 	mov	sp,fp
81116b70:	dfc00117 	ldw	ra,4(sp)
81116b74:	df000017 	ldw	fp,0(sp)
81116b78:	dec00204 	addi	sp,sp,8
81116b7c:	f800283a 	ret

81116b80 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
81116b80:	defffe04 	addi	sp,sp,-8
81116b84:	de00012e 	bgeu	sp,et,81116b8c <vFailSenderCreate+0xc>
81116b88:	003b68fa 	trap	3
81116b8c:	dfc00115 	stw	ra,4(sp)
81116b90:	df000015 	stw	fp,0(sp)
81116b94:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
81116b98:	d0a05c17 	ldw	r2,-32400(gp)
81116b9c:	100f883a 	mov	r7,r2
81116ba0:	01800484 	movi	r6,18
81116ba4:	01400044 	movi	r5,1
81116ba8:	01204574 	movhi	r4,33045
81116bac:	2123b504 	addi	r4,r4,-28972
81116bb0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116bb4:	0001883a 	nop
81116bb8:	e037883a 	mov	sp,fp
81116bbc:	dfc00117 	ldw	ra,4(sp)
81116bc0:	df000017 	ldw	fp,0(sp)
81116bc4:	dec00204 	addi	sp,sp,8
81116bc8:	f800283a 	ret

81116bcc <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
81116bcc:	defffe04 	addi	sp,sp,-8
81116bd0:	de00012e 	bgeu	sp,et,81116bd8 <vFailDeleteInitialization+0xc>
81116bd4:	003b68fa 	trap	3
81116bd8:	dfc00115 	stw	ra,4(sp)
81116bdc:	df000015 	stw	fp,0(sp)
81116be0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
81116be4:	d0a05c17 	ldw	r2,-32400(gp)
81116be8:	100f883a 	mov	r7,r2
81116bec:	01800684 	movi	r6,26
81116bf0:	01400044 	movi	r5,1
81116bf4:	01204574 	movhi	r4,33045
81116bf8:	2123ba04 	addi	r4,r4,-28952
81116bfc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c00:	0001883a 	nop
81116c04:	e037883a 	mov	sp,fp
81116c08:	dfc00117 	ldw	ra,4(sp)
81116c0c:	df000017 	ldw	fp,0(sp)
81116c10:	dec00204 	addi	sp,sp,8
81116c14:	f800283a 	ret

81116c18 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
81116c18:	defffe04 	addi	sp,sp,-8
81116c1c:	de00012e 	bgeu	sp,et,81116c24 <vFailSetCountSemaphorexBuffer32+0xc>
81116c20:	003b68fa 	trap	3
81116c24:	dfc00115 	stw	ra,4(sp)
81116c28:	df000015 	stw	fp,0(sp)
81116c2c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
81116c30:	d0a05c17 	ldw	r2,-32400(gp)
81116c34:	100f883a 	mov	r7,r2
81116c38:	01800a04 	movi	r6,40
81116c3c:	01400044 	movi	r5,1
81116c40:	01204574 	movhi	r4,33045
81116c44:	2123c104 	addi	r4,r4,-28924
81116c48:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81116c4c:	d0a05c17 	ldw	r2,-32400(gp)
81116c50:	100f883a 	mov	r7,r2
81116c54:	018008c4 	movi	r6,35
81116c58:	01400044 	movi	r5,1
81116c5c:	01204574 	movhi	r4,33045
81116c60:	2123cc04 	addi	r4,r4,-28880
81116c64:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c68:	0001883a 	nop
81116c6c:	e037883a 	mov	sp,fp
81116c70:	dfc00117 	ldw	ra,4(sp)
81116c74:	df000017 	ldw	fp,0(sp)
81116c78:	dec00204 	addi	sp,sp,8
81116c7c:	f800283a 	ret

81116c80 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
81116c80:	defffe04 	addi	sp,sp,-8
81116c84:	de00012e 	bgeu	sp,et,81116c8c <vFailSetCountSemaphorexBuffer64+0xc>
81116c88:	003b68fa 	trap	3
81116c8c:	dfc00115 	stw	ra,4(sp)
81116c90:	df000015 	stw	fp,0(sp)
81116c94:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
81116c98:	d0a05c17 	ldw	r2,-32400(gp)
81116c9c:	100f883a 	mov	r7,r2
81116ca0:	01800a04 	movi	r6,40
81116ca4:	01400044 	movi	r5,1
81116ca8:	01204574 	movhi	r4,33045
81116cac:	2123d504 	addi	r4,r4,-28844
81116cb0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81116cb4:	d0a05c17 	ldw	r2,-32400(gp)
81116cb8:	100f883a 	mov	r7,r2
81116cbc:	018008c4 	movi	r6,35
81116cc0:	01400044 	movi	r5,1
81116cc4:	01204574 	movhi	r4,33045
81116cc8:	2123cc04 	addi	r4,r4,-28880
81116ccc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116cd0:	0001883a 	nop
81116cd4:	e037883a 	mov	sp,fp
81116cd8:	dfc00117 	ldw	ra,4(sp)
81116cdc:	df000017 	ldw	fp,0(sp)
81116ce0:	dec00204 	addi	sp,sp,8
81116ce4:	f800283a 	ret

81116ce8 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
81116ce8:	defffe04 	addi	sp,sp,-8
81116cec:	de00012e 	bgeu	sp,et,81116cf4 <vFailSetCountSemaphorexBuffer128+0xc>
81116cf0:	003b68fa 	trap	3
81116cf4:	dfc00115 	stw	ra,4(sp)
81116cf8:	df000015 	stw	fp,0(sp)
81116cfc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
81116d00:	d0a05c17 	ldw	r2,-32400(gp)
81116d04:	100f883a 	mov	r7,r2
81116d08:	01800a44 	movi	r6,41
81116d0c:	01400044 	movi	r5,1
81116d10:	01204574 	movhi	r4,33045
81116d14:	2123e004 	addi	r4,r4,-28800
81116d18:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81116d1c:	d0a05c17 	ldw	r2,-32400(gp)
81116d20:	100f883a 	mov	r7,r2
81116d24:	018008c4 	movi	r6,35
81116d28:	01400044 	movi	r5,1
81116d2c:	01204574 	movhi	r4,33045
81116d30:	2123cc04 	addi	r4,r4,-28880
81116d34:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116d38:	0001883a 	nop
81116d3c:	e037883a 	mov	sp,fp
81116d40:	dfc00117 	ldw	ra,4(sp)
81116d44:	df000017 	ldw	fp,0(sp)
81116d48:	dec00204 	addi	sp,sp,8
81116d4c:	f800283a 	ret

81116d50 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
81116d50:	defffe04 	addi	sp,sp,-8
81116d54:	de00012e 	bgeu	sp,et,81116d5c <vFailGetCountSemaphorexBuffer128+0xc>
81116d58:	003b68fa 	trap	3
81116d5c:	dfc00115 	stw	ra,4(sp)
81116d60:	df000015 	stw	fp,0(sp)
81116d64:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
81116d68:	d0a05c17 	ldw	r2,-32400(gp)
81116d6c:	100f883a 	mov	r7,r2
81116d70:	01800a44 	movi	r6,41
81116d74:	01400044 	movi	r5,1
81116d78:	01204574 	movhi	r4,33045
81116d7c:	2123eb04 	addi	r4,r4,-28756
81116d80:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81116d84:	d0a05c17 	ldw	r2,-32400(gp)
81116d88:	100f883a 	mov	r7,r2
81116d8c:	01800884 	movi	r6,34
81116d90:	01400044 	movi	r5,1
81116d94:	01204574 	movhi	r4,33045
81116d98:	2123f604 	addi	r4,r4,-28712
81116d9c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116da0:	0001883a 	nop
81116da4:	e037883a 	mov	sp,fp
81116da8:	dfc00117 	ldw	ra,4(sp)
81116dac:	df000017 	ldw	fp,0(sp)
81116db0:	dec00204 	addi	sp,sp,8
81116db4:	f800283a 	ret

81116db8 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
81116db8:	defffe04 	addi	sp,sp,-8
81116dbc:	de00012e 	bgeu	sp,et,81116dc4 <vFailGetCountSemaphorexBuffer64+0xc>
81116dc0:	003b68fa 	trap	3
81116dc4:	dfc00115 	stw	ra,4(sp)
81116dc8:	df000015 	stw	fp,0(sp)
81116dcc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
81116dd0:	d0a05c17 	ldw	r2,-32400(gp)
81116dd4:	100f883a 	mov	r7,r2
81116dd8:	01800a04 	movi	r6,40
81116ddc:	01400044 	movi	r5,1
81116de0:	01204574 	movhi	r4,33045
81116de4:	2123ff04 	addi	r4,r4,-28676
81116de8:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81116dec:	d0a05c17 	ldw	r2,-32400(gp)
81116df0:	100f883a 	mov	r7,r2
81116df4:	01800884 	movi	r6,34
81116df8:	01400044 	movi	r5,1
81116dfc:	01204574 	movhi	r4,33045
81116e00:	2123f604 	addi	r4,r4,-28712
81116e04:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e08:	0001883a 	nop
81116e0c:	e037883a 	mov	sp,fp
81116e10:	dfc00117 	ldw	ra,4(sp)
81116e14:	df000017 	ldw	fp,0(sp)
81116e18:	dec00204 	addi	sp,sp,8
81116e1c:	f800283a 	ret

81116e20 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
81116e20:	defffe04 	addi	sp,sp,-8
81116e24:	de00012e 	bgeu	sp,et,81116e2c <vFailGetCountSemaphorexBuffer32+0xc>
81116e28:	003b68fa 	trap	3
81116e2c:	dfc00115 	stw	ra,4(sp)
81116e30:	df000015 	stw	fp,0(sp)
81116e34:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
81116e38:	d0a05c17 	ldw	r2,-32400(gp)
81116e3c:	100f883a 	mov	r7,r2
81116e40:	01800a04 	movi	r6,40
81116e44:	01400044 	movi	r5,1
81116e48:	01204574 	movhi	r4,33045
81116e4c:	21240a04 	addi	r4,r4,-28632
81116e50:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81116e54:	d0a05c17 	ldw	r2,-32400(gp)
81116e58:	100f883a 	mov	r7,r2
81116e5c:	01800884 	movi	r6,34
81116e60:	01400044 	movi	r5,1
81116e64:	01204574 	movhi	r4,33045
81116e68:	2123f604 	addi	r4,r4,-28712
81116e6c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e70:	0001883a 	nop
81116e74:	e037883a 	mov	sp,fp
81116e78:	dfc00117 	ldw	ra,4(sp)
81116e7c:	df000017 	ldw	fp,0(sp)
81116e80:	dec00204 	addi	sp,sp,8
81116e84:	f800283a 	ret

81116e88 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
81116e88:	defffe04 	addi	sp,sp,-8
81116e8c:	de00012e 	bgeu	sp,et,81116e94 <vFailFoundBufferRetransmission+0xc>
81116e90:	003b68fa 	trap	3
81116e94:	dfc00115 	stw	ra,4(sp)
81116e98:	df000015 	stw	fp,0(sp)
81116e9c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
81116ea0:	d0a05c17 	ldw	r2,-32400(gp)
81116ea4:	100f883a 	mov	r7,r2
81116ea8:	01800a84 	movi	r6,42
81116eac:	01400044 	movi	r5,1
81116eb0:	01204574 	movhi	r4,33045
81116eb4:	21241504 	addi	r4,r4,-28588
81116eb8:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
81116ebc:	d0a05c17 	ldw	r2,-32400(gp)
81116ec0:	100f883a 	mov	r7,r2
81116ec4:	01801204 	movi	r6,72
81116ec8:	01400044 	movi	r5,1
81116ecc:	01204574 	movhi	r4,33045
81116ed0:	21242004 	addi	r4,r4,-28544
81116ed4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116ed8:	0001883a 	nop
81116edc:	e037883a 	mov	sp,fp
81116ee0:	dfc00117 	ldw	ra,4(sp)
81116ee4:	df000017 	ldw	fp,0(sp)
81116ee8:	dec00204 	addi	sp,sp,8
81116eec:	f800283a 	ret

81116ef0 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
81116ef0:	defffe04 	addi	sp,sp,-8
81116ef4:	de00012e 	bgeu	sp,et,81116efc <vFailGetCountSemaphorePreParsedBuffer+0xc>
81116ef8:	003b68fa 	trap	3
81116efc:	dfc00115 	stw	ra,4(sp)
81116f00:	df000015 	stw	fp,0(sp)
81116f04:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
81116f08:	d0a05c17 	ldw	r2,-32400(gp)
81116f0c:	100f883a 	mov	r7,r2
81116f10:	01800b84 	movi	r6,46
81116f14:	01400044 	movi	r5,1
81116f18:	01204574 	movhi	r4,33045
81116f1c:	21243304 	addi	r4,r4,-28468
81116f20:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
81116f24:	d0a05c17 	ldw	r2,-32400(gp)
81116f28:	100f883a 	mov	r7,r2
81116f2c:	018010c4 	movi	r6,67
81116f30:	01400044 	movi	r5,1
81116f34:	01204574 	movhi	r4,33045
81116f38:	21243f04 	addi	r4,r4,-28420
81116f3c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116f40:	0001883a 	nop
81116f44:	e037883a 	mov	sp,fp
81116f48:	dfc00117 	ldw	ra,4(sp)
81116f4c:	df000017 	ldw	fp,0(sp)
81116f50:	dec00204 	addi	sp,sp,8
81116f54:	f800283a 	ret

81116f58 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
81116f58:	defffe04 	addi	sp,sp,-8
81116f5c:	de00012e 	bgeu	sp,et,81116f64 <vFailGetxMutexPreParsedParserRxTask+0xc>
81116f60:	003b68fa 	trap	3
81116f64:	dfc00115 	stw	ra,4(sp)
81116f68:	df000015 	stw	fp,0(sp)
81116f6c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
81116f70:	d0a05c17 	ldw	r2,-32400(gp)
81116f74:	100f883a 	mov	r7,r2
81116f78:	01800b04 	movi	r6,44
81116f7c:	01400044 	movi	r5,1
81116f80:	01204574 	movhi	r4,33045
81116f84:	21245004 	addi	r4,r4,-28352
81116f88:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
81116f8c:	d0a05c17 	ldw	r2,-32400(gp)
81116f90:	100f883a 	mov	r7,r2
81116f94:	01800fc4 	movi	r6,63
81116f98:	01400044 	movi	r5,1
81116f9c:	01204574 	movhi	r4,33045
81116fa0:	21245c04 	addi	r4,r4,-28304
81116fa4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116fa8:	0001883a 	nop
81116fac:	e037883a 	mov	sp,fp
81116fb0:	dfc00117 	ldw	ra,4(sp)
81116fb4:	df000017 	ldw	fp,0(sp)
81116fb8:	dec00204 	addi	sp,sp,8
81116fbc:	f800283a 	ret

81116fc0 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
81116fc0:	defffe04 	addi	sp,sp,-8
81116fc4:	de00012e 	bgeu	sp,et,81116fcc <vNoContentInPreParsedBuffer+0xc>
81116fc8:	003b68fa 	trap	3
81116fcc:	dfc00115 	stw	ra,4(sp)
81116fd0:	df000015 	stw	fp,0(sp)
81116fd4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
81116fd8:	d0a05c17 	ldw	r2,-32400(gp)
81116fdc:	100f883a 	mov	r7,r2
81116fe0:	01800904 	movi	r6,36
81116fe4:	01400044 	movi	r5,1
81116fe8:	01204574 	movhi	r4,33045
81116fec:	21246c04 	addi	r4,r4,-28240
81116ff0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
81116ff4:	d0a05c17 	ldw	r2,-32400(gp)
81116ff8:	100f883a 	mov	r7,r2
81116ffc:	01801684 	movi	r6,90
81117000:	01400044 	movi	r5,1
81117004:	01204574 	movhi	r4,33045
81117008:	21247604 	addi	r4,r4,-28200
8111700c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117010:	0001883a 	nop
81117014:	e037883a 	mov	sp,fp
81117018:	dfc00117 	ldw	ra,4(sp)
8111701c:	df000017 	ldw	fp,0(sp)
81117020:	dec00204 	addi	sp,sp,8
81117024:	f800283a 	ret

81117028 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
81117028:	defffe04 	addi	sp,sp,-8
8111702c:	de00012e 	bgeu	sp,et,81117034 <vCouldNotSendEthConfUART+0xc>
81117030:	003b68fa 	trap	3
81117034:	dfc00115 	stw	ra,4(sp)
81117038:	df000015 	stw	fp,0(sp)
8111703c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
81117040:	d0a05c17 	ldw	r2,-32400(gp)
81117044:	100f883a 	mov	r7,r2
81117048:	01800844 	movi	r6,33
8111704c:	01400044 	movi	r5,1
81117050:	01204574 	movhi	r4,33045
81117054:	21248d04 	addi	r4,r4,-28108
81117058:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111705c:	d0a05c17 	ldw	r2,-32400(gp)
81117060:	100f883a 	mov	r7,r2
81117064:	01801784 	movi	r6,94
81117068:	01400044 	movi	r5,1
8111706c:	01204574 	movhi	r4,33045
81117070:	21249604 	addi	r4,r4,-28072
81117074:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117078:	0001883a 	nop
8111707c:	e037883a 	mov	sp,fp
81117080:	dfc00117 	ldw	ra,4(sp)
81117084:	df000017 	ldw	fp,0(sp)
81117088:	dec00204 	addi	sp,sp,8
8111708c:	f800283a 	ret

81117090 <vFailSendNack>:

void vFailSendNack( void )
{
81117090:	defffe04 	addi	sp,sp,-8
81117094:	de00012e 	bgeu	sp,et,8111709c <vFailSendNack+0xc>
81117098:	003b68fa 	trap	3
8111709c:	dfc00115 	stw	ra,4(sp)
811170a0:	df000015 	stw	fp,0(sp)
811170a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
811170a8:	d0a05c17 	ldw	r2,-32400(gp)
811170ac:	100f883a 	mov	r7,r2
811170b0:	01800584 	movi	r6,22
811170b4:	01400044 	movi	r5,1
811170b8:	01204574 	movhi	r4,33045
811170bc:	2124ae04 	addi	r4,r4,-27976
811170c0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
811170c4:	d0a05c17 	ldw	r2,-32400(gp)
811170c8:	100f883a 	mov	r7,r2
811170cc:	01800a84 	movi	r6,42
811170d0:	01400044 	movi	r5,1
811170d4:	01204574 	movhi	r4,33045
811170d8:	2124b404 	addi	r4,r4,-27952
811170dc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811170e0:	0001883a 	nop
811170e4:	e037883a 	mov	sp,fp
811170e8:	dfc00117 	ldw	ra,4(sp)
811170ec:	df000017 	ldw	fp,0(sp)
811170f0:	dec00204 	addi	sp,sp,8
811170f4:	f800283a 	ret

811170f8 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
811170f8:	defffe04 	addi	sp,sp,-8
811170fc:	de00012e 	bgeu	sp,et,81117104 <vFailSetPreAckSenderBuffer+0xc>
81117100:	003b68fa 	trap	3
81117104:	dfc00115 	stw	ra,4(sp)
81117108:	df000015 	stw	fp,0(sp)
8111710c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
81117110:	d0a05c17 	ldw	r2,-32400(gp)
81117114:	100f883a 	mov	r7,r2
81117118:	018008c4 	movi	r6,35
8111711c:	01400044 	movi	r5,1
81117120:	01204574 	movhi	r4,33045
81117124:	2124bf04 	addi	r4,r4,-27908
81117128:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111712c:	d0a05c17 	ldw	r2,-32400(gp)
81117130:	100f883a 	mov	r7,r2
81117134:	01801584 	movi	r6,86
81117138:	01400044 	movi	r5,1
8111713c:	01204574 	movhi	r4,33045
81117140:	2124c804 	addi	r4,r4,-27872
81117144:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117148:	0001883a 	nop
8111714c:	e037883a 	mov	sp,fp
81117150:	dfc00117 	ldw	ra,4(sp)
81117154:	df000017 	ldw	fp,0(sp)
81117158:	dec00204 	addi	sp,sp,8
8111715c:	f800283a 	ret

81117160 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
81117160:	defffe04 	addi	sp,sp,-8
81117164:	de00012e 	bgeu	sp,et,8111716c <vFailSetPreParsedBuffer+0xc>
81117168:	003b68fa 	trap	3
8111716c:	dfc00115 	stw	ra,4(sp)
81117170:	df000015 	stw	fp,0(sp)
81117174:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
81117178:	d0a05c17 	ldw	r2,-32400(gp)
8111717c:	100f883a 	mov	r7,r2
81117180:	01800804 	movi	r6,32
81117184:	01400044 	movi	r5,1
81117188:	01204574 	movhi	r4,33045
8111718c:	2124de04 	addi	r4,r4,-27784
81117190:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
81117194:	d0a05c17 	ldw	r2,-32400(gp)
81117198:	100f883a 	mov	r7,r2
8111719c:	018013c4 	movi	r6,79
811171a0:	01400044 	movi	r5,1
811171a4:	01204574 	movhi	r4,33045
811171a8:	2124e704 	addi	r4,r4,-27748
811171ac:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811171b0:	0001883a 	nop
811171b4:	e037883a 	mov	sp,fp
811171b8:	dfc00117 	ldw	ra,4(sp)
811171bc:	df000017 	ldw	fp,0(sp)
811171c0:	dec00204 	addi	sp,sp,8
811171c4:	f800283a 	ret

811171c8 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
811171c8:	defffe04 	addi	sp,sp,-8
811171cc:	de00012e 	bgeu	sp,et,811171d4 <vFailSetPreAckReceiverBuffer+0xc>
811171d0:	003b68fa 	trap	3
811171d4:	dfc00115 	stw	ra,4(sp)
811171d8:	df000015 	stw	fp,0(sp)
811171dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
811171e0:	d0a05c17 	ldw	r2,-32400(gp)
811171e4:	100f883a 	mov	r7,r2
811171e8:	01800944 	movi	r6,37
811171ec:	01400044 	movi	r5,1
811171f0:	01204574 	movhi	r4,33045
811171f4:	2124fb04 	addi	r4,r4,-27668
811171f8:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
811171fc:	d0a05c17 	ldw	r2,-32400(gp)
81117200:	100f883a 	mov	r7,r2
81117204:	018015c4 	movi	r6,87
81117208:	01400044 	movi	r5,1
8111720c:	01204574 	movhi	r4,33045
81117210:	21250504 	addi	r4,r4,-27628
81117214:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117218:	0001883a 	nop
8111721c:	e037883a 	mov	sp,fp
81117220:	dfc00117 	ldw	ra,4(sp)
81117224:	df000017 	ldw	fp,0(sp)
81117228:	dec00204 	addi	sp,sp,8
8111722c:	f800283a 	ret

81117230 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
81117230:	defffe04 	addi	sp,sp,-8
81117234:	de00012e 	bgeu	sp,et,8111723c <vFailParserCommTaskCreate+0xc>
81117238:	003b68fa 	trap	3
8111723c:	dfc00115 	stw	ra,4(sp)
81117240:	df000015 	stw	fp,0(sp)
81117244:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
81117248:	d0a05c17 	ldw	r2,-32400(gp)
8111724c:	100f883a 	mov	r7,r2
81117250:	01800684 	movi	r6,26
81117254:	01400044 	movi	r5,1
81117258:	01204574 	movhi	r4,33045
8111725c:	21251b04 	addi	r4,r4,-27540
81117260:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117264:	0001883a 	nop
81117268:	e037883a 	mov	sp,fp
8111726c:	dfc00117 	ldw	ra,4(sp)
81117270:	df000017 	ldw	fp,0(sp)
81117274:	dec00204 	addi	sp,sp,8
81117278:	f800283a 	ret

8111727c <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111727c:	defffe04 	addi	sp,sp,-8
81117280:	de00012e 	bgeu	sp,et,81117288 <vFailInAckHandlerTaskCreate+0xc>
81117284:	003b68fa 	trap	3
81117288:	dfc00115 	stw	ra,4(sp)
8111728c:	df000015 	stw	fp,0(sp)
81117290:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81117294:	d0a05c17 	ldw	r2,-32400(gp)
81117298:	100f883a 	mov	r7,r2
8111729c:	01800704 	movi	r6,28
811172a0:	01400044 	movi	r5,1
811172a4:	01204574 	movhi	r4,33045
811172a8:	21252204 	addi	r4,r4,-27512
811172ac:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811172b0:	0001883a 	nop
811172b4:	e037883a 	mov	sp,fp
811172b8:	dfc00117 	ldw	ra,4(sp)
811172bc:	df000017 	ldw	fp,0(sp)
811172c0:	dec00204 	addi	sp,sp,8
811172c4:	f800283a 	ret

811172c8 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
811172c8:	defffe04 	addi	sp,sp,-8
811172cc:	de00012e 	bgeu	sp,et,811172d4 <vFailOutAckHandlerTaskCreate+0xc>
811172d0:	003b68fa 	trap	3
811172d4:	dfc00115 	stw	ra,4(sp)
811172d8:	df000015 	stw	fp,0(sp)
811172dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
811172e0:	d0a05c17 	ldw	r2,-32400(gp)
811172e4:	100f883a 	mov	r7,r2
811172e8:	01800704 	movi	r6,28
811172ec:	01400044 	movi	r5,1
811172f0:	01204574 	movhi	r4,33045
811172f4:	21252204 	addi	r4,r4,-27512
811172f8:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811172fc:	0001883a 	nop
81117300:	e037883a 	mov	sp,fp
81117304:	dfc00117 	ldw	ra,4(sp)
81117308:	df000017 	ldw	fp,0(sp)
8111730c:	dec00204 	addi	sp,sp,8
81117310:	f800283a 	ret

81117314 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
81117314:	defffe04 	addi	sp,sp,-8
81117318:	de00012e 	bgeu	sp,et,81117320 <vFailCreateTimerRetransmisison+0xc>
8111731c:	003b68fa 	trap	3
81117320:	dfc00115 	stw	ra,4(sp)
81117324:	df000015 	stw	fp,0(sp)
81117328:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111732c:	d0a05c17 	ldw	r2,-32400(gp)
81117330:	100f883a 	mov	r7,r2
81117334:	018007c4 	movi	r6,31
81117338:	01400044 	movi	r5,1
8111733c:	01204574 	movhi	r4,33045
81117340:	21252a04 	addi	r4,r4,-27480
81117344:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117348:	0001883a 	nop
8111734c:	e037883a 	mov	sp,fp
81117350:	dfc00117 	ldw	ra,4(sp)
81117354:	df000017 	ldw	fp,0(sp)
81117358:	dec00204 	addi	sp,sp,8
8111735c:	f800283a 	ret

81117360 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
81117360:	defffe04 	addi	sp,sp,-8
81117364:	de00012e 	bgeu	sp,et,8111736c <vCouldNotCheckBufferTimeOutFunction+0xc>
81117368:	003b68fa 	trap	3
8111736c:	dfc00115 	stw	ra,4(sp)
81117370:	df000015 	stw	fp,0(sp)
81117374:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
81117378:	d0a05c17 	ldw	r2,-32400(gp)
8111737c:	100f883a 	mov	r7,r2
81117380:	01800904 	movi	r6,36
81117384:	01400044 	movi	r5,1
81117388:	01204574 	movhi	r4,33045
8111738c:	21253204 	addi	r4,r4,-27448
81117390:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117394:	0001883a 	nop
81117398:	e037883a 	mov	sp,fp
8111739c:	dfc00117 	ldw	ra,4(sp)
811173a0:	df000017 	ldw	fp,0(sp)
811173a4:	dec00204 	addi	sp,sp,8
811173a8:	f800283a 	ret

811173ac <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
811173ac:	defffe04 	addi	sp,sp,-8
811173b0:	de00012e 	bgeu	sp,et,811173b8 <vFailTimeoutCheckerTaskCreate+0xc>
811173b4:	003b68fa 	trap	3
811173b8:	dfc00115 	stw	ra,4(sp)
811173bc:	df000015 	stw	fp,0(sp)
811173c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
811173c4:	d0a05c17 	ldw	r2,-32400(gp)
811173c8:	100f883a 	mov	r7,r2
811173cc:	01800a04 	movi	r6,40
811173d0:	01400044 	movi	r5,1
811173d4:	01204574 	movhi	r4,33045
811173d8:	21253c04 	addi	r4,r4,-27408
811173dc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811173e0:	0001883a 	nop
811173e4:	e037883a 	mov	sp,fp
811173e8:	dfc00117 	ldw	ra,4(sp)
811173ec:	df000017 	ldw	fp,0(sp)
811173f0:	dec00204 	addi	sp,sp,8
811173f4:	f800283a 	ret

811173f8 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
811173f8:	defffe04 	addi	sp,sp,-8
811173fc:	de00012e 	bgeu	sp,et,81117404 <vFailGetBlockingSemTimeoutTask+0xc>
81117400:	003b68fa 	trap	3
81117404:	dfc00115 	stw	ra,4(sp)
81117408:	df000015 	stw	fp,0(sp)
8111740c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
81117410:	d0a05c17 	ldw	r2,-32400(gp)
81117414:	100f883a 	mov	r7,r2
81117418:	018009c4 	movi	r6,39
8111741c:	01400044 	movi	r5,1
81117420:	01204574 	movhi	r4,33045
81117424:	21254704 	addi	r4,r4,-27364
81117428:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111742c:	d0a05c17 	ldw	r2,-32400(gp)
81117430:	100f883a 	mov	r7,r2
81117434:	01800cc4 	movi	r6,51
81117438:	01400044 	movi	r5,1
8111743c:	01204574 	movhi	r4,33045
81117440:	21255104 	addi	r4,r4,-27324
81117444:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117448:	0001883a 	nop
8111744c:	e037883a 	mov	sp,fp
81117450:	dfc00117 	ldw	ra,4(sp)
81117454:	df000017 	ldw	fp,0(sp)
81117458:	dec00204 	addi	sp,sp,8
8111745c:	f800283a 	ret

81117460 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
81117460:	defffe04 	addi	sp,sp,-8
81117464:	de00012e 	bgeu	sp,et,8111746c <vFailPostBlockingSemTimeoutTask+0xc>
81117468:	003b68fa 	trap	3
8111746c:	dfc00115 	stw	ra,4(sp)
81117470:	df000015 	stw	fp,0(sp)
81117474:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
81117478:	d0a05c17 	ldw	r2,-32400(gp)
8111747c:	100f883a 	mov	r7,r2
81117480:	01800a04 	movi	r6,40
81117484:	01400044 	movi	r5,1
81117488:	01204574 	movhi	r4,33045
8111748c:	21255e04 	addi	r4,r4,-27272
81117490:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
81117494:	d0a05c17 	ldw	r2,-32400(gp)
81117498:	100f883a 	mov	r7,r2
8111749c:	01800c84 	movi	r6,50
811174a0:	01400044 	movi	r5,1
811174a4:	01204574 	movhi	r4,33045
811174a8:	21256904 	addi	r4,r4,-27228
811174ac:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811174b0:	0001883a 	nop
811174b4:	e037883a 	mov	sp,fp
811174b8:	dfc00117 	ldw	ra,4(sp)
811174bc:	df000017 	ldw	fp,0(sp)
811174c0:	dec00204 	addi	sp,sp,8
811174c4:	f800283a 	ret

811174c8 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
811174c8:	defffe04 	addi	sp,sp,-8
811174cc:	de00012e 	bgeu	sp,et,811174d4 <vFailCouldNotRetransmitTimeoutTask+0xc>
811174d0:	003b68fa 	trap	3
811174d4:	dfc00115 	stw	ra,4(sp)
811174d8:	df000015 	stw	fp,0(sp)
811174dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
811174e0:	d0a05c17 	ldw	r2,-32400(gp)
811174e4:	100f883a 	mov	r7,r2
811174e8:	01800ac4 	movi	r6,43
811174ec:	01400044 	movi	r5,1
811174f0:	01204574 	movhi	r4,33045
811174f4:	21257604 	addi	r4,r4,-27176
811174f8:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
811174fc:	d0a05c17 	ldw	r2,-32400(gp)
81117500:	100f883a 	mov	r7,r2
81117504:	01801644 	movi	r6,89
81117508:	01400044 	movi	r5,1
8111750c:	01204574 	movhi	r4,33045
81117510:	21258104 	addi	r4,r4,-27132
81117514:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117518:	0001883a 	nop
8111751c:	e037883a 	mov	sp,fp
81117520:	dfc00117 	ldw	ra,4(sp)
81117524:	df000017 	ldw	fp,0(sp)
81117528:	dec00204 	addi	sp,sp,8
8111752c:	f800283a 	ret

81117530 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
81117530:	defffe04 	addi	sp,sp,-8
81117534:	de00012e 	bgeu	sp,et,8111753c <vCouldNotRetransmitB32TimeoutTask+0xc>
81117538:	003b68fa 	trap	3
8111753c:	dfc00115 	stw	ra,4(sp)
81117540:	df000015 	stw	fp,0(sp)
81117544:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
81117548:	d0a05c17 	ldw	r2,-32400(gp)
8111754c:	100f883a 	mov	r7,r2
81117550:	01800a84 	movi	r6,42
81117554:	01400044 	movi	r5,1
81117558:	01204574 	movhi	r4,33045
8111755c:	21259804 	addi	r4,r4,-27040
81117560:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
81117564:	d0a05c17 	ldw	r2,-32400(gp)
81117568:	100f883a 	mov	r7,r2
8111756c:	01801444 	movi	r6,81
81117570:	01400044 	movi	r5,1
81117574:	01204574 	movhi	r4,33045
81117578:	2125a304 	addi	r4,r4,-26996
8111757c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117580:	0001883a 	nop
81117584:	e037883a 	mov	sp,fp
81117588:	dfc00117 	ldw	ra,4(sp)
8111758c:	df000017 	ldw	fp,0(sp)
81117590:	dec00204 	addi	sp,sp,8
81117594:	f800283a 	ret

81117598 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
81117598:	defffe04 	addi	sp,sp,-8
8111759c:	de00012e 	bgeu	sp,et,811175a4 <vCouldNotRetransmitB64TimeoutTask+0xc>
811175a0:	003b68fa 	trap	3
811175a4:	dfc00115 	stw	ra,4(sp)
811175a8:	df000015 	stw	fp,0(sp)
811175ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
811175b0:	d0a05c17 	ldw	r2,-32400(gp)
811175b4:	100f883a 	mov	r7,r2
811175b8:	01800a84 	movi	r6,42
811175bc:	01400044 	movi	r5,1
811175c0:	01204574 	movhi	r4,33045
811175c4:	2125b804 	addi	r4,r4,-26912
811175c8:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
811175cc:	d0a05c17 	ldw	r2,-32400(gp)
811175d0:	100f883a 	mov	r7,r2
811175d4:	01801444 	movi	r6,81
811175d8:	01400044 	movi	r5,1
811175dc:	01204574 	movhi	r4,33045
811175e0:	2125c304 	addi	r4,r4,-26868
811175e4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811175e8:	0001883a 	nop
811175ec:	e037883a 	mov	sp,fp
811175f0:	dfc00117 	ldw	ra,4(sp)
811175f4:	df000017 	ldw	fp,0(sp)
811175f8:	dec00204 	addi	sp,sp,8
811175fc:	f800283a 	ret

81117600 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
81117600:	defffe04 	addi	sp,sp,-8
81117604:	de00012e 	bgeu	sp,et,8111760c <vCouldNotRetransmitB128TimeoutTask+0xc>
81117608:	003b68fa 	trap	3
8111760c:	dfc00115 	stw	ra,4(sp)
81117610:	df000015 	stw	fp,0(sp)
81117614:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
81117618:	d0a05c17 	ldw	r2,-32400(gp)
8111761c:	100f883a 	mov	r7,r2
81117620:	01800ac4 	movi	r6,43
81117624:	01400044 	movi	r5,1
81117628:	01204574 	movhi	r4,33045
8111762c:	2125d804 	addi	r4,r4,-26784
81117630:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
81117634:	d0a05c17 	ldw	r2,-32400(gp)
81117638:	100f883a 	mov	r7,r2
8111763c:	01801484 	movi	r6,82
81117640:	01400044 	movi	r5,1
81117644:	01204574 	movhi	r4,33045
81117648:	2125e304 	addi	r4,r4,-26740
8111764c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117650:	0001883a 	nop
81117654:	e037883a 	mov	sp,fp
81117658:	dfc00117 	ldw	ra,4(sp)
8111765c:	df000017 	ldw	fp,0(sp)
81117660:	dec00204 	addi	sp,sp,8
81117664:	f800283a 	ret

81117668 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
81117668:	defffe04 	addi	sp,sp,-8
8111766c:	de00012e 	bgeu	sp,et,81117674 <vFailStartTimerRetransmission+0xc>
81117670:	003b68fa 	trap	3
81117674:	dfc00115 	stw	ra,4(sp)
81117678:	df000015 	stw	fp,0(sp)
8111767c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
81117680:	d0a05c17 	ldw	r2,-32400(gp)
81117684:	100f883a 	mov	r7,r2
81117688:	01800984 	movi	r6,38
8111768c:	01400044 	movi	r5,1
81117690:	01204574 	movhi	r4,33045
81117694:	2125f804 	addi	r4,r4,-26656
81117698:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111769c:	d0a05c17 	ldw	r2,-32400(gp)
811176a0:	100f883a 	mov	r7,r2
811176a4:	01800d44 	movi	r6,53
811176a8:	01400044 	movi	r5,1
811176ac:	01204574 	movhi	r4,33045
811176b0:	21260204 	addi	r4,r4,-26616
811176b4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811176b8:	0001883a 	nop
811176bc:	e037883a 	mov	sp,fp
811176c0:	dfc00117 	ldw	ra,4(sp)
811176c4:	df000017 	ldw	fp,0(sp)
811176c8:	dec00204 	addi	sp,sp,8
811176cc:	f800283a 	ret

811176d0 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
811176d0:	defffe04 	addi	sp,sp,-8
811176d4:	de00012e 	bgeu	sp,et,811176dc <vCouldNotSendTurnOff+0xc>
811176d8:	003b68fa 	trap	3
811176dc:	dfc00115 	stw	ra,4(sp)
811176e0:	df000015 	stw	fp,0(sp)
811176e4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
811176e8:	d0a05c17 	ldw	r2,-32400(gp)
811176ec:	100f883a 	mov	r7,r2
811176f0:	01800744 	movi	r6,29
811176f4:	01400044 	movi	r5,1
811176f8:	01204574 	movhi	r4,33045
811176fc:	21261004 	addi	r4,r4,-26560
81117700:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
81117704:	d0a05c17 	ldw	r2,-32400(gp)
81117708:	100f883a 	mov	r7,r2
8111770c:	01800984 	movi	r6,38
81117710:	01400044 	movi	r5,1
81117714:	01204574 	movhi	r4,33045
81117718:	21261804 	addi	r4,r4,-26528
8111771c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117720:	0001883a 	nop
81117724:	e037883a 	mov	sp,fp
81117728:	dfc00117 	ldw	ra,4(sp)
8111772c:	df000017 	ldw	fp,0(sp)
81117730:	dec00204 	addi	sp,sp,8
81117734:	f800283a 	ret

81117738 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
81117738:	defffe04 	addi	sp,sp,-8
8111773c:	de00012e 	bgeu	sp,et,81117744 <vCouldNotSendReset+0xc>
81117740:	003b68fa 	trap	3
81117744:	dfc00115 	stw	ra,4(sp)
81117748:	df000015 	stw	fp,0(sp)
8111774c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
81117750:	d0a05c17 	ldw	r2,-32400(gp)
81117754:	100f883a 	mov	r7,r2
81117758:	018006c4 	movi	r6,27
8111775c:	01400044 	movi	r5,1
81117760:	01204574 	movhi	r4,33045
81117764:	21262204 	addi	r4,r4,-26488
81117768:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
8111776c:	d0a05c17 	ldw	r2,-32400(gp)
81117770:	100f883a 	mov	r7,r2
81117774:	018008c4 	movi	r6,35
81117778:	01400044 	movi	r5,1
8111777c:	01204574 	movhi	r4,33045
81117780:	21262904 	addi	r4,r4,-26460
81117784:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117788:	0001883a 	nop
8111778c:	e037883a 	mov	sp,fp
81117790:	dfc00117 	ldw	ra,4(sp)
81117794:	df000017 	ldw	fp,0(sp)
81117798:	dec00204 	addi	sp,sp,8
8111779c:	f800283a 	ret

811177a0 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
811177a0:	defffe04 	addi	sp,sp,-8
811177a4:	de00012e 	bgeu	sp,et,811177ac <vCouldNotSendLog+0xc>
811177a8:	003b68fa 	trap	3
811177ac:	dfc00115 	stw	ra,4(sp)
811177b0:	df000015 	stw	fp,0(sp)
811177b4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
811177b8:	d0a05c17 	ldw	r2,-32400(gp)
811177bc:	100f883a 	mov	r7,r2
811177c0:	01800644 	movi	r6,25
811177c4:	01400044 	movi	r5,1
811177c8:	01204574 	movhi	r4,33045
811177cc:	21263204 	addi	r4,r4,-26424
811177d0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
811177d4:	d0a05c17 	ldw	r2,-32400(gp)
811177d8:	100f883a 	mov	r7,r2
811177dc:	018008c4 	movi	r6,35
811177e0:	01400044 	movi	r5,1
811177e4:	01204574 	movhi	r4,33045
811177e8:	21263904 	addi	r4,r4,-26396
811177ec:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811177f0:	0001883a 	nop
811177f4:	e037883a 	mov	sp,fp
811177f8:	dfc00117 	ldw	ra,4(sp)
811177fc:	df000017 	ldw	fp,0(sp)
81117800:	dec00204 	addi	sp,sp,8
81117804:	f800283a 	ret

81117808 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
81117808:	defffd04 	addi	sp,sp,-12
8111780c:	de00012e 	bgeu	sp,et,81117814 <vCouldNotSendTMPusCommand+0xc>
81117810:	003b68fa 	trap	3
81117814:	dfc00215 	stw	ra,8(sp)
81117818:	df000115 	stw	fp,4(sp)
8111781c:	df000104 	addi	fp,sp,4
81117820:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
81117824:	d0a05c17 	ldw	r2,-32400(gp)
81117828:	100f883a 	mov	r7,r2
8111782c:	01800884 	movi	r6,34
81117830:	01400044 	movi	r5,1
81117834:	01204574 	movhi	r4,33045
81117838:	21264204 	addi	r4,r4,-26360
8111783c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
81117840:	d0a05c17 	ldw	r2,-32400(gp)
81117844:	100f883a 	mov	r7,r2
81117848:	01800ac4 	movi	r6,43
8111784c:	01400044 	movi	r5,1
81117850:	01204574 	movhi	r4,33045
81117854:	21264b04 	addi	r4,r4,-26324
81117858:	111ba2c0 	call	8111ba2c <fwrite>
		debug(fp,"cData");
8111785c:	d0a05c17 	ldw	r2,-32400(gp)
81117860:	100f883a 	mov	r7,r2
81117864:	01800144 	movi	r6,5
81117868:	01400044 	movi	r5,1
8111786c:	01204574 	movhi	r4,33045
81117870:	21265604 	addi	r4,r4,-26280
81117874:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117878:	0001883a 	nop
8111787c:	e037883a 	mov	sp,fp
81117880:	dfc00117 	ldw	ra,4(sp)
81117884:	df000017 	ldw	fp,0(sp)
81117888:	dec00204 	addi	sp,sp,8
8111788c:	f800283a 	ret

81117890 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
81117890:	defffe04 	addi	sp,sp,-8
81117894:	de00012e 	bgeu	sp,et,8111789c <vWarnCouldNotgetMutexRetrans128+0xc>
81117898:	003b68fa 	trap	3
8111789c:	dfc00115 	stw	ra,4(sp)
811178a0:	df000015 	stw	fp,0(sp)
811178a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
811178a8:	d0a05c17 	ldw	r2,-32400(gp)
811178ac:	100f883a 	mov	r7,r2
811178b0:	01800a04 	movi	r6,40
811178b4:	01400044 	movi	r5,1
811178b8:	01204574 	movhi	r4,33045
811178bc:	21265804 	addi	r4,r4,-26272
811178c0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
811178c4:	d0a05c17 	ldw	r2,-32400(gp)
811178c8:	100f883a 	mov	r7,r2
811178cc:	018014c4 	movi	r6,83
811178d0:	01400044 	movi	r5,1
811178d4:	01204574 	movhi	r4,33045
811178d8:	21266304 	addi	r4,r4,-26228
811178dc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811178e0:	0001883a 	nop
811178e4:	e037883a 	mov	sp,fp
811178e8:	dfc00117 	ldw	ra,4(sp)
811178ec:	df000017 	ldw	fp,0(sp)
811178f0:	dec00204 	addi	sp,sp,8
811178f4:	f800283a 	ret

811178f8 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
811178f8:	defffe04 	addi	sp,sp,-8
811178fc:	de00012e 	bgeu	sp,et,81117904 <vFailCreateScheduleQueue+0xc>
81117900:	003b68fa 	trap	3
81117904:	dfc00115 	stw	ra,4(sp)
81117908:	df000015 	stw	fp,0(sp)
8111790c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
81117910:	d0a05c17 	ldw	r2,-32400(gp)
81117914:	100f883a 	mov	r7,r2
81117918:	01800844 	movi	r6,33
8111791c:	01400044 	movi	r5,1
81117920:	01204574 	movhi	r4,33045
81117924:	21267804 	addi	r4,r4,-26144
81117928:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111792c:	d0a05c17 	ldw	r2,-32400(gp)
81117930:	100f883a 	mov	r7,r2
81117934:	01801204 	movi	r6,72
81117938:	01400044 	movi	r5,1
8111793c:	01204574 	movhi	r4,33045
81117940:	21268104 	addi	r4,r4,-26108
81117944:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117948:	0001883a 	nop
8111794c:	e037883a 	mov	sp,fp
81117950:	dfc00117 	ldw	ra,4(sp)
81117954:	df000017 	ldw	fp,0(sp)
81117958:	dec00204 	addi	sp,sp,8
8111795c:	f800283a 	ret

81117960 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
81117960:	defffd04 	addi	sp,sp,-12
81117964:	de00012e 	bgeu	sp,et,8111796c <vFailCreateNFEEQueue+0xc>
81117968:	003b68fa 	trap	3
8111796c:	dfc00215 	stw	ra,8(sp)
81117970:	df000115 	stw	fp,4(sp)
81117974:	df000104 	addi	fp,sp,4
81117978:	2005883a 	mov	r2,r4
8111797c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
81117980:	d0a05c17 	ldw	r2,-32400(gp)
81117984:	100f883a 	mov	r7,r2
81117988:	01800744 	movi	r6,29
8111798c:	01400044 	movi	r5,1
81117990:	01204574 	movhi	r4,33045
81117994:	21269404 	addi	r4,r4,-26032
81117998:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111799c:	d0a05c17 	ldw	r2,-32400(gp)
811179a0:	e0ffff03 	ldbu	r3,-4(fp)
811179a4:	180d883a 	mov	r6,r3
811179a8:	01604574 	movhi	r5,33045
811179ac:	29669c04 	addi	r5,r5,-26000
811179b0:	1009883a 	mov	r4,r2
811179b4:	111c7580 	call	8111c758 <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811179b8:	0001883a 	nop
811179bc:	e037883a 	mov	sp,fp
811179c0:	dfc00117 	ldw	ra,4(sp)
811179c4:	df000017 	ldw	fp,0(sp)
811179c8:	dec00204 	addi	sp,sp,8
811179cc:	f800283a 	ret

811179d0 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
811179d0:	defffd04 	addi	sp,sp,-12
811179d4:	de00012e 	bgeu	sp,et,811179dc <vFailCreateNFEESyncQueue+0xc>
811179d8:	003b68fa 	trap	3
811179dc:	dfc00215 	stw	ra,8(sp)
811179e0:	df000115 	stw	fp,4(sp)
811179e4:	df000104 	addi	fp,sp,4
811179e8:	2005883a 	mov	r2,r4
811179ec:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
811179f0:	d0a05c17 	ldw	r2,-32400(gp)
811179f4:	100f883a 	mov	r7,r2
811179f8:	01800844 	movi	r6,33
811179fc:	01400044 	movi	r5,1
81117a00:	01204574 	movhi	r4,33045
81117a04:	2126aa04 	addi	r4,r4,-25944
81117a08:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
81117a0c:	d0a05c17 	ldw	r2,-32400(gp)
81117a10:	e0ffff03 	ldbu	r3,-4(fp)
81117a14:	180d883a 	mov	r6,r3
81117a18:	01604574 	movhi	r5,33045
81117a1c:	2966b304 	addi	r5,r5,-25908
81117a20:	1009883a 	mov	r4,r2
81117a24:	111c7580 	call	8111c758 <printf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117a28:	0001883a 	nop
81117a2c:	e037883a 	mov	sp,fp
81117a30:	dfc00117 	ldw	ra,4(sp)
81117a34:	df000017 	ldw	fp,0(sp)
81117a38:	dec00204 	addi	sp,sp,8
81117a3c:	f800283a 	ret

81117a40 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
81117a40:	defffe04 	addi	sp,sp,-8
81117a44:	de00012e 	bgeu	sp,et,81117a4c <vCoudlNotCreateNFee0Task+0xc>
81117a48:	003b68fa 	trap	3
81117a4c:	dfc00115 	stw	ra,4(sp)
81117a50:	df000015 	stw	fp,0(sp)
81117a54:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
81117a58:	d0a05c17 	ldw	r2,-32400(gp)
81117a5c:	100f883a 	mov	r7,r2
81117a60:	01800844 	movi	r6,33
81117a64:	01400044 	movi	r5,1
81117a68:	01204574 	movhi	r4,33045
81117a6c:	2126c104 	addi	r4,r4,-25852
81117a70:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
81117a74:	d0a05c17 	ldw	r2,-32400(gp)
81117a78:	100f883a 	mov	r7,r2
81117a7c:	01800784 	movi	r6,30
81117a80:	01400044 	movi	r5,1
81117a84:	01204574 	movhi	r4,33045
81117a88:	2126ca04 	addi	r4,r4,-25816
81117a8c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117a90:	0001883a 	nop
81117a94:	e037883a 	mov	sp,fp
81117a98:	dfc00117 	ldw	ra,4(sp)
81117a9c:	df000017 	ldw	fp,0(sp)
81117aa0:	dec00204 	addi	sp,sp,8
81117aa4:	f800283a 	ret

81117aa8 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
81117aa8:	defffe04 	addi	sp,sp,-8
81117aac:	de00012e 	bgeu	sp,et,81117ab4 <vCoudlNotCreateNFee1Task+0xc>
81117ab0:	003b68fa 	trap	3
81117ab4:	dfc00115 	stw	ra,4(sp)
81117ab8:	df000015 	stw	fp,0(sp)
81117abc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
81117ac0:	d0a05c17 	ldw	r2,-32400(gp)
81117ac4:	100f883a 	mov	r7,r2
81117ac8:	01800844 	movi	r6,33
81117acc:	01400044 	movi	r5,1
81117ad0:	01204574 	movhi	r4,33045
81117ad4:	2126d204 	addi	r4,r4,-25784
81117ad8:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
81117adc:	d0a05c17 	ldw	r2,-32400(gp)
81117ae0:	100f883a 	mov	r7,r2
81117ae4:	01800784 	movi	r6,30
81117ae8:	01400044 	movi	r5,1
81117aec:	01204574 	movhi	r4,33045
81117af0:	2126db04 	addi	r4,r4,-25748
81117af4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117af8:	0001883a 	nop
81117afc:	e037883a 	mov	sp,fp
81117b00:	dfc00117 	ldw	ra,4(sp)
81117b04:	df000017 	ldw	fp,0(sp)
81117b08:	dec00204 	addi	sp,sp,8
81117b0c:	f800283a 	ret

81117b10 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
81117b10:	defffe04 	addi	sp,sp,-8
81117b14:	de00012e 	bgeu	sp,et,81117b1c <vCoudlNotCreateNFee2Task+0xc>
81117b18:	003b68fa 	trap	3
81117b1c:	dfc00115 	stw	ra,4(sp)
81117b20:	df000015 	stw	fp,0(sp)
81117b24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
81117b28:	d0a05c17 	ldw	r2,-32400(gp)
81117b2c:	100f883a 	mov	r7,r2
81117b30:	01800844 	movi	r6,33
81117b34:	01400044 	movi	r5,1
81117b38:	01204574 	movhi	r4,33045
81117b3c:	2126e304 	addi	r4,r4,-25716
81117b40:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
81117b44:	d0a05c17 	ldw	r2,-32400(gp)
81117b48:	100f883a 	mov	r7,r2
81117b4c:	01800784 	movi	r6,30
81117b50:	01400044 	movi	r5,1
81117b54:	01204574 	movhi	r4,33045
81117b58:	2126ec04 	addi	r4,r4,-25680
81117b5c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117b60:	0001883a 	nop
81117b64:	e037883a 	mov	sp,fp
81117b68:	dfc00117 	ldw	ra,4(sp)
81117b6c:	df000017 	ldw	fp,0(sp)
81117b70:	dec00204 	addi	sp,sp,8
81117b74:	f800283a 	ret

81117b78 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
81117b78:	defffe04 	addi	sp,sp,-8
81117b7c:	de00012e 	bgeu	sp,et,81117b84 <vCoudlNotCreateNFee3Task+0xc>
81117b80:	003b68fa 	trap	3
81117b84:	dfc00115 	stw	ra,4(sp)
81117b88:	df000015 	stw	fp,0(sp)
81117b8c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
81117b90:	d0a05c17 	ldw	r2,-32400(gp)
81117b94:	100f883a 	mov	r7,r2
81117b98:	01800844 	movi	r6,33
81117b9c:	01400044 	movi	r5,1
81117ba0:	01204574 	movhi	r4,33045
81117ba4:	2126f404 	addi	r4,r4,-25648
81117ba8:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
81117bac:	d0a05c17 	ldw	r2,-32400(gp)
81117bb0:	100f883a 	mov	r7,r2
81117bb4:	01800784 	movi	r6,30
81117bb8:	01400044 	movi	r5,1
81117bbc:	01204574 	movhi	r4,33045
81117bc0:	2126fd04 	addi	r4,r4,-25612
81117bc4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117bc8:	0001883a 	nop
81117bcc:	e037883a 	mov	sp,fp
81117bd0:	dfc00117 	ldw	ra,4(sp)
81117bd4:	df000017 	ldw	fp,0(sp)
81117bd8:	dec00204 	addi	sp,sp,8
81117bdc:	f800283a 	ret

81117be0 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
81117be0:	defffe04 	addi	sp,sp,-8
81117be4:	de00012e 	bgeu	sp,et,81117bec <vCoudlNotCreateNFee4Task+0xc>
81117be8:	003b68fa 	trap	3
81117bec:	dfc00115 	stw	ra,4(sp)
81117bf0:	df000015 	stw	fp,0(sp)
81117bf4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
81117bf8:	d0a05c17 	ldw	r2,-32400(gp)
81117bfc:	100f883a 	mov	r7,r2
81117c00:	01800844 	movi	r6,33
81117c04:	01400044 	movi	r5,1
81117c08:	01204574 	movhi	r4,33045
81117c0c:	21270504 	addi	r4,r4,-25580
81117c10:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
81117c14:	d0a05c17 	ldw	r2,-32400(gp)
81117c18:	100f883a 	mov	r7,r2
81117c1c:	01800784 	movi	r6,30
81117c20:	01400044 	movi	r5,1
81117c24:	01204574 	movhi	r4,33045
81117c28:	21270e04 	addi	r4,r4,-25544
81117c2c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117c30:	0001883a 	nop
81117c34:	e037883a 	mov	sp,fp
81117c38:	dfc00117 	ldw	ra,4(sp)
81117c3c:	df000017 	ldw	fp,0(sp)
81117c40:	dec00204 	addi	sp,sp,8
81117c44:	f800283a 	ret

81117c48 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
81117c48:	defffe04 	addi	sp,sp,-8
81117c4c:	de00012e 	bgeu	sp,et,81117c54 <vCoudlNotCreateNFee5Task+0xc>
81117c50:	003b68fa 	trap	3
81117c54:	dfc00115 	stw	ra,4(sp)
81117c58:	df000015 	stw	fp,0(sp)
81117c5c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
81117c60:	d0a05c17 	ldw	r2,-32400(gp)
81117c64:	100f883a 	mov	r7,r2
81117c68:	01800844 	movi	r6,33
81117c6c:	01400044 	movi	r5,1
81117c70:	01204574 	movhi	r4,33045
81117c74:	21271604 	addi	r4,r4,-25512
81117c78:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
81117c7c:	d0a05c17 	ldw	r2,-32400(gp)
81117c80:	100f883a 	mov	r7,r2
81117c84:	01800784 	movi	r6,30
81117c88:	01400044 	movi	r5,1
81117c8c:	01204574 	movhi	r4,33045
81117c90:	21271f04 	addi	r4,r4,-25476
81117c94:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117c98:	0001883a 	nop
81117c9c:	e037883a 	mov	sp,fp
81117ca0:	dfc00117 	ldw	ra,4(sp)
81117ca4:	df000017 	ldw	fp,0(sp)
81117ca8:	dec00204 	addi	sp,sp,8
81117cac:	f800283a 	ret

81117cb0 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
81117cb0:	defffe04 	addi	sp,sp,-8
81117cb4:	de00012e 	bgeu	sp,et,81117cbc <vCoudlNotCreateNFeeControllerTask+0xc>
81117cb8:	003b68fa 	trap	3
81117cbc:	dfc00115 	stw	ra,4(sp)
81117cc0:	df000015 	stw	fp,0(sp)
81117cc4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
81117cc8:	d0a05c17 	ldw	r2,-32400(gp)
81117ccc:	100f883a 	mov	r7,r2
81117cd0:	01800a84 	movi	r6,42
81117cd4:	01400044 	movi	r5,1
81117cd8:	01204574 	movhi	r4,33045
81117cdc:	21272704 	addi	r4,r4,-25444
81117ce0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
81117ce4:	d0a05c17 	ldw	r2,-32400(gp)
81117ce8:	100f883a 	mov	r7,r2
81117cec:	018009c4 	movi	r6,39
81117cf0:	01400044 	movi	r5,1
81117cf4:	01204574 	movhi	r4,33045
81117cf8:	21273204 	addi	r4,r4,-25400
81117cfc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117d00:	0001883a 	nop
81117d04:	e037883a 	mov	sp,fp
81117d08:	dfc00117 	ldw	ra,4(sp)
81117d0c:	df000017 	ldw	fp,0(sp)
81117d10:	dec00204 	addi	sp,sp,8
81117d14:	f800283a 	ret

81117d18 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
81117d18:	defffe04 	addi	sp,sp,-8
81117d1c:	de00012e 	bgeu	sp,et,81117d24 <vCoudlNotCreateDataControllerTask+0xc>
81117d20:	003b68fa 	trap	3
81117d24:	dfc00115 	stw	ra,4(sp)
81117d28:	df000015 	stw	fp,0(sp)
81117d2c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
81117d30:	d0a05c17 	ldw	r2,-32400(gp)
81117d34:	100f883a 	mov	r7,r2
81117d38:	01800a84 	movi	r6,42
81117d3c:	01400044 	movi	r5,1
81117d40:	01204574 	movhi	r4,33045
81117d44:	21273c04 	addi	r4,r4,-25360
81117d48:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
81117d4c:	d0a05c17 	ldw	r2,-32400(gp)
81117d50:	100f883a 	mov	r7,r2
81117d54:	018009c4 	movi	r6,39
81117d58:	01400044 	movi	r5,1
81117d5c:	01204574 	movhi	r4,33045
81117d60:	21274704 	addi	r4,r4,-25316
81117d64:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117d68:	0001883a 	nop
81117d6c:	e037883a 	mov	sp,fp
81117d70:	dfc00117 	ldw	ra,4(sp)
81117d74:	df000017 	ldw	fp,0(sp)
81117d78:	dec00204 	addi	sp,sp,8
81117d7c:	f800283a 	ret

81117d80 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
81117d80:	defffe04 	addi	sp,sp,-8
81117d84:	de00012e 	bgeu	sp,et,81117d8c <vCoudlNotCreateMebTask+0xc>
81117d88:	003b68fa 	trap	3
81117d8c:	dfc00115 	stw	ra,4(sp)
81117d90:	df000015 	stw	fp,0(sp)
81117d94:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
81117d98:	d0a05c17 	ldw	r2,-32400(gp)
81117d9c:	100f883a 	mov	r7,r2
81117da0:	018007c4 	movi	r6,31
81117da4:	01400044 	movi	r5,1
81117da8:	01204574 	movhi	r4,33045
81117dac:	21275104 	addi	r4,r4,-25276
81117db0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
81117db4:	d0a05c17 	ldw	r2,-32400(gp)
81117db8:	100f883a 	mov	r7,r2
81117dbc:	018006c4 	movi	r6,27
81117dc0:	01400044 	movi	r5,1
81117dc4:	01204574 	movhi	r4,33045
81117dc8:	21275904 	addi	r4,r4,-25244
81117dcc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117dd0:	0001883a 	nop
81117dd4:	e037883a 	mov	sp,fp
81117dd8:	dfc00117 	ldw	ra,4(sp)
81117ddc:	df000017 	ldw	fp,0(sp)
81117de0:	dec00204 	addi	sp,sp,8
81117de4:	f800283a 	ret

81117de8 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
81117de8:	defffd04 	addi	sp,sp,-12
81117dec:	de00012e 	bgeu	sp,et,81117df4 <vFailCreateMutexSPUSQueueMeb+0xc>
81117df0:	003b68fa 	trap	3
81117df4:	dfc00215 	stw	ra,8(sp)
81117df8:	df000115 	stw	fp,4(sp)
81117dfc:	df000104 	addi	fp,sp,4
81117e00:	2005883a 	mov	r2,r4
81117e04:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
81117e08:	d0a05c17 	ldw	r2,-32400(gp)
81117e0c:	100f883a 	mov	r7,r2
81117e10:	01800944 	movi	r6,37
81117e14:	01400044 	movi	r5,1
81117e18:	01204574 	movhi	r4,33045
81117e1c:	21276004 	addi	r4,r4,-25216
81117e20:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81117e24:	e0bfff03 	ldbu	r2,-4(fp)
81117e28:	1009883a 	mov	r4,r2
81117e2c:	11165940 	call	81116594 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117e30:	0001883a 	nop
81117e34:	e037883a 	mov	sp,fp
81117e38:	dfc00117 	ldw	ra,4(sp)
81117e3c:	df000017 	ldw	fp,0(sp)
81117e40:	dec00204 	addi	sp,sp,8
81117e44:	f800283a 	ret

81117e48 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
81117e48:	defffe04 	addi	sp,sp,-8
81117e4c:	de00012e 	bgeu	sp,et,81117e54 <vFailSendPUStoMebTask+0xc>
81117e50:	003b68fa 	trap	3
81117e54:	dfc00115 	stw	ra,4(sp)
81117e58:	df000015 	stw	fp,0(sp)
81117e5c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
81117e60:	d0a05c17 	ldw	r2,-32400(gp)
81117e64:	100f883a 	mov	r7,r2
81117e68:	01800784 	movi	r6,30
81117e6c:	01400044 	movi	r5,1
81117e70:	01204574 	movhi	r4,33045
81117e74:	21276a04 	addi	r4,r4,-25176
81117e78:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117e7c:	0001883a 	nop
81117e80:	e037883a 	mov	sp,fp
81117e84:	dfc00117 	ldw	ra,4(sp)
81117e88:	df000017 	ldw	fp,0(sp)
81117e8c:	dec00204 	addi	sp,sp,8
81117e90:	f800283a 	ret

81117e94 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
81117e94:	defffe04 	addi	sp,sp,-8
81117e98:	de00012e 	bgeu	sp,et,81117ea0 <vCouldNotGetCmdQueueMeb+0xc>
81117e9c:	003b68fa 	trap	3
81117ea0:	dfc00115 	stw	ra,4(sp)
81117ea4:	df000015 	stw	fp,0(sp)
81117ea8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
81117eac:	d0a05c17 	ldw	r2,-32400(gp)
81117eb0:	100f883a 	mov	r7,r2
81117eb4:	01800a84 	movi	r6,42
81117eb8:	01400044 	movi	r5,1
81117ebc:	01204574 	movhi	r4,33045
81117ec0:	21277204 	addi	r4,r4,-25144
81117ec4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
81117ec8:	d0a05c17 	ldw	r2,-32400(gp)
81117ecc:	100f883a 	mov	r7,r2
81117ed0:	01800cc4 	movi	r6,51
81117ed4:	01400044 	movi	r5,1
81117ed8:	01204574 	movhi	r4,33045
81117edc:	21277d04 	addi	r4,r4,-25100
81117ee0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117ee4:	0001883a 	nop
81117ee8:	e037883a 	mov	sp,fp
81117eec:	dfc00117 	ldw	ra,4(sp)
81117ef0:	df000017 	ldw	fp,0(sp)
81117ef4:	dec00204 	addi	sp,sp,8
81117ef8:	f800283a 	ret

81117efc <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
81117efc:	defffe04 	addi	sp,sp,-8
81117f00:	de00012e 	bgeu	sp,et,81117f08 <vCouldNotGetMutexMebPus+0xc>
81117f04:	003b68fa 	trap	3
81117f08:	dfc00115 	stw	ra,4(sp)
81117f0c:	df000015 	stw	fp,0(sp)
81117f10:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
81117f14:	d0a05c17 	ldw	r2,-32400(gp)
81117f18:	100f883a 	mov	r7,r2
81117f1c:	01800804 	movi	r6,32
81117f20:	01400044 	movi	r5,1
81117f24:	01204574 	movhi	r4,33045
81117f28:	21278a04 	addi	r4,r4,-25048
81117f2c:	111ba2c0 	call	8111ba2c <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117f30:	0001883a 	nop
81117f34:	e037883a 	mov	sp,fp
81117f38:	dfc00117 	ldw	ra,4(sp)
81117f3c:	df000017 	ldw	fp,0(sp)
81117f40:	dec00204 	addi	sp,sp,8
81117f44:	f800283a 	ret

81117f48 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
81117f48:	defffe04 	addi	sp,sp,-8
81117f4c:	de00012e 	bgeu	sp,et,81117f54 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
81117f50:	003b68fa 	trap	3
81117f54:	dfc00115 	stw	ra,4(sp)
81117f58:	df000015 	stw	fp,0(sp)
81117f5c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
81117f60:	d0a05c17 	ldw	r2,-32400(gp)
81117f64:	100f883a 	mov	r7,r2
81117f68:	01800a44 	movi	r6,41
81117f6c:	01400044 	movi	r5,1
81117f70:	01204574 	movhi	r4,33045
81117f74:	21279304 	addi	r4,r4,-25012
81117f78:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
81117f7c:	d0a05c17 	ldw	r2,-32400(gp)
81117f80:	100f883a 	mov	r7,r2
81117f84:	01800c84 	movi	r6,50
81117f88:	01400044 	movi	r5,1
81117f8c:	01204574 	movhi	r4,33045
81117f90:	21279e04 	addi	r4,r4,-24968
81117f94:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117f98:	0001883a 	nop
81117f9c:	e037883a 	mov	sp,fp
81117fa0:	dfc00117 	ldw	ra,4(sp)
81117fa4:	df000017 	ldw	fp,0(sp)
81117fa8:	dec00204 	addi	sp,sp,8
81117fac:	f800283a 	ret

81117fb0 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
81117fb0:	defffe04 	addi	sp,sp,-8
81117fb4:	de00012e 	bgeu	sp,et,81117fbc <vCouldNotCreateQueueMaskDataCtrl+0xc>
81117fb8:	003b68fa 	trap	3
81117fbc:	dfc00115 	stw	ra,4(sp)
81117fc0:	df000015 	stw	fp,0(sp)
81117fc4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
81117fc8:	d0a05c17 	ldw	r2,-32400(gp)
81117fcc:	100f883a 	mov	r7,r2
81117fd0:	01800a44 	movi	r6,41
81117fd4:	01400044 	movi	r5,1
81117fd8:	01204574 	movhi	r4,33045
81117fdc:	2127ab04 	addi	r4,r4,-24916
81117fe0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
81117fe4:	d0a05c17 	ldw	r2,-32400(gp)
81117fe8:	100f883a 	mov	r7,r2
81117fec:	01800c84 	movi	r6,50
81117ff0:	01400044 	movi	r5,1
81117ff4:	01204574 	movhi	r4,33045
81117ff8:	2127b604 	addi	r4,r4,-24872
81117ffc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118000:	0001883a 	nop
81118004:	e037883a 	mov	sp,fp
81118008:	dfc00117 	ldw	ra,4(sp)
8111800c:	df000017 	ldw	fp,0(sp)
81118010:	dec00204 	addi	sp,sp,8
81118014:	f800283a 	ret

81118018 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
81118018:	defffe04 	addi	sp,sp,-8
8111801c:	de00012e 	bgeu	sp,et,81118024 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
81118020:	003b68fa 	trap	3
81118024:	dfc00115 	stw	ra,4(sp)
81118028:	df000015 	stw	fp,0(sp)
8111802c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
81118030:	d0a05c17 	ldw	r2,-32400(gp)
81118034:	100f883a 	mov	r7,r2
81118038:	01800984 	movi	r6,38
8111803c:	01400044 	movi	r5,1
81118040:	01204574 	movhi	r4,33045
81118044:	2127c304 	addi	r4,r4,-24820
81118048:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111804c:	d0a05c17 	ldw	r2,-32400(gp)
81118050:	100f883a 	mov	r7,r2
81118054:	01800bc4 	movi	r6,47
81118058:	01400044 	movi	r5,1
8111805c:	01204574 	movhi	r4,33045
81118060:	2127cd04 	addi	r4,r4,-24780
81118064:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118068:	0001883a 	nop
8111806c:	e037883a 	mov	sp,fp
81118070:	dfc00117 	ldw	ra,4(sp)
81118074:	df000017 	ldw	fp,0(sp)
81118078:	dec00204 	addi	sp,sp,8
8111807c:	f800283a 	ret

81118080 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
81118080:	defffe04 	addi	sp,sp,-8
81118084:	de00012e 	bgeu	sp,et,8111808c <vCouldNotGetQueueMaskDataCtrl+0xc>
81118088:	003b68fa 	trap	3
8111808c:	dfc00115 	stw	ra,4(sp)
81118090:	df000015 	stw	fp,0(sp)
81118094:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
81118098:	d0a05c17 	ldw	r2,-32400(gp)
8111809c:	100f883a 	mov	r7,r2
811180a0:	01800984 	movi	r6,38
811180a4:	01400044 	movi	r5,1
811180a8:	01204574 	movhi	r4,33045
811180ac:	2127d904 	addi	r4,r4,-24732
811180b0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
811180b4:	d0a05c17 	ldw	r2,-32400(gp)
811180b8:	100f883a 	mov	r7,r2
811180bc:	01800bc4 	movi	r6,47
811180c0:	01400044 	movi	r5,1
811180c4:	01204574 	movhi	r4,33045
811180c8:	2127e304 	addi	r4,r4,-24692
811180cc:	111ba2c0 	call	8111ba2c <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811180d0:	0001883a 	nop
811180d4:	e037883a 	mov	sp,fp
811180d8:	dfc00117 	ldw	ra,4(sp)
811180dc:	df000017 	ldw	fp,0(sp)
811180e0:	dec00204 	addi	sp,sp,8
811180e4:	f800283a 	ret

811180e8 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
811180e8:	defffd04 	addi	sp,sp,-12
811180ec:	de00012e 	bgeu	sp,et,811180f4 <vFailSendMsgAccessDMA+0xc>
811180f0:	003b68fa 	trap	3
811180f4:	dfc00215 	stw	ra,8(sp)
811180f8:	df000115 	stw	fp,4(sp)
811180fc:	df000104 	addi	fp,sp,4
81118100:	2005883a 	mov	r2,r4
81118104:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
81118108:	d0a05c17 	ldw	r2,-32400(gp)
8111810c:	e0ffff03 	ldbu	r3,-4(fp)
81118110:	180d883a 	mov	r6,r3
81118114:	01604574 	movhi	r5,33045
81118118:	2967ef04 	addi	r5,r5,-24644
8111811c:	1009883a 	mov	r4,r2
81118120:	111b3900 	call	8111b390 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118124:	0001883a 	nop
81118128:	e037883a 	mov	sp,fp
8111812c:	dfc00117 	ldw	ra,4(sp)
81118130:	df000017 	ldw	fp,0(sp)
81118134:	dec00204 	addi	sp,sp,8
81118138:	f800283a 	ret

8111813c <vFailSendMsgSync>:

void vFailSendMsgSync( unsigned char ucTemp)
{
8111813c:	defffd04 	addi	sp,sp,-12
81118140:	de00012e 	bgeu	sp,et,81118148 <vFailSendMsgSync+0xc>
81118144:	003b68fa 	trap	3
81118148:	dfc00215 	stw	ra,8(sp)
8111814c:	df000115 	stw	fp,4(sp)
81118150:	df000104 	addi	fp,sp,4
81118154:	2005883a 	mov	r2,r4
81118158:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
8111815c:	d0a05c17 	ldw	r2,-32400(gp)
81118160:	e0ffff03 	ldbu	r3,-4(fp)
81118164:	180d883a 	mov	r6,r3
81118168:	01604574 	movhi	r5,33045
8111816c:	2967f704 	addi	r5,r5,-24612
81118170:	1009883a 	mov	r4,r2
81118174:	111b3900 	call	8111b390 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118178:	0001883a 	nop
8111817c:	e037883a 	mov	sp,fp
81118180:	dfc00117 	ldw	ra,4(sp)
81118184:	df000017 	ldw	fp,0(sp)
81118188:	dec00204 	addi	sp,sp,8
8111818c:	f800283a 	ret

81118190 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
81118190:	defffe04 	addi	sp,sp,-8
81118194:	de00012e 	bgeu	sp,et,8111819c <vFailSendMsgMasterSyncMeb+0xc>
81118198:	003b68fa 	trap	3
8111819c:	dfc00115 	stw	ra,4(sp)
811181a0:	df000015 	stw	fp,0(sp)
811181a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
811181a8:	d0a05c17 	ldw	r2,-32400(gp)
811181ac:	100f883a 	mov	r7,r2
811181b0:	018006c4 	movi	r6,27
811181b4:	01400044 	movi	r5,1
811181b8:	01204574 	movhi	r4,33045
811181bc:	2127fe04 	addi	r4,r4,-24584
811181c0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811181c4:	0001883a 	nop
811181c8:	e037883a 	mov	sp,fp
811181cc:	dfc00117 	ldw	ra,4(sp)
811181d0:	df000017 	ldw	fp,0(sp)
811181d4:	dec00204 	addi	sp,sp,8
811181d8:	f800283a 	ret

811181dc <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
811181dc:	defffe04 	addi	sp,sp,-8
811181e0:	de00012e 	bgeu	sp,et,811181e8 <vFailSendMsgFeeCTRL+0xc>
811181e4:	003b68fa 	trap	3
811181e8:	dfc00115 	stw	ra,4(sp)
811181ec:	df000015 	stw	fp,0(sp)
811181f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
811181f4:	d0a05c17 	ldw	r2,-32400(gp)
811181f8:	100f883a 	mov	r7,r2
811181fc:	018005c4 	movi	r6,23
81118200:	01400044 	movi	r5,1
81118204:	01204574 	movhi	r4,33045
81118208:	21280504 	addi	r4,r4,-24556
8111820c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118210:	0001883a 	nop
81118214:	e037883a 	mov	sp,fp
81118218:	dfc00117 	ldw	ra,4(sp)
8111821c:	df000017 	ldw	fp,0(sp)
81118220:	dec00204 	addi	sp,sp,8
81118224:	f800283a 	ret

81118228 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
81118228:	defffe04 	addi	sp,sp,-8
8111822c:	de00012e 	bgeu	sp,et,81118234 <vFailSendMsgDataCTRL+0xc>
81118230:	003b68fa 	trap	3
81118234:	dfc00115 	stw	ra,4(sp)
81118238:	df000015 	stw	fp,0(sp)
8111823c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
81118240:	d0a05c17 	ldw	r2,-32400(gp)
81118244:	100f883a 	mov	r7,r2
81118248:	01800604 	movi	r6,24
8111824c:	01400044 	movi	r5,1
81118250:	01204574 	movhi	r4,33045
81118254:	21280b04 	addi	r4,r4,-24532
81118258:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111825c:	0001883a 	nop
81118260:	e037883a 	mov	sp,fp
81118264:	dfc00117 	ldw	ra,4(sp)
81118268:	df000017 	ldw	fp,0(sp)
8111826c:	dec00204 	addi	sp,sp,8
81118270:	f800283a 	ret

81118274 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
81118274:	defffe04 	addi	sp,sp,-8
81118278:	de00012e 	bgeu	sp,et,81118280 <vFailFlushQueue+0xc>
8111827c:	003b68fa 	trap	3
81118280:	dfc00115 	stw	ra,4(sp)
81118284:	df000015 	stw	fp,0(sp)
81118288:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111828c:	d0a05c17 	ldw	r2,-32400(gp)
81118290:	100f883a 	mov	r7,r2
81118294:	01800744 	movi	r6,29
81118298:	01400044 	movi	r5,1
8111829c:	01204574 	movhi	r4,33045
811182a0:	21281204 	addi	r4,r4,-24504
811182a4:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811182a8:	0001883a 	nop
811182ac:	e037883a 	mov	sp,fp
811182b0:	dfc00117 	ldw	ra,4(sp)
811182b4:	df000017 	ldw	fp,0(sp)
811182b8:	dec00204 	addi	sp,sp,8
811182bc:	f800283a 	ret

811182c0 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
811182c0:	defffe04 	addi	sp,sp,-8
811182c4:	de00012e 	bgeu	sp,et,811182cc <vFailFlushQueueData+0xc>
811182c8:	003b68fa 	trap	3
811182cc:	dfc00115 	stw	ra,4(sp)
811182d0:	df000015 	stw	fp,0(sp)
811182d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
811182d8:	d0a05c17 	ldw	r2,-32400(gp)
811182dc:	100f883a 	mov	r7,r2
811182e0:	01800844 	movi	r6,33
811182e4:	01400044 	movi	r5,1
811182e8:	01204574 	movhi	r4,33045
811182ec:	21281a04 	addi	r4,r4,-24472
811182f0:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811182f4:	0001883a 	nop
811182f8:	e037883a 	mov	sp,fp
811182fc:	dfc00117 	ldw	ra,4(sp)
81118300:	df000017 	ldw	fp,0(sp)
81118304:	dec00204 	addi	sp,sp,8
81118308:	f800283a 	ret

8111830c <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111830c:	defffe04 	addi	sp,sp,-8
81118310:	de00012e 	bgeu	sp,et,81118318 <vFailFlushMEBQueue+0xc>
81118314:	003b68fa 	trap	3
81118318:	dfc00115 	stw	ra,4(sp)
8111831c:	df000015 	stw	fp,0(sp)
81118320:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
81118324:	d0a05c17 	ldw	r2,-32400(gp)
81118328:	100f883a 	mov	r7,r2
8111832c:	01800804 	movi	r6,32
81118330:	01400044 	movi	r5,1
81118334:	01204574 	movhi	r4,33045
81118338:	21282304 	addi	r4,r4,-24436
8111833c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118340:	0001883a 	nop
81118344:	e037883a 	mov	sp,fp
81118348:	dfc00117 	ldw	ra,4(sp)
8111834c:	df000017 	ldw	fp,0(sp)
81118350:	dec00204 	addi	sp,sp,8
81118354:	f800283a 	ret

81118358 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
81118358:	defffe04 	addi	sp,sp,-8
8111835c:	de00012e 	bgeu	sp,et,81118364 <vFailFlushNFEEQueue+0xc>
81118360:	003b68fa 	trap	3
81118364:	dfc00115 	stw	ra,4(sp)
81118368:	df000015 	stw	fp,0(sp)
8111836c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
81118370:	d0a05c17 	ldw	r2,-32400(gp)
81118374:	100f883a 	mov	r7,r2
81118378:	01800844 	movi	r6,33
8111837c:	01400044 	movi	r5,1
81118380:	01204574 	movhi	r4,33045
81118384:	21282c04 	addi	r4,r4,-24400
81118388:	111ba2c0 	call	8111ba2c <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111838c:	0001883a 	nop
81118390:	e037883a 	mov	sp,fp
81118394:	dfc00117 	ldw	ra,4(sp)
81118398:	df000017 	ldw	fp,0(sp)
8111839c:	dec00204 	addi	sp,sp,8
811183a0:	f800283a 	ret

811183a4 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
811183a4:	deffff04 	addi	sp,sp,-4
811183a8:	de00012e 	bgeu	sp,et,811183b0 <vEvtChangeMebMode+0xc>
811183ac:	003b68fa 	trap	3
811183b0:	df000015 	stw	fp,0(sp)
811183b4:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
811183b8:	0001883a 	nop
811183bc:	e037883a 	mov	sp,fp
811183c0:	df000017 	ldw	fp,0(sp)
811183c4:	dec00104 	addi	sp,sp,4
811183c8:	f800283a 	ret

811183cc <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
811183cc:	deffff04 	addi	sp,sp,-4
811183d0:	de00012e 	bgeu	sp,et,811183d8 <vEvtChangeFeeControllerMode+0xc>
811183d4:	003b68fa 	trap	3
811183d8:	df000015 	stw	fp,0(sp)
811183dc:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
811183e0:	0001883a 	nop
811183e4:	e037883a 	mov	sp,fp
811183e8:	df000017 	ldw	fp,0(sp)
811183ec:	dec00104 	addi	sp,sp,4
811183f0:	f800283a 	ret

811183f4 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
811183f4:	deffff04 	addi	sp,sp,-4
811183f8:	de00012e 	bgeu	sp,et,81118400 <vEvtChangeDataControllerMode+0xc>
811183fc:	003b68fa 	trap	3
81118400:	df000015 	stw	fp,0(sp)
81118404:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81118408:	0001883a 	nop
8111840c:	e037883a 	mov	sp,fp
81118410:	df000017 	ldw	fp,0(sp)
81118414:	dec00104 	addi	sp,sp,4
81118418:	f800283a 	ret

8111841c <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111841c:	defffd04 	addi	sp,sp,-12
81118420:	de00012e 	bgeu	sp,et,81118428 <vNFeeNotInUse+0xc>
81118424:	003b68fa 	trap	3
81118428:	df000215 	stw	fp,8(sp)
8111842c:	df000204 	addi	fp,sp,8
81118430:	e13ffe15 	stw	r4,-8(fp)
81118434:	2805883a 	mov	r2,r5
81118438:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111843c:	e0bffe17 	ldw	r2,-8(fp)
81118440:	e0ffff03 	ldbu	r3,-4(fp)
81118444:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
81118448:	e0bffe17 	ldw	r2,-8(fp)
8111844c:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81118450:	e0bffe17 	ldw	r2,-8(fp)
81118454:	10002315 	stw	zero,140(r2)
}
81118458:	0001883a 	nop
8111845c:	e037883a 	mov	sp,fp
81118460:	df000017 	ldw	fp,0(sp)
81118464:	dec00104 	addi	sp,sp,4
81118468:	f800283a 	ret

8111846c <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111846c:	defffb04 	addi	sp,sp,-20
81118470:	de00012e 	bgeu	sp,et,81118478 <vNFeeStructureInit+0xc>
81118474:	003b68fa 	trap	3
81118478:	dfc00415 	stw	ra,16(sp)
8111847c:	df000315 	stw	fp,12(sp)
81118480:	df000304 	addi	fp,sp,12
81118484:	e13ffe15 	stw	r4,-8(fp)
81118488:	2805883a 	mov	r2,r5
8111848c:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
81118490:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
81118494:	e0bffe17 	ldw	r2,-8(fp)
81118498:	e0ffff03 	ldbu	r3,-4(fp)
8111849c:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
811184a0:	e0bffe17 	ldw	r2,-8(fp)
811184a4:	10802f04 	addi	r2,r2,188
811184a8:	1009883a 	mov	r4,r2
811184ac:	11142500 	call	81114250 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
811184b0:	e13ffe17 	ldw	r4,-8(fp)
811184b4:	11185ac0 	call	811185ac <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
811184b8:	e0bffe17 	ldw	r2,-8(fp)
811184bc:	00c00044 	movi	r3,1
811184c0:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
811184c4:	e0bffe17 	ldw	r2,-8(fp)
811184c8:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
811184cc:	e0bffe17 	ldw	r2,-8(fp)
811184d0:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
811184d4:	e0bffe17 	ldw	r2,-8(fp)
811184d8:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
811184dc:	e0bffe17 	ldw	r2,-8(fp)
811184e0:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
811184e4:	e0bffe17 	ldw	r2,-8(fp)
811184e8:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
811184ec:	e0bffe17 	ldw	r2,-8(fp)
811184f0:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
811184f4:	e0bffe17 	ldw	r2,-8(fp)
811184f8:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
811184fc:	e0bffe17 	ldw	r2,-8(fp)
81118500:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
81118504:	e0bffe17 	ldw	r2,-8(fp)
81118508:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111850c:	e0bffe17 	ldw	r2,-8(fp)
81118510:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
81118514:	e0bffe17 	ldw	r2,-8(fp)
81118518:	10002d15 	stw	zero,180(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111851c:	e03ffd05 	stb	zero,-12(fp)
81118520:	00000906 	br	81118548 <vNFeeStructureInit+0xdc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
81118524:	e0bffd03 	ldbu	r2,-12(fp)
81118528:	e0fffe17 	ldw	r3,-8(fp)
8111852c:	1885883a 	add	r2,r3,r2
81118530:	10802a44 	addi	r2,r2,169
81118534:	e0fffd03 	ldbu	r3,-12(fp)
81118538:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111853c:	e0bffd03 	ldbu	r2,-12(fp)
81118540:	10800044 	addi	r2,r2,1
81118544:	e0bffd05 	stb	r2,-12(fp)
81118548:	e0bffd03 	ldbu	r2,-12(fp)
8111854c:	10800130 	cmpltui	r2,r2,4
81118550:	103ff41e 	bne	r2,zero,81118524 <__reset+0xfb0f8524>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, ucIdNFEE ) == FALSE ) {
81118554:	e0bffe17 	ldw	r2,-8(fp)
81118558:	10803204 	addi	r2,r2,200
8111855c:	e0ffff03 	ldbu	r3,-4(fp)
81118560:	180b883a 	mov	r5,r3
81118564:	1009883a 	mov	r4,r2
81118568:	11044b00 	call	811044b0 <bCommInitCh>
8111856c:	1000091e 	bne	r2,zero,81118594 <vNFeeStructureInit+0x128>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
81118570:	d0e05c17 	ldw	r3,-32400(gp)
81118574:	e0bffe17 	ldw	r2,-8(fp)
81118578:	10800003 	ldbu	r2,0(r2)
8111857c:	10803fcc 	andi	r2,r2,255
81118580:	100d883a 	mov	r6,r2
81118584:	01604574 	movhi	r5,33045
81118588:	29683504 	addi	r5,r5,-24364
8111858c:	1809883a 	mov	r4,r3
81118590:	111b3900 	call	8111b390 <fprintf>
		#endif
    }

}
81118594:	0001883a 	nop
81118598:	e037883a 	mov	sp,fp
8111859c:	dfc00117 	ldw	ra,4(sp)
811185a0:	df000017 	ldw	fp,0(sp)
811185a4:	dec00204 	addi	sp,sp,8
811185a8:	f800283a 	ret

811185ac <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
811185ac:	defff404 	addi	sp,sp,-48
811185b0:	de00012e 	bgeu	sp,et,811185b8 <vUpdateMemMapFEE+0xc>
811185b4:	003b68fa 	trap	3
811185b8:	df000b15 	stw	fp,44(sp)
811185bc:	df000b04 	addi	fp,sp,44
811185c0:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
811185c4:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
811185c8:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
811185cc:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
811185d0:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
811185d4:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
811185d8:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
811185dc:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
811185e0:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
811185e4:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
811185e8:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
811185ec:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
811185f0:	e17fff17 	ldw	r5,-4(fp)
811185f4:	01035a34 	movhi	r4,3432
811185f8:	21348c04 	addi	r4,r4,-11728
811185fc:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
81118600:	e13fff17 	ldw	r4,-4(fp)
81118604:	21000003 	ldbu	r4,0(r4)
81118608:	21403fcc 	andi	r5,r4,255
8111860c:	01035a34 	movhi	r4,3432
81118610:	21348c04 	addi	r4,r4,-11728
81118614:	2909383a 	mul	r4,r5,r4
81118618:	200b883a 	mov	r5,r4
8111861c:	e13fff17 	ldw	r4,-4(fp)
81118620:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
81118624:	e13fff17 	ldw	r4,-4(fp)
81118628:	21400117 	ldw	r5,4(r4)
8111862c:	01033234 	movhi	r4,3272
81118630:	21348c04 	addi	r4,r4,-11728
81118634:	290b883a 	add	r5,r5,r4
81118638:	e13fff17 	ldw	r4,-4(fp)
8111863c:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81118640:	e13fff17 	ldw	r4,-4(fp)
81118644:	2100310b 	ldhu	r4,196(r4)
81118648:	217fffcc 	andi	r5,r4,65535
8111864c:	e13fff17 	ldw	r4,-4(fp)
81118650:	2100300b 	ldhu	r4,192(r4)
81118654:	213fffcc 	andi	r4,r4,65535
81118658:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111865c:	e13fff17 	ldw	r4,-4(fp)
81118660:	2100308b 	ldhu	r4,194(r4)
81118664:	21bfffcc 	andi	r6,r4,65535
81118668:	e13fff17 	ldw	r4,-4(fp)
8111866c:	21002f8b 	ldhu	r4,190(r4)
81118670:	213fffcc 	andi	r4,r4,65535
81118674:	310d883a 	add	r6,r6,r4
81118678:	e13fff17 	ldw	r4,-4(fp)
8111867c:	21002f0b 	ldhu	r4,188(r4)
81118680:	213fffcc 	andi	r4,r4,65535
81118684:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81118688:	2909383a 	mul	r4,r5,r4
8111868c:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
81118690:	e13ffa17 	ldw	r4,-24(fp)
81118694:	2109883a 	add	r4,r4,r4
81118698:	200b883a 	mov	r5,r4
8111869c:	e13fff17 	ldw	r4,-4(fp)
811186a0:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
811186a4:	e13fff17 	ldw	r4,-4(fp)
811186a8:	21000517 	ldw	r4,20(r4)
811186ac:	2008d0fa 	srli	r4,r4,3
811186b0:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
811186b4:	e13fff17 	ldw	r4,-4(fp)
811186b8:	21000517 	ldw	r4,20(r4)
811186bc:	210001cc 	andi	r4,r4,7
811186c0:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
811186c4:	e13ffb17 	ldw	r4,-20(fp)
811186c8:	20001226 	beq	r4,zero,81118714 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
811186cc:	e13ff517 	ldw	r4,-44(fp)
811186d0:	21000044 	addi	r4,r4,1
811186d4:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
811186d8:	e13fff17 	ldw	r4,-4(fp)
811186dc:	21400517 	ldw	r5,20(r4)
811186e0:	e13ffb17 	ldw	r4,-20(fp)
811186e4:	2909c83a 	sub	r4,r5,r4
811186e8:	21400204 	addi	r5,r4,8
811186ec:	e13fff17 	ldw	r4,-4(fp)
811186f0:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
811186f4:	e13ffb17 	ldw	r4,-20(fp)
811186f8:	200b883a 	mov	r5,r4
811186fc:	01000204 	movi	r4,8
81118700:	2149c83a 	sub	r4,r4,r5
81118704:	200b883a 	mov	r5,r4
81118708:	e13fff17 	ldw	r4,-4(fp)
8111870c:	21400605 	stb	r5,24(r4)
81118710:	00000206 	br	8111871c <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
81118714:	e13fff17 	ldw	r4,-4(fp)
81118718:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111871c:	e13ff517 	ldw	r4,-44(fp)
81118720:	2008d13a 	srli	r4,r4,4
81118724:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
81118728:	e13ff517 	ldw	r4,-44(fp)
8111872c:	210003cc 	andi	r4,r4,15
81118730:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
81118734:	e13ffc17 	ldw	r4,-16(fp)
81118738:	20000b26 	beq	r4,zero,81118768 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111873c:	e13ff717 	ldw	r4,-36(fp)
81118740:	21000044 	addi	r4,r4,1
81118744:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
81118748:	e17ff517 	ldw	r5,-44(fp)
8111874c:	e13ffc17 	ldw	r4,-16(fp)
81118750:	290bc83a 	sub	r5,r5,r4
81118754:	e13ff717 	ldw	r4,-36(fp)
81118758:	2909883a 	add	r4,r5,r4
8111875c:	21000404 	addi	r4,r4,16
81118760:	e13ff615 	stw	r4,-40(fp)
81118764:	00000406 	br	81118778 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
81118768:	e17ff517 	ldw	r5,-44(fp)
8111876c:	e13ff717 	ldw	r4,-36(fp)
81118770:	2909883a 	add	r4,r5,r4
81118774:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
81118778:	e13ff617 	ldw	r4,-40(fp)
8111877c:	200a90fa 	slli	r5,r4,3
81118780:	e13fff17 	ldw	r4,-4(fp)
81118784:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
81118788:	e13ffb17 	ldw	r4,-20(fp)
8111878c:	20000926 	beq	r4,zero,811187b4 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
81118790:	e13ffc17 	ldw	r4,-16(fp)
81118794:	2109883a 	add	r4,r4,r4
81118798:	2109883a 	add	r4,r4,r4
8111879c:	200b883a 	mov	r5,r4
811187a0:	e13ffb17 	ldw	r4,-20(fp)
811187a4:	2008d07a 	srli	r4,r4,1
811187a8:	2909883a 	add	r4,r5,r4
811187ac:	e13ff805 	stb	r4,-32(fp)
811187b0:	00000406 	br	811187c4 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
811187b4:	e13ffc17 	ldw	r4,-16(fp)
811187b8:	2109883a 	add	r4,r4,r4
811187bc:	2109883a 	add	r4,r4,r4
811187c0:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
811187c4:	e13ff803 	ldbu	r4,-32(fp)
811187c8:	01401004 	movi	r5,64
811187cc:	2909c83a 	sub	r4,r5,r4
811187d0:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
811187d4:	e13ffd03 	ldbu	r4,-12(fp)
811187d8:	217ff804 	addi	r5,r4,-32
811187dc:	28000416 	blt	r5,zero,811187f0 <vUpdateMemMapFEE+0x244>
811187e0:	013fffc4 	movi	r4,-1
811187e4:	2144d83a 	srl	r2,r4,r5
811187e8:	0007883a 	mov	r3,zero
811187ec:	00000a06 	br	81118818 <vUpdateMemMapFEE+0x26c>
811187f0:	017fffc4 	movi	r5,-1
811187f4:	280c907a 	slli	r6,r5,1
811187f8:	014007c4 	movi	r5,31
811187fc:	290bc83a 	sub	r5,r5,r4
81118800:	314a983a 	sll	r5,r6,r5
81118804:	01bfffc4 	movi	r6,-1
81118808:	3104d83a 	srl	r2,r6,r4
8111880c:	2884b03a 	or	r2,r5,r2
81118810:	017fffc4 	movi	r5,-1
81118814:	2906d83a 	srl	r3,r5,r4
81118818:	e13fff17 	ldw	r4,-4(fp)
8111881c:	20800715 	stw	r2,28(r4)
81118820:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
81118824:	e0bfff17 	ldw	r2,-4(fp)
81118828:	e0fff717 	ldw	r3,-36(fp)
8111882c:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
81118830:	e0bfff17 	ldw	r2,-4(fp)
81118834:	10c00117 	ldw	r3,4(r2)
81118838:	008004b4 	movhi	r2,18
8111883c:	10a40004 	addi	r2,r2,-28672
81118840:	1885883a 	add	r2,r3,r2
81118844:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
81118848:	e0bfff17 	ldw	r2,-4(fp)
8111884c:	10c00517 	ldw	r3,20(r2)
81118850:	008000b4 	movhi	r2,2
81118854:	10a40004 	addi	r2,r2,-28672
81118858:	1885883a 	add	r2,r3,r2
8111885c:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81118860:	e03ff845 	stb	zero,-31(fp)
81118864:	00001906 	br	811188cc <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
81118868:	e0bff843 	ldbu	r2,-31(fp)
8111886c:	e0ffff17 	ldw	r3,-4(fp)
81118870:	10800624 	muli	r2,r2,24
81118874:	1885883a 	add	r2,r3,r2
81118878:	10800904 	addi	r2,r2,36
8111887c:	e0fff917 	ldw	r3,-28(fp)
81118880:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81118884:	e0fff917 	ldw	r3,-28(fp)
81118888:	e0bffe17 	ldw	r2,-8(fp)
8111888c:	1885883a 	add	r2,r3,r2
81118890:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
81118894:	e0bff843 	ldbu	r2,-31(fp)
81118898:	e0ffff17 	ldw	r3,-4(fp)
8111889c:	10800624 	muli	r2,r2,24
811188a0:	1885883a 	add	r2,r3,r2
811188a4:	10800c04 	addi	r2,r2,48
811188a8:	e0fff917 	ldw	r3,-28(fp)
811188ac:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
811188b0:	e0fff917 	ldw	r3,-28(fp)
811188b4:	e0bffe17 	ldw	r2,-8(fp)
811188b8:	1885883a 	add	r2,r3,r2
811188bc:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
811188c0:	e0bff843 	ldbu	r2,-31(fp)
811188c4:	10800044 	addi	r2,r2,1
811188c8:	e0bff845 	stb	r2,-31(fp)
811188cc:	e0bff843 	ldbu	r2,-31(fp)
811188d0:	10800130 	cmpltui	r2,r2,4
811188d4:	103fe41e 	bne	r2,zero,81118868 <__reset+0xfb0f8868>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
811188d8:	0001883a 	nop
811188dc:	e037883a 	mov	sp,fp
811188e0:	df000017 	ldw	fp,0(sp)
811188e4:	dec00104 	addi	sp,sp,4
811188e8:	f800283a 	ret

811188ec <vFeeSpwRMAPLoadDefault>:

/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
811188ec:	defffe04 	addi	sp,sp,-8
811188f0:	de00012e 	bgeu	sp,et,811188f8 <vFeeSpwRMAPLoadDefault+0xc>
811188f4:	003b68fa 	trap	3
811188f8:	df000115 	stw	fp,4(sp)
811188fc:	df000104 	addi	fp,sp,4
81118900:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
81118904:	0001883a 	nop
81118908:	e037883a 	mov	sp,fp
8111890c:	df000017 	ldw	fp,0(sp)
81118910:	dec00104 	addi	sp,sp,4
81118914:	f800283a 	ret

81118918 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
81118918:	defffe04 	addi	sp,sp,-8
8111891c:	de00012e 	bgeu	sp,et,81118924 <vFeeSpwRMAPChangeConfig+0xc>
81118920:	003b68fa 	trap	3
81118924:	df000115 	stw	fp,4(sp)
81118928:	df000104 	addi	fp,sp,4
8111892c:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
81118930:	0001883a 	nop
81118934:	e037883a 	mov	sp,fp
81118938:	df000017 	ldw	fp,0(sp)
8111893c:	dec00104 	addi	sp,sp,4
81118940:	f800283a 	ret

81118944 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
81118944:	defffe04 	addi	sp,sp,-8
81118948:	de00012e 	bgeu	sp,et,81118950 <vFeeSpwRMAPChangeDefault+0xc>
8111894c:	003b68fa 	trap	3
81118950:	df000115 	stw	fp,4(sp)
81118954:	df000104 	addi	fp,sp,4
81118958:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111895c:	0001883a 	nop
81118960:	e037883a 	mov	sp,fp
81118964:	df000017 	ldw	fp,0(sp)
81118968:	dec00104 	addi	sp,sp,4
8111896c:	f800283a 	ret

81118970 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
81118970:	defffe04 	addi	sp,sp,-8
81118974:	de00012e 	bgeu	sp,et,8111897c <cFeeSpwChannelEnable+0xc>
81118978:	003b68fa 	trap	3
8111897c:	df000115 	stw	fp,4(sp)
81118980:	df000104 	addi	fp,sp,4
81118984:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81118988:	0001883a 	nop
8111898c:	e037883a 	mov	sp,fp
81118990:	df000017 	ldw	fp,0(sp)
81118994:	dec00104 	addi	sp,sp,4
81118998:	f800283a 	ret

8111899c <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111899c:	defffe04 	addi	sp,sp,-8
811189a0:	de00012e 	bgeu	sp,et,811189a8 <cFeeSpwChannelDisable+0xc>
811189a4:	003b68fa 	trap	3
811189a8:	df000115 	stw	fp,4(sp)
811189ac:	df000104 	addi	fp,sp,4
811189b0:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
811189b4:	0001883a 	nop
811189b8:	e037883a 	mov	sp,fp
811189bc:	df000017 	ldw	fp,0(sp)
811189c0:	dec00104 	addi	sp,sp,4
811189c4:	f800283a 	ret

811189c8 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
811189c8:	defffe04 	addi	sp,sp,-8
811189cc:	de00012e 	bgeu	sp,et,811189d4 <cFeeRMAPDump+0xc>
811189d0:	003b68fa 	trap	3
811189d4:	df000115 	stw	fp,4(sp)
811189d8:	df000104 	addi	fp,sp,4
811189dc:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
811189e0:	0001883a 	nop
811189e4:	e037883a 	mov	sp,fp
811189e8:	df000017 	ldw	fp,0(sp)
811189ec:	dec00104 	addi	sp,sp,4
811189f0:	f800283a 	ret

811189f4 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
811189f4:	defffe04 	addi	sp,sp,-8
811189f8:	de00012e 	bgeu	sp,et,81118a00 <cFeeRMAPEchoingEnable+0xc>
811189fc:	003b68fa 	trap	3
81118a00:	df000115 	stw	fp,4(sp)
81118a04:	df000104 	addi	fp,sp,4
81118a08:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
81118a0c:	e0bfff17 	ldw	r2,-4(fp)
81118a10:	00c00044 	movi	r3,1
81118a14:	10c02515 	stw	r3,148(r2)
}
81118a18:	0001883a 	nop
81118a1c:	e037883a 	mov	sp,fp
81118a20:	df000017 	ldw	fp,0(sp)
81118a24:	dec00104 	addi	sp,sp,4
81118a28:	f800283a 	ret

81118a2c <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
81118a2c:	defffe04 	addi	sp,sp,-8
81118a30:	de00012e 	bgeu	sp,et,81118a38 <cFeeRMAPEchoingDisable+0xc>
81118a34:	003b68fa 	trap	3
81118a38:	df000115 	stw	fp,4(sp)
81118a3c:	df000104 	addi	fp,sp,4
81118a40:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
81118a44:	e0bfff17 	ldw	r2,-4(fp)
81118a48:	10002515 	stw	zero,148(r2)
}
81118a4c:	0001883a 	nop
81118a50:	e037883a 	mov	sp,fp
81118a54:	df000017 	ldw	fp,0(sp)
81118a58:	dec00104 	addi	sp,sp,4
81118a5c:	f800283a 	ret

81118a60 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
81118a60:	defffe04 	addi	sp,sp,-8
81118a64:	de00012e 	bgeu	sp,et,81118a6c <cFeeRMAPLogEnable+0xc>
81118a68:	003b68fa 	trap	3
81118a6c:	df000115 	stw	fp,4(sp)
81118a70:	df000104 	addi	fp,sp,4
81118a74:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
81118a78:	e0bfff17 	ldw	r2,-4(fp)
81118a7c:	00c00044 	movi	r3,1
81118a80:	10c02415 	stw	r3,144(r2)
}
81118a84:	0001883a 	nop
81118a88:	e037883a 	mov	sp,fp
81118a8c:	df000017 	ldw	fp,0(sp)
81118a90:	dec00104 	addi	sp,sp,4
81118a94:	f800283a 	ret

81118a98 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
81118a98:	defffe04 	addi	sp,sp,-8
81118a9c:	de00012e 	bgeu	sp,et,81118aa4 <cFeeRMAPLogDisable+0xc>
81118aa0:	003b68fa 	trap	3
81118aa4:	df000115 	stw	fp,4(sp)
81118aa8:	df000104 	addi	fp,sp,4
81118aac:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
81118ab0:	e0bfff17 	ldw	r2,-4(fp)
81118ab4:	10002415 	stw	zero,144(r2)
}
81118ab8:	0001883a 	nop
81118abc:	e037883a 	mov	sp,fp
81118ac0:	df000017 	ldw	fp,0(sp)
81118ac4:	dec00104 	addi	sp,sp,4
81118ac8:	f800283a 	ret

81118acc <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
81118acc:	defffc04 	addi	sp,sp,-16
81118ad0:	de00012e 	bgeu	sp,et,81118ad8 <vNFeeControlInit+0xc>
81118ad4:	003b68fa 	trap	3
81118ad8:	dfc00315 	stw	ra,12(sp)
81118adc:	df000215 	stw	fp,8(sp)
81118ae0:	df000204 	addi	fp,sp,8
81118ae4:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
81118ae8:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
81118aec:	e13fff17 	ldw	r4,-4(fp)
81118af0:	1118c180 	call	81118c18 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
81118af4:	e13fff17 	ldw	r4,-4(fp)
81118af8:	1118c4c0 	call	81118c4c <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
81118afc:	e0bfff17 	ldw	r2,-4(fp)
81118b00:	10009915 	stw	zero,612(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
81118b04:	e03ffe05 	stb	zero,-8(fp)
81118b08:	00002b06 	br	81118bb8 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
81118b0c:	e0bffe03 	ldbu	r2,-8(fp)
81118b10:	10809524 	muli	r2,r2,596
81118b14:	e0ffff17 	ldw	r3,-4(fp)
81118b18:	1885883a 	add	r2,r3,r2
81118b1c:	e0fffe03 	ldbu	r3,-8(fp)
81118b20:	180b883a 	mov	r5,r3
81118b24:	1009883a 	mov	r4,r2
81118b28:	111846c0 	call	8111846c <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
81118b2c:	e0bffe03 	ldbu	r2,-8(fp)
81118b30:	e0fffe03 	ldbu	r3,-8(fp)
81118b34:	18c09524 	muli	r3,r3,596
81118b38:	18c02104 	addi	r3,r3,132
81118b3c:	e13fff17 	ldw	r4,-4(fp)
81118b40:	20c7883a 	add	r3,r4,r3
81118b44:	e13fff17 	ldw	r4,-4(fp)
81118b48:	10802584 	addi	r2,r2,150
81118b4c:	1085883a 	add	r2,r2,r2
81118b50:	1085883a 	add	r2,r2,r2
81118b54:	2085883a 	add	r2,r4,r2
81118b58:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
81118b5c:	e0bffe03 	ldbu	r2,-8(fp)
81118b60:	e0fffe03 	ldbu	r3,-8(fp)
81118b64:	18c09524 	muli	r3,r3,596
81118b68:	18c02704 	addi	r3,r3,156
81118b6c:	e13fff17 	ldw	r4,-4(fp)
81118b70:	20c7883a 	add	r3,r4,r3
81118b74:	e13fff17 	ldw	r4,-4(fp)
81118b78:	108025c4 	addi	r2,r2,151
81118b7c:	1085883a 	add	r2,r2,r2
81118b80:	1085883a 	add	r2,r2,r2
81118b84:	2085883a 	add	r2,r4,r2
81118b88:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
81118b8c:	e0bffe03 	ldbu	r2,-8(fp)
81118b90:	e0ffff17 	ldw	r3,-4(fp)
81118b94:	18c09517 	ldw	r3,596(r3)
81118b98:	e13fff17 	ldw	r4,-4(fp)
81118b9c:	10809524 	muli	r2,r2,596
81118ba0:	2085883a 	add	r2,r4,r2
81118ba4:	10802904 	addi	r2,r2,164
81118ba8:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
81118bac:	e0bffe03 	ldbu	r2,-8(fp)
81118bb0:	10800044 	addi	r2,r2,1
81118bb4:	e0bffe05 	stb	r2,-8(fp)
81118bb8:	e0bffe03 	ldbu	r2,-8(fp)
81118bbc:	103fd326 	beq	r2,zero,81118b0c <__reset+0xfb0f8b0c>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
81118bc0:	0001883a 	nop
81118bc4:	e037883a 	mov	sp,fp
81118bc8:	dfc00117 	ldw	ra,4(sp)
81118bcc:	df000017 	ldw	fp,0(sp)
81118bd0:	dec00204 	addi	sp,sp,8
81118bd4:	f800283a 	ret

81118bd8 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
81118bd8:	defffd04 	addi	sp,sp,-12
81118bdc:	de00012e 	bgeu	sp,et,81118be4 <vSetTimeCode+0xc>
81118be0:	003b68fa 	trap	3
81118be4:	df000215 	stw	fp,8(sp)
81118be8:	df000204 	addi	fp,sp,8
81118bec:	e13ffe15 	stw	r4,-8(fp)
81118bf0:	2805883a 	mov	r2,r5
81118bf4:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
81118bf8:	e0bffe17 	ldw	r2,-8(fp)
81118bfc:	e0ffff03 	ldbu	r3,-4(fp)
81118c00:	10c09805 	stb	r3,608(r2)
}
81118c04:	0001883a 	nop
81118c08:	e037883a 	mov	sp,fp
81118c0c:	df000017 	ldw	fp,0(sp)
81118c10:	dec00104 	addi	sp,sp,4
81118c14:	f800283a 	ret

81118c18 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
81118c18:	defffe04 	addi	sp,sp,-8
81118c1c:	de00012e 	bgeu	sp,et,81118c24 <vResetTimeCode+0xc>
81118c20:	003b68fa 	trap	3
81118c24:	df000115 	stw	fp,4(sp)
81118c28:	df000104 	addi	fp,sp,4
81118c2c:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
81118c30:	e0bfff17 	ldw	r2,-4(fp)
81118c34:	10009805 	stb	zero,608(r2)
}
81118c38:	0001883a 	nop
81118c3c:	e037883a 	mov	sp,fp
81118c40:	df000017 	ldw	fp,0(sp)
81118c44:	dec00104 	addi	sp,sp,4
81118c48:	f800283a 	ret

81118c4c <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
81118c4c:	defffe04 	addi	sp,sp,-8
81118c50:	de00012e 	bgeu	sp,et,81118c58 <vLoadDefaultIdNFEEMaster+0xc>
81118c54:	003b68fa 	trap	3
81118c58:	df000115 	stw	fp,4(sp)
81118c5c:	df000104 	addi	fp,sp,4
81118c60:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
81118c64:	e0bfff17 	ldw	r2,-4(fp)
81118c68:	10009845 	stb	zero,609(r2)
}
81118c6c:	0001883a 	nop
81118c70:	e037883a 	mov	sp,fp
81118c74:	df000017 	ldw	fp,0(sp)
81118c78:	dec00104 	addi	sp,sp,4
81118c7c:	f800283a 	ret

81118c80 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
81118c80:	defffd04 	addi	sp,sp,-12
81118c84:	de00012e 	bgeu	sp,et,81118c8c <vChangeIdNFEEMaster+0xc>
81118c88:	003b68fa 	trap	3
81118c8c:	df000215 	stw	fp,8(sp)
81118c90:	df000204 	addi	fp,sp,8
81118c94:	e13ffe15 	stw	r4,-8(fp)
81118c98:	2805883a 	mov	r2,r5
81118c9c:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
81118ca0:	e0bffe17 	ldw	r2,-8(fp)
81118ca4:	e0ffff03 	ldbu	r3,-4(fp)
81118ca8:	10c09845 	stb	r3,609(r2)
}
81118cac:	0001883a 	nop
81118cb0:	e037883a 	mov	sp,fp
81118cb4:	df000017 	ldw	fp,0(sp)
81118cb8:	dec00104 	addi	sp,sp,4
81118cbc:	f800283a 	ret

81118cc0 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
81118cc0:	defffd04 	addi	sp,sp,-12
81118cc4:	de00012e 	bgeu	sp,et,81118ccc <vChangeDefaultIdNFEEMaster+0xc>
81118cc8:	003b68fa 	trap	3
81118ccc:	df000215 	stw	fp,8(sp)
81118cd0:	df000204 	addi	fp,sp,8
81118cd4:	e13ffe15 	stw	r4,-8(fp)
81118cd8:	2805883a 	mov	r2,r5
81118cdc:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
81118ce0:	0001883a 	nop
81118ce4:	e037883a 	mov	sp,fp
81118ce8:	df000017 	ldw	fp,0(sp)
81118cec:	dec00104 	addi	sp,sp,4
81118cf0:	f800283a 	ret

81118cf4 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
81118cf4:	defffe04 	addi	sp,sp,-8
81118cf8:	de00012e 	bgeu	sp,et,81118d00 <vInitSimucamBasicHW+0xc>
81118cfc:	003b68fa 	trap	3
81118d00:	dfc00115 	stw	ra,4(sp)
81118d04:	df000015 	stw	fp,0(sp)
81118d08:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
81118d0c:	01403fc4 	movi	r5,255
81118d10:	0009883a 	mov	r4,zero
81118d14:	1109e640 	call	81109e64 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
81118d18:	01400834 	movhi	r5,32
81118d1c:	297fffc4 	addi	r5,r5,-1
81118d20:	0009883a 	mov	r4,zero
81118d24:	1109ee40 	call	81109ee4 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
81118d28:	01400074 	movhi	r5,1
81118d2c:	01000044 	movi	r4,1
81118d30:	1109ee40 	call	81109ee4 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
81118d34:	0009883a 	mov	r4,zero
81118d38:	110b4c00 	call	8110b4c0 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
81118d3c:	0009883a 	mov	r4,zero
81118d40:	110b5900 	call	8110b590 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81118d44:	01008004 	movi	r4,512
81118d48:	110b0200 	call	8110b020 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81118d4c:	01008004 	movi	r4,512
81118d50:	110afac0 	call	8110afac <vRstcReleaseDeviceReset>

}
81118d54:	0001883a 	nop
81118d58:	e037883a 	mov	sp,fp
81118d5c:	dfc00117 	ldw	ra,4(sp)
81118d60:	df000017 	ldw	fp,0(sp)
81118d64:	dec00204 	addi	sp,sp,8
81118d68:	f800283a 	ret

81118d6c <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
81118d6c:	defffd04 	addi	sp,sp,-12
81118d70:	de00012e 	bgeu	sp,et,81118d78 <bLogWriteSDCard+0xc>
81118d74:	003b68fa 	trap	3
81118d78:	df000215 	stw	fp,8(sp)
81118d7c:	df000204 	addi	fp,sp,8
81118d80:	e13ffe15 	stw	r4,-8(fp)
81118d84:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
81118d88:	00800044 	movi	r2,1
}
81118d8c:	e037883a 	mov	sp,fp
81118d90:	df000017 	ldw	fp,0(sp)
81118d94:	dec00104 	addi	sp,sp,4
81118d98:	f800283a 	ret

81118d9c <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
81118d9c:	deffe004 	addi	sp,sp,-128
81118da0:	de00012e 	bgeu	sp,et,81118da8 <vLogWriteNUC+0xc>
81118da4:	003b68fa 	trap	3
81118da8:	dfc01f15 	stw	ra,124(sp)
81118dac:	df001e15 	stw	fp,120(sp)
81118db0:	df001e04 	addi	fp,sp,120
81118db4:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
81118db8:	e03fe215 	stw	zero,-120(fp)
81118dbc:	e0bfe304 	addi	r2,fp,-116
81118dc0:	00c01b84 	movi	r3,110
81118dc4:	180d883a 	mov	r6,r3
81118dc8:	000b883a 	mov	r5,zero
81118dcc:	1009883a 	mov	r4,r2
81118dd0:	111c5900 	call	8111c590 <memset>
	memset(cTemp,0,114);
81118dd4:	01801c84 	movi	r6,114
81118dd8:	000b883a 	mov	r5,zero
81118ddc:	e13fe204 	addi	r4,fp,-120
81118de0:	111c5900 	call	8111c590 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
81118de4:	e13fff17 	ldw	r4,-4(fp)
81118de8:	111cf340 	call	8111cf34 <strlen>
81118dec:	10801c68 	cmpgeui	r2,r2,113
81118df0:	1000031e 	bne	r2,zero,81118e00 <vLogWriteNUC+0x64>
81118df4:	e13fff17 	ldw	r4,-4(fp)
81118df8:	111cf340 	call	8111cf34 <strlen>
81118dfc:	00000106 	br	81118e04 <vLogWriteNUC+0x68>
81118e00:	00801c44 	movi	r2,113
81118e04:	100d883a 	mov	r6,r2
81118e08:	e17fff17 	ldw	r5,-4(fp)
81118e0c:	e13fe204 	addi	r4,fp,-120
81118e10:	111c4400 	call	8111c440 <memcpy>
	vSendLog ( cDataIn );
81118e14:	e13fff17 	ldw	r4,-4(fp)
81118e18:	11150e80 	call	811150e8 <vSendLog>
}
81118e1c:	0001883a 	nop
81118e20:	e037883a 	mov	sp,fp
81118e24:	dfc00117 	ldw	ra,4(sp)
81118e28:	df000017 	ldw	fp,0(sp)
81118e2c:	dec00204 	addi	sp,sp,8
81118e30:	f800283a 	ret

81118e34 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
81118e34:	defffd04 	addi	sp,sp,-12
81118e38:	de00012e 	bgeu	sp,et,81118e40 <vSimucamStructureInit+0xc>
81118e3c:	003b68fa 	trap	3
81118e40:	dfc00215 	stw	ra,8(sp)
81118e44:	df000115 	stw	fp,4(sp)
81118e48:	df000104 	addi	fp,sp,4
81118e4c:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
81118e50:	e0bfff17 	ldw	r2,-4(fp)
81118e54:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
81118e58:	e0bfff17 	ldw	r2,-4(fp)
81118e5c:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
81118e60:	e13fff17 	ldw	r4,-4(fp)
81118e64:	1118f200 	call	81118f20 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
81118e68:	e13fff17 	ldw	r4,-4(fp)
81118e6c:	1118fc40 	call	81118fc4 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
81118e70:	e13fff17 	ldw	r4,-4(fp)
81118e74:	111906c0 	call	8111906c <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
81118e78:	e13fff17 	ldw	r4,-4(fp)
81118e7c:	111910c0 	call	8111910c <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
81118e80:	e0bfff17 	ldw	r2,-4(fp)
81118e84:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
81118e88:	e0bfff17 	ldw	r2,-4(fp)
81118e8c:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
81118e90:	e0bfff17 	ldw	r2,-4(fp)
81118e94:	00c07d04 	movi	r3,500
81118e98:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
81118e9c:	e0bfff17 	ldw	r2,-4(fp)
81118ea0:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
81118ea4:	e0bfff17 	ldw	r2,-4(fp)
81118ea8:	00c00044 	movi	r3,1
81118eac:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
81118eb0:	e0bfff17 	ldw	r2,-4(fp)
81118eb4:	10c00204 	addi	r3,r2,8
81118eb8:	e0bfff17 	ldw	r2,-4(fp)
81118ebc:	10c0a715 	stw	r3,668(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
81118ec0:	e0bfff17 	ldw	r2,-4(fp)
81118ec4:	10c00244 	addi	r3,r2,9
81118ec8:	e0bfff17 	ldw	r2,-4(fp)
81118ecc:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
81118ed0:	e0bfff17 	ldw	r2,-4(fp)
81118ed4:	10800017 	ldw	r2,0(r2)
81118ed8:	10000b1e 	bne	r2,zero,81118f08 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
81118edc:	e0bfff17 	ldw	r2,-4(fp)
81118ee0:	10801204 	addi	r2,r2,72
81118ee4:	1009883a 	mov	r4,r2
81118ee8:	1118acc0 	call	81118acc <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
81118eec:	e0bfff17 	ldw	r2,-4(fp)
81118ef0:	10c00a04 	addi	r3,r2,40
81118ef4:	e0bfff17 	ldw	r2,-4(fp)
81118ef8:	10801204 	addi	r2,r2,72
81118efc:	100b883a 	mov	r5,r2
81118f00:	1809883a 	mov	r4,r3
81118f04:	11164b40 	call	811164b4 <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
81118f08:	0001883a 	nop
81118f0c:	e037883a 	mov	sp,fp
81118f10:	dfc00117 	ldw	ra,4(sp)
81118f14:	df000017 	ldw	fp,0(sp)
81118f18:	dec00204 	addi	sp,sp,8
81118f1c:	f800283a 	ret

81118f20 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
81118f20:	defffe04 	addi	sp,sp,-8
81118f24:	de00012e 	bgeu	sp,et,81118f2c <vLoadDefaultEPValue+0xc>
81118f28:	003b68fa 	trap	3
81118f2c:	df000115 	stw	fp,4(sp)
81118f30:	df000104 	addi	fp,sp,4
81118f34:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
81118f38:	e0bfff17 	ldw	r2,-4(fp)
81118f3c:	00d07234 	movhi	r3,16840
81118f40:	10c00315 	stw	r3,12(r2)
}
81118f44:	0001883a 	nop
81118f48:	e037883a 	mov	sp,fp
81118f4c:	df000017 	ldw	fp,0(sp)
81118f50:	dec00104 	addi	sp,sp,4
81118f54:	f800283a 	ret

81118f58 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81118f58:	defffd04 	addi	sp,sp,-12
81118f5c:	de00012e 	bgeu	sp,et,81118f64 <vChangeEPValue+0xc>
81118f60:	003b68fa 	trap	3
81118f64:	df000215 	stw	fp,8(sp)
81118f68:	df000204 	addi	fp,sp,8
81118f6c:	e13ffe15 	stw	r4,-8(fp)
81118f70:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
81118f74:	e0bffe17 	ldw	r2,-8(fp)
81118f78:	e0ffff17 	ldw	r3,-4(fp)
81118f7c:	10c00315 	stw	r3,12(r2)
}
81118f80:	0001883a 	nop
81118f84:	e037883a 	mov	sp,fp
81118f88:	df000017 	ldw	fp,0(sp)
81118f8c:	dec00104 	addi	sp,sp,4
81118f90:	f800283a 	ret

81118f94 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81118f94:	defffd04 	addi	sp,sp,-12
81118f98:	de00012e 	bgeu	sp,et,81118fa0 <vChangeDefaultEPValue+0xc>
81118f9c:	003b68fa 	trap	3
81118fa0:	df000215 	stw	fp,8(sp)
81118fa4:	df000204 	addi	fp,sp,8
81118fa8:	e13ffe15 	stw	r4,-8(fp)
81118fac:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
81118fb0:	0001883a 	nop
81118fb4:	e037883a 	mov	sp,fp
81118fb8:	df000017 	ldw	fp,0(sp)
81118fbc:	dec00104 	addi	sp,sp,4
81118fc0:	f800283a 	ret

81118fc4 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
81118fc4:	defffe04 	addi	sp,sp,-8
81118fc8:	de00012e 	bgeu	sp,et,81118fd0 <vLoadDefaultRTValue+0xc>
81118fcc:	003b68fa 	trap	3
81118fd0:	df000115 	stw	fp,4(sp)
81118fd4:	df000104 	addi	fp,sp,4
81118fd8:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
81118fdc:	e0ffff17 	ldw	r3,-4(fp)
81118fe0:	00901eb4 	movhi	r2,16506
81118fe4:	10a66684 	addi	r2,r2,-26214
81118fe8:	18800415 	stw	r2,16(r3)
}
81118fec:	0001883a 	nop
81118ff0:	e037883a 	mov	sp,fp
81118ff4:	df000017 	ldw	fp,0(sp)
81118ff8:	dec00104 	addi	sp,sp,4
81118ffc:	f800283a 	ret

81119000 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81119000:	defffd04 	addi	sp,sp,-12
81119004:	de00012e 	bgeu	sp,et,8111900c <vChangeRTValue+0xc>
81119008:	003b68fa 	trap	3
8111900c:	df000215 	stw	fp,8(sp)
81119010:	df000204 	addi	fp,sp,8
81119014:	e13ffe15 	stw	r4,-8(fp)
81119018:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111901c:	e0bffe17 	ldw	r2,-8(fp)
81119020:	e0ffff17 	ldw	r3,-4(fp)
81119024:	10c00415 	stw	r3,16(r2)
}
81119028:	0001883a 	nop
8111902c:	e037883a 	mov	sp,fp
81119030:	df000017 	ldw	fp,0(sp)
81119034:	dec00104 	addi	sp,sp,4
81119038:	f800283a 	ret

8111903c <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111903c:	defffd04 	addi	sp,sp,-12
81119040:	de00012e 	bgeu	sp,et,81119048 <vChangeDefaultRTValue+0xc>
81119044:	003b68fa 	trap	3
81119048:	df000215 	stw	fp,8(sp)
8111904c:	df000204 	addi	fp,sp,8
81119050:	e13ffe15 	stw	r4,-8(fp)
81119054:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
81119058:	0001883a 	nop
8111905c:	e037883a 	mov	sp,fp
81119060:	df000017 	ldw	fp,0(sp)
81119064:	dec00104 	addi	sp,sp,4
81119068:	f800283a 	ret

8111906c <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111906c:	defffe04 	addi	sp,sp,-8
81119070:	de00012e 	bgeu	sp,et,81119078 <vLoadDefaultSyncSource+0xc>
81119074:	003b68fa 	trap	3
81119078:	df000115 	stw	fp,4(sp)
8111907c:	df000104 	addi	fp,sp,4
81119080:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
81119084:	e0bfff17 	ldw	r2,-4(fp)
81119088:	10000815 	stw	zero,32(r2)
}
8111908c:	0001883a 	nop
81119090:	e037883a 	mov	sp,fp
81119094:	df000017 	ldw	fp,0(sp)
81119098:	dec00104 	addi	sp,sp,4
8111909c:	f800283a 	ret

811190a0 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
811190a0:	defffd04 	addi	sp,sp,-12
811190a4:	de00012e 	bgeu	sp,et,811190ac <vChangeSyncSource+0xc>
811190a8:	003b68fa 	trap	3
811190ac:	df000215 	stw	fp,8(sp)
811190b0:	df000204 	addi	fp,sp,8
811190b4:	e13ffe15 	stw	r4,-8(fp)
811190b8:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
811190bc:	e0bffe17 	ldw	r2,-8(fp)
811190c0:	e0ffff17 	ldw	r3,-4(fp)
811190c4:	10c00815 	stw	r3,32(r2)
}
811190c8:	0001883a 	nop
811190cc:	e037883a 	mov	sp,fp
811190d0:	df000017 	ldw	fp,0(sp)
811190d4:	dec00104 	addi	sp,sp,4
811190d8:	f800283a 	ret

811190dc <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
811190dc:	defffd04 	addi	sp,sp,-12
811190e0:	de00012e 	bgeu	sp,et,811190e8 <vChangeDefaultSyncSource+0xc>
811190e4:	003b68fa 	trap	3
811190e8:	df000215 	stw	fp,8(sp)
811190ec:	df000204 	addi	fp,sp,8
811190f0:	e13ffe15 	stw	r4,-8(fp)
811190f4:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
811190f8:	0001883a 	nop
811190fc:	e037883a 	mov	sp,fp
81119100:	df000017 	ldw	fp,0(sp)
81119104:	dec00104 	addi	sp,sp,4
81119108:	f800283a 	ret

8111910c <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111910c:	defffe04 	addi	sp,sp,-8
81119110:	de00012e 	bgeu	sp,et,81119118 <vLoadDefaultAutoResetSync+0xc>
81119114:	003b68fa 	trap	3
81119118:	df000115 	stw	fp,4(sp)
8111911c:	df000104 	addi	fp,sp,4
81119120:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
81119124:	e0bfff17 	ldw	r2,-4(fp)
81119128:	00c00044 	movi	r3,1
8111912c:	10c00915 	stw	r3,36(r2)
}
81119130:	0001883a 	nop
81119134:	e037883a 	mov	sp,fp
81119138:	df000017 	ldw	fp,0(sp)
8111913c:	dec00104 	addi	sp,sp,4
81119140:	f800283a 	ret

81119144 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81119144:	defffd04 	addi	sp,sp,-12
81119148:	de00012e 	bgeu	sp,et,81119150 <vChangeAutoResetSync+0xc>
8111914c:	003b68fa 	trap	3
81119150:	df000215 	stw	fp,8(sp)
81119154:	df000204 	addi	fp,sp,8
81119158:	e13ffe15 	stw	r4,-8(fp)
8111915c:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
81119160:	e0bffe17 	ldw	r2,-8(fp)
81119164:	e0ffff17 	ldw	r3,-4(fp)
81119168:	10c00915 	stw	r3,36(r2)
}
8111916c:	0001883a 	nop
81119170:	e037883a 	mov	sp,fp
81119174:	df000017 	ldw	fp,0(sp)
81119178:	dec00104 	addi	sp,sp,4
8111917c:	f800283a 	ret

81119180 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81119180:	defffd04 	addi	sp,sp,-12
81119184:	de00012e 	bgeu	sp,et,8111918c <vChangeDefaultAutoResetSync+0xc>
81119188:	003b68fa 	trap	3
8111918c:	df000215 	stw	fp,8(sp)
81119190:	df000204 	addi	fp,sp,8
81119194:	e13ffe15 	stw	r4,-8(fp)
81119198:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111919c:	0001883a 	nop
811191a0:	e037883a 	mov	sp,fp
811191a4:	df000017 	ldw	fp,0(sp)
811191a8:	dec00104 	addi	sp,sp,4
811191ac:	f800283a 	ret

811191b0 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
811191b0:	defffc04 	addi	sp,sp,-16
811191b4:	de00012e 	bgeu	sp,et,811191bc <vSyncReset+0xc>
811191b8:	003b68fa 	trap	3
811191bc:	dfc00315 	stw	ra,12(sp)
811191c0:	df000215 	stw	fp,8(sp)
811191c4:	df000204 	addi	fp,sp,8
811191c8:	e13ffe15 	stw	r4,-8(fp)
811191cc:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
811191d0:	e0bffe17 	ldw	r2,-8(fp)
811191d4:	10801204 	addi	r2,r2,72
811191d8:	1009883a 	mov	r4,r2
811191dc:	1118c180 	call	81118c18 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
811191e0:	0001883a 	nop
811191e4:	e037883a 	mov	sp,fp
811191e8:	dfc00117 	ldw	ra,4(sp)
811191ec:	df000017 	ldw	fp,0(sp)
811191f0:	dec00204 	addi	sp,sp,8
811191f4:	f800283a 	ret

811191f8 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
811191f8:	defff004 	addi	sp,sp,-64
811191fc:	de00012e 	bgeu	sp,et,81119204 <pattern_createPattern+0xc>
81119200:	003b68fa 	trap	3
81119204:	dfc00f15 	stw	ra,60(sp)
81119208:	df000e15 	stw	fp,56(sp)
8111920c:	dcc00d15 	stw	r19,52(sp)
81119210:	dc800c15 	stw	r18,48(sp)
81119214:	dc400b15 	stw	r17,44(sp)
81119218:	dc000a15 	stw	r16,40(sp)
8111921c:	df000e04 	addi	fp,sp,56
81119220:	e17ff915 	stw	r5,-28(fp)
81119224:	3007883a 	mov	r3,r6
81119228:	3805883a 	mov	r2,r7
8111922c:	e13ff805 	stb	r4,-32(fp)
81119230:	e0fffa05 	stb	r3,-24(fp)
81119234:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
81119238:	e0bff803 	ldbu	r2,-32(fp)
8111923c:	1009883a 	mov	r4,r2
81119240:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
81119244:	e0bff917 	ldw	r2,-28(fp)
81119248:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8111924c:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
81119250:	e0bff217 	ldw	r2,-56(fp)
81119254:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
81119258:	e03ff515 	stw	zero,-44(fp)
8111925c:	00003606 	br	81119338 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81119260:	e03ff615 	stw	zero,-40(fp)
81119264:	00002e06 	br	81119320 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
81119268:	e0bff303 	ldbu	r2,-52(fp)
8111926c:	10801018 	cmpnei	r2,r2,64
81119270:	10000b1e 	bne	r2,zero,811192a0 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
81119274:	e0bff417 	ldw	r2,-48(fp)
81119278:	00ffffc4 	movi	r3,-1
8111927c:	10c02015 	stw	r3,128(r2)
81119280:	00ffffc4 	movi	r3,-1
81119284:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
81119288:	e0bff217 	ldw	r2,-56(fp)
8111928c:	10802204 	addi	r2,r2,136
81119290:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
81119294:	e0bff217 	ldw	r2,-56(fp)
81119298:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111929c:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
811192a0:	e0bff303 	ldbu	r2,-52(fp)
811192a4:	10c00044 	addi	r3,r2,1
811192a8:	e0fff305 	stb	r3,-52(fp)
811192ac:	10803fcc 	andi	r2,r2,255
811192b0:	e0fffa03 	ldbu	r3,-24(fp)
811192b4:	18c000cc 	andi	r3,r3,3
811192b8:	180692fa 	slli	r3,r3,11
811192bc:	1809883a 	mov	r4,r3
811192c0:	00f80004 	movi	r3,-8192
811192c4:	20c6b03a 	or	r3,r4,r3
811192c8:	1809883a 	mov	r4,r3
811192cc:	e0fffb03 	ldbu	r3,-20(fp)
811192d0:	18c0004c 	andi	r3,r3,1
811192d4:	180692ba 	slli	r3,r3,10
811192d8:	20c6b03a 	or	r3,r4,r3
811192dc:	1809883a 	mov	r4,r3
811192e0:	e0fff517 	ldw	r3,-44(fp)
811192e4:	18c007cc 	andi	r3,r3,31
811192e8:	1806917a 	slli	r3,r3,5
811192ec:	20c6b03a 	or	r3,r4,r3
811192f0:	1809883a 	mov	r4,r3
811192f4:	e0fff617 	ldw	r3,-40(fp)
811192f8:	18c007cc 	andi	r3,r3,31
811192fc:	20c6b03a 	or	r3,r4,r3
81119300:	1809883a 	mov	r4,r3
81119304:	e0fff417 	ldw	r3,-48(fp)
81119308:	1085883a 	add	r2,r2,r2
8111930c:	1885883a 	add	r2,r3,r2
81119310:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81119314:	e0bff617 	ldw	r2,-40(fp)
81119318:	10800044 	addi	r2,r2,1
8111931c:	e0bff615 	stw	r2,-40(fp)
81119320:	e0fff617 	ldw	r3,-40(fp)
81119324:	e0800217 	ldw	r2,8(fp)
81119328:	18bfcf36 	bltu	r3,r2,81119268 <__reset+0xfb0f9268>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111932c:	e0bff517 	ldw	r2,-44(fp)
81119330:	10800044 	addi	r2,r2,1
81119334:	e0bff515 	stw	r2,-44(fp)
81119338:	e0fff517 	ldw	r3,-44(fp)
8111933c:	e0800317 	ldw	r2,12(fp)
81119340:	18bfc736 	bltu	r3,r2,81119260 <__reset+0xfb0f9260>
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
81119344:	e0bff303 	ldbu	r2,-52(fp)
81119348:	e0bff705 	stb	r2,-36(fp)
8111934c:	00000806 	br	81119370 <pattern_createPattern+0x178>
	{
		pxPixelData->usiPixel[j] = 0;
81119350:	e0bff703 	ldbu	r2,-36(fp)
81119354:	e0fff417 	ldw	r3,-48(fp)
81119358:	1085883a 	add	r2,r2,r2
8111935c:	1885883a 	add	r2,r3,r2
81119360:	1000000d 	sth	zero,0(r2)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
81119364:	e0bff703 	ldbu	r2,-36(fp)
81119368:	10800044 	addi	r2,r2,1
8111936c:	e0bff705 	stb	r2,-36(fp)
81119370:	e0bff703 	ldbu	r2,-36(fp)
81119374:	10801030 	cmpltui	r2,r2,64
81119378:	103ff51e 	bne	r2,zero,81119350 <__reset+0xfb0f9350>
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
8111937c:	e0bff417 	ldw	r2,-48(fp)
81119380:	10002015 	stw	zero,128(r2)
81119384:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
81119388:	e03ff745 	stb	zero,-35(fp)
8111938c:	00001106 	br	811193d4 <pattern_createPattern+0x1dc>
	{
		pxPixelData->ulliMask |= 1 << j;
81119390:	e13ff417 	ldw	r4,-48(fp)
81119394:	20802017 	ldw	r2,128(r4)
81119398:	20c02117 	ldw	r3,132(r4)
8111939c:	e13ff743 	ldbu	r4,-35(fp)
811193a0:	01400044 	movi	r5,1
811193a4:	2908983a 	sll	r4,r5,r4
811193a8:	2025883a 	mov	r18,r4
811193ac:	2009d7fa 	srai	r4,r4,31
811193b0:	2027883a 	mov	r19,r4
811193b4:	14a0b03a 	or	r16,r2,r18
811193b8:	1ce2b03a 	or	r17,r3,r19
811193bc:	e0bff417 	ldw	r2,-48(fp)
811193c0:	14002015 	stw	r16,128(r2)
811193c4:	14402115 	stw	r17,132(r2)
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
811193c8:	e0bff743 	ldbu	r2,-35(fp)
811193cc:	10800044 	addi	r2,r2,1
811193d0:	e0bff745 	stb	r2,-35(fp)
811193d4:	e0fff743 	ldbu	r3,-35(fp)
811193d8:	e0bff303 	ldbu	r2,-52(fp)
811193dc:	18bfec36 	bltu	r3,r2,81119390 <__reset+0xfb0f9390>
	{
		pxPixelData->ulliMask |= 1 << j;
	}
	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
811193e0:	e0bff217 	ldw	r2,-56(fp)
811193e4:	10802204 	addi	r2,r2,136
811193e8:	e0bff215 	stw	r2,-56(fp)
	return offset;
811193ec:	e0bff217 	ldw	r2,-56(fp)
}
811193f0:	e6fffc04 	addi	sp,fp,-16
811193f4:	dfc00517 	ldw	ra,20(sp)
811193f8:	df000417 	ldw	fp,16(sp)
811193fc:	dcc00317 	ldw	r19,12(sp)
81119400:	dc800217 	ldw	r18,8(sp)
81119404:	dc400117 	ldw	r17,4(sp)
81119408:	dc000017 	ldw	r16,0(sp)
8111940c:	dec00604 	addi	sp,sp,24
81119410:	f800283a 	ret

81119414 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
81119414:	defffe04 	addi	sp,sp,-8
81119418:	de00012e 	bgeu	sp,et,81119420 <bSDcardIsPresent+0xc>
8111941c:	003b68fa 	trap	3
81119420:	dfc00115 	stw	ra,4(sp)
81119424:	df000015 	stw	fp,0(sp)
81119428:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111942c:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
}
81119430:	e037883a 	mov	sp,fp
81119434:	dfc00117 	ldw	ra,4(sp)
81119438:	df000017 	ldw	fp,0(sp)
8111943c:	dec00204 	addi	sp,sp,8
81119440:	f800283a 	ret

81119444 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
81119444:	defffe04 	addi	sp,sp,-8
81119448:	de00012e 	bgeu	sp,et,81119450 <bSDcardFAT16Check+0xc>
8111944c:	003b68fa 	trap	3
81119450:	dfc00115 	stw	ra,4(sp)
81119454:	df000015 	stw	fp,0(sp)
81119458:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111945c:	113f7c40 	call	8113f7c4 <alt_up_sd_card_is_FAT16>
}
81119460:	e037883a 	mov	sp,fp
81119464:	dfc00117 	ldw	ra,4(sp)
81119468:	df000017 	ldw	fp,0(sp)
8111946c:	dec00204 	addi	sp,sp,8
81119470:	f800283a 	ret

81119474 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
81119474:	defffd04 	addi	sp,sp,-12
81119478:	de00012e 	bgeu	sp,et,81119480 <bInitializeSDCard+0xc>
8111947c:	003b68fa 	trap	3
81119480:	dfc00215 	stw	ra,8(sp)
81119484:	df000115 	stw	fp,4(sp)
81119488:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111948c:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
81119490:	d0207115 	stw	zero,-32316(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
81119494:	01204574 	movhi	r4,33045
81119498:	21284104 	addi	r4,r4,-24316
8111949c:	113f6340 	call	8113f634 <alt_up_sd_card_open_dev>
811194a0:	d0a07115 	stw	r2,-32316(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
811194a4:	d0a07117 	ldw	r2,-32316(gp)
811194a8:	10002226 	beq	r2,zero,81119534 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
811194ac:	11194140 	call	81119414 <bSDcardIsPresent>
811194b0:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
811194b4:	e0bfff17 	ldw	r2,-4(fp)
811194b8:	10001626 	beq	r2,zero,81119514 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
811194bc:	11194440 	call	81119444 <bSDcardFAT16Check>
811194c0:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
811194c4:	e0bfff17 	ldw	r2,-4(fp)
811194c8:	10000a26 	beq	r2,zero,811194f4 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
811194cc:	00800044 	movi	r2,1
811194d0:	d0a07015 	stw	r2,-32320(gp)
				debug(fp, "SD is up.\r\n");
811194d4:	d0a05c17 	ldw	r2,-32400(gp)
811194d8:	100f883a 	mov	r7,r2
811194dc:	018002c4 	movi	r6,11
811194e0:	01400044 	movi	r5,1
811194e4:	01204574 	movhi	r4,33045
811194e8:	21284c04 	addi	r4,r4,-24272
811194ec:	111ba2c0 	call	8111ba2c <fwrite>
811194f0:	00001806 	br	81119554 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
811194f4:	d0a05c17 	ldw	r2,-32400(gp)
811194f8:	100f883a 	mov	r7,r2
811194fc:	01800984 	movi	r6,38
81119500:	01400044 	movi	r5,1
81119504:	01204574 	movhi	r4,33045
81119508:	21284f04 	addi	r4,r4,-24260
8111950c:	111ba2c0 	call	8111ba2c <fwrite>
81119510:	00001006 	br	81119554 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
81119514:	d0a05c17 	ldw	r2,-32400(gp)
81119518:	100f883a 	mov	r7,r2
8111951c:	01800744 	movi	r6,29
81119520:	01400044 	movi	r5,1
81119524:	01204574 	movhi	r4,33045
81119528:	21285904 	addi	r4,r4,-24220
8111952c:	111ba2c0 	call	8111ba2c <fwrite>
81119530:	00000806 	br	81119554 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
81119534:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
81119538:	d0a05c17 	ldw	r2,-32400(gp)
8111953c:	100f883a 	mov	r7,r2
81119540:	018008c4 	movi	r6,35
81119544:	01400044 	movi	r5,1
81119548:	01204574 	movhi	r4,33045
8111954c:	21286104 	addi	r4,r4,-24188
81119550:	111ba2c0 	call	8111ba2c <fwrite>
	}

	return bSucess;
81119554:	e0bfff17 	ldw	r2,-4(fp)
}
81119558:	e037883a 	mov	sp,fp
8111955c:	dfc00117 	ldw	ra,4(sp)
81119560:	df000017 	ldw	fp,0(sp)
81119564:	dec00204 	addi	sp,sp,8
81119568:	f800283a 	ret

8111956c <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
8111956c:	defffd04 	addi	sp,sp,-12
81119570:	de00012e 	bgeu	sp,et,81119578 <siOpenFile+0xc>
81119574:	003b68fa 	trap	3
81119578:	dfc00215 	stw	ra,8(sp)
8111957c:	df000115 	stw	fp,4(sp)
81119580:	df000104 	addi	fp,sp,4
81119584:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
81119588:	000b883a 	mov	r5,zero
8111958c:	e13fff17 	ldw	r4,-4(fp)
81119590:	113fcd00 	call	8113fcd0 <alt_up_sd_card_fopen>
}
81119594:	e037883a 	mov	sp,fp
81119598:	dfc00117 	ldw	ra,4(sp)
8111959c:	df000017 	ldw	fp,0(sp)
811195a0:	dec00204 	addi	sp,sp,8
811195a4:	f800283a 	ret

811195a8 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
811195a8:	defffd04 	addi	sp,sp,-12
811195ac:	de00012e 	bgeu	sp,et,811195b4 <siCloseFile+0xc>
811195b0:	003b68fa 	trap	3
811195b4:	dfc00215 	stw	ra,8(sp)
811195b8:	df000115 	stw	fp,4(sp)
811195bc:	df000104 	addi	fp,sp,4
811195c0:	2005883a 	mov	r2,r4
811195c4:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
811195c8:	e0bfff0f 	ldh	r2,-4(fp)
811195cc:	1009883a 	mov	r4,r2
811195d0:	1140b1c0 	call	81140b1c <alt_up_sd_card_fclose>
}
811195d4:	e037883a 	mov	sp,fp
811195d8:	dfc00117 	ldw	ra,4(sp)
811195dc:	df000017 	ldw	fp,0(sp)
811195e0:	dec00204 	addi	sp,sp,8
811195e4:	f800283a 	ret

811195e8 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
811195e8:	defffd04 	addi	sp,sp,-12
811195ec:	de00012e 	bgeu	sp,et,811195f4 <cGetNextChar+0xc>
811195f0:	003b68fa 	trap	3
811195f4:	dfc00215 	stw	ra,8(sp)
811195f8:	df000115 	stw	fp,4(sp)
811195fc:	df000104 	addi	fp,sp,4
81119600:	2005883a 	mov	r2,r4
81119604:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
81119608:	e0bfff0f 	ldh	r2,-4(fp)
8111960c:	1009883a 	mov	r4,r2
81119610:	11401740 	call	81140174 <alt_up_sd_card_read>
}
81119614:	e037883a 	mov	sp,fp
81119618:	dfc00117 	ldw	ra,4(sp)
8111961c:	df000017 	ldw	fp,0(sp)
81119620:	dec00204 	addi	sp,sp,8
81119624:	f800283a 	ret

81119628 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
81119628:	defffc04 	addi	sp,sp,-16
8111962c:	de00012e 	bgeu	sp,et,81119634 <bInitSync+0xc>
81119630:	003b68fa 	trap	3
81119634:	dfc00315 	stw	ra,12(sp)
81119638:	df000215 	stw	fp,8(sp)
8111963c:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
81119640:	110b7540 	call	8110b754 <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
81119644:	d0a05c17 	ldw	r2,-32400(gp)
81119648:	100f883a 	mov	r7,r2
8111964c:	01800684 	movi	r6,26
81119650:	01400044 	movi	r5,1
81119654:	01204574 	movhi	r4,33045
81119658:	21286a04 	addi	r4,r4,-24152
8111965c:	111ba2c0 	call	8111ba2c <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
81119660:	01004c74 	movhi	r4,305
81119664:	210b4004 	addi	r4,r4,11520
81119668:	110b95c0 	call	8110b95c <bSyncSetMbt>
8111966c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119670:	e0bffe17 	ldw	r2,-8(fp)
81119674:	1000091e 	bne	r2,zero,8111969c <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119678:	d0a05c17 	ldw	r2,-32400(gp)
8111967c:	100f883a 	mov	r7,r2
81119680:	018005c4 	movi	r6,23
81119684:	01400044 	movi	r5,1
81119688:	01204574 	movhi	r4,33045
8111968c:	21287104 	addi	r4,r4,-24124
81119690:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		return bSuccess;
81119694:	e0bffe17 	ldw	r2,-8(fp)
81119698:	00006c06 	br	8111984c <bInitSync+0x224>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8111969c:	01002674 	movhi	r4,153
811196a0:	2125a004 	addi	r4,r4,-27008
811196a4:	110b99c0 	call	8110b99c <bSyncSetBt>
811196a8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
811196ac:	e0bffe17 	ldw	r2,-8(fp)
811196b0:	1000091e 	bne	r2,zero,811196d8 <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
811196b4:	d0a05c17 	ldw	r2,-32400(gp)
811196b8:	100f883a 	mov	r7,r2
811196bc:	018005c4 	movi	r6,23
811196c0:	01400044 	movi	r5,1
811196c4:	01204574 	movhi	r4,33045
811196c8:	21287104 	addi	r4,r4,-24124
811196cc:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		return bSuccess;
811196d0:	e0bffe17 	ldw	r2,-8(fp)
811196d4:	00005d06 	br	8111984c <bInitSync+0x224>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer((alt_u32)PER);
811196d8:	0104a834 	movhi	r4,4768
811196dc:	2117c804 	addi	r4,r4,24352
811196e0:	110b9dc0 	call	8110b9dc <bSyncSetPer>
811196e4:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
811196e8:	e0bffe17 	ldw	r2,-8(fp)
811196ec:	1000091e 	bne	r2,zero,81119714 <bInitSync+0xec>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
811196f0:	d0a05c17 	ldw	r2,-32400(gp)
811196f4:	100f883a 	mov	r7,r2
811196f8:	018005c4 	movi	r6,23
811196fc:	01400044 	movi	r5,1
81119700:	01204574 	movhi	r4,33045
81119704:	21287104 	addi	r4,r4,-24124
81119708:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		return bSuccess;
8111970c:	e0bffe17 	ldw	r2,-8(fp)
81119710:	00004e06 	br	8111984c <bInitSync+0x224>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
81119714:	01005f74 	movhi	r4,381
81119718:	211e1004 	addi	r4,r4,30784
8111971c:	110ba1c0 	call	8110ba1c <bSyncSetOst>
81119720:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119724:	e0bffe17 	ldw	r2,-8(fp)
81119728:	1000091e 	bne	r2,zero,81119750 <bInitSync+0x128>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111972c:	d0a05c17 	ldw	r2,-32400(gp)
81119730:	100f883a 	mov	r7,r2
81119734:	018005c4 	movi	r6,23
81119738:	01400044 	movi	r5,1
8111973c:	01204574 	movhi	r4,33045
81119740:	21287104 	addi	r4,r4,-24124
81119744:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		return bSuccess;
81119748:	e0bffe17 	ldw	r2,-8(fp)
8111974c:	00003f06 	br	8111984c <bInitSync+0x224>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
81119750:	0009883a 	mov	r4,zero
81119754:	110ba5c0 	call	8110ba5c <bSyncSetPolarity>
81119758:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111975c:	e0bffe17 	ldw	r2,-8(fp)
81119760:	1000091e 	bne	r2,zero,81119788 <bInitSync+0x160>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119764:	d0a05c17 	ldw	r2,-32400(gp)
81119768:	100f883a 	mov	r7,r2
8111976c:	018005c4 	movi	r6,23
81119770:	01400044 	movi	r5,1
81119774:	01204574 	movhi	r4,33045
81119778:	21287104 	addi	r4,r4,-24124
8111977c:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		return bSuccess;
81119780:	e0bffe17 	ldw	r2,-8(fp)
81119784:	00003106 	br	8111984c <bInitSync+0x224>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
81119788:	01000104 	movi	r4,4
8111978c:	110bad00 	call	8110bad0 <bSyncSetNCycles>
81119790:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119794:	e0bffe17 	ldw	r2,-8(fp)
81119798:	1000091e 	bne	r2,zero,811197c0 <bInitSync+0x198>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111979c:	d0a05c17 	ldw	r2,-32400(gp)
811197a0:	100f883a 	mov	r7,r2
811197a4:	018005c4 	movi	r6,23
811197a8:	01400044 	movi	r5,1
811197ac:	01204574 	movhi	r4,33045
811197b0:	21287104 	addi	r4,r4,-24124
811197b4:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		return bSuccess;
811197b8:	e0bffe17 	ldw	r2,-8(fp)
811197bc:	00002306 	br	8111984c <bInitSync+0x224>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
811197c0:	01000044 	movi	r4,1
811197c4:	110bcac0 	call	8110bcac <bSyncCtrExtnIrq>
811197c8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
811197cc:	e0bffe17 	ldw	r2,-8(fp)
811197d0:	1000091e 	bne	r2,zero,811197f8 <bInitSync+0x1d0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
811197d4:	d0a05c17 	ldw	r2,-32400(gp)
811197d8:	100f883a 	mov	r7,r2
811197dc:	018005c4 	movi	r6,23
811197e0:	01400044 	movi	r5,1
811197e4:	01204574 	movhi	r4,33045
811197e8:	21287104 	addi	r4,r4,-24124
811197ec:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		return bSuccess;
811197f0:	e0bffe17 	ldw	r2,-8(fp)
811197f4:	00001506 	br	8111984c <bInitSync+0x224>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
811197f8:	01000044 	movi	r4,1
811197fc:	110be740 	call	8110be74 <bSyncCtrSyncOutEnable>
81119800:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119804:	e0bffe17 	ldw	r2,-8(fp)
81119808:	1000091e 	bne	r2,zero,81119830 <bInitSync+0x208>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111980c:	d0a05c17 	ldw	r2,-32400(gp)
81119810:	100f883a 	mov	r7,r2
81119814:	018005c4 	movi	r6,23
81119818:	01400044 	movi	r5,1
8111981c:	01204574 	movhi	r4,33045
81119820:	21287104 	addi	r4,r4,-24124
81119824:	111ba2c0 	call	8111ba2c <fwrite>
		#endif
		return bSuccess;
81119828:	e0bffe17 	ldw	r2,-8(fp)
8111982c:	00000706 	br	8111984c <bInitSync+0x224>
	}

	bSuccess = bSyncCtrStart();
81119830:	110bd240 	call	8110bd24 <bSyncCtrStart>
81119834:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
81119838:	110bd780 	call	8110bd78 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
8111983c:	01000044 	movi	r4,1
81119840:	110c2fc0 	call	8110c2fc <bSyncIrqEnableBlank>
81119844:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
81119848:	e0bffe17 	ldw	r2,-8(fp)
}
8111984c:	e037883a 	mov	sp,fp
81119850:	dfc00117 	ldw	ra,4(sp)
81119854:	df000017 	ldw	fp,0(sp)
81119858:	dec00204 	addi	sp,sp,8
8111985c:	f800283a 	ret

81119860 <bStartSync>:


bool bStartSync(void) {
81119860:	defffd04 	addi	sp,sp,-12
81119864:	de00012e 	bgeu	sp,et,8111986c <bStartSync+0xc>
81119868:	003b68fa 	trap	3
8111986c:	dfc00215 	stw	ra,8(sp)
81119870:	df000115 	stw	fp,4(sp)
81119874:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSuccess = bSyncCtrStart();
81119878:	110bd240 	call	8110bd24 <bSyncCtrStart>
8111987c:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
81119880:	e0bfff17 	ldw	r2,-4(fp)
}
81119884:	e037883a 	mov	sp,fp
81119888:	dfc00117 	ldw	ra,4(sp)
8111988c:	df000017 	ldw	fp,0(sp)
81119890:	dec00204 	addi	sp,sp,8
81119894:	f800283a 	ret

81119898 <bStopSync>:

bool bStopSync(void) {
81119898:	defffe04 	addi	sp,sp,-8
8111989c:	de00012e 	bgeu	sp,et,811198a4 <bStopSync+0xc>
811198a0:	003b68fa 	trap	3
811198a4:	dfc00115 	stw	ra,4(sp)
811198a8:	df000015 	stw	fp,0(sp)
811198ac:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
811198b0:	110bd780 	call	8110bd78 <bSyncCtrReset>
}
811198b4:	e037883a 	mov	sp,fp
811198b8:	dfc00117 	ldw	ra,4(sp)
811198bc:	df000017 	ldw	fp,0(sp)
811198c0:	dec00204 	addi	sp,sp,8
811198c4:	f800283a 	ret

811198c8 <bClearCounterSync>:

bool bClearCounterSync(void) {
811198c8:	defffe04 	addi	sp,sp,-8
811198cc:	de00012e 	bgeu	sp,et,811198d4 <bClearCounterSync+0xc>
811198d0:	003b68fa 	trap	3
811198d4:	dfc00115 	stw	ra,4(sp)
811198d8:	df000015 	stw	fp,0(sp)
811198dc:	d839883a 	mov	fp,sp

	vSyncClearCounter();
811198e0:	110b7280 	call	8110b728 <vSyncClearCounter>
}
811198e4:	0001883a 	nop
811198e8:	e037883a 	mov	sp,fp
811198ec:	dfc00117 	ldw	ra,4(sp)
811198f0:	df000017 	ldw	fp,0(sp)
811198f4:	dec00204 	addi	sp,sp,8
811198f8:	f800283a 	ret

811198fc <bTestSimucamCriticalHW>:


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void )
{
811198fc:	deffff04 	addi	sp,sp,-4
81119900:	de00012e 	bgeu	sp,et,81119908 <bTestSimucamCriticalHW+0xc>
81119904:	003b68fa 	trap	3
81119908:	df000015 	stw	fp,0(sp)
8111990c:	d839883a 	mov	fp,sp
	 * SDcard para criar logs e pegar defaults
	 */



	return TRUE;
81119910:	00800044 	movi	r2,1
}
81119914:	e037883a 	mov	sp,fp
81119918:	df000017 	ldw	fp,0(sp)
8111991c:	dec00104 	addi	sp,sp,4
81119920:	f800283a 	ret

81119924 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
81119924:	defffc04 	addi	sp,sp,-16
81119928:	de00012e 	bgeu	sp,et,81119930 <_reg_write+0xc>
8111992c:	003b68fa 	trap	3
81119930:	df000315 	stw	fp,12(sp)
81119934:	df000304 	addi	fp,sp,12
81119938:	e13ffd15 	stw	r4,-12(fp)
8111993c:	e17ffe15 	stw	r5,-8(fp)
81119940:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
81119944:	e0bffe17 	ldw	r2,-8(fp)
81119948:	1085883a 	add	r2,r2,r2
8111994c:	1085883a 	add	r2,r2,r2
81119950:	1007883a 	mov	r3,r2
81119954:	e0bffd17 	ldw	r2,-12(fp)
81119958:	1885883a 	add	r2,r3,r2
8111995c:	1007883a 	mov	r3,r2
81119960:	e0bfff17 	ldw	r2,-4(fp)
81119964:	18800035 	stwio	r2,0(r3)
	return 1;
81119968:	00800044 	movi	r2,1

}
8111996c:	e037883a 	mov	sp,fp
81119970:	df000017 	ldw	fp,0(sp)
81119974:	dec00104 	addi	sp,sp,4
81119978:	f800283a 	ret

8111997c <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111997c:	defffc04 	addi	sp,sp,-16
81119980:	de00012e 	bgeu	sp,et,81119988 <_reg_read+0xc>
81119984:	003b68fa 	trap	3
81119988:	df000315 	stw	fp,12(sp)
8111998c:	df000304 	addi	fp,sp,12
81119990:	e13ffd15 	stw	r4,-12(fp)
81119994:	e17ffe15 	stw	r5,-8(fp)
81119998:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111999c:	e0bffe17 	ldw	r2,-8(fp)
811199a0:	1085883a 	add	r2,r2,r2
811199a4:	1085883a 	add	r2,r2,r2
811199a8:	1007883a 	mov	r3,r2
811199ac:	e0bffd17 	ldw	r2,-12(fp)
811199b0:	1885883a 	add	r2,r3,r2
811199b4:	10c00037 	ldwio	r3,0(r2)
811199b8:	e0bfff17 	ldw	r2,-4(fp)
811199bc:	10c00015 	stw	r3,0(r2)
	return 1;
811199c0:	00800044 	movi	r2,1

}
811199c4:	e037883a 	mov	sp,fp
811199c8:	df000017 	ldw	fp,0(sp)
811199cc:	dec00104 	addi	sp,sp,4
811199d0:	f800283a 	ret

811199d4 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
811199d4:	defffa04 	addi	sp,sp,-24
811199d8:	de00012e 	bgeu	sp,et,811199e0 <_print_codec_status+0xc>
811199dc:	003b68fa 	trap	3
811199e0:	dfc00515 	stw	ra,20(sp)
811199e4:	df000415 	stw	fp,16(sp)
811199e8:	df000404 	addi	fp,sp,16
811199ec:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
811199f0:	e0bfff17 	ldw	r2,-4(fp)
811199f4:	1005d1ba 	srai	r2,r2,6
811199f8:	1080004c 	andi	r2,r2,1
811199fc:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
81119a00:	e0bfff17 	ldw	r2,-4(fp)
81119a04:	1005d17a 	srai	r2,r2,5
81119a08:	1080004c 	andi	r2,r2,1
81119a0c:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
81119a10:	e0bfff17 	ldw	r2,-4(fp)
81119a14:	1005d13a 	srai	r2,r2,4
81119a18:	1080004c 	andi	r2,r2,1
81119a1c:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
81119a20:	00e04574 	movhi	r3,33045
81119a24:	18f45504 	addi	r3,r3,-11948
81119a28:	00a04574 	movhi	r2,33045
81119a2c:	10a87704 	addi	r2,r2,-24100
81119a30:	1009883a 	mov	r4,r2
81119a34:	008005c4 	movi	r2,23
81119a38:	100d883a 	mov	r6,r2
81119a3c:	200b883a 	mov	r5,r4
81119a40:	1809883a 	mov	r4,r3
81119a44:	111c4400 	call	8111c440 <memcpy>
	debug(fp, cDebugBuffer);
81119a48:	d0a05c17 	ldw	r2,-32400(gp)
81119a4c:	01604574 	movhi	r5,33045
81119a50:	29745504 	addi	r5,r5,-11948
81119a54:	1009883a 	mov	r4,r2
81119a58:	111b3900 	call	8111b390 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
81119a5c:	e0bffc17 	ldw	r2,-16(fp)
81119a60:	10800058 	cmpnei	r2,r2,1
81119a64:	1000031e 	bne	r2,zero,81119a74 <_print_codec_status+0xa0>
81119a68:	00a04574 	movhi	r2,33045
81119a6c:	10a87d04 	addi	r2,r2,-24076
81119a70:	00000206 	br	81119a7c <_print_codec_status+0xa8>
81119a74:	00a04574 	movhi	r2,33045
81119a78:	10a87e04 	addi	r2,r2,-24072
81119a7c:	100d883a 	mov	r6,r2
81119a80:	01604574 	movhi	r5,33045
81119a84:	29687f04 	addi	r5,r5,-24068
81119a88:	01204574 	movhi	r4,33045
81119a8c:	21345504 	addi	r4,r4,-11948
81119a90:	111cd200 	call	8111cd20 <sprintf>
	debug(fp, cDebugBuffer);
81119a94:	d0a05c17 	ldw	r2,-32400(gp)
81119a98:	01604574 	movhi	r5,33045
81119a9c:	29745504 	addi	r5,r5,-11948
81119aa0:	1009883a 	mov	r4,r2
81119aa4:	111b3900 	call	8111b390 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
81119aa8:	e0bffd17 	ldw	r2,-12(fp)
81119aac:	10800058 	cmpnei	r2,r2,1
81119ab0:	1000031e 	bne	r2,zero,81119ac0 <_print_codec_status+0xec>
81119ab4:	00a04574 	movhi	r2,33045
81119ab8:	10a87d04 	addi	r2,r2,-24076
81119abc:	00000206 	br	81119ac8 <_print_codec_status+0xf4>
81119ac0:	00a04574 	movhi	r2,33045
81119ac4:	10a87e04 	addi	r2,r2,-24072
81119ac8:	100d883a 	mov	r6,r2
81119acc:	01604574 	movhi	r5,33045
81119ad0:	29688504 	addi	r5,r5,-24044
81119ad4:	01204574 	movhi	r4,33045
81119ad8:	21345504 	addi	r4,r4,-11948
81119adc:	111cd200 	call	8111cd20 <sprintf>
	debug(fp, cDebugBuffer);
81119ae0:	d0a05c17 	ldw	r2,-32400(gp)
81119ae4:	01604574 	movhi	r5,33045
81119ae8:	29745504 	addi	r5,r5,-11948
81119aec:	1009883a 	mov	r4,r2
81119af0:	111b3900 	call	8111b390 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
81119af4:	e0bffe17 	ldw	r2,-8(fp)
81119af8:	10800058 	cmpnei	r2,r2,1
81119afc:	1000031e 	bne	r2,zero,81119b0c <_print_codec_status+0x138>
81119b00:	00a04574 	movhi	r2,33045
81119b04:	10a87d04 	addi	r2,r2,-24076
81119b08:	00000206 	br	81119b14 <_print_codec_status+0x140>
81119b0c:	00a04574 	movhi	r2,33045
81119b10:	10a87e04 	addi	r2,r2,-24072
81119b14:	100d883a 	mov	r6,r2
81119b18:	01604574 	movhi	r5,33045
81119b1c:	29688b04 	addi	r5,r5,-24020
81119b20:	01204574 	movhi	r4,33045
81119b24:	21345504 	addi	r4,r4,-11948
81119b28:	111cd200 	call	8111cd20 <sprintf>
	debug(fp, cDebugBuffer);
81119b2c:	d0a05c17 	ldw	r2,-32400(gp)
81119b30:	01604574 	movhi	r5,33045
81119b34:	29745504 	addi	r5,r5,-11948
81119b38:	1009883a 	mov	r4,r2
81119b3c:	111b3900 	call	8111b390 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
81119b40:	00a04574 	movhi	r2,33045
81119b44:	10b45504 	addi	r2,r2,-11948
81119b48:	00c00b44 	movi	r3,45
81119b4c:	10c00005 	stb	r3,0(r2)
81119b50:	00c00b44 	movi	r3,45
81119b54:	10c00045 	stb	r3,1(r2)
81119b58:	00c00b44 	movi	r3,45
81119b5c:	10c00085 	stb	r3,2(r2)
81119b60:	00c00b44 	movi	r3,45
81119b64:	10c000c5 	stb	r3,3(r2)
81119b68:	00c00b44 	movi	r3,45
81119b6c:	10c00105 	stb	r3,4(r2)
81119b70:	00c00b44 	movi	r3,45
81119b74:	10c00145 	stb	r3,5(r2)
81119b78:	00c00b44 	movi	r3,45
81119b7c:	10c00185 	stb	r3,6(r2)
81119b80:	00c00b44 	movi	r3,45
81119b84:	10c001c5 	stb	r3,7(r2)
81119b88:	00c00804 	movi	r3,32
81119b8c:	10c00205 	stb	r3,8(r2)
81119b90:	00c00804 	movi	r3,32
81119b94:	10c00245 	stb	r3,9(r2)
81119b98:	00c00284 	movi	r3,10
81119b9c:	10c00285 	stb	r3,10(r2)
81119ba0:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
81119ba4:	d0a05c17 	ldw	r2,-32400(gp)
81119ba8:	01604574 	movhi	r5,33045
81119bac:	29745504 	addi	r5,r5,-11948
81119bb0:	1009883a 	mov	r4,r2
81119bb4:	111b3900 	call	8111b390 <fprintf>
#endif
}
81119bb8:	0001883a 	nop
81119bbc:	e037883a 	mov	sp,fp
81119bc0:	dfc00117 	ldw	ra,4(sp)
81119bc4:	df000017 	ldw	fp,0(sp)
81119bc8:	dec00204 	addi	sp,sp,8
81119bcc:	f800283a 	ret

81119bd0 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
81119bd0:	defffb04 	addi	sp,sp,-20
81119bd4:	de00012e 	bgeu	sp,et,81119bdc <_split_codec_status+0xc>
81119bd8:	003b68fa 	trap	3
81119bdc:	df000415 	stw	fp,16(sp)
81119be0:	df000404 	addi	fp,sp,16
81119be4:	e13ffc15 	stw	r4,-16(fp)
81119be8:	e17ffd15 	stw	r5,-12(fp)
81119bec:	e1bffe15 	stw	r6,-8(fp)
81119bf0:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
81119bf4:	e0bffc17 	ldw	r2,-16(fp)
81119bf8:	1005d1ba 	srai	r2,r2,6
81119bfc:	10c0004c 	andi	r3,r2,1
81119c00:	e0bffd17 	ldw	r2,-12(fp)
81119c04:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
81119c08:	e0bffc17 	ldw	r2,-16(fp)
81119c0c:	1005d17a 	srai	r2,r2,5
81119c10:	10c0004c 	andi	r3,r2,1
81119c14:	e0bffe17 	ldw	r2,-8(fp)
81119c18:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
81119c1c:	e0bffc17 	ldw	r2,-16(fp)
81119c20:	1005d13a 	srai	r2,r2,4
81119c24:	10c0004c 	andi	r3,r2,1
81119c28:	e0bfff17 	ldw	r2,-4(fp)
81119c2c:	10c00015 	stw	r3,0(r2)
}
81119c30:	0001883a 	nop
81119c34:	e037883a 	mov	sp,fp
81119c38:	df000017 	ldw	fp,0(sp)
81119c3c:	dec00104 	addi	sp,sp,4
81119c40:	f800283a 	ret

81119c44 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
81119c44:	defffc04 	addi	sp,sp,-16
81119c48:	de00012e 	bgeu	sp,et,81119c50 <aatoh+0xc>
81119c4c:	003b68fa 	trap	3
81119c50:	df000315 	stw	fp,12(sp)
81119c54:	df000304 	addi	fp,sp,12
81119c58:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
81119c5c:	e0bfff17 	ldw	r2,-4(fp)
81119c60:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81119c64:	e0bffd17 	ldw	r2,-12(fp)
81119c68:	10c00003 	ldbu	r3,0(r2)
81119c6c:	e0bffd17 	ldw	r2,-12(fp)
81119c70:	10800003 	ldbu	r2,0(r2)
81119c74:	10803fcc 	andi	r2,r2,255
81119c78:	10800eb0 	cmpltui	r2,r2,58
81119c7c:	1000021e 	bne	r2,zero,81119c88 <aatoh+0x44>
81119c80:	00800dc4 	movi	r2,55
81119c84:	00000106 	br	81119c8c <aatoh+0x48>
81119c88:	00800c04 	movi	r2,48
81119c8c:	1885c83a 	sub	r2,r3,r2
81119c90:	1004913a 	slli	r2,r2,4
81119c94:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
81119c98:	e0bffd17 	ldw	r2,-12(fp)
81119c9c:	10800044 	addi	r2,r2,1
81119ca0:	10c00003 	ldbu	r3,0(r2)
81119ca4:	e0bffd17 	ldw	r2,-12(fp)
81119ca8:	10800044 	addi	r2,r2,1
81119cac:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81119cb0:	10803fcc 	andi	r2,r2,255
81119cb4:	10800eb0 	cmpltui	r2,r2,58
81119cb8:	1000021e 	bne	r2,zero,81119cc4 <aatoh+0x80>
81119cbc:	00800dc4 	movi	r2,55
81119cc0:	00000106 	br	81119cc8 <aatoh+0x84>
81119cc4:	00800c04 	movi	r2,48
81119cc8:	1885c83a 	sub	r2,r3,r2
81119ccc:	2085883a 	add	r2,r4,r2
81119cd0:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
81119cd4:	e0bffe03 	ldbu	r2,-8(fp)
}
81119cd8:	e037883a 	mov	sp,fp
81119cdc:	df000017 	ldw	fp,0(sp)
81119ce0:	dec00104 	addi	sp,sp,4
81119ce4:	f800283a 	ret

81119ce8 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
81119ce8:	defffd04 	addi	sp,sp,-12
81119cec:	de00012e 	bgeu	sp,et,81119cf4 <Verif_Error+0xc>
81119cf0:	003b68fa 	trap	3
81119cf4:	dfc00215 	stw	ra,8(sp)
81119cf8:	df000115 	stw	fp,4(sp)
81119cfc:	df000104 	addi	fp,sp,4
81119d00:	2005883a 	mov	r2,r4
81119d04:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
81119d08:	e0bfff03 	ldbu	r2,-4(fp)
81119d0c:	1000091e 	bne	r2,zero,81119d34 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
81119d10:	d0a05c17 	ldw	r2,-32400(gp)
81119d14:	100f883a 	mov	r7,r2
81119d18:	018001c4 	movi	r6,7
81119d1c:	01400044 	movi	r5,1
81119d20:	01204574 	movhi	r4,33045
81119d24:	21289104 	addi	r4,r4,-23996
81119d28:	111ba2c0 	call	8111ba2c <fwrite>
#endif
		return 0;
81119d2c:	0005883a 	mov	r2,zero
81119d30:	00000106 	br	81119d38 <Verif_Error+0x50>
	} else
		return 1;
81119d34:	00800044 	movi	r2,1
}
81119d38:	e037883a 	mov	sp,fp
81119d3c:	dfc00117 	ldw	ra,4(sp)
81119d40:	df000017 	ldw	fp,0(sp)
81119d44:	dec00204 	addi	sp,sp,8
81119d48:	f800283a 	ret

81119d4c <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
81119d4c:	defffe04 	addi	sp,sp,-8
81119d50:	de00012e 	bgeu	sp,et,81119d58 <toInt+0xc>
81119d54:	003b68fa 	trap	3
81119d58:	df000115 	stw	fp,4(sp)
81119d5c:	df000104 	addi	fp,sp,4
81119d60:	2005883a 	mov	r2,r4
81119d64:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
81119d68:	e0bfff03 	ldbu	r2,-4(fp)
81119d6c:	10bff404 	addi	r2,r2,-48
}
81119d70:	e037883a 	mov	sp,fp
81119d74:	df000017 	ldw	fp,0(sp)
81119d78:	dec00104 	addi	sp,sp,4
81119d7c:	f800283a 	ret

81119d80 <__divsf3>:
81119d80:	defff504 	addi	sp,sp,-44
81119d84:	200cd5fa 	srli	r6,r4,23
81119d88:	de00012e 	bgeu	sp,et,81119d90 <__divsf3+0x10>
81119d8c:	003b68fa 	trap	3
81119d90:	dcc00415 	stw	r19,16(sp)
81119d94:	2026d7fa 	srli	r19,r4,31
81119d98:	00c02034 	movhi	r3,128
81119d9c:	dd800715 	stw	r22,28(sp)
81119da0:	dd000515 	stw	r20,20(sp)
81119da4:	dc800315 	stw	r18,12(sp)
81119da8:	18ffffc4 	addi	r3,r3,-1
81119dac:	dfc00a15 	stw	ra,40(sp)
81119db0:	df000915 	stw	fp,36(sp)
81119db4:	ddc00815 	stw	r23,32(sp)
81119db8:	dd400615 	stw	r21,24(sp)
81119dbc:	dc400215 	stw	r17,8(sp)
81119dc0:	dc000115 	stw	r16,4(sp)
81119dc4:	35003fcc 	andi	r20,r6,255
81119dc8:	1924703a 	and	r18,r3,r4
81119dcc:	9d803fcc 	andi	r22,r19,255
81119dd0:	a0005226 	beq	r20,zero,81119f1c <__divsf3+0x19c>
81119dd4:	00803fc4 	movi	r2,255
81119dd8:	a0802e26 	beq	r20,r2,81119e94 <__divsf3+0x114>
81119ddc:	91002034 	orhi	r4,r18,128
81119de0:	202490fa 	slli	r18,r4,3
81119de4:	a53fe044 	addi	r20,r20,-127
81119de8:	0021883a 	mov	r16,zero
81119dec:	002f883a 	mov	r23,zero
81119df0:	280cd5fa 	srli	r6,r5,23
81119df4:	282ad7fa 	srli	r21,r5,31
81119df8:	00c02034 	movhi	r3,128
81119dfc:	18ffffc4 	addi	r3,r3,-1
81119e00:	31803fcc 	andi	r6,r6,255
81119e04:	1962703a 	and	r17,r3,r5
81119e08:	af003fcc 	andi	fp,r21,255
81119e0c:	30004a26 	beq	r6,zero,81119f38 <__divsf3+0x1b8>
81119e10:	00803fc4 	movi	r2,255
81119e14:	30804526 	beq	r6,r2,81119f2c <__divsf3+0x1ac>
81119e18:	89402034 	orhi	r5,r17,128
81119e1c:	282290fa 	slli	r17,r5,3
81119e20:	31bfe044 	addi	r6,r6,-127
81119e24:	000b883a 	mov	r5,zero
81119e28:	2c20b03a 	or	r16,r5,r16
81119e2c:	802090ba 	slli	r16,r16,2
81119e30:	00a044b4 	movhi	r2,33042
81119e34:	10a79504 	addi	r2,r2,-25004
81119e38:	80a1883a 	add	r16,r16,r2
81119e3c:	81000017 	ldw	r4,0(r16)
81119e40:	9d46f03a 	xor	r3,r19,r21
81119e44:	180f883a 	mov	r7,r3
81119e48:	18803fcc 	andi	r2,r3,255
81119e4c:	a18dc83a 	sub	r6,r20,r6
81119e50:	2000683a 	jmp	r4
81119e54:	8111a038 	rdprs	r4,r16,18048
81119e58:	81119ebc 	xorhi	r4,r16,18042
81119e5c:	8111a02c 	andhi	r4,r16,18048
81119e60:	81119ea8 	cmpgeui	r4,r16,18042
81119e64:	8111a02c 	andhi	r4,r16,18048
81119e68:	8111a004 	addi	r4,r16,18048
81119e6c:	8111a02c 	andhi	r4,r16,18048
81119e70:	81119ea8 	cmpgeui	r4,r16,18042
81119e74:	81119ebc 	xorhi	r4,r16,18042
81119e78:	81119ebc 	xorhi	r4,r16,18042
81119e7c:	8111a004 	addi	r4,r16,18048
81119e80:	81119ea8 	cmpgeui	r4,r16,18042
81119e84:	8111a118 	cmpnei	r4,r16,18052
81119e88:	8111a118 	cmpnei	r4,r16,18052
81119e8c:	8111a118 	cmpnei	r4,r16,18052
81119e90:	8111a0cc 	andi	r4,r16,18051
81119e94:	9000581e 	bne	r18,zero,81119ff8 <__divsf3+0x278>
81119e98:	04000204 	movi	r16,8
81119e9c:	05c00084 	movi	r23,2
81119ea0:	003fd306 	br	81119df0 <__reset+0xfb0f9df0>
81119ea4:	0023883a 	mov	r17,zero
81119ea8:	e02d883a 	mov	r22,fp
81119eac:	282f883a 	mov	r23,r5
81119eb0:	00800084 	movi	r2,2
81119eb4:	b8808f1e 	bne	r23,r2,8111a0f4 <__divsf3+0x374>
81119eb8:	b005883a 	mov	r2,r22
81119ebc:	11c0004c 	andi	r7,r2,1
81119ec0:	013fffc4 	movi	r4,-1
81119ec4:	000d883a 	mov	r6,zero
81119ec8:	21003fcc 	andi	r4,r4,255
81119ecc:	200895fa 	slli	r4,r4,23
81119ed0:	38803fcc 	andi	r2,r7,255
81119ed4:	00c02034 	movhi	r3,128
81119ed8:	100497fa 	slli	r2,r2,31
81119edc:	18ffffc4 	addi	r3,r3,-1
81119ee0:	30c6703a 	and	r3,r6,r3
81119ee4:	1906b03a 	or	r3,r3,r4
81119ee8:	1884b03a 	or	r2,r3,r2
81119eec:	dfc00a17 	ldw	ra,40(sp)
81119ef0:	df000917 	ldw	fp,36(sp)
81119ef4:	ddc00817 	ldw	r23,32(sp)
81119ef8:	dd800717 	ldw	r22,28(sp)
81119efc:	dd400617 	ldw	r21,24(sp)
81119f00:	dd000517 	ldw	r20,20(sp)
81119f04:	dcc00417 	ldw	r19,16(sp)
81119f08:	dc800317 	ldw	r18,12(sp)
81119f0c:	dc400217 	ldw	r17,8(sp)
81119f10:	dc000117 	ldw	r16,4(sp)
81119f14:	dec00b04 	addi	sp,sp,44
81119f18:	f800283a 	ret
81119f1c:	90002b1e 	bne	r18,zero,81119fcc <__divsf3+0x24c>
81119f20:	04000104 	movi	r16,4
81119f24:	05c00044 	movi	r23,1
81119f28:	003fb106 	br	81119df0 <__reset+0xfb0f9df0>
81119f2c:	8800251e 	bne	r17,zero,81119fc4 <__divsf3+0x244>
81119f30:	01400084 	movi	r5,2
81119f34:	00000206 	br	81119f40 <__divsf3+0x1c0>
81119f38:	88001a1e 	bne	r17,zero,81119fa4 <__divsf3+0x224>
81119f3c:	01400044 	movi	r5,1
81119f40:	8160b03a 	or	r16,r16,r5
81119f44:	802090ba 	slli	r16,r16,2
81119f48:	00e044b4 	movhi	r3,33042
81119f4c:	18e7d904 	addi	r3,r3,-24732
81119f50:	80e1883a 	add	r16,r16,r3
81119f54:	80c00017 	ldw	r3,0(r16)
81119f58:	9d44f03a 	xor	r2,r19,r21
81119f5c:	a18dc83a 	sub	r6,r20,r6
81119f60:	1800683a 	jmp	r3
81119f64:	81119ebc 	xorhi	r4,r16,18042
81119f68:	81119ebc 	xorhi	r4,r16,18042
81119f6c:	8111a108 	cmpgei	r4,r16,18052
81119f70:	81119ea4 	muli	r4,r16,18042
81119f74:	8111a108 	cmpgei	r4,r16,18052
81119f78:	8111a004 	addi	r4,r16,18048
81119f7c:	8111a108 	cmpgei	r4,r16,18052
81119f80:	81119ea4 	muli	r4,r16,18042
81119f84:	81119ebc 	xorhi	r4,r16,18042
81119f88:	81119ebc 	xorhi	r4,r16,18042
81119f8c:	8111a004 	addi	r4,r16,18048
81119f90:	81119ea4 	muli	r4,r16,18042
81119f94:	8111a118 	cmpnei	r4,r16,18052
81119f98:	8111a118 	cmpnei	r4,r16,18052
81119f9c:	8111a118 	cmpnei	r4,r16,18052
81119fa0:	8111a130 	cmpltui	r4,r16,18052
81119fa4:	8809883a 	mov	r4,r17
81119fa8:	111b1d00 	call	8111b1d0 <__clzsi2>
81119fac:	10fffec4 	addi	r3,r2,-5
81119fb0:	10801d84 	addi	r2,r2,118
81119fb4:	88e2983a 	sll	r17,r17,r3
81119fb8:	008dc83a 	sub	r6,zero,r2
81119fbc:	000b883a 	mov	r5,zero
81119fc0:	003f9906 	br	81119e28 <__reset+0xfb0f9e28>
81119fc4:	014000c4 	movi	r5,3
81119fc8:	003f9706 	br	81119e28 <__reset+0xfb0f9e28>
81119fcc:	9009883a 	mov	r4,r18
81119fd0:	d9400015 	stw	r5,0(sp)
81119fd4:	111b1d00 	call	8111b1d0 <__clzsi2>
81119fd8:	10fffec4 	addi	r3,r2,-5
81119fdc:	11801d84 	addi	r6,r2,118
81119fe0:	90e4983a 	sll	r18,r18,r3
81119fe4:	01a9c83a 	sub	r20,zero,r6
81119fe8:	0021883a 	mov	r16,zero
81119fec:	002f883a 	mov	r23,zero
81119ff0:	d9400017 	ldw	r5,0(sp)
81119ff4:	003f7e06 	br	81119df0 <__reset+0xfb0f9df0>
81119ff8:	04000304 	movi	r16,12
81119ffc:	05c000c4 	movi	r23,3
8111a000:	003f7b06 	br	81119df0 <__reset+0xfb0f9df0>
8111a004:	01802034 	movhi	r6,128
8111a008:	000f883a 	mov	r7,zero
8111a00c:	31bfffc4 	addi	r6,r6,-1
8111a010:	013fffc4 	movi	r4,-1
8111a014:	003fac06 	br	81119ec8 <__reset+0xfb0f9ec8>
8111a018:	01400044 	movi	r5,1
8111a01c:	2909c83a 	sub	r4,r5,r4
8111a020:	00c006c4 	movi	r3,27
8111a024:	19004b0e 	bge	r3,r4,8111a154 <__divsf3+0x3d4>
8111a028:	114e703a 	and	r7,r2,r5
8111a02c:	0009883a 	mov	r4,zero
8111a030:	000d883a 	mov	r6,zero
8111a034:	003fa406 	br	81119ec8 <__reset+0xfb0f9ec8>
8111a038:	9006917a 	slli	r3,r18,5
8111a03c:	8822917a 	slli	r17,r17,5
8111a040:	1c40372e 	bgeu	r3,r17,8111a120 <__divsf3+0x3a0>
8111a044:	31bfffc4 	addi	r6,r6,-1
8111a048:	010006c4 	movi	r4,27
8111a04c:	000b883a 	mov	r5,zero
8111a050:	180f883a 	mov	r7,r3
8111a054:	294b883a 	add	r5,r5,r5
8111a058:	18c7883a 	add	r3,r3,r3
8111a05c:	38000116 	blt	r7,zero,8111a064 <__divsf3+0x2e4>
8111a060:	1c400236 	bltu	r3,r17,8111a06c <__divsf3+0x2ec>
8111a064:	1c47c83a 	sub	r3,r3,r17
8111a068:	29400054 	ori	r5,r5,1
8111a06c:	213fffc4 	addi	r4,r4,-1
8111a070:	203ff71e 	bne	r4,zero,8111a050 <__reset+0xfb0fa050>
8111a074:	1806c03a 	cmpne	r3,r3,zero
8111a078:	1962b03a 	or	r17,r3,r5
8111a07c:	31001fc4 	addi	r4,r6,127
8111a080:	013fe50e 	bge	zero,r4,8111a018 <__reset+0xfb0fa018>
8111a084:	88c001cc 	andi	r3,r17,7
8111a088:	18000426 	beq	r3,zero,8111a09c <__divsf3+0x31c>
8111a08c:	88c003cc 	andi	r3,r17,15
8111a090:	01400104 	movi	r5,4
8111a094:	19400126 	beq	r3,r5,8111a09c <__divsf3+0x31c>
8111a098:	8963883a 	add	r17,r17,r5
8111a09c:	88c2002c 	andhi	r3,r17,2048
8111a0a0:	18000426 	beq	r3,zero,8111a0b4 <__divsf3+0x334>
8111a0a4:	00fe0034 	movhi	r3,63488
8111a0a8:	18ffffc4 	addi	r3,r3,-1
8111a0ac:	31002004 	addi	r4,r6,128
8111a0b0:	88e2703a 	and	r17,r17,r3
8111a0b4:	00c03f84 	movi	r3,254
8111a0b8:	193f8016 	blt	r3,r4,81119ebc <__reset+0xfb0f9ebc>
8111a0bc:	880c91ba 	slli	r6,r17,6
8111a0c0:	11c0004c 	andi	r7,r2,1
8111a0c4:	300cd27a 	srli	r6,r6,9
8111a0c8:	003f7f06 	br	81119ec8 <__reset+0xfb0f9ec8>
8111a0cc:	9080102c 	andhi	r2,r18,64
8111a0d0:	10000226 	beq	r2,zero,8111a0dc <__divsf3+0x35c>
8111a0d4:	8880102c 	andhi	r2,r17,64
8111a0d8:	10001826 	beq	r2,zero,8111a13c <__divsf3+0x3bc>
8111a0dc:	00802034 	movhi	r2,128
8111a0e0:	91801034 	orhi	r6,r18,64
8111a0e4:	10bfffc4 	addi	r2,r2,-1
8111a0e8:	980f883a 	mov	r7,r19
8111a0ec:	308c703a 	and	r6,r6,r2
8111a0f0:	003fc706 	br	8111a010 <__reset+0xfb0fa010>
8111a0f4:	008000c4 	movi	r2,3
8111a0f8:	b8802d26 	beq	r23,r2,8111a1b0 <__divsf3+0x430>
8111a0fc:	00c00044 	movi	r3,1
8111a100:	b005883a 	mov	r2,r22
8111a104:	b8ffdd1e 	bne	r23,r3,8111a07c <__reset+0xfb0fa07c>
8111a108:	11c0004c 	andi	r7,r2,1
8111a10c:	0009883a 	mov	r4,zero
8111a110:	000d883a 	mov	r6,zero
8111a114:	003f6c06 	br	81119ec8 <__reset+0xfb0f9ec8>
8111a118:	9023883a 	mov	r17,r18
8111a11c:	003f6406 	br	81119eb0 <__reset+0xfb0f9eb0>
8111a120:	1c47c83a 	sub	r3,r3,r17
8111a124:	01000684 	movi	r4,26
8111a128:	01400044 	movi	r5,1
8111a12c:	003fc806 	br	8111a050 <__reset+0xfb0fa050>
8111a130:	9080102c 	andhi	r2,r18,64
8111a134:	103fe926 	beq	r2,zero,8111a0dc <__reset+0xfb0fa0dc>
8111a138:	0023883a 	mov	r17,zero
8111a13c:	00802034 	movhi	r2,128
8111a140:	89801034 	orhi	r6,r17,64
8111a144:	10bfffc4 	addi	r2,r2,-1
8111a148:	a80f883a 	mov	r7,r21
8111a14c:	308c703a 	and	r6,r6,r2
8111a150:	003faf06 	br	8111a010 <__reset+0xfb0fa010>
8111a154:	01c00804 	movi	r7,32
8111a158:	390fc83a 	sub	r7,r7,r4
8111a15c:	89ce983a 	sll	r7,r17,r7
8111a160:	890ad83a 	srl	r5,r17,r4
8111a164:	380ec03a 	cmpne	r7,r7,zero
8111a168:	29cab03a 	or	r5,r5,r7
8111a16c:	28c001cc 	andi	r3,r5,7
8111a170:	18000426 	beq	r3,zero,8111a184 <__divsf3+0x404>
8111a174:	28c003cc 	andi	r3,r5,15
8111a178:	01000104 	movi	r4,4
8111a17c:	19000126 	beq	r3,r4,8111a184 <__divsf3+0x404>
8111a180:	290b883a 	add	r5,r5,r4
8111a184:	28c1002c 	andhi	r3,r5,1024
8111a188:	18000426 	beq	r3,zero,8111a19c <__divsf3+0x41c>
8111a18c:	11c0004c 	andi	r7,r2,1
8111a190:	01000044 	movi	r4,1
8111a194:	000d883a 	mov	r6,zero
8111a198:	003f4b06 	br	81119ec8 <__reset+0xfb0f9ec8>
8111a19c:	280a91ba 	slli	r5,r5,6
8111a1a0:	11c0004c 	andi	r7,r2,1
8111a1a4:	0009883a 	mov	r4,zero
8111a1a8:	280cd27a 	srli	r6,r5,9
8111a1ac:	003f4606 	br	81119ec8 <__reset+0xfb0f9ec8>
8111a1b0:	00802034 	movhi	r2,128
8111a1b4:	89801034 	orhi	r6,r17,64
8111a1b8:	10bfffc4 	addi	r2,r2,-1
8111a1bc:	b00f883a 	mov	r7,r22
8111a1c0:	308c703a 	and	r6,r6,r2
8111a1c4:	003f9206 	br	8111a010 <__reset+0xfb0fa010>

8111a1c8 <__mulsf3>:
8111a1c8:	defff504 	addi	sp,sp,-44
8111a1cc:	de00012e 	bgeu	sp,et,8111a1d4 <__mulsf3+0xc>
8111a1d0:	003b68fa 	trap	3
8111a1d4:	dc000115 	stw	r16,4(sp)
8111a1d8:	2020d5fa 	srli	r16,r4,23
8111a1dc:	dd400615 	stw	r21,24(sp)
8111a1e0:	202ad7fa 	srli	r21,r4,31
8111a1e4:	dc800315 	stw	r18,12(sp)
8111a1e8:	04802034 	movhi	r18,128
8111a1ec:	df000915 	stw	fp,36(sp)
8111a1f0:	dd000515 	stw	r20,20(sp)
8111a1f4:	94bfffc4 	addi	r18,r18,-1
8111a1f8:	dfc00a15 	stw	ra,40(sp)
8111a1fc:	ddc00815 	stw	r23,32(sp)
8111a200:	dd800715 	stw	r22,28(sp)
8111a204:	dcc00415 	stw	r19,16(sp)
8111a208:	dc400215 	stw	r17,8(sp)
8111a20c:	84003fcc 	andi	r16,r16,255
8111a210:	9124703a 	and	r18,r18,r4
8111a214:	a829883a 	mov	r20,r21
8111a218:	af003fcc 	andi	fp,r21,255
8111a21c:	80005426 	beq	r16,zero,8111a370 <__mulsf3+0x1a8>
8111a220:	00803fc4 	movi	r2,255
8111a224:	80802f26 	beq	r16,r2,8111a2e4 <__mulsf3+0x11c>
8111a228:	91002034 	orhi	r4,r18,128
8111a22c:	202490fa 	slli	r18,r4,3
8111a230:	843fe044 	addi	r16,r16,-127
8111a234:	0023883a 	mov	r17,zero
8111a238:	002f883a 	mov	r23,zero
8111a23c:	2804d5fa 	srli	r2,r5,23
8111a240:	282cd7fa 	srli	r22,r5,31
8111a244:	01002034 	movhi	r4,128
8111a248:	213fffc4 	addi	r4,r4,-1
8111a24c:	10803fcc 	andi	r2,r2,255
8111a250:	2166703a 	and	r19,r4,r5
8111a254:	b1803fcc 	andi	r6,r22,255
8111a258:	10004c26 	beq	r2,zero,8111a38c <__mulsf3+0x1c4>
8111a25c:	00c03fc4 	movi	r3,255
8111a260:	10c04726 	beq	r2,r3,8111a380 <__mulsf3+0x1b8>
8111a264:	99002034 	orhi	r4,r19,128
8111a268:	202690fa 	slli	r19,r4,3
8111a26c:	10bfe044 	addi	r2,r2,-127
8111a270:	0007883a 	mov	r3,zero
8111a274:	80a1883a 	add	r16,r16,r2
8111a278:	010003c4 	movi	r4,15
8111a27c:	1c44b03a 	or	r2,r3,r17
8111a280:	b56af03a 	xor	r21,r22,r21
8111a284:	81c00044 	addi	r7,r16,1
8111a288:	20806b36 	bltu	r4,r2,8111a438 <__mulsf3+0x270>
8111a28c:	100490ba 	slli	r2,r2,2
8111a290:	012044b4 	movhi	r4,33042
8111a294:	2128a904 	addi	r4,r4,-23900
8111a298:	1105883a 	add	r2,r2,r4
8111a29c:	10800017 	ldw	r2,0(r2)
8111a2a0:	1000683a 	jmp	r2
8111a2a4:	8111a438 	rdprs	r4,r16,18064
8111a2a8:	8111a2f8 	rdprs	r4,r16,18059
8111a2ac:	8111a2f8 	rdprs	r4,r16,18059
8111a2b0:	8111a2f4 	orhi	r4,r16,18059
8111a2b4:	8111a41c 	xori	r4,r16,18064
8111a2b8:	8111a41c 	xori	r4,r16,18064
8111a2bc:	8111a408 	cmpgei	r4,r16,18064
8111a2c0:	8111a2f4 	orhi	r4,r16,18059
8111a2c4:	8111a41c 	xori	r4,r16,18064
8111a2c8:	8111a408 	cmpgei	r4,r16,18064
8111a2cc:	8111a41c 	xori	r4,r16,18064
8111a2d0:	8111a2f4 	orhi	r4,r16,18059
8111a2d4:	8111a428 	cmpgeui	r4,r16,18064
8111a2d8:	8111a428 	cmpgeui	r4,r16,18064
8111a2dc:	8111a428 	cmpgeui	r4,r16,18064
8111a2e0:	8111a504 	addi	r4,r16,18068
8111a2e4:	90003b1e 	bne	r18,zero,8111a3d4 <__mulsf3+0x20c>
8111a2e8:	04400204 	movi	r17,8
8111a2ec:	05c00084 	movi	r23,2
8111a2f0:	003fd206 	br	8111a23c <__reset+0xfb0fa23c>
8111a2f4:	302b883a 	mov	r21,r6
8111a2f8:	00800084 	movi	r2,2
8111a2fc:	18802626 	beq	r3,r2,8111a398 <__mulsf3+0x1d0>
8111a300:	008000c4 	movi	r2,3
8111a304:	1880ab26 	beq	r3,r2,8111a5b4 <__mulsf3+0x3ec>
8111a308:	00800044 	movi	r2,1
8111a30c:	1880a21e 	bne	r3,r2,8111a598 <__mulsf3+0x3d0>
8111a310:	a829883a 	mov	r20,r21
8111a314:	0007883a 	mov	r3,zero
8111a318:	0009883a 	mov	r4,zero
8111a31c:	18803fcc 	andi	r2,r3,255
8111a320:	100695fa 	slli	r3,r2,23
8111a324:	a0803fcc 	andi	r2,r20,255
8111a328:	100a97fa 	slli	r5,r2,31
8111a32c:	00802034 	movhi	r2,128
8111a330:	10bfffc4 	addi	r2,r2,-1
8111a334:	2084703a 	and	r2,r4,r2
8111a338:	10c4b03a 	or	r2,r2,r3
8111a33c:	1144b03a 	or	r2,r2,r5
8111a340:	dfc00a17 	ldw	ra,40(sp)
8111a344:	df000917 	ldw	fp,36(sp)
8111a348:	ddc00817 	ldw	r23,32(sp)
8111a34c:	dd800717 	ldw	r22,28(sp)
8111a350:	dd400617 	ldw	r21,24(sp)
8111a354:	dd000517 	ldw	r20,20(sp)
8111a358:	dcc00417 	ldw	r19,16(sp)
8111a35c:	dc800317 	ldw	r18,12(sp)
8111a360:	dc400217 	ldw	r17,8(sp)
8111a364:	dc000117 	ldw	r16,4(sp)
8111a368:	dec00b04 	addi	sp,sp,44
8111a36c:	f800283a 	ret
8111a370:	90000d1e 	bne	r18,zero,8111a3a8 <__mulsf3+0x1e0>
8111a374:	04400104 	movi	r17,4
8111a378:	05c00044 	movi	r23,1
8111a37c:	003faf06 	br	8111a23c <__reset+0xfb0fa23c>
8111a380:	9806c03a 	cmpne	r3,r19,zero
8111a384:	18c00084 	addi	r3,r3,2
8111a388:	003fba06 	br	8111a274 <__reset+0xfb0fa274>
8111a38c:	9800141e 	bne	r19,zero,8111a3e0 <__mulsf3+0x218>
8111a390:	00c00044 	movi	r3,1
8111a394:	003fb706 	br	8111a274 <__reset+0xfb0fa274>
8111a398:	a829883a 	mov	r20,r21
8111a39c:	00ffffc4 	movi	r3,-1
8111a3a0:	0009883a 	mov	r4,zero
8111a3a4:	003fdd06 	br	8111a31c <__reset+0xfb0fa31c>
8111a3a8:	9009883a 	mov	r4,r18
8111a3ac:	d9400015 	stw	r5,0(sp)
8111a3b0:	111b1d00 	call	8111b1d0 <__clzsi2>
8111a3b4:	10fffec4 	addi	r3,r2,-5
8111a3b8:	10801d84 	addi	r2,r2,118
8111a3bc:	90e4983a 	sll	r18,r18,r3
8111a3c0:	00a1c83a 	sub	r16,zero,r2
8111a3c4:	0023883a 	mov	r17,zero
8111a3c8:	002f883a 	mov	r23,zero
8111a3cc:	d9400017 	ldw	r5,0(sp)
8111a3d0:	003f9a06 	br	8111a23c <__reset+0xfb0fa23c>
8111a3d4:	04400304 	movi	r17,12
8111a3d8:	05c000c4 	movi	r23,3
8111a3dc:	003f9706 	br	8111a23c <__reset+0xfb0fa23c>
8111a3e0:	9809883a 	mov	r4,r19
8111a3e4:	d9800015 	stw	r6,0(sp)
8111a3e8:	111b1d00 	call	8111b1d0 <__clzsi2>
8111a3ec:	10fffec4 	addi	r3,r2,-5
8111a3f0:	10801d84 	addi	r2,r2,118
8111a3f4:	98e6983a 	sll	r19,r19,r3
8111a3f8:	0085c83a 	sub	r2,zero,r2
8111a3fc:	0007883a 	mov	r3,zero
8111a400:	d9800017 	ldw	r6,0(sp)
8111a404:	003f9b06 	br	8111a274 <__reset+0xfb0fa274>
8111a408:	01002034 	movhi	r4,128
8111a40c:	0029883a 	mov	r20,zero
8111a410:	213fffc4 	addi	r4,r4,-1
8111a414:	00ffffc4 	movi	r3,-1
8111a418:	003fc006 	br	8111a31c <__reset+0xfb0fa31c>
8111a41c:	9027883a 	mov	r19,r18
8111a420:	b807883a 	mov	r3,r23
8111a424:	003fb406 	br	8111a2f8 <__reset+0xfb0fa2f8>
8111a428:	9027883a 	mov	r19,r18
8111a42c:	e02b883a 	mov	r21,fp
8111a430:	b807883a 	mov	r3,r23
8111a434:	003fb006 	br	8111a2f8 <__reset+0xfb0fa2f8>
8111a438:	9004d43a 	srli	r2,r18,16
8111a43c:	9810d43a 	srli	r8,r19,16
8111a440:	94bfffcc 	andi	r18,r18,65535
8111a444:	993fffcc 	andi	r4,r19,65535
8111a448:	910d383a 	mul	r6,r18,r4
8111a44c:	20a7383a 	mul	r19,r4,r2
8111a450:	9225383a 	mul	r18,r18,r8
8111a454:	3006d43a 	srli	r3,r6,16
8111a458:	1211383a 	mul	r8,r2,r8
8111a45c:	94e5883a 	add	r18,r18,r19
8111a460:	1c87883a 	add	r3,r3,r18
8111a464:	1cc0022e 	bgeu	r3,r19,8111a470 <__mulsf3+0x2a8>
8111a468:	00800074 	movhi	r2,1
8111a46c:	4091883a 	add	r8,r8,r2
8111a470:	1804943a 	slli	r2,r3,16
8111a474:	31bfffcc 	andi	r6,r6,65535
8111a478:	1806d43a 	srli	r3,r3,16
8111a47c:	1185883a 	add	r2,r2,r6
8111a480:	102691ba 	slli	r19,r2,6
8111a484:	1a07883a 	add	r3,r3,r8
8111a488:	1004d6ba 	srli	r2,r2,26
8111a48c:	180891ba 	slli	r4,r3,6
8111a490:	9826c03a 	cmpne	r19,r19,zero
8111a494:	9884b03a 	or	r2,r19,r2
8111a498:	1126b03a 	or	r19,r2,r4
8111a49c:	9882002c 	andhi	r2,r19,2048
8111a4a0:	10000426 	beq	r2,zero,8111a4b4 <__mulsf3+0x2ec>
8111a4a4:	9804d07a 	srli	r2,r19,1
8111a4a8:	9900004c 	andi	r4,r19,1
8111a4ac:	3821883a 	mov	r16,r7
8111a4b0:	1126b03a 	or	r19,r2,r4
8111a4b4:	80c01fc4 	addi	r3,r16,127
8111a4b8:	00c0210e 	bge	zero,r3,8111a540 <__mulsf3+0x378>
8111a4bc:	988001cc 	andi	r2,r19,7
8111a4c0:	10000426 	beq	r2,zero,8111a4d4 <__mulsf3+0x30c>
8111a4c4:	988003cc 	andi	r2,r19,15
8111a4c8:	01000104 	movi	r4,4
8111a4cc:	11000126 	beq	r2,r4,8111a4d4 <__mulsf3+0x30c>
8111a4d0:	9927883a 	add	r19,r19,r4
8111a4d4:	9882002c 	andhi	r2,r19,2048
8111a4d8:	10000426 	beq	r2,zero,8111a4ec <__mulsf3+0x324>
8111a4dc:	00be0034 	movhi	r2,63488
8111a4e0:	10bfffc4 	addi	r2,r2,-1
8111a4e4:	80c02004 	addi	r3,r16,128
8111a4e8:	98a6703a 	and	r19,r19,r2
8111a4ec:	00803f84 	movi	r2,254
8111a4f0:	10ffa916 	blt	r2,r3,8111a398 <__reset+0xfb0fa398>
8111a4f4:	980891ba 	slli	r4,r19,6
8111a4f8:	a829883a 	mov	r20,r21
8111a4fc:	2008d27a 	srli	r4,r4,9
8111a500:	003f8606 	br	8111a31c <__reset+0xfb0fa31c>
8111a504:	9080102c 	andhi	r2,r18,64
8111a508:	10000826 	beq	r2,zero,8111a52c <__mulsf3+0x364>
8111a50c:	9880102c 	andhi	r2,r19,64
8111a510:	1000061e 	bne	r2,zero,8111a52c <__mulsf3+0x364>
8111a514:	00802034 	movhi	r2,128
8111a518:	99001034 	orhi	r4,r19,64
8111a51c:	10bfffc4 	addi	r2,r2,-1
8111a520:	b029883a 	mov	r20,r22
8111a524:	2088703a 	and	r4,r4,r2
8111a528:	003fba06 	br	8111a414 <__reset+0xfb0fa414>
8111a52c:	00802034 	movhi	r2,128
8111a530:	91001034 	orhi	r4,r18,64
8111a534:	10bfffc4 	addi	r2,r2,-1
8111a538:	2088703a 	and	r4,r4,r2
8111a53c:	003fb506 	br	8111a414 <__reset+0xfb0fa414>
8111a540:	00800044 	movi	r2,1
8111a544:	10c7c83a 	sub	r3,r2,r3
8111a548:	008006c4 	movi	r2,27
8111a54c:	10ff7016 	blt	r2,r3,8111a310 <__reset+0xfb0fa310>
8111a550:	00800804 	movi	r2,32
8111a554:	10c5c83a 	sub	r2,r2,r3
8111a558:	9884983a 	sll	r2,r19,r2
8111a55c:	98c6d83a 	srl	r3,r19,r3
8111a560:	1004c03a 	cmpne	r2,r2,zero
8111a564:	1884b03a 	or	r2,r3,r2
8111a568:	10c001cc 	andi	r3,r2,7
8111a56c:	18000426 	beq	r3,zero,8111a580 <__mulsf3+0x3b8>
8111a570:	10c003cc 	andi	r3,r2,15
8111a574:	01000104 	movi	r4,4
8111a578:	19000126 	beq	r3,r4,8111a580 <__mulsf3+0x3b8>
8111a57c:	1105883a 	add	r2,r2,r4
8111a580:	10c1002c 	andhi	r3,r2,1024
8111a584:	18000626 	beq	r3,zero,8111a5a0 <__mulsf3+0x3d8>
8111a588:	a829883a 	mov	r20,r21
8111a58c:	00c00044 	movi	r3,1
8111a590:	0009883a 	mov	r4,zero
8111a594:	003f6106 	br	8111a31c <__reset+0xfb0fa31c>
8111a598:	3821883a 	mov	r16,r7
8111a59c:	003fc506 	br	8111a4b4 <__reset+0xfb0fa4b4>
8111a5a0:	100491ba 	slli	r2,r2,6
8111a5a4:	a829883a 	mov	r20,r21
8111a5a8:	0007883a 	mov	r3,zero
8111a5ac:	1008d27a 	srli	r4,r2,9
8111a5b0:	003f5a06 	br	8111a31c <__reset+0xfb0fa31c>
8111a5b4:	00802034 	movhi	r2,128
8111a5b8:	99001034 	orhi	r4,r19,64
8111a5bc:	10bfffc4 	addi	r2,r2,-1
8111a5c0:	a829883a 	mov	r20,r21
8111a5c4:	2088703a 	and	r4,r4,r2
8111a5c8:	003f9206 	br	8111a414 <__reset+0xfb0fa414>

8111a5cc <__floatsisf>:
8111a5cc:	defffd04 	addi	sp,sp,-12
8111a5d0:	de00012e 	bgeu	sp,et,8111a5d8 <__floatsisf+0xc>
8111a5d4:	003b68fa 	trap	3
8111a5d8:	dfc00215 	stw	ra,8(sp)
8111a5dc:	dc400115 	stw	r17,4(sp)
8111a5e0:	dc000015 	stw	r16,0(sp)
8111a5e4:	20003526 	beq	r4,zero,8111a6bc <__floatsisf+0xf0>
8111a5e8:	2021883a 	mov	r16,r4
8111a5ec:	2022d7fa 	srli	r17,r4,31
8111a5f0:	20003616 	blt	r4,zero,8111a6cc <__floatsisf+0x100>
8111a5f4:	8009883a 	mov	r4,r16
8111a5f8:	111b1d00 	call	8111b1d0 <__clzsi2>
8111a5fc:	00c02784 	movi	r3,158
8111a600:	1887c83a 	sub	r3,r3,r2
8111a604:	01002584 	movi	r4,150
8111a608:	20c01416 	blt	r4,r3,8111a65c <__floatsisf+0x90>
8111a60c:	20c9c83a 	sub	r4,r4,r3
8111a610:	8120983a 	sll	r16,r16,r4
8111a614:	00802034 	movhi	r2,128
8111a618:	10bfffc4 	addi	r2,r2,-1
8111a61c:	8809883a 	mov	r4,r17
8111a620:	80a0703a 	and	r16,r16,r2
8111a624:	18803fcc 	andi	r2,r3,255
8111a628:	100695fa 	slli	r3,r2,23
8111a62c:	20803fcc 	andi	r2,r4,255
8111a630:	100897fa 	slli	r4,r2,31
8111a634:	00802034 	movhi	r2,128
8111a638:	10bfffc4 	addi	r2,r2,-1
8111a63c:	8084703a 	and	r2,r16,r2
8111a640:	10c4b03a 	or	r2,r2,r3
8111a644:	1104b03a 	or	r2,r2,r4
8111a648:	dfc00217 	ldw	ra,8(sp)
8111a64c:	dc400117 	ldw	r17,4(sp)
8111a650:	dc000017 	ldw	r16,0(sp)
8111a654:	dec00304 	addi	sp,sp,12
8111a658:	f800283a 	ret
8111a65c:	01002644 	movi	r4,153
8111a660:	20c01c16 	blt	r4,r3,8111a6d4 <__floatsisf+0x108>
8111a664:	20c9c83a 	sub	r4,r4,r3
8111a668:	8120983a 	sll	r16,r16,r4
8111a66c:	013f0034 	movhi	r4,64512
8111a670:	213fffc4 	addi	r4,r4,-1
8111a674:	814001cc 	andi	r5,r16,7
8111a678:	8108703a 	and	r4,r16,r4
8111a67c:	28000426 	beq	r5,zero,8111a690 <__floatsisf+0xc4>
8111a680:	840003cc 	andi	r16,r16,15
8111a684:	01400104 	movi	r5,4
8111a688:	81400126 	beq	r16,r5,8111a690 <__floatsisf+0xc4>
8111a68c:	2149883a 	add	r4,r4,r5
8111a690:	2141002c 	andhi	r5,r4,1024
8111a694:	28000526 	beq	r5,zero,8111a6ac <__floatsisf+0xe0>
8111a698:	00c027c4 	movi	r3,159
8111a69c:	1887c83a 	sub	r3,r3,r2
8111a6a0:	00bf0034 	movhi	r2,64512
8111a6a4:	10bfffc4 	addi	r2,r2,-1
8111a6a8:	2088703a 	and	r4,r4,r2
8111a6ac:	202091ba 	slli	r16,r4,6
8111a6b0:	8809883a 	mov	r4,r17
8111a6b4:	8020d27a 	srli	r16,r16,9
8111a6b8:	003fda06 	br	8111a624 <__reset+0xfb0fa624>
8111a6bc:	0009883a 	mov	r4,zero
8111a6c0:	0007883a 	mov	r3,zero
8111a6c4:	0021883a 	mov	r16,zero
8111a6c8:	003fd606 	br	8111a624 <__reset+0xfb0fa624>
8111a6cc:	0121c83a 	sub	r16,zero,r4
8111a6d0:	003fc806 	br	8111a5f4 <__reset+0xfb0fa5f4>
8111a6d4:	01002e44 	movi	r4,185
8111a6d8:	20c9c83a 	sub	r4,r4,r3
8111a6dc:	01400144 	movi	r5,5
8111a6e0:	8108983a 	sll	r4,r16,r4
8111a6e4:	288bc83a 	sub	r5,r5,r2
8111a6e8:	8160d83a 	srl	r16,r16,r5
8111a6ec:	2008c03a 	cmpne	r4,r4,zero
8111a6f0:	8120b03a 	or	r16,r16,r4
8111a6f4:	003fdd06 	br	8111a66c <__reset+0xfb0fa66c>

8111a6f8 <__floatunsisf>:
8111a6f8:	defffe04 	addi	sp,sp,-8
8111a6fc:	de00012e 	bgeu	sp,et,8111a704 <__floatunsisf+0xc>
8111a700:	003b68fa 	trap	3
8111a704:	dfc00115 	stw	ra,4(sp)
8111a708:	dc000015 	stw	r16,0(sp)
8111a70c:	20002c26 	beq	r4,zero,8111a7c0 <__floatunsisf+0xc8>
8111a710:	2021883a 	mov	r16,r4
8111a714:	111b1d00 	call	8111b1d0 <__clzsi2>
8111a718:	00c02784 	movi	r3,158
8111a71c:	1887c83a 	sub	r3,r3,r2
8111a720:	01002584 	movi	r4,150
8111a724:	20c00f16 	blt	r4,r3,8111a764 <__floatunsisf+0x6c>
8111a728:	20c9c83a 	sub	r4,r4,r3
8111a72c:	8108983a 	sll	r4,r16,r4
8111a730:	00802034 	movhi	r2,128
8111a734:	10bfffc4 	addi	r2,r2,-1
8111a738:	2088703a 	and	r4,r4,r2
8111a73c:	18803fcc 	andi	r2,r3,255
8111a740:	100695fa 	slli	r3,r2,23
8111a744:	00802034 	movhi	r2,128
8111a748:	10bfffc4 	addi	r2,r2,-1
8111a74c:	2084703a 	and	r2,r4,r2
8111a750:	10c4b03a 	or	r2,r2,r3
8111a754:	dfc00117 	ldw	ra,4(sp)
8111a758:	dc000017 	ldw	r16,0(sp)
8111a75c:	dec00204 	addi	sp,sp,8
8111a760:	f800283a 	ret
8111a764:	01002644 	movi	r4,153
8111a768:	20c01816 	blt	r4,r3,8111a7cc <__floatunsisf+0xd4>
8111a76c:	20c9c83a 	sub	r4,r4,r3
8111a770:	8108983a 	sll	r4,r16,r4
8111a774:	017f0034 	movhi	r5,64512
8111a778:	297fffc4 	addi	r5,r5,-1
8111a77c:	218001cc 	andi	r6,r4,7
8111a780:	214a703a 	and	r5,r4,r5
8111a784:	30000426 	beq	r6,zero,8111a798 <__floatunsisf+0xa0>
8111a788:	210003cc 	andi	r4,r4,15
8111a78c:	01800104 	movi	r6,4
8111a790:	21800126 	beq	r4,r6,8111a798 <__floatunsisf+0xa0>
8111a794:	298b883a 	add	r5,r5,r6
8111a798:	2901002c 	andhi	r4,r5,1024
8111a79c:	20000526 	beq	r4,zero,8111a7b4 <__floatunsisf+0xbc>
8111a7a0:	00c027c4 	movi	r3,159
8111a7a4:	1887c83a 	sub	r3,r3,r2
8111a7a8:	00bf0034 	movhi	r2,64512
8111a7ac:	10bfffc4 	addi	r2,r2,-1
8111a7b0:	288a703a 	and	r5,r5,r2
8111a7b4:	280891ba 	slli	r4,r5,6
8111a7b8:	2008d27a 	srli	r4,r4,9
8111a7bc:	003fdf06 	br	8111a73c <__reset+0xfb0fa73c>
8111a7c0:	0007883a 	mov	r3,zero
8111a7c4:	0009883a 	mov	r4,zero
8111a7c8:	003fdc06 	br	8111a73c <__reset+0xfb0fa73c>
8111a7cc:	01402e44 	movi	r5,185
8111a7d0:	28cbc83a 	sub	r5,r5,r3
8111a7d4:	01000144 	movi	r4,5
8111a7d8:	2089c83a 	sub	r4,r4,r2
8111a7dc:	814a983a 	sll	r5,r16,r5
8111a7e0:	8108d83a 	srl	r4,r16,r4
8111a7e4:	2820c03a 	cmpne	r16,r5,zero
8111a7e8:	2408b03a 	or	r4,r4,r16
8111a7ec:	003fe106 	br	8111a774 <__reset+0xfb0fa774>

8111a7f0 <__muldf3>:
8111a7f0:	defff304 	addi	sp,sp,-52
8111a7f4:	2804d53a 	srli	r2,r5,20
8111a7f8:	de00012e 	bgeu	sp,et,8111a800 <__muldf3+0x10>
8111a7fc:	003b68fa 	trap	3
8111a800:	dd800915 	stw	r22,36(sp)
8111a804:	282cd7fa 	srli	r22,r5,31
8111a808:	dc000315 	stw	r16,12(sp)
8111a80c:	04000434 	movhi	r16,16
8111a810:	dd400815 	stw	r21,32(sp)
8111a814:	dc800515 	stw	r18,20(sp)
8111a818:	843fffc4 	addi	r16,r16,-1
8111a81c:	dfc00c15 	stw	ra,48(sp)
8111a820:	df000b15 	stw	fp,44(sp)
8111a824:	ddc00a15 	stw	r23,40(sp)
8111a828:	dd000715 	stw	r20,28(sp)
8111a82c:	dcc00615 	stw	r19,24(sp)
8111a830:	dc400415 	stw	r17,16(sp)
8111a834:	1481ffcc 	andi	r18,r2,2047
8111a838:	2c20703a 	and	r16,r5,r16
8111a83c:	b02b883a 	mov	r21,r22
8111a840:	b2403fcc 	andi	r9,r22,255
8111a844:	90006026 	beq	r18,zero,8111a9c8 <__muldf3+0x1d8>
8111a848:	0081ffc4 	movi	r2,2047
8111a84c:	2029883a 	mov	r20,r4
8111a850:	90803626 	beq	r18,r2,8111a92c <__muldf3+0x13c>
8111a854:	80800434 	orhi	r2,r16,16
8111a858:	100490fa 	slli	r2,r2,3
8111a85c:	2020d77a 	srli	r16,r4,29
8111a860:	202890fa 	slli	r20,r4,3
8111a864:	94bf0044 	addi	r18,r18,-1023
8111a868:	80a0b03a 	or	r16,r16,r2
8111a86c:	0027883a 	mov	r19,zero
8111a870:	0039883a 	mov	fp,zero
8111a874:	3804d53a 	srli	r2,r7,20
8111a878:	382ed7fa 	srli	r23,r7,31
8111a87c:	04400434 	movhi	r17,16
8111a880:	8c7fffc4 	addi	r17,r17,-1
8111a884:	1081ffcc 	andi	r2,r2,2047
8111a888:	3011883a 	mov	r8,r6
8111a88c:	3c62703a 	and	r17,r7,r17
8111a890:	ba803fcc 	andi	r10,r23,255
8111a894:	10006d26 	beq	r2,zero,8111aa4c <__muldf3+0x25c>
8111a898:	00c1ffc4 	movi	r3,2047
8111a89c:	10c06526 	beq	r2,r3,8111aa34 <__muldf3+0x244>
8111a8a0:	88c00434 	orhi	r3,r17,16
8111a8a4:	180690fa 	slli	r3,r3,3
8111a8a8:	3022d77a 	srli	r17,r6,29
8111a8ac:	301090fa 	slli	r8,r6,3
8111a8b0:	10bf0044 	addi	r2,r2,-1023
8111a8b4:	88e2b03a 	or	r17,r17,r3
8111a8b8:	000b883a 	mov	r5,zero
8111a8bc:	9085883a 	add	r2,r18,r2
8111a8c0:	2cc8b03a 	or	r4,r5,r19
8111a8c4:	00c003c4 	movi	r3,15
8111a8c8:	bdacf03a 	xor	r22,r23,r22
8111a8cc:	12c00044 	addi	r11,r2,1
8111a8d0:	19009936 	bltu	r3,r4,8111ab38 <__muldf3+0x348>
8111a8d4:	200890ba 	slli	r4,r4,2
8111a8d8:	00e044b4 	movhi	r3,33042
8111a8dc:	18ea3b04 	addi	r3,r3,-22292
8111a8e0:	20c9883a 	add	r4,r4,r3
8111a8e4:	20c00017 	ldw	r3,0(r4)
8111a8e8:	1800683a 	jmp	r3
8111a8ec:	8111ab38 	rdprs	r4,r16,18092
8111a8f0:	8111a94c 	andi	r4,r16,18085
8111a8f4:	8111a94c 	andi	r4,r16,18085
8111a8f8:	8111a948 	cmpgei	r4,r16,18085
8111a8fc:	8111ab14 	ori	r4,r16,18092
8111a900:	8111ab14 	ori	r4,r16,18092
8111a904:	8111aafc 	xorhi	r4,r16,18091
8111a908:	8111a948 	cmpgei	r4,r16,18085
8111a90c:	8111ab14 	ori	r4,r16,18092
8111a910:	8111aafc 	xorhi	r4,r16,18091
8111a914:	8111ab14 	ori	r4,r16,18092
8111a918:	8111a948 	cmpgei	r4,r16,18085
8111a91c:	8111ab24 	muli	r4,r16,18092
8111a920:	8111ab24 	muli	r4,r16,18092
8111a924:	8111ab24 	muli	r4,r16,18092
8111a928:	8111ad40 	call	88111ad4 <__reset+0x20f1ad4>
8111a92c:	2404b03a 	or	r2,r4,r16
8111a930:	10006f1e 	bne	r2,zero,8111aaf0 <__muldf3+0x300>
8111a934:	04c00204 	movi	r19,8
8111a938:	0021883a 	mov	r16,zero
8111a93c:	0029883a 	mov	r20,zero
8111a940:	07000084 	movi	fp,2
8111a944:	003fcb06 	br	8111a874 <__reset+0xfb0fa874>
8111a948:	502d883a 	mov	r22,r10
8111a94c:	00800084 	movi	r2,2
8111a950:	28805726 	beq	r5,r2,8111aab0 <__muldf3+0x2c0>
8111a954:	008000c4 	movi	r2,3
8111a958:	28816626 	beq	r5,r2,8111aef4 <__muldf3+0x704>
8111a95c:	00800044 	movi	r2,1
8111a960:	2881411e 	bne	r5,r2,8111ae68 <__muldf3+0x678>
8111a964:	b02b883a 	mov	r21,r22
8111a968:	0005883a 	mov	r2,zero
8111a96c:	000b883a 	mov	r5,zero
8111a970:	0029883a 	mov	r20,zero
8111a974:	1004953a 	slli	r2,r2,20
8111a978:	a8c03fcc 	andi	r3,r21,255
8111a97c:	04400434 	movhi	r17,16
8111a980:	8c7fffc4 	addi	r17,r17,-1
8111a984:	180697fa 	slli	r3,r3,31
8111a988:	2c4a703a 	and	r5,r5,r17
8111a98c:	288ab03a 	or	r5,r5,r2
8111a990:	28c6b03a 	or	r3,r5,r3
8111a994:	a005883a 	mov	r2,r20
8111a998:	dfc00c17 	ldw	ra,48(sp)
8111a99c:	df000b17 	ldw	fp,44(sp)
8111a9a0:	ddc00a17 	ldw	r23,40(sp)
8111a9a4:	dd800917 	ldw	r22,36(sp)
8111a9a8:	dd400817 	ldw	r21,32(sp)
8111a9ac:	dd000717 	ldw	r20,28(sp)
8111a9b0:	dcc00617 	ldw	r19,24(sp)
8111a9b4:	dc800517 	ldw	r18,20(sp)
8111a9b8:	dc400417 	ldw	r17,16(sp)
8111a9bc:	dc000317 	ldw	r16,12(sp)
8111a9c0:	dec00d04 	addi	sp,sp,52
8111a9c4:	f800283a 	ret
8111a9c8:	2404b03a 	or	r2,r4,r16
8111a9cc:	2027883a 	mov	r19,r4
8111a9d0:	10004226 	beq	r2,zero,8111aadc <__muldf3+0x2ec>
8111a9d4:	8000fc26 	beq	r16,zero,8111adc8 <__muldf3+0x5d8>
8111a9d8:	8009883a 	mov	r4,r16
8111a9dc:	d9800215 	stw	r6,8(sp)
8111a9e0:	d9c00015 	stw	r7,0(sp)
8111a9e4:	da400115 	stw	r9,4(sp)
8111a9e8:	111b1d00 	call	8111b1d0 <__clzsi2>
8111a9ec:	d9800217 	ldw	r6,8(sp)
8111a9f0:	d9c00017 	ldw	r7,0(sp)
8111a9f4:	da400117 	ldw	r9,4(sp)
8111a9f8:	113ffd44 	addi	r4,r2,-11
8111a9fc:	00c00704 	movi	r3,28
8111aa00:	1900ed16 	blt	r3,r4,8111adb8 <__muldf3+0x5c8>
8111aa04:	00c00744 	movi	r3,29
8111aa08:	147ffe04 	addi	r17,r2,-8
8111aa0c:	1907c83a 	sub	r3,r3,r4
8111aa10:	8460983a 	sll	r16,r16,r17
8111aa14:	98c6d83a 	srl	r3,r19,r3
8111aa18:	9c68983a 	sll	r20,r19,r17
8111aa1c:	1c20b03a 	or	r16,r3,r16
8111aa20:	1080fcc4 	addi	r2,r2,1011
8111aa24:	00a5c83a 	sub	r18,zero,r2
8111aa28:	0027883a 	mov	r19,zero
8111aa2c:	0039883a 	mov	fp,zero
8111aa30:	003f9006 	br	8111a874 <__reset+0xfb0fa874>
8111aa34:	3446b03a 	or	r3,r6,r17
8111aa38:	1800261e 	bne	r3,zero,8111aad4 <__muldf3+0x2e4>
8111aa3c:	0023883a 	mov	r17,zero
8111aa40:	0011883a 	mov	r8,zero
8111aa44:	01400084 	movi	r5,2
8111aa48:	003f9c06 	br	8111a8bc <__reset+0xfb0fa8bc>
8111aa4c:	3446b03a 	or	r3,r6,r17
8111aa50:	18001c26 	beq	r3,zero,8111aac4 <__muldf3+0x2d4>
8111aa54:	8800ce26 	beq	r17,zero,8111ad90 <__muldf3+0x5a0>
8111aa58:	8809883a 	mov	r4,r17
8111aa5c:	d9800215 	stw	r6,8(sp)
8111aa60:	da400115 	stw	r9,4(sp)
8111aa64:	da800015 	stw	r10,0(sp)
8111aa68:	111b1d00 	call	8111b1d0 <__clzsi2>
8111aa6c:	d9800217 	ldw	r6,8(sp)
8111aa70:	da400117 	ldw	r9,4(sp)
8111aa74:	da800017 	ldw	r10,0(sp)
8111aa78:	113ffd44 	addi	r4,r2,-11
8111aa7c:	00c00704 	movi	r3,28
8111aa80:	1900bf16 	blt	r3,r4,8111ad80 <__muldf3+0x590>
8111aa84:	00c00744 	movi	r3,29
8111aa88:	123ffe04 	addi	r8,r2,-8
8111aa8c:	1907c83a 	sub	r3,r3,r4
8111aa90:	8a22983a 	sll	r17,r17,r8
8111aa94:	30c6d83a 	srl	r3,r6,r3
8111aa98:	3210983a 	sll	r8,r6,r8
8111aa9c:	1c62b03a 	or	r17,r3,r17
8111aaa0:	1080fcc4 	addi	r2,r2,1011
8111aaa4:	0085c83a 	sub	r2,zero,r2
8111aaa8:	000b883a 	mov	r5,zero
8111aaac:	003f8306 	br	8111a8bc <__reset+0xfb0fa8bc>
8111aab0:	b02b883a 	mov	r21,r22
8111aab4:	0081ffc4 	movi	r2,2047
8111aab8:	000b883a 	mov	r5,zero
8111aabc:	0029883a 	mov	r20,zero
8111aac0:	003fac06 	br	8111a974 <__reset+0xfb0fa974>
8111aac4:	0023883a 	mov	r17,zero
8111aac8:	0011883a 	mov	r8,zero
8111aacc:	01400044 	movi	r5,1
8111aad0:	003f7a06 	br	8111a8bc <__reset+0xfb0fa8bc>
8111aad4:	014000c4 	movi	r5,3
8111aad8:	003f7806 	br	8111a8bc <__reset+0xfb0fa8bc>
8111aadc:	04c00104 	movi	r19,4
8111aae0:	0021883a 	mov	r16,zero
8111aae4:	0029883a 	mov	r20,zero
8111aae8:	07000044 	movi	fp,1
8111aaec:	003f6106 	br	8111a874 <__reset+0xfb0fa874>
8111aaf0:	04c00304 	movi	r19,12
8111aaf4:	070000c4 	movi	fp,3
8111aaf8:	003f5e06 	br	8111a874 <__reset+0xfb0fa874>
8111aafc:	01400434 	movhi	r5,16
8111ab00:	002b883a 	mov	r21,zero
8111ab04:	297fffc4 	addi	r5,r5,-1
8111ab08:	053fffc4 	movi	r20,-1
8111ab0c:	0081ffc4 	movi	r2,2047
8111ab10:	003f9806 	br	8111a974 <__reset+0xfb0fa974>
8111ab14:	8023883a 	mov	r17,r16
8111ab18:	a011883a 	mov	r8,r20
8111ab1c:	e00b883a 	mov	r5,fp
8111ab20:	003f8a06 	br	8111a94c <__reset+0xfb0fa94c>
8111ab24:	8023883a 	mov	r17,r16
8111ab28:	a011883a 	mov	r8,r20
8111ab2c:	482d883a 	mov	r22,r9
8111ab30:	e00b883a 	mov	r5,fp
8111ab34:	003f8506 	br	8111a94c <__reset+0xfb0fa94c>
8111ab38:	a00ad43a 	srli	r5,r20,16
8111ab3c:	401ad43a 	srli	r13,r8,16
8111ab40:	a53fffcc 	andi	r20,r20,65535
8111ab44:	423fffcc 	andi	r8,r8,65535
8111ab48:	4519383a 	mul	r12,r8,r20
8111ab4c:	4147383a 	mul	r3,r8,r5
8111ab50:	6d09383a 	mul	r4,r13,r20
8111ab54:	600cd43a 	srli	r6,r12,16
8111ab58:	2b5d383a 	mul	r14,r5,r13
8111ab5c:	20c9883a 	add	r4,r4,r3
8111ab60:	310d883a 	add	r6,r6,r4
8111ab64:	30c0022e 	bgeu	r6,r3,8111ab70 <__muldf3+0x380>
8111ab68:	00c00074 	movhi	r3,1
8111ab6c:	70dd883a 	add	r14,r14,r3
8111ab70:	8826d43a 	srli	r19,r17,16
8111ab74:	8bffffcc 	andi	r15,r17,65535
8111ab78:	7d23383a 	mul	r17,r15,r20
8111ab7c:	7949383a 	mul	r4,r15,r5
8111ab80:	9d29383a 	mul	r20,r19,r20
8111ab84:	8814d43a 	srli	r10,r17,16
8111ab88:	3012943a 	slli	r9,r6,16
8111ab8c:	a129883a 	add	r20,r20,r4
8111ab90:	633fffcc 	andi	r12,r12,65535
8111ab94:	5515883a 	add	r10,r10,r20
8111ab98:	3006d43a 	srli	r3,r6,16
8111ab9c:	4b13883a 	add	r9,r9,r12
8111aba0:	2ccb383a 	mul	r5,r5,r19
8111aba4:	5100022e 	bgeu	r10,r4,8111abb0 <__muldf3+0x3c0>
8111aba8:	01000074 	movhi	r4,1
8111abac:	290b883a 	add	r5,r5,r4
8111abb0:	802ad43a 	srli	r21,r16,16
8111abb4:	843fffcc 	andi	r16,r16,65535
8111abb8:	440d383a 	mul	r6,r8,r16
8111abbc:	4565383a 	mul	r18,r8,r21
8111abc0:	8349383a 	mul	r4,r16,r13
8111abc4:	500e943a 	slli	r7,r10,16
8111abc8:	3010d43a 	srli	r8,r6,16
8111abcc:	5028d43a 	srli	r20,r10,16
8111abd0:	2489883a 	add	r4,r4,r18
8111abd4:	8abfffcc 	andi	r10,r17,65535
8111abd8:	3a95883a 	add	r10,r7,r10
8111abdc:	4119883a 	add	r12,r8,r4
8111abe0:	a169883a 	add	r20,r20,r5
8111abe4:	1a87883a 	add	r3,r3,r10
8111abe8:	6d5b383a 	mul	r13,r13,r21
8111abec:	6480022e 	bgeu	r12,r18,8111abf8 <__muldf3+0x408>
8111abf0:	01000074 	movhi	r4,1
8111abf4:	691b883a 	add	r13,r13,r4
8111abf8:	7c25383a 	mul	r18,r15,r16
8111abfc:	7d4b383a 	mul	r5,r15,r21
8111ac00:	84cf383a 	mul	r7,r16,r19
8111ac04:	901ed43a 	srli	r15,r18,16
8111ac08:	6008d43a 	srli	r4,r12,16
8111ac0c:	6010943a 	slli	r8,r12,16
8111ac10:	394f883a 	add	r7,r7,r5
8111ac14:	333fffcc 	andi	r12,r6,65535
8111ac18:	79df883a 	add	r15,r15,r7
8111ac1c:	235b883a 	add	r13,r4,r13
8111ac20:	9d63383a 	mul	r17,r19,r21
8111ac24:	4309883a 	add	r4,r8,r12
8111ac28:	7940022e 	bgeu	r15,r5,8111ac34 <__muldf3+0x444>
8111ac2c:	01400074 	movhi	r5,1
8111ac30:	8963883a 	add	r17,r17,r5
8111ac34:	780a943a 	slli	r5,r15,16
8111ac38:	91bfffcc 	andi	r6,r18,65535
8111ac3c:	70c7883a 	add	r3,r14,r3
8111ac40:	298d883a 	add	r6,r5,r6
8111ac44:	1a8f803a 	cmpltu	r7,r3,r10
8111ac48:	350b883a 	add	r5,r6,r20
8111ac4c:	20c7883a 	add	r3,r4,r3
8111ac50:	3955883a 	add	r10,r7,r5
8111ac54:	1909803a 	cmpltu	r4,r3,r4
8111ac58:	6a91883a 	add	r8,r13,r10
8111ac5c:	780cd43a 	srli	r6,r15,16
8111ac60:	2219883a 	add	r12,r4,r8
8111ac64:	2d0b803a 	cmpltu	r5,r5,r20
8111ac68:	51cf803a 	cmpltu	r7,r10,r7
8111ac6c:	29ceb03a 	or	r7,r5,r7
8111ac70:	4351803a 	cmpltu	r8,r8,r13
8111ac74:	610b803a 	cmpltu	r5,r12,r4
8111ac78:	4148b03a 	or	r4,r8,r5
8111ac7c:	398f883a 	add	r7,r7,r6
8111ac80:	3909883a 	add	r4,r7,r4
8111ac84:	1810927a 	slli	r8,r3,9
8111ac88:	2449883a 	add	r4,r4,r17
8111ac8c:	2008927a 	slli	r4,r4,9
8111ac90:	6022d5fa 	srli	r17,r12,23
8111ac94:	1806d5fa 	srli	r3,r3,23
8111ac98:	4252b03a 	or	r9,r8,r9
8111ac9c:	600a927a 	slli	r5,r12,9
8111aca0:	4810c03a 	cmpne	r8,r9,zero
8111aca4:	2462b03a 	or	r17,r4,r17
8111aca8:	40c6b03a 	or	r3,r8,r3
8111acac:	8900402c 	andhi	r4,r17,256
8111acb0:	1950b03a 	or	r8,r3,r5
8111acb4:	20000726 	beq	r4,zero,8111acd4 <__muldf3+0x4e4>
8111acb8:	4006d07a 	srli	r3,r8,1
8111acbc:	880497fa 	slli	r2,r17,31
8111acc0:	4200004c 	andi	r8,r8,1
8111acc4:	8822d07a 	srli	r17,r17,1
8111acc8:	1a10b03a 	or	r8,r3,r8
8111accc:	1210b03a 	or	r8,r2,r8
8111acd0:	5805883a 	mov	r2,r11
8111acd4:	1140ffc4 	addi	r5,r2,1023
8111acd8:	0140440e 	bge	zero,r5,8111adec <__muldf3+0x5fc>
8111acdc:	40c001cc 	andi	r3,r8,7
8111ace0:	18000726 	beq	r3,zero,8111ad00 <__muldf3+0x510>
8111ace4:	40c003cc 	andi	r3,r8,15
8111ace8:	01000104 	movi	r4,4
8111acec:	19000426 	beq	r3,r4,8111ad00 <__muldf3+0x510>
8111acf0:	4107883a 	add	r3,r8,r4
8111acf4:	1a11803a 	cmpltu	r8,r3,r8
8111acf8:	8a23883a 	add	r17,r17,r8
8111acfc:	1811883a 	mov	r8,r3
8111ad00:	88c0402c 	andhi	r3,r17,256
8111ad04:	18000426 	beq	r3,zero,8111ad18 <__muldf3+0x528>
8111ad08:	11410004 	addi	r5,r2,1024
8111ad0c:	00bfc034 	movhi	r2,65280
8111ad10:	10bfffc4 	addi	r2,r2,-1
8111ad14:	88a2703a 	and	r17,r17,r2
8111ad18:	0081ff84 	movi	r2,2046
8111ad1c:	117f6416 	blt	r2,r5,8111aab0 <__reset+0xfb0faab0>
8111ad20:	8828977a 	slli	r20,r17,29
8111ad24:	4010d0fa 	srli	r8,r8,3
8111ad28:	8822927a 	slli	r17,r17,9
8111ad2c:	2881ffcc 	andi	r2,r5,2047
8111ad30:	a228b03a 	or	r20,r20,r8
8111ad34:	880ad33a 	srli	r5,r17,12
8111ad38:	b02b883a 	mov	r21,r22
8111ad3c:	003f0d06 	br	8111a974 <__reset+0xfb0fa974>
8111ad40:	8080022c 	andhi	r2,r16,8
8111ad44:	10000926 	beq	r2,zero,8111ad6c <__muldf3+0x57c>
8111ad48:	8880022c 	andhi	r2,r17,8
8111ad4c:	1000071e 	bne	r2,zero,8111ad6c <__muldf3+0x57c>
8111ad50:	00800434 	movhi	r2,16
8111ad54:	89400234 	orhi	r5,r17,8
8111ad58:	10bfffc4 	addi	r2,r2,-1
8111ad5c:	b82b883a 	mov	r21,r23
8111ad60:	288a703a 	and	r5,r5,r2
8111ad64:	4029883a 	mov	r20,r8
8111ad68:	003f6806 	br	8111ab0c <__reset+0xfb0fab0c>
8111ad6c:	00800434 	movhi	r2,16
8111ad70:	81400234 	orhi	r5,r16,8
8111ad74:	10bfffc4 	addi	r2,r2,-1
8111ad78:	288a703a 	and	r5,r5,r2
8111ad7c:	003f6306 	br	8111ab0c <__reset+0xfb0fab0c>
8111ad80:	147ff604 	addi	r17,r2,-40
8111ad84:	3462983a 	sll	r17,r6,r17
8111ad88:	0011883a 	mov	r8,zero
8111ad8c:	003f4406 	br	8111aaa0 <__reset+0xfb0faaa0>
8111ad90:	3009883a 	mov	r4,r6
8111ad94:	d9800215 	stw	r6,8(sp)
8111ad98:	da400115 	stw	r9,4(sp)
8111ad9c:	da800015 	stw	r10,0(sp)
8111ada0:	111b1d00 	call	8111b1d0 <__clzsi2>
8111ada4:	10800804 	addi	r2,r2,32
8111ada8:	da800017 	ldw	r10,0(sp)
8111adac:	da400117 	ldw	r9,4(sp)
8111adb0:	d9800217 	ldw	r6,8(sp)
8111adb4:	003f3006 	br	8111aa78 <__reset+0xfb0faa78>
8111adb8:	143ff604 	addi	r16,r2,-40
8111adbc:	9c20983a 	sll	r16,r19,r16
8111adc0:	0029883a 	mov	r20,zero
8111adc4:	003f1606 	br	8111aa20 <__reset+0xfb0faa20>
8111adc8:	d9800215 	stw	r6,8(sp)
8111adcc:	d9c00015 	stw	r7,0(sp)
8111add0:	da400115 	stw	r9,4(sp)
8111add4:	111b1d00 	call	8111b1d0 <__clzsi2>
8111add8:	10800804 	addi	r2,r2,32
8111addc:	da400117 	ldw	r9,4(sp)
8111ade0:	d9c00017 	ldw	r7,0(sp)
8111ade4:	d9800217 	ldw	r6,8(sp)
8111ade8:	003f0306 	br	8111a9f8 <__reset+0xfb0fa9f8>
8111adec:	00c00044 	movi	r3,1
8111adf0:	1947c83a 	sub	r3,r3,r5
8111adf4:	00800e04 	movi	r2,56
8111adf8:	10feda16 	blt	r2,r3,8111a964 <__reset+0xfb0fa964>
8111adfc:	008007c4 	movi	r2,31
8111ae00:	10c01b16 	blt	r2,r3,8111ae70 <__muldf3+0x680>
8111ae04:	00800804 	movi	r2,32
8111ae08:	10c5c83a 	sub	r2,r2,r3
8111ae0c:	888a983a 	sll	r5,r17,r2
8111ae10:	40c8d83a 	srl	r4,r8,r3
8111ae14:	4084983a 	sll	r2,r8,r2
8111ae18:	88e2d83a 	srl	r17,r17,r3
8111ae1c:	2906b03a 	or	r3,r5,r4
8111ae20:	1004c03a 	cmpne	r2,r2,zero
8111ae24:	1886b03a 	or	r3,r3,r2
8111ae28:	188001cc 	andi	r2,r3,7
8111ae2c:	10000726 	beq	r2,zero,8111ae4c <__muldf3+0x65c>
8111ae30:	188003cc 	andi	r2,r3,15
8111ae34:	01000104 	movi	r4,4
8111ae38:	11000426 	beq	r2,r4,8111ae4c <__muldf3+0x65c>
8111ae3c:	1805883a 	mov	r2,r3
8111ae40:	10c00104 	addi	r3,r2,4
8111ae44:	1885803a 	cmpltu	r2,r3,r2
8111ae48:	88a3883a 	add	r17,r17,r2
8111ae4c:	8880202c 	andhi	r2,r17,128
8111ae50:	10001c26 	beq	r2,zero,8111aec4 <__muldf3+0x6d4>
8111ae54:	b02b883a 	mov	r21,r22
8111ae58:	00800044 	movi	r2,1
8111ae5c:	000b883a 	mov	r5,zero
8111ae60:	0029883a 	mov	r20,zero
8111ae64:	003ec306 	br	8111a974 <__reset+0xfb0fa974>
8111ae68:	5805883a 	mov	r2,r11
8111ae6c:	003f9906 	br	8111acd4 <__reset+0xfb0facd4>
8111ae70:	00bff844 	movi	r2,-31
8111ae74:	1145c83a 	sub	r2,r2,r5
8111ae78:	8888d83a 	srl	r4,r17,r2
8111ae7c:	00800804 	movi	r2,32
8111ae80:	18801a26 	beq	r3,r2,8111aeec <__muldf3+0x6fc>
8111ae84:	00801004 	movi	r2,64
8111ae88:	10c5c83a 	sub	r2,r2,r3
8111ae8c:	8884983a 	sll	r2,r17,r2
8111ae90:	1204b03a 	or	r2,r2,r8
8111ae94:	1004c03a 	cmpne	r2,r2,zero
8111ae98:	2084b03a 	or	r2,r4,r2
8111ae9c:	144001cc 	andi	r17,r2,7
8111aea0:	88000d1e 	bne	r17,zero,8111aed8 <__muldf3+0x6e8>
8111aea4:	000b883a 	mov	r5,zero
8111aea8:	1028d0fa 	srli	r20,r2,3
8111aeac:	b02b883a 	mov	r21,r22
8111aeb0:	0005883a 	mov	r2,zero
8111aeb4:	a468b03a 	or	r20,r20,r17
8111aeb8:	003eae06 	br	8111a974 <__reset+0xfb0fa974>
8111aebc:	1007883a 	mov	r3,r2
8111aec0:	0023883a 	mov	r17,zero
8111aec4:	880a927a 	slli	r5,r17,9
8111aec8:	1805883a 	mov	r2,r3
8111aecc:	8822977a 	slli	r17,r17,29
8111aed0:	280ad33a 	srli	r5,r5,12
8111aed4:	003ff406 	br	8111aea8 <__reset+0xfb0faea8>
8111aed8:	10c003cc 	andi	r3,r2,15
8111aedc:	01000104 	movi	r4,4
8111aee0:	193ff626 	beq	r3,r4,8111aebc <__reset+0xfb0faebc>
8111aee4:	0023883a 	mov	r17,zero
8111aee8:	003fd506 	br	8111ae40 <__reset+0xfb0fae40>
8111aeec:	0005883a 	mov	r2,zero
8111aef0:	003fe706 	br	8111ae90 <__reset+0xfb0fae90>
8111aef4:	00800434 	movhi	r2,16
8111aef8:	89400234 	orhi	r5,r17,8
8111aefc:	10bfffc4 	addi	r2,r2,-1
8111af00:	b02b883a 	mov	r21,r22
8111af04:	288a703a 	and	r5,r5,r2
8111af08:	4029883a 	mov	r20,r8
8111af0c:	003eff06 	br	8111ab0c <__reset+0xfb0fab0c>

8111af10 <__extendsfdf2>:
8111af10:	200ad5fa 	srli	r5,r4,23
8111af14:	defffd04 	addi	sp,sp,-12
8111af18:	de00012e 	bgeu	sp,et,8111af20 <__extendsfdf2+0x10>
8111af1c:	003b68fa 	trap	3
8111af20:	29403fcc 	andi	r5,r5,255
8111af24:	dc400115 	stw	r17,4(sp)
8111af28:	29800044 	addi	r6,r5,1
8111af2c:	04402034 	movhi	r17,128
8111af30:	dc000015 	stw	r16,0(sp)
8111af34:	8c7fffc4 	addi	r17,r17,-1
8111af38:	dfc00215 	stw	ra,8(sp)
8111af3c:	31803fcc 	andi	r6,r6,255
8111af40:	00800044 	movi	r2,1
8111af44:	8922703a 	and	r17,r17,r4
8111af48:	2020d7fa 	srli	r16,r4,31
8111af4c:	1180110e 	bge	r2,r6,8111af94 <__extendsfdf2+0x84>
8111af50:	880cd0fa 	srli	r6,r17,3
8111af54:	8822977a 	slli	r17,r17,29
8111af58:	2940e004 	addi	r5,r5,896
8111af5c:	2941ffcc 	andi	r5,r5,2047
8111af60:	2804953a 	slli	r2,r5,20
8111af64:	01400434 	movhi	r5,16
8111af68:	800697fa 	slli	r3,r16,31
8111af6c:	297fffc4 	addi	r5,r5,-1
8111af70:	314a703a 	and	r5,r6,r5
8111af74:	288ab03a 	or	r5,r5,r2
8111af78:	28c6b03a 	or	r3,r5,r3
8111af7c:	8805883a 	mov	r2,r17
8111af80:	dfc00217 	ldw	ra,8(sp)
8111af84:	dc400117 	ldw	r17,4(sp)
8111af88:	dc000017 	ldw	r16,0(sp)
8111af8c:	dec00304 	addi	sp,sp,12
8111af90:	f800283a 	ret
8111af94:	2800111e 	bne	r5,zero,8111afdc <__extendsfdf2+0xcc>
8111af98:	88001c26 	beq	r17,zero,8111b00c <__extendsfdf2+0xfc>
8111af9c:	8809883a 	mov	r4,r17
8111afa0:	111b1d00 	call	8111b1d0 <__clzsi2>
8111afa4:	00c00284 	movi	r3,10
8111afa8:	18801b16 	blt	r3,r2,8111b018 <__extendsfdf2+0x108>
8111afac:	018002c4 	movi	r6,11
8111afb0:	308dc83a 	sub	r6,r6,r2
8111afb4:	11000544 	addi	r4,r2,21
8111afb8:	8986d83a 	srl	r3,r17,r6
8111afbc:	8922983a 	sll	r17,r17,r4
8111afc0:	0180e244 	movi	r6,905
8111afc4:	01400434 	movhi	r5,16
8111afc8:	3085c83a 	sub	r2,r6,r2
8111afcc:	297fffc4 	addi	r5,r5,-1
8111afd0:	194c703a 	and	r6,r3,r5
8111afd4:	1141ffcc 	andi	r5,r2,2047
8111afd8:	003fe006 	br	8111af5c <__reset+0xfb0faf5c>
8111afdc:	88000826 	beq	r17,zero,8111b000 <__extendsfdf2+0xf0>
8111afe0:	880cd0fa 	srli	r6,r17,3
8111afe4:	00800434 	movhi	r2,16
8111afe8:	10bfffc4 	addi	r2,r2,-1
8111afec:	31800234 	orhi	r6,r6,8
8111aff0:	8822977a 	slli	r17,r17,29
8111aff4:	308c703a 	and	r6,r6,r2
8111aff8:	0141ffc4 	movi	r5,2047
8111affc:	003fd706 	br	8111af5c <__reset+0xfb0faf5c>
8111b000:	0141ffc4 	movi	r5,2047
8111b004:	000d883a 	mov	r6,zero
8111b008:	003fd406 	br	8111af5c <__reset+0xfb0faf5c>
8111b00c:	000b883a 	mov	r5,zero
8111b010:	000d883a 	mov	r6,zero
8111b014:	003fd106 	br	8111af5c <__reset+0xfb0faf5c>
8111b018:	11bffd44 	addi	r6,r2,-11
8111b01c:	8986983a 	sll	r3,r17,r6
8111b020:	0023883a 	mov	r17,zero
8111b024:	003fe606 	br	8111afc0 <__reset+0xfb0fafc0>

8111b028 <__truncdfsf2>:
8111b028:	2810d53a 	srli	r8,r5,20
8111b02c:	01c00434 	movhi	r7,16
8111b030:	39ffffc4 	addi	r7,r7,-1
8111b034:	29ce703a 	and	r7,r5,r7
8111b038:	4201ffcc 	andi	r8,r8,2047
8111b03c:	380e90fa 	slli	r7,r7,3
8111b040:	200cd77a 	srli	r6,r4,29
8111b044:	42400044 	addi	r9,r8,1
8111b048:	4a41ffcc 	andi	r9,r9,2047
8111b04c:	00c00044 	movi	r3,1
8111b050:	280ad7fa 	srli	r5,r5,31
8111b054:	31ceb03a 	or	r7,r6,r7
8111b058:	200490fa 	slli	r2,r4,3
8111b05c:	1a40230e 	bge	r3,r9,8111b0ec <__truncdfsf2+0xc4>
8111b060:	40ff2004 	addi	r3,r8,-896
8111b064:	01803f84 	movi	r6,254
8111b068:	30c01516 	blt	r6,r3,8111b0c0 <__truncdfsf2+0x98>
8111b06c:	00c0380e 	bge	zero,r3,8111b150 <__truncdfsf2+0x128>
8111b070:	200c91ba 	slli	r6,r4,6
8111b074:	380e90fa 	slli	r7,r7,3
8111b078:	1004d77a 	srli	r2,r2,29
8111b07c:	300cc03a 	cmpne	r6,r6,zero
8111b080:	31ccb03a 	or	r6,r6,r7
8111b084:	308cb03a 	or	r6,r6,r2
8111b088:	308001cc 	andi	r2,r6,7
8111b08c:	10000426 	beq	r2,zero,8111b0a0 <__truncdfsf2+0x78>
8111b090:	308003cc 	andi	r2,r6,15
8111b094:	01000104 	movi	r4,4
8111b098:	11000126 	beq	r2,r4,8111b0a0 <__truncdfsf2+0x78>
8111b09c:	31800104 	addi	r6,r6,4
8111b0a0:	3081002c 	andhi	r2,r6,1024
8111b0a4:	10001626 	beq	r2,zero,8111b100 <__truncdfsf2+0xd8>
8111b0a8:	18c00044 	addi	r3,r3,1
8111b0ac:	00803fc4 	movi	r2,255
8111b0b0:	18800326 	beq	r3,r2,8111b0c0 <__truncdfsf2+0x98>
8111b0b4:	300c91ba 	slli	r6,r6,6
8111b0b8:	300cd27a 	srli	r6,r6,9
8111b0bc:	00000206 	br	8111b0c8 <__truncdfsf2+0xa0>
8111b0c0:	00ffffc4 	movi	r3,-1
8111b0c4:	000d883a 	mov	r6,zero
8111b0c8:	18c03fcc 	andi	r3,r3,255
8111b0cc:	180895fa 	slli	r4,r3,23
8111b0d0:	00c02034 	movhi	r3,128
8111b0d4:	280a97fa 	slli	r5,r5,31
8111b0d8:	18ffffc4 	addi	r3,r3,-1
8111b0dc:	30c6703a 	and	r3,r6,r3
8111b0e0:	1906b03a 	or	r3,r3,r4
8111b0e4:	1944b03a 	or	r2,r3,r5
8111b0e8:	f800283a 	ret
8111b0ec:	40000b1e 	bne	r8,zero,8111b11c <__truncdfsf2+0xf4>
8111b0f0:	388cb03a 	or	r6,r7,r2
8111b0f4:	0007883a 	mov	r3,zero
8111b0f8:	30000426 	beq	r6,zero,8111b10c <__truncdfsf2+0xe4>
8111b0fc:	01800144 	movi	r6,5
8111b100:	00803fc4 	movi	r2,255
8111b104:	300cd0fa 	srli	r6,r6,3
8111b108:	18800a26 	beq	r3,r2,8111b134 <__truncdfsf2+0x10c>
8111b10c:	00802034 	movhi	r2,128
8111b110:	10bfffc4 	addi	r2,r2,-1
8111b114:	308c703a 	and	r6,r6,r2
8111b118:	003feb06 	br	8111b0c8 <__reset+0xfb0fb0c8>
8111b11c:	3888b03a 	or	r4,r7,r2
8111b120:	203fe726 	beq	r4,zero,8111b0c0 <__reset+0xfb0fb0c0>
8111b124:	380c90fa 	slli	r6,r7,3
8111b128:	00c03fc4 	movi	r3,255
8111b12c:	31808034 	orhi	r6,r6,512
8111b130:	003fd506 	br	8111b088 <__reset+0xfb0fb088>
8111b134:	303fe226 	beq	r6,zero,8111b0c0 <__reset+0xfb0fb0c0>
8111b138:	00802034 	movhi	r2,128
8111b13c:	31801034 	orhi	r6,r6,64
8111b140:	10bfffc4 	addi	r2,r2,-1
8111b144:	00ffffc4 	movi	r3,-1
8111b148:	308c703a 	and	r6,r6,r2
8111b14c:	003fde06 	br	8111b0c8 <__reset+0xfb0fb0c8>
8111b150:	013ffa44 	movi	r4,-23
8111b154:	19000e16 	blt	r3,r4,8111b190 <__truncdfsf2+0x168>
8111b158:	01000784 	movi	r4,30
8111b15c:	20c9c83a 	sub	r4,r4,r3
8111b160:	018007c4 	movi	r6,31
8111b164:	39c02034 	orhi	r7,r7,128
8111b168:	31000b16 	blt	r6,r4,8111b198 <__truncdfsf2+0x170>
8111b16c:	423f2084 	addi	r8,r8,-894
8111b170:	120c983a 	sll	r6,r2,r8
8111b174:	3a0e983a 	sll	r7,r7,r8
8111b178:	1104d83a 	srl	r2,r2,r4
8111b17c:	300cc03a 	cmpne	r6,r6,zero
8111b180:	31ceb03a 	or	r7,r6,r7
8111b184:	388cb03a 	or	r6,r7,r2
8111b188:	0007883a 	mov	r3,zero
8111b18c:	003fbe06 	br	8111b088 <__reset+0xfb0fb088>
8111b190:	0007883a 	mov	r3,zero
8111b194:	003fd906 	br	8111b0fc <__reset+0xfb0fb0fc>
8111b198:	01bfff84 	movi	r6,-2
8111b19c:	30cdc83a 	sub	r6,r6,r3
8111b1a0:	00c00804 	movi	r3,32
8111b1a4:	398cd83a 	srl	r6,r7,r6
8111b1a8:	20c00726 	beq	r4,r3,8111b1c8 <__truncdfsf2+0x1a0>
8111b1ac:	423f2884 	addi	r8,r8,-862
8111b1b0:	3a0e983a 	sll	r7,r7,r8
8111b1b4:	3884b03a 	or	r2,r7,r2
8111b1b8:	1004c03a 	cmpne	r2,r2,zero
8111b1bc:	118cb03a 	or	r6,r2,r6
8111b1c0:	0007883a 	mov	r3,zero
8111b1c4:	003fb006 	br	8111b088 <__reset+0xfb0fb088>
8111b1c8:	000f883a 	mov	r7,zero
8111b1cc:	003ff906 	br	8111b1b4 <__reset+0xfb0fb1b4>

8111b1d0 <__clzsi2>:
8111b1d0:	00bfffd4 	movui	r2,65535
8111b1d4:	11000536 	bltu	r2,r4,8111b1ec <__clzsi2+0x1c>
8111b1d8:	00803fc4 	movi	r2,255
8111b1dc:	11000f36 	bltu	r2,r4,8111b21c <__clzsi2+0x4c>
8111b1e0:	00800804 	movi	r2,32
8111b1e4:	0007883a 	mov	r3,zero
8111b1e8:	00000506 	br	8111b200 <__clzsi2+0x30>
8111b1ec:	00804034 	movhi	r2,256
8111b1f0:	10bfffc4 	addi	r2,r2,-1
8111b1f4:	11000c2e 	bgeu	r2,r4,8111b228 <__clzsi2+0x58>
8111b1f8:	00800204 	movi	r2,8
8111b1fc:	00c00604 	movi	r3,24
8111b200:	20c8d83a 	srl	r4,r4,r3
8111b204:	00e04574 	movhi	r3,33045
8111b208:	18e89304 	addi	r3,r3,-23988
8111b20c:	1909883a 	add	r4,r3,r4
8111b210:	20c00003 	ldbu	r3,0(r4)
8111b214:	10c5c83a 	sub	r2,r2,r3
8111b218:	f800283a 	ret
8111b21c:	00800604 	movi	r2,24
8111b220:	00c00204 	movi	r3,8
8111b224:	003ff606 	br	8111b200 <__reset+0xfb0fb200>
8111b228:	00800404 	movi	r2,16
8111b22c:	1007883a 	mov	r3,r2
8111b230:	003ff306 	br	8111b200 <__reset+0xfb0fb200>

8111b234 <atoi>:
8111b234:	01800284 	movi	r6,10
8111b238:	000b883a 	mov	r5,zero
8111b23c:	111d2501 	jmpi	8111d250 <strtol>

8111b240 <_atoi_r>:
8111b240:	01c00284 	movi	r7,10
8111b244:	000d883a 	mov	r6,zero
8111b248:	111d0101 	jmpi	8111d010 <_strtol_r>

8111b24c <_fopen_r>:
8111b24c:	defffa04 	addi	sp,sp,-24
8111b250:	3005883a 	mov	r2,r6
8111b254:	de00012e 	bgeu	sp,et,8111b25c <_fopen_r+0x10>
8111b258:	003b68fa 	trap	3
8111b25c:	d80d883a 	mov	r6,sp
8111b260:	dcc00415 	stw	r19,16(sp)
8111b264:	2827883a 	mov	r19,r5
8111b268:	100b883a 	mov	r5,r2
8111b26c:	dc800315 	stw	r18,12(sp)
8111b270:	dfc00515 	stw	ra,20(sp)
8111b274:	dc400215 	stw	r17,8(sp)
8111b278:	dc000115 	stw	r16,4(sp)
8111b27c:	2025883a 	mov	r18,r4
8111b280:	11252580 	call	81125258 <__sflags>
8111b284:	10002726 	beq	r2,zero,8111b324 <_fopen_r+0xd8>
8111b288:	9009883a 	mov	r4,r18
8111b28c:	1023883a 	mov	r17,r2
8111b290:	11250d00 	call	811250d0 <__sfp>
8111b294:	1021883a 	mov	r16,r2
8111b298:	10002226 	beq	r2,zero,8111b324 <_fopen_r+0xd8>
8111b29c:	d9800017 	ldw	r6,0(sp)
8111b2a0:	01c06d84 	movi	r7,438
8111b2a4:	980b883a 	mov	r5,r19
8111b2a8:	9009883a 	mov	r4,r18
8111b2ac:	111c6b80 	call	8111c6b8 <_open_r>
8111b2b0:	10001916 	blt	r2,zero,8111b318 <_fopen_r+0xcc>
8111b2b4:	8080038d 	sth	r2,14(r16)
8111b2b8:	00a044b4 	movhi	r2,33042
8111b2bc:	10b36504 	addi	r2,r2,-12908
8111b2c0:	80800815 	stw	r2,32(r16)
8111b2c4:	00a044b4 	movhi	r2,33042
8111b2c8:	10b37e04 	addi	r2,r2,-12808
8111b2cc:	80800915 	stw	r2,36(r16)
8111b2d0:	00a044b4 	movhi	r2,33042
8111b2d4:	10b39f04 	addi	r2,r2,-12676
8111b2d8:	80800a15 	stw	r2,40(r16)
8111b2dc:	00a044b4 	movhi	r2,33042
8111b2e0:	10b3b804 	addi	r2,r2,-12576
8111b2e4:	8440030d 	sth	r17,12(r16)
8111b2e8:	84000715 	stw	r16,28(r16)
8111b2ec:	80800b15 	stw	r2,44(r16)
8111b2f0:	8c40400c 	andi	r17,r17,256
8111b2f4:	88000d1e 	bne	r17,zero,8111b32c <_fopen_r+0xe0>
8111b2f8:	8005883a 	mov	r2,r16
8111b2fc:	dfc00517 	ldw	ra,20(sp)
8111b300:	dcc00417 	ldw	r19,16(sp)
8111b304:	dc800317 	ldw	r18,12(sp)
8111b308:	dc400217 	ldw	r17,8(sp)
8111b30c:	dc000117 	ldw	r16,4(sp)
8111b310:	dec00604 	addi	sp,sp,24
8111b314:	f800283a 	ret
8111b318:	11252180 	call	81125218 <__sfp_lock_acquire>
8111b31c:	8000030d 	sth	zero,12(r16)
8111b320:	112521c0 	call	8112521c <__sfp_lock_release>
8111b324:	0005883a 	mov	r2,zero
8111b328:	003ff406 	br	8111b2fc <__reset+0xfb0fb2fc>
8111b32c:	01c00084 	movi	r7,2
8111b330:	000d883a 	mov	r6,zero
8111b334:	800b883a 	mov	r5,r16
8111b338:	9009883a 	mov	r4,r18
8111b33c:	111b46c0 	call	8111b46c <_fseek_r>
8111b340:	8005883a 	mov	r2,r16
8111b344:	003fed06 	br	8111b2fc <__reset+0xfb0fb2fc>

8111b348 <fopen>:
8111b348:	00a04574 	movhi	r2,33045
8111b34c:	10b34e04 	addi	r2,r2,-13000
8111b350:	280d883a 	mov	r6,r5
8111b354:	200b883a 	mov	r5,r4
8111b358:	11000017 	ldw	r4,0(r2)
8111b35c:	111b24c1 	jmpi	8111b24c <_fopen_r>

8111b360 <_fprintf_r>:
8111b360:	defffe04 	addi	sp,sp,-8
8111b364:	2809883a 	mov	r4,r5
8111b368:	300b883a 	mov	r5,r6
8111b36c:	de00012e 	bgeu	sp,et,8111b374 <_fprintf_r+0x14>
8111b370:	003b68fa 	trap	3
8111b374:	dfc00015 	stw	ra,0(sp)
8111b378:	d9c00115 	stw	r7,4(sp)
8111b37c:	d9800104 	addi	r6,sp,4
8111b380:	112164c0 	call	8112164c <__vfprintf_internal>
8111b384:	dfc00017 	ldw	ra,0(sp)
8111b388:	dec00204 	addi	sp,sp,8
8111b38c:	f800283a 	ret

8111b390 <fprintf>:
8111b390:	defffd04 	addi	sp,sp,-12
8111b394:	de00012e 	bgeu	sp,et,8111b39c <fprintf+0xc>
8111b398:	003b68fa 	trap	3
8111b39c:	dfc00015 	stw	ra,0(sp)
8111b3a0:	d9800115 	stw	r6,4(sp)
8111b3a4:	d9c00215 	stw	r7,8(sp)
8111b3a8:	d9800104 	addi	r6,sp,4
8111b3ac:	112164c0 	call	8112164c <__vfprintf_internal>
8111b3b0:	dfc00017 	ldw	ra,0(sp)
8111b3b4:	dec00304 	addi	sp,sp,12
8111b3b8:	f800283a 	ret

8111b3bc <_fputc_r>:
8111b3bc:	defffc04 	addi	sp,sp,-16
8111b3c0:	de00012e 	bgeu	sp,et,8111b3c8 <_fputc_r+0xc>
8111b3c4:	003b68fa 	trap	3
8111b3c8:	dc000215 	stw	r16,8(sp)
8111b3cc:	dfc00315 	stw	ra,12(sp)
8111b3d0:	2021883a 	mov	r16,r4
8111b3d4:	20000726 	beq	r4,zero,8111b3f4 <_fputc_r+0x38>
8111b3d8:	20800e17 	ldw	r2,56(r4)
8111b3dc:	1000051e 	bne	r2,zero,8111b3f4 <_fputc_r+0x38>
8111b3e0:	d9400015 	stw	r5,0(sp)
8111b3e4:	d9800115 	stw	r6,4(sp)
8111b3e8:	11252080 	call	81125208 <__sinit>
8111b3ec:	d9800117 	ldw	r6,4(sp)
8111b3f0:	d9400017 	ldw	r5,0(sp)
8111b3f4:	8009883a 	mov	r4,r16
8111b3f8:	dfc00317 	ldw	ra,12(sp)
8111b3fc:	dc000217 	ldw	r16,8(sp)
8111b400:	dec00404 	addi	sp,sp,16
8111b404:	111c79c1 	jmpi	8111c79c <_putc_r>

8111b408 <fputc>:
8111b408:	00a04574 	movhi	r2,33045
8111b40c:	defffc04 	addi	sp,sp,-16
8111b410:	10b34e04 	addi	r2,r2,-13000
8111b414:	de00012e 	bgeu	sp,et,8111b41c <fputc+0x14>
8111b418:	003b68fa 	trap	3
8111b41c:	dc000115 	stw	r16,4(sp)
8111b420:	14000017 	ldw	r16,0(r2)
8111b424:	dc400215 	stw	r17,8(sp)
8111b428:	dfc00315 	stw	ra,12(sp)
8111b42c:	2023883a 	mov	r17,r4
8111b430:	80000626 	beq	r16,zero,8111b44c <fputc+0x44>
8111b434:	80800e17 	ldw	r2,56(r16)
8111b438:	1000041e 	bne	r2,zero,8111b44c <fputc+0x44>
8111b43c:	8009883a 	mov	r4,r16
8111b440:	d9400015 	stw	r5,0(sp)
8111b444:	11252080 	call	81125208 <__sinit>
8111b448:	d9400017 	ldw	r5,0(sp)
8111b44c:	280d883a 	mov	r6,r5
8111b450:	8009883a 	mov	r4,r16
8111b454:	880b883a 	mov	r5,r17
8111b458:	dfc00317 	ldw	ra,12(sp)
8111b45c:	dc400217 	ldw	r17,8(sp)
8111b460:	dc000117 	ldw	r16,4(sp)
8111b464:	dec00404 	addi	sp,sp,16
8111b468:	111c79c1 	jmpi	8111c79c <_putc_r>

8111b46c <_fseek_r>:
8111b46c:	111b48c1 	jmpi	8111b48c <_fseeko_r>

8111b470 <fseek>:
8111b470:	00a04574 	movhi	r2,33045
8111b474:	10b34e04 	addi	r2,r2,-13000
8111b478:	300f883a 	mov	r7,r6
8111b47c:	280d883a 	mov	r6,r5
8111b480:	200b883a 	mov	r5,r4
8111b484:	11000017 	ldw	r4,0(r2)
8111b488:	111b48c1 	jmpi	8111b48c <_fseeko_r>

8111b48c <_fseeko_r>:
8111b48c:	deffe804 	addi	sp,sp,-96
8111b490:	de00012e 	bgeu	sp,et,8111b498 <_fseeko_r+0xc>
8111b494:	003b68fa 	trap	3
8111b498:	dd401415 	stw	r21,80(sp)
8111b49c:	dc801115 	stw	r18,68(sp)
8111b4a0:	dc401015 	stw	r17,64(sp)
8111b4a4:	dc000f15 	stw	r16,60(sp)
8111b4a8:	dfc01715 	stw	ra,92(sp)
8111b4ac:	ddc01615 	stw	r23,88(sp)
8111b4b0:	dd801515 	stw	r22,84(sp)
8111b4b4:	dd001315 	stw	r20,76(sp)
8111b4b8:	dcc01215 	stw	r19,72(sp)
8111b4bc:	2023883a 	mov	r17,r4
8111b4c0:	2821883a 	mov	r16,r5
8111b4c4:	302b883a 	mov	r21,r6
8111b4c8:	3825883a 	mov	r18,r7
8111b4cc:	20000226 	beq	r4,zero,8111b4d8 <_fseeko_r+0x4c>
8111b4d0:	20800e17 	ldw	r2,56(r4)
8111b4d4:	10005a26 	beq	r2,zero,8111b640 <_fseeko_r+0x1b4>
8111b4d8:	8080030b 	ldhu	r2,12(r16)
8111b4dc:	00c04204 	movi	r3,264
8111b4e0:	1080420c 	andi	r2,r2,264
8111b4e4:	10c05b26 	beq	r2,r3,8111b654 <_fseeko_r+0x1c8>
8111b4e8:	85000a17 	ldw	r20,40(r16)
8111b4ec:	a000f626 	beq	r20,zero,8111b8c8 <_fseeko_r+0x43c>
8111b4f0:	00800044 	movi	r2,1
8111b4f4:	90803e26 	beq	r18,r2,8111b5f0 <_fseeko_r+0x164>
8111b4f8:	00800084 	movi	r2,2
8111b4fc:	90801026 	beq	r18,r2,8111b540 <_fseeko_r+0xb4>
8111b500:	90000f26 	beq	r18,zero,8111b540 <_fseeko_r+0xb4>
8111b504:	00800584 	movi	r2,22
8111b508:	88800015 	stw	r2,0(r17)
8111b50c:	04ffffc4 	movi	r19,-1
8111b510:	9805883a 	mov	r2,r19
8111b514:	dfc01717 	ldw	ra,92(sp)
8111b518:	ddc01617 	ldw	r23,88(sp)
8111b51c:	dd801517 	ldw	r22,84(sp)
8111b520:	dd401417 	ldw	r21,80(sp)
8111b524:	dd001317 	ldw	r20,76(sp)
8111b528:	dcc01217 	ldw	r19,72(sp)
8111b52c:	dc801117 	ldw	r18,68(sp)
8111b530:	dc401017 	ldw	r17,64(sp)
8111b534:	dc000f17 	ldw	r16,60(sp)
8111b538:	dec01804 	addi	sp,sp,96
8111b53c:	f800283a 	ret
8111b540:	80800417 	ldw	r2,16(r16)
8111b544:	002f883a 	mov	r23,zero
8111b548:	0027883a 	mov	r19,zero
8111b54c:	1000cb26 	beq	r2,zero,8111b87c <_fseeko_r+0x3f0>
8111b550:	8080030b 	ldhu	r2,12(r16)
8111b554:	10c2068c 	andi	r3,r2,2074
8111b558:	1800071e 	bne	r3,zero,8111b578 <_fseeko_r+0xec>
8111b55c:	10c1000c 	andi	r3,r2,1024
8111b560:	1800451e 	bne	r3,zero,8111b678 <_fseeko_r+0x1ec>
8111b564:	00e044b4 	movhi	r3,33042
8111b568:	18f39f04 	addi	r3,r3,-12676
8111b56c:	a0c0b726 	beq	r20,r3,8111b84c <_fseeko_r+0x3c0>
8111b570:	10820014 	ori	r2,r2,2048
8111b574:	8080030d 	sth	r2,12(r16)
8111b578:	800b883a 	mov	r5,r16
8111b57c:	8809883a 	mov	r4,r17
8111b580:	1124e0c0 	call	81124e0c <_fflush_r>
8111b584:	1027883a 	mov	r19,r2
8111b588:	103fe01e 	bne	r2,zero,8111b50c <__reset+0xfb0fb50c>
8111b58c:	81400717 	ldw	r5,28(r16)
8111b590:	900f883a 	mov	r7,r18
8111b594:	a80d883a 	mov	r6,r21
8111b598:	8809883a 	mov	r4,r17
8111b59c:	a03ee83a 	callr	r20
8111b5a0:	00ffffc4 	movi	r3,-1
8111b5a4:	10ffd926 	beq	r2,r3,8111b50c <__reset+0xfb0fb50c>
8111b5a8:	81400c17 	ldw	r5,48(r16)
8111b5ac:	28000526 	beq	r5,zero,8111b5c4 <_fseeko_r+0x138>
8111b5b0:	80801004 	addi	r2,r16,64
8111b5b4:	28800226 	beq	r5,r2,8111b5c0 <_fseeko_r+0x134>
8111b5b8:	8809883a 	mov	r4,r17
8111b5bc:	11256a00 	call	811256a0 <_free_r>
8111b5c0:	80000c15 	stw	zero,48(r16)
8111b5c4:	8080030b 	ldhu	r2,12(r16)
8111b5c8:	80c00417 	ldw	r3,16(r16)
8111b5cc:	80000115 	stw	zero,4(r16)
8111b5d0:	10bdf7cc 	andi	r2,r2,63455
8111b5d4:	80c00015 	stw	r3,0(r16)
8111b5d8:	8080030d 	sth	r2,12(r16)
8111b5dc:	01800204 	movi	r6,8
8111b5e0:	000b883a 	mov	r5,zero
8111b5e4:	81001704 	addi	r4,r16,92
8111b5e8:	111c5900 	call	8111c590 <memset>
8111b5ec:	003fc806 	br	8111b510 <__reset+0xfb0fb510>
8111b5f0:	800b883a 	mov	r5,r16
8111b5f4:	8809883a 	mov	r4,r17
8111b5f8:	1124e0c0 	call	81124e0c <_fflush_r>
8111b5fc:	8080030b 	ldhu	r2,12(r16)
8111b600:	10c4000c 	andi	r3,r2,4096
8111b604:	18008726 	beq	r3,zero,8111b824 <_fseeko_r+0x398>
8111b608:	84c01417 	ldw	r19,80(r16)
8111b60c:	10c0010c 	andi	r3,r2,4
8111b610:	1800431e 	bne	r3,zero,8111b720 <_fseeko_r+0x294>
8111b614:	1080020c 	andi	r2,r2,8
8111b618:	10008026 	beq	r2,zero,8111b81c <_fseeko_r+0x390>
8111b61c:	80c00017 	ldw	r3,0(r16)
8111b620:	80800417 	ldw	r2,16(r16)
8111b624:	18000226 	beq	r3,zero,8111b630 <_fseeko_r+0x1a4>
8111b628:	1887c83a 	sub	r3,r3,r2
8111b62c:	98e7883a 	add	r19,r19,r3
8111b630:	aceb883a 	add	r21,r21,r19
8111b634:	05c00044 	movi	r23,1
8111b638:	0025883a 	mov	r18,zero
8111b63c:	003fc306 	br	8111b54c <__reset+0xfb0fb54c>
8111b640:	11252080 	call	81125208 <__sinit>
8111b644:	8080030b 	ldhu	r2,12(r16)
8111b648:	00c04204 	movi	r3,264
8111b64c:	1080420c 	andi	r2,r2,264
8111b650:	10ffa51e 	bne	r2,r3,8111b4e8 <__reset+0xfb0fb4e8>
8111b654:	800b883a 	mov	r5,r16
8111b658:	8809883a 	mov	r4,r17
8111b65c:	1124e0c0 	call	81124e0c <_fflush_r>
8111b660:	003fa106 	br	8111b4e8 <__reset+0xfb0fb4e8>
8111b664:	8080030b 	ldhu	r2,12(r16)
8111b668:	00c10004 	movi	r3,1024
8111b66c:	80c01315 	stw	r3,76(r16)
8111b670:	10c4b03a 	or	r2,r2,r3
8111b674:	8080030d 	sth	r2,12(r16)
8111b678:	9000311e 	bne	r18,zero,8111b740 <_fseeko_r+0x2b4>
8111b67c:	a82d883a 	mov	r22,r21
8111b680:	b800371e 	bne	r23,zero,8111b760 <_fseeko_r+0x2d4>
8111b684:	8080030b 	ldhu	r2,12(r16)
8111b688:	1084000c 	andi	r2,r2,4096
8111b68c:	10007f26 	beq	r2,zero,8111b88c <_fseeko_r+0x400>
8111b690:	80801417 	ldw	r2,80(r16)
8111b694:	81800117 	ldw	r6,4(r16)
8111b698:	81400c17 	ldw	r5,48(r16)
8111b69c:	11a7c83a 	sub	r19,r2,r6
8111b6a0:	28008226 	beq	r5,zero,8111b8ac <_fseeko_r+0x420>
8111b6a4:	81c00f17 	ldw	r7,60(r16)
8111b6a8:	99e7c83a 	sub	r19,r19,r7
8111b6ac:	81000e17 	ldw	r4,56(r16)
8111b6b0:	80800417 	ldw	r2,16(r16)
8111b6b4:	99a7883a 	add	r19,r19,r6
8111b6b8:	2087c83a 	sub	r3,r4,r2
8111b6bc:	98e7c83a 	sub	r19,r19,r3
8111b6c0:	38c7883a 	add	r3,r7,r3
8111b6c4:	b4c02b16 	blt	r22,r19,8111b774 <_fseeko_r+0x2e8>
8111b6c8:	98c9883a 	add	r4,r19,r3
8111b6cc:	b100292e 	bgeu	r22,r4,8111b774 <_fseeko_r+0x2e8>
8111b6d0:	b4e7c83a 	sub	r19,r22,r19
8111b6d4:	14c5883a 	add	r2,r2,r19
8111b6d8:	1ce7c83a 	sub	r19,r3,r19
8111b6dc:	80800015 	stw	r2,0(r16)
8111b6e0:	84c00115 	stw	r19,4(r16)
8111b6e4:	28000526 	beq	r5,zero,8111b6fc <_fseeko_r+0x270>
8111b6e8:	80801004 	addi	r2,r16,64
8111b6ec:	28800226 	beq	r5,r2,8111b6f8 <_fseeko_r+0x26c>
8111b6f0:	8809883a 	mov	r4,r17
8111b6f4:	11256a00 	call	811256a0 <_free_r>
8111b6f8:	80000c15 	stw	zero,48(r16)
8111b6fc:	8080030b 	ldhu	r2,12(r16)
8111b700:	01800204 	movi	r6,8
8111b704:	000b883a 	mov	r5,zero
8111b708:	10bff7cc 	andi	r2,r2,65503
8111b70c:	8080030d 	sth	r2,12(r16)
8111b710:	81001704 	addi	r4,r16,92
8111b714:	111c5900 	call	8111c590 <memset>
8111b718:	0027883a 	mov	r19,zero
8111b71c:	003f7c06 	br	8111b510 <__reset+0xfb0fb510>
8111b720:	80c00117 	ldw	r3,4(r16)
8111b724:	80800c17 	ldw	r2,48(r16)
8111b728:	98e7c83a 	sub	r19,r19,r3
8111b72c:	10003b26 	beq	r2,zero,8111b81c <_fseeko_r+0x390>
8111b730:	80c00f17 	ldw	r3,60(r16)
8111b734:	80800417 	ldw	r2,16(r16)
8111b738:	98e7c83a 	sub	r19,r19,r3
8111b73c:	003fbc06 	br	8111b630 <__reset+0xfb0fb630>
8111b740:	8140038f 	ldh	r5,14(r16)
8111b744:	d80d883a 	mov	r6,sp
8111b748:	8809883a 	mov	r4,r17
8111b74c:	111b8f40 	call	8111b8f4 <_fstat_r>
8111b750:	103f891e 	bne	r2,zero,8111b578 <__reset+0xfb0fb578>
8111b754:	dd800417 	ldw	r22,16(sp)
8111b758:	adad883a 	add	r22,r21,r22
8111b75c:	b83fc926 	beq	r23,zero,8111b684 <__reset+0xfb0fb684>
8111b760:	81400c17 	ldw	r5,48(r16)
8111b764:	81800117 	ldw	r6,4(r16)
8111b768:	28005026 	beq	r5,zero,8111b8ac <_fseeko_r+0x420>
8111b76c:	81c00f17 	ldw	r7,60(r16)
8111b770:	003fce06 	br	8111b6ac <__reset+0xfb0fb6ac>
8111b774:	84c01317 	ldw	r19,76(r16)
8111b778:	81400717 	ldw	r5,28(r16)
8111b77c:	000f883a 	mov	r7,zero
8111b780:	04e7c83a 	sub	r19,zero,r19
8111b784:	9da6703a 	and	r19,r19,r22
8111b788:	980d883a 	mov	r6,r19
8111b78c:	8809883a 	mov	r4,r17
8111b790:	a03ee83a 	callr	r20
8111b794:	00ffffc4 	movi	r3,-1
8111b798:	10ff7726 	beq	r2,r3,8111b578 <__reset+0xfb0fb578>
8111b79c:	80800417 	ldw	r2,16(r16)
8111b7a0:	81400c17 	ldw	r5,48(r16)
8111b7a4:	80000115 	stw	zero,4(r16)
8111b7a8:	80800015 	stw	r2,0(r16)
8111b7ac:	28000526 	beq	r5,zero,8111b7c4 <_fseeko_r+0x338>
8111b7b0:	80801004 	addi	r2,r16,64
8111b7b4:	28800226 	beq	r5,r2,8111b7c0 <_fseeko_r+0x334>
8111b7b8:	8809883a 	mov	r4,r17
8111b7bc:	11256a00 	call	811256a0 <_free_r>
8111b7c0:	80000c15 	stw	zero,48(r16)
8111b7c4:	8080030b 	ldhu	r2,12(r16)
8111b7c8:	b4e7c83a 	sub	r19,r22,r19
8111b7cc:	10bff7cc 	andi	r2,r2,65503
8111b7d0:	8080030d 	sth	r2,12(r16)
8111b7d4:	98000b26 	beq	r19,zero,8111b804 <_fseeko_r+0x378>
8111b7d8:	800b883a 	mov	r5,r16
8111b7dc:	8809883a 	mov	r4,r17
8111b7e0:	111ca0c0 	call	8111ca0c <__srefill_r>
8111b7e4:	103f641e 	bne	r2,zero,8111b578 <__reset+0xfb0fb578>
8111b7e8:	80800117 	ldw	r2,4(r16)
8111b7ec:	14ff6236 	bltu	r2,r19,8111b578 <__reset+0xfb0fb578>
8111b7f0:	80c00017 	ldw	r3,0(r16)
8111b7f4:	14c5c83a 	sub	r2,r2,r19
8111b7f8:	80800115 	stw	r2,4(r16)
8111b7fc:	1ce7883a 	add	r19,r3,r19
8111b800:	84c00015 	stw	r19,0(r16)
8111b804:	01800204 	movi	r6,8
8111b808:	000b883a 	mov	r5,zero
8111b80c:	81001704 	addi	r4,r16,92
8111b810:	111c5900 	call	8111c590 <memset>
8111b814:	0027883a 	mov	r19,zero
8111b818:	003f3d06 	br	8111b510 <__reset+0xfb0fb510>
8111b81c:	80800417 	ldw	r2,16(r16)
8111b820:	003f8306 	br	8111b630 <__reset+0xfb0fb630>
8111b824:	81400717 	ldw	r5,28(r16)
8111b828:	900f883a 	mov	r7,r18
8111b82c:	000d883a 	mov	r6,zero
8111b830:	8809883a 	mov	r4,r17
8111b834:	a03ee83a 	callr	r20
8111b838:	1027883a 	mov	r19,r2
8111b83c:	00bfffc4 	movi	r2,-1
8111b840:	98bf3226 	beq	r19,r2,8111b50c <__reset+0xfb0fb50c>
8111b844:	8080030b 	ldhu	r2,12(r16)
8111b848:	003f7006 	br	8111b60c <__reset+0xfb0fb60c>
8111b84c:	8140038f 	ldh	r5,14(r16)
8111b850:	283f4716 	blt	r5,zero,8111b570 <__reset+0xfb0fb570>
8111b854:	d80d883a 	mov	r6,sp
8111b858:	8809883a 	mov	r4,r17
8111b85c:	111b8f40 	call	8111b8f4 <_fstat_r>
8111b860:	1000041e 	bne	r2,zero,8111b874 <_fseeko_r+0x3e8>
8111b864:	d8800117 	ldw	r2,4(sp)
8111b868:	00e00014 	movui	r3,32768
8111b86c:	10bc000c 	andi	r2,r2,61440
8111b870:	10ff7c26 	beq	r2,r3,8111b664 <__reset+0xfb0fb664>
8111b874:	8080030b 	ldhu	r2,12(r16)
8111b878:	003f3d06 	br	8111b570 <__reset+0xfb0fb570>
8111b87c:	800b883a 	mov	r5,r16
8111b880:	8809883a 	mov	r4,r17
8111b884:	111ba680 	call	8111ba68 <__smakebuf_r>
8111b888:	003f3106 	br	8111b550 <__reset+0xfb0fb550>
8111b88c:	81400717 	ldw	r5,28(r16)
8111b890:	01c00044 	movi	r7,1
8111b894:	000d883a 	mov	r6,zero
8111b898:	8809883a 	mov	r4,r17
8111b89c:	a03ee83a 	callr	r20
8111b8a0:	00ffffc4 	movi	r3,-1
8111b8a4:	10ff7b1e 	bne	r2,r3,8111b694 <__reset+0xfb0fb694>
8111b8a8:	003f3306 	br	8111b578 <__reset+0xfb0fb578>
8111b8ac:	80c00017 	ldw	r3,0(r16)
8111b8b0:	80800417 	ldw	r2,16(r16)
8111b8b4:	000b883a 	mov	r5,zero
8111b8b8:	1887c83a 	sub	r3,r3,r2
8111b8bc:	98e7c83a 	sub	r19,r19,r3
8111b8c0:	30c7883a 	add	r3,r6,r3
8111b8c4:	003f7f06 	br	8111b6c4 <__reset+0xfb0fb6c4>
8111b8c8:	00800744 	movi	r2,29
8111b8cc:	88800015 	stw	r2,0(r17)
8111b8d0:	04ffffc4 	movi	r19,-1
8111b8d4:	003f0e06 	br	8111b510 <__reset+0xfb0fb510>

8111b8d8 <fseeko>:
8111b8d8:	00a04574 	movhi	r2,33045
8111b8dc:	10b34e04 	addi	r2,r2,-13000
8111b8e0:	300f883a 	mov	r7,r6
8111b8e4:	280d883a 	mov	r6,r5
8111b8e8:	200b883a 	mov	r5,r4
8111b8ec:	11000017 	ldw	r4,0(r2)
8111b8f0:	111b48c1 	jmpi	8111b48c <_fseeko_r>

8111b8f4 <_fstat_r>:
8111b8f4:	defffd04 	addi	sp,sp,-12
8111b8f8:	de00012e 	bgeu	sp,et,8111b900 <_fstat_r+0xc>
8111b8fc:	003b68fa 	trap	3
8111b900:	2805883a 	mov	r2,r5
8111b904:	dc000015 	stw	r16,0(sp)
8111b908:	04204574 	movhi	r16,33045
8111b90c:	dc400115 	stw	r17,4(sp)
8111b910:	8433bb04 	addi	r16,r16,-12564
8111b914:	2023883a 	mov	r17,r4
8111b918:	300b883a 	mov	r5,r6
8111b91c:	1009883a 	mov	r4,r2
8111b920:	dfc00215 	stw	ra,8(sp)
8111b924:	80000015 	stw	zero,0(r16)
8111b928:	1130ee00 	call	81130ee0 <fstat>
8111b92c:	00ffffc4 	movi	r3,-1
8111b930:	10c00526 	beq	r2,r3,8111b948 <_fstat_r+0x54>
8111b934:	dfc00217 	ldw	ra,8(sp)
8111b938:	dc400117 	ldw	r17,4(sp)
8111b93c:	dc000017 	ldw	r16,0(sp)
8111b940:	dec00304 	addi	sp,sp,12
8111b944:	f800283a 	ret
8111b948:	80c00017 	ldw	r3,0(r16)
8111b94c:	183ff926 	beq	r3,zero,8111b934 <__reset+0xfb0fb934>
8111b950:	88c00015 	stw	r3,0(r17)
8111b954:	003ff706 	br	8111b934 <__reset+0xfb0fb934>

8111b958 <_fwrite_r>:
8111b958:	defff504 	addi	sp,sp,-44
8111b95c:	de00012e 	bgeu	sp,et,8111b964 <_fwrite_r+0xc>
8111b960:	003b68fa 	trap	3
8111b964:	dc800815 	stw	r18,32(sp)
8111b968:	39a5383a 	mul	r18,r7,r6
8111b96c:	d8800304 	addi	r2,sp,12
8111b970:	d8800015 	stw	r2,0(sp)
8111b974:	00800044 	movi	r2,1
8111b978:	dcc00915 	stw	r19,36(sp)
8111b97c:	dc400715 	stw	r17,28(sp)
8111b980:	dc000615 	stw	r16,24(sp)
8111b984:	d9400315 	stw	r5,12(sp)
8111b988:	dfc00a15 	stw	ra,40(sp)
8111b98c:	dc800415 	stw	r18,16(sp)
8111b990:	dc800215 	stw	r18,8(sp)
8111b994:	d8800115 	stw	r2,4(sp)
8111b998:	3027883a 	mov	r19,r6
8111b99c:	3821883a 	mov	r16,r7
8111b9a0:	2023883a 	mov	r17,r4
8111b9a4:	d9400b17 	ldw	r5,44(sp)
8111b9a8:	20000226 	beq	r4,zero,8111b9b4 <_fwrite_r+0x5c>
8111b9ac:	20800e17 	ldw	r2,56(r4)
8111b9b0:	10001a26 	beq	r2,zero,8111ba1c <_fwrite_r+0xc4>
8111b9b4:	2880030b 	ldhu	r2,12(r5)
8111b9b8:	10c8000c 	andi	r3,r2,8192
8111b9bc:	1800061e 	bne	r3,zero,8111b9d8 <_fwrite_r+0x80>
8111b9c0:	29001917 	ldw	r4,100(r5)
8111b9c4:	00f7ffc4 	movi	r3,-8193
8111b9c8:	10880014 	ori	r2,r2,8192
8111b9cc:	20c6703a 	and	r3,r4,r3
8111b9d0:	2880030d 	sth	r2,12(r5)
8111b9d4:	28c01915 	stw	r3,100(r5)
8111b9d8:	d80d883a 	mov	r6,sp
8111b9dc:	8809883a 	mov	r4,r17
8111b9e0:	11259b80 	call	811259b8 <__sfvwrite_r>
8111b9e4:	10000b26 	beq	r2,zero,8111ba14 <_fwrite_r+0xbc>
8111b9e8:	d9000217 	ldw	r4,8(sp)
8111b9ec:	980b883a 	mov	r5,r19
8111b9f0:	9109c83a 	sub	r4,r18,r4
8111b9f4:	112ea280 	call	8112ea28 <__udivsi3>
8111b9f8:	dfc00a17 	ldw	ra,40(sp)
8111b9fc:	dcc00917 	ldw	r19,36(sp)
8111ba00:	dc800817 	ldw	r18,32(sp)
8111ba04:	dc400717 	ldw	r17,28(sp)
8111ba08:	dc000617 	ldw	r16,24(sp)
8111ba0c:	dec00b04 	addi	sp,sp,44
8111ba10:	f800283a 	ret
8111ba14:	8005883a 	mov	r2,r16
8111ba18:	003ff706 	br	8111b9f8 <__reset+0xfb0fb9f8>
8111ba1c:	d9400515 	stw	r5,20(sp)
8111ba20:	11252080 	call	81125208 <__sinit>
8111ba24:	d9400517 	ldw	r5,20(sp)
8111ba28:	003fe206 	br	8111b9b4 <__reset+0xfb0fb9b4>

8111ba2c <fwrite>:
8111ba2c:	defffe04 	addi	sp,sp,-8
8111ba30:	00a04574 	movhi	r2,33045
8111ba34:	de00012e 	bgeu	sp,et,8111ba3c <fwrite+0x10>
8111ba38:	003b68fa 	trap	3
8111ba3c:	10b34e04 	addi	r2,r2,-13000
8111ba40:	d9c00015 	stw	r7,0(sp)
8111ba44:	300f883a 	mov	r7,r6
8111ba48:	280d883a 	mov	r6,r5
8111ba4c:	200b883a 	mov	r5,r4
8111ba50:	11000017 	ldw	r4,0(r2)
8111ba54:	dfc00115 	stw	ra,4(sp)
8111ba58:	111b9580 	call	8111b958 <_fwrite_r>
8111ba5c:	dfc00117 	ldw	ra,4(sp)
8111ba60:	dec00204 	addi	sp,sp,8
8111ba64:	f800283a 	ret

8111ba68 <__smakebuf_r>:
8111ba68:	2880030b 	ldhu	r2,12(r5)
8111ba6c:	10c0008c 	andi	r3,r2,2
8111ba70:	1800431e 	bne	r3,zero,8111bb80 <__smakebuf_r+0x118>
8111ba74:	deffec04 	addi	sp,sp,-80
8111ba78:	de00012e 	bgeu	sp,et,8111ba80 <__smakebuf_r+0x18>
8111ba7c:	003b68fa 	trap	3
8111ba80:	dc000f15 	stw	r16,60(sp)
8111ba84:	2821883a 	mov	r16,r5
8111ba88:	2940038f 	ldh	r5,14(r5)
8111ba8c:	dc401015 	stw	r17,64(sp)
8111ba90:	dfc01315 	stw	ra,76(sp)
8111ba94:	dcc01215 	stw	r19,72(sp)
8111ba98:	dc801115 	stw	r18,68(sp)
8111ba9c:	2023883a 	mov	r17,r4
8111baa0:	28001c16 	blt	r5,zero,8111bb14 <__smakebuf_r+0xac>
8111baa4:	d80d883a 	mov	r6,sp
8111baa8:	111b8f40 	call	8111b8f4 <_fstat_r>
8111baac:	10001816 	blt	r2,zero,8111bb10 <__smakebuf_r+0xa8>
8111bab0:	d8800117 	ldw	r2,4(sp)
8111bab4:	00e00014 	movui	r3,32768
8111bab8:	10bc000c 	andi	r2,r2,61440
8111babc:	14c80020 	cmpeqi	r19,r2,8192
8111bac0:	10c03726 	beq	r2,r3,8111bba0 <__smakebuf_r+0x138>
8111bac4:	80c0030b 	ldhu	r3,12(r16)
8111bac8:	18c20014 	ori	r3,r3,2048
8111bacc:	80c0030d 	sth	r3,12(r16)
8111bad0:	00c80004 	movi	r3,8192
8111bad4:	10c0521e 	bne	r2,r3,8111bc20 <__smakebuf_r+0x1b8>
8111bad8:	8140038f 	ldh	r5,14(r16)
8111badc:	8809883a 	mov	r4,r17
8111bae0:	11260140 	call	81126014 <_isatty_r>
8111bae4:	10004c26 	beq	r2,zero,8111bc18 <__smakebuf_r+0x1b0>
8111bae8:	8080030b 	ldhu	r2,12(r16)
8111baec:	80c010c4 	addi	r3,r16,67
8111baf0:	80c00015 	stw	r3,0(r16)
8111baf4:	10800054 	ori	r2,r2,1
8111baf8:	8080030d 	sth	r2,12(r16)
8111bafc:	00800044 	movi	r2,1
8111bb00:	80c00415 	stw	r3,16(r16)
8111bb04:	80800515 	stw	r2,20(r16)
8111bb08:	04810004 	movi	r18,1024
8111bb0c:	00000706 	br	8111bb2c <__smakebuf_r+0xc4>
8111bb10:	8080030b 	ldhu	r2,12(r16)
8111bb14:	10c0200c 	andi	r3,r2,128
8111bb18:	18001f1e 	bne	r3,zero,8111bb98 <__smakebuf_r+0x130>
8111bb1c:	04810004 	movi	r18,1024
8111bb20:	10820014 	ori	r2,r2,2048
8111bb24:	8080030d 	sth	r2,12(r16)
8111bb28:	0027883a 	mov	r19,zero
8111bb2c:	900b883a 	mov	r5,r18
8111bb30:	8809883a 	mov	r4,r17
8111bb34:	111bc2c0 	call	8111bc2c <_malloc_r>
8111bb38:	10002c26 	beq	r2,zero,8111bbec <__smakebuf_r+0x184>
8111bb3c:	80c0030b 	ldhu	r3,12(r16)
8111bb40:	012044b4 	movhi	r4,33042
8111bb44:	2113aa04 	addi	r4,r4,20136
8111bb48:	89000f15 	stw	r4,60(r17)
8111bb4c:	18c02014 	ori	r3,r3,128
8111bb50:	80c0030d 	sth	r3,12(r16)
8111bb54:	80800015 	stw	r2,0(r16)
8111bb58:	80800415 	stw	r2,16(r16)
8111bb5c:	84800515 	stw	r18,20(r16)
8111bb60:	98001a1e 	bne	r19,zero,8111bbcc <__smakebuf_r+0x164>
8111bb64:	dfc01317 	ldw	ra,76(sp)
8111bb68:	dcc01217 	ldw	r19,72(sp)
8111bb6c:	dc801117 	ldw	r18,68(sp)
8111bb70:	dc401017 	ldw	r17,64(sp)
8111bb74:	dc000f17 	ldw	r16,60(sp)
8111bb78:	dec01404 	addi	sp,sp,80
8111bb7c:	f800283a 	ret
8111bb80:	288010c4 	addi	r2,r5,67
8111bb84:	28800015 	stw	r2,0(r5)
8111bb88:	28800415 	stw	r2,16(r5)
8111bb8c:	00800044 	movi	r2,1
8111bb90:	28800515 	stw	r2,20(r5)
8111bb94:	f800283a 	ret
8111bb98:	04801004 	movi	r18,64
8111bb9c:	003fe006 	br	8111bb20 <__reset+0xfb0fbb20>
8111bba0:	81000a17 	ldw	r4,40(r16)
8111bba4:	00e044b4 	movhi	r3,33042
8111bba8:	18f39f04 	addi	r3,r3,-12676
8111bbac:	20ffc51e 	bne	r4,r3,8111bac4 <__reset+0xfb0fbac4>
8111bbb0:	8080030b 	ldhu	r2,12(r16)
8111bbb4:	04810004 	movi	r18,1024
8111bbb8:	84801315 	stw	r18,76(r16)
8111bbbc:	1484b03a 	or	r2,r2,r18
8111bbc0:	8080030d 	sth	r2,12(r16)
8111bbc4:	0027883a 	mov	r19,zero
8111bbc8:	003fd806 	br	8111bb2c <__reset+0xfb0fbb2c>
8111bbcc:	8140038f 	ldh	r5,14(r16)
8111bbd0:	8809883a 	mov	r4,r17
8111bbd4:	11260140 	call	81126014 <_isatty_r>
8111bbd8:	103fe226 	beq	r2,zero,8111bb64 <__reset+0xfb0fbb64>
8111bbdc:	8080030b 	ldhu	r2,12(r16)
8111bbe0:	10800054 	ori	r2,r2,1
8111bbe4:	8080030d 	sth	r2,12(r16)
8111bbe8:	003fde06 	br	8111bb64 <__reset+0xfb0fbb64>
8111bbec:	8080030b 	ldhu	r2,12(r16)
8111bbf0:	10c0800c 	andi	r3,r2,512
8111bbf4:	183fdb1e 	bne	r3,zero,8111bb64 <__reset+0xfb0fbb64>
8111bbf8:	10800094 	ori	r2,r2,2
8111bbfc:	80c010c4 	addi	r3,r16,67
8111bc00:	8080030d 	sth	r2,12(r16)
8111bc04:	00800044 	movi	r2,1
8111bc08:	80c00015 	stw	r3,0(r16)
8111bc0c:	80c00415 	stw	r3,16(r16)
8111bc10:	80800515 	stw	r2,20(r16)
8111bc14:	003fd306 	br	8111bb64 <__reset+0xfb0fbb64>
8111bc18:	04810004 	movi	r18,1024
8111bc1c:	003fc306 	br	8111bb2c <__reset+0xfb0fbb2c>
8111bc20:	0027883a 	mov	r19,zero
8111bc24:	04810004 	movi	r18,1024
8111bc28:	003fc006 	br	8111bb2c <__reset+0xfb0fbb2c>

8111bc2c <_malloc_r>:
8111bc2c:	defff504 	addi	sp,sp,-44
8111bc30:	de00012e 	bgeu	sp,et,8111bc38 <_malloc_r+0xc>
8111bc34:	003b68fa 	trap	3
8111bc38:	288002c4 	addi	r2,r5,11
8111bc3c:	dc800315 	stw	r18,12(sp)
8111bc40:	dfc00a15 	stw	ra,40(sp)
8111bc44:	df000915 	stw	fp,36(sp)
8111bc48:	ddc00815 	stw	r23,32(sp)
8111bc4c:	dd800715 	stw	r22,28(sp)
8111bc50:	dd400615 	stw	r21,24(sp)
8111bc54:	dd000515 	stw	r20,20(sp)
8111bc58:	dcc00415 	stw	r19,16(sp)
8111bc5c:	dc400215 	stw	r17,8(sp)
8111bc60:	dc000115 	stw	r16,4(sp)
8111bc64:	00c00584 	movi	r3,22
8111bc68:	2025883a 	mov	r18,r4
8111bc6c:	18807f2e 	bgeu	r3,r2,8111be6c <_malloc_r+0x240>
8111bc70:	047ffe04 	movi	r17,-8
8111bc74:	1462703a 	and	r17,r2,r17
8111bc78:	8800a316 	blt	r17,zero,8111bf08 <_malloc_r+0x2dc>
8111bc7c:	8940a236 	bltu	r17,r5,8111bf08 <_malloc_r+0x2dc>
8111bc80:	1132a280 	call	81132a28 <__malloc_lock>
8111bc84:	00807dc4 	movi	r2,503
8111bc88:	1441e92e 	bgeu	r2,r17,8111c430 <_malloc_r+0x804>
8111bc8c:	8804d27a 	srli	r2,r17,9
8111bc90:	1000a126 	beq	r2,zero,8111bf18 <_malloc_r+0x2ec>
8111bc94:	00c00104 	movi	r3,4
8111bc98:	18811e36 	bltu	r3,r2,8111c114 <_malloc_r+0x4e8>
8111bc9c:	8804d1ba 	srli	r2,r17,6
8111bca0:	12000e44 	addi	r8,r2,57
8111bca4:	11c00e04 	addi	r7,r2,56
8111bca8:	4209883a 	add	r4,r8,r8
8111bcac:	04e04574 	movhi	r19,33045
8111bcb0:	2109883a 	add	r4,r4,r4
8111bcb4:	9ced0c04 	addi	r19,r19,-19408
8111bcb8:	2109883a 	add	r4,r4,r4
8111bcbc:	9909883a 	add	r4,r19,r4
8111bcc0:	24000117 	ldw	r16,4(r4)
8111bcc4:	213ffe04 	addi	r4,r4,-8
8111bcc8:	24009726 	beq	r4,r16,8111bf28 <_malloc_r+0x2fc>
8111bccc:	80800117 	ldw	r2,4(r16)
8111bcd0:	01bfff04 	movi	r6,-4
8111bcd4:	014003c4 	movi	r5,15
8111bcd8:	1184703a 	and	r2,r2,r6
8111bcdc:	1447c83a 	sub	r3,r2,r17
8111bce0:	28c00716 	blt	r5,r3,8111bd00 <_malloc_r+0xd4>
8111bce4:	1800920e 	bge	r3,zero,8111bf30 <_malloc_r+0x304>
8111bce8:	84000317 	ldw	r16,12(r16)
8111bcec:	24008e26 	beq	r4,r16,8111bf28 <_malloc_r+0x2fc>
8111bcf0:	80800117 	ldw	r2,4(r16)
8111bcf4:	1184703a 	and	r2,r2,r6
8111bcf8:	1447c83a 	sub	r3,r2,r17
8111bcfc:	28fff90e 	bge	r5,r3,8111bce4 <__reset+0xfb0fbce4>
8111bd00:	3809883a 	mov	r4,r7
8111bd04:	01a04574 	movhi	r6,33045
8111bd08:	9c000417 	ldw	r16,16(r19)
8111bd0c:	31ad0c04 	addi	r6,r6,-19408
8111bd10:	32000204 	addi	r8,r6,8
8111bd14:	82013426 	beq	r16,r8,8111c1e8 <_malloc_r+0x5bc>
8111bd18:	80c00117 	ldw	r3,4(r16)
8111bd1c:	00bfff04 	movi	r2,-4
8111bd20:	188e703a 	and	r7,r3,r2
8111bd24:	3c45c83a 	sub	r2,r7,r17
8111bd28:	00c003c4 	movi	r3,15
8111bd2c:	18811f16 	blt	r3,r2,8111c1ac <_malloc_r+0x580>
8111bd30:	32000515 	stw	r8,20(r6)
8111bd34:	32000415 	stw	r8,16(r6)
8111bd38:	10007f0e 	bge	r2,zero,8111bf38 <_malloc_r+0x30c>
8111bd3c:	00807fc4 	movi	r2,511
8111bd40:	11c0fd36 	bltu	r2,r7,8111c138 <_malloc_r+0x50c>
8111bd44:	3806d0fa 	srli	r3,r7,3
8111bd48:	01c00044 	movi	r7,1
8111bd4c:	30800117 	ldw	r2,4(r6)
8111bd50:	19400044 	addi	r5,r3,1
8111bd54:	294b883a 	add	r5,r5,r5
8111bd58:	1807d0ba 	srai	r3,r3,2
8111bd5c:	294b883a 	add	r5,r5,r5
8111bd60:	294b883a 	add	r5,r5,r5
8111bd64:	298b883a 	add	r5,r5,r6
8111bd68:	38c6983a 	sll	r3,r7,r3
8111bd6c:	29c00017 	ldw	r7,0(r5)
8111bd70:	2a7ffe04 	addi	r9,r5,-8
8111bd74:	1886b03a 	or	r3,r3,r2
8111bd78:	82400315 	stw	r9,12(r16)
8111bd7c:	81c00215 	stw	r7,8(r16)
8111bd80:	30c00115 	stw	r3,4(r6)
8111bd84:	2c000015 	stw	r16,0(r5)
8111bd88:	3c000315 	stw	r16,12(r7)
8111bd8c:	2005d0ba 	srai	r2,r4,2
8111bd90:	01400044 	movi	r5,1
8111bd94:	288a983a 	sll	r5,r5,r2
8111bd98:	19406f36 	bltu	r3,r5,8111bf58 <_malloc_r+0x32c>
8111bd9c:	28c4703a 	and	r2,r5,r3
8111bda0:	10000a1e 	bne	r2,zero,8111bdcc <_malloc_r+0x1a0>
8111bda4:	00bfff04 	movi	r2,-4
8111bda8:	294b883a 	add	r5,r5,r5
8111bdac:	2088703a 	and	r4,r4,r2
8111bdb0:	28c4703a 	and	r2,r5,r3
8111bdb4:	21000104 	addi	r4,r4,4
8111bdb8:	1000041e 	bne	r2,zero,8111bdcc <_malloc_r+0x1a0>
8111bdbc:	294b883a 	add	r5,r5,r5
8111bdc0:	28c4703a 	and	r2,r5,r3
8111bdc4:	21000104 	addi	r4,r4,4
8111bdc8:	103ffc26 	beq	r2,zero,8111bdbc <__reset+0xfb0fbdbc>
8111bdcc:	02bfff04 	movi	r10,-4
8111bdd0:	024003c4 	movi	r9,15
8111bdd4:	21800044 	addi	r6,r4,1
8111bdd8:	318d883a 	add	r6,r6,r6
8111bddc:	318d883a 	add	r6,r6,r6
8111bde0:	318d883a 	add	r6,r6,r6
8111bde4:	998d883a 	add	r6,r19,r6
8111bde8:	333ffe04 	addi	r12,r6,-8
8111bdec:	2017883a 	mov	r11,r4
8111bdf0:	31800104 	addi	r6,r6,4
8111bdf4:	34000017 	ldw	r16,0(r6)
8111bdf8:	31fffd04 	addi	r7,r6,-12
8111bdfc:	81c0041e 	bne	r16,r7,8111be10 <_malloc_r+0x1e4>
8111be00:	0000fb06 	br	8111c1f0 <_malloc_r+0x5c4>
8111be04:	1801030e 	bge	r3,zero,8111c214 <_malloc_r+0x5e8>
8111be08:	84000317 	ldw	r16,12(r16)
8111be0c:	81c0f826 	beq	r16,r7,8111c1f0 <_malloc_r+0x5c4>
8111be10:	80800117 	ldw	r2,4(r16)
8111be14:	1284703a 	and	r2,r2,r10
8111be18:	1447c83a 	sub	r3,r2,r17
8111be1c:	48fff90e 	bge	r9,r3,8111be04 <__reset+0xfb0fbe04>
8111be20:	80800317 	ldw	r2,12(r16)
8111be24:	81000217 	ldw	r4,8(r16)
8111be28:	89400054 	ori	r5,r17,1
8111be2c:	81400115 	stw	r5,4(r16)
8111be30:	20800315 	stw	r2,12(r4)
8111be34:	11000215 	stw	r4,8(r2)
8111be38:	8463883a 	add	r17,r16,r17
8111be3c:	9c400515 	stw	r17,20(r19)
8111be40:	9c400415 	stw	r17,16(r19)
8111be44:	18800054 	ori	r2,r3,1
8111be48:	88800115 	stw	r2,4(r17)
8111be4c:	8a000315 	stw	r8,12(r17)
8111be50:	8a000215 	stw	r8,8(r17)
8111be54:	88e3883a 	add	r17,r17,r3
8111be58:	88c00015 	stw	r3,0(r17)
8111be5c:	9009883a 	mov	r4,r18
8111be60:	1132b500 	call	81132b50 <__malloc_unlock>
8111be64:	80800204 	addi	r2,r16,8
8111be68:	00001b06 	br	8111bed8 <_malloc_r+0x2ac>
8111be6c:	04400404 	movi	r17,16
8111be70:	89402536 	bltu	r17,r5,8111bf08 <_malloc_r+0x2dc>
8111be74:	1132a280 	call	81132a28 <__malloc_lock>
8111be78:	00800184 	movi	r2,6
8111be7c:	01000084 	movi	r4,2
8111be80:	04e04574 	movhi	r19,33045
8111be84:	1085883a 	add	r2,r2,r2
8111be88:	9ced0c04 	addi	r19,r19,-19408
8111be8c:	1085883a 	add	r2,r2,r2
8111be90:	9885883a 	add	r2,r19,r2
8111be94:	14000117 	ldw	r16,4(r2)
8111be98:	10fffe04 	addi	r3,r2,-8
8111be9c:	80c0d926 	beq	r16,r3,8111c204 <_malloc_r+0x5d8>
8111bea0:	80c00117 	ldw	r3,4(r16)
8111bea4:	81000317 	ldw	r4,12(r16)
8111bea8:	00bfff04 	movi	r2,-4
8111beac:	1884703a 	and	r2,r3,r2
8111beb0:	81400217 	ldw	r5,8(r16)
8111beb4:	8085883a 	add	r2,r16,r2
8111beb8:	10c00117 	ldw	r3,4(r2)
8111bebc:	29000315 	stw	r4,12(r5)
8111bec0:	21400215 	stw	r5,8(r4)
8111bec4:	18c00054 	ori	r3,r3,1
8111bec8:	10c00115 	stw	r3,4(r2)
8111becc:	9009883a 	mov	r4,r18
8111bed0:	1132b500 	call	81132b50 <__malloc_unlock>
8111bed4:	80800204 	addi	r2,r16,8
8111bed8:	dfc00a17 	ldw	ra,40(sp)
8111bedc:	df000917 	ldw	fp,36(sp)
8111bee0:	ddc00817 	ldw	r23,32(sp)
8111bee4:	dd800717 	ldw	r22,28(sp)
8111bee8:	dd400617 	ldw	r21,24(sp)
8111beec:	dd000517 	ldw	r20,20(sp)
8111bef0:	dcc00417 	ldw	r19,16(sp)
8111bef4:	dc800317 	ldw	r18,12(sp)
8111bef8:	dc400217 	ldw	r17,8(sp)
8111befc:	dc000117 	ldw	r16,4(sp)
8111bf00:	dec00b04 	addi	sp,sp,44
8111bf04:	f800283a 	ret
8111bf08:	00800304 	movi	r2,12
8111bf0c:	90800015 	stw	r2,0(r18)
8111bf10:	0005883a 	mov	r2,zero
8111bf14:	003ff006 	br	8111bed8 <__reset+0xfb0fbed8>
8111bf18:	01002004 	movi	r4,128
8111bf1c:	02001004 	movi	r8,64
8111bf20:	01c00fc4 	movi	r7,63
8111bf24:	003f6106 	br	8111bcac <__reset+0xfb0fbcac>
8111bf28:	4009883a 	mov	r4,r8
8111bf2c:	003f7506 	br	8111bd04 <__reset+0xfb0fbd04>
8111bf30:	81000317 	ldw	r4,12(r16)
8111bf34:	003fde06 	br	8111beb0 <__reset+0xfb0fbeb0>
8111bf38:	81c5883a 	add	r2,r16,r7
8111bf3c:	11400117 	ldw	r5,4(r2)
8111bf40:	9009883a 	mov	r4,r18
8111bf44:	29400054 	ori	r5,r5,1
8111bf48:	11400115 	stw	r5,4(r2)
8111bf4c:	1132b500 	call	81132b50 <__malloc_unlock>
8111bf50:	80800204 	addi	r2,r16,8
8111bf54:	003fe006 	br	8111bed8 <__reset+0xfb0fbed8>
8111bf58:	9c000217 	ldw	r16,8(r19)
8111bf5c:	00bfff04 	movi	r2,-4
8111bf60:	85800117 	ldw	r22,4(r16)
8111bf64:	b0ac703a 	and	r22,r22,r2
8111bf68:	b4400336 	bltu	r22,r17,8111bf78 <_malloc_r+0x34c>
8111bf6c:	b445c83a 	sub	r2,r22,r17
8111bf70:	00c003c4 	movi	r3,15
8111bf74:	18805d16 	blt	r3,r2,8111c0ec <_malloc_r+0x4c0>
8111bf78:	05e04574 	movhi	r23,33045
8111bf7c:	00a04574 	movhi	r2,33045
8111bf80:	10b3be04 	addi	r2,r2,-12552
8111bf84:	bdf34f04 	addi	r23,r23,-12996
8111bf88:	15400017 	ldw	r21,0(r2)
8111bf8c:	b8c00017 	ldw	r3,0(r23)
8111bf90:	00bfffc4 	movi	r2,-1
8111bf94:	858d883a 	add	r6,r16,r22
8111bf98:	8d6b883a 	add	r21,r17,r21
8111bf9c:	1880ea26 	beq	r3,r2,8111c348 <_malloc_r+0x71c>
8111bfa0:	ad4403c4 	addi	r21,r21,4111
8111bfa4:	00bc0004 	movi	r2,-4096
8111bfa8:	a8aa703a 	and	r21,r21,r2
8111bfac:	a80b883a 	mov	r5,r21
8111bfb0:	9009883a 	mov	r4,r18
8111bfb4:	d9800015 	stw	r6,0(sp)
8111bfb8:	111cbe80 	call	8111cbe8 <_sbrk_r>
8111bfbc:	1029883a 	mov	r20,r2
8111bfc0:	00bfffc4 	movi	r2,-1
8111bfc4:	d9800017 	ldw	r6,0(sp)
8111bfc8:	a080e826 	beq	r20,r2,8111c36c <_malloc_r+0x740>
8111bfcc:	a180a636 	bltu	r20,r6,8111c268 <_malloc_r+0x63c>
8111bfd0:	07204574 	movhi	fp,33045
8111bfd4:	e7344b04 	addi	fp,fp,-11988
8111bfd8:	e0800017 	ldw	r2,0(fp)
8111bfdc:	a887883a 	add	r3,r21,r2
8111bfe0:	e0c00015 	stw	r3,0(fp)
8111bfe4:	3500e626 	beq	r6,r20,8111c380 <_malloc_r+0x754>
8111bfe8:	b9000017 	ldw	r4,0(r23)
8111bfec:	00bfffc4 	movi	r2,-1
8111bff0:	2080ee26 	beq	r4,r2,8111c3ac <_malloc_r+0x780>
8111bff4:	a185c83a 	sub	r2,r20,r6
8111bff8:	10c5883a 	add	r2,r2,r3
8111bffc:	e0800015 	stw	r2,0(fp)
8111c000:	a0c001cc 	andi	r3,r20,7
8111c004:	1800bc26 	beq	r3,zero,8111c2f8 <_malloc_r+0x6cc>
8111c008:	a0e9c83a 	sub	r20,r20,r3
8111c00c:	00840204 	movi	r2,4104
8111c010:	a5000204 	addi	r20,r20,8
8111c014:	10c7c83a 	sub	r3,r2,r3
8111c018:	a545883a 	add	r2,r20,r21
8111c01c:	1083ffcc 	andi	r2,r2,4095
8111c020:	18abc83a 	sub	r21,r3,r2
8111c024:	a80b883a 	mov	r5,r21
8111c028:	9009883a 	mov	r4,r18
8111c02c:	111cbe80 	call	8111cbe8 <_sbrk_r>
8111c030:	00ffffc4 	movi	r3,-1
8111c034:	10c0e126 	beq	r2,r3,8111c3bc <_malloc_r+0x790>
8111c038:	1505c83a 	sub	r2,r2,r20
8111c03c:	1545883a 	add	r2,r2,r21
8111c040:	10800054 	ori	r2,r2,1
8111c044:	e0c00017 	ldw	r3,0(fp)
8111c048:	9d000215 	stw	r20,8(r19)
8111c04c:	a0800115 	stw	r2,4(r20)
8111c050:	a8c7883a 	add	r3,r21,r3
8111c054:	e0c00015 	stw	r3,0(fp)
8111c058:	84c00e26 	beq	r16,r19,8111c094 <_malloc_r+0x468>
8111c05c:	018003c4 	movi	r6,15
8111c060:	3580a72e 	bgeu	r6,r22,8111c300 <_malloc_r+0x6d4>
8111c064:	81400117 	ldw	r5,4(r16)
8111c068:	013ffe04 	movi	r4,-8
8111c06c:	b0bffd04 	addi	r2,r22,-12
8111c070:	1104703a 	and	r2,r2,r4
8111c074:	2900004c 	andi	r4,r5,1
8111c078:	2088b03a 	or	r4,r4,r2
8111c07c:	81000115 	stw	r4,4(r16)
8111c080:	01400144 	movi	r5,5
8111c084:	8089883a 	add	r4,r16,r2
8111c088:	21400115 	stw	r5,4(r4)
8111c08c:	21400215 	stw	r5,8(r4)
8111c090:	3080cd36 	bltu	r6,r2,8111c3c8 <_malloc_r+0x79c>
8111c094:	00a04574 	movhi	r2,33045
8111c098:	10b3bd04 	addi	r2,r2,-12556
8111c09c:	11000017 	ldw	r4,0(r2)
8111c0a0:	20c0012e 	bgeu	r4,r3,8111c0a8 <_malloc_r+0x47c>
8111c0a4:	10c00015 	stw	r3,0(r2)
8111c0a8:	00a04574 	movhi	r2,33045
8111c0ac:	10b3bc04 	addi	r2,r2,-12560
8111c0b0:	11000017 	ldw	r4,0(r2)
8111c0b4:	9c000217 	ldw	r16,8(r19)
8111c0b8:	20c0012e 	bgeu	r4,r3,8111c0c0 <_malloc_r+0x494>
8111c0bc:	10c00015 	stw	r3,0(r2)
8111c0c0:	80c00117 	ldw	r3,4(r16)
8111c0c4:	00bfff04 	movi	r2,-4
8111c0c8:	1886703a 	and	r3,r3,r2
8111c0cc:	1c45c83a 	sub	r2,r3,r17
8111c0d0:	1c400236 	bltu	r3,r17,8111c0dc <_malloc_r+0x4b0>
8111c0d4:	00c003c4 	movi	r3,15
8111c0d8:	18800416 	blt	r3,r2,8111c0ec <_malloc_r+0x4c0>
8111c0dc:	9009883a 	mov	r4,r18
8111c0e0:	1132b500 	call	81132b50 <__malloc_unlock>
8111c0e4:	0005883a 	mov	r2,zero
8111c0e8:	003f7b06 	br	8111bed8 <__reset+0xfb0fbed8>
8111c0ec:	88c00054 	ori	r3,r17,1
8111c0f0:	80c00115 	stw	r3,4(r16)
8111c0f4:	8463883a 	add	r17,r16,r17
8111c0f8:	10800054 	ori	r2,r2,1
8111c0fc:	9c400215 	stw	r17,8(r19)
8111c100:	88800115 	stw	r2,4(r17)
8111c104:	9009883a 	mov	r4,r18
8111c108:	1132b500 	call	81132b50 <__malloc_unlock>
8111c10c:	80800204 	addi	r2,r16,8
8111c110:	003f7106 	br	8111bed8 <__reset+0xfb0fbed8>
8111c114:	00c00504 	movi	r3,20
8111c118:	18804a2e 	bgeu	r3,r2,8111c244 <_malloc_r+0x618>
8111c11c:	00c01504 	movi	r3,84
8111c120:	18806e36 	bltu	r3,r2,8111c2dc <_malloc_r+0x6b0>
8111c124:	8804d33a 	srli	r2,r17,12
8111c128:	12001bc4 	addi	r8,r2,111
8111c12c:	11c01b84 	addi	r7,r2,110
8111c130:	4209883a 	add	r4,r8,r8
8111c134:	003edd06 	br	8111bcac <__reset+0xfb0fbcac>
8111c138:	3804d27a 	srli	r2,r7,9
8111c13c:	00c00104 	movi	r3,4
8111c140:	1880442e 	bgeu	r3,r2,8111c254 <_malloc_r+0x628>
8111c144:	00c00504 	movi	r3,20
8111c148:	18808136 	bltu	r3,r2,8111c350 <_malloc_r+0x724>
8111c14c:	11401704 	addi	r5,r2,92
8111c150:	10c016c4 	addi	r3,r2,91
8111c154:	294b883a 	add	r5,r5,r5
8111c158:	294b883a 	add	r5,r5,r5
8111c15c:	294b883a 	add	r5,r5,r5
8111c160:	994b883a 	add	r5,r19,r5
8111c164:	28800017 	ldw	r2,0(r5)
8111c168:	01a04574 	movhi	r6,33045
8111c16c:	297ffe04 	addi	r5,r5,-8
8111c170:	31ad0c04 	addi	r6,r6,-19408
8111c174:	28806526 	beq	r5,r2,8111c30c <_malloc_r+0x6e0>
8111c178:	01bfff04 	movi	r6,-4
8111c17c:	10c00117 	ldw	r3,4(r2)
8111c180:	1986703a 	and	r3,r3,r6
8111c184:	38c0022e 	bgeu	r7,r3,8111c190 <_malloc_r+0x564>
8111c188:	10800217 	ldw	r2,8(r2)
8111c18c:	28bffb1e 	bne	r5,r2,8111c17c <__reset+0xfb0fc17c>
8111c190:	11400317 	ldw	r5,12(r2)
8111c194:	98c00117 	ldw	r3,4(r19)
8111c198:	81400315 	stw	r5,12(r16)
8111c19c:	80800215 	stw	r2,8(r16)
8111c1a0:	2c000215 	stw	r16,8(r5)
8111c1a4:	14000315 	stw	r16,12(r2)
8111c1a8:	003ef806 	br	8111bd8c <__reset+0xfb0fbd8c>
8111c1ac:	88c00054 	ori	r3,r17,1
8111c1b0:	80c00115 	stw	r3,4(r16)
8111c1b4:	8463883a 	add	r17,r16,r17
8111c1b8:	34400515 	stw	r17,20(r6)
8111c1bc:	34400415 	stw	r17,16(r6)
8111c1c0:	10c00054 	ori	r3,r2,1
8111c1c4:	8a000315 	stw	r8,12(r17)
8111c1c8:	8a000215 	stw	r8,8(r17)
8111c1cc:	88c00115 	stw	r3,4(r17)
8111c1d0:	88a3883a 	add	r17,r17,r2
8111c1d4:	88800015 	stw	r2,0(r17)
8111c1d8:	9009883a 	mov	r4,r18
8111c1dc:	1132b500 	call	81132b50 <__malloc_unlock>
8111c1e0:	80800204 	addi	r2,r16,8
8111c1e4:	003f3c06 	br	8111bed8 <__reset+0xfb0fbed8>
8111c1e8:	30c00117 	ldw	r3,4(r6)
8111c1ec:	003ee706 	br	8111bd8c <__reset+0xfb0fbd8c>
8111c1f0:	5ac00044 	addi	r11,r11,1
8111c1f4:	588000cc 	andi	r2,r11,3
8111c1f8:	31800204 	addi	r6,r6,8
8111c1fc:	103efd1e 	bne	r2,zero,8111bdf4 <__reset+0xfb0fbdf4>
8111c200:	00002406 	br	8111c294 <_malloc_r+0x668>
8111c204:	14000317 	ldw	r16,12(r2)
8111c208:	143f251e 	bne	r2,r16,8111bea0 <__reset+0xfb0fbea0>
8111c20c:	21000084 	addi	r4,r4,2
8111c210:	003ebc06 	br	8111bd04 <__reset+0xfb0fbd04>
8111c214:	8085883a 	add	r2,r16,r2
8111c218:	10c00117 	ldw	r3,4(r2)
8111c21c:	81000317 	ldw	r4,12(r16)
8111c220:	81400217 	ldw	r5,8(r16)
8111c224:	18c00054 	ori	r3,r3,1
8111c228:	10c00115 	stw	r3,4(r2)
8111c22c:	29000315 	stw	r4,12(r5)
8111c230:	21400215 	stw	r5,8(r4)
8111c234:	9009883a 	mov	r4,r18
8111c238:	1132b500 	call	81132b50 <__malloc_unlock>
8111c23c:	80800204 	addi	r2,r16,8
8111c240:	003f2506 	br	8111bed8 <__reset+0xfb0fbed8>
8111c244:	12001704 	addi	r8,r2,92
8111c248:	11c016c4 	addi	r7,r2,91
8111c24c:	4209883a 	add	r4,r8,r8
8111c250:	003e9606 	br	8111bcac <__reset+0xfb0fbcac>
8111c254:	3804d1ba 	srli	r2,r7,6
8111c258:	11400e44 	addi	r5,r2,57
8111c25c:	10c00e04 	addi	r3,r2,56
8111c260:	294b883a 	add	r5,r5,r5
8111c264:	003fbc06 	br	8111c158 <__reset+0xfb0fc158>
8111c268:	84ff5926 	beq	r16,r19,8111bfd0 <__reset+0xfb0fbfd0>
8111c26c:	00a04574 	movhi	r2,33045
8111c270:	10ad0c04 	addi	r2,r2,-19408
8111c274:	14000217 	ldw	r16,8(r2)
8111c278:	00bfff04 	movi	r2,-4
8111c27c:	80c00117 	ldw	r3,4(r16)
8111c280:	1886703a 	and	r3,r3,r2
8111c284:	003f9106 	br	8111c0cc <__reset+0xfb0fc0cc>
8111c288:	60800217 	ldw	r2,8(r12)
8111c28c:	213fffc4 	addi	r4,r4,-1
8111c290:	1300651e 	bne	r2,r12,8111c428 <_malloc_r+0x7fc>
8111c294:	208000cc 	andi	r2,r4,3
8111c298:	633ffe04 	addi	r12,r12,-8
8111c29c:	103ffa1e 	bne	r2,zero,8111c288 <__reset+0xfb0fc288>
8111c2a0:	98800117 	ldw	r2,4(r19)
8111c2a4:	0146303a 	nor	r3,zero,r5
8111c2a8:	1884703a 	and	r2,r3,r2
8111c2ac:	98800115 	stw	r2,4(r19)
8111c2b0:	294b883a 	add	r5,r5,r5
8111c2b4:	117f2836 	bltu	r2,r5,8111bf58 <__reset+0xfb0fbf58>
8111c2b8:	283f2726 	beq	r5,zero,8111bf58 <__reset+0xfb0fbf58>
8111c2bc:	2886703a 	and	r3,r5,r2
8111c2c0:	5809883a 	mov	r4,r11
8111c2c4:	183ec31e 	bne	r3,zero,8111bdd4 <__reset+0xfb0fbdd4>
8111c2c8:	294b883a 	add	r5,r5,r5
8111c2cc:	2886703a 	and	r3,r5,r2
8111c2d0:	21000104 	addi	r4,r4,4
8111c2d4:	183ffc26 	beq	r3,zero,8111c2c8 <__reset+0xfb0fc2c8>
8111c2d8:	003ebe06 	br	8111bdd4 <__reset+0xfb0fbdd4>
8111c2dc:	00c05504 	movi	r3,340
8111c2e0:	18801236 	bltu	r3,r2,8111c32c <_malloc_r+0x700>
8111c2e4:	8804d3fa 	srli	r2,r17,15
8111c2e8:	12001e04 	addi	r8,r2,120
8111c2ec:	11c01dc4 	addi	r7,r2,119
8111c2f0:	4209883a 	add	r4,r8,r8
8111c2f4:	003e6d06 	br	8111bcac <__reset+0xfb0fbcac>
8111c2f8:	00c40004 	movi	r3,4096
8111c2fc:	003f4606 	br	8111c018 <__reset+0xfb0fc018>
8111c300:	00800044 	movi	r2,1
8111c304:	a0800115 	stw	r2,4(r20)
8111c308:	003f7406 	br	8111c0dc <__reset+0xfb0fc0dc>
8111c30c:	1805d0ba 	srai	r2,r3,2
8111c310:	01c00044 	movi	r7,1
8111c314:	30c00117 	ldw	r3,4(r6)
8111c318:	388e983a 	sll	r7,r7,r2
8111c31c:	2805883a 	mov	r2,r5
8111c320:	38c6b03a 	or	r3,r7,r3
8111c324:	30c00115 	stw	r3,4(r6)
8111c328:	003f9b06 	br	8111c198 <__reset+0xfb0fc198>
8111c32c:	00c15504 	movi	r3,1364
8111c330:	18801a36 	bltu	r3,r2,8111c39c <_malloc_r+0x770>
8111c334:	8804d4ba 	srli	r2,r17,18
8111c338:	12001f44 	addi	r8,r2,125
8111c33c:	11c01f04 	addi	r7,r2,124
8111c340:	4209883a 	add	r4,r8,r8
8111c344:	003e5906 	br	8111bcac <__reset+0xfb0fbcac>
8111c348:	ad400404 	addi	r21,r21,16
8111c34c:	003f1706 	br	8111bfac <__reset+0xfb0fbfac>
8111c350:	00c01504 	movi	r3,84
8111c354:	18802336 	bltu	r3,r2,8111c3e4 <_malloc_r+0x7b8>
8111c358:	3804d33a 	srli	r2,r7,12
8111c35c:	11401bc4 	addi	r5,r2,111
8111c360:	10c01b84 	addi	r3,r2,110
8111c364:	294b883a 	add	r5,r5,r5
8111c368:	003f7b06 	br	8111c158 <__reset+0xfb0fc158>
8111c36c:	9c000217 	ldw	r16,8(r19)
8111c370:	00bfff04 	movi	r2,-4
8111c374:	80c00117 	ldw	r3,4(r16)
8111c378:	1886703a 	and	r3,r3,r2
8111c37c:	003f5306 	br	8111c0cc <__reset+0xfb0fc0cc>
8111c380:	3083ffcc 	andi	r2,r6,4095
8111c384:	103f181e 	bne	r2,zero,8111bfe8 <__reset+0xfb0fbfe8>
8111c388:	99000217 	ldw	r4,8(r19)
8111c38c:	b545883a 	add	r2,r22,r21
8111c390:	10800054 	ori	r2,r2,1
8111c394:	20800115 	stw	r2,4(r4)
8111c398:	003f3e06 	br	8111c094 <__reset+0xfb0fc094>
8111c39c:	01003f84 	movi	r4,254
8111c3a0:	02001fc4 	movi	r8,127
8111c3a4:	01c01f84 	movi	r7,126
8111c3a8:	003e4006 	br	8111bcac <__reset+0xfb0fbcac>
8111c3ac:	00a04574 	movhi	r2,33045
8111c3b0:	10b34f04 	addi	r2,r2,-12996
8111c3b4:	15000015 	stw	r20,0(r2)
8111c3b8:	003f1106 	br	8111c000 <__reset+0xfb0fc000>
8111c3bc:	00800044 	movi	r2,1
8111c3c0:	002b883a 	mov	r21,zero
8111c3c4:	003f1f06 	br	8111c044 <__reset+0xfb0fc044>
8111c3c8:	81400204 	addi	r5,r16,8
8111c3cc:	9009883a 	mov	r4,r18
8111c3d0:	11256a00 	call	811256a0 <_free_r>
8111c3d4:	00a04574 	movhi	r2,33045
8111c3d8:	10b44b04 	addi	r2,r2,-11988
8111c3dc:	10c00017 	ldw	r3,0(r2)
8111c3e0:	003f2c06 	br	8111c094 <__reset+0xfb0fc094>
8111c3e4:	00c05504 	movi	r3,340
8111c3e8:	18800536 	bltu	r3,r2,8111c400 <_malloc_r+0x7d4>
8111c3ec:	3804d3fa 	srli	r2,r7,15
8111c3f0:	11401e04 	addi	r5,r2,120
8111c3f4:	10c01dc4 	addi	r3,r2,119
8111c3f8:	294b883a 	add	r5,r5,r5
8111c3fc:	003f5606 	br	8111c158 <__reset+0xfb0fc158>
8111c400:	00c15504 	movi	r3,1364
8111c404:	18800536 	bltu	r3,r2,8111c41c <_malloc_r+0x7f0>
8111c408:	3804d4ba 	srli	r2,r7,18
8111c40c:	11401f44 	addi	r5,r2,125
8111c410:	10c01f04 	addi	r3,r2,124
8111c414:	294b883a 	add	r5,r5,r5
8111c418:	003f4f06 	br	8111c158 <__reset+0xfb0fc158>
8111c41c:	01403f84 	movi	r5,254
8111c420:	00c01f84 	movi	r3,126
8111c424:	003f4c06 	br	8111c158 <__reset+0xfb0fc158>
8111c428:	98800117 	ldw	r2,4(r19)
8111c42c:	003fa006 	br	8111c2b0 <__reset+0xfb0fc2b0>
8111c430:	8808d0fa 	srli	r4,r17,3
8111c434:	20800044 	addi	r2,r4,1
8111c438:	1085883a 	add	r2,r2,r2
8111c43c:	003e9006 	br	8111be80 <__reset+0xfb0fbe80>

8111c440 <memcpy>:
8111c440:	defffd04 	addi	sp,sp,-12
8111c444:	de00012e 	bgeu	sp,et,8111c44c <memcpy+0xc>
8111c448:	003b68fa 	trap	3
8111c44c:	00c003c4 	movi	r3,15
8111c450:	dfc00215 	stw	ra,8(sp)
8111c454:	dc400115 	stw	r17,4(sp)
8111c458:	dc000015 	stw	r16,0(sp)
8111c45c:	2005883a 	mov	r2,r4
8111c460:	1980452e 	bgeu	r3,r6,8111c578 <memcpy+0x138>
8111c464:	2906b03a 	or	r3,r5,r4
8111c468:	18c000cc 	andi	r3,r3,3
8111c46c:	1800441e 	bne	r3,zero,8111c580 <memcpy+0x140>
8111c470:	347ffc04 	addi	r17,r6,-16
8111c474:	8822d13a 	srli	r17,r17,4
8111c478:	28c00104 	addi	r3,r5,4
8111c47c:	23400104 	addi	r13,r4,4
8111c480:	8820913a 	slli	r16,r17,4
8111c484:	2b000204 	addi	r12,r5,8
8111c488:	22c00204 	addi	r11,r4,8
8111c48c:	84000504 	addi	r16,r16,20
8111c490:	2a800304 	addi	r10,r5,12
8111c494:	22400304 	addi	r9,r4,12
8111c498:	2c21883a 	add	r16,r5,r16
8111c49c:	2811883a 	mov	r8,r5
8111c4a0:	200f883a 	mov	r7,r4
8111c4a4:	41000017 	ldw	r4,0(r8)
8111c4a8:	1fc00017 	ldw	ra,0(r3)
8111c4ac:	63c00017 	ldw	r15,0(r12)
8111c4b0:	39000015 	stw	r4,0(r7)
8111c4b4:	53800017 	ldw	r14,0(r10)
8111c4b8:	6fc00015 	stw	ra,0(r13)
8111c4bc:	5bc00015 	stw	r15,0(r11)
8111c4c0:	4b800015 	stw	r14,0(r9)
8111c4c4:	18c00404 	addi	r3,r3,16
8111c4c8:	39c00404 	addi	r7,r7,16
8111c4cc:	42000404 	addi	r8,r8,16
8111c4d0:	6b400404 	addi	r13,r13,16
8111c4d4:	63000404 	addi	r12,r12,16
8111c4d8:	5ac00404 	addi	r11,r11,16
8111c4dc:	52800404 	addi	r10,r10,16
8111c4e0:	4a400404 	addi	r9,r9,16
8111c4e4:	1c3fef1e 	bne	r3,r16,8111c4a4 <__reset+0xfb0fc4a4>
8111c4e8:	89c00044 	addi	r7,r17,1
8111c4ec:	380e913a 	slli	r7,r7,4
8111c4f0:	310003cc 	andi	r4,r6,15
8111c4f4:	02c000c4 	movi	r11,3
8111c4f8:	11c7883a 	add	r3,r2,r7
8111c4fc:	29cb883a 	add	r5,r5,r7
8111c500:	5900212e 	bgeu	r11,r4,8111c588 <memcpy+0x148>
8111c504:	1813883a 	mov	r9,r3
8111c508:	2811883a 	mov	r8,r5
8111c50c:	200f883a 	mov	r7,r4
8111c510:	42800017 	ldw	r10,0(r8)
8111c514:	4a400104 	addi	r9,r9,4
8111c518:	39ffff04 	addi	r7,r7,-4
8111c51c:	4abfff15 	stw	r10,-4(r9)
8111c520:	42000104 	addi	r8,r8,4
8111c524:	59fffa36 	bltu	r11,r7,8111c510 <__reset+0xfb0fc510>
8111c528:	213fff04 	addi	r4,r4,-4
8111c52c:	2008d0ba 	srli	r4,r4,2
8111c530:	318000cc 	andi	r6,r6,3
8111c534:	21000044 	addi	r4,r4,1
8111c538:	2109883a 	add	r4,r4,r4
8111c53c:	2109883a 	add	r4,r4,r4
8111c540:	1907883a 	add	r3,r3,r4
8111c544:	290b883a 	add	r5,r5,r4
8111c548:	30000626 	beq	r6,zero,8111c564 <memcpy+0x124>
8111c54c:	198d883a 	add	r6,r3,r6
8111c550:	29c00003 	ldbu	r7,0(r5)
8111c554:	18c00044 	addi	r3,r3,1
8111c558:	29400044 	addi	r5,r5,1
8111c55c:	19ffffc5 	stb	r7,-1(r3)
8111c560:	19bffb1e 	bne	r3,r6,8111c550 <__reset+0xfb0fc550>
8111c564:	dfc00217 	ldw	ra,8(sp)
8111c568:	dc400117 	ldw	r17,4(sp)
8111c56c:	dc000017 	ldw	r16,0(sp)
8111c570:	dec00304 	addi	sp,sp,12
8111c574:	f800283a 	ret
8111c578:	2007883a 	mov	r3,r4
8111c57c:	003ff206 	br	8111c548 <__reset+0xfb0fc548>
8111c580:	2007883a 	mov	r3,r4
8111c584:	003ff106 	br	8111c54c <__reset+0xfb0fc54c>
8111c588:	200d883a 	mov	r6,r4
8111c58c:	003fee06 	br	8111c548 <__reset+0xfb0fc548>

8111c590 <memset>:
8111c590:	20c000cc 	andi	r3,r4,3
8111c594:	2005883a 	mov	r2,r4
8111c598:	18004426 	beq	r3,zero,8111c6ac <memset+0x11c>
8111c59c:	31ffffc4 	addi	r7,r6,-1
8111c5a0:	30004026 	beq	r6,zero,8111c6a4 <memset+0x114>
8111c5a4:	2813883a 	mov	r9,r5
8111c5a8:	200d883a 	mov	r6,r4
8111c5ac:	2007883a 	mov	r3,r4
8111c5b0:	00000406 	br	8111c5c4 <memset+0x34>
8111c5b4:	3a3fffc4 	addi	r8,r7,-1
8111c5b8:	31800044 	addi	r6,r6,1
8111c5bc:	38003926 	beq	r7,zero,8111c6a4 <memset+0x114>
8111c5c0:	400f883a 	mov	r7,r8
8111c5c4:	18c00044 	addi	r3,r3,1
8111c5c8:	32400005 	stb	r9,0(r6)
8111c5cc:	1a0000cc 	andi	r8,r3,3
8111c5d0:	403ff81e 	bne	r8,zero,8111c5b4 <__reset+0xfb0fc5b4>
8111c5d4:	010000c4 	movi	r4,3
8111c5d8:	21c02d2e 	bgeu	r4,r7,8111c690 <memset+0x100>
8111c5dc:	29003fcc 	andi	r4,r5,255
8111c5e0:	200c923a 	slli	r6,r4,8
8111c5e4:	3108b03a 	or	r4,r6,r4
8111c5e8:	200c943a 	slli	r6,r4,16
8111c5ec:	218cb03a 	or	r6,r4,r6
8111c5f0:	010003c4 	movi	r4,15
8111c5f4:	21c0182e 	bgeu	r4,r7,8111c658 <memset+0xc8>
8111c5f8:	3b3ffc04 	addi	r12,r7,-16
8111c5fc:	6018d13a 	srli	r12,r12,4
8111c600:	1a000104 	addi	r8,r3,4
8111c604:	1ac00204 	addi	r11,r3,8
8111c608:	6008913a 	slli	r4,r12,4
8111c60c:	1a800304 	addi	r10,r3,12
8111c610:	1813883a 	mov	r9,r3
8111c614:	21000504 	addi	r4,r4,20
8111c618:	1909883a 	add	r4,r3,r4
8111c61c:	49800015 	stw	r6,0(r9)
8111c620:	41800015 	stw	r6,0(r8)
8111c624:	59800015 	stw	r6,0(r11)
8111c628:	51800015 	stw	r6,0(r10)
8111c62c:	42000404 	addi	r8,r8,16
8111c630:	4a400404 	addi	r9,r9,16
8111c634:	5ac00404 	addi	r11,r11,16
8111c638:	52800404 	addi	r10,r10,16
8111c63c:	413ff71e 	bne	r8,r4,8111c61c <__reset+0xfb0fc61c>
8111c640:	63000044 	addi	r12,r12,1
8111c644:	6018913a 	slli	r12,r12,4
8111c648:	39c003cc 	andi	r7,r7,15
8111c64c:	010000c4 	movi	r4,3
8111c650:	1b07883a 	add	r3,r3,r12
8111c654:	21c00e2e 	bgeu	r4,r7,8111c690 <memset+0x100>
8111c658:	1813883a 	mov	r9,r3
8111c65c:	3811883a 	mov	r8,r7
8111c660:	010000c4 	movi	r4,3
8111c664:	49800015 	stw	r6,0(r9)
8111c668:	423fff04 	addi	r8,r8,-4
8111c66c:	4a400104 	addi	r9,r9,4
8111c670:	223ffc36 	bltu	r4,r8,8111c664 <__reset+0xfb0fc664>
8111c674:	393fff04 	addi	r4,r7,-4
8111c678:	2008d0ba 	srli	r4,r4,2
8111c67c:	39c000cc 	andi	r7,r7,3
8111c680:	21000044 	addi	r4,r4,1
8111c684:	2109883a 	add	r4,r4,r4
8111c688:	2109883a 	add	r4,r4,r4
8111c68c:	1907883a 	add	r3,r3,r4
8111c690:	38000526 	beq	r7,zero,8111c6a8 <memset+0x118>
8111c694:	19cf883a 	add	r7,r3,r7
8111c698:	19400005 	stb	r5,0(r3)
8111c69c:	18c00044 	addi	r3,r3,1
8111c6a0:	38fffd1e 	bne	r7,r3,8111c698 <__reset+0xfb0fc698>
8111c6a4:	f800283a 	ret
8111c6a8:	f800283a 	ret
8111c6ac:	2007883a 	mov	r3,r4
8111c6b0:	300f883a 	mov	r7,r6
8111c6b4:	003fc706 	br	8111c5d4 <__reset+0xfb0fc5d4>

8111c6b8 <_open_r>:
8111c6b8:	defffd04 	addi	sp,sp,-12
8111c6bc:	de00012e 	bgeu	sp,et,8111c6c4 <_open_r+0xc>
8111c6c0:	003b68fa 	trap	3
8111c6c4:	2805883a 	mov	r2,r5
8111c6c8:	dc000015 	stw	r16,0(sp)
8111c6cc:	04204574 	movhi	r16,33045
8111c6d0:	dc400115 	stw	r17,4(sp)
8111c6d4:	300b883a 	mov	r5,r6
8111c6d8:	8433bb04 	addi	r16,r16,-12564
8111c6dc:	2023883a 	mov	r17,r4
8111c6e0:	380d883a 	mov	r6,r7
8111c6e4:	1009883a 	mov	r4,r2
8111c6e8:	dfc00215 	stw	ra,8(sp)
8111c6ec:	80000015 	stw	zero,0(r16)
8111c6f0:	11320a80 	call	811320a8 <open>
8111c6f4:	00ffffc4 	movi	r3,-1
8111c6f8:	10c00526 	beq	r2,r3,8111c710 <_open_r+0x58>
8111c6fc:	dfc00217 	ldw	ra,8(sp)
8111c700:	dc400117 	ldw	r17,4(sp)
8111c704:	dc000017 	ldw	r16,0(sp)
8111c708:	dec00304 	addi	sp,sp,12
8111c70c:	f800283a 	ret
8111c710:	80c00017 	ldw	r3,0(r16)
8111c714:	183ff926 	beq	r3,zero,8111c6fc <__reset+0xfb0fc6fc>
8111c718:	88c00015 	stw	r3,0(r17)
8111c71c:	003ff706 	br	8111c6fc <__reset+0xfb0fc6fc>

8111c720 <_printf_r>:
8111c720:	defffd04 	addi	sp,sp,-12
8111c724:	2805883a 	mov	r2,r5
8111c728:	de00012e 	bgeu	sp,et,8111c730 <_printf_r+0x10>
8111c72c:	003b68fa 	trap	3
8111c730:	dfc00015 	stw	ra,0(sp)
8111c734:	d9800115 	stw	r6,4(sp)
8111c738:	d9c00215 	stw	r7,8(sp)
8111c73c:	21400217 	ldw	r5,8(r4)
8111c740:	d9c00104 	addi	r7,sp,4
8111c744:	100d883a 	mov	r6,r2
8111c748:	111f44c0 	call	8111f44c <___vfprintf_internal_r>
8111c74c:	dfc00017 	ldw	ra,0(sp)
8111c750:	dec00304 	addi	sp,sp,12
8111c754:	f800283a 	ret

8111c758 <printf>:
8111c758:	defffc04 	addi	sp,sp,-16
8111c75c:	de00012e 	bgeu	sp,et,8111c764 <printf+0xc>
8111c760:	003b68fa 	trap	3
8111c764:	dfc00015 	stw	ra,0(sp)
8111c768:	d9400115 	stw	r5,4(sp)
8111c76c:	d9800215 	stw	r6,8(sp)
8111c770:	d9c00315 	stw	r7,12(sp)
8111c774:	00a04574 	movhi	r2,33045
8111c778:	10b34e04 	addi	r2,r2,-13000
8111c77c:	10800017 	ldw	r2,0(r2)
8111c780:	200b883a 	mov	r5,r4
8111c784:	d9800104 	addi	r6,sp,4
8111c788:	11000217 	ldw	r4,8(r2)
8111c78c:	112164c0 	call	8112164c <__vfprintf_internal>
8111c790:	dfc00017 	ldw	ra,0(sp)
8111c794:	dec00404 	addi	sp,sp,16
8111c798:	f800283a 	ret

8111c79c <_putc_r>:
8111c79c:	defffc04 	addi	sp,sp,-16
8111c7a0:	de00012e 	bgeu	sp,et,8111c7a8 <_putc_r+0xc>
8111c7a4:	003b68fa 	trap	3
8111c7a8:	dc000215 	stw	r16,8(sp)
8111c7ac:	dfc00315 	stw	ra,12(sp)
8111c7b0:	2021883a 	mov	r16,r4
8111c7b4:	20000226 	beq	r4,zero,8111c7c0 <_putc_r+0x24>
8111c7b8:	20800e17 	ldw	r2,56(r4)
8111c7bc:	10001b26 	beq	r2,zero,8111c82c <_putc_r+0x90>
8111c7c0:	30800217 	ldw	r2,8(r6)
8111c7c4:	10bfffc4 	addi	r2,r2,-1
8111c7c8:	30800215 	stw	r2,8(r6)
8111c7cc:	10000a16 	blt	r2,zero,8111c7f8 <_putc_r+0x5c>
8111c7d0:	30800017 	ldw	r2,0(r6)
8111c7d4:	11400005 	stb	r5,0(r2)
8111c7d8:	30800017 	ldw	r2,0(r6)
8111c7dc:	10c00044 	addi	r3,r2,1
8111c7e0:	30c00015 	stw	r3,0(r6)
8111c7e4:	10800003 	ldbu	r2,0(r2)
8111c7e8:	dfc00317 	ldw	ra,12(sp)
8111c7ec:	dc000217 	ldw	r16,8(sp)
8111c7f0:	dec00404 	addi	sp,sp,16
8111c7f4:	f800283a 	ret
8111c7f8:	30c00617 	ldw	r3,24(r6)
8111c7fc:	10c00616 	blt	r2,r3,8111c818 <_putc_r+0x7c>
8111c800:	30800017 	ldw	r2,0(r6)
8111c804:	00c00284 	movi	r3,10
8111c808:	11400005 	stb	r5,0(r2)
8111c80c:	30800017 	ldw	r2,0(r6)
8111c810:	11400003 	ldbu	r5,0(r2)
8111c814:	28fff11e 	bne	r5,r3,8111c7dc <__reset+0xfb0fc7dc>
8111c818:	8009883a 	mov	r4,r16
8111c81c:	dfc00317 	ldw	ra,12(sp)
8111c820:	dc000217 	ldw	r16,8(sp)
8111c824:	dec00404 	addi	sp,sp,16
8111c828:	1122fd01 	jmpi	81122fd0 <__swbuf_r>
8111c82c:	d9400015 	stw	r5,0(sp)
8111c830:	d9800115 	stw	r6,4(sp)
8111c834:	11252080 	call	81125208 <__sinit>
8111c838:	d9800117 	ldw	r6,4(sp)
8111c83c:	d9400017 	ldw	r5,0(sp)
8111c840:	003fdf06 	br	8111c7c0 <__reset+0xfb0fc7c0>

8111c844 <putc>:
8111c844:	00a04574 	movhi	r2,33045
8111c848:	defffc04 	addi	sp,sp,-16
8111c84c:	10b34e04 	addi	r2,r2,-13000
8111c850:	de00012e 	bgeu	sp,et,8111c858 <putc+0x14>
8111c854:	003b68fa 	trap	3
8111c858:	dc000115 	stw	r16,4(sp)
8111c85c:	14000017 	ldw	r16,0(r2)
8111c860:	dc400215 	stw	r17,8(sp)
8111c864:	dfc00315 	stw	ra,12(sp)
8111c868:	2023883a 	mov	r17,r4
8111c86c:	80000226 	beq	r16,zero,8111c878 <putc+0x34>
8111c870:	80800e17 	ldw	r2,56(r16)
8111c874:	10001a26 	beq	r2,zero,8111c8e0 <putc+0x9c>
8111c878:	28800217 	ldw	r2,8(r5)
8111c87c:	10bfffc4 	addi	r2,r2,-1
8111c880:	28800215 	stw	r2,8(r5)
8111c884:	10000b16 	blt	r2,zero,8111c8b4 <putc+0x70>
8111c888:	28800017 	ldw	r2,0(r5)
8111c88c:	14400005 	stb	r17,0(r2)
8111c890:	28800017 	ldw	r2,0(r5)
8111c894:	10c00044 	addi	r3,r2,1
8111c898:	28c00015 	stw	r3,0(r5)
8111c89c:	10800003 	ldbu	r2,0(r2)
8111c8a0:	dfc00317 	ldw	ra,12(sp)
8111c8a4:	dc400217 	ldw	r17,8(sp)
8111c8a8:	dc000117 	ldw	r16,4(sp)
8111c8ac:	dec00404 	addi	sp,sp,16
8111c8b0:	f800283a 	ret
8111c8b4:	28c00617 	ldw	r3,24(r5)
8111c8b8:	10c00e16 	blt	r2,r3,8111c8f4 <putc+0xb0>
8111c8bc:	28800017 	ldw	r2,0(r5)
8111c8c0:	01000284 	movi	r4,10
8111c8c4:	14400005 	stb	r17,0(r2)
8111c8c8:	28800017 	ldw	r2,0(r5)
8111c8cc:	10c00003 	ldbu	r3,0(r2)
8111c8d0:	193ff01e 	bne	r3,r4,8111c894 <__reset+0xfb0fc894>
8111c8d4:	280d883a 	mov	r6,r5
8111c8d8:	180b883a 	mov	r5,r3
8111c8dc:	00000706 	br	8111c8fc <putc+0xb8>
8111c8e0:	8009883a 	mov	r4,r16
8111c8e4:	d9400015 	stw	r5,0(sp)
8111c8e8:	11252080 	call	81125208 <__sinit>
8111c8ec:	d9400017 	ldw	r5,0(sp)
8111c8f0:	003fe106 	br	8111c878 <__reset+0xfb0fc878>
8111c8f4:	280d883a 	mov	r6,r5
8111c8f8:	880b883a 	mov	r5,r17
8111c8fc:	8009883a 	mov	r4,r16
8111c900:	dfc00317 	ldw	ra,12(sp)
8111c904:	dc400217 	ldw	r17,8(sp)
8111c908:	dc000117 	ldw	r16,4(sp)
8111c90c:	dec00404 	addi	sp,sp,16
8111c910:	1122fd01 	jmpi	81122fd0 <__swbuf_r>

8111c914 <_puts_r>:
8111c914:	defff604 	addi	sp,sp,-40
8111c918:	de00012e 	bgeu	sp,et,8111c920 <_puts_r+0xc>
8111c91c:	003b68fa 	trap	3
8111c920:	dc000715 	stw	r16,28(sp)
8111c924:	2021883a 	mov	r16,r4
8111c928:	2809883a 	mov	r4,r5
8111c92c:	dc400815 	stw	r17,32(sp)
8111c930:	dfc00915 	stw	ra,36(sp)
8111c934:	2823883a 	mov	r17,r5
8111c938:	111cf340 	call	8111cf34 <strlen>
8111c93c:	10c00044 	addi	r3,r2,1
8111c940:	d8800115 	stw	r2,4(sp)
8111c944:	00a04574 	movhi	r2,33045
8111c948:	10a97504 	addi	r2,r2,-23084
8111c94c:	d8800215 	stw	r2,8(sp)
8111c950:	00800044 	movi	r2,1
8111c954:	d8800315 	stw	r2,12(sp)
8111c958:	00800084 	movi	r2,2
8111c95c:	dc400015 	stw	r17,0(sp)
8111c960:	d8c00615 	stw	r3,24(sp)
8111c964:	dec00415 	stw	sp,16(sp)
8111c968:	d8800515 	stw	r2,20(sp)
8111c96c:	80000226 	beq	r16,zero,8111c978 <_puts_r+0x64>
8111c970:	80800e17 	ldw	r2,56(r16)
8111c974:	10001426 	beq	r2,zero,8111c9c8 <_puts_r+0xb4>
8111c978:	81400217 	ldw	r5,8(r16)
8111c97c:	2880030b 	ldhu	r2,12(r5)
8111c980:	10c8000c 	andi	r3,r2,8192
8111c984:	1800061e 	bne	r3,zero,8111c9a0 <_puts_r+0x8c>
8111c988:	29001917 	ldw	r4,100(r5)
8111c98c:	00f7ffc4 	movi	r3,-8193
8111c990:	10880014 	ori	r2,r2,8192
8111c994:	20c6703a 	and	r3,r4,r3
8111c998:	2880030d 	sth	r2,12(r5)
8111c99c:	28c01915 	stw	r3,100(r5)
8111c9a0:	d9800404 	addi	r6,sp,16
8111c9a4:	8009883a 	mov	r4,r16
8111c9a8:	11259b80 	call	811259b8 <__sfvwrite_r>
8111c9ac:	1000091e 	bne	r2,zero,8111c9d4 <_puts_r+0xc0>
8111c9b0:	00800284 	movi	r2,10
8111c9b4:	dfc00917 	ldw	ra,36(sp)
8111c9b8:	dc400817 	ldw	r17,32(sp)
8111c9bc:	dc000717 	ldw	r16,28(sp)
8111c9c0:	dec00a04 	addi	sp,sp,40
8111c9c4:	f800283a 	ret
8111c9c8:	8009883a 	mov	r4,r16
8111c9cc:	11252080 	call	81125208 <__sinit>
8111c9d0:	003fe906 	br	8111c978 <__reset+0xfb0fc978>
8111c9d4:	00bfffc4 	movi	r2,-1
8111c9d8:	003ff606 	br	8111c9b4 <__reset+0xfb0fc9b4>

8111c9dc <puts>:
8111c9dc:	00a04574 	movhi	r2,33045
8111c9e0:	10b34e04 	addi	r2,r2,-13000
8111c9e4:	200b883a 	mov	r5,r4
8111c9e8:	11000017 	ldw	r4,0(r2)
8111c9ec:	111c9141 	jmpi	8111c914 <_puts_r>

8111c9f0 <lflush>:
8111c9f0:	2080030b 	ldhu	r2,12(r4)
8111c9f4:	00c00244 	movi	r3,9
8111c9f8:	1080024c 	andi	r2,r2,9
8111c9fc:	10c00226 	beq	r2,r3,8111ca08 <lflush+0x18>
8111ca00:	0005883a 	mov	r2,zero
8111ca04:	f800283a 	ret
8111ca08:	1124e701 	jmpi	81124e70 <fflush>

8111ca0c <__srefill_r>:
8111ca0c:	defffc04 	addi	sp,sp,-16
8111ca10:	de00012e 	bgeu	sp,et,8111ca18 <__srefill_r+0xc>
8111ca14:	003b68fa 	trap	3
8111ca18:	dc400115 	stw	r17,4(sp)
8111ca1c:	dc000015 	stw	r16,0(sp)
8111ca20:	dfc00315 	stw	ra,12(sp)
8111ca24:	dc800215 	stw	r18,8(sp)
8111ca28:	2023883a 	mov	r17,r4
8111ca2c:	2821883a 	mov	r16,r5
8111ca30:	20000226 	beq	r4,zero,8111ca3c <__srefill_r+0x30>
8111ca34:	20800e17 	ldw	r2,56(r4)
8111ca38:	10003c26 	beq	r2,zero,8111cb2c <__srefill_r+0x120>
8111ca3c:	80c0030b 	ldhu	r3,12(r16)
8111ca40:	1908000c 	andi	r4,r3,8192
8111ca44:	1805883a 	mov	r2,r3
8111ca48:	2000071e 	bne	r4,zero,8111ca68 <__srefill_r+0x5c>
8111ca4c:	81001917 	ldw	r4,100(r16)
8111ca50:	18880014 	ori	r2,r3,8192
8111ca54:	00f7ffc4 	movi	r3,-8193
8111ca58:	20c8703a 	and	r4,r4,r3
8111ca5c:	8080030d 	sth	r2,12(r16)
8111ca60:	1007883a 	mov	r3,r2
8111ca64:	81001915 	stw	r4,100(r16)
8111ca68:	80000115 	stw	zero,4(r16)
8111ca6c:	1100080c 	andi	r4,r2,32
8111ca70:	2000571e 	bne	r4,zero,8111cbd0 <__srefill_r+0x1c4>
8111ca74:	1100010c 	andi	r4,r2,4
8111ca78:	20001f26 	beq	r4,zero,8111caf8 <__srefill_r+0xec>
8111ca7c:	81400c17 	ldw	r5,48(r16)
8111ca80:	28000826 	beq	r5,zero,8111caa4 <__srefill_r+0x98>
8111ca84:	80801004 	addi	r2,r16,64
8111ca88:	28800226 	beq	r5,r2,8111ca94 <__srefill_r+0x88>
8111ca8c:	8809883a 	mov	r4,r17
8111ca90:	11256a00 	call	811256a0 <_free_r>
8111ca94:	80800f17 	ldw	r2,60(r16)
8111ca98:	80000c15 	stw	zero,48(r16)
8111ca9c:	80800115 	stw	r2,4(r16)
8111caa0:	1000391e 	bne	r2,zero,8111cb88 <__srefill_r+0x17c>
8111caa4:	80800417 	ldw	r2,16(r16)
8111caa8:	10004b26 	beq	r2,zero,8111cbd8 <__srefill_r+0x1cc>
8111caac:	8480030b 	ldhu	r18,12(r16)
8111cab0:	908000cc 	andi	r2,r18,3
8111cab4:	10001f1e 	bne	r2,zero,8111cb34 <__srefill_r+0x128>
8111cab8:	81800417 	ldw	r6,16(r16)
8111cabc:	80800817 	ldw	r2,32(r16)
8111cac0:	81c00517 	ldw	r7,20(r16)
8111cac4:	81400717 	ldw	r5,28(r16)
8111cac8:	81800015 	stw	r6,0(r16)
8111cacc:	8809883a 	mov	r4,r17
8111cad0:	103ee83a 	callr	r2
8111cad4:	80800115 	stw	r2,4(r16)
8111cad8:	00800e0e 	bge	zero,r2,8111cb14 <__srefill_r+0x108>
8111cadc:	0005883a 	mov	r2,zero
8111cae0:	dfc00317 	ldw	ra,12(sp)
8111cae4:	dc800217 	ldw	r18,8(sp)
8111cae8:	dc400117 	ldw	r17,4(sp)
8111caec:	dc000017 	ldw	r16,0(sp)
8111caf0:	dec00404 	addi	sp,sp,16
8111caf4:	f800283a 	ret
8111caf8:	1100040c 	andi	r4,r2,16
8111cafc:	20003026 	beq	r4,zero,8111cbc0 <__srefill_r+0x1b4>
8111cb00:	1080020c 	andi	r2,r2,8
8111cb04:	1000241e 	bne	r2,zero,8111cb98 <__srefill_r+0x18c>
8111cb08:	18c00114 	ori	r3,r3,4
8111cb0c:	80c0030d 	sth	r3,12(r16)
8111cb10:	003fe406 	br	8111caa4 <__reset+0xfb0fcaa4>
8111cb14:	80c0030b 	ldhu	r3,12(r16)
8111cb18:	1000161e 	bne	r2,zero,8111cb74 <__srefill_r+0x168>
8111cb1c:	18c00814 	ori	r3,r3,32
8111cb20:	00bfffc4 	movi	r2,-1
8111cb24:	80c0030d 	sth	r3,12(r16)
8111cb28:	003fed06 	br	8111cae0 <__reset+0xfb0fcae0>
8111cb2c:	11252080 	call	81125208 <__sinit>
8111cb30:	003fc206 	br	8111ca3c <__reset+0xfb0fca3c>
8111cb34:	00a04574 	movhi	r2,33045
8111cb38:	10b34d04 	addi	r2,r2,-13004
8111cb3c:	11000017 	ldw	r4,0(r2)
8111cb40:	016044b4 	movhi	r5,33042
8111cb44:	00800044 	movi	r2,1
8111cb48:	29727c04 	addi	r5,r5,-13840
8111cb4c:	8080030d 	sth	r2,12(r16)
8111cb50:	1125e7c0 	call	81125e7c <_fwalk>
8111cb54:	00800244 	movi	r2,9
8111cb58:	8480030d 	sth	r18,12(r16)
8111cb5c:	9480024c 	andi	r18,r18,9
8111cb60:	90bfd51e 	bne	r18,r2,8111cab8 <__reset+0xfb0fcab8>
8111cb64:	800b883a 	mov	r5,r16
8111cb68:	8809883a 	mov	r4,r17
8111cb6c:	1124be80 	call	81124be8 <__sflush_r>
8111cb70:	003fd106 	br	8111cab8 <__reset+0xfb0fcab8>
8111cb74:	18c01014 	ori	r3,r3,64
8111cb78:	80000115 	stw	zero,4(r16)
8111cb7c:	00bfffc4 	movi	r2,-1
8111cb80:	80c0030d 	sth	r3,12(r16)
8111cb84:	003fd606 	br	8111cae0 <__reset+0xfb0fcae0>
8111cb88:	80c00e17 	ldw	r3,56(r16)
8111cb8c:	0005883a 	mov	r2,zero
8111cb90:	80c00015 	stw	r3,0(r16)
8111cb94:	003fd206 	br	8111cae0 <__reset+0xfb0fcae0>
8111cb98:	800b883a 	mov	r5,r16
8111cb9c:	8809883a 	mov	r4,r17
8111cba0:	1124e0c0 	call	81124e0c <_fflush_r>
8111cba4:	10000a1e 	bne	r2,zero,8111cbd0 <__srefill_r+0x1c4>
8111cba8:	8080030b 	ldhu	r2,12(r16)
8111cbac:	00fffdc4 	movi	r3,-9
8111cbb0:	80000215 	stw	zero,8(r16)
8111cbb4:	1886703a 	and	r3,r3,r2
8111cbb8:	80000615 	stw	zero,24(r16)
8111cbbc:	003fd206 	br	8111cb08 <__reset+0xfb0fcb08>
8111cbc0:	00800244 	movi	r2,9
8111cbc4:	88800015 	stw	r2,0(r17)
8111cbc8:	18c01014 	ori	r3,r3,64
8111cbcc:	80c0030d 	sth	r3,12(r16)
8111cbd0:	00bfffc4 	movi	r2,-1
8111cbd4:	003fc206 	br	8111cae0 <__reset+0xfb0fcae0>
8111cbd8:	800b883a 	mov	r5,r16
8111cbdc:	8809883a 	mov	r4,r17
8111cbe0:	111ba680 	call	8111ba68 <__smakebuf_r>
8111cbe4:	003fb106 	br	8111caac <__reset+0xfb0fcaac>

8111cbe8 <_sbrk_r>:
8111cbe8:	defffd04 	addi	sp,sp,-12
8111cbec:	de00012e 	bgeu	sp,et,8111cbf4 <_sbrk_r+0xc>
8111cbf0:	003b68fa 	trap	3
8111cbf4:	dc000015 	stw	r16,0(sp)
8111cbf8:	04204574 	movhi	r16,33045
8111cbfc:	dc400115 	stw	r17,4(sp)
8111cc00:	8433bb04 	addi	r16,r16,-12564
8111cc04:	2023883a 	mov	r17,r4
8111cc08:	2809883a 	mov	r4,r5
8111cc0c:	dfc00215 	stw	ra,8(sp)
8111cc10:	80000015 	stw	zero,0(r16)
8111cc14:	11323b80 	call	811323b8 <sbrk>
8111cc18:	00ffffc4 	movi	r3,-1
8111cc1c:	10c00526 	beq	r2,r3,8111cc34 <_sbrk_r+0x4c>
8111cc20:	dfc00217 	ldw	ra,8(sp)
8111cc24:	dc400117 	ldw	r17,4(sp)
8111cc28:	dc000017 	ldw	r16,0(sp)
8111cc2c:	dec00304 	addi	sp,sp,12
8111cc30:	f800283a 	ret
8111cc34:	80c00017 	ldw	r3,0(r16)
8111cc38:	183ff926 	beq	r3,zero,8111cc20 <__reset+0xfb0fcc20>
8111cc3c:	88c00015 	stw	r3,0(r17)
8111cc40:	003ff706 	br	8111cc20 <__reset+0xfb0fcc20>

8111cc44 <scanf>:
8111cc44:	defffc04 	addi	sp,sp,-16
8111cc48:	de00012e 	bgeu	sp,et,8111cc50 <scanf+0xc>
8111cc4c:	003b68fa 	trap	3
8111cc50:	dfc00015 	stw	ra,0(sp)
8111cc54:	d9400115 	stw	r5,4(sp)
8111cc58:	d9800215 	stw	r6,8(sp)
8111cc5c:	d9c00315 	stw	r7,12(sp)
8111cc60:	00a04574 	movhi	r2,33045
8111cc64:	10b34e04 	addi	r2,r2,-13000
8111cc68:	200d883a 	mov	r6,r4
8111cc6c:	11000017 	ldw	r4,0(r2)
8111cc70:	d9c00104 	addi	r7,sp,4
8111cc74:	21400117 	ldw	r5,4(r4)
8111cc78:	1122f7c0 	call	81122f7c <_vfscanf_r>
8111cc7c:	dfc00017 	ldw	ra,0(sp)
8111cc80:	dec00404 	addi	sp,sp,16
8111cc84:	f800283a 	ret

8111cc88 <_scanf_r>:
8111cc88:	defffd04 	addi	sp,sp,-12
8111cc8c:	2805883a 	mov	r2,r5
8111cc90:	de00012e 	bgeu	sp,et,8111cc98 <_scanf_r+0x10>
8111cc94:	003b68fa 	trap	3
8111cc98:	dfc00015 	stw	ra,0(sp)
8111cc9c:	d9800115 	stw	r6,4(sp)
8111cca0:	d9c00215 	stw	r7,8(sp)
8111cca4:	21400117 	ldw	r5,4(r4)
8111cca8:	d9c00104 	addi	r7,sp,4
8111ccac:	100d883a 	mov	r6,r2
8111ccb0:	1122f7c0 	call	81122f7c <_vfscanf_r>
8111ccb4:	dfc00017 	ldw	ra,0(sp)
8111ccb8:	dec00304 	addi	sp,sp,12
8111ccbc:	f800283a 	ret

8111ccc0 <_sprintf_r>:
8111ccc0:	deffe404 	addi	sp,sp,-112
8111ccc4:	2807883a 	mov	r3,r5
8111ccc8:	de00012e 	bgeu	sp,et,8111ccd0 <_sprintf_r+0x10>
8111cccc:	003b68fa 	trap	3
8111ccd0:	dfc01a15 	stw	ra,104(sp)
8111ccd4:	d9c01b15 	stw	r7,108(sp)
8111ccd8:	00a00034 	movhi	r2,32768
8111ccdc:	10bfffc4 	addi	r2,r2,-1
8111cce0:	02008204 	movi	r8,520
8111cce4:	d8800215 	stw	r2,8(sp)
8111cce8:	d8800515 	stw	r2,20(sp)
8111ccec:	d9c01b04 	addi	r7,sp,108
8111ccf0:	d80b883a 	mov	r5,sp
8111ccf4:	00bfffc4 	movi	r2,-1
8111ccf8:	d8c00015 	stw	r3,0(sp)
8111ccfc:	d8c00415 	stw	r3,16(sp)
8111cd00:	da00030d 	sth	r8,12(sp)
8111cd04:	d880038d 	sth	r2,14(sp)
8111cd08:	111d26c0 	call	8111d26c <___svfprintf_internal_r>
8111cd0c:	d8c00017 	ldw	r3,0(sp)
8111cd10:	18000005 	stb	zero,0(r3)
8111cd14:	dfc01a17 	ldw	ra,104(sp)
8111cd18:	dec01c04 	addi	sp,sp,112
8111cd1c:	f800283a 	ret

8111cd20 <sprintf>:
8111cd20:	deffe304 	addi	sp,sp,-116
8111cd24:	2007883a 	mov	r3,r4
8111cd28:	de00012e 	bgeu	sp,et,8111cd30 <sprintf+0x10>
8111cd2c:	003b68fa 	trap	3
8111cd30:	dfc01a15 	stw	ra,104(sp)
8111cd34:	d9801b15 	stw	r6,108(sp)
8111cd38:	d9c01c15 	stw	r7,112(sp)
8111cd3c:	01204574 	movhi	r4,33045
8111cd40:	21334e04 	addi	r4,r4,-13000
8111cd44:	21000017 	ldw	r4,0(r4)
8111cd48:	00a00034 	movhi	r2,32768
8111cd4c:	10bfffc4 	addi	r2,r2,-1
8111cd50:	280d883a 	mov	r6,r5
8111cd54:	02008204 	movi	r8,520
8111cd58:	d8800215 	stw	r2,8(sp)
8111cd5c:	d8800515 	stw	r2,20(sp)
8111cd60:	d9c01b04 	addi	r7,sp,108
8111cd64:	d80b883a 	mov	r5,sp
8111cd68:	00bfffc4 	movi	r2,-1
8111cd6c:	d8c00015 	stw	r3,0(sp)
8111cd70:	d8c00415 	stw	r3,16(sp)
8111cd74:	da00030d 	sth	r8,12(sp)
8111cd78:	d880038d 	sth	r2,14(sp)
8111cd7c:	111d26c0 	call	8111d26c <___svfprintf_internal_r>
8111cd80:	d8c00017 	ldw	r3,0(sp)
8111cd84:	18000005 	stb	zero,0(r3)
8111cd88:	dfc01a17 	ldw	ra,104(sp)
8111cd8c:	dec01d04 	addi	sp,sp,116
8111cd90:	f800283a 	ret

8111cd94 <__sread>:
8111cd94:	defffe04 	addi	sp,sp,-8
8111cd98:	de00012e 	bgeu	sp,et,8111cda0 <__sread+0xc>
8111cd9c:	003b68fa 	trap	3
8111cda0:	dc000015 	stw	r16,0(sp)
8111cda4:	2821883a 	mov	r16,r5
8111cda8:	2940038f 	ldh	r5,14(r5)
8111cdac:	dfc00115 	stw	ra,4(sp)
8111cdb0:	11276cc0 	call	811276cc <_read_r>
8111cdb4:	10000716 	blt	r2,zero,8111cdd4 <__sread+0x40>
8111cdb8:	80c01417 	ldw	r3,80(r16)
8111cdbc:	1887883a 	add	r3,r3,r2
8111cdc0:	80c01415 	stw	r3,80(r16)
8111cdc4:	dfc00117 	ldw	ra,4(sp)
8111cdc8:	dc000017 	ldw	r16,0(sp)
8111cdcc:	dec00204 	addi	sp,sp,8
8111cdd0:	f800283a 	ret
8111cdd4:	80c0030b 	ldhu	r3,12(r16)
8111cdd8:	18fbffcc 	andi	r3,r3,61439
8111cddc:	80c0030d 	sth	r3,12(r16)
8111cde0:	dfc00117 	ldw	ra,4(sp)
8111cde4:	dc000017 	ldw	r16,0(sp)
8111cde8:	dec00204 	addi	sp,sp,8
8111cdec:	f800283a 	ret

8111cdf0 <__seofread>:
8111cdf0:	0005883a 	mov	r2,zero
8111cdf4:	f800283a 	ret

8111cdf8 <__swrite>:
8111cdf8:	defffb04 	addi	sp,sp,-20
8111cdfc:	de00012e 	bgeu	sp,et,8111ce04 <__swrite+0xc>
8111ce00:	003b68fa 	trap	3
8111ce04:	2880030b 	ldhu	r2,12(r5)
8111ce08:	dcc00315 	stw	r19,12(sp)
8111ce0c:	dc800215 	stw	r18,8(sp)
8111ce10:	dc400115 	stw	r17,4(sp)
8111ce14:	dc000015 	stw	r16,0(sp)
8111ce18:	dfc00415 	stw	ra,16(sp)
8111ce1c:	10c0400c 	andi	r3,r2,256
8111ce20:	2821883a 	mov	r16,r5
8111ce24:	2023883a 	mov	r17,r4
8111ce28:	3025883a 	mov	r18,r6
8111ce2c:	3827883a 	mov	r19,r7
8111ce30:	18000526 	beq	r3,zero,8111ce48 <__swrite+0x50>
8111ce34:	2940038f 	ldh	r5,14(r5)
8111ce38:	01c00084 	movi	r7,2
8111ce3c:	000d883a 	mov	r6,zero
8111ce40:	11261840 	call	81126184 <_lseek_r>
8111ce44:	8080030b 	ldhu	r2,12(r16)
8111ce48:	8140038f 	ldh	r5,14(r16)
8111ce4c:	10bbffcc 	andi	r2,r2,61439
8111ce50:	980f883a 	mov	r7,r19
8111ce54:	900d883a 	mov	r6,r18
8111ce58:	8809883a 	mov	r4,r17
8111ce5c:	8080030d 	sth	r2,12(r16)
8111ce60:	dfc00417 	ldw	ra,16(sp)
8111ce64:	dcc00317 	ldw	r19,12(sp)
8111ce68:	dc800217 	ldw	r18,8(sp)
8111ce6c:	dc400117 	ldw	r17,4(sp)
8111ce70:	dc000017 	ldw	r16,0(sp)
8111ce74:	dec00504 	addi	sp,sp,20
8111ce78:	11231301 	jmpi	81123130 <_write_r>

8111ce7c <__sseek>:
8111ce7c:	defffe04 	addi	sp,sp,-8
8111ce80:	de00012e 	bgeu	sp,et,8111ce88 <__sseek+0xc>
8111ce84:	003b68fa 	trap	3
8111ce88:	dc000015 	stw	r16,0(sp)
8111ce8c:	2821883a 	mov	r16,r5
8111ce90:	2940038f 	ldh	r5,14(r5)
8111ce94:	dfc00115 	stw	ra,4(sp)
8111ce98:	11261840 	call	81126184 <_lseek_r>
8111ce9c:	00ffffc4 	movi	r3,-1
8111cea0:	10c00826 	beq	r2,r3,8111cec4 <__sseek+0x48>
8111cea4:	80c0030b 	ldhu	r3,12(r16)
8111cea8:	80801415 	stw	r2,80(r16)
8111ceac:	18c40014 	ori	r3,r3,4096
8111ceb0:	80c0030d 	sth	r3,12(r16)
8111ceb4:	dfc00117 	ldw	ra,4(sp)
8111ceb8:	dc000017 	ldw	r16,0(sp)
8111cebc:	dec00204 	addi	sp,sp,8
8111cec0:	f800283a 	ret
8111cec4:	80c0030b 	ldhu	r3,12(r16)
8111cec8:	18fbffcc 	andi	r3,r3,61439
8111cecc:	80c0030d 	sth	r3,12(r16)
8111ced0:	dfc00117 	ldw	ra,4(sp)
8111ced4:	dc000017 	ldw	r16,0(sp)
8111ced8:	dec00204 	addi	sp,sp,8
8111cedc:	f800283a 	ret

8111cee0 <__sclose>:
8111cee0:	2940038f 	ldh	r5,14(r5)
8111cee4:	11232f41 	jmpi	811232f4 <_close_r>

8111cee8 <strcspn>:
8111cee8:	21c00007 	ldb	r7,0(r4)
8111ceec:	38000f26 	beq	r7,zero,8111cf2c <strcspn+0x44>
8111cef0:	2a000007 	ldb	r8,0(r5)
8111cef4:	2005883a 	mov	r2,r4
8111cef8:	40000726 	beq	r8,zero,8111cf18 <strcspn+0x30>
8111cefc:	3a000926 	beq	r7,r8,8111cf24 <strcspn+0x3c>
8111cf00:	2807883a 	mov	r3,r5
8111cf04:	00000106 	br	8111cf0c <strcspn+0x24>
8111cf08:	31c00626 	beq	r6,r7,8111cf24 <strcspn+0x3c>
8111cf0c:	18c00044 	addi	r3,r3,1
8111cf10:	19800007 	ldb	r6,0(r3)
8111cf14:	303ffc1e 	bne	r6,zero,8111cf08 <__reset+0xfb0fcf08>
8111cf18:	10800044 	addi	r2,r2,1
8111cf1c:	11c00007 	ldb	r7,0(r2)
8111cf20:	383ff51e 	bne	r7,zero,8111cef8 <__reset+0xfb0fcef8>
8111cf24:	1105c83a 	sub	r2,r2,r4
8111cf28:	f800283a 	ret
8111cf2c:	0005883a 	mov	r2,zero
8111cf30:	f800283a 	ret

8111cf34 <strlen>:
8111cf34:	208000cc 	andi	r2,r4,3
8111cf38:	10002026 	beq	r2,zero,8111cfbc <strlen+0x88>
8111cf3c:	20800007 	ldb	r2,0(r4)
8111cf40:	10002026 	beq	r2,zero,8111cfc4 <strlen+0x90>
8111cf44:	2005883a 	mov	r2,r4
8111cf48:	00000206 	br	8111cf54 <strlen+0x20>
8111cf4c:	10c00007 	ldb	r3,0(r2)
8111cf50:	18001826 	beq	r3,zero,8111cfb4 <strlen+0x80>
8111cf54:	10800044 	addi	r2,r2,1
8111cf58:	10c000cc 	andi	r3,r2,3
8111cf5c:	183ffb1e 	bne	r3,zero,8111cf4c <__reset+0xfb0fcf4c>
8111cf60:	10c00017 	ldw	r3,0(r2)
8111cf64:	01ffbff4 	movhi	r7,65279
8111cf68:	39ffbfc4 	addi	r7,r7,-257
8111cf6c:	00ca303a 	nor	r5,zero,r3
8111cf70:	01a02074 	movhi	r6,32897
8111cf74:	19c7883a 	add	r3,r3,r7
8111cf78:	31a02004 	addi	r6,r6,-32640
8111cf7c:	1946703a 	and	r3,r3,r5
8111cf80:	1986703a 	and	r3,r3,r6
8111cf84:	1800091e 	bne	r3,zero,8111cfac <strlen+0x78>
8111cf88:	10800104 	addi	r2,r2,4
8111cf8c:	10c00017 	ldw	r3,0(r2)
8111cf90:	19cb883a 	add	r5,r3,r7
8111cf94:	00c6303a 	nor	r3,zero,r3
8111cf98:	28c6703a 	and	r3,r5,r3
8111cf9c:	1986703a 	and	r3,r3,r6
8111cfa0:	183ff926 	beq	r3,zero,8111cf88 <__reset+0xfb0fcf88>
8111cfa4:	00000106 	br	8111cfac <strlen+0x78>
8111cfa8:	10800044 	addi	r2,r2,1
8111cfac:	10c00007 	ldb	r3,0(r2)
8111cfb0:	183ffd1e 	bne	r3,zero,8111cfa8 <__reset+0xfb0fcfa8>
8111cfb4:	1105c83a 	sub	r2,r2,r4
8111cfb8:	f800283a 	ret
8111cfbc:	2005883a 	mov	r2,r4
8111cfc0:	003fe706 	br	8111cf60 <__reset+0xfb0fcf60>
8111cfc4:	0005883a 	mov	r2,zero
8111cfc8:	f800283a 	ret

8111cfcc <strnlen>:
8111cfcc:	28000e26 	beq	r5,zero,8111d008 <strnlen+0x3c>
8111cfd0:	20800007 	ldb	r2,0(r4)
8111cfd4:	10000c26 	beq	r2,zero,8111d008 <strnlen+0x3c>
8111cfd8:	20c00044 	addi	r3,r4,1
8111cfdc:	214b883a 	add	r5,r4,r5
8111cfe0:	28c00526 	beq	r5,r3,8111cff8 <strnlen+0x2c>
8111cfe4:	19800007 	ldb	r6,0(r3)
8111cfe8:	19c00044 	addi	r7,r3,1
8111cfec:	30000426 	beq	r6,zero,8111d000 <strnlen+0x34>
8111cff0:	3807883a 	mov	r3,r7
8111cff4:	28fffb1e 	bne	r5,r3,8111cfe4 <__reset+0xfb0fcfe4>
8111cff8:	2905c83a 	sub	r2,r5,r4
8111cffc:	f800283a 	ret
8111d000:	1905c83a 	sub	r2,r3,r4
8111d004:	f800283a 	ret
8111d008:	0005883a 	mov	r2,zero
8111d00c:	f800283a 	ret

8111d010 <_strtol_r>:
8111d010:	00a04574 	movhi	r2,33045
8111d014:	defff404 	addi	sp,sp,-48
8111d018:	10b34c04 	addi	r2,r2,-13008
8111d01c:	de00012e 	bgeu	sp,et,8111d024 <_strtol_r+0x14>
8111d020:	003b68fa 	trap	3
8111d024:	dd400715 	stw	r21,28(sp)
8111d028:	15400017 	ldw	r21,0(r2)
8111d02c:	dd800815 	stw	r22,32(sp)
8111d030:	dd000615 	stw	r20,24(sp)
8111d034:	dcc00515 	stw	r19,20(sp)
8111d038:	d9000015 	stw	r4,0(sp)
8111d03c:	dfc00b15 	stw	ra,44(sp)
8111d040:	df000a15 	stw	fp,40(sp)
8111d044:	ddc00915 	stw	r23,36(sp)
8111d048:	dc800415 	stw	r18,16(sp)
8111d04c:	dc400315 	stw	r17,12(sp)
8111d050:	dc000215 	stw	r16,8(sp)
8111d054:	2829883a 	mov	r20,r5
8111d058:	3027883a 	mov	r19,r6
8111d05c:	382d883a 	mov	r22,r7
8111d060:	2809883a 	mov	r4,r5
8111d064:	24000003 	ldbu	r16,0(r4)
8111d068:	24400044 	addi	r17,r4,1
8111d06c:	2007883a 	mov	r3,r4
8111d070:	ac05883a 	add	r2,r21,r16
8111d074:	10800043 	ldbu	r2,1(r2)
8111d078:	8809883a 	mov	r4,r17
8111d07c:	1080020c 	andi	r2,r2,8
8111d080:	103ff81e 	bne	r2,zero,8111d064 <__reset+0xfb0fd064>
8111d084:	00800b44 	movi	r2,45
8111d088:	80805826 	beq	r16,r2,8111d1ec <_strtol_r+0x1dc>
8111d08c:	00800ac4 	movi	r2,43
8111d090:	80805a26 	beq	r16,r2,8111d1fc <_strtol_r+0x1ec>
8111d094:	0039883a 	mov	fp,zero
8111d098:	b0004426 	beq	r22,zero,8111d1ac <_strtol_r+0x19c>
8111d09c:	00800404 	movi	r2,16
8111d0a0:	b0806026 	beq	r22,r2,8111d224 <_strtol_r+0x214>
8111d0a4:	b02f883a 	mov	r23,r22
8111d0a8:	00a00034 	movhi	r2,32768
8111d0ac:	e025003a 	cmpeq	r18,fp,zero
8111d0b0:	14a5c83a 	sub	r18,r2,r18
8111d0b4:	b80b883a 	mov	r5,r23
8111d0b8:	9009883a 	mov	r4,r18
8111d0bc:	112ea8c0 	call	8112ea8c <__umodsi3>
8111d0c0:	b80b883a 	mov	r5,r23
8111d0c4:	9009883a 	mov	r4,r18
8111d0c8:	d8800115 	stw	r2,4(sp)
8111d0cc:	112ea280 	call	8112ea28 <__udivsi3>
8111d0d0:	ac07883a 	add	r3,r21,r16
8111d0d4:	18c00043 	ldbu	r3,1(r3)
8111d0d8:	880b883a 	mov	r5,r17
8111d0dc:	000d883a 	mov	r6,zero
8111d0e0:	1a00010c 	andi	r8,r3,4
8111d0e4:	0009883a 	mov	r4,zero
8111d0e8:	02800044 	movi	r10,1
8111d0ec:	027fffc4 	movi	r9,-1
8111d0f0:	d9c00117 	ldw	r7,4(sp)
8111d0f4:	40000e26 	beq	r8,zero,8111d130 <_strtol_r+0x120>
8111d0f8:	843ff404 	addi	r16,r16,-48
8111d0fc:	8580120e 	bge	r16,r22,8111d148 <_strtol_r+0x138>
8111d100:	32400526 	beq	r6,r9,8111d118 <_strtol_r+0x108>
8111d104:	11002536 	bltu	r2,r4,8111d19c <_strtol_r+0x18c>
8111d108:	20802326 	beq	r4,r2,8111d198 <_strtol_r+0x188>
8111d10c:	25c9383a 	mul	r4,r4,r23
8111d110:	01800044 	movi	r6,1
8111d114:	8109883a 	add	r4,r16,r4
8111d118:	2c000003 	ldbu	r16,0(r5)
8111d11c:	29400044 	addi	r5,r5,1
8111d120:	ac07883a 	add	r3,r21,r16
8111d124:	18c00043 	ldbu	r3,1(r3)
8111d128:	1a00010c 	andi	r8,r3,4
8111d12c:	403ff21e 	bne	r8,zero,8111d0f8 <__reset+0xfb0fd0f8>
8111d130:	18c000cc 	andi	r3,r3,3
8111d134:	18000426 	beq	r3,zero,8111d148 <_strtol_r+0x138>
8111d138:	1a801a26 	beq	r3,r10,8111d1a4 <_strtol_r+0x194>
8111d13c:	00c015c4 	movi	r3,87
8111d140:	80e1c83a 	sub	r16,r16,r3
8111d144:	85bfee16 	blt	r16,r22,8111d100 <__reset+0xfb0fd100>
8111d148:	00bfffc4 	movi	r2,-1
8111d14c:	30801e26 	beq	r6,r2,8111d1c8 <_strtol_r+0x1b8>
8111d150:	e0001b1e 	bne	fp,zero,8111d1c0 <_strtol_r+0x1b0>
8111d154:	2005883a 	mov	r2,r4
8111d158:	98000326 	beq	r19,zero,8111d168 <_strtol_r+0x158>
8111d15c:	3000211e 	bne	r6,zero,8111d1e4 <_strtol_r+0x1d4>
8111d160:	a00b883a 	mov	r5,r20
8111d164:	99400015 	stw	r5,0(r19)
8111d168:	dfc00b17 	ldw	ra,44(sp)
8111d16c:	df000a17 	ldw	fp,40(sp)
8111d170:	ddc00917 	ldw	r23,36(sp)
8111d174:	dd800817 	ldw	r22,32(sp)
8111d178:	dd400717 	ldw	r21,28(sp)
8111d17c:	dd000617 	ldw	r20,24(sp)
8111d180:	dcc00517 	ldw	r19,20(sp)
8111d184:	dc800417 	ldw	r18,16(sp)
8111d188:	dc400317 	ldw	r17,12(sp)
8111d18c:	dc000217 	ldw	r16,8(sp)
8111d190:	dec00c04 	addi	sp,sp,48
8111d194:	f800283a 	ret
8111d198:	3c3fdc0e 	bge	r7,r16,8111d10c <__reset+0xfb0fd10c>
8111d19c:	01bfffc4 	movi	r6,-1
8111d1a0:	003fdd06 	br	8111d118 <__reset+0xfb0fd118>
8111d1a4:	00c00dc4 	movi	r3,55
8111d1a8:	003fe506 	br	8111d140 <__reset+0xfb0fd140>
8111d1ac:	00800c04 	movi	r2,48
8111d1b0:	80801626 	beq	r16,r2,8111d20c <_strtol_r+0x1fc>
8111d1b4:	05800284 	movi	r22,10
8111d1b8:	b02f883a 	mov	r23,r22
8111d1bc:	003fba06 	br	8111d0a8 <__reset+0xfb0fd0a8>
8111d1c0:	0109c83a 	sub	r4,zero,r4
8111d1c4:	003fe306 	br	8111d154 <__reset+0xfb0fd154>
8111d1c8:	d9000017 	ldw	r4,0(sp)
8111d1cc:	00c00884 	movi	r3,34
8111d1d0:	e005003a 	cmpeq	r2,fp,zero
8111d1d4:	20c00015 	stw	r3,0(r4)
8111d1d8:	00e00034 	movhi	r3,32768
8111d1dc:	1885c83a 	sub	r2,r3,r2
8111d1e0:	983fe126 	beq	r19,zero,8111d168 <__reset+0xfb0fd168>
8111d1e4:	297fffc4 	addi	r5,r5,-1
8111d1e8:	003fde06 	br	8111d164 <__reset+0xfb0fd164>
8111d1ec:	1c400084 	addi	r17,r3,2
8111d1f0:	1c000043 	ldbu	r16,1(r3)
8111d1f4:	07000044 	movi	fp,1
8111d1f8:	003fa706 	br	8111d098 <__reset+0xfb0fd098>
8111d1fc:	1c400084 	addi	r17,r3,2
8111d200:	1c000043 	ldbu	r16,1(r3)
8111d204:	0039883a 	mov	fp,zero
8111d208:	003fa306 	br	8111d098 <__reset+0xfb0fd098>
8111d20c:	88800003 	ldbu	r2,0(r17)
8111d210:	00c01604 	movi	r3,88
8111d214:	108037cc 	andi	r2,r2,223
8111d218:	10c00826 	beq	r2,r3,8111d23c <_strtol_r+0x22c>
8111d21c:	05800204 	movi	r22,8
8111d220:	003fa006 	br	8111d0a4 <__reset+0xfb0fd0a4>
8111d224:	00800c04 	movi	r2,48
8111d228:	80bf9e1e 	bne	r16,r2,8111d0a4 <__reset+0xfb0fd0a4>
8111d22c:	88800003 	ldbu	r2,0(r17)
8111d230:	00c01604 	movi	r3,88
8111d234:	108037cc 	andi	r2,r2,223
8111d238:	10ff9a1e 	bne	r2,r3,8111d0a4 <__reset+0xfb0fd0a4>
8111d23c:	05c00404 	movi	r23,16
8111d240:	8c000043 	ldbu	r16,1(r17)
8111d244:	b82d883a 	mov	r22,r23
8111d248:	8c400084 	addi	r17,r17,2
8111d24c:	003f9606 	br	8111d0a8 <__reset+0xfb0fd0a8>

8111d250 <strtol>:
8111d250:	00a04574 	movhi	r2,33045
8111d254:	10b34e04 	addi	r2,r2,-13000
8111d258:	300f883a 	mov	r7,r6
8111d25c:	280d883a 	mov	r6,r5
8111d260:	200b883a 	mov	r5,r4
8111d264:	11000017 	ldw	r4,0(r2)
8111d268:	111d0101 	jmpi	8111d010 <_strtol_r>

8111d26c <___svfprintf_internal_r>:
8111d26c:	deffb704 	addi	sp,sp,-292
8111d270:	de00012e 	bgeu	sp,et,8111d278 <___svfprintf_internal_r+0xc>
8111d274:	003b68fa 	trap	3
8111d278:	dfc04815 	stw	ra,288(sp)
8111d27c:	ddc04615 	stw	r23,280(sp)
8111d280:	d9402c15 	stw	r5,176(sp)
8111d284:	d9003915 	stw	r4,228(sp)
8111d288:	302f883a 	mov	r23,r6
8111d28c:	d9c02d15 	stw	r7,180(sp)
8111d290:	df004715 	stw	fp,284(sp)
8111d294:	dd804515 	stw	r22,276(sp)
8111d298:	dd404415 	stw	r21,272(sp)
8111d29c:	dd004315 	stw	r20,268(sp)
8111d2a0:	dcc04215 	stw	r19,264(sp)
8111d2a4:	dc804115 	stw	r18,260(sp)
8111d2a8:	dc404015 	stw	r17,256(sp)
8111d2ac:	dc003f15 	stw	r16,252(sp)
8111d2b0:	11261540 	call	81126154 <_localeconv_r>
8111d2b4:	10800017 	ldw	r2,0(r2)
8111d2b8:	1009883a 	mov	r4,r2
8111d2bc:	d8803415 	stw	r2,208(sp)
8111d2c0:	111cf340 	call	8111cf34 <strlen>
8111d2c4:	d8c02c17 	ldw	r3,176(sp)
8111d2c8:	d8803815 	stw	r2,224(sp)
8111d2cc:	1880030b 	ldhu	r2,12(r3)
8111d2d0:	1080200c 	andi	r2,r2,128
8111d2d4:	10000226 	beq	r2,zero,8111d2e0 <___svfprintf_internal_r+0x74>
8111d2d8:	18800417 	ldw	r2,16(r3)
8111d2dc:	10067f26 	beq	r2,zero,8111ecdc <___svfprintf_internal_r+0x1a70>
8111d2e0:	dcc03917 	ldw	r19,228(sp)
8111d2e4:	d8c00404 	addi	r3,sp,16
8111d2e8:	05604574 	movhi	r21,33045
8111d2ec:	d9001e04 	addi	r4,sp,120
8111d2f0:	ad698684 	addi	r21,r21,-23014
8111d2f4:	d8c01e15 	stw	r3,120(sp)
8111d2f8:	d8002015 	stw	zero,128(sp)
8111d2fc:	d8001f15 	stw	zero,124(sp)
8111d300:	d8003315 	stw	zero,204(sp)
8111d304:	d8003615 	stw	zero,216(sp)
8111d308:	d8003715 	stw	zero,220(sp)
8111d30c:	1811883a 	mov	r8,r3
8111d310:	d8003a15 	stw	zero,232(sp)
8111d314:	d8003b15 	stw	zero,236(sp)
8111d318:	d8002f15 	stw	zero,188(sp)
8111d31c:	d9002815 	stw	r4,160(sp)
8111d320:	b8800007 	ldb	r2,0(r23)
8111d324:	10026726 	beq	r2,zero,8111dcc4 <___svfprintf_internal_r+0xa58>
8111d328:	00c00944 	movi	r3,37
8111d32c:	b821883a 	mov	r16,r23
8111d330:	10c0021e 	bne	r2,r3,8111d33c <___svfprintf_internal_r+0xd0>
8111d334:	00001406 	br	8111d388 <___svfprintf_internal_r+0x11c>
8111d338:	10c00326 	beq	r2,r3,8111d348 <___svfprintf_internal_r+0xdc>
8111d33c:	84000044 	addi	r16,r16,1
8111d340:	80800007 	ldb	r2,0(r16)
8111d344:	103ffc1e 	bne	r2,zero,8111d338 <__reset+0xfb0fd338>
8111d348:	85e3c83a 	sub	r17,r16,r23
8111d34c:	88000e26 	beq	r17,zero,8111d388 <___svfprintf_internal_r+0x11c>
8111d350:	d8c02017 	ldw	r3,128(sp)
8111d354:	d8801f17 	ldw	r2,124(sp)
8111d358:	45c00015 	stw	r23,0(r8)
8111d35c:	1c47883a 	add	r3,r3,r17
8111d360:	10800044 	addi	r2,r2,1
8111d364:	d8c02015 	stw	r3,128(sp)
8111d368:	44400115 	stw	r17,4(r8)
8111d36c:	d8801f15 	stw	r2,124(sp)
8111d370:	00c001c4 	movi	r3,7
8111d374:	18809716 	blt	r3,r2,8111d5d4 <___svfprintf_internal_r+0x368>
8111d378:	42000204 	addi	r8,r8,8
8111d37c:	d9402f17 	ldw	r5,188(sp)
8111d380:	2c4b883a 	add	r5,r5,r17
8111d384:	d9402f15 	stw	r5,188(sp)
8111d388:	80800007 	ldb	r2,0(r16)
8111d38c:	10009826 	beq	r2,zero,8111d5f0 <___svfprintf_internal_r+0x384>
8111d390:	84400047 	ldb	r17,1(r16)
8111d394:	00bfffc4 	movi	r2,-1
8111d398:	85c00044 	addi	r23,r16,1
8111d39c:	d8002785 	stb	zero,158(sp)
8111d3a0:	0007883a 	mov	r3,zero
8111d3a4:	000f883a 	mov	r7,zero
8111d3a8:	d8802915 	stw	r2,164(sp)
8111d3ac:	d8003115 	stw	zero,196(sp)
8111d3b0:	0025883a 	mov	r18,zero
8111d3b4:	01401604 	movi	r5,88
8111d3b8:	01800244 	movi	r6,9
8111d3bc:	02800a84 	movi	r10,42
8111d3c0:	02401b04 	movi	r9,108
8111d3c4:	bdc00044 	addi	r23,r23,1
8111d3c8:	88bff804 	addi	r2,r17,-32
8111d3cc:	2882f036 	bltu	r5,r2,8111df90 <___svfprintf_internal_r+0xd24>
8111d3d0:	100490ba 	slli	r2,r2,2
8111d3d4:	012044b4 	movhi	r4,33042
8111d3d8:	2134fa04 	addi	r4,r4,-11288
8111d3dc:	1105883a 	add	r2,r2,r4
8111d3e0:	10800017 	ldw	r2,0(r2)
8111d3e4:	1000683a 	jmp	r2
8111d3e8:	8111def8 	rdprs	r4,r16,18299
8111d3ec:	8111df90 	cmplti	r4,r16,18302
8111d3f0:	8111df90 	cmplti	r4,r16,18302
8111d3f4:	8111deec 	andhi	r4,r16,18299
8111d3f8:	8111df90 	cmplti	r4,r16,18302
8111d3fc:	8111df90 	cmplti	r4,r16,18302
8111d400:	8111df90 	cmplti	r4,r16,18302
8111d404:	8111df90 	cmplti	r4,r16,18302
8111d408:	8111df90 	cmplti	r4,r16,18302
8111d40c:	8111df90 	cmplti	r4,r16,18302
8111d410:	8111d64c 	andi	r4,r16,18265
8111d414:	8111de28 	cmpgeui	r4,r16,18296
8111d418:	8111df90 	cmplti	r4,r16,18302
8111d41c:	8111d55c 	xori	r4,r16,18261
8111d420:	8111d674 	orhi	r4,r16,18265
8111d424:	8111df90 	cmplti	r4,r16,18302
8111d428:	8111d6e8 	cmpgeui	r4,r16,18267
8111d42c:	8111d6b4 	orhi	r4,r16,18266
8111d430:	8111d6b4 	orhi	r4,r16,18266
8111d434:	8111d6b4 	orhi	r4,r16,18266
8111d438:	8111d6b4 	orhi	r4,r16,18266
8111d43c:	8111d6b4 	orhi	r4,r16,18266
8111d440:	8111d6b4 	orhi	r4,r16,18266
8111d444:	8111d6b4 	orhi	r4,r16,18266
8111d448:	8111d6b4 	orhi	r4,r16,18266
8111d44c:	8111d6b4 	orhi	r4,r16,18266
8111d450:	8111df90 	cmplti	r4,r16,18302
8111d454:	8111df90 	cmplti	r4,r16,18302
8111d458:	8111df90 	cmplti	r4,r16,18302
8111d45c:	8111df90 	cmplti	r4,r16,18302
8111d460:	8111df90 	cmplti	r4,r16,18302
8111d464:	8111df90 	cmplti	r4,r16,18302
8111d468:	8111df90 	cmplti	r4,r16,18302
8111d46c:	8111df90 	cmplti	r4,r16,18302
8111d470:	8111df90 	cmplti	r4,r16,18302
8111d474:	8111df90 	cmplti	r4,r16,18302
8111d478:	8111d7a0 	cmpeqi	r4,r16,18270
8111d47c:	8111d6f4 	orhi	r4,r16,18267
8111d480:	8111df90 	cmplti	r4,r16,18302
8111d484:	8111d6f4 	orhi	r4,r16,18267
8111d488:	8111df90 	cmplti	r4,r16,18302
8111d48c:	8111df90 	cmplti	r4,r16,18302
8111d490:	8111df90 	cmplti	r4,r16,18302
8111d494:	8111df90 	cmplti	r4,r16,18302
8111d498:	8111d794 	ori	r4,r16,18270
8111d49c:	8111df90 	cmplti	r4,r16,18302
8111d4a0:	8111df90 	cmplti	r4,r16,18302
8111d4a4:	8111d85c 	xori	r4,r16,18273
8111d4a8:	8111df90 	cmplti	r4,r16,18302
8111d4ac:	8111df90 	cmplti	r4,r16,18302
8111d4b0:	8111df90 	cmplti	r4,r16,18302
8111d4b4:	8111df90 	cmplti	r4,r16,18302
8111d4b8:	8111df90 	cmplti	r4,r16,18302
8111d4bc:	8111dccc 	andi	r4,r16,18291
8111d4c0:	8111df90 	cmplti	r4,r16,18302
8111d4c4:	8111df90 	cmplti	r4,r16,18302
8111d4c8:	8111dd2c 	andhi	r4,r16,18292
8111d4cc:	8111df90 	cmplti	r4,r16,18302
8111d4d0:	8111df90 	cmplti	r4,r16,18302
8111d4d4:	8111df90 	cmplti	r4,r16,18302
8111d4d8:	8111df90 	cmplti	r4,r16,18302
8111d4dc:	8111df90 	cmplti	r4,r16,18302
8111d4e0:	8111df90 	cmplti	r4,r16,18302
8111d4e4:	8111df90 	cmplti	r4,r16,18302
8111d4e8:	8111df90 	cmplti	r4,r16,18302
8111d4ec:	8111df90 	cmplti	r4,r16,18302
8111d4f0:	8111df90 	cmplti	r4,r16,18302
8111d4f4:	8111dddc 	xori	r4,r16,18295
8111d4f8:	8111df18 	cmpnei	r4,r16,18300
8111d4fc:	8111d6f4 	orhi	r4,r16,18267
8111d500:	8111d6f4 	orhi	r4,r16,18267
8111d504:	8111d6f4 	orhi	r4,r16,18267
8111d508:	8111df6c 	andhi	r4,r16,18301
8111d50c:	8111df18 	cmpnei	r4,r16,18300
8111d510:	8111df90 	cmplti	r4,r16,18302
8111d514:	8111df90 	cmplti	r4,r16,18302
8111d518:	8111df28 	cmpgeui	r4,r16,18300
8111d51c:	8111df90 	cmplti	r4,r16,18302
8111d520:	8111df38 	rdprs	r4,r16,18300
8111d524:	8111de18 	cmpnei	r4,r16,18296
8111d528:	8111d568 	cmpgeui	r4,r16,18261
8111d52c:	8111de38 	rdprs	r4,r16,18296
8111d530:	8111df90 	cmplti	r4,r16,18302
8111d534:	8111de44 	addi	r4,r16,18297
8111d538:	8111df90 	cmplti	r4,r16,18302
8111d53c:	8111dea0 	cmpeqi	r4,r16,18298
8111d540:	8111df90 	cmplti	r4,r16,18302
8111d544:	8111df90 	cmplti	r4,r16,18302
8111d548:	8111deb0 	cmpltui	r4,r16,18298
8111d54c:	d9003117 	ldw	r4,196(sp)
8111d550:	d8802d15 	stw	r2,180(sp)
8111d554:	0109c83a 	sub	r4,zero,r4
8111d558:	d9003115 	stw	r4,196(sp)
8111d55c:	94800114 	ori	r18,r18,4
8111d560:	bc400007 	ldb	r17,0(r23)
8111d564:	003f9706 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111d568:	00800c04 	movi	r2,48
8111d56c:	d9002d17 	ldw	r4,180(sp)
8111d570:	d9402917 	ldw	r5,164(sp)
8111d574:	d8802705 	stb	r2,156(sp)
8111d578:	00801e04 	movi	r2,120
8111d57c:	d8802745 	stb	r2,157(sp)
8111d580:	d8002785 	stb	zero,158(sp)
8111d584:	20c00104 	addi	r3,r4,4
8111d588:	25000017 	ldw	r20,0(r4)
8111d58c:	002d883a 	mov	r22,zero
8111d590:	90800094 	ori	r2,r18,2
8111d594:	28028616 	blt	r5,zero,8111dfb0 <___svfprintf_internal_r+0xd44>
8111d598:	00bfdfc4 	movi	r2,-129
8111d59c:	90a4703a 	and	r18,r18,r2
8111d5a0:	d8c02d15 	stw	r3,180(sp)
8111d5a4:	94800094 	ori	r18,r18,2
8111d5a8:	a002731e 	bne	r20,zero,8111df78 <___svfprintf_internal_r+0xd0c>
8111d5ac:	00a04574 	movhi	r2,33045
8111d5b0:	10a97f04 	addi	r2,r2,-23044
8111d5b4:	d8803a15 	stw	r2,232(sp)
8111d5b8:	04401e04 	movi	r17,120
8111d5bc:	d8c02917 	ldw	r3,164(sp)
8111d5c0:	0039883a 	mov	fp,zero
8111d5c4:	1801d526 	beq	r3,zero,8111dd1c <___svfprintf_internal_r+0xab0>
8111d5c8:	0029883a 	mov	r20,zero
8111d5cc:	002d883a 	mov	r22,zero
8111d5d0:	0001f106 	br	8111dd98 <___svfprintf_internal_r+0xb2c>
8111d5d4:	d9402c17 	ldw	r5,176(sp)
8111d5d8:	d9801e04 	addi	r6,sp,120
8111d5dc:	9809883a 	mov	r4,r19
8111d5e0:	1129e8c0 	call	81129e8c <__ssprint_r>
8111d5e4:	1000081e 	bne	r2,zero,8111d608 <___svfprintf_internal_r+0x39c>
8111d5e8:	da000404 	addi	r8,sp,16
8111d5ec:	003f6306 	br	8111d37c <__reset+0xfb0fd37c>
8111d5f0:	d8802017 	ldw	r2,128(sp)
8111d5f4:	10000426 	beq	r2,zero,8111d608 <___svfprintf_internal_r+0x39c>
8111d5f8:	d9402c17 	ldw	r5,176(sp)
8111d5fc:	d9003917 	ldw	r4,228(sp)
8111d600:	d9801e04 	addi	r6,sp,120
8111d604:	1129e8c0 	call	81129e8c <__ssprint_r>
8111d608:	d8802c17 	ldw	r2,176(sp)
8111d60c:	10c0030b 	ldhu	r3,12(r2)
8111d610:	d8802f17 	ldw	r2,188(sp)
8111d614:	18c0100c 	andi	r3,r3,64
8111d618:	1805f51e 	bne	r3,zero,8111edf0 <___svfprintf_internal_r+0x1b84>
8111d61c:	dfc04817 	ldw	ra,288(sp)
8111d620:	df004717 	ldw	fp,284(sp)
8111d624:	ddc04617 	ldw	r23,280(sp)
8111d628:	dd804517 	ldw	r22,276(sp)
8111d62c:	dd404417 	ldw	r21,272(sp)
8111d630:	dd004317 	ldw	r20,268(sp)
8111d634:	dcc04217 	ldw	r19,264(sp)
8111d638:	dc804117 	ldw	r18,260(sp)
8111d63c:	dc404017 	ldw	r17,256(sp)
8111d640:	dc003f17 	ldw	r16,252(sp)
8111d644:	dec04904 	addi	sp,sp,292
8111d648:	f800283a 	ret
8111d64c:	d8802d17 	ldw	r2,180(sp)
8111d650:	d9002d17 	ldw	r4,180(sp)
8111d654:	10800017 	ldw	r2,0(r2)
8111d658:	d8803115 	stw	r2,196(sp)
8111d65c:	20800104 	addi	r2,r4,4
8111d660:	d9003117 	ldw	r4,196(sp)
8111d664:	203fb916 	blt	r4,zero,8111d54c <__reset+0xfb0fd54c>
8111d668:	d8802d15 	stw	r2,180(sp)
8111d66c:	bc400007 	ldb	r17,0(r23)
8111d670:	003f5406 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111d674:	bc400007 	ldb	r17,0(r23)
8111d678:	bac00044 	addi	r11,r23,1
8111d67c:	8a873926 	beq	r17,r10,8111f364 <___svfprintf_internal_r+0x20f8>
8111d680:	88bff404 	addi	r2,r17,-48
8111d684:	0009883a 	mov	r4,zero
8111d688:	30868836 	bltu	r6,r2,8111f0ac <___svfprintf_internal_r+0x1e40>
8111d68c:	5c400007 	ldb	r17,0(r11)
8111d690:	210002a4 	muli	r4,r4,10
8111d694:	5dc00044 	addi	r23,r11,1
8111d698:	b817883a 	mov	r11,r23
8111d69c:	2089883a 	add	r4,r4,r2
8111d6a0:	88bff404 	addi	r2,r17,-48
8111d6a4:	30bff92e 	bgeu	r6,r2,8111d68c <__reset+0xfb0fd68c>
8111d6a8:	2005d716 	blt	r4,zero,8111ee08 <___svfprintf_internal_r+0x1b9c>
8111d6ac:	d9002915 	stw	r4,164(sp)
8111d6b0:	003f4506 	br	8111d3c8 <__reset+0xfb0fd3c8>
8111d6b4:	b809883a 	mov	r4,r23
8111d6b8:	d8003115 	stw	zero,196(sp)
8111d6bc:	88bff404 	addi	r2,r17,-48
8111d6c0:	0017883a 	mov	r11,zero
8111d6c4:	24400007 	ldb	r17,0(r4)
8111d6c8:	5ac002a4 	muli	r11,r11,10
8111d6cc:	bdc00044 	addi	r23,r23,1
8111d6d0:	b809883a 	mov	r4,r23
8111d6d4:	12d7883a 	add	r11,r2,r11
8111d6d8:	88bff404 	addi	r2,r17,-48
8111d6dc:	30bff92e 	bgeu	r6,r2,8111d6c4 <__reset+0xfb0fd6c4>
8111d6e0:	dac03115 	stw	r11,196(sp)
8111d6e4:	003f3806 	br	8111d3c8 <__reset+0xfb0fd3c8>
8111d6e8:	94802014 	ori	r18,r18,128
8111d6ec:	bc400007 	ldb	r17,0(r23)
8111d6f0:	003f3406 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111d6f4:	18c03fcc 	andi	r3,r3,255
8111d6f8:	1807471e 	bne	r3,zero,8111f418 <___svfprintf_internal_r+0x21ac>
8111d6fc:	9080020c 	andi	r2,r18,8
8111d700:	10047d26 	beq	r2,zero,8111e8f8 <___svfprintf_internal_r+0x168c>
8111d704:	d8c02d17 	ldw	r3,180(sp)
8111d708:	d9002d17 	ldw	r4,180(sp)
8111d70c:	d9402d17 	ldw	r5,180(sp)
8111d710:	18c00017 	ldw	r3,0(r3)
8111d714:	21000117 	ldw	r4,4(r4)
8111d718:	29400204 	addi	r5,r5,8
8111d71c:	d8c03615 	stw	r3,216(sp)
8111d720:	d9003715 	stw	r4,220(sp)
8111d724:	d9402d15 	stw	r5,180(sp)
8111d728:	d9003617 	ldw	r4,216(sp)
8111d72c:	d9403717 	ldw	r5,220(sp)
8111d730:	da003e15 	stw	r8,248(sp)
8111d734:	04000044 	movi	r16,1
8111d738:	1127ca00 	call	81127ca0 <__fpclassifyd>
8111d73c:	da003e17 	ldw	r8,248(sp)
8111d740:	14044b1e 	bne	r2,r16,8111e870 <___svfprintf_internal_r+0x1604>
8111d744:	d9003617 	ldw	r4,216(sp)
8111d748:	d9403717 	ldw	r5,220(sp)
8111d74c:	000d883a 	mov	r6,zero
8111d750:	000f883a 	mov	r7,zero
8111d754:	112ffe80 	call	8112ffe8 <__ledf2>
8111d758:	da003e17 	ldw	r8,248(sp)
8111d75c:	1005f316 	blt	r2,zero,8111ef2c <___svfprintf_internal_r+0x1cc0>
8111d760:	df002783 	ldbu	fp,158(sp)
8111d764:	008011c4 	movi	r2,71
8111d768:	1445590e 	bge	r2,r17,8111ecd0 <___svfprintf_internal_r+0x1a64>
8111d76c:	04204574 	movhi	r16,33045
8111d770:	84297704 	addi	r16,r16,-23076
8111d774:	00c000c4 	movi	r3,3
8111d778:	00bfdfc4 	movi	r2,-129
8111d77c:	d8c02a15 	stw	r3,168(sp)
8111d780:	90a4703a 	and	r18,r18,r2
8111d784:	d8c02e15 	stw	r3,184(sp)
8111d788:	d8002915 	stw	zero,164(sp)
8111d78c:	d8003215 	stw	zero,200(sp)
8111d790:	00006606 	br	8111d92c <___svfprintf_internal_r+0x6c0>
8111d794:	94800214 	ori	r18,r18,8
8111d798:	bc400007 	ldb	r17,0(r23)
8111d79c:	003f0906 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111d7a0:	18c03fcc 	andi	r3,r3,255
8111d7a4:	1807181e 	bne	r3,zero,8111f408 <___svfprintf_internal_r+0x219c>
8111d7a8:	94800414 	ori	r18,r18,16
8111d7ac:	9080080c 	andi	r2,r18,32
8111d7b0:	10039626 	beq	r2,zero,8111e60c <___svfprintf_internal_r+0x13a0>
8111d7b4:	d9402d17 	ldw	r5,180(sp)
8111d7b8:	28800117 	ldw	r2,4(r5)
8111d7bc:	2d000017 	ldw	r20,0(r5)
8111d7c0:	29400204 	addi	r5,r5,8
8111d7c4:	d9402d15 	stw	r5,180(sp)
8111d7c8:	102d883a 	mov	r22,r2
8111d7cc:	10039816 	blt	r2,zero,8111e630 <___svfprintf_internal_r+0x13c4>
8111d7d0:	d9402917 	ldw	r5,164(sp)
8111d7d4:	df002783 	ldbu	fp,158(sp)
8111d7d8:	2803ab16 	blt	r5,zero,8111e688 <___svfprintf_internal_r+0x141c>
8111d7dc:	00ffdfc4 	movi	r3,-129
8111d7e0:	a584b03a 	or	r2,r20,r22
8111d7e4:	90e4703a 	and	r18,r18,r3
8111d7e8:	10014a26 	beq	r2,zero,8111dd14 <___svfprintf_internal_r+0xaa8>
8111d7ec:	b0034b26 	beq	r22,zero,8111e51c <___svfprintf_internal_r+0x12b0>
8111d7f0:	dc402a15 	stw	r17,168(sp)
8111d7f4:	dc001e04 	addi	r16,sp,120
8111d7f8:	b023883a 	mov	r17,r22
8111d7fc:	402d883a 	mov	r22,r8
8111d800:	a009883a 	mov	r4,r20
8111d804:	880b883a 	mov	r5,r17
8111d808:	01800284 	movi	r6,10
8111d80c:	000f883a 	mov	r7,zero
8111d810:	112e3f00 	call	8112e3f0 <__umoddi3>
8111d814:	10800c04 	addi	r2,r2,48
8111d818:	843fffc4 	addi	r16,r16,-1
8111d81c:	a009883a 	mov	r4,r20
8111d820:	880b883a 	mov	r5,r17
8111d824:	80800005 	stb	r2,0(r16)
8111d828:	01800284 	movi	r6,10
8111d82c:	000f883a 	mov	r7,zero
8111d830:	112de700 	call	8112de70 <__udivdi3>
8111d834:	1029883a 	mov	r20,r2
8111d838:	10c4b03a 	or	r2,r2,r3
8111d83c:	1823883a 	mov	r17,r3
8111d840:	103fef1e 	bne	r2,zero,8111d800 <__reset+0xfb0fd800>
8111d844:	d8c02817 	ldw	r3,160(sp)
8111d848:	dc402a17 	ldw	r17,168(sp)
8111d84c:	b011883a 	mov	r8,r22
8111d850:	1c07c83a 	sub	r3,r3,r16
8111d854:	d8c02e15 	stw	r3,184(sp)
8111d858:	00002e06 	br	8111d914 <___svfprintf_internal_r+0x6a8>
8111d85c:	18c03fcc 	andi	r3,r3,255
8111d860:	1806e71e 	bne	r3,zero,8111f400 <___svfprintf_internal_r+0x2194>
8111d864:	94800414 	ori	r18,r18,16
8111d868:	9080080c 	andi	r2,r18,32
8111d86c:	1002d426 	beq	r2,zero,8111e3c0 <___svfprintf_internal_r+0x1154>
8111d870:	d9402d17 	ldw	r5,180(sp)
8111d874:	d8c02917 	ldw	r3,164(sp)
8111d878:	d8002785 	stb	zero,158(sp)
8111d87c:	28800204 	addi	r2,r5,8
8111d880:	2d000017 	ldw	r20,0(r5)
8111d884:	2d800117 	ldw	r22,4(r5)
8111d888:	18041516 	blt	r3,zero,8111e8e0 <___svfprintf_internal_r+0x1674>
8111d88c:	013fdfc4 	movi	r4,-129
8111d890:	a586b03a 	or	r3,r20,r22
8111d894:	d8802d15 	stw	r2,180(sp)
8111d898:	9124703a 	and	r18,r18,r4
8111d89c:	1802d51e 	bne	r3,zero,8111e3f4 <___svfprintf_internal_r+0x1188>
8111d8a0:	d9402917 	ldw	r5,164(sp)
8111d8a4:	0039883a 	mov	fp,zero
8111d8a8:	2806be26 	beq	r5,zero,8111f3a4 <___svfprintf_internal_r+0x2138>
8111d8ac:	0029883a 	mov	r20,zero
8111d8b0:	002d883a 	mov	r22,zero
8111d8b4:	dc001e04 	addi	r16,sp,120
8111d8b8:	a006d0fa 	srli	r3,r20,3
8111d8bc:	b008977a 	slli	r4,r22,29
8111d8c0:	b02cd0fa 	srli	r22,r22,3
8111d8c4:	a50001cc 	andi	r20,r20,7
8111d8c8:	a0800c04 	addi	r2,r20,48
8111d8cc:	843fffc4 	addi	r16,r16,-1
8111d8d0:	20e8b03a 	or	r20,r4,r3
8111d8d4:	80800005 	stb	r2,0(r16)
8111d8d8:	a586b03a 	or	r3,r20,r22
8111d8dc:	183ff61e 	bne	r3,zero,8111d8b8 <__reset+0xfb0fd8b8>
8111d8e0:	90c0004c 	andi	r3,r18,1
8111d8e4:	18013926 	beq	r3,zero,8111ddcc <___svfprintf_internal_r+0xb60>
8111d8e8:	10803fcc 	andi	r2,r2,255
8111d8ec:	1080201c 	xori	r2,r2,128
8111d8f0:	10bfe004 	addi	r2,r2,-128
8111d8f4:	00c00c04 	movi	r3,48
8111d8f8:	10c13426 	beq	r2,r3,8111ddcc <___svfprintf_internal_r+0xb60>
8111d8fc:	80ffffc5 	stb	r3,-1(r16)
8111d900:	d8c02817 	ldw	r3,160(sp)
8111d904:	80bfffc4 	addi	r2,r16,-1
8111d908:	1021883a 	mov	r16,r2
8111d90c:	1887c83a 	sub	r3,r3,r2
8111d910:	d8c02e15 	stw	r3,184(sp)
8111d914:	d8802e17 	ldw	r2,184(sp)
8111d918:	d9002917 	ldw	r4,164(sp)
8111d91c:	1100010e 	bge	r2,r4,8111d924 <___svfprintf_internal_r+0x6b8>
8111d920:	2005883a 	mov	r2,r4
8111d924:	d8802a15 	stw	r2,168(sp)
8111d928:	d8003215 	stw	zero,200(sp)
8111d92c:	e7003fcc 	andi	fp,fp,255
8111d930:	e700201c 	xori	fp,fp,128
8111d934:	e73fe004 	addi	fp,fp,-128
8111d938:	e0000326 	beq	fp,zero,8111d948 <___svfprintf_internal_r+0x6dc>
8111d93c:	d8c02a17 	ldw	r3,168(sp)
8111d940:	18c00044 	addi	r3,r3,1
8111d944:	d8c02a15 	stw	r3,168(sp)
8111d948:	90c0008c 	andi	r3,r18,2
8111d94c:	d8c02b15 	stw	r3,172(sp)
8111d950:	18000326 	beq	r3,zero,8111d960 <___svfprintf_internal_r+0x6f4>
8111d954:	d8c02a17 	ldw	r3,168(sp)
8111d958:	18c00084 	addi	r3,r3,2
8111d95c:	d8c02a15 	stw	r3,168(sp)
8111d960:	90c0210c 	andi	r3,r18,132
8111d964:	d8c03015 	stw	r3,192(sp)
8111d968:	1801a11e 	bne	r3,zero,8111dff0 <___svfprintf_internal_r+0xd84>
8111d96c:	d9003117 	ldw	r4,196(sp)
8111d970:	d8c02a17 	ldw	r3,168(sp)
8111d974:	20e9c83a 	sub	r20,r4,r3
8111d978:	05019d0e 	bge	zero,r20,8111dff0 <___svfprintf_internal_r+0xd84>
8111d97c:	02400404 	movi	r9,16
8111d980:	d8c02017 	ldw	r3,128(sp)
8111d984:	d8801f17 	ldw	r2,124(sp)
8111d988:	4d051b0e 	bge	r9,r20,8111edf8 <___svfprintf_internal_r+0x1b8c>
8111d98c:	01604574 	movhi	r5,33045
8111d990:	29698a84 	addi	r5,r5,-22998
8111d994:	dc403c15 	stw	r17,240(sp)
8111d998:	d9403515 	stw	r5,212(sp)
8111d99c:	a023883a 	mov	r17,r20
8111d9a0:	482d883a 	mov	r22,r9
8111d9a4:	9029883a 	mov	r20,r18
8111d9a8:	070001c4 	movi	fp,7
8111d9ac:	8025883a 	mov	r18,r16
8111d9b0:	dc002c17 	ldw	r16,176(sp)
8111d9b4:	00000306 	br	8111d9c4 <___svfprintf_internal_r+0x758>
8111d9b8:	8c7ffc04 	addi	r17,r17,-16
8111d9bc:	42000204 	addi	r8,r8,8
8111d9c0:	b440130e 	bge	r22,r17,8111da10 <___svfprintf_internal_r+0x7a4>
8111d9c4:	01204574 	movhi	r4,33045
8111d9c8:	18c00404 	addi	r3,r3,16
8111d9cc:	10800044 	addi	r2,r2,1
8111d9d0:	21298a84 	addi	r4,r4,-22998
8111d9d4:	41000015 	stw	r4,0(r8)
8111d9d8:	45800115 	stw	r22,4(r8)
8111d9dc:	d8c02015 	stw	r3,128(sp)
8111d9e0:	d8801f15 	stw	r2,124(sp)
8111d9e4:	e0bff40e 	bge	fp,r2,8111d9b8 <__reset+0xfb0fd9b8>
8111d9e8:	d9801e04 	addi	r6,sp,120
8111d9ec:	800b883a 	mov	r5,r16
8111d9f0:	9809883a 	mov	r4,r19
8111d9f4:	1129e8c0 	call	81129e8c <__ssprint_r>
8111d9f8:	103f031e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111d9fc:	8c7ffc04 	addi	r17,r17,-16
8111da00:	d8c02017 	ldw	r3,128(sp)
8111da04:	d8801f17 	ldw	r2,124(sp)
8111da08:	da000404 	addi	r8,sp,16
8111da0c:	b47fed16 	blt	r22,r17,8111d9c4 <__reset+0xfb0fd9c4>
8111da10:	9021883a 	mov	r16,r18
8111da14:	a025883a 	mov	r18,r20
8111da18:	8829883a 	mov	r20,r17
8111da1c:	dc403c17 	ldw	r17,240(sp)
8111da20:	d9403517 	ldw	r5,212(sp)
8111da24:	a0c7883a 	add	r3,r20,r3
8111da28:	10800044 	addi	r2,r2,1
8111da2c:	41400015 	stw	r5,0(r8)
8111da30:	45000115 	stw	r20,4(r8)
8111da34:	d8c02015 	stw	r3,128(sp)
8111da38:	d8801f15 	stw	r2,124(sp)
8111da3c:	010001c4 	movi	r4,7
8111da40:	20829f16 	blt	r4,r2,8111e4c0 <___svfprintf_internal_r+0x1254>
8111da44:	df002787 	ldb	fp,158(sp)
8111da48:	42000204 	addi	r8,r8,8
8111da4c:	e0000c26 	beq	fp,zero,8111da80 <___svfprintf_internal_r+0x814>
8111da50:	d8801f17 	ldw	r2,124(sp)
8111da54:	d9002784 	addi	r4,sp,158
8111da58:	18c00044 	addi	r3,r3,1
8111da5c:	10800044 	addi	r2,r2,1
8111da60:	41000015 	stw	r4,0(r8)
8111da64:	01000044 	movi	r4,1
8111da68:	41000115 	stw	r4,4(r8)
8111da6c:	d8c02015 	stw	r3,128(sp)
8111da70:	d8801f15 	stw	r2,124(sp)
8111da74:	010001c4 	movi	r4,7
8111da78:	20823816 	blt	r4,r2,8111e35c <___svfprintf_internal_r+0x10f0>
8111da7c:	42000204 	addi	r8,r8,8
8111da80:	d8802b17 	ldw	r2,172(sp)
8111da84:	10000c26 	beq	r2,zero,8111dab8 <___svfprintf_internal_r+0x84c>
8111da88:	d8801f17 	ldw	r2,124(sp)
8111da8c:	d9002704 	addi	r4,sp,156
8111da90:	18c00084 	addi	r3,r3,2
8111da94:	10800044 	addi	r2,r2,1
8111da98:	41000015 	stw	r4,0(r8)
8111da9c:	01000084 	movi	r4,2
8111daa0:	41000115 	stw	r4,4(r8)
8111daa4:	d8c02015 	stw	r3,128(sp)
8111daa8:	d8801f15 	stw	r2,124(sp)
8111daac:	010001c4 	movi	r4,7
8111dab0:	20823216 	blt	r4,r2,8111e37c <___svfprintf_internal_r+0x1110>
8111dab4:	42000204 	addi	r8,r8,8
8111dab8:	d9003017 	ldw	r4,192(sp)
8111dabc:	00802004 	movi	r2,128
8111dac0:	20819726 	beq	r4,r2,8111e120 <___svfprintf_internal_r+0xeb4>
8111dac4:	d9402917 	ldw	r5,164(sp)
8111dac8:	d8802e17 	ldw	r2,184(sp)
8111dacc:	28adc83a 	sub	r22,r5,r2
8111dad0:	05802f0e 	bge	zero,r22,8111db90 <___svfprintf_internal_r+0x924>
8111dad4:	07000404 	movi	fp,16
8111dad8:	d8801f17 	ldw	r2,124(sp)
8111dadc:	e583c00e 	bge	fp,r22,8111e9e0 <___svfprintf_internal_r+0x1774>
8111dae0:	01604574 	movhi	r5,33045
8111dae4:	29698684 	addi	r5,r5,-23014
8111dae8:	dc402915 	stw	r17,164(sp)
8111daec:	d9402b15 	stw	r5,172(sp)
8111daf0:	b023883a 	mov	r17,r22
8111daf4:	050001c4 	movi	r20,7
8111daf8:	902d883a 	mov	r22,r18
8111dafc:	8025883a 	mov	r18,r16
8111db00:	dc002c17 	ldw	r16,176(sp)
8111db04:	00000306 	br	8111db14 <___svfprintf_internal_r+0x8a8>
8111db08:	8c7ffc04 	addi	r17,r17,-16
8111db0c:	42000204 	addi	r8,r8,8
8111db10:	e440110e 	bge	fp,r17,8111db58 <___svfprintf_internal_r+0x8ec>
8111db14:	18c00404 	addi	r3,r3,16
8111db18:	10800044 	addi	r2,r2,1
8111db1c:	45400015 	stw	r21,0(r8)
8111db20:	47000115 	stw	fp,4(r8)
8111db24:	d8c02015 	stw	r3,128(sp)
8111db28:	d8801f15 	stw	r2,124(sp)
8111db2c:	a0bff60e 	bge	r20,r2,8111db08 <__reset+0xfb0fdb08>
8111db30:	d9801e04 	addi	r6,sp,120
8111db34:	800b883a 	mov	r5,r16
8111db38:	9809883a 	mov	r4,r19
8111db3c:	1129e8c0 	call	81129e8c <__ssprint_r>
8111db40:	103eb11e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111db44:	8c7ffc04 	addi	r17,r17,-16
8111db48:	d8c02017 	ldw	r3,128(sp)
8111db4c:	d8801f17 	ldw	r2,124(sp)
8111db50:	da000404 	addi	r8,sp,16
8111db54:	e47fef16 	blt	fp,r17,8111db14 <__reset+0xfb0fdb14>
8111db58:	9021883a 	mov	r16,r18
8111db5c:	b025883a 	mov	r18,r22
8111db60:	882d883a 	mov	r22,r17
8111db64:	dc402917 	ldw	r17,164(sp)
8111db68:	d9002b17 	ldw	r4,172(sp)
8111db6c:	1d87883a 	add	r3,r3,r22
8111db70:	10800044 	addi	r2,r2,1
8111db74:	41000015 	stw	r4,0(r8)
8111db78:	45800115 	stw	r22,4(r8)
8111db7c:	d8c02015 	stw	r3,128(sp)
8111db80:	d8801f15 	stw	r2,124(sp)
8111db84:	010001c4 	movi	r4,7
8111db88:	2081ec16 	blt	r4,r2,8111e33c <___svfprintf_internal_r+0x10d0>
8111db8c:	42000204 	addi	r8,r8,8
8111db90:	9080400c 	andi	r2,r18,256
8111db94:	1001181e 	bne	r2,zero,8111dff8 <___svfprintf_internal_r+0xd8c>
8111db98:	d9402e17 	ldw	r5,184(sp)
8111db9c:	d8801f17 	ldw	r2,124(sp)
8111dba0:	44000015 	stw	r16,0(r8)
8111dba4:	1947883a 	add	r3,r3,r5
8111dba8:	10800044 	addi	r2,r2,1
8111dbac:	41400115 	stw	r5,4(r8)
8111dbb0:	d8c02015 	stw	r3,128(sp)
8111dbb4:	d8801f15 	stw	r2,124(sp)
8111dbb8:	010001c4 	movi	r4,7
8111dbbc:	2081d116 	blt	r4,r2,8111e304 <___svfprintf_internal_r+0x1098>
8111dbc0:	42000204 	addi	r8,r8,8
8111dbc4:	9480010c 	andi	r18,r18,4
8111dbc8:	90003226 	beq	r18,zero,8111dc94 <___svfprintf_internal_r+0xa28>
8111dbcc:	d9403117 	ldw	r5,196(sp)
8111dbd0:	d8802a17 	ldw	r2,168(sp)
8111dbd4:	28a1c83a 	sub	r16,r5,r2
8111dbd8:	04002e0e 	bge	zero,r16,8111dc94 <___svfprintf_internal_r+0xa28>
8111dbdc:	04400404 	movi	r17,16
8111dbe0:	d8801f17 	ldw	r2,124(sp)
8111dbe4:	8c04b90e 	bge	r17,r16,8111eecc <___svfprintf_internal_r+0x1c60>
8111dbe8:	01604574 	movhi	r5,33045
8111dbec:	29698a84 	addi	r5,r5,-22998
8111dbf0:	d9403515 	stw	r5,212(sp)
8111dbf4:	048001c4 	movi	r18,7
8111dbf8:	dd002c17 	ldw	r20,176(sp)
8111dbfc:	00000306 	br	8111dc0c <___svfprintf_internal_r+0x9a0>
8111dc00:	843ffc04 	addi	r16,r16,-16
8111dc04:	42000204 	addi	r8,r8,8
8111dc08:	8c00130e 	bge	r17,r16,8111dc58 <___svfprintf_internal_r+0x9ec>
8111dc0c:	01204574 	movhi	r4,33045
8111dc10:	18c00404 	addi	r3,r3,16
8111dc14:	10800044 	addi	r2,r2,1
8111dc18:	21298a84 	addi	r4,r4,-22998
8111dc1c:	41000015 	stw	r4,0(r8)
8111dc20:	44400115 	stw	r17,4(r8)
8111dc24:	d8c02015 	stw	r3,128(sp)
8111dc28:	d8801f15 	stw	r2,124(sp)
8111dc2c:	90bff40e 	bge	r18,r2,8111dc00 <__reset+0xfb0fdc00>
8111dc30:	d9801e04 	addi	r6,sp,120
8111dc34:	a00b883a 	mov	r5,r20
8111dc38:	9809883a 	mov	r4,r19
8111dc3c:	1129e8c0 	call	81129e8c <__ssprint_r>
8111dc40:	103e711e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111dc44:	843ffc04 	addi	r16,r16,-16
8111dc48:	d8c02017 	ldw	r3,128(sp)
8111dc4c:	d8801f17 	ldw	r2,124(sp)
8111dc50:	da000404 	addi	r8,sp,16
8111dc54:	8c3fed16 	blt	r17,r16,8111dc0c <__reset+0xfb0fdc0c>
8111dc58:	d9403517 	ldw	r5,212(sp)
8111dc5c:	1c07883a 	add	r3,r3,r16
8111dc60:	10800044 	addi	r2,r2,1
8111dc64:	41400015 	stw	r5,0(r8)
8111dc68:	44000115 	stw	r16,4(r8)
8111dc6c:	d8c02015 	stw	r3,128(sp)
8111dc70:	d8801f15 	stw	r2,124(sp)
8111dc74:	010001c4 	movi	r4,7
8111dc78:	2080060e 	bge	r4,r2,8111dc94 <___svfprintf_internal_r+0xa28>
8111dc7c:	d9402c17 	ldw	r5,176(sp)
8111dc80:	d9801e04 	addi	r6,sp,120
8111dc84:	9809883a 	mov	r4,r19
8111dc88:	1129e8c0 	call	81129e8c <__ssprint_r>
8111dc8c:	103e5e1e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111dc90:	d8c02017 	ldw	r3,128(sp)
8111dc94:	d8803117 	ldw	r2,196(sp)
8111dc98:	d9002a17 	ldw	r4,168(sp)
8111dc9c:	1100010e 	bge	r2,r4,8111dca4 <___svfprintf_internal_r+0xa38>
8111dca0:	2005883a 	mov	r2,r4
8111dca4:	d9402f17 	ldw	r5,188(sp)
8111dca8:	288b883a 	add	r5,r5,r2
8111dcac:	d9402f15 	stw	r5,188(sp)
8111dcb0:	18019c1e 	bne	r3,zero,8111e324 <___svfprintf_internal_r+0x10b8>
8111dcb4:	b8800007 	ldb	r2,0(r23)
8111dcb8:	d8001f15 	stw	zero,124(sp)
8111dcbc:	da000404 	addi	r8,sp,16
8111dcc0:	103d991e 	bne	r2,zero,8111d328 <__reset+0xfb0fd328>
8111dcc4:	b821883a 	mov	r16,r23
8111dcc8:	003daf06 	br	8111d388 <__reset+0xfb0fd388>
8111dccc:	18c03fcc 	andi	r3,r3,255
8111dcd0:	1805c71e 	bne	r3,zero,8111f3f0 <___svfprintf_internal_r+0x2184>
8111dcd4:	94800414 	ori	r18,r18,16
8111dcd8:	9080080c 	andi	r2,r18,32
8111dcdc:	10020126 	beq	r2,zero,8111e4e4 <___svfprintf_internal_r+0x1278>
8111dce0:	d8802d17 	ldw	r2,180(sp)
8111dce4:	d9002917 	ldw	r4,164(sp)
8111dce8:	d8002785 	stb	zero,158(sp)
8111dcec:	10c00204 	addi	r3,r2,8
8111dcf0:	15000017 	ldw	r20,0(r2)
8111dcf4:	15800117 	ldw	r22,4(r2)
8111dcf8:	20038e16 	blt	r4,zero,8111eb34 <___svfprintf_internal_r+0x18c8>
8111dcfc:	013fdfc4 	movi	r4,-129
8111dd00:	a584b03a 	or	r2,r20,r22
8111dd04:	d8c02d15 	stw	r3,180(sp)
8111dd08:	9124703a 	and	r18,r18,r4
8111dd0c:	0039883a 	mov	fp,zero
8111dd10:	103eb61e 	bne	r2,zero,8111d7ec <__reset+0xfb0fd7ec>
8111dd14:	d8802917 	ldw	r2,164(sp)
8111dd18:	1002c81e 	bne	r2,zero,8111e83c <___svfprintf_internal_r+0x15d0>
8111dd1c:	d8002915 	stw	zero,164(sp)
8111dd20:	d8002e15 	stw	zero,184(sp)
8111dd24:	dc001e04 	addi	r16,sp,120
8111dd28:	003efa06 	br	8111d914 <__reset+0xfb0fd914>
8111dd2c:	18c03fcc 	andi	r3,r3,255
8111dd30:	1805ad1e 	bne	r3,zero,8111f3e8 <___svfprintf_internal_r+0x217c>
8111dd34:	01604574 	movhi	r5,33045
8111dd38:	29697a04 	addi	r5,r5,-23064
8111dd3c:	d9403a15 	stw	r5,232(sp)
8111dd40:	9080080c 	andi	r2,r18,32
8111dd44:	10006126 	beq	r2,zero,8111decc <___svfprintf_internal_r+0xc60>
8111dd48:	d8802d17 	ldw	r2,180(sp)
8111dd4c:	15000017 	ldw	r20,0(r2)
8111dd50:	15800117 	ldw	r22,4(r2)
8111dd54:	10800204 	addi	r2,r2,8
8111dd58:	d8802d15 	stw	r2,180(sp)
8111dd5c:	9080004c 	andi	r2,r18,1
8111dd60:	10018e26 	beq	r2,zero,8111e39c <___svfprintf_internal_r+0x1130>
8111dd64:	a584b03a 	or	r2,r20,r22
8111dd68:	10030926 	beq	r2,zero,8111e990 <___svfprintf_internal_r+0x1724>
8111dd6c:	d8c02917 	ldw	r3,164(sp)
8111dd70:	00800c04 	movi	r2,48
8111dd74:	d8802705 	stb	r2,156(sp)
8111dd78:	dc402745 	stb	r17,157(sp)
8111dd7c:	d8002785 	stb	zero,158(sp)
8111dd80:	90800094 	ori	r2,r18,2
8111dd84:	18048716 	blt	r3,zero,8111efa4 <___svfprintf_internal_r+0x1d38>
8111dd88:	00bfdfc4 	movi	r2,-129
8111dd8c:	90a4703a 	and	r18,r18,r2
8111dd90:	94800094 	ori	r18,r18,2
8111dd94:	0039883a 	mov	fp,zero
8111dd98:	d9003a17 	ldw	r4,232(sp)
8111dd9c:	dc001e04 	addi	r16,sp,120
8111dda0:	a08003cc 	andi	r2,r20,15
8111dda4:	b006973a 	slli	r3,r22,28
8111dda8:	2085883a 	add	r2,r4,r2
8111ddac:	a028d13a 	srli	r20,r20,4
8111ddb0:	10800003 	ldbu	r2,0(r2)
8111ddb4:	b02cd13a 	srli	r22,r22,4
8111ddb8:	843fffc4 	addi	r16,r16,-1
8111ddbc:	1d28b03a 	or	r20,r3,r20
8111ddc0:	80800005 	stb	r2,0(r16)
8111ddc4:	a584b03a 	or	r2,r20,r22
8111ddc8:	103ff51e 	bne	r2,zero,8111dda0 <__reset+0xfb0fdda0>
8111ddcc:	d8c02817 	ldw	r3,160(sp)
8111ddd0:	1c07c83a 	sub	r3,r3,r16
8111ddd4:	d8c02e15 	stw	r3,184(sp)
8111ddd8:	003ece06 	br	8111d914 <__reset+0xfb0fd914>
8111dddc:	d8c02d17 	ldw	r3,180(sp)
8111dde0:	d9002d17 	ldw	r4,180(sp)
8111dde4:	d8002785 	stb	zero,158(sp)
8111dde8:	18800017 	ldw	r2,0(r3)
8111ddec:	21000104 	addi	r4,r4,4
8111ddf0:	00c00044 	movi	r3,1
8111ddf4:	d8c02a15 	stw	r3,168(sp)
8111ddf8:	d8801405 	stb	r2,80(sp)
8111ddfc:	d9002d15 	stw	r4,180(sp)
8111de00:	d8c02e15 	stw	r3,184(sp)
8111de04:	d8002915 	stw	zero,164(sp)
8111de08:	d8003215 	stw	zero,200(sp)
8111de0c:	dc001404 	addi	r16,sp,80
8111de10:	0039883a 	mov	fp,zero
8111de14:	003ecc06 	br	8111d948 <__reset+0xfb0fd948>
8111de18:	18c03fcc 	andi	r3,r3,255
8111de1c:	183e9226 	beq	r3,zero,8111d868 <__reset+0xfb0fd868>
8111de20:	d9c02785 	stb	r7,158(sp)
8111de24:	003e9006 	br	8111d868 <__reset+0xfb0fd868>
8111de28:	00c00044 	movi	r3,1
8111de2c:	01c00ac4 	movi	r7,43
8111de30:	bc400007 	ldb	r17,0(r23)
8111de34:	003d6306 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111de38:	94800814 	ori	r18,r18,32
8111de3c:	bc400007 	ldb	r17,0(r23)
8111de40:	003d6006 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111de44:	d8c02d17 	ldw	r3,180(sp)
8111de48:	d8002785 	stb	zero,158(sp)
8111de4c:	1c000017 	ldw	r16,0(r3)
8111de50:	1d000104 	addi	r20,r3,4
8111de54:	80040f26 	beq	r16,zero,8111ee94 <___svfprintf_internal_r+0x1c28>
8111de58:	d9002917 	ldw	r4,164(sp)
8111de5c:	2003dc16 	blt	r4,zero,8111edd0 <___svfprintf_internal_r+0x1b64>
8111de60:	200d883a 	mov	r6,r4
8111de64:	000b883a 	mov	r5,zero
8111de68:	8009883a 	mov	r4,r16
8111de6c:	da003e15 	stw	r8,248(sp)
8111de70:	11264300 	call	81126430 <memchr>
8111de74:	da003e17 	ldw	r8,248(sp)
8111de78:	10045826 	beq	r2,zero,8111efdc <___svfprintf_internal_r+0x1d70>
8111de7c:	1405c83a 	sub	r2,r2,r16
8111de80:	d8802e15 	stw	r2,184(sp)
8111de84:	1003d816 	blt	r2,zero,8111ede8 <___svfprintf_internal_r+0x1b7c>
8111de88:	df002783 	ldbu	fp,158(sp)
8111de8c:	d8802a15 	stw	r2,168(sp)
8111de90:	dd002d15 	stw	r20,180(sp)
8111de94:	d8002915 	stw	zero,164(sp)
8111de98:	d8003215 	stw	zero,200(sp)
8111de9c:	003ea306 	br	8111d92c <__reset+0xfb0fd92c>
8111dea0:	18c03fcc 	andi	r3,r3,255
8111dea4:	183f8c26 	beq	r3,zero,8111dcd8 <__reset+0xfb0fdcd8>
8111dea8:	d9c02785 	stb	r7,158(sp)
8111deac:	003f8a06 	br	8111dcd8 <__reset+0xfb0fdcd8>
8111deb0:	18c03fcc 	andi	r3,r3,255
8111deb4:	1805631e 	bne	r3,zero,8111f444 <___svfprintf_internal_r+0x21d8>
8111deb8:	01604574 	movhi	r5,33045
8111debc:	29697f04 	addi	r5,r5,-23044
8111dec0:	d9403a15 	stw	r5,232(sp)
8111dec4:	9080080c 	andi	r2,r18,32
8111dec8:	103f9f1e 	bne	r2,zero,8111dd48 <__reset+0xfb0fdd48>
8111decc:	9080040c 	andi	r2,r18,16
8111ded0:	10029c26 	beq	r2,zero,8111e944 <___svfprintf_internal_r+0x16d8>
8111ded4:	d8c02d17 	ldw	r3,180(sp)
8111ded8:	002d883a 	mov	r22,zero
8111dedc:	1d000017 	ldw	r20,0(r3)
8111dee0:	18c00104 	addi	r3,r3,4
8111dee4:	d8c02d15 	stw	r3,180(sp)
8111dee8:	003f9c06 	br	8111dd5c <__reset+0xfb0fdd5c>
8111deec:	94800054 	ori	r18,r18,1
8111def0:	bc400007 	ldb	r17,0(r23)
8111def4:	003d3306 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111def8:	38803fcc 	andi	r2,r7,255
8111defc:	1080201c 	xori	r2,r2,128
8111df00:	10bfe004 	addi	r2,r2,-128
8111df04:	1002971e 	bne	r2,zero,8111e964 <___svfprintf_internal_r+0x16f8>
8111df08:	00c00044 	movi	r3,1
8111df0c:	01c00804 	movi	r7,32
8111df10:	bc400007 	ldb	r17,0(r23)
8111df14:	003d2b06 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111df18:	18c03fcc 	andi	r3,r3,255
8111df1c:	183e2326 	beq	r3,zero,8111d7ac <__reset+0xfb0fd7ac>
8111df20:	d9c02785 	stb	r7,158(sp)
8111df24:	003e2106 	br	8111d7ac <__reset+0xfb0fd7ac>
8111df28:	bc400007 	ldb	r17,0(r23)
8111df2c:	8a430426 	beq	r17,r9,8111eb40 <___svfprintf_internal_r+0x18d4>
8111df30:	94800414 	ori	r18,r18,16
8111df34:	003d2306 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111df38:	18c03fcc 	andi	r3,r3,255
8111df3c:	18053f1e 	bne	r3,zero,8111f43c <___svfprintf_internal_r+0x21d0>
8111df40:	9080080c 	andi	r2,r18,32
8111df44:	10028926 	beq	r2,zero,8111e96c <___svfprintf_internal_r+0x1700>
8111df48:	d9402d17 	ldw	r5,180(sp)
8111df4c:	d9002f17 	ldw	r4,188(sp)
8111df50:	28800017 	ldw	r2,0(r5)
8111df54:	2007d7fa 	srai	r3,r4,31
8111df58:	29400104 	addi	r5,r5,4
8111df5c:	d9402d15 	stw	r5,180(sp)
8111df60:	11000015 	stw	r4,0(r2)
8111df64:	10c00115 	stw	r3,4(r2)
8111df68:	003ced06 	br	8111d320 <__reset+0xfb0fd320>
8111df6c:	94801014 	ori	r18,r18,64
8111df70:	bc400007 	ldb	r17,0(r23)
8111df74:	003d1306 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111df78:	01204574 	movhi	r4,33045
8111df7c:	21297f04 	addi	r4,r4,-23044
8111df80:	0039883a 	mov	fp,zero
8111df84:	d9003a15 	stw	r4,232(sp)
8111df88:	04401e04 	movi	r17,120
8111df8c:	003f8206 	br	8111dd98 <__reset+0xfb0fdd98>
8111df90:	18c03fcc 	andi	r3,r3,255
8111df94:	1805221e 	bne	r3,zero,8111f420 <___svfprintf_internal_r+0x21b4>
8111df98:	883d9526 	beq	r17,zero,8111d5f0 <__reset+0xfb0fd5f0>
8111df9c:	00c00044 	movi	r3,1
8111dfa0:	d8c02a15 	stw	r3,168(sp)
8111dfa4:	dc401405 	stb	r17,80(sp)
8111dfa8:	d8002785 	stb	zero,158(sp)
8111dfac:	003f9406 	br	8111de00 <__reset+0xfb0fde00>
8111dfb0:	01204574 	movhi	r4,33045
8111dfb4:	21297f04 	addi	r4,r4,-23044
8111dfb8:	d9003a15 	stw	r4,232(sp)
8111dfbc:	d8c02d15 	stw	r3,180(sp)
8111dfc0:	1025883a 	mov	r18,r2
8111dfc4:	04401e04 	movi	r17,120
8111dfc8:	a584b03a 	or	r2,r20,r22
8111dfcc:	1000fa1e 	bne	r2,zero,8111e3b8 <___svfprintf_internal_r+0x114c>
8111dfd0:	0039883a 	mov	fp,zero
8111dfd4:	00800084 	movi	r2,2
8111dfd8:	10803fcc 	andi	r2,r2,255
8111dfdc:	00c00044 	movi	r3,1
8111dfe0:	10c21626 	beq	r2,r3,8111e83c <___svfprintf_internal_r+0x15d0>
8111dfe4:	00c00084 	movi	r3,2
8111dfe8:	10fe301e 	bne	r2,r3,8111d8ac <__reset+0xfb0fd8ac>
8111dfec:	003d7606 	br	8111d5c8 <__reset+0xfb0fd5c8>
8111dff0:	d8c02017 	ldw	r3,128(sp)
8111dff4:	003e9506 	br	8111da4c <__reset+0xfb0fda4c>
8111dff8:	00801944 	movi	r2,101
8111dffc:	14407c0e 	bge	r2,r17,8111e1f0 <___svfprintf_internal_r+0xf84>
8111e000:	d9003617 	ldw	r4,216(sp)
8111e004:	d9403717 	ldw	r5,220(sp)
8111e008:	000d883a 	mov	r6,zero
8111e00c:	000f883a 	mov	r7,zero
8111e010:	d8c03d15 	stw	r3,244(sp)
8111e014:	da003e15 	stw	r8,248(sp)
8111e018:	112fe840 	call	8112fe84 <__eqdf2>
8111e01c:	d8c03d17 	ldw	r3,244(sp)
8111e020:	da003e17 	ldw	r8,248(sp)
8111e024:	1000f51e 	bne	r2,zero,8111e3fc <___svfprintf_internal_r+0x1190>
8111e028:	d8801f17 	ldw	r2,124(sp)
8111e02c:	01204574 	movhi	r4,33045
8111e030:	21298604 	addi	r4,r4,-23016
8111e034:	18c00044 	addi	r3,r3,1
8111e038:	10800044 	addi	r2,r2,1
8111e03c:	41000015 	stw	r4,0(r8)
8111e040:	01000044 	movi	r4,1
8111e044:	41000115 	stw	r4,4(r8)
8111e048:	d8c02015 	stw	r3,128(sp)
8111e04c:	d8801f15 	stw	r2,124(sp)
8111e050:	010001c4 	movi	r4,7
8111e054:	20826616 	blt	r4,r2,8111e9f0 <___svfprintf_internal_r+0x1784>
8111e058:	42000204 	addi	r8,r8,8
8111e05c:	d8802617 	ldw	r2,152(sp)
8111e060:	d9403317 	ldw	r5,204(sp)
8111e064:	11400216 	blt	r2,r5,8111e070 <___svfprintf_internal_r+0xe04>
8111e068:	9080004c 	andi	r2,r18,1
8111e06c:	103ed526 	beq	r2,zero,8111dbc4 <__reset+0xfb0fdbc4>
8111e070:	d8803817 	ldw	r2,224(sp)
8111e074:	d9003417 	ldw	r4,208(sp)
8111e078:	d9403817 	ldw	r5,224(sp)
8111e07c:	1887883a 	add	r3,r3,r2
8111e080:	d8801f17 	ldw	r2,124(sp)
8111e084:	41000015 	stw	r4,0(r8)
8111e088:	41400115 	stw	r5,4(r8)
8111e08c:	10800044 	addi	r2,r2,1
8111e090:	d8c02015 	stw	r3,128(sp)
8111e094:	d8801f15 	stw	r2,124(sp)
8111e098:	010001c4 	movi	r4,7
8111e09c:	2082af16 	blt	r4,r2,8111eb5c <___svfprintf_internal_r+0x18f0>
8111e0a0:	42000204 	addi	r8,r8,8
8111e0a4:	d8803317 	ldw	r2,204(sp)
8111e0a8:	143fffc4 	addi	r16,r2,-1
8111e0ac:	043ec50e 	bge	zero,r16,8111dbc4 <__reset+0xfb0fdbc4>
8111e0b0:	04400404 	movi	r17,16
8111e0b4:	d8801f17 	ldw	r2,124(sp)
8111e0b8:	8c00860e 	bge	r17,r16,8111e2d4 <___svfprintf_internal_r+0x1068>
8111e0bc:	01604574 	movhi	r5,33045
8111e0c0:	29698684 	addi	r5,r5,-23014
8111e0c4:	d9402b15 	stw	r5,172(sp)
8111e0c8:	058001c4 	movi	r22,7
8111e0cc:	dd002c17 	ldw	r20,176(sp)
8111e0d0:	00000306 	br	8111e0e0 <___svfprintf_internal_r+0xe74>
8111e0d4:	42000204 	addi	r8,r8,8
8111e0d8:	843ffc04 	addi	r16,r16,-16
8111e0dc:	8c00800e 	bge	r17,r16,8111e2e0 <___svfprintf_internal_r+0x1074>
8111e0e0:	18c00404 	addi	r3,r3,16
8111e0e4:	10800044 	addi	r2,r2,1
8111e0e8:	45400015 	stw	r21,0(r8)
8111e0ec:	44400115 	stw	r17,4(r8)
8111e0f0:	d8c02015 	stw	r3,128(sp)
8111e0f4:	d8801f15 	stw	r2,124(sp)
8111e0f8:	b0bff60e 	bge	r22,r2,8111e0d4 <__reset+0xfb0fe0d4>
8111e0fc:	d9801e04 	addi	r6,sp,120
8111e100:	a00b883a 	mov	r5,r20
8111e104:	9809883a 	mov	r4,r19
8111e108:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e10c:	103d3e1e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e110:	d8c02017 	ldw	r3,128(sp)
8111e114:	d8801f17 	ldw	r2,124(sp)
8111e118:	da000404 	addi	r8,sp,16
8111e11c:	003fee06 	br	8111e0d8 <__reset+0xfb0fe0d8>
8111e120:	d9403117 	ldw	r5,196(sp)
8111e124:	d8802a17 	ldw	r2,168(sp)
8111e128:	28adc83a 	sub	r22,r5,r2
8111e12c:	05be650e 	bge	zero,r22,8111dac4 <__reset+0xfb0fdac4>
8111e130:	07000404 	movi	fp,16
8111e134:	d8801f17 	ldw	r2,124(sp)
8111e138:	e583a20e 	bge	fp,r22,8111efc4 <___svfprintf_internal_r+0x1d58>
8111e13c:	01604574 	movhi	r5,33045
8111e140:	29698684 	addi	r5,r5,-23014
8111e144:	dc403015 	stw	r17,192(sp)
8111e148:	d9402b15 	stw	r5,172(sp)
8111e14c:	b023883a 	mov	r17,r22
8111e150:	050001c4 	movi	r20,7
8111e154:	902d883a 	mov	r22,r18
8111e158:	8025883a 	mov	r18,r16
8111e15c:	dc002c17 	ldw	r16,176(sp)
8111e160:	00000306 	br	8111e170 <___svfprintf_internal_r+0xf04>
8111e164:	8c7ffc04 	addi	r17,r17,-16
8111e168:	42000204 	addi	r8,r8,8
8111e16c:	e440110e 	bge	fp,r17,8111e1b4 <___svfprintf_internal_r+0xf48>
8111e170:	18c00404 	addi	r3,r3,16
8111e174:	10800044 	addi	r2,r2,1
8111e178:	45400015 	stw	r21,0(r8)
8111e17c:	47000115 	stw	fp,4(r8)
8111e180:	d8c02015 	stw	r3,128(sp)
8111e184:	d8801f15 	stw	r2,124(sp)
8111e188:	a0bff60e 	bge	r20,r2,8111e164 <__reset+0xfb0fe164>
8111e18c:	d9801e04 	addi	r6,sp,120
8111e190:	800b883a 	mov	r5,r16
8111e194:	9809883a 	mov	r4,r19
8111e198:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e19c:	103d1a1e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e1a0:	8c7ffc04 	addi	r17,r17,-16
8111e1a4:	d8c02017 	ldw	r3,128(sp)
8111e1a8:	d8801f17 	ldw	r2,124(sp)
8111e1ac:	da000404 	addi	r8,sp,16
8111e1b0:	e47fef16 	blt	fp,r17,8111e170 <__reset+0xfb0fe170>
8111e1b4:	9021883a 	mov	r16,r18
8111e1b8:	b025883a 	mov	r18,r22
8111e1bc:	882d883a 	mov	r22,r17
8111e1c0:	dc403017 	ldw	r17,192(sp)
8111e1c4:	d9002b17 	ldw	r4,172(sp)
8111e1c8:	1d87883a 	add	r3,r3,r22
8111e1cc:	10800044 	addi	r2,r2,1
8111e1d0:	41000015 	stw	r4,0(r8)
8111e1d4:	45800115 	stw	r22,4(r8)
8111e1d8:	d8c02015 	stw	r3,128(sp)
8111e1dc:	d8801f15 	stw	r2,124(sp)
8111e1e0:	010001c4 	movi	r4,7
8111e1e4:	20819a16 	blt	r4,r2,8111e850 <___svfprintf_internal_r+0x15e4>
8111e1e8:	42000204 	addi	r8,r8,8
8111e1ec:	003e3506 	br	8111dac4 <__reset+0xfb0fdac4>
8111e1f0:	d9403317 	ldw	r5,204(sp)
8111e1f4:	00800044 	movi	r2,1
8111e1f8:	18c00044 	addi	r3,r3,1
8111e1fc:	1141710e 	bge	r2,r5,8111e7c4 <___svfprintf_internal_r+0x1558>
8111e200:	dc401f17 	ldw	r17,124(sp)
8111e204:	00800044 	movi	r2,1
8111e208:	40800115 	stw	r2,4(r8)
8111e20c:	8c400044 	addi	r17,r17,1
8111e210:	44000015 	stw	r16,0(r8)
8111e214:	d8c02015 	stw	r3,128(sp)
8111e218:	dc401f15 	stw	r17,124(sp)
8111e21c:	008001c4 	movi	r2,7
8111e220:	14417416 	blt	r2,r17,8111e7f4 <___svfprintf_internal_r+0x1588>
8111e224:	42000204 	addi	r8,r8,8
8111e228:	d8803817 	ldw	r2,224(sp)
8111e22c:	d9003417 	ldw	r4,208(sp)
8111e230:	8c400044 	addi	r17,r17,1
8111e234:	10c7883a 	add	r3,r2,r3
8111e238:	40800115 	stw	r2,4(r8)
8111e23c:	41000015 	stw	r4,0(r8)
8111e240:	d8c02015 	stw	r3,128(sp)
8111e244:	dc401f15 	stw	r17,124(sp)
8111e248:	008001c4 	movi	r2,7
8111e24c:	14417216 	blt	r2,r17,8111e818 <___svfprintf_internal_r+0x15ac>
8111e250:	45800204 	addi	r22,r8,8
8111e254:	d9003617 	ldw	r4,216(sp)
8111e258:	d9403717 	ldw	r5,220(sp)
8111e25c:	000d883a 	mov	r6,zero
8111e260:	000f883a 	mov	r7,zero
8111e264:	d8c03d15 	stw	r3,244(sp)
8111e268:	112fe840 	call	8112fe84 <__eqdf2>
8111e26c:	d8c03d17 	ldw	r3,244(sp)
8111e270:	1000b326 	beq	r2,zero,8111e540 <___svfprintf_internal_r+0x12d4>
8111e274:	d9403317 	ldw	r5,204(sp)
8111e278:	84000044 	addi	r16,r16,1
8111e27c:	8c400044 	addi	r17,r17,1
8111e280:	28bfffc4 	addi	r2,r5,-1
8111e284:	1887883a 	add	r3,r3,r2
8111e288:	b0800115 	stw	r2,4(r22)
8111e28c:	b4000015 	stw	r16,0(r22)
8111e290:	d8c02015 	stw	r3,128(sp)
8111e294:	dc401f15 	stw	r17,124(sp)
8111e298:	008001c4 	movi	r2,7
8111e29c:	1440d216 	blt	r2,r17,8111e5e8 <___svfprintf_internal_r+0x137c>
8111e2a0:	b5800204 	addi	r22,r22,8
8111e2a4:	d9003b17 	ldw	r4,236(sp)
8111e2a8:	df0022c4 	addi	fp,sp,139
8111e2ac:	8c400044 	addi	r17,r17,1
8111e2b0:	20c7883a 	add	r3,r4,r3
8111e2b4:	b7000015 	stw	fp,0(r22)
8111e2b8:	b1000115 	stw	r4,4(r22)
8111e2bc:	d8c02015 	stw	r3,128(sp)
8111e2c0:	dc401f15 	stw	r17,124(sp)
8111e2c4:	008001c4 	movi	r2,7
8111e2c8:	14400e16 	blt	r2,r17,8111e304 <___svfprintf_internal_r+0x1098>
8111e2cc:	b2000204 	addi	r8,r22,8
8111e2d0:	003e3c06 	br	8111dbc4 <__reset+0xfb0fdbc4>
8111e2d4:	01204574 	movhi	r4,33045
8111e2d8:	21298684 	addi	r4,r4,-23014
8111e2dc:	d9002b15 	stw	r4,172(sp)
8111e2e0:	d9002b17 	ldw	r4,172(sp)
8111e2e4:	1c07883a 	add	r3,r3,r16
8111e2e8:	44000115 	stw	r16,4(r8)
8111e2ec:	41000015 	stw	r4,0(r8)
8111e2f0:	10800044 	addi	r2,r2,1
8111e2f4:	d8c02015 	stw	r3,128(sp)
8111e2f8:	d8801f15 	stw	r2,124(sp)
8111e2fc:	010001c4 	movi	r4,7
8111e300:	20be2f0e 	bge	r4,r2,8111dbc0 <__reset+0xfb0fdbc0>
8111e304:	d9402c17 	ldw	r5,176(sp)
8111e308:	d9801e04 	addi	r6,sp,120
8111e30c:	9809883a 	mov	r4,r19
8111e310:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e314:	103cbc1e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e318:	d8c02017 	ldw	r3,128(sp)
8111e31c:	da000404 	addi	r8,sp,16
8111e320:	003e2806 	br	8111dbc4 <__reset+0xfb0fdbc4>
8111e324:	d9402c17 	ldw	r5,176(sp)
8111e328:	d9801e04 	addi	r6,sp,120
8111e32c:	9809883a 	mov	r4,r19
8111e330:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e334:	103e5f26 	beq	r2,zero,8111dcb4 <__reset+0xfb0fdcb4>
8111e338:	003cb306 	br	8111d608 <__reset+0xfb0fd608>
8111e33c:	d9402c17 	ldw	r5,176(sp)
8111e340:	d9801e04 	addi	r6,sp,120
8111e344:	9809883a 	mov	r4,r19
8111e348:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e34c:	103cae1e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e350:	d8c02017 	ldw	r3,128(sp)
8111e354:	da000404 	addi	r8,sp,16
8111e358:	003e0d06 	br	8111db90 <__reset+0xfb0fdb90>
8111e35c:	d9402c17 	ldw	r5,176(sp)
8111e360:	d9801e04 	addi	r6,sp,120
8111e364:	9809883a 	mov	r4,r19
8111e368:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e36c:	103ca61e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e370:	d8c02017 	ldw	r3,128(sp)
8111e374:	da000404 	addi	r8,sp,16
8111e378:	003dc106 	br	8111da80 <__reset+0xfb0fda80>
8111e37c:	d9402c17 	ldw	r5,176(sp)
8111e380:	d9801e04 	addi	r6,sp,120
8111e384:	9809883a 	mov	r4,r19
8111e388:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e38c:	103c9e1e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e390:	d8c02017 	ldw	r3,128(sp)
8111e394:	da000404 	addi	r8,sp,16
8111e398:	003dc706 	br	8111dab8 <__reset+0xfb0fdab8>
8111e39c:	d8802917 	ldw	r2,164(sp)
8111e3a0:	d8002785 	stb	zero,158(sp)
8111e3a4:	103f0816 	blt	r2,zero,8111dfc8 <__reset+0xfb0fdfc8>
8111e3a8:	00ffdfc4 	movi	r3,-129
8111e3ac:	a584b03a 	or	r2,r20,r22
8111e3b0:	90e4703a 	and	r18,r18,r3
8111e3b4:	103c8126 	beq	r2,zero,8111d5bc <__reset+0xfb0fd5bc>
8111e3b8:	0039883a 	mov	fp,zero
8111e3bc:	003e7606 	br	8111dd98 <__reset+0xfb0fdd98>
8111e3c0:	9080040c 	andi	r2,r18,16
8111e3c4:	10013d26 	beq	r2,zero,8111e8bc <___svfprintf_internal_r+0x1650>
8111e3c8:	d9002d17 	ldw	r4,180(sp)
8111e3cc:	d9402917 	ldw	r5,164(sp)
8111e3d0:	d8002785 	stb	zero,158(sp)
8111e3d4:	20800104 	addi	r2,r4,4
8111e3d8:	25000017 	ldw	r20,0(r4)
8111e3dc:	002d883a 	mov	r22,zero
8111e3e0:	28013f16 	blt	r5,zero,8111e8e0 <___svfprintf_internal_r+0x1674>
8111e3e4:	00ffdfc4 	movi	r3,-129
8111e3e8:	d8802d15 	stw	r2,180(sp)
8111e3ec:	90e4703a 	and	r18,r18,r3
8111e3f0:	a03d2b26 	beq	r20,zero,8111d8a0 <__reset+0xfb0fd8a0>
8111e3f4:	0039883a 	mov	fp,zero
8111e3f8:	003d2e06 	br	8111d8b4 <__reset+0xfb0fd8b4>
8111e3fc:	dc402617 	ldw	r17,152(sp)
8111e400:	0441830e 	bge	zero,r17,8111ea10 <___svfprintf_internal_r+0x17a4>
8111e404:	dc403217 	ldw	r17,200(sp)
8111e408:	d8803317 	ldw	r2,204(sp)
8111e40c:	1440010e 	bge	r2,r17,8111e414 <___svfprintf_internal_r+0x11a8>
8111e410:	1023883a 	mov	r17,r2
8111e414:	04400a0e 	bge	zero,r17,8111e440 <___svfprintf_internal_r+0x11d4>
8111e418:	d8801f17 	ldw	r2,124(sp)
8111e41c:	1c47883a 	add	r3,r3,r17
8111e420:	44000015 	stw	r16,0(r8)
8111e424:	10800044 	addi	r2,r2,1
8111e428:	44400115 	stw	r17,4(r8)
8111e42c:	d8c02015 	stw	r3,128(sp)
8111e430:	d8801f15 	stw	r2,124(sp)
8111e434:	010001c4 	movi	r4,7
8111e438:	20827516 	blt	r4,r2,8111ee10 <___svfprintf_internal_r+0x1ba4>
8111e43c:	42000204 	addi	r8,r8,8
8111e440:	88027b16 	blt	r17,zero,8111ee30 <___svfprintf_internal_r+0x1bc4>
8111e444:	d9003217 	ldw	r4,200(sp)
8111e448:	2463c83a 	sub	r17,r4,r17
8111e44c:	0440990e 	bge	zero,r17,8111e6b4 <___svfprintf_internal_r+0x1448>
8111e450:	05800404 	movi	r22,16
8111e454:	d8801f17 	ldw	r2,124(sp)
8111e458:	b441530e 	bge	r22,r17,8111e9a8 <___svfprintf_internal_r+0x173c>
8111e45c:	01204574 	movhi	r4,33045
8111e460:	21298684 	addi	r4,r4,-23014
8111e464:	d9002b15 	stw	r4,172(sp)
8111e468:	070001c4 	movi	fp,7
8111e46c:	dd002c17 	ldw	r20,176(sp)
8111e470:	00000306 	br	8111e480 <___svfprintf_internal_r+0x1214>
8111e474:	42000204 	addi	r8,r8,8
8111e478:	8c7ffc04 	addi	r17,r17,-16
8111e47c:	b4414d0e 	bge	r22,r17,8111e9b4 <___svfprintf_internal_r+0x1748>
8111e480:	18c00404 	addi	r3,r3,16
8111e484:	10800044 	addi	r2,r2,1
8111e488:	45400015 	stw	r21,0(r8)
8111e48c:	45800115 	stw	r22,4(r8)
8111e490:	d8c02015 	stw	r3,128(sp)
8111e494:	d8801f15 	stw	r2,124(sp)
8111e498:	e0bff60e 	bge	fp,r2,8111e474 <__reset+0xfb0fe474>
8111e49c:	d9801e04 	addi	r6,sp,120
8111e4a0:	a00b883a 	mov	r5,r20
8111e4a4:	9809883a 	mov	r4,r19
8111e4a8:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e4ac:	103c561e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e4b0:	d8c02017 	ldw	r3,128(sp)
8111e4b4:	d8801f17 	ldw	r2,124(sp)
8111e4b8:	da000404 	addi	r8,sp,16
8111e4bc:	003fee06 	br	8111e478 <__reset+0xfb0fe478>
8111e4c0:	d9402c17 	ldw	r5,176(sp)
8111e4c4:	d9801e04 	addi	r6,sp,120
8111e4c8:	9809883a 	mov	r4,r19
8111e4cc:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e4d0:	103c4d1e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e4d4:	d8c02017 	ldw	r3,128(sp)
8111e4d8:	df002787 	ldb	fp,158(sp)
8111e4dc:	da000404 	addi	r8,sp,16
8111e4e0:	003d5a06 	br	8111da4c <__reset+0xfb0fda4c>
8111e4e4:	9080040c 	andi	r2,r18,16
8111e4e8:	10005c26 	beq	r2,zero,8111e65c <___svfprintf_internal_r+0x13f0>
8111e4ec:	d9402d17 	ldw	r5,180(sp)
8111e4f0:	d8c02917 	ldw	r3,164(sp)
8111e4f4:	d8002785 	stb	zero,158(sp)
8111e4f8:	28800104 	addi	r2,r5,4
8111e4fc:	2d000017 	ldw	r20,0(r5)
8111e500:	002d883a 	mov	r22,zero
8111e504:	18005e16 	blt	r3,zero,8111e680 <___svfprintf_internal_r+0x1414>
8111e508:	00ffdfc4 	movi	r3,-129
8111e50c:	d8802d15 	stw	r2,180(sp)
8111e510:	90e4703a 	and	r18,r18,r3
8111e514:	0039883a 	mov	fp,zero
8111e518:	a03dfe26 	beq	r20,zero,8111dd14 <__reset+0xfb0fdd14>
8111e51c:	00800244 	movi	r2,9
8111e520:	153cb336 	bltu	r2,r20,8111d7f0 <__reset+0xfb0fd7f0>
8111e524:	a5000c04 	addi	r20,r20,48
8111e528:	dc001dc4 	addi	r16,sp,119
8111e52c:	dd001dc5 	stb	r20,119(sp)
8111e530:	d8c02817 	ldw	r3,160(sp)
8111e534:	1c07c83a 	sub	r3,r3,r16
8111e538:	d8c02e15 	stw	r3,184(sp)
8111e53c:	003cf506 	br	8111d914 <__reset+0xfb0fd914>
8111e540:	d8803317 	ldw	r2,204(sp)
8111e544:	143fffc4 	addi	r16,r2,-1
8111e548:	043f560e 	bge	zero,r16,8111e2a4 <__reset+0xfb0fe2a4>
8111e54c:	07000404 	movi	fp,16
8111e550:	e403530e 	bge	fp,r16,8111f2a0 <___svfprintf_internal_r+0x2034>
8111e554:	01604574 	movhi	r5,33045
8111e558:	29698684 	addi	r5,r5,-23014
8111e55c:	d9402b15 	stw	r5,172(sp)
8111e560:	01c001c4 	movi	r7,7
8111e564:	dd002c17 	ldw	r20,176(sp)
8111e568:	00000306 	br	8111e578 <___svfprintf_internal_r+0x130c>
8111e56c:	843ffc04 	addi	r16,r16,-16
8111e570:	b5800204 	addi	r22,r22,8
8111e574:	e400130e 	bge	fp,r16,8111e5c4 <___svfprintf_internal_r+0x1358>
8111e578:	18c00404 	addi	r3,r3,16
8111e57c:	8c400044 	addi	r17,r17,1
8111e580:	b5400015 	stw	r21,0(r22)
8111e584:	b7000115 	stw	fp,4(r22)
8111e588:	d8c02015 	stw	r3,128(sp)
8111e58c:	dc401f15 	stw	r17,124(sp)
8111e590:	3c7ff60e 	bge	r7,r17,8111e56c <__reset+0xfb0fe56c>
8111e594:	d9801e04 	addi	r6,sp,120
8111e598:	a00b883a 	mov	r5,r20
8111e59c:	9809883a 	mov	r4,r19
8111e5a0:	d9c03d15 	stw	r7,244(sp)
8111e5a4:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e5a8:	d9c03d17 	ldw	r7,244(sp)
8111e5ac:	103c161e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e5b0:	843ffc04 	addi	r16,r16,-16
8111e5b4:	d8c02017 	ldw	r3,128(sp)
8111e5b8:	dc401f17 	ldw	r17,124(sp)
8111e5bc:	dd800404 	addi	r22,sp,16
8111e5c0:	e43fed16 	blt	fp,r16,8111e578 <__reset+0xfb0fe578>
8111e5c4:	d8802b17 	ldw	r2,172(sp)
8111e5c8:	1c07883a 	add	r3,r3,r16
8111e5cc:	8c400044 	addi	r17,r17,1
8111e5d0:	b0800015 	stw	r2,0(r22)
8111e5d4:	b4000115 	stw	r16,4(r22)
8111e5d8:	d8c02015 	stw	r3,128(sp)
8111e5dc:	dc401f15 	stw	r17,124(sp)
8111e5e0:	008001c4 	movi	r2,7
8111e5e4:	147f2e0e 	bge	r2,r17,8111e2a0 <__reset+0xfb0fe2a0>
8111e5e8:	d9402c17 	ldw	r5,176(sp)
8111e5ec:	d9801e04 	addi	r6,sp,120
8111e5f0:	9809883a 	mov	r4,r19
8111e5f4:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e5f8:	103c031e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e5fc:	d8c02017 	ldw	r3,128(sp)
8111e600:	dc401f17 	ldw	r17,124(sp)
8111e604:	dd800404 	addi	r22,sp,16
8111e608:	003f2606 	br	8111e2a4 <__reset+0xfb0fe2a4>
8111e60c:	9080040c 	andi	r2,r18,16
8111e610:	1000c326 	beq	r2,zero,8111e920 <___svfprintf_internal_r+0x16b4>
8111e614:	d8802d17 	ldw	r2,180(sp)
8111e618:	15000017 	ldw	r20,0(r2)
8111e61c:	10800104 	addi	r2,r2,4
8111e620:	d8802d15 	stw	r2,180(sp)
8111e624:	a02dd7fa 	srai	r22,r20,31
8111e628:	b005883a 	mov	r2,r22
8111e62c:	103c680e 	bge	r2,zero,8111d7d0 <__reset+0xfb0fd7d0>
8111e630:	0529c83a 	sub	r20,zero,r20
8111e634:	a004c03a 	cmpne	r2,r20,zero
8111e638:	05adc83a 	sub	r22,zero,r22
8111e63c:	b0adc83a 	sub	r22,r22,r2
8111e640:	d8802917 	ldw	r2,164(sp)
8111e644:	07000b44 	movi	fp,45
8111e648:	df002785 	stb	fp,158(sp)
8111e64c:	10022e16 	blt	r2,zero,8111ef08 <___svfprintf_internal_r+0x1c9c>
8111e650:	00bfdfc4 	movi	r2,-129
8111e654:	90a4703a 	and	r18,r18,r2
8111e658:	003c6406 	br	8111d7ec <__reset+0xfb0fd7ec>
8111e65c:	9080100c 	andi	r2,r18,64
8111e660:	d8002785 	stb	zero,158(sp)
8111e664:	10012526 	beq	r2,zero,8111eafc <___svfprintf_internal_r+0x1890>
8111e668:	d9002d17 	ldw	r4,180(sp)
8111e66c:	d9402917 	ldw	r5,164(sp)
8111e670:	002d883a 	mov	r22,zero
8111e674:	20800104 	addi	r2,r4,4
8111e678:	2500000b 	ldhu	r20,0(r4)
8111e67c:	283fa20e 	bge	r5,zero,8111e508 <__reset+0xfb0fe508>
8111e680:	d8802d15 	stw	r2,180(sp)
8111e684:	0039883a 	mov	fp,zero
8111e688:	a584b03a 	or	r2,r20,r22
8111e68c:	103c571e 	bne	r2,zero,8111d7ec <__reset+0xfb0fd7ec>
8111e690:	00800044 	movi	r2,1
8111e694:	003e5006 	br	8111dfd8 <__reset+0xfb0fdfd8>
8111e698:	d9402c17 	ldw	r5,176(sp)
8111e69c:	d9801e04 	addi	r6,sp,120
8111e6a0:	9809883a 	mov	r4,r19
8111e6a4:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e6a8:	103bd71e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e6ac:	d8c02017 	ldw	r3,128(sp)
8111e6b0:	da000404 	addi	r8,sp,16
8111e6b4:	d9003217 	ldw	r4,200(sp)
8111e6b8:	d8802617 	ldw	r2,152(sp)
8111e6bc:	d9403317 	ldw	r5,204(sp)
8111e6c0:	8123883a 	add	r17,r16,r4
8111e6c4:	11400216 	blt	r2,r5,8111e6d0 <___svfprintf_internal_r+0x1464>
8111e6c8:	9100004c 	andi	r4,r18,1
8111e6cc:	20000d26 	beq	r4,zero,8111e704 <___svfprintf_internal_r+0x1498>
8111e6d0:	d9003817 	ldw	r4,224(sp)
8111e6d4:	d9403417 	ldw	r5,208(sp)
8111e6d8:	1907883a 	add	r3,r3,r4
8111e6dc:	d9001f17 	ldw	r4,124(sp)
8111e6e0:	41400015 	stw	r5,0(r8)
8111e6e4:	d9403817 	ldw	r5,224(sp)
8111e6e8:	21000044 	addi	r4,r4,1
8111e6ec:	d8c02015 	stw	r3,128(sp)
8111e6f0:	41400115 	stw	r5,4(r8)
8111e6f4:	d9001f15 	stw	r4,124(sp)
8111e6f8:	014001c4 	movi	r5,7
8111e6fc:	2901dc16 	blt	r5,r4,8111ee70 <___svfprintf_internal_r+0x1c04>
8111e700:	42000204 	addi	r8,r8,8
8111e704:	d9003317 	ldw	r4,204(sp)
8111e708:	8121883a 	add	r16,r16,r4
8111e70c:	2085c83a 	sub	r2,r4,r2
8111e710:	8461c83a 	sub	r16,r16,r17
8111e714:	1400010e 	bge	r2,r16,8111e71c <___svfprintf_internal_r+0x14b0>
8111e718:	1021883a 	mov	r16,r2
8111e71c:	04000a0e 	bge	zero,r16,8111e748 <___svfprintf_internal_r+0x14dc>
8111e720:	d9001f17 	ldw	r4,124(sp)
8111e724:	1c07883a 	add	r3,r3,r16
8111e728:	44400015 	stw	r17,0(r8)
8111e72c:	21000044 	addi	r4,r4,1
8111e730:	44000115 	stw	r16,4(r8)
8111e734:	d8c02015 	stw	r3,128(sp)
8111e738:	d9001f15 	stw	r4,124(sp)
8111e73c:	014001c4 	movi	r5,7
8111e740:	2901e616 	blt	r5,r4,8111eedc <___svfprintf_internal_r+0x1c70>
8111e744:	42000204 	addi	r8,r8,8
8111e748:	8001f616 	blt	r16,zero,8111ef24 <___svfprintf_internal_r+0x1cb8>
8111e74c:	1421c83a 	sub	r16,r2,r16
8111e750:	043d1c0e 	bge	zero,r16,8111dbc4 <__reset+0xfb0fdbc4>
8111e754:	04400404 	movi	r17,16
8111e758:	d8801f17 	ldw	r2,124(sp)
8111e75c:	8c3edd0e 	bge	r17,r16,8111e2d4 <__reset+0xfb0fe2d4>
8111e760:	01604574 	movhi	r5,33045
8111e764:	29698684 	addi	r5,r5,-23014
8111e768:	d9402b15 	stw	r5,172(sp)
8111e76c:	058001c4 	movi	r22,7
8111e770:	dd002c17 	ldw	r20,176(sp)
8111e774:	00000306 	br	8111e784 <___svfprintf_internal_r+0x1518>
8111e778:	42000204 	addi	r8,r8,8
8111e77c:	843ffc04 	addi	r16,r16,-16
8111e780:	8c3ed70e 	bge	r17,r16,8111e2e0 <__reset+0xfb0fe2e0>
8111e784:	18c00404 	addi	r3,r3,16
8111e788:	10800044 	addi	r2,r2,1
8111e78c:	45400015 	stw	r21,0(r8)
8111e790:	44400115 	stw	r17,4(r8)
8111e794:	d8c02015 	stw	r3,128(sp)
8111e798:	d8801f15 	stw	r2,124(sp)
8111e79c:	b0bff60e 	bge	r22,r2,8111e778 <__reset+0xfb0fe778>
8111e7a0:	d9801e04 	addi	r6,sp,120
8111e7a4:	a00b883a 	mov	r5,r20
8111e7a8:	9809883a 	mov	r4,r19
8111e7ac:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e7b0:	103b951e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e7b4:	d8c02017 	ldw	r3,128(sp)
8111e7b8:	d8801f17 	ldw	r2,124(sp)
8111e7bc:	da000404 	addi	r8,sp,16
8111e7c0:	003fee06 	br	8111e77c <__reset+0xfb0fe77c>
8111e7c4:	9088703a 	and	r4,r18,r2
8111e7c8:	203e8d1e 	bne	r4,zero,8111e200 <__reset+0xfb0fe200>
8111e7cc:	dc401f17 	ldw	r17,124(sp)
8111e7d0:	40800115 	stw	r2,4(r8)
8111e7d4:	44000015 	stw	r16,0(r8)
8111e7d8:	8c400044 	addi	r17,r17,1
8111e7dc:	d8c02015 	stw	r3,128(sp)
8111e7e0:	dc401f15 	stw	r17,124(sp)
8111e7e4:	008001c4 	movi	r2,7
8111e7e8:	147f7f16 	blt	r2,r17,8111e5e8 <__reset+0xfb0fe5e8>
8111e7ec:	45800204 	addi	r22,r8,8
8111e7f0:	003eac06 	br	8111e2a4 <__reset+0xfb0fe2a4>
8111e7f4:	d9402c17 	ldw	r5,176(sp)
8111e7f8:	d9801e04 	addi	r6,sp,120
8111e7fc:	9809883a 	mov	r4,r19
8111e800:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e804:	103b801e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e808:	d8c02017 	ldw	r3,128(sp)
8111e80c:	dc401f17 	ldw	r17,124(sp)
8111e810:	da000404 	addi	r8,sp,16
8111e814:	003e8406 	br	8111e228 <__reset+0xfb0fe228>
8111e818:	d9402c17 	ldw	r5,176(sp)
8111e81c:	d9801e04 	addi	r6,sp,120
8111e820:	9809883a 	mov	r4,r19
8111e824:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e828:	103b771e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e82c:	d8c02017 	ldw	r3,128(sp)
8111e830:	dc401f17 	ldw	r17,124(sp)
8111e834:	dd800404 	addi	r22,sp,16
8111e838:	003e8606 	br	8111e254 <__reset+0xfb0fe254>
8111e83c:	0029883a 	mov	r20,zero
8111e840:	a5000c04 	addi	r20,r20,48
8111e844:	dc001dc4 	addi	r16,sp,119
8111e848:	dd001dc5 	stb	r20,119(sp)
8111e84c:	003f3806 	br	8111e530 <__reset+0xfb0fe530>
8111e850:	d9402c17 	ldw	r5,176(sp)
8111e854:	d9801e04 	addi	r6,sp,120
8111e858:	9809883a 	mov	r4,r19
8111e85c:	1129e8c0 	call	81129e8c <__ssprint_r>
8111e860:	103b691e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111e864:	d8c02017 	ldw	r3,128(sp)
8111e868:	da000404 	addi	r8,sp,16
8111e86c:	003c9506 	br	8111dac4 <__reset+0xfb0fdac4>
8111e870:	d9003617 	ldw	r4,216(sp)
8111e874:	d9403717 	ldw	r5,220(sp)
8111e878:	da003e15 	stw	r8,248(sp)
8111e87c:	1127ca00 	call	81127ca0 <__fpclassifyd>
8111e880:	da003e17 	ldw	r8,248(sp)
8111e884:	1000bd1e 	bne	r2,zero,8111eb7c <___svfprintf_internal_r+0x1910>
8111e888:	008011c4 	movi	r2,71
8111e88c:	14411e0e 	bge	r2,r17,8111ed08 <___svfprintf_internal_r+0x1a9c>
8111e890:	04204574 	movhi	r16,33045
8111e894:	84297904 	addi	r16,r16,-23068
8111e898:	00c000c4 	movi	r3,3
8111e89c:	00bfdfc4 	movi	r2,-129
8111e8a0:	d8c02a15 	stw	r3,168(sp)
8111e8a4:	90a4703a 	and	r18,r18,r2
8111e8a8:	df002783 	ldbu	fp,158(sp)
8111e8ac:	d8c02e15 	stw	r3,184(sp)
8111e8b0:	d8002915 	stw	zero,164(sp)
8111e8b4:	d8003215 	stw	zero,200(sp)
8111e8b8:	003c1c06 	br	8111d92c <__reset+0xfb0fd92c>
8111e8bc:	9080100c 	andi	r2,r18,64
8111e8c0:	d8002785 	stb	zero,158(sp)
8111e8c4:	10009426 	beq	r2,zero,8111eb18 <___svfprintf_internal_r+0x18ac>
8111e8c8:	d8c02d17 	ldw	r3,180(sp)
8111e8cc:	d9002917 	ldw	r4,164(sp)
8111e8d0:	002d883a 	mov	r22,zero
8111e8d4:	18800104 	addi	r2,r3,4
8111e8d8:	1d00000b 	ldhu	r20,0(r3)
8111e8dc:	203ec10e 	bge	r4,zero,8111e3e4 <__reset+0xfb0fe3e4>
8111e8e0:	a586b03a 	or	r3,r20,r22
8111e8e4:	d8802d15 	stw	r2,180(sp)
8111e8e8:	183ec21e 	bne	r3,zero,8111e3f4 <__reset+0xfb0fe3f4>
8111e8ec:	0039883a 	mov	fp,zero
8111e8f0:	0005883a 	mov	r2,zero
8111e8f4:	003db806 	br	8111dfd8 <__reset+0xfb0fdfd8>
8111e8f8:	d8802d17 	ldw	r2,180(sp)
8111e8fc:	d8c02d17 	ldw	r3,180(sp)
8111e900:	d9002d17 	ldw	r4,180(sp)
8111e904:	10800017 	ldw	r2,0(r2)
8111e908:	18c00117 	ldw	r3,4(r3)
8111e90c:	21000204 	addi	r4,r4,8
8111e910:	d8803615 	stw	r2,216(sp)
8111e914:	d8c03715 	stw	r3,220(sp)
8111e918:	d9002d15 	stw	r4,180(sp)
8111e91c:	003b8206 	br	8111d728 <__reset+0xfb0fd728>
8111e920:	9080100c 	andi	r2,r18,64
8111e924:	10010726 	beq	r2,zero,8111ed44 <___svfprintf_internal_r+0x1ad8>
8111e928:	d8c02d17 	ldw	r3,180(sp)
8111e92c:	1d00000f 	ldh	r20,0(r3)
8111e930:	18c00104 	addi	r3,r3,4
8111e934:	d8c02d15 	stw	r3,180(sp)
8111e938:	a02dd7fa 	srai	r22,r20,31
8111e93c:	b005883a 	mov	r2,r22
8111e940:	003ba206 	br	8111d7cc <__reset+0xfb0fd7cc>
8111e944:	9080100c 	andi	r2,r18,64
8111e948:	10010526 	beq	r2,zero,8111ed60 <___svfprintf_internal_r+0x1af4>
8111e94c:	d9002d17 	ldw	r4,180(sp)
8111e950:	002d883a 	mov	r22,zero
8111e954:	2500000b 	ldhu	r20,0(r4)
8111e958:	21000104 	addi	r4,r4,4
8111e95c:	d9002d15 	stw	r4,180(sp)
8111e960:	003cfe06 	br	8111dd5c <__reset+0xfb0fdd5c>
8111e964:	bc400007 	ldb	r17,0(r23)
8111e968:	003a9606 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111e96c:	9080040c 	andi	r2,r18,16
8111e970:	10010126 	beq	r2,zero,8111ed78 <___svfprintf_internal_r+0x1b0c>
8111e974:	d9402d17 	ldw	r5,180(sp)
8111e978:	d8c02f17 	ldw	r3,188(sp)
8111e97c:	28800017 	ldw	r2,0(r5)
8111e980:	29400104 	addi	r5,r5,4
8111e984:	d9402d15 	stw	r5,180(sp)
8111e988:	10c00015 	stw	r3,0(r2)
8111e98c:	003a6406 	br	8111d320 <__reset+0xfb0fd320>
8111e990:	d9002917 	ldw	r4,164(sp)
8111e994:	d8002785 	stb	zero,158(sp)
8111e998:	203d8d16 	blt	r4,zero,8111dfd0 <__reset+0xfb0fdfd0>
8111e99c:	00bfdfc4 	movi	r2,-129
8111e9a0:	90a4703a 	and	r18,r18,r2
8111e9a4:	003b0506 	br	8111d5bc <__reset+0xfb0fd5bc>
8111e9a8:	01604574 	movhi	r5,33045
8111e9ac:	29698684 	addi	r5,r5,-23014
8111e9b0:	d9402b15 	stw	r5,172(sp)
8111e9b4:	d9402b17 	ldw	r5,172(sp)
8111e9b8:	1c47883a 	add	r3,r3,r17
8111e9bc:	10800044 	addi	r2,r2,1
8111e9c0:	41400015 	stw	r5,0(r8)
8111e9c4:	44400115 	stw	r17,4(r8)
8111e9c8:	d8c02015 	stw	r3,128(sp)
8111e9cc:	d8801f15 	stw	r2,124(sp)
8111e9d0:	010001c4 	movi	r4,7
8111e9d4:	20bf3016 	blt	r4,r2,8111e698 <__reset+0xfb0fe698>
8111e9d8:	42000204 	addi	r8,r8,8
8111e9dc:	003f3506 	br	8111e6b4 <__reset+0xfb0fe6b4>
8111e9e0:	01204574 	movhi	r4,33045
8111e9e4:	21298684 	addi	r4,r4,-23014
8111e9e8:	d9002b15 	stw	r4,172(sp)
8111e9ec:	003c5e06 	br	8111db68 <__reset+0xfb0fdb68>
8111e9f0:	d9402c17 	ldw	r5,176(sp)
8111e9f4:	d9801e04 	addi	r6,sp,120
8111e9f8:	9809883a 	mov	r4,r19
8111e9fc:	1129e8c0 	call	81129e8c <__ssprint_r>
8111ea00:	103b011e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111ea04:	d8c02017 	ldw	r3,128(sp)
8111ea08:	da000404 	addi	r8,sp,16
8111ea0c:	003d9306 	br	8111e05c <__reset+0xfb0fe05c>
8111ea10:	d8801f17 	ldw	r2,124(sp)
8111ea14:	01604574 	movhi	r5,33045
8111ea18:	01000044 	movi	r4,1
8111ea1c:	18c00044 	addi	r3,r3,1
8111ea20:	10800044 	addi	r2,r2,1
8111ea24:	29698604 	addi	r5,r5,-23016
8111ea28:	41000115 	stw	r4,4(r8)
8111ea2c:	41400015 	stw	r5,0(r8)
8111ea30:	d8c02015 	stw	r3,128(sp)
8111ea34:	d8801f15 	stw	r2,124(sp)
8111ea38:	010001c4 	movi	r4,7
8111ea3c:	2080b516 	blt	r4,r2,8111ed14 <___svfprintf_internal_r+0x1aa8>
8111ea40:	42000204 	addi	r8,r8,8
8111ea44:	8800041e 	bne	r17,zero,8111ea58 <___svfprintf_internal_r+0x17ec>
8111ea48:	d8803317 	ldw	r2,204(sp)
8111ea4c:	1000021e 	bne	r2,zero,8111ea58 <___svfprintf_internal_r+0x17ec>
8111ea50:	9080004c 	andi	r2,r18,1
8111ea54:	103c5b26 	beq	r2,zero,8111dbc4 <__reset+0xfb0fdbc4>
8111ea58:	d9003817 	ldw	r4,224(sp)
8111ea5c:	d8801f17 	ldw	r2,124(sp)
8111ea60:	d9403417 	ldw	r5,208(sp)
8111ea64:	20c7883a 	add	r3,r4,r3
8111ea68:	10800044 	addi	r2,r2,1
8111ea6c:	41000115 	stw	r4,4(r8)
8111ea70:	41400015 	stw	r5,0(r8)
8111ea74:	d8c02015 	stw	r3,128(sp)
8111ea78:	d8801f15 	stw	r2,124(sp)
8111ea7c:	010001c4 	movi	r4,7
8111ea80:	20818016 	blt	r4,r2,8111f084 <___svfprintf_internal_r+0x1e18>
8111ea84:	42000204 	addi	r8,r8,8
8111ea88:	0463c83a 	sub	r17,zero,r17
8111ea8c:	0440cb0e 	bge	zero,r17,8111edbc <___svfprintf_internal_r+0x1b50>
8111ea90:	05800404 	movi	r22,16
8111ea94:	b440e80e 	bge	r22,r17,8111ee38 <___svfprintf_internal_r+0x1bcc>
8111ea98:	01604574 	movhi	r5,33045
8111ea9c:	29698684 	addi	r5,r5,-23014
8111eaa0:	d9402b15 	stw	r5,172(sp)
8111eaa4:	070001c4 	movi	fp,7
8111eaa8:	dd002c17 	ldw	r20,176(sp)
8111eaac:	00000306 	br	8111eabc <___svfprintf_internal_r+0x1850>
8111eab0:	42000204 	addi	r8,r8,8
8111eab4:	8c7ffc04 	addi	r17,r17,-16
8111eab8:	b440e20e 	bge	r22,r17,8111ee44 <___svfprintf_internal_r+0x1bd8>
8111eabc:	18c00404 	addi	r3,r3,16
8111eac0:	10800044 	addi	r2,r2,1
8111eac4:	45400015 	stw	r21,0(r8)
8111eac8:	45800115 	stw	r22,4(r8)
8111eacc:	d8c02015 	stw	r3,128(sp)
8111ead0:	d8801f15 	stw	r2,124(sp)
8111ead4:	e0bff60e 	bge	fp,r2,8111eab0 <__reset+0xfb0feab0>
8111ead8:	d9801e04 	addi	r6,sp,120
8111eadc:	a00b883a 	mov	r5,r20
8111eae0:	9809883a 	mov	r4,r19
8111eae4:	1129e8c0 	call	81129e8c <__ssprint_r>
8111eae8:	103ac71e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111eaec:	d8c02017 	ldw	r3,128(sp)
8111eaf0:	d8801f17 	ldw	r2,124(sp)
8111eaf4:	da000404 	addi	r8,sp,16
8111eaf8:	003fee06 	br	8111eab4 <__reset+0xfb0feab4>
8111eafc:	d8c02d17 	ldw	r3,180(sp)
8111eb00:	d9002917 	ldw	r4,164(sp)
8111eb04:	002d883a 	mov	r22,zero
8111eb08:	18800104 	addi	r2,r3,4
8111eb0c:	1d000017 	ldw	r20,0(r3)
8111eb10:	203e7d0e 	bge	r4,zero,8111e508 <__reset+0xfb0fe508>
8111eb14:	003eda06 	br	8111e680 <__reset+0xfb0fe680>
8111eb18:	d9402d17 	ldw	r5,180(sp)
8111eb1c:	d8c02917 	ldw	r3,164(sp)
8111eb20:	002d883a 	mov	r22,zero
8111eb24:	28800104 	addi	r2,r5,4
8111eb28:	2d000017 	ldw	r20,0(r5)
8111eb2c:	183e2d0e 	bge	r3,zero,8111e3e4 <__reset+0xfb0fe3e4>
8111eb30:	003f6b06 	br	8111e8e0 <__reset+0xfb0fe8e0>
8111eb34:	d8c02d15 	stw	r3,180(sp)
8111eb38:	0039883a 	mov	fp,zero
8111eb3c:	003ed206 	br	8111e688 <__reset+0xfb0fe688>
8111eb40:	bc400043 	ldbu	r17,1(r23)
8111eb44:	94800814 	ori	r18,r18,32
8111eb48:	bdc00044 	addi	r23,r23,1
8111eb4c:	8c403fcc 	andi	r17,r17,255
8111eb50:	8c40201c 	xori	r17,r17,128
8111eb54:	8c7fe004 	addi	r17,r17,-128
8111eb58:	003a1a06 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111eb5c:	d9402c17 	ldw	r5,176(sp)
8111eb60:	d9801e04 	addi	r6,sp,120
8111eb64:	9809883a 	mov	r4,r19
8111eb68:	1129e8c0 	call	81129e8c <__ssprint_r>
8111eb6c:	103aa61e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111eb70:	d8c02017 	ldw	r3,128(sp)
8111eb74:	da000404 	addi	r8,sp,16
8111eb78:	003d4a06 	br	8111e0a4 <__reset+0xfb0fe0a4>
8111eb7c:	d9002917 	ldw	r4,164(sp)
8111eb80:	05bff7c4 	movi	r22,-33
8111eb84:	00bfffc4 	movi	r2,-1
8111eb88:	8dac703a 	and	r22,r17,r22
8111eb8c:	20806a26 	beq	r4,r2,8111ed38 <___svfprintf_internal_r+0x1acc>
8111eb90:	008011c4 	movi	r2,71
8111eb94:	b0813726 	beq	r22,r2,8111f074 <___svfprintf_internal_r+0x1e08>
8111eb98:	d9003717 	ldw	r4,220(sp)
8111eb9c:	90c04014 	ori	r3,r18,256
8111eba0:	d8c02b15 	stw	r3,172(sp)
8111eba4:	20015d16 	blt	r4,zero,8111f11c <___svfprintf_internal_r+0x1eb0>
8111eba8:	dd003717 	ldw	r20,220(sp)
8111ebac:	d8002a05 	stb	zero,168(sp)
8111ebb0:	00801984 	movi	r2,102
8111ebb4:	88814026 	beq	r17,r2,8111f0b8 <___svfprintf_internal_r+0x1e4c>
8111ebb8:	00801184 	movi	r2,70
8111ebbc:	88817126 	beq	r17,r2,8111f184 <___svfprintf_internal_r+0x1f18>
8111ebc0:	00801144 	movi	r2,69
8111ebc4:	b0816226 	beq	r22,r2,8111f150 <___svfprintf_internal_r+0x1ee4>
8111ebc8:	d8c02917 	ldw	r3,164(sp)
8111ebcc:	d8802104 	addi	r2,sp,132
8111ebd0:	d8800315 	stw	r2,12(sp)
8111ebd4:	d9403617 	ldw	r5,216(sp)
8111ebd8:	d8802504 	addi	r2,sp,148
8111ebdc:	d8800215 	stw	r2,8(sp)
8111ebe0:	d8802604 	addi	r2,sp,152
8111ebe4:	d8c00015 	stw	r3,0(sp)
8111ebe8:	d8800115 	stw	r2,4(sp)
8111ebec:	01c00084 	movi	r7,2
8111ebf0:	a00d883a 	mov	r6,r20
8111ebf4:	9809883a 	mov	r4,r19
8111ebf8:	d8c03d15 	stw	r3,244(sp)
8111ebfc:	da003e15 	stw	r8,248(sp)
8111ec00:	11235580 	call	81123558 <_dtoa_r>
8111ec04:	1021883a 	mov	r16,r2
8111ec08:	008019c4 	movi	r2,103
8111ec0c:	d8c03d17 	ldw	r3,244(sp)
8111ec10:	da003e17 	ldw	r8,248(sp)
8111ec14:	8880e726 	beq	r17,r2,8111efb4 <___svfprintf_internal_r+0x1d48>
8111ec18:	008011c4 	movi	r2,71
8111ec1c:	8880d426 	beq	r17,r2,8111ef70 <___svfprintf_internal_r+0x1d04>
8111ec20:	80f9883a 	add	fp,r16,r3
8111ec24:	d9003617 	ldw	r4,216(sp)
8111ec28:	000d883a 	mov	r6,zero
8111ec2c:	000f883a 	mov	r7,zero
8111ec30:	a00b883a 	mov	r5,r20
8111ec34:	da003e15 	stw	r8,248(sp)
8111ec38:	112fe840 	call	8112fe84 <__eqdf2>
8111ec3c:	da003e17 	ldw	r8,248(sp)
8111ec40:	1000e426 	beq	r2,zero,8111efd4 <___svfprintf_internal_r+0x1d68>
8111ec44:	d8802117 	ldw	r2,132(sp)
8111ec48:	1700062e 	bgeu	r2,fp,8111ec64 <___svfprintf_internal_r+0x19f8>
8111ec4c:	01000c04 	movi	r4,48
8111ec50:	10c00044 	addi	r3,r2,1
8111ec54:	d8c02115 	stw	r3,132(sp)
8111ec58:	11000005 	stb	r4,0(r2)
8111ec5c:	d8802117 	ldw	r2,132(sp)
8111ec60:	173ffb36 	bltu	r2,fp,8111ec50 <__reset+0xfb0fec50>
8111ec64:	1405c83a 	sub	r2,r2,r16
8111ec68:	d8803315 	stw	r2,204(sp)
8111ec6c:	008011c4 	movi	r2,71
8111ec70:	b080c526 	beq	r22,r2,8111ef88 <___svfprintf_internal_r+0x1d1c>
8111ec74:	00801944 	movi	r2,101
8111ec78:	1441d90e 	bge	r2,r17,8111f3e0 <___svfprintf_internal_r+0x2174>
8111ec7c:	d8c02617 	ldw	r3,152(sp)
8111ec80:	00801984 	movi	r2,102
8111ec84:	d8c03215 	stw	r3,200(sp)
8111ec88:	88813426 	beq	r17,r2,8111f15c <___svfprintf_internal_r+0x1ef0>
8111ec8c:	d8c03217 	ldw	r3,200(sp)
8111ec90:	d9003317 	ldw	r4,204(sp)
8111ec94:	19012516 	blt	r3,r4,8111f12c <___svfprintf_internal_r+0x1ec0>
8111ec98:	9480004c 	andi	r18,r18,1
8111ec9c:	9001841e 	bne	r18,zero,8111f2b0 <___svfprintf_internal_r+0x2044>
8111eca0:	1805883a 	mov	r2,r3
8111eca4:	1801cc16 	blt	r3,zero,8111f3d8 <___svfprintf_internal_r+0x216c>
8111eca8:	d8c03217 	ldw	r3,200(sp)
8111ecac:	044019c4 	movi	r17,103
8111ecb0:	d8c02e15 	stw	r3,184(sp)
8111ecb4:	df002a07 	ldb	fp,168(sp)
8111ecb8:	e000a61e 	bne	fp,zero,8111ef54 <___svfprintf_internal_r+0x1ce8>
8111ecbc:	df002783 	ldbu	fp,158(sp)
8111ecc0:	d8802a15 	stw	r2,168(sp)
8111ecc4:	dc802b17 	ldw	r18,172(sp)
8111ecc8:	d8002915 	stw	zero,164(sp)
8111eccc:	003b1706 	br	8111d92c <__reset+0xfb0fd92c>
8111ecd0:	04204574 	movhi	r16,33045
8111ecd4:	84297604 	addi	r16,r16,-23080
8111ecd8:	003aa606 	br	8111d774 <__reset+0xfb0fd774>
8111ecdc:	d9003917 	ldw	r4,228(sp)
8111ece0:	04001004 	movi	r16,64
8111ece4:	800b883a 	mov	r5,r16
8111ece8:	111bc2c0 	call	8111bc2c <_malloc_r>
8111ecec:	d9002c17 	ldw	r4,176(sp)
8111ecf0:	20800015 	stw	r2,0(r4)
8111ecf4:	20800415 	stw	r2,16(r4)
8111ecf8:	1001cb26 	beq	r2,zero,8111f428 <___svfprintf_internal_r+0x21bc>
8111ecfc:	d8802c17 	ldw	r2,176(sp)
8111ed00:	14000515 	stw	r16,20(r2)
8111ed04:	00397606 	br	8111d2e0 <__reset+0xfb0fd2e0>
8111ed08:	04204574 	movhi	r16,33045
8111ed0c:	84297804 	addi	r16,r16,-23072
8111ed10:	003ee106 	br	8111e898 <__reset+0xfb0fe898>
8111ed14:	d9402c17 	ldw	r5,176(sp)
8111ed18:	d9801e04 	addi	r6,sp,120
8111ed1c:	9809883a 	mov	r4,r19
8111ed20:	1129e8c0 	call	81129e8c <__ssprint_r>
8111ed24:	103a381e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111ed28:	dc402617 	ldw	r17,152(sp)
8111ed2c:	d8c02017 	ldw	r3,128(sp)
8111ed30:	da000404 	addi	r8,sp,16
8111ed34:	003f4306 	br	8111ea44 <__reset+0xfb0fea44>
8111ed38:	01400184 	movi	r5,6
8111ed3c:	d9402915 	stw	r5,164(sp)
8111ed40:	003f9506 	br	8111eb98 <__reset+0xfb0feb98>
8111ed44:	d9002d17 	ldw	r4,180(sp)
8111ed48:	25000017 	ldw	r20,0(r4)
8111ed4c:	21000104 	addi	r4,r4,4
8111ed50:	d9002d15 	stw	r4,180(sp)
8111ed54:	a02dd7fa 	srai	r22,r20,31
8111ed58:	b005883a 	mov	r2,r22
8111ed5c:	003a9b06 	br	8111d7cc <__reset+0xfb0fd7cc>
8111ed60:	d9402d17 	ldw	r5,180(sp)
8111ed64:	002d883a 	mov	r22,zero
8111ed68:	2d000017 	ldw	r20,0(r5)
8111ed6c:	29400104 	addi	r5,r5,4
8111ed70:	d9402d15 	stw	r5,180(sp)
8111ed74:	003bf906 	br	8111dd5c <__reset+0xfb0fdd5c>
8111ed78:	9480100c 	andi	r18,r18,64
8111ed7c:	90006e26 	beq	r18,zero,8111ef38 <___svfprintf_internal_r+0x1ccc>
8111ed80:	d9002d17 	ldw	r4,180(sp)
8111ed84:	d9402f17 	ldw	r5,188(sp)
8111ed88:	20800017 	ldw	r2,0(r4)
8111ed8c:	21000104 	addi	r4,r4,4
8111ed90:	d9002d15 	stw	r4,180(sp)
8111ed94:	1140000d 	sth	r5,0(r2)
8111ed98:	00396106 	br	8111d320 <__reset+0xfb0fd320>
8111ed9c:	d9402c17 	ldw	r5,176(sp)
8111eda0:	d9801e04 	addi	r6,sp,120
8111eda4:	9809883a 	mov	r4,r19
8111eda8:	1129e8c0 	call	81129e8c <__ssprint_r>
8111edac:	103a161e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111edb0:	d8c02017 	ldw	r3,128(sp)
8111edb4:	d8801f17 	ldw	r2,124(sp)
8111edb8:	da000404 	addi	r8,sp,16
8111edbc:	d9403317 	ldw	r5,204(sp)
8111edc0:	10800044 	addi	r2,r2,1
8111edc4:	44000015 	stw	r16,0(r8)
8111edc8:	28c7883a 	add	r3,r5,r3
8111edcc:	003b7706 	br	8111dbac <__reset+0xfb0fdbac>
8111edd0:	8009883a 	mov	r4,r16
8111edd4:	da003e15 	stw	r8,248(sp)
8111edd8:	111cf340 	call	8111cf34 <strlen>
8111eddc:	d8802e15 	stw	r2,184(sp)
8111ede0:	da003e17 	ldw	r8,248(sp)
8111ede4:	103c280e 	bge	r2,zero,8111de88 <__reset+0xfb0fde88>
8111ede8:	0005883a 	mov	r2,zero
8111edec:	003c2606 	br	8111de88 <__reset+0xfb0fde88>
8111edf0:	00bfffc4 	movi	r2,-1
8111edf4:	003a0906 	br	8111d61c <__reset+0xfb0fd61c>
8111edf8:	01204574 	movhi	r4,33045
8111edfc:	21298a84 	addi	r4,r4,-22998
8111ee00:	d9003515 	stw	r4,212(sp)
8111ee04:	003b0606 	br	8111da20 <__reset+0xfb0fda20>
8111ee08:	013fffc4 	movi	r4,-1
8111ee0c:	003a2706 	br	8111d6ac <__reset+0xfb0fd6ac>
8111ee10:	d9402c17 	ldw	r5,176(sp)
8111ee14:	d9801e04 	addi	r6,sp,120
8111ee18:	9809883a 	mov	r4,r19
8111ee1c:	1129e8c0 	call	81129e8c <__ssprint_r>
8111ee20:	1039f91e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111ee24:	d8c02017 	ldw	r3,128(sp)
8111ee28:	da000404 	addi	r8,sp,16
8111ee2c:	003d8406 	br	8111e440 <__reset+0xfb0fe440>
8111ee30:	0023883a 	mov	r17,zero
8111ee34:	003d8306 	br	8111e444 <__reset+0xfb0fe444>
8111ee38:	01204574 	movhi	r4,33045
8111ee3c:	21298684 	addi	r4,r4,-23014
8111ee40:	d9002b15 	stw	r4,172(sp)
8111ee44:	d9002b17 	ldw	r4,172(sp)
8111ee48:	1c47883a 	add	r3,r3,r17
8111ee4c:	10800044 	addi	r2,r2,1
8111ee50:	41000015 	stw	r4,0(r8)
8111ee54:	44400115 	stw	r17,4(r8)
8111ee58:	d8c02015 	stw	r3,128(sp)
8111ee5c:	d8801f15 	stw	r2,124(sp)
8111ee60:	010001c4 	movi	r4,7
8111ee64:	20bfcd16 	blt	r4,r2,8111ed9c <__reset+0xfb0fed9c>
8111ee68:	42000204 	addi	r8,r8,8
8111ee6c:	003fd306 	br	8111edbc <__reset+0xfb0fedbc>
8111ee70:	d9402c17 	ldw	r5,176(sp)
8111ee74:	d9801e04 	addi	r6,sp,120
8111ee78:	9809883a 	mov	r4,r19
8111ee7c:	1129e8c0 	call	81129e8c <__ssprint_r>
8111ee80:	1039e11e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111ee84:	d8802617 	ldw	r2,152(sp)
8111ee88:	d8c02017 	ldw	r3,128(sp)
8111ee8c:	da000404 	addi	r8,sp,16
8111ee90:	003e1c06 	br	8111e704 <__reset+0xfb0fe704>
8111ee94:	d8802917 	ldw	r2,164(sp)
8111ee98:	00c00184 	movi	r3,6
8111ee9c:	1880012e 	bgeu	r3,r2,8111eea4 <___svfprintf_internal_r+0x1c38>
8111eea0:	1805883a 	mov	r2,r3
8111eea4:	d8802e15 	stw	r2,184(sp)
8111eea8:	1000f316 	blt	r2,zero,8111f278 <___svfprintf_internal_r+0x200c>
8111eeac:	04204574 	movhi	r16,33045
8111eeb0:	d8802a15 	stw	r2,168(sp)
8111eeb4:	dd002d15 	stw	r20,180(sp)
8111eeb8:	d8002915 	stw	zero,164(sp)
8111eebc:	d8003215 	stw	zero,200(sp)
8111eec0:	84298404 	addi	r16,r16,-23024
8111eec4:	0039883a 	mov	fp,zero
8111eec8:	003a9f06 	br	8111d948 <__reset+0xfb0fd948>
8111eecc:	01204574 	movhi	r4,33045
8111eed0:	21298a84 	addi	r4,r4,-22998
8111eed4:	d9003515 	stw	r4,212(sp)
8111eed8:	003b5f06 	br	8111dc58 <__reset+0xfb0fdc58>
8111eedc:	d9402c17 	ldw	r5,176(sp)
8111eee0:	d9801e04 	addi	r6,sp,120
8111eee4:	9809883a 	mov	r4,r19
8111eee8:	1129e8c0 	call	81129e8c <__ssprint_r>
8111eeec:	1039c61e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111eef0:	d8802617 	ldw	r2,152(sp)
8111eef4:	d9403317 	ldw	r5,204(sp)
8111eef8:	d8c02017 	ldw	r3,128(sp)
8111eefc:	da000404 	addi	r8,sp,16
8111ef00:	2885c83a 	sub	r2,r5,r2
8111ef04:	003e1006 	br	8111e748 <__reset+0xfb0fe748>
8111ef08:	00800044 	movi	r2,1
8111ef0c:	10803fcc 	andi	r2,r2,255
8111ef10:	00c00044 	movi	r3,1
8111ef14:	10fa3526 	beq	r2,r3,8111d7ec <__reset+0xfb0fd7ec>
8111ef18:	00c00084 	movi	r3,2
8111ef1c:	10fb9e26 	beq	r2,r3,8111dd98 <__reset+0xfb0fdd98>
8111ef20:	003a6406 	br	8111d8b4 <__reset+0xfb0fd8b4>
8111ef24:	0021883a 	mov	r16,zero
8111ef28:	003e0806 	br	8111e74c <__reset+0xfb0fe74c>
8111ef2c:	07000b44 	movi	fp,45
8111ef30:	df002785 	stb	fp,158(sp)
8111ef34:	003a0b06 	br	8111d764 <__reset+0xfb0fd764>
8111ef38:	d8c02d17 	ldw	r3,180(sp)
8111ef3c:	d9002f17 	ldw	r4,188(sp)
8111ef40:	18800017 	ldw	r2,0(r3)
8111ef44:	18c00104 	addi	r3,r3,4
8111ef48:	d8c02d15 	stw	r3,180(sp)
8111ef4c:	11000015 	stw	r4,0(r2)
8111ef50:	0038f306 	br	8111d320 <__reset+0xfb0fd320>
8111ef54:	00c00b44 	movi	r3,45
8111ef58:	d8c02785 	stb	r3,158(sp)
8111ef5c:	d8802a15 	stw	r2,168(sp)
8111ef60:	dc802b17 	ldw	r18,172(sp)
8111ef64:	d8002915 	stw	zero,164(sp)
8111ef68:	07000b44 	movi	fp,45
8111ef6c:	003a7306 	br	8111d93c <__reset+0xfb0fd93c>
8111ef70:	9080004c 	andi	r2,r18,1
8111ef74:	1000941e 	bne	r2,zero,8111f1c8 <___svfprintf_internal_r+0x1f5c>
8111ef78:	d8802117 	ldw	r2,132(sp)
8111ef7c:	1405c83a 	sub	r2,r2,r16
8111ef80:	d8803315 	stw	r2,204(sp)
8111ef84:	b441161e 	bne	r22,r17,8111f3e0 <___svfprintf_internal_r+0x2174>
8111ef88:	dd802617 	ldw	r22,152(sp)
8111ef8c:	00bfff44 	movi	r2,-3
8111ef90:	b0801a16 	blt	r22,r2,8111effc <___svfprintf_internal_r+0x1d90>
8111ef94:	d9402917 	ldw	r5,164(sp)
8111ef98:	2d801816 	blt	r5,r22,8111effc <___svfprintf_internal_r+0x1d90>
8111ef9c:	dd803215 	stw	r22,200(sp)
8111efa0:	003f3a06 	br	8111ec8c <__reset+0xfb0fec8c>
8111efa4:	1025883a 	mov	r18,r2
8111efa8:	0039883a 	mov	fp,zero
8111efac:	00800084 	movi	r2,2
8111efb0:	003fd606 	br	8111ef0c <__reset+0xfb0fef0c>
8111efb4:	9080004c 	andi	r2,r18,1
8111efb8:	103f191e 	bne	r2,zero,8111ec20 <__reset+0xfb0fec20>
8111efbc:	d8802117 	ldw	r2,132(sp)
8111efc0:	003f2806 	br	8111ec64 <__reset+0xfb0fec64>
8111efc4:	01204574 	movhi	r4,33045
8111efc8:	21298684 	addi	r4,r4,-23014
8111efcc:	d9002b15 	stw	r4,172(sp)
8111efd0:	003c7c06 	br	8111e1c4 <__reset+0xfb0fe1c4>
8111efd4:	e005883a 	mov	r2,fp
8111efd8:	003f2206 	br	8111ec64 <__reset+0xfb0fec64>
8111efdc:	d9402917 	ldw	r5,164(sp)
8111efe0:	df002783 	ldbu	fp,158(sp)
8111efe4:	dd002d15 	stw	r20,180(sp)
8111efe8:	d9402a15 	stw	r5,168(sp)
8111efec:	d9402e15 	stw	r5,184(sp)
8111eff0:	d8002915 	stw	zero,164(sp)
8111eff4:	d8003215 	stw	zero,200(sp)
8111eff8:	003a4c06 	br	8111d92c <__reset+0xfb0fd92c>
8111effc:	8c7fff84 	addi	r17,r17,-2
8111f000:	b5bfffc4 	addi	r22,r22,-1
8111f004:	dd802615 	stw	r22,152(sp)
8111f008:	dc4022c5 	stb	r17,139(sp)
8111f00c:	b000c316 	blt	r22,zero,8111f31c <___svfprintf_internal_r+0x20b0>
8111f010:	00800ac4 	movi	r2,43
8111f014:	d8802305 	stb	r2,140(sp)
8111f018:	00800244 	movi	r2,9
8111f01c:	15806e16 	blt	r2,r22,8111f1d8 <___svfprintf_internal_r+0x1f6c>
8111f020:	00800c04 	movi	r2,48
8111f024:	b5800c04 	addi	r22,r22,48
8111f028:	d8802345 	stb	r2,141(sp)
8111f02c:	dd802385 	stb	r22,142(sp)
8111f030:	d88023c4 	addi	r2,sp,143
8111f034:	df0022c4 	addi	fp,sp,139
8111f038:	d8c03317 	ldw	r3,204(sp)
8111f03c:	1739c83a 	sub	fp,r2,fp
8111f040:	d9003317 	ldw	r4,204(sp)
8111f044:	e0c7883a 	add	r3,fp,r3
8111f048:	df003b15 	stw	fp,236(sp)
8111f04c:	d8c02e15 	stw	r3,184(sp)
8111f050:	00800044 	movi	r2,1
8111f054:	1100b70e 	bge	r2,r4,8111f334 <___svfprintf_internal_r+0x20c8>
8111f058:	d8c02e17 	ldw	r3,184(sp)
8111f05c:	18c00044 	addi	r3,r3,1
8111f060:	d8c02e15 	stw	r3,184(sp)
8111f064:	1805883a 	mov	r2,r3
8111f068:	1800b016 	blt	r3,zero,8111f32c <___svfprintf_internal_r+0x20c0>
8111f06c:	d8003215 	stw	zero,200(sp)
8111f070:	003f1006 	br	8111ecb4 <__reset+0xfb0fecb4>
8111f074:	d8802917 	ldw	r2,164(sp)
8111f078:	103ec71e 	bne	r2,zero,8111eb98 <__reset+0xfb0feb98>
8111f07c:	dc002915 	stw	r16,164(sp)
8111f080:	003ec506 	br	8111eb98 <__reset+0xfb0feb98>
8111f084:	d9402c17 	ldw	r5,176(sp)
8111f088:	d9801e04 	addi	r6,sp,120
8111f08c:	9809883a 	mov	r4,r19
8111f090:	1129e8c0 	call	81129e8c <__ssprint_r>
8111f094:	10395c1e 	bne	r2,zero,8111d608 <__reset+0xfb0fd608>
8111f098:	dc402617 	ldw	r17,152(sp)
8111f09c:	d8c02017 	ldw	r3,128(sp)
8111f0a0:	d8801f17 	ldw	r2,124(sp)
8111f0a4:	da000404 	addi	r8,sp,16
8111f0a8:	003e7706 	br	8111ea88 <__reset+0xfb0fea88>
8111f0ac:	582f883a 	mov	r23,r11
8111f0b0:	d8002915 	stw	zero,164(sp)
8111f0b4:	0038c406 	br	8111d3c8 <__reset+0xfb0fd3c8>
8111f0b8:	d8c02917 	ldw	r3,164(sp)
8111f0bc:	d8802104 	addi	r2,sp,132
8111f0c0:	d8800315 	stw	r2,12(sp)
8111f0c4:	d9403617 	ldw	r5,216(sp)
8111f0c8:	d8802504 	addi	r2,sp,148
8111f0cc:	d8800215 	stw	r2,8(sp)
8111f0d0:	d8802604 	addi	r2,sp,152
8111f0d4:	d8c00015 	stw	r3,0(sp)
8111f0d8:	9809883a 	mov	r4,r19
8111f0dc:	d8800115 	stw	r2,4(sp)
8111f0e0:	01c000c4 	movi	r7,3
8111f0e4:	a00d883a 	mov	r6,r20
8111f0e8:	da003e15 	stw	r8,248(sp)
8111f0ec:	11235580 	call	81123558 <_dtoa_r>
8111f0f0:	d9002917 	ldw	r4,164(sp)
8111f0f4:	da003e17 	ldw	r8,248(sp)
8111f0f8:	1021883a 	mov	r16,r2
8111f0fc:	1139883a 	add	fp,r2,r4
8111f100:	2007883a 	mov	r3,r4
8111f104:	81000007 	ldb	r4,0(r16)
8111f108:	00800c04 	movi	r2,48
8111f10c:	20806f26 	beq	r4,r2,8111f2cc <___svfprintf_internal_r+0x2060>
8111f110:	d8c02617 	ldw	r3,152(sp)
8111f114:	e0f9883a 	add	fp,fp,r3
8111f118:	003ec206 	br	8111ec24 <__reset+0xfb0fec24>
8111f11c:	00c00b44 	movi	r3,45
8111f120:	2520003c 	xorhi	r20,r4,32768
8111f124:	d8c02a05 	stb	r3,168(sp)
8111f128:	003ea106 	br	8111ebb0 <__reset+0xfb0febb0>
8111f12c:	d8c03217 	ldw	r3,200(sp)
8111f130:	00c0890e 	bge	zero,r3,8111f358 <___svfprintf_internal_r+0x20ec>
8111f134:	00800044 	movi	r2,1
8111f138:	d9003317 	ldw	r4,204(sp)
8111f13c:	1105883a 	add	r2,r2,r4
8111f140:	d8802e15 	stw	r2,184(sp)
8111f144:	10005f16 	blt	r2,zero,8111f2c4 <___svfprintf_internal_r+0x2058>
8111f148:	044019c4 	movi	r17,103
8111f14c:	003ed906 	br	8111ecb4 <__reset+0xfb0fecb4>
8111f150:	d9002917 	ldw	r4,164(sp)
8111f154:	20c00044 	addi	r3,r4,1
8111f158:	003e9c06 	br	8111ebcc <__reset+0xfb0febcc>
8111f15c:	d9002917 	ldw	r4,164(sp)
8111f160:	00c0680e 	bge	zero,r3,8111f304 <___svfprintf_internal_r+0x2098>
8111f164:	2000461e 	bne	r4,zero,8111f280 <___svfprintf_internal_r+0x2014>
8111f168:	9480004c 	andi	r18,r18,1
8111f16c:	9000441e 	bne	r18,zero,8111f280 <___svfprintf_internal_r+0x2014>
8111f170:	1805883a 	mov	r2,r3
8111f174:	1800a016 	blt	r3,zero,8111f3f8 <___svfprintf_internal_r+0x218c>
8111f178:	d8c03217 	ldw	r3,200(sp)
8111f17c:	d8c02e15 	stw	r3,184(sp)
8111f180:	003ecc06 	br	8111ecb4 <__reset+0xfb0fecb4>
8111f184:	d9402917 	ldw	r5,164(sp)
8111f188:	d8802104 	addi	r2,sp,132
8111f18c:	d8800315 	stw	r2,12(sp)
8111f190:	d9400015 	stw	r5,0(sp)
8111f194:	d8802504 	addi	r2,sp,148
8111f198:	d9403617 	ldw	r5,216(sp)
8111f19c:	d8800215 	stw	r2,8(sp)
8111f1a0:	d8802604 	addi	r2,sp,152
8111f1a4:	d8800115 	stw	r2,4(sp)
8111f1a8:	01c000c4 	movi	r7,3
8111f1ac:	a00d883a 	mov	r6,r20
8111f1b0:	9809883a 	mov	r4,r19
8111f1b4:	da003e15 	stw	r8,248(sp)
8111f1b8:	11235580 	call	81123558 <_dtoa_r>
8111f1bc:	d8c02917 	ldw	r3,164(sp)
8111f1c0:	da003e17 	ldw	r8,248(sp)
8111f1c4:	1021883a 	mov	r16,r2
8111f1c8:	00801184 	movi	r2,70
8111f1cc:	80f9883a 	add	fp,r16,r3
8111f1d0:	88bfcc26 	beq	r17,r2,8111f104 <__reset+0xfb0ff104>
8111f1d4:	003e9306 	br	8111ec24 <__reset+0xfb0fec24>
8111f1d8:	df0022c4 	addi	fp,sp,139
8111f1dc:	dc002915 	stw	r16,164(sp)
8111f1e0:	9829883a 	mov	r20,r19
8111f1e4:	e021883a 	mov	r16,fp
8111f1e8:	4027883a 	mov	r19,r8
8111f1ec:	b009883a 	mov	r4,r22
8111f1f0:	01400284 	movi	r5,10
8111f1f4:	112e9b40 	call	8112e9b4 <__modsi3>
8111f1f8:	10800c04 	addi	r2,r2,48
8111f1fc:	843fffc4 	addi	r16,r16,-1
8111f200:	b009883a 	mov	r4,r22
8111f204:	01400284 	movi	r5,10
8111f208:	80800005 	stb	r2,0(r16)
8111f20c:	112e9300 	call	8112e930 <__divsi3>
8111f210:	102d883a 	mov	r22,r2
8111f214:	00800244 	movi	r2,9
8111f218:	15bff416 	blt	r2,r22,8111f1ec <__reset+0xfb0ff1ec>
8111f21c:	9811883a 	mov	r8,r19
8111f220:	b0800c04 	addi	r2,r22,48
8111f224:	a027883a 	mov	r19,r20
8111f228:	8029883a 	mov	r20,r16
8111f22c:	a17fffc4 	addi	r5,r20,-1
8111f230:	a0bfffc5 	stb	r2,-1(r20)
8111f234:	dc002917 	ldw	r16,164(sp)
8111f238:	2f00752e 	bgeu	r5,fp,8111f410 <___svfprintf_internal_r+0x21a4>
8111f23c:	d9c02384 	addi	r7,sp,142
8111f240:	3d0fc83a 	sub	r7,r7,r20
8111f244:	d9002344 	addi	r4,sp,141
8111f248:	e1cf883a 	add	r7,fp,r7
8111f24c:	00000106 	br	8111f254 <___svfprintf_internal_r+0x1fe8>
8111f250:	28800003 	ldbu	r2,0(r5)
8111f254:	20800005 	stb	r2,0(r4)
8111f258:	21000044 	addi	r4,r4,1
8111f25c:	29400044 	addi	r5,r5,1
8111f260:	21fffb1e 	bne	r4,r7,8111f250 <__reset+0xfb0ff250>
8111f264:	d8802304 	addi	r2,sp,140
8111f268:	1505c83a 	sub	r2,r2,r20
8111f26c:	d8c02344 	addi	r3,sp,141
8111f270:	1885883a 	add	r2,r3,r2
8111f274:	003f7006 	br	8111f038 <__reset+0xfb0ff038>
8111f278:	0005883a 	mov	r2,zero
8111f27c:	003f0b06 	br	8111eeac <__reset+0xfb0feeac>
8111f280:	d9002917 	ldw	r4,164(sp)
8111f284:	d8c03217 	ldw	r3,200(sp)
8111f288:	20800044 	addi	r2,r4,1
8111f28c:	1885883a 	add	r2,r3,r2
8111f290:	d8802e15 	stw	r2,184(sp)
8111f294:	103e870e 	bge	r2,zero,8111ecb4 <__reset+0xfb0fecb4>
8111f298:	0005883a 	mov	r2,zero
8111f29c:	003e8506 	br	8111ecb4 <__reset+0xfb0fecb4>
8111f2a0:	01204574 	movhi	r4,33045
8111f2a4:	21298684 	addi	r4,r4,-23014
8111f2a8:	d9002b15 	stw	r4,172(sp)
8111f2ac:	003cc506 	br	8111e5c4 <__reset+0xfb0fe5c4>
8111f2b0:	d8c03217 	ldw	r3,200(sp)
8111f2b4:	18c00044 	addi	r3,r3,1
8111f2b8:	d8c02e15 	stw	r3,184(sp)
8111f2bc:	1805883a 	mov	r2,r3
8111f2c0:	183fa10e 	bge	r3,zero,8111f148 <__reset+0xfb0ff148>
8111f2c4:	0005883a 	mov	r2,zero
8111f2c8:	003f9f06 	br	8111f148 <__reset+0xfb0ff148>
8111f2cc:	d9003617 	ldw	r4,216(sp)
8111f2d0:	000d883a 	mov	r6,zero
8111f2d4:	000f883a 	mov	r7,zero
8111f2d8:	a00b883a 	mov	r5,r20
8111f2dc:	d8c03d15 	stw	r3,244(sp)
8111f2e0:	da003e15 	stw	r8,248(sp)
8111f2e4:	112fe840 	call	8112fe84 <__eqdf2>
8111f2e8:	d8c03d17 	ldw	r3,244(sp)
8111f2ec:	da003e17 	ldw	r8,248(sp)
8111f2f0:	103f8726 	beq	r2,zero,8111f110 <__reset+0xfb0ff110>
8111f2f4:	00800044 	movi	r2,1
8111f2f8:	10c7c83a 	sub	r3,r2,r3
8111f2fc:	d8c02615 	stw	r3,152(sp)
8111f300:	003f8406 	br	8111f114 <__reset+0xfb0ff114>
8111f304:	20000e1e 	bne	r4,zero,8111f340 <___svfprintf_internal_r+0x20d4>
8111f308:	9480004c 	andi	r18,r18,1
8111f30c:	90000c1e 	bne	r18,zero,8111f340 <___svfprintf_internal_r+0x20d4>
8111f310:	00800044 	movi	r2,1
8111f314:	d8802e15 	stw	r2,184(sp)
8111f318:	003e6606 	br	8111ecb4 <__reset+0xfb0fecb4>
8111f31c:	00800b44 	movi	r2,45
8111f320:	05adc83a 	sub	r22,zero,r22
8111f324:	d8802305 	stb	r2,140(sp)
8111f328:	003f3b06 	br	8111f018 <__reset+0xfb0ff018>
8111f32c:	0005883a 	mov	r2,zero
8111f330:	003f4e06 	br	8111f06c <__reset+0xfb0ff06c>
8111f334:	90a4703a 	and	r18,r18,r2
8111f338:	903f4a26 	beq	r18,zero,8111f064 <__reset+0xfb0ff064>
8111f33c:	003f4606 	br	8111f058 <__reset+0xfb0ff058>
8111f340:	d8c02917 	ldw	r3,164(sp)
8111f344:	18c00084 	addi	r3,r3,2
8111f348:	d8c02e15 	stw	r3,184(sp)
8111f34c:	1805883a 	mov	r2,r3
8111f350:	183e580e 	bge	r3,zero,8111ecb4 <__reset+0xfb0fecb4>
8111f354:	003fd006 	br	8111f298 <__reset+0xfb0ff298>
8111f358:	00800084 	movi	r2,2
8111f35c:	10c5c83a 	sub	r2,r2,r3
8111f360:	003f7506 	br	8111f138 <__reset+0xfb0ff138>
8111f364:	d8802d17 	ldw	r2,180(sp)
8111f368:	d9002d17 	ldw	r4,180(sp)
8111f36c:	bc400043 	ldbu	r17,1(r23)
8111f370:	10800017 	ldw	r2,0(r2)
8111f374:	582f883a 	mov	r23,r11
8111f378:	d8802915 	stw	r2,164(sp)
8111f37c:	20800104 	addi	r2,r4,4
8111f380:	d9002917 	ldw	r4,164(sp)
8111f384:	d8802d15 	stw	r2,180(sp)
8111f388:	203df00e 	bge	r4,zero,8111eb4c <__reset+0xfb0feb4c>
8111f38c:	8c403fcc 	andi	r17,r17,255
8111f390:	00bfffc4 	movi	r2,-1
8111f394:	8c40201c 	xori	r17,r17,128
8111f398:	d8802915 	stw	r2,164(sp)
8111f39c:	8c7fe004 	addi	r17,r17,-128
8111f3a0:	00380806 	br	8111d3c4 <__reset+0xfb0fd3c4>
8111f3a4:	9080004c 	andi	r2,r18,1
8111f3a8:	0039883a 	mov	fp,zero
8111f3ac:	10000726 	beq	r2,zero,8111f3cc <___svfprintf_internal_r+0x2160>
8111f3b0:	d8c02817 	ldw	r3,160(sp)
8111f3b4:	dc001dc4 	addi	r16,sp,119
8111f3b8:	00800c04 	movi	r2,48
8111f3bc:	1c07c83a 	sub	r3,r3,r16
8111f3c0:	d8801dc5 	stb	r2,119(sp)
8111f3c4:	d8c02e15 	stw	r3,184(sp)
8111f3c8:	00395206 	br	8111d914 <__reset+0xfb0fd914>
8111f3cc:	d8002e15 	stw	zero,184(sp)
8111f3d0:	dc001e04 	addi	r16,sp,120
8111f3d4:	00394f06 	br	8111d914 <__reset+0xfb0fd914>
8111f3d8:	0005883a 	mov	r2,zero
8111f3dc:	003e3206 	br	8111eca8 <__reset+0xfb0feca8>
8111f3e0:	dd802617 	ldw	r22,152(sp)
8111f3e4:	003f0606 	br	8111f000 <__reset+0xfb0ff000>
8111f3e8:	d9c02785 	stb	r7,158(sp)
8111f3ec:	003a5106 	br	8111dd34 <__reset+0xfb0fdd34>
8111f3f0:	d9c02785 	stb	r7,158(sp)
8111f3f4:	003a3706 	br	8111dcd4 <__reset+0xfb0fdcd4>
8111f3f8:	0005883a 	mov	r2,zero
8111f3fc:	003f5e06 	br	8111f178 <__reset+0xfb0ff178>
8111f400:	d9c02785 	stb	r7,158(sp)
8111f404:	00391706 	br	8111d864 <__reset+0xfb0fd864>
8111f408:	d9c02785 	stb	r7,158(sp)
8111f40c:	0038e606 	br	8111d7a8 <__reset+0xfb0fd7a8>
8111f410:	d8802344 	addi	r2,sp,141
8111f414:	003f0806 	br	8111f038 <__reset+0xfb0ff038>
8111f418:	d9c02785 	stb	r7,158(sp)
8111f41c:	0038b706 	br	8111d6fc <__reset+0xfb0fd6fc>
8111f420:	d9c02785 	stb	r7,158(sp)
8111f424:	003adc06 	br	8111df98 <__reset+0xfb0fdf98>
8111f428:	d9403917 	ldw	r5,228(sp)
8111f42c:	00800304 	movi	r2,12
8111f430:	28800015 	stw	r2,0(r5)
8111f434:	00bfffc4 	movi	r2,-1
8111f438:	00387806 	br	8111d61c <__reset+0xfb0fd61c>
8111f43c:	d9c02785 	stb	r7,158(sp)
8111f440:	003abf06 	br	8111df40 <__reset+0xfb0fdf40>
8111f444:	d9c02785 	stb	r7,158(sp)
8111f448:	003a9b06 	br	8111deb8 <__reset+0xfb0fdeb8>

8111f44c <___vfprintf_internal_r>:
8111f44c:	deffb804 	addi	sp,sp,-288
8111f450:	de00012e 	bgeu	sp,et,8111f458 <___vfprintf_internal_r+0xc>
8111f454:	003b68fa 	trap	3
8111f458:	dfc04715 	stw	ra,284(sp)
8111f45c:	ddc04515 	stw	r23,276(sp)
8111f460:	dd404315 	stw	r21,268(sp)
8111f464:	d9002c15 	stw	r4,176(sp)
8111f468:	282f883a 	mov	r23,r5
8111f46c:	302b883a 	mov	r21,r6
8111f470:	d9c02d15 	stw	r7,180(sp)
8111f474:	df004615 	stw	fp,280(sp)
8111f478:	dd804415 	stw	r22,272(sp)
8111f47c:	dd004215 	stw	r20,264(sp)
8111f480:	dcc04115 	stw	r19,260(sp)
8111f484:	dc804015 	stw	r18,256(sp)
8111f488:	dc403f15 	stw	r17,252(sp)
8111f48c:	dc003e15 	stw	r16,248(sp)
8111f490:	11261540 	call	81126154 <_localeconv_r>
8111f494:	10800017 	ldw	r2,0(r2)
8111f498:	1009883a 	mov	r4,r2
8111f49c:	d8803415 	stw	r2,208(sp)
8111f4a0:	111cf340 	call	8111cf34 <strlen>
8111f4a4:	d8803715 	stw	r2,220(sp)
8111f4a8:	d8802c17 	ldw	r2,176(sp)
8111f4ac:	10000226 	beq	r2,zero,8111f4b8 <___vfprintf_internal_r+0x6c>
8111f4b0:	10800e17 	ldw	r2,56(r2)
8111f4b4:	1000f926 	beq	r2,zero,8111f89c <___vfprintf_internal_r+0x450>
8111f4b8:	b880030b 	ldhu	r2,12(r23)
8111f4bc:	10c8000c 	andi	r3,r2,8192
8111f4c0:	1800061e 	bne	r3,zero,8111f4dc <___vfprintf_internal_r+0x90>
8111f4c4:	b9001917 	ldw	r4,100(r23)
8111f4c8:	00f7ffc4 	movi	r3,-8193
8111f4cc:	10880014 	ori	r2,r2,8192
8111f4d0:	20c6703a 	and	r3,r4,r3
8111f4d4:	b880030d 	sth	r2,12(r23)
8111f4d8:	b8c01915 	stw	r3,100(r23)
8111f4dc:	10c0020c 	andi	r3,r2,8
8111f4e0:	1800c126 	beq	r3,zero,8111f7e8 <___vfprintf_internal_r+0x39c>
8111f4e4:	b8c00417 	ldw	r3,16(r23)
8111f4e8:	1800bf26 	beq	r3,zero,8111f7e8 <___vfprintf_internal_r+0x39c>
8111f4ec:	1080068c 	andi	r2,r2,26
8111f4f0:	00c00284 	movi	r3,10
8111f4f4:	10c0c426 	beq	r2,r3,8111f808 <___vfprintf_internal_r+0x3bc>
8111f4f8:	d8c00404 	addi	r3,sp,16
8111f4fc:	05204574 	movhi	r20,33045
8111f500:	d9001e04 	addi	r4,sp,120
8111f504:	a5298e84 	addi	r20,r20,-22982
8111f508:	d8c01e15 	stw	r3,120(sp)
8111f50c:	d8002015 	stw	zero,128(sp)
8111f510:	d8001f15 	stw	zero,124(sp)
8111f514:	d8003315 	stw	zero,204(sp)
8111f518:	d8003615 	stw	zero,216(sp)
8111f51c:	d8003815 	stw	zero,224(sp)
8111f520:	1811883a 	mov	r8,r3
8111f524:	d8003915 	stw	zero,228(sp)
8111f528:	d8003a15 	stw	zero,232(sp)
8111f52c:	d8002f15 	stw	zero,188(sp)
8111f530:	d9002815 	stw	r4,160(sp)
8111f534:	a8800007 	ldb	r2,0(r21)
8111f538:	10027b26 	beq	r2,zero,8111ff28 <___vfprintf_internal_r+0xadc>
8111f53c:	00c00944 	movi	r3,37
8111f540:	a821883a 	mov	r16,r21
8111f544:	10c0021e 	bne	r2,r3,8111f550 <___vfprintf_internal_r+0x104>
8111f548:	00001406 	br	8111f59c <___vfprintf_internal_r+0x150>
8111f54c:	10c00326 	beq	r2,r3,8111f55c <___vfprintf_internal_r+0x110>
8111f550:	84000044 	addi	r16,r16,1
8111f554:	80800007 	ldb	r2,0(r16)
8111f558:	103ffc1e 	bne	r2,zero,8111f54c <__reset+0xfb0ff54c>
8111f55c:	8563c83a 	sub	r17,r16,r21
8111f560:	88000e26 	beq	r17,zero,8111f59c <___vfprintf_internal_r+0x150>
8111f564:	d8c02017 	ldw	r3,128(sp)
8111f568:	d8801f17 	ldw	r2,124(sp)
8111f56c:	45400015 	stw	r21,0(r8)
8111f570:	1c47883a 	add	r3,r3,r17
8111f574:	10800044 	addi	r2,r2,1
8111f578:	d8c02015 	stw	r3,128(sp)
8111f57c:	44400115 	stw	r17,4(r8)
8111f580:	d8801f15 	stw	r2,124(sp)
8111f584:	00c001c4 	movi	r3,7
8111f588:	1880a716 	blt	r3,r2,8111f828 <___vfprintf_internal_r+0x3dc>
8111f58c:	42000204 	addi	r8,r8,8
8111f590:	d9402f17 	ldw	r5,188(sp)
8111f594:	2c4b883a 	add	r5,r5,r17
8111f598:	d9402f15 	stw	r5,188(sp)
8111f59c:	80800007 	ldb	r2,0(r16)
8111f5a0:	1000a826 	beq	r2,zero,8111f844 <___vfprintf_internal_r+0x3f8>
8111f5a4:	84400047 	ldb	r17,1(r16)
8111f5a8:	00bfffc4 	movi	r2,-1
8111f5ac:	85400044 	addi	r21,r16,1
8111f5b0:	d8002785 	stb	zero,158(sp)
8111f5b4:	0007883a 	mov	r3,zero
8111f5b8:	000f883a 	mov	r7,zero
8111f5bc:	d8802915 	stw	r2,164(sp)
8111f5c0:	d8003115 	stw	zero,196(sp)
8111f5c4:	0025883a 	mov	r18,zero
8111f5c8:	01401604 	movi	r5,88
8111f5cc:	01800244 	movi	r6,9
8111f5d0:	02800a84 	movi	r10,42
8111f5d4:	02401b04 	movi	r9,108
8111f5d8:	ad400044 	addi	r21,r21,1
8111f5dc:	88bff804 	addi	r2,r17,-32
8111f5e0:	28830436 	bltu	r5,r2,811201f4 <___vfprintf_internal_r+0xda8>
8111f5e4:	100490ba 	slli	r2,r2,2
8111f5e8:	012044b4 	movhi	r4,33042
8111f5ec:	213d7f04 	addi	r4,r4,-2564
8111f5f0:	1105883a 	add	r2,r2,r4
8111f5f4:	10800017 	ldw	r2,0(r2)
8111f5f8:	1000683a 	jmp	r2
8111f5fc:	81120114 	ori	r4,r16,18436
8111f600:	811201f4 	orhi	r4,r16,18439
8111f604:	811201f4 	orhi	r4,r16,18439
8111f608:	81120134 	orhi	r4,r16,18436
8111f60c:	811201f4 	orhi	r4,r16,18439
8111f610:	811201f4 	orhi	r4,r16,18439
8111f614:	811201f4 	orhi	r4,r16,18439
8111f618:	811201f4 	orhi	r4,r16,18439
8111f61c:	811201f4 	orhi	r4,r16,18439
8111f620:	811201f4 	orhi	r4,r16,18439
8111f624:	8111f8a8 	cmpgeui	r4,r16,18402
8111f628:	81120050 	cmplti	r4,r16,18433
8111f62c:	811201f4 	orhi	r4,r16,18439
8111f630:	8111f770 	cmpltui	r4,r16,18397
8111f634:	8111f8d0 	cmplti	r4,r16,18403
8111f638:	811201f4 	orhi	r4,r16,18439
8111f63c:	8111f910 	cmplti	r4,r16,18404
8111f640:	8111f91c 	xori	r4,r16,18404
8111f644:	8111f91c 	xori	r4,r16,18404
8111f648:	8111f91c 	xori	r4,r16,18404
8111f64c:	8111f91c 	xori	r4,r16,18404
8111f650:	8111f91c 	xori	r4,r16,18404
8111f654:	8111f91c 	xori	r4,r16,18404
8111f658:	8111f91c 	xori	r4,r16,18404
8111f65c:	8111f91c 	xori	r4,r16,18404
8111f660:	8111f91c 	xori	r4,r16,18404
8111f664:	811201f4 	orhi	r4,r16,18439
8111f668:	811201f4 	orhi	r4,r16,18439
8111f66c:	811201f4 	orhi	r4,r16,18439
8111f670:	811201f4 	orhi	r4,r16,18439
8111f674:	811201f4 	orhi	r4,r16,18439
8111f678:	811201f4 	orhi	r4,r16,18439
8111f67c:	811201f4 	orhi	r4,r16,18439
8111f680:	811201f4 	orhi	r4,r16,18439
8111f684:	811201f4 	orhi	r4,r16,18439
8111f688:	811201f4 	orhi	r4,r16,18439
8111f68c:	8111f950 	cmplti	r4,r16,18405
8111f690:	8111fa0c 	andi	r4,r16,18408
8111f694:	811201f4 	orhi	r4,r16,18439
8111f698:	8111fa0c 	andi	r4,r16,18408
8111f69c:	811201f4 	orhi	r4,r16,18439
8111f6a0:	811201f4 	orhi	r4,r16,18439
8111f6a4:	811201f4 	orhi	r4,r16,18439
8111f6a8:	811201f4 	orhi	r4,r16,18439
8111f6ac:	8111faac 	andhi	r4,r16,18410
8111f6b0:	811201f4 	orhi	r4,r16,18439
8111f6b4:	811201f4 	orhi	r4,r16,18439
8111f6b8:	8111fab8 	rdprs	r4,r16,18410
8111f6bc:	811201f4 	orhi	r4,r16,18439
8111f6c0:	811201f4 	orhi	r4,r16,18439
8111f6c4:	811201f4 	orhi	r4,r16,18439
8111f6c8:	811201f4 	orhi	r4,r16,18439
8111f6cc:	811201f4 	orhi	r4,r16,18439
8111f6d0:	8111ff30 	cmpltui	r4,r16,18428
8111f6d4:	811201f4 	orhi	r4,r16,18439
8111f6d8:	811201f4 	orhi	r4,r16,18439
8111f6dc:	8111ff90 	cmplti	r4,r16,18430
8111f6e0:	811201f4 	orhi	r4,r16,18439
8111f6e4:	811201f4 	orhi	r4,r16,18439
8111f6e8:	811201f4 	orhi	r4,r16,18439
8111f6ec:	811201f4 	orhi	r4,r16,18439
8111f6f0:	811201f4 	orhi	r4,r16,18439
8111f6f4:	811201f4 	orhi	r4,r16,18439
8111f6f8:	811201f4 	orhi	r4,r16,18439
8111f6fc:	811201f4 	orhi	r4,r16,18439
8111f700:	811201f4 	orhi	r4,r16,18439
8111f704:	811201f4 	orhi	r4,r16,18439
8111f708:	811201a0 	cmpeqi	r4,r16,18438
8111f70c:	81120140 	call	88112014 <__reset+0x20f2014>
8111f710:	8111fa0c 	andi	r4,r16,18408
8111f714:	8111fa0c 	andi	r4,r16,18408
8111f718:	8111fa0c 	andi	r4,r16,18408
8111f71c:	81120150 	cmplti	r4,r16,18437
8111f720:	81120140 	call	88112014 <__reset+0x20f2014>
8111f724:	811201f4 	orhi	r4,r16,18439
8111f728:	811201f4 	orhi	r4,r16,18439
8111f72c:	8112015c 	xori	r4,r16,18437
8111f730:	811201f4 	orhi	r4,r16,18439
8111f734:	8112016c 	andhi	r4,r16,18437
8111f738:	81120040 	call	88112004 <__reset+0x20f2004>
8111f73c:	8111f77c 	xorhi	r4,r16,18397
8111f740:	81120060 	cmpeqi	r4,r16,18433
8111f744:	811201f4 	orhi	r4,r16,18439
8111f748:	8112006c 	andhi	r4,r16,18433
8111f74c:	811201f4 	orhi	r4,r16,18439
8111f750:	811200c8 	cmpgei	r4,r16,18435
8111f754:	811201f4 	orhi	r4,r16,18439
8111f758:	811201f4 	orhi	r4,r16,18439
8111f75c:	811200d8 	cmpnei	r4,r16,18435
8111f760:	d9003117 	ldw	r4,196(sp)
8111f764:	d8802d15 	stw	r2,180(sp)
8111f768:	0109c83a 	sub	r4,zero,r4
8111f76c:	d9003115 	stw	r4,196(sp)
8111f770:	94800114 	ori	r18,r18,4
8111f774:	ac400007 	ldb	r17,0(r21)
8111f778:	003f9706 	br	8111f5d8 <__reset+0xfb0ff5d8>
8111f77c:	00800c04 	movi	r2,48
8111f780:	d9002d17 	ldw	r4,180(sp)
8111f784:	d9402917 	ldw	r5,164(sp)
8111f788:	d8802705 	stb	r2,156(sp)
8111f78c:	00801e04 	movi	r2,120
8111f790:	d8802745 	stb	r2,157(sp)
8111f794:	d8002785 	stb	zero,158(sp)
8111f798:	20c00104 	addi	r3,r4,4
8111f79c:	24c00017 	ldw	r19,0(r4)
8111f7a0:	002d883a 	mov	r22,zero
8111f7a4:	90800094 	ori	r2,r18,2
8111f7a8:	28029a16 	blt	r5,zero,81120214 <___vfprintf_internal_r+0xdc8>
8111f7ac:	00bfdfc4 	movi	r2,-129
8111f7b0:	90a4703a 	and	r18,r18,r2
8111f7b4:	d8c02d15 	stw	r3,180(sp)
8111f7b8:	94800094 	ori	r18,r18,2
8111f7bc:	9802871e 	bne	r19,zero,811201dc <___vfprintf_internal_r+0xd90>
8111f7c0:	00a04574 	movhi	r2,33045
8111f7c4:	10a97f04 	addi	r2,r2,-23044
8111f7c8:	d8803915 	stw	r2,228(sp)
8111f7cc:	04401e04 	movi	r17,120
8111f7d0:	d8802917 	ldw	r2,164(sp)
8111f7d4:	0039883a 	mov	fp,zero
8111f7d8:	1001e926 	beq	r2,zero,8111ff80 <___vfprintf_internal_r+0xb34>
8111f7dc:	0027883a 	mov	r19,zero
8111f7e0:	002d883a 	mov	r22,zero
8111f7e4:	00020506 	br	8111fffc <___vfprintf_internal_r+0xbb0>
8111f7e8:	d9002c17 	ldw	r4,176(sp)
8111f7ec:	b80b883a 	mov	r5,r23
8111f7f0:	11231980 	call	81123198 <__swsetup_r>
8111f7f4:	1005ac1e 	bne	r2,zero,81120ea8 <___vfprintf_internal_r+0x1a5c>
8111f7f8:	b880030b 	ldhu	r2,12(r23)
8111f7fc:	00c00284 	movi	r3,10
8111f800:	1080068c 	andi	r2,r2,26
8111f804:	10ff3c1e 	bne	r2,r3,8111f4f8 <__reset+0xfb0ff4f8>
8111f808:	b880038f 	ldh	r2,14(r23)
8111f80c:	103f3a16 	blt	r2,zero,8111f4f8 <__reset+0xfb0ff4f8>
8111f810:	d9c02d17 	ldw	r7,180(sp)
8111f814:	d9002c17 	ldw	r4,176(sp)
8111f818:	a80d883a 	mov	r6,r21
8111f81c:	b80b883a 	mov	r5,r23
8111f820:	11216680 	call	81121668 <__sbprintf>
8111f824:	00001106 	br	8111f86c <___vfprintf_internal_r+0x420>
8111f828:	d9002c17 	ldw	r4,176(sp)
8111f82c:	d9801e04 	addi	r6,sp,120
8111f830:	b80b883a 	mov	r5,r23
8111f834:	112b63c0 	call	8112b63c <__sprint_r>
8111f838:	1000081e 	bne	r2,zero,8111f85c <___vfprintf_internal_r+0x410>
8111f83c:	da000404 	addi	r8,sp,16
8111f840:	003f5306 	br	8111f590 <__reset+0xfb0ff590>
8111f844:	d8802017 	ldw	r2,128(sp)
8111f848:	10000426 	beq	r2,zero,8111f85c <___vfprintf_internal_r+0x410>
8111f84c:	d9002c17 	ldw	r4,176(sp)
8111f850:	d9801e04 	addi	r6,sp,120
8111f854:	b80b883a 	mov	r5,r23
8111f858:	112b63c0 	call	8112b63c <__sprint_r>
8111f85c:	b880030b 	ldhu	r2,12(r23)
8111f860:	1080100c 	andi	r2,r2,64
8111f864:	1005901e 	bne	r2,zero,81120ea8 <___vfprintf_internal_r+0x1a5c>
8111f868:	d8802f17 	ldw	r2,188(sp)
8111f86c:	dfc04717 	ldw	ra,284(sp)
8111f870:	df004617 	ldw	fp,280(sp)
8111f874:	ddc04517 	ldw	r23,276(sp)
8111f878:	dd804417 	ldw	r22,272(sp)
8111f87c:	dd404317 	ldw	r21,268(sp)
8111f880:	dd004217 	ldw	r20,264(sp)
8111f884:	dcc04117 	ldw	r19,260(sp)
8111f888:	dc804017 	ldw	r18,256(sp)
8111f88c:	dc403f17 	ldw	r17,252(sp)
8111f890:	dc003e17 	ldw	r16,248(sp)
8111f894:	dec04804 	addi	sp,sp,288
8111f898:	f800283a 	ret
8111f89c:	d9002c17 	ldw	r4,176(sp)
8111f8a0:	11252080 	call	81125208 <__sinit>
8111f8a4:	003f0406 	br	8111f4b8 <__reset+0xfb0ff4b8>
8111f8a8:	d8802d17 	ldw	r2,180(sp)
8111f8ac:	d9002d17 	ldw	r4,180(sp)
8111f8b0:	10800017 	ldw	r2,0(r2)
8111f8b4:	d8803115 	stw	r2,196(sp)
8111f8b8:	20800104 	addi	r2,r4,4
8111f8bc:	d9003117 	ldw	r4,196(sp)
8111f8c0:	203fa716 	blt	r4,zero,8111f760 <__reset+0xfb0ff760>
8111f8c4:	d8802d15 	stw	r2,180(sp)
8111f8c8:	ac400007 	ldb	r17,0(r21)
8111f8cc:	003f4206 	br	8111f5d8 <__reset+0xfb0ff5d8>
8111f8d0:	ac400007 	ldb	r17,0(r21)
8111f8d4:	aac00044 	addi	r11,r21,1
8111f8d8:	8a872826 	beq	r17,r10,8112157c <___vfprintf_internal_r+0x2130>
8111f8dc:	88bff404 	addi	r2,r17,-48
8111f8e0:	0009883a 	mov	r4,zero
8111f8e4:	30867d36 	bltu	r6,r2,811212dc <___vfprintf_internal_r+0x1e90>
8111f8e8:	5c400007 	ldb	r17,0(r11)
8111f8ec:	210002a4 	muli	r4,r4,10
8111f8f0:	5d400044 	addi	r21,r11,1
8111f8f4:	a817883a 	mov	r11,r21
8111f8f8:	2089883a 	add	r4,r4,r2
8111f8fc:	88bff404 	addi	r2,r17,-48
8111f900:	30bff92e 	bgeu	r6,r2,8111f8e8 <__reset+0xfb0ff8e8>
8111f904:	2005c916 	blt	r4,zero,8112102c <___vfprintf_internal_r+0x1be0>
8111f908:	d9002915 	stw	r4,164(sp)
8111f90c:	003f3306 	br	8111f5dc <__reset+0xfb0ff5dc>
8111f910:	94802014 	ori	r18,r18,128
8111f914:	ac400007 	ldb	r17,0(r21)
8111f918:	003f2f06 	br	8111f5d8 <__reset+0xfb0ff5d8>
8111f91c:	a809883a 	mov	r4,r21
8111f920:	d8003115 	stw	zero,196(sp)
8111f924:	88bff404 	addi	r2,r17,-48
8111f928:	0017883a 	mov	r11,zero
8111f92c:	24400007 	ldb	r17,0(r4)
8111f930:	5ac002a4 	muli	r11,r11,10
8111f934:	ad400044 	addi	r21,r21,1
8111f938:	a809883a 	mov	r4,r21
8111f93c:	12d7883a 	add	r11,r2,r11
8111f940:	88bff404 	addi	r2,r17,-48
8111f944:	30bff92e 	bgeu	r6,r2,8111f92c <__reset+0xfb0ff92c>
8111f948:	dac03115 	stw	r11,196(sp)
8111f94c:	003f2306 	br	8111f5dc <__reset+0xfb0ff5dc>
8111f950:	18c03fcc 	andi	r3,r3,255
8111f954:	18072b1e 	bne	r3,zero,81121604 <___vfprintf_internal_r+0x21b8>
8111f958:	94800414 	ori	r18,r18,16
8111f95c:	9080080c 	andi	r2,r18,32
8111f960:	10037b26 	beq	r2,zero,81120750 <___vfprintf_internal_r+0x1304>
8111f964:	d9402d17 	ldw	r5,180(sp)
8111f968:	28800117 	ldw	r2,4(r5)
8111f96c:	2cc00017 	ldw	r19,0(r5)
8111f970:	29400204 	addi	r5,r5,8
8111f974:	d9402d15 	stw	r5,180(sp)
8111f978:	102d883a 	mov	r22,r2
8111f97c:	10044b16 	blt	r2,zero,81120aac <___vfprintf_internal_r+0x1660>
8111f980:	d9402917 	ldw	r5,164(sp)
8111f984:	df002783 	ldbu	fp,158(sp)
8111f988:	2803bc16 	blt	r5,zero,8112087c <___vfprintf_internal_r+0x1430>
8111f98c:	00ffdfc4 	movi	r3,-129
8111f990:	9d84b03a 	or	r2,r19,r22
8111f994:	90e4703a 	and	r18,r18,r3
8111f998:	10017726 	beq	r2,zero,8111ff78 <___vfprintf_internal_r+0xb2c>
8111f99c:	b0038326 	beq	r22,zero,811207ac <___vfprintf_internal_r+0x1360>
8111f9a0:	dc402a15 	stw	r17,168(sp)
8111f9a4:	dc001e04 	addi	r16,sp,120
8111f9a8:	b023883a 	mov	r17,r22
8111f9ac:	402d883a 	mov	r22,r8
8111f9b0:	9809883a 	mov	r4,r19
8111f9b4:	880b883a 	mov	r5,r17
8111f9b8:	01800284 	movi	r6,10
8111f9bc:	000f883a 	mov	r7,zero
8111f9c0:	112e3f00 	call	8112e3f0 <__umoddi3>
8111f9c4:	10800c04 	addi	r2,r2,48
8111f9c8:	843fffc4 	addi	r16,r16,-1
8111f9cc:	9809883a 	mov	r4,r19
8111f9d0:	880b883a 	mov	r5,r17
8111f9d4:	80800005 	stb	r2,0(r16)
8111f9d8:	01800284 	movi	r6,10
8111f9dc:	000f883a 	mov	r7,zero
8111f9e0:	112de700 	call	8112de70 <__udivdi3>
8111f9e4:	1027883a 	mov	r19,r2
8111f9e8:	10c4b03a 	or	r2,r2,r3
8111f9ec:	1823883a 	mov	r17,r3
8111f9f0:	103fef1e 	bne	r2,zero,8111f9b0 <__reset+0xfb0ff9b0>
8111f9f4:	d8c02817 	ldw	r3,160(sp)
8111f9f8:	dc402a17 	ldw	r17,168(sp)
8111f9fc:	b011883a 	mov	r8,r22
8111fa00:	1c07c83a 	sub	r3,r3,r16
8111fa04:	d8c02e15 	stw	r3,184(sp)
8111fa08:	00005906 	br	8111fb70 <___vfprintf_internal_r+0x724>
8111fa0c:	18c03fcc 	andi	r3,r3,255
8111fa10:	1806fa1e 	bne	r3,zero,811215fc <___vfprintf_internal_r+0x21b0>
8111fa14:	9080020c 	andi	r2,r18,8
8111fa18:	10048a26 	beq	r2,zero,81120c44 <___vfprintf_internal_r+0x17f8>
8111fa1c:	d8c02d17 	ldw	r3,180(sp)
8111fa20:	d9002d17 	ldw	r4,180(sp)
8111fa24:	d9402d17 	ldw	r5,180(sp)
8111fa28:	18c00017 	ldw	r3,0(r3)
8111fa2c:	21000117 	ldw	r4,4(r4)
8111fa30:	29400204 	addi	r5,r5,8
8111fa34:	d8c03615 	stw	r3,216(sp)
8111fa38:	d9003815 	stw	r4,224(sp)
8111fa3c:	d9402d15 	stw	r5,180(sp)
8111fa40:	d9003617 	ldw	r4,216(sp)
8111fa44:	d9403817 	ldw	r5,224(sp)
8111fa48:	da003d15 	stw	r8,244(sp)
8111fa4c:	04000044 	movi	r16,1
8111fa50:	1127ca00 	call	81127ca0 <__fpclassifyd>
8111fa54:	da003d17 	ldw	r8,244(sp)
8111fa58:	14041f1e 	bne	r2,r16,81120ad8 <___vfprintf_internal_r+0x168c>
8111fa5c:	d9003617 	ldw	r4,216(sp)
8111fa60:	d9403817 	ldw	r5,224(sp)
8111fa64:	000d883a 	mov	r6,zero
8111fa68:	000f883a 	mov	r7,zero
8111fa6c:	112ffe80 	call	8112ffe8 <__ledf2>
8111fa70:	da003d17 	ldw	r8,244(sp)
8111fa74:	1005be16 	blt	r2,zero,81121170 <___vfprintf_internal_r+0x1d24>
8111fa78:	df002783 	ldbu	fp,158(sp)
8111fa7c:	008011c4 	movi	r2,71
8111fa80:	1445330e 	bge	r2,r17,81120f50 <___vfprintf_internal_r+0x1b04>
8111fa84:	04204574 	movhi	r16,33045
8111fa88:	84297704 	addi	r16,r16,-23076
8111fa8c:	00c000c4 	movi	r3,3
8111fa90:	00bfdfc4 	movi	r2,-129
8111fa94:	d8c02a15 	stw	r3,168(sp)
8111fa98:	90a4703a 	and	r18,r18,r2
8111fa9c:	d8c02e15 	stw	r3,184(sp)
8111faa0:	d8002915 	stw	zero,164(sp)
8111faa4:	d8003215 	stw	zero,200(sp)
8111faa8:	00003706 	br	8111fb88 <___vfprintf_internal_r+0x73c>
8111faac:	94800214 	ori	r18,r18,8
8111fab0:	ac400007 	ldb	r17,0(r21)
8111fab4:	003ec806 	br	8111f5d8 <__reset+0xfb0ff5d8>
8111fab8:	18c03fcc 	andi	r3,r3,255
8111fabc:	1806db1e 	bne	r3,zero,8112162c <___vfprintf_internal_r+0x21e0>
8111fac0:	94800414 	ori	r18,r18,16
8111fac4:	9080080c 	andi	r2,r18,32
8111fac8:	1002d826 	beq	r2,zero,8112062c <___vfprintf_internal_r+0x11e0>
8111facc:	d9402d17 	ldw	r5,180(sp)
8111fad0:	d8c02917 	ldw	r3,164(sp)
8111fad4:	d8002785 	stb	zero,158(sp)
8111fad8:	28800204 	addi	r2,r5,8
8111fadc:	2cc00017 	ldw	r19,0(r5)
8111fae0:	2d800117 	ldw	r22,4(r5)
8111fae4:	18048f16 	blt	r3,zero,81120d24 <___vfprintf_internal_r+0x18d8>
8111fae8:	013fdfc4 	movi	r4,-129
8111faec:	9d86b03a 	or	r3,r19,r22
8111faf0:	d8802d15 	stw	r2,180(sp)
8111faf4:	9124703a 	and	r18,r18,r4
8111faf8:	1802d91e 	bne	r3,zero,81120660 <___vfprintf_internal_r+0x1214>
8111fafc:	d8c02917 	ldw	r3,164(sp)
8111fb00:	0039883a 	mov	fp,zero
8111fb04:	1805c326 	beq	r3,zero,81121214 <___vfprintf_internal_r+0x1dc8>
8111fb08:	0027883a 	mov	r19,zero
8111fb0c:	002d883a 	mov	r22,zero
8111fb10:	dc001e04 	addi	r16,sp,120
8111fb14:	9806d0fa 	srli	r3,r19,3
8111fb18:	b008977a 	slli	r4,r22,29
8111fb1c:	b02cd0fa 	srli	r22,r22,3
8111fb20:	9cc001cc 	andi	r19,r19,7
8111fb24:	98800c04 	addi	r2,r19,48
8111fb28:	843fffc4 	addi	r16,r16,-1
8111fb2c:	20e6b03a 	or	r19,r4,r3
8111fb30:	80800005 	stb	r2,0(r16)
8111fb34:	9d86b03a 	or	r3,r19,r22
8111fb38:	183ff61e 	bne	r3,zero,8111fb14 <__reset+0xfb0ffb14>
8111fb3c:	90c0004c 	andi	r3,r18,1
8111fb40:	18013b26 	beq	r3,zero,81120030 <___vfprintf_internal_r+0xbe4>
8111fb44:	10803fcc 	andi	r2,r2,255
8111fb48:	1080201c 	xori	r2,r2,128
8111fb4c:	10bfe004 	addi	r2,r2,-128
8111fb50:	00c00c04 	movi	r3,48
8111fb54:	10c13626 	beq	r2,r3,81120030 <___vfprintf_internal_r+0xbe4>
8111fb58:	80ffffc5 	stb	r3,-1(r16)
8111fb5c:	d8c02817 	ldw	r3,160(sp)
8111fb60:	80bfffc4 	addi	r2,r16,-1
8111fb64:	1021883a 	mov	r16,r2
8111fb68:	1887c83a 	sub	r3,r3,r2
8111fb6c:	d8c02e15 	stw	r3,184(sp)
8111fb70:	d8802e17 	ldw	r2,184(sp)
8111fb74:	d9002917 	ldw	r4,164(sp)
8111fb78:	1100010e 	bge	r2,r4,8111fb80 <___vfprintf_internal_r+0x734>
8111fb7c:	2005883a 	mov	r2,r4
8111fb80:	d8802a15 	stw	r2,168(sp)
8111fb84:	d8003215 	stw	zero,200(sp)
8111fb88:	e7003fcc 	andi	fp,fp,255
8111fb8c:	e700201c 	xori	fp,fp,128
8111fb90:	e73fe004 	addi	fp,fp,-128
8111fb94:	e0000326 	beq	fp,zero,8111fba4 <___vfprintf_internal_r+0x758>
8111fb98:	d8c02a17 	ldw	r3,168(sp)
8111fb9c:	18c00044 	addi	r3,r3,1
8111fba0:	d8c02a15 	stw	r3,168(sp)
8111fba4:	90c0008c 	andi	r3,r18,2
8111fba8:	d8c02b15 	stw	r3,172(sp)
8111fbac:	18000326 	beq	r3,zero,8111fbbc <___vfprintf_internal_r+0x770>
8111fbb0:	d8c02a17 	ldw	r3,168(sp)
8111fbb4:	18c00084 	addi	r3,r3,2
8111fbb8:	d8c02a15 	stw	r3,168(sp)
8111fbbc:	90c0210c 	andi	r3,r18,132
8111fbc0:	d8c03015 	stw	r3,192(sp)
8111fbc4:	1801a31e 	bne	r3,zero,81120254 <___vfprintf_internal_r+0xe08>
8111fbc8:	d9003117 	ldw	r4,196(sp)
8111fbcc:	d8c02a17 	ldw	r3,168(sp)
8111fbd0:	20e7c83a 	sub	r19,r4,r3
8111fbd4:	04c19f0e 	bge	zero,r19,81120254 <___vfprintf_internal_r+0xe08>
8111fbd8:	02400404 	movi	r9,16
8111fbdc:	d8c02017 	ldw	r3,128(sp)
8111fbe0:	d8801f17 	ldw	r2,124(sp)
8111fbe4:	4cc50d0e 	bge	r9,r19,8112101c <___vfprintf_internal_r+0x1bd0>
8111fbe8:	01604574 	movhi	r5,33045
8111fbec:	29699284 	addi	r5,r5,-22966
8111fbf0:	dc403b15 	stw	r17,236(sp)
8111fbf4:	d9403515 	stw	r5,212(sp)
8111fbf8:	9823883a 	mov	r17,r19
8111fbfc:	482d883a 	mov	r22,r9
8111fc00:	9027883a 	mov	r19,r18
8111fc04:	070001c4 	movi	fp,7
8111fc08:	8025883a 	mov	r18,r16
8111fc0c:	dc002c17 	ldw	r16,176(sp)
8111fc10:	00000306 	br	8111fc20 <___vfprintf_internal_r+0x7d4>
8111fc14:	8c7ffc04 	addi	r17,r17,-16
8111fc18:	42000204 	addi	r8,r8,8
8111fc1c:	b440130e 	bge	r22,r17,8111fc6c <___vfprintf_internal_r+0x820>
8111fc20:	01204574 	movhi	r4,33045
8111fc24:	18c00404 	addi	r3,r3,16
8111fc28:	10800044 	addi	r2,r2,1
8111fc2c:	21299284 	addi	r4,r4,-22966
8111fc30:	41000015 	stw	r4,0(r8)
8111fc34:	45800115 	stw	r22,4(r8)
8111fc38:	d8c02015 	stw	r3,128(sp)
8111fc3c:	d8801f15 	stw	r2,124(sp)
8111fc40:	e0bff40e 	bge	fp,r2,8111fc14 <__reset+0xfb0ffc14>
8111fc44:	d9801e04 	addi	r6,sp,120
8111fc48:	b80b883a 	mov	r5,r23
8111fc4c:	8009883a 	mov	r4,r16
8111fc50:	112b63c0 	call	8112b63c <__sprint_r>
8111fc54:	103f011e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
8111fc58:	8c7ffc04 	addi	r17,r17,-16
8111fc5c:	d8c02017 	ldw	r3,128(sp)
8111fc60:	d8801f17 	ldw	r2,124(sp)
8111fc64:	da000404 	addi	r8,sp,16
8111fc68:	b47fed16 	blt	r22,r17,8111fc20 <__reset+0xfb0ffc20>
8111fc6c:	9021883a 	mov	r16,r18
8111fc70:	9825883a 	mov	r18,r19
8111fc74:	8827883a 	mov	r19,r17
8111fc78:	dc403b17 	ldw	r17,236(sp)
8111fc7c:	d9403517 	ldw	r5,212(sp)
8111fc80:	98c7883a 	add	r3,r19,r3
8111fc84:	10800044 	addi	r2,r2,1
8111fc88:	41400015 	stw	r5,0(r8)
8111fc8c:	44c00115 	stw	r19,4(r8)
8111fc90:	d8c02015 	stw	r3,128(sp)
8111fc94:	d8801f15 	stw	r2,124(sp)
8111fc98:	010001c4 	movi	r4,7
8111fc9c:	2082a316 	blt	r4,r2,8112072c <___vfprintf_internal_r+0x12e0>
8111fca0:	df002787 	ldb	fp,158(sp)
8111fca4:	42000204 	addi	r8,r8,8
8111fca8:	e0000c26 	beq	fp,zero,8111fcdc <___vfprintf_internal_r+0x890>
8111fcac:	d8801f17 	ldw	r2,124(sp)
8111fcb0:	d9002784 	addi	r4,sp,158
8111fcb4:	18c00044 	addi	r3,r3,1
8111fcb8:	10800044 	addi	r2,r2,1
8111fcbc:	41000015 	stw	r4,0(r8)
8111fcc0:	01000044 	movi	r4,1
8111fcc4:	41000115 	stw	r4,4(r8)
8111fcc8:	d8c02015 	stw	r3,128(sp)
8111fccc:	d8801f15 	stw	r2,124(sp)
8111fcd0:	010001c4 	movi	r4,7
8111fcd4:	20823c16 	blt	r4,r2,811205c8 <___vfprintf_internal_r+0x117c>
8111fcd8:	42000204 	addi	r8,r8,8
8111fcdc:	d8802b17 	ldw	r2,172(sp)
8111fce0:	10000c26 	beq	r2,zero,8111fd14 <___vfprintf_internal_r+0x8c8>
8111fce4:	d8801f17 	ldw	r2,124(sp)
8111fce8:	d9002704 	addi	r4,sp,156
8111fcec:	18c00084 	addi	r3,r3,2
8111fcf0:	10800044 	addi	r2,r2,1
8111fcf4:	41000015 	stw	r4,0(r8)
8111fcf8:	01000084 	movi	r4,2
8111fcfc:	41000115 	stw	r4,4(r8)
8111fd00:	d8c02015 	stw	r3,128(sp)
8111fd04:	d8801f15 	stw	r2,124(sp)
8111fd08:	010001c4 	movi	r4,7
8111fd0c:	20823616 	blt	r4,r2,811205e8 <___vfprintf_internal_r+0x119c>
8111fd10:	42000204 	addi	r8,r8,8
8111fd14:	d9003017 	ldw	r4,192(sp)
8111fd18:	00802004 	movi	r2,128
8111fd1c:	20819926 	beq	r4,r2,81120384 <___vfprintf_internal_r+0xf38>
8111fd20:	d9402917 	ldw	r5,164(sp)
8111fd24:	d8802e17 	ldw	r2,184(sp)
8111fd28:	28adc83a 	sub	r22,r5,r2
8111fd2c:	0580310e 	bge	zero,r22,8111fdf4 <___vfprintf_internal_r+0x9a8>
8111fd30:	07000404 	movi	fp,16
8111fd34:	d8801f17 	ldw	r2,124(sp)
8111fd38:	e584140e 	bge	fp,r22,81120d8c <___vfprintf_internal_r+0x1940>
8111fd3c:	01604574 	movhi	r5,33045
8111fd40:	29698e84 	addi	r5,r5,-22982
8111fd44:	dc402915 	stw	r17,164(sp)
8111fd48:	d9402b15 	stw	r5,172(sp)
8111fd4c:	b023883a 	mov	r17,r22
8111fd50:	04c001c4 	movi	r19,7
8111fd54:	a82d883a 	mov	r22,r21
8111fd58:	902b883a 	mov	r21,r18
8111fd5c:	8025883a 	mov	r18,r16
8111fd60:	dc002c17 	ldw	r16,176(sp)
8111fd64:	00000306 	br	8111fd74 <___vfprintf_internal_r+0x928>
8111fd68:	8c7ffc04 	addi	r17,r17,-16
8111fd6c:	42000204 	addi	r8,r8,8
8111fd70:	e440110e 	bge	fp,r17,8111fdb8 <___vfprintf_internal_r+0x96c>
8111fd74:	18c00404 	addi	r3,r3,16
8111fd78:	10800044 	addi	r2,r2,1
8111fd7c:	45000015 	stw	r20,0(r8)
8111fd80:	47000115 	stw	fp,4(r8)
8111fd84:	d8c02015 	stw	r3,128(sp)
8111fd88:	d8801f15 	stw	r2,124(sp)
8111fd8c:	98bff60e 	bge	r19,r2,8111fd68 <__reset+0xfb0ffd68>
8111fd90:	d9801e04 	addi	r6,sp,120
8111fd94:	b80b883a 	mov	r5,r23
8111fd98:	8009883a 	mov	r4,r16
8111fd9c:	112b63c0 	call	8112b63c <__sprint_r>
8111fda0:	103eae1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
8111fda4:	8c7ffc04 	addi	r17,r17,-16
8111fda8:	d8c02017 	ldw	r3,128(sp)
8111fdac:	d8801f17 	ldw	r2,124(sp)
8111fdb0:	da000404 	addi	r8,sp,16
8111fdb4:	e47fef16 	blt	fp,r17,8111fd74 <__reset+0xfb0ffd74>
8111fdb8:	9021883a 	mov	r16,r18
8111fdbc:	a825883a 	mov	r18,r21
8111fdc0:	b02b883a 	mov	r21,r22
8111fdc4:	882d883a 	mov	r22,r17
8111fdc8:	dc402917 	ldw	r17,164(sp)
8111fdcc:	d9002b17 	ldw	r4,172(sp)
8111fdd0:	1d87883a 	add	r3,r3,r22
8111fdd4:	10800044 	addi	r2,r2,1
8111fdd8:	41000015 	stw	r4,0(r8)
8111fddc:	45800115 	stw	r22,4(r8)
8111fde0:	d8c02015 	stw	r3,128(sp)
8111fde4:	d8801f15 	stw	r2,124(sp)
8111fde8:	010001c4 	movi	r4,7
8111fdec:	2081ee16 	blt	r4,r2,811205a8 <___vfprintf_internal_r+0x115c>
8111fdf0:	42000204 	addi	r8,r8,8
8111fdf4:	9080400c 	andi	r2,r18,256
8111fdf8:	1001181e 	bne	r2,zero,8112025c <___vfprintf_internal_r+0xe10>
8111fdfc:	d9402e17 	ldw	r5,184(sp)
8111fe00:	d8801f17 	ldw	r2,124(sp)
8111fe04:	44000015 	stw	r16,0(r8)
8111fe08:	1947883a 	add	r3,r3,r5
8111fe0c:	10800044 	addi	r2,r2,1
8111fe10:	41400115 	stw	r5,4(r8)
8111fe14:	d8c02015 	stw	r3,128(sp)
8111fe18:	d8801f15 	stw	r2,124(sp)
8111fe1c:	010001c4 	movi	r4,7
8111fe20:	2081d316 	blt	r4,r2,81120570 <___vfprintf_internal_r+0x1124>
8111fe24:	42000204 	addi	r8,r8,8
8111fe28:	9480010c 	andi	r18,r18,4
8111fe2c:	90003226 	beq	r18,zero,8111fef8 <___vfprintf_internal_r+0xaac>
8111fe30:	d9403117 	ldw	r5,196(sp)
8111fe34:	d8802a17 	ldw	r2,168(sp)
8111fe38:	28a1c83a 	sub	r16,r5,r2
8111fe3c:	04002e0e 	bge	zero,r16,8111fef8 <___vfprintf_internal_r+0xaac>
8111fe40:	04400404 	movi	r17,16
8111fe44:	d8801f17 	ldw	r2,124(sp)
8111fe48:	8c04a20e 	bge	r17,r16,811210d4 <___vfprintf_internal_r+0x1c88>
8111fe4c:	01604574 	movhi	r5,33045
8111fe50:	29699284 	addi	r5,r5,-22966
8111fe54:	d9403515 	stw	r5,212(sp)
8111fe58:	048001c4 	movi	r18,7
8111fe5c:	dcc02c17 	ldw	r19,176(sp)
8111fe60:	00000306 	br	8111fe70 <___vfprintf_internal_r+0xa24>
8111fe64:	843ffc04 	addi	r16,r16,-16
8111fe68:	42000204 	addi	r8,r8,8
8111fe6c:	8c00130e 	bge	r17,r16,8111febc <___vfprintf_internal_r+0xa70>
8111fe70:	01204574 	movhi	r4,33045
8111fe74:	18c00404 	addi	r3,r3,16
8111fe78:	10800044 	addi	r2,r2,1
8111fe7c:	21299284 	addi	r4,r4,-22966
8111fe80:	41000015 	stw	r4,0(r8)
8111fe84:	44400115 	stw	r17,4(r8)
8111fe88:	d8c02015 	stw	r3,128(sp)
8111fe8c:	d8801f15 	stw	r2,124(sp)
8111fe90:	90bff40e 	bge	r18,r2,8111fe64 <__reset+0xfb0ffe64>
8111fe94:	d9801e04 	addi	r6,sp,120
8111fe98:	b80b883a 	mov	r5,r23
8111fe9c:	9809883a 	mov	r4,r19
8111fea0:	112b63c0 	call	8112b63c <__sprint_r>
8111fea4:	103e6d1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
8111fea8:	843ffc04 	addi	r16,r16,-16
8111feac:	d8c02017 	ldw	r3,128(sp)
8111feb0:	d8801f17 	ldw	r2,124(sp)
8111feb4:	da000404 	addi	r8,sp,16
8111feb8:	8c3fed16 	blt	r17,r16,8111fe70 <__reset+0xfb0ffe70>
8111febc:	d9403517 	ldw	r5,212(sp)
8111fec0:	1c07883a 	add	r3,r3,r16
8111fec4:	10800044 	addi	r2,r2,1
8111fec8:	41400015 	stw	r5,0(r8)
8111fecc:	44000115 	stw	r16,4(r8)
8111fed0:	d8c02015 	stw	r3,128(sp)
8111fed4:	d8801f15 	stw	r2,124(sp)
8111fed8:	010001c4 	movi	r4,7
8111fedc:	2080060e 	bge	r4,r2,8111fef8 <___vfprintf_internal_r+0xaac>
8111fee0:	d9002c17 	ldw	r4,176(sp)
8111fee4:	d9801e04 	addi	r6,sp,120
8111fee8:	b80b883a 	mov	r5,r23
8111feec:	112b63c0 	call	8112b63c <__sprint_r>
8111fef0:	103e5a1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
8111fef4:	d8c02017 	ldw	r3,128(sp)
8111fef8:	d8803117 	ldw	r2,196(sp)
8111fefc:	d9002a17 	ldw	r4,168(sp)
8111ff00:	1100010e 	bge	r2,r4,8111ff08 <___vfprintf_internal_r+0xabc>
8111ff04:	2005883a 	mov	r2,r4
8111ff08:	d9402f17 	ldw	r5,188(sp)
8111ff0c:	288b883a 	add	r5,r5,r2
8111ff10:	d9402f15 	stw	r5,188(sp)
8111ff14:	18019e1e 	bne	r3,zero,81120590 <___vfprintf_internal_r+0x1144>
8111ff18:	a8800007 	ldb	r2,0(r21)
8111ff1c:	d8001f15 	stw	zero,124(sp)
8111ff20:	da000404 	addi	r8,sp,16
8111ff24:	103d851e 	bne	r2,zero,8111f53c <__reset+0xfb0ff53c>
8111ff28:	a821883a 	mov	r16,r21
8111ff2c:	003d9b06 	br	8111f59c <__reset+0xfb0ff59c>
8111ff30:	18c03fcc 	andi	r3,r3,255
8111ff34:	1805c11e 	bne	r3,zero,8112163c <___vfprintf_internal_r+0x21f0>
8111ff38:	94800414 	ori	r18,r18,16
8111ff3c:	9080080c 	andi	r2,r18,32
8111ff40:	10020c26 	beq	r2,zero,81120774 <___vfprintf_internal_r+0x1328>
8111ff44:	d8802d17 	ldw	r2,180(sp)
8111ff48:	d9002917 	ldw	r4,164(sp)
8111ff4c:	d8002785 	stb	zero,158(sp)
8111ff50:	10c00204 	addi	r3,r2,8
8111ff54:	14c00017 	ldw	r19,0(r2)
8111ff58:	15800117 	ldw	r22,4(r2)
8111ff5c:	20040f16 	blt	r4,zero,81120f9c <___vfprintf_internal_r+0x1b50>
8111ff60:	013fdfc4 	movi	r4,-129
8111ff64:	9d84b03a 	or	r2,r19,r22
8111ff68:	d8c02d15 	stw	r3,180(sp)
8111ff6c:	9124703a 	and	r18,r18,r4
8111ff70:	0039883a 	mov	fp,zero
8111ff74:	103e891e 	bne	r2,zero,8111f99c <__reset+0xfb0ff99c>
8111ff78:	d9002917 	ldw	r4,164(sp)
8111ff7c:	2002c11e 	bne	r4,zero,81120a84 <___vfprintf_internal_r+0x1638>
8111ff80:	d8002915 	stw	zero,164(sp)
8111ff84:	d8002e15 	stw	zero,184(sp)
8111ff88:	dc001e04 	addi	r16,sp,120
8111ff8c:	003ef806 	br	8111fb70 <__reset+0xfb0ffb70>
8111ff90:	18c03fcc 	andi	r3,r3,255
8111ff94:	18059d1e 	bne	r3,zero,8112160c <___vfprintf_internal_r+0x21c0>
8111ff98:	01604574 	movhi	r5,33045
8111ff9c:	29697a04 	addi	r5,r5,-23064
8111ffa0:	d9403915 	stw	r5,228(sp)
8111ffa4:	9080080c 	andi	r2,r18,32
8111ffa8:	10005226 	beq	r2,zero,811200f4 <___vfprintf_internal_r+0xca8>
8111ffac:	d8802d17 	ldw	r2,180(sp)
8111ffb0:	14c00017 	ldw	r19,0(r2)
8111ffb4:	15800117 	ldw	r22,4(r2)
8111ffb8:	10800204 	addi	r2,r2,8
8111ffbc:	d8802d15 	stw	r2,180(sp)
8111ffc0:	9080004c 	andi	r2,r18,1
8111ffc4:	10019026 	beq	r2,zero,81120608 <___vfprintf_internal_r+0x11bc>
8111ffc8:	9d84b03a 	or	r2,r19,r22
8111ffcc:	10036926 	beq	r2,zero,81120d74 <___vfprintf_internal_r+0x1928>
8111ffd0:	d8c02917 	ldw	r3,164(sp)
8111ffd4:	00800c04 	movi	r2,48
8111ffd8:	d8802705 	stb	r2,156(sp)
8111ffdc:	dc402745 	stb	r17,157(sp)
8111ffe0:	d8002785 	stb	zero,158(sp)
8111ffe4:	90800094 	ori	r2,r18,2
8111ffe8:	18045d16 	blt	r3,zero,81121160 <___vfprintf_internal_r+0x1d14>
8111ffec:	00bfdfc4 	movi	r2,-129
8111fff0:	90a4703a 	and	r18,r18,r2
8111fff4:	94800094 	ori	r18,r18,2
8111fff8:	0039883a 	mov	fp,zero
8111fffc:	d9003917 	ldw	r4,228(sp)
81120000:	dc001e04 	addi	r16,sp,120
81120004:	988003cc 	andi	r2,r19,15
81120008:	b006973a 	slli	r3,r22,28
8112000c:	2085883a 	add	r2,r4,r2
81120010:	9826d13a 	srli	r19,r19,4
81120014:	10800003 	ldbu	r2,0(r2)
81120018:	b02cd13a 	srli	r22,r22,4
8112001c:	843fffc4 	addi	r16,r16,-1
81120020:	1ce6b03a 	or	r19,r3,r19
81120024:	80800005 	stb	r2,0(r16)
81120028:	9d84b03a 	or	r2,r19,r22
8112002c:	103ff51e 	bne	r2,zero,81120004 <__reset+0xfb100004>
81120030:	d8c02817 	ldw	r3,160(sp)
81120034:	1c07c83a 	sub	r3,r3,r16
81120038:	d8c02e15 	stw	r3,184(sp)
8112003c:	003ecc06 	br	8111fb70 <__reset+0xfb0ffb70>
81120040:	18c03fcc 	andi	r3,r3,255
81120044:	183e9f26 	beq	r3,zero,8111fac4 <__reset+0xfb0ffac4>
81120048:	d9c02785 	stb	r7,158(sp)
8112004c:	003e9d06 	br	8111fac4 <__reset+0xfb0ffac4>
81120050:	00c00044 	movi	r3,1
81120054:	01c00ac4 	movi	r7,43
81120058:	ac400007 	ldb	r17,0(r21)
8112005c:	003d5e06 	br	8111f5d8 <__reset+0xfb0ff5d8>
81120060:	94800814 	ori	r18,r18,32
81120064:	ac400007 	ldb	r17,0(r21)
81120068:	003d5b06 	br	8111f5d8 <__reset+0xfb0ff5d8>
8112006c:	d8c02d17 	ldw	r3,180(sp)
81120070:	d8002785 	stb	zero,158(sp)
81120074:	1c000017 	ldw	r16,0(r3)
81120078:	1cc00104 	addi	r19,r3,4
8112007c:	80041926 	beq	r16,zero,811210e4 <___vfprintf_internal_r+0x1c98>
81120080:	d9002917 	ldw	r4,164(sp)
81120084:	2003d016 	blt	r4,zero,81120fc8 <___vfprintf_internal_r+0x1b7c>
81120088:	200d883a 	mov	r6,r4
8112008c:	000b883a 	mov	r5,zero
81120090:	8009883a 	mov	r4,r16
81120094:	da003d15 	stw	r8,244(sp)
81120098:	11264300 	call	81126430 <memchr>
8112009c:	da003d17 	ldw	r8,244(sp)
811200a0:	10045426 	beq	r2,zero,811211f4 <___vfprintf_internal_r+0x1da8>
811200a4:	1405c83a 	sub	r2,r2,r16
811200a8:	d8802e15 	stw	r2,184(sp)
811200ac:	1003cc16 	blt	r2,zero,81120fe0 <___vfprintf_internal_r+0x1b94>
811200b0:	df002783 	ldbu	fp,158(sp)
811200b4:	d8802a15 	stw	r2,168(sp)
811200b8:	dcc02d15 	stw	r19,180(sp)
811200bc:	d8002915 	stw	zero,164(sp)
811200c0:	d8003215 	stw	zero,200(sp)
811200c4:	003eb006 	br	8111fb88 <__reset+0xfb0ffb88>
811200c8:	18c03fcc 	andi	r3,r3,255
811200cc:	183f9b26 	beq	r3,zero,8111ff3c <__reset+0xfb0fff3c>
811200d0:	d9c02785 	stb	r7,158(sp)
811200d4:	003f9906 	br	8111ff3c <__reset+0xfb0fff3c>
811200d8:	18c03fcc 	andi	r3,r3,255
811200dc:	1805551e 	bne	r3,zero,81121634 <___vfprintf_internal_r+0x21e8>
811200e0:	01604574 	movhi	r5,33045
811200e4:	29697f04 	addi	r5,r5,-23044
811200e8:	d9403915 	stw	r5,228(sp)
811200ec:	9080080c 	andi	r2,r18,32
811200f0:	103fae1e 	bne	r2,zero,8111ffac <__reset+0xfb0fffac>
811200f4:	9080040c 	andi	r2,r18,16
811200f8:	1002de26 	beq	r2,zero,81120c74 <___vfprintf_internal_r+0x1828>
811200fc:	d8c02d17 	ldw	r3,180(sp)
81120100:	002d883a 	mov	r22,zero
81120104:	1cc00017 	ldw	r19,0(r3)
81120108:	18c00104 	addi	r3,r3,4
8112010c:	d8c02d15 	stw	r3,180(sp)
81120110:	003fab06 	br	8111ffc0 <__reset+0xfb0fffc0>
81120114:	38803fcc 	andi	r2,r7,255
81120118:	1080201c 	xori	r2,r2,128
8112011c:	10bfe004 	addi	r2,r2,-128
81120120:	1002d21e 	bne	r2,zero,81120c6c <___vfprintf_internal_r+0x1820>
81120124:	00c00044 	movi	r3,1
81120128:	01c00804 	movi	r7,32
8112012c:	ac400007 	ldb	r17,0(r21)
81120130:	003d2906 	br	8111f5d8 <__reset+0xfb0ff5d8>
81120134:	94800054 	ori	r18,r18,1
81120138:	ac400007 	ldb	r17,0(r21)
8112013c:	003d2606 	br	8111f5d8 <__reset+0xfb0ff5d8>
81120140:	18c03fcc 	andi	r3,r3,255
81120144:	183e0526 	beq	r3,zero,8111f95c <__reset+0xfb0ff95c>
81120148:	d9c02785 	stb	r7,158(sp)
8112014c:	003e0306 	br	8111f95c <__reset+0xfb0ff95c>
81120150:	94801014 	ori	r18,r18,64
81120154:	ac400007 	ldb	r17,0(r21)
81120158:	003d1f06 	br	8111f5d8 <__reset+0xfb0ff5d8>
8112015c:	ac400007 	ldb	r17,0(r21)
81120160:	8a438726 	beq	r17,r9,81120f80 <___vfprintf_internal_r+0x1b34>
81120164:	94800414 	ori	r18,r18,16
81120168:	003d1b06 	br	8111f5d8 <__reset+0xfb0ff5d8>
8112016c:	18c03fcc 	andi	r3,r3,255
81120170:	1805341e 	bne	r3,zero,81121644 <___vfprintf_internal_r+0x21f8>
81120174:	9080080c 	andi	r2,r18,32
81120178:	1002cd26 	beq	r2,zero,81120cb0 <___vfprintf_internal_r+0x1864>
8112017c:	d9402d17 	ldw	r5,180(sp)
81120180:	d9002f17 	ldw	r4,188(sp)
81120184:	28800017 	ldw	r2,0(r5)
81120188:	2007d7fa 	srai	r3,r4,31
8112018c:	29400104 	addi	r5,r5,4
81120190:	d9402d15 	stw	r5,180(sp)
81120194:	11000015 	stw	r4,0(r2)
81120198:	10c00115 	stw	r3,4(r2)
8112019c:	003ce506 	br	8111f534 <__reset+0xfb0ff534>
811201a0:	d8c02d17 	ldw	r3,180(sp)
811201a4:	d9002d17 	ldw	r4,180(sp)
811201a8:	d8002785 	stb	zero,158(sp)
811201ac:	18800017 	ldw	r2,0(r3)
811201b0:	21000104 	addi	r4,r4,4
811201b4:	00c00044 	movi	r3,1
811201b8:	d8c02a15 	stw	r3,168(sp)
811201bc:	d8801405 	stb	r2,80(sp)
811201c0:	d9002d15 	stw	r4,180(sp)
811201c4:	d8c02e15 	stw	r3,184(sp)
811201c8:	d8002915 	stw	zero,164(sp)
811201cc:	d8003215 	stw	zero,200(sp)
811201d0:	dc001404 	addi	r16,sp,80
811201d4:	0039883a 	mov	fp,zero
811201d8:	003e7206 	br	8111fba4 <__reset+0xfb0ffba4>
811201dc:	01204574 	movhi	r4,33045
811201e0:	21297f04 	addi	r4,r4,-23044
811201e4:	0039883a 	mov	fp,zero
811201e8:	d9003915 	stw	r4,228(sp)
811201ec:	04401e04 	movi	r17,120
811201f0:	003f8206 	br	8111fffc <__reset+0xfb0ffffc>
811201f4:	18c03fcc 	andi	r3,r3,255
811201f8:	1805061e 	bne	r3,zero,81121614 <___vfprintf_internal_r+0x21c8>
811201fc:	883d9126 	beq	r17,zero,8111f844 <__reset+0xfb0ff844>
81120200:	00c00044 	movi	r3,1
81120204:	d8c02a15 	stw	r3,168(sp)
81120208:	dc401405 	stb	r17,80(sp)
8112020c:	d8002785 	stb	zero,158(sp)
81120210:	003fec06 	br	811201c4 <__reset+0xfb1001c4>
81120214:	01604574 	movhi	r5,33045
81120218:	29697f04 	addi	r5,r5,-23044
8112021c:	d9403915 	stw	r5,228(sp)
81120220:	d8c02d15 	stw	r3,180(sp)
81120224:	1025883a 	mov	r18,r2
81120228:	04401e04 	movi	r17,120
8112022c:	9d84b03a 	or	r2,r19,r22
81120230:	1000fc1e 	bne	r2,zero,81120624 <___vfprintf_internal_r+0x11d8>
81120234:	0039883a 	mov	fp,zero
81120238:	00800084 	movi	r2,2
8112023c:	10803fcc 	andi	r2,r2,255
81120240:	00c00044 	movi	r3,1
81120244:	10c20f26 	beq	r2,r3,81120a84 <___vfprintf_internal_r+0x1638>
81120248:	00c00084 	movi	r3,2
8112024c:	10fd6326 	beq	r2,r3,8111f7dc <__reset+0xfb0ff7dc>
81120250:	003e2d06 	br	8111fb08 <__reset+0xfb0ffb08>
81120254:	d8c02017 	ldw	r3,128(sp)
81120258:	003e9306 	br	8111fca8 <__reset+0xfb0ffca8>
8112025c:	00801944 	movi	r2,101
81120260:	14407e0e 	bge	r2,r17,8112045c <___vfprintf_internal_r+0x1010>
81120264:	d9003617 	ldw	r4,216(sp)
81120268:	d9403817 	ldw	r5,224(sp)
8112026c:	000d883a 	mov	r6,zero
81120270:	000f883a 	mov	r7,zero
81120274:	d8c03c15 	stw	r3,240(sp)
81120278:	da003d15 	stw	r8,244(sp)
8112027c:	112fe840 	call	8112fe84 <__eqdf2>
81120280:	d8c03c17 	ldw	r3,240(sp)
81120284:	da003d17 	ldw	r8,244(sp)
81120288:	1000f71e 	bne	r2,zero,81120668 <___vfprintf_internal_r+0x121c>
8112028c:	d8801f17 	ldw	r2,124(sp)
81120290:	01204574 	movhi	r4,33045
81120294:	21298604 	addi	r4,r4,-23016
81120298:	18c00044 	addi	r3,r3,1
8112029c:	10800044 	addi	r2,r2,1
811202a0:	41000015 	stw	r4,0(r8)
811202a4:	01000044 	movi	r4,1
811202a8:	41000115 	stw	r4,4(r8)
811202ac:	d8c02015 	stw	r3,128(sp)
811202b0:	d8801f15 	stw	r2,124(sp)
811202b4:	010001c4 	movi	r4,7
811202b8:	2082b816 	blt	r4,r2,81120d9c <___vfprintf_internal_r+0x1950>
811202bc:	42000204 	addi	r8,r8,8
811202c0:	d8802617 	ldw	r2,152(sp)
811202c4:	d9403317 	ldw	r5,204(sp)
811202c8:	11400216 	blt	r2,r5,811202d4 <___vfprintf_internal_r+0xe88>
811202cc:	9080004c 	andi	r2,r18,1
811202d0:	103ed526 	beq	r2,zero,8111fe28 <__reset+0xfb0ffe28>
811202d4:	d8803717 	ldw	r2,220(sp)
811202d8:	d9003417 	ldw	r4,208(sp)
811202dc:	d9403717 	ldw	r5,220(sp)
811202e0:	1887883a 	add	r3,r3,r2
811202e4:	d8801f17 	ldw	r2,124(sp)
811202e8:	41000015 	stw	r4,0(r8)
811202ec:	41400115 	stw	r5,4(r8)
811202f0:	10800044 	addi	r2,r2,1
811202f4:	d8c02015 	stw	r3,128(sp)
811202f8:	d8801f15 	stw	r2,124(sp)
811202fc:	010001c4 	movi	r4,7
81120300:	20832916 	blt	r4,r2,81120fa8 <___vfprintf_internal_r+0x1b5c>
81120304:	42000204 	addi	r8,r8,8
81120308:	d8803317 	ldw	r2,204(sp)
8112030c:	143fffc4 	addi	r16,r2,-1
81120310:	043ec50e 	bge	zero,r16,8111fe28 <__reset+0xfb0ffe28>
81120314:	04400404 	movi	r17,16
81120318:	d8801f17 	ldw	r2,124(sp)
8112031c:	8c00880e 	bge	r17,r16,81120540 <___vfprintf_internal_r+0x10f4>
81120320:	01604574 	movhi	r5,33045
81120324:	29698e84 	addi	r5,r5,-22982
81120328:	d9402b15 	stw	r5,172(sp)
8112032c:	058001c4 	movi	r22,7
81120330:	dcc02c17 	ldw	r19,176(sp)
81120334:	00000306 	br	81120344 <___vfprintf_internal_r+0xef8>
81120338:	42000204 	addi	r8,r8,8
8112033c:	843ffc04 	addi	r16,r16,-16
81120340:	8c00820e 	bge	r17,r16,8112054c <___vfprintf_internal_r+0x1100>
81120344:	18c00404 	addi	r3,r3,16
81120348:	10800044 	addi	r2,r2,1
8112034c:	45000015 	stw	r20,0(r8)
81120350:	44400115 	stw	r17,4(r8)
81120354:	d8c02015 	stw	r3,128(sp)
81120358:	d8801f15 	stw	r2,124(sp)
8112035c:	b0bff60e 	bge	r22,r2,81120338 <__reset+0xfb100338>
81120360:	d9801e04 	addi	r6,sp,120
81120364:	b80b883a 	mov	r5,r23
81120368:	9809883a 	mov	r4,r19
8112036c:	112b63c0 	call	8112b63c <__sprint_r>
81120370:	103d3a1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120374:	d8c02017 	ldw	r3,128(sp)
81120378:	d8801f17 	ldw	r2,124(sp)
8112037c:	da000404 	addi	r8,sp,16
81120380:	003fee06 	br	8112033c <__reset+0xfb10033c>
81120384:	d9403117 	ldw	r5,196(sp)
81120388:	d8802a17 	ldw	r2,168(sp)
8112038c:	28adc83a 	sub	r22,r5,r2
81120390:	05be630e 	bge	zero,r22,8111fd20 <__reset+0xfb0ffd20>
81120394:	07000404 	movi	fp,16
81120398:	d8801f17 	ldw	r2,124(sp)
8112039c:	e5838f0e 	bge	fp,r22,811211dc <___vfprintf_internal_r+0x1d90>
811203a0:	01604574 	movhi	r5,33045
811203a4:	29698e84 	addi	r5,r5,-22982
811203a8:	dc403015 	stw	r17,192(sp)
811203ac:	d9402b15 	stw	r5,172(sp)
811203b0:	b023883a 	mov	r17,r22
811203b4:	04c001c4 	movi	r19,7
811203b8:	a82d883a 	mov	r22,r21
811203bc:	902b883a 	mov	r21,r18
811203c0:	8025883a 	mov	r18,r16
811203c4:	dc002c17 	ldw	r16,176(sp)
811203c8:	00000306 	br	811203d8 <___vfprintf_internal_r+0xf8c>
811203cc:	8c7ffc04 	addi	r17,r17,-16
811203d0:	42000204 	addi	r8,r8,8
811203d4:	e440110e 	bge	fp,r17,8112041c <___vfprintf_internal_r+0xfd0>
811203d8:	18c00404 	addi	r3,r3,16
811203dc:	10800044 	addi	r2,r2,1
811203e0:	45000015 	stw	r20,0(r8)
811203e4:	47000115 	stw	fp,4(r8)
811203e8:	d8c02015 	stw	r3,128(sp)
811203ec:	d8801f15 	stw	r2,124(sp)
811203f0:	98bff60e 	bge	r19,r2,811203cc <__reset+0xfb1003cc>
811203f4:	d9801e04 	addi	r6,sp,120
811203f8:	b80b883a 	mov	r5,r23
811203fc:	8009883a 	mov	r4,r16
81120400:	112b63c0 	call	8112b63c <__sprint_r>
81120404:	103d151e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120408:	8c7ffc04 	addi	r17,r17,-16
8112040c:	d8c02017 	ldw	r3,128(sp)
81120410:	d8801f17 	ldw	r2,124(sp)
81120414:	da000404 	addi	r8,sp,16
81120418:	e47fef16 	blt	fp,r17,811203d8 <__reset+0xfb1003d8>
8112041c:	9021883a 	mov	r16,r18
81120420:	a825883a 	mov	r18,r21
81120424:	b02b883a 	mov	r21,r22
81120428:	882d883a 	mov	r22,r17
8112042c:	dc403017 	ldw	r17,192(sp)
81120430:	d9002b17 	ldw	r4,172(sp)
81120434:	1d87883a 	add	r3,r3,r22
81120438:	10800044 	addi	r2,r2,1
8112043c:	41000015 	stw	r4,0(r8)
81120440:	45800115 	stw	r22,4(r8)
81120444:	d8c02015 	stw	r3,128(sp)
81120448:	d8801f15 	stw	r2,124(sp)
8112044c:	010001c4 	movi	r4,7
81120450:	20818e16 	blt	r4,r2,81120a8c <___vfprintf_internal_r+0x1640>
81120454:	42000204 	addi	r8,r8,8
81120458:	003e3106 	br	8111fd20 <__reset+0xfb0ffd20>
8112045c:	d9403317 	ldw	r5,204(sp)
81120460:	00800044 	movi	r2,1
81120464:	18c00044 	addi	r3,r3,1
81120468:	1141530e 	bge	r2,r5,811209b8 <___vfprintf_internal_r+0x156c>
8112046c:	dc401f17 	ldw	r17,124(sp)
81120470:	00800044 	movi	r2,1
81120474:	40800115 	stw	r2,4(r8)
81120478:	8c400044 	addi	r17,r17,1
8112047c:	44000015 	stw	r16,0(r8)
81120480:	d8c02015 	stw	r3,128(sp)
81120484:	dc401f15 	stw	r17,124(sp)
81120488:	008001c4 	movi	r2,7
8112048c:	14416b16 	blt	r2,r17,81120a3c <___vfprintf_internal_r+0x15f0>
81120490:	42000204 	addi	r8,r8,8
81120494:	d8803717 	ldw	r2,220(sp)
81120498:	d9003417 	ldw	r4,208(sp)
8112049c:	8c400044 	addi	r17,r17,1
811204a0:	10c7883a 	add	r3,r2,r3
811204a4:	40800115 	stw	r2,4(r8)
811204a8:	41000015 	stw	r4,0(r8)
811204ac:	d8c02015 	stw	r3,128(sp)
811204b0:	dc401f15 	stw	r17,124(sp)
811204b4:	008001c4 	movi	r2,7
811204b8:	14416916 	blt	r2,r17,81120a60 <___vfprintf_internal_r+0x1614>
811204bc:	45800204 	addi	r22,r8,8
811204c0:	d9003617 	ldw	r4,216(sp)
811204c4:	d9403817 	ldw	r5,224(sp)
811204c8:	000d883a 	mov	r6,zero
811204cc:	000f883a 	mov	r7,zero
811204d0:	d8c03c15 	stw	r3,240(sp)
811204d4:	112fe840 	call	8112fe84 <__eqdf2>
811204d8:	d8c03c17 	ldw	r3,240(sp)
811204dc:	1000bc26 	beq	r2,zero,811207d0 <___vfprintf_internal_r+0x1384>
811204e0:	d9403317 	ldw	r5,204(sp)
811204e4:	84000044 	addi	r16,r16,1
811204e8:	8c400044 	addi	r17,r17,1
811204ec:	28bfffc4 	addi	r2,r5,-1
811204f0:	1887883a 	add	r3,r3,r2
811204f4:	b0800115 	stw	r2,4(r22)
811204f8:	b4000015 	stw	r16,0(r22)
811204fc:	d8c02015 	stw	r3,128(sp)
81120500:	dc401f15 	stw	r17,124(sp)
81120504:	008001c4 	movi	r2,7
81120508:	14414316 	blt	r2,r17,81120a18 <___vfprintf_internal_r+0x15cc>
8112050c:	b5800204 	addi	r22,r22,8
81120510:	d9003a17 	ldw	r4,232(sp)
81120514:	df0022c4 	addi	fp,sp,139
81120518:	8c400044 	addi	r17,r17,1
8112051c:	20c7883a 	add	r3,r4,r3
81120520:	b7000015 	stw	fp,0(r22)
81120524:	b1000115 	stw	r4,4(r22)
81120528:	d8c02015 	stw	r3,128(sp)
8112052c:	dc401f15 	stw	r17,124(sp)
81120530:	008001c4 	movi	r2,7
81120534:	14400e16 	blt	r2,r17,81120570 <___vfprintf_internal_r+0x1124>
81120538:	b2000204 	addi	r8,r22,8
8112053c:	003e3a06 	br	8111fe28 <__reset+0xfb0ffe28>
81120540:	01204574 	movhi	r4,33045
81120544:	21298e84 	addi	r4,r4,-22982
81120548:	d9002b15 	stw	r4,172(sp)
8112054c:	d9002b17 	ldw	r4,172(sp)
81120550:	1c07883a 	add	r3,r3,r16
81120554:	44000115 	stw	r16,4(r8)
81120558:	41000015 	stw	r4,0(r8)
8112055c:	10800044 	addi	r2,r2,1
81120560:	d8c02015 	stw	r3,128(sp)
81120564:	d8801f15 	stw	r2,124(sp)
81120568:	010001c4 	movi	r4,7
8112056c:	20be2d0e 	bge	r4,r2,8111fe24 <__reset+0xfb0ffe24>
81120570:	d9002c17 	ldw	r4,176(sp)
81120574:	d9801e04 	addi	r6,sp,120
81120578:	b80b883a 	mov	r5,r23
8112057c:	112b63c0 	call	8112b63c <__sprint_r>
81120580:	103cb61e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120584:	d8c02017 	ldw	r3,128(sp)
81120588:	da000404 	addi	r8,sp,16
8112058c:	003e2606 	br	8111fe28 <__reset+0xfb0ffe28>
81120590:	d9002c17 	ldw	r4,176(sp)
81120594:	d9801e04 	addi	r6,sp,120
81120598:	b80b883a 	mov	r5,r23
8112059c:	112b63c0 	call	8112b63c <__sprint_r>
811205a0:	103e5d26 	beq	r2,zero,8111ff18 <__reset+0xfb0fff18>
811205a4:	003cad06 	br	8111f85c <__reset+0xfb0ff85c>
811205a8:	d9002c17 	ldw	r4,176(sp)
811205ac:	d9801e04 	addi	r6,sp,120
811205b0:	b80b883a 	mov	r5,r23
811205b4:	112b63c0 	call	8112b63c <__sprint_r>
811205b8:	103ca81e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
811205bc:	d8c02017 	ldw	r3,128(sp)
811205c0:	da000404 	addi	r8,sp,16
811205c4:	003e0b06 	br	8111fdf4 <__reset+0xfb0ffdf4>
811205c8:	d9002c17 	ldw	r4,176(sp)
811205cc:	d9801e04 	addi	r6,sp,120
811205d0:	b80b883a 	mov	r5,r23
811205d4:	112b63c0 	call	8112b63c <__sprint_r>
811205d8:	103ca01e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
811205dc:	d8c02017 	ldw	r3,128(sp)
811205e0:	da000404 	addi	r8,sp,16
811205e4:	003dbd06 	br	8111fcdc <__reset+0xfb0ffcdc>
811205e8:	d9002c17 	ldw	r4,176(sp)
811205ec:	d9801e04 	addi	r6,sp,120
811205f0:	b80b883a 	mov	r5,r23
811205f4:	112b63c0 	call	8112b63c <__sprint_r>
811205f8:	103c981e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
811205fc:	d8c02017 	ldw	r3,128(sp)
81120600:	da000404 	addi	r8,sp,16
81120604:	003dc306 	br	8111fd14 <__reset+0xfb0ffd14>
81120608:	d8802917 	ldw	r2,164(sp)
8112060c:	d8002785 	stb	zero,158(sp)
81120610:	103f0616 	blt	r2,zero,8112022c <__reset+0xfb10022c>
81120614:	00ffdfc4 	movi	r3,-129
81120618:	9d84b03a 	or	r2,r19,r22
8112061c:	90e4703a 	and	r18,r18,r3
81120620:	103c6b26 	beq	r2,zero,8111f7d0 <__reset+0xfb0ff7d0>
81120624:	0039883a 	mov	fp,zero
81120628:	003e7406 	br	8111fffc <__reset+0xfb0ffffc>
8112062c:	9080040c 	andi	r2,r18,16
81120630:	1001b326 	beq	r2,zero,81120d00 <___vfprintf_internal_r+0x18b4>
81120634:	d9002d17 	ldw	r4,180(sp)
81120638:	d9402917 	ldw	r5,164(sp)
8112063c:	d8002785 	stb	zero,158(sp)
81120640:	20800104 	addi	r2,r4,4
81120644:	24c00017 	ldw	r19,0(r4)
81120648:	002d883a 	mov	r22,zero
8112064c:	2801b516 	blt	r5,zero,81120d24 <___vfprintf_internal_r+0x18d8>
81120650:	00ffdfc4 	movi	r3,-129
81120654:	d8802d15 	stw	r2,180(sp)
81120658:	90e4703a 	and	r18,r18,r3
8112065c:	983d2726 	beq	r19,zero,8111fafc <__reset+0xfb0ffafc>
81120660:	0039883a 	mov	fp,zero
81120664:	003d2a06 	br	8111fb10 <__reset+0xfb0ffb10>
81120668:	dc402617 	ldw	r17,152(sp)
8112066c:	0441d30e 	bge	zero,r17,81120dbc <___vfprintf_internal_r+0x1970>
81120670:	dc403217 	ldw	r17,200(sp)
81120674:	d8803317 	ldw	r2,204(sp)
81120678:	1440010e 	bge	r2,r17,81120680 <___vfprintf_internal_r+0x1234>
8112067c:	1023883a 	mov	r17,r2
81120680:	04400a0e 	bge	zero,r17,811206ac <___vfprintf_internal_r+0x1260>
81120684:	d8801f17 	ldw	r2,124(sp)
81120688:	1c47883a 	add	r3,r3,r17
8112068c:	44000015 	stw	r16,0(r8)
81120690:	10800044 	addi	r2,r2,1
81120694:	44400115 	stw	r17,4(r8)
81120698:	d8c02015 	stw	r3,128(sp)
8112069c:	d8801f15 	stw	r2,124(sp)
811206a0:	010001c4 	movi	r4,7
811206a4:	20826516 	blt	r4,r2,8112103c <___vfprintf_internal_r+0x1bf0>
811206a8:	42000204 	addi	r8,r8,8
811206ac:	88026116 	blt	r17,zero,81121034 <___vfprintf_internal_r+0x1be8>
811206b0:	d9003217 	ldw	r4,200(sp)
811206b4:	2463c83a 	sub	r17,r4,r17
811206b8:	04407b0e 	bge	zero,r17,811208a8 <___vfprintf_internal_r+0x145c>
811206bc:	05800404 	movi	r22,16
811206c0:	d8801f17 	ldw	r2,124(sp)
811206c4:	b4419d0e 	bge	r22,r17,81120d3c <___vfprintf_internal_r+0x18f0>
811206c8:	01204574 	movhi	r4,33045
811206cc:	21298e84 	addi	r4,r4,-22982
811206d0:	d9002b15 	stw	r4,172(sp)
811206d4:	070001c4 	movi	fp,7
811206d8:	dcc02c17 	ldw	r19,176(sp)
811206dc:	00000306 	br	811206ec <___vfprintf_internal_r+0x12a0>
811206e0:	42000204 	addi	r8,r8,8
811206e4:	8c7ffc04 	addi	r17,r17,-16
811206e8:	b441970e 	bge	r22,r17,81120d48 <___vfprintf_internal_r+0x18fc>
811206ec:	18c00404 	addi	r3,r3,16
811206f0:	10800044 	addi	r2,r2,1
811206f4:	45000015 	stw	r20,0(r8)
811206f8:	45800115 	stw	r22,4(r8)
811206fc:	d8c02015 	stw	r3,128(sp)
81120700:	d8801f15 	stw	r2,124(sp)
81120704:	e0bff60e 	bge	fp,r2,811206e0 <__reset+0xfb1006e0>
81120708:	d9801e04 	addi	r6,sp,120
8112070c:	b80b883a 	mov	r5,r23
81120710:	9809883a 	mov	r4,r19
81120714:	112b63c0 	call	8112b63c <__sprint_r>
81120718:	103c501e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
8112071c:	d8c02017 	ldw	r3,128(sp)
81120720:	d8801f17 	ldw	r2,124(sp)
81120724:	da000404 	addi	r8,sp,16
81120728:	003fee06 	br	811206e4 <__reset+0xfb1006e4>
8112072c:	d9002c17 	ldw	r4,176(sp)
81120730:	d9801e04 	addi	r6,sp,120
81120734:	b80b883a 	mov	r5,r23
81120738:	112b63c0 	call	8112b63c <__sprint_r>
8112073c:	103c471e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120740:	d8c02017 	ldw	r3,128(sp)
81120744:	df002787 	ldb	fp,158(sp)
81120748:	da000404 	addi	r8,sp,16
8112074c:	003d5606 	br	8111fca8 <__reset+0xfb0ffca8>
81120750:	9080040c 	andi	r2,r18,16
81120754:	10016126 	beq	r2,zero,81120cdc <___vfprintf_internal_r+0x1890>
81120758:	d8802d17 	ldw	r2,180(sp)
8112075c:	14c00017 	ldw	r19,0(r2)
81120760:	10800104 	addi	r2,r2,4
81120764:	d8802d15 	stw	r2,180(sp)
81120768:	982dd7fa 	srai	r22,r19,31
8112076c:	b005883a 	mov	r2,r22
81120770:	003c8206 	br	8111f97c <__reset+0xfb0ff97c>
81120774:	9080040c 	andi	r2,r18,16
81120778:	10003526 	beq	r2,zero,81120850 <___vfprintf_internal_r+0x1404>
8112077c:	d9402d17 	ldw	r5,180(sp)
81120780:	d8c02917 	ldw	r3,164(sp)
81120784:	d8002785 	stb	zero,158(sp)
81120788:	28800104 	addi	r2,r5,4
8112078c:	2cc00017 	ldw	r19,0(r5)
81120790:	002d883a 	mov	r22,zero
81120794:	18003716 	blt	r3,zero,81120874 <___vfprintf_internal_r+0x1428>
81120798:	00ffdfc4 	movi	r3,-129
8112079c:	d8802d15 	stw	r2,180(sp)
811207a0:	90e4703a 	and	r18,r18,r3
811207a4:	0039883a 	mov	fp,zero
811207a8:	983df326 	beq	r19,zero,8111ff78 <__reset+0xfb0fff78>
811207ac:	00800244 	movi	r2,9
811207b0:	14fc7b36 	bltu	r2,r19,8111f9a0 <__reset+0xfb0ff9a0>
811207b4:	d8c02817 	ldw	r3,160(sp)
811207b8:	dc001dc4 	addi	r16,sp,119
811207bc:	9cc00c04 	addi	r19,r19,48
811207c0:	1c07c83a 	sub	r3,r3,r16
811207c4:	dcc01dc5 	stb	r19,119(sp)
811207c8:	d8c02e15 	stw	r3,184(sp)
811207cc:	003ce806 	br	8111fb70 <__reset+0xfb0ffb70>
811207d0:	d8803317 	ldw	r2,204(sp)
811207d4:	143fffc4 	addi	r16,r2,-1
811207d8:	043f4d0e 	bge	zero,r16,81120510 <__reset+0xfb100510>
811207dc:	07000404 	movi	fp,16
811207e0:	e400810e 	bge	fp,r16,811209e8 <___vfprintf_internal_r+0x159c>
811207e4:	01604574 	movhi	r5,33045
811207e8:	29698e84 	addi	r5,r5,-22982
811207ec:	d9402b15 	stw	r5,172(sp)
811207f0:	01c001c4 	movi	r7,7
811207f4:	dcc02c17 	ldw	r19,176(sp)
811207f8:	00000306 	br	81120808 <___vfprintf_internal_r+0x13bc>
811207fc:	b5800204 	addi	r22,r22,8
81120800:	843ffc04 	addi	r16,r16,-16
81120804:	e4007b0e 	bge	fp,r16,811209f4 <___vfprintf_internal_r+0x15a8>
81120808:	18c00404 	addi	r3,r3,16
8112080c:	8c400044 	addi	r17,r17,1
81120810:	b5000015 	stw	r20,0(r22)
81120814:	b7000115 	stw	fp,4(r22)
81120818:	d8c02015 	stw	r3,128(sp)
8112081c:	dc401f15 	stw	r17,124(sp)
81120820:	3c7ff60e 	bge	r7,r17,811207fc <__reset+0xfb1007fc>
81120824:	d9801e04 	addi	r6,sp,120
81120828:	b80b883a 	mov	r5,r23
8112082c:	9809883a 	mov	r4,r19
81120830:	d9c03c15 	stw	r7,240(sp)
81120834:	112b63c0 	call	8112b63c <__sprint_r>
81120838:	d9c03c17 	ldw	r7,240(sp)
8112083c:	103c071e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120840:	d8c02017 	ldw	r3,128(sp)
81120844:	dc401f17 	ldw	r17,124(sp)
81120848:	dd800404 	addi	r22,sp,16
8112084c:	003fec06 	br	81120800 <__reset+0xfb100800>
81120850:	9080100c 	andi	r2,r18,64
81120854:	d8002785 	stb	zero,158(sp)
81120858:	10010e26 	beq	r2,zero,81120c94 <___vfprintf_internal_r+0x1848>
8112085c:	d9002d17 	ldw	r4,180(sp)
81120860:	d9402917 	ldw	r5,164(sp)
81120864:	002d883a 	mov	r22,zero
81120868:	20800104 	addi	r2,r4,4
8112086c:	24c0000b 	ldhu	r19,0(r4)
81120870:	283fc90e 	bge	r5,zero,81120798 <__reset+0xfb100798>
81120874:	d8802d15 	stw	r2,180(sp)
81120878:	0039883a 	mov	fp,zero
8112087c:	9d84b03a 	or	r2,r19,r22
81120880:	103c461e 	bne	r2,zero,8111f99c <__reset+0xfb0ff99c>
81120884:	00800044 	movi	r2,1
81120888:	003e6c06 	br	8112023c <__reset+0xfb10023c>
8112088c:	d9002c17 	ldw	r4,176(sp)
81120890:	d9801e04 	addi	r6,sp,120
81120894:	b80b883a 	mov	r5,r23
81120898:	112b63c0 	call	8112b63c <__sprint_r>
8112089c:	103bef1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
811208a0:	d8c02017 	ldw	r3,128(sp)
811208a4:	da000404 	addi	r8,sp,16
811208a8:	d9003217 	ldw	r4,200(sp)
811208ac:	d8802617 	ldw	r2,152(sp)
811208b0:	d9403317 	ldw	r5,204(sp)
811208b4:	8123883a 	add	r17,r16,r4
811208b8:	11400216 	blt	r2,r5,811208c4 <___vfprintf_internal_r+0x1478>
811208bc:	9100004c 	andi	r4,r18,1
811208c0:	20000d26 	beq	r4,zero,811208f8 <___vfprintf_internal_r+0x14ac>
811208c4:	d9003717 	ldw	r4,220(sp)
811208c8:	d9403417 	ldw	r5,208(sp)
811208cc:	1907883a 	add	r3,r3,r4
811208d0:	d9001f17 	ldw	r4,124(sp)
811208d4:	41400015 	stw	r5,0(r8)
811208d8:	d9403717 	ldw	r5,220(sp)
811208dc:	21000044 	addi	r4,r4,1
811208e0:	d8c02015 	stw	r3,128(sp)
811208e4:	41400115 	stw	r5,4(r8)
811208e8:	d9001f15 	stw	r4,124(sp)
811208ec:	014001c4 	movi	r5,7
811208f0:	2901e816 	blt	r5,r4,81121094 <___vfprintf_internal_r+0x1c48>
811208f4:	42000204 	addi	r8,r8,8
811208f8:	d9003317 	ldw	r4,204(sp)
811208fc:	8121883a 	add	r16,r16,r4
81120900:	2085c83a 	sub	r2,r4,r2
81120904:	8461c83a 	sub	r16,r16,r17
81120908:	1400010e 	bge	r2,r16,81120910 <___vfprintf_internal_r+0x14c4>
8112090c:	1021883a 	mov	r16,r2
81120910:	04000a0e 	bge	zero,r16,8112093c <___vfprintf_internal_r+0x14f0>
81120914:	d9001f17 	ldw	r4,124(sp)
81120918:	1c07883a 	add	r3,r3,r16
8112091c:	44400015 	stw	r17,0(r8)
81120920:	21000044 	addi	r4,r4,1
81120924:	44000115 	stw	r16,4(r8)
81120928:	d8c02015 	stw	r3,128(sp)
8112092c:	d9001f15 	stw	r4,124(sp)
81120930:	014001c4 	movi	r5,7
81120934:	2901fb16 	blt	r5,r4,81121124 <___vfprintf_internal_r+0x1cd8>
81120938:	42000204 	addi	r8,r8,8
8112093c:	8001f716 	blt	r16,zero,8112111c <___vfprintf_internal_r+0x1cd0>
81120940:	1421c83a 	sub	r16,r2,r16
81120944:	043d380e 	bge	zero,r16,8111fe28 <__reset+0xfb0ffe28>
81120948:	04400404 	movi	r17,16
8112094c:	d8801f17 	ldw	r2,124(sp)
81120950:	8c3efb0e 	bge	r17,r16,81120540 <__reset+0xfb100540>
81120954:	01604574 	movhi	r5,33045
81120958:	29698e84 	addi	r5,r5,-22982
8112095c:	d9402b15 	stw	r5,172(sp)
81120960:	058001c4 	movi	r22,7
81120964:	dcc02c17 	ldw	r19,176(sp)
81120968:	00000306 	br	81120978 <___vfprintf_internal_r+0x152c>
8112096c:	42000204 	addi	r8,r8,8
81120970:	843ffc04 	addi	r16,r16,-16
81120974:	8c3ef50e 	bge	r17,r16,8112054c <__reset+0xfb10054c>
81120978:	18c00404 	addi	r3,r3,16
8112097c:	10800044 	addi	r2,r2,1
81120980:	45000015 	stw	r20,0(r8)
81120984:	44400115 	stw	r17,4(r8)
81120988:	d8c02015 	stw	r3,128(sp)
8112098c:	d8801f15 	stw	r2,124(sp)
81120990:	b0bff60e 	bge	r22,r2,8112096c <__reset+0xfb10096c>
81120994:	d9801e04 	addi	r6,sp,120
81120998:	b80b883a 	mov	r5,r23
8112099c:	9809883a 	mov	r4,r19
811209a0:	112b63c0 	call	8112b63c <__sprint_r>
811209a4:	103bad1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
811209a8:	d8c02017 	ldw	r3,128(sp)
811209ac:	d8801f17 	ldw	r2,124(sp)
811209b0:	da000404 	addi	r8,sp,16
811209b4:	003fee06 	br	81120970 <__reset+0xfb100970>
811209b8:	9088703a 	and	r4,r18,r2
811209bc:	203eab1e 	bne	r4,zero,8112046c <__reset+0xfb10046c>
811209c0:	dc401f17 	ldw	r17,124(sp)
811209c4:	40800115 	stw	r2,4(r8)
811209c8:	44000015 	stw	r16,0(r8)
811209cc:	8c400044 	addi	r17,r17,1
811209d0:	d8c02015 	stw	r3,128(sp)
811209d4:	dc401f15 	stw	r17,124(sp)
811209d8:	008001c4 	movi	r2,7
811209dc:	14400e16 	blt	r2,r17,81120a18 <___vfprintf_internal_r+0x15cc>
811209e0:	45800204 	addi	r22,r8,8
811209e4:	003eca06 	br	81120510 <__reset+0xfb100510>
811209e8:	01204574 	movhi	r4,33045
811209ec:	21298e84 	addi	r4,r4,-22982
811209f0:	d9002b15 	stw	r4,172(sp)
811209f4:	d8802b17 	ldw	r2,172(sp)
811209f8:	1c07883a 	add	r3,r3,r16
811209fc:	8c400044 	addi	r17,r17,1
81120a00:	b0800015 	stw	r2,0(r22)
81120a04:	b4000115 	stw	r16,4(r22)
81120a08:	d8c02015 	stw	r3,128(sp)
81120a0c:	dc401f15 	stw	r17,124(sp)
81120a10:	008001c4 	movi	r2,7
81120a14:	147ebd0e 	bge	r2,r17,8112050c <__reset+0xfb10050c>
81120a18:	d9002c17 	ldw	r4,176(sp)
81120a1c:	d9801e04 	addi	r6,sp,120
81120a20:	b80b883a 	mov	r5,r23
81120a24:	112b63c0 	call	8112b63c <__sprint_r>
81120a28:	103b8c1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120a2c:	d8c02017 	ldw	r3,128(sp)
81120a30:	dc401f17 	ldw	r17,124(sp)
81120a34:	dd800404 	addi	r22,sp,16
81120a38:	003eb506 	br	81120510 <__reset+0xfb100510>
81120a3c:	d9002c17 	ldw	r4,176(sp)
81120a40:	d9801e04 	addi	r6,sp,120
81120a44:	b80b883a 	mov	r5,r23
81120a48:	112b63c0 	call	8112b63c <__sprint_r>
81120a4c:	103b831e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120a50:	d8c02017 	ldw	r3,128(sp)
81120a54:	dc401f17 	ldw	r17,124(sp)
81120a58:	da000404 	addi	r8,sp,16
81120a5c:	003e8d06 	br	81120494 <__reset+0xfb100494>
81120a60:	d9002c17 	ldw	r4,176(sp)
81120a64:	d9801e04 	addi	r6,sp,120
81120a68:	b80b883a 	mov	r5,r23
81120a6c:	112b63c0 	call	8112b63c <__sprint_r>
81120a70:	103b7a1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120a74:	d8c02017 	ldw	r3,128(sp)
81120a78:	dc401f17 	ldw	r17,124(sp)
81120a7c:	dd800404 	addi	r22,sp,16
81120a80:	003e8f06 	br	811204c0 <__reset+0xfb1004c0>
81120a84:	0027883a 	mov	r19,zero
81120a88:	003f4a06 	br	811207b4 <__reset+0xfb1007b4>
81120a8c:	d9002c17 	ldw	r4,176(sp)
81120a90:	d9801e04 	addi	r6,sp,120
81120a94:	b80b883a 	mov	r5,r23
81120a98:	112b63c0 	call	8112b63c <__sprint_r>
81120a9c:	103b6f1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120aa0:	d8c02017 	ldw	r3,128(sp)
81120aa4:	da000404 	addi	r8,sp,16
81120aa8:	003c9d06 	br	8111fd20 <__reset+0xfb0ffd20>
81120aac:	04e7c83a 	sub	r19,zero,r19
81120ab0:	9804c03a 	cmpne	r2,r19,zero
81120ab4:	05adc83a 	sub	r22,zero,r22
81120ab8:	b0adc83a 	sub	r22,r22,r2
81120abc:	d8802917 	ldw	r2,164(sp)
81120ac0:	07000b44 	movi	fp,45
81120ac4:	df002785 	stb	fp,158(sp)
81120ac8:	10017b16 	blt	r2,zero,811210b8 <___vfprintf_internal_r+0x1c6c>
81120acc:	00bfdfc4 	movi	r2,-129
81120ad0:	90a4703a 	and	r18,r18,r2
81120ad4:	003bb106 	br	8111f99c <__reset+0xfb0ff99c>
81120ad8:	d9003617 	ldw	r4,216(sp)
81120adc:	d9403817 	ldw	r5,224(sp)
81120ae0:	da003d15 	stw	r8,244(sp)
81120ae4:	1127ca00 	call	81127ca0 <__fpclassifyd>
81120ae8:	da003d17 	ldw	r8,244(sp)
81120aec:	1000f026 	beq	r2,zero,81120eb0 <___vfprintf_internal_r+0x1a64>
81120af0:	d9002917 	ldw	r4,164(sp)
81120af4:	05bff7c4 	movi	r22,-33
81120af8:	00bfffc4 	movi	r2,-1
81120afc:	8dac703a 	and	r22,r17,r22
81120b00:	20820026 	beq	r4,r2,81121304 <___vfprintf_internal_r+0x1eb8>
81120b04:	008011c4 	movi	r2,71
81120b08:	b081f726 	beq	r22,r2,811212e8 <___vfprintf_internal_r+0x1e9c>
81120b0c:	d9003817 	ldw	r4,224(sp)
81120b10:	90c04014 	ori	r3,r18,256
81120b14:	d8c02b15 	stw	r3,172(sp)
81120b18:	20021516 	blt	r4,zero,81121370 <___vfprintf_internal_r+0x1f24>
81120b1c:	dcc03817 	ldw	r19,224(sp)
81120b20:	d8002a05 	stb	zero,168(sp)
81120b24:	00801984 	movi	r2,102
81120b28:	8881f926 	beq	r17,r2,81121310 <___vfprintf_internal_r+0x1ec4>
81120b2c:	00801184 	movi	r2,70
81120b30:	88821c26 	beq	r17,r2,811213a4 <___vfprintf_internal_r+0x1f58>
81120b34:	00801144 	movi	r2,69
81120b38:	b081ef26 	beq	r22,r2,811212f8 <___vfprintf_internal_r+0x1eac>
81120b3c:	d8c02917 	ldw	r3,164(sp)
81120b40:	d8802104 	addi	r2,sp,132
81120b44:	d8800315 	stw	r2,12(sp)
81120b48:	d9403617 	ldw	r5,216(sp)
81120b4c:	d8802504 	addi	r2,sp,148
81120b50:	d9002c17 	ldw	r4,176(sp)
81120b54:	d8800215 	stw	r2,8(sp)
81120b58:	d8802604 	addi	r2,sp,152
81120b5c:	d8c00015 	stw	r3,0(sp)
81120b60:	d8800115 	stw	r2,4(sp)
81120b64:	01c00084 	movi	r7,2
81120b68:	980d883a 	mov	r6,r19
81120b6c:	d8c03c15 	stw	r3,240(sp)
81120b70:	da003d15 	stw	r8,244(sp)
81120b74:	11235580 	call	81123558 <_dtoa_r>
81120b78:	1021883a 	mov	r16,r2
81120b7c:	008019c4 	movi	r2,103
81120b80:	d8c03c17 	ldw	r3,240(sp)
81120b84:	da003d17 	ldw	r8,244(sp)
81120b88:	88817126 	beq	r17,r2,81121150 <___vfprintf_internal_r+0x1d04>
81120b8c:	008011c4 	movi	r2,71
81120b90:	88829226 	beq	r17,r2,811215dc <___vfprintf_internal_r+0x2190>
81120b94:	80f9883a 	add	fp,r16,r3
81120b98:	d9003617 	ldw	r4,216(sp)
81120b9c:	000d883a 	mov	r6,zero
81120ba0:	000f883a 	mov	r7,zero
81120ba4:	980b883a 	mov	r5,r19
81120ba8:	da003d15 	stw	r8,244(sp)
81120bac:	112fe840 	call	8112fe84 <__eqdf2>
81120bb0:	da003d17 	ldw	r8,244(sp)
81120bb4:	10018d26 	beq	r2,zero,811211ec <___vfprintf_internal_r+0x1da0>
81120bb8:	d8802117 	ldw	r2,132(sp)
81120bbc:	1700062e 	bgeu	r2,fp,81120bd8 <___vfprintf_internal_r+0x178c>
81120bc0:	01000c04 	movi	r4,48
81120bc4:	10c00044 	addi	r3,r2,1
81120bc8:	d8c02115 	stw	r3,132(sp)
81120bcc:	11000005 	stb	r4,0(r2)
81120bd0:	d8802117 	ldw	r2,132(sp)
81120bd4:	173ffb36 	bltu	r2,fp,81120bc4 <__reset+0xfb100bc4>
81120bd8:	1405c83a 	sub	r2,r2,r16
81120bdc:	d8803315 	stw	r2,204(sp)
81120be0:	008011c4 	movi	r2,71
81120be4:	b0817626 	beq	r22,r2,811211c0 <___vfprintf_internal_r+0x1d74>
81120be8:	00801944 	movi	r2,101
81120bec:	1442810e 	bge	r2,r17,811215f4 <___vfprintf_internal_r+0x21a8>
81120bf0:	d8c02617 	ldw	r3,152(sp)
81120bf4:	00801984 	movi	r2,102
81120bf8:	d8c03215 	stw	r3,200(sp)
81120bfc:	8881fe26 	beq	r17,r2,811213f8 <___vfprintf_internal_r+0x1fac>
81120c00:	d8c03217 	ldw	r3,200(sp)
81120c04:	d9003317 	ldw	r4,204(sp)
81120c08:	1901dd16 	blt	r3,r4,81121380 <___vfprintf_internal_r+0x1f34>
81120c0c:	9480004c 	andi	r18,r18,1
81120c10:	90022b1e 	bne	r18,zero,811214c0 <___vfprintf_internal_r+0x2074>
81120c14:	1805883a 	mov	r2,r3
81120c18:	18028016 	blt	r3,zero,8112161c <___vfprintf_internal_r+0x21d0>
81120c1c:	d8c03217 	ldw	r3,200(sp)
81120c20:	044019c4 	movi	r17,103
81120c24:	d8c02e15 	stw	r3,184(sp)
81120c28:	df002a07 	ldb	fp,168(sp)
81120c2c:	e001531e 	bne	fp,zero,8112117c <___vfprintf_internal_r+0x1d30>
81120c30:	df002783 	ldbu	fp,158(sp)
81120c34:	d8802a15 	stw	r2,168(sp)
81120c38:	dc802b17 	ldw	r18,172(sp)
81120c3c:	d8002915 	stw	zero,164(sp)
81120c40:	003bd106 	br	8111fb88 <__reset+0xfb0ffb88>
81120c44:	d8802d17 	ldw	r2,180(sp)
81120c48:	d8c02d17 	ldw	r3,180(sp)
81120c4c:	d9002d17 	ldw	r4,180(sp)
81120c50:	10800017 	ldw	r2,0(r2)
81120c54:	18c00117 	ldw	r3,4(r3)
81120c58:	21000204 	addi	r4,r4,8
81120c5c:	d8803615 	stw	r2,216(sp)
81120c60:	d8c03815 	stw	r3,224(sp)
81120c64:	d9002d15 	stw	r4,180(sp)
81120c68:	003b7506 	br	8111fa40 <__reset+0xfb0ffa40>
81120c6c:	ac400007 	ldb	r17,0(r21)
81120c70:	003a5906 	br	8111f5d8 <__reset+0xfb0ff5d8>
81120c74:	9080100c 	andi	r2,r18,64
81120c78:	1000a826 	beq	r2,zero,81120f1c <___vfprintf_internal_r+0x1ad0>
81120c7c:	d9002d17 	ldw	r4,180(sp)
81120c80:	002d883a 	mov	r22,zero
81120c84:	24c0000b 	ldhu	r19,0(r4)
81120c88:	21000104 	addi	r4,r4,4
81120c8c:	d9002d15 	stw	r4,180(sp)
81120c90:	003ccb06 	br	8111ffc0 <__reset+0xfb0fffc0>
81120c94:	d8c02d17 	ldw	r3,180(sp)
81120c98:	d9002917 	ldw	r4,164(sp)
81120c9c:	002d883a 	mov	r22,zero
81120ca0:	18800104 	addi	r2,r3,4
81120ca4:	1cc00017 	ldw	r19,0(r3)
81120ca8:	203ebb0e 	bge	r4,zero,81120798 <__reset+0xfb100798>
81120cac:	003ef106 	br	81120874 <__reset+0xfb100874>
81120cb0:	9080040c 	andi	r2,r18,16
81120cb4:	1000921e 	bne	r2,zero,81120f00 <___vfprintf_internal_r+0x1ab4>
81120cb8:	9480100c 	andi	r18,r18,64
81120cbc:	90013926 	beq	r18,zero,811211a4 <___vfprintf_internal_r+0x1d58>
81120cc0:	d9002d17 	ldw	r4,180(sp)
81120cc4:	d9402f17 	ldw	r5,188(sp)
81120cc8:	20800017 	ldw	r2,0(r4)
81120ccc:	21000104 	addi	r4,r4,4
81120cd0:	d9002d15 	stw	r4,180(sp)
81120cd4:	1140000d 	sth	r5,0(r2)
81120cd8:	003a1606 	br	8111f534 <__reset+0xfb0ff534>
81120cdc:	9080100c 	andi	r2,r18,64
81120ce0:	10008026 	beq	r2,zero,81120ee4 <___vfprintf_internal_r+0x1a98>
81120ce4:	d8c02d17 	ldw	r3,180(sp)
81120ce8:	1cc0000f 	ldh	r19,0(r3)
81120cec:	18c00104 	addi	r3,r3,4
81120cf0:	d8c02d15 	stw	r3,180(sp)
81120cf4:	982dd7fa 	srai	r22,r19,31
81120cf8:	b005883a 	mov	r2,r22
81120cfc:	003b1f06 	br	8111f97c <__reset+0xfb0ff97c>
81120d00:	9080100c 	andi	r2,r18,64
81120d04:	d8002785 	stb	zero,158(sp)
81120d08:	10008a1e 	bne	r2,zero,81120f34 <___vfprintf_internal_r+0x1ae8>
81120d0c:	d9402d17 	ldw	r5,180(sp)
81120d10:	d8c02917 	ldw	r3,164(sp)
81120d14:	002d883a 	mov	r22,zero
81120d18:	28800104 	addi	r2,r5,4
81120d1c:	2cc00017 	ldw	r19,0(r5)
81120d20:	183e4b0e 	bge	r3,zero,81120650 <__reset+0xfb100650>
81120d24:	9d86b03a 	or	r3,r19,r22
81120d28:	d8802d15 	stw	r2,180(sp)
81120d2c:	183e4c1e 	bne	r3,zero,81120660 <__reset+0xfb100660>
81120d30:	0039883a 	mov	fp,zero
81120d34:	0005883a 	mov	r2,zero
81120d38:	003d4006 	br	8112023c <__reset+0xfb10023c>
81120d3c:	01604574 	movhi	r5,33045
81120d40:	29698e84 	addi	r5,r5,-22982
81120d44:	d9402b15 	stw	r5,172(sp)
81120d48:	d9402b17 	ldw	r5,172(sp)
81120d4c:	1c47883a 	add	r3,r3,r17
81120d50:	10800044 	addi	r2,r2,1
81120d54:	41400015 	stw	r5,0(r8)
81120d58:	44400115 	stw	r17,4(r8)
81120d5c:	d8c02015 	stw	r3,128(sp)
81120d60:	d8801f15 	stw	r2,124(sp)
81120d64:	010001c4 	movi	r4,7
81120d68:	20bec816 	blt	r4,r2,8112088c <__reset+0xfb10088c>
81120d6c:	42000204 	addi	r8,r8,8
81120d70:	003ecd06 	br	811208a8 <__reset+0xfb1008a8>
81120d74:	d9002917 	ldw	r4,164(sp)
81120d78:	d8002785 	stb	zero,158(sp)
81120d7c:	203d2d16 	blt	r4,zero,81120234 <__reset+0xfb100234>
81120d80:	00bfdfc4 	movi	r2,-129
81120d84:	90a4703a 	and	r18,r18,r2
81120d88:	003a9106 	br	8111f7d0 <__reset+0xfb0ff7d0>
81120d8c:	01204574 	movhi	r4,33045
81120d90:	21298e84 	addi	r4,r4,-22982
81120d94:	d9002b15 	stw	r4,172(sp)
81120d98:	003c0c06 	br	8111fdcc <__reset+0xfb0ffdcc>
81120d9c:	d9002c17 	ldw	r4,176(sp)
81120da0:	d9801e04 	addi	r6,sp,120
81120da4:	b80b883a 	mov	r5,r23
81120da8:	112b63c0 	call	8112b63c <__sprint_r>
81120dac:	103aab1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120db0:	d8c02017 	ldw	r3,128(sp)
81120db4:	da000404 	addi	r8,sp,16
81120db8:	003d4106 	br	811202c0 <__reset+0xfb1002c0>
81120dbc:	d8801f17 	ldw	r2,124(sp)
81120dc0:	01604574 	movhi	r5,33045
81120dc4:	01000044 	movi	r4,1
81120dc8:	18c00044 	addi	r3,r3,1
81120dcc:	10800044 	addi	r2,r2,1
81120dd0:	29698604 	addi	r5,r5,-23016
81120dd4:	41000115 	stw	r4,4(r8)
81120dd8:	41400015 	stw	r5,0(r8)
81120ddc:	d8c02015 	stw	r3,128(sp)
81120de0:	d8801f15 	stw	r2,124(sp)
81120de4:	010001c4 	movi	r4,7
81120de8:	20805c16 	blt	r4,r2,81120f5c <___vfprintf_internal_r+0x1b10>
81120dec:	42000204 	addi	r8,r8,8
81120df0:	8800041e 	bne	r17,zero,81120e04 <___vfprintf_internal_r+0x19b8>
81120df4:	d8803317 	ldw	r2,204(sp)
81120df8:	1000021e 	bne	r2,zero,81120e04 <___vfprintf_internal_r+0x19b8>
81120dfc:	9080004c 	andi	r2,r18,1
81120e00:	103c0926 	beq	r2,zero,8111fe28 <__reset+0xfb0ffe28>
81120e04:	d9003717 	ldw	r4,220(sp)
81120e08:	d8801f17 	ldw	r2,124(sp)
81120e0c:	d9403417 	ldw	r5,208(sp)
81120e10:	20c7883a 	add	r3,r4,r3
81120e14:	10800044 	addi	r2,r2,1
81120e18:	41000115 	stw	r4,4(r8)
81120e1c:	41400015 	stw	r5,0(r8)
81120e20:	d8c02015 	stw	r3,128(sp)
81120e24:	d8801f15 	stw	r2,124(sp)
81120e28:	010001c4 	movi	r4,7
81120e2c:	20812116 	blt	r4,r2,811212b4 <___vfprintf_internal_r+0x1e68>
81120e30:	42000204 	addi	r8,r8,8
81120e34:	0463c83a 	sub	r17,zero,r17
81120e38:	0440730e 	bge	zero,r17,81121008 <___vfprintf_internal_r+0x1bbc>
81120e3c:	05800404 	movi	r22,16
81120e40:	b440860e 	bge	r22,r17,8112105c <___vfprintf_internal_r+0x1c10>
81120e44:	01604574 	movhi	r5,33045
81120e48:	29698e84 	addi	r5,r5,-22982
81120e4c:	d9402b15 	stw	r5,172(sp)
81120e50:	070001c4 	movi	fp,7
81120e54:	dcc02c17 	ldw	r19,176(sp)
81120e58:	00000306 	br	81120e68 <___vfprintf_internal_r+0x1a1c>
81120e5c:	42000204 	addi	r8,r8,8
81120e60:	8c7ffc04 	addi	r17,r17,-16
81120e64:	b440800e 	bge	r22,r17,81121068 <___vfprintf_internal_r+0x1c1c>
81120e68:	18c00404 	addi	r3,r3,16
81120e6c:	10800044 	addi	r2,r2,1
81120e70:	45000015 	stw	r20,0(r8)
81120e74:	45800115 	stw	r22,4(r8)
81120e78:	d8c02015 	stw	r3,128(sp)
81120e7c:	d8801f15 	stw	r2,124(sp)
81120e80:	e0bff60e 	bge	fp,r2,81120e5c <__reset+0xfb100e5c>
81120e84:	d9801e04 	addi	r6,sp,120
81120e88:	b80b883a 	mov	r5,r23
81120e8c:	9809883a 	mov	r4,r19
81120e90:	112b63c0 	call	8112b63c <__sprint_r>
81120e94:	103a711e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120e98:	d8c02017 	ldw	r3,128(sp)
81120e9c:	d8801f17 	ldw	r2,124(sp)
81120ea0:	da000404 	addi	r8,sp,16
81120ea4:	003fee06 	br	81120e60 <__reset+0xfb100e60>
81120ea8:	00bfffc4 	movi	r2,-1
81120eac:	003a6f06 	br	8111f86c <__reset+0xfb0ff86c>
81120eb0:	008011c4 	movi	r2,71
81120eb4:	1440b816 	blt	r2,r17,81121198 <___vfprintf_internal_r+0x1d4c>
81120eb8:	04204574 	movhi	r16,33045
81120ebc:	84297804 	addi	r16,r16,-23072
81120ec0:	00c000c4 	movi	r3,3
81120ec4:	00bfdfc4 	movi	r2,-129
81120ec8:	d8c02a15 	stw	r3,168(sp)
81120ecc:	90a4703a 	and	r18,r18,r2
81120ed0:	df002783 	ldbu	fp,158(sp)
81120ed4:	d8c02e15 	stw	r3,184(sp)
81120ed8:	d8002915 	stw	zero,164(sp)
81120edc:	d8003215 	stw	zero,200(sp)
81120ee0:	003b2906 	br	8111fb88 <__reset+0xfb0ffb88>
81120ee4:	d9002d17 	ldw	r4,180(sp)
81120ee8:	24c00017 	ldw	r19,0(r4)
81120eec:	21000104 	addi	r4,r4,4
81120ef0:	d9002d15 	stw	r4,180(sp)
81120ef4:	982dd7fa 	srai	r22,r19,31
81120ef8:	b005883a 	mov	r2,r22
81120efc:	003a9f06 	br	8111f97c <__reset+0xfb0ff97c>
81120f00:	d9402d17 	ldw	r5,180(sp)
81120f04:	d8c02f17 	ldw	r3,188(sp)
81120f08:	28800017 	ldw	r2,0(r5)
81120f0c:	29400104 	addi	r5,r5,4
81120f10:	d9402d15 	stw	r5,180(sp)
81120f14:	10c00015 	stw	r3,0(r2)
81120f18:	00398606 	br	8111f534 <__reset+0xfb0ff534>
81120f1c:	d9402d17 	ldw	r5,180(sp)
81120f20:	002d883a 	mov	r22,zero
81120f24:	2cc00017 	ldw	r19,0(r5)
81120f28:	29400104 	addi	r5,r5,4
81120f2c:	d9402d15 	stw	r5,180(sp)
81120f30:	003c2306 	br	8111ffc0 <__reset+0xfb0fffc0>
81120f34:	d8c02d17 	ldw	r3,180(sp)
81120f38:	d9002917 	ldw	r4,164(sp)
81120f3c:	002d883a 	mov	r22,zero
81120f40:	18800104 	addi	r2,r3,4
81120f44:	1cc0000b 	ldhu	r19,0(r3)
81120f48:	203dc10e 	bge	r4,zero,81120650 <__reset+0xfb100650>
81120f4c:	003f7506 	br	81120d24 <__reset+0xfb100d24>
81120f50:	04204574 	movhi	r16,33045
81120f54:	84297604 	addi	r16,r16,-23080
81120f58:	003acc06 	br	8111fa8c <__reset+0xfb0ffa8c>
81120f5c:	d9002c17 	ldw	r4,176(sp)
81120f60:	d9801e04 	addi	r6,sp,120
81120f64:	b80b883a 	mov	r5,r23
81120f68:	112b63c0 	call	8112b63c <__sprint_r>
81120f6c:	103a3b1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120f70:	dc402617 	ldw	r17,152(sp)
81120f74:	d8c02017 	ldw	r3,128(sp)
81120f78:	da000404 	addi	r8,sp,16
81120f7c:	003f9c06 	br	81120df0 <__reset+0xfb100df0>
81120f80:	ac400043 	ldbu	r17,1(r21)
81120f84:	94800814 	ori	r18,r18,32
81120f88:	ad400044 	addi	r21,r21,1
81120f8c:	8c403fcc 	andi	r17,r17,255
81120f90:	8c40201c 	xori	r17,r17,128
81120f94:	8c7fe004 	addi	r17,r17,-128
81120f98:	00398f06 	br	8111f5d8 <__reset+0xfb0ff5d8>
81120f9c:	d8c02d15 	stw	r3,180(sp)
81120fa0:	0039883a 	mov	fp,zero
81120fa4:	003e3506 	br	8112087c <__reset+0xfb10087c>
81120fa8:	d9002c17 	ldw	r4,176(sp)
81120fac:	d9801e04 	addi	r6,sp,120
81120fb0:	b80b883a 	mov	r5,r23
81120fb4:	112b63c0 	call	8112b63c <__sprint_r>
81120fb8:	103a281e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120fbc:	d8c02017 	ldw	r3,128(sp)
81120fc0:	da000404 	addi	r8,sp,16
81120fc4:	003cd006 	br	81120308 <__reset+0xfb100308>
81120fc8:	8009883a 	mov	r4,r16
81120fcc:	da003d15 	stw	r8,244(sp)
81120fd0:	111cf340 	call	8111cf34 <strlen>
81120fd4:	d8802e15 	stw	r2,184(sp)
81120fd8:	da003d17 	ldw	r8,244(sp)
81120fdc:	103c340e 	bge	r2,zero,811200b0 <__reset+0xfb1000b0>
81120fe0:	0005883a 	mov	r2,zero
81120fe4:	003c3206 	br	811200b0 <__reset+0xfb1000b0>
81120fe8:	d9002c17 	ldw	r4,176(sp)
81120fec:	d9801e04 	addi	r6,sp,120
81120ff0:	b80b883a 	mov	r5,r23
81120ff4:	112b63c0 	call	8112b63c <__sprint_r>
81120ff8:	103a181e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81120ffc:	d8c02017 	ldw	r3,128(sp)
81121000:	d8801f17 	ldw	r2,124(sp)
81121004:	da000404 	addi	r8,sp,16
81121008:	d9403317 	ldw	r5,204(sp)
8112100c:	10800044 	addi	r2,r2,1
81121010:	44000015 	stw	r16,0(r8)
81121014:	28c7883a 	add	r3,r5,r3
81121018:	003b7d06 	br	8111fe10 <__reset+0xfb0ffe10>
8112101c:	01204574 	movhi	r4,33045
81121020:	21299284 	addi	r4,r4,-22966
81121024:	d9003515 	stw	r4,212(sp)
81121028:	003b1406 	br	8111fc7c <__reset+0xfb0ffc7c>
8112102c:	013fffc4 	movi	r4,-1
81121030:	003a3506 	br	8111f908 <__reset+0xfb0ff908>
81121034:	0023883a 	mov	r17,zero
81121038:	003d9d06 	br	811206b0 <__reset+0xfb1006b0>
8112103c:	d9002c17 	ldw	r4,176(sp)
81121040:	d9801e04 	addi	r6,sp,120
81121044:	b80b883a 	mov	r5,r23
81121048:	112b63c0 	call	8112b63c <__sprint_r>
8112104c:	103a031e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81121050:	d8c02017 	ldw	r3,128(sp)
81121054:	da000404 	addi	r8,sp,16
81121058:	003d9406 	br	811206ac <__reset+0xfb1006ac>
8112105c:	01204574 	movhi	r4,33045
81121060:	21298e84 	addi	r4,r4,-22982
81121064:	d9002b15 	stw	r4,172(sp)
81121068:	d9002b17 	ldw	r4,172(sp)
8112106c:	1c47883a 	add	r3,r3,r17
81121070:	10800044 	addi	r2,r2,1
81121074:	41000015 	stw	r4,0(r8)
81121078:	44400115 	stw	r17,4(r8)
8112107c:	d8c02015 	stw	r3,128(sp)
81121080:	d8801f15 	stw	r2,124(sp)
81121084:	010001c4 	movi	r4,7
81121088:	20bfd716 	blt	r4,r2,81120fe8 <__reset+0xfb100fe8>
8112108c:	42000204 	addi	r8,r8,8
81121090:	003fdd06 	br	81121008 <__reset+0xfb101008>
81121094:	d9002c17 	ldw	r4,176(sp)
81121098:	d9801e04 	addi	r6,sp,120
8112109c:	b80b883a 	mov	r5,r23
811210a0:	112b63c0 	call	8112b63c <__sprint_r>
811210a4:	1039ed1e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
811210a8:	d8802617 	ldw	r2,152(sp)
811210ac:	d8c02017 	ldw	r3,128(sp)
811210b0:	da000404 	addi	r8,sp,16
811210b4:	003e1006 	br	811208f8 <__reset+0xfb1008f8>
811210b8:	00800044 	movi	r2,1
811210bc:	10803fcc 	andi	r2,r2,255
811210c0:	00c00044 	movi	r3,1
811210c4:	10fa3526 	beq	r2,r3,8111f99c <__reset+0xfb0ff99c>
811210c8:	00c00084 	movi	r3,2
811210cc:	10fbcb26 	beq	r2,r3,8111fffc <__reset+0xfb0ffffc>
811210d0:	003a8f06 	br	8111fb10 <__reset+0xfb0ffb10>
811210d4:	01204574 	movhi	r4,33045
811210d8:	21299284 	addi	r4,r4,-22966
811210dc:	d9003515 	stw	r4,212(sp)
811210e0:	003b7606 	br	8111febc <__reset+0xfb0ffebc>
811210e4:	d8802917 	ldw	r2,164(sp)
811210e8:	00c00184 	movi	r3,6
811210ec:	1880012e 	bgeu	r3,r2,811210f4 <___vfprintf_internal_r+0x1ca8>
811210f0:	1805883a 	mov	r2,r3
811210f4:	d8802e15 	stw	r2,184(sp)
811210f8:	1000ef16 	blt	r2,zero,811214b8 <___vfprintf_internal_r+0x206c>
811210fc:	04204574 	movhi	r16,33045
81121100:	d8802a15 	stw	r2,168(sp)
81121104:	dcc02d15 	stw	r19,180(sp)
81121108:	d8002915 	stw	zero,164(sp)
8112110c:	d8003215 	stw	zero,200(sp)
81121110:	84298404 	addi	r16,r16,-23024
81121114:	0039883a 	mov	fp,zero
81121118:	003aa206 	br	8111fba4 <__reset+0xfb0ffba4>
8112111c:	0021883a 	mov	r16,zero
81121120:	003e0706 	br	81120940 <__reset+0xfb100940>
81121124:	d9002c17 	ldw	r4,176(sp)
81121128:	d9801e04 	addi	r6,sp,120
8112112c:	b80b883a 	mov	r5,r23
81121130:	112b63c0 	call	8112b63c <__sprint_r>
81121134:	1039c91e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
81121138:	d8802617 	ldw	r2,152(sp)
8112113c:	d9403317 	ldw	r5,204(sp)
81121140:	d8c02017 	ldw	r3,128(sp)
81121144:	da000404 	addi	r8,sp,16
81121148:	2885c83a 	sub	r2,r5,r2
8112114c:	003dfb06 	br	8112093c <__reset+0xfb10093c>
81121150:	9080004c 	andi	r2,r18,1
81121154:	103e8f1e 	bne	r2,zero,81120b94 <__reset+0xfb100b94>
81121158:	d8802117 	ldw	r2,132(sp)
8112115c:	003e9e06 	br	81120bd8 <__reset+0xfb100bd8>
81121160:	1025883a 	mov	r18,r2
81121164:	0039883a 	mov	fp,zero
81121168:	00800084 	movi	r2,2
8112116c:	003fd306 	br	811210bc <__reset+0xfb1010bc>
81121170:	07000b44 	movi	fp,45
81121174:	df002785 	stb	fp,158(sp)
81121178:	003a4006 	br	8111fa7c <__reset+0xfb0ffa7c>
8112117c:	00c00b44 	movi	r3,45
81121180:	d8c02785 	stb	r3,158(sp)
81121184:	d8802a15 	stw	r2,168(sp)
81121188:	dc802b17 	ldw	r18,172(sp)
8112118c:	d8002915 	stw	zero,164(sp)
81121190:	07000b44 	movi	fp,45
81121194:	003a8006 	br	8111fb98 <__reset+0xfb0ffb98>
81121198:	04204574 	movhi	r16,33045
8112119c:	84297904 	addi	r16,r16,-23068
811211a0:	003f4706 	br	81120ec0 <__reset+0xfb100ec0>
811211a4:	d8c02d17 	ldw	r3,180(sp)
811211a8:	d9002f17 	ldw	r4,188(sp)
811211ac:	18800017 	ldw	r2,0(r3)
811211b0:	18c00104 	addi	r3,r3,4
811211b4:	d8c02d15 	stw	r3,180(sp)
811211b8:	11000015 	stw	r4,0(r2)
811211bc:	0038dd06 	br	8111f534 <__reset+0xfb0ff534>
811211c0:	dd802617 	ldw	r22,152(sp)
811211c4:	00bfff44 	movi	r2,-3
811211c8:	b0801c16 	blt	r22,r2,8112123c <___vfprintf_internal_r+0x1df0>
811211cc:	d9402917 	ldw	r5,164(sp)
811211d0:	2d801a16 	blt	r5,r22,8112123c <___vfprintf_internal_r+0x1df0>
811211d4:	dd803215 	stw	r22,200(sp)
811211d8:	003e8906 	br	81120c00 <__reset+0xfb100c00>
811211dc:	01204574 	movhi	r4,33045
811211e0:	21298e84 	addi	r4,r4,-22982
811211e4:	d9002b15 	stw	r4,172(sp)
811211e8:	003c9106 	br	81120430 <__reset+0xfb100430>
811211ec:	e005883a 	mov	r2,fp
811211f0:	003e7906 	br	81120bd8 <__reset+0xfb100bd8>
811211f4:	d9402917 	ldw	r5,164(sp)
811211f8:	df002783 	ldbu	fp,158(sp)
811211fc:	dcc02d15 	stw	r19,180(sp)
81121200:	d9402a15 	stw	r5,168(sp)
81121204:	d9402e15 	stw	r5,184(sp)
81121208:	d8002915 	stw	zero,164(sp)
8112120c:	d8003215 	stw	zero,200(sp)
81121210:	003a5d06 	br	8111fb88 <__reset+0xfb0ffb88>
81121214:	9080004c 	andi	r2,r18,1
81121218:	0039883a 	mov	fp,zero
8112121c:	10000426 	beq	r2,zero,81121230 <___vfprintf_internal_r+0x1de4>
81121220:	00800c04 	movi	r2,48
81121224:	dc001dc4 	addi	r16,sp,119
81121228:	d8801dc5 	stb	r2,119(sp)
8112122c:	003b8006 	br	81120030 <__reset+0xfb100030>
81121230:	d8002e15 	stw	zero,184(sp)
81121234:	dc001e04 	addi	r16,sp,120
81121238:	003a4d06 	br	8111fb70 <__reset+0xfb0ffb70>
8112123c:	8c7fff84 	addi	r17,r17,-2
81121240:	b5bfffc4 	addi	r22,r22,-1
81121244:	dd802615 	stw	r22,152(sp)
81121248:	dc4022c5 	stb	r17,139(sp)
8112124c:	b000bf16 	blt	r22,zero,8112154c <___vfprintf_internal_r+0x2100>
81121250:	00800ac4 	movi	r2,43
81121254:	d8802305 	stb	r2,140(sp)
81121258:	00800244 	movi	r2,9
8112125c:	15807016 	blt	r2,r22,81121420 <___vfprintf_internal_r+0x1fd4>
81121260:	00800c04 	movi	r2,48
81121264:	b5800c04 	addi	r22,r22,48
81121268:	d8802345 	stb	r2,141(sp)
8112126c:	dd802385 	stb	r22,142(sp)
81121270:	d88023c4 	addi	r2,sp,143
81121274:	df0022c4 	addi	fp,sp,139
81121278:	d8c03317 	ldw	r3,204(sp)
8112127c:	1739c83a 	sub	fp,r2,fp
81121280:	d9003317 	ldw	r4,204(sp)
81121284:	e0c7883a 	add	r3,fp,r3
81121288:	df003a15 	stw	fp,232(sp)
8112128c:	d8c02e15 	stw	r3,184(sp)
81121290:	00800044 	movi	r2,1
81121294:	1100b30e 	bge	r2,r4,81121564 <___vfprintf_internal_r+0x2118>
81121298:	d8c02e17 	ldw	r3,184(sp)
8112129c:	18c00044 	addi	r3,r3,1
811212a0:	d8c02e15 	stw	r3,184(sp)
811212a4:	1805883a 	mov	r2,r3
811212a8:	1800ac16 	blt	r3,zero,8112155c <___vfprintf_internal_r+0x2110>
811212ac:	d8003215 	stw	zero,200(sp)
811212b0:	003e5d06 	br	81120c28 <__reset+0xfb100c28>
811212b4:	d9002c17 	ldw	r4,176(sp)
811212b8:	d9801e04 	addi	r6,sp,120
811212bc:	b80b883a 	mov	r5,r23
811212c0:	112b63c0 	call	8112b63c <__sprint_r>
811212c4:	1039651e 	bne	r2,zero,8111f85c <__reset+0xfb0ff85c>
811212c8:	dc402617 	ldw	r17,152(sp)
811212cc:	d8c02017 	ldw	r3,128(sp)
811212d0:	d8801f17 	ldw	r2,124(sp)
811212d4:	da000404 	addi	r8,sp,16
811212d8:	003ed606 	br	81120e34 <__reset+0xfb100e34>
811212dc:	582b883a 	mov	r21,r11
811212e0:	d8002915 	stw	zero,164(sp)
811212e4:	0038bd06 	br	8111f5dc <__reset+0xfb0ff5dc>
811212e8:	d8802917 	ldw	r2,164(sp)
811212ec:	103e071e 	bne	r2,zero,81120b0c <__reset+0xfb100b0c>
811212f0:	dc002915 	stw	r16,164(sp)
811212f4:	003e0506 	br	81120b0c <__reset+0xfb100b0c>
811212f8:	d9002917 	ldw	r4,164(sp)
811212fc:	20c00044 	addi	r3,r4,1
81121300:	003e0f06 	br	81120b40 <__reset+0xfb100b40>
81121304:	01400184 	movi	r5,6
81121308:	d9402915 	stw	r5,164(sp)
8112130c:	003dff06 	br	81120b0c <__reset+0xfb100b0c>
81121310:	d8802104 	addi	r2,sp,132
81121314:	d8800315 	stw	r2,12(sp)
81121318:	d8802504 	addi	r2,sp,148
8112131c:	d8800215 	stw	r2,8(sp)
81121320:	d8802604 	addi	r2,sp,152
81121324:	d8800115 	stw	r2,4(sp)
81121328:	d8802917 	ldw	r2,164(sp)
8112132c:	d9403617 	ldw	r5,216(sp)
81121330:	d9002c17 	ldw	r4,176(sp)
81121334:	d8800015 	stw	r2,0(sp)
81121338:	01c000c4 	movi	r7,3
8112133c:	980d883a 	mov	r6,r19
81121340:	da003d15 	stw	r8,244(sp)
81121344:	11235580 	call	81123558 <_dtoa_r>
81121348:	d8c02917 	ldw	r3,164(sp)
8112134c:	da003d17 	ldw	r8,244(sp)
81121350:	1021883a 	mov	r16,r2
81121354:	10f9883a 	add	fp,r2,r3
81121358:	81000007 	ldb	r4,0(r16)
8112135c:	00800c04 	movi	r2,48
81121360:	20805e26 	beq	r4,r2,811214dc <___vfprintf_internal_r+0x2090>
81121364:	d8c02617 	ldw	r3,152(sp)
81121368:	e0f9883a 	add	fp,fp,r3
8112136c:	003e0a06 	br	81120b98 <__reset+0xfb100b98>
81121370:	00c00b44 	movi	r3,45
81121374:	24e0003c 	xorhi	r19,r4,32768
81121378:	d8c02a05 	stb	r3,168(sp)
8112137c:	003de906 	br	81120b24 <__reset+0xfb100b24>
81121380:	d8c03217 	ldw	r3,200(sp)
81121384:	00c07a0e 	bge	zero,r3,81121570 <___vfprintf_internal_r+0x2124>
81121388:	00800044 	movi	r2,1
8112138c:	d9003317 	ldw	r4,204(sp)
81121390:	1105883a 	add	r2,r2,r4
81121394:	d8802e15 	stw	r2,184(sp)
81121398:	10004e16 	blt	r2,zero,811214d4 <___vfprintf_internal_r+0x2088>
8112139c:	044019c4 	movi	r17,103
811213a0:	003e2106 	br	81120c28 <__reset+0xfb100c28>
811213a4:	d9002917 	ldw	r4,164(sp)
811213a8:	d8802104 	addi	r2,sp,132
811213ac:	d8800315 	stw	r2,12(sp)
811213b0:	d9000015 	stw	r4,0(sp)
811213b4:	d8802504 	addi	r2,sp,148
811213b8:	d9403617 	ldw	r5,216(sp)
811213bc:	d9002c17 	ldw	r4,176(sp)
811213c0:	d8800215 	stw	r2,8(sp)
811213c4:	d8802604 	addi	r2,sp,152
811213c8:	d8800115 	stw	r2,4(sp)
811213cc:	01c000c4 	movi	r7,3
811213d0:	980d883a 	mov	r6,r19
811213d4:	da003d15 	stw	r8,244(sp)
811213d8:	11235580 	call	81123558 <_dtoa_r>
811213dc:	d8c02917 	ldw	r3,164(sp)
811213e0:	da003d17 	ldw	r8,244(sp)
811213e4:	1021883a 	mov	r16,r2
811213e8:	00801184 	movi	r2,70
811213ec:	80f9883a 	add	fp,r16,r3
811213f0:	88bfd926 	beq	r17,r2,81121358 <__reset+0xfb101358>
811213f4:	003de806 	br	81120b98 <__reset+0xfb100b98>
811213f8:	d9002917 	ldw	r4,164(sp)
811213fc:	00c04d0e 	bge	zero,r3,81121534 <___vfprintf_internal_r+0x20e8>
81121400:	2000441e 	bne	r4,zero,81121514 <___vfprintf_internal_r+0x20c8>
81121404:	9480004c 	andi	r18,r18,1
81121408:	9000421e 	bne	r18,zero,81121514 <___vfprintf_internal_r+0x20c8>
8112140c:	1805883a 	mov	r2,r3
81121410:	18007016 	blt	r3,zero,811215d4 <___vfprintf_internal_r+0x2188>
81121414:	d8c03217 	ldw	r3,200(sp)
81121418:	d8c02e15 	stw	r3,184(sp)
8112141c:	003e0206 	br	81120c28 <__reset+0xfb100c28>
81121420:	df0022c4 	addi	fp,sp,139
81121424:	dc002915 	stw	r16,164(sp)
81121428:	4027883a 	mov	r19,r8
8112142c:	e021883a 	mov	r16,fp
81121430:	b009883a 	mov	r4,r22
81121434:	01400284 	movi	r5,10
81121438:	112e9b40 	call	8112e9b4 <__modsi3>
8112143c:	10800c04 	addi	r2,r2,48
81121440:	843fffc4 	addi	r16,r16,-1
81121444:	b009883a 	mov	r4,r22
81121448:	01400284 	movi	r5,10
8112144c:	80800005 	stb	r2,0(r16)
81121450:	112e9300 	call	8112e930 <__divsi3>
81121454:	102d883a 	mov	r22,r2
81121458:	00800244 	movi	r2,9
8112145c:	15bff416 	blt	r2,r22,81121430 <__reset+0xfb101430>
81121460:	9811883a 	mov	r8,r19
81121464:	b0800c04 	addi	r2,r22,48
81121468:	8027883a 	mov	r19,r16
8112146c:	997fffc4 	addi	r5,r19,-1
81121470:	98bfffc5 	stb	r2,-1(r19)
81121474:	dc002917 	ldw	r16,164(sp)
81121478:	2f006a2e 	bgeu	r5,fp,81121624 <___vfprintf_internal_r+0x21d8>
8112147c:	d9c02384 	addi	r7,sp,142
81121480:	3ccfc83a 	sub	r7,r7,r19
81121484:	d9002344 	addi	r4,sp,141
81121488:	e1cf883a 	add	r7,fp,r7
8112148c:	00000106 	br	81121494 <___vfprintf_internal_r+0x2048>
81121490:	28800003 	ldbu	r2,0(r5)
81121494:	20800005 	stb	r2,0(r4)
81121498:	21000044 	addi	r4,r4,1
8112149c:	29400044 	addi	r5,r5,1
811214a0:	393ffb1e 	bne	r7,r4,81121490 <__reset+0xfb101490>
811214a4:	d8802304 	addi	r2,sp,140
811214a8:	14c5c83a 	sub	r2,r2,r19
811214ac:	d8c02344 	addi	r3,sp,141
811214b0:	1885883a 	add	r2,r3,r2
811214b4:	003f7006 	br	81121278 <__reset+0xfb101278>
811214b8:	0005883a 	mov	r2,zero
811214bc:	003f0f06 	br	811210fc <__reset+0xfb1010fc>
811214c0:	d8c03217 	ldw	r3,200(sp)
811214c4:	18c00044 	addi	r3,r3,1
811214c8:	d8c02e15 	stw	r3,184(sp)
811214cc:	1805883a 	mov	r2,r3
811214d0:	183fb20e 	bge	r3,zero,8112139c <__reset+0xfb10139c>
811214d4:	0005883a 	mov	r2,zero
811214d8:	003fb006 	br	8112139c <__reset+0xfb10139c>
811214dc:	d9003617 	ldw	r4,216(sp)
811214e0:	000d883a 	mov	r6,zero
811214e4:	000f883a 	mov	r7,zero
811214e8:	980b883a 	mov	r5,r19
811214ec:	d8c03c15 	stw	r3,240(sp)
811214f0:	da003d15 	stw	r8,244(sp)
811214f4:	112fe840 	call	8112fe84 <__eqdf2>
811214f8:	d8c03c17 	ldw	r3,240(sp)
811214fc:	da003d17 	ldw	r8,244(sp)
81121500:	103f9826 	beq	r2,zero,81121364 <__reset+0xfb101364>
81121504:	00800044 	movi	r2,1
81121508:	10c7c83a 	sub	r3,r2,r3
8112150c:	d8c02615 	stw	r3,152(sp)
81121510:	003f9506 	br	81121368 <__reset+0xfb101368>
81121514:	d9002917 	ldw	r4,164(sp)
81121518:	d8c03217 	ldw	r3,200(sp)
8112151c:	20800044 	addi	r2,r4,1
81121520:	1885883a 	add	r2,r3,r2
81121524:	d8802e15 	stw	r2,184(sp)
81121528:	103dbf0e 	bge	r2,zero,81120c28 <__reset+0xfb100c28>
8112152c:	0005883a 	mov	r2,zero
81121530:	003dbd06 	br	81120c28 <__reset+0xfb100c28>
81121534:	2000211e 	bne	r4,zero,811215bc <___vfprintf_internal_r+0x2170>
81121538:	9480004c 	andi	r18,r18,1
8112153c:	90001f1e 	bne	r18,zero,811215bc <___vfprintf_internal_r+0x2170>
81121540:	00800044 	movi	r2,1
81121544:	d8802e15 	stw	r2,184(sp)
81121548:	003db706 	br	81120c28 <__reset+0xfb100c28>
8112154c:	00800b44 	movi	r2,45
81121550:	05adc83a 	sub	r22,zero,r22
81121554:	d8802305 	stb	r2,140(sp)
81121558:	003f3f06 	br	81121258 <__reset+0xfb101258>
8112155c:	0005883a 	mov	r2,zero
81121560:	003f5206 	br	811212ac <__reset+0xfb1012ac>
81121564:	90a4703a 	and	r18,r18,r2
81121568:	903f4e26 	beq	r18,zero,811212a4 <__reset+0xfb1012a4>
8112156c:	003f4a06 	br	81121298 <__reset+0xfb101298>
81121570:	00800084 	movi	r2,2
81121574:	10c5c83a 	sub	r2,r2,r3
81121578:	003f8406 	br	8112138c <__reset+0xfb10138c>
8112157c:	d8802d17 	ldw	r2,180(sp)
81121580:	d9002d17 	ldw	r4,180(sp)
81121584:	ac400043 	ldbu	r17,1(r21)
81121588:	10800017 	ldw	r2,0(r2)
8112158c:	582b883a 	mov	r21,r11
81121590:	d8802915 	stw	r2,164(sp)
81121594:	20800104 	addi	r2,r4,4
81121598:	d9002917 	ldw	r4,164(sp)
8112159c:	d8802d15 	stw	r2,180(sp)
811215a0:	203e7a0e 	bge	r4,zero,81120f8c <__reset+0xfb100f8c>
811215a4:	8c403fcc 	andi	r17,r17,255
811215a8:	00bfffc4 	movi	r2,-1
811215ac:	8c40201c 	xori	r17,r17,128
811215b0:	d8802915 	stw	r2,164(sp)
811215b4:	8c7fe004 	addi	r17,r17,-128
811215b8:	00380706 	br	8111f5d8 <__reset+0xfb0ff5d8>
811215bc:	d8c02917 	ldw	r3,164(sp)
811215c0:	18c00084 	addi	r3,r3,2
811215c4:	d8c02e15 	stw	r3,184(sp)
811215c8:	1805883a 	mov	r2,r3
811215cc:	183d960e 	bge	r3,zero,81120c28 <__reset+0xfb100c28>
811215d0:	003fd606 	br	8112152c <__reset+0xfb10152c>
811215d4:	0005883a 	mov	r2,zero
811215d8:	003f8e06 	br	81121414 <__reset+0xfb101414>
811215dc:	9080004c 	andi	r2,r18,1
811215e0:	103f811e 	bne	r2,zero,811213e8 <__reset+0xfb1013e8>
811215e4:	d8802117 	ldw	r2,132(sp)
811215e8:	1405c83a 	sub	r2,r2,r16
811215ec:	d8803315 	stw	r2,204(sp)
811215f0:	b47ef326 	beq	r22,r17,811211c0 <__reset+0xfb1011c0>
811215f4:	dd802617 	ldw	r22,152(sp)
811215f8:	003f1106 	br	81121240 <__reset+0xfb101240>
811215fc:	d9c02785 	stb	r7,158(sp)
81121600:	00390406 	br	8111fa14 <__reset+0xfb0ffa14>
81121604:	d9c02785 	stb	r7,158(sp)
81121608:	0038d306 	br	8111f958 <__reset+0xfb0ff958>
8112160c:	d9c02785 	stb	r7,158(sp)
81121610:	003a6106 	br	8111ff98 <__reset+0xfb0fff98>
81121614:	d9c02785 	stb	r7,158(sp)
81121618:	003af806 	br	811201fc <__reset+0xfb1001fc>
8112161c:	0005883a 	mov	r2,zero
81121620:	003d7e06 	br	81120c1c <__reset+0xfb100c1c>
81121624:	d8802344 	addi	r2,sp,141
81121628:	003f1306 	br	81121278 <__reset+0xfb101278>
8112162c:	d9c02785 	stb	r7,158(sp)
81121630:	00392306 	br	8111fac0 <__reset+0xfb0ffac0>
81121634:	d9c02785 	stb	r7,158(sp)
81121638:	003aa906 	br	811200e0 <__reset+0xfb1000e0>
8112163c:	d9c02785 	stb	r7,158(sp)
81121640:	003a3d06 	br	8111ff38 <__reset+0xfb0fff38>
81121644:	d9c02785 	stb	r7,158(sp)
81121648:	003aca06 	br	81120174 <__reset+0xfb100174>

8112164c <__vfprintf_internal>:
8112164c:	00a04574 	movhi	r2,33045
81121650:	10b34e04 	addi	r2,r2,-13000
81121654:	300f883a 	mov	r7,r6
81121658:	280d883a 	mov	r6,r5
8112165c:	200b883a 	mov	r5,r4
81121660:	11000017 	ldw	r4,0(r2)
81121664:	111f44c1 	jmpi	8111f44c <___vfprintf_internal_r>

81121668 <__sbprintf>:
81121668:	defee204 	addi	sp,sp,-1144
8112166c:	de00012e 	bgeu	sp,et,81121674 <__sbprintf+0xc>
81121670:	003b68fa 	trap	3
81121674:	2880030b 	ldhu	r2,12(r5)
81121678:	2ac01917 	ldw	r11,100(r5)
8112167c:	2a80038b 	ldhu	r10,14(r5)
81121680:	2a400717 	ldw	r9,28(r5)
81121684:	2a000917 	ldw	r8,36(r5)
81121688:	00c10004 	movi	r3,1024
8112168c:	dc011a15 	stw	r16,1128(sp)
81121690:	10bfff4c 	andi	r2,r2,65533
81121694:	2821883a 	mov	r16,r5
81121698:	d8cb883a 	add	r5,sp,r3
8112169c:	dc811c15 	stw	r18,1136(sp)
811216a0:	dc411b15 	stw	r17,1132(sp)
811216a4:	dfc11d15 	stw	ra,1140(sp)
811216a8:	2025883a 	mov	r18,r4
811216ac:	d881030d 	sth	r2,1036(sp)
811216b0:	dac11915 	stw	r11,1124(sp)
811216b4:	da81038d 	sth	r10,1038(sp)
811216b8:	da410715 	stw	r9,1052(sp)
811216bc:	da010915 	stw	r8,1060(sp)
811216c0:	dec10015 	stw	sp,1024(sp)
811216c4:	dec10415 	stw	sp,1040(sp)
811216c8:	d8c10215 	stw	r3,1032(sp)
811216cc:	d8c10515 	stw	r3,1044(sp)
811216d0:	d8010615 	stw	zero,1048(sp)
811216d4:	111f44c0 	call	8111f44c <___vfprintf_internal_r>
811216d8:	1023883a 	mov	r17,r2
811216dc:	10000416 	blt	r2,zero,811216f0 <__sbprintf+0x88>
811216e0:	d9410004 	addi	r5,sp,1024
811216e4:	9009883a 	mov	r4,r18
811216e8:	1124e0c0 	call	81124e0c <_fflush_r>
811216ec:	10000d1e 	bne	r2,zero,81121724 <__sbprintf+0xbc>
811216f0:	d881030b 	ldhu	r2,1036(sp)
811216f4:	1080100c 	andi	r2,r2,64
811216f8:	10000326 	beq	r2,zero,81121708 <__sbprintf+0xa0>
811216fc:	8080030b 	ldhu	r2,12(r16)
81121700:	10801014 	ori	r2,r2,64
81121704:	8080030d 	sth	r2,12(r16)
81121708:	8805883a 	mov	r2,r17
8112170c:	dfc11d17 	ldw	ra,1140(sp)
81121710:	dc811c17 	ldw	r18,1136(sp)
81121714:	dc411b17 	ldw	r17,1132(sp)
81121718:	dc011a17 	ldw	r16,1128(sp)
8112171c:	dec11e04 	addi	sp,sp,1144
81121720:	f800283a 	ret
81121724:	047fffc4 	movi	r17,-1
81121728:	003ff106 	br	811216f0 <__reset+0xfb1016f0>

8112172c <__svfscanf_r>:
8112172c:	deff4b04 	addi	sp,sp,-724
81121730:	de00012e 	bgeu	sp,et,81121738 <__svfscanf_r+0xc>
81121734:	003b68fa 	trap	3
81121738:	2880030b 	ldhu	r2,12(r5)
8112173c:	df00b315 	stw	fp,716(sp)
81121740:	dd80b115 	stw	r22,708(sp)
81121744:	dfc0b415 	stw	ra,720(sp)
81121748:	ddc0b215 	stw	r23,712(sp)
8112174c:	dd40b015 	stw	r21,704(sp)
81121750:	dd00af15 	stw	r20,700(sp)
81121754:	dcc0ae15 	stw	r19,696(sp)
81121758:	dc80ad15 	stw	r18,692(sp)
8112175c:	dc40ac15 	stw	r17,688(sp)
81121760:	dc00ab15 	stw	r16,684(sp)
81121764:	10c8000c 	andi	r3,r2,8192
81121768:	d9c09c15 	stw	r7,624(sp)
8112176c:	2839883a 	mov	fp,r5
81121770:	202d883a 	mov	r22,r4
81121774:	1800061e 	bne	r3,zero,81121790 <__svfscanf_r+0x64>
81121778:	29001917 	ldw	r4,100(r5)
8112177c:	00f7ffc4 	movi	r3,-8193
81121780:	10880014 	ori	r2,r2,8192
81121784:	20c6703a 	and	r3,r4,r3
81121788:	2880030d 	sth	r2,12(r5)
8112178c:	28c01915 	stw	r3,100(r5)
81121790:	30800003 	ldbu	r2,0(r6)
81121794:	0021883a 	mov	r16,zero
81121798:	05e04574 	movhi	r23,33045
8112179c:	d800a115 	stw	zero,644(sp)
811217a0:	d8009e15 	stw	zero,632(sp)
811217a4:	d800a015 	stw	zero,640(sp)
811217a8:	d8809b15 	stw	r2,620(sp)
811217ac:	bdf34c04 	addi	r23,r23,-13008
811217b0:	8025883a 	mov	r18,r16
811217b4:	35000044 	addi	r20,r6,1
811217b8:	10001e26 	beq	r2,zero,81121834 <__svfscanf_r+0x108>
811217bc:	b9c00017 	ldw	r7,0(r23)
811217c0:	3887883a 	add	r3,r7,r2
811217c4:	18c00043 	ldbu	r3,1(r3)
811217c8:	18c0020c 	andi	r3,r3,8
811217cc:	18001b26 	beq	r3,zero,8112183c <__svfscanf_r+0x110>
811217d0:	e0800117 	ldw	r2,4(fp)
811217d4:	00800e0e 	bge	zero,r2,81121810 <__svfscanf_r+0xe4>
811217d8:	e0c00017 	ldw	r3,0(fp)
811217dc:	b9000017 	ldw	r4,0(r23)
811217e0:	18800003 	ldbu	r2,0(r3)
811217e4:	2085883a 	add	r2,r4,r2
811217e8:	10800043 	ldbu	r2,1(r2)
811217ec:	1080020c 	andi	r2,r2,8
811217f0:	10000b26 	beq	r2,zero,81121820 <__svfscanf_r+0xf4>
811217f4:	e0800117 	ldw	r2,4(fp)
811217f8:	18c00044 	addi	r3,r3,1
811217fc:	e0c00015 	stw	r3,0(fp)
81121800:	10bfffc4 	addi	r2,r2,-1
81121804:	e0800115 	stw	r2,4(fp)
81121808:	94800044 	addi	r18,r18,1
8112180c:	00bff216 	blt	zero,r2,811217d8 <__reset+0xfb1017d8>
81121810:	e00b883a 	mov	r5,fp
81121814:	b009883a 	mov	r4,r22
81121818:	111ca0c0 	call	8111ca0c <__srefill_r>
8112181c:	103fee26 	beq	r2,zero,811217d8 <__reset+0xfb1017d8>
81121820:	a00d883a 	mov	r6,r20
81121824:	30800003 	ldbu	r2,0(r6)
81121828:	35000044 	addi	r20,r6,1
8112182c:	d8809b15 	stw	r2,620(sp)
81121830:	103fe21e 	bne	r2,zero,811217bc <__reset+0xfb1017bc>
81121834:	d880a017 	ldw	r2,640(sp)
81121838:	00009906 	br	81121aa0 <__svfscanf_r+0x374>
8112183c:	00c00944 	movi	r3,37
81121840:	10c0881e 	bne	r2,r3,81121a64 <__svfscanf_r+0x338>
81121844:	30c00043 	ldbu	r3,1(r6)
81121848:	0023883a 	mov	r17,zero
8112184c:	0027883a 	mov	r19,zero
81121850:	01001e04 	movi	r4,120
81121854:	01401b04 	movi	r5,108
81121858:	a1800044 	addi	r6,r20,1
8112185c:	20c0a236 	bltu	r4,r3,81121ae8 <__svfscanf_r+0x3bc>
81121860:	180490ba 	slli	r2,r3,2
81121864:	022044b4 	movhi	r8,33042
81121868:	42061e04 	addi	r8,r8,6264
8112186c:	1205883a 	add	r2,r2,r8
81121870:	10800017 	ldw	r2,0(r2)
81121874:	1000683a 	jmp	r2
81121878:	81121a9c 	xori	r4,r16,18538
8112187c:	81121ae8 	cmpgeui	r4,r16,18539
81121880:	81121ae8 	cmpgeui	r4,r16,18539
81121884:	81121ae8 	cmpgeui	r4,r16,18539
81121888:	81121ae8 	cmpgeui	r4,r16,18539
8112188c:	81121ae8 	cmpgeui	r4,r16,18539
81121890:	81121ae8 	cmpgeui	r4,r16,18539
81121894:	81121ae8 	cmpgeui	r4,r16,18539
81121898:	81121ae8 	cmpgeui	r4,r16,18539
8112189c:	81121ae8 	cmpgeui	r4,r16,18539
811218a0:	81121ae8 	cmpgeui	r4,r16,18539
811218a4:	81121ae8 	cmpgeui	r4,r16,18539
811218a8:	81121ae8 	cmpgeui	r4,r16,18539
811218ac:	81121ae8 	cmpgeui	r4,r16,18539
811218b0:	81121ae8 	cmpgeui	r4,r16,18539
811218b4:	81121ae8 	cmpgeui	r4,r16,18539
811218b8:	81121ae8 	cmpgeui	r4,r16,18539
811218bc:	81121ae8 	cmpgeui	r4,r16,18539
811218c0:	81121ae8 	cmpgeui	r4,r16,18539
811218c4:	81121ae8 	cmpgeui	r4,r16,18539
811218c8:	81121ae8 	cmpgeui	r4,r16,18539
811218cc:	81121ae8 	cmpgeui	r4,r16,18539
811218d0:	81121ae8 	cmpgeui	r4,r16,18539
811218d4:	81121ae8 	cmpgeui	r4,r16,18539
811218d8:	81121ae8 	cmpgeui	r4,r16,18539
811218dc:	81121ae8 	cmpgeui	r4,r16,18539
811218e0:	81121ae8 	cmpgeui	r4,r16,18539
811218e4:	81121ae8 	cmpgeui	r4,r16,18539
811218e8:	81121ae8 	cmpgeui	r4,r16,18539
811218ec:	81121ae8 	cmpgeui	r4,r16,18539
811218f0:	81121ae8 	cmpgeui	r4,r16,18539
811218f4:	81121ae8 	cmpgeui	r4,r16,18539
811218f8:	81121ae8 	cmpgeui	r4,r16,18539
811218fc:	81121ae8 	cmpgeui	r4,r16,18539
81121900:	81121ae8 	cmpgeui	r4,r16,18539
81121904:	81121ae8 	cmpgeui	r4,r16,18539
81121908:	81121ae8 	cmpgeui	r4,r16,18539
8112190c:	81121a5c 	xori	r4,r16,18537
81121910:	81121ae8 	cmpgeui	r4,r16,18539
81121914:	81121ae8 	cmpgeui	r4,r16,18539
81121918:	81121ae8 	cmpgeui	r4,r16,18539
8112191c:	81121ae8 	cmpgeui	r4,r16,18539
81121920:	81121ad0 	cmplti	r4,r16,18539
81121924:	81121ae8 	cmpgeui	r4,r16,18539
81121928:	81121ae8 	cmpgeui	r4,r16,18539
8112192c:	81121ae8 	cmpgeui	r4,r16,18539
81121930:	81121ae8 	cmpgeui	r4,r16,18539
81121934:	81121ae8 	cmpgeui	r4,r16,18539
81121938:	81121c04 	addi	r4,r16,18544
8112193c:	81121c04 	addi	r4,r16,18544
81121940:	81121c04 	addi	r4,r16,18544
81121944:	81121c04 	addi	r4,r16,18544
81121948:	81121c04 	addi	r4,r16,18544
8112194c:	81121c04 	addi	r4,r16,18544
81121950:	81121c04 	addi	r4,r16,18544
81121954:	81121c04 	addi	r4,r16,18544
81121958:	81121c04 	addi	r4,r16,18544
8112195c:	81121c04 	addi	r4,r16,18544
81121960:	81121ae8 	cmpgeui	r4,r16,18539
81121964:	81121ae8 	cmpgeui	r4,r16,18539
81121968:	81121ae8 	cmpgeui	r4,r16,18539
8112196c:	81121ae8 	cmpgeui	r4,r16,18539
81121970:	81121ae8 	cmpgeui	r4,r16,18539
81121974:	81121ae8 	cmpgeui	r4,r16,18539
81121978:	81121ae8 	cmpgeui	r4,r16,18539
8112197c:	81121ae8 	cmpgeui	r4,r16,18539
81121980:	81121ae8 	cmpgeui	r4,r16,18539
81121984:	81121ae8 	cmpgeui	r4,r16,18539
81121988:	81121bd8 	cmpnei	r4,r16,18543
8112198c:	81121c88 	cmpgei	r4,r16,18546
81121990:	81121ae8 	cmpgeui	r4,r16,18539
81121994:	81121c88 	cmpgei	r4,r16,18546
81121998:	81121ae8 	cmpgeui	r4,r16,18539
8112199c:	81121ae8 	cmpgeui	r4,r16,18539
811219a0:	81121ae8 	cmpgeui	r4,r16,18539
811219a4:	81121ae8 	cmpgeui	r4,r16,18539
811219a8:	81121c74 	orhi	r4,r16,18545
811219ac:	81121ae8 	cmpgeui	r4,r16,18539
811219b0:	81121ae8 	cmpgeui	r4,r16,18539
811219b4:	81121c48 	cmpgei	r4,r16,18545
811219b8:	81121ae8 	cmpgeui	r4,r16,18539
811219bc:	81121ae8 	cmpgeui	r4,r16,18539
811219c0:	81121ae8 	cmpgeui	r4,r16,18539
811219c4:	81121ae8 	cmpgeui	r4,r16,18539
811219c8:	81121ae8 	cmpgeui	r4,r16,18539
811219cc:	81121ae8 	cmpgeui	r4,r16,18539
811219d0:	81121ae8 	cmpgeui	r4,r16,18539
811219d4:	81121ae8 	cmpgeui	r4,r16,18539
811219d8:	81121c20 	cmpeqi	r4,r16,18544
811219dc:	81121ae8 	cmpgeui	r4,r16,18539
811219e0:	81121ae8 	cmpgeui	r4,r16,18539
811219e4:	81121dbc 	xorhi	r4,r16,18550
811219e8:	81121ae8 	cmpgeui	r4,r16,18539
811219ec:	81121ae8 	cmpgeui	r4,r16,18539
811219f0:	81121ae8 	cmpgeui	r4,r16,18539
811219f4:	81121ae8 	cmpgeui	r4,r16,18539
811219f8:	81121ae8 	cmpgeui	r4,r16,18539
811219fc:	81121ae8 	cmpgeui	r4,r16,18539
81121a00:	81121ae8 	cmpgeui	r4,r16,18539
81121a04:	81121d40 	call	881121d4 <__reset+0x20f21d4>
81121a08:	81121d18 	cmpnei	r4,r16,18548
81121a0c:	81121c88 	cmpgei	r4,r16,18546
81121a10:	81121c88 	cmpgei	r4,r16,18546
81121a14:	81121c88 	cmpgei	r4,r16,18546
81121a18:	81121d04 	addi	r4,r16,18548
81121a1c:	81121e48 	cmpgei	r4,r16,18553
81121a20:	81121ae8 	cmpgeui	r4,r16,18539
81121a24:	81121ae8 	cmpgeui	r4,r16,18539
81121a28:	81121cf0 	cmpltui	r4,r16,18547
81121a2c:	81121ae8 	cmpgeui	r4,r16,18539
81121a30:	81121cc0 	call	881121cc <__reset+0x20f21cc>
81121a34:	81121c9c 	xori	r4,r16,18546
81121a38:	81121bac 	andhi	r4,r16,18542
81121a3c:	81121ae8 	cmpgeui	r4,r16,18539
81121a40:	81121ae8 	cmpgeui	r4,r16,18539
81121a44:	81121b98 	cmpnei	r4,r16,18542
81121a48:	81121ae8 	cmpgeui	r4,r16,18539
81121a4c:	81121b20 	cmpeqi	r4,r16,18540
81121a50:	81121ae8 	cmpgeui	r4,r16,18539
81121a54:	81121ae8 	cmpgeui	r4,r16,18539
81121a58:	81121c20 	cmpeqi	r4,r16,18544
81121a5c:	d9809d15 	stw	r6,628(sp)
81121a60:	3029883a 	mov	r20,r6
81121a64:	e0800117 	ldw	r2,4(fp)
81121a68:	0081aa0e 	bge	zero,r2,81122114 <__svfscanf_r+0x9e8>
81121a6c:	e0800017 	ldw	r2,0(fp)
81121a70:	a0ffffc3 	ldbu	r3,-1(r20)
81121a74:	11000003 	ldbu	r4,0(r2)
81121a78:	20ff6e1e 	bne	r4,r3,81121834 <__reset+0xfb101834>
81121a7c:	e0c00117 	ldw	r3,4(fp)
81121a80:	10800044 	addi	r2,r2,1
81121a84:	e0800015 	stw	r2,0(fp)
81121a88:	18bfffc4 	addi	r2,r3,-1
81121a8c:	e0800115 	stw	r2,4(fp)
81121a90:	94800044 	addi	r18,r18,1
81121a94:	a00d883a 	mov	r6,r20
81121a98:	003f6206 	br	81121824 <__reset+0xfb101824>
81121a9c:	00bfffc4 	movi	r2,-1
81121aa0:	dfc0b417 	ldw	ra,720(sp)
81121aa4:	df00b317 	ldw	fp,716(sp)
81121aa8:	ddc0b217 	ldw	r23,712(sp)
81121aac:	dd80b117 	ldw	r22,708(sp)
81121ab0:	dd40b017 	ldw	r21,704(sp)
81121ab4:	dd00af17 	ldw	r20,700(sp)
81121ab8:	dcc0ae17 	ldw	r19,696(sp)
81121abc:	dc80ad17 	ldw	r18,692(sp)
81121ac0:	dc40ac17 	ldw	r17,688(sp)
81121ac4:	dc00ab17 	ldw	r16,684(sp)
81121ac8:	dec0b504 	addi	sp,sp,724
81121acc:	f800283a 	ret
81121ad0:	a0800043 	ldbu	r2,1(r20)
81121ad4:	3029883a 	mov	r20,r6
81121ad8:	8c400414 	ori	r17,r17,16
81121adc:	10c03fcc 	andi	r3,r2,255
81121ae0:	a1800044 	addi	r6,r20,1
81121ae4:	20ff5e2e 	bgeu	r4,r3,81121860 <__reset+0xfb101860>
81121ae8:	38c7883a 	add	r3,r7,r3
81121aec:	18800043 	ldbu	r2,1(r3)
81121af0:	d9809d15 	stw	r6,628(sp)
81121af4:	00c00044 	movi	r3,1
81121af8:	108000cc 	andi	r2,r2,3
81121afc:	10c18f26 	beq	r2,r3,8112213c <__svfscanf_r+0xa10>
81121b00:	e0800117 	ldw	r2,4(fp)
81121b04:	00808716 	blt	zero,r2,81121d24 <__svfscanf_r+0x5f8>
81121b08:	e00b883a 	mov	r5,fp
81121b0c:	b009883a 	mov	r4,r22
81121b10:	111ca0c0 	call	8111ca0c <__srefill_r>
81121b14:	1001431e 	bne	r2,zero,81122024 <__svfscanf_r+0x8f8>
81121b18:	b9c00017 	ldw	r7,0(r23)
81121b1c:	00008106 	br	81121d24 <__svfscanf_r+0x5f8>
81121b20:	e0800117 	ldw	r2,4(fp)
81121b24:	d9809d15 	stw	r6,628(sp)
81121b28:	0081a30e 	bge	zero,r2,811221b8 <__svfscanf_r+0xa8c>
81121b2c:	00a044f4 	movhi	r2,33043
81121b30:	10a64f04 	addi	r2,r2,-26308
81121b34:	02000284 	movi	r8,10
81121b38:	d880a115 	stw	r2,644(sp)
81121b3c:	da009e15 	stw	r8,632(sp)
81121b40:	050000c4 	movi	r20,3
81121b44:	e0c00017 	ldw	r3,0(fp)
81121b48:	00000206 	br	81121b54 <__svfscanf_r+0x428>
81121b4c:	18c00044 	addi	r3,r3,1
81121b50:	e0c00015 	stw	r3,0(fp)
81121b54:	19000003 	ldbu	r4,0(r3)
81121b58:	20803fcc 	andi	r2,r4,255
81121b5c:	3885883a 	add	r2,r7,r2
81121b60:	10800043 	ldbu	r2,1(r2)
81121b64:	1140020c 	andi	r5,r2,8
81121b68:	2801ab26 	beq	r5,zero,81122218 <__svfscanf_r+0xaec>
81121b6c:	e0800117 	ldw	r2,4(fp)
81121b70:	94800044 	addi	r18,r18,1
81121b74:	10bfffc4 	addi	r2,r2,-1
81121b78:	e0800115 	stw	r2,4(fp)
81121b7c:	00bff316 	blt	zero,r2,81121b4c <__reset+0xfb101b4c>
81121b80:	e00b883a 	mov	r5,fp
81121b84:	b009883a 	mov	r4,r22
81121b88:	111ca0c0 	call	8111ca0c <__srefill_r>
81121b8c:	1001251e 	bne	r2,zero,81122024 <__svfscanf_r+0x8f8>
81121b90:	b9c00017 	ldw	r7,0(r23)
81121b94:	003feb06 	br	81121b44 <__reset+0xfb101b44>
81121b98:	e0800117 	ldw	r2,4(fp)
81121b9c:	d9809d15 	stw	r6,628(sp)
81121ba0:	00818b0e 	bge	zero,r2,811221d0 <__svfscanf_r+0xaa4>
81121ba4:	05000084 	movi	r20,2
81121ba8:	003fe606 	br	81121b44 <__reset+0xfb101b44>
81121bac:	e0800117 	ldw	r2,4(fp)
81121bb0:	d9809d15 	stw	r6,628(sp)
81121bb4:	8c408814 	ori	r17,r17,544
81121bb8:	00801d0e 	bge	zero,r2,81121c30 <__svfscanf_r+0x504>
81121bbc:	00a044f4 	movhi	r2,33043
81121bc0:	10a64f04 	addi	r2,r2,-26308
81121bc4:	02000404 	movi	r8,16
81121bc8:	d880a115 	stw	r2,644(sp)
81121bcc:	da009e15 	stw	r8,632(sp)
81121bd0:	050000c4 	movi	r20,3
81121bd4:	003fdb06 	br	81121b44 <__reset+0xfb101b44>
81121bd8:	e0800117 	ldw	r2,4(fp)
81121bdc:	d9809d15 	stw	r6,628(sp)
81121be0:	8c400054 	ori	r17,r17,1
81121be4:	00bfc80e 	bge	zero,r2,81121b08 <__reset+0xfb101b08>
81121be8:	00e044b4 	movhi	r3,33042
81121bec:	18f40404 	addi	r3,r3,-12272
81121bf0:	02000284 	movi	r8,10
81121bf4:	d8c0a115 	stw	r3,644(sp)
81121bf8:	da009e15 	stw	r8,632(sp)
81121bfc:	050000c4 	movi	r20,3
81121c00:	003fd006 	br	81121b44 <__reset+0xfb101b44>
81121c04:	9cc002a4 	muli	r19,r19,10
81121c08:	a0800043 	ldbu	r2,1(r20)
81121c0c:	3029883a 	mov	r20,r6
81121c10:	98e7883a 	add	r19,r19,r3
81121c14:	9cfff404 	addi	r19,r19,-48
81121c18:	10c03fcc 	andi	r3,r2,255
81121c1c:	003f0e06 	br	81121858 <__reset+0xfb101858>
81121c20:	e0800117 	ldw	r2,4(fp)
81121c24:	d9809d15 	stw	r6,628(sp)
81121c28:	8c408014 	ori	r17,r17,512
81121c2c:	00bfe316 	blt	zero,r2,81121bbc <__reset+0xfb101bbc>
81121c30:	e00b883a 	mov	r5,fp
81121c34:	b009883a 	mov	r4,r22
81121c38:	111ca0c0 	call	8111ca0c <__srefill_r>
81121c3c:	1000f91e 	bne	r2,zero,81122024 <__svfscanf_r+0x8f8>
81121c40:	b9c00017 	ldw	r7,0(r23)
81121c44:	003fdd06 	br	81121bbc <__reset+0xfb101bbc>
81121c48:	e0800117 	ldw	r2,4(fp)
81121c4c:	d9809d15 	stw	r6,628(sp)
81121c50:	8c400054 	ori	r17,r17,1
81121c54:	0080140e 	bge	zero,r2,81121ca8 <__svfscanf_r+0x57c>
81121c58:	00a044f4 	movhi	r2,33043
81121c5c:	10a64f04 	addi	r2,r2,-26308
81121c60:	02000204 	movi	r8,8
81121c64:	d880a115 	stw	r2,644(sp)
81121c68:	da009e15 	stw	r8,632(sp)
81121c6c:	050000c4 	movi	r20,3
81121c70:	003fb406 	br	81121b44 <__reset+0xfb101b44>
81121c74:	a0800043 	ldbu	r2,1(r20)
81121c78:	8c400094 	ori	r17,r17,2
81121c7c:	3029883a 	mov	r20,r6
81121c80:	10c03fcc 	andi	r3,r2,255
81121c84:	003ef406 	br	81121858 <__reset+0xfb101858>
81121c88:	e0800117 	ldw	r2,4(fp)
81121c8c:	d9809d15 	stw	r6,628(sp)
81121c90:	0081420e 	bge	zero,r2,8112219c <__svfscanf_r+0xa70>
81121c94:	05000104 	movi	r20,4
81121c98:	003faa06 	br	81121b44 <__reset+0xfb101b44>
81121c9c:	e0800117 	ldw	r2,4(fp)
81121ca0:	d9809d15 	stw	r6,628(sp)
81121ca4:	00bfec16 	blt	zero,r2,81121c58 <__reset+0xfb101c58>
81121ca8:	e00b883a 	mov	r5,fp
81121cac:	b009883a 	mov	r4,r22
81121cb0:	111ca0c0 	call	8111ca0c <__srefill_r>
81121cb4:	1000db1e 	bne	r2,zero,81122024 <__svfscanf_r+0x8f8>
81121cb8:	b9c00017 	ldw	r7,0(r23)
81121cbc:	003fe606 	br	81121c58 <__reset+0xfb101c58>
81121cc0:	d9809d15 	stw	r6,628(sp)
81121cc4:	8880040c 	andi	r2,r17,16
81121cc8:	10009c1e 	bne	r2,zero,81121f3c <__svfscanf_r+0x810>
81121ccc:	8880010c 	andi	r2,r17,4
81121cd0:	10011e26 	beq	r2,zero,8112214c <__svfscanf_r+0xa20>
81121cd4:	da009c17 	ldw	r8,624(sp)
81121cd8:	3029883a 	mov	r20,r6
81121cdc:	40800017 	ldw	r2,0(r8)
81121ce0:	42000104 	addi	r8,r8,4
81121ce4:	da009c15 	stw	r8,624(sp)
81121ce8:	1480000d 	sth	r18,0(r2)
81121cec:	003ecc06 	br	81121820 <__reset+0xfb101820>
81121cf0:	a0c00043 	ldbu	r3,1(r20)
81121cf4:	19410c26 	beq	r3,r5,81122128 <__svfscanf_r+0x9fc>
81121cf8:	8c400054 	ori	r17,r17,1
81121cfc:	3029883a 	mov	r20,r6
81121d00:	003ed506 	br	81121858 <__reset+0xfb101858>
81121d04:	a0800043 	ldbu	r2,1(r20)
81121d08:	8c400114 	ori	r17,r17,4
81121d0c:	3029883a 	mov	r20,r6
81121d10:	10c03fcc 	andi	r3,r2,255
81121d14:	003ed006 	br	81121858 <__reset+0xfb101858>
81121d18:	e0800117 	ldw	r2,4(fp)
81121d1c:	d9809d15 	stw	r6,628(sp)
81121d20:	00bf790e 	bge	zero,r2,81121b08 <__reset+0xfb101b08>
81121d24:	00a044b4 	movhi	r2,33042
81121d28:	10b40404 	addi	r2,r2,-12272
81121d2c:	02000284 	movi	r8,10
81121d30:	d880a115 	stw	r2,644(sp)
81121d34:	da009e15 	stw	r8,632(sp)
81121d38:	050000c4 	movi	r20,3
81121d3c:	003f8106 	br	81121b44 <__reset+0xfb101b44>
81121d40:	e0800117 	ldw	r2,4(fp)
81121d44:	d9809d15 	stw	r6,628(sp)
81121d48:	0080c40e 	bge	zero,r2,8112205c <__svfscanf_r+0x930>
81121d4c:	9800011e 	bne	r19,zero,81121d54 <__svfscanf_r+0x628>
81121d50:	04c00044 	movi	r19,1
81121d54:	8880004c 	andi	r2,r17,1
81121d58:	1000441e 	bne	r2,zero,81121e6c <__svfscanf_r+0x740>
81121d5c:	8c40040c 	andi	r17,r17,16
81121d60:	8800da26 	beq	r17,zero,811220cc <__svfscanf_r+0x9a0>
81121d64:	0021883a 	mov	r16,zero
81121d68:	00000806 	br	81121d8c <__svfscanf_r+0x660>
81121d6c:	1887883a 	add	r3,r3,r2
81121d70:	e00b883a 	mov	r5,fp
81121d74:	b009883a 	mov	r4,r22
81121d78:	e0c00015 	stw	r3,0(fp)
81121d7c:	80a1883a 	add	r16,r16,r2
81121d80:	98a7c83a 	sub	r19,r19,r2
81121d84:	111ca0c0 	call	8111ca0c <__srefill_r>
81121d88:	1000ca1e 	bne	r2,zero,811220b4 <__svfscanf_r+0x988>
81121d8c:	e0800117 	ldw	r2,4(fp)
81121d90:	e0c00017 	ldw	r3,0(fp)
81121d94:	14fff516 	blt	r2,r19,81121d6c <__reset+0xfb101d6c>
81121d98:	14c5c83a 	sub	r2,r2,r19
81121d9c:	1cd5883a 	add	r10,r3,r19
81121da0:	84e1883a 	add	r16,r16,r19
81121da4:	e0800115 	stw	r2,4(fp)
81121da8:	e2800015 	stw	r10,0(fp)
81121dac:	dd009d17 	ldw	r20,628(sp)
81121db0:	9425883a 	add	r18,r18,r16
81121db4:	a00d883a 	mov	r6,r20
81121db8:	003e9a06 	br	81121824 <__reset+0xfb101824>
81121dbc:	300b883a 	mov	r5,r6
81121dc0:	d9005884 	addi	r4,sp,354
81121dc4:	d9809d15 	stw	r6,628(sp)
81121dc8:	1127d140 	call	81127d14 <__sccl>
81121dcc:	1029883a 	mov	r20,r2
81121dd0:	e0800117 	ldw	r2,4(fp)
81121dd4:	0081050e 	bge	zero,r2,811221ec <__svfscanf_r+0xac0>
81121dd8:	e1000017 	ldw	r4,0(fp)
81121ddc:	20800003 	ldbu	r2,0(r4)
81121de0:	98005926 	beq	r19,zero,81121f48 <__svfscanf_r+0x81c>
81121de4:	8c40040c 	andi	r17,r17,16
81121de8:	88005a26 	beq	r17,zero,81121f54 <__svfscanf_r+0x828>
81121dec:	9823883a 	mov	r17,r19
81121df0:	0021883a 	mov	r16,zero
81121df4:	00000106 	br	81121dfc <__svfscanf_r+0x6d0>
81121df8:	20800003 	ldbu	r2,0(r4)
81121dfc:	10803fcc 	andi	r2,r2,255
81121e00:	d8c05884 	addi	r3,sp,354
81121e04:	1885883a 	add	r2,r3,r2
81121e08:	10800007 	ldb	r2,0(r2)
81121e0c:	1000ad26 	beq	r2,zero,811220c4 <__svfscanf_r+0x998>
81121e10:	e0800117 	ldw	r2,4(fp)
81121e14:	21000044 	addi	r4,r4,1
81121e18:	84000044 	addi	r16,r16,1
81121e1c:	10bfffc4 	addi	r2,r2,-1
81121e20:	e0800115 	stw	r2,4(fp)
81121e24:	e1000015 	stw	r4,0(fp)
81121e28:	84c0a026 	beq	r16,r19,811220ac <__svfscanf_r+0x980>
81121e2c:	00bff216 	blt	zero,r2,81121df8 <__reset+0xfb101df8>
81121e30:	e00b883a 	mov	r5,fp
81121e34:	b009883a 	mov	r4,r22
81121e38:	111ca0c0 	call	8111ca0c <__srefill_r>
81121e3c:	10009a1e 	bne	r2,zero,811220a8 <__svfscanf_r+0x97c>
81121e40:	e1000017 	ldw	r4,0(fp)
81121e44:	003fec06 	br	81121df8 <__reset+0xfb101df8>
81121e48:	e0800117 	ldw	r2,4(fp)
81121e4c:	d9809d15 	stw	r6,628(sp)
81121e50:	0080eb0e 	bge	zero,r2,81122200 <__svfscanf_r+0xad4>
81121e54:	00a044b4 	movhi	r2,33042
81121e58:	10b40404 	addi	r2,r2,-12272
81121e5c:	d880a115 	stw	r2,644(sp)
81121e60:	d8009e15 	stw	zero,632(sp)
81121e64:	050000c4 	movi	r20,3
81121e68:	003f3606 	br	81121b44 <__reset+0xfb101b44>
81121e6c:	dd409904 	addi	r21,sp,612
81121e70:	8c40040c 	andi	r17,r17,16
81121e74:	01800204 	movi	r6,8
81121e78:	000b883a 	mov	r5,zero
81121e7c:	a809883a 	mov	r4,r21
81121e80:	dc409f15 	stw	r17,636(sp)
81121e84:	111c5900 	call	8111c590 <memset>
81121e88:	dc409f17 	ldw	r17,636(sp)
81121e8c:	88006e26 	beq	r17,zero,81122048 <__svfscanf_r+0x91c>
81121e90:	0029883a 	mov	r20,zero
81121e94:	0023883a 	mov	r17,zero
81121e98:	11261300 	call	81126130 <__locale_mb_cur_max>
81121e9c:	14406126 	beq	r2,r17,81122024 <__svfscanf_r+0x8f8>
81121ea0:	e0800017 	ldw	r2,0(fp)
81121ea4:	e0c00117 	ldw	r3,4(fp)
81121ea8:	d9000104 	addi	r4,sp,4
81121eac:	12000003 	ldbu	r8,0(r2)
81121eb0:	18ffffc4 	addi	r3,r3,-1
81121eb4:	10800044 	addi	r2,r2,1
81121eb8:	e0c00115 	stw	r3,4(fp)
81121ebc:	e0800015 	stw	r2,0(fp)
81121ec0:	8c000044 	addi	r16,r17,1
81121ec4:	dd400015 	stw	r21,0(sp)
81121ec8:	2463883a 	add	r17,r4,r17
81121ecc:	200d883a 	mov	r6,r4
81121ed0:	a00b883a 	mov	r5,r20
81121ed4:	800f883a 	mov	r7,r16
81121ed8:	b009883a 	mov	r4,r22
81121edc:	8a000005 	stb	r8,0(r17)
81121ee0:	11261ec0 	call	811261ec <_mbrtowc_r>
81121ee4:	017fffc4 	movi	r5,-1
81121ee8:	11404e26 	beq	r2,r5,81122024 <__svfscanf_r+0x8f8>
81121eec:	1000601e 	bne	r2,zero,81122070 <__svfscanf_r+0x944>
81121ef0:	da009f17 	ldw	r8,636(sp)
81121ef4:	4000641e 	bne	r8,zero,81122088 <__svfscanf_r+0x95c>
81121ef8:	a0000015 	stw	zero,0(r20)
81121efc:	9425883a 	add	r18,r18,r16
81121f00:	9967883a 	add	r19,r19,r5
81121f04:	a5000104 	addi	r20,r20,4
81121f08:	e0800117 	ldw	r2,4(fp)
81121f0c:	0023883a 	mov	r17,zero
81121f10:	00804b16 	blt	zero,r2,81122040 <__svfscanf_r+0x914>
81121f14:	e00b883a 	mov	r5,fp
81121f18:	b009883a 	mov	r4,r22
81121f1c:	111ca0c0 	call	8111ca0c <__srefill_r>
81121f20:	10004726 	beq	r2,zero,81122040 <__svfscanf_r+0x914>
81121f24:	88003f1e 	bne	r17,zero,81122024 <__svfscanf_r+0x8f8>
81121f28:	d8c09f17 	ldw	r3,636(sp)
81121f2c:	1800031e 	bne	r3,zero,81121f3c <__svfscanf_r+0x810>
81121f30:	da00a017 	ldw	r8,640(sp)
81121f34:	42000044 	addi	r8,r8,1
81121f38:	da00a015 	stw	r8,640(sp)
81121f3c:	dd009d17 	ldw	r20,628(sp)
81121f40:	a00d883a 	mov	r6,r20
81121f44:	003e3706 	br	81121824 <__reset+0xfb101824>
81121f48:	8c40040c 	andi	r17,r17,16
81121f4c:	04ffffc4 	movi	r19,-1
81121f50:	883fa61e 	bne	r17,zero,81121dec <__reset+0xfb101dec>
81121f54:	da009c17 	ldw	r8,624(sp)
81121f58:	9abfffc4 	addi	r10,r19,-1
81121f5c:	44000017 	ldw	r16,0(r8)
81121f60:	44400104 	addi	r17,r8,4
81121f64:	8007883a 	mov	r3,r16
81121f68:	82ab883a 	add	r21,r16,r10
81121f6c:	00000306 	br	81121f7c <__svfscanf_r+0x850>
81121f70:	e1000017 	ldw	r4,0(fp)
81121f74:	9807883a 	mov	r3,r19
81121f78:	20800003 	ldbu	r2,0(r4)
81121f7c:	10803fcc 	andi	r2,r2,255
81121f80:	d9405884 	addi	r5,sp,354
81121f84:	2885883a 	add	r2,r5,r2
81121f88:	10800007 	ldb	r2,0(r2)
81121f8c:	10004b26 	beq	r2,zero,811220bc <__svfscanf_r+0x990>
81121f90:	e0800117 	ldw	r2,4(fp)
81121f94:	21400044 	addi	r5,r4,1
81121f98:	e1400015 	stw	r5,0(fp)
81121f9c:	10bfffc4 	addi	r2,r2,-1
81121fa0:	e0800115 	stw	r2,4(fp)
81121fa4:	20800003 	ldbu	r2,0(r4)
81121fa8:	1cc00044 	addi	r19,r3,1
81121fac:	18800005 	stb	r2,0(r3)
81121fb0:	1d400726 	beq	r3,r21,81121fd0 <__svfscanf_r+0x8a4>
81121fb4:	e0800117 	ldw	r2,4(fp)
81121fb8:	00bfed16 	blt	zero,r2,81121f70 <__reset+0xfb101f70>
81121fbc:	e00b883a 	mov	r5,fp
81121fc0:	b009883a 	mov	r4,r22
81121fc4:	111ca0c0 	call	8111ca0c <__srefill_r>
81121fc8:	103fe926 	beq	r2,zero,81121f70 <__reset+0xfb101f70>
81121fcc:	84c01526 	beq	r16,r19,81122024 <__svfscanf_r+0x8f8>
81121fd0:	9c21c83a 	sub	r16,r19,r16
81121fd4:	803e1726 	beq	r16,zero,81121834 <__reset+0xfb101834>
81121fd8:	da00a017 	ldw	r8,640(sp)
81121fdc:	98000005 	stb	zero,0(r19)
81121fe0:	dc409c15 	stw	r17,624(sp)
81121fe4:	42000044 	addi	r8,r8,1
81121fe8:	da00a015 	stw	r8,640(sp)
81121fec:	9425883a 	add	r18,r18,r16
81121ff0:	a00d883a 	mov	r6,r20
81121ff4:	003e0b06 	br	81121824 <__reset+0xfb101824>
81121ff8:	017fff84 	movi	r5,-2
81121ffc:	11439b1e 	bne	r2,r5,81122e6c <__svfscanf_r+0x1740>
81122000:	8821883a 	mov	r16,r17
81122004:	e0800117 	ldw	r2,4(fp)
81122008:	0082e516 	blt	zero,r2,81122ba0 <__svfscanf_r+0x1474>
8112200c:	e00b883a 	mov	r5,fp
81122010:	b009883a 	mov	r4,r22
81122014:	111ca0c0 	call	8111ca0c <__srefill_r>
81122018:	1002e126 	beq	r2,zero,81122ba0 <__svfscanf_r+0x1474>
8112201c:	dc409f17 	ldw	r17,636(sp)
81122020:	8002e826 	beq	r16,zero,81122bc4 <__svfscanf_r+0x1498>
81122024:	da00a017 	ldw	r8,640(sp)
81122028:	403e9c26 	beq	r8,zero,81121a9c <__reset+0xfb101a9c>
8112202c:	e080030b 	ldhu	r2,12(fp)
81122030:	1080100c 	andi	r2,r2,64
81122034:	103e991e 	bne	r2,zero,81121a9c <__reset+0xfb101a9c>
81122038:	4005883a 	mov	r2,r8
8112203c:	003e9806 	br	81121aa0 <__reset+0xfb101aa0>
81122040:	983f951e 	bne	r19,zero,81121e98 <__reset+0xfb101e98>
81122044:	003fb806 	br	81121f28 <__reset+0xfb101f28>
81122048:	da009c17 	ldw	r8,624(sp)
8112204c:	45000017 	ldw	r20,0(r8)
81122050:	42000104 	addi	r8,r8,4
81122054:	da009c15 	stw	r8,624(sp)
81122058:	003f8e06 	br	81121e94 <__reset+0xfb101e94>
8112205c:	e00b883a 	mov	r5,fp
81122060:	b009883a 	mov	r4,r22
81122064:	111ca0c0 	call	8111ca0c <__srefill_r>
81122068:	103f3826 	beq	r2,zero,81121d4c <__reset+0xfb101d4c>
8112206c:	003fed06 	br	81122024 <__reset+0xfb102024>
81122070:	00ffff84 	movi	r3,-2
81122074:	10c0071e 	bne	r2,r3,81122094 <__svfscanf_r+0x968>
81122078:	e0800117 	ldw	r2,4(fp)
8112207c:	8023883a 	mov	r17,r16
81122080:	00bf8516 	blt	zero,r2,81121e98 <__reset+0xfb101e98>
81122084:	003fa306 	br	81121f14 <__reset+0xfb101f14>
81122088:	9425883a 	add	r18,r18,r16
8112208c:	9cffffc4 	addi	r19,r19,-1
81122090:	003f9d06 	br	81121f08 <__reset+0xfb101f08>
81122094:	da009f17 	ldw	r8,636(sp)
81122098:	9425883a 	add	r18,r18,r16
8112209c:	9cffffc4 	addi	r19,r19,-1
811220a0:	403f9826 	beq	r8,zero,81121f04 <__reset+0xfb101f04>
811220a4:	003f9806 	br	81121f08 <__reset+0xfb101f08>
811220a8:	8023883a 	mov	r17,r16
811220ac:	8821883a 	mov	r16,r17
811220b0:	003fce06 	br	81121fec <__reset+0xfb101fec>
811220b4:	803f3d1e 	bne	r16,zero,81121dac <__reset+0xfb101dac>
811220b8:	003fda06 	br	81122024 <__reset+0xfb102024>
811220bc:	1827883a 	mov	r19,r3
811220c0:	003fc306 	br	81121fd0 <__reset+0xfb101fd0>
811220c4:	803fc91e 	bne	r16,zero,81121fec <__reset+0xfb101fec>
811220c8:	003dda06 	br	81121834 <__reset+0xfb101834>
811220cc:	da009c17 	ldw	r8,624(sp)
811220d0:	df000015 	stw	fp,0(sp)
811220d4:	980f883a 	mov	r7,r19
811220d8:	41400017 	ldw	r5,0(r8)
811220dc:	01800044 	movi	r6,1
811220e0:	b009883a 	mov	r4,r22
811220e4:	11253040 	call	81125304 <_fread_r>
811220e8:	da009c17 	ldw	r8,624(sp)
811220ec:	40c00104 	addi	r3,r8,4
811220f0:	103fcc26 	beq	r2,zero,81122024 <__reset+0xfb102024>
811220f4:	da00a017 	ldw	r8,640(sp)
811220f8:	dd009d17 	ldw	r20,628(sp)
811220fc:	90a5883a 	add	r18,r18,r2
81122100:	42000044 	addi	r8,r8,1
81122104:	da00a015 	stw	r8,640(sp)
81122108:	d8c09c15 	stw	r3,624(sp)
8112210c:	a00d883a 	mov	r6,r20
81122110:	003dc406 	br	81121824 <__reset+0xfb101824>
81122114:	e00b883a 	mov	r5,fp
81122118:	b009883a 	mov	r4,r22
8112211c:	111ca0c0 	call	8111ca0c <__srefill_r>
81122120:	103e5226 	beq	r2,zero,81121a6c <__reset+0xfb101a6c>
81122124:	003fbf06 	br	81122024 <__reset+0xfb102024>
81122128:	a0800083 	ldbu	r2,2(r20)
8112212c:	8c400094 	ori	r17,r17,2
81122130:	a5000084 	addi	r20,r20,2
81122134:	10c03fcc 	andi	r3,r2,255
81122138:	003dc706 	br	81121858 <__reset+0xfb101858>
8112213c:	e0800117 	ldw	r2,4(fp)
81122140:	88e2b03a 	or	r17,r17,r3
81122144:	00bef716 	blt	zero,r2,81121d24 <__reset+0xfb101d24>
81122148:	003e6f06 	br	81121b08 <__reset+0xfb101b08>
8112214c:	8880004c 	andi	r2,r17,1
81122150:	10000b1e 	bne	r2,zero,81122180 <__svfscanf_r+0xa54>
81122154:	8c40008c 	andi	r17,r17,2
81122158:	88000926 	beq	r17,zero,81122180 <__svfscanf_r+0xa54>
8112215c:	da009c17 	ldw	r8,624(sp)
81122160:	9007d7fa 	srai	r3,r18,31
81122164:	dd009d17 	ldw	r20,628(sp)
81122168:	40800017 	ldw	r2,0(r8)
8112216c:	42000104 	addi	r8,r8,4
81122170:	da009c15 	stw	r8,624(sp)
81122174:	14800015 	stw	r18,0(r2)
81122178:	10c00115 	stw	r3,4(r2)
8112217c:	003da806 	br	81121820 <__reset+0xfb101820>
81122180:	da009c17 	ldw	r8,624(sp)
81122184:	dd009d17 	ldw	r20,628(sp)
81122188:	40800017 	ldw	r2,0(r8)
8112218c:	42000104 	addi	r8,r8,4
81122190:	da009c15 	stw	r8,624(sp)
81122194:	14800015 	stw	r18,0(r2)
81122198:	003da106 	br	81121820 <__reset+0xfb101820>
8112219c:	e00b883a 	mov	r5,fp
811221a0:	b009883a 	mov	r4,r22
811221a4:	111ca0c0 	call	8111ca0c <__srefill_r>
811221a8:	103f9e1e 	bne	r2,zero,81122024 <__reset+0xfb102024>
811221ac:	b9c00017 	ldw	r7,0(r23)
811221b0:	05000104 	movi	r20,4
811221b4:	003e6306 	br	81121b44 <__reset+0xfb101b44>
811221b8:	e00b883a 	mov	r5,fp
811221bc:	b009883a 	mov	r4,r22
811221c0:	111ca0c0 	call	8111ca0c <__srefill_r>
811221c4:	103f971e 	bne	r2,zero,81122024 <__reset+0xfb102024>
811221c8:	b9c00017 	ldw	r7,0(r23)
811221cc:	003e5706 	br	81121b2c <__reset+0xfb101b2c>
811221d0:	e00b883a 	mov	r5,fp
811221d4:	b009883a 	mov	r4,r22
811221d8:	111ca0c0 	call	8111ca0c <__srefill_r>
811221dc:	103f911e 	bne	r2,zero,81122024 <__reset+0xfb102024>
811221e0:	b9c00017 	ldw	r7,0(r23)
811221e4:	05000084 	movi	r20,2
811221e8:	003e5606 	br	81121b44 <__reset+0xfb101b44>
811221ec:	e00b883a 	mov	r5,fp
811221f0:	b009883a 	mov	r4,r22
811221f4:	111ca0c0 	call	8111ca0c <__srefill_r>
811221f8:	103ef726 	beq	r2,zero,81121dd8 <__reset+0xfb101dd8>
811221fc:	003f8906 	br	81122024 <__reset+0xfb102024>
81122200:	e00b883a 	mov	r5,fp
81122204:	b009883a 	mov	r4,r22
81122208:	111ca0c0 	call	8111ca0c <__srefill_r>
8112220c:	103f851e 	bne	r2,zero,81122024 <__reset+0xfb102024>
81122210:	b9c00017 	ldw	r7,0(r23)
81122214:	003f0f06 	br	81121e54 <__reset+0xfb101e54>
81122218:	014000c4 	movi	r5,3
8112221c:	a1414a26 	beq	r20,r5,81122748 <__svfscanf_r+0x101c>
81122220:	01000104 	movi	r4,4
81122224:	a101f11e 	bne	r20,r4,811229ec <__svfscanf_r+0x12c0>
81122228:	b009883a 	mov	r4,r22
8112222c:	11261540 	call	81126154 <_localeconv_r>
81122230:	10800017 	ldw	r2,0(r2)
81122234:	98ffffc4 	addi	r3,r19,-1
81122238:	d880a315 	stw	r2,652(sp)
8112223c:	00805704 	movi	r2,348
81122240:	10c21e2e 	bgeu	r2,r3,81122abc <__svfscanf_r+0x1390>
81122244:	9cffa8c4 	addi	r19,r19,-349
81122248:	dcc0a215 	stw	r19,648(sp)
8112224c:	04c05744 	movi	r19,349
81122250:	8d01e014 	ori	r20,r17,1920
81122254:	0023883a 	mov	r17,zero
81122258:	dc000104 	addi	r16,sp,4
8112225c:	8805883a 	mov	r2,r17
81122260:	0019883a 	mov	r12,zero
81122264:	8023883a 	mov	r17,r16
81122268:	b007883a 	mov	r3,r22
8112226c:	9821883a 	mov	r16,r19
81122270:	002b883a 	mov	r21,zero
81122274:	d800a515 	stw	zero,660(sp)
81122278:	d800a415 	stw	zero,656(sp)
8112227c:	d8009f15 	stw	zero,636(sp)
81122280:	01c01384 	movi	r7,78
81122284:	602d883a 	mov	r22,r12
81122288:	1027883a 	mov	r19,r2
8112228c:	e1000017 	ldw	r4,0(fp)
81122290:	21400003 	ldbu	r5,0(r4)
81122294:	28bff544 	addi	r2,r5,-43
81122298:	10803fcc 	andi	r2,r2,255
8112229c:	38810e36 	bltu	r7,r2,811226d8 <__svfscanf_r+0xfac>
811222a0:	100490ba 	slli	r2,r2,2
811222a4:	01a044b4 	movhi	r6,33042
811222a8:	3188ae04 	addi	r6,r6,8888
811222ac:	1185883a 	add	r2,r2,r6
811222b0:	10800017 	ldw	r2,0(r2)
811222b4:	1000683a 	jmp	r2
811222b8:	811225b0 	cmpltui	r4,r16,18582
811222bc:	811226d8 	cmpnei	r4,r16,18587
811222c0:	811225b0 	cmpltui	r4,r16,18582
811222c4:	811226d8 	cmpnei	r4,r16,18587
811222c8:	811226d8 	cmpnei	r4,r16,18587
811222cc:	81122584 	addi	r4,r16,18582
811222d0:	811223f4 	orhi	r4,r16,18575
811222d4:	811223f4 	orhi	r4,r16,18575
811222d8:	811223f4 	orhi	r4,r16,18575
811222dc:	811223f4 	orhi	r4,r16,18575
811222e0:	811223f4 	orhi	r4,r16,18575
811222e4:	811223f4 	orhi	r4,r16,18575
811222e8:	811223f4 	orhi	r4,r16,18575
811222ec:	811223f4 	orhi	r4,r16,18575
811222f0:	811223f4 	orhi	r4,r16,18575
811222f4:	811226d8 	cmpnei	r4,r16,18587
811222f8:	811226d8 	cmpnei	r4,r16,18587
811222fc:	811226d8 	cmpnei	r4,r16,18587
81122300:	811226d8 	cmpnei	r4,r16,18587
81122304:	811226d8 	cmpnei	r4,r16,18587
81122308:	811226d8 	cmpnei	r4,r16,18587
8112230c:	811226d8 	cmpnei	r4,r16,18587
81122310:	811226c8 	cmpgei	r4,r16,18587
81122314:	811226d8 	cmpnei	r4,r16,18587
81122318:	811226d8 	cmpnei	r4,r16,18587
8112231c:	811226d8 	cmpnei	r4,r16,18587
81122320:	81122684 	addi	r4,r16,18586
81122324:	81122668 	cmpgeui	r4,r16,18585
81122328:	811226d8 	cmpnei	r4,r16,18587
8112232c:	811226d8 	cmpnei	r4,r16,18587
81122330:	81122634 	orhi	r4,r16,18584
81122334:	811226d8 	cmpnei	r4,r16,18587
81122338:	811226d8 	cmpnei	r4,r16,18587
8112233c:	811226d8 	cmpnei	r4,r16,18587
81122340:	811226d8 	cmpnei	r4,r16,18587
81122344:	811225fc 	xorhi	r4,r16,18583
81122348:	811226d8 	cmpnei	r4,r16,18587
8112234c:	811226d8 	cmpnei	r4,r16,18587
81122350:	811226d8 	cmpnei	r4,r16,18587
81122354:	811226d8 	cmpnei	r4,r16,18587
81122358:	811226d8 	cmpnei	r4,r16,18587
8112235c:	811225e0 	cmpeqi	r4,r16,18583
81122360:	811226d8 	cmpnei	r4,r16,18587
81122364:	811226d8 	cmpnei	r4,r16,18587
81122368:	811226d8 	cmpnei	r4,r16,18587
8112236c:	811226d8 	cmpnei	r4,r16,18587
81122370:	811225c4 	addi	r4,r16,18583
81122374:	811226d8 	cmpnei	r4,r16,18587
81122378:	811226d8 	cmpnei	r4,r16,18587
8112237c:	811226d8 	cmpnei	r4,r16,18587
81122380:	811226d8 	cmpnei	r4,r16,18587
81122384:	811226d8 	cmpnei	r4,r16,18587
81122388:	811226d8 	cmpnei	r4,r16,18587
8112238c:	811226d8 	cmpnei	r4,r16,18587
81122390:	811226c8 	cmpgei	r4,r16,18587
81122394:	811226d8 	cmpnei	r4,r16,18587
81122398:	811226d8 	cmpnei	r4,r16,18587
8112239c:	811226d8 	cmpnei	r4,r16,18587
811223a0:	81122684 	addi	r4,r16,18586
811223a4:	81122668 	cmpgeui	r4,r16,18585
811223a8:	811226d8 	cmpnei	r4,r16,18587
811223ac:	811226d8 	cmpnei	r4,r16,18587
811223b0:	81122634 	orhi	r4,r16,18584
811223b4:	811226d8 	cmpnei	r4,r16,18587
811223b8:	811226d8 	cmpnei	r4,r16,18587
811223bc:	811226d8 	cmpnei	r4,r16,18587
811223c0:	811226d8 	cmpnei	r4,r16,18587
811223c4:	811225fc 	xorhi	r4,r16,18583
811223c8:	811226d8 	cmpnei	r4,r16,18587
811223cc:	811226d8 	cmpnei	r4,r16,18587
811223d0:	811226d8 	cmpnei	r4,r16,18587
811223d4:	811226d8 	cmpnei	r4,r16,18587
811223d8:	811226d8 	cmpnei	r4,r16,18587
811223dc:	811225e0 	cmpeqi	r4,r16,18583
811223e0:	811226d8 	cmpnei	r4,r16,18587
811223e4:	811226d8 	cmpnei	r4,r16,18587
811223e8:	811226d8 	cmpnei	r4,r16,18587
811223ec:	811226d8 	cmpnei	r4,r16,18587
811223f0:	811225c4 	addi	r4,r16,18583
811223f4:	a8803fcc 	andi	r2,r21,255
811223f8:	1080201c 	xori	r2,r2,128
811223fc:	10bfe004 	addi	r2,r2,-128
81122400:	b085883a 	add	r2,r22,r2
81122404:	10000d1e 	bne	r2,zero,8112243c <__svfscanf_r+0xd10>
81122408:	00bf9fc4 	movi	r2,-385
8112240c:	a0a8703a 	and	r20,r20,r2
81122410:	89400005 	stb	r5,0(r17)
81122414:	8c400044 	addi	r17,r17,1
81122418:	e0800117 	ldw	r2,4(fp)
8112241c:	843fffc4 	addi	r16,r16,-1
81122420:	94800044 	addi	r18,r18,1
81122424:	10bfffc4 	addi	r2,r2,-1
81122428:	e0800115 	stw	r2,4(fp)
8112242c:	0080b40e 	bge	zero,r2,81122700 <__svfscanf_r+0xfd4>
81122430:	21000044 	addi	r4,r4,1
81122434:	e1000015 	stw	r4,0(fp)
81122438:	803f941e 	bne	r16,zero,8112228c <__reset+0xfb10228c>
8112243c:	8821883a 	mov	r16,r17
81122440:	b019883a 	mov	r12,r22
81122444:	9823883a 	mov	r17,r19
81122448:	182d883a 	mov	r22,r3
8112244c:	9801961e 	bne	r19,zero,81122aa8 <__svfscanf_r+0x137c>
81122450:	633fffc4 	addi	r12,r12,-1
81122454:	00800044 	movi	r2,1
81122458:	1302882e 	bgeu	r2,r12,81122e7c <__svfscanf_r+0x1750>
8112245c:	a8803fcc 	andi	r2,r21,255
81122460:	1080201c 	xori	r2,r2,128
81122464:	10bfe004 	addi	r2,r2,-128
81122468:	113fffc4 	addi	r4,r2,-1
8112246c:	01400184 	movi	r5,6
81122470:	29001136 	bltu	r5,r4,811224b8 <__svfscanf_r+0xd8c>
81122474:	01000084 	movi	r4,2
81122478:	2082900e 	bge	r4,r2,81122ebc <__svfscanf_r+0x1790>
8112247c:	00c000c4 	movi	r3,3
81122480:	10c00d26 	beq	r2,r3,811224b8 <__svfscanf_r+0xd8c>
81122484:	9425c83a 	sub	r18,r18,r16
81122488:	1827883a 	mov	r19,r3
8112248c:	843fffc4 	addi	r16,r16,-1
81122490:	81400007 	ldb	r5,0(r16)
81122494:	e00d883a 	mov	r6,fp
81122498:	b009883a 	mov	r4,r22
8112249c:	112b3840 	call	8112b384 <_ungetc_r>
811224a0:	a8bfffc4 	addi	r2,r21,-1
811224a4:	10c03fcc 	andi	r3,r2,255
811224a8:	8493883a 	add	r9,r16,r18
811224ac:	102b883a 	mov	r21,r2
811224b0:	98fff636 	bltu	r19,r3,8112248c <__reset+0xfb10248c>
811224b4:	4825883a 	mov	r18,r9
811224b8:	a080400c 	andi	r2,r20,256
811224bc:	10001426 	beq	r2,zero,81122510 <__svfscanf_r+0xde4>
811224c0:	a081000c 	andi	r2,r20,1024
811224c4:	1002571e 	bne	r2,zero,81122e24 <__svfscanf_r+0x16f8>
811224c8:	817fffc7 	ldb	r5,-1(r16)
811224cc:	00801944 	movi	r2,101
811224d0:	84ffffc4 	addi	r19,r16,-1
811224d4:	957fffc4 	addi	r21,r18,-1
811224d8:	28800826 	beq	r5,r2,811224fc <__svfscanf_r+0xdd0>
811224dc:	00801144 	movi	r2,69
811224e0:	28800626 	beq	r5,r2,811224fc <__svfscanf_r+0xdd0>
811224e4:	e00d883a 	mov	r6,fp
811224e8:	b009883a 	mov	r4,r22
811224ec:	112b3840 	call	8112b384 <_ungetc_r>
811224f0:	817fff87 	ldb	r5,-2(r16)
811224f4:	84ffff84 	addi	r19,r16,-2
811224f8:	957fff84 	addi	r21,r18,-2
811224fc:	e00d883a 	mov	r6,fp
81122500:	b009883a 	mov	r4,r22
81122504:	112b3840 	call	8112b384 <_ungetc_r>
81122508:	a825883a 	mov	r18,r21
8112250c:	9821883a 	mov	r16,r19
81122510:	a080040c 	andi	r2,r20,16
81122514:	103e891e 	bne	r2,zero,81121f3c <__reset+0xfb101f3c>
81122518:	80000005 	stb	zero,0(r16)
8112251c:	a081800c 	andi	r2,r20,1536
81122520:	01010004 	movi	r4,1024
81122524:	1101dd26 	beq	r2,r4,81122c9c <__svfscanf_r+0x1570>
81122528:	da00a417 	ldw	r8,656(sp)
8112252c:	4001e71e 	bne	r8,zero,81122ccc <__svfscanf_r+0x15a0>
81122530:	000d883a 	mov	r6,zero
81122534:	d9400104 	addi	r5,sp,4
81122538:	b009883a 	mov	r4,r22
8112253c:	1127f340 	call	81127f34 <_strtod_r>
81122540:	1021883a 	mov	r16,r2
81122544:	a080004c 	andi	r2,r20,1
81122548:	1000021e 	bne	r2,zero,81122554 <__svfscanf_r+0xe28>
8112254c:	a2c0008c 	andi	r11,r20,2
81122550:	5801e826 	beq	r11,zero,81122cf4 <__svfscanf_r+0x15c8>
81122554:	da009c17 	ldw	r8,624(sp)
81122558:	40800017 	ldw	r2,0(r8)
8112255c:	42000104 	addi	r8,r8,4
81122560:	da009c15 	stw	r8,624(sp)
81122564:	14000015 	stw	r16,0(r2)
81122568:	10c00115 	stw	r3,4(r2)
8112256c:	da00a017 	ldw	r8,640(sp)
81122570:	dd009d17 	ldw	r20,628(sp)
81122574:	42000044 	addi	r8,r8,1
81122578:	da00a015 	stw	r8,640(sp)
8112257c:	a00d883a 	mov	r6,r20
81122580:	003ca806 	br	81121824 <__reset+0xfb101824>
81122584:	a080400c 	andi	r2,r20,256
81122588:	103f9a26 	beq	r2,zero,811223f4 <__reset+0xfb1023f4>
8112258c:	da00a217 	ldw	r8,648(sp)
81122590:	00bfdfc4 	movi	r2,-129
81122594:	a0a8703a 	and	r20,r20,r2
81122598:	9cc00044 	addi	r19,r19,1
8112259c:	403f9e26 	beq	r8,zero,81122418 <__reset+0xfb102418>
811225a0:	423fffc4 	addi	r8,r8,-1
811225a4:	da00a215 	stw	r8,648(sp)
811225a8:	84000044 	addi	r16,r16,1
811225ac:	003f9a06 	br	81122418 <__reset+0xfb102418>
811225b0:	a080200c 	andi	r2,r20,128
811225b4:	103fa126 	beq	r2,zero,8112243c <__reset+0xfb10243c>
811225b8:	00bfdfc4 	movi	r2,-129
811225bc:	a0a8703a 	and	r20,r20,r2
811225c0:	003f9306 	br	81122410 <__reset+0xfb102410>
811225c4:	a8803fcc 	andi	r2,r21,255
811225c8:	1080201c 	xori	r2,r2,128
811225cc:	10bfe004 	addi	r2,r2,-128
811225d0:	020001c4 	movi	r8,7
811225d4:	123f991e 	bne	r2,r8,8112243c <__reset+0xfb10243c>
811225d8:	05400204 	movi	r21,8
811225dc:	003f8c06 	br	81122410 <__reset+0xfb102410>
811225e0:	a8803fcc 	andi	r2,r21,255
811225e4:	1080201c 	xori	r2,r2,128
811225e8:	10bfe004 	addi	r2,r2,-128
811225ec:	01800184 	movi	r6,6
811225f0:	11bf921e 	bne	r2,r6,8112243c <__reset+0xfb10243c>
811225f4:	054001c4 	movi	r21,7
811225f8:	003f8506 	br	81122410 <__reset+0xfb102410>
811225fc:	b000491e 	bne	r22,zero,81122724 <__svfscanf_r+0xff8>
81122600:	9800031e 	bne	r19,zero,81122610 <__svfscanf_r+0xee4>
81122604:	a081c00c 	andi	r2,r20,1792
81122608:	0181c004 	movi	r6,1792
8112260c:	11819f26 	beq	r2,r6,81122c8c <__svfscanf_r+0x1560>
81122610:	a8803fcc 	andi	r2,r21,255
81122614:	1080201c 	xori	r2,r2,128
81122618:	10bfe004 	addi	r2,r2,-128
8112261c:	01800044 	movi	r6,1
81122620:	11800226 	beq	r2,r6,8112262c <__svfscanf_r+0xf00>
81122624:	01800104 	movi	r6,4
81122628:	11bf841e 	bne	r2,r6,8112243c <__reset+0xfb10243c>
8112262c:	ad400044 	addi	r21,r21,1
81122630:	003f7706 	br	81122410 <__reset+0xfb102410>
81122634:	a8803fcc 	andi	r2,r21,255
81122638:	1080201c 	xori	r2,r2,128
8112263c:	10bfe004 	addi	r2,r2,-128
81122640:	10003c1e 	bne	r2,zero,81122734 <__svfscanf_r+0x1008>
81122644:	9801141e 	bne	r19,zero,81122a98 <__svfscanf_r+0x136c>
81122648:	a081c00c 	andi	r2,r20,1792
8112264c:	0181c004 	movi	r6,1792
81122650:	11818226 	beq	r2,r6,81122c5c <__svfscanf_r+0x1530>
81122654:	8821883a 	mov	r16,r17
81122658:	b019883a 	mov	r12,r22
8112265c:	9823883a 	mov	r17,r19
81122660:	182d883a 	mov	r22,r3
81122664:	003f7a06 	br	81122450 <__reset+0xfb102450>
81122668:	a8803fcc 	andi	r2,r21,255
8112266c:	1080201c 	xori	r2,r2,128
81122670:	10bfe004 	addi	r2,r2,-128
81122674:	01800084 	movi	r6,2
81122678:	11bf701e 	bne	r2,r6,8112243c <__reset+0xfb10243c>
8112267c:	054000c4 	movi	r21,3
81122680:	003f6306 	br	81122410 <__reset+0xfb102410>
81122684:	a081400c 	andi	r2,r20,1280
81122688:	01810004 	movi	r6,1024
8112268c:	11800326 	beq	r2,r6,8112269c <__svfscanf_r+0xf70>
81122690:	a184703a 	and	r2,r20,r6
81122694:	103f6926 	beq	r2,zero,8112243c <__reset+0xfb10243c>
81122698:	983fee26 	beq	r19,zero,81122654 <__reset+0xfb102654>
8112269c:	a080800c 	andi	r2,r20,512
811226a0:	1000041e 	bne	r2,zero,811226b4 <__svfscanf_r+0xf88>
811226a4:	da009f17 	ldw	r8,636(sp)
811226a8:	dc40a515 	stw	r17,660(sp)
811226ac:	9a27c83a 	sub	r19,r19,r8
811226b0:	dcc0a415 	stw	r19,656(sp)
811226b4:	00be1fc4 	movi	r2,-1921
811226b8:	a0a8703a 	and	r20,r20,r2
811226bc:	a5006014 	ori	r20,r20,384
811226c0:	0027883a 	mov	r19,zero
811226c4:	003f5206 	br	81122410 <__reset+0xfb102410>
811226c8:	00800044 	movi	r2,1
811226cc:	b0bf5b1e 	bne	r22,r2,8112243c <__reset+0xfb10243c>
811226d0:	05800084 	movi	r22,2
811226d4:	003f4e06 	br	81122410 <__reset+0xfb102410>
811226d8:	d980a317 	ldw	r6,652(sp)
811226dc:	30800003 	ldbu	r2,0(r6)
811226e0:	29803fcc 	andi	r6,r5,255
811226e4:	30bf551e 	bne	r6,r2,8112243c <__reset+0xfb10243c>
811226e8:	a080800c 	andi	r2,r20,512
811226ec:	103f5326 	beq	r2,zero,8112243c <__reset+0xfb10243c>
811226f0:	023f5fc4 	movi	r8,-641
811226f4:	a228703a 	and	r20,r20,r8
811226f8:	dcc09f15 	stw	r19,636(sp)
811226fc:	003f4406 	br	81122410 <__reset+0xfb102410>
81122700:	1809883a 	mov	r4,r3
81122704:	e00b883a 	mov	r5,fp
81122708:	d8c0a615 	stw	r3,664(sp)
8112270c:	d9c0aa15 	stw	r7,680(sp)
81122710:	111ca0c0 	call	8111ca0c <__srefill_r>
81122714:	d8c0a617 	ldw	r3,664(sp)
81122718:	d9c0aa17 	ldw	r7,680(sp)
8112271c:	103f4626 	beq	r2,zero,81122438 <__reset+0xfb102438>
81122720:	003f4606 	br	8112243c <__reset+0xfb10243c>
81122724:	00800084 	movi	r2,2
81122728:	b0bfb91e 	bne	r22,r2,81122610 <__reset+0xfb102610>
8112272c:	058000c4 	movi	r22,3
81122730:	003f3706 	br	81122410 <__reset+0xfb102410>
81122734:	018000c4 	movi	r6,3
81122738:	11bfbc26 	beq	r2,r6,8112262c <__reset+0xfb10262c>
8112273c:	01800144 	movi	r6,5
81122740:	11bfba26 	beq	r2,r6,8112262c <__reset+0xfb10262c>
81122744:	003f3d06 	br	8112243c <__reset+0xfb10243c>
81122748:	98bfffc4 	addi	r2,r19,-1
8112274c:	01405704 	movi	r5,348
81122750:	2880d82e 	bgeu	r5,r2,81122ab4 <__svfscanf_r+0x1388>
81122754:	99ffa8c4 	addi	r7,r19,-349
81122758:	04c05744 	movi	r19,349
8112275c:	8c436014 	ori	r17,r17,3456
81122760:	9013883a 	mov	r9,r18
81122764:	8825883a 	mov	r18,r17
81122768:	dc409e17 	ldw	r17,632(sp)
8112276c:	0029883a 	mov	r20,zero
81122770:	dc000104 	addi	r16,sp,4
81122774:	05401344 	movi	r21,77
81122778:	02c08004 	movi	r11,512
8112277c:	01bf7fc4 	movi	r6,-513
81122780:	023fdfc4 	movi	r8,-129
81122784:	20bff544 	addi	r2,r4,-43
81122788:	10803fcc 	andi	r2,r2,255
8112278c:	a8807236 	bltu	r21,r2,81122958 <__svfscanf_r+0x122c>
81122790:	100490ba 	slli	r2,r2,2
81122794:	016044b4 	movhi	r5,33042
81122798:	2949ea04 	addi	r5,r5,10152
8112279c:	1145883a 	add	r2,r2,r5
811227a0:	10800017 	ldw	r2,0(r2)
811227a4:	1000683a 	jmp	r2
811227a8:	811229dc 	xori	r4,r16,18599
811227ac:	81122958 	cmpnei	r4,r16,18597
811227b0:	811229dc 	xori	r4,r16,18599
811227b4:	81122958 	cmpnei	r4,r16,18597
811227b8:	81122958 	cmpnei	r4,r16,18597
811227bc:	811229b4 	orhi	r4,r16,18598
811227c0:	81122994 	ori	r4,r16,18598
811227c4:	81122994 	ori	r4,r16,18598
811227c8:	81122994 	ori	r4,r16,18598
811227cc:	81122994 	ori	r4,r16,18598
811227d0:	81122994 	ori	r4,r16,18598
811227d4:	81122994 	ori	r4,r16,18598
811227d8:	81122994 	ori	r4,r16,18598
811227dc:	8112293c 	xorhi	r4,r16,18596
811227e0:	8112293c 	xorhi	r4,r16,18596
811227e4:	81122958 	cmpnei	r4,r16,18597
811227e8:	81122958 	cmpnei	r4,r16,18597
811227ec:	81122958 	cmpnei	r4,r16,18597
811227f0:	81122958 	cmpnei	r4,r16,18597
811227f4:	81122958 	cmpnei	r4,r16,18597
811227f8:	81122958 	cmpnei	r4,r16,18597
811227fc:	81122958 	cmpnei	r4,r16,18597
81122800:	81122928 	cmpgeui	r4,r16,18596
81122804:	81122928 	cmpgeui	r4,r16,18596
81122808:	81122928 	cmpgeui	r4,r16,18596
8112280c:	81122928 	cmpgeui	r4,r16,18596
81122810:	81122928 	cmpgeui	r4,r16,18596
81122814:	81122928 	cmpgeui	r4,r16,18596
81122818:	81122958 	cmpnei	r4,r16,18597
8112281c:	81122958 	cmpnei	r4,r16,18597
81122820:	81122958 	cmpnei	r4,r16,18597
81122824:	81122958 	cmpnei	r4,r16,18597
81122828:	81122958 	cmpnei	r4,r16,18597
8112282c:	81122958 	cmpnei	r4,r16,18597
81122830:	81122958 	cmpnei	r4,r16,18597
81122834:	81122958 	cmpnei	r4,r16,18597
81122838:	81122958 	cmpnei	r4,r16,18597
8112283c:	81122958 	cmpnei	r4,r16,18597
81122840:	81122958 	cmpnei	r4,r16,18597
81122844:	81122958 	cmpnei	r4,r16,18597
81122848:	81122958 	cmpnei	r4,r16,18597
8112284c:	81122958 	cmpnei	r4,r16,18597
81122850:	81122958 	cmpnei	r4,r16,18597
81122854:	81122958 	cmpnei	r4,r16,18597
81122858:	81122958 	cmpnei	r4,r16,18597
8112285c:	811228e0 	cmpeqi	r4,r16,18595
81122860:	81122958 	cmpnei	r4,r16,18597
81122864:	81122958 	cmpnei	r4,r16,18597
81122868:	81122958 	cmpnei	r4,r16,18597
8112286c:	81122958 	cmpnei	r4,r16,18597
81122870:	81122958 	cmpnei	r4,r16,18597
81122874:	81122958 	cmpnei	r4,r16,18597
81122878:	81122958 	cmpnei	r4,r16,18597
8112287c:	81122958 	cmpnei	r4,r16,18597
81122880:	81122928 	cmpgeui	r4,r16,18596
81122884:	81122928 	cmpgeui	r4,r16,18596
81122888:	81122928 	cmpgeui	r4,r16,18596
8112288c:	81122928 	cmpgeui	r4,r16,18596
81122890:	81122928 	cmpgeui	r4,r16,18596
81122894:	81122928 	cmpgeui	r4,r16,18596
81122898:	81122958 	cmpnei	r4,r16,18597
8112289c:	81122958 	cmpnei	r4,r16,18597
811228a0:	81122958 	cmpnei	r4,r16,18597
811228a4:	81122958 	cmpnei	r4,r16,18597
811228a8:	81122958 	cmpnei	r4,r16,18597
811228ac:	81122958 	cmpnei	r4,r16,18597
811228b0:	81122958 	cmpnei	r4,r16,18597
811228b4:	81122958 	cmpnei	r4,r16,18597
811228b8:	81122958 	cmpnei	r4,r16,18597
811228bc:	81122958 	cmpnei	r4,r16,18597
811228c0:	81122958 	cmpnei	r4,r16,18597
811228c4:	81122958 	cmpnei	r4,r16,18597
811228c8:	81122958 	cmpnei	r4,r16,18597
811228cc:	81122958 	cmpnei	r4,r16,18597
811228d0:	81122958 	cmpnei	r4,r16,18597
811228d4:	81122958 	cmpnei	r4,r16,18597
811228d8:	81122958 	cmpnei	r4,r16,18597
811228dc:	811228e0 	cmpeqi	r4,r16,18595
811228e0:	9081800c 	andi	r2,r18,1536
811228e4:	12c01c1e 	bne	r2,r11,81122958 <__svfscanf_r+0x122c>
811228e8:	91a4703a 	and	r18,r18,r6
811228ec:	94814014 	ori	r18,r18,1280
811228f0:	04400404 	movi	r17,16
811228f4:	81000005 	stb	r4,0(r16)
811228f8:	84000044 	addi	r16,r16,1
811228fc:	e0800117 	ldw	r2,4(fp)
81122900:	10bfffc4 	addi	r2,r2,-1
81122904:	e0800115 	stw	r2,4(fp)
81122908:	0080540e 	bge	zero,r2,81122a5c <__svfscanf_r+0x1330>
8112290c:	18c00044 	addi	r3,r3,1
81122910:	e0c00015 	stw	r3,0(fp)
81122914:	9cffffc4 	addi	r19,r19,-1
81122918:	98000f26 	beq	r19,zero,81122958 <__svfscanf_r+0x122c>
8112291c:	e0c00017 	ldw	r3,0(fp)
81122920:	19000003 	ldbu	r4,0(r3)
81122924:	003f9706 	br	81122784 <__reset+0xfb102784>
81122928:	00800284 	movi	r2,10
8112292c:	14400a0e 	bge	r2,r17,81122958 <__svfscanf_r+0x122c>
81122930:	00bd1fc4 	movi	r2,-2945
81122934:	90a4703a 	and	r18,r18,r2
81122938:	003fee06 	br	811228f4 <__reset+0xfb1028f4>
8112293c:	01604574 	movhi	r5,33045
81122940:	8c63883a 	add	r17,r17,r17
81122944:	29699884 	addi	r5,r5,-22942
81122948:	2c45883a 	add	r2,r5,r17
8112294c:	1440000f 	ldh	r17,0(r2)
81122950:	00800204 	movi	r2,8
81122954:	147ff616 	blt	r2,r17,81122930 <__reset+0xfb102930>
81122958:	dc409e15 	stw	r17,632(sp)
8112295c:	9023883a 	mov	r17,r18
81122960:	8880400c 	andi	r2,r17,256
81122964:	4825883a 	mov	r18,r9
81122968:	10000426 	beq	r2,zero,8112297c <__svfscanf_r+0x1250>
8112296c:	d9800104 	addi	r6,sp,4
81122970:	3400be36 	bltu	r6,r16,81122c6c <__svfscanf_r+0x1540>
81122974:	da000104 	addi	r8,sp,4
81122978:	443bae26 	beq	r8,r16,81121834 <__reset+0xfb101834>
8112297c:	8880040c 	andi	r2,r17,16
81122980:	10009326 	beq	r2,zero,81122bd0 <__svfscanf_r+0x14a4>
81122984:	d8800104 	addi	r2,sp,4
81122988:	80a1c83a 	sub	r16,r16,r2
8112298c:	8521883a 	add	r16,r16,r20
81122990:	003d0606 	br	81121dac <__reset+0xfb101dac>
81122994:	01604574 	movhi	r5,33045
81122998:	8c63883a 	add	r17,r17,r17
8112299c:	29699884 	addi	r5,r5,-22942
811229a0:	2c45883a 	add	r2,r5,r17
811229a4:	1440000f 	ldh	r17,0(r2)
811229a8:	00bd1fc4 	movi	r2,-2945
811229ac:	90a4703a 	and	r18,r18,r2
811229b0:	003fd006 	br	811228f4 <__reset+0xfb1028f4>
811229b4:	9082000c 	andi	r2,r18,2048
811229b8:	103fce26 	beq	r2,zero,811228f4 <__reset+0xfb1028f4>
811229bc:	8800021e 	bne	r17,zero,811229c8 <__svfscanf_r+0x129c>
811229c0:	94808014 	ori	r18,r18,512
811229c4:	04400204 	movi	r17,8
811229c8:	9081000c 	andi	r2,r18,1024
811229cc:	10009426 	beq	r2,zero,81122c20 <__svfscanf_r+0x14f4>
811229d0:	00be9fc4 	movi	r2,-1409
811229d4:	90a4703a 	and	r18,r18,r2
811229d8:	003fc606 	br	811228f4 <__reset+0xfb1028f4>
811229dc:	9080200c 	andi	r2,r18,128
811229e0:	103fdd26 	beq	r2,zero,81122958 <__reset+0xfb102958>
811229e4:	9224703a 	and	r18,r18,r8
811229e8:	003fc206 	br	811228f4 <__reset+0xfb1028f4>
811229ec:	9800011e 	bne	r19,zero,811229f4 <__svfscanf_r+0x12c8>
811229f0:	04ffffc4 	movi	r19,-1
811229f4:	8900004c 	andi	r4,r17,1
811229f8:	20005b1e 	bne	r4,zero,81122b68 <__svfscanf_r+0x143c>
811229fc:	8c40040c 	andi	r17,r17,16
81122a00:	88003026 	beq	r17,zero,81122ac4 <__svfscanf_r+0x1398>
81122a04:	0021883a 	mov	r16,zero
81122a08:	00000306 	br	81122a18 <__svfscanf_r+0x12ec>
81122a0c:	18800003 	ldbu	r2,0(r3)
81122a10:	3885883a 	add	r2,r7,r2
81122a14:	10800043 	ldbu	r2,1(r2)
81122a18:	1080020c 	andi	r2,r2,8
81122a1c:	103ce31e 	bne	r2,zero,81121dac <__reset+0xfb101dac>
81122a20:	e0800117 	ldw	r2,4(fp)
81122a24:	18c00044 	addi	r3,r3,1
81122a28:	84000044 	addi	r16,r16,1
81122a2c:	10bfffc4 	addi	r2,r2,-1
81122a30:	e0800115 	stw	r2,4(fp)
81122a34:	e0c00015 	stw	r3,0(fp)
81122a38:	84fcdc26 	beq	r16,r19,81121dac <__reset+0xfb101dac>
81122a3c:	00bff316 	blt	zero,r2,81122a0c <__reset+0xfb102a0c>
81122a40:	e00b883a 	mov	r5,fp
81122a44:	b009883a 	mov	r4,r22
81122a48:	111ca0c0 	call	8111ca0c <__srefill_r>
81122a4c:	103cd71e 	bne	r2,zero,81121dac <__reset+0xfb101dac>
81122a50:	b9c00017 	ldw	r7,0(r23)
81122a54:	e0c00017 	ldw	r3,0(fp)
81122a58:	003fec06 	br	81122a0c <__reset+0xfb102a0c>
81122a5c:	e00b883a 	mov	r5,fp
81122a60:	b009883a 	mov	r4,r22
81122a64:	d980a715 	stw	r6,668(sp)
81122a68:	d9c0aa15 	stw	r7,680(sp)
81122a6c:	da00a815 	stw	r8,672(sp)
81122a70:	da40a915 	stw	r9,676(sp)
81122a74:	dac0a615 	stw	r11,664(sp)
81122a78:	111ca0c0 	call	8111ca0c <__srefill_r>
81122a7c:	d980a717 	ldw	r6,668(sp)
81122a80:	d9c0aa17 	ldw	r7,680(sp)
81122a84:	da00a817 	ldw	r8,672(sp)
81122a88:	da40a917 	ldw	r9,676(sp)
81122a8c:	dac0a617 	ldw	r11,664(sp)
81122a90:	103fa026 	beq	r2,zero,81122914 <__reset+0xfb102914>
81122a94:	003fb006 	br	81122958 <__reset+0xfb102958>
81122a98:	8821883a 	mov	r16,r17
81122a9c:	b019883a 	mov	r12,r22
81122aa0:	9823883a 	mov	r17,r19
81122aa4:	182d883a 	mov	r22,r3
81122aa8:	00bfbfc4 	movi	r2,-257
81122aac:	a0a8703a 	and	r20,r20,r2
81122ab0:	003e6706 	br	81122450 <__reset+0xfb102450>
81122ab4:	000f883a 	mov	r7,zero
81122ab8:	003f2806 	br	8112275c <__reset+0xfb10275c>
81122abc:	d800a215 	stw	zero,648(sp)
81122ac0:	003de306 	br	81122250 <__reset+0xfb102250>
81122ac4:	da009c17 	ldw	r8,624(sp)
81122ac8:	9abfffc4 	addi	r10,r19,-1
81122acc:	44400017 	ldw	r17,0(r8)
81122ad0:	44000104 	addi	r16,r8,4
81122ad4:	880b883a 	mov	r5,r17
81122ad8:	8aa9883a 	add	r20,r17,r10
81122adc:	00000606 	br	81122af8 <__svfscanf_r+0x13cc>
81122ae0:	e0c00017 	ldw	r3,0(fp)
81122ae4:	b9000017 	ldw	r4,0(r23)
81122ae8:	a80b883a 	mov	r5,r21
81122aec:	18800003 	ldbu	r2,0(r3)
81122af0:	2085883a 	add	r2,r4,r2
81122af4:	10800043 	ldbu	r2,1(r2)
81122af8:	1080020c 	andi	r2,r2,8
81122afc:	1000551e 	bne	r2,zero,81122c54 <__svfscanf_r+0x1528>
81122b00:	e0800117 	ldw	r2,4(fp)
81122b04:	19000044 	addi	r4,r3,1
81122b08:	e1000015 	stw	r4,0(fp)
81122b0c:	10bfffc4 	addi	r2,r2,-1
81122b10:	e0800115 	stw	r2,4(fp)
81122b14:	18800003 	ldbu	r2,0(r3)
81122b18:	2d400044 	addi	r21,r5,1
81122b1c:	a827883a 	mov	r19,r21
81122b20:	28800005 	stb	r2,0(r5)
81122b24:	2d000626 	beq	r5,r20,81122b40 <__svfscanf_r+0x1414>
81122b28:	e0800117 	ldw	r2,4(fp)
81122b2c:	00bfec16 	blt	zero,r2,81122ae0 <__reset+0xfb102ae0>
81122b30:	e00b883a 	mov	r5,fp
81122b34:	b009883a 	mov	r4,r22
81122b38:	111ca0c0 	call	8111ca0c <__srefill_r>
81122b3c:	103fe826 	beq	r2,zero,81122ae0 <__reset+0xfb102ae0>
81122b40:	da00a017 	ldw	r8,640(sp)
81122b44:	dd009d17 	ldw	r20,628(sp)
81122b48:	9c63c83a 	sub	r17,r19,r17
81122b4c:	42000044 	addi	r8,r8,1
81122b50:	98000005 	stb	zero,0(r19)
81122b54:	9465883a 	add	r18,r18,r17
81122b58:	da00a015 	stw	r8,640(sp)
81122b5c:	dc009c15 	stw	r16,624(sp)
81122b60:	a00d883a 	mov	r6,r20
81122b64:	003b2f06 	br	81121824 <__reset+0xfb101824>
81122b68:	dd409904 	addi	r21,sp,612
81122b6c:	8c40040c 	andi	r17,r17,16
81122b70:	01800204 	movi	r6,8
81122b74:	000b883a 	mov	r5,zero
81122b78:	a809883a 	mov	r4,r21
81122b7c:	111c5900 	call	8111c590 <memset>
81122b80:	8800401e 	bne	r17,zero,81122c84 <__svfscanf_r+0x1558>
81122b84:	da009c17 	ldw	r8,624(sp)
81122b88:	45000017 	ldw	r20,0(r8)
81122b8c:	42000104 	addi	r8,r8,4
81122b90:	da009c15 	stw	r8,624(sp)
81122b94:	000d883a 	mov	r6,zero
81122b98:	3021883a 	mov	r16,r6
81122b9c:	dc409f15 	stw	r17,636(sp)
81122ba0:	e0800017 	ldw	r2,0(fp)
81122ba4:	b8c00017 	ldw	r3,0(r23)
81122ba8:	10800003 	ldbu	r2,0(r2)
81122bac:	1885883a 	add	r2,r3,r2
81122bb0:	10800043 	ldbu	r2,1(r2)
81122bb4:	1080020c 	andi	r2,r2,8
81122bb8:	1000011e 	bne	r2,zero,81122bc0 <__svfscanf_r+0x1494>
81122bbc:	9800701e 	bne	r19,zero,81122d80 <__svfscanf_r+0x1654>
81122bc0:	dc409f17 	ldw	r17,636(sp)
81122bc4:	883cdd1e 	bne	r17,zero,81121f3c <__reset+0xfb101f3c>
81122bc8:	a0000015 	stw	zero,0(r20)
81122bcc:	003cd806 	br	81121f30 <__reset+0xfb101f30>
81122bd0:	d9c09e17 	ldw	r7,632(sp)
81122bd4:	da00a117 	ldw	r8,644(sp)
81122bd8:	000d883a 	mov	r6,zero
81122bdc:	d9400104 	addi	r5,sp,4
81122be0:	b009883a 	mov	r4,r22
81122be4:	80000005 	stb	zero,0(r16)
81122be8:	403ee83a 	callr	r8
81122bec:	88c0080c 	andi	r3,r17,32
81122bf0:	1800121e 	bne	r3,zero,81122c3c <__svfscanf_r+0x1510>
81122bf4:	88c0010c 	andi	r3,r17,4
81122bf8:	18004d26 	beq	r3,zero,81122d30 <__svfscanf_r+0x1604>
81122bfc:	da009c17 	ldw	r8,624(sp)
81122c00:	40c00017 	ldw	r3,0(r8)
81122c04:	42000104 	addi	r8,r8,4
81122c08:	da009c15 	stw	r8,624(sp)
81122c0c:	1880000d 	sth	r2,0(r3)
81122c10:	da00a017 	ldw	r8,640(sp)
81122c14:	42000044 	addi	r8,r8,1
81122c18:	da00a015 	stw	r8,640(sp)
81122c1c:	003f5906 	br	81122984 <__reset+0xfb102984>
81122c20:	00bf1fc4 	movi	r2,-897
81122c24:	90a4703a 	and	r18,r18,r2
81122c28:	38000226 	beq	r7,zero,81122c34 <__svfscanf_r+0x1508>
81122c2c:	39ffffc4 	addi	r7,r7,-1
81122c30:	9cc00044 	addi	r19,r19,1
81122c34:	a5000044 	addi	r20,r20,1
81122c38:	003f3006 	br	811228fc <__reset+0xfb1028fc>
81122c3c:	da009c17 	ldw	r8,624(sp)
81122c40:	40c00017 	ldw	r3,0(r8)
81122c44:	42000104 	addi	r8,r8,4
81122c48:	da009c15 	stw	r8,624(sp)
81122c4c:	18800015 	stw	r2,0(r3)
81122c50:	003fef06 	br	81122c10 <__reset+0xfb102c10>
81122c54:	2827883a 	mov	r19,r5
81122c58:	003fb906 	br	81122b40 <__reset+0xfb102b40>
81122c5c:	01be1fc4 	movi	r6,-1921
81122c60:	a1a8703a 	and	r20,r20,r6
81122c64:	05400044 	movi	r21,1
81122c68:	003de906 	br	81122410 <__reset+0xfb102410>
81122c6c:	817fffc7 	ldb	r5,-1(r16)
81122c70:	e00d883a 	mov	r6,fp
81122c74:	b009883a 	mov	r4,r22
81122c78:	843fffc4 	addi	r16,r16,-1
81122c7c:	112b3840 	call	8112b384 <_ungetc_r>
81122c80:	003f3c06 	br	81122974 <__reset+0xfb102974>
81122c84:	dd009b04 	addi	r20,sp,620
81122c88:	003fc206 	br	81122b94 <__reset+0xfb102b94>
81122c8c:	00be1fc4 	movi	r2,-1921
81122c90:	a0a8703a 	and	r20,r20,r2
81122c94:	05800044 	movi	r22,1
81122c98:	003ddd06 	br	81122410 <__reset+0xfb102410>
81122c9c:	d8c09f17 	ldw	r3,636(sp)
81122ca0:	88e3c83a 	sub	r17,r17,r3
81122ca4:	044dc83a 	sub	r6,zero,r17
81122ca8:	883e2126 	beq	r17,zero,81122530 <__reset+0xfb102530>
81122cac:	d88055c4 	addi	r2,sp,343
81122cb0:	80800136 	bltu	r16,r2,81122cb8 <__svfscanf_r+0x158c>
81122cb4:	dc005584 	addi	r16,sp,342
81122cb8:	01604574 	movhi	r5,33045
81122cbc:	29699704 	addi	r5,r5,-22948
81122cc0:	8009883a 	mov	r4,r16
81122cc4:	111cd200 	call	8111cd20 <sprintf>
81122cc8:	003e1906 	br	81122530 <__reset+0xfb102530>
81122ccc:	d8c0a517 	ldw	r3,660(sp)
81122cd0:	000d883a 	mov	r6,zero
81122cd4:	01c00284 	movi	r7,10
81122cd8:	19400044 	addi	r5,r3,1
81122cdc:	b009883a 	mov	r4,r22
81122ce0:	111d0100 	call	8111d010 <_strtol_r>
81122ce4:	da00a417 	ldw	r8,656(sp)
81122ce8:	dc00a517 	ldw	r16,660(sp)
81122cec:	120dc83a 	sub	r6,r2,r8
81122cf0:	003fee06 	br	81122cac <__reset+0xfb102cac>
81122cf4:	da009c17 	ldw	r8,624(sp)
81122cf8:	180b883a 	mov	r5,r3
81122cfc:	8009883a 	mov	r4,r16
81122d00:	45000017 	ldw	r20,0(r8)
81122d04:	44400104 	addi	r17,r8,4
81122d08:	d8c0a615 	stw	r3,664(sp)
81122d0c:	1127ca00 	call	81127ca0 <__fpclassifyd>
81122d10:	d8c0a617 	ldw	r3,664(sp)
81122d14:	10006426 	beq	r2,zero,81122ea8 <__svfscanf_r+0x177c>
81122d18:	8009883a 	mov	r4,r16
81122d1c:	180b883a 	mov	r5,r3
81122d20:	111b0280 	call	8111b028 <__truncdfsf2>
81122d24:	a0800015 	stw	r2,0(r20)
81122d28:	dc409c15 	stw	r17,624(sp)
81122d2c:	003e0f06 	br	8112256c <__reset+0xfb10256c>
81122d30:	88c0004c 	andi	r3,r17,1
81122d34:	183fc11e 	bne	r3,zero,81122c3c <__reset+0xfb102c3c>
81122d38:	8c40008c 	andi	r17,r17,2
81122d3c:	883fbf26 	beq	r17,zero,81122c3c <__reset+0xfb102c3c>
81122d40:	da00a117 	ldw	r8,644(sp)
81122d44:	00a044f4 	movhi	r2,33043
81122d48:	10a64f04 	addi	r2,r2,-26308
81122d4c:	d9c09e17 	ldw	r7,632(sp)
81122d50:	000d883a 	mov	r6,zero
81122d54:	d9400104 	addi	r5,sp,4
81122d58:	b009883a 	mov	r4,r22
81122d5c:	40806226 	beq	r8,r2,81122ee8 <__svfscanf_r+0x17bc>
81122d60:	11296540 	call	81129654 <_strtoll_r>
81122d64:	da009c17 	ldw	r8,624(sp)
81122d68:	41000017 	ldw	r4,0(r8)
81122d6c:	42000104 	addi	r8,r8,4
81122d70:	da009c15 	stw	r8,624(sp)
81122d74:	20800015 	stw	r2,0(r4)
81122d78:	20c00115 	stw	r3,4(r4)
81122d7c:	003fa406 	br	81122c10 <__reset+0xfb102c10>
81122d80:	11261300 	call	81126130 <__locale_mb_cur_max>
81122d84:	80bca726 	beq	r16,r2,81122024 <__reset+0xfb102024>
81122d88:	e0800017 	ldw	r2,0(fp)
81122d8c:	e1000117 	ldw	r4,4(fp)
81122d90:	d8c00104 	addi	r3,sp,4
81122d94:	12000003 	ldbu	r8,0(r2)
81122d98:	213fffc4 	addi	r4,r4,-1
81122d9c:	10800044 	addi	r2,r2,1
81122da0:	e1000115 	stw	r4,4(fp)
81122da4:	e0800015 	stw	r2,0(fp)
81122da8:	84400044 	addi	r17,r16,1
81122dac:	dd400015 	stw	r21,0(sp)
81122db0:	1c21883a 	add	r16,r3,r16
81122db4:	b009883a 	mov	r4,r22
81122db8:	880f883a 	mov	r7,r17
81122dbc:	180d883a 	mov	r6,r3
81122dc0:	a00b883a 	mov	r5,r20
81122dc4:	82000005 	stb	r8,0(r16)
81122dc8:	11261ec0 	call	811261ec <_mbrtowc_r>
81122dcc:	013fffc4 	movi	r4,-1
81122dd0:	113c9426 	beq	r2,r4,81122024 <__reset+0xfb102024>
81122dd4:	103c881e 	bne	r2,zero,81121ff8 <__reset+0xfb101ff8>
81122dd8:	a0000015 	stw	zero,0(r20)
81122ddc:	0009883a 	mov	r4,zero
81122de0:	11260700 	call	81126070 <iswspace>
81122de4:	10001a26 	beq	r2,zero,81122e50 <__svfscanf_r+0x1724>
81122de8:	8821883a 	mov	r16,r17
81122dec:	dc409f17 	ldw	r17,636(sp)
81122df0:	803f7426 	beq	r16,zero,81122bc4 <__reset+0xfb102bc4>
81122df4:	843fffc4 	addi	r16,r16,-1
81122df8:	d9800104 	addi	r6,sp,4
81122dfc:	342b883a 	add	r21,r6,r16
81122e00:	00000106 	br	81122e08 <__svfscanf_r+0x16dc>
81122e04:	843fffc4 	addi	r16,r16,-1
81122e08:	a9400003 	ldbu	r5,0(r21)
81122e0c:	e00d883a 	mov	r6,fp
81122e10:	b009883a 	mov	r4,r22
81122e14:	112b3840 	call	8112b384 <_ungetc_r>
81122e18:	ad7fffc4 	addi	r21,r21,-1
81122e1c:	803ff91e 	bne	r16,zero,81122e04 <__reset+0xfb102e04>
81122e20:	003f6806 	br	81122bc4 <__reset+0xfb102bc4>
81122e24:	d9800104 	addi	r6,sp,4
81122e28:	802b883a 	mov	r21,r16
81122e2c:	343a812e 	bgeu	r6,r16,81121834 <__reset+0xfb101834>
81122e30:	ad7fffc4 	addi	r21,r21,-1
81122e34:	a9400007 	ldb	r5,0(r21)
81122e38:	e00d883a 	mov	r6,fp
81122e3c:	b009883a 	mov	r4,r22
81122e40:	112b3840 	call	8112b384 <_ungetc_r>
81122e44:	da000104 	addi	r8,sp,4
81122e48:	457ff91e 	bne	r8,r21,81122e30 <__reset+0xfb102e30>
81122e4c:	003a7906 	br	81121834 <__reset+0xfb101834>
81122e50:	da009f17 	ldw	r8,636(sp)
81122e54:	9465883a 	add	r18,r18,r17
81122e58:	9cffffc4 	addi	r19,r19,-1
81122e5c:	4000051e 	bne	r8,zero,81122e74 <__svfscanf_r+0x1748>
81122e60:	a5000104 	addi	r20,r20,4
81122e64:	0021883a 	mov	r16,zero
81122e68:	003c6606 	br	81122004 <__reset+0xfb102004>
81122e6c:	a1000017 	ldw	r4,0(r20)
81122e70:	003fdb06 	br	81122de0 <__reset+0xfb102de0>
81122e74:	0021883a 	mov	r16,zero
81122e78:	003c6206 	br	81122004 <__reset+0xfb102004>
81122e7c:	d8800104 	addi	r2,sp,4
81122e80:	802b883a 	mov	r21,r16
81122e84:	143a6b2e 	bgeu	r2,r16,81121834 <__reset+0xfb101834>
81122e88:	ad7fffc4 	addi	r21,r21,-1
81122e8c:	a9400007 	ldb	r5,0(r21)
81122e90:	e00d883a 	mov	r6,fp
81122e94:	b009883a 	mov	r4,r22
81122e98:	112b3840 	call	8112b384 <_ungetc_r>
81122e9c:	d8c00104 	addi	r3,sp,4
81122ea0:	1d7ff91e 	bne	r3,r21,81122e88 <__reset+0xfb102e88>
81122ea4:	003a6306 	br	81121834 <__reset+0xfb101834>
81122ea8:	0009883a 	mov	r4,zero
81122eac:	1127de40 	call	81127de4 <nanf>
81122eb0:	a0800015 	stw	r2,0(r20)
81122eb4:	dc409c15 	stw	r17,624(sp)
81122eb8:	003dac06 	br	8112256c <__reset+0xfb10256c>
81122ebc:	d9000104 	addi	r4,sp,4
81122ec0:	802b883a 	mov	r21,r16
81122ec4:	243a5b2e 	bgeu	r4,r16,81121834 <__reset+0xfb101834>
81122ec8:	ad7fffc4 	addi	r21,r21,-1
81122ecc:	a9400007 	ldb	r5,0(r21)
81122ed0:	e00d883a 	mov	r6,fp
81122ed4:	b009883a 	mov	r4,r22
81122ed8:	112b3840 	call	8112b384 <_ungetc_r>
81122edc:	d9400104 	addi	r5,sp,4
81122ee0:	2d7ff91e 	bne	r5,r21,81122ec8 <__reset+0xfb102ec8>
81122ee4:	003a5306 	br	81121834 <__reset+0xfb101834>
81122ee8:	1129bac0 	call	81129bac <_strtoull_r>
81122eec:	003f9d06 	br	81122d64 <__reset+0xfb102d64>

81122ef0 <vfscanf>:
81122ef0:	00a04574 	movhi	r2,33045
81122ef4:	defffb04 	addi	sp,sp,-20
81122ef8:	10b34e04 	addi	r2,r2,-13000
81122efc:	de00012e 	bgeu	sp,et,81122f04 <vfscanf+0x14>
81122f00:	003b68fa 	trap	3
81122f04:	dc000215 	stw	r16,8(sp)
81122f08:	14000017 	ldw	r16,0(r2)
81122f0c:	dc400315 	stw	r17,12(sp)
81122f10:	dfc00415 	stw	ra,16(sp)
81122f14:	2023883a 	mov	r17,r4
81122f18:	80000826 	beq	r16,zero,81122f3c <vfscanf+0x4c>
81122f1c:	80800e17 	ldw	r2,56(r16)
81122f20:	1000061e 	bne	r2,zero,81122f3c <vfscanf+0x4c>
81122f24:	8009883a 	mov	r4,r16
81122f28:	d9400015 	stw	r5,0(sp)
81122f2c:	d9800115 	stw	r6,4(sp)
81122f30:	11252080 	call	81125208 <__sinit>
81122f34:	d9800117 	ldw	r6,4(sp)
81122f38:	d9400017 	ldw	r5,0(sp)
81122f3c:	300f883a 	mov	r7,r6
81122f40:	8009883a 	mov	r4,r16
81122f44:	280d883a 	mov	r6,r5
81122f48:	880b883a 	mov	r5,r17
81122f4c:	dfc00417 	ldw	ra,16(sp)
81122f50:	dc400317 	ldw	r17,12(sp)
81122f54:	dc000217 	ldw	r16,8(sp)
81122f58:	dec00504 	addi	sp,sp,20
81122f5c:	112172c1 	jmpi	8112172c <__svfscanf_r>

81122f60 <__svfscanf>:
81122f60:	00a04574 	movhi	r2,33045
81122f64:	10b34e04 	addi	r2,r2,-13000
81122f68:	300f883a 	mov	r7,r6
81122f6c:	280d883a 	mov	r6,r5
81122f70:	200b883a 	mov	r5,r4
81122f74:	11000017 	ldw	r4,0(r2)
81122f78:	112172c1 	jmpi	8112172c <__svfscanf_r>

81122f7c <_vfscanf_r>:
81122f7c:	defffb04 	addi	sp,sp,-20
81122f80:	de00012e 	bgeu	sp,et,81122f88 <_vfscanf_r+0xc>
81122f84:	003b68fa 	trap	3
81122f88:	dc000315 	stw	r16,12(sp)
81122f8c:	dfc00415 	stw	ra,16(sp)
81122f90:	2021883a 	mov	r16,r4
81122f94:	20000926 	beq	r4,zero,81122fbc <_vfscanf_r+0x40>
81122f98:	20800e17 	ldw	r2,56(r4)
81122f9c:	1000071e 	bne	r2,zero,81122fbc <_vfscanf_r+0x40>
81122fa0:	d9400015 	stw	r5,0(sp)
81122fa4:	d9800115 	stw	r6,4(sp)
81122fa8:	d9c00215 	stw	r7,8(sp)
81122fac:	11252080 	call	81125208 <__sinit>
81122fb0:	d9c00217 	ldw	r7,8(sp)
81122fb4:	d9800117 	ldw	r6,4(sp)
81122fb8:	d9400017 	ldw	r5,0(sp)
81122fbc:	8009883a 	mov	r4,r16
81122fc0:	dfc00417 	ldw	ra,16(sp)
81122fc4:	dc000317 	ldw	r16,12(sp)
81122fc8:	dec00504 	addi	sp,sp,20
81122fcc:	112172c1 	jmpi	8112172c <__svfscanf_r>

81122fd0 <__swbuf_r>:
81122fd0:	defffb04 	addi	sp,sp,-20
81122fd4:	de00012e 	bgeu	sp,et,81122fdc <__swbuf_r+0xc>
81122fd8:	003b68fa 	trap	3
81122fdc:	dcc00315 	stw	r19,12(sp)
81122fe0:	dc800215 	stw	r18,8(sp)
81122fe4:	dc000015 	stw	r16,0(sp)
81122fe8:	dfc00415 	stw	ra,16(sp)
81122fec:	dc400115 	stw	r17,4(sp)
81122ff0:	2025883a 	mov	r18,r4
81122ff4:	2827883a 	mov	r19,r5
81122ff8:	3021883a 	mov	r16,r6
81122ffc:	20000226 	beq	r4,zero,81123008 <__swbuf_r+0x38>
81123000:	20800e17 	ldw	r2,56(r4)
81123004:	10004226 	beq	r2,zero,81123110 <__swbuf_r+0x140>
81123008:	80800617 	ldw	r2,24(r16)
8112300c:	8100030b 	ldhu	r4,12(r16)
81123010:	80800215 	stw	r2,8(r16)
81123014:	2080020c 	andi	r2,r4,8
81123018:	10003626 	beq	r2,zero,811230f4 <__swbuf_r+0x124>
8112301c:	80c00417 	ldw	r3,16(r16)
81123020:	18003426 	beq	r3,zero,811230f4 <__swbuf_r+0x124>
81123024:	2088000c 	andi	r2,r4,8192
81123028:	9c403fcc 	andi	r17,r19,255
8112302c:	10001a26 	beq	r2,zero,81123098 <__swbuf_r+0xc8>
81123030:	80800017 	ldw	r2,0(r16)
81123034:	81000517 	ldw	r4,20(r16)
81123038:	10c7c83a 	sub	r3,r2,r3
8112303c:	1900200e 	bge	r3,r4,811230c0 <__swbuf_r+0xf0>
81123040:	18c00044 	addi	r3,r3,1
81123044:	81000217 	ldw	r4,8(r16)
81123048:	11400044 	addi	r5,r2,1
8112304c:	81400015 	stw	r5,0(r16)
81123050:	213fffc4 	addi	r4,r4,-1
81123054:	81000215 	stw	r4,8(r16)
81123058:	14c00005 	stb	r19,0(r2)
8112305c:	80800517 	ldw	r2,20(r16)
81123060:	10c01e26 	beq	r2,r3,811230dc <__swbuf_r+0x10c>
81123064:	8080030b 	ldhu	r2,12(r16)
81123068:	1080004c 	andi	r2,r2,1
8112306c:	10000226 	beq	r2,zero,81123078 <__swbuf_r+0xa8>
81123070:	00800284 	movi	r2,10
81123074:	88801926 	beq	r17,r2,811230dc <__swbuf_r+0x10c>
81123078:	8805883a 	mov	r2,r17
8112307c:	dfc00417 	ldw	ra,16(sp)
81123080:	dcc00317 	ldw	r19,12(sp)
81123084:	dc800217 	ldw	r18,8(sp)
81123088:	dc400117 	ldw	r17,4(sp)
8112308c:	dc000017 	ldw	r16,0(sp)
81123090:	dec00504 	addi	sp,sp,20
81123094:	f800283a 	ret
81123098:	81401917 	ldw	r5,100(r16)
8112309c:	00b7ffc4 	movi	r2,-8193
811230a0:	21080014 	ori	r4,r4,8192
811230a4:	2884703a 	and	r2,r5,r2
811230a8:	80801915 	stw	r2,100(r16)
811230ac:	80800017 	ldw	r2,0(r16)
811230b0:	8100030d 	sth	r4,12(r16)
811230b4:	81000517 	ldw	r4,20(r16)
811230b8:	10c7c83a 	sub	r3,r2,r3
811230bc:	193fe016 	blt	r3,r4,81123040 <__reset+0xfb103040>
811230c0:	800b883a 	mov	r5,r16
811230c4:	9009883a 	mov	r4,r18
811230c8:	1124e0c0 	call	81124e0c <_fflush_r>
811230cc:	1000071e 	bne	r2,zero,811230ec <__swbuf_r+0x11c>
811230d0:	80800017 	ldw	r2,0(r16)
811230d4:	00c00044 	movi	r3,1
811230d8:	003fda06 	br	81123044 <__reset+0xfb103044>
811230dc:	800b883a 	mov	r5,r16
811230e0:	9009883a 	mov	r4,r18
811230e4:	1124e0c0 	call	81124e0c <_fflush_r>
811230e8:	103fe326 	beq	r2,zero,81123078 <__reset+0xfb103078>
811230ec:	00bfffc4 	movi	r2,-1
811230f0:	003fe206 	br	8112307c <__reset+0xfb10307c>
811230f4:	800b883a 	mov	r5,r16
811230f8:	9009883a 	mov	r4,r18
811230fc:	11231980 	call	81123198 <__swsetup_r>
81123100:	103ffa1e 	bne	r2,zero,811230ec <__reset+0xfb1030ec>
81123104:	8100030b 	ldhu	r4,12(r16)
81123108:	80c00417 	ldw	r3,16(r16)
8112310c:	003fc506 	br	81123024 <__reset+0xfb103024>
81123110:	11252080 	call	81125208 <__sinit>
81123114:	003fbc06 	br	81123008 <__reset+0xfb103008>

81123118 <__swbuf>:
81123118:	00a04574 	movhi	r2,33045
8112311c:	10b34e04 	addi	r2,r2,-13000
81123120:	280d883a 	mov	r6,r5
81123124:	200b883a 	mov	r5,r4
81123128:	11000017 	ldw	r4,0(r2)
8112312c:	1122fd01 	jmpi	81122fd0 <__swbuf_r>

81123130 <_write_r>:
81123130:	defffd04 	addi	sp,sp,-12
81123134:	de00012e 	bgeu	sp,et,8112313c <_write_r+0xc>
81123138:	003b68fa 	trap	3
8112313c:	2805883a 	mov	r2,r5
81123140:	dc000015 	stw	r16,0(sp)
81123144:	04204574 	movhi	r16,33045
81123148:	dc400115 	stw	r17,4(sp)
8112314c:	300b883a 	mov	r5,r6
81123150:	8433bb04 	addi	r16,r16,-12564
81123154:	2023883a 	mov	r17,r4
81123158:	380d883a 	mov	r6,r7
8112315c:	1009883a 	mov	r4,r2
81123160:	dfc00215 	stw	ra,8(sp)
81123164:	80000015 	stw	zero,0(r16)
81123168:	11327e80 	call	811327e8 <write>
8112316c:	00ffffc4 	movi	r3,-1
81123170:	10c00526 	beq	r2,r3,81123188 <_write_r+0x58>
81123174:	dfc00217 	ldw	ra,8(sp)
81123178:	dc400117 	ldw	r17,4(sp)
8112317c:	dc000017 	ldw	r16,0(sp)
81123180:	dec00304 	addi	sp,sp,12
81123184:	f800283a 	ret
81123188:	80c00017 	ldw	r3,0(r16)
8112318c:	183ff926 	beq	r3,zero,81123174 <__reset+0xfb103174>
81123190:	88c00015 	stw	r3,0(r17)
81123194:	003ff706 	br	81123174 <__reset+0xfb103174>

81123198 <__swsetup_r>:
81123198:	00a04574 	movhi	r2,33045
8112319c:	defffd04 	addi	sp,sp,-12
811231a0:	10b34e04 	addi	r2,r2,-13000
811231a4:	de00012e 	bgeu	sp,et,811231ac <__swsetup_r+0x14>
811231a8:	003b68fa 	trap	3
811231ac:	dc400115 	stw	r17,4(sp)
811231b0:	2023883a 	mov	r17,r4
811231b4:	11000017 	ldw	r4,0(r2)
811231b8:	dc000015 	stw	r16,0(sp)
811231bc:	dfc00215 	stw	ra,8(sp)
811231c0:	2821883a 	mov	r16,r5
811231c4:	20000226 	beq	r4,zero,811231d0 <__swsetup_r+0x38>
811231c8:	20800e17 	ldw	r2,56(r4)
811231cc:	10003126 	beq	r2,zero,81123294 <__swsetup_r+0xfc>
811231d0:	8080030b 	ldhu	r2,12(r16)
811231d4:	10c0020c 	andi	r3,r2,8
811231d8:	1009883a 	mov	r4,r2
811231dc:	18000f26 	beq	r3,zero,8112321c <__swsetup_r+0x84>
811231e0:	80c00417 	ldw	r3,16(r16)
811231e4:	18001526 	beq	r3,zero,8112323c <__swsetup_r+0xa4>
811231e8:	1100004c 	andi	r4,r2,1
811231ec:	20001c1e 	bne	r4,zero,81123260 <__swsetup_r+0xc8>
811231f0:	1080008c 	andi	r2,r2,2
811231f4:	1000291e 	bne	r2,zero,8112329c <__swsetup_r+0x104>
811231f8:	80800517 	ldw	r2,20(r16)
811231fc:	80800215 	stw	r2,8(r16)
81123200:	18001c26 	beq	r3,zero,81123274 <__swsetup_r+0xdc>
81123204:	0005883a 	mov	r2,zero
81123208:	dfc00217 	ldw	ra,8(sp)
8112320c:	dc400117 	ldw	r17,4(sp)
81123210:	dc000017 	ldw	r16,0(sp)
81123214:	dec00304 	addi	sp,sp,12
81123218:	f800283a 	ret
8112321c:	2080040c 	andi	r2,r4,16
81123220:	10002e26 	beq	r2,zero,811232dc <__swsetup_r+0x144>
81123224:	2080010c 	andi	r2,r4,4
81123228:	10001e1e 	bne	r2,zero,811232a4 <__swsetup_r+0x10c>
8112322c:	80c00417 	ldw	r3,16(r16)
81123230:	20800214 	ori	r2,r4,8
81123234:	8080030d 	sth	r2,12(r16)
81123238:	183feb1e 	bne	r3,zero,811231e8 <__reset+0xfb1031e8>
8112323c:	1100a00c 	andi	r4,r2,640
81123240:	01408004 	movi	r5,512
81123244:	217fe826 	beq	r4,r5,811231e8 <__reset+0xfb1031e8>
81123248:	800b883a 	mov	r5,r16
8112324c:	8809883a 	mov	r4,r17
81123250:	111ba680 	call	8111ba68 <__smakebuf_r>
81123254:	8080030b 	ldhu	r2,12(r16)
81123258:	80c00417 	ldw	r3,16(r16)
8112325c:	003fe206 	br	811231e8 <__reset+0xfb1031e8>
81123260:	80800517 	ldw	r2,20(r16)
81123264:	80000215 	stw	zero,8(r16)
81123268:	0085c83a 	sub	r2,zero,r2
8112326c:	80800615 	stw	r2,24(r16)
81123270:	183fe41e 	bne	r3,zero,81123204 <__reset+0xfb103204>
81123274:	80c0030b 	ldhu	r3,12(r16)
81123278:	0005883a 	mov	r2,zero
8112327c:	1900200c 	andi	r4,r3,128
81123280:	203fe126 	beq	r4,zero,81123208 <__reset+0xfb103208>
81123284:	18c01014 	ori	r3,r3,64
81123288:	80c0030d 	sth	r3,12(r16)
8112328c:	00bfffc4 	movi	r2,-1
81123290:	003fdd06 	br	81123208 <__reset+0xfb103208>
81123294:	11252080 	call	81125208 <__sinit>
81123298:	003fcd06 	br	811231d0 <__reset+0xfb1031d0>
8112329c:	0005883a 	mov	r2,zero
811232a0:	003fd606 	br	811231fc <__reset+0xfb1031fc>
811232a4:	81400c17 	ldw	r5,48(r16)
811232a8:	28000626 	beq	r5,zero,811232c4 <__swsetup_r+0x12c>
811232ac:	80801004 	addi	r2,r16,64
811232b0:	28800326 	beq	r5,r2,811232c0 <__swsetup_r+0x128>
811232b4:	8809883a 	mov	r4,r17
811232b8:	11256a00 	call	811256a0 <_free_r>
811232bc:	8100030b 	ldhu	r4,12(r16)
811232c0:	80000c15 	stw	zero,48(r16)
811232c4:	80c00417 	ldw	r3,16(r16)
811232c8:	00bff6c4 	movi	r2,-37
811232cc:	1108703a 	and	r4,r2,r4
811232d0:	80000115 	stw	zero,4(r16)
811232d4:	80c00015 	stw	r3,0(r16)
811232d8:	003fd506 	br	81123230 <__reset+0xfb103230>
811232dc:	00800244 	movi	r2,9
811232e0:	88800015 	stw	r2,0(r17)
811232e4:	20801014 	ori	r2,r4,64
811232e8:	8080030d 	sth	r2,12(r16)
811232ec:	00bfffc4 	movi	r2,-1
811232f0:	003fc506 	br	81123208 <__reset+0xfb103208>

811232f4 <_close_r>:
811232f4:	defffd04 	addi	sp,sp,-12
811232f8:	de00012e 	bgeu	sp,et,81123300 <_close_r+0xc>
811232fc:	003b68fa 	trap	3
81123300:	dc000015 	stw	r16,0(sp)
81123304:	04204574 	movhi	r16,33045
81123308:	dc400115 	stw	r17,4(sp)
8112330c:	8433bb04 	addi	r16,r16,-12564
81123310:	2023883a 	mov	r17,r4
81123314:	2809883a 	mov	r4,r5
81123318:	dfc00215 	stw	ra,8(sp)
8112331c:	80000015 	stw	zero,0(r16)
81123320:	1130d680 	call	81130d68 <close>
81123324:	00ffffc4 	movi	r3,-1
81123328:	10c00526 	beq	r2,r3,81123340 <_close_r+0x4c>
8112332c:	dfc00217 	ldw	ra,8(sp)
81123330:	dc400117 	ldw	r17,4(sp)
81123334:	dc000017 	ldw	r16,0(sp)
81123338:	dec00304 	addi	sp,sp,12
8112333c:	f800283a 	ret
81123340:	80c00017 	ldw	r3,0(r16)
81123344:	183ff926 	beq	r3,zero,8112332c <__reset+0xfb10332c>
81123348:	88c00015 	stw	r3,0(r17)
8112334c:	003ff706 	br	8112332c <__reset+0xfb10332c>

81123350 <quorem>:
81123350:	defff704 	addi	sp,sp,-36
81123354:	de00012e 	bgeu	sp,et,8112335c <quorem+0xc>
81123358:	003b68fa 	trap	3
8112335c:	dc800215 	stw	r18,8(sp)
81123360:	20800417 	ldw	r2,16(r4)
81123364:	2c800417 	ldw	r18,16(r5)
81123368:	dfc00815 	stw	ra,32(sp)
8112336c:	ddc00715 	stw	r23,28(sp)
81123370:	dd800615 	stw	r22,24(sp)
81123374:	dd400515 	stw	r21,20(sp)
81123378:	dd000415 	stw	r20,16(sp)
8112337c:	dcc00315 	stw	r19,12(sp)
81123380:	dc400115 	stw	r17,4(sp)
81123384:	dc000015 	stw	r16,0(sp)
81123388:	14807116 	blt	r2,r18,81123550 <quorem+0x200>
8112338c:	94bfffc4 	addi	r18,r18,-1
81123390:	94ad883a 	add	r22,r18,r18
81123394:	b5ad883a 	add	r22,r22,r22
81123398:	2c400504 	addi	r17,r5,20
8112339c:	8da9883a 	add	r20,r17,r22
811233a0:	25400504 	addi	r21,r4,20
811233a4:	282f883a 	mov	r23,r5
811233a8:	adad883a 	add	r22,r21,r22
811233ac:	a1400017 	ldw	r5,0(r20)
811233b0:	2021883a 	mov	r16,r4
811233b4:	b1000017 	ldw	r4,0(r22)
811233b8:	29400044 	addi	r5,r5,1
811233bc:	112ea280 	call	8112ea28 <__udivsi3>
811233c0:	1027883a 	mov	r19,r2
811233c4:	10002c26 	beq	r2,zero,81123478 <quorem+0x128>
811233c8:	a813883a 	mov	r9,r21
811233cc:	880b883a 	mov	r5,r17
811233d0:	0009883a 	mov	r4,zero
811233d4:	000d883a 	mov	r6,zero
811233d8:	2a000017 	ldw	r8,0(r5)
811233dc:	49c00017 	ldw	r7,0(r9)
811233e0:	29400104 	addi	r5,r5,4
811233e4:	40bfffcc 	andi	r2,r8,65535
811233e8:	14c5383a 	mul	r2,r2,r19
811233ec:	4010d43a 	srli	r8,r8,16
811233f0:	38ffffcc 	andi	r3,r7,65535
811233f4:	1105883a 	add	r2,r2,r4
811233f8:	1008d43a 	srli	r4,r2,16
811233fc:	44d1383a 	mul	r8,r8,r19
81123400:	198d883a 	add	r6,r3,r6
81123404:	10ffffcc 	andi	r3,r2,65535
81123408:	30c7c83a 	sub	r3,r6,r3
8112340c:	380ed43a 	srli	r7,r7,16
81123410:	4105883a 	add	r2,r8,r4
81123414:	180dd43a 	srai	r6,r3,16
81123418:	113fffcc 	andi	r4,r2,65535
8112341c:	390fc83a 	sub	r7,r7,r4
81123420:	398d883a 	add	r6,r7,r6
81123424:	300e943a 	slli	r7,r6,16
81123428:	18ffffcc 	andi	r3,r3,65535
8112342c:	1008d43a 	srli	r4,r2,16
81123430:	38ceb03a 	or	r7,r7,r3
81123434:	49c00015 	stw	r7,0(r9)
81123438:	300dd43a 	srai	r6,r6,16
8112343c:	4a400104 	addi	r9,r9,4
81123440:	a17fe52e 	bgeu	r20,r5,811233d8 <__reset+0xfb1033d8>
81123444:	b0800017 	ldw	r2,0(r22)
81123448:	10000b1e 	bne	r2,zero,81123478 <quorem+0x128>
8112344c:	b0bfff04 	addi	r2,r22,-4
81123450:	a880082e 	bgeu	r21,r2,81123474 <quorem+0x124>
81123454:	b0ffff17 	ldw	r3,-4(r22)
81123458:	18000326 	beq	r3,zero,81123468 <quorem+0x118>
8112345c:	00000506 	br	81123474 <quorem+0x124>
81123460:	10c00017 	ldw	r3,0(r2)
81123464:	1800031e 	bne	r3,zero,81123474 <quorem+0x124>
81123468:	10bfff04 	addi	r2,r2,-4
8112346c:	94bfffc4 	addi	r18,r18,-1
81123470:	a8bffb36 	bltu	r21,r2,81123460 <__reset+0xfb103460>
81123474:	84800415 	stw	r18,16(r16)
81123478:	b80b883a 	mov	r5,r23
8112347c:	8009883a 	mov	r4,r16
81123480:	1126f700 	call	81126f70 <__mcmp>
81123484:	10002616 	blt	r2,zero,81123520 <quorem+0x1d0>
81123488:	9cc00044 	addi	r19,r19,1
8112348c:	a805883a 	mov	r2,r21
81123490:	000b883a 	mov	r5,zero
81123494:	11000017 	ldw	r4,0(r2)
81123498:	89800017 	ldw	r6,0(r17)
8112349c:	10800104 	addi	r2,r2,4
811234a0:	20ffffcc 	andi	r3,r4,65535
811234a4:	194b883a 	add	r5,r3,r5
811234a8:	30ffffcc 	andi	r3,r6,65535
811234ac:	28c7c83a 	sub	r3,r5,r3
811234b0:	300cd43a 	srli	r6,r6,16
811234b4:	2008d43a 	srli	r4,r4,16
811234b8:	180bd43a 	srai	r5,r3,16
811234bc:	18ffffcc 	andi	r3,r3,65535
811234c0:	2189c83a 	sub	r4,r4,r6
811234c4:	2149883a 	add	r4,r4,r5
811234c8:	200c943a 	slli	r6,r4,16
811234cc:	8c400104 	addi	r17,r17,4
811234d0:	200bd43a 	srai	r5,r4,16
811234d4:	30c6b03a 	or	r3,r6,r3
811234d8:	10ffff15 	stw	r3,-4(r2)
811234dc:	a47fed2e 	bgeu	r20,r17,81123494 <__reset+0xfb103494>
811234e0:	9485883a 	add	r2,r18,r18
811234e4:	1085883a 	add	r2,r2,r2
811234e8:	a887883a 	add	r3,r21,r2
811234ec:	18800017 	ldw	r2,0(r3)
811234f0:	10000b1e 	bne	r2,zero,81123520 <quorem+0x1d0>
811234f4:	18bfff04 	addi	r2,r3,-4
811234f8:	a880082e 	bgeu	r21,r2,8112351c <quorem+0x1cc>
811234fc:	18ffff17 	ldw	r3,-4(r3)
81123500:	18000326 	beq	r3,zero,81123510 <quorem+0x1c0>
81123504:	00000506 	br	8112351c <quorem+0x1cc>
81123508:	10c00017 	ldw	r3,0(r2)
8112350c:	1800031e 	bne	r3,zero,8112351c <quorem+0x1cc>
81123510:	10bfff04 	addi	r2,r2,-4
81123514:	94bfffc4 	addi	r18,r18,-1
81123518:	a8bffb36 	bltu	r21,r2,81123508 <__reset+0xfb103508>
8112351c:	84800415 	stw	r18,16(r16)
81123520:	9805883a 	mov	r2,r19
81123524:	dfc00817 	ldw	ra,32(sp)
81123528:	ddc00717 	ldw	r23,28(sp)
8112352c:	dd800617 	ldw	r22,24(sp)
81123530:	dd400517 	ldw	r21,20(sp)
81123534:	dd000417 	ldw	r20,16(sp)
81123538:	dcc00317 	ldw	r19,12(sp)
8112353c:	dc800217 	ldw	r18,8(sp)
81123540:	dc400117 	ldw	r17,4(sp)
81123544:	dc000017 	ldw	r16,0(sp)
81123548:	dec00904 	addi	sp,sp,36
8112354c:	f800283a 	ret
81123550:	0005883a 	mov	r2,zero
81123554:	003ff306 	br	81123524 <__reset+0xfb103524>

81123558 <_dtoa_r>:
81123558:	deffde04 	addi	sp,sp,-136
8112355c:	de00012e 	bgeu	sp,et,81123564 <_dtoa_r+0xc>
81123560:	003b68fa 	trap	3
81123564:	20801017 	ldw	r2,64(r4)
81123568:	df002015 	stw	fp,128(sp)
8112356c:	dcc01b15 	stw	r19,108(sp)
81123570:	dc801a15 	stw	r18,104(sp)
81123574:	dc401915 	stw	r17,100(sp)
81123578:	dc001815 	stw	r16,96(sp)
8112357c:	dfc02115 	stw	ra,132(sp)
81123580:	ddc01f15 	stw	r23,124(sp)
81123584:	dd801e15 	stw	r22,120(sp)
81123588:	dd401d15 	stw	r21,116(sp)
8112358c:	dd001c15 	stw	r20,112(sp)
81123590:	d9c00315 	stw	r7,12(sp)
81123594:	2039883a 	mov	fp,r4
81123598:	3023883a 	mov	r17,r6
8112359c:	2825883a 	mov	r18,r5
811235a0:	dc002417 	ldw	r16,144(sp)
811235a4:	3027883a 	mov	r19,r6
811235a8:	10000826 	beq	r2,zero,811235cc <_dtoa_r+0x74>
811235ac:	21801117 	ldw	r6,68(r4)
811235b0:	00c00044 	movi	r3,1
811235b4:	100b883a 	mov	r5,r2
811235b8:	1986983a 	sll	r3,r3,r6
811235bc:	11800115 	stw	r6,4(r2)
811235c0:	10c00215 	stw	r3,8(r2)
811235c4:	11267200 	call	81126720 <_Bfree>
811235c8:	e0001015 	stw	zero,64(fp)
811235cc:	88002e16 	blt	r17,zero,81123688 <_dtoa_r+0x130>
811235d0:	80000015 	stw	zero,0(r16)
811235d4:	889ffc2c 	andhi	r2,r17,32752
811235d8:	00dffc34 	movhi	r3,32752
811235dc:	10c01c26 	beq	r2,r3,81123650 <_dtoa_r+0xf8>
811235e0:	000d883a 	mov	r6,zero
811235e4:	000f883a 	mov	r7,zero
811235e8:	9009883a 	mov	r4,r18
811235ec:	980b883a 	mov	r5,r19
811235f0:	112fe840 	call	8112fe84 <__eqdf2>
811235f4:	10002b1e 	bne	r2,zero,811236a4 <_dtoa_r+0x14c>
811235f8:	d9c02317 	ldw	r7,140(sp)
811235fc:	00800044 	movi	r2,1
81123600:	38800015 	stw	r2,0(r7)
81123604:	d8802517 	ldw	r2,148(sp)
81123608:	10019e26 	beq	r2,zero,81123c84 <_dtoa_r+0x72c>
8112360c:	d8c02517 	ldw	r3,148(sp)
81123610:	00a04574 	movhi	r2,33045
81123614:	10a98644 	addi	r2,r2,-23015
81123618:	18800015 	stw	r2,0(r3)
8112361c:	10bfffc4 	addi	r2,r2,-1
81123620:	dfc02117 	ldw	ra,132(sp)
81123624:	df002017 	ldw	fp,128(sp)
81123628:	ddc01f17 	ldw	r23,124(sp)
8112362c:	dd801e17 	ldw	r22,120(sp)
81123630:	dd401d17 	ldw	r21,116(sp)
81123634:	dd001c17 	ldw	r20,112(sp)
81123638:	dcc01b17 	ldw	r19,108(sp)
8112363c:	dc801a17 	ldw	r18,104(sp)
81123640:	dc401917 	ldw	r17,100(sp)
81123644:	dc001817 	ldw	r16,96(sp)
81123648:	dec02204 	addi	sp,sp,136
8112364c:	f800283a 	ret
81123650:	d8c02317 	ldw	r3,140(sp)
81123654:	0089c3c4 	movi	r2,9999
81123658:	18800015 	stw	r2,0(r3)
8112365c:	90017726 	beq	r18,zero,81123c3c <_dtoa_r+0x6e4>
81123660:	00a04574 	movhi	r2,33045
81123664:	10a9a404 	addi	r2,r2,-22896
81123668:	d9002517 	ldw	r4,148(sp)
8112366c:	203fec26 	beq	r4,zero,81123620 <__reset+0xfb103620>
81123670:	10c000c7 	ldb	r3,3(r2)
81123674:	1801781e 	bne	r3,zero,81123c58 <_dtoa_r+0x700>
81123678:	10c000c4 	addi	r3,r2,3
8112367c:	d9802517 	ldw	r6,148(sp)
81123680:	30c00015 	stw	r3,0(r6)
81123684:	003fe606 	br	81123620 <__reset+0xfb103620>
81123688:	04e00034 	movhi	r19,32768
8112368c:	9cffffc4 	addi	r19,r19,-1
81123690:	00800044 	movi	r2,1
81123694:	8ce6703a 	and	r19,r17,r19
81123698:	80800015 	stw	r2,0(r16)
8112369c:	9823883a 	mov	r17,r19
811236a0:	003fcc06 	br	811235d4 <__reset+0xfb1035d4>
811236a4:	d8800204 	addi	r2,sp,8
811236a8:	d8800015 	stw	r2,0(sp)
811236ac:	d9c00104 	addi	r7,sp,4
811236b0:	900b883a 	mov	r5,r18
811236b4:	980d883a 	mov	r6,r19
811236b8:	e009883a 	mov	r4,fp
811236bc:	8820d53a 	srli	r16,r17,20
811236c0:	112734c0 	call	8112734c <__d2b>
811236c4:	d8800915 	stw	r2,36(sp)
811236c8:	8001651e 	bne	r16,zero,81123c60 <_dtoa_r+0x708>
811236cc:	dd800217 	ldw	r22,8(sp)
811236d0:	dc000117 	ldw	r16,4(sp)
811236d4:	00800804 	movi	r2,32
811236d8:	b421883a 	add	r16,r22,r16
811236dc:	80c10c84 	addi	r3,r16,1074
811236e0:	10c2d10e 	bge	r2,r3,81124228 <_dtoa_r+0xcd0>
811236e4:	00801004 	movi	r2,64
811236e8:	81010484 	addi	r4,r16,1042
811236ec:	10c7c83a 	sub	r3,r2,r3
811236f0:	9108d83a 	srl	r4,r18,r4
811236f4:	88e2983a 	sll	r17,r17,r3
811236f8:	2448b03a 	or	r4,r4,r17
811236fc:	1130b440 	call	81130b44 <__floatunsidf>
81123700:	017f8434 	movhi	r5,65040
81123704:	01800044 	movi	r6,1
81123708:	1009883a 	mov	r4,r2
8112370c:	194b883a 	add	r5,r3,r5
81123710:	843fffc4 	addi	r16,r16,-1
81123714:	d9801115 	stw	r6,68(sp)
81123718:	000d883a 	mov	r6,zero
8112371c:	01cffe34 	movhi	r7,16376
81123720:	11300dc0 	call	811300dc <__subdf3>
81123724:	0198dbf4 	movhi	r6,25455
81123728:	01cff4f4 	movhi	r7,16339
8112372c:	3190d844 	addi	r6,r6,17249
81123730:	39e1e9c4 	addi	r7,r7,-30809
81123734:	1009883a 	mov	r4,r2
81123738:	180b883a 	mov	r5,r3
8112373c:	111a7f00 	call	8111a7f0 <__muldf3>
81123740:	01a2d874 	movhi	r6,35681
81123744:	01cff1f4 	movhi	r7,16327
81123748:	31b22cc4 	addi	r6,r6,-14157
8112374c:	39e28a04 	addi	r7,r7,-30168
81123750:	180b883a 	mov	r5,r3
81123754:	1009883a 	mov	r4,r2
81123758:	112ece00 	call	8112ece0 <__adddf3>
8112375c:	8009883a 	mov	r4,r16
81123760:	1029883a 	mov	r20,r2
81123764:	1823883a 	mov	r17,r3
81123768:	1130a600 	call	81130a60 <__floatsidf>
8112376c:	019427f4 	movhi	r6,20639
81123770:	01cff4f4 	movhi	r7,16339
81123774:	319e7ec4 	addi	r6,r6,31227
81123778:	39d104c4 	addi	r7,r7,17427
8112377c:	1009883a 	mov	r4,r2
81123780:	180b883a 	mov	r5,r3
81123784:	111a7f00 	call	8111a7f0 <__muldf3>
81123788:	100d883a 	mov	r6,r2
8112378c:	180f883a 	mov	r7,r3
81123790:	a009883a 	mov	r4,r20
81123794:	880b883a 	mov	r5,r17
81123798:	112ece00 	call	8112ece0 <__adddf3>
8112379c:	1009883a 	mov	r4,r2
811237a0:	180b883a 	mov	r5,r3
811237a4:	1029883a 	mov	r20,r2
811237a8:	1823883a 	mov	r17,r3
811237ac:	11309e00 	call	811309e0 <__fixdfsi>
811237b0:	000d883a 	mov	r6,zero
811237b4:	000f883a 	mov	r7,zero
811237b8:	a009883a 	mov	r4,r20
811237bc:	880b883a 	mov	r5,r17
811237c0:	d8800515 	stw	r2,20(sp)
811237c4:	112ffe80 	call	8112ffe8 <__ledf2>
811237c8:	10028716 	blt	r2,zero,811241e8 <_dtoa_r+0xc90>
811237cc:	d8c00517 	ldw	r3,20(sp)
811237d0:	00800584 	movi	r2,22
811237d4:	10c27536 	bltu	r2,r3,811241ac <_dtoa_r+0xc54>
811237d8:	180490fa 	slli	r2,r3,3
811237dc:	00e04574 	movhi	r3,33045
811237e0:	18e9bf04 	addi	r3,r3,-22788
811237e4:	1885883a 	add	r2,r3,r2
811237e8:	11000017 	ldw	r4,0(r2)
811237ec:	11400117 	ldw	r5,4(r2)
811237f0:	900d883a 	mov	r6,r18
811237f4:	980f883a 	mov	r7,r19
811237f8:	112ff0c0 	call	8112ff0c <__gedf2>
811237fc:	00828d0e 	bge	zero,r2,81124234 <_dtoa_r+0xcdc>
81123800:	d9000517 	ldw	r4,20(sp)
81123804:	d8000e15 	stw	zero,56(sp)
81123808:	213fffc4 	addi	r4,r4,-1
8112380c:	d9000515 	stw	r4,20(sp)
81123810:	b42dc83a 	sub	r22,r22,r16
81123814:	b5bfffc4 	addi	r22,r22,-1
81123818:	b0026f16 	blt	r22,zero,811241d8 <_dtoa_r+0xc80>
8112381c:	d8000815 	stw	zero,32(sp)
81123820:	d9c00517 	ldw	r7,20(sp)
81123824:	38026416 	blt	r7,zero,811241b8 <_dtoa_r+0xc60>
81123828:	b1ed883a 	add	r22,r22,r7
8112382c:	d9c00d15 	stw	r7,52(sp)
81123830:	d8000a15 	stw	zero,40(sp)
81123834:	d9800317 	ldw	r6,12(sp)
81123838:	00800244 	movi	r2,9
8112383c:	11811436 	bltu	r2,r6,81123c90 <_dtoa_r+0x738>
81123840:	00800144 	movi	r2,5
81123844:	1184e10e 	bge	r2,r6,81124bcc <_dtoa_r+0x1674>
81123848:	31bfff04 	addi	r6,r6,-4
8112384c:	d9800315 	stw	r6,12(sp)
81123850:	0023883a 	mov	r17,zero
81123854:	d9800317 	ldw	r6,12(sp)
81123858:	008000c4 	movi	r2,3
8112385c:	30836726 	beq	r6,r2,811245fc <_dtoa_r+0x10a4>
81123860:	1183410e 	bge	r2,r6,81124568 <_dtoa_r+0x1010>
81123864:	d9c00317 	ldw	r7,12(sp)
81123868:	00800104 	movi	r2,4
8112386c:	38827c26 	beq	r7,r2,81124260 <_dtoa_r+0xd08>
81123870:	00800144 	movi	r2,5
81123874:	3884c41e 	bne	r7,r2,81124b88 <_dtoa_r+0x1630>
81123878:	00800044 	movi	r2,1
8112387c:	d8800b15 	stw	r2,44(sp)
81123880:	d8c00517 	ldw	r3,20(sp)
81123884:	d9002217 	ldw	r4,136(sp)
81123888:	1907883a 	add	r3,r3,r4
8112388c:	19800044 	addi	r6,r3,1
81123890:	d8c00c15 	stw	r3,48(sp)
81123894:	d9800615 	stw	r6,24(sp)
81123898:	0183a40e 	bge	zero,r6,8112472c <_dtoa_r+0x11d4>
8112389c:	d9800617 	ldw	r6,24(sp)
811238a0:	3021883a 	mov	r16,r6
811238a4:	e0001115 	stw	zero,68(fp)
811238a8:	008005c4 	movi	r2,23
811238ac:	1184c92e 	bgeu	r2,r6,81124bd4 <_dtoa_r+0x167c>
811238b0:	00c00044 	movi	r3,1
811238b4:	00800104 	movi	r2,4
811238b8:	1085883a 	add	r2,r2,r2
811238bc:	11000504 	addi	r4,r2,20
811238c0:	180b883a 	mov	r5,r3
811238c4:	18c00044 	addi	r3,r3,1
811238c8:	313ffb2e 	bgeu	r6,r4,811238b8 <__reset+0xfb1038b8>
811238cc:	e1401115 	stw	r5,68(fp)
811238d0:	e009883a 	mov	r4,fp
811238d4:	11266700 	call	81126670 <_Balloc>
811238d8:	d8800715 	stw	r2,28(sp)
811238dc:	e0801015 	stw	r2,64(fp)
811238e0:	00800384 	movi	r2,14
811238e4:	1400f736 	bltu	r2,r16,81123cc4 <_dtoa_r+0x76c>
811238e8:	8800f626 	beq	r17,zero,81123cc4 <_dtoa_r+0x76c>
811238ec:	d9c00517 	ldw	r7,20(sp)
811238f0:	01c39a0e 	bge	zero,r7,8112475c <_dtoa_r+0x1204>
811238f4:	388003cc 	andi	r2,r7,15
811238f8:	100490fa 	slli	r2,r2,3
811238fc:	382bd13a 	srai	r21,r7,4
81123900:	00e04574 	movhi	r3,33045
81123904:	18e9bf04 	addi	r3,r3,-22788
81123908:	1885883a 	add	r2,r3,r2
8112390c:	a8c0040c 	andi	r3,r21,16
81123910:	12400017 	ldw	r9,0(r2)
81123914:	12000117 	ldw	r8,4(r2)
81123918:	18037926 	beq	r3,zero,81124700 <_dtoa_r+0x11a8>
8112391c:	00a04574 	movhi	r2,33045
81123920:	10a9b504 	addi	r2,r2,-22828
81123924:	11800817 	ldw	r6,32(r2)
81123928:	11c00917 	ldw	r7,36(r2)
8112392c:	9009883a 	mov	r4,r18
81123930:	980b883a 	mov	r5,r19
81123934:	da001715 	stw	r8,92(sp)
81123938:	da401615 	stw	r9,88(sp)
8112393c:	112f5940 	call	8112f594 <__divdf3>
81123940:	da001717 	ldw	r8,92(sp)
81123944:	da401617 	ldw	r9,88(sp)
81123948:	ad4003cc 	andi	r21,r21,15
8112394c:	040000c4 	movi	r16,3
81123950:	1023883a 	mov	r17,r2
81123954:	1829883a 	mov	r20,r3
81123958:	a8001126 	beq	r21,zero,811239a0 <_dtoa_r+0x448>
8112395c:	05e04574 	movhi	r23,33045
81123960:	bde9b504 	addi	r23,r23,-22828
81123964:	4805883a 	mov	r2,r9
81123968:	4007883a 	mov	r3,r8
8112396c:	a980004c 	andi	r6,r21,1
81123970:	1009883a 	mov	r4,r2
81123974:	a82bd07a 	srai	r21,r21,1
81123978:	180b883a 	mov	r5,r3
8112397c:	30000426 	beq	r6,zero,81123990 <_dtoa_r+0x438>
81123980:	b9800017 	ldw	r6,0(r23)
81123984:	b9c00117 	ldw	r7,4(r23)
81123988:	84000044 	addi	r16,r16,1
8112398c:	111a7f00 	call	8111a7f0 <__muldf3>
81123990:	bdc00204 	addi	r23,r23,8
81123994:	a83ff51e 	bne	r21,zero,8112396c <__reset+0xfb10396c>
81123998:	1013883a 	mov	r9,r2
8112399c:	1811883a 	mov	r8,r3
811239a0:	480d883a 	mov	r6,r9
811239a4:	400f883a 	mov	r7,r8
811239a8:	8809883a 	mov	r4,r17
811239ac:	a00b883a 	mov	r5,r20
811239b0:	112f5940 	call	8112f594 <__divdf3>
811239b4:	d8800f15 	stw	r2,60(sp)
811239b8:	d8c01015 	stw	r3,64(sp)
811239bc:	d8c00e17 	ldw	r3,56(sp)
811239c0:	18000626 	beq	r3,zero,811239dc <_dtoa_r+0x484>
811239c4:	d9000f17 	ldw	r4,60(sp)
811239c8:	d9401017 	ldw	r5,64(sp)
811239cc:	000d883a 	mov	r6,zero
811239d0:	01cffc34 	movhi	r7,16368
811239d4:	112ffe80 	call	8112ffe8 <__ledf2>
811239d8:	10040b16 	blt	r2,zero,81124a08 <_dtoa_r+0x14b0>
811239dc:	8009883a 	mov	r4,r16
811239e0:	1130a600 	call	81130a60 <__floatsidf>
811239e4:	d9800f17 	ldw	r6,60(sp)
811239e8:	d9c01017 	ldw	r7,64(sp)
811239ec:	1009883a 	mov	r4,r2
811239f0:	180b883a 	mov	r5,r3
811239f4:	111a7f00 	call	8111a7f0 <__muldf3>
811239f8:	000d883a 	mov	r6,zero
811239fc:	01d00734 	movhi	r7,16412
81123a00:	1009883a 	mov	r4,r2
81123a04:	180b883a 	mov	r5,r3
81123a08:	112ece00 	call	8112ece0 <__adddf3>
81123a0c:	1021883a 	mov	r16,r2
81123a10:	d8800617 	ldw	r2,24(sp)
81123a14:	047f3034 	movhi	r17,64704
81123a18:	1c63883a 	add	r17,r3,r17
81123a1c:	10031826 	beq	r2,zero,81124680 <_dtoa_r+0x1128>
81123a20:	d8c00517 	ldw	r3,20(sp)
81123a24:	db000617 	ldw	r12,24(sp)
81123a28:	d8c01315 	stw	r3,76(sp)
81123a2c:	d9000b17 	ldw	r4,44(sp)
81123a30:	20038f26 	beq	r4,zero,81124870 <_dtoa_r+0x1318>
81123a34:	60bfffc4 	addi	r2,r12,-1
81123a38:	100490fa 	slli	r2,r2,3
81123a3c:	00e04574 	movhi	r3,33045
81123a40:	18e9bf04 	addi	r3,r3,-22788
81123a44:	1885883a 	add	r2,r3,r2
81123a48:	11800017 	ldw	r6,0(r2)
81123a4c:	11c00117 	ldw	r7,4(r2)
81123a50:	d8800717 	ldw	r2,28(sp)
81123a54:	0009883a 	mov	r4,zero
81123a58:	014ff834 	movhi	r5,16352
81123a5c:	db001615 	stw	r12,88(sp)
81123a60:	15c00044 	addi	r23,r2,1
81123a64:	112f5940 	call	8112f594 <__divdf3>
81123a68:	800d883a 	mov	r6,r16
81123a6c:	880f883a 	mov	r7,r17
81123a70:	1009883a 	mov	r4,r2
81123a74:	180b883a 	mov	r5,r3
81123a78:	11300dc0 	call	811300dc <__subdf3>
81123a7c:	d9401017 	ldw	r5,64(sp)
81123a80:	d9000f17 	ldw	r4,60(sp)
81123a84:	102b883a 	mov	r21,r2
81123a88:	d8c01215 	stw	r3,72(sp)
81123a8c:	11309e00 	call	811309e0 <__fixdfsi>
81123a90:	1009883a 	mov	r4,r2
81123a94:	1029883a 	mov	r20,r2
81123a98:	1130a600 	call	81130a60 <__floatsidf>
81123a9c:	d9000f17 	ldw	r4,60(sp)
81123aa0:	d9401017 	ldw	r5,64(sp)
81123aa4:	100d883a 	mov	r6,r2
81123aa8:	180f883a 	mov	r7,r3
81123aac:	11300dc0 	call	811300dc <__subdf3>
81123ab0:	1823883a 	mov	r17,r3
81123ab4:	d8c00717 	ldw	r3,28(sp)
81123ab8:	d9401217 	ldw	r5,72(sp)
81123abc:	a2000c04 	addi	r8,r20,48
81123ac0:	1021883a 	mov	r16,r2
81123ac4:	1a000005 	stb	r8,0(r3)
81123ac8:	800d883a 	mov	r6,r16
81123acc:	880f883a 	mov	r7,r17
81123ad0:	a809883a 	mov	r4,r21
81123ad4:	4029883a 	mov	r20,r8
81123ad8:	112ff0c0 	call	8112ff0c <__gedf2>
81123adc:	00841d16 	blt	zero,r2,81124b54 <_dtoa_r+0x15fc>
81123ae0:	800d883a 	mov	r6,r16
81123ae4:	880f883a 	mov	r7,r17
81123ae8:	0009883a 	mov	r4,zero
81123aec:	014ffc34 	movhi	r5,16368
81123af0:	11300dc0 	call	811300dc <__subdf3>
81123af4:	d9401217 	ldw	r5,72(sp)
81123af8:	100d883a 	mov	r6,r2
81123afc:	180f883a 	mov	r7,r3
81123b00:	a809883a 	mov	r4,r21
81123b04:	112ff0c0 	call	8112ff0c <__gedf2>
81123b08:	db001617 	ldw	r12,88(sp)
81123b0c:	00840e16 	blt	zero,r2,81124b48 <_dtoa_r+0x15f0>
81123b10:	00800044 	movi	r2,1
81123b14:	13006b0e 	bge	r2,r12,81123cc4 <_dtoa_r+0x76c>
81123b18:	d9000717 	ldw	r4,28(sp)
81123b1c:	dd800f15 	stw	r22,60(sp)
81123b20:	dcc01015 	stw	r19,64(sp)
81123b24:	2319883a 	add	r12,r4,r12
81123b28:	dcc01217 	ldw	r19,72(sp)
81123b2c:	602d883a 	mov	r22,r12
81123b30:	dc801215 	stw	r18,72(sp)
81123b34:	b825883a 	mov	r18,r23
81123b38:	00000906 	br	81123b60 <_dtoa_r+0x608>
81123b3c:	11300dc0 	call	811300dc <__subdf3>
81123b40:	a80d883a 	mov	r6,r21
81123b44:	980f883a 	mov	r7,r19
81123b48:	1009883a 	mov	r4,r2
81123b4c:	180b883a 	mov	r5,r3
81123b50:	112ffe80 	call	8112ffe8 <__ledf2>
81123b54:	1003e816 	blt	r2,zero,81124af8 <_dtoa_r+0x15a0>
81123b58:	b825883a 	mov	r18,r23
81123b5c:	bd83e926 	beq	r23,r22,81124b04 <_dtoa_r+0x15ac>
81123b60:	a809883a 	mov	r4,r21
81123b64:	980b883a 	mov	r5,r19
81123b68:	000d883a 	mov	r6,zero
81123b6c:	01d00934 	movhi	r7,16420
81123b70:	111a7f00 	call	8111a7f0 <__muldf3>
81123b74:	000d883a 	mov	r6,zero
81123b78:	01d00934 	movhi	r7,16420
81123b7c:	8009883a 	mov	r4,r16
81123b80:	880b883a 	mov	r5,r17
81123b84:	102b883a 	mov	r21,r2
81123b88:	1827883a 	mov	r19,r3
81123b8c:	111a7f00 	call	8111a7f0 <__muldf3>
81123b90:	180b883a 	mov	r5,r3
81123b94:	1009883a 	mov	r4,r2
81123b98:	1821883a 	mov	r16,r3
81123b9c:	1023883a 	mov	r17,r2
81123ba0:	11309e00 	call	811309e0 <__fixdfsi>
81123ba4:	1009883a 	mov	r4,r2
81123ba8:	1029883a 	mov	r20,r2
81123bac:	1130a600 	call	81130a60 <__floatsidf>
81123bb0:	8809883a 	mov	r4,r17
81123bb4:	800b883a 	mov	r5,r16
81123bb8:	100d883a 	mov	r6,r2
81123bbc:	180f883a 	mov	r7,r3
81123bc0:	11300dc0 	call	811300dc <__subdf3>
81123bc4:	a5000c04 	addi	r20,r20,48
81123bc8:	a80d883a 	mov	r6,r21
81123bcc:	980f883a 	mov	r7,r19
81123bd0:	1009883a 	mov	r4,r2
81123bd4:	180b883a 	mov	r5,r3
81123bd8:	95000005 	stb	r20,0(r18)
81123bdc:	1021883a 	mov	r16,r2
81123be0:	1823883a 	mov	r17,r3
81123be4:	112ffe80 	call	8112ffe8 <__ledf2>
81123be8:	bdc00044 	addi	r23,r23,1
81123bec:	800d883a 	mov	r6,r16
81123bf0:	880f883a 	mov	r7,r17
81123bf4:	0009883a 	mov	r4,zero
81123bf8:	014ffc34 	movhi	r5,16368
81123bfc:	103fcf0e 	bge	r2,zero,81123b3c <__reset+0xfb103b3c>
81123c00:	d8c01317 	ldw	r3,76(sp)
81123c04:	d8c00515 	stw	r3,20(sp)
81123c08:	d9400917 	ldw	r5,36(sp)
81123c0c:	e009883a 	mov	r4,fp
81123c10:	11267200 	call	81126720 <_Bfree>
81123c14:	d9000517 	ldw	r4,20(sp)
81123c18:	d9802317 	ldw	r6,140(sp)
81123c1c:	d9c02517 	ldw	r7,148(sp)
81123c20:	b8000005 	stb	zero,0(r23)
81123c24:	20800044 	addi	r2,r4,1
81123c28:	30800015 	stw	r2,0(r6)
81123c2c:	3802aa26 	beq	r7,zero,811246d8 <_dtoa_r+0x1180>
81123c30:	3dc00015 	stw	r23,0(r7)
81123c34:	d8800717 	ldw	r2,28(sp)
81123c38:	003e7906 	br	81123620 <__reset+0xfb103620>
81123c3c:	00800434 	movhi	r2,16
81123c40:	10bfffc4 	addi	r2,r2,-1
81123c44:	88a2703a 	and	r17,r17,r2
81123c48:	883e851e 	bne	r17,zero,81123660 <__reset+0xfb103660>
81123c4c:	00a04574 	movhi	r2,33045
81123c50:	10a9a104 	addi	r2,r2,-22908
81123c54:	003e8406 	br	81123668 <__reset+0xfb103668>
81123c58:	10c00204 	addi	r3,r2,8
81123c5c:	003e8706 	br	8112367c <__reset+0xfb10367c>
81123c60:	01400434 	movhi	r5,16
81123c64:	297fffc4 	addi	r5,r5,-1
81123c68:	994a703a 	and	r5,r19,r5
81123c6c:	9009883a 	mov	r4,r18
81123c70:	843f0044 	addi	r16,r16,-1023
81123c74:	294ffc34 	orhi	r5,r5,16368
81123c78:	dd800217 	ldw	r22,8(sp)
81123c7c:	d8001115 	stw	zero,68(sp)
81123c80:	003ea506 	br	81123718 <__reset+0xfb103718>
81123c84:	00a04574 	movhi	r2,33045
81123c88:	10a98604 	addi	r2,r2,-23016
81123c8c:	003e6406 	br	81123620 <__reset+0xfb103620>
81123c90:	e0001115 	stw	zero,68(fp)
81123c94:	000b883a 	mov	r5,zero
81123c98:	e009883a 	mov	r4,fp
81123c9c:	11266700 	call	81126670 <_Balloc>
81123ca0:	01bfffc4 	movi	r6,-1
81123ca4:	01c00044 	movi	r7,1
81123ca8:	d8800715 	stw	r2,28(sp)
81123cac:	d9800c15 	stw	r6,48(sp)
81123cb0:	e0801015 	stw	r2,64(fp)
81123cb4:	d8000315 	stw	zero,12(sp)
81123cb8:	d9c00b15 	stw	r7,44(sp)
81123cbc:	d9800615 	stw	r6,24(sp)
81123cc0:	d8002215 	stw	zero,136(sp)
81123cc4:	d8800117 	ldw	r2,4(sp)
81123cc8:	10008916 	blt	r2,zero,81123ef0 <_dtoa_r+0x998>
81123ccc:	d9000517 	ldw	r4,20(sp)
81123cd0:	00c00384 	movi	r3,14
81123cd4:	19008616 	blt	r3,r4,81123ef0 <_dtoa_r+0x998>
81123cd8:	200490fa 	slli	r2,r4,3
81123cdc:	00e04574 	movhi	r3,33045
81123ce0:	d9802217 	ldw	r6,136(sp)
81123ce4:	18e9bf04 	addi	r3,r3,-22788
81123ce8:	1885883a 	add	r2,r3,r2
81123cec:	14000017 	ldw	r16,0(r2)
81123cf0:	14400117 	ldw	r17,4(r2)
81123cf4:	30016316 	blt	r6,zero,81124284 <_dtoa_r+0xd2c>
81123cf8:	800d883a 	mov	r6,r16
81123cfc:	880f883a 	mov	r7,r17
81123d00:	9009883a 	mov	r4,r18
81123d04:	980b883a 	mov	r5,r19
81123d08:	112f5940 	call	8112f594 <__divdf3>
81123d0c:	180b883a 	mov	r5,r3
81123d10:	1009883a 	mov	r4,r2
81123d14:	11309e00 	call	811309e0 <__fixdfsi>
81123d18:	1009883a 	mov	r4,r2
81123d1c:	102b883a 	mov	r21,r2
81123d20:	1130a600 	call	81130a60 <__floatsidf>
81123d24:	800d883a 	mov	r6,r16
81123d28:	880f883a 	mov	r7,r17
81123d2c:	1009883a 	mov	r4,r2
81123d30:	180b883a 	mov	r5,r3
81123d34:	111a7f00 	call	8111a7f0 <__muldf3>
81123d38:	100d883a 	mov	r6,r2
81123d3c:	180f883a 	mov	r7,r3
81123d40:	9009883a 	mov	r4,r18
81123d44:	980b883a 	mov	r5,r19
81123d48:	11300dc0 	call	811300dc <__subdf3>
81123d4c:	d9c00717 	ldw	r7,28(sp)
81123d50:	1009883a 	mov	r4,r2
81123d54:	a8800c04 	addi	r2,r21,48
81123d58:	38800005 	stb	r2,0(r7)
81123d5c:	3dc00044 	addi	r23,r7,1
81123d60:	d9c00617 	ldw	r7,24(sp)
81123d64:	01800044 	movi	r6,1
81123d68:	180b883a 	mov	r5,r3
81123d6c:	2005883a 	mov	r2,r4
81123d70:	39803826 	beq	r7,r6,81123e54 <_dtoa_r+0x8fc>
81123d74:	000d883a 	mov	r6,zero
81123d78:	01d00934 	movhi	r7,16420
81123d7c:	111a7f00 	call	8111a7f0 <__muldf3>
81123d80:	000d883a 	mov	r6,zero
81123d84:	000f883a 	mov	r7,zero
81123d88:	1009883a 	mov	r4,r2
81123d8c:	180b883a 	mov	r5,r3
81123d90:	1025883a 	mov	r18,r2
81123d94:	1827883a 	mov	r19,r3
81123d98:	112fe840 	call	8112fe84 <__eqdf2>
81123d9c:	103f9a26 	beq	r2,zero,81123c08 <__reset+0xfb103c08>
81123da0:	d9c00617 	ldw	r7,24(sp)
81123da4:	d8c00717 	ldw	r3,28(sp)
81123da8:	b829883a 	mov	r20,r23
81123dac:	38bfffc4 	addi	r2,r7,-1
81123db0:	18ad883a 	add	r22,r3,r2
81123db4:	00000a06 	br	81123de0 <_dtoa_r+0x888>
81123db8:	111a7f00 	call	8111a7f0 <__muldf3>
81123dbc:	000d883a 	mov	r6,zero
81123dc0:	000f883a 	mov	r7,zero
81123dc4:	1009883a 	mov	r4,r2
81123dc8:	180b883a 	mov	r5,r3
81123dcc:	1025883a 	mov	r18,r2
81123dd0:	1827883a 	mov	r19,r3
81123dd4:	b829883a 	mov	r20,r23
81123dd8:	112fe840 	call	8112fe84 <__eqdf2>
81123ddc:	103f8a26 	beq	r2,zero,81123c08 <__reset+0xfb103c08>
81123de0:	800d883a 	mov	r6,r16
81123de4:	880f883a 	mov	r7,r17
81123de8:	9009883a 	mov	r4,r18
81123dec:	980b883a 	mov	r5,r19
81123df0:	112f5940 	call	8112f594 <__divdf3>
81123df4:	180b883a 	mov	r5,r3
81123df8:	1009883a 	mov	r4,r2
81123dfc:	11309e00 	call	811309e0 <__fixdfsi>
81123e00:	1009883a 	mov	r4,r2
81123e04:	102b883a 	mov	r21,r2
81123e08:	1130a600 	call	81130a60 <__floatsidf>
81123e0c:	800d883a 	mov	r6,r16
81123e10:	880f883a 	mov	r7,r17
81123e14:	1009883a 	mov	r4,r2
81123e18:	180b883a 	mov	r5,r3
81123e1c:	111a7f00 	call	8111a7f0 <__muldf3>
81123e20:	100d883a 	mov	r6,r2
81123e24:	180f883a 	mov	r7,r3
81123e28:	9009883a 	mov	r4,r18
81123e2c:	980b883a 	mov	r5,r19
81123e30:	11300dc0 	call	811300dc <__subdf3>
81123e34:	aa000c04 	addi	r8,r21,48
81123e38:	a2000005 	stb	r8,0(r20)
81123e3c:	000d883a 	mov	r6,zero
81123e40:	01d00934 	movhi	r7,16420
81123e44:	1009883a 	mov	r4,r2
81123e48:	180b883a 	mov	r5,r3
81123e4c:	a5c00044 	addi	r23,r20,1
81123e50:	b53fd91e 	bne	r22,r20,81123db8 <__reset+0xfb103db8>
81123e54:	100d883a 	mov	r6,r2
81123e58:	180f883a 	mov	r7,r3
81123e5c:	1009883a 	mov	r4,r2
81123e60:	180b883a 	mov	r5,r3
81123e64:	112ece00 	call	8112ece0 <__adddf3>
81123e68:	100d883a 	mov	r6,r2
81123e6c:	180f883a 	mov	r7,r3
81123e70:	8009883a 	mov	r4,r16
81123e74:	880b883a 	mov	r5,r17
81123e78:	1027883a 	mov	r19,r2
81123e7c:	1825883a 	mov	r18,r3
81123e80:	112ffe80 	call	8112ffe8 <__ledf2>
81123e84:	10000816 	blt	r2,zero,81123ea8 <_dtoa_r+0x950>
81123e88:	980d883a 	mov	r6,r19
81123e8c:	900f883a 	mov	r7,r18
81123e90:	8009883a 	mov	r4,r16
81123e94:	880b883a 	mov	r5,r17
81123e98:	112fe840 	call	8112fe84 <__eqdf2>
81123e9c:	103f5a1e 	bne	r2,zero,81123c08 <__reset+0xfb103c08>
81123ea0:	ad40004c 	andi	r21,r21,1
81123ea4:	a83f5826 	beq	r21,zero,81123c08 <__reset+0xfb103c08>
81123ea8:	bd3fffc3 	ldbu	r20,-1(r23)
81123eac:	b8bfffc4 	addi	r2,r23,-1
81123eb0:	1007883a 	mov	r3,r2
81123eb4:	01400e44 	movi	r5,57
81123eb8:	d9800717 	ldw	r6,28(sp)
81123ebc:	00000506 	br	81123ed4 <_dtoa_r+0x97c>
81123ec0:	18ffffc4 	addi	r3,r3,-1
81123ec4:	11824726 	beq	r2,r6,811247e4 <_dtoa_r+0x128c>
81123ec8:	1d000003 	ldbu	r20,0(r3)
81123ecc:	102f883a 	mov	r23,r2
81123ed0:	10bfffc4 	addi	r2,r2,-1
81123ed4:	a1003fcc 	andi	r4,r20,255
81123ed8:	2100201c 	xori	r4,r4,128
81123edc:	213fe004 	addi	r4,r4,-128
81123ee0:	217ff726 	beq	r4,r5,81123ec0 <__reset+0xfb103ec0>
81123ee4:	a2000044 	addi	r8,r20,1
81123ee8:	12000005 	stb	r8,0(r2)
81123eec:	003f4606 	br	81123c08 <__reset+0xfb103c08>
81123ef0:	d9000b17 	ldw	r4,44(sp)
81123ef4:	2000c826 	beq	r4,zero,81124218 <_dtoa_r+0xcc0>
81123ef8:	d9800317 	ldw	r6,12(sp)
81123efc:	00c00044 	movi	r3,1
81123f00:	1980f90e 	bge	r3,r6,811242e8 <_dtoa_r+0xd90>
81123f04:	d8800617 	ldw	r2,24(sp)
81123f08:	d8c00a17 	ldw	r3,40(sp)
81123f0c:	157fffc4 	addi	r21,r2,-1
81123f10:	1d41f316 	blt	r3,r21,811246e0 <_dtoa_r+0x1188>
81123f14:	1d6bc83a 	sub	r21,r3,r21
81123f18:	d9c00617 	ldw	r7,24(sp)
81123f1c:	3802aa16 	blt	r7,zero,811249c8 <_dtoa_r+0x1470>
81123f20:	dd000817 	ldw	r20,32(sp)
81123f24:	d8800617 	ldw	r2,24(sp)
81123f28:	d8c00817 	ldw	r3,32(sp)
81123f2c:	01400044 	movi	r5,1
81123f30:	e009883a 	mov	r4,fp
81123f34:	1887883a 	add	r3,r3,r2
81123f38:	d8c00815 	stw	r3,32(sp)
81123f3c:	b0ad883a 	add	r22,r22,r2
81123f40:	1126a940 	call	81126a94 <__i2b>
81123f44:	1023883a 	mov	r17,r2
81123f48:	a0000826 	beq	r20,zero,81123f6c <_dtoa_r+0xa14>
81123f4c:	0580070e 	bge	zero,r22,81123f6c <_dtoa_r+0xa14>
81123f50:	a005883a 	mov	r2,r20
81123f54:	b500b916 	blt	r22,r20,8112423c <_dtoa_r+0xce4>
81123f58:	d9000817 	ldw	r4,32(sp)
81123f5c:	a0a9c83a 	sub	r20,r20,r2
81123f60:	b0adc83a 	sub	r22,r22,r2
81123f64:	2089c83a 	sub	r4,r4,r2
81123f68:	d9000815 	stw	r4,32(sp)
81123f6c:	d9800a17 	ldw	r6,40(sp)
81123f70:	0181810e 	bge	zero,r6,81124578 <_dtoa_r+0x1020>
81123f74:	d9c00b17 	ldw	r7,44(sp)
81123f78:	3800b326 	beq	r7,zero,81124248 <_dtoa_r+0xcf0>
81123f7c:	a800b226 	beq	r21,zero,81124248 <_dtoa_r+0xcf0>
81123f80:	880b883a 	mov	r5,r17
81123f84:	a80d883a 	mov	r6,r21
81123f88:	e009883a 	mov	r4,fp
81123f8c:	1126cd80 	call	81126cd8 <__pow5mult>
81123f90:	d9800917 	ldw	r6,36(sp)
81123f94:	100b883a 	mov	r5,r2
81123f98:	e009883a 	mov	r4,fp
81123f9c:	1023883a 	mov	r17,r2
81123fa0:	1126ad80 	call	81126ad8 <__multiply>
81123fa4:	1021883a 	mov	r16,r2
81123fa8:	d8800a17 	ldw	r2,40(sp)
81123fac:	d9400917 	ldw	r5,36(sp)
81123fb0:	e009883a 	mov	r4,fp
81123fb4:	1545c83a 	sub	r2,r2,r21
81123fb8:	d8800a15 	stw	r2,40(sp)
81123fbc:	11267200 	call	81126720 <_Bfree>
81123fc0:	d8c00a17 	ldw	r3,40(sp)
81123fc4:	18009f1e 	bne	r3,zero,81124244 <_dtoa_r+0xcec>
81123fc8:	05c00044 	movi	r23,1
81123fcc:	e009883a 	mov	r4,fp
81123fd0:	b80b883a 	mov	r5,r23
81123fd4:	1126a940 	call	81126a94 <__i2b>
81123fd8:	d9000d17 	ldw	r4,52(sp)
81123fdc:	102b883a 	mov	r21,r2
81123fe0:	2000ce26 	beq	r4,zero,8112431c <_dtoa_r+0xdc4>
81123fe4:	200d883a 	mov	r6,r4
81123fe8:	100b883a 	mov	r5,r2
81123fec:	e009883a 	mov	r4,fp
81123ff0:	1126cd80 	call	81126cd8 <__pow5mult>
81123ff4:	d9800317 	ldw	r6,12(sp)
81123ff8:	102b883a 	mov	r21,r2
81123ffc:	b981810e 	bge	r23,r6,81124604 <_dtoa_r+0x10ac>
81124000:	0027883a 	mov	r19,zero
81124004:	a8800417 	ldw	r2,16(r21)
81124008:	05c00804 	movi	r23,32
8112400c:	10800104 	addi	r2,r2,4
81124010:	1085883a 	add	r2,r2,r2
81124014:	1085883a 	add	r2,r2,r2
81124018:	a885883a 	add	r2,r21,r2
8112401c:	11000017 	ldw	r4,0(r2)
81124020:	112697c0 	call	8112697c <__hi0bits>
81124024:	b885c83a 	sub	r2,r23,r2
81124028:	1585883a 	add	r2,r2,r22
8112402c:	108007cc 	andi	r2,r2,31
81124030:	1000b326 	beq	r2,zero,81124300 <_dtoa_r+0xda8>
81124034:	00c00804 	movi	r3,32
81124038:	1887c83a 	sub	r3,r3,r2
8112403c:	01000104 	movi	r4,4
81124040:	20c2cd0e 	bge	r4,r3,81124b78 <_dtoa_r+0x1620>
81124044:	00c00704 	movi	r3,28
81124048:	1885c83a 	sub	r2,r3,r2
8112404c:	d8c00817 	ldw	r3,32(sp)
81124050:	a0a9883a 	add	r20,r20,r2
81124054:	b0ad883a 	add	r22,r22,r2
81124058:	1887883a 	add	r3,r3,r2
8112405c:	d8c00815 	stw	r3,32(sp)
81124060:	d9800817 	ldw	r6,32(sp)
81124064:	0180040e 	bge	zero,r6,81124078 <_dtoa_r+0xb20>
81124068:	800b883a 	mov	r5,r16
8112406c:	e009883a 	mov	r4,fp
81124070:	1126e200 	call	81126e20 <__lshift>
81124074:	1021883a 	mov	r16,r2
81124078:	0580050e 	bge	zero,r22,81124090 <_dtoa_r+0xb38>
8112407c:	a80b883a 	mov	r5,r21
81124080:	b00d883a 	mov	r6,r22
81124084:	e009883a 	mov	r4,fp
81124088:	1126e200 	call	81126e20 <__lshift>
8112408c:	102b883a 	mov	r21,r2
81124090:	d9c00e17 	ldw	r7,56(sp)
81124094:	3801211e 	bne	r7,zero,8112451c <_dtoa_r+0xfc4>
81124098:	d9800617 	ldw	r6,24(sp)
8112409c:	0181380e 	bge	zero,r6,81124580 <_dtoa_r+0x1028>
811240a0:	d8c00b17 	ldw	r3,44(sp)
811240a4:	1800ab1e 	bne	r3,zero,81124354 <_dtoa_r+0xdfc>
811240a8:	dc800717 	ldw	r18,28(sp)
811240ac:	dcc00617 	ldw	r19,24(sp)
811240b0:	9029883a 	mov	r20,r18
811240b4:	00000206 	br	811240c0 <_dtoa_r+0xb68>
811240b8:	11267480 	call	81126748 <__multadd>
811240bc:	1021883a 	mov	r16,r2
811240c0:	a80b883a 	mov	r5,r21
811240c4:	8009883a 	mov	r4,r16
811240c8:	11233500 	call	81123350 <quorem>
811240cc:	10800c04 	addi	r2,r2,48
811240d0:	90800005 	stb	r2,0(r18)
811240d4:	94800044 	addi	r18,r18,1
811240d8:	9507c83a 	sub	r3,r18,r20
811240dc:	000f883a 	mov	r7,zero
811240e0:	01800284 	movi	r6,10
811240e4:	800b883a 	mov	r5,r16
811240e8:	e009883a 	mov	r4,fp
811240ec:	1cfff216 	blt	r3,r19,811240b8 <__reset+0xfb1040b8>
811240f0:	1011883a 	mov	r8,r2
811240f4:	d8800617 	ldw	r2,24(sp)
811240f8:	0082370e 	bge	zero,r2,811249d8 <_dtoa_r+0x1480>
811240fc:	d9000717 	ldw	r4,28(sp)
81124100:	0025883a 	mov	r18,zero
81124104:	20af883a 	add	r23,r4,r2
81124108:	01800044 	movi	r6,1
8112410c:	800b883a 	mov	r5,r16
81124110:	e009883a 	mov	r4,fp
81124114:	da001715 	stw	r8,92(sp)
81124118:	1126e200 	call	81126e20 <__lshift>
8112411c:	a80b883a 	mov	r5,r21
81124120:	1009883a 	mov	r4,r2
81124124:	d8800915 	stw	r2,36(sp)
81124128:	1126f700 	call	81126f70 <__mcmp>
8112412c:	da001717 	ldw	r8,92(sp)
81124130:	0081800e 	bge	zero,r2,81124734 <_dtoa_r+0x11dc>
81124134:	b93fffc3 	ldbu	r4,-1(r23)
81124138:	b8bfffc4 	addi	r2,r23,-1
8112413c:	1007883a 	mov	r3,r2
81124140:	01800e44 	movi	r6,57
81124144:	d9c00717 	ldw	r7,28(sp)
81124148:	00000506 	br	81124160 <_dtoa_r+0xc08>
8112414c:	18ffffc4 	addi	r3,r3,-1
81124150:	11c12326 	beq	r2,r7,811245e0 <_dtoa_r+0x1088>
81124154:	19000003 	ldbu	r4,0(r3)
81124158:	102f883a 	mov	r23,r2
8112415c:	10bfffc4 	addi	r2,r2,-1
81124160:	21403fcc 	andi	r5,r4,255
81124164:	2940201c 	xori	r5,r5,128
81124168:	297fe004 	addi	r5,r5,-128
8112416c:	29bff726 	beq	r5,r6,8112414c <__reset+0xfb10414c>
81124170:	21000044 	addi	r4,r4,1
81124174:	11000005 	stb	r4,0(r2)
81124178:	a80b883a 	mov	r5,r21
8112417c:	e009883a 	mov	r4,fp
81124180:	11267200 	call	81126720 <_Bfree>
81124184:	883ea026 	beq	r17,zero,81123c08 <__reset+0xfb103c08>
81124188:	90000426 	beq	r18,zero,8112419c <_dtoa_r+0xc44>
8112418c:	94400326 	beq	r18,r17,8112419c <_dtoa_r+0xc44>
81124190:	900b883a 	mov	r5,r18
81124194:	e009883a 	mov	r4,fp
81124198:	11267200 	call	81126720 <_Bfree>
8112419c:	880b883a 	mov	r5,r17
811241a0:	e009883a 	mov	r4,fp
811241a4:	11267200 	call	81126720 <_Bfree>
811241a8:	003e9706 	br	81123c08 <__reset+0xfb103c08>
811241ac:	01800044 	movi	r6,1
811241b0:	d9800e15 	stw	r6,56(sp)
811241b4:	003d9606 	br	81123810 <__reset+0xfb103810>
811241b8:	d8800817 	ldw	r2,32(sp)
811241bc:	d8c00517 	ldw	r3,20(sp)
811241c0:	d8000d15 	stw	zero,52(sp)
811241c4:	10c5c83a 	sub	r2,r2,r3
811241c8:	00c9c83a 	sub	r4,zero,r3
811241cc:	d8800815 	stw	r2,32(sp)
811241d0:	d9000a15 	stw	r4,40(sp)
811241d4:	003d9706 	br	81123834 <__reset+0xfb103834>
811241d8:	05adc83a 	sub	r22,zero,r22
811241dc:	dd800815 	stw	r22,32(sp)
811241e0:	002d883a 	mov	r22,zero
811241e4:	003d8e06 	br	81123820 <__reset+0xfb103820>
811241e8:	d9000517 	ldw	r4,20(sp)
811241ec:	1130a600 	call	81130a60 <__floatsidf>
811241f0:	100d883a 	mov	r6,r2
811241f4:	180f883a 	mov	r7,r3
811241f8:	a009883a 	mov	r4,r20
811241fc:	880b883a 	mov	r5,r17
81124200:	112fe840 	call	8112fe84 <__eqdf2>
81124204:	103d7126 	beq	r2,zero,811237cc <__reset+0xfb1037cc>
81124208:	d9c00517 	ldw	r7,20(sp)
8112420c:	39ffffc4 	addi	r7,r7,-1
81124210:	d9c00515 	stw	r7,20(sp)
81124214:	003d6d06 	br	811237cc <__reset+0xfb1037cc>
81124218:	dd400a17 	ldw	r21,40(sp)
8112421c:	dd000817 	ldw	r20,32(sp)
81124220:	0023883a 	mov	r17,zero
81124224:	003f4806 	br	81123f48 <__reset+0xfb103f48>
81124228:	10e3c83a 	sub	r17,r2,r3
8112422c:	9448983a 	sll	r4,r18,r17
81124230:	003d3206 	br	811236fc <__reset+0xfb1036fc>
81124234:	d8000e15 	stw	zero,56(sp)
81124238:	003d7506 	br	81123810 <__reset+0xfb103810>
8112423c:	b005883a 	mov	r2,r22
81124240:	003f4506 	br	81123f58 <__reset+0xfb103f58>
81124244:	dc000915 	stw	r16,36(sp)
81124248:	d9800a17 	ldw	r6,40(sp)
8112424c:	d9400917 	ldw	r5,36(sp)
81124250:	e009883a 	mov	r4,fp
81124254:	1126cd80 	call	81126cd8 <__pow5mult>
81124258:	1021883a 	mov	r16,r2
8112425c:	003f5a06 	br	81123fc8 <__reset+0xfb103fc8>
81124260:	01c00044 	movi	r7,1
81124264:	d9c00b15 	stw	r7,44(sp)
81124268:	d8802217 	ldw	r2,136(sp)
8112426c:	0081280e 	bge	zero,r2,81124710 <_dtoa_r+0x11b8>
81124270:	100d883a 	mov	r6,r2
81124274:	1021883a 	mov	r16,r2
81124278:	d8800c15 	stw	r2,48(sp)
8112427c:	d8800615 	stw	r2,24(sp)
81124280:	003d8806 	br	811238a4 <__reset+0xfb1038a4>
81124284:	d8800617 	ldw	r2,24(sp)
81124288:	00be9b16 	blt	zero,r2,81123cf8 <__reset+0xfb103cf8>
8112428c:	10010f1e 	bne	r2,zero,811246cc <_dtoa_r+0x1174>
81124290:	880b883a 	mov	r5,r17
81124294:	000d883a 	mov	r6,zero
81124298:	01d00534 	movhi	r7,16404
8112429c:	8009883a 	mov	r4,r16
811242a0:	111a7f00 	call	8111a7f0 <__muldf3>
811242a4:	900d883a 	mov	r6,r18
811242a8:	980f883a 	mov	r7,r19
811242ac:	1009883a 	mov	r4,r2
811242b0:	180b883a 	mov	r5,r3
811242b4:	112ff0c0 	call	8112ff0c <__gedf2>
811242b8:	002b883a 	mov	r21,zero
811242bc:	0023883a 	mov	r17,zero
811242c0:	1000bf16 	blt	r2,zero,811245c0 <_dtoa_r+0x1068>
811242c4:	d9802217 	ldw	r6,136(sp)
811242c8:	ddc00717 	ldw	r23,28(sp)
811242cc:	018c303a 	nor	r6,zero,r6
811242d0:	d9800515 	stw	r6,20(sp)
811242d4:	a80b883a 	mov	r5,r21
811242d8:	e009883a 	mov	r4,fp
811242dc:	11267200 	call	81126720 <_Bfree>
811242e0:	883e4926 	beq	r17,zero,81123c08 <__reset+0xfb103c08>
811242e4:	003fad06 	br	8112419c <__reset+0xfb10419c>
811242e8:	d9c01117 	ldw	r7,68(sp)
811242ec:	3801bc26 	beq	r7,zero,811249e0 <_dtoa_r+0x1488>
811242f0:	10810cc4 	addi	r2,r2,1075
811242f4:	dd400a17 	ldw	r21,40(sp)
811242f8:	dd000817 	ldw	r20,32(sp)
811242fc:	003f0a06 	br	81123f28 <__reset+0xfb103f28>
81124300:	00800704 	movi	r2,28
81124304:	d9000817 	ldw	r4,32(sp)
81124308:	a0a9883a 	add	r20,r20,r2
8112430c:	b0ad883a 	add	r22,r22,r2
81124310:	2089883a 	add	r4,r4,r2
81124314:	d9000815 	stw	r4,32(sp)
81124318:	003f5106 	br	81124060 <__reset+0xfb104060>
8112431c:	d8c00317 	ldw	r3,12(sp)
81124320:	b8c1fc0e 	bge	r23,r3,81124b14 <_dtoa_r+0x15bc>
81124324:	0027883a 	mov	r19,zero
81124328:	b805883a 	mov	r2,r23
8112432c:	003f3e06 	br	81124028 <__reset+0xfb104028>
81124330:	880b883a 	mov	r5,r17
81124334:	e009883a 	mov	r4,fp
81124338:	000f883a 	mov	r7,zero
8112433c:	01800284 	movi	r6,10
81124340:	11267480 	call	81126748 <__multadd>
81124344:	d9000c17 	ldw	r4,48(sp)
81124348:	1023883a 	mov	r17,r2
8112434c:	0102040e 	bge	zero,r4,81124b60 <_dtoa_r+0x1608>
81124350:	d9000615 	stw	r4,24(sp)
81124354:	0500050e 	bge	zero,r20,8112436c <_dtoa_r+0xe14>
81124358:	880b883a 	mov	r5,r17
8112435c:	a00d883a 	mov	r6,r20
81124360:	e009883a 	mov	r4,fp
81124364:	1126e200 	call	81126e20 <__lshift>
81124368:	1023883a 	mov	r17,r2
8112436c:	9801241e 	bne	r19,zero,81124800 <_dtoa_r+0x12a8>
81124370:	8829883a 	mov	r20,r17
81124374:	d9000617 	ldw	r4,24(sp)
81124378:	dcc00717 	ldw	r19,28(sp)
8112437c:	9480004c 	andi	r18,r18,1
81124380:	20bfffc4 	addi	r2,r4,-1
81124384:	9885883a 	add	r2,r19,r2
81124388:	d8800415 	stw	r2,16(sp)
8112438c:	dc800615 	stw	r18,24(sp)
81124390:	a80b883a 	mov	r5,r21
81124394:	8009883a 	mov	r4,r16
81124398:	11233500 	call	81123350 <quorem>
8112439c:	880b883a 	mov	r5,r17
811243a0:	8009883a 	mov	r4,r16
811243a4:	102f883a 	mov	r23,r2
811243a8:	1126f700 	call	81126f70 <__mcmp>
811243ac:	a80b883a 	mov	r5,r21
811243b0:	a00d883a 	mov	r6,r20
811243b4:	e009883a 	mov	r4,fp
811243b8:	102d883a 	mov	r22,r2
811243bc:	1126fd00 	call	81126fd0 <__mdiff>
811243c0:	1007883a 	mov	r3,r2
811243c4:	10800317 	ldw	r2,12(r2)
811243c8:	bc800c04 	addi	r18,r23,48
811243cc:	180b883a 	mov	r5,r3
811243d0:	10004e1e 	bne	r2,zero,8112450c <_dtoa_r+0xfb4>
811243d4:	8009883a 	mov	r4,r16
811243d8:	d8c01615 	stw	r3,88(sp)
811243dc:	1126f700 	call	81126f70 <__mcmp>
811243e0:	d8c01617 	ldw	r3,88(sp)
811243e4:	e009883a 	mov	r4,fp
811243e8:	d8801615 	stw	r2,88(sp)
811243ec:	180b883a 	mov	r5,r3
811243f0:	11267200 	call	81126720 <_Bfree>
811243f4:	d8801617 	ldw	r2,88(sp)
811243f8:	1000041e 	bne	r2,zero,8112440c <_dtoa_r+0xeb4>
811243fc:	d9800317 	ldw	r6,12(sp)
81124400:	3000021e 	bne	r6,zero,8112440c <_dtoa_r+0xeb4>
81124404:	d8c00617 	ldw	r3,24(sp)
81124408:	18003726 	beq	r3,zero,811244e8 <_dtoa_r+0xf90>
8112440c:	b0002016 	blt	r22,zero,81124490 <_dtoa_r+0xf38>
81124410:	b000041e 	bne	r22,zero,81124424 <_dtoa_r+0xecc>
81124414:	d9000317 	ldw	r4,12(sp)
81124418:	2000021e 	bne	r4,zero,81124424 <_dtoa_r+0xecc>
8112441c:	d8c00617 	ldw	r3,24(sp)
81124420:	18001b26 	beq	r3,zero,81124490 <_dtoa_r+0xf38>
81124424:	00810716 	blt	zero,r2,81124844 <_dtoa_r+0x12ec>
81124428:	d8c00417 	ldw	r3,16(sp)
8112442c:	9d800044 	addi	r22,r19,1
81124430:	9c800005 	stb	r18,0(r19)
81124434:	b02f883a 	mov	r23,r22
81124438:	98c10626 	beq	r19,r3,81124854 <_dtoa_r+0x12fc>
8112443c:	800b883a 	mov	r5,r16
81124440:	000f883a 	mov	r7,zero
81124444:	01800284 	movi	r6,10
81124448:	e009883a 	mov	r4,fp
8112444c:	11267480 	call	81126748 <__multadd>
81124450:	1021883a 	mov	r16,r2
81124454:	000f883a 	mov	r7,zero
81124458:	01800284 	movi	r6,10
8112445c:	880b883a 	mov	r5,r17
81124460:	e009883a 	mov	r4,fp
81124464:	8d002526 	beq	r17,r20,811244fc <_dtoa_r+0xfa4>
81124468:	11267480 	call	81126748 <__multadd>
8112446c:	a00b883a 	mov	r5,r20
81124470:	000f883a 	mov	r7,zero
81124474:	01800284 	movi	r6,10
81124478:	e009883a 	mov	r4,fp
8112447c:	1023883a 	mov	r17,r2
81124480:	11267480 	call	81126748 <__multadd>
81124484:	1029883a 	mov	r20,r2
81124488:	b027883a 	mov	r19,r22
8112448c:	003fc006 	br	81124390 <__reset+0xfb104390>
81124490:	9011883a 	mov	r8,r18
81124494:	00800e0e 	bge	zero,r2,811244d0 <_dtoa_r+0xf78>
81124498:	800b883a 	mov	r5,r16
8112449c:	01800044 	movi	r6,1
811244a0:	e009883a 	mov	r4,fp
811244a4:	da001715 	stw	r8,92(sp)
811244a8:	1126e200 	call	81126e20 <__lshift>
811244ac:	a80b883a 	mov	r5,r21
811244b0:	1009883a 	mov	r4,r2
811244b4:	1021883a 	mov	r16,r2
811244b8:	1126f700 	call	81126f70 <__mcmp>
811244bc:	da001717 	ldw	r8,92(sp)
811244c0:	0081960e 	bge	zero,r2,81124b1c <_dtoa_r+0x15c4>
811244c4:	00800e44 	movi	r2,57
811244c8:	40817026 	beq	r8,r2,81124a8c <_dtoa_r+0x1534>
811244cc:	ba000c44 	addi	r8,r23,49
811244d0:	8825883a 	mov	r18,r17
811244d4:	9dc00044 	addi	r23,r19,1
811244d8:	9a000005 	stb	r8,0(r19)
811244dc:	a023883a 	mov	r17,r20
811244e0:	dc000915 	stw	r16,36(sp)
811244e4:	003f2406 	br	81124178 <__reset+0xfb104178>
811244e8:	00800e44 	movi	r2,57
811244ec:	9011883a 	mov	r8,r18
811244f0:	90816626 	beq	r18,r2,81124a8c <_dtoa_r+0x1534>
811244f4:	05bff516 	blt	zero,r22,811244cc <__reset+0xfb1044cc>
811244f8:	003ff506 	br	811244d0 <__reset+0xfb1044d0>
811244fc:	11267480 	call	81126748 <__multadd>
81124500:	1023883a 	mov	r17,r2
81124504:	1029883a 	mov	r20,r2
81124508:	003fdf06 	br	81124488 <__reset+0xfb104488>
8112450c:	e009883a 	mov	r4,fp
81124510:	11267200 	call	81126720 <_Bfree>
81124514:	00800044 	movi	r2,1
81124518:	003fbc06 	br	8112440c <__reset+0xfb10440c>
8112451c:	a80b883a 	mov	r5,r21
81124520:	8009883a 	mov	r4,r16
81124524:	1126f700 	call	81126f70 <__mcmp>
81124528:	103edb0e 	bge	r2,zero,81124098 <__reset+0xfb104098>
8112452c:	800b883a 	mov	r5,r16
81124530:	000f883a 	mov	r7,zero
81124534:	01800284 	movi	r6,10
81124538:	e009883a 	mov	r4,fp
8112453c:	11267480 	call	81126748 <__multadd>
81124540:	1021883a 	mov	r16,r2
81124544:	d8800517 	ldw	r2,20(sp)
81124548:	d8c00b17 	ldw	r3,44(sp)
8112454c:	10bfffc4 	addi	r2,r2,-1
81124550:	d8800515 	stw	r2,20(sp)
81124554:	183f761e 	bne	r3,zero,81124330 <__reset+0xfb104330>
81124558:	d9000c17 	ldw	r4,48(sp)
8112455c:	0101730e 	bge	zero,r4,81124b2c <_dtoa_r+0x15d4>
81124560:	d9000615 	stw	r4,24(sp)
81124564:	003ed006 	br	811240a8 <__reset+0xfb1040a8>
81124568:	00800084 	movi	r2,2
8112456c:	3081861e 	bne	r6,r2,81124b88 <_dtoa_r+0x1630>
81124570:	d8000b15 	stw	zero,44(sp)
81124574:	003f3c06 	br	81124268 <__reset+0xfb104268>
81124578:	dc000917 	ldw	r16,36(sp)
8112457c:	003e9206 	br	81123fc8 <__reset+0xfb103fc8>
81124580:	d9c00317 	ldw	r7,12(sp)
81124584:	00800084 	movi	r2,2
81124588:	11fec50e 	bge	r2,r7,811240a0 <__reset+0xfb1040a0>
8112458c:	d9000617 	ldw	r4,24(sp)
81124590:	20013c1e 	bne	r4,zero,81124a84 <_dtoa_r+0x152c>
81124594:	a80b883a 	mov	r5,r21
81124598:	000f883a 	mov	r7,zero
8112459c:	01800144 	movi	r6,5
811245a0:	e009883a 	mov	r4,fp
811245a4:	11267480 	call	81126748 <__multadd>
811245a8:	100b883a 	mov	r5,r2
811245ac:	8009883a 	mov	r4,r16
811245b0:	102b883a 	mov	r21,r2
811245b4:	1126f700 	call	81126f70 <__mcmp>
811245b8:	dc000915 	stw	r16,36(sp)
811245bc:	00bf410e 	bge	zero,r2,811242c4 <__reset+0xfb1042c4>
811245c0:	d9c00717 	ldw	r7,28(sp)
811245c4:	00800c44 	movi	r2,49
811245c8:	38800005 	stb	r2,0(r7)
811245cc:	d8800517 	ldw	r2,20(sp)
811245d0:	3dc00044 	addi	r23,r7,1
811245d4:	10800044 	addi	r2,r2,1
811245d8:	d8800515 	stw	r2,20(sp)
811245dc:	003f3d06 	br	811242d4 <__reset+0xfb1042d4>
811245e0:	d9800517 	ldw	r6,20(sp)
811245e4:	d9c00717 	ldw	r7,28(sp)
811245e8:	00800c44 	movi	r2,49
811245ec:	31800044 	addi	r6,r6,1
811245f0:	d9800515 	stw	r6,20(sp)
811245f4:	38800005 	stb	r2,0(r7)
811245f8:	003edf06 	br	81124178 <__reset+0xfb104178>
811245fc:	d8000b15 	stw	zero,44(sp)
81124600:	003c9f06 	br	81123880 <__reset+0xfb103880>
81124604:	903e7e1e 	bne	r18,zero,81124000 <__reset+0xfb104000>
81124608:	00800434 	movhi	r2,16
8112460c:	10bfffc4 	addi	r2,r2,-1
81124610:	9884703a 	and	r2,r19,r2
81124614:	1000ea1e 	bne	r2,zero,811249c0 <_dtoa_r+0x1468>
81124618:	9cdffc2c 	andhi	r19,r19,32752
8112461c:	9800e826 	beq	r19,zero,811249c0 <_dtoa_r+0x1468>
81124620:	d9c00817 	ldw	r7,32(sp)
81124624:	b5800044 	addi	r22,r22,1
81124628:	04c00044 	movi	r19,1
8112462c:	39c00044 	addi	r7,r7,1
81124630:	d9c00815 	stw	r7,32(sp)
81124634:	d8800d17 	ldw	r2,52(sp)
81124638:	103e721e 	bne	r2,zero,81124004 <__reset+0xfb104004>
8112463c:	00800044 	movi	r2,1
81124640:	003e7906 	br	81124028 <__reset+0xfb104028>
81124644:	8009883a 	mov	r4,r16
81124648:	1130a600 	call	81130a60 <__floatsidf>
8112464c:	d9800f17 	ldw	r6,60(sp)
81124650:	d9c01017 	ldw	r7,64(sp)
81124654:	1009883a 	mov	r4,r2
81124658:	180b883a 	mov	r5,r3
8112465c:	111a7f00 	call	8111a7f0 <__muldf3>
81124660:	000d883a 	mov	r6,zero
81124664:	01d00734 	movhi	r7,16412
81124668:	1009883a 	mov	r4,r2
8112466c:	180b883a 	mov	r5,r3
81124670:	112ece00 	call	8112ece0 <__adddf3>
81124674:	047f3034 	movhi	r17,64704
81124678:	1021883a 	mov	r16,r2
8112467c:	1c63883a 	add	r17,r3,r17
81124680:	d9000f17 	ldw	r4,60(sp)
81124684:	d9401017 	ldw	r5,64(sp)
81124688:	000d883a 	mov	r6,zero
8112468c:	01d00534 	movhi	r7,16404
81124690:	11300dc0 	call	811300dc <__subdf3>
81124694:	800d883a 	mov	r6,r16
81124698:	880f883a 	mov	r7,r17
8112469c:	1009883a 	mov	r4,r2
811246a0:	180b883a 	mov	r5,r3
811246a4:	102b883a 	mov	r21,r2
811246a8:	1829883a 	mov	r20,r3
811246ac:	112ff0c0 	call	8112ff0c <__gedf2>
811246b0:	00806c16 	blt	zero,r2,81124864 <_dtoa_r+0x130c>
811246b4:	89e0003c 	xorhi	r7,r17,32768
811246b8:	800d883a 	mov	r6,r16
811246bc:	a809883a 	mov	r4,r21
811246c0:	a00b883a 	mov	r5,r20
811246c4:	112ffe80 	call	8112ffe8 <__ledf2>
811246c8:	103d7e0e 	bge	r2,zero,81123cc4 <__reset+0xfb103cc4>
811246cc:	002b883a 	mov	r21,zero
811246d0:	0023883a 	mov	r17,zero
811246d4:	003efb06 	br	811242c4 <__reset+0xfb1042c4>
811246d8:	d8800717 	ldw	r2,28(sp)
811246dc:	003bd006 	br	81123620 <__reset+0xfb103620>
811246e0:	d9000a17 	ldw	r4,40(sp)
811246e4:	d9800d17 	ldw	r6,52(sp)
811246e8:	dd400a15 	stw	r21,40(sp)
811246ec:	a905c83a 	sub	r2,r21,r4
811246f0:	308d883a 	add	r6,r6,r2
811246f4:	d9800d15 	stw	r6,52(sp)
811246f8:	002b883a 	mov	r21,zero
811246fc:	003e0606 	br	81123f18 <__reset+0xfb103f18>
81124700:	9023883a 	mov	r17,r18
81124704:	9829883a 	mov	r20,r19
81124708:	04000084 	movi	r16,2
8112470c:	003c9206 	br	81123958 <__reset+0xfb103958>
81124710:	04000044 	movi	r16,1
81124714:	dc000c15 	stw	r16,48(sp)
81124718:	dc000615 	stw	r16,24(sp)
8112471c:	dc002215 	stw	r16,136(sp)
81124720:	e0001115 	stw	zero,68(fp)
81124724:	000b883a 	mov	r5,zero
81124728:	003c6906 	br	811238d0 <__reset+0xfb1038d0>
8112472c:	3021883a 	mov	r16,r6
81124730:	003ffb06 	br	81124720 <__reset+0xfb104720>
81124734:	1000021e 	bne	r2,zero,81124740 <_dtoa_r+0x11e8>
81124738:	4200004c 	andi	r8,r8,1
8112473c:	403e7d1e 	bne	r8,zero,81124134 <__reset+0xfb104134>
81124740:	01000c04 	movi	r4,48
81124744:	00000106 	br	8112474c <_dtoa_r+0x11f4>
81124748:	102f883a 	mov	r23,r2
8112474c:	b8bfffc4 	addi	r2,r23,-1
81124750:	10c00007 	ldb	r3,0(r2)
81124754:	193ffc26 	beq	r3,r4,81124748 <__reset+0xfb104748>
81124758:	003e8706 	br	81124178 <__reset+0xfb104178>
8112475c:	d8800517 	ldw	r2,20(sp)
81124760:	00a3c83a 	sub	r17,zero,r2
81124764:	8800a426 	beq	r17,zero,811249f8 <_dtoa_r+0x14a0>
81124768:	888003cc 	andi	r2,r17,15
8112476c:	100490fa 	slli	r2,r2,3
81124770:	00e04574 	movhi	r3,33045
81124774:	18e9bf04 	addi	r3,r3,-22788
81124778:	1885883a 	add	r2,r3,r2
8112477c:	11800017 	ldw	r6,0(r2)
81124780:	11c00117 	ldw	r7,4(r2)
81124784:	9009883a 	mov	r4,r18
81124788:	980b883a 	mov	r5,r19
8112478c:	8823d13a 	srai	r17,r17,4
81124790:	111a7f00 	call	8111a7f0 <__muldf3>
81124794:	d8800f15 	stw	r2,60(sp)
81124798:	d8c01015 	stw	r3,64(sp)
8112479c:	8800e826 	beq	r17,zero,81124b40 <_dtoa_r+0x15e8>
811247a0:	05204574 	movhi	r20,33045
811247a4:	a529b504 	addi	r20,r20,-22828
811247a8:	04000084 	movi	r16,2
811247ac:	8980004c 	andi	r6,r17,1
811247b0:	1009883a 	mov	r4,r2
811247b4:	8823d07a 	srai	r17,r17,1
811247b8:	180b883a 	mov	r5,r3
811247bc:	30000426 	beq	r6,zero,811247d0 <_dtoa_r+0x1278>
811247c0:	a1800017 	ldw	r6,0(r20)
811247c4:	a1c00117 	ldw	r7,4(r20)
811247c8:	84000044 	addi	r16,r16,1
811247cc:	111a7f00 	call	8111a7f0 <__muldf3>
811247d0:	a5000204 	addi	r20,r20,8
811247d4:	883ff51e 	bne	r17,zero,811247ac <__reset+0xfb1047ac>
811247d8:	d8800f15 	stw	r2,60(sp)
811247dc:	d8c01015 	stw	r3,64(sp)
811247e0:	003c7606 	br	811239bc <__reset+0xfb1039bc>
811247e4:	00c00c04 	movi	r3,48
811247e8:	10c00005 	stb	r3,0(r2)
811247ec:	d8c00517 	ldw	r3,20(sp)
811247f0:	bd3fffc3 	ldbu	r20,-1(r23)
811247f4:	18c00044 	addi	r3,r3,1
811247f8:	d8c00515 	stw	r3,20(sp)
811247fc:	003db906 	br	81123ee4 <__reset+0xfb103ee4>
81124800:	89400117 	ldw	r5,4(r17)
81124804:	e009883a 	mov	r4,fp
81124808:	11266700 	call	81126670 <_Balloc>
8112480c:	89800417 	ldw	r6,16(r17)
81124810:	89400304 	addi	r5,r17,12
81124814:	11000304 	addi	r4,r2,12
81124818:	31800084 	addi	r6,r6,2
8112481c:	318d883a 	add	r6,r6,r6
81124820:	318d883a 	add	r6,r6,r6
81124824:	1027883a 	mov	r19,r2
81124828:	111c4400 	call	8111c440 <memcpy>
8112482c:	01800044 	movi	r6,1
81124830:	980b883a 	mov	r5,r19
81124834:	e009883a 	mov	r4,fp
81124838:	1126e200 	call	81126e20 <__lshift>
8112483c:	1029883a 	mov	r20,r2
81124840:	003ecc06 	br	81124374 <__reset+0xfb104374>
81124844:	00800e44 	movi	r2,57
81124848:	90809026 	beq	r18,r2,81124a8c <_dtoa_r+0x1534>
8112484c:	92000044 	addi	r8,r18,1
81124850:	003f1f06 	br	811244d0 <__reset+0xfb1044d0>
81124854:	9011883a 	mov	r8,r18
81124858:	8825883a 	mov	r18,r17
8112485c:	a023883a 	mov	r17,r20
81124860:	003e2906 	br	81124108 <__reset+0xfb104108>
81124864:	002b883a 	mov	r21,zero
81124868:	0023883a 	mov	r17,zero
8112486c:	003f5406 	br	811245c0 <__reset+0xfb1045c0>
81124870:	61bfffc4 	addi	r6,r12,-1
81124874:	300490fa 	slli	r2,r6,3
81124878:	00e04574 	movhi	r3,33045
8112487c:	18e9bf04 	addi	r3,r3,-22788
81124880:	1885883a 	add	r2,r3,r2
81124884:	11000017 	ldw	r4,0(r2)
81124888:	11400117 	ldw	r5,4(r2)
8112488c:	d8800717 	ldw	r2,28(sp)
81124890:	880f883a 	mov	r7,r17
81124894:	d9801215 	stw	r6,72(sp)
81124898:	800d883a 	mov	r6,r16
8112489c:	db001615 	stw	r12,88(sp)
811248a0:	15c00044 	addi	r23,r2,1
811248a4:	111a7f00 	call	8111a7f0 <__muldf3>
811248a8:	d9401017 	ldw	r5,64(sp)
811248ac:	d9000f17 	ldw	r4,60(sp)
811248b0:	d8c01515 	stw	r3,84(sp)
811248b4:	d8801415 	stw	r2,80(sp)
811248b8:	11309e00 	call	811309e0 <__fixdfsi>
811248bc:	1009883a 	mov	r4,r2
811248c0:	1021883a 	mov	r16,r2
811248c4:	1130a600 	call	81130a60 <__floatsidf>
811248c8:	d9000f17 	ldw	r4,60(sp)
811248cc:	d9401017 	ldw	r5,64(sp)
811248d0:	100d883a 	mov	r6,r2
811248d4:	180f883a 	mov	r7,r3
811248d8:	11300dc0 	call	811300dc <__subdf3>
811248dc:	1829883a 	mov	r20,r3
811248e0:	d8c00717 	ldw	r3,28(sp)
811248e4:	84000c04 	addi	r16,r16,48
811248e8:	1023883a 	mov	r17,r2
811248ec:	1c000005 	stb	r16,0(r3)
811248f0:	db001617 	ldw	r12,88(sp)
811248f4:	00800044 	movi	r2,1
811248f8:	60802226 	beq	r12,r2,81124984 <_dtoa_r+0x142c>
811248fc:	d9c00717 	ldw	r7,28(sp)
81124900:	8805883a 	mov	r2,r17
81124904:	b82b883a 	mov	r21,r23
81124908:	3b19883a 	add	r12,r7,r12
8112490c:	6023883a 	mov	r17,r12
81124910:	a007883a 	mov	r3,r20
81124914:	dc800f15 	stw	r18,60(sp)
81124918:	000d883a 	mov	r6,zero
8112491c:	01d00934 	movhi	r7,16420
81124920:	1009883a 	mov	r4,r2
81124924:	180b883a 	mov	r5,r3
81124928:	111a7f00 	call	8111a7f0 <__muldf3>
8112492c:	180b883a 	mov	r5,r3
81124930:	1009883a 	mov	r4,r2
81124934:	1829883a 	mov	r20,r3
81124938:	1025883a 	mov	r18,r2
8112493c:	11309e00 	call	811309e0 <__fixdfsi>
81124940:	1009883a 	mov	r4,r2
81124944:	1021883a 	mov	r16,r2
81124948:	1130a600 	call	81130a60 <__floatsidf>
8112494c:	100d883a 	mov	r6,r2
81124950:	180f883a 	mov	r7,r3
81124954:	9009883a 	mov	r4,r18
81124958:	a00b883a 	mov	r5,r20
8112495c:	84000c04 	addi	r16,r16,48
81124960:	11300dc0 	call	811300dc <__subdf3>
81124964:	ad400044 	addi	r21,r21,1
81124968:	ac3fffc5 	stb	r16,-1(r21)
8112496c:	ac7fea1e 	bne	r21,r17,81124918 <__reset+0xfb104918>
81124970:	1023883a 	mov	r17,r2
81124974:	d8801217 	ldw	r2,72(sp)
81124978:	dc800f17 	ldw	r18,60(sp)
8112497c:	1829883a 	mov	r20,r3
81124980:	b8af883a 	add	r23,r23,r2
81124984:	d9001417 	ldw	r4,80(sp)
81124988:	d9401517 	ldw	r5,84(sp)
8112498c:	000d883a 	mov	r6,zero
81124990:	01cff834 	movhi	r7,16352
81124994:	112ece00 	call	8112ece0 <__adddf3>
81124998:	880d883a 	mov	r6,r17
8112499c:	a00f883a 	mov	r7,r20
811249a0:	1009883a 	mov	r4,r2
811249a4:	180b883a 	mov	r5,r3
811249a8:	112ffe80 	call	8112ffe8 <__ledf2>
811249ac:	10003e0e 	bge	r2,zero,81124aa8 <_dtoa_r+0x1550>
811249b0:	d9001317 	ldw	r4,76(sp)
811249b4:	bd3fffc3 	ldbu	r20,-1(r23)
811249b8:	d9000515 	stw	r4,20(sp)
811249bc:	003d3b06 	br	81123eac <__reset+0xfb103eac>
811249c0:	0027883a 	mov	r19,zero
811249c4:	003f1b06 	br	81124634 <__reset+0xfb104634>
811249c8:	d8800817 	ldw	r2,32(sp)
811249cc:	11e9c83a 	sub	r20,r2,r7
811249d0:	0005883a 	mov	r2,zero
811249d4:	003d5406 	br	81123f28 <__reset+0xfb103f28>
811249d8:	00800044 	movi	r2,1
811249dc:	003dc706 	br	811240fc <__reset+0xfb1040fc>
811249e0:	d8c00217 	ldw	r3,8(sp)
811249e4:	00800d84 	movi	r2,54
811249e8:	dd400a17 	ldw	r21,40(sp)
811249ec:	10c5c83a 	sub	r2,r2,r3
811249f0:	dd000817 	ldw	r20,32(sp)
811249f4:	003d4c06 	br	81123f28 <__reset+0xfb103f28>
811249f8:	dc800f15 	stw	r18,60(sp)
811249fc:	dcc01015 	stw	r19,64(sp)
81124a00:	04000084 	movi	r16,2
81124a04:	003bed06 	br	811239bc <__reset+0xfb1039bc>
81124a08:	d9000617 	ldw	r4,24(sp)
81124a0c:	203f0d26 	beq	r4,zero,81124644 <__reset+0xfb104644>
81124a10:	d9800c17 	ldw	r6,48(sp)
81124a14:	01bcab0e 	bge	zero,r6,81123cc4 <__reset+0xfb103cc4>
81124a18:	d9401017 	ldw	r5,64(sp)
81124a1c:	d9000f17 	ldw	r4,60(sp)
81124a20:	000d883a 	mov	r6,zero
81124a24:	01d00934 	movhi	r7,16420
81124a28:	111a7f00 	call	8111a7f0 <__muldf3>
81124a2c:	81000044 	addi	r4,r16,1
81124a30:	d8800f15 	stw	r2,60(sp)
81124a34:	d8c01015 	stw	r3,64(sp)
81124a38:	1130a600 	call	81130a60 <__floatsidf>
81124a3c:	d9800f17 	ldw	r6,60(sp)
81124a40:	d9c01017 	ldw	r7,64(sp)
81124a44:	1009883a 	mov	r4,r2
81124a48:	180b883a 	mov	r5,r3
81124a4c:	111a7f00 	call	8111a7f0 <__muldf3>
81124a50:	01d00734 	movhi	r7,16412
81124a54:	000d883a 	mov	r6,zero
81124a58:	1009883a 	mov	r4,r2
81124a5c:	180b883a 	mov	r5,r3
81124a60:	112ece00 	call	8112ece0 <__adddf3>
81124a64:	d9c00517 	ldw	r7,20(sp)
81124a68:	047f3034 	movhi	r17,64704
81124a6c:	1021883a 	mov	r16,r2
81124a70:	39ffffc4 	addi	r7,r7,-1
81124a74:	d9c01315 	stw	r7,76(sp)
81124a78:	1c63883a 	add	r17,r3,r17
81124a7c:	db000c17 	ldw	r12,48(sp)
81124a80:	003bea06 	br	81123a2c <__reset+0xfb103a2c>
81124a84:	dc000915 	stw	r16,36(sp)
81124a88:	003e0e06 	br	811242c4 <__reset+0xfb1042c4>
81124a8c:	01000e44 	movi	r4,57
81124a90:	8825883a 	mov	r18,r17
81124a94:	9dc00044 	addi	r23,r19,1
81124a98:	99000005 	stb	r4,0(r19)
81124a9c:	a023883a 	mov	r17,r20
81124aa0:	dc000915 	stw	r16,36(sp)
81124aa4:	003da406 	br	81124138 <__reset+0xfb104138>
81124aa8:	d9801417 	ldw	r6,80(sp)
81124aac:	d9c01517 	ldw	r7,84(sp)
81124ab0:	0009883a 	mov	r4,zero
81124ab4:	014ff834 	movhi	r5,16352
81124ab8:	11300dc0 	call	811300dc <__subdf3>
81124abc:	880d883a 	mov	r6,r17
81124ac0:	a00f883a 	mov	r7,r20
81124ac4:	1009883a 	mov	r4,r2
81124ac8:	180b883a 	mov	r5,r3
81124acc:	112ff0c0 	call	8112ff0c <__gedf2>
81124ad0:	00bc7c0e 	bge	zero,r2,81123cc4 <__reset+0xfb103cc4>
81124ad4:	01000c04 	movi	r4,48
81124ad8:	00000106 	br	81124ae0 <_dtoa_r+0x1588>
81124adc:	102f883a 	mov	r23,r2
81124ae0:	b8bfffc4 	addi	r2,r23,-1
81124ae4:	10c00007 	ldb	r3,0(r2)
81124ae8:	193ffc26 	beq	r3,r4,81124adc <__reset+0xfb104adc>
81124aec:	d9801317 	ldw	r6,76(sp)
81124af0:	d9800515 	stw	r6,20(sp)
81124af4:	003c4406 	br	81123c08 <__reset+0xfb103c08>
81124af8:	d9801317 	ldw	r6,76(sp)
81124afc:	d9800515 	stw	r6,20(sp)
81124b00:	003cea06 	br	81123eac <__reset+0xfb103eac>
81124b04:	dd800f17 	ldw	r22,60(sp)
81124b08:	dcc01017 	ldw	r19,64(sp)
81124b0c:	dc801217 	ldw	r18,72(sp)
81124b10:	003c6c06 	br	81123cc4 <__reset+0xfb103cc4>
81124b14:	903e031e 	bne	r18,zero,81124324 <__reset+0xfb104324>
81124b18:	003ebb06 	br	81124608 <__reset+0xfb104608>
81124b1c:	103e6c1e 	bne	r2,zero,811244d0 <__reset+0xfb1044d0>
81124b20:	4080004c 	andi	r2,r8,1
81124b24:	103e6a26 	beq	r2,zero,811244d0 <__reset+0xfb1044d0>
81124b28:	003e6606 	br	811244c4 <__reset+0xfb1044c4>
81124b2c:	d8c00317 	ldw	r3,12(sp)
81124b30:	00800084 	movi	r2,2
81124b34:	10c02916 	blt	r2,r3,81124bdc <_dtoa_r+0x1684>
81124b38:	d9000c17 	ldw	r4,48(sp)
81124b3c:	003e8806 	br	81124560 <__reset+0xfb104560>
81124b40:	04000084 	movi	r16,2
81124b44:	003b9d06 	br	811239bc <__reset+0xfb1039bc>
81124b48:	d9001317 	ldw	r4,76(sp)
81124b4c:	d9000515 	stw	r4,20(sp)
81124b50:	003cd606 	br	81123eac <__reset+0xfb103eac>
81124b54:	d8801317 	ldw	r2,76(sp)
81124b58:	d8800515 	stw	r2,20(sp)
81124b5c:	003c2a06 	br	81123c08 <__reset+0xfb103c08>
81124b60:	d9800317 	ldw	r6,12(sp)
81124b64:	00800084 	movi	r2,2
81124b68:	11801516 	blt	r2,r6,81124bc0 <_dtoa_r+0x1668>
81124b6c:	d9c00c17 	ldw	r7,48(sp)
81124b70:	d9c00615 	stw	r7,24(sp)
81124b74:	003df706 	br	81124354 <__reset+0xfb104354>
81124b78:	193d3926 	beq	r3,r4,81124060 <__reset+0xfb104060>
81124b7c:	00c00f04 	movi	r3,60
81124b80:	1885c83a 	sub	r2,r3,r2
81124b84:	003ddf06 	br	81124304 <__reset+0xfb104304>
81124b88:	e009883a 	mov	r4,fp
81124b8c:	e0001115 	stw	zero,68(fp)
81124b90:	000b883a 	mov	r5,zero
81124b94:	11266700 	call	81126670 <_Balloc>
81124b98:	d8800715 	stw	r2,28(sp)
81124b9c:	d8c00717 	ldw	r3,28(sp)
81124ba0:	00bfffc4 	movi	r2,-1
81124ba4:	01000044 	movi	r4,1
81124ba8:	d8800c15 	stw	r2,48(sp)
81124bac:	e0c01015 	stw	r3,64(fp)
81124bb0:	d9000b15 	stw	r4,44(sp)
81124bb4:	d8800615 	stw	r2,24(sp)
81124bb8:	d8002215 	stw	zero,136(sp)
81124bbc:	003c4106 	br	81123cc4 <__reset+0xfb103cc4>
81124bc0:	d8c00c17 	ldw	r3,48(sp)
81124bc4:	d8c00615 	stw	r3,24(sp)
81124bc8:	003e7006 	br	8112458c <__reset+0xfb10458c>
81124bcc:	04400044 	movi	r17,1
81124bd0:	003b2006 	br	81123854 <__reset+0xfb103854>
81124bd4:	000b883a 	mov	r5,zero
81124bd8:	003b3d06 	br	811238d0 <__reset+0xfb1038d0>
81124bdc:	d8800c17 	ldw	r2,48(sp)
81124be0:	d8800615 	stw	r2,24(sp)
81124be4:	003e6906 	br	8112458c <__reset+0xfb10458c>

81124be8 <__sflush_r>:
81124be8:	defffb04 	addi	sp,sp,-20
81124bec:	de00012e 	bgeu	sp,et,81124bf4 <__sflush_r+0xc>
81124bf0:	003b68fa 	trap	3
81124bf4:	2880030b 	ldhu	r2,12(r5)
81124bf8:	dcc00315 	stw	r19,12(sp)
81124bfc:	dc400115 	stw	r17,4(sp)
81124c00:	dfc00415 	stw	ra,16(sp)
81124c04:	dc800215 	stw	r18,8(sp)
81124c08:	dc000015 	stw	r16,0(sp)
81124c0c:	10c0020c 	andi	r3,r2,8
81124c10:	2823883a 	mov	r17,r5
81124c14:	2027883a 	mov	r19,r4
81124c18:	1800311e 	bne	r3,zero,81124ce0 <__sflush_r+0xf8>
81124c1c:	28c00117 	ldw	r3,4(r5)
81124c20:	10820014 	ori	r2,r2,2048
81124c24:	2880030d 	sth	r2,12(r5)
81124c28:	00c04b0e 	bge	zero,r3,81124d58 <__sflush_r+0x170>
81124c2c:	8a000a17 	ldw	r8,40(r17)
81124c30:	40002326 	beq	r8,zero,81124cc0 <__sflush_r+0xd8>
81124c34:	9c000017 	ldw	r16,0(r19)
81124c38:	10c4000c 	andi	r3,r2,4096
81124c3c:	98000015 	stw	zero,0(r19)
81124c40:	18004826 	beq	r3,zero,81124d64 <__sflush_r+0x17c>
81124c44:	89801417 	ldw	r6,80(r17)
81124c48:	10c0010c 	andi	r3,r2,4
81124c4c:	18000626 	beq	r3,zero,81124c68 <__sflush_r+0x80>
81124c50:	88c00117 	ldw	r3,4(r17)
81124c54:	88800c17 	ldw	r2,48(r17)
81124c58:	30cdc83a 	sub	r6,r6,r3
81124c5c:	10000226 	beq	r2,zero,81124c68 <__sflush_r+0x80>
81124c60:	88800f17 	ldw	r2,60(r17)
81124c64:	308dc83a 	sub	r6,r6,r2
81124c68:	89400717 	ldw	r5,28(r17)
81124c6c:	000f883a 	mov	r7,zero
81124c70:	9809883a 	mov	r4,r19
81124c74:	403ee83a 	callr	r8
81124c78:	00ffffc4 	movi	r3,-1
81124c7c:	10c04426 	beq	r2,r3,81124d90 <__sflush_r+0x1a8>
81124c80:	88c0030b 	ldhu	r3,12(r17)
81124c84:	89000417 	ldw	r4,16(r17)
81124c88:	88000115 	stw	zero,4(r17)
81124c8c:	197dffcc 	andi	r5,r3,63487
81124c90:	8940030d 	sth	r5,12(r17)
81124c94:	89000015 	stw	r4,0(r17)
81124c98:	18c4000c 	andi	r3,r3,4096
81124c9c:	18002c1e 	bne	r3,zero,81124d50 <__sflush_r+0x168>
81124ca0:	89400c17 	ldw	r5,48(r17)
81124ca4:	9c000015 	stw	r16,0(r19)
81124ca8:	28000526 	beq	r5,zero,81124cc0 <__sflush_r+0xd8>
81124cac:	88801004 	addi	r2,r17,64
81124cb0:	28800226 	beq	r5,r2,81124cbc <__sflush_r+0xd4>
81124cb4:	9809883a 	mov	r4,r19
81124cb8:	11256a00 	call	811256a0 <_free_r>
81124cbc:	88000c15 	stw	zero,48(r17)
81124cc0:	0005883a 	mov	r2,zero
81124cc4:	dfc00417 	ldw	ra,16(sp)
81124cc8:	dcc00317 	ldw	r19,12(sp)
81124ccc:	dc800217 	ldw	r18,8(sp)
81124cd0:	dc400117 	ldw	r17,4(sp)
81124cd4:	dc000017 	ldw	r16,0(sp)
81124cd8:	dec00504 	addi	sp,sp,20
81124cdc:	f800283a 	ret
81124ce0:	2c800417 	ldw	r18,16(r5)
81124ce4:	903ff626 	beq	r18,zero,81124cc0 <__reset+0xfb104cc0>
81124ce8:	2c000017 	ldw	r16,0(r5)
81124cec:	108000cc 	andi	r2,r2,3
81124cf0:	2c800015 	stw	r18,0(r5)
81124cf4:	84a1c83a 	sub	r16,r16,r18
81124cf8:	1000131e 	bne	r2,zero,81124d48 <__sflush_r+0x160>
81124cfc:	28800517 	ldw	r2,20(r5)
81124d00:	88800215 	stw	r2,8(r17)
81124d04:	04000316 	blt	zero,r16,81124d14 <__sflush_r+0x12c>
81124d08:	003fed06 	br	81124cc0 <__reset+0xfb104cc0>
81124d0c:	90a5883a 	add	r18,r18,r2
81124d10:	043feb0e 	bge	zero,r16,81124cc0 <__reset+0xfb104cc0>
81124d14:	88800917 	ldw	r2,36(r17)
81124d18:	89400717 	ldw	r5,28(r17)
81124d1c:	800f883a 	mov	r7,r16
81124d20:	900d883a 	mov	r6,r18
81124d24:	9809883a 	mov	r4,r19
81124d28:	103ee83a 	callr	r2
81124d2c:	80a1c83a 	sub	r16,r16,r2
81124d30:	00bff616 	blt	zero,r2,81124d0c <__reset+0xfb104d0c>
81124d34:	88c0030b 	ldhu	r3,12(r17)
81124d38:	00bfffc4 	movi	r2,-1
81124d3c:	18c01014 	ori	r3,r3,64
81124d40:	88c0030d 	sth	r3,12(r17)
81124d44:	003fdf06 	br	81124cc4 <__reset+0xfb104cc4>
81124d48:	0005883a 	mov	r2,zero
81124d4c:	003fec06 	br	81124d00 <__reset+0xfb104d00>
81124d50:	88801415 	stw	r2,80(r17)
81124d54:	003fd206 	br	81124ca0 <__reset+0xfb104ca0>
81124d58:	28c00f17 	ldw	r3,60(r5)
81124d5c:	00ffb316 	blt	zero,r3,81124c2c <__reset+0xfb104c2c>
81124d60:	003fd706 	br	81124cc0 <__reset+0xfb104cc0>
81124d64:	89400717 	ldw	r5,28(r17)
81124d68:	000d883a 	mov	r6,zero
81124d6c:	01c00044 	movi	r7,1
81124d70:	9809883a 	mov	r4,r19
81124d74:	403ee83a 	callr	r8
81124d78:	100d883a 	mov	r6,r2
81124d7c:	00bfffc4 	movi	r2,-1
81124d80:	30801426 	beq	r6,r2,81124dd4 <__sflush_r+0x1ec>
81124d84:	8880030b 	ldhu	r2,12(r17)
81124d88:	8a000a17 	ldw	r8,40(r17)
81124d8c:	003fae06 	br	81124c48 <__reset+0xfb104c48>
81124d90:	98c00017 	ldw	r3,0(r19)
81124d94:	183fba26 	beq	r3,zero,81124c80 <__reset+0xfb104c80>
81124d98:	01000744 	movi	r4,29
81124d9c:	19000626 	beq	r3,r4,81124db8 <__sflush_r+0x1d0>
81124da0:	01000584 	movi	r4,22
81124da4:	19000426 	beq	r3,r4,81124db8 <__sflush_r+0x1d0>
81124da8:	88c0030b 	ldhu	r3,12(r17)
81124dac:	18c01014 	ori	r3,r3,64
81124db0:	88c0030d 	sth	r3,12(r17)
81124db4:	003fc306 	br	81124cc4 <__reset+0xfb104cc4>
81124db8:	8880030b 	ldhu	r2,12(r17)
81124dbc:	88c00417 	ldw	r3,16(r17)
81124dc0:	88000115 	stw	zero,4(r17)
81124dc4:	10bdffcc 	andi	r2,r2,63487
81124dc8:	8880030d 	sth	r2,12(r17)
81124dcc:	88c00015 	stw	r3,0(r17)
81124dd0:	003fb306 	br	81124ca0 <__reset+0xfb104ca0>
81124dd4:	98800017 	ldw	r2,0(r19)
81124dd8:	103fea26 	beq	r2,zero,81124d84 <__reset+0xfb104d84>
81124ddc:	00c00744 	movi	r3,29
81124de0:	10c00226 	beq	r2,r3,81124dec <__sflush_r+0x204>
81124de4:	00c00584 	movi	r3,22
81124de8:	10c0031e 	bne	r2,r3,81124df8 <__sflush_r+0x210>
81124dec:	9c000015 	stw	r16,0(r19)
81124df0:	0005883a 	mov	r2,zero
81124df4:	003fb306 	br	81124cc4 <__reset+0xfb104cc4>
81124df8:	88c0030b 	ldhu	r3,12(r17)
81124dfc:	3005883a 	mov	r2,r6
81124e00:	18c01014 	ori	r3,r3,64
81124e04:	88c0030d 	sth	r3,12(r17)
81124e08:	003fae06 	br	81124cc4 <__reset+0xfb104cc4>

81124e0c <_fflush_r>:
81124e0c:	defffd04 	addi	sp,sp,-12
81124e10:	de00012e 	bgeu	sp,et,81124e18 <_fflush_r+0xc>
81124e14:	003b68fa 	trap	3
81124e18:	dc000115 	stw	r16,4(sp)
81124e1c:	dfc00215 	stw	ra,8(sp)
81124e20:	2021883a 	mov	r16,r4
81124e24:	20000226 	beq	r4,zero,81124e30 <_fflush_r+0x24>
81124e28:	20800e17 	ldw	r2,56(r4)
81124e2c:	10000c26 	beq	r2,zero,81124e60 <_fflush_r+0x54>
81124e30:	2880030f 	ldh	r2,12(r5)
81124e34:	1000051e 	bne	r2,zero,81124e4c <_fflush_r+0x40>
81124e38:	0005883a 	mov	r2,zero
81124e3c:	dfc00217 	ldw	ra,8(sp)
81124e40:	dc000117 	ldw	r16,4(sp)
81124e44:	dec00304 	addi	sp,sp,12
81124e48:	f800283a 	ret
81124e4c:	8009883a 	mov	r4,r16
81124e50:	dfc00217 	ldw	ra,8(sp)
81124e54:	dc000117 	ldw	r16,4(sp)
81124e58:	dec00304 	addi	sp,sp,12
81124e5c:	1124be81 	jmpi	81124be8 <__sflush_r>
81124e60:	d9400015 	stw	r5,0(sp)
81124e64:	11252080 	call	81125208 <__sinit>
81124e68:	d9400017 	ldw	r5,0(sp)
81124e6c:	003ff006 	br	81124e30 <__reset+0xfb104e30>

81124e70 <fflush>:
81124e70:	20000526 	beq	r4,zero,81124e88 <fflush+0x18>
81124e74:	00a04574 	movhi	r2,33045
81124e78:	10b34e04 	addi	r2,r2,-13000
81124e7c:	200b883a 	mov	r5,r4
81124e80:	11000017 	ldw	r4,0(r2)
81124e84:	1124e0c1 	jmpi	81124e0c <_fflush_r>
81124e88:	00a04574 	movhi	r2,33045
81124e8c:	10b34d04 	addi	r2,r2,-13004
81124e90:	11000017 	ldw	r4,0(r2)
81124e94:	016044b4 	movhi	r5,33042
81124e98:	29538304 	addi	r5,r5,19980
81124e9c:	1125f481 	jmpi	81125f48 <_fwalk_reent>

81124ea0 <__fp_unlock>:
81124ea0:	0005883a 	mov	r2,zero
81124ea4:	f800283a 	ret

81124ea8 <_cleanup_r>:
81124ea8:	016044f4 	movhi	r5,33043
81124eac:	29731904 	addi	r5,r5,-13212
81124eb0:	1125f481 	jmpi	81125f48 <_fwalk_reent>

81124eb4 <__sinit.part.1>:
81124eb4:	defff704 	addi	sp,sp,-36
81124eb8:	00e044b4 	movhi	r3,33042
81124ebc:	de00012e 	bgeu	sp,et,81124ec4 <__sinit.part.1+0x10>
81124ec0:	003b68fa 	trap	3
81124ec4:	18d3aa04 	addi	r3,r3,20136
81124ec8:	dfc00815 	stw	ra,32(sp)
81124ecc:	ddc00715 	stw	r23,28(sp)
81124ed0:	dd800615 	stw	r22,24(sp)
81124ed4:	dd400515 	stw	r21,20(sp)
81124ed8:	dd000415 	stw	r20,16(sp)
81124edc:	dcc00315 	stw	r19,12(sp)
81124ee0:	dc800215 	stw	r18,8(sp)
81124ee4:	dc400115 	stw	r17,4(sp)
81124ee8:	dc000015 	stw	r16,0(sp)
81124eec:	24000117 	ldw	r16,4(r4)
81124ef0:	20c00f15 	stw	r3,60(r4)
81124ef4:	2080bb04 	addi	r2,r4,748
81124ef8:	00c000c4 	movi	r3,3
81124efc:	20c0b915 	stw	r3,740(r4)
81124f00:	2080ba15 	stw	r2,744(r4)
81124f04:	2000b815 	stw	zero,736(r4)
81124f08:	05c00204 	movi	r23,8
81124f0c:	00800104 	movi	r2,4
81124f10:	2025883a 	mov	r18,r4
81124f14:	b80d883a 	mov	r6,r23
81124f18:	81001704 	addi	r4,r16,92
81124f1c:	000b883a 	mov	r5,zero
81124f20:	80000015 	stw	zero,0(r16)
81124f24:	80000115 	stw	zero,4(r16)
81124f28:	80000215 	stw	zero,8(r16)
81124f2c:	8080030d 	sth	r2,12(r16)
81124f30:	80001915 	stw	zero,100(r16)
81124f34:	8000038d 	sth	zero,14(r16)
81124f38:	80000415 	stw	zero,16(r16)
81124f3c:	80000515 	stw	zero,20(r16)
81124f40:	80000615 	stw	zero,24(r16)
81124f44:	111c5900 	call	8111c590 <memset>
81124f48:	05a044b4 	movhi	r22,33042
81124f4c:	94400217 	ldw	r17,8(r18)
81124f50:	056044b4 	movhi	r21,33042
81124f54:	052044b4 	movhi	r20,33042
81124f58:	04e044b4 	movhi	r19,33042
81124f5c:	b5b36504 	addi	r22,r22,-12908
81124f60:	ad737e04 	addi	r21,r21,-12808
81124f64:	a5339f04 	addi	r20,r20,-12676
81124f68:	9cf3b804 	addi	r19,r19,-12576
81124f6c:	85800815 	stw	r22,32(r16)
81124f70:	85400915 	stw	r21,36(r16)
81124f74:	85000a15 	stw	r20,40(r16)
81124f78:	84c00b15 	stw	r19,44(r16)
81124f7c:	84000715 	stw	r16,28(r16)
81124f80:	00800284 	movi	r2,10
81124f84:	8880030d 	sth	r2,12(r17)
81124f88:	00800044 	movi	r2,1
81124f8c:	b80d883a 	mov	r6,r23
81124f90:	89001704 	addi	r4,r17,92
81124f94:	000b883a 	mov	r5,zero
81124f98:	88000015 	stw	zero,0(r17)
81124f9c:	88000115 	stw	zero,4(r17)
81124fa0:	88000215 	stw	zero,8(r17)
81124fa4:	88001915 	stw	zero,100(r17)
81124fa8:	8880038d 	sth	r2,14(r17)
81124fac:	88000415 	stw	zero,16(r17)
81124fb0:	88000515 	stw	zero,20(r17)
81124fb4:	88000615 	stw	zero,24(r17)
81124fb8:	111c5900 	call	8111c590 <memset>
81124fbc:	94000317 	ldw	r16,12(r18)
81124fc0:	00800484 	movi	r2,18
81124fc4:	8c400715 	stw	r17,28(r17)
81124fc8:	8d800815 	stw	r22,32(r17)
81124fcc:	8d400915 	stw	r21,36(r17)
81124fd0:	8d000a15 	stw	r20,40(r17)
81124fd4:	8cc00b15 	stw	r19,44(r17)
81124fd8:	8080030d 	sth	r2,12(r16)
81124fdc:	00800084 	movi	r2,2
81124fe0:	80000015 	stw	zero,0(r16)
81124fe4:	80000115 	stw	zero,4(r16)
81124fe8:	80000215 	stw	zero,8(r16)
81124fec:	80001915 	stw	zero,100(r16)
81124ff0:	8080038d 	sth	r2,14(r16)
81124ff4:	80000415 	stw	zero,16(r16)
81124ff8:	80000515 	stw	zero,20(r16)
81124ffc:	80000615 	stw	zero,24(r16)
81125000:	b80d883a 	mov	r6,r23
81125004:	000b883a 	mov	r5,zero
81125008:	81001704 	addi	r4,r16,92
8112500c:	111c5900 	call	8111c590 <memset>
81125010:	00800044 	movi	r2,1
81125014:	84000715 	stw	r16,28(r16)
81125018:	85800815 	stw	r22,32(r16)
8112501c:	85400915 	stw	r21,36(r16)
81125020:	85000a15 	stw	r20,40(r16)
81125024:	84c00b15 	stw	r19,44(r16)
81125028:	90800e15 	stw	r2,56(r18)
8112502c:	dfc00817 	ldw	ra,32(sp)
81125030:	ddc00717 	ldw	r23,28(sp)
81125034:	dd800617 	ldw	r22,24(sp)
81125038:	dd400517 	ldw	r21,20(sp)
8112503c:	dd000417 	ldw	r20,16(sp)
81125040:	dcc00317 	ldw	r19,12(sp)
81125044:	dc800217 	ldw	r18,8(sp)
81125048:	dc400117 	ldw	r17,4(sp)
8112504c:	dc000017 	ldw	r16,0(sp)
81125050:	dec00904 	addi	sp,sp,36
81125054:	f800283a 	ret

81125058 <__fp_lock>:
81125058:	0005883a 	mov	r2,zero
8112505c:	f800283a 	ret

81125060 <__sfmoreglue>:
81125060:	defffc04 	addi	sp,sp,-16
81125064:	de00012e 	bgeu	sp,et,8112506c <__sfmoreglue+0xc>
81125068:	003b68fa 	trap	3
8112506c:	dc400115 	stw	r17,4(sp)
81125070:	2c7fffc4 	addi	r17,r5,-1
81125074:	8c401a24 	muli	r17,r17,104
81125078:	dc800215 	stw	r18,8(sp)
8112507c:	2825883a 	mov	r18,r5
81125080:	89401d04 	addi	r5,r17,116
81125084:	dc000015 	stw	r16,0(sp)
81125088:	dfc00315 	stw	ra,12(sp)
8112508c:	111bc2c0 	call	8111bc2c <_malloc_r>
81125090:	1021883a 	mov	r16,r2
81125094:	10000726 	beq	r2,zero,811250b4 <__sfmoreglue+0x54>
81125098:	11000304 	addi	r4,r2,12
8112509c:	10000015 	stw	zero,0(r2)
811250a0:	14800115 	stw	r18,4(r2)
811250a4:	11000215 	stw	r4,8(r2)
811250a8:	89801a04 	addi	r6,r17,104
811250ac:	000b883a 	mov	r5,zero
811250b0:	111c5900 	call	8111c590 <memset>
811250b4:	8005883a 	mov	r2,r16
811250b8:	dfc00317 	ldw	ra,12(sp)
811250bc:	dc800217 	ldw	r18,8(sp)
811250c0:	dc400117 	ldw	r17,4(sp)
811250c4:	dc000017 	ldw	r16,0(sp)
811250c8:	dec00404 	addi	sp,sp,16
811250cc:	f800283a 	ret

811250d0 <__sfp>:
811250d0:	defffb04 	addi	sp,sp,-20
811250d4:	de00012e 	bgeu	sp,et,811250dc <__sfp+0xc>
811250d8:	003b68fa 	trap	3
811250dc:	dc000015 	stw	r16,0(sp)
811250e0:	04204574 	movhi	r16,33045
811250e4:	84334d04 	addi	r16,r16,-13004
811250e8:	dcc00315 	stw	r19,12(sp)
811250ec:	2027883a 	mov	r19,r4
811250f0:	81000017 	ldw	r4,0(r16)
811250f4:	dfc00415 	stw	ra,16(sp)
811250f8:	dc800215 	stw	r18,8(sp)
811250fc:	20800e17 	ldw	r2,56(r4)
81125100:	dc400115 	stw	r17,4(sp)
81125104:	1000021e 	bne	r2,zero,81125110 <__sfp+0x40>
81125108:	1124eb40 	call	81124eb4 <__sinit.part.1>
8112510c:	81000017 	ldw	r4,0(r16)
81125110:	2480b804 	addi	r18,r4,736
81125114:	047fffc4 	movi	r17,-1
81125118:	91000117 	ldw	r4,4(r18)
8112511c:	94000217 	ldw	r16,8(r18)
81125120:	213fffc4 	addi	r4,r4,-1
81125124:	20000a16 	blt	r4,zero,81125150 <__sfp+0x80>
81125128:	8080030f 	ldh	r2,12(r16)
8112512c:	10000c26 	beq	r2,zero,81125160 <__sfp+0x90>
81125130:	80c01d04 	addi	r3,r16,116
81125134:	00000206 	br	81125140 <__sfp+0x70>
81125138:	18bfe60f 	ldh	r2,-104(r3)
8112513c:	10000826 	beq	r2,zero,81125160 <__sfp+0x90>
81125140:	213fffc4 	addi	r4,r4,-1
81125144:	1c3ffd04 	addi	r16,r3,-12
81125148:	18c01a04 	addi	r3,r3,104
8112514c:	247ffa1e 	bne	r4,r17,81125138 <__reset+0xfb105138>
81125150:	90800017 	ldw	r2,0(r18)
81125154:	10001d26 	beq	r2,zero,811251cc <__sfp+0xfc>
81125158:	1025883a 	mov	r18,r2
8112515c:	003fee06 	br	81125118 <__reset+0xfb105118>
81125160:	00bfffc4 	movi	r2,-1
81125164:	8080038d 	sth	r2,14(r16)
81125168:	00800044 	movi	r2,1
8112516c:	8080030d 	sth	r2,12(r16)
81125170:	80001915 	stw	zero,100(r16)
81125174:	80000015 	stw	zero,0(r16)
81125178:	80000215 	stw	zero,8(r16)
8112517c:	80000115 	stw	zero,4(r16)
81125180:	80000415 	stw	zero,16(r16)
81125184:	80000515 	stw	zero,20(r16)
81125188:	80000615 	stw	zero,24(r16)
8112518c:	01800204 	movi	r6,8
81125190:	000b883a 	mov	r5,zero
81125194:	81001704 	addi	r4,r16,92
81125198:	111c5900 	call	8111c590 <memset>
8112519c:	8005883a 	mov	r2,r16
811251a0:	80000c15 	stw	zero,48(r16)
811251a4:	80000d15 	stw	zero,52(r16)
811251a8:	80001115 	stw	zero,68(r16)
811251ac:	80001215 	stw	zero,72(r16)
811251b0:	dfc00417 	ldw	ra,16(sp)
811251b4:	dcc00317 	ldw	r19,12(sp)
811251b8:	dc800217 	ldw	r18,8(sp)
811251bc:	dc400117 	ldw	r17,4(sp)
811251c0:	dc000017 	ldw	r16,0(sp)
811251c4:	dec00504 	addi	sp,sp,20
811251c8:	f800283a 	ret
811251cc:	01400104 	movi	r5,4
811251d0:	9809883a 	mov	r4,r19
811251d4:	11250600 	call	81125060 <__sfmoreglue>
811251d8:	90800015 	stw	r2,0(r18)
811251dc:	103fde1e 	bne	r2,zero,81125158 <__reset+0xfb105158>
811251e0:	00800304 	movi	r2,12
811251e4:	98800015 	stw	r2,0(r19)
811251e8:	0005883a 	mov	r2,zero
811251ec:	003ff006 	br	811251b0 <__reset+0xfb1051b0>

811251f0 <_cleanup>:
811251f0:	00a04574 	movhi	r2,33045
811251f4:	10b34d04 	addi	r2,r2,-13004
811251f8:	11000017 	ldw	r4,0(r2)
811251fc:	016044f4 	movhi	r5,33043
81125200:	29731904 	addi	r5,r5,-13212
81125204:	1125f481 	jmpi	81125f48 <_fwalk_reent>

81125208 <__sinit>:
81125208:	20800e17 	ldw	r2,56(r4)
8112520c:	10000126 	beq	r2,zero,81125214 <__sinit+0xc>
81125210:	f800283a 	ret
81125214:	1124eb41 	jmpi	81124eb4 <__sinit.part.1>

81125218 <__sfp_lock_acquire>:
81125218:	f800283a 	ret

8112521c <__sfp_lock_release>:
8112521c:	f800283a 	ret

81125220 <__sinit_lock_acquire>:
81125220:	f800283a 	ret

81125224 <__sinit_lock_release>:
81125224:	f800283a 	ret

81125228 <__fp_lock_all>:
81125228:	00a04574 	movhi	r2,33045
8112522c:	10b34e04 	addi	r2,r2,-13000
81125230:	11000017 	ldw	r4,0(r2)
81125234:	016044b4 	movhi	r5,33042
81125238:	29541604 	addi	r5,r5,20568
8112523c:	1125e7c1 	jmpi	81125e7c <_fwalk>

81125240 <__fp_unlock_all>:
81125240:	00a04574 	movhi	r2,33045
81125244:	10b34e04 	addi	r2,r2,-13000
81125248:	11000017 	ldw	r4,0(r2)
8112524c:	016044b4 	movhi	r5,33042
81125250:	2953a804 	addi	r5,r5,20128
81125254:	1125e7c1 	jmpi	81125e7c <_fwalk>

81125258 <__sflags>:
81125258:	28800007 	ldb	r2,0(r5)
8112525c:	00c01c84 	movi	r3,114
81125260:	10c02426 	beq	r2,r3,811252f4 <__sflags+0x9c>
81125264:	00c01dc4 	movi	r3,119
81125268:	10c01e26 	beq	r2,r3,811252e4 <__sflags+0x8c>
8112526c:	00c01844 	movi	r3,97
81125270:	10c00426 	beq	r2,r3,81125284 <__sflags+0x2c>
81125274:	00800584 	movi	r2,22
81125278:	20800015 	stw	r2,0(r4)
8112527c:	0005883a 	mov	r2,zero
81125280:	f800283a 	ret
81125284:	02c08204 	movi	r11,520
81125288:	01000044 	movi	r4,1
8112528c:	00804204 	movi	r2,264
81125290:	01c00ac4 	movi	r7,43
81125294:	02bff8c4 	movi	r10,-29
81125298:	027fff04 	movi	r9,-4
8112529c:	02001e04 	movi	r8,120
811252a0:	29400044 	addi	r5,r5,1
811252a4:	28c00007 	ldb	r3,0(r5)
811252a8:	18000626 	beq	r3,zero,811252c4 <__sflags+0x6c>
811252ac:	19c00826 	beq	r3,r7,811252d0 <__sflags+0x78>
811252b0:	1a3ffb1e 	bne	r3,r8,811252a0 <__reset+0xfb1052a0>
811252b4:	29400044 	addi	r5,r5,1
811252b8:	28c00007 	ldb	r3,0(r5)
811252bc:	21020014 	ori	r4,r4,2048
811252c0:	183ffa1e 	bne	r3,zero,811252ac <__reset+0xfb1052ac>
811252c4:	22c8b03a 	or	r4,r4,r11
811252c8:	31000015 	stw	r4,0(r6)
811252cc:	f800283a 	ret
811252d0:	1284703a 	and	r2,r2,r10
811252d4:	2248703a 	and	r4,r4,r9
811252d8:	10800414 	ori	r2,r2,16
811252dc:	21000094 	ori	r4,r4,2
811252e0:	003fef06 	br	811252a0 <__reset+0xfb1052a0>
811252e4:	02c18004 	movi	r11,1536
811252e8:	01000044 	movi	r4,1
811252ec:	00800204 	movi	r2,8
811252f0:	003fe706 	br	81125290 <__reset+0xfb105290>
811252f4:	0017883a 	mov	r11,zero
811252f8:	0009883a 	mov	r4,zero
811252fc:	00800104 	movi	r2,4
81125300:	003fe306 	br	81125290 <__reset+0xfb105290>

81125304 <_fread_r>:
81125304:	defff404 	addi	sp,sp,-48
81125308:	de00012e 	bgeu	sp,et,81125310 <_fread_r+0xc>
8112530c:	003b68fa 	trap	3
81125310:	dd800815 	stw	r22,32(sp)
81125314:	39ad383a 	mul	r22,r7,r6
81125318:	dc000215 	stw	r16,8(sp)
8112531c:	dfc00b15 	stw	ra,44(sp)
81125320:	df000a15 	stw	fp,40(sp)
81125324:	ddc00915 	stw	r23,36(sp)
81125328:	dd400715 	stw	r21,28(sp)
8112532c:	dd000615 	stw	r20,24(sp)
81125330:	dcc00515 	stw	r19,20(sp)
81125334:	dc800415 	stw	r18,16(sp)
81125338:	dc400315 	stw	r17,12(sp)
8112533c:	dc000c17 	ldw	r16,48(sp)
81125340:	b0003b26 	beq	r22,zero,81125430 <_fread_r+0x12c>
81125344:	302f883a 	mov	r23,r6
81125348:	382b883a 	mov	r21,r7
8112534c:	2029883a 	mov	r20,r4
81125350:	2827883a 	mov	r19,r5
81125354:	20000226 	beq	r4,zero,81125360 <_fread_r+0x5c>
81125358:	20800e17 	ldw	r2,56(r4)
8112535c:	10006e26 	beq	r2,zero,81125518 <_fread_r+0x214>
81125360:	8080030b 	ldhu	r2,12(r16)
81125364:	10c8000c 	andi	r3,r2,8192
81125368:	1800061e 	bne	r3,zero,81125384 <_fread_r+0x80>
8112536c:	81001917 	ldw	r4,100(r16)
81125370:	00f7ffc4 	movi	r3,-8193
81125374:	10880014 	ori	r2,r2,8192
81125378:	20c6703a 	and	r3,r4,r3
8112537c:	8080030d 	sth	r2,12(r16)
81125380:	80c01915 	stw	r3,100(r16)
81125384:	84400117 	ldw	r17,4(r16)
81125388:	88005f16 	blt	r17,zero,81125508 <_fread_r+0x204>
8112538c:	8809883a 	mov	r4,r17
81125390:	1080008c 	andi	r2,r2,2
81125394:	1000281e 	bne	r2,zero,81125438 <_fread_r+0x134>
81125398:	b025883a 	mov	r18,r22
8112539c:	00000b06 	br	811253cc <_fread_r+0xc8>
811253a0:	111c4400 	call	8111c440 <memcpy>
811253a4:	80800017 	ldw	r2,0(r16)
811253a8:	9c67883a 	add	r19,r19,r17
811253ac:	9465c83a 	sub	r18,r18,r17
811253b0:	1463883a 	add	r17,r2,r17
811253b4:	800b883a 	mov	r5,r16
811253b8:	a009883a 	mov	r4,r20
811253bc:	84400015 	stw	r17,0(r16)
811253c0:	111ca0c0 	call	8111ca0c <__srefill_r>
811253c4:	10004c1e 	bne	r2,zero,811254f8 <_fread_r+0x1f4>
811253c8:	84400117 	ldw	r17,4(r16)
811253cc:	880d883a 	mov	r6,r17
811253d0:	9809883a 	mov	r4,r19
811253d4:	81400017 	ldw	r5,0(r16)
811253d8:	8cbff136 	bltu	r17,r18,811253a0 <__reset+0xfb1053a0>
811253dc:	900d883a 	mov	r6,r18
811253e0:	111c4400 	call	8111c440 <memcpy>
811253e4:	80c00117 	ldw	r3,4(r16)
811253e8:	81000017 	ldw	r4,0(r16)
811253ec:	a805883a 	mov	r2,r21
811253f0:	1c87c83a 	sub	r3,r3,r18
811253f4:	24a5883a 	add	r18,r4,r18
811253f8:	80c00115 	stw	r3,4(r16)
811253fc:	84800015 	stw	r18,0(r16)
81125400:	dfc00b17 	ldw	ra,44(sp)
81125404:	df000a17 	ldw	fp,40(sp)
81125408:	ddc00917 	ldw	r23,36(sp)
8112540c:	dd800817 	ldw	r22,32(sp)
81125410:	dd400717 	ldw	r21,28(sp)
81125414:	dd000617 	ldw	r20,24(sp)
81125418:	dcc00517 	ldw	r19,20(sp)
8112541c:	dc800417 	ldw	r18,16(sp)
81125420:	dc400317 	ldw	r17,12(sp)
81125424:	dc000217 	ldw	r16,8(sp)
81125428:	dec00c04 	addi	sp,sp,48
8112542c:	f800283a 	ret
81125430:	0005883a 	mov	r2,zero
81125434:	003ff206 	br	81125400 <__reset+0xfb105400>
81125438:	b007883a 	mov	r3,r22
8112543c:	2580012e 	bgeu	r4,r22,81125444 <_fread_r+0x140>
81125440:	2007883a 	mov	r3,r4
81125444:	81400017 	ldw	r5,0(r16)
81125448:	180d883a 	mov	r6,r3
8112544c:	9809883a 	mov	r4,r19
81125450:	d8c00115 	stw	r3,4(sp)
81125454:	111c4400 	call	8111c440 <memcpy>
81125458:	d8c00117 	ldw	r3,4(sp)
8112545c:	84400017 	ldw	r17,0(r16)
81125460:	80800117 	ldw	r2,4(r16)
81125464:	81400c17 	ldw	r5,48(r16)
81125468:	88e3883a 	add	r17,r17,r3
8112546c:	10c5c83a 	sub	r2,r2,r3
81125470:	84400015 	stw	r17,0(r16)
81125474:	80800115 	stw	r2,4(r16)
81125478:	b0e5c83a 	sub	r18,r22,r3
8112547c:	28002b26 	beq	r5,zero,8112552c <_fread_r+0x228>
81125480:	90002b26 	beq	r18,zero,81125530 <_fread_r+0x22c>
81125484:	80801004 	addi	r2,r16,64
81125488:	28800526 	beq	r5,r2,811254a0 <_fread_r+0x19c>
8112548c:	a009883a 	mov	r4,r20
81125490:	d8c00115 	stw	r3,4(sp)
81125494:	11256a00 	call	811256a0 <_free_r>
81125498:	d8c00117 	ldw	r3,4(sp)
8112549c:	84400017 	ldw	r17,0(r16)
811254a0:	80000c15 	stw	zero,48(r16)
811254a4:	80800517 	ldw	r2,20(r16)
811254a8:	87000417 	ldw	fp,16(r16)
811254ac:	98e7883a 	add	r19,r19,r3
811254b0:	d8800015 	stw	r2,0(sp)
811254b4:	00000106 	br	811254bc <_fread_r+0x1b8>
811254b8:	90001d26 	beq	r18,zero,81125530 <_fread_r+0x22c>
811254bc:	84c00415 	stw	r19,16(r16)
811254c0:	84800515 	stw	r18,20(r16)
811254c4:	84c00015 	stw	r19,0(r16)
811254c8:	a009883a 	mov	r4,r20
811254cc:	800b883a 	mov	r5,r16
811254d0:	111ca0c0 	call	8111ca0c <__srefill_r>
811254d4:	d9000017 	ldw	r4,0(sp)
811254d8:	80c00117 	ldw	r3,4(r16)
811254dc:	87000415 	stw	fp,16(r16)
811254e0:	81000515 	stw	r4,20(r16)
811254e4:	84400015 	stw	r17,0(r16)
811254e8:	80000115 	stw	zero,4(r16)
811254ec:	90e5c83a 	sub	r18,r18,r3
811254f0:	98e7883a 	add	r19,r19,r3
811254f4:	103ff026 	beq	r2,zero,811254b8 <__reset+0xfb1054b8>
811254f8:	b80b883a 	mov	r5,r23
811254fc:	b489c83a 	sub	r4,r22,r18
81125500:	112ea280 	call	8112ea28 <__udivsi3>
81125504:	003fbe06 	br	81125400 <__reset+0xfb105400>
81125508:	80000115 	stw	zero,4(r16)
8112550c:	0009883a 	mov	r4,zero
81125510:	0023883a 	mov	r17,zero
81125514:	003f9e06 	br	81125390 <__reset+0xfb105390>
81125518:	11252080 	call	81125208 <__sinit>
8112551c:	8080030b 	ldhu	r2,12(r16)
81125520:	10c8000c 	andi	r3,r2,8192
81125524:	183f971e 	bne	r3,zero,81125384 <__reset+0xfb105384>
81125528:	003f9006 	br	8112536c <__reset+0xfb10536c>
8112552c:	903fdd1e 	bne	r18,zero,811254a4 <__reset+0xfb1054a4>
81125530:	a805883a 	mov	r2,r21
81125534:	003fb206 	br	81125400 <__reset+0xfb105400>

81125538 <fread>:
81125538:	defffe04 	addi	sp,sp,-8
8112553c:	00a04574 	movhi	r2,33045
81125540:	de00012e 	bgeu	sp,et,81125548 <fread+0x10>
81125544:	003b68fa 	trap	3
81125548:	10b34e04 	addi	r2,r2,-13000
8112554c:	d9c00015 	stw	r7,0(sp)
81125550:	300f883a 	mov	r7,r6
81125554:	280d883a 	mov	r6,r5
81125558:	200b883a 	mov	r5,r4
8112555c:	11000017 	ldw	r4,0(r2)
81125560:	dfc00115 	stw	ra,4(sp)
81125564:	11253040 	call	81125304 <_fread_r>
81125568:	dfc00117 	ldw	ra,4(sp)
8112556c:	dec00204 	addi	sp,sp,8
81125570:	f800283a 	ret

81125574 <_malloc_trim_r>:
81125574:	defffb04 	addi	sp,sp,-20
81125578:	de00012e 	bgeu	sp,et,81125580 <_malloc_trim_r+0xc>
8112557c:	003b68fa 	trap	3
81125580:	dcc00315 	stw	r19,12(sp)
81125584:	04e04574 	movhi	r19,33045
81125588:	dc800215 	stw	r18,8(sp)
8112558c:	dc400115 	stw	r17,4(sp)
81125590:	dc000015 	stw	r16,0(sp)
81125594:	dfc00415 	stw	ra,16(sp)
81125598:	2821883a 	mov	r16,r5
8112559c:	9ced0c04 	addi	r19,r19,-19408
811255a0:	2025883a 	mov	r18,r4
811255a4:	1132a280 	call	81132a28 <__malloc_lock>
811255a8:	98800217 	ldw	r2,8(r19)
811255ac:	14400117 	ldw	r17,4(r2)
811255b0:	00bfff04 	movi	r2,-4
811255b4:	88a2703a 	and	r17,r17,r2
811255b8:	8c21c83a 	sub	r16,r17,r16
811255bc:	8403fbc4 	addi	r16,r16,4079
811255c0:	8020d33a 	srli	r16,r16,12
811255c4:	0083ffc4 	movi	r2,4095
811255c8:	843fffc4 	addi	r16,r16,-1
811255cc:	8020933a 	slli	r16,r16,12
811255d0:	1400060e 	bge	r2,r16,811255ec <_malloc_trim_r+0x78>
811255d4:	000b883a 	mov	r5,zero
811255d8:	9009883a 	mov	r4,r18
811255dc:	111cbe80 	call	8111cbe8 <_sbrk_r>
811255e0:	98c00217 	ldw	r3,8(r19)
811255e4:	1c47883a 	add	r3,r3,r17
811255e8:	10c00a26 	beq	r2,r3,81125614 <_malloc_trim_r+0xa0>
811255ec:	9009883a 	mov	r4,r18
811255f0:	1132b500 	call	81132b50 <__malloc_unlock>
811255f4:	0005883a 	mov	r2,zero
811255f8:	dfc00417 	ldw	ra,16(sp)
811255fc:	dcc00317 	ldw	r19,12(sp)
81125600:	dc800217 	ldw	r18,8(sp)
81125604:	dc400117 	ldw	r17,4(sp)
81125608:	dc000017 	ldw	r16,0(sp)
8112560c:	dec00504 	addi	sp,sp,20
81125610:	f800283a 	ret
81125614:	040bc83a 	sub	r5,zero,r16
81125618:	9009883a 	mov	r4,r18
8112561c:	111cbe80 	call	8111cbe8 <_sbrk_r>
81125620:	00ffffc4 	movi	r3,-1
81125624:	10c00d26 	beq	r2,r3,8112565c <_malloc_trim_r+0xe8>
81125628:	00e04574 	movhi	r3,33045
8112562c:	18f44b04 	addi	r3,r3,-11988
81125630:	18800017 	ldw	r2,0(r3)
81125634:	99000217 	ldw	r4,8(r19)
81125638:	8c23c83a 	sub	r17,r17,r16
8112563c:	8c400054 	ori	r17,r17,1
81125640:	1421c83a 	sub	r16,r2,r16
81125644:	24400115 	stw	r17,4(r4)
81125648:	9009883a 	mov	r4,r18
8112564c:	1c000015 	stw	r16,0(r3)
81125650:	1132b500 	call	81132b50 <__malloc_unlock>
81125654:	00800044 	movi	r2,1
81125658:	003fe706 	br	811255f8 <__reset+0xfb1055f8>
8112565c:	000b883a 	mov	r5,zero
81125660:	9009883a 	mov	r4,r18
81125664:	111cbe80 	call	8111cbe8 <_sbrk_r>
81125668:	99000217 	ldw	r4,8(r19)
8112566c:	014003c4 	movi	r5,15
81125670:	1107c83a 	sub	r3,r2,r4
81125674:	28ffdd0e 	bge	r5,r3,811255ec <__reset+0xfb1055ec>
81125678:	01604574 	movhi	r5,33045
8112567c:	29734f04 	addi	r5,r5,-12996
81125680:	29400017 	ldw	r5,0(r5)
81125684:	18c00054 	ori	r3,r3,1
81125688:	20c00115 	stw	r3,4(r4)
8112568c:	00e04574 	movhi	r3,33045
81125690:	1145c83a 	sub	r2,r2,r5
81125694:	18f44b04 	addi	r3,r3,-11988
81125698:	18800015 	stw	r2,0(r3)
8112569c:	003fd306 	br	811255ec <__reset+0xfb1055ec>

811256a0 <_free_r>:
811256a0:	28004326 	beq	r5,zero,811257b0 <_free_r+0x110>
811256a4:	defffd04 	addi	sp,sp,-12
811256a8:	de00012e 	bgeu	sp,et,811256b0 <_free_r+0x10>
811256ac:	003b68fa 	trap	3
811256b0:	dc400115 	stw	r17,4(sp)
811256b4:	dc000015 	stw	r16,0(sp)
811256b8:	2023883a 	mov	r17,r4
811256bc:	2821883a 	mov	r16,r5
811256c0:	dfc00215 	stw	ra,8(sp)
811256c4:	1132a280 	call	81132a28 <__malloc_lock>
811256c8:	81ffff17 	ldw	r7,-4(r16)
811256cc:	00bfff84 	movi	r2,-2
811256d0:	01204574 	movhi	r4,33045
811256d4:	81bffe04 	addi	r6,r16,-8
811256d8:	3884703a 	and	r2,r7,r2
811256dc:	212d0c04 	addi	r4,r4,-19408
811256e0:	308b883a 	add	r5,r6,r2
811256e4:	2a400117 	ldw	r9,4(r5)
811256e8:	22000217 	ldw	r8,8(r4)
811256ec:	00ffff04 	movi	r3,-4
811256f0:	48c6703a 	and	r3,r9,r3
811256f4:	2a005726 	beq	r5,r8,81125854 <_free_r+0x1b4>
811256f8:	28c00115 	stw	r3,4(r5)
811256fc:	39c0004c 	andi	r7,r7,1
81125700:	3800091e 	bne	r7,zero,81125728 <_free_r+0x88>
81125704:	823ffe17 	ldw	r8,-8(r16)
81125708:	22400204 	addi	r9,r4,8
8112570c:	320dc83a 	sub	r6,r6,r8
81125710:	31c00217 	ldw	r7,8(r6)
81125714:	1205883a 	add	r2,r2,r8
81125718:	3a406526 	beq	r7,r9,811258b0 <_free_r+0x210>
8112571c:	32000317 	ldw	r8,12(r6)
81125720:	3a000315 	stw	r8,12(r7)
81125724:	41c00215 	stw	r7,8(r8)
81125728:	28cf883a 	add	r7,r5,r3
8112572c:	39c00117 	ldw	r7,4(r7)
81125730:	39c0004c 	andi	r7,r7,1
81125734:	38003a26 	beq	r7,zero,81125820 <_free_r+0x180>
81125738:	10c00054 	ori	r3,r2,1
8112573c:	30c00115 	stw	r3,4(r6)
81125740:	3087883a 	add	r3,r6,r2
81125744:	18800015 	stw	r2,0(r3)
81125748:	00c07fc4 	movi	r3,511
8112574c:	18801936 	bltu	r3,r2,811257b4 <_free_r+0x114>
81125750:	1004d0fa 	srli	r2,r2,3
81125754:	01c00044 	movi	r7,1
81125758:	21400117 	ldw	r5,4(r4)
8112575c:	10c00044 	addi	r3,r2,1
81125760:	18c7883a 	add	r3,r3,r3
81125764:	1005d0ba 	srai	r2,r2,2
81125768:	18c7883a 	add	r3,r3,r3
8112576c:	18c7883a 	add	r3,r3,r3
81125770:	1907883a 	add	r3,r3,r4
81125774:	3884983a 	sll	r2,r7,r2
81125778:	19c00017 	ldw	r7,0(r3)
8112577c:	1a3ffe04 	addi	r8,r3,-8
81125780:	1144b03a 	or	r2,r2,r5
81125784:	32000315 	stw	r8,12(r6)
81125788:	31c00215 	stw	r7,8(r6)
8112578c:	20800115 	stw	r2,4(r4)
81125790:	19800015 	stw	r6,0(r3)
81125794:	39800315 	stw	r6,12(r7)
81125798:	8809883a 	mov	r4,r17
8112579c:	dfc00217 	ldw	ra,8(sp)
811257a0:	dc400117 	ldw	r17,4(sp)
811257a4:	dc000017 	ldw	r16,0(sp)
811257a8:	dec00304 	addi	sp,sp,12
811257ac:	1132b501 	jmpi	81132b50 <__malloc_unlock>
811257b0:	f800283a 	ret
811257b4:	100ad27a 	srli	r5,r2,9
811257b8:	00c00104 	movi	r3,4
811257bc:	19404a36 	bltu	r3,r5,811258e8 <_free_r+0x248>
811257c0:	100ad1ba 	srli	r5,r2,6
811257c4:	28c00e44 	addi	r3,r5,57
811257c8:	18c7883a 	add	r3,r3,r3
811257cc:	29400e04 	addi	r5,r5,56
811257d0:	18c7883a 	add	r3,r3,r3
811257d4:	18c7883a 	add	r3,r3,r3
811257d8:	1909883a 	add	r4,r3,r4
811257dc:	20c00017 	ldw	r3,0(r4)
811257e0:	01e04574 	movhi	r7,33045
811257e4:	213ffe04 	addi	r4,r4,-8
811257e8:	39ed0c04 	addi	r7,r7,-19408
811257ec:	20c04426 	beq	r4,r3,81125900 <_free_r+0x260>
811257f0:	01ffff04 	movi	r7,-4
811257f4:	19400117 	ldw	r5,4(r3)
811257f8:	29ca703a 	and	r5,r5,r7
811257fc:	1140022e 	bgeu	r2,r5,81125808 <_free_r+0x168>
81125800:	18c00217 	ldw	r3,8(r3)
81125804:	20fffb1e 	bne	r4,r3,811257f4 <__reset+0xfb1057f4>
81125808:	19000317 	ldw	r4,12(r3)
8112580c:	31000315 	stw	r4,12(r6)
81125810:	30c00215 	stw	r3,8(r6)
81125814:	21800215 	stw	r6,8(r4)
81125818:	19800315 	stw	r6,12(r3)
8112581c:	003fde06 	br	81125798 <__reset+0xfb105798>
81125820:	29c00217 	ldw	r7,8(r5)
81125824:	10c5883a 	add	r2,r2,r3
81125828:	00e04574 	movhi	r3,33045
8112582c:	18ed0e04 	addi	r3,r3,-19400
81125830:	38c03b26 	beq	r7,r3,81125920 <_free_r+0x280>
81125834:	2a000317 	ldw	r8,12(r5)
81125838:	11400054 	ori	r5,r2,1
8112583c:	3087883a 	add	r3,r6,r2
81125840:	3a000315 	stw	r8,12(r7)
81125844:	41c00215 	stw	r7,8(r8)
81125848:	31400115 	stw	r5,4(r6)
8112584c:	18800015 	stw	r2,0(r3)
81125850:	003fbd06 	br	81125748 <__reset+0xfb105748>
81125854:	39c0004c 	andi	r7,r7,1
81125858:	10c5883a 	add	r2,r2,r3
8112585c:	3800071e 	bne	r7,zero,8112587c <_free_r+0x1dc>
81125860:	81fffe17 	ldw	r7,-8(r16)
81125864:	31cdc83a 	sub	r6,r6,r7
81125868:	30c00317 	ldw	r3,12(r6)
8112586c:	31400217 	ldw	r5,8(r6)
81125870:	11c5883a 	add	r2,r2,r7
81125874:	28c00315 	stw	r3,12(r5)
81125878:	19400215 	stw	r5,8(r3)
8112587c:	10c00054 	ori	r3,r2,1
81125880:	30c00115 	stw	r3,4(r6)
81125884:	00e04574 	movhi	r3,33045
81125888:	18f35004 	addi	r3,r3,-12992
8112588c:	18c00017 	ldw	r3,0(r3)
81125890:	21800215 	stw	r6,8(r4)
81125894:	10ffc036 	bltu	r2,r3,81125798 <__reset+0xfb105798>
81125898:	00a04574 	movhi	r2,33045
8112589c:	10b3be04 	addi	r2,r2,-12552
811258a0:	11400017 	ldw	r5,0(r2)
811258a4:	8809883a 	mov	r4,r17
811258a8:	11255740 	call	81125574 <_malloc_trim_r>
811258ac:	003fba06 	br	81125798 <__reset+0xfb105798>
811258b0:	28c9883a 	add	r4,r5,r3
811258b4:	21000117 	ldw	r4,4(r4)
811258b8:	2100004c 	andi	r4,r4,1
811258bc:	2000391e 	bne	r4,zero,811259a4 <_free_r+0x304>
811258c0:	29c00217 	ldw	r7,8(r5)
811258c4:	29000317 	ldw	r4,12(r5)
811258c8:	1885883a 	add	r2,r3,r2
811258cc:	10c00054 	ori	r3,r2,1
811258d0:	39000315 	stw	r4,12(r7)
811258d4:	21c00215 	stw	r7,8(r4)
811258d8:	30c00115 	stw	r3,4(r6)
811258dc:	308d883a 	add	r6,r6,r2
811258e0:	30800015 	stw	r2,0(r6)
811258e4:	003fac06 	br	81125798 <__reset+0xfb105798>
811258e8:	00c00504 	movi	r3,20
811258ec:	19401536 	bltu	r3,r5,81125944 <_free_r+0x2a4>
811258f0:	28c01704 	addi	r3,r5,92
811258f4:	18c7883a 	add	r3,r3,r3
811258f8:	294016c4 	addi	r5,r5,91
811258fc:	003fb406 	br	811257d0 <__reset+0xfb1057d0>
81125900:	280bd0ba 	srai	r5,r5,2
81125904:	00c00044 	movi	r3,1
81125908:	38800117 	ldw	r2,4(r7)
8112590c:	194a983a 	sll	r5,r3,r5
81125910:	2007883a 	mov	r3,r4
81125914:	2884b03a 	or	r2,r5,r2
81125918:	38800115 	stw	r2,4(r7)
8112591c:	003fbb06 	br	8112580c <__reset+0xfb10580c>
81125920:	21800515 	stw	r6,20(r4)
81125924:	21800415 	stw	r6,16(r4)
81125928:	10c00054 	ori	r3,r2,1
8112592c:	31c00315 	stw	r7,12(r6)
81125930:	31c00215 	stw	r7,8(r6)
81125934:	30c00115 	stw	r3,4(r6)
81125938:	308d883a 	add	r6,r6,r2
8112593c:	30800015 	stw	r2,0(r6)
81125940:	003f9506 	br	81125798 <__reset+0xfb105798>
81125944:	00c01504 	movi	r3,84
81125948:	19400536 	bltu	r3,r5,81125960 <_free_r+0x2c0>
8112594c:	100ad33a 	srli	r5,r2,12
81125950:	28c01bc4 	addi	r3,r5,111
81125954:	18c7883a 	add	r3,r3,r3
81125958:	29401b84 	addi	r5,r5,110
8112595c:	003f9c06 	br	811257d0 <__reset+0xfb1057d0>
81125960:	00c05504 	movi	r3,340
81125964:	19400536 	bltu	r3,r5,8112597c <_free_r+0x2dc>
81125968:	100ad3fa 	srli	r5,r2,15
8112596c:	28c01e04 	addi	r3,r5,120
81125970:	18c7883a 	add	r3,r3,r3
81125974:	29401dc4 	addi	r5,r5,119
81125978:	003f9506 	br	811257d0 <__reset+0xfb1057d0>
8112597c:	00c15504 	movi	r3,1364
81125980:	19400536 	bltu	r3,r5,81125998 <_free_r+0x2f8>
81125984:	100ad4ba 	srli	r5,r2,18
81125988:	28c01f44 	addi	r3,r5,125
8112598c:	18c7883a 	add	r3,r3,r3
81125990:	29401f04 	addi	r5,r5,124
81125994:	003f8e06 	br	811257d0 <__reset+0xfb1057d0>
81125998:	00c03f84 	movi	r3,254
8112599c:	01401f84 	movi	r5,126
811259a0:	003f8b06 	br	811257d0 <__reset+0xfb1057d0>
811259a4:	10c00054 	ori	r3,r2,1
811259a8:	30c00115 	stw	r3,4(r6)
811259ac:	308d883a 	add	r6,r6,r2
811259b0:	30800015 	stw	r2,0(r6)
811259b4:	003f7806 	br	81125798 <__reset+0xfb105798>

811259b8 <__sfvwrite_r>:
811259b8:	30800217 	ldw	r2,8(r6)
811259bc:	10006926 	beq	r2,zero,81125b64 <__sfvwrite_r+0x1ac>
811259c0:	defff404 	addi	sp,sp,-48
811259c4:	de00012e 	bgeu	sp,et,811259cc <__sfvwrite_r+0x14>
811259c8:	003b68fa 	trap	3
811259cc:	28c0030b 	ldhu	r3,12(r5)
811259d0:	dd400715 	stw	r21,28(sp)
811259d4:	dd000615 	stw	r20,24(sp)
811259d8:	dc000215 	stw	r16,8(sp)
811259dc:	dfc00b15 	stw	ra,44(sp)
811259e0:	df000a15 	stw	fp,40(sp)
811259e4:	ddc00915 	stw	r23,36(sp)
811259e8:	dd800815 	stw	r22,32(sp)
811259ec:	dcc00515 	stw	r19,20(sp)
811259f0:	dc800415 	stw	r18,16(sp)
811259f4:	dc400315 	stw	r17,12(sp)
811259f8:	1880020c 	andi	r2,r3,8
811259fc:	2821883a 	mov	r16,r5
81125a00:	202b883a 	mov	r21,r4
81125a04:	3029883a 	mov	r20,r6
81125a08:	10002726 	beq	r2,zero,81125aa8 <__sfvwrite_r+0xf0>
81125a0c:	28800417 	ldw	r2,16(r5)
81125a10:	10002526 	beq	r2,zero,81125aa8 <__sfvwrite_r+0xf0>
81125a14:	1880008c 	andi	r2,r3,2
81125a18:	a4400017 	ldw	r17,0(r20)
81125a1c:	10002a26 	beq	r2,zero,81125ac8 <__sfvwrite_r+0x110>
81125a20:	05a00034 	movhi	r22,32768
81125a24:	0027883a 	mov	r19,zero
81125a28:	0025883a 	mov	r18,zero
81125a2c:	b5bf0004 	addi	r22,r22,-1024
81125a30:	980d883a 	mov	r6,r19
81125a34:	a809883a 	mov	r4,r21
81125a38:	90004626 	beq	r18,zero,81125b54 <__sfvwrite_r+0x19c>
81125a3c:	900f883a 	mov	r7,r18
81125a40:	b480022e 	bgeu	r22,r18,81125a4c <__sfvwrite_r+0x94>
81125a44:	01e00034 	movhi	r7,32768
81125a48:	39ff0004 	addi	r7,r7,-1024
81125a4c:	80800917 	ldw	r2,36(r16)
81125a50:	81400717 	ldw	r5,28(r16)
81125a54:	103ee83a 	callr	r2
81125a58:	0080570e 	bge	zero,r2,81125bb8 <__sfvwrite_r+0x200>
81125a5c:	a0c00217 	ldw	r3,8(r20)
81125a60:	98a7883a 	add	r19,r19,r2
81125a64:	90a5c83a 	sub	r18,r18,r2
81125a68:	1885c83a 	sub	r2,r3,r2
81125a6c:	a0800215 	stw	r2,8(r20)
81125a70:	103fef1e 	bne	r2,zero,81125a30 <__reset+0xfb105a30>
81125a74:	0005883a 	mov	r2,zero
81125a78:	dfc00b17 	ldw	ra,44(sp)
81125a7c:	df000a17 	ldw	fp,40(sp)
81125a80:	ddc00917 	ldw	r23,36(sp)
81125a84:	dd800817 	ldw	r22,32(sp)
81125a88:	dd400717 	ldw	r21,28(sp)
81125a8c:	dd000617 	ldw	r20,24(sp)
81125a90:	dcc00517 	ldw	r19,20(sp)
81125a94:	dc800417 	ldw	r18,16(sp)
81125a98:	dc400317 	ldw	r17,12(sp)
81125a9c:	dc000217 	ldw	r16,8(sp)
81125aa0:	dec00c04 	addi	sp,sp,48
81125aa4:	f800283a 	ret
81125aa8:	800b883a 	mov	r5,r16
81125aac:	a809883a 	mov	r4,r21
81125ab0:	11231980 	call	81123198 <__swsetup_r>
81125ab4:	1000eb1e 	bne	r2,zero,81125e64 <__sfvwrite_r+0x4ac>
81125ab8:	80c0030b 	ldhu	r3,12(r16)
81125abc:	a4400017 	ldw	r17,0(r20)
81125ac0:	1880008c 	andi	r2,r3,2
81125ac4:	103fd61e 	bne	r2,zero,81125a20 <__reset+0xfb105a20>
81125ac8:	1880004c 	andi	r2,r3,1
81125acc:	10003f1e 	bne	r2,zero,81125bcc <__sfvwrite_r+0x214>
81125ad0:	0039883a 	mov	fp,zero
81125ad4:	0025883a 	mov	r18,zero
81125ad8:	90001a26 	beq	r18,zero,81125b44 <__sfvwrite_r+0x18c>
81125adc:	1880800c 	andi	r2,r3,512
81125ae0:	84c00217 	ldw	r19,8(r16)
81125ae4:	10002126 	beq	r2,zero,81125b6c <__sfvwrite_r+0x1b4>
81125ae8:	982f883a 	mov	r23,r19
81125aec:	94c09336 	bltu	r18,r19,81125d3c <__sfvwrite_r+0x384>
81125af0:	1881200c 	andi	r2,r3,1152
81125af4:	10009e1e 	bne	r2,zero,81125d70 <__sfvwrite_r+0x3b8>
81125af8:	81000017 	ldw	r4,0(r16)
81125afc:	b80d883a 	mov	r6,r23
81125b00:	e00b883a 	mov	r5,fp
81125b04:	11265140 	call	81126514 <memmove>
81125b08:	80c00217 	ldw	r3,8(r16)
81125b0c:	81000017 	ldw	r4,0(r16)
81125b10:	9005883a 	mov	r2,r18
81125b14:	1ce7c83a 	sub	r19,r3,r19
81125b18:	25cf883a 	add	r7,r4,r23
81125b1c:	84c00215 	stw	r19,8(r16)
81125b20:	81c00015 	stw	r7,0(r16)
81125b24:	a0c00217 	ldw	r3,8(r20)
81125b28:	e0b9883a 	add	fp,fp,r2
81125b2c:	90a5c83a 	sub	r18,r18,r2
81125b30:	18a7c83a 	sub	r19,r3,r2
81125b34:	a4c00215 	stw	r19,8(r20)
81125b38:	983fce26 	beq	r19,zero,81125a74 <__reset+0xfb105a74>
81125b3c:	80c0030b 	ldhu	r3,12(r16)
81125b40:	903fe61e 	bne	r18,zero,81125adc <__reset+0xfb105adc>
81125b44:	8f000017 	ldw	fp,0(r17)
81125b48:	8c800117 	ldw	r18,4(r17)
81125b4c:	8c400204 	addi	r17,r17,8
81125b50:	003fe106 	br	81125ad8 <__reset+0xfb105ad8>
81125b54:	8cc00017 	ldw	r19,0(r17)
81125b58:	8c800117 	ldw	r18,4(r17)
81125b5c:	8c400204 	addi	r17,r17,8
81125b60:	003fb306 	br	81125a30 <__reset+0xfb105a30>
81125b64:	0005883a 	mov	r2,zero
81125b68:	f800283a 	ret
81125b6c:	81000017 	ldw	r4,0(r16)
81125b70:	80800417 	ldw	r2,16(r16)
81125b74:	11005736 	bltu	r2,r4,81125cd4 <__sfvwrite_r+0x31c>
81125b78:	85c00517 	ldw	r23,20(r16)
81125b7c:	95c05536 	bltu	r18,r23,81125cd4 <__sfvwrite_r+0x31c>
81125b80:	00a00034 	movhi	r2,32768
81125b84:	10bfffc4 	addi	r2,r2,-1
81125b88:	9009883a 	mov	r4,r18
81125b8c:	1480012e 	bgeu	r2,r18,81125b94 <__sfvwrite_r+0x1dc>
81125b90:	1009883a 	mov	r4,r2
81125b94:	b80b883a 	mov	r5,r23
81125b98:	112e9300 	call	8112e930 <__divsi3>
81125b9c:	15cf383a 	mul	r7,r2,r23
81125ba0:	81400717 	ldw	r5,28(r16)
81125ba4:	80800917 	ldw	r2,36(r16)
81125ba8:	e00d883a 	mov	r6,fp
81125bac:	a809883a 	mov	r4,r21
81125bb0:	103ee83a 	callr	r2
81125bb4:	00bfdb16 	blt	zero,r2,81125b24 <__reset+0xfb105b24>
81125bb8:	8080030b 	ldhu	r2,12(r16)
81125bbc:	10801014 	ori	r2,r2,64
81125bc0:	8080030d 	sth	r2,12(r16)
81125bc4:	00bfffc4 	movi	r2,-1
81125bc8:	003fab06 	br	81125a78 <__reset+0xfb105a78>
81125bcc:	0027883a 	mov	r19,zero
81125bd0:	0011883a 	mov	r8,zero
81125bd4:	0039883a 	mov	fp,zero
81125bd8:	0025883a 	mov	r18,zero
81125bdc:	90001f26 	beq	r18,zero,81125c5c <__sfvwrite_r+0x2a4>
81125be0:	40005a26 	beq	r8,zero,81125d4c <__sfvwrite_r+0x394>
81125be4:	982d883a 	mov	r22,r19
81125be8:	94c0012e 	bgeu	r18,r19,81125bf0 <__sfvwrite_r+0x238>
81125bec:	902d883a 	mov	r22,r18
81125bf0:	81000017 	ldw	r4,0(r16)
81125bf4:	80800417 	ldw	r2,16(r16)
81125bf8:	b02f883a 	mov	r23,r22
81125bfc:	81c00517 	ldw	r7,20(r16)
81125c00:	1100032e 	bgeu	r2,r4,81125c10 <__sfvwrite_r+0x258>
81125c04:	80c00217 	ldw	r3,8(r16)
81125c08:	38c7883a 	add	r3,r7,r3
81125c0c:	1d801816 	blt	r3,r22,81125c70 <__sfvwrite_r+0x2b8>
81125c10:	b1c03e16 	blt	r22,r7,81125d0c <__sfvwrite_r+0x354>
81125c14:	80800917 	ldw	r2,36(r16)
81125c18:	81400717 	ldw	r5,28(r16)
81125c1c:	e00d883a 	mov	r6,fp
81125c20:	da000115 	stw	r8,4(sp)
81125c24:	a809883a 	mov	r4,r21
81125c28:	103ee83a 	callr	r2
81125c2c:	102f883a 	mov	r23,r2
81125c30:	da000117 	ldw	r8,4(sp)
81125c34:	00bfe00e 	bge	zero,r2,81125bb8 <__reset+0xfb105bb8>
81125c38:	9de7c83a 	sub	r19,r19,r23
81125c3c:	98001f26 	beq	r19,zero,81125cbc <__sfvwrite_r+0x304>
81125c40:	a0800217 	ldw	r2,8(r20)
81125c44:	e5f9883a 	add	fp,fp,r23
81125c48:	95e5c83a 	sub	r18,r18,r23
81125c4c:	15efc83a 	sub	r23,r2,r23
81125c50:	a5c00215 	stw	r23,8(r20)
81125c54:	b83f8726 	beq	r23,zero,81125a74 <__reset+0xfb105a74>
81125c58:	903fe11e 	bne	r18,zero,81125be0 <__reset+0xfb105be0>
81125c5c:	8f000017 	ldw	fp,0(r17)
81125c60:	8c800117 	ldw	r18,4(r17)
81125c64:	0011883a 	mov	r8,zero
81125c68:	8c400204 	addi	r17,r17,8
81125c6c:	003fdb06 	br	81125bdc <__reset+0xfb105bdc>
81125c70:	180d883a 	mov	r6,r3
81125c74:	e00b883a 	mov	r5,fp
81125c78:	da000115 	stw	r8,4(sp)
81125c7c:	d8c00015 	stw	r3,0(sp)
81125c80:	11265140 	call	81126514 <memmove>
81125c84:	d8c00017 	ldw	r3,0(sp)
81125c88:	80800017 	ldw	r2,0(r16)
81125c8c:	800b883a 	mov	r5,r16
81125c90:	a809883a 	mov	r4,r21
81125c94:	10c5883a 	add	r2,r2,r3
81125c98:	80800015 	stw	r2,0(r16)
81125c9c:	d8c00015 	stw	r3,0(sp)
81125ca0:	1124e0c0 	call	81124e0c <_fflush_r>
81125ca4:	d8c00017 	ldw	r3,0(sp)
81125ca8:	da000117 	ldw	r8,4(sp)
81125cac:	103fc21e 	bne	r2,zero,81125bb8 <__reset+0xfb105bb8>
81125cb0:	182f883a 	mov	r23,r3
81125cb4:	9de7c83a 	sub	r19,r19,r23
81125cb8:	983fe11e 	bne	r19,zero,81125c40 <__reset+0xfb105c40>
81125cbc:	800b883a 	mov	r5,r16
81125cc0:	a809883a 	mov	r4,r21
81125cc4:	1124e0c0 	call	81124e0c <_fflush_r>
81125cc8:	103fbb1e 	bne	r2,zero,81125bb8 <__reset+0xfb105bb8>
81125ccc:	0011883a 	mov	r8,zero
81125cd0:	003fdb06 	br	81125c40 <__reset+0xfb105c40>
81125cd4:	94c0012e 	bgeu	r18,r19,81125cdc <__sfvwrite_r+0x324>
81125cd8:	9027883a 	mov	r19,r18
81125cdc:	980d883a 	mov	r6,r19
81125ce0:	e00b883a 	mov	r5,fp
81125ce4:	11265140 	call	81126514 <memmove>
81125ce8:	80800217 	ldw	r2,8(r16)
81125cec:	80c00017 	ldw	r3,0(r16)
81125cf0:	14c5c83a 	sub	r2,r2,r19
81125cf4:	1cc7883a 	add	r3,r3,r19
81125cf8:	80800215 	stw	r2,8(r16)
81125cfc:	80c00015 	stw	r3,0(r16)
81125d00:	10004326 	beq	r2,zero,81125e10 <__sfvwrite_r+0x458>
81125d04:	9805883a 	mov	r2,r19
81125d08:	003f8606 	br	81125b24 <__reset+0xfb105b24>
81125d0c:	b00d883a 	mov	r6,r22
81125d10:	e00b883a 	mov	r5,fp
81125d14:	da000115 	stw	r8,4(sp)
81125d18:	11265140 	call	81126514 <memmove>
81125d1c:	80800217 	ldw	r2,8(r16)
81125d20:	80c00017 	ldw	r3,0(r16)
81125d24:	da000117 	ldw	r8,4(sp)
81125d28:	1585c83a 	sub	r2,r2,r22
81125d2c:	1dad883a 	add	r22,r3,r22
81125d30:	80800215 	stw	r2,8(r16)
81125d34:	85800015 	stw	r22,0(r16)
81125d38:	003fbf06 	br	81125c38 <__reset+0xfb105c38>
81125d3c:	81000017 	ldw	r4,0(r16)
81125d40:	9027883a 	mov	r19,r18
81125d44:	902f883a 	mov	r23,r18
81125d48:	003f6c06 	br	81125afc <__reset+0xfb105afc>
81125d4c:	900d883a 	mov	r6,r18
81125d50:	01400284 	movi	r5,10
81125d54:	e009883a 	mov	r4,fp
81125d58:	11264300 	call	81126430 <memchr>
81125d5c:	10003e26 	beq	r2,zero,81125e58 <__sfvwrite_r+0x4a0>
81125d60:	10800044 	addi	r2,r2,1
81125d64:	1727c83a 	sub	r19,r2,fp
81125d68:	02000044 	movi	r8,1
81125d6c:	003f9d06 	br	81125be4 <__reset+0xfb105be4>
81125d70:	80800517 	ldw	r2,20(r16)
81125d74:	81400417 	ldw	r5,16(r16)
81125d78:	81c00017 	ldw	r7,0(r16)
81125d7c:	10a7883a 	add	r19,r2,r2
81125d80:	9885883a 	add	r2,r19,r2
81125d84:	1026d7fa 	srli	r19,r2,31
81125d88:	396dc83a 	sub	r22,r7,r5
81125d8c:	b1000044 	addi	r4,r22,1
81125d90:	9885883a 	add	r2,r19,r2
81125d94:	1027d07a 	srai	r19,r2,1
81125d98:	2485883a 	add	r2,r4,r18
81125d9c:	980d883a 	mov	r6,r19
81125da0:	9880022e 	bgeu	r19,r2,81125dac <__sfvwrite_r+0x3f4>
81125da4:	1027883a 	mov	r19,r2
81125da8:	100d883a 	mov	r6,r2
81125dac:	18c1000c 	andi	r3,r3,1024
81125db0:	18001c26 	beq	r3,zero,81125e24 <__sfvwrite_r+0x46c>
81125db4:	300b883a 	mov	r5,r6
81125db8:	a809883a 	mov	r4,r21
81125dbc:	111bc2c0 	call	8111bc2c <_malloc_r>
81125dc0:	102f883a 	mov	r23,r2
81125dc4:	10002926 	beq	r2,zero,81125e6c <__sfvwrite_r+0x4b4>
81125dc8:	81400417 	ldw	r5,16(r16)
81125dcc:	b00d883a 	mov	r6,r22
81125dd0:	1009883a 	mov	r4,r2
81125dd4:	111c4400 	call	8111c440 <memcpy>
81125dd8:	8080030b 	ldhu	r2,12(r16)
81125ddc:	00fedfc4 	movi	r3,-1153
81125de0:	10c4703a 	and	r2,r2,r3
81125de4:	10802014 	ori	r2,r2,128
81125de8:	8080030d 	sth	r2,12(r16)
81125dec:	bd89883a 	add	r4,r23,r22
81125df0:	9d8fc83a 	sub	r7,r19,r22
81125df4:	85c00415 	stw	r23,16(r16)
81125df8:	84c00515 	stw	r19,20(r16)
81125dfc:	81000015 	stw	r4,0(r16)
81125e00:	9027883a 	mov	r19,r18
81125e04:	81c00215 	stw	r7,8(r16)
81125e08:	902f883a 	mov	r23,r18
81125e0c:	003f3b06 	br	81125afc <__reset+0xfb105afc>
81125e10:	800b883a 	mov	r5,r16
81125e14:	a809883a 	mov	r4,r21
81125e18:	1124e0c0 	call	81124e0c <_fflush_r>
81125e1c:	103fb926 	beq	r2,zero,81125d04 <__reset+0xfb105d04>
81125e20:	003f6506 	br	81125bb8 <__reset+0xfb105bb8>
81125e24:	a809883a 	mov	r4,r21
81125e28:	11277340 	call	81127734 <_realloc_r>
81125e2c:	102f883a 	mov	r23,r2
81125e30:	103fee1e 	bne	r2,zero,81125dec <__reset+0xfb105dec>
81125e34:	81400417 	ldw	r5,16(r16)
81125e38:	a809883a 	mov	r4,r21
81125e3c:	11256a00 	call	811256a0 <_free_r>
81125e40:	8080030b 	ldhu	r2,12(r16)
81125e44:	00ffdfc4 	movi	r3,-129
81125e48:	1884703a 	and	r2,r3,r2
81125e4c:	00c00304 	movi	r3,12
81125e50:	a8c00015 	stw	r3,0(r21)
81125e54:	003f5906 	br	81125bbc <__reset+0xfb105bbc>
81125e58:	94c00044 	addi	r19,r18,1
81125e5c:	02000044 	movi	r8,1
81125e60:	003f6006 	br	81125be4 <__reset+0xfb105be4>
81125e64:	00bfffc4 	movi	r2,-1
81125e68:	003f0306 	br	81125a78 <__reset+0xfb105a78>
81125e6c:	00800304 	movi	r2,12
81125e70:	a8800015 	stw	r2,0(r21)
81125e74:	8080030b 	ldhu	r2,12(r16)
81125e78:	003f5006 	br	81125bbc <__reset+0xfb105bbc>

81125e7c <_fwalk>:
81125e7c:	defff704 	addi	sp,sp,-36
81125e80:	de00012e 	bgeu	sp,et,81125e88 <_fwalk+0xc>
81125e84:	003b68fa 	trap	3
81125e88:	dd000415 	stw	r20,16(sp)
81125e8c:	dfc00815 	stw	ra,32(sp)
81125e90:	ddc00715 	stw	r23,28(sp)
81125e94:	dd800615 	stw	r22,24(sp)
81125e98:	dd400515 	stw	r21,20(sp)
81125e9c:	dcc00315 	stw	r19,12(sp)
81125ea0:	dc800215 	stw	r18,8(sp)
81125ea4:	dc400115 	stw	r17,4(sp)
81125ea8:	dc000015 	stw	r16,0(sp)
81125eac:	2500b804 	addi	r20,r4,736
81125eb0:	a0002326 	beq	r20,zero,81125f40 <_fwalk+0xc4>
81125eb4:	282b883a 	mov	r21,r5
81125eb8:	002f883a 	mov	r23,zero
81125ebc:	05800044 	movi	r22,1
81125ec0:	04ffffc4 	movi	r19,-1
81125ec4:	a4400117 	ldw	r17,4(r20)
81125ec8:	a4800217 	ldw	r18,8(r20)
81125ecc:	8c7fffc4 	addi	r17,r17,-1
81125ed0:	88000d16 	blt	r17,zero,81125f08 <_fwalk+0x8c>
81125ed4:	94000304 	addi	r16,r18,12
81125ed8:	94800384 	addi	r18,r18,14
81125edc:	8080000b 	ldhu	r2,0(r16)
81125ee0:	8c7fffc4 	addi	r17,r17,-1
81125ee4:	813ffd04 	addi	r4,r16,-12
81125ee8:	b080042e 	bgeu	r22,r2,81125efc <_fwalk+0x80>
81125eec:	9080000f 	ldh	r2,0(r18)
81125ef0:	14c00226 	beq	r2,r19,81125efc <_fwalk+0x80>
81125ef4:	a83ee83a 	callr	r21
81125ef8:	b8aeb03a 	or	r23,r23,r2
81125efc:	84001a04 	addi	r16,r16,104
81125f00:	94801a04 	addi	r18,r18,104
81125f04:	8cfff51e 	bne	r17,r19,81125edc <__reset+0xfb105edc>
81125f08:	a5000017 	ldw	r20,0(r20)
81125f0c:	a03fed1e 	bne	r20,zero,81125ec4 <__reset+0xfb105ec4>
81125f10:	b805883a 	mov	r2,r23
81125f14:	dfc00817 	ldw	ra,32(sp)
81125f18:	ddc00717 	ldw	r23,28(sp)
81125f1c:	dd800617 	ldw	r22,24(sp)
81125f20:	dd400517 	ldw	r21,20(sp)
81125f24:	dd000417 	ldw	r20,16(sp)
81125f28:	dcc00317 	ldw	r19,12(sp)
81125f2c:	dc800217 	ldw	r18,8(sp)
81125f30:	dc400117 	ldw	r17,4(sp)
81125f34:	dc000017 	ldw	r16,0(sp)
81125f38:	dec00904 	addi	sp,sp,36
81125f3c:	f800283a 	ret
81125f40:	002f883a 	mov	r23,zero
81125f44:	003ff206 	br	81125f10 <__reset+0xfb105f10>

81125f48 <_fwalk_reent>:
81125f48:	defff704 	addi	sp,sp,-36
81125f4c:	de00012e 	bgeu	sp,et,81125f54 <_fwalk_reent+0xc>
81125f50:	003b68fa 	trap	3
81125f54:	dd000415 	stw	r20,16(sp)
81125f58:	dfc00815 	stw	ra,32(sp)
81125f5c:	ddc00715 	stw	r23,28(sp)
81125f60:	dd800615 	stw	r22,24(sp)
81125f64:	dd400515 	stw	r21,20(sp)
81125f68:	dcc00315 	stw	r19,12(sp)
81125f6c:	dc800215 	stw	r18,8(sp)
81125f70:	dc400115 	stw	r17,4(sp)
81125f74:	dc000015 	stw	r16,0(sp)
81125f78:	2500b804 	addi	r20,r4,736
81125f7c:	a0002326 	beq	r20,zero,8112600c <_fwalk_reent+0xc4>
81125f80:	282b883a 	mov	r21,r5
81125f84:	2027883a 	mov	r19,r4
81125f88:	002f883a 	mov	r23,zero
81125f8c:	05800044 	movi	r22,1
81125f90:	04bfffc4 	movi	r18,-1
81125f94:	a4400117 	ldw	r17,4(r20)
81125f98:	a4000217 	ldw	r16,8(r20)
81125f9c:	8c7fffc4 	addi	r17,r17,-1
81125fa0:	88000c16 	blt	r17,zero,81125fd4 <_fwalk_reent+0x8c>
81125fa4:	84000304 	addi	r16,r16,12
81125fa8:	8080000b 	ldhu	r2,0(r16)
81125fac:	8c7fffc4 	addi	r17,r17,-1
81125fb0:	817ffd04 	addi	r5,r16,-12
81125fb4:	b080052e 	bgeu	r22,r2,81125fcc <_fwalk_reent+0x84>
81125fb8:	8080008f 	ldh	r2,2(r16)
81125fbc:	9809883a 	mov	r4,r19
81125fc0:	14800226 	beq	r2,r18,81125fcc <_fwalk_reent+0x84>
81125fc4:	a83ee83a 	callr	r21
81125fc8:	b8aeb03a 	or	r23,r23,r2
81125fcc:	84001a04 	addi	r16,r16,104
81125fd0:	8cbff51e 	bne	r17,r18,81125fa8 <__reset+0xfb105fa8>
81125fd4:	a5000017 	ldw	r20,0(r20)
81125fd8:	a03fee1e 	bne	r20,zero,81125f94 <__reset+0xfb105f94>
81125fdc:	b805883a 	mov	r2,r23
81125fe0:	dfc00817 	ldw	ra,32(sp)
81125fe4:	ddc00717 	ldw	r23,28(sp)
81125fe8:	dd800617 	ldw	r22,24(sp)
81125fec:	dd400517 	ldw	r21,20(sp)
81125ff0:	dd000417 	ldw	r20,16(sp)
81125ff4:	dcc00317 	ldw	r19,12(sp)
81125ff8:	dc800217 	ldw	r18,8(sp)
81125ffc:	dc400117 	ldw	r17,4(sp)
81126000:	dc000017 	ldw	r16,0(sp)
81126004:	dec00904 	addi	sp,sp,36
81126008:	f800283a 	ret
8112600c:	002f883a 	mov	r23,zero
81126010:	003ff206 	br	81125fdc <__reset+0xfb105fdc>

81126014 <_isatty_r>:
81126014:	defffd04 	addi	sp,sp,-12
81126018:	de00012e 	bgeu	sp,et,81126020 <_isatty_r+0xc>
8112601c:	003b68fa 	trap	3
81126020:	dc000015 	stw	r16,0(sp)
81126024:	04204574 	movhi	r16,33045
81126028:	dc400115 	stw	r17,4(sp)
8112602c:	8433bb04 	addi	r16,r16,-12564
81126030:	2023883a 	mov	r17,r4
81126034:	2809883a 	mov	r4,r5
81126038:	dfc00215 	stw	ra,8(sp)
8112603c:	80000015 	stw	zero,0(r16)
81126040:	11311640 	call	81131164 <isatty>
81126044:	00ffffc4 	movi	r3,-1
81126048:	10c00526 	beq	r2,r3,81126060 <_isatty_r+0x4c>
8112604c:	dfc00217 	ldw	ra,8(sp)
81126050:	dc400117 	ldw	r17,4(sp)
81126054:	dc000017 	ldw	r16,0(sp)
81126058:	dec00304 	addi	sp,sp,12
8112605c:	f800283a 	ret
81126060:	80c00017 	ldw	r3,0(r16)
81126064:	183ff926 	beq	r3,zero,8112604c <__reset+0xfb10604c>
81126068:	88c00015 	stw	r3,0(r17)
8112606c:	003ff706 	br	8112604c <__reset+0xfb10604c>

81126070 <iswspace>:
81126070:	00803fc4 	movi	r2,255
81126074:	11000836 	bltu	r2,r4,81126098 <iswspace+0x28>
81126078:	00a04574 	movhi	r2,33045
8112607c:	10b34c04 	addi	r2,r2,-13008
81126080:	10800017 	ldw	r2,0(r2)
81126084:	1109883a 	add	r4,r2,r4
81126088:	20800043 	ldbu	r2,1(r4)
8112608c:	1080020c 	andi	r2,r2,8
81126090:	10803fcc 	andi	r2,r2,255
81126094:	f800283a 	ret
81126098:	0005883a 	mov	r2,zero
8112609c:	f800283a 	ret

811260a0 <_setlocale_r>:
811260a0:	30001d26 	beq	r6,zero,81126118 <_setlocale_r+0x78>
811260a4:	01604574 	movhi	r5,33045
811260a8:	defffe04 	addi	sp,sp,-8
811260ac:	2969a504 	addi	r5,r5,-22892
811260b0:	3009883a 	mov	r4,r6
811260b4:	de00012e 	bgeu	sp,et,811260bc <_setlocale_r+0x1c>
811260b8:	003b68fa 	trap	3
811260bc:	dc000015 	stw	r16,0(sp)
811260c0:	dfc00115 	stw	ra,4(sp)
811260c4:	3021883a 	mov	r16,r6
811260c8:	1127dec0 	call	81127dec <strcmp>
811260cc:	1000061e 	bne	r2,zero,811260e8 <_setlocale_r+0x48>
811260d0:	00a04574 	movhi	r2,33045
811260d4:	10a97404 	addi	r2,r2,-23088
811260d8:	dfc00117 	ldw	ra,4(sp)
811260dc:	dc000017 	ldw	r16,0(sp)
811260e0:	dec00204 	addi	sp,sp,8
811260e4:	f800283a 	ret
811260e8:	01604574 	movhi	r5,33045
811260ec:	29697404 	addi	r5,r5,-23088
811260f0:	8009883a 	mov	r4,r16
811260f4:	1127dec0 	call	81127dec <strcmp>
811260f8:	103ff526 	beq	r2,zero,811260d0 <__reset+0xfb1060d0>
811260fc:	01604574 	movhi	r5,33045
81126100:	29697e04 	addi	r5,r5,-23048
81126104:	8009883a 	mov	r4,r16
81126108:	1127dec0 	call	81127dec <strcmp>
8112610c:	103ff026 	beq	r2,zero,811260d0 <__reset+0xfb1060d0>
81126110:	0005883a 	mov	r2,zero
81126114:	003ff006 	br	811260d8 <__reset+0xfb1060d8>
81126118:	00a04574 	movhi	r2,33045
8112611c:	10a97404 	addi	r2,r2,-23088
81126120:	f800283a 	ret

81126124 <__locale_charset>:
81126124:	00a04574 	movhi	r2,33045
81126128:	10ae1604 	addi	r2,r2,-18344
8112612c:	f800283a 	ret

81126130 <__locale_mb_cur_max>:
81126130:	00a04574 	movhi	r2,33045
81126134:	10b35104 	addi	r2,r2,-12988
81126138:	10800017 	ldw	r2,0(r2)
8112613c:	f800283a 	ret

81126140 <__locale_msgcharset>:
81126140:	00a04574 	movhi	r2,33045
81126144:	10ae0e04 	addi	r2,r2,-18376
81126148:	f800283a 	ret

8112614c <__locale_cjk_lang>:
8112614c:	0005883a 	mov	r2,zero
81126150:	f800283a 	ret

81126154 <_localeconv_r>:
81126154:	00a04574 	movhi	r2,33045
81126158:	10ae1e04 	addi	r2,r2,-18312
8112615c:	f800283a 	ret

81126160 <setlocale>:
81126160:	00a04574 	movhi	r2,33045
81126164:	10b34e04 	addi	r2,r2,-13000
81126168:	280d883a 	mov	r6,r5
8112616c:	200b883a 	mov	r5,r4
81126170:	11000017 	ldw	r4,0(r2)
81126174:	11260a01 	jmpi	811260a0 <_setlocale_r>

81126178 <localeconv>:
81126178:	00a04574 	movhi	r2,33045
8112617c:	10ae1e04 	addi	r2,r2,-18312
81126180:	f800283a 	ret

81126184 <_lseek_r>:
81126184:	defffd04 	addi	sp,sp,-12
81126188:	de00012e 	bgeu	sp,et,81126190 <_lseek_r+0xc>
8112618c:	003b68fa 	trap	3
81126190:	2805883a 	mov	r2,r5
81126194:	dc000015 	stw	r16,0(sp)
81126198:	04204574 	movhi	r16,33045
8112619c:	dc400115 	stw	r17,4(sp)
811261a0:	300b883a 	mov	r5,r6
811261a4:	8433bb04 	addi	r16,r16,-12564
811261a8:	2023883a 	mov	r17,r4
811261ac:	380d883a 	mov	r6,r7
811261b0:	1009883a 	mov	r4,r2
811261b4:	dfc00215 	stw	ra,8(sp)
811261b8:	80000015 	stw	zero,0(r16)
811261bc:	1131d600 	call	81131d60 <lseek>
811261c0:	00ffffc4 	movi	r3,-1
811261c4:	10c00526 	beq	r2,r3,811261dc <_lseek_r+0x58>
811261c8:	dfc00217 	ldw	ra,8(sp)
811261cc:	dc400117 	ldw	r17,4(sp)
811261d0:	dc000017 	ldw	r16,0(sp)
811261d4:	dec00304 	addi	sp,sp,12
811261d8:	f800283a 	ret
811261dc:	80c00017 	ldw	r3,0(r16)
811261e0:	183ff926 	beq	r3,zero,811261c8 <__reset+0xfb1061c8>
811261e4:	88c00015 	stw	r3,0(r17)
811261e8:	003ff706 	br	811261c8 <__reset+0xfb1061c8>

811261ec <_mbrtowc_r>:
811261ec:	defff704 	addi	sp,sp,-36
811261f0:	00a04574 	movhi	r2,33045
811261f4:	de00012e 	bgeu	sp,et,811261fc <_mbrtowc_r+0x10>
811261f8:	003b68fa 	trap	3
811261fc:	10b35204 	addi	r2,r2,-12984
81126200:	dc800715 	stw	r18,28(sp)
81126204:	dc400615 	stw	r17,24(sp)
81126208:	dc000515 	stw	r16,20(sp)
8112620c:	dfc00815 	stw	ra,32(sp)
81126210:	2021883a 	mov	r16,r4
81126214:	dc400917 	ldw	r17,36(sp)
81126218:	14800017 	ldw	r18,0(r2)
8112621c:	30001626 	beq	r6,zero,81126278 <_mbrtowc_r+0x8c>
81126220:	d9400215 	stw	r5,8(sp)
81126224:	d9800315 	stw	r6,12(sp)
81126228:	d9c00415 	stw	r7,16(sp)
8112622c:	11261240 	call	81126124 <__locale_charset>
81126230:	d9c00417 	ldw	r7,16(sp)
81126234:	d9800317 	ldw	r6,12(sp)
81126238:	d9400217 	ldw	r5,8(sp)
8112623c:	d8800015 	stw	r2,0(sp)
81126240:	dc400115 	stw	r17,4(sp)
81126244:	8009883a 	mov	r4,r16
81126248:	903ee83a 	callr	r18
8112624c:	00ffffc4 	movi	r3,-1
81126250:	10c0031e 	bne	r2,r3,81126260 <_mbrtowc_r+0x74>
81126254:	88000015 	stw	zero,0(r17)
81126258:	00c02284 	movi	r3,138
8112625c:	80c00015 	stw	r3,0(r16)
81126260:	dfc00817 	ldw	ra,32(sp)
81126264:	dc800717 	ldw	r18,28(sp)
81126268:	dc400617 	ldw	r17,24(sp)
8112626c:	dc000517 	ldw	r16,20(sp)
81126270:	dec00904 	addi	sp,sp,36
81126274:	f800283a 	ret
81126278:	11261240 	call	81126124 <__locale_charset>
8112627c:	01a04574 	movhi	r6,33045
81126280:	31a97e04 	addi	r6,r6,-23048
81126284:	dc400115 	stw	r17,4(sp)
81126288:	d8800015 	stw	r2,0(sp)
8112628c:	01c00044 	movi	r7,1
81126290:	000b883a 	mov	r5,zero
81126294:	8009883a 	mov	r4,r16
81126298:	903ee83a 	callr	r18
8112629c:	003feb06 	br	8112624c <__reset+0xfb10624c>

811262a0 <mbrtowc>:
811262a0:	defff704 	addi	sp,sp,-36
811262a4:	00a04574 	movhi	r2,33045
811262a8:	de00012e 	bgeu	sp,et,811262b0 <mbrtowc+0x10>
811262ac:	003b68fa 	trap	3
811262b0:	10b34e04 	addi	r2,r2,-13000
811262b4:	dc800415 	stw	r18,16(sp)
811262b8:	dc400315 	stw	r17,12(sp)
811262bc:	dfc00815 	stw	ra,32(sp)
811262c0:	dd400715 	stw	r21,28(sp)
811262c4:	dd000615 	stw	r20,24(sp)
811262c8:	dcc00515 	stw	r19,20(sp)
811262cc:	dc000215 	stw	r16,8(sp)
811262d0:	3825883a 	mov	r18,r7
811262d4:	14400017 	ldw	r17,0(r2)
811262d8:	28001c26 	beq	r5,zero,8112634c <mbrtowc+0xac>
811262dc:	00a04574 	movhi	r2,33045
811262e0:	10b35204 	addi	r2,r2,-12984
811262e4:	15400017 	ldw	r21,0(r2)
811262e8:	2821883a 	mov	r16,r5
811262ec:	2027883a 	mov	r19,r4
811262f0:	3029883a 	mov	r20,r6
811262f4:	11261240 	call	81126124 <__locale_charset>
811262f8:	d8800015 	stw	r2,0(sp)
811262fc:	dc800115 	stw	r18,4(sp)
81126300:	a00f883a 	mov	r7,r20
81126304:	800d883a 	mov	r6,r16
81126308:	980b883a 	mov	r5,r19
8112630c:	8809883a 	mov	r4,r17
81126310:	a83ee83a 	callr	r21
81126314:	00ffffc4 	movi	r3,-1
81126318:	10c0031e 	bne	r2,r3,81126328 <mbrtowc+0x88>
8112631c:	90000015 	stw	zero,0(r18)
81126320:	00c02284 	movi	r3,138
81126324:	88c00015 	stw	r3,0(r17)
81126328:	dfc00817 	ldw	ra,32(sp)
8112632c:	dd400717 	ldw	r21,28(sp)
81126330:	dd000617 	ldw	r20,24(sp)
81126334:	dcc00517 	ldw	r19,20(sp)
81126338:	dc800417 	ldw	r18,16(sp)
8112633c:	dc400317 	ldw	r17,12(sp)
81126340:	dc000217 	ldw	r16,8(sp)
81126344:	dec00904 	addi	sp,sp,36
81126348:	f800283a 	ret
8112634c:	00a04574 	movhi	r2,33045
81126350:	10b35204 	addi	r2,r2,-12984
81126354:	14000017 	ldw	r16,0(r2)
81126358:	11261240 	call	81126124 <__locale_charset>
8112635c:	01a04574 	movhi	r6,33045
81126360:	31a97e04 	addi	r6,r6,-23048
81126364:	dc800115 	stw	r18,4(sp)
81126368:	d8800015 	stw	r2,0(sp)
8112636c:	01c00044 	movi	r7,1
81126370:	000b883a 	mov	r5,zero
81126374:	8809883a 	mov	r4,r17
81126378:	803ee83a 	callr	r16
8112637c:	003fe506 	br	81126314 <__reset+0xfb106314>

81126380 <__ascii_mbtowc>:
81126380:	deffff04 	addi	sp,sp,-4
81126384:	de00012e 	bgeu	sp,et,8112638c <__ascii_mbtowc+0xc>
81126388:	003b68fa 	trap	3
8112638c:	28000826 	beq	r5,zero,811263b0 <__ascii_mbtowc+0x30>
81126390:	30000926 	beq	r6,zero,811263b8 <__ascii_mbtowc+0x38>
81126394:	38000b26 	beq	r7,zero,811263c4 <__ascii_mbtowc+0x44>
81126398:	30800003 	ldbu	r2,0(r6)
8112639c:	28800015 	stw	r2,0(r5)
811263a0:	30800003 	ldbu	r2,0(r6)
811263a4:	1004c03a 	cmpne	r2,r2,zero
811263a8:	dec00104 	addi	sp,sp,4
811263ac:	f800283a 	ret
811263b0:	d80b883a 	mov	r5,sp
811263b4:	303ff71e 	bne	r6,zero,81126394 <__reset+0xfb106394>
811263b8:	0005883a 	mov	r2,zero
811263bc:	dec00104 	addi	sp,sp,4
811263c0:	f800283a 	ret
811263c4:	00bfff84 	movi	r2,-2
811263c8:	003ff706 	br	811263a8 <__reset+0xfb1063a8>

811263cc <_mbtowc_r>:
811263cc:	00a04574 	movhi	r2,33045
811263d0:	defff804 	addi	sp,sp,-32
811263d4:	10b35204 	addi	r2,r2,-12984
811263d8:	de00012e 	bgeu	sp,et,811263e0 <_mbtowc_r+0x14>
811263dc:	003b68fa 	trap	3
811263e0:	dfc00715 	stw	ra,28(sp)
811263e4:	dc000615 	stw	r16,24(sp)
811263e8:	14000017 	ldw	r16,0(r2)
811263ec:	d9000215 	stw	r4,8(sp)
811263f0:	d9400315 	stw	r5,12(sp)
811263f4:	d9800415 	stw	r6,16(sp)
811263f8:	d9c00515 	stw	r7,20(sp)
811263fc:	11261240 	call	81126124 <__locale_charset>
81126400:	d8800015 	stw	r2,0(sp)
81126404:	d8800817 	ldw	r2,32(sp)
81126408:	d9c00517 	ldw	r7,20(sp)
8112640c:	d9800417 	ldw	r6,16(sp)
81126410:	d9400317 	ldw	r5,12(sp)
81126414:	d9000217 	ldw	r4,8(sp)
81126418:	d8800115 	stw	r2,4(sp)
8112641c:	803ee83a 	callr	r16
81126420:	dfc00717 	ldw	ra,28(sp)
81126424:	dc000617 	ldw	r16,24(sp)
81126428:	dec00804 	addi	sp,sp,32
8112642c:	f800283a 	ret

81126430 <memchr>:
81126430:	208000cc 	andi	r2,r4,3
81126434:	280f883a 	mov	r7,r5
81126438:	10003426 	beq	r2,zero,8112650c <memchr+0xdc>
8112643c:	30bfffc4 	addi	r2,r6,-1
81126440:	30001a26 	beq	r6,zero,811264ac <memchr+0x7c>
81126444:	20c00003 	ldbu	r3,0(r4)
81126448:	29803fcc 	andi	r6,r5,255
8112644c:	30c0051e 	bne	r6,r3,81126464 <memchr+0x34>
81126450:	00001806 	br	811264b4 <memchr+0x84>
81126454:	10001526 	beq	r2,zero,811264ac <memchr+0x7c>
81126458:	20c00003 	ldbu	r3,0(r4)
8112645c:	10bfffc4 	addi	r2,r2,-1
81126460:	30c01426 	beq	r6,r3,811264b4 <memchr+0x84>
81126464:	21000044 	addi	r4,r4,1
81126468:	20c000cc 	andi	r3,r4,3
8112646c:	183ff91e 	bne	r3,zero,81126454 <__reset+0xfb106454>
81126470:	020000c4 	movi	r8,3
81126474:	40801136 	bltu	r8,r2,811264bc <memchr+0x8c>
81126478:	10000c26 	beq	r2,zero,811264ac <memchr+0x7c>
8112647c:	20c00003 	ldbu	r3,0(r4)
81126480:	29403fcc 	andi	r5,r5,255
81126484:	28c00b26 	beq	r5,r3,811264b4 <memchr+0x84>
81126488:	20c00044 	addi	r3,r4,1
8112648c:	39803fcc 	andi	r6,r7,255
81126490:	2089883a 	add	r4,r4,r2
81126494:	00000306 	br	811264a4 <memchr+0x74>
81126498:	18c00044 	addi	r3,r3,1
8112649c:	197fffc3 	ldbu	r5,-1(r3)
811264a0:	31400526 	beq	r6,r5,811264b8 <memchr+0x88>
811264a4:	1805883a 	mov	r2,r3
811264a8:	20fffb1e 	bne	r4,r3,81126498 <__reset+0xfb106498>
811264ac:	0005883a 	mov	r2,zero
811264b0:	f800283a 	ret
811264b4:	2005883a 	mov	r2,r4
811264b8:	f800283a 	ret
811264bc:	28c03fcc 	andi	r3,r5,255
811264c0:	1812923a 	slli	r9,r3,8
811264c4:	02ffbff4 	movhi	r11,65279
811264c8:	02a02074 	movhi	r10,32897
811264cc:	48d2b03a 	or	r9,r9,r3
811264d0:	4806943a 	slli	r3,r9,16
811264d4:	5affbfc4 	addi	r11,r11,-257
811264d8:	52a02004 	addi	r10,r10,-32640
811264dc:	48d2b03a 	or	r9,r9,r3
811264e0:	20c00017 	ldw	r3,0(r4)
811264e4:	48c6f03a 	xor	r3,r9,r3
811264e8:	1acd883a 	add	r6,r3,r11
811264ec:	00c6303a 	nor	r3,zero,r3
811264f0:	30c6703a 	and	r3,r6,r3
811264f4:	1a86703a 	and	r3,r3,r10
811264f8:	183fe01e 	bne	r3,zero,8112647c <__reset+0xfb10647c>
811264fc:	10bfff04 	addi	r2,r2,-4
81126500:	21000104 	addi	r4,r4,4
81126504:	40bff636 	bltu	r8,r2,811264e0 <__reset+0xfb1064e0>
81126508:	003fdb06 	br	81126478 <__reset+0xfb106478>
8112650c:	3005883a 	mov	r2,r6
81126510:	003fd706 	br	81126470 <__reset+0xfb106470>

81126514 <memmove>:
81126514:	2005883a 	mov	r2,r4
81126518:	29000b2e 	bgeu	r5,r4,81126548 <memmove+0x34>
8112651c:	298f883a 	add	r7,r5,r6
81126520:	21c0092e 	bgeu	r4,r7,81126548 <memmove+0x34>
81126524:	2187883a 	add	r3,r4,r6
81126528:	198bc83a 	sub	r5,r3,r6
8112652c:	30004826 	beq	r6,zero,81126650 <memmove+0x13c>
81126530:	39ffffc4 	addi	r7,r7,-1
81126534:	39000003 	ldbu	r4,0(r7)
81126538:	18ffffc4 	addi	r3,r3,-1
8112653c:	19000005 	stb	r4,0(r3)
81126540:	28fffb1e 	bne	r5,r3,81126530 <__reset+0xfb106530>
81126544:	f800283a 	ret
81126548:	00c003c4 	movi	r3,15
8112654c:	1980412e 	bgeu	r3,r6,81126654 <memmove+0x140>
81126550:	2886b03a 	or	r3,r5,r2
81126554:	18c000cc 	andi	r3,r3,3
81126558:	1800401e 	bne	r3,zero,8112665c <memmove+0x148>
8112655c:	33fffc04 	addi	r15,r6,-16
81126560:	781ed13a 	srli	r15,r15,4
81126564:	28c00104 	addi	r3,r5,4
81126568:	13400104 	addi	r13,r2,4
8112656c:	781c913a 	slli	r14,r15,4
81126570:	2b000204 	addi	r12,r5,8
81126574:	12c00204 	addi	r11,r2,8
81126578:	73800504 	addi	r14,r14,20
8112657c:	2a800304 	addi	r10,r5,12
81126580:	12400304 	addi	r9,r2,12
81126584:	2b9d883a 	add	r14,r5,r14
81126588:	2811883a 	mov	r8,r5
8112658c:	100f883a 	mov	r7,r2
81126590:	41000017 	ldw	r4,0(r8)
81126594:	39c00404 	addi	r7,r7,16
81126598:	18c00404 	addi	r3,r3,16
8112659c:	393ffc15 	stw	r4,-16(r7)
811265a0:	193ffc17 	ldw	r4,-16(r3)
811265a4:	6b400404 	addi	r13,r13,16
811265a8:	5ac00404 	addi	r11,r11,16
811265ac:	693ffc15 	stw	r4,-16(r13)
811265b0:	61000017 	ldw	r4,0(r12)
811265b4:	4a400404 	addi	r9,r9,16
811265b8:	42000404 	addi	r8,r8,16
811265bc:	593ffc15 	stw	r4,-16(r11)
811265c0:	51000017 	ldw	r4,0(r10)
811265c4:	63000404 	addi	r12,r12,16
811265c8:	52800404 	addi	r10,r10,16
811265cc:	493ffc15 	stw	r4,-16(r9)
811265d0:	1bbfef1e 	bne	r3,r14,81126590 <__reset+0xfb106590>
811265d4:	79000044 	addi	r4,r15,1
811265d8:	2008913a 	slli	r4,r4,4
811265dc:	328003cc 	andi	r10,r6,15
811265e0:	02c000c4 	movi	r11,3
811265e4:	1107883a 	add	r3,r2,r4
811265e8:	290b883a 	add	r5,r5,r4
811265ec:	5a801e2e 	bgeu	r11,r10,81126668 <memmove+0x154>
811265f0:	1813883a 	mov	r9,r3
811265f4:	2811883a 	mov	r8,r5
811265f8:	500f883a 	mov	r7,r10
811265fc:	41000017 	ldw	r4,0(r8)
81126600:	4a400104 	addi	r9,r9,4
81126604:	39ffff04 	addi	r7,r7,-4
81126608:	493fff15 	stw	r4,-4(r9)
8112660c:	42000104 	addi	r8,r8,4
81126610:	59fffa36 	bltu	r11,r7,811265fc <__reset+0xfb1065fc>
81126614:	513fff04 	addi	r4,r10,-4
81126618:	2008d0ba 	srli	r4,r4,2
8112661c:	318000cc 	andi	r6,r6,3
81126620:	21000044 	addi	r4,r4,1
81126624:	2109883a 	add	r4,r4,r4
81126628:	2109883a 	add	r4,r4,r4
8112662c:	1907883a 	add	r3,r3,r4
81126630:	290b883a 	add	r5,r5,r4
81126634:	30000b26 	beq	r6,zero,81126664 <memmove+0x150>
81126638:	198d883a 	add	r6,r3,r6
8112663c:	29c00003 	ldbu	r7,0(r5)
81126640:	18c00044 	addi	r3,r3,1
81126644:	29400044 	addi	r5,r5,1
81126648:	19ffffc5 	stb	r7,-1(r3)
8112664c:	19bffb1e 	bne	r3,r6,8112663c <__reset+0xfb10663c>
81126650:	f800283a 	ret
81126654:	1007883a 	mov	r3,r2
81126658:	003ff606 	br	81126634 <__reset+0xfb106634>
8112665c:	1007883a 	mov	r3,r2
81126660:	003ff506 	br	81126638 <__reset+0xfb106638>
81126664:	f800283a 	ret
81126668:	500d883a 	mov	r6,r10
8112666c:	003ff106 	br	81126634 <__reset+0xfb106634>

81126670 <_Balloc>:
81126670:	defffc04 	addi	sp,sp,-16
81126674:	de00012e 	bgeu	sp,et,8112667c <_Balloc+0xc>
81126678:	003b68fa 	trap	3
8112667c:	20801317 	ldw	r2,76(r4)
81126680:	dc400115 	stw	r17,4(sp)
81126684:	dc000015 	stw	r16,0(sp)
81126688:	dfc00315 	stw	ra,12(sp)
8112668c:	dc800215 	stw	r18,8(sp)
81126690:	2023883a 	mov	r17,r4
81126694:	2821883a 	mov	r16,r5
81126698:	10000f26 	beq	r2,zero,811266d8 <_Balloc+0x68>
8112669c:	8407883a 	add	r3,r16,r16
811266a0:	18c7883a 	add	r3,r3,r3
811266a4:	10c7883a 	add	r3,r2,r3
811266a8:	18800017 	ldw	r2,0(r3)
811266ac:	10001126 	beq	r2,zero,811266f4 <_Balloc+0x84>
811266b0:	11000017 	ldw	r4,0(r2)
811266b4:	19000015 	stw	r4,0(r3)
811266b8:	10000415 	stw	zero,16(r2)
811266bc:	10000315 	stw	zero,12(r2)
811266c0:	dfc00317 	ldw	ra,12(sp)
811266c4:	dc800217 	ldw	r18,8(sp)
811266c8:	dc400117 	ldw	r17,4(sp)
811266cc:	dc000017 	ldw	r16,0(sp)
811266d0:	dec00404 	addi	sp,sp,16
811266d4:	f800283a 	ret
811266d8:	01800844 	movi	r6,33
811266dc:	01400104 	movi	r5,4
811266e0:	112cb980 	call	8112cb98 <_calloc_r>
811266e4:	88801315 	stw	r2,76(r17)
811266e8:	103fec1e 	bne	r2,zero,8112669c <__reset+0xfb10669c>
811266ec:	0005883a 	mov	r2,zero
811266f0:	003ff306 	br	811266c0 <__reset+0xfb1066c0>
811266f4:	01400044 	movi	r5,1
811266f8:	2c24983a 	sll	r18,r5,r16
811266fc:	8809883a 	mov	r4,r17
81126700:	91800144 	addi	r6,r18,5
81126704:	318d883a 	add	r6,r6,r6
81126708:	318d883a 	add	r6,r6,r6
8112670c:	112cb980 	call	8112cb98 <_calloc_r>
81126710:	103ff626 	beq	r2,zero,811266ec <__reset+0xfb1066ec>
81126714:	14000115 	stw	r16,4(r2)
81126718:	14800215 	stw	r18,8(r2)
8112671c:	003fe606 	br	811266b8 <__reset+0xfb1066b8>

81126720 <_Bfree>:
81126720:	28000826 	beq	r5,zero,81126744 <_Bfree+0x24>
81126724:	28c00117 	ldw	r3,4(r5)
81126728:	20801317 	ldw	r2,76(r4)
8112672c:	18c7883a 	add	r3,r3,r3
81126730:	18c7883a 	add	r3,r3,r3
81126734:	10c5883a 	add	r2,r2,r3
81126738:	10c00017 	ldw	r3,0(r2)
8112673c:	28c00015 	stw	r3,0(r5)
81126740:	11400015 	stw	r5,0(r2)
81126744:	f800283a 	ret

81126748 <__multadd>:
81126748:	defffa04 	addi	sp,sp,-24
8112674c:	de00012e 	bgeu	sp,et,81126754 <__multadd+0xc>
81126750:	003b68fa 	trap	3
81126754:	0011883a 	mov	r8,zero
81126758:	dc800315 	stw	r18,12(sp)
8112675c:	dc400215 	stw	r17,8(sp)
81126760:	dc000115 	stw	r16,4(sp)
81126764:	2823883a 	mov	r17,r5
81126768:	2c000417 	ldw	r16,16(r5)
8112676c:	dfc00515 	stw	ra,20(sp)
81126770:	dcc00415 	stw	r19,16(sp)
81126774:	2025883a 	mov	r18,r4
81126778:	29400504 	addi	r5,r5,20
8112677c:	28c00017 	ldw	r3,0(r5)
81126780:	29400104 	addi	r5,r5,4
81126784:	42000044 	addi	r8,r8,1
81126788:	18bfffcc 	andi	r2,r3,65535
8112678c:	1185383a 	mul	r2,r2,r6
81126790:	1806d43a 	srli	r3,r3,16
81126794:	11cf883a 	add	r7,r2,r7
81126798:	3808d43a 	srli	r4,r7,16
8112679c:	1987383a 	mul	r3,r3,r6
811267a0:	38bfffcc 	andi	r2,r7,65535
811267a4:	1907883a 	add	r3,r3,r4
811267a8:	1808943a 	slli	r4,r3,16
811267ac:	180ed43a 	srli	r7,r3,16
811267b0:	2085883a 	add	r2,r4,r2
811267b4:	28bfff15 	stw	r2,-4(r5)
811267b8:	443ff016 	blt	r8,r16,8112677c <__reset+0xfb10677c>
811267bc:	38000926 	beq	r7,zero,811267e4 <__multadd+0x9c>
811267c0:	88800217 	ldw	r2,8(r17)
811267c4:	80800f0e 	bge	r16,r2,81126804 <__multadd+0xbc>
811267c8:	80800144 	addi	r2,r16,5
811267cc:	1085883a 	add	r2,r2,r2
811267d0:	1085883a 	add	r2,r2,r2
811267d4:	8885883a 	add	r2,r17,r2
811267d8:	11c00015 	stw	r7,0(r2)
811267dc:	84000044 	addi	r16,r16,1
811267e0:	8c000415 	stw	r16,16(r17)
811267e4:	8805883a 	mov	r2,r17
811267e8:	dfc00517 	ldw	ra,20(sp)
811267ec:	dcc00417 	ldw	r19,16(sp)
811267f0:	dc800317 	ldw	r18,12(sp)
811267f4:	dc400217 	ldw	r17,8(sp)
811267f8:	dc000117 	ldw	r16,4(sp)
811267fc:	dec00604 	addi	sp,sp,24
81126800:	f800283a 	ret
81126804:	89400117 	ldw	r5,4(r17)
81126808:	9009883a 	mov	r4,r18
8112680c:	d9c00015 	stw	r7,0(sp)
81126810:	29400044 	addi	r5,r5,1
81126814:	11266700 	call	81126670 <_Balloc>
81126818:	89800417 	ldw	r6,16(r17)
8112681c:	89400304 	addi	r5,r17,12
81126820:	11000304 	addi	r4,r2,12
81126824:	31800084 	addi	r6,r6,2
81126828:	318d883a 	add	r6,r6,r6
8112682c:	318d883a 	add	r6,r6,r6
81126830:	1027883a 	mov	r19,r2
81126834:	111c4400 	call	8111c440 <memcpy>
81126838:	d9c00017 	ldw	r7,0(sp)
8112683c:	88000a26 	beq	r17,zero,81126868 <__multadd+0x120>
81126840:	88c00117 	ldw	r3,4(r17)
81126844:	90801317 	ldw	r2,76(r18)
81126848:	18c7883a 	add	r3,r3,r3
8112684c:	18c7883a 	add	r3,r3,r3
81126850:	10c5883a 	add	r2,r2,r3
81126854:	10c00017 	ldw	r3,0(r2)
81126858:	88c00015 	stw	r3,0(r17)
8112685c:	14400015 	stw	r17,0(r2)
81126860:	9823883a 	mov	r17,r19
81126864:	003fd806 	br	811267c8 <__reset+0xfb1067c8>
81126868:	9823883a 	mov	r17,r19
8112686c:	003fd606 	br	811267c8 <__reset+0xfb1067c8>

81126870 <__s2b>:
81126870:	defff904 	addi	sp,sp,-28
81126874:	de00012e 	bgeu	sp,et,8112687c <__s2b+0xc>
81126878:	003b68fa 	trap	3
8112687c:	dc400115 	stw	r17,4(sp)
81126880:	dc000015 	stw	r16,0(sp)
81126884:	2023883a 	mov	r17,r4
81126888:	2821883a 	mov	r16,r5
8112688c:	39000204 	addi	r4,r7,8
81126890:	01400244 	movi	r5,9
81126894:	dcc00315 	stw	r19,12(sp)
81126898:	dc800215 	stw	r18,8(sp)
8112689c:	dfc00615 	stw	ra,24(sp)
811268a0:	dd400515 	stw	r21,20(sp)
811268a4:	dd000415 	stw	r20,16(sp)
811268a8:	3825883a 	mov	r18,r7
811268ac:	3027883a 	mov	r19,r6
811268b0:	112e9300 	call	8112e930 <__divsi3>
811268b4:	00c00044 	movi	r3,1
811268b8:	000b883a 	mov	r5,zero
811268bc:	1880030e 	bge	r3,r2,811268cc <__s2b+0x5c>
811268c0:	18c7883a 	add	r3,r3,r3
811268c4:	29400044 	addi	r5,r5,1
811268c8:	18bffd16 	blt	r3,r2,811268c0 <__reset+0xfb1068c0>
811268cc:	8809883a 	mov	r4,r17
811268d0:	11266700 	call	81126670 <_Balloc>
811268d4:	d8c00717 	ldw	r3,28(sp)
811268d8:	10c00515 	stw	r3,20(r2)
811268dc:	00c00044 	movi	r3,1
811268e0:	10c00415 	stw	r3,16(r2)
811268e4:	00c00244 	movi	r3,9
811268e8:	1cc0210e 	bge	r3,r19,81126970 <__s2b+0x100>
811268ec:	80eb883a 	add	r21,r16,r3
811268f0:	a829883a 	mov	r20,r21
811268f4:	84e1883a 	add	r16,r16,r19
811268f8:	a1c00007 	ldb	r7,0(r20)
811268fc:	01800284 	movi	r6,10
81126900:	a5000044 	addi	r20,r20,1
81126904:	100b883a 	mov	r5,r2
81126908:	39fff404 	addi	r7,r7,-48
8112690c:	8809883a 	mov	r4,r17
81126910:	11267480 	call	81126748 <__multadd>
81126914:	a43ff81e 	bne	r20,r16,811268f8 <__reset+0xfb1068f8>
81126918:	ace1883a 	add	r16,r21,r19
8112691c:	843ffe04 	addi	r16,r16,-8
81126920:	9c800a0e 	bge	r19,r18,8112694c <__s2b+0xdc>
81126924:	94e5c83a 	sub	r18,r18,r19
81126928:	84a5883a 	add	r18,r16,r18
8112692c:	81c00007 	ldb	r7,0(r16)
81126930:	01800284 	movi	r6,10
81126934:	84000044 	addi	r16,r16,1
81126938:	100b883a 	mov	r5,r2
8112693c:	39fff404 	addi	r7,r7,-48
81126940:	8809883a 	mov	r4,r17
81126944:	11267480 	call	81126748 <__multadd>
81126948:	84bff81e 	bne	r16,r18,8112692c <__reset+0xfb10692c>
8112694c:	dfc00617 	ldw	ra,24(sp)
81126950:	dd400517 	ldw	r21,20(sp)
81126954:	dd000417 	ldw	r20,16(sp)
81126958:	dcc00317 	ldw	r19,12(sp)
8112695c:	dc800217 	ldw	r18,8(sp)
81126960:	dc400117 	ldw	r17,4(sp)
81126964:	dc000017 	ldw	r16,0(sp)
81126968:	dec00704 	addi	sp,sp,28
8112696c:	f800283a 	ret
81126970:	84000284 	addi	r16,r16,10
81126974:	1827883a 	mov	r19,r3
81126978:	003fe906 	br	81126920 <__reset+0xfb106920>

8112697c <__hi0bits>:
8112697c:	20bfffec 	andhi	r2,r4,65535
81126980:	1000141e 	bne	r2,zero,811269d4 <__hi0bits+0x58>
81126984:	2008943a 	slli	r4,r4,16
81126988:	00800404 	movi	r2,16
8112698c:	20ffc02c 	andhi	r3,r4,65280
81126990:	1800021e 	bne	r3,zero,8112699c <__hi0bits+0x20>
81126994:	2008923a 	slli	r4,r4,8
81126998:	10800204 	addi	r2,r2,8
8112699c:	20fc002c 	andhi	r3,r4,61440
811269a0:	1800021e 	bne	r3,zero,811269ac <__hi0bits+0x30>
811269a4:	2008913a 	slli	r4,r4,4
811269a8:	10800104 	addi	r2,r2,4
811269ac:	20f0002c 	andhi	r3,r4,49152
811269b0:	1800031e 	bne	r3,zero,811269c0 <__hi0bits+0x44>
811269b4:	2109883a 	add	r4,r4,r4
811269b8:	10800084 	addi	r2,r2,2
811269bc:	2109883a 	add	r4,r4,r4
811269c0:	20000316 	blt	r4,zero,811269d0 <__hi0bits+0x54>
811269c4:	2110002c 	andhi	r4,r4,16384
811269c8:	2000041e 	bne	r4,zero,811269dc <__hi0bits+0x60>
811269cc:	00800804 	movi	r2,32
811269d0:	f800283a 	ret
811269d4:	0005883a 	mov	r2,zero
811269d8:	003fec06 	br	8112698c <__reset+0xfb10698c>
811269dc:	10800044 	addi	r2,r2,1
811269e0:	f800283a 	ret

811269e4 <__lo0bits>:
811269e4:	20c00017 	ldw	r3,0(r4)
811269e8:	188001cc 	andi	r2,r3,7
811269ec:	10000826 	beq	r2,zero,81126a10 <__lo0bits+0x2c>
811269f0:	1880004c 	andi	r2,r3,1
811269f4:	1000211e 	bne	r2,zero,81126a7c <__lo0bits+0x98>
811269f8:	1880008c 	andi	r2,r3,2
811269fc:	1000211e 	bne	r2,zero,81126a84 <__lo0bits+0xa0>
81126a00:	1806d0ba 	srli	r3,r3,2
81126a04:	00800084 	movi	r2,2
81126a08:	20c00015 	stw	r3,0(r4)
81126a0c:	f800283a 	ret
81126a10:	18bfffcc 	andi	r2,r3,65535
81126a14:	10001326 	beq	r2,zero,81126a64 <__lo0bits+0x80>
81126a18:	0005883a 	mov	r2,zero
81126a1c:	19403fcc 	andi	r5,r3,255
81126a20:	2800021e 	bne	r5,zero,81126a2c <__lo0bits+0x48>
81126a24:	1806d23a 	srli	r3,r3,8
81126a28:	10800204 	addi	r2,r2,8
81126a2c:	194003cc 	andi	r5,r3,15
81126a30:	2800021e 	bne	r5,zero,81126a3c <__lo0bits+0x58>
81126a34:	1806d13a 	srli	r3,r3,4
81126a38:	10800104 	addi	r2,r2,4
81126a3c:	194000cc 	andi	r5,r3,3
81126a40:	2800021e 	bne	r5,zero,81126a4c <__lo0bits+0x68>
81126a44:	1806d0ba 	srli	r3,r3,2
81126a48:	10800084 	addi	r2,r2,2
81126a4c:	1940004c 	andi	r5,r3,1
81126a50:	2800081e 	bne	r5,zero,81126a74 <__lo0bits+0x90>
81126a54:	1806d07a 	srli	r3,r3,1
81126a58:	1800051e 	bne	r3,zero,81126a70 <__lo0bits+0x8c>
81126a5c:	00800804 	movi	r2,32
81126a60:	f800283a 	ret
81126a64:	1806d43a 	srli	r3,r3,16
81126a68:	00800404 	movi	r2,16
81126a6c:	003feb06 	br	81126a1c <__reset+0xfb106a1c>
81126a70:	10800044 	addi	r2,r2,1
81126a74:	20c00015 	stw	r3,0(r4)
81126a78:	f800283a 	ret
81126a7c:	0005883a 	mov	r2,zero
81126a80:	f800283a 	ret
81126a84:	1806d07a 	srli	r3,r3,1
81126a88:	00800044 	movi	r2,1
81126a8c:	20c00015 	stw	r3,0(r4)
81126a90:	f800283a 	ret

81126a94 <__i2b>:
81126a94:	defffd04 	addi	sp,sp,-12
81126a98:	de00012e 	bgeu	sp,et,81126aa0 <__i2b+0xc>
81126a9c:	003b68fa 	trap	3
81126aa0:	dc000015 	stw	r16,0(sp)
81126aa4:	04000044 	movi	r16,1
81126aa8:	dc400115 	stw	r17,4(sp)
81126aac:	2823883a 	mov	r17,r5
81126ab0:	800b883a 	mov	r5,r16
81126ab4:	dfc00215 	stw	ra,8(sp)
81126ab8:	11266700 	call	81126670 <_Balloc>
81126abc:	14400515 	stw	r17,20(r2)
81126ac0:	14000415 	stw	r16,16(r2)
81126ac4:	dfc00217 	ldw	ra,8(sp)
81126ac8:	dc400117 	ldw	r17,4(sp)
81126acc:	dc000017 	ldw	r16,0(sp)
81126ad0:	dec00304 	addi	sp,sp,12
81126ad4:	f800283a 	ret

81126ad8 <__multiply>:
81126ad8:	defffa04 	addi	sp,sp,-24
81126adc:	de00012e 	bgeu	sp,et,81126ae4 <__multiply+0xc>
81126ae0:	003b68fa 	trap	3
81126ae4:	dcc00315 	stw	r19,12(sp)
81126ae8:	dc800215 	stw	r18,8(sp)
81126aec:	34c00417 	ldw	r19,16(r6)
81126af0:	2c800417 	ldw	r18,16(r5)
81126af4:	dd000415 	stw	r20,16(sp)
81126af8:	dc400115 	stw	r17,4(sp)
81126afc:	dfc00515 	stw	ra,20(sp)
81126b00:	dc000015 	stw	r16,0(sp)
81126b04:	2829883a 	mov	r20,r5
81126b08:	3023883a 	mov	r17,r6
81126b0c:	94c0050e 	bge	r18,r19,81126b24 <__multiply+0x4c>
81126b10:	9007883a 	mov	r3,r18
81126b14:	3029883a 	mov	r20,r6
81126b18:	9825883a 	mov	r18,r19
81126b1c:	2823883a 	mov	r17,r5
81126b20:	1827883a 	mov	r19,r3
81126b24:	a0800217 	ldw	r2,8(r20)
81126b28:	94e1883a 	add	r16,r18,r19
81126b2c:	a1400117 	ldw	r5,4(r20)
81126b30:	1400010e 	bge	r2,r16,81126b38 <__multiply+0x60>
81126b34:	29400044 	addi	r5,r5,1
81126b38:	11266700 	call	81126670 <_Balloc>
81126b3c:	8415883a 	add	r10,r16,r16
81126b40:	12c00504 	addi	r11,r2,20
81126b44:	5295883a 	add	r10,r10,r10
81126b48:	5a95883a 	add	r10,r11,r10
81126b4c:	5807883a 	mov	r3,r11
81126b50:	5a80032e 	bgeu	r11,r10,81126b60 <__multiply+0x88>
81126b54:	18000015 	stw	zero,0(r3)
81126b58:	18c00104 	addi	r3,r3,4
81126b5c:	1abffd36 	bltu	r3,r10,81126b54 <__reset+0xfb106b54>
81126b60:	9ce7883a 	add	r19,r19,r19
81126b64:	94a5883a 	add	r18,r18,r18
81126b68:	89800504 	addi	r6,r17,20
81126b6c:	9ce7883a 	add	r19,r19,r19
81126b70:	a3400504 	addi	r13,r20,20
81126b74:	94a5883a 	add	r18,r18,r18
81126b78:	34d9883a 	add	r12,r6,r19
81126b7c:	6c93883a 	add	r9,r13,r18
81126b80:	3300422e 	bgeu	r6,r12,81126c8c <__multiply+0x1b4>
81126b84:	37c00017 	ldw	ra,0(r6)
81126b88:	fbffffcc 	andi	r15,ra,65535
81126b8c:	78001b26 	beq	r15,zero,81126bfc <__multiply+0x124>
81126b90:	5811883a 	mov	r8,r11
81126b94:	681d883a 	mov	r14,r13
81126b98:	000f883a 	mov	r7,zero
81126b9c:	71000017 	ldw	r4,0(r14)
81126ba0:	40c00017 	ldw	r3,0(r8)
81126ba4:	73800104 	addi	r14,r14,4
81126ba8:	217fffcc 	andi	r5,r4,65535
81126bac:	2bcb383a 	mul	r5,r5,r15
81126bb0:	2008d43a 	srli	r4,r4,16
81126bb4:	1c7fffcc 	andi	r17,r3,65535
81126bb8:	2c4b883a 	add	r5,r5,r17
81126bbc:	29cb883a 	add	r5,r5,r7
81126bc0:	23c9383a 	mul	r4,r4,r15
81126bc4:	1806d43a 	srli	r3,r3,16
81126bc8:	280ed43a 	srli	r7,r5,16
81126bcc:	297fffcc 	andi	r5,r5,65535
81126bd0:	20c7883a 	add	r3,r4,r3
81126bd4:	19c7883a 	add	r3,r3,r7
81126bd8:	1808943a 	slli	r4,r3,16
81126bdc:	4023883a 	mov	r17,r8
81126be0:	180ed43a 	srli	r7,r3,16
81126be4:	214ab03a 	or	r5,r4,r5
81126be8:	41400015 	stw	r5,0(r8)
81126bec:	42000104 	addi	r8,r8,4
81126bf0:	727fea36 	bltu	r14,r9,81126b9c <__reset+0xfb106b9c>
81126bf4:	89c00115 	stw	r7,4(r17)
81126bf8:	37c00017 	ldw	ra,0(r6)
81126bfc:	f83ed43a 	srli	ra,ra,16
81126c00:	f8001f26 	beq	ra,zero,81126c80 <__multiply+0x1a8>
81126c04:	58c00017 	ldw	r3,0(r11)
81126c08:	681d883a 	mov	r14,r13
81126c0c:	581f883a 	mov	r15,r11
81126c10:	1811883a 	mov	r8,r3
81126c14:	5825883a 	mov	r18,r11
81126c18:	000f883a 	mov	r7,zero
81126c1c:	00000106 	br	81126c24 <__multiply+0x14c>
81126c20:	8825883a 	mov	r18,r17
81126c24:	7140000b 	ldhu	r5,0(r14)
81126c28:	4010d43a 	srli	r8,r8,16
81126c2c:	193fffcc 	andi	r4,r3,65535
81126c30:	2fcb383a 	mul	r5,r5,ra
81126c34:	7bc00104 	addi	r15,r15,4
81126c38:	73800104 	addi	r14,r14,4
81126c3c:	2a0b883a 	add	r5,r5,r8
81126c40:	29cb883a 	add	r5,r5,r7
81126c44:	2806943a 	slli	r3,r5,16
81126c48:	94400104 	addi	r17,r18,4
81126c4c:	280ad43a 	srli	r5,r5,16
81126c50:	1908b03a 	or	r4,r3,r4
81126c54:	793fff15 	stw	r4,-4(r15)
81126c58:	70ffff17 	ldw	r3,-4(r14)
81126c5c:	8a000017 	ldw	r8,0(r17)
81126c60:	1806d43a 	srli	r3,r3,16
81126c64:	413fffcc 	andi	r4,r8,65535
81126c68:	1fc7383a 	mul	r3,r3,ra
81126c6c:	1907883a 	add	r3,r3,r4
81126c70:	1947883a 	add	r3,r3,r5
81126c74:	180ed43a 	srli	r7,r3,16
81126c78:	727fe936 	bltu	r14,r9,81126c20 <__reset+0xfb106c20>
81126c7c:	90c00115 	stw	r3,4(r18)
81126c80:	31800104 	addi	r6,r6,4
81126c84:	5ac00104 	addi	r11,r11,4
81126c88:	333fbe36 	bltu	r6,r12,81126b84 <__reset+0xfb106b84>
81126c8c:	0400090e 	bge	zero,r16,81126cb4 <__multiply+0x1dc>
81126c90:	50ffff17 	ldw	r3,-4(r10)
81126c94:	52bfff04 	addi	r10,r10,-4
81126c98:	18000326 	beq	r3,zero,81126ca8 <__multiply+0x1d0>
81126c9c:	00000506 	br	81126cb4 <__multiply+0x1dc>
81126ca0:	50c00017 	ldw	r3,0(r10)
81126ca4:	1800031e 	bne	r3,zero,81126cb4 <__multiply+0x1dc>
81126ca8:	843fffc4 	addi	r16,r16,-1
81126cac:	52bfff04 	addi	r10,r10,-4
81126cb0:	803ffb1e 	bne	r16,zero,81126ca0 <__reset+0xfb106ca0>
81126cb4:	14000415 	stw	r16,16(r2)
81126cb8:	dfc00517 	ldw	ra,20(sp)
81126cbc:	dd000417 	ldw	r20,16(sp)
81126cc0:	dcc00317 	ldw	r19,12(sp)
81126cc4:	dc800217 	ldw	r18,8(sp)
81126cc8:	dc400117 	ldw	r17,4(sp)
81126ccc:	dc000017 	ldw	r16,0(sp)
81126cd0:	dec00604 	addi	sp,sp,24
81126cd4:	f800283a 	ret

81126cd8 <__pow5mult>:
81126cd8:	defffa04 	addi	sp,sp,-24
81126cdc:	de00012e 	bgeu	sp,et,81126ce4 <__pow5mult+0xc>
81126ce0:	003b68fa 	trap	3
81126ce4:	308000cc 	andi	r2,r6,3
81126ce8:	dcc00315 	stw	r19,12(sp)
81126cec:	dc000015 	stw	r16,0(sp)
81126cf0:	dfc00515 	stw	ra,20(sp)
81126cf4:	dd000415 	stw	r20,16(sp)
81126cf8:	dc800215 	stw	r18,8(sp)
81126cfc:	dc400115 	stw	r17,4(sp)
81126d00:	3021883a 	mov	r16,r6
81126d04:	2027883a 	mov	r19,r4
81126d08:	10002f1e 	bne	r2,zero,81126dc8 <__pow5mult+0xf0>
81126d0c:	2825883a 	mov	r18,r5
81126d10:	8021d0ba 	srai	r16,r16,2
81126d14:	80001a26 	beq	r16,zero,81126d80 <__pow5mult+0xa8>
81126d18:	9c401217 	ldw	r17,72(r19)
81126d1c:	8800061e 	bne	r17,zero,81126d38 <__pow5mult+0x60>
81126d20:	00003406 	br	81126df4 <__pow5mult+0x11c>
81126d24:	8021d07a 	srai	r16,r16,1
81126d28:	80001526 	beq	r16,zero,81126d80 <__pow5mult+0xa8>
81126d2c:	88800017 	ldw	r2,0(r17)
81126d30:	10001c26 	beq	r2,zero,81126da4 <__pow5mult+0xcc>
81126d34:	1023883a 	mov	r17,r2
81126d38:	8080004c 	andi	r2,r16,1
81126d3c:	103ff926 	beq	r2,zero,81126d24 <__reset+0xfb106d24>
81126d40:	880d883a 	mov	r6,r17
81126d44:	900b883a 	mov	r5,r18
81126d48:	9809883a 	mov	r4,r19
81126d4c:	1126ad80 	call	81126ad8 <__multiply>
81126d50:	90001b26 	beq	r18,zero,81126dc0 <__pow5mult+0xe8>
81126d54:	91000117 	ldw	r4,4(r18)
81126d58:	98c01317 	ldw	r3,76(r19)
81126d5c:	8021d07a 	srai	r16,r16,1
81126d60:	2109883a 	add	r4,r4,r4
81126d64:	2109883a 	add	r4,r4,r4
81126d68:	1907883a 	add	r3,r3,r4
81126d6c:	19000017 	ldw	r4,0(r3)
81126d70:	91000015 	stw	r4,0(r18)
81126d74:	1c800015 	stw	r18,0(r3)
81126d78:	1025883a 	mov	r18,r2
81126d7c:	803feb1e 	bne	r16,zero,81126d2c <__reset+0xfb106d2c>
81126d80:	9005883a 	mov	r2,r18
81126d84:	dfc00517 	ldw	ra,20(sp)
81126d88:	dd000417 	ldw	r20,16(sp)
81126d8c:	dcc00317 	ldw	r19,12(sp)
81126d90:	dc800217 	ldw	r18,8(sp)
81126d94:	dc400117 	ldw	r17,4(sp)
81126d98:	dc000017 	ldw	r16,0(sp)
81126d9c:	dec00604 	addi	sp,sp,24
81126da0:	f800283a 	ret
81126da4:	880d883a 	mov	r6,r17
81126da8:	880b883a 	mov	r5,r17
81126dac:	9809883a 	mov	r4,r19
81126db0:	1126ad80 	call	81126ad8 <__multiply>
81126db4:	88800015 	stw	r2,0(r17)
81126db8:	10000015 	stw	zero,0(r2)
81126dbc:	003fdd06 	br	81126d34 <__reset+0xfb106d34>
81126dc0:	1025883a 	mov	r18,r2
81126dc4:	003fd706 	br	81126d24 <__reset+0xfb106d24>
81126dc8:	10bfffc4 	addi	r2,r2,-1
81126dcc:	1085883a 	add	r2,r2,r2
81126dd0:	00e04574 	movhi	r3,33045
81126dd4:	18e9a804 	addi	r3,r3,-22880
81126dd8:	1085883a 	add	r2,r2,r2
81126ddc:	1885883a 	add	r2,r3,r2
81126de0:	11800017 	ldw	r6,0(r2)
81126de4:	000f883a 	mov	r7,zero
81126de8:	11267480 	call	81126748 <__multadd>
81126dec:	1025883a 	mov	r18,r2
81126df0:	003fc706 	br	81126d10 <__reset+0xfb106d10>
81126df4:	05000044 	movi	r20,1
81126df8:	a00b883a 	mov	r5,r20
81126dfc:	9809883a 	mov	r4,r19
81126e00:	11266700 	call	81126670 <_Balloc>
81126e04:	1023883a 	mov	r17,r2
81126e08:	00809c44 	movi	r2,625
81126e0c:	88800515 	stw	r2,20(r17)
81126e10:	8d000415 	stw	r20,16(r17)
81126e14:	9c401215 	stw	r17,72(r19)
81126e18:	88000015 	stw	zero,0(r17)
81126e1c:	003fc606 	br	81126d38 <__reset+0xfb106d38>

81126e20 <__lshift>:
81126e20:	defff904 	addi	sp,sp,-28
81126e24:	de00012e 	bgeu	sp,et,81126e2c <__lshift+0xc>
81126e28:	003b68fa 	trap	3
81126e2c:	dd400515 	stw	r21,20(sp)
81126e30:	dcc00315 	stw	r19,12(sp)
81126e34:	302bd17a 	srai	r21,r6,5
81126e38:	2cc00417 	ldw	r19,16(r5)
81126e3c:	28800217 	ldw	r2,8(r5)
81126e40:	dd000415 	stw	r20,16(sp)
81126e44:	ace7883a 	add	r19,r21,r19
81126e48:	dc800215 	stw	r18,8(sp)
81126e4c:	dc400115 	stw	r17,4(sp)
81126e50:	dc000015 	stw	r16,0(sp)
81126e54:	dfc00615 	stw	ra,24(sp)
81126e58:	9c000044 	addi	r16,r19,1
81126e5c:	2823883a 	mov	r17,r5
81126e60:	3029883a 	mov	r20,r6
81126e64:	2025883a 	mov	r18,r4
81126e68:	29400117 	ldw	r5,4(r5)
81126e6c:	1400030e 	bge	r2,r16,81126e7c <__lshift+0x5c>
81126e70:	1085883a 	add	r2,r2,r2
81126e74:	29400044 	addi	r5,r5,1
81126e78:	143ffd16 	blt	r2,r16,81126e70 <__reset+0xfb106e70>
81126e7c:	9009883a 	mov	r4,r18
81126e80:	11266700 	call	81126670 <_Balloc>
81126e84:	10c00504 	addi	r3,r2,20
81126e88:	0540070e 	bge	zero,r21,81126ea8 <__lshift+0x88>
81126e8c:	ad6b883a 	add	r21,r21,r21
81126e90:	ad6b883a 	add	r21,r21,r21
81126e94:	1809883a 	mov	r4,r3
81126e98:	1d47883a 	add	r3,r3,r21
81126e9c:	20000015 	stw	zero,0(r4)
81126ea0:	21000104 	addi	r4,r4,4
81126ea4:	193ffd1e 	bne	r3,r4,81126e9c <__reset+0xfb106e9c>
81126ea8:	8a000417 	ldw	r8,16(r17)
81126eac:	89000504 	addi	r4,r17,20
81126eb0:	a18007cc 	andi	r6,r20,31
81126eb4:	4211883a 	add	r8,r8,r8
81126eb8:	4211883a 	add	r8,r8,r8
81126ebc:	2211883a 	add	r8,r4,r8
81126ec0:	30002326 	beq	r6,zero,81126f50 <__lshift+0x130>
81126ec4:	02400804 	movi	r9,32
81126ec8:	4993c83a 	sub	r9,r9,r6
81126ecc:	000b883a 	mov	r5,zero
81126ed0:	21c00017 	ldw	r7,0(r4)
81126ed4:	1815883a 	mov	r10,r3
81126ed8:	18c00104 	addi	r3,r3,4
81126edc:	398e983a 	sll	r7,r7,r6
81126ee0:	21000104 	addi	r4,r4,4
81126ee4:	394ab03a 	or	r5,r7,r5
81126ee8:	197fff15 	stw	r5,-4(r3)
81126eec:	217fff17 	ldw	r5,-4(r4)
81126ef0:	2a4ad83a 	srl	r5,r5,r9
81126ef4:	223ff636 	bltu	r4,r8,81126ed0 <__reset+0xfb106ed0>
81126ef8:	51400115 	stw	r5,4(r10)
81126efc:	28001a1e 	bne	r5,zero,81126f68 <__lshift+0x148>
81126f00:	843fffc4 	addi	r16,r16,-1
81126f04:	14000415 	stw	r16,16(r2)
81126f08:	88000826 	beq	r17,zero,81126f2c <__lshift+0x10c>
81126f0c:	89000117 	ldw	r4,4(r17)
81126f10:	90c01317 	ldw	r3,76(r18)
81126f14:	2109883a 	add	r4,r4,r4
81126f18:	2109883a 	add	r4,r4,r4
81126f1c:	1907883a 	add	r3,r3,r4
81126f20:	19000017 	ldw	r4,0(r3)
81126f24:	89000015 	stw	r4,0(r17)
81126f28:	1c400015 	stw	r17,0(r3)
81126f2c:	dfc00617 	ldw	ra,24(sp)
81126f30:	dd400517 	ldw	r21,20(sp)
81126f34:	dd000417 	ldw	r20,16(sp)
81126f38:	dcc00317 	ldw	r19,12(sp)
81126f3c:	dc800217 	ldw	r18,8(sp)
81126f40:	dc400117 	ldw	r17,4(sp)
81126f44:	dc000017 	ldw	r16,0(sp)
81126f48:	dec00704 	addi	sp,sp,28
81126f4c:	f800283a 	ret
81126f50:	21400017 	ldw	r5,0(r4)
81126f54:	18c00104 	addi	r3,r3,4
81126f58:	21000104 	addi	r4,r4,4
81126f5c:	197fff15 	stw	r5,-4(r3)
81126f60:	223ffb36 	bltu	r4,r8,81126f50 <__reset+0xfb106f50>
81126f64:	003fe606 	br	81126f00 <__reset+0xfb106f00>
81126f68:	9c000084 	addi	r16,r19,2
81126f6c:	003fe406 	br	81126f00 <__reset+0xfb106f00>

81126f70 <__mcmp>:
81126f70:	20800417 	ldw	r2,16(r4)
81126f74:	28c00417 	ldw	r3,16(r5)
81126f78:	10c5c83a 	sub	r2,r2,r3
81126f7c:	1000111e 	bne	r2,zero,81126fc4 <__mcmp+0x54>
81126f80:	18c7883a 	add	r3,r3,r3
81126f84:	18c7883a 	add	r3,r3,r3
81126f88:	21000504 	addi	r4,r4,20
81126f8c:	29400504 	addi	r5,r5,20
81126f90:	20c5883a 	add	r2,r4,r3
81126f94:	28cb883a 	add	r5,r5,r3
81126f98:	00000106 	br	81126fa0 <__mcmp+0x30>
81126f9c:	20800a2e 	bgeu	r4,r2,81126fc8 <__mcmp+0x58>
81126fa0:	10bfff04 	addi	r2,r2,-4
81126fa4:	297fff04 	addi	r5,r5,-4
81126fa8:	11800017 	ldw	r6,0(r2)
81126fac:	28c00017 	ldw	r3,0(r5)
81126fb0:	30fffa26 	beq	r6,r3,81126f9c <__reset+0xfb106f9c>
81126fb4:	30c00236 	bltu	r6,r3,81126fc0 <__mcmp+0x50>
81126fb8:	00800044 	movi	r2,1
81126fbc:	f800283a 	ret
81126fc0:	00bfffc4 	movi	r2,-1
81126fc4:	f800283a 	ret
81126fc8:	0005883a 	mov	r2,zero
81126fcc:	f800283a 	ret

81126fd0 <__mdiff>:
81126fd0:	defffa04 	addi	sp,sp,-24
81126fd4:	de00012e 	bgeu	sp,et,81126fdc <__mdiff+0xc>
81126fd8:	003b68fa 	trap	3
81126fdc:	28c00417 	ldw	r3,16(r5)
81126fe0:	30800417 	ldw	r2,16(r6)
81126fe4:	dcc00315 	stw	r19,12(sp)
81126fe8:	dc800215 	stw	r18,8(sp)
81126fec:	dfc00515 	stw	ra,20(sp)
81126ff0:	dd000415 	stw	r20,16(sp)
81126ff4:	dc400115 	stw	r17,4(sp)
81126ff8:	dc000015 	stw	r16,0(sp)
81126ffc:	1887c83a 	sub	r3,r3,r2
81127000:	2825883a 	mov	r18,r5
81127004:	3027883a 	mov	r19,r6
81127008:	1800141e 	bne	r3,zero,8112705c <__mdiff+0x8c>
8112700c:	1085883a 	add	r2,r2,r2
81127010:	1085883a 	add	r2,r2,r2
81127014:	2a000504 	addi	r8,r5,20
81127018:	34000504 	addi	r16,r6,20
8112701c:	4087883a 	add	r3,r8,r2
81127020:	8085883a 	add	r2,r16,r2
81127024:	00000106 	br	8112702c <__mdiff+0x5c>
81127028:	40c0592e 	bgeu	r8,r3,81127190 <__mdiff+0x1c0>
8112702c:	18ffff04 	addi	r3,r3,-4
81127030:	10bfff04 	addi	r2,r2,-4
81127034:	19c00017 	ldw	r7,0(r3)
81127038:	11400017 	ldw	r5,0(r2)
8112703c:	397ffa26 	beq	r7,r5,81127028 <__reset+0xfb107028>
81127040:	3940592e 	bgeu	r7,r5,811271a8 <__mdiff+0x1d8>
81127044:	9005883a 	mov	r2,r18
81127048:	4023883a 	mov	r17,r8
8112704c:	9825883a 	mov	r18,r19
81127050:	05000044 	movi	r20,1
81127054:	1027883a 	mov	r19,r2
81127058:	00000406 	br	8112706c <__mdiff+0x9c>
8112705c:	18005616 	blt	r3,zero,811271b8 <__mdiff+0x1e8>
81127060:	34400504 	addi	r17,r6,20
81127064:	2c000504 	addi	r16,r5,20
81127068:	0029883a 	mov	r20,zero
8112706c:	91400117 	ldw	r5,4(r18)
81127070:	11266700 	call	81126670 <_Balloc>
81127074:	92400417 	ldw	r9,16(r18)
81127078:	9b000417 	ldw	r12,16(r19)
8112707c:	12c00504 	addi	r11,r2,20
81127080:	4a51883a 	add	r8,r9,r9
81127084:	6319883a 	add	r12,r12,r12
81127088:	4211883a 	add	r8,r8,r8
8112708c:	6319883a 	add	r12,r12,r12
81127090:	15000315 	stw	r20,12(r2)
81127094:	8211883a 	add	r8,r16,r8
81127098:	8b19883a 	add	r12,r17,r12
8112709c:	0007883a 	mov	r3,zero
811270a0:	81400017 	ldw	r5,0(r16)
811270a4:	89c00017 	ldw	r7,0(r17)
811270a8:	59800104 	addi	r6,r11,4
811270ac:	293fffcc 	andi	r4,r5,65535
811270b0:	20c7883a 	add	r3,r4,r3
811270b4:	393fffcc 	andi	r4,r7,65535
811270b8:	1909c83a 	sub	r4,r3,r4
811270bc:	280ad43a 	srli	r5,r5,16
811270c0:	380ed43a 	srli	r7,r7,16
811270c4:	2007d43a 	srai	r3,r4,16
811270c8:	213fffcc 	andi	r4,r4,65535
811270cc:	29cbc83a 	sub	r5,r5,r7
811270d0:	28c7883a 	add	r3,r5,r3
811270d4:	180a943a 	slli	r5,r3,16
811270d8:	8c400104 	addi	r17,r17,4
811270dc:	84000104 	addi	r16,r16,4
811270e0:	2908b03a 	or	r4,r5,r4
811270e4:	59000015 	stw	r4,0(r11)
811270e8:	1807d43a 	srai	r3,r3,16
811270ec:	3015883a 	mov	r10,r6
811270f0:	3017883a 	mov	r11,r6
811270f4:	8b3fea36 	bltu	r17,r12,811270a0 <__reset+0xfb1070a0>
811270f8:	8200162e 	bgeu	r16,r8,81127154 <__mdiff+0x184>
811270fc:	8017883a 	mov	r11,r16
81127100:	59400017 	ldw	r5,0(r11)
81127104:	31800104 	addi	r6,r6,4
81127108:	5ac00104 	addi	r11,r11,4
8112710c:	293fffcc 	andi	r4,r5,65535
81127110:	20c7883a 	add	r3,r4,r3
81127114:	280ed43a 	srli	r7,r5,16
81127118:	180bd43a 	srai	r5,r3,16
8112711c:	193fffcc 	andi	r4,r3,65535
81127120:	3947883a 	add	r3,r7,r5
81127124:	180a943a 	slli	r5,r3,16
81127128:	1807d43a 	srai	r3,r3,16
8112712c:	2908b03a 	or	r4,r5,r4
81127130:	313fff15 	stw	r4,-4(r6)
81127134:	5a3ff236 	bltu	r11,r8,81127100 <__reset+0xfb107100>
81127138:	0406303a 	nor	r3,zero,r16
8112713c:	1a07883a 	add	r3,r3,r8
81127140:	1806d0ba 	srli	r3,r3,2
81127144:	18c00044 	addi	r3,r3,1
81127148:	18c7883a 	add	r3,r3,r3
8112714c:	18c7883a 	add	r3,r3,r3
81127150:	50d5883a 	add	r10,r10,r3
81127154:	50ffff04 	addi	r3,r10,-4
81127158:	2000041e 	bne	r4,zero,8112716c <__mdiff+0x19c>
8112715c:	18ffff04 	addi	r3,r3,-4
81127160:	19000017 	ldw	r4,0(r3)
81127164:	4a7fffc4 	addi	r9,r9,-1
81127168:	203ffc26 	beq	r4,zero,8112715c <__reset+0xfb10715c>
8112716c:	12400415 	stw	r9,16(r2)
81127170:	dfc00517 	ldw	ra,20(sp)
81127174:	dd000417 	ldw	r20,16(sp)
81127178:	dcc00317 	ldw	r19,12(sp)
8112717c:	dc800217 	ldw	r18,8(sp)
81127180:	dc400117 	ldw	r17,4(sp)
81127184:	dc000017 	ldw	r16,0(sp)
81127188:	dec00604 	addi	sp,sp,24
8112718c:	f800283a 	ret
81127190:	000b883a 	mov	r5,zero
81127194:	11266700 	call	81126670 <_Balloc>
81127198:	00c00044 	movi	r3,1
8112719c:	10c00415 	stw	r3,16(r2)
811271a0:	10000515 	stw	zero,20(r2)
811271a4:	003ff206 	br	81127170 <__reset+0xfb107170>
811271a8:	8023883a 	mov	r17,r16
811271ac:	0029883a 	mov	r20,zero
811271b0:	4021883a 	mov	r16,r8
811271b4:	003fad06 	br	8112706c <__reset+0xfb10706c>
811271b8:	9005883a 	mov	r2,r18
811271bc:	94400504 	addi	r17,r18,20
811271c0:	9c000504 	addi	r16,r19,20
811271c4:	9825883a 	mov	r18,r19
811271c8:	05000044 	movi	r20,1
811271cc:	1027883a 	mov	r19,r2
811271d0:	003fa606 	br	8112706c <__reset+0xfb10706c>

811271d4 <__ulp>:
811271d4:	295ffc2c 	andhi	r5,r5,32752
811271d8:	00bf3034 	movhi	r2,64704
811271dc:	2887883a 	add	r3,r5,r2
811271e0:	00c0020e 	bge	zero,r3,811271ec <__ulp+0x18>
811271e4:	0005883a 	mov	r2,zero
811271e8:	f800283a 	ret
811271ec:	00c7c83a 	sub	r3,zero,r3
811271f0:	1807d53a 	srai	r3,r3,20
811271f4:	008004c4 	movi	r2,19
811271f8:	10c00b0e 	bge	r2,r3,81127228 <__ulp+0x54>
811271fc:	18bffb04 	addi	r2,r3,-20
81127200:	01000784 	movi	r4,30
81127204:	0007883a 	mov	r3,zero
81127208:	20800516 	blt	r4,r2,81127220 <__ulp+0x4c>
8112720c:	010007c4 	movi	r4,31
81127210:	2089c83a 	sub	r4,r4,r2
81127214:	00800044 	movi	r2,1
81127218:	1104983a 	sll	r2,r2,r4
8112721c:	f800283a 	ret
81127220:	00800044 	movi	r2,1
81127224:	f800283a 	ret
81127228:	01400234 	movhi	r5,8
8112722c:	28c7d83a 	sra	r3,r5,r3
81127230:	0005883a 	mov	r2,zero
81127234:	f800283a 	ret

81127238 <__b2d>:
81127238:	defffa04 	addi	sp,sp,-24
8112723c:	de00012e 	bgeu	sp,et,81127244 <__b2d+0xc>
81127240:	003b68fa 	trap	3
81127244:	dc000015 	stw	r16,0(sp)
81127248:	24000417 	ldw	r16,16(r4)
8112724c:	dc400115 	stw	r17,4(sp)
81127250:	24400504 	addi	r17,r4,20
81127254:	8421883a 	add	r16,r16,r16
81127258:	8421883a 	add	r16,r16,r16
8112725c:	8c21883a 	add	r16,r17,r16
81127260:	dc800215 	stw	r18,8(sp)
81127264:	84bfff17 	ldw	r18,-4(r16)
81127268:	dd000415 	stw	r20,16(sp)
8112726c:	dcc00315 	stw	r19,12(sp)
81127270:	9009883a 	mov	r4,r18
81127274:	2829883a 	mov	r20,r5
81127278:	dfc00515 	stw	ra,20(sp)
8112727c:	112697c0 	call	8112697c <__hi0bits>
81127280:	00c00804 	movi	r3,32
81127284:	1889c83a 	sub	r4,r3,r2
81127288:	a1000015 	stw	r4,0(r20)
8112728c:	01000284 	movi	r4,10
81127290:	84ffff04 	addi	r19,r16,-4
81127294:	20801216 	blt	r4,r2,811272e0 <__b2d+0xa8>
81127298:	018002c4 	movi	r6,11
8112729c:	308dc83a 	sub	r6,r6,r2
811272a0:	9186d83a 	srl	r3,r18,r6
811272a4:	18cffc34 	orhi	r3,r3,16368
811272a8:	8cc0212e 	bgeu	r17,r19,81127330 <__b2d+0xf8>
811272ac:	813ffe17 	ldw	r4,-8(r16)
811272b0:	218cd83a 	srl	r6,r4,r6
811272b4:	10800544 	addi	r2,r2,21
811272b8:	9084983a 	sll	r2,r18,r2
811272bc:	1184b03a 	or	r2,r2,r6
811272c0:	dfc00517 	ldw	ra,20(sp)
811272c4:	dd000417 	ldw	r20,16(sp)
811272c8:	dcc00317 	ldw	r19,12(sp)
811272cc:	dc800217 	ldw	r18,8(sp)
811272d0:	dc400117 	ldw	r17,4(sp)
811272d4:	dc000017 	ldw	r16,0(sp)
811272d8:	dec00604 	addi	sp,sp,24
811272dc:	f800283a 	ret
811272e0:	8cc00f2e 	bgeu	r17,r19,81127320 <__b2d+0xe8>
811272e4:	117ffd44 	addi	r5,r2,-11
811272e8:	80bffe17 	ldw	r2,-8(r16)
811272ec:	28000e26 	beq	r5,zero,81127328 <__b2d+0xf0>
811272f0:	1949c83a 	sub	r4,r3,r5
811272f4:	9164983a 	sll	r18,r18,r5
811272f8:	1106d83a 	srl	r3,r2,r4
811272fc:	81bffe04 	addi	r6,r16,-8
81127300:	948ffc34 	orhi	r18,r18,16368
81127304:	90c6b03a 	or	r3,r18,r3
81127308:	89800e2e 	bgeu	r17,r6,81127344 <__b2d+0x10c>
8112730c:	81bffd17 	ldw	r6,-12(r16)
81127310:	1144983a 	sll	r2,r2,r5
81127314:	310ad83a 	srl	r5,r6,r4
81127318:	2884b03a 	or	r2,r5,r2
8112731c:	003fe806 	br	811272c0 <__reset+0xfb1072c0>
81127320:	10bffd44 	addi	r2,r2,-11
81127324:	1000041e 	bne	r2,zero,81127338 <__b2d+0x100>
81127328:	90cffc34 	orhi	r3,r18,16368
8112732c:	003fe406 	br	811272c0 <__reset+0xfb1072c0>
81127330:	000d883a 	mov	r6,zero
81127334:	003fdf06 	br	811272b4 <__reset+0xfb1072b4>
81127338:	90a4983a 	sll	r18,r18,r2
8112733c:	0005883a 	mov	r2,zero
81127340:	003ff906 	br	81127328 <__reset+0xfb107328>
81127344:	1144983a 	sll	r2,r2,r5
81127348:	003fdd06 	br	811272c0 <__reset+0xfb1072c0>

8112734c <__d2b>:
8112734c:	defff804 	addi	sp,sp,-32
81127350:	de00012e 	bgeu	sp,et,81127358 <__d2b+0xc>
81127354:	003b68fa 	trap	3
81127358:	dc000215 	stw	r16,8(sp)
8112735c:	3021883a 	mov	r16,r6
81127360:	dc400315 	stw	r17,12(sp)
81127364:	8022907a 	slli	r17,r16,1
81127368:	dd000615 	stw	r20,24(sp)
8112736c:	2829883a 	mov	r20,r5
81127370:	01400044 	movi	r5,1
81127374:	dcc00515 	stw	r19,20(sp)
81127378:	dc800415 	stw	r18,16(sp)
8112737c:	dfc00715 	stw	ra,28(sp)
81127380:	3825883a 	mov	r18,r7
81127384:	8822d57a 	srli	r17,r17,21
81127388:	11266700 	call	81126670 <_Balloc>
8112738c:	1027883a 	mov	r19,r2
81127390:	00800434 	movhi	r2,16
81127394:	10bfffc4 	addi	r2,r2,-1
81127398:	808c703a 	and	r6,r16,r2
8112739c:	88000126 	beq	r17,zero,811273a4 <__d2b+0x58>
811273a0:	31800434 	orhi	r6,r6,16
811273a4:	d9800015 	stw	r6,0(sp)
811273a8:	a0002426 	beq	r20,zero,8112743c <__d2b+0xf0>
811273ac:	d9000104 	addi	r4,sp,4
811273b0:	dd000115 	stw	r20,4(sp)
811273b4:	11269e40 	call	811269e4 <__lo0bits>
811273b8:	d8c00017 	ldw	r3,0(sp)
811273bc:	10002f1e 	bne	r2,zero,8112747c <__d2b+0x130>
811273c0:	d9000117 	ldw	r4,4(sp)
811273c4:	99000515 	stw	r4,20(r19)
811273c8:	1821003a 	cmpeq	r16,r3,zero
811273cc:	01000084 	movi	r4,2
811273d0:	2421c83a 	sub	r16,r4,r16
811273d4:	98c00615 	stw	r3,24(r19)
811273d8:	9c000415 	stw	r16,16(r19)
811273dc:	88001f1e 	bne	r17,zero,8112745c <__d2b+0x110>
811273e0:	10bef384 	addi	r2,r2,-1074
811273e4:	90800015 	stw	r2,0(r18)
811273e8:	00900034 	movhi	r2,16384
811273ec:	10bfffc4 	addi	r2,r2,-1
811273f0:	8085883a 	add	r2,r16,r2
811273f4:	1085883a 	add	r2,r2,r2
811273f8:	1085883a 	add	r2,r2,r2
811273fc:	9885883a 	add	r2,r19,r2
81127400:	11000517 	ldw	r4,20(r2)
81127404:	8020917a 	slli	r16,r16,5
81127408:	112697c0 	call	8112697c <__hi0bits>
8112740c:	d8c00817 	ldw	r3,32(sp)
81127410:	8085c83a 	sub	r2,r16,r2
81127414:	18800015 	stw	r2,0(r3)
81127418:	9805883a 	mov	r2,r19
8112741c:	dfc00717 	ldw	ra,28(sp)
81127420:	dd000617 	ldw	r20,24(sp)
81127424:	dcc00517 	ldw	r19,20(sp)
81127428:	dc800417 	ldw	r18,16(sp)
8112742c:	dc400317 	ldw	r17,12(sp)
81127430:	dc000217 	ldw	r16,8(sp)
81127434:	dec00804 	addi	sp,sp,32
81127438:	f800283a 	ret
8112743c:	d809883a 	mov	r4,sp
81127440:	11269e40 	call	811269e4 <__lo0bits>
81127444:	d8c00017 	ldw	r3,0(sp)
81127448:	04000044 	movi	r16,1
8112744c:	9c000415 	stw	r16,16(r19)
81127450:	98c00515 	stw	r3,20(r19)
81127454:	10800804 	addi	r2,r2,32
81127458:	883fe126 	beq	r17,zero,811273e0 <__reset+0xfb1073e0>
8112745c:	00c00d44 	movi	r3,53
81127460:	8c7ef344 	addi	r17,r17,-1075
81127464:	88a3883a 	add	r17,r17,r2
81127468:	1885c83a 	sub	r2,r3,r2
8112746c:	d8c00817 	ldw	r3,32(sp)
81127470:	94400015 	stw	r17,0(r18)
81127474:	18800015 	stw	r2,0(r3)
81127478:	003fe706 	br	81127418 <__reset+0xfb107418>
8112747c:	01000804 	movi	r4,32
81127480:	2089c83a 	sub	r4,r4,r2
81127484:	1908983a 	sll	r4,r3,r4
81127488:	d9400117 	ldw	r5,4(sp)
8112748c:	1886d83a 	srl	r3,r3,r2
81127490:	2148b03a 	or	r4,r4,r5
81127494:	99000515 	stw	r4,20(r19)
81127498:	d8c00015 	stw	r3,0(sp)
8112749c:	003fca06 	br	811273c8 <__reset+0xfb1073c8>

811274a0 <__ratio>:
811274a0:	defff904 	addi	sp,sp,-28
811274a4:	de00012e 	bgeu	sp,et,811274ac <__ratio+0xc>
811274a8:	003b68fa 	trap	3
811274ac:	dc400315 	stw	r17,12(sp)
811274b0:	2823883a 	mov	r17,r5
811274b4:	d9400104 	addi	r5,sp,4
811274b8:	dfc00615 	stw	ra,24(sp)
811274bc:	dcc00515 	stw	r19,20(sp)
811274c0:	dc800415 	stw	r18,16(sp)
811274c4:	2027883a 	mov	r19,r4
811274c8:	dc000215 	stw	r16,8(sp)
811274cc:	11272380 	call	81127238 <__b2d>
811274d0:	d80b883a 	mov	r5,sp
811274d4:	8809883a 	mov	r4,r17
811274d8:	1025883a 	mov	r18,r2
811274dc:	1821883a 	mov	r16,r3
811274e0:	11272380 	call	81127238 <__b2d>
811274e4:	8a000417 	ldw	r8,16(r17)
811274e8:	99000417 	ldw	r4,16(r19)
811274ec:	d9400117 	ldw	r5,4(sp)
811274f0:	2209c83a 	sub	r4,r4,r8
811274f4:	2010917a 	slli	r8,r4,5
811274f8:	d9000017 	ldw	r4,0(sp)
811274fc:	2909c83a 	sub	r4,r5,r4
81127500:	4109883a 	add	r4,r8,r4
81127504:	01000e0e 	bge	zero,r4,81127540 <__ratio+0xa0>
81127508:	2008953a 	slli	r4,r4,20
8112750c:	2421883a 	add	r16,r4,r16
81127510:	100d883a 	mov	r6,r2
81127514:	180f883a 	mov	r7,r3
81127518:	9009883a 	mov	r4,r18
8112751c:	800b883a 	mov	r5,r16
81127520:	112f5940 	call	8112f594 <__divdf3>
81127524:	dfc00617 	ldw	ra,24(sp)
81127528:	dcc00517 	ldw	r19,20(sp)
8112752c:	dc800417 	ldw	r18,16(sp)
81127530:	dc400317 	ldw	r17,12(sp)
81127534:	dc000217 	ldw	r16,8(sp)
81127538:	dec00704 	addi	sp,sp,28
8112753c:	f800283a 	ret
81127540:	2008953a 	slli	r4,r4,20
81127544:	1907c83a 	sub	r3,r3,r4
81127548:	003ff106 	br	81127510 <__reset+0xfb107510>

8112754c <_mprec_log10>:
8112754c:	defffe04 	addi	sp,sp,-8
81127550:	de00012e 	bgeu	sp,et,81127558 <_mprec_log10+0xc>
81127554:	003b68fa 	trap	3
81127558:	008005c4 	movi	r2,23
8112755c:	dc000015 	stw	r16,0(sp)
81127560:	dfc00115 	stw	ra,4(sp)
81127564:	2021883a 	mov	r16,r4
81127568:	11000d0e 	bge	r2,r4,811275a0 <_mprec_log10+0x54>
8112756c:	0005883a 	mov	r2,zero
81127570:	00cffc34 	movhi	r3,16368
81127574:	843fffc4 	addi	r16,r16,-1
81127578:	000d883a 	mov	r6,zero
8112757c:	01d00934 	movhi	r7,16420
81127580:	1009883a 	mov	r4,r2
81127584:	180b883a 	mov	r5,r3
81127588:	111a7f00 	call	8111a7f0 <__muldf3>
8112758c:	803ff91e 	bne	r16,zero,81127574 <__reset+0xfb107574>
81127590:	dfc00117 	ldw	ra,4(sp)
81127594:	dc000017 	ldw	r16,0(sp)
81127598:	dec00204 	addi	sp,sp,8
8112759c:	f800283a 	ret
811275a0:	202090fa 	slli	r16,r4,3
811275a4:	00a04574 	movhi	r2,33045
811275a8:	10a9bf04 	addi	r2,r2,-22788
811275ac:	1421883a 	add	r16,r2,r16
811275b0:	80800017 	ldw	r2,0(r16)
811275b4:	80c00117 	ldw	r3,4(r16)
811275b8:	dfc00117 	ldw	ra,4(sp)
811275bc:	dc000017 	ldw	r16,0(sp)
811275c0:	dec00204 	addi	sp,sp,8
811275c4:	f800283a 	ret

811275c8 <__copybits>:
811275c8:	297fffc4 	addi	r5,r5,-1
811275cc:	280fd17a 	srai	r7,r5,5
811275d0:	30c00417 	ldw	r3,16(r6)
811275d4:	30800504 	addi	r2,r6,20
811275d8:	39c00044 	addi	r7,r7,1
811275dc:	18c7883a 	add	r3,r3,r3
811275e0:	39cf883a 	add	r7,r7,r7
811275e4:	18c7883a 	add	r3,r3,r3
811275e8:	39cf883a 	add	r7,r7,r7
811275ec:	10c7883a 	add	r3,r2,r3
811275f0:	21cf883a 	add	r7,r4,r7
811275f4:	10c00d2e 	bgeu	r2,r3,8112762c <__copybits+0x64>
811275f8:	200b883a 	mov	r5,r4
811275fc:	12000017 	ldw	r8,0(r2)
81127600:	29400104 	addi	r5,r5,4
81127604:	10800104 	addi	r2,r2,4
81127608:	2a3fff15 	stw	r8,-4(r5)
8112760c:	10fffb36 	bltu	r2,r3,811275fc <__reset+0xfb1075fc>
81127610:	1985c83a 	sub	r2,r3,r6
81127614:	10bffac4 	addi	r2,r2,-21
81127618:	1004d0ba 	srli	r2,r2,2
8112761c:	10800044 	addi	r2,r2,1
81127620:	1085883a 	add	r2,r2,r2
81127624:	1085883a 	add	r2,r2,r2
81127628:	2089883a 	add	r4,r4,r2
8112762c:	21c0032e 	bgeu	r4,r7,8112763c <__copybits+0x74>
81127630:	20000015 	stw	zero,0(r4)
81127634:	21000104 	addi	r4,r4,4
81127638:	21fffd36 	bltu	r4,r7,81127630 <__reset+0xfb107630>
8112763c:	f800283a 	ret

81127640 <__any_on>:
81127640:	20c00417 	ldw	r3,16(r4)
81127644:	2805d17a 	srai	r2,r5,5
81127648:	21000504 	addi	r4,r4,20
8112764c:	18800d0e 	bge	r3,r2,81127684 <__any_on+0x44>
81127650:	18c7883a 	add	r3,r3,r3
81127654:	18c7883a 	add	r3,r3,r3
81127658:	20c7883a 	add	r3,r4,r3
8112765c:	20c0192e 	bgeu	r4,r3,811276c4 <__any_on+0x84>
81127660:	18bfff17 	ldw	r2,-4(r3)
81127664:	18ffff04 	addi	r3,r3,-4
81127668:	1000041e 	bne	r2,zero,8112767c <__any_on+0x3c>
8112766c:	20c0142e 	bgeu	r4,r3,811276c0 <__any_on+0x80>
81127670:	18ffff04 	addi	r3,r3,-4
81127674:	19400017 	ldw	r5,0(r3)
81127678:	283ffc26 	beq	r5,zero,8112766c <__reset+0xfb10766c>
8112767c:	00800044 	movi	r2,1
81127680:	f800283a 	ret
81127684:	10c00a0e 	bge	r2,r3,811276b0 <__any_on+0x70>
81127688:	1085883a 	add	r2,r2,r2
8112768c:	1085883a 	add	r2,r2,r2
81127690:	294007cc 	andi	r5,r5,31
81127694:	2087883a 	add	r3,r4,r2
81127698:	283ff026 	beq	r5,zero,8112765c <__reset+0xfb10765c>
8112769c:	19800017 	ldw	r6,0(r3)
811276a0:	3144d83a 	srl	r2,r6,r5
811276a4:	114a983a 	sll	r5,r2,r5
811276a8:	317ff41e 	bne	r6,r5,8112767c <__reset+0xfb10767c>
811276ac:	003feb06 	br	8112765c <__reset+0xfb10765c>
811276b0:	1085883a 	add	r2,r2,r2
811276b4:	1085883a 	add	r2,r2,r2
811276b8:	2087883a 	add	r3,r4,r2
811276bc:	003fe706 	br	8112765c <__reset+0xfb10765c>
811276c0:	f800283a 	ret
811276c4:	0005883a 	mov	r2,zero
811276c8:	f800283a 	ret

811276cc <_read_r>:
811276cc:	defffd04 	addi	sp,sp,-12
811276d0:	de00012e 	bgeu	sp,et,811276d8 <_read_r+0xc>
811276d4:	003b68fa 	trap	3
811276d8:	2805883a 	mov	r2,r5
811276dc:	dc000015 	stw	r16,0(sp)
811276e0:	04204574 	movhi	r16,33045
811276e4:	dc400115 	stw	r17,4(sp)
811276e8:	300b883a 	mov	r5,r6
811276ec:	8433bb04 	addi	r16,r16,-12564
811276f0:	2023883a 	mov	r17,r4
811276f4:	380d883a 	mov	r6,r7
811276f8:	1009883a 	mov	r4,r2
811276fc:	dfc00215 	stw	ra,8(sp)
81127700:	80000015 	stw	zero,0(r16)
81127704:	11322480 	call	81132248 <read>
81127708:	00ffffc4 	movi	r3,-1
8112770c:	10c00526 	beq	r2,r3,81127724 <_read_r+0x58>
81127710:	dfc00217 	ldw	ra,8(sp)
81127714:	dc400117 	ldw	r17,4(sp)
81127718:	dc000017 	ldw	r16,0(sp)
8112771c:	dec00304 	addi	sp,sp,12
81127720:	f800283a 	ret
81127724:	80c00017 	ldw	r3,0(r16)
81127728:	183ff926 	beq	r3,zero,81127710 <__reset+0xfb107710>
8112772c:	88c00015 	stw	r3,0(r17)
81127730:	003ff706 	br	81127710 <__reset+0xfb107710>

81127734 <_realloc_r>:
81127734:	defff604 	addi	sp,sp,-40
81127738:	de00012e 	bgeu	sp,et,81127740 <_realloc_r+0xc>
8112773c:	003b68fa 	trap	3
81127740:	dc800215 	stw	r18,8(sp)
81127744:	dfc00915 	stw	ra,36(sp)
81127748:	df000815 	stw	fp,32(sp)
8112774c:	ddc00715 	stw	r23,28(sp)
81127750:	dd800615 	stw	r22,24(sp)
81127754:	dd400515 	stw	r21,20(sp)
81127758:	dd000415 	stw	r20,16(sp)
8112775c:	dcc00315 	stw	r19,12(sp)
81127760:	dc400115 	stw	r17,4(sp)
81127764:	dc000015 	stw	r16,0(sp)
81127768:	3025883a 	mov	r18,r6
8112776c:	2800b726 	beq	r5,zero,81127a4c <_realloc_r+0x318>
81127770:	282b883a 	mov	r21,r5
81127774:	2029883a 	mov	r20,r4
81127778:	1132a280 	call	81132a28 <__malloc_lock>
8112777c:	a8bfff17 	ldw	r2,-4(r21)
81127780:	043fff04 	movi	r16,-4
81127784:	90c002c4 	addi	r3,r18,11
81127788:	01000584 	movi	r4,22
8112778c:	acfffe04 	addi	r19,r21,-8
81127790:	1420703a 	and	r16,r2,r16
81127794:	20c0332e 	bgeu	r4,r3,81127864 <_realloc_r+0x130>
81127798:	047ffe04 	movi	r17,-8
8112779c:	1c62703a 	and	r17,r3,r17
811277a0:	8807883a 	mov	r3,r17
811277a4:	88005816 	blt	r17,zero,81127908 <_realloc_r+0x1d4>
811277a8:	8c805736 	bltu	r17,r18,81127908 <_realloc_r+0x1d4>
811277ac:	80c0300e 	bge	r16,r3,81127870 <_realloc_r+0x13c>
811277b0:	07204574 	movhi	fp,33045
811277b4:	e72d0c04 	addi	fp,fp,-19408
811277b8:	e1c00217 	ldw	r7,8(fp)
811277bc:	9c09883a 	add	r4,r19,r16
811277c0:	22000117 	ldw	r8,4(r4)
811277c4:	21c06326 	beq	r4,r7,81127954 <_realloc_r+0x220>
811277c8:	017fff84 	movi	r5,-2
811277cc:	414a703a 	and	r5,r8,r5
811277d0:	214b883a 	add	r5,r4,r5
811277d4:	29800117 	ldw	r6,4(r5)
811277d8:	3180004c 	andi	r6,r6,1
811277dc:	30003f26 	beq	r6,zero,811278dc <_realloc_r+0x1a8>
811277e0:	1080004c 	andi	r2,r2,1
811277e4:	10008326 	beq	r2,zero,811279f4 <_realloc_r+0x2c0>
811277e8:	900b883a 	mov	r5,r18
811277ec:	a009883a 	mov	r4,r20
811277f0:	111bc2c0 	call	8111bc2c <_malloc_r>
811277f4:	1025883a 	mov	r18,r2
811277f8:	10011e26 	beq	r2,zero,81127c74 <_realloc_r+0x540>
811277fc:	a93fff17 	ldw	r4,-4(r21)
81127800:	10fffe04 	addi	r3,r2,-8
81127804:	00bfff84 	movi	r2,-2
81127808:	2084703a 	and	r2,r4,r2
8112780c:	9885883a 	add	r2,r19,r2
81127810:	1880ee26 	beq	r3,r2,81127bcc <_realloc_r+0x498>
81127814:	81bfff04 	addi	r6,r16,-4
81127818:	00800904 	movi	r2,36
8112781c:	1180b836 	bltu	r2,r6,81127b00 <_realloc_r+0x3cc>
81127820:	00c004c4 	movi	r3,19
81127824:	19809636 	bltu	r3,r6,81127a80 <_realloc_r+0x34c>
81127828:	9005883a 	mov	r2,r18
8112782c:	a807883a 	mov	r3,r21
81127830:	19000017 	ldw	r4,0(r3)
81127834:	11000015 	stw	r4,0(r2)
81127838:	19000117 	ldw	r4,4(r3)
8112783c:	11000115 	stw	r4,4(r2)
81127840:	18c00217 	ldw	r3,8(r3)
81127844:	10c00215 	stw	r3,8(r2)
81127848:	a80b883a 	mov	r5,r21
8112784c:	a009883a 	mov	r4,r20
81127850:	11256a00 	call	811256a0 <_free_r>
81127854:	a009883a 	mov	r4,r20
81127858:	1132b500 	call	81132b50 <__malloc_unlock>
8112785c:	9005883a 	mov	r2,r18
81127860:	00001206 	br	811278ac <_realloc_r+0x178>
81127864:	00c00404 	movi	r3,16
81127868:	1823883a 	mov	r17,r3
8112786c:	003fce06 	br	811277a8 <__reset+0xfb1077a8>
81127870:	a825883a 	mov	r18,r21
81127874:	8445c83a 	sub	r2,r16,r17
81127878:	00c003c4 	movi	r3,15
8112787c:	18802636 	bltu	r3,r2,81127918 <_realloc_r+0x1e4>
81127880:	99800117 	ldw	r6,4(r19)
81127884:	9c07883a 	add	r3,r19,r16
81127888:	3180004c 	andi	r6,r6,1
8112788c:	3420b03a 	or	r16,r6,r16
81127890:	9c000115 	stw	r16,4(r19)
81127894:	18800117 	ldw	r2,4(r3)
81127898:	10800054 	ori	r2,r2,1
8112789c:	18800115 	stw	r2,4(r3)
811278a0:	a009883a 	mov	r4,r20
811278a4:	1132b500 	call	81132b50 <__malloc_unlock>
811278a8:	9005883a 	mov	r2,r18
811278ac:	dfc00917 	ldw	ra,36(sp)
811278b0:	df000817 	ldw	fp,32(sp)
811278b4:	ddc00717 	ldw	r23,28(sp)
811278b8:	dd800617 	ldw	r22,24(sp)
811278bc:	dd400517 	ldw	r21,20(sp)
811278c0:	dd000417 	ldw	r20,16(sp)
811278c4:	dcc00317 	ldw	r19,12(sp)
811278c8:	dc800217 	ldw	r18,8(sp)
811278cc:	dc400117 	ldw	r17,4(sp)
811278d0:	dc000017 	ldw	r16,0(sp)
811278d4:	dec00a04 	addi	sp,sp,40
811278d8:	f800283a 	ret
811278dc:	017fff04 	movi	r5,-4
811278e0:	414a703a 	and	r5,r8,r5
811278e4:	814d883a 	add	r6,r16,r5
811278e8:	30c01f16 	blt	r6,r3,81127968 <_realloc_r+0x234>
811278ec:	20800317 	ldw	r2,12(r4)
811278f0:	20c00217 	ldw	r3,8(r4)
811278f4:	a825883a 	mov	r18,r21
811278f8:	3021883a 	mov	r16,r6
811278fc:	18800315 	stw	r2,12(r3)
81127900:	10c00215 	stw	r3,8(r2)
81127904:	003fdb06 	br	81127874 <__reset+0xfb107874>
81127908:	00800304 	movi	r2,12
8112790c:	a0800015 	stw	r2,0(r20)
81127910:	0005883a 	mov	r2,zero
81127914:	003fe506 	br	811278ac <__reset+0xfb1078ac>
81127918:	98c00117 	ldw	r3,4(r19)
8112791c:	9c4b883a 	add	r5,r19,r17
81127920:	11000054 	ori	r4,r2,1
81127924:	18c0004c 	andi	r3,r3,1
81127928:	1c62b03a 	or	r17,r3,r17
8112792c:	9c400115 	stw	r17,4(r19)
81127930:	29000115 	stw	r4,4(r5)
81127934:	2885883a 	add	r2,r5,r2
81127938:	10c00117 	ldw	r3,4(r2)
8112793c:	29400204 	addi	r5,r5,8
81127940:	a009883a 	mov	r4,r20
81127944:	18c00054 	ori	r3,r3,1
81127948:	10c00115 	stw	r3,4(r2)
8112794c:	11256a00 	call	811256a0 <_free_r>
81127950:	003fd306 	br	811278a0 <__reset+0xfb1078a0>
81127954:	017fff04 	movi	r5,-4
81127958:	414a703a 	and	r5,r8,r5
8112795c:	89800404 	addi	r6,r17,16
81127960:	8151883a 	add	r8,r16,r5
81127964:	4180590e 	bge	r8,r6,81127acc <_realloc_r+0x398>
81127968:	1080004c 	andi	r2,r2,1
8112796c:	103f9e1e 	bne	r2,zero,811277e8 <__reset+0xfb1077e8>
81127970:	adbffe17 	ldw	r22,-8(r21)
81127974:	00bfff04 	movi	r2,-4
81127978:	9dadc83a 	sub	r22,r19,r22
8112797c:	b1800117 	ldw	r6,4(r22)
81127980:	3084703a 	and	r2,r6,r2
81127984:	20002026 	beq	r4,zero,81127a08 <_realloc_r+0x2d4>
81127988:	80af883a 	add	r23,r16,r2
8112798c:	b96f883a 	add	r23,r23,r5
81127990:	21c05f26 	beq	r4,r7,81127b10 <_realloc_r+0x3dc>
81127994:	b8c01c16 	blt	r23,r3,81127a08 <_realloc_r+0x2d4>
81127998:	20800317 	ldw	r2,12(r4)
8112799c:	20c00217 	ldw	r3,8(r4)
811279a0:	81bfff04 	addi	r6,r16,-4
811279a4:	01000904 	movi	r4,36
811279a8:	18800315 	stw	r2,12(r3)
811279ac:	10c00215 	stw	r3,8(r2)
811279b0:	b0c00217 	ldw	r3,8(r22)
811279b4:	b0800317 	ldw	r2,12(r22)
811279b8:	b4800204 	addi	r18,r22,8
811279bc:	18800315 	stw	r2,12(r3)
811279c0:	10c00215 	stw	r3,8(r2)
811279c4:	21801b36 	bltu	r4,r6,81127a34 <_realloc_r+0x300>
811279c8:	008004c4 	movi	r2,19
811279cc:	1180352e 	bgeu	r2,r6,81127aa4 <_realloc_r+0x370>
811279d0:	a8800017 	ldw	r2,0(r21)
811279d4:	b0800215 	stw	r2,8(r22)
811279d8:	a8800117 	ldw	r2,4(r21)
811279dc:	b0800315 	stw	r2,12(r22)
811279e0:	008006c4 	movi	r2,27
811279e4:	11807f36 	bltu	r2,r6,81127be4 <_realloc_r+0x4b0>
811279e8:	b0800404 	addi	r2,r22,16
811279ec:	ad400204 	addi	r21,r21,8
811279f0:	00002d06 	br	81127aa8 <_realloc_r+0x374>
811279f4:	adbffe17 	ldw	r22,-8(r21)
811279f8:	00bfff04 	movi	r2,-4
811279fc:	9dadc83a 	sub	r22,r19,r22
81127a00:	b1000117 	ldw	r4,4(r22)
81127a04:	2084703a 	and	r2,r4,r2
81127a08:	b03f7726 	beq	r22,zero,811277e8 <__reset+0xfb1077e8>
81127a0c:	80af883a 	add	r23,r16,r2
81127a10:	b8ff7516 	blt	r23,r3,811277e8 <__reset+0xfb1077e8>
81127a14:	b0800317 	ldw	r2,12(r22)
81127a18:	b0c00217 	ldw	r3,8(r22)
81127a1c:	81bfff04 	addi	r6,r16,-4
81127a20:	01000904 	movi	r4,36
81127a24:	18800315 	stw	r2,12(r3)
81127a28:	10c00215 	stw	r3,8(r2)
81127a2c:	b4800204 	addi	r18,r22,8
81127a30:	21bfe52e 	bgeu	r4,r6,811279c8 <__reset+0xfb1079c8>
81127a34:	a80b883a 	mov	r5,r21
81127a38:	9009883a 	mov	r4,r18
81127a3c:	11265140 	call	81126514 <memmove>
81127a40:	b821883a 	mov	r16,r23
81127a44:	b027883a 	mov	r19,r22
81127a48:	003f8a06 	br	81127874 <__reset+0xfb107874>
81127a4c:	300b883a 	mov	r5,r6
81127a50:	dfc00917 	ldw	ra,36(sp)
81127a54:	df000817 	ldw	fp,32(sp)
81127a58:	ddc00717 	ldw	r23,28(sp)
81127a5c:	dd800617 	ldw	r22,24(sp)
81127a60:	dd400517 	ldw	r21,20(sp)
81127a64:	dd000417 	ldw	r20,16(sp)
81127a68:	dcc00317 	ldw	r19,12(sp)
81127a6c:	dc800217 	ldw	r18,8(sp)
81127a70:	dc400117 	ldw	r17,4(sp)
81127a74:	dc000017 	ldw	r16,0(sp)
81127a78:	dec00a04 	addi	sp,sp,40
81127a7c:	111bc2c1 	jmpi	8111bc2c <_malloc_r>
81127a80:	a8c00017 	ldw	r3,0(r21)
81127a84:	90c00015 	stw	r3,0(r18)
81127a88:	a8c00117 	ldw	r3,4(r21)
81127a8c:	90c00115 	stw	r3,4(r18)
81127a90:	00c006c4 	movi	r3,27
81127a94:	19804536 	bltu	r3,r6,81127bac <_realloc_r+0x478>
81127a98:	90800204 	addi	r2,r18,8
81127a9c:	a8c00204 	addi	r3,r21,8
81127aa0:	003f6306 	br	81127830 <__reset+0xfb107830>
81127aa4:	9005883a 	mov	r2,r18
81127aa8:	a8c00017 	ldw	r3,0(r21)
81127aac:	b821883a 	mov	r16,r23
81127ab0:	b027883a 	mov	r19,r22
81127ab4:	10c00015 	stw	r3,0(r2)
81127ab8:	a8c00117 	ldw	r3,4(r21)
81127abc:	10c00115 	stw	r3,4(r2)
81127ac0:	a8c00217 	ldw	r3,8(r21)
81127ac4:	10c00215 	stw	r3,8(r2)
81127ac8:	003f6a06 	br	81127874 <__reset+0xfb107874>
81127acc:	9c67883a 	add	r19,r19,r17
81127ad0:	4445c83a 	sub	r2,r8,r17
81127ad4:	e4c00215 	stw	r19,8(fp)
81127ad8:	10800054 	ori	r2,r2,1
81127adc:	98800115 	stw	r2,4(r19)
81127ae0:	a8bfff17 	ldw	r2,-4(r21)
81127ae4:	a009883a 	mov	r4,r20
81127ae8:	1080004c 	andi	r2,r2,1
81127aec:	1462b03a 	or	r17,r2,r17
81127af0:	ac7fff15 	stw	r17,-4(r21)
81127af4:	1132b500 	call	81132b50 <__malloc_unlock>
81127af8:	a805883a 	mov	r2,r21
81127afc:	003f6b06 	br	811278ac <__reset+0xfb1078ac>
81127b00:	a80b883a 	mov	r5,r21
81127b04:	9009883a 	mov	r4,r18
81127b08:	11265140 	call	81126514 <memmove>
81127b0c:	003f4e06 	br	81127848 <__reset+0xfb107848>
81127b10:	89000404 	addi	r4,r17,16
81127b14:	b93fbc16 	blt	r23,r4,81127a08 <__reset+0xfb107a08>
81127b18:	b0800317 	ldw	r2,12(r22)
81127b1c:	b0c00217 	ldw	r3,8(r22)
81127b20:	81bfff04 	addi	r6,r16,-4
81127b24:	01000904 	movi	r4,36
81127b28:	18800315 	stw	r2,12(r3)
81127b2c:	10c00215 	stw	r3,8(r2)
81127b30:	b4800204 	addi	r18,r22,8
81127b34:	21804336 	bltu	r4,r6,81127c44 <_realloc_r+0x510>
81127b38:	008004c4 	movi	r2,19
81127b3c:	11803f2e 	bgeu	r2,r6,81127c3c <_realloc_r+0x508>
81127b40:	a8800017 	ldw	r2,0(r21)
81127b44:	b0800215 	stw	r2,8(r22)
81127b48:	a8800117 	ldw	r2,4(r21)
81127b4c:	b0800315 	stw	r2,12(r22)
81127b50:	008006c4 	movi	r2,27
81127b54:	11803f36 	bltu	r2,r6,81127c54 <_realloc_r+0x520>
81127b58:	b0800404 	addi	r2,r22,16
81127b5c:	ad400204 	addi	r21,r21,8
81127b60:	a8c00017 	ldw	r3,0(r21)
81127b64:	10c00015 	stw	r3,0(r2)
81127b68:	a8c00117 	ldw	r3,4(r21)
81127b6c:	10c00115 	stw	r3,4(r2)
81127b70:	a8c00217 	ldw	r3,8(r21)
81127b74:	10c00215 	stw	r3,8(r2)
81127b78:	b447883a 	add	r3,r22,r17
81127b7c:	bc45c83a 	sub	r2,r23,r17
81127b80:	e0c00215 	stw	r3,8(fp)
81127b84:	10800054 	ori	r2,r2,1
81127b88:	18800115 	stw	r2,4(r3)
81127b8c:	b0800117 	ldw	r2,4(r22)
81127b90:	a009883a 	mov	r4,r20
81127b94:	1080004c 	andi	r2,r2,1
81127b98:	1462b03a 	or	r17,r2,r17
81127b9c:	b4400115 	stw	r17,4(r22)
81127ba0:	1132b500 	call	81132b50 <__malloc_unlock>
81127ba4:	9005883a 	mov	r2,r18
81127ba8:	003f4006 	br	811278ac <__reset+0xfb1078ac>
81127bac:	a8c00217 	ldw	r3,8(r21)
81127bb0:	90c00215 	stw	r3,8(r18)
81127bb4:	a8c00317 	ldw	r3,12(r21)
81127bb8:	90c00315 	stw	r3,12(r18)
81127bbc:	30801126 	beq	r6,r2,81127c04 <_realloc_r+0x4d0>
81127bc0:	90800404 	addi	r2,r18,16
81127bc4:	a8c00404 	addi	r3,r21,16
81127bc8:	003f1906 	br	81127830 <__reset+0xfb107830>
81127bcc:	90ffff17 	ldw	r3,-4(r18)
81127bd0:	00bfff04 	movi	r2,-4
81127bd4:	a825883a 	mov	r18,r21
81127bd8:	1884703a 	and	r2,r3,r2
81127bdc:	80a1883a 	add	r16,r16,r2
81127be0:	003f2406 	br	81127874 <__reset+0xfb107874>
81127be4:	a8800217 	ldw	r2,8(r21)
81127be8:	b0800415 	stw	r2,16(r22)
81127bec:	a8800317 	ldw	r2,12(r21)
81127bf0:	b0800515 	stw	r2,20(r22)
81127bf4:	31000a26 	beq	r6,r4,81127c20 <_realloc_r+0x4ec>
81127bf8:	b0800604 	addi	r2,r22,24
81127bfc:	ad400404 	addi	r21,r21,16
81127c00:	003fa906 	br	81127aa8 <__reset+0xfb107aa8>
81127c04:	a9000417 	ldw	r4,16(r21)
81127c08:	90800604 	addi	r2,r18,24
81127c0c:	a8c00604 	addi	r3,r21,24
81127c10:	91000415 	stw	r4,16(r18)
81127c14:	a9000517 	ldw	r4,20(r21)
81127c18:	91000515 	stw	r4,20(r18)
81127c1c:	003f0406 	br	81127830 <__reset+0xfb107830>
81127c20:	a8c00417 	ldw	r3,16(r21)
81127c24:	ad400604 	addi	r21,r21,24
81127c28:	b0800804 	addi	r2,r22,32
81127c2c:	b0c00615 	stw	r3,24(r22)
81127c30:	a8ffff17 	ldw	r3,-4(r21)
81127c34:	b0c00715 	stw	r3,28(r22)
81127c38:	003f9b06 	br	81127aa8 <__reset+0xfb107aa8>
81127c3c:	9005883a 	mov	r2,r18
81127c40:	003fc706 	br	81127b60 <__reset+0xfb107b60>
81127c44:	a80b883a 	mov	r5,r21
81127c48:	9009883a 	mov	r4,r18
81127c4c:	11265140 	call	81126514 <memmove>
81127c50:	003fc906 	br	81127b78 <__reset+0xfb107b78>
81127c54:	a8800217 	ldw	r2,8(r21)
81127c58:	b0800415 	stw	r2,16(r22)
81127c5c:	a8800317 	ldw	r2,12(r21)
81127c60:	b0800515 	stw	r2,20(r22)
81127c64:	31000726 	beq	r6,r4,81127c84 <_realloc_r+0x550>
81127c68:	b0800604 	addi	r2,r22,24
81127c6c:	ad400404 	addi	r21,r21,16
81127c70:	003fbb06 	br	81127b60 <__reset+0xfb107b60>
81127c74:	a009883a 	mov	r4,r20
81127c78:	1132b500 	call	81132b50 <__malloc_unlock>
81127c7c:	0005883a 	mov	r2,zero
81127c80:	003f0a06 	br	811278ac <__reset+0xfb1078ac>
81127c84:	a8c00417 	ldw	r3,16(r21)
81127c88:	ad400604 	addi	r21,r21,24
81127c8c:	b0800804 	addi	r2,r22,32
81127c90:	b0c00615 	stw	r3,24(r22)
81127c94:	a8ffff17 	ldw	r3,-4(r21)
81127c98:	b0c00715 	stw	r3,28(r22)
81127c9c:	003fb006 	br	81127b60 <__reset+0xfb107b60>

81127ca0 <__fpclassifyd>:
81127ca0:	00a00034 	movhi	r2,32768
81127ca4:	10bfffc4 	addi	r2,r2,-1
81127ca8:	2884703a 	and	r2,r5,r2
81127cac:	10000726 	beq	r2,zero,81127ccc <__fpclassifyd+0x2c>
81127cb0:	00fffc34 	movhi	r3,65520
81127cb4:	019ff834 	movhi	r6,32736
81127cb8:	28c7883a 	add	r3,r5,r3
81127cbc:	31bfffc4 	addi	r6,r6,-1
81127cc0:	30c00536 	bltu	r6,r3,81127cd8 <__fpclassifyd+0x38>
81127cc4:	00800104 	movi	r2,4
81127cc8:	f800283a 	ret
81127ccc:	2000021e 	bne	r4,zero,81127cd8 <__fpclassifyd+0x38>
81127cd0:	00800084 	movi	r2,2
81127cd4:	f800283a 	ret
81127cd8:	00dffc34 	movhi	r3,32752
81127cdc:	019ff834 	movhi	r6,32736
81127ce0:	28cb883a 	add	r5,r5,r3
81127ce4:	31bfffc4 	addi	r6,r6,-1
81127ce8:	317ff62e 	bgeu	r6,r5,81127cc4 <__reset+0xfb107cc4>
81127cec:	01400434 	movhi	r5,16
81127cf0:	297fffc4 	addi	r5,r5,-1
81127cf4:	28800236 	bltu	r5,r2,81127d00 <__fpclassifyd+0x60>
81127cf8:	008000c4 	movi	r2,3
81127cfc:	f800283a 	ret
81127d00:	10c00226 	beq	r2,r3,81127d0c <__fpclassifyd+0x6c>
81127d04:	0005883a 	mov	r2,zero
81127d08:	f800283a 	ret
81127d0c:	2005003a 	cmpeq	r2,r4,zero
81127d10:	f800283a 	ret

81127d14 <__sccl>:
81127d14:	2a000003 	ldbu	r8,0(r5)
81127d18:	00801784 	movi	r2,94
81127d1c:	40802a26 	beq	r8,r2,81127dc8 <__sccl+0xb4>
81127d20:	29400044 	addi	r5,r5,1
81127d24:	000f883a 	mov	r7,zero
81127d28:	0013883a 	mov	r9,zero
81127d2c:	2007883a 	mov	r3,r4
81127d30:	21804004 	addi	r6,r4,256
81127d34:	19c00005 	stb	r7,0(r3)
81127d38:	18c00044 	addi	r3,r3,1
81127d3c:	19bffd1e 	bne	r3,r6,81127d34 <__reset+0xfb107d34>
81127d40:	40001126 	beq	r8,zero,81127d88 <__sccl+0x74>
81127d44:	00800044 	movi	r2,1
81127d48:	124fc83a 	sub	r7,r2,r9
81127d4c:	02800b44 	movi	r10,45
81127d50:	02c01744 	movi	r11,93
81127d54:	2205883a 	add	r2,r4,r8
81127d58:	11c00005 	stb	r7,0(r2)
81127d5c:	28800044 	addi	r2,r5,1
81127d60:	28c00003 	ldbu	r3,0(r5)
81127d64:	1a800a26 	beq	r3,r10,81127d90 <__sccl+0x7c>
81127d68:	1ac00426 	beq	r3,r11,81127d7c <__sccl+0x68>
81127d6c:	18000426 	beq	r3,zero,81127d80 <__sccl+0x6c>
81127d70:	1811883a 	mov	r8,r3
81127d74:	100b883a 	mov	r5,r2
81127d78:	003ff606 	br	81127d54 <__reset+0xfb107d54>
81127d7c:	f800283a 	ret
81127d80:	2805883a 	mov	r2,r5
81127d84:	f800283a 	ret
81127d88:	28bfffc4 	addi	r2,r5,-1
81127d8c:	f800283a 	ret
81127d90:	12400003 	ldbu	r9,0(r2)
81127d94:	4ac01126 	beq	r9,r11,81127ddc <__sccl+0xc8>
81127d98:	4a001016 	blt	r9,r8,81127ddc <__sccl+0xc8>
81127d9c:	41800044 	addi	r6,r8,1
81127da0:	29400084 	addi	r5,r5,2
81127da4:	2187883a 	add	r3,r4,r6
81127da8:	00000106 	br	81127db0 <__sccl+0x9c>
81127dac:	31800044 	addi	r6,r6,1
81127db0:	19c00005 	stb	r7,0(r3)
81127db4:	3011883a 	mov	r8,r6
81127db8:	18c00044 	addi	r3,r3,1
81127dbc:	327ffb16 	blt	r6,r9,81127dac <__reset+0xfb107dac>
81127dc0:	10800084 	addi	r2,r2,2
81127dc4:	003fe606 	br	81127d60 <__reset+0xfb107d60>
81127dc8:	2a000043 	ldbu	r8,1(r5)
81127dcc:	01c00044 	movi	r7,1
81127dd0:	29400084 	addi	r5,r5,2
81127dd4:	02400044 	movi	r9,1
81127dd8:	003fd406 	br	81127d2c <__reset+0xfb107d2c>
81127ddc:	5011883a 	mov	r8,r10
81127de0:	003fe406 	br	81127d74 <__reset+0xfb107d74>

81127de4 <nanf>:
81127de4:	009ff034 	movhi	r2,32704
81127de8:	f800283a 	ret

81127dec <strcmp>:
81127dec:	2144b03a 	or	r2,r4,r5
81127df0:	108000cc 	andi	r2,r2,3
81127df4:	1000171e 	bne	r2,zero,81127e54 <strcmp+0x68>
81127df8:	20800017 	ldw	r2,0(r4)
81127dfc:	28c00017 	ldw	r3,0(r5)
81127e00:	10c0141e 	bne	r2,r3,81127e54 <strcmp+0x68>
81127e04:	027fbff4 	movhi	r9,65279
81127e08:	4a7fbfc4 	addi	r9,r9,-257
81127e0c:	0086303a 	nor	r3,zero,r2
81127e10:	02202074 	movhi	r8,32897
81127e14:	1245883a 	add	r2,r2,r9
81127e18:	42202004 	addi	r8,r8,-32640
81127e1c:	10c4703a 	and	r2,r2,r3
81127e20:	1204703a 	and	r2,r2,r8
81127e24:	10000226 	beq	r2,zero,81127e30 <strcmp+0x44>
81127e28:	00002306 	br	81127eb8 <strcmp+0xcc>
81127e2c:	1000221e 	bne	r2,zero,81127eb8 <strcmp+0xcc>
81127e30:	21000104 	addi	r4,r4,4
81127e34:	20c00017 	ldw	r3,0(r4)
81127e38:	29400104 	addi	r5,r5,4
81127e3c:	29800017 	ldw	r6,0(r5)
81127e40:	1a4f883a 	add	r7,r3,r9
81127e44:	00c4303a 	nor	r2,zero,r3
81127e48:	3884703a 	and	r2,r7,r2
81127e4c:	1204703a 	and	r2,r2,r8
81127e50:	19bff626 	beq	r3,r6,81127e2c <__reset+0xfb107e2c>
81127e54:	20800003 	ldbu	r2,0(r4)
81127e58:	10c03fcc 	andi	r3,r2,255
81127e5c:	18c0201c 	xori	r3,r3,128
81127e60:	18ffe004 	addi	r3,r3,-128
81127e64:	18000c26 	beq	r3,zero,81127e98 <strcmp+0xac>
81127e68:	29800007 	ldb	r6,0(r5)
81127e6c:	19800326 	beq	r3,r6,81127e7c <strcmp+0x90>
81127e70:	00001306 	br	81127ec0 <strcmp+0xd4>
81127e74:	29800007 	ldb	r6,0(r5)
81127e78:	11800b1e 	bne	r2,r6,81127ea8 <strcmp+0xbc>
81127e7c:	21000044 	addi	r4,r4,1
81127e80:	20c00003 	ldbu	r3,0(r4)
81127e84:	29400044 	addi	r5,r5,1
81127e88:	18803fcc 	andi	r2,r3,255
81127e8c:	1080201c 	xori	r2,r2,128
81127e90:	10bfe004 	addi	r2,r2,-128
81127e94:	103ff71e 	bne	r2,zero,81127e74 <__reset+0xfb107e74>
81127e98:	0007883a 	mov	r3,zero
81127e9c:	28800003 	ldbu	r2,0(r5)
81127ea0:	1885c83a 	sub	r2,r3,r2
81127ea4:	f800283a 	ret
81127ea8:	28800003 	ldbu	r2,0(r5)
81127eac:	18c03fcc 	andi	r3,r3,255
81127eb0:	1885c83a 	sub	r2,r3,r2
81127eb4:	f800283a 	ret
81127eb8:	0005883a 	mov	r2,zero
81127ebc:	f800283a 	ret
81127ec0:	10c03fcc 	andi	r3,r2,255
81127ec4:	003ff506 	br	81127e9c <__reset+0xfb107e9c>

81127ec8 <sulp>:
81127ec8:	defffd04 	addi	sp,sp,-12
81127ecc:	de00012e 	bgeu	sp,et,81127ed4 <sulp+0xc>
81127ed0:	003b68fa 	trap	3
81127ed4:	dc400115 	stw	r17,4(sp)
81127ed8:	3023883a 	mov	r17,r6
81127edc:	dc000015 	stw	r16,0(sp)
81127ee0:	dfc00215 	stw	ra,8(sp)
81127ee4:	2821883a 	mov	r16,r5
81127ee8:	11271d40 	call	811271d4 <__ulp>
81127eec:	88000c26 	beq	r17,zero,81127f20 <sulp+0x58>
81127ef0:	841ffc2c 	andhi	r16,r16,32752
81127ef4:	8020d53a 	srli	r16,r16,20
81127ef8:	01c01ac4 	movi	r7,107
81127efc:	3c21c83a 	sub	r16,r7,r16
81127f00:	0400070e 	bge	zero,r16,81127f20 <sulp+0x58>
81127f04:	8020953a 	slli	r16,r16,20
81127f08:	01cffc34 	movhi	r7,16368
81127f0c:	000d883a 	mov	r6,zero
81127f10:	81cf883a 	add	r7,r16,r7
81127f14:	1009883a 	mov	r4,r2
81127f18:	180b883a 	mov	r5,r3
81127f1c:	111a7f00 	call	8111a7f0 <__muldf3>
81127f20:	dfc00217 	ldw	ra,8(sp)
81127f24:	dc400117 	ldw	r17,4(sp)
81127f28:	dc000017 	ldw	r16,0(sp)
81127f2c:	dec00304 	addi	sp,sp,12
81127f30:	f800283a 	ret

81127f34 <_strtod_r>:
81127f34:	deffe204 	addi	sp,sp,-120
81127f38:	de00012e 	bgeu	sp,et,81127f40 <_strtod_r+0xc>
81127f3c:	003b68fa 	trap	3
81127f40:	ddc01b15 	stw	r23,108(sp)
81127f44:	dd001815 	stw	r20,96(sp)
81127f48:	dc801615 	stw	r18,88(sp)
81127f4c:	dc401515 	stw	r17,84(sp)
81127f50:	dc001415 	stw	r16,80(sp)
81127f54:	d9400615 	stw	r5,24(sp)
81127f58:	dfc01d15 	stw	ra,116(sp)
81127f5c:	df001c15 	stw	fp,112(sp)
81127f60:	dd801a15 	stw	r22,104(sp)
81127f64:	dd401915 	stw	r21,100(sp)
81127f68:	dcc01715 	stw	r19,92(sp)
81127f6c:	2021883a 	mov	r16,r4
81127f70:	d8000515 	stw	zero,20(sp)
81127f74:	2809883a 	mov	r4,r5
81127f78:	20800003 	ldbu	r2,0(r4)
81127f7c:	01e044b4 	movhi	r7,33042
81127f80:	282f883a 	mov	r23,r5
81127f84:	10c03fcc 	andi	r3,r2,255
81127f88:	01400b44 	movi	r5,45
81127f8c:	39dfec04 	addi	r7,r7,32688
81127f90:	3029883a 	mov	r20,r6
81127f94:	0025883a 	mov	r18,zero
81127f98:	0023883a 	mov	r17,zero
81127f9c:	28c0ba36 	bltu	r5,r3,81128288 <_strtod_r+0x354>
81127fa0:	180690ba 	slli	r3,r3,2
81127fa4:	19c7883a 	add	r3,r3,r7
81127fa8:	18c00017 	ldw	r3,0(r3)
81127fac:	1800683a 	jmp	r3
81127fb0:	81128070 	cmpltui	r4,r16,18945
81127fb4:	81128288 	cmpgei	r4,r16,18954
81127fb8:	81128288 	cmpgei	r4,r16,18954
81127fbc:	81128288 	cmpgei	r4,r16,18954
81127fc0:	81128288 	cmpgei	r4,r16,18954
81127fc4:	81128288 	cmpgei	r4,r16,18954
81127fc8:	81128288 	cmpgei	r4,r16,18954
81127fcc:	81128288 	cmpgei	r4,r16,18954
81127fd0:	81128288 	cmpgei	r4,r16,18954
81127fd4:	81128274 	orhi	r4,r16,18953
81127fd8:	81128274 	orhi	r4,r16,18953
81127fdc:	81128274 	orhi	r4,r16,18953
81127fe0:	81128274 	orhi	r4,r16,18953
81127fe4:	81128274 	orhi	r4,r16,18953
81127fe8:	81128288 	cmpgei	r4,r16,18954
81127fec:	81128288 	cmpgei	r4,r16,18954
81127ff0:	81128288 	cmpgei	r4,r16,18954
81127ff4:	81128288 	cmpgei	r4,r16,18954
81127ff8:	81128288 	cmpgei	r4,r16,18954
81127ffc:	81128288 	cmpgei	r4,r16,18954
81128000:	81128288 	cmpgei	r4,r16,18954
81128004:	81128288 	cmpgei	r4,r16,18954
81128008:	81128288 	cmpgei	r4,r16,18954
8112800c:	81128288 	cmpgei	r4,r16,18954
81128010:	81128288 	cmpgei	r4,r16,18954
81128014:	81128288 	cmpgei	r4,r16,18954
81128018:	81128288 	cmpgei	r4,r16,18954
8112801c:	81128288 	cmpgei	r4,r16,18954
81128020:	81128288 	cmpgei	r4,r16,18954
81128024:	81128288 	cmpgei	r4,r16,18954
81128028:	81128288 	cmpgei	r4,r16,18954
8112802c:	81128288 	cmpgei	r4,r16,18954
81128030:	81128274 	orhi	r4,r16,18953
81128034:	81128288 	cmpgei	r4,r16,18954
81128038:	81128288 	cmpgei	r4,r16,18954
8112803c:	81128288 	cmpgei	r4,r16,18954
81128040:	81128288 	cmpgei	r4,r16,18954
81128044:	81128288 	cmpgei	r4,r16,18954
81128048:	81128288 	cmpgei	r4,r16,18954
8112804c:	81128288 	cmpgei	r4,r16,18954
81128050:	81128288 	cmpgei	r4,r16,18954
81128054:	81128288 	cmpgei	r4,r16,18954
81128058:	81128288 	cmpgei	r4,r16,18954
8112805c:	811280c8 	cmpgei	r4,r16,18947
81128060:	81128288 	cmpgei	r4,r16,18954
81128064:	81128268 	cmpgeui	r4,r16,18953
81128068:	00801244 	movi	r2,73
8112806c:	88843526 	beq	r17,r2,81129144 <_strtod_r+0x1210>
81128070:	002b883a 	mov	r21,zero
81128074:	002d883a 	mov	r22,zero
81128078:	a0000526 	beq	r20,zero,81128090 <_strtod_r+0x15c>
8112807c:	d8000715 	stw	zero,28(sp)
81128080:	a5c00015 	stw	r23,0(r20)
81128084:	d9000717 	ldw	r4,28(sp)
81128088:	20000126 	beq	r4,zero,81128090 <_strtod_r+0x15c>
8112808c:	b5a0003c 	xorhi	r22,r22,32768
81128090:	a805883a 	mov	r2,r21
81128094:	b007883a 	mov	r3,r22
81128098:	dfc01d17 	ldw	ra,116(sp)
8112809c:	df001c17 	ldw	fp,112(sp)
811280a0:	ddc01b17 	ldw	r23,108(sp)
811280a4:	dd801a17 	ldw	r22,104(sp)
811280a8:	dd401917 	ldw	r21,100(sp)
811280ac:	dd001817 	ldw	r20,96(sp)
811280b0:	dcc01717 	ldw	r19,92(sp)
811280b4:	dc801617 	ldw	r18,88(sp)
811280b8:	dc401517 	ldw	r17,84(sp)
811280bc:	dc001417 	ldw	r16,80(sp)
811280c0:	dec01e04 	addi	sp,sp,120
811280c4:	f800283a 	ret
811280c8:	d8000715 	stw	zero,28(sp)
811280cc:	24c00044 	addi	r19,r4,1
811280d0:	dcc00615 	stw	r19,24(sp)
811280d4:	20800043 	ldbu	r2,1(r4)
811280d8:	10c03fcc 	andi	r3,r2,255
811280dc:	18c0201c 	xori	r3,r3,128
811280e0:	18ffe004 	addi	r3,r3,-128
811280e4:	183fe226 	beq	r3,zero,81128070 <__reset+0xfb108070>
811280e8:	11403fcc 	andi	r5,r2,255
811280ec:	2940201c 	xori	r5,r5,128
811280f0:	297fe004 	addi	r5,r5,-128
811280f4:	00c00c04 	movi	r3,48
811280f8:	28c0e526 	beq	r5,r3,81128490 <_strtod_r+0x55c>
811280fc:	dcc00815 	stw	r19,32(sp)
81128100:	0025883a 	mov	r18,zero
81128104:	10fff404 	addi	r3,r2,-48
81128108:	18c03fcc 	andi	r3,r3,255
8112810c:	01000244 	movi	r4,9
81128110:	20c37536 	bltu	r4,r3,81128ee8 <_strtod_r+0xfb4>
81128114:	dd400817 	ldw	r21,32(sp)
81128118:	0027883a 	mov	r19,zero
8112811c:	0039883a 	mov	fp,zero
81128120:	002d883a 	mov	r22,zero
81128124:	01400204 	movi	r5,8
81128128:	2d805a16 	blt	r5,r22,81128294 <_strtod_r+0x360>
8112812c:	e70002a4 	muli	fp,fp,10
81128130:	10c03fcc 	andi	r3,r2,255
81128134:	18c0201c 	xori	r3,r3,128
81128138:	18ffe004 	addi	r3,r3,-128
8112813c:	e0f9883a 	add	fp,fp,r3
81128140:	e73ff404 	addi	fp,fp,-48
81128144:	ad400044 	addi	r21,r21,1
81128148:	dd400615 	stw	r21,24(sp)
8112814c:	a8800003 	ldbu	r2,0(r21)
81128150:	b5800044 	addi	r22,r22,1
81128154:	10fff404 	addi	r3,r2,-48
81128158:	18c03fcc 	andi	r3,r3,255
8112815c:	20fff22e 	bgeu	r4,r3,81128128 <__reset+0xfb108128>
81128160:	14403fcc 	andi	r17,r2,255
81128164:	8c40201c 	xori	r17,r17,128
81128168:	8c7fe004 	addi	r17,r17,-128
8112816c:	8009883a 	mov	r4,r16
81128170:	11261540 	call	81126154 <_localeconv_r>
81128174:	11400017 	ldw	r5,0(r2)
81128178:	8009883a 	mov	r4,r16
8112817c:	d9401315 	stw	r5,76(sp)
81128180:	11261540 	call	81126154 <_localeconv_r>
81128184:	11000017 	ldw	r4,0(r2)
81128188:	111cf340 	call	8111cf34 <strlen>
8112818c:	d9401317 	ldw	r5,76(sp)
81128190:	100d883a 	mov	r6,r2
81128194:	a809883a 	mov	r4,r21
81128198:	112db240 	call	8112db24 <strncmp>
8112819c:	1000ce26 	beq	r2,zero,811284d8 <_strtod_r+0x5a4>
811281a0:	b013883a 	mov	r9,r22
811281a4:	000b883a 	mov	r5,zero
811281a8:	0015883a 	mov	r10,zero
811281ac:	0017883a 	mov	r11,zero
811281b0:	00801944 	movi	r2,101
811281b4:	88807826 	beq	r17,r2,81128398 <_strtod_r+0x464>
811281b8:	00801144 	movi	r2,69
811281bc:	88807626 	beq	r17,r2,81128398 <_strtod_r+0x464>
811281c0:	002b883a 	mov	r21,zero
811281c4:	48003d1e 	bne	r9,zero,811282bc <_strtod_r+0x388>
811281c8:	2800391e 	bne	r5,zero,811282b0 <_strtod_r+0x37c>
811281cc:	9000381e 	bne	r18,zero,811282b0 <_strtod_r+0x37c>
811281d0:	583fa71e 	bne	r11,zero,81128070 <__reset+0xfb108070>
811281d4:	00801384 	movi	r2,78
811281d8:	88800526 	beq	r17,r2,811281f0 <_strtod_r+0x2bc>
811281dc:	147fa20e 	bge	r2,r17,81128068 <__reset+0xfb108068>
811281e0:	00801a44 	movi	r2,105
811281e4:	8883d726 	beq	r17,r2,81129144 <_strtod_r+0x1210>
811281e8:	00801b84 	movi	r2,110
811281ec:	88bfa01e 	bne	r17,r2,81128070 <__reset+0xfb108070>
811281f0:	01604574 	movhi	r5,33045
811281f4:	d9000617 	ldw	r4,24(sp)
811281f8:	2969f404 	addi	r5,r5,-22576
811281fc:	01c00644 	movi	r7,25
81128200:	00000b06 	br	81128230 <_strtod_r+0x2fc>
81128204:	21000044 	addi	r4,r4,1
81128208:	20800003 	ldbu	r2,0(r4)
8112820c:	10ffefc4 	addi	r3,r2,-65
81128210:	10803fcc 	andi	r2,r2,255
81128214:	1080201c 	xori	r2,r2,128
81128218:	18c03fcc 	andi	r3,r3,255
8112821c:	10bfe004 	addi	r2,r2,-128
81128220:	38c00136 	bltu	r7,r3,81128228 <_strtod_r+0x2f4>
81128224:	10800804 	addi	r2,r2,32
81128228:	29400044 	addi	r5,r5,1
8112822c:	11bf901e 	bne	r2,r6,81128070 <__reset+0xfb108070>
81128230:	29800007 	ldb	r6,0(r5)
81128234:	303ff31e 	bne	r6,zero,81128204 <__reset+0xfb108204>
81128238:	20800044 	addi	r2,r4,1
8112823c:	d8800615 	stw	r2,24(sp)
81128240:	20c00047 	ldb	r3,1(r4)
81128244:	00800a04 	movi	r2,40
81128248:	18849d26 	beq	r3,r2,811294c0 <_strtod_r+0x158c>
8112824c:	047ffe34 	movhi	r17,65528
81128250:	0025883a 	mov	r18,zero
81128254:	902b883a 	mov	r21,r18
81128258:	882d883a 	mov	r22,r17
8112825c:	a03f8926 	beq	r20,zero,81128084 <__reset+0xfb108084>
81128260:	ddc00617 	ldw	r23,24(sp)
81128264:	003f8606 	br	81128080 <__reset+0xfb108080>
81128268:	00800044 	movi	r2,1
8112826c:	d8800715 	stw	r2,28(sp)
81128270:	003f9606 	br	811280cc <__reset+0xfb1080cc>
81128274:	21000044 	addi	r4,r4,1
81128278:	d9000615 	stw	r4,24(sp)
8112827c:	20800003 	ldbu	r2,0(r4)
81128280:	10c03fcc 	andi	r3,r2,255
81128284:	28ff462e 	bgeu	r5,r3,81127fa0 <__reset+0xfb107fa0>
81128288:	2027883a 	mov	r19,r4
8112828c:	d8000715 	stw	zero,28(sp)
81128290:	003f9506 	br	811280e8 <__reset+0xfb1080e8>
81128294:	9cc002a4 	muli	r19,r19,10
81128298:	10803fcc 	andi	r2,r2,255
8112829c:	1080201c 	xori	r2,r2,128
811282a0:	10bfe004 	addi	r2,r2,-128
811282a4:	9885883a 	add	r2,r19,r2
811282a8:	14fff404 	addi	r19,r2,-48
811282ac:	003fa506 	br	81128144 <__reset+0xfb108144>
811282b0:	002b883a 	mov	r21,zero
811282b4:	002d883a 	mov	r22,zero
811282b8:	003fe806 	br	8112825c <__reset+0xfb10825c>
811282bc:	aaabc83a 	sub	r21,r21,r10
811282c0:	b000011e 	bne	r22,zero,811282c8 <_strtod_r+0x394>
811282c4:	482d883a 	mov	r22,r9
811282c8:	00800404 	movi	r2,16
811282cc:	482f883a 	mov	r23,r9
811282d0:	1240010e 	bge	r2,r9,811282d8 <_strtod_r+0x3a4>
811282d4:	102f883a 	mov	r23,r2
811282d8:	e009883a 	mov	r4,fp
811282dc:	da401315 	stw	r9,76(sp)
811282e0:	1130b440 	call	81130b44 <__floatunsidf>
811282e4:	1025883a 	mov	r18,r2
811282e8:	00800244 	movi	r2,9
811282ec:	1823883a 	mov	r17,r3
811282f0:	da401317 	ldw	r9,76(sp)
811282f4:	15c0160e 	bge	r2,r23,81128350 <_strtod_r+0x41c>
811282f8:	b8bffdc4 	addi	r2,r23,-9
811282fc:	100490fa 	slli	r2,r2,3
81128300:	180b883a 	mov	r5,r3
81128304:	00e04574 	movhi	r3,33045
81128308:	18e9bf04 	addi	r3,r3,-22788
8112830c:	1885883a 	add	r2,r3,r2
81128310:	11800017 	ldw	r6,0(r2)
81128314:	11c00117 	ldw	r7,4(r2)
81128318:	9009883a 	mov	r4,r18
8112831c:	111a7f00 	call	8111a7f0 <__muldf3>
81128320:	9809883a 	mov	r4,r19
81128324:	1025883a 	mov	r18,r2
81128328:	1823883a 	mov	r17,r3
8112832c:	1130b440 	call	81130b44 <__floatunsidf>
81128330:	9009883a 	mov	r4,r18
81128334:	880b883a 	mov	r5,r17
81128338:	100d883a 	mov	r6,r2
8112833c:	180f883a 	mov	r7,r3
81128340:	112ece00 	call	8112ece0 <__adddf3>
81128344:	da401317 	ldw	r9,76(sp)
81128348:	1025883a 	mov	r18,r2
8112834c:	1823883a 	mov	r17,r3
81128350:	008003c4 	movi	r2,15
81128354:	12407b16 	blt	r2,r9,81128544 <_strtod_r+0x610>
81128358:	a83fbe26 	beq	r21,zero,81128254 <__reset+0xfb108254>
8112835c:	0543670e 	bge	zero,r21,811290fc <_strtod_r+0x11c8>
81128360:	00c00584 	movi	r3,22
81128364:	1d42e816 	blt	r3,r21,81128f08 <_strtod_r+0xfd4>
81128368:	a82a90fa 	slli	r21,r21,3
8112836c:	00a04574 	movhi	r2,33045
81128370:	10a9bf04 	addi	r2,r2,-22788
81128374:	1545883a 	add	r2,r2,r21
81128378:	11000017 	ldw	r4,0(r2)
8112837c:	11400117 	ldw	r5,4(r2)
81128380:	900d883a 	mov	r6,r18
81128384:	880f883a 	mov	r7,r17
81128388:	111a7f00 	call	8111a7f0 <__muldf3>
8112838c:	102b883a 	mov	r21,r2
81128390:	182d883a 	mov	r22,r3
81128394:	003fb106 	br	8112825c <__reset+0xfb10825c>
81128398:	4801b526 	beq	r9,zero,81128a70 <_strtod_r+0xb3c>
8112839c:	ddc00617 	ldw	r23,24(sp)
811283a0:	00c00ac4 	movi	r3,43
811283a4:	b8800044 	addi	r2,r23,1
811283a8:	d8800615 	stw	r2,24(sp)
811283ac:	b8800047 	ldb	r2,1(r23)
811283b0:	10c1e926 	beq	r2,r3,81128b58 <_strtod_r+0xc24>
811283b4:	00c00b44 	movi	r3,45
811283b8:	10c1ec26 	beq	r2,r3,81128b6c <_strtod_r+0xc38>
811283bc:	1023883a 	mov	r17,r2
811283c0:	0019883a 	mov	r12,zero
811283c4:	88bff404 	addi	r2,r17,-48
811283c8:	00c00244 	movi	r3,9
811283cc:	1881b736 	bltu	r3,r2,81128aac <_strtod_r+0xb78>
811283d0:	00800c04 	movi	r2,48
811283d4:	8880071e 	bne	r17,r2,811283f4 <_strtod_r+0x4c0>
811283d8:	d8800617 	ldw	r2,24(sp)
811283dc:	8807883a 	mov	r3,r17
811283e0:	10800044 	addi	r2,r2,1
811283e4:	d8800615 	stw	r2,24(sp)
811283e8:	14400007 	ldb	r17,0(r2)
811283ec:	10800044 	addi	r2,r2,1
811283f0:	88fffc26 	beq	r17,r3,811283e4 <__reset+0xfb1083e4>
811283f4:	88bff3c4 	addi	r2,r17,-49
811283f8:	00c00204 	movi	r3,8
811283fc:	18bf7036 	bltu	r3,r2,811281c0 <__reset+0xfb1081c0>
81128400:	db800617 	ldw	r14,24(sp)
81128404:	88bff404 	addi	r2,r17,-48
81128408:	03400244 	movi	r13,9
8112840c:	71c00044 	addi	r7,r14,1
81128410:	d9c00615 	stw	r7,24(sp)
81128414:	74400043 	ldbu	r17,1(r14)
81128418:	88fff404 	addi	r3,r17,-48
8112841c:	8c403fcc 	andi	r17,r17,255
81128420:	8c40201c 	xori	r17,r17,128
81128424:	18c03fcc 	andi	r3,r3,255
81128428:	8c7fe004 	addi	r17,r17,-128
8112842c:	68c00e36 	bltu	r13,r3,81128468 <_strtod_r+0x534>
81128430:	71000084 	addi	r4,r14,2
81128434:	d9000615 	stw	r4,24(sp)
81128438:	108002a4 	muli	r2,r2,10
8112843c:	21800003 	ldbu	r6,0(r4)
81128440:	200f883a 	mov	r7,r4
81128444:	1463883a 	add	r17,r2,r17
81128448:	30fff404 	addi	r3,r6,-48
8112844c:	88bff404 	addi	r2,r17,-48
81128450:	34403fcc 	andi	r17,r6,255
81128454:	8c40201c 	xori	r17,r17,128
81128458:	18c03fcc 	andi	r3,r3,255
8112845c:	8c7fe004 	addi	r17,r17,-128
81128460:	21000044 	addi	r4,r4,1
81128464:	68fff32e 	bgeu	r13,r3,81128434 <__reset+0xfb108434>
81128468:	3b8fc83a 	sub	r7,r7,r14
8112846c:	00c00204 	movi	r3,8
81128470:	19c29716 	blt	r3,r7,81128ed0 <_strtod_r+0xf9c>
81128474:	102b883a 	mov	r21,r2
81128478:	009387c4 	movi	r2,19999
8112847c:	1540010e 	bge	r2,r21,81128484 <_strtod_r+0x550>
81128480:	102b883a 	mov	r21,r2
81128484:	603f4f26 	beq	r12,zero,811281c4 <__reset+0xfb1081c4>
81128488:	056bc83a 	sub	r21,zero,r21
8112848c:	003f4d06 	br	811281c4 <__reset+0xfb1081c4>
81128490:	98800047 	ldb	r2,1(r19)
81128494:	00c01604 	movi	r3,88
81128498:	10c1de26 	beq	r2,r3,81128c14 <_strtod_r+0xce0>
8112849c:	00c01e04 	movi	r3,120
811284a0:	10c1dc26 	beq	r2,r3,81128c14 <_strtod_r+0xce0>
811284a4:	98c00044 	addi	r3,r19,1
811284a8:	1827883a 	mov	r19,r3
811284ac:	d8c00615 	stw	r3,24(sp)
811284b0:	18c00044 	addi	r3,r3,1
811284b4:	18bfffc3 	ldbu	r2,-1(r3)
811284b8:	11003fcc 	andi	r4,r2,255
811284bc:	2100201c 	xori	r4,r4,128
811284c0:	213fe004 	addi	r4,r4,-128
811284c4:	217ff826 	beq	r4,r5,811284a8 <__reset+0xfb1084a8>
811284c8:	203f7926 	beq	r4,zero,811282b0 <__reset+0xfb1082b0>
811284cc:	dcc00815 	stw	r19,32(sp)
811284d0:	04800044 	movi	r18,1
811284d4:	003f0b06 	br	81128104 <__reset+0xfb108104>
811284d8:	8009883a 	mov	r4,r16
811284dc:	11261540 	call	81126154 <_localeconv_r>
811284e0:	11000017 	ldw	r4,0(r2)
811284e4:	111cf340 	call	8111cf34 <strlen>
811284e8:	d8c00617 	ldw	r3,24(sp)
811284ec:	1885883a 	add	r2,r3,r2
811284f0:	d8800615 	stw	r2,24(sp)
811284f4:	14400007 	ldb	r17,0(r2)
811284f8:	b001881e 	bne	r22,zero,81128b1c <_strtod_r+0xbe8>
811284fc:	00c00c04 	movi	r3,48
81128500:	88c3391e 	bne	r17,r3,811291e8 <_strtod_r+0x12b4>
81128504:	10c00044 	addi	r3,r2,1
81128508:	8809883a 	mov	r4,r17
8112850c:	d8c00615 	stw	r3,24(sp)
81128510:	1c400007 	ldb	r17,0(r3)
81128514:	188bc83a 	sub	r5,r3,r2
81128518:	18c00044 	addi	r3,r3,1
8112851c:	893ffb26 	beq	r17,r4,8112850c <__reset+0xfb10850c>
81128520:	88bff3c4 	addi	r2,r17,-49
81128524:	00c00204 	movi	r3,8
81128528:	1882e72e 	bgeu	r3,r2,811290c8 <_strtod_r+0x1194>
8112852c:	00801944 	movi	r2,101
81128530:	88814d26 	beq	r17,r2,81128a68 <_strtod_r+0xb34>
81128534:	0013883a 	mov	r9,zero
81128538:	0015883a 	mov	r10,zero
8112853c:	02c00044 	movi	r11,1
81128540:	003f1d06 	br	811281b8 <__reset+0xfb1081b8>
81128544:	4defc83a 	sub	r23,r9,r23
81128548:	bd6f883a 	add	r23,r23,r21
8112854c:	05c21e0e 	bge	zero,r23,81128dc8 <_strtod_r+0xe94>
81128550:	b88003cc 	andi	r2,r23,15
81128554:	10000d26 	beq	r2,zero,8112858c <_strtod_r+0x658>
81128558:	100490fa 	slli	r2,r2,3
8112855c:	00e04574 	movhi	r3,33045
81128560:	18e9bf04 	addi	r3,r3,-22788
81128564:	1885883a 	add	r2,r3,r2
81128568:	11000017 	ldw	r4,0(r2)
8112856c:	11400117 	ldw	r5,4(r2)
81128570:	900d883a 	mov	r6,r18
81128574:	880f883a 	mov	r7,r17
81128578:	da401315 	stw	r9,76(sp)
8112857c:	111a7f00 	call	8111a7f0 <__muldf3>
81128580:	da401317 	ldw	r9,76(sp)
81128584:	1025883a 	mov	r18,r2
81128588:	1823883a 	mov	r17,r3
8112858c:	023ffc04 	movi	r8,-16
81128590:	ba10703a 	and	r8,r23,r8
81128594:	40003c26 	beq	r8,zero,81128688 <_strtod_r+0x754>
81128598:	00804d04 	movi	r2,308
8112859c:	1201cd16 	blt	r2,r8,81128cd4 <_strtod_r+0xda0>
811285a0:	4011d13a 	srai	r8,r8,4
811285a4:	03000044 	movi	r12,1
811285a8:	62037c0e 	bge	r12,r8,8112939c <_strtod_r+0x1468>
811285ac:	01204574 	movhi	r4,33045
811285b0:	2129b504 	addi	r4,r4,-22828
811285b4:	2015883a 	mov	r10,r4
811285b8:	0027883a 	mov	r19,zero
811285bc:	d9000915 	stw	r4,36(sp)
811285c0:	9005883a 	mov	r2,r18
811285c4:	8807883a 	mov	r3,r17
811285c8:	dc000c15 	stw	r16,48(sp)
811285cc:	dc800e15 	stw	r18,56(sp)
811285d0:	9821883a 	mov	r16,r19
811285d4:	0009883a 	mov	r4,zero
811285d8:	8827883a 	mov	r19,r17
811285dc:	602f883a 	mov	r23,r12
811285e0:	da400a15 	stw	r9,40(sp)
811285e4:	5025883a 	mov	r18,r10
811285e8:	4023883a 	mov	r17,r8
811285ec:	8980004c 	andi	r6,r17,1
811285f0:	30000626 	beq	r6,zero,8112860c <_strtod_r+0x6d8>
811285f4:	91800017 	ldw	r6,0(r18)
811285f8:	91c00117 	ldw	r7,4(r18)
811285fc:	1009883a 	mov	r4,r2
81128600:	180b883a 	mov	r5,r3
81128604:	111a7f00 	call	8111a7f0 <__muldf3>
81128608:	01000044 	movi	r4,1
8112860c:	8823d07a 	srai	r17,r17,1
81128610:	84000044 	addi	r16,r16,1
81128614:	94800204 	addi	r18,r18,8
81128618:	8dfff41e 	bne	r17,r23,811285ec <__reset+0xfb1085ec>
8112861c:	21003fcc 	andi	r4,r4,255
81128620:	9823883a 	mov	r17,r19
81128624:	da400a17 	ldw	r9,40(sp)
81128628:	8027883a 	mov	r19,r16
8112862c:	dc800e17 	ldw	r18,56(sp)
81128630:	dc000c17 	ldw	r16,48(sp)
81128634:	2003b11e 	bne	r4,zero,811294fc <_strtod_r+0x15c8>
81128638:	981690fa 	slli	r11,r19,3
8112863c:	d8800917 	ldw	r2,36(sp)
81128640:	01ff2c34 	movhi	r7,64688
81128644:	900d883a 	mov	r6,r18
81128648:	12ef883a 	add	r23,r2,r11
8112864c:	b9000017 	ldw	r4,0(r23)
81128650:	b9400117 	ldw	r5,4(r23)
81128654:	89cf883a 	add	r7,r17,r7
81128658:	da401315 	stw	r9,76(sp)
8112865c:	111a7f00 	call	8111a7f0 <__muldf3>
81128660:	1025883a 	mov	r18,r2
81128664:	011f2834 	movhi	r4,31904
81128668:	189ffc2c 	andhi	r2,r3,32752
8112866c:	da401317 	ldw	r9,76(sp)
81128670:	20819836 	bltu	r4,r2,81128cd4 <_strtod_r+0xda0>
81128674:	011f2434 	movhi	r4,31888
81128678:	2083382e 	bgeu	r4,r2,8112935c <_strtod_r+0x1428>
8112867c:	045ffc34 	movhi	r17,32752
81128680:	8c7fffc4 	addi	r17,r17,-1
81128684:	04bfffc4 	movi	r18,-1
81128688:	d8000915 	stw	zero,36(sp)
8112868c:	d9400817 	ldw	r5,32(sp)
81128690:	df000015 	stw	fp,0(sp)
81128694:	480f883a 	mov	r7,r9
81128698:	b00d883a 	mov	r6,r22
8112869c:	8009883a 	mov	r4,r16
811286a0:	11268700 	call	81126870 <__s2b>
811286a4:	d8800815 	stw	r2,32(sp)
811286a8:	10018a26 	beq	r2,zero,81128cd4 <_strtod_r+0xda0>
811286ac:	a807d7fa 	srai	r3,r21,31
811286b0:	0545c83a 	sub	r2,zero,r21
811286b4:	dd400a15 	stw	r21,40(sp)
811286b8:	1886703a 	and	r3,r3,r2
811286bc:	d8c00c15 	stw	r3,48(sp)
811286c0:	a8013516 	blt	r21,zero,81128b98 <_strtod_r+0xc64>
811286c4:	d9400817 	ldw	r5,32(sp)
811286c8:	0011883a 	mov	r8,zero
811286cc:	0027883a 	mov	r19,zero
811286d0:	29400304 	addi	r5,r5,12
811286d4:	d9400f15 	stw	r5,60(sp)
811286d8:	402b883a 	mov	r21,r8
811286dc:	dd001215 	stw	r20,72(sp)
811286e0:	d8800817 	ldw	r2,32(sp)
811286e4:	8009883a 	mov	r4,r16
811286e8:	11400117 	ldw	r5,4(r2)
811286ec:	11266700 	call	81126670 <_Balloc>
811286f0:	1029883a 	mov	r20,r2
811286f4:	10012d26 	beq	r2,zero,81128bac <_strtod_r+0xc78>
811286f8:	d8c00817 	ldw	r3,32(sp)
811286fc:	d9400f17 	ldw	r5,60(sp)
81128700:	11000304 	addi	r4,r2,12
81128704:	19800417 	ldw	r6,16(r3)
81128708:	31800084 	addi	r6,r6,2
8112870c:	318d883a 	add	r6,r6,r6
81128710:	318d883a 	add	r6,r6,r6
81128714:	111c4400 	call	8111c440 <memcpy>
81128718:	d9000204 	addi	r4,sp,8
8112871c:	d9000015 	stw	r4,0(sp)
81128720:	d9c00404 	addi	r7,sp,16
81128724:	900b883a 	mov	r5,r18
81128728:	880d883a 	mov	r6,r17
8112872c:	8009883a 	mov	r4,r16
81128730:	112734c0 	call	8112734c <__d2b>
81128734:	d8800515 	stw	r2,20(sp)
81128738:	dc801115 	stw	r18,68(sp)
8112873c:	dc401015 	stw	r17,64(sp)
81128740:	10027c26 	beq	r2,zero,81129134 <_strtod_r+0x1200>
81128744:	01400044 	movi	r5,1
81128748:	8009883a 	mov	r4,r16
8112874c:	1126a940 	call	81126a94 <__i2b>
81128750:	1027883a 	mov	r19,r2
81128754:	10011526 	beq	r2,zero,81128bac <_strtod_r+0xc78>
81128758:	d8800417 	ldw	r2,16(sp)
8112875c:	1000c816 	blt	r2,zero,81128a80 <_strtod_r+0xb4c>
81128760:	d9400c17 	ldw	r5,48(sp)
81128764:	d9000a17 	ldw	r4,40(sp)
81128768:	28ad883a 	add	r22,r5,r2
8112876c:	d9400917 	ldw	r5,36(sp)
81128770:	df000217 	ldw	fp,8(sp)
81128774:	05ff0084 	movi	r23,-1022
81128778:	1147c83a 	sub	r3,r2,r5
8112877c:	1f07883a 	add	r3,r3,fp
81128780:	00800d84 	movi	r2,54
81128784:	18ffffc4 	addi	r3,r3,-1
81128788:	1739c83a 	sub	fp,r2,fp
8112878c:	1dc0a50e 	bge	r3,r23,81128a24 <_strtod_r+0xaf0>
81128790:	b8efc83a 	sub	r23,r23,r3
81128794:	008007c4 	movi	r2,31
81128798:	e5f9c83a 	sub	fp,fp,r23
8112879c:	15c0bc16 	blt	r2,r23,81128a90 <_strtod_r+0xb5c>
811287a0:	00800044 	movi	r2,1
811287a4:	15c4983a 	sll	r2,r2,r23
811287a8:	d8000b15 	stw	zero,44(sp)
811287ac:	d8800d15 	stw	r2,52(sp)
811287b0:	2707883a 	add	r3,r4,fp
811287b4:	d9000917 	ldw	r4,36(sp)
811287b8:	b739883a 	add	fp,r22,fp
811287bc:	20ef883a 	add	r23,r4,r3
811287c0:	b009883a 	mov	r4,r22
811287c4:	e580010e 	bge	fp,r22,811287cc <_strtod_r+0x898>
811287c8:	e009883a 	mov	r4,fp
811287cc:	b805883a 	mov	r2,r23
811287d0:	25c0010e 	bge	r4,r23,811287d8 <_strtod_r+0x8a4>
811287d4:	2005883a 	mov	r2,r4
811287d8:	0080030e 	bge	zero,r2,811287e8 <_strtod_r+0x8b4>
811287dc:	e0b9c83a 	sub	fp,fp,r2
811287e0:	b8afc83a 	sub	r23,r23,r2
811287e4:	b0adc83a 	sub	r22,r22,r2
811287e8:	d9400c17 	ldw	r5,48(sp)
811287ec:	28001126 	beq	r5,zero,81128834 <_strtod_r+0x900>
811287f0:	280d883a 	mov	r6,r5
811287f4:	8009883a 	mov	r4,r16
811287f8:	980b883a 	mov	r5,r19
811287fc:	1126cd80 	call	81126cd8 <__pow5mult>
81128800:	1027883a 	mov	r19,r2
81128804:	1000e926 	beq	r2,zero,81128bac <_strtod_r+0xc78>
81128808:	d9800517 	ldw	r6,20(sp)
8112880c:	100b883a 	mov	r5,r2
81128810:	8009883a 	mov	r4,r16
81128814:	1126ad80 	call	81126ad8 <__multiply>
81128818:	1000e426 	beq	r2,zero,81128bac <_strtod_r+0xc78>
8112881c:	d9400517 	ldw	r5,20(sp)
81128820:	8009883a 	mov	r4,r16
81128824:	d8801315 	stw	r2,76(sp)
81128828:	11267200 	call	81126720 <_Bfree>
8112882c:	d8801317 	ldw	r2,76(sp)
81128830:	d8800515 	stw	r2,20(sp)
81128834:	0700060e 	bge	zero,fp,81128850 <_strtod_r+0x91c>
81128838:	d9400517 	ldw	r5,20(sp)
8112883c:	e00d883a 	mov	r6,fp
81128840:	8009883a 	mov	r4,r16
81128844:	1126e200 	call	81126e20 <__lshift>
81128848:	d8800515 	stw	r2,20(sp)
8112884c:	10023926 	beq	r2,zero,81129134 <_strtod_r+0x1200>
81128850:	d8800a17 	ldw	r2,40(sp)
81128854:	10000626 	beq	r2,zero,81128870 <_strtod_r+0x93c>
81128858:	d9800a17 	ldw	r6,40(sp)
8112885c:	a00b883a 	mov	r5,r20
81128860:	8009883a 	mov	r4,r16
81128864:	1126cd80 	call	81126cd8 <__pow5mult>
81128868:	1029883a 	mov	r20,r2
8112886c:	1000cf26 	beq	r2,zero,81128bac <_strtod_r+0xc78>
81128870:	05c0060e 	bge	zero,r23,8112888c <_strtod_r+0x958>
81128874:	a00b883a 	mov	r5,r20
81128878:	b80d883a 	mov	r6,r23
8112887c:	8009883a 	mov	r4,r16
81128880:	1126e200 	call	81126e20 <__lshift>
81128884:	1029883a 	mov	r20,r2
81128888:	1000c826 	beq	r2,zero,81128bac <_strtod_r+0xc78>
8112888c:	0580060e 	bge	zero,r22,811288a8 <_strtod_r+0x974>
81128890:	980b883a 	mov	r5,r19
81128894:	b00d883a 	mov	r6,r22
81128898:	8009883a 	mov	r4,r16
8112889c:	1126e200 	call	81126e20 <__lshift>
811288a0:	1027883a 	mov	r19,r2
811288a4:	1000c126 	beq	r2,zero,81128bac <_strtod_r+0xc78>
811288a8:	d9400517 	ldw	r5,20(sp)
811288ac:	a00d883a 	mov	r6,r20
811288b0:	8009883a 	mov	r4,r16
811288b4:	1126fd00 	call	81126fd0 <__mdiff>
811288b8:	102b883a 	mov	r21,r2
811288bc:	1000bb26 	beq	r2,zero,81128bac <_strtod_r+0xc78>
811288c0:	10c00317 	ldw	r3,12(r2)
811288c4:	980b883a 	mov	r5,r19
811288c8:	10000315 	stw	zero,12(r2)
811288cc:	1009883a 	mov	r4,r2
811288d0:	d8c00e15 	stw	r3,56(sp)
811288d4:	1126f700 	call	81126f70 <__mcmp>
811288d8:	10027616 	blt	r2,zero,811292b4 <_strtod_r+0x1380>
811288dc:	10024426 	beq	r2,zero,811291f0 <_strtod_r+0x12bc>
811288e0:	980b883a 	mov	r5,r19
811288e4:	a809883a 	mov	r4,r21
811288e8:	11274a00 	call	811274a0 <__ratio>
811288ec:	000d883a 	mov	r6,zero
811288f0:	01d00034 	movhi	r7,16384
811288f4:	1009883a 	mov	r4,r2
811288f8:	180b883a 	mov	r5,r3
811288fc:	102f883a 	mov	r23,r2
81128900:	182d883a 	mov	r22,r3
81128904:	112ffe80 	call	8112ffe8 <__ledf2>
81128908:	00804a16 	blt	zero,r2,81128a34 <_strtod_r+0xb00>
8112890c:	d9400e17 	ldw	r5,56(sp)
81128910:	28006b26 	beq	r5,zero,81128ac0 <_strtod_r+0xb8c>
81128914:	058ffc34 	movhi	r22,16368
81128918:	d8000b15 	stw	zero,44(sp)
8112891c:	d8000d15 	stw	zero,52(sp)
81128920:	b02f883a 	mov	r23,r22
81128924:	8f1ffc2c 	andhi	fp,r17,32752
81128928:	009ff834 	movhi	r2,32736
8112892c:	e080cd26 	beq	fp,r2,81128c64 <_strtod_r+0xd30>
81128930:	d9400917 	ldw	r5,36(sp)
81128934:	28001a26 	beq	r5,zero,811289a0 <_strtod_r+0xa6c>
81128938:	0081a834 	movhi	r2,1696
8112893c:	17001836 	bltu	r2,fp,811289a0 <_strtod_r+0xa6c>
81128940:	d9000d17 	ldw	r4,52(sp)
81128944:	01d07834 	movhi	r7,16864
81128948:	39ffffc4 	addi	r7,r7,-1
8112894c:	01bff034 	movhi	r6,65472
81128950:	b80b883a 	mov	r5,r23
81128954:	112ffe80 	call	8112ffe8 <__ledf2>
81128958:	00800e16 	blt	zero,r2,81128994 <_strtod_r+0xa60>
8112895c:	d9000d17 	ldw	r4,52(sp)
81128960:	b80b883a 	mov	r5,r23
81128964:	112ddf40 	call	8112ddf4 <__fixunsdfsi>
81128968:	10018126 	beq	r2,zero,81128f70 <_strtod_r+0x103c>
8112896c:	1009883a 	mov	r4,r2
81128970:	1130b440 	call	81130b44 <__floatunsidf>
81128974:	d8800d15 	stw	r2,52(sp)
81128978:	182f883a 	mov	r23,r3
8112897c:	d8800e17 	ldw	r2,56(sp)
81128980:	1001791e 	bne	r2,zero,81128f68 <_strtod_r+0x1034>
81128984:	ba20003c 	xorhi	r8,r23,32768
81128988:	d8c00d17 	ldw	r3,52(sp)
8112898c:	402d883a 	mov	r22,r8
81128990:	d8c00b15 	stw	r3,44(sp)
81128994:	0081ac34 	movhi	r2,1712
81128998:	b091883a 	add	r8,r22,r2
8112899c:	472dc83a 	sub	r22,r8,fp
811289a0:	9009883a 	mov	r4,r18
811289a4:	880b883a 	mov	r5,r17
811289a8:	11271d40 	call	811271d4 <__ulp>
811289ac:	d9000b17 	ldw	r4,44(sp)
811289b0:	b00b883a 	mov	r5,r22
811289b4:	100d883a 	mov	r6,r2
811289b8:	180f883a 	mov	r7,r3
811289bc:	111a7f00 	call	8111a7f0 <__muldf3>
811289c0:	900d883a 	mov	r6,r18
811289c4:	880f883a 	mov	r7,r17
811289c8:	1009883a 	mov	r4,r2
811289cc:	180b883a 	mov	r5,r3
811289d0:	112ece00 	call	8112ece0 <__adddf3>
811289d4:	1025883a 	mov	r18,r2
811289d8:	1823883a 	mov	r17,r3
811289dc:	182d883a 	mov	r22,r3
811289e0:	d9000917 	ldw	r4,36(sp)
811289e4:	2000021e 	bne	r4,zero,811289f0 <_strtod_r+0xabc>
811289e8:	b09ffc2c 	andhi	r2,r22,32752
811289ec:	e080be26 	beq	fp,r2,81128ce8 <_strtod_r+0xdb4>
811289f0:	d9400517 	ldw	r5,20(sp)
811289f4:	8009883a 	mov	r4,r16
811289f8:	11267200 	call	81126720 <_Bfree>
811289fc:	a00b883a 	mov	r5,r20
81128a00:	8009883a 	mov	r4,r16
81128a04:	11267200 	call	81126720 <_Bfree>
81128a08:	980b883a 	mov	r5,r19
81128a0c:	8009883a 	mov	r4,r16
81128a10:	11267200 	call	81126720 <_Bfree>
81128a14:	a80b883a 	mov	r5,r21
81128a18:	8009883a 	mov	r4,r16
81128a1c:	11267200 	call	81126720 <_Bfree>
81128a20:	003f2f06 	br	811286e0 <__reset+0xfb1086e0>
81128a24:	00c00044 	movi	r3,1
81128a28:	d8000b15 	stw	zero,44(sp)
81128a2c:	d8c00d15 	stw	r3,52(sp)
81128a30:	003f5f06 	br	811287b0 <__reset+0xfb1087b0>
81128a34:	b809883a 	mov	r4,r23
81128a38:	000d883a 	mov	r6,zero
81128a3c:	01cff834 	movhi	r7,16352
81128a40:	b00b883a 	mov	r5,r22
81128a44:	111a7f00 	call	8111a7f0 <__muldf3>
81128a48:	d9000e17 	ldw	r4,56(sp)
81128a4c:	d8800d15 	stw	r2,52(sp)
81128a50:	182f883a 	mov	r23,r3
81128a54:	2000181e 	bne	r4,zero,81128ab8 <_strtod_r+0xb84>
81128a58:	1a20003c 	xorhi	r8,r3,32768
81128a5c:	d8800b15 	stw	r2,44(sp)
81128a60:	402d883a 	mov	r22,r8
81128a64:	003faf06 	br	81128924 <__reset+0xfb108924>
81128a68:	0015883a 	mov	r10,zero
81128a6c:	02c00044 	movi	r11,1
81128a70:	2800011e 	bne	r5,zero,81128a78 <_strtod_r+0xb44>
81128a74:	903d7e26 	beq	r18,zero,81128070 <__reset+0xfb108070>
81128a78:	0013883a 	mov	r9,zero
81128a7c:	003e4706 	br	8112839c <__reset+0xfb10839c>
81128a80:	d8c00a17 	ldw	r3,40(sp)
81128a84:	dd800c17 	ldw	r22,48(sp)
81128a88:	1889c83a 	sub	r4,r3,r2
81128a8c:	003f3706 	br	8112876c <__reset+0xfb10876c>
81128a90:	00bef884 	movi	r2,-1054
81128a94:	05c00044 	movi	r23,1
81128a98:	10c5c83a 	sub	r2,r2,r3
81128a9c:	b884983a 	sll	r2,r23,r2
81128aa0:	ddc00d15 	stw	r23,52(sp)
81128aa4:	d8800b15 	stw	r2,44(sp)
81128aa8:	003f4106 	br	811287b0 <__reset+0xfb1087b0>
81128aac:	ddc00615 	stw	r23,24(sp)
81128ab0:	002b883a 	mov	r21,zero
81128ab4:	003dc306 	br	811281c4 <__reset+0xfb1081c4>
81128ab8:	1811883a 	mov	r8,r3
81128abc:	003fe706 	br	81128a5c <__reset+0xfb108a5c>
81128ac0:	90002e1e 	bne	r18,zero,81128b7c <_strtod_r+0xc48>
81128ac4:	00c00434 	movhi	r3,16
81128ac8:	18ffffc4 	addi	r3,r3,-1
81128acc:	88c4703a 	and	r2,r17,r3
81128ad0:	10002c1e 	bne	r2,zero,81128b84 <_strtod_r+0xc50>
81128ad4:	000d883a 	mov	r6,zero
81128ad8:	01cffc34 	movhi	r7,16368
81128adc:	b809883a 	mov	r4,r23
81128ae0:	b00b883a 	mov	r5,r22
81128ae4:	112ffe80 	call	8112ffe8 <__ledf2>
81128ae8:	10021716 	blt	r2,zero,81129348 <_strtod_r+0x1414>
81128aec:	b809883a 	mov	r4,r23
81128af0:	b00b883a 	mov	r5,r22
81128af4:	000d883a 	mov	r6,zero
81128af8:	01cff834 	movhi	r7,16352
81128afc:	111a7f00 	call	8111a7f0 <__muldf3>
81128b00:	d8800d15 	stw	r2,52(sp)
81128b04:	182f883a 	mov	r23,r3
81128b08:	102d883a 	mov	r22,r2
81128b0c:	1a20003c 	xorhi	r8,r3,32768
81128b10:	dd800b15 	stw	r22,44(sp)
81128b14:	402d883a 	mov	r22,r8
81128b18:	003f8206 	br	81128924 <__reset+0xfb108924>
81128b1c:	b013883a 	mov	r9,r22
81128b20:	000b883a 	mov	r5,zero
81128b24:	0015883a 	mov	r10,zero
81128b28:	893ff404 	addi	r4,r17,-48
81128b2c:	00800244 	movi	r2,9
81128b30:	11001036 	bltu	r2,r4,81128b74 <_strtod_r+0xc40>
81128b34:	28c00044 	addi	r3,r5,1
81128b38:	2023883a 	mov	r17,r4
81128b3c:	20014d1e 	bne	r4,zero,81129074 <_strtod_r+0x1140>
81128b40:	d9800617 	ldw	r6,24(sp)
81128b44:	180b883a 	mov	r5,r3
81128b48:	30800044 	addi	r2,r6,1
81128b4c:	d8800615 	stw	r2,24(sp)
81128b50:	34400047 	ldb	r17,1(r6)
81128b54:	003ff406 	br	81128b28 <__reset+0xfb108b28>
81128b58:	0019883a 	mov	r12,zero
81128b5c:	b8800084 	addi	r2,r23,2
81128b60:	d8800615 	stw	r2,24(sp)
81128b64:	bc400087 	ldb	r17,2(r23)
81128b68:	003e1606 	br	811283c4 <__reset+0xfb1083c4>
81128b6c:	03000044 	movi	r12,1
81128b70:	003ffa06 	br	81128b5c <__reset+0xfb108b5c>
81128b74:	02c00044 	movi	r11,1
81128b78:	003d8d06 	br	811281b0 <__reset+0xfb1081b0>
81128b7c:	00800044 	movi	r2,1
81128b80:	9080fe26 	beq	r18,r2,81128f7c <_strtod_r+0x1048>
81128b84:	d8000b15 	stw	zero,44(sp)
81128b88:	05affc34 	movhi	r22,49136
81128b8c:	d8000d15 	stw	zero,52(sp)
81128b90:	05cffc34 	movhi	r23,16368
81128b94:	003f6306 	br	81128924 <__reset+0xfb108924>
81128b98:	d8000a15 	stw	zero,40(sp)
81128b9c:	003ec906 	br	811286c4 <__reset+0xfb1086c4>
81128ba0:	d9001117 	ldw	r4,68(sp)
81128ba4:	00bfffc4 	movi	r2,-1
81128ba8:	2080461e 	bne	r4,r2,81128cc4 <_strtod_r+0xd90>
81128bac:	dd000a15 	stw	r20,40(sp)
81128bb0:	dd001217 	ldw	r20,72(sp)
81128bb4:	a811883a 	mov	r8,r21
81128bb8:	d8800517 	ldw	r2,20(sp)
81128bbc:	00c00884 	movi	r3,34
81128bc0:	80c00015 	stw	r3,0(r16)
81128bc4:	002b883a 	mov	r21,zero
81128bc8:	059ffc34 	movhi	r22,32752
81128bcc:	100b883a 	mov	r5,r2
81128bd0:	8009883a 	mov	r4,r16
81128bd4:	da001315 	stw	r8,76(sp)
81128bd8:	11267200 	call	81126720 <_Bfree>
81128bdc:	d9400a17 	ldw	r5,40(sp)
81128be0:	8009883a 	mov	r4,r16
81128be4:	11267200 	call	81126720 <_Bfree>
81128be8:	980b883a 	mov	r5,r19
81128bec:	8009883a 	mov	r4,r16
81128bf0:	11267200 	call	81126720 <_Bfree>
81128bf4:	d9400817 	ldw	r5,32(sp)
81128bf8:	8009883a 	mov	r4,r16
81128bfc:	11267200 	call	81126720 <_Bfree>
81128c00:	da001317 	ldw	r8,76(sp)
81128c04:	8009883a 	mov	r4,r16
81128c08:	400b883a 	mov	r5,r8
81128c0c:	11267200 	call	81126720 <_Bfree>
81128c10:	003d9206 	br	8112825c <__reset+0xfb10825c>
81128c14:	d8c00717 	ldw	r3,28(sp)
81128c18:	d8800504 	addi	r2,sp,20
81128c1c:	01a04574 	movhi	r6,33045
81128c20:	31a9fa04 	addi	r6,r6,-22552
81128c24:	d8c00115 	stw	r3,4(sp)
81128c28:	d8800015 	stw	r2,0(sp)
81128c2c:	d9c00404 	addi	r7,sp,16
81128c30:	d9400604 	addi	r5,sp,24
81128c34:	8009883a 	mov	r4,r16
81128c38:	112d0880 	call	8112d088 <__gethex>
81128c3c:	154001cc 	andi	r21,r2,7
81128c40:	a83d9b26 	beq	r21,zero,811282b0 <__reset+0xfb1082b0>
81128c44:	00c00184 	movi	r3,6
81128c48:	a8c0d61e 	bne	r21,r3,81128fa4 <_strtod_r+0x1070>
81128c4c:	9cc00044 	addi	r19,r19,1
81128c50:	dcc00615 	stw	r19,24(sp)
81128c54:	002b883a 	mov	r21,zero
81128c58:	002d883a 	mov	r22,zero
81128c5c:	d8000715 	stw	zero,28(sp)
81128c60:	003d7e06 	br	8112825c <__reset+0xfb10825c>
81128c64:	00bf2c34 	movhi	r2,64688
81128c68:	88a3883a 	add	r17,r17,r2
81128c6c:	9009883a 	mov	r4,r18
81128c70:	880b883a 	mov	r5,r17
81128c74:	11271d40 	call	811271d4 <__ulp>
81128c78:	d9000b17 	ldw	r4,44(sp)
81128c7c:	100d883a 	mov	r6,r2
81128c80:	180f883a 	mov	r7,r3
81128c84:	b00b883a 	mov	r5,r22
81128c88:	111a7f00 	call	8111a7f0 <__muldf3>
81128c8c:	900d883a 	mov	r6,r18
81128c90:	180b883a 	mov	r5,r3
81128c94:	880f883a 	mov	r7,r17
81128c98:	1009883a 	mov	r4,r2
81128c9c:	112ece00 	call	8112ece0 <__adddf3>
81128ca0:	015f2834 	movhi	r5,31904
81128ca4:	1025883a 	mov	r18,r2
81128ca8:	297fffc4 	addi	r5,r5,-1
81128cac:	189ffc2c 	andhi	r2,r3,32752
81128cb0:	2880892e 	bgeu	r5,r2,81128ed8 <_strtod_r+0xfa4>
81128cb4:	d8801017 	ldw	r2,64(sp)
81128cb8:	00dffc34 	movhi	r3,32752
81128cbc:	18ffffc4 	addi	r3,r3,-1
81128cc0:	10ffb726 	beq	r2,r3,81128ba0 <__reset+0xfb108ba0>
81128cc4:	045ffc34 	movhi	r17,32752
81128cc8:	8c7fffc4 	addi	r17,r17,-1
81128ccc:	04bfffc4 	movi	r18,-1
81128cd0:	003f4706 	br	811289f0 <__reset+0xfb1089f0>
81128cd4:	00800884 	movi	r2,34
81128cd8:	80800015 	stw	r2,0(r16)
81128cdc:	002b883a 	mov	r21,zero
81128ce0:	059ffc34 	movhi	r22,32752
81128ce4:	003d5d06 	br	8112825c <__reset+0xfb10825c>
81128ce8:	d9000d17 	ldw	r4,52(sp)
81128cec:	b80b883a 	mov	r5,r23
81128cf0:	11309e00 	call	811309e0 <__fixdfsi>
81128cf4:	1009883a 	mov	r4,r2
81128cf8:	1130a600 	call	81130a60 <__floatsidf>
81128cfc:	d9000d17 	ldw	r4,52(sp)
81128d00:	b80b883a 	mov	r5,r23
81128d04:	100d883a 	mov	r6,r2
81128d08:	180f883a 	mov	r7,r3
81128d0c:	11300dc0 	call	811300dc <__subdf3>
81128d10:	d9400e17 	ldw	r5,56(sp)
81128d14:	1039883a 	mov	fp,r2
81128d18:	182f883a 	mov	r23,r3
81128d1c:	2800141e 	bne	r5,zero,81128d70 <_strtod_r+0xe3c>
81128d20:	9000131e 	bne	r18,zero,81128d70 <_strtod_r+0xe3c>
81128d24:	00800434 	movhi	r2,16
81128d28:	10bfffc4 	addi	r2,r2,-1
81128d2c:	b0ac703a 	and	r22,r22,r2
81128d30:	b0000f1e 	bne	r22,zero,81128d70 <_strtod_r+0xe3c>
81128d34:	01a52834 	movhi	r6,38048
81128d38:	01cff434 	movhi	r7,16336
81128d3c:	318d6544 	addi	r6,r6,13717
81128d40:	39ffffc4 	addi	r7,r7,-1
81128d44:	e009883a 	mov	r4,fp
81128d48:	180b883a 	mov	r5,r3
81128d4c:	112ffe80 	call	8112ffe8 <__ledf2>
81128d50:	103f270e 	bge	r2,zero,811289f0 <__reset+0xfb1089f0>
81128d54:	dd000a15 	stw	r20,40(sp)
81128d58:	a811883a 	mov	r8,r21
81128d5c:	dd001217 	ldw	r20,72(sp)
81128d60:	d8800517 	ldw	r2,20(sp)
81128d64:	002b883a 	mov	r21,zero
81128d68:	882d883a 	mov	r22,r17
81128d6c:	003f9706 	br	81128bcc <__reset+0xfb108bcc>
81128d70:	01a52834 	movhi	r6,38048
81128d74:	01cff834 	movhi	r7,16352
81128d78:	318d6544 	addi	r6,r6,13717
81128d7c:	39ffffc4 	addi	r7,r7,-1
81128d80:	e009883a 	mov	r4,fp
81128d84:	b80b883a 	mov	r5,r23
81128d88:	112ffe80 	call	8112ffe8 <__ledf2>
81128d8c:	10000716 	blt	r2,zero,81128dac <_strtod_r+0xe78>
81128d90:	018d6c34 	movhi	r6,13744
81128d94:	31b94d44 	addi	r6,r6,-6859
81128d98:	01cff834 	movhi	r7,16352
81128d9c:	e009883a 	mov	r4,fp
81128da0:	b80b883a 	mov	r5,r23
81128da4:	112ff0c0 	call	8112ff0c <__gedf2>
81128da8:	00bf110e 	bge	zero,r2,811289f0 <__reset+0xfb1089f0>
81128dac:	dd000a15 	stw	r20,40(sp)
81128db0:	a811883a 	mov	r8,r21
81128db4:	dd001217 	ldw	r20,72(sp)
81128db8:	d8800517 	ldw	r2,20(sp)
81128dbc:	902b883a 	mov	r21,r18
81128dc0:	882d883a 	mov	r22,r17
81128dc4:	003f8106 	br	81128bcc <__reset+0xfb108bcc>
81128dc8:	b83e2f26 	beq	r23,zero,81128688 <__reset+0xfb108688>
81128dcc:	05efc83a 	sub	r23,zero,r23
81128dd0:	b88003cc 	andi	r2,r23,15
81128dd4:	10000d26 	beq	r2,zero,81128e0c <_strtod_r+0xed8>
81128dd8:	100490fa 	slli	r2,r2,3
81128ddc:	00e04574 	movhi	r3,33045
81128de0:	18e9bf04 	addi	r3,r3,-22788
81128de4:	1885883a 	add	r2,r3,r2
81128de8:	11800017 	ldw	r6,0(r2)
81128dec:	11c00117 	ldw	r7,4(r2)
81128df0:	9009883a 	mov	r4,r18
81128df4:	880b883a 	mov	r5,r17
81128df8:	da401315 	stw	r9,76(sp)
81128dfc:	112f5940 	call	8112f594 <__divdf3>
81128e00:	da401317 	ldw	r9,76(sp)
81128e04:	1025883a 	mov	r18,r2
81128e08:	1823883a 	mov	r17,r3
81128e0c:	b82fd13a 	srai	r23,r23,4
81128e10:	b83e1d26 	beq	r23,zero,81128688 <__reset+0xfb108688>
81128e14:	008007c4 	movi	r2,31
81128e18:	15c02816 	blt	r2,r23,81128ebc <_strtod_r+0xf88>
81128e1c:	b880040c 	andi	r2,r23,16
81128e20:	10019726 	beq	r2,zero,81129480 <_strtod_r+0x154c>
81128e24:	05c1880e 	bge	zero,r23,81129448 <_strtod_r+0x1514>
81128e28:	00c01a84 	movi	r3,106
81128e2c:	d8c00915 	stw	r3,36(sp)
81128e30:	04e04574 	movhi	r19,33045
81128e34:	9ce9ff04 	addi	r19,r19,-22532
81128e38:	8807883a 	mov	r3,r17
81128e3c:	9005883a 	mov	r2,r18
81128e40:	8023883a 	mov	r17,r16
81128e44:	0009883a 	mov	r4,zero
81128e48:	9821883a 	mov	r16,r19
81128e4c:	da400a15 	stw	r9,40(sp)
81128e50:	1827883a 	mov	r19,r3
81128e54:	b980004c 	andi	r6,r23,1
81128e58:	30000626 	beq	r6,zero,81128e74 <_strtod_r+0xf40>
81128e5c:	81800017 	ldw	r6,0(r16)
81128e60:	81c00117 	ldw	r7,4(r16)
81128e64:	1009883a 	mov	r4,r2
81128e68:	180b883a 	mov	r5,r3
81128e6c:	111a7f00 	call	8111a7f0 <__muldf3>
81128e70:	01000044 	movi	r4,1
81128e74:	b82fd07a 	srai	r23,r23,1
81128e78:	84000204 	addi	r16,r16,8
81128e7c:	b83ff51e 	bne	r23,zero,81128e54 <__reset+0xfb108e54>
81128e80:	21003fcc 	andi	r4,r4,255
81128e84:	8821883a 	mov	r16,r17
81128e88:	da400a17 	ldw	r9,40(sp)
81128e8c:	9823883a 	mov	r17,r19
81128e90:	2001a51e 	bne	r4,zero,81129528 <_strtod_r+0x15f4>
81128e94:	d9000917 	ldw	r4,36(sp)
81128e98:	20016d1e 	bne	r4,zero,81129450 <_strtod_r+0x151c>
81128e9c:	000d883a 	mov	r6,zero
81128ea0:	000f883a 	mov	r7,zero
81128ea4:	9009883a 	mov	r4,r18
81128ea8:	880b883a 	mov	r5,r17
81128eac:	da401315 	stw	r9,76(sp)
81128eb0:	112fe840 	call	8112fe84 <__eqdf2>
81128eb4:	da401317 	ldw	r9,76(sp)
81128eb8:	103df41e 	bne	r2,zero,8112868c <__reset+0xfb10868c>
81128ebc:	00800884 	movi	r2,34
81128ec0:	80800015 	stw	r2,0(r16)
81128ec4:	002b883a 	mov	r21,zero
81128ec8:	002d883a 	mov	r22,zero
81128ecc:	003ce306 	br	8112825c <__reset+0xfb10825c>
81128ed0:	055387c4 	movi	r21,19999
81128ed4:	003d6b06 	br	81128484 <__reset+0xfb108484>
81128ed8:	0440d434 	movhi	r17,848
81128edc:	1c63883a 	add	r17,r3,r17
81128ee0:	882d883a 	mov	r22,r17
81128ee4:	003ebe06 	br	811289e0 <__reset+0xfb1089e0>
81128ee8:	14403fcc 	andi	r17,r2,255
81128eec:	8c40201c 	xori	r17,r17,128
81128ef0:	8c7fe004 	addi	r17,r17,-128
81128ef4:	dd400817 	ldw	r21,32(sp)
81128ef8:	0027883a 	mov	r19,zero
81128efc:	0039883a 	mov	fp,zero
81128f00:	002d883a 	mov	r22,zero
81128f04:	003c9906 	br	8112816c <__reset+0xfb10816c>
81128f08:	00c00944 	movi	r3,37
81128f0c:	1a47c83a 	sub	r3,r3,r9
81128f10:	1d7d8c16 	blt	r3,r21,81128544 <__reset+0xfb108544>
81128f14:	1261c83a 	sub	r16,r2,r9
81128f18:	800490fa 	slli	r2,r16,3
81128f1c:	04e04574 	movhi	r19,33045
81128f20:	9ce9bf04 	addi	r19,r19,-22788
81128f24:	9885883a 	add	r2,r19,r2
81128f28:	11000017 	ldw	r4,0(r2)
81128f2c:	11400117 	ldw	r5,4(r2)
81128f30:	900d883a 	mov	r6,r18
81128f34:	880f883a 	mov	r7,r17
81128f38:	111a7f00 	call	8111a7f0 <__muldf3>
81128f3c:	ac0dc83a 	sub	r6,r21,r16
81128f40:	300c90fa 	slli	r6,r6,3
81128f44:	1009883a 	mov	r4,r2
81128f48:	180b883a 	mov	r5,r3
81128f4c:	9985883a 	add	r2,r19,r6
81128f50:	11800017 	ldw	r6,0(r2)
81128f54:	11c00117 	ldw	r7,4(r2)
81128f58:	111a7f00 	call	8111a7f0 <__muldf3>
81128f5c:	102b883a 	mov	r21,r2
81128f60:	182d883a 	mov	r22,r3
81128f64:	003cbd06 	br	8112825c <__reset+0xfb10825c>
81128f68:	b811883a 	mov	r8,r23
81128f6c:	003e8606 	br	81128988 <__reset+0xfb108988>
81128f70:	d8000d15 	stw	zero,52(sp)
81128f74:	05cffc34 	movhi	r23,16368
81128f78:	003e8006 	br	8112897c <__reset+0xfb10897c>
81128f7c:	883f011e 	bne	r17,zero,81128b84 <__reset+0xfb108b84>
81128f80:	dd000a15 	stw	r20,40(sp)
81128f84:	dd001217 	ldw	r20,72(sp)
81128f88:	a811883a 	mov	r8,r21
81128f8c:	00800884 	movi	r2,34
81128f90:	80800015 	stw	r2,0(r16)
81128f94:	002b883a 	mov	r21,zero
81128f98:	d8800517 	ldw	r2,20(sp)
81128f9c:	002d883a 	mov	r22,zero
81128fa0:	003f0a06 	br	81128bcc <__reset+0xfb108bcc>
81128fa4:	d9800517 	ldw	r6,20(sp)
81128fa8:	30000826 	beq	r6,zero,81128fcc <_strtod_r+0x1098>
81128fac:	01400d44 	movi	r5,53
81128fb0:	d9000204 	addi	r4,sp,8
81128fb4:	d8801315 	stw	r2,76(sp)
81128fb8:	11275c80 	call	811275c8 <__copybits>
81128fbc:	d9400517 	ldw	r5,20(sp)
81128fc0:	8009883a 	mov	r4,r16
81128fc4:	11267200 	call	81126720 <_Bfree>
81128fc8:	d8801317 	ldw	r2,76(sp)
81128fcc:	00c00184 	movi	r3,6
81128fd0:	1d400f36 	bltu	r3,r21,81129010 <_strtod_r+0x10dc>
81128fd4:	a82a90ba 	slli	r21,r21,2
81128fd8:	00e044f4 	movhi	r3,33043
81128fdc:	18e3fb04 	addi	r3,r3,-28692
81128fe0:	a8eb883a 	add	r21,r21,r3
81128fe4:	a8c00017 	ldw	r3,0(r21)
81128fe8:	1800683a 	jmp	r3
81128fec:	81129068 	cmpgeui	r4,r16,19009
81128ff0:	81129040 	call	88112904 <__reset+0x20f2904>
81128ff4:	81129024 	muli	r4,r16,19008
81128ff8:	81129008 	cmpgei	r4,r16,19008
81128ffc:	81129030 	cmpltui	r4,r16,19008
81129000:	81129040 	call	88112904 <__reset+0x20f2904>
81129004:	81129068 	cmpgeui	r4,r16,19009
81129008:	045ffc34 	movhi	r17,32752
8112900c:	0025883a 	mov	r18,zero
81129010:	1080020c 	andi	r2,r2,8
81129014:	902b883a 	mov	r21,r18
81129018:	103c8f26 	beq	r2,zero,81128258 <__reset+0xfb108258>
8112901c:	8da00034 	orhi	r22,r17,32768
81129020:	003c8e06 	br	8112825c <__reset+0xfb10825c>
81129024:	dc800217 	ldw	r18,8(sp)
81129028:	dc400317 	ldw	r17,12(sp)
8112902c:	003ff806 	br	81129010 <__reset+0xfb109010>
81129030:	04600034 	movhi	r17,32768
81129034:	8c7fffc4 	addi	r17,r17,-1
81129038:	04bfffc4 	movi	r18,-1
8112903c:	003ff406 	br	81129010 <__reset+0xfb109010>
81129040:	d8c00417 	ldw	r3,16(sp)
81129044:	dc400317 	ldw	r17,12(sp)
81129048:	013ffc34 	movhi	r4,65520
8112904c:	18c10cc4 	addi	r3,r3,1075
81129050:	1806953a 	slli	r3,r3,20
81129054:	213fffc4 	addi	r4,r4,-1
81129058:	8922703a 	and	r17,r17,r4
8112905c:	dc800217 	ldw	r18,8(sp)
81129060:	88e2b03a 	or	r17,r17,r3
81129064:	003fea06 	br	81129010 <__reset+0xfb109010>
81129068:	0023883a 	mov	r17,zero
8112906c:	0025883a 	mov	r18,zero
81129070:	003fe706 	br	81129010 <__reset+0xfb109010>
81129074:	01800044 	movi	r6,1
81129078:	50d5883a 	add	r10,r10,r3
8112907c:	2a4b883a 	add	r5,r5,r9
81129080:	19811a26 	beq	r3,r6,811294ec <_strtod_r+0x15b8>
81129084:	01800204 	movi	r6,8
81129088:	01c00404 	movi	r7,16
8112908c:	4a400044 	addi	r9,r9,1
81129090:	48bfffc4 	addi	r2,r9,-1
81129094:	30801616 	blt	r6,r2,811290f0 <_strtod_r+0x11bc>
81129098:	e70002a4 	muli	fp,fp,10
8112909c:	497ffb1e 	bne	r9,r5,8112908c <__reset+0xfb10908c>
811290a0:	d9800617 	ldw	r6,24(sp)
811290a4:	4a400044 	addi	r9,r9,1
811290a8:	00c00204 	movi	r3,8
811290ac:	19400c0e 	bge	r3,r5,811290e0 <_strtod_r+0x11ac>
811290b0:	00800404 	movi	r2,16
811290b4:	000b883a 	mov	r5,zero
811290b8:	127ea316 	blt	r2,r9,81128b48 <__reset+0xfb108b48>
811290bc:	988002a4 	muli	r2,r19,10
811290c0:	20a7883a 	add	r19,r4,r2
811290c4:	003ea006 	br	81128b48 <__reset+0xfb108b48>
811290c8:	d8800617 	ldw	r2,24(sp)
811290cc:	8c7ff404 	addi	r17,r17,-48
811290d0:	2a800044 	addi	r10,r5,1
811290d4:	d8800815 	stw	r2,32(sp)
811290d8:	100d883a 	mov	r6,r2
811290dc:	02400044 	movi	r9,1
811290e0:	e08002a4 	muli	r2,fp,10
811290e4:	000b883a 	mov	r5,zero
811290e8:	88b9883a 	add	fp,r17,r2
811290ec:	003e9606 	br	81128b48 <__reset+0xfb108b48>
811290f0:	3a7fea16 	blt	r7,r9,8112909c <__reset+0xfb10909c>
811290f4:	9cc002a4 	muli	r19,r19,10
811290f8:	003fe806 	br	8112909c <__reset+0xfb10909c>
811290fc:	00bffa84 	movi	r2,-22
81129100:	a8bd1016 	blt	r21,r2,81128544 <__reset+0xfb108544>
81129104:	a82a90fa 	slli	r21,r21,3
81129108:	00a04574 	movhi	r2,33045
8112910c:	10a9bf04 	addi	r2,r2,-22788
81129110:	1545c83a 	sub	r2,r2,r21
81129114:	11800017 	ldw	r6,0(r2)
81129118:	11c00117 	ldw	r7,4(r2)
8112911c:	9009883a 	mov	r4,r18
81129120:	880b883a 	mov	r5,r17
81129124:	112f5940 	call	8112f594 <__divdf3>
81129128:	102b883a 	mov	r21,r2
8112912c:	182d883a 	mov	r22,r3
81129130:	003c4a06 	br	8112825c <__reset+0xfb10825c>
81129134:	dd000a15 	stw	r20,40(sp)
81129138:	a811883a 	mov	r8,r21
8112913c:	dd001217 	ldw	r20,72(sp)
81129140:	003e9e06 	br	81128bbc <__reset+0xfb108bbc>
81129144:	01604574 	movhi	r5,33045
81129148:	d9000617 	ldw	r4,24(sp)
8112914c:	2969f104 	addi	r5,r5,-22588
81129150:	01c00644 	movi	r7,25
81129154:	00000b06 	br	81129184 <_strtod_r+0x1250>
81129158:	21000044 	addi	r4,r4,1
8112915c:	20800003 	ldbu	r2,0(r4)
81129160:	10ffefc4 	addi	r3,r2,-65
81129164:	10803fcc 	andi	r2,r2,255
81129168:	1080201c 	xori	r2,r2,128
8112916c:	18c03fcc 	andi	r3,r3,255
81129170:	10bfe004 	addi	r2,r2,-128
81129174:	38c00136 	bltu	r7,r3,8112917c <_strtod_r+0x1248>
81129178:	10800804 	addi	r2,r2,32
8112917c:	29400044 	addi	r5,r5,1
81129180:	11bbbb1e 	bne	r2,r6,81128070 <__reset+0xfb108070>
81129184:	29800007 	ldb	r6,0(r5)
81129188:	303ff31e 	bne	r6,zero,81129158 <__reset+0xfb109158>
8112918c:	01a04574 	movhi	r6,33045
81129190:	d9000615 	stw	r4,24(sp)
81129194:	31a9f204 	addi	r6,r6,-22584
81129198:	200b883a 	mov	r5,r4
8112919c:	02000644 	movi	r8,25
811291a0:	00000a06 	br	811291cc <_strtod_r+0x1298>
811291a4:	28800003 	ldbu	r2,0(r5)
811291a8:	10ffefc4 	addi	r3,r2,-65
811291ac:	10803fcc 	andi	r2,r2,255
811291b0:	1080201c 	xori	r2,r2,128
811291b4:	18c03fcc 	andi	r3,r3,255
811291b8:	10bfe004 	addi	r2,r2,-128
811291bc:	40c00136 	bltu	r8,r3,811291c4 <_strtod_r+0x1290>
811291c0:	10800804 	addi	r2,r2,32
811291c4:	31800044 	addi	r6,r6,1
811291c8:	11c0711e 	bne	r2,r7,81129390 <_strtod_r+0x145c>
811291cc:	31c00007 	ldb	r7,0(r6)
811291d0:	29400044 	addi	r5,r5,1
811291d4:	383ff31e 	bne	r7,zero,811291a4 <__reset+0xfb1091a4>
811291d8:	d9400615 	stw	r5,24(sp)
811291dc:	045ffc34 	movhi	r17,32752
811291e0:	0025883a 	mov	r18,zero
811291e4:	003c1b06 	br	81128254 <__reset+0xfb108254>
811291e8:	000b883a 	mov	r5,zero
811291ec:	003ccc06 	br	81128520 <__reset+0xfb108520>
811291f0:	d9400e17 	ldw	r5,56(sp)
811291f4:	dd000a15 	stw	r20,40(sp)
811291f8:	00800434 	movhi	r2,16
811291fc:	a811883a 	mov	r8,r21
81129200:	dd001217 	ldw	r20,72(sp)
81129204:	dd401117 	ldw	r21,68(sp)
81129208:	dd801017 	ldw	r22,64(sp)
8112920c:	10bfffc4 	addi	r2,r2,-1
81129210:	28005626 	beq	r5,zero,8112936c <_strtod_r+0x1438>
81129214:	8886703a 	and	r3,r17,r2
81129218:	18807826 	beq	r3,r2,811293fc <_strtod_r+0x14c8>
8112921c:	d8c00b17 	ldw	r3,44(sp)
81129220:	18005726 	beq	r3,zero,81129380 <_strtod_r+0x144c>
81129224:	1c44703a 	and	r2,r3,r17
81129228:	10000f26 	beq	r2,zero,81129268 <_strtod_r+0x1334>
8112922c:	d9000e17 	ldw	r4,56(sp)
81129230:	d9800917 	ldw	r6,36(sp)
81129234:	20005e26 	beq	r4,zero,811293b0 <_strtod_r+0x147c>
81129238:	9009883a 	mov	r4,r18
8112923c:	880b883a 	mov	r5,r17
81129240:	da001315 	stw	r8,76(sp)
81129244:	1127ec80 	call	81127ec8 <sulp>
81129248:	100d883a 	mov	r6,r2
8112924c:	180f883a 	mov	r7,r3
81129250:	9009883a 	mov	r4,r18
81129254:	880b883a 	mov	r5,r17
81129258:	112ece00 	call	8112ece0 <__adddf3>
8112925c:	da001317 	ldw	r8,76(sp)
81129260:	102b883a 	mov	r21,r2
81129264:	182d883a 	mov	r22,r3
81129268:	d8c00917 	ldw	r3,36(sp)
8112926c:	18000f26 	beq	r3,zero,811292ac <_strtod_r+0x1378>
81129270:	a809883a 	mov	r4,r21
81129274:	b00b883a 	mov	r5,r22
81129278:	000d883a 	mov	r6,zero
8112927c:	01ce5434 	movhi	r7,14672
81129280:	da001315 	stw	r8,76(sp)
81129284:	111a7f00 	call	8111a7f0 <__muldf3>
81129288:	102b883a 	mov	r21,r2
8112928c:	182d883a 	mov	r22,r3
81129290:	da001317 	ldw	r8,76(sp)
81129294:	1800051e 	bne	r3,zero,811292ac <_strtod_r+0x1378>
81129298:	d8800517 	ldw	r2,20(sp)
8112929c:	a83e4b1e 	bne	r21,zero,81128bcc <__reset+0xfb108bcc>
811292a0:	00c00884 	movi	r3,34
811292a4:	80c00015 	stw	r3,0(r16)
811292a8:	003e4806 	br	81128bcc <__reset+0xfb108bcc>
811292ac:	d8800517 	ldw	r2,20(sp)
811292b0:	003e4606 	br	81128bcc <__reset+0xfb108bcc>
811292b4:	d9000e17 	ldw	r4,56(sp)
811292b8:	dd000a15 	stw	r20,40(sp)
811292bc:	a811883a 	mov	r8,r21
811292c0:	dd001217 	ldw	r20,72(sp)
811292c4:	dd401117 	ldw	r21,68(sp)
811292c8:	dd801017 	ldw	r22,64(sp)
811292cc:	203fe61e 	bne	r4,zero,81129268 <__reset+0xfb109268>
811292d0:	903fe51e 	bne	r18,zero,81129268 <__reset+0xfb109268>
811292d4:	00800434 	movhi	r2,16
811292d8:	10bfffc4 	addi	r2,r2,-1
811292dc:	8884703a 	and	r2,r17,r2
811292e0:	103fe11e 	bne	r2,zero,81129268 <__reset+0xfb109268>
811292e4:	8ddffc2c 	andhi	r23,r17,32752
811292e8:	0081ac34 	movhi	r2,1712
811292ec:	15ffde2e 	bgeu	r2,r23,81129268 <__reset+0xfb109268>
811292f0:	40800517 	ldw	r2,20(r8)
811292f4:	1000031e 	bne	r2,zero,81129304 <_strtod_r+0x13d0>
811292f8:	40800417 	ldw	r2,16(r8)
811292fc:	00c00044 	movi	r3,1
81129300:	18bfd90e 	bge	r3,r2,81129268 <__reset+0xfb109268>
81129304:	400b883a 	mov	r5,r8
81129308:	01800044 	movi	r6,1
8112930c:	8009883a 	mov	r4,r16
81129310:	1126e200 	call	81126e20 <__lshift>
81129314:	980b883a 	mov	r5,r19
81129318:	1009883a 	mov	r4,r2
8112931c:	d8801315 	stw	r2,76(sp)
81129320:	1126f700 	call	81126f70 <__mcmp>
81129324:	da001317 	ldw	r8,76(sp)
81129328:	00bfcf0e 	bge	zero,r2,81129268 <__reset+0xfb109268>
8112932c:	d8c00917 	ldw	r3,36(sp)
81129330:	18005c26 	beq	r3,zero,811294a4 <_strtod_r+0x1570>
81129334:	0081ac34 	movhi	r2,1712
81129338:	15c05a16 	blt	r2,r23,811294a4 <_strtod_r+0x1570>
8112933c:	0080dc34 	movhi	r2,880
81129340:	15ffcb16 	blt	r2,r23,81129270 <__reset+0xfb109270>
81129344:	003f1106 	br	81128f8c <__reset+0xfb108f8c>
81129348:	002d883a 	mov	r22,zero
8112934c:	022ff834 	movhi	r8,49120
81129350:	d8000d15 	stw	zero,52(sp)
81129354:	05cff834 	movhi	r23,16352
81129358:	003ded06 	br	81128b10 <__reset+0xfb108b10>
8112935c:	0440d434 	movhi	r17,848
81129360:	1c63883a 	add	r17,r3,r17
81129364:	d8000915 	stw	zero,36(sp)
81129368:	003cc806 	br	8112868c <__reset+0xfb10868c>
8112936c:	8884703a 	and	r2,r17,r2
81129370:	103faa1e 	bne	r2,zero,8112921c <__reset+0xfb10921c>
81129374:	903fa91e 	bne	r18,zero,8112921c <__reset+0xfb10921c>
81129378:	8ddffc2c 	andhi	r23,r17,32752
8112937c:	003feb06 	br	8112932c <__reset+0xfb10932c>
81129380:	d8c00d17 	ldw	r3,52(sp)
81129384:	1cae703a 	and	r23,r3,r18
81129388:	b83fb726 	beq	r23,zero,81129268 <__reset+0xfb109268>
8112938c:	003fa706 	br	8112922c <__reset+0xfb10922c>
81129390:	21000044 	addi	r4,r4,1
81129394:	d9000615 	stw	r4,24(sp)
81129398:	003f9006 	br	811291dc <__reset+0xfb1091dc>
8112939c:	01604574 	movhi	r5,33045
811293a0:	2969b504 	addi	r5,r5,-22828
811293a4:	d9400915 	stw	r5,36(sp)
811293a8:	0027883a 	mov	r19,zero
811293ac:	003ca206 	br	81128638 <__reset+0xfb108638>
811293b0:	9009883a 	mov	r4,r18
811293b4:	880b883a 	mov	r5,r17
811293b8:	da001315 	stw	r8,76(sp)
811293bc:	1127ec80 	call	81127ec8 <sulp>
811293c0:	100d883a 	mov	r6,r2
811293c4:	180f883a 	mov	r7,r3
811293c8:	9009883a 	mov	r4,r18
811293cc:	880b883a 	mov	r5,r17
811293d0:	11300dc0 	call	811300dc <__subdf3>
811293d4:	000d883a 	mov	r6,zero
811293d8:	000f883a 	mov	r7,zero
811293dc:	1009883a 	mov	r4,r2
811293e0:	180b883a 	mov	r5,r3
811293e4:	102b883a 	mov	r21,r2
811293e8:	182d883a 	mov	r22,r3
811293ec:	112fe840 	call	8112fe84 <__eqdf2>
811293f0:	da001317 	ldw	r8,76(sp)
811293f4:	103ee526 	beq	r2,zero,81128f8c <__reset+0xfb108f8c>
811293f8:	003f9b06 	br	81129268 <__reset+0xfb109268>
811293fc:	d8800917 	ldw	r2,36(sp)
81129400:	10002226 	beq	r2,zero,8112948c <_strtod_r+0x1558>
81129404:	889ffc2c 	andhi	r2,r17,32752
81129408:	00c1a834 	movhi	r3,1696
8112940c:	18801f36 	bltu	r3,r2,8112948c <_strtod_r+0x1558>
81129410:	1004d53a 	srli	r2,r2,20
81129414:	00c01ac4 	movi	r3,107
81129418:	1887c83a 	sub	r3,r3,r2
8112941c:	00bfffc4 	movi	r2,-1
81129420:	10c4983a 	sll	r2,r2,r3
81129424:	14bf7d1e 	bne	r2,r18,8112921c <__reset+0xfb10921c>
81129428:	00dffc34 	movhi	r3,32752
8112942c:	18ffffc4 	addi	r3,r3,-1
81129430:	88c03526 	beq	r17,r3,81129508 <_strtod_r+0x15d4>
81129434:	8c5ffc2c 	andhi	r17,r17,32752
81129438:	00800434 	movhi	r2,16
8112943c:	002b883a 	mov	r21,zero
81129440:	88ad883a 	add	r22,r17,r2
81129444:	003f8806 	br	81129268 <__reset+0xfb109268>
81129448:	01401a84 	movi	r5,106
8112944c:	d9400915 	stw	r5,36(sp)
81129450:	8ddffc2c 	andhi	r23,r17,32752
81129454:	b82ed53a 	srli	r23,r23,20
81129458:	00801ac4 	movi	r2,107
8112945c:	15c5c83a 	sub	r2,r2,r23
81129460:	00be8e0e 	bge	zero,r2,81128e9c <__reset+0xfb108e9c>
81129464:	00c007c4 	movi	r3,31
81129468:	18800a0e 	bge	r3,r2,81129494 <_strtod_r+0x1560>
8112946c:	00c00d04 	movi	r3,52
81129470:	0025883a 	mov	r18,zero
81129474:	1880270e 	bge	r3,r2,81129514 <_strtod_r+0x15e0>
81129478:	0440dc34 	movhi	r17,880
8112947c:	003e8706 	br	81128e9c <__reset+0xfb108e9c>
81129480:	d8000915 	stw	zero,36(sp)
81129484:	05fe6a16 	blt	zero,r23,81128e30 <__reset+0xfb108e30>
81129488:	003e8406 	br	81128e9c <__reset+0xfb108e9c>
8112948c:	00bfffc4 	movi	r2,-1
81129490:	003fe406 	br	81129424 <__reset+0xfb109424>
81129494:	00ffffc4 	movi	r3,-1
81129498:	1884983a 	sll	r2,r3,r2
8112949c:	14a4703a 	and	r18,r2,r18
811294a0:	003e7e06 	br	81128e9c <__reset+0xfb108e9c>
811294a4:	00bffc34 	movhi	r2,65520
811294a8:	b8af883a 	add	r23,r23,r2
811294ac:	057fffc4 	movi	r21,-1
811294b0:	00800434 	movhi	r2,16
811294b4:	1545883a 	add	r2,r2,r21
811294b8:	b8acb03a 	or	r22,r23,r2
811294bc:	003f6a06 	br	81129268 <__reset+0xfb109268>
811294c0:	01604574 	movhi	r5,33045
811294c4:	2969f504 	addi	r5,r5,-22572
811294c8:	d9800204 	addi	r6,sp,8
811294cc:	d9000604 	addi	r4,sp,24
811294d0:	112d8c00 	call	8112d8c0 <__hexnan>
811294d4:	00c00144 	movi	r3,5
811294d8:	10fb5c1e 	bne	r2,r3,8112824c <__reset+0xfb10824c>
811294dc:	dc400317 	ldw	r17,12(sp)
811294e0:	dc800217 	ldw	r18,8(sp)
811294e4:	8c5ffc34 	orhi	r17,r17,32752
811294e8:	003b5a06 	br	81128254 <__reset+0xfb108254>
811294ec:	480b883a 	mov	r5,r9
811294f0:	d9800617 	ldw	r6,24(sp)
811294f4:	4a400044 	addi	r9,r9,1
811294f8:	003eeb06 	br	811290a8 <__reset+0xfb1090a8>
811294fc:	1025883a 	mov	r18,r2
81129500:	1823883a 	mov	r17,r3
81129504:	003c4c06 	br	81128638 <__reset+0xfb108638>
81129508:	00ffffc4 	movi	r3,-1
8112950c:	10ffc91e 	bne	r2,r3,81129434 <__reset+0xfb109434>
81129510:	003da906 	br	81128bb8 <__reset+0xfb108bb8>
81129514:	10bff804 	addi	r2,r2,-32
81129518:	00ffffc4 	movi	r3,-1
8112951c:	1884983a 	sll	r2,r3,r2
81129520:	1462703a 	and	r17,r2,r17
81129524:	003e5d06 	br	81128e9c <__reset+0xfb108e9c>
81129528:	1025883a 	mov	r18,r2
8112952c:	1823883a 	mov	r17,r3
81129530:	003e5806 	br	81128e94 <__reset+0xfb108e94>

81129534 <strtod>:
81129534:	00a04574 	movhi	r2,33045
81129538:	10b34e04 	addi	r2,r2,-13000
8112953c:	280d883a 	mov	r6,r5
81129540:	200b883a 	mov	r5,r4
81129544:	11000017 	ldw	r4,0(r2)
81129548:	1127f341 	jmpi	81127f34 <_strtod_r>

8112954c <strtof>:
8112954c:	defffb04 	addi	sp,sp,-20
81129550:	de00012e 	bgeu	sp,et,81129558 <strtof+0xc>
81129554:	003b68fa 	trap	3
81129558:	dcc00315 	stw	r19,12(sp)
8112955c:	04e04574 	movhi	r19,33045
81129560:	9cf34e04 	addi	r19,r19,-13000
81129564:	280d883a 	mov	r6,r5
81129568:	200b883a 	mov	r5,r4
8112956c:	99000017 	ldw	r4,0(r19)
81129570:	dfc00415 	stw	ra,16(sp)
81129574:	dc800215 	stw	r18,8(sp)
81129578:	dc400115 	stw	r17,4(sp)
8112957c:	dc000015 	stw	r16,0(sp)
81129580:	1127f340 	call	81127f34 <_strtod_r>
81129584:	1009883a 	mov	r4,r2
81129588:	180b883a 	mov	r5,r3
8112958c:	1025883a 	mov	r18,r2
81129590:	1823883a 	mov	r17,r3
81129594:	111b0280 	call	8111b028 <__truncdfsf2>
81129598:	000b883a 	mov	r5,zero
8112959c:	1009883a 	mov	r4,r2
811295a0:	1021883a 	mov	r16,r2
811295a4:	112eae40 	call	8112eae4 <__eqsf2>
811295a8:	1000111e 	bne	r2,zero,811295f0 <strtof+0xa4>
811295ac:	000d883a 	mov	r6,zero
811295b0:	000f883a 	mov	r7,zero
811295b4:	9009883a 	mov	r4,r18
811295b8:	880b883a 	mov	r5,r17
811295bc:	112fe840 	call	8112fe84 <__eqdf2>
811295c0:	10000b26 	beq	r2,zero,811295f0 <strtof+0xa4>
811295c4:	98800017 	ldw	r2,0(r19)
811295c8:	00c00884 	movi	r3,34
811295cc:	10c00015 	stw	r3,0(r2)
811295d0:	8005883a 	mov	r2,r16
811295d4:	dfc00417 	ldw	ra,16(sp)
811295d8:	dcc00317 	ldw	r19,12(sp)
811295dc:	dc800217 	ldw	r18,8(sp)
811295e0:	dc400117 	ldw	r17,4(sp)
811295e4:	dc000017 	ldw	r16,0(sp)
811295e8:	dec00504 	addi	sp,sp,20
811295ec:	f800283a 	ret
811295f0:	015fe034 	movhi	r5,32640
811295f4:	297fffc4 	addi	r5,r5,-1
811295f8:	8009883a 	mov	r4,r16
811295fc:	112eb5c0 	call	8112eb5c <__gesf2>
81129600:	0080070e 	bge	zero,r2,81129620 <strtof+0xd4>
81129604:	01dffc34 	movhi	r7,32752
81129608:	39ffffc4 	addi	r7,r7,-1
8112960c:	01bfffc4 	movi	r6,-1
81129610:	9009883a 	mov	r4,r18
81129614:	880b883a 	mov	r5,r17
81129618:	112ff0c0 	call	8112ff0c <__gedf2>
8112961c:	00bfe90e 	bge	zero,r2,811295c4 <__reset+0xfb1095c4>
81129620:	017fe034 	movhi	r5,65408
81129624:	297fffc4 	addi	r5,r5,-1
81129628:	8009883a 	mov	r4,r16
8112962c:	112ec180 	call	8112ec18 <__lesf2>
81129630:	103fe70e 	bge	r2,zero,811295d0 <__reset+0xfb1095d0>
81129634:	01fffc34 	movhi	r7,65520
81129638:	39ffffc4 	addi	r7,r7,-1
8112963c:	01bfffc4 	movi	r6,-1
81129640:	9009883a 	mov	r4,r18
81129644:	880b883a 	mov	r5,r17
81129648:	112ffe80 	call	8112ffe8 <__ledf2>
8112964c:	103fdd0e 	bge	r2,zero,811295c4 <__reset+0xfb1095c4>
81129650:	003fdf06 	br	811295d0 <__reset+0xfb1095d0>

81129654 <_strtoll_r>:
81129654:	00a04574 	movhi	r2,33045
81129658:	defff304 	addi	sp,sp,-52
8112965c:	10b34c04 	addi	r2,r2,-13008
81129660:	de00012e 	bgeu	sp,et,81129668 <_strtoll_r+0x14>
81129664:	003b68fa 	trap	3
81129668:	dc800515 	stw	r18,20(sp)
8112966c:	14800017 	ldw	r18,0(r2)
81129670:	dd800915 	stw	r22,36(sp)
81129674:	dd400815 	stw	r21,32(sp)
81129678:	dcc00615 	stw	r19,24(sp)
8112967c:	d9000015 	stw	r4,0(sp)
81129680:	dfc00c15 	stw	ra,48(sp)
81129684:	df000b15 	stw	fp,44(sp)
81129688:	ddc00a15 	stw	r23,40(sp)
8112968c:	dd000715 	stw	r20,28(sp)
81129690:	dc400415 	stw	r17,16(sp)
81129694:	dc000315 	stw	r16,12(sp)
81129698:	282d883a 	mov	r22,r5
8112969c:	302b883a 	mov	r21,r6
811296a0:	3827883a 	mov	r19,r7
811296a4:	2809883a 	mov	r4,r5
811296a8:	24000003 	ldbu	r16,0(r4)
811296ac:	24400044 	addi	r17,r4,1
811296b0:	2007883a 	mov	r3,r4
811296b4:	9405883a 	add	r2,r18,r16
811296b8:	10800043 	ldbu	r2,1(r2)
811296bc:	8809883a 	mov	r4,r17
811296c0:	1080020c 	andi	r2,r2,8
811296c4:	103ff81e 	bne	r2,zero,811296a8 <__reset+0xfb1096a8>
811296c8:	00800b44 	movi	r2,45
811296cc:	80807826 	beq	r16,r2,811298b0 <_strtoll_r+0x25c>
811296d0:	00800ac4 	movi	r2,43
811296d4:	80807a26 	beq	r16,r2,811298c0 <_strtoll_r+0x26c>
811296d8:	0039883a 	mov	fp,zero
811296dc:	98004e26 	beq	r19,zero,81129818 <_strtoll_r+0x1c4>
811296e0:	00800404 	movi	r2,16
811296e4:	98808226 	beq	r19,r2,811298f0 <_strtoll_r+0x29c>
811296e8:	982fd7fa 	srai	r23,r19,31
811296ec:	9829883a 	mov	r20,r19
811296f0:	e0004f26 	beq	fp,zero,81129830 <_strtoll_r+0x1dc>
811296f4:	0017883a 	mov	r11,zero
811296f8:	02a00034 	movhi	r10,32768
811296fc:	5809883a 	mov	r4,r11
81129700:	500b883a 	mov	r5,r10
81129704:	a00d883a 	mov	r6,r20
81129708:	b80f883a 	mov	r7,r23
8112970c:	da800215 	stw	r10,8(sp)
81129710:	dac00115 	stw	r11,4(sp)
81129714:	112e3f00 	call	8112e3f0 <__umoddi3>
81129718:	dac00117 	ldw	r11,4(sp)
8112971c:	da800217 	ldw	r10,8(sp)
81129720:	a00d883a 	mov	r6,r20
81129724:	5809883a 	mov	r4,r11
81129728:	500b883a 	mov	r5,r10
8112972c:	b80f883a 	mov	r7,r23
81129730:	d8800115 	stw	r2,4(sp)
81129734:	112de700 	call	8112de70 <__udivdi3>
81129738:	9409883a 	add	r4,r18,r16
8112973c:	21000043 	ldbu	r4,1(r4)
81129740:	1019883a 	mov	r12,r2
81129744:	880b883a 	mov	r5,r17
81129748:	2240010c 	andi	r9,r4,4
8112974c:	0015883a 	mov	r10,zero
81129750:	000d883a 	mov	r6,zero
81129754:	000f883a 	mov	r7,zero
81129758:	03400044 	movi	r13,1
8112975c:	02ffffc4 	movi	r11,-1
81129760:	da000117 	ldw	r8,4(sp)
81129764:	48000d26 	beq	r9,zero,8112979c <_strtoll_r+0x148>
81129768:	843ff404 	addi	r16,r16,-48
8112976c:	84c0110e 	bge	r16,r19,811297b4 <_strtoll_r+0x160>
81129770:	52c00426 	beq	r10,r11,81129784 <_strtoll_r+0x130>
81129774:	19c00236 	bltu	r3,r7,81129780 <_strtoll_r+0x12c>
81129778:	38c0311e 	bne	r7,r3,81129840 <_strtoll_r+0x1ec>
8112977c:	6180302e 	bgeu	r12,r6,81129840 <_strtoll_r+0x1ec>
81129780:	02bfffc4 	movi	r10,-1
81129784:	2c000003 	ldbu	r16,0(r5)
81129788:	29400044 	addi	r5,r5,1
8112978c:	9409883a 	add	r4,r18,r16
81129790:	21000043 	ldbu	r4,1(r4)
81129794:	2240010c 	andi	r9,r4,4
81129798:	483ff31e 	bne	r9,zero,81129768 <__reset+0xfb109768>
8112979c:	210000cc 	andi	r4,r4,3
811297a0:	20000426 	beq	r4,zero,811297b4 <_strtoll_r+0x160>
811297a4:	23403426 	beq	r4,r13,81129878 <_strtoll_r+0x224>
811297a8:	008015c4 	movi	r2,87
811297ac:	80a1c83a 	sub	r16,r16,r2
811297b0:	84ffef16 	blt	r16,r19,81129770 <__reset+0xfb109770>
811297b4:	00bfffc4 	movi	r2,-1
811297b8:	50803426 	beq	r10,r2,8112988c <_strtoll_r+0x238>
811297bc:	e0000426 	beq	fp,zero,811297d0 <_strtoll_r+0x17c>
811297c0:	018dc83a 	sub	r6,zero,r6
811297c4:	3004c03a 	cmpne	r2,r6,zero
811297c8:	01e1c83a 	sub	r16,zero,r7
811297cc:	808fc83a 	sub	r7,r16,r2
811297d0:	3005883a 	mov	r2,r6
811297d4:	3807883a 	mov	r3,r7
811297d8:	a8000326 	beq	r21,zero,811297e8 <_strtoll_r+0x194>
811297dc:	5000321e 	bne	r10,zero,811298a8 <_strtoll_r+0x254>
811297e0:	b00b883a 	mov	r5,r22
811297e4:	a9400015 	stw	r5,0(r21)
811297e8:	dfc00c17 	ldw	ra,48(sp)
811297ec:	df000b17 	ldw	fp,44(sp)
811297f0:	ddc00a17 	ldw	r23,40(sp)
811297f4:	dd800917 	ldw	r22,36(sp)
811297f8:	dd400817 	ldw	r21,32(sp)
811297fc:	dd000717 	ldw	r20,28(sp)
81129800:	dcc00617 	ldw	r19,24(sp)
81129804:	dc800517 	ldw	r18,20(sp)
81129808:	dc400417 	ldw	r17,16(sp)
8112980c:	dc000317 	ldw	r16,12(sp)
81129810:	dec00d04 	addi	sp,sp,52
81129814:	f800283a 	ret
81129818:	00800c04 	movi	r2,48
8112981c:	80802c26 	beq	r16,r2,811298d0 <_strtoll_r+0x27c>
81129820:	05000284 	movi	r20,10
81129824:	002f883a 	mov	r23,zero
81129828:	a027883a 	mov	r19,r20
8112982c:	e03fb11e 	bne	fp,zero,811296f4 <__reset+0xfb1096f4>
81129830:	02a00034 	movhi	r10,32768
81129834:	52bfffc4 	addi	r10,r10,-1
81129838:	02ffffc4 	movi	r11,-1
8112983c:	003faf06 	br	811296fc <__reset+0xfb1096fc>
81129840:	33000f26 	beq	r6,r12,81129880 <_strtoll_r+0x22c>
81129844:	b985383a 	mul	r2,r23,r6
81129848:	3d0f383a 	mul	r7,r7,r20
8112984c:	3508383a 	mulxuu	r4,r6,r20
81129850:	350d383a 	mul	r6,r6,r20
81129854:	8013d7fa 	srai	r9,r16,31
81129858:	388f883a 	add	r7,r7,r2
8112985c:	818d883a 	add	r6,r16,r6
81129860:	390f883a 	add	r7,r7,r4
81129864:	3421803a 	cmpltu	r16,r6,r16
81129868:	49cf883a 	add	r7,r9,r7
8112986c:	81cf883a 	add	r7,r16,r7
81129870:	02800044 	movi	r10,1
81129874:	003fc306 	br	81129784 <__reset+0xfb109784>
81129878:	00800dc4 	movi	r2,55
8112987c:	003fcb06 	br	811297ac <__reset+0xfb1097ac>
81129880:	38fff01e 	bne	r7,r3,81129844 <__reset+0xfb109844>
81129884:	443fbe16 	blt	r8,r16,81129780 <__reset+0xfb109780>
81129888:	003fee06 	br	81129844 <__reset+0xfb109844>
8112988c:	e0002426 	beq	fp,zero,81129920 <_strtoll_r+0x2cc>
81129890:	0005883a 	mov	r2,zero
81129894:	00e00034 	movhi	r3,32768
81129898:	d9800017 	ldw	r6,0(sp)
8112989c:	01000884 	movi	r4,34
811298a0:	31000015 	stw	r4,0(r6)
811298a4:	a83fd026 	beq	r21,zero,811297e8 <__reset+0xfb1097e8>
811298a8:	297fffc4 	addi	r5,r5,-1
811298ac:	003fcd06 	br	811297e4 <__reset+0xfb1097e4>
811298b0:	1c400084 	addi	r17,r3,2
811298b4:	1c000043 	ldbu	r16,1(r3)
811298b8:	07000044 	movi	fp,1
811298bc:	003f8706 	br	811296dc <__reset+0xfb1096dc>
811298c0:	1c400084 	addi	r17,r3,2
811298c4:	1c000043 	ldbu	r16,1(r3)
811298c8:	0039883a 	mov	fp,zero
811298cc:	003f8306 	br	811296dc <__reset+0xfb1096dc>
811298d0:	88800003 	ldbu	r2,0(r17)
811298d4:	00c01604 	movi	r3,88
811298d8:	108037cc 	andi	r2,r2,223
811298dc:	10c00a26 	beq	r2,r3,81129908 <_strtoll_r+0x2b4>
811298e0:	05000204 	movi	r20,8
811298e4:	002f883a 	mov	r23,zero
811298e8:	a027883a 	mov	r19,r20
811298ec:	003f8006 	br	811296f0 <__reset+0xfb1096f0>
811298f0:	00800c04 	movi	r2,48
811298f4:	80800e1e 	bne	r16,r2,81129930 <_strtoll_r+0x2dc>
811298f8:	88800003 	ldbu	r2,0(r17)
811298fc:	00c01604 	movi	r3,88
81129900:	108037cc 	andi	r2,r2,223
81129904:	10c00a1e 	bne	r2,r3,81129930 <_strtoll_r+0x2dc>
81129908:	05000404 	movi	r20,16
8112990c:	8c000043 	ldbu	r16,1(r17)
81129910:	002f883a 	mov	r23,zero
81129914:	8c400084 	addi	r17,r17,2
81129918:	a027883a 	mov	r19,r20
8112991c:	003f7406 	br	811296f0 <__reset+0xfb1096f0>
81129920:	00e00034 	movhi	r3,32768
81129924:	18ffffc4 	addi	r3,r3,-1
81129928:	5005883a 	mov	r2,r10
8112992c:	003fda06 	br	81129898 <__reset+0xfb109898>
81129930:	9829883a 	mov	r20,r19
81129934:	002f883a 	mov	r23,zero
81129938:	003f6d06 	br	811296f0 <__reset+0xfb1096f0>

8112993c <_strtoul_r>:
8112993c:	00a04574 	movhi	r2,33045
81129940:	defff604 	addi	sp,sp,-40
81129944:	10b34c04 	addi	r2,r2,-13008
81129948:	de00012e 	bgeu	sp,et,81129950 <_strtoul_r+0x14>
8112994c:	003b68fa 	trap	3
81129950:	dc800315 	stw	r18,12(sp)
81129954:	14800017 	ldw	r18,0(r2)
81129958:	dd400615 	stw	r21,24(sp)
8112995c:	dd000515 	stw	r20,20(sp)
81129960:	dcc00415 	stw	r19,16(sp)
81129964:	2029883a 	mov	r20,r4
81129968:	dfc00915 	stw	ra,36(sp)
8112996c:	ddc00815 	stw	r23,32(sp)
81129970:	dd800715 	stw	r22,28(sp)
81129974:	dc400215 	stw	r17,8(sp)
81129978:	dc000115 	stw	r16,4(sp)
8112997c:	2827883a 	mov	r19,r5
81129980:	382b883a 	mov	r21,r7
81129984:	2809883a 	mov	r4,r5
81129988:	24000003 	ldbu	r16,0(r4)
8112998c:	24400044 	addi	r17,r4,1
81129990:	2007883a 	mov	r3,r4
81129994:	9405883a 	add	r2,r18,r16
81129998:	10800043 	ldbu	r2,1(r2)
8112999c:	8809883a 	mov	r4,r17
811299a0:	1080020c 	andi	r2,r2,8
811299a4:	103ff81e 	bne	r2,zero,81129988 <__reset+0xfb109988>
811299a8:	00800b44 	movi	r2,45
811299ac:	80805326 	beq	r16,r2,81129afc <_strtoul_r+0x1c0>
811299b0:	00800ac4 	movi	r2,43
811299b4:	80805526 	beq	r16,r2,81129b0c <_strtoul_r+0x1d0>
811299b8:	002f883a 	mov	r23,zero
811299bc:	a8000f26 	beq	r21,zero,811299fc <_strtoul_r+0xc0>
811299c0:	00800404 	movi	r2,16
811299c4:	a8805f26 	beq	r21,r2,81129b44 <_strtoul_r+0x208>
811299c8:	013fffc4 	movi	r4,-1
811299cc:	a80b883a 	mov	r5,r21
811299d0:	d9800015 	stw	r6,0(sp)
811299d4:	112ea280 	call	8112ea28 <__udivsi3>
811299d8:	a80b883a 	mov	r5,r21
811299dc:	013fffc4 	movi	r4,-1
811299e0:	102d883a 	mov	r22,r2
811299e4:	112ea8c0 	call	8112ea8c <__umodsi3>
811299e8:	d9800017 	ldw	r6,0(sp)
811299ec:	1019883a 	mov	r12,r2
811299f0:	a817883a 	mov	r11,r21
811299f4:	b00f883a 	mov	r7,r22
811299f8:	00000706 	br	81129a18 <_strtoul_r+0xdc>
811299fc:	00800c04 	movi	r2,48
81129a00:	80804626 	beq	r16,r2,81129b1c <_strtoul_r+0x1e0>
81129a04:	05400284 	movi	r21,10
81129a08:	01c666b4 	movhi	r7,6554
81129a0c:	03000144 	movi	r12,5
81129a10:	39e66644 	addi	r7,r7,-26215
81129a14:	a817883a 	mov	r11,r21
81129a18:	9407883a 	add	r3,r18,r16
81129a1c:	18c00043 	ldbu	r3,1(r3)
81129a20:	8809883a 	mov	r4,r17
81129a24:	0011883a 	mov	r8,zero
81129a28:	1940010c 	andi	r5,r3,4
81129a2c:	0005883a 	mov	r2,zero
81129a30:	02800044 	movi	r10,1
81129a34:	027fffc4 	movi	r9,-1
81129a38:	28000e26 	beq	r5,zero,81129a74 <_strtoul_r+0x138>
81129a3c:	843ff404 	addi	r16,r16,-48
81129a40:	8540120e 	bge	r16,r21,81129a8c <_strtoul_r+0x150>
81129a44:	42400526 	beq	r8,r9,81129a5c <_strtoul_r+0x120>
81129a48:	38802236 	bltu	r7,r2,81129ad4 <_strtoul_r+0x198>
81129a4c:	11c02026 	beq	r2,r7,81129ad0 <_strtoul_r+0x194>
81129a50:	12c5383a 	mul	r2,r2,r11
81129a54:	02000044 	movi	r8,1
81129a58:	8085883a 	add	r2,r16,r2
81129a5c:	24000003 	ldbu	r16,0(r4)
81129a60:	21000044 	addi	r4,r4,1
81129a64:	9407883a 	add	r3,r18,r16
81129a68:	18c00043 	ldbu	r3,1(r3)
81129a6c:	1940010c 	andi	r5,r3,4
81129a70:	283ff21e 	bne	r5,zero,81129a3c <__reset+0xfb109a3c>
81129a74:	18c000cc 	andi	r3,r3,3
81129a78:	18000426 	beq	r3,zero,81129a8c <_strtoul_r+0x150>
81129a7c:	1a801726 	beq	r3,r10,81129adc <_strtoul_r+0x1a0>
81129a80:	00c015c4 	movi	r3,87
81129a84:	80e1c83a 	sub	r16,r16,r3
81129a88:	857fee16 	blt	r16,r21,81129a44 <__reset+0xfb109a44>
81129a8c:	40001516 	blt	r8,zero,81129ae4 <_strtoul_r+0x1a8>
81129a90:	b8000126 	beq	r23,zero,81129a98 <_strtoul_r+0x15c>
81129a94:	0085c83a 	sub	r2,zero,r2
81129a98:	30000226 	beq	r6,zero,81129aa4 <_strtoul_r+0x168>
81129a9c:	4000151e 	bne	r8,zero,81129af4 <_strtoul_r+0x1b8>
81129aa0:	34c00015 	stw	r19,0(r6)
81129aa4:	dfc00917 	ldw	ra,36(sp)
81129aa8:	ddc00817 	ldw	r23,32(sp)
81129aac:	dd800717 	ldw	r22,28(sp)
81129ab0:	dd400617 	ldw	r21,24(sp)
81129ab4:	dd000517 	ldw	r20,20(sp)
81129ab8:	dcc00417 	ldw	r19,16(sp)
81129abc:	dc800317 	ldw	r18,12(sp)
81129ac0:	dc400217 	ldw	r17,8(sp)
81129ac4:	dc000117 	ldw	r16,4(sp)
81129ac8:	dec00a04 	addi	sp,sp,40
81129acc:	f800283a 	ret
81129ad0:	643fdf0e 	bge	r12,r16,81129a50 <__reset+0xfb109a50>
81129ad4:	023fffc4 	movi	r8,-1
81129ad8:	003fe006 	br	81129a5c <__reset+0xfb109a5c>
81129adc:	00c00dc4 	movi	r3,55
81129ae0:	003fe806 	br	81129a84 <__reset+0xfb109a84>
81129ae4:	00800884 	movi	r2,34
81129ae8:	a0800015 	stw	r2,0(r20)
81129aec:	00bfffc4 	movi	r2,-1
81129af0:	303fec26 	beq	r6,zero,81129aa4 <__reset+0xfb109aa4>
81129af4:	24ffffc4 	addi	r19,r4,-1
81129af8:	003fe906 	br	81129aa0 <__reset+0xfb109aa0>
81129afc:	1c400084 	addi	r17,r3,2
81129b00:	1c000043 	ldbu	r16,1(r3)
81129b04:	05c00044 	movi	r23,1
81129b08:	003fac06 	br	811299bc <__reset+0xfb1099bc>
81129b0c:	1c400084 	addi	r17,r3,2
81129b10:	1c000043 	ldbu	r16,1(r3)
81129b14:	002f883a 	mov	r23,zero
81129b18:	003fa806 	br	811299bc <__reset+0xfb1099bc>
81129b1c:	88800003 	ldbu	r2,0(r17)
81129b20:	00c01604 	movi	r3,88
81129b24:	108037cc 	andi	r2,r2,223
81129b28:	10c00c26 	beq	r2,r3,81129b5c <_strtoul_r+0x220>
81129b2c:	05400204 	movi	r21,8
81129b30:	01c80034 	movhi	r7,8192
81129b34:	030001c4 	movi	r12,7
81129b38:	39ffffc4 	addi	r7,r7,-1
81129b3c:	a817883a 	mov	r11,r21
81129b40:	003fb506 	br	81129a18 <__reset+0xfb109a18>
81129b44:	00800c04 	movi	r2,48
81129b48:	80800c1e 	bne	r16,r2,81129b7c <_strtoul_r+0x240>
81129b4c:	88800003 	ldbu	r2,0(r17)
81129b50:	00c01604 	movi	r3,88
81129b54:	108037cc 	andi	r2,r2,223
81129b58:	10c0081e 	bne	r2,r3,81129b7c <_strtoul_r+0x240>
81129b5c:	02c00404 	movi	r11,16
81129b60:	05840034 	movhi	r22,4096
81129b64:	8c000043 	ldbu	r16,1(r17)
81129b68:	030003c4 	movi	r12,15
81129b6c:	8c400084 	addi	r17,r17,2
81129b70:	b5bfffc4 	addi	r22,r22,-1
81129b74:	582b883a 	mov	r21,r11
81129b78:	003f9e06 	br	811299f4 <__reset+0xfb1099f4>
81129b7c:	01c40034 	movhi	r7,4096
81129b80:	030003c4 	movi	r12,15
81129b84:	39ffffc4 	addi	r7,r7,-1
81129b88:	a817883a 	mov	r11,r21
81129b8c:	003fa206 	br	81129a18 <__reset+0xfb109a18>

81129b90 <strtoul>:
81129b90:	00a04574 	movhi	r2,33045
81129b94:	10b34e04 	addi	r2,r2,-13000
81129b98:	300f883a 	mov	r7,r6
81129b9c:	280d883a 	mov	r6,r5
81129ba0:	200b883a 	mov	r5,r4
81129ba4:	11000017 	ldw	r4,0(r2)
81129ba8:	112993c1 	jmpi	8112993c <_strtoul_r>

81129bac <_strtoull_r>:
81129bac:	00a04574 	movhi	r2,33045
81129bb0:	defff404 	addi	sp,sp,-48
81129bb4:	10b34c04 	addi	r2,r2,-13008
81129bb8:	de00012e 	bgeu	sp,et,81129bc0 <_strtoull_r+0x14>
81129bbc:	003b68fa 	trap	3
81129bc0:	dc400315 	stw	r17,12(sp)
81129bc4:	14400017 	ldw	r17,0(r2)
81129bc8:	dd400715 	stw	r21,28(sp)
81129bcc:	dd000615 	stw	r20,24(sp)
81129bd0:	dcc00515 	stw	r19,20(sp)
81129bd4:	dc800415 	stw	r18,16(sp)
81129bd8:	dfc00b15 	stw	ra,44(sp)
81129bdc:	df000a15 	stw	fp,40(sp)
81129be0:	ddc00915 	stw	r23,36(sp)
81129be4:	dd800815 	stw	r22,32(sp)
81129be8:	dc000215 	stw	r16,8(sp)
81129bec:	2827883a 	mov	r19,r5
81129bf0:	202b883a 	mov	r21,r4
81129bf4:	3029883a 	mov	r20,r6
81129bf8:	3825883a 	mov	r18,r7
81129bfc:	2807883a 	mov	r3,r5
81129c00:	1c000003 	ldbu	r16,0(r3)
81129c04:	1f000044 	addi	fp,r3,1
81129c08:	1809883a 	mov	r4,r3
81129c0c:	8c05883a 	add	r2,r17,r16
81129c10:	10800043 	ldbu	r2,1(r2)
81129c14:	e007883a 	mov	r3,fp
81129c18:	1080020c 	andi	r2,r2,8
81129c1c:	103ff81e 	bne	r2,zero,81129c00 <__reset+0xfb109c00>
81129c20:	00800b44 	movi	r2,45
81129c24:	80806e26 	beq	r16,r2,81129de0 <_strtoull_r+0x234>
81129c28:	00800ac4 	movi	r2,43
81129c2c:	80807026 	beq	r16,r2,81129df0 <_strtoull_r+0x244>
81129c30:	002f883a 	mov	r23,zero
81129c34:	90001426 	beq	r18,zero,81129c88 <_strtoull_r+0xdc>
81129c38:	00800404 	movi	r2,16
81129c3c:	90807c26 	beq	r18,r2,81129e30 <_strtoull_r+0x284>
81129c40:	902dd7fa 	srai	r22,r18,31
81129c44:	013fffc4 	movi	r4,-1
81129c48:	200b883a 	mov	r5,r4
81129c4c:	900d883a 	mov	r6,r18
81129c50:	b00f883a 	mov	r7,r22
81129c54:	112de700 	call	8112de70 <__udivdi3>
81129c58:	013fffc4 	movi	r4,-1
81129c5c:	900d883a 	mov	r6,r18
81129c60:	b00f883a 	mov	r7,r22
81129c64:	200b883a 	mov	r5,r4
81129c68:	d8c00115 	stw	r3,4(sp)
81129c6c:	d8800015 	stw	r2,0(sp)
81129c70:	112e3f00 	call	8112e3f0 <__umoddi3>
81129c74:	101b883a 	mov	r13,r2
81129c78:	9015883a 	mov	r10,r18
81129c7c:	dac00017 	ldw	r11,0(sp)
81129c80:	da000117 	ldw	r8,4(sp)
81129c84:	00000a06 	br	81129cb0 <_strtoull_r+0x104>
81129c88:	00800c04 	movi	r2,48
81129c8c:	80805c26 	beq	r16,r2,81129e00 <_strtoull_r+0x254>
81129c90:	02800284 	movi	r10,10
81129c94:	02e666b4 	movhi	r11,39322
81129c98:	020666b4 	movhi	r8,6554
81129c9c:	03400144 	movi	r13,5
81129ca0:	5ae66644 	addi	r11,r11,-26215
81129ca4:	42266644 	addi	r8,r8,-26215
81129ca8:	002d883a 	mov	r22,zero
81129cac:	5025883a 	mov	r18,r10
81129cb0:	8c0b883a 	add	r5,r17,r16
81129cb4:	29400043 	ldbu	r5,1(r5)
81129cb8:	e009883a 	mov	r4,fp
81129cbc:	000f883a 	mov	r7,zero
81129cc0:	2980010c 	andi	r6,r5,4
81129cc4:	0005883a 	mov	r2,zero
81129cc8:	0007883a 	mov	r3,zero
81129ccc:	03000044 	movi	r12,1
81129cd0:	027fffc4 	movi	r9,-1
81129cd4:	30000d26 	beq	r6,zero,81129d0c <_strtoull_r+0x160>
81129cd8:	843ff404 	addi	r16,r16,-48
81129cdc:	8480110e 	bge	r16,r18,81129d24 <_strtoull_r+0x178>
81129ce0:	3a400426 	beq	r7,r9,81129cf4 <_strtoull_r+0x148>
81129ce4:	40c00236 	bltu	r8,r3,81129cf0 <_strtoull_r+0x144>
81129ce8:	1a00231e 	bne	r3,r8,81129d78 <_strtoull_r+0x1cc>
81129cec:	5880222e 	bgeu	r11,r2,81129d78 <_strtoull_r+0x1cc>
81129cf0:	01ffffc4 	movi	r7,-1
81129cf4:	24000003 	ldbu	r16,0(r4)
81129cf8:	21000044 	addi	r4,r4,1
81129cfc:	8c0b883a 	add	r5,r17,r16
81129d00:	29400043 	ldbu	r5,1(r5)
81129d04:	2980010c 	andi	r6,r5,4
81129d08:	303ff31e 	bne	r6,zero,81129cd8 <__reset+0xfb109cd8>
81129d0c:	294000cc 	andi	r5,r5,3
81129d10:	28000426 	beq	r5,zero,81129d24 <_strtoull_r+0x178>
81129d14:	2b002626 	beq	r5,r12,81129db0 <_strtoull_r+0x204>
81129d18:	014015c4 	movi	r5,87
81129d1c:	8161c83a 	sub	r16,r16,r5
81129d20:	84bfef16 	blt	r16,r18,81129ce0 <__reset+0xfb109ce0>
81129d24:	38002716 	blt	r7,zero,81129dc4 <_strtoull_r+0x218>
81129d28:	b8000426 	beq	r23,zero,81129d3c <_strtoull_r+0x190>
81129d2c:	0085c83a 	sub	r2,zero,r2
81129d30:	100ac03a 	cmpne	r5,r2,zero
81129d34:	00e1c83a 	sub	r16,zero,r3
81129d38:	8147c83a 	sub	r3,r16,r5
81129d3c:	a0000226 	beq	r20,zero,81129d48 <_strtoull_r+0x19c>
81129d40:	3800251e 	bne	r7,zero,81129dd8 <_strtoull_r+0x22c>
81129d44:	a4c00015 	stw	r19,0(r20)
81129d48:	dfc00b17 	ldw	ra,44(sp)
81129d4c:	df000a17 	ldw	fp,40(sp)
81129d50:	ddc00917 	ldw	r23,36(sp)
81129d54:	dd800817 	ldw	r22,32(sp)
81129d58:	dd400717 	ldw	r21,28(sp)
81129d5c:	dd000617 	ldw	r20,24(sp)
81129d60:	dcc00517 	ldw	r19,20(sp)
81129d64:	dc800417 	ldw	r18,16(sp)
81129d68:	dc400317 	ldw	r17,12(sp)
81129d6c:	dc000217 	ldw	r16,8(sp)
81129d70:	dec00c04 	addi	sp,sp,48
81129d74:	f800283a 	ret
81129d78:	12c00f26 	beq	r2,r11,81129db8 <_strtoull_r+0x20c>
81129d7c:	b08d383a 	mul	r6,r22,r2
81129d80:	1a87383a 	mul	r3,r3,r10
81129d84:	128a383a 	mulxuu	r5,r2,r10
81129d88:	1285383a 	mul	r2,r2,r10
81129d8c:	800fd7fa 	srai	r7,r16,31
81129d90:	1987883a 	add	r3,r3,r6
81129d94:	8085883a 	add	r2,r16,r2
81129d98:	1947883a 	add	r3,r3,r5
81129d9c:	38c7883a 	add	r3,r7,r3
81129da0:	1421803a 	cmpltu	r16,r2,r16
81129da4:	80c7883a 	add	r3,r16,r3
81129da8:	01c00044 	movi	r7,1
81129dac:	003fd106 	br	81129cf4 <__reset+0xfb109cf4>
81129db0:	01400dc4 	movi	r5,55
81129db4:	003fd906 	br	81129d1c <__reset+0xfb109d1c>
81129db8:	1a3ff01e 	bne	r3,r8,81129d7c <__reset+0xfb109d7c>
81129dbc:	6c3fcc16 	blt	r13,r16,81129cf0 <__reset+0xfb109cf0>
81129dc0:	003fee06 	br	81129d7c <__reset+0xfb109d7c>
81129dc4:	00800884 	movi	r2,34
81129dc8:	a8800015 	stw	r2,0(r21)
81129dcc:	00bfffc4 	movi	r2,-1
81129dd0:	1007883a 	mov	r3,r2
81129dd4:	a03fdc26 	beq	r20,zero,81129d48 <__reset+0xfb109d48>
81129dd8:	24ffffc4 	addi	r19,r4,-1
81129ddc:	003fd906 	br	81129d44 <__reset+0xfb109d44>
81129de0:	27000084 	addi	fp,r4,2
81129de4:	24000043 	ldbu	r16,1(r4)
81129de8:	05c00044 	movi	r23,1
81129dec:	003f9106 	br	81129c34 <__reset+0xfb109c34>
81129df0:	27000084 	addi	fp,r4,2
81129df4:	24000043 	ldbu	r16,1(r4)
81129df8:	002f883a 	mov	r23,zero
81129dfc:	003f8d06 	br	81129c34 <__reset+0xfb109c34>
81129e00:	e0800003 	ldbu	r2,0(fp)
81129e04:	00c01604 	movi	r3,88
81129e08:	108037cc 	andi	r2,r2,223
81129e0c:	10c00e26 	beq	r2,r3,81129e48 <_strtoull_r+0x29c>
81129e10:	02800204 	movi	r10,8
81129e14:	02ffffc4 	movi	r11,-1
81129e18:	02080034 	movhi	r8,8192
81129e1c:	034001c4 	movi	r13,7
81129e20:	42d1883a 	add	r8,r8,r11
81129e24:	002d883a 	mov	r22,zero
81129e28:	5025883a 	mov	r18,r10
81129e2c:	003fa006 	br	81129cb0 <__reset+0xfb109cb0>
81129e30:	00800c04 	movi	r2,48
81129e34:	80800e1e 	bne	r16,r2,81129e70 <_strtoull_r+0x2c4>
81129e38:	e0800003 	ldbu	r2,0(fp)
81129e3c:	00c01604 	movi	r3,88
81129e40:	108037cc 	andi	r2,r2,223
81129e44:	10c00a1e 	bne	r2,r3,81129e70 <_strtoull_r+0x2c4>
81129e48:	02800404 	movi	r10,16
81129e4c:	02ffffc4 	movi	r11,-1
81129e50:	02040034 	movhi	r8,4096
81129e54:	e4000043 	ldbu	r16,1(fp)
81129e58:	034003c4 	movi	r13,15
81129e5c:	e7000084 	addi	fp,fp,2
81129e60:	42d1883a 	add	r8,r8,r11
81129e64:	002d883a 	mov	r22,zero
81129e68:	5025883a 	mov	r18,r10
81129e6c:	003f9006 	br	81129cb0 <__reset+0xfb109cb0>
81129e70:	02ffffc4 	movi	r11,-1
81129e74:	02040034 	movhi	r8,4096
81129e78:	034003c4 	movi	r13,15
81129e7c:	42d1883a 	add	r8,r8,r11
81129e80:	9015883a 	mov	r10,r18
81129e84:	002d883a 	mov	r22,zero
81129e88:	003f8906 	br	81129cb0 <__reset+0xfb109cb0>

81129e8c <__ssprint_r>:
81129e8c:	defff604 	addi	sp,sp,-40
81129e90:	de00012e 	bgeu	sp,et,81129e98 <__ssprint_r+0xc>
81129e94:	003b68fa 	trap	3
81129e98:	30800217 	ldw	r2,8(r6)
81129e9c:	dc800215 	stw	r18,8(sp)
81129ea0:	dfc00915 	stw	ra,36(sp)
81129ea4:	df000815 	stw	fp,32(sp)
81129ea8:	ddc00715 	stw	r23,28(sp)
81129eac:	dd800615 	stw	r22,24(sp)
81129eb0:	dd400515 	stw	r21,20(sp)
81129eb4:	dd000415 	stw	r20,16(sp)
81129eb8:	dcc00315 	stw	r19,12(sp)
81129ebc:	dc400115 	stw	r17,4(sp)
81129ec0:	dc000015 	stw	r16,0(sp)
81129ec4:	3025883a 	mov	r18,r6
81129ec8:	10005826 	beq	r2,zero,8112a02c <__ssprint_r+0x1a0>
81129ecc:	2027883a 	mov	r19,r4
81129ed0:	35c00017 	ldw	r23,0(r6)
81129ed4:	29000017 	ldw	r4,0(r5)
81129ed8:	28800217 	ldw	r2,8(r5)
81129edc:	2823883a 	mov	r17,r5
81129ee0:	0039883a 	mov	fp,zero
81129ee4:	0021883a 	mov	r16,zero
81129ee8:	80003926 	beq	r16,zero,81129fd0 <__ssprint_r+0x144>
81129eec:	102b883a 	mov	r21,r2
81129ef0:	102d883a 	mov	r22,r2
81129ef4:	80803a36 	bltu	r16,r2,81129fe0 <__ssprint_r+0x154>
81129ef8:	88c0030b 	ldhu	r3,12(r17)
81129efc:	1881200c 	andi	r2,r3,1152
81129f00:	10002626 	beq	r2,zero,81129f9c <__ssprint_r+0x110>
81129f04:	88800517 	ldw	r2,20(r17)
81129f08:	89400417 	ldw	r5,16(r17)
81129f0c:	81800044 	addi	r6,r16,1
81129f10:	108f883a 	add	r7,r2,r2
81129f14:	3885883a 	add	r2,r7,r2
81129f18:	100ed7fa 	srli	r7,r2,31
81129f1c:	216dc83a 	sub	r22,r4,r5
81129f20:	3589883a 	add	r4,r6,r22
81129f24:	3885883a 	add	r2,r7,r2
81129f28:	102bd07a 	srai	r21,r2,1
81129f2c:	a80d883a 	mov	r6,r21
81129f30:	a900022e 	bgeu	r21,r4,81129f3c <__ssprint_r+0xb0>
81129f34:	202b883a 	mov	r21,r4
81129f38:	200d883a 	mov	r6,r4
81129f3c:	18c1000c 	andi	r3,r3,1024
81129f40:	18002a26 	beq	r3,zero,81129fec <__ssprint_r+0x160>
81129f44:	300b883a 	mov	r5,r6
81129f48:	9809883a 	mov	r4,r19
81129f4c:	111bc2c0 	call	8111bc2c <_malloc_r>
81129f50:	1029883a 	mov	r20,r2
81129f54:	10002c26 	beq	r2,zero,8112a008 <__ssprint_r+0x17c>
81129f58:	89400417 	ldw	r5,16(r17)
81129f5c:	b00d883a 	mov	r6,r22
81129f60:	1009883a 	mov	r4,r2
81129f64:	111c4400 	call	8111c440 <memcpy>
81129f68:	8880030b 	ldhu	r2,12(r17)
81129f6c:	00fedfc4 	movi	r3,-1153
81129f70:	10c4703a 	and	r2,r2,r3
81129f74:	10802014 	ori	r2,r2,128
81129f78:	8880030d 	sth	r2,12(r17)
81129f7c:	a589883a 	add	r4,r20,r22
81129f80:	adadc83a 	sub	r22,r21,r22
81129f84:	8d400515 	stw	r21,20(r17)
81129f88:	8d800215 	stw	r22,8(r17)
81129f8c:	8d000415 	stw	r20,16(r17)
81129f90:	89000015 	stw	r4,0(r17)
81129f94:	802b883a 	mov	r21,r16
81129f98:	802d883a 	mov	r22,r16
81129f9c:	b00d883a 	mov	r6,r22
81129fa0:	e00b883a 	mov	r5,fp
81129fa4:	11265140 	call	81126514 <memmove>
81129fa8:	88800217 	ldw	r2,8(r17)
81129fac:	89000017 	ldw	r4,0(r17)
81129fb0:	90c00217 	ldw	r3,8(r18)
81129fb4:	1545c83a 	sub	r2,r2,r21
81129fb8:	2589883a 	add	r4,r4,r22
81129fbc:	88800215 	stw	r2,8(r17)
81129fc0:	89000015 	stw	r4,0(r17)
81129fc4:	1c21c83a 	sub	r16,r3,r16
81129fc8:	94000215 	stw	r16,8(r18)
81129fcc:	80001726 	beq	r16,zero,8112a02c <__ssprint_r+0x1a0>
81129fd0:	bf000017 	ldw	fp,0(r23)
81129fd4:	bc000117 	ldw	r16,4(r23)
81129fd8:	bdc00204 	addi	r23,r23,8
81129fdc:	003fc206 	br	81129ee8 <__reset+0xfb109ee8>
81129fe0:	802b883a 	mov	r21,r16
81129fe4:	802d883a 	mov	r22,r16
81129fe8:	003fec06 	br	81129f9c <__reset+0xfb109f9c>
81129fec:	9809883a 	mov	r4,r19
81129ff0:	11277340 	call	81127734 <_realloc_r>
81129ff4:	1029883a 	mov	r20,r2
81129ff8:	103fe01e 	bne	r2,zero,81129f7c <__reset+0xfb109f7c>
81129ffc:	89400417 	ldw	r5,16(r17)
8112a000:	9809883a 	mov	r4,r19
8112a004:	11256a00 	call	811256a0 <_free_r>
8112a008:	88c0030b 	ldhu	r3,12(r17)
8112a00c:	00800304 	movi	r2,12
8112a010:	98800015 	stw	r2,0(r19)
8112a014:	18c01014 	ori	r3,r3,64
8112a018:	88c0030d 	sth	r3,12(r17)
8112a01c:	00bfffc4 	movi	r2,-1
8112a020:	90000215 	stw	zero,8(r18)
8112a024:	90000115 	stw	zero,4(r18)
8112a028:	00000206 	br	8112a034 <__ssprint_r+0x1a8>
8112a02c:	90000115 	stw	zero,4(r18)
8112a030:	0005883a 	mov	r2,zero
8112a034:	dfc00917 	ldw	ra,36(sp)
8112a038:	df000817 	ldw	fp,32(sp)
8112a03c:	ddc00717 	ldw	r23,28(sp)
8112a040:	dd800617 	ldw	r22,24(sp)
8112a044:	dd400517 	ldw	r21,20(sp)
8112a048:	dd000417 	ldw	r20,16(sp)
8112a04c:	dcc00317 	ldw	r19,12(sp)
8112a050:	dc800217 	ldw	r18,8(sp)
8112a054:	dc400117 	ldw	r17,4(sp)
8112a058:	dc000017 	ldw	r16,0(sp)
8112a05c:	dec00a04 	addi	sp,sp,40
8112a060:	f800283a 	ret

8112a064 <___svfiprintf_internal_r>:
8112a064:	deffc804 	addi	sp,sp,-224
8112a068:	de00012e 	bgeu	sp,et,8112a070 <___svfiprintf_internal_r+0xc>
8112a06c:	003b68fa 	trap	3
8112a070:	2880030b 	ldhu	r2,12(r5)
8112a074:	dcc03115 	stw	r19,196(sp)
8112a078:	dfc03715 	stw	ra,220(sp)
8112a07c:	df003615 	stw	fp,216(sp)
8112a080:	ddc03515 	stw	r23,212(sp)
8112a084:	dd803415 	stw	r22,208(sp)
8112a088:	dd403315 	stw	r21,204(sp)
8112a08c:	dd003215 	stw	r20,200(sp)
8112a090:	dc803015 	stw	r18,192(sp)
8112a094:	dc402f15 	stw	r17,188(sp)
8112a098:	dc002e15 	stw	r16,184(sp)
8112a09c:	d9402715 	stw	r5,156(sp)
8112a0a0:	d9002a15 	stw	r4,168(sp)
8112a0a4:	1080200c 	andi	r2,r2,128
8112a0a8:	d9c02315 	stw	r7,140(sp)
8112a0ac:	3027883a 	mov	r19,r6
8112a0b0:	10000226 	beq	r2,zero,8112a0bc <___svfiprintf_internal_r+0x58>
8112a0b4:	28800417 	ldw	r2,16(r5)
8112a0b8:	10041d26 	beq	r2,zero,8112b130 <___svfiprintf_internal_r+0x10cc>
8112a0bc:	dac01a04 	addi	r11,sp,104
8112a0c0:	dac01e15 	stw	r11,120(sp)
8112a0c4:	d8801e17 	ldw	r2,120(sp)
8112a0c8:	dac019c4 	addi	r11,sp,103
8112a0cc:	dd402a17 	ldw	r21,168(sp)
8112a0d0:	ddc02717 	ldw	r23,156(sp)
8112a0d4:	05a04574 	movhi	r22,33045
8112a0d8:	05204574 	movhi	r20,33045
8112a0dc:	dac01f15 	stw	r11,124(sp)
8112a0e0:	12d7c83a 	sub	r11,r2,r11
8112a0e4:	b5aa0d04 	addi	r22,r22,-22476
8112a0e8:	a52a0904 	addi	r20,r20,-22492
8112a0ec:	dec01a15 	stw	sp,104(sp)
8112a0f0:	d8001c15 	stw	zero,112(sp)
8112a0f4:	d8001b15 	stw	zero,108(sp)
8112a0f8:	d811883a 	mov	r8,sp
8112a0fc:	d8002915 	stw	zero,164(sp)
8112a100:	d8002515 	stw	zero,148(sp)
8112a104:	dac02b15 	stw	r11,172(sp)
8112a108:	98800007 	ldb	r2,0(r19)
8112a10c:	1002dd26 	beq	r2,zero,8112ac84 <___svfiprintf_internal_r+0xc20>
8112a110:	00c00944 	movi	r3,37
8112a114:	9823883a 	mov	r17,r19
8112a118:	10c0021e 	bne	r2,r3,8112a124 <___svfiprintf_internal_r+0xc0>
8112a11c:	00001406 	br	8112a170 <___svfiprintf_internal_r+0x10c>
8112a120:	10c00326 	beq	r2,r3,8112a130 <___svfiprintf_internal_r+0xcc>
8112a124:	8c400044 	addi	r17,r17,1
8112a128:	88800007 	ldb	r2,0(r17)
8112a12c:	103ffc1e 	bne	r2,zero,8112a120 <__reset+0xfb10a120>
8112a130:	8ce1c83a 	sub	r16,r17,r19
8112a134:	80000e26 	beq	r16,zero,8112a170 <___svfiprintf_internal_r+0x10c>
8112a138:	d8c01c17 	ldw	r3,112(sp)
8112a13c:	d8801b17 	ldw	r2,108(sp)
8112a140:	44c00015 	stw	r19,0(r8)
8112a144:	1c07883a 	add	r3,r3,r16
8112a148:	10800044 	addi	r2,r2,1
8112a14c:	d8c01c15 	stw	r3,112(sp)
8112a150:	44000115 	stw	r16,4(r8)
8112a154:	d8801b15 	stw	r2,108(sp)
8112a158:	00c001c4 	movi	r3,7
8112a15c:	18831e16 	blt	r3,r2,8112add8 <___svfiprintf_internal_r+0xd74>
8112a160:	42000204 	addi	r8,r8,8
8112a164:	dac02517 	ldw	r11,148(sp)
8112a168:	5c17883a 	add	r11,r11,r16
8112a16c:	dac02515 	stw	r11,148(sp)
8112a170:	88800007 	ldb	r2,0(r17)
8112a174:	1002c526 	beq	r2,zero,8112ac8c <___svfiprintf_internal_r+0xc28>
8112a178:	88c00047 	ldb	r3,1(r17)
8112a17c:	8cc00044 	addi	r19,r17,1
8112a180:	d8001d85 	stb	zero,118(sp)
8112a184:	0009883a 	mov	r4,zero
8112a188:	000f883a 	mov	r7,zero
8112a18c:	043fffc4 	movi	r16,-1
8112a190:	d8002415 	stw	zero,144(sp)
8112a194:	0025883a 	mov	r18,zero
8112a198:	01401604 	movi	r5,88
8112a19c:	01800244 	movi	r6,9
8112a1a0:	02800a84 	movi	r10,42
8112a1a4:	02401b04 	movi	r9,108
8112a1a8:	9cc00044 	addi	r19,r19,1
8112a1ac:	18bff804 	addi	r2,r3,-32
8112a1b0:	2881dd36 	bltu	r5,r2,8112a928 <___svfiprintf_internal_r+0x8c4>
8112a1b4:	100490ba 	slli	r2,r2,2
8112a1b8:	02e044f4 	movhi	r11,33043
8112a1bc:	5ae87304 	addi	r11,r11,-24116
8112a1c0:	12c5883a 	add	r2,r2,r11
8112a1c4:	10800017 	ldw	r2,0(r2)
8112a1c8:	1000683a 	jmp	r2
8112a1cc:	8112a3c8 	cmpgei	r4,r16,19087
8112a1d0:	8112a928 	cmpgeui	r4,r16,19108
8112a1d4:	8112a928 	cmpgeui	r4,r16,19108
8112a1d8:	8112a3bc 	xorhi	r4,r16,19086
8112a1dc:	8112a928 	cmpgeui	r4,r16,19108
8112a1e0:	8112a928 	cmpgeui	r4,r16,19108
8112a1e4:	8112a928 	cmpgeui	r4,r16,19108
8112a1e8:	8112a928 	cmpgeui	r4,r16,19108
8112a1ec:	8112a928 	cmpgeui	r4,r16,19108
8112a1f0:	8112a928 	cmpgeui	r4,r16,19108
8112a1f4:	8112a330 	cmpltui	r4,r16,19084
8112a1f8:	8112a50c 	andi	r4,r16,19092
8112a1fc:	8112a928 	cmpgeui	r4,r16,19108
8112a200:	8112a35c 	xori	r4,r16,19085
8112a204:	8112a95c 	xori	r4,r16,19109
8112a208:	8112a928 	cmpgeui	r4,r16,19108
8112a20c:	8112a950 	cmplti	r4,r16,19109
8112a210:	8112a8f0 	cmpltui	r4,r16,19107
8112a214:	8112a8f0 	cmpltui	r4,r16,19107
8112a218:	8112a8f0 	cmpltui	r4,r16,19107
8112a21c:	8112a8f0 	cmpltui	r4,r16,19107
8112a220:	8112a8f0 	cmpltui	r4,r16,19107
8112a224:	8112a8f0 	cmpltui	r4,r16,19107
8112a228:	8112a8f0 	cmpltui	r4,r16,19107
8112a22c:	8112a8f0 	cmpltui	r4,r16,19107
8112a230:	8112a8f0 	cmpltui	r4,r16,19107
8112a234:	8112a928 	cmpgeui	r4,r16,19108
8112a238:	8112a928 	cmpgeui	r4,r16,19108
8112a23c:	8112a928 	cmpgeui	r4,r16,19108
8112a240:	8112a928 	cmpgeui	r4,r16,19108
8112a244:	8112a928 	cmpgeui	r4,r16,19108
8112a248:	8112a928 	cmpgeui	r4,r16,19108
8112a24c:	8112a928 	cmpgeui	r4,r16,19108
8112a250:	8112a928 	cmpgeui	r4,r16,19108
8112a254:	8112a928 	cmpgeui	r4,r16,19108
8112a258:	8112a928 	cmpgeui	r4,r16,19108
8112a25c:	8112a88c 	andi	r4,r16,19106
8112a260:	8112a928 	cmpgeui	r4,r16,19108
8112a264:	8112a928 	cmpgeui	r4,r16,19108
8112a268:	8112a928 	cmpgeui	r4,r16,19108
8112a26c:	8112a928 	cmpgeui	r4,r16,19108
8112a270:	8112a928 	cmpgeui	r4,r16,19108
8112a274:	8112a928 	cmpgeui	r4,r16,19108
8112a278:	8112a928 	cmpgeui	r4,r16,19108
8112a27c:	8112a928 	cmpgeui	r4,r16,19108
8112a280:	8112a928 	cmpgeui	r4,r16,19108
8112a284:	8112a928 	cmpgeui	r4,r16,19108
8112a288:	8112aa04 	addi	r4,r16,19112
8112a28c:	8112a928 	cmpgeui	r4,r16,19108
8112a290:	8112a928 	cmpgeui	r4,r16,19108
8112a294:	8112a928 	cmpgeui	r4,r16,19108
8112a298:	8112a928 	cmpgeui	r4,r16,19108
8112a29c:	8112a928 	cmpgeui	r4,r16,19108
8112a2a0:	8112a99c 	xori	r4,r16,19110
8112a2a4:	8112a928 	cmpgeui	r4,r16,19108
8112a2a8:	8112a928 	cmpgeui	r4,r16,19108
8112a2ac:	8112a6d0 	cmplti	r4,r16,19099
8112a2b0:	8112a928 	cmpgeui	r4,r16,19108
8112a2b4:	8112a928 	cmpgeui	r4,r16,19108
8112a2b8:	8112a928 	cmpgeui	r4,r16,19108
8112a2bc:	8112a928 	cmpgeui	r4,r16,19108
8112a2c0:	8112a928 	cmpgeui	r4,r16,19108
8112a2c4:	8112a928 	cmpgeui	r4,r16,19108
8112a2c8:	8112a928 	cmpgeui	r4,r16,19108
8112a2cc:	8112a928 	cmpgeui	r4,r16,19108
8112a2d0:	8112a928 	cmpgeui	r4,r16,19108
8112a2d4:	8112a928 	cmpgeui	r4,r16,19108
8112a2d8:	8112a5c0 	call	88112a5c <__reset+0x20f2a5c>
8112a2dc:	8112a76c 	andhi	r4,r16,19101
8112a2e0:	8112a928 	cmpgeui	r4,r16,19108
8112a2e4:	8112a928 	cmpgeui	r4,r16,19108
8112a2e8:	8112a928 	cmpgeui	r4,r16,19108
8112a2ec:	8112a760 	cmpeqi	r4,r16,19101
8112a2f0:	8112a76c 	andhi	r4,r16,19101
8112a2f4:	8112a928 	cmpgeui	r4,r16,19108
8112a2f8:	8112a928 	cmpgeui	r4,r16,19108
8112a2fc:	8112a750 	cmplti	r4,r16,19101
8112a300:	8112a928 	cmpgeui	r4,r16,19108
8112a304:	8112a714 	ori	r4,r16,19100
8112a308:	8112a51c 	xori	r4,r16,19092
8112a30c:	8112a368 	cmpgeui	r4,r16,19085
8112a310:	8112a880 	call	88112a88 <__reset+0x20f2a88>
8112a314:	8112a928 	cmpgeui	r4,r16,19108
8112a318:	8112a834 	orhi	r4,r16,19104
8112a31c:	8112a928 	cmpgeui	r4,r16,19108
8112a320:	8112a48c 	andi	r4,r16,19090
8112a324:	8112a928 	cmpgeui	r4,r16,19108
8112a328:	8112a928 	cmpgeui	r4,r16,19108
8112a32c:	8112a3e8 	cmpgeui	r4,r16,19087
8112a330:	dac02317 	ldw	r11,140(sp)
8112a334:	5ac00017 	ldw	r11,0(r11)
8112a338:	dac02415 	stw	r11,144(sp)
8112a33c:	dac02317 	ldw	r11,140(sp)
8112a340:	58800104 	addi	r2,r11,4
8112a344:	dac02417 	ldw	r11,144(sp)
8112a348:	5802e90e 	bge	r11,zero,8112aef0 <___svfiprintf_internal_r+0xe8c>
8112a34c:	dac02417 	ldw	r11,144(sp)
8112a350:	d8802315 	stw	r2,140(sp)
8112a354:	02d7c83a 	sub	r11,zero,r11
8112a358:	dac02415 	stw	r11,144(sp)
8112a35c:	94800114 	ori	r18,r18,4
8112a360:	98c00007 	ldb	r3,0(r19)
8112a364:	003f9006 	br	8112a1a8 <__reset+0xfb10a1a8>
8112a368:	00800c04 	movi	r2,48
8112a36c:	dac02317 	ldw	r11,140(sp)
8112a370:	d8801d05 	stb	r2,116(sp)
8112a374:	00801e04 	movi	r2,120
8112a378:	d8801d45 	stb	r2,117(sp)
8112a37c:	d8001d85 	stb	zero,118(sp)
8112a380:	58c00104 	addi	r3,r11,4
8112a384:	5f000017 	ldw	fp,0(r11)
8112a388:	0013883a 	mov	r9,zero
8112a38c:	90800094 	ori	r2,r18,2
8112a390:	80032b16 	blt	r16,zero,8112b040 <___svfiprintf_internal_r+0xfdc>
8112a394:	00bfdfc4 	movi	r2,-129
8112a398:	90a4703a 	and	r18,r18,r2
8112a39c:	d8c02315 	stw	r3,140(sp)
8112a3a0:	94800094 	ori	r18,r18,2
8112a3a4:	e002dc26 	beq	fp,zero,8112af18 <___svfiprintf_internal_r+0xeb4>
8112a3a8:	01204574 	movhi	r4,33045
8112a3ac:	21297f04 	addi	r4,r4,-23044
8112a3b0:	0015883a 	mov	r10,zero
8112a3b4:	d9002915 	stw	r4,164(sp)
8112a3b8:	00002306 	br	8112a448 <___svfiprintf_internal_r+0x3e4>
8112a3bc:	94800054 	ori	r18,r18,1
8112a3c0:	98c00007 	ldb	r3,0(r19)
8112a3c4:	003f7806 	br	8112a1a8 <__reset+0xfb10a1a8>
8112a3c8:	38803fcc 	andi	r2,r7,255
8112a3cc:	1080201c 	xori	r2,r2,128
8112a3d0:	10bfe004 	addi	r2,r2,-128
8112a3d4:	1002f31e 	bne	r2,zero,8112afa4 <___svfiprintf_internal_r+0xf40>
8112a3d8:	01000044 	movi	r4,1
8112a3dc:	01c00804 	movi	r7,32
8112a3e0:	98c00007 	ldb	r3,0(r19)
8112a3e4:	003f7006 	br	8112a1a8 <__reset+0xfb10a1a8>
8112a3e8:	21003fcc 	andi	r4,r4,255
8112a3ec:	2003aa1e 	bne	r4,zero,8112b298 <___svfiprintf_internal_r+0x1234>
8112a3f0:	00a04574 	movhi	r2,33045
8112a3f4:	10a97f04 	addi	r2,r2,-23044
8112a3f8:	d8802915 	stw	r2,164(sp)
8112a3fc:	9080080c 	andi	r2,r18,32
8112a400:	1000ba26 	beq	r2,zero,8112a6ec <___svfiprintf_internal_r+0x688>
8112a404:	dac02317 	ldw	r11,140(sp)
8112a408:	5f000017 	ldw	fp,0(r11)
8112a40c:	5a400117 	ldw	r9,4(r11)
8112a410:	5ac00204 	addi	r11,r11,8
8112a414:	dac02315 	stw	r11,140(sp)
8112a418:	9080004c 	andi	r2,r18,1
8112a41c:	10029026 	beq	r2,zero,8112ae60 <___svfiprintf_internal_r+0xdfc>
8112a420:	e244b03a 	or	r2,fp,r9
8112a424:	1002d41e 	bne	r2,zero,8112af78 <___svfiprintf_internal_r+0xf14>
8112a428:	d8001d85 	stb	zero,118(sp)
8112a42c:	80030b16 	blt	r16,zero,8112b05c <___svfiprintf_internal_r+0xff8>
8112a430:	00bfdfc4 	movi	r2,-129
8112a434:	90a4703a 	and	r18,r18,r2
8112a438:	0015883a 	mov	r10,zero
8112a43c:	80002426 	beq	r16,zero,8112a4d0 <___svfiprintf_internal_r+0x46c>
8112a440:	0039883a 	mov	fp,zero
8112a444:	0013883a 	mov	r9,zero
8112a448:	d9002917 	ldw	r4,164(sp)
8112a44c:	dc401a04 	addi	r17,sp,104
8112a450:	e08003cc 	andi	r2,fp,15
8112a454:	4806973a 	slli	r3,r9,28
8112a458:	2085883a 	add	r2,r4,r2
8112a45c:	e038d13a 	srli	fp,fp,4
8112a460:	10800003 	ldbu	r2,0(r2)
8112a464:	4812d13a 	srli	r9,r9,4
8112a468:	8c7fffc4 	addi	r17,r17,-1
8112a46c:	1f38b03a 	or	fp,r3,fp
8112a470:	88800005 	stb	r2,0(r17)
8112a474:	e244b03a 	or	r2,fp,r9
8112a478:	103ff51e 	bne	r2,zero,8112a450 <__reset+0xfb10a450>
8112a47c:	dac01e17 	ldw	r11,120(sp)
8112a480:	5c57c83a 	sub	r11,r11,r17
8112a484:	dac02115 	stw	r11,132(sp)
8112a488:	00001406 	br	8112a4dc <___svfiprintf_internal_r+0x478>
8112a48c:	21003fcc 	andi	r4,r4,255
8112a490:	2003741e 	bne	r4,zero,8112b264 <___svfiprintf_internal_r+0x1200>
8112a494:	9080080c 	andi	r2,r18,32
8112a498:	10014526 	beq	r2,zero,8112a9b0 <___svfiprintf_internal_r+0x94c>
8112a49c:	dac02317 	ldw	r11,140(sp)
8112a4a0:	d8001d85 	stb	zero,118(sp)
8112a4a4:	58c00204 	addi	r3,r11,8
8112a4a8:	5f000017 	ldw	fp,0(r11)
8112a4ac:	5a400117 	ldw	r9,4(r11)
8112a4b0:	8002d916 	blt	r16,zero,8112b018 <___svfiprintf_internal_r+0xfb4>
8112a4b4:	013fdfc4 	movi	r4,-129
8112a4b8:	e244b03a 	or	r2,fp,r9
8112a4bc:	d8c02315 	stw	r3,140(sp)
8112a4c0:	9124703a 	and	r18,r18,r4
8112a4c4:	0015883a 	mov	r10,zero
8112a4c8:	1000b91e 	bne	r2,zero,8112a7b0 <___svfiprintf_internal_r+0x74c>
8112a4cc:	8002e61e 	bne	r16,zero,8112b068 <___svfiprintf_internal_r+0x1004>
8112a4d0:	0021883a 	mov	r16,zero
8112a4d4:	d8002115 	stw	zero,132(sp)
8112a4d8:	dc401a04 	addi	r17,sp,104
8112a4dc:	d8c02117 	ldw	r3,132(sp)
8112a4e0:	dc002015 	stw	r16,128(sp)
8112a4e4:	80c0010e 	bge	r16,r3,8112a4ec <___svfiprintf_internal_r+0x488>
8112a4e8:	d8c02015 	stw	r3,128(sp)
8112a4ec:	52803fcc 	andi	r10,r10,255
8112a4f0:	5280201c 	xori	r10,r10,128
8112a4f4:	52bfe004 	addi	r10,r10,-128
8112a4f8:	50003c26 	beq	r10,zero,8112a5ec <___svfiprintf_internal_r+0x588>
8112a4fc:	dac02017 	ldw	r11,128(sp)
8112a500:	5ac00044 	addi	r11,r11,1
8112a504:	dac02015 	stw	r11,128(sp)
8112a508:	00003806 	br	8112a5ec <___svfiprintf_internal_r+0x588>
8112a50c:	01000044 	movi	r4,1
8112a510:	01c00ac4 	movi	r7,43
8112a514:	98c00007 	ldb	r3,0(r19)
8112a518:	003f2306 	br	8112a1a8 <__reset+0xfb10a1a8>
8112a51c:	21003fcc 	andi	r4,r4,255
8112a520:	2003481e 	bne	r4,zero,8112b244 <___svfiprintf_internal_r+0x11e0>
8112a524:	9080080c 	andi	r2,r18,32
8112a528:	10013b26 	beq	r2,zero,8112aa18 <___svfiprintf_internal_r+0x9b4>
8112a52c:	dac02317 	ldw	r11,140(sp)
8112a530:	d8001d85 	stb	zero,118(sp)
8112a534:	58800204 	addi	r2,r11,8
8112a538:	5f000017 	ldw	fp,0(r11)
8112a53c:	5a400117 	ldw	r9,4(r11)
8112a540:	8002a816 	blt	r16,zero,8112afe4 <___svfiprintf_internal_r+0xf80>
8112a544:	013fdfc4 	movi	r4,-129
8112a548:	e246b03a 	or	r3,fp,r9
8112a54c:	d8802315 	stw	r2,140(sp)
8112a550:	9124703a 	and	r18,r18,r4
8112a554:	18013c26 	beq	r3,zero,8112aa48 <___svfiprintf_internal_r+0x9e4>
8112a558:	0015883a 	mov	r10,zero
8112a55c:	dc401a04 	addi	r17,sp,104
8112a560:	e006d0fa 	srli	r3,fp,3
8112a564:	4808977a 	slli	r4,r9,29
8112a568:	4812d0fa 	srli	r9,r9,3
8112a56c:	e70001cc 	andi	fp,fp,7
8112a570:	e0800c04 	addi	r2,fp,48
8112a574:	8c7fffc4 	addi	r17,r17,-1
8112a578:	20f8b03a 	or	fp,r4,r3
8112a57c:	88800005 	stb	r2,0(r17)
8112a580:	e246b03a 	or	r3,fp,r9
8112a584:	183ff61e 	bne	r3,zero,8112a560 <__reset+0xfb10a560>
8112a588:	90c0004c 	andi	r3,r18,1
8112a58c:	1800a526 	beq	r3,zero,8112a824 <___svfiprintf_internal_r+0x7c0>
8112a590:	10803fcc 	andi	r2,r2,255
8112a594:	1080201c 	xori	r2,r2,128
8112a598:	10bfe004 	addi	r2,r2,-128
8112a59c:	00c00c04 	movi	r3,48
8112a5a0:	10ffb626 	beq	r2,r3,8112a47c <__reset+0xfb10a47c>
8112a5a4:	88ffffc5 	stb	r3,-1(r17)
8112a5a8:	d8c01e17 	ldw	r3,120(sp)
8112a5ac:	88bfffc4 	addi	r2,r17,-1
8112a5b0:	1023883a 	mov	r17,r2
8112a5b4:	1887c83a 	sub	r3,r3,r2
8112a5b8:	d8c02115 	stw	r3,132(sp)
8112a5bc:	003fc706 	br	8112a4dc <__reset+0xfb10a4dc>
8112a5c0:	dac02317 	ldw	r11,140(sp)
8112a5c4:	00c00044 	movi	r3,1
8112a5c8:	d8c02015 	stw	r3,128(sp)
8112a5cc:	58800017 	ldw	r2,0(r11)
8112a5d0:	5ac00104 	addi	r11,r11,4
8112a5d4:	d8001d85 	stb	zero,118(sp)
8112a5d8:	d8801005 	stb	r2,64(sp)
8112a5dc:	dac02315 	stw	r11,140(sp)
8112a5e0:	d8c02115 	stw	r3,132(sp)
8112a5e4:	dc401004 	addi	r17,sp,64
8112a5e8:	0021883a 	mov	r16,zero
8112a5ec:	90c0008c 	andi	r3,r18,2
8112a5f0:	d8c02215 	stw	r3,136(sp)
8112a5f4:	18000326 	beq	r3,zero,8112a604 <___svfiprintf_internal_r+0x5a0>
8112a5f8:	dac02017 	ldw	r11,128(sp)
8112a5fc:	5ac00084 	addi	r11,r11,2
8112a600:	dac02015 	stw	r11,128(sp)
8112a604:	90c0210c 	andi	r3,r18,132
8112a608:	d8c02615 	stw	r3,152(sp)
8112a60c:	1801131e 	bne	r3,zero,8112aa5c <___svfiprintf_internal_r+0x9f8>
8112a610:	dac02417 	ldw	r11,144(sp)
8112a614:	d8c02017 	ldw	r3,128(sp)
8112a618:	58f9c83a 	sub	fp,r11,r3
8112a61c:	07010f0e 	bge	zero,fp,8112aa5c <___svfiprintf_internal_r+0x9f8>
8112a620:	02400404 	movi	r9,16
8112a624:	d8c01c17 	ldw	r3,112(sp)
8112a628:	d8801b17 	ldw	r2,108(sp)
8112a62c:	4f02d60e 	bge	r9,fp,8112b188 <___svfiprintf_internal_r+0x1124>
8112a630:	01604574 	movhi	r5,33045
8112a634:	296a0d04 	addi	r5,r5,-22476
8112a638:	d9402815 	stw	r5,160(sp)
8112a63c:	028001c4 	movi	r10,7
8112a640:	00000306 	br	8112a650 <___svfiprintf_internal_r+0x5ec>
8112a644:	e73ffc04 	addi	fp,fp,-16
8112a648:	42000204 	addi	r8,r8,8
8112a64c:	4f00150e 	bge	r9,fp,8112a6a4 <___svfiprintf_internal_r+0x640>
8112a650:	18c00404 	addi	r3,r3,16
8112a654:	10800044 	addi	r2,r2,1
8112a658:	45800015 	stw	r22,0(r8)
8112a65c:	42400115 	stw	r9,4(r8)
8112a660:	d8c01c15 	stw	r3,112(sp)
8112a664:	d8801b15 	stw	r2,108(sp)
8112a668:	50bff60e 	bge	r10,r2,8112a644 <__reset+0xfb10a644>
8112a66c:	d9801a04 	addi	r6,sp,104
8112a670:	b80b883a 	mov	r5,r23
8112a674:	a809883a 	mov	r4,r21
8112a678:	da402c15 	stw	r9,176(sp)
8112a67c:	da802d15 	stw	r10,180(sp)
8112a680:	1129e8c0 	call	81129e8c <__ssprint_r>
8112a684:	da402c17 	ldw	r9,176(sp)
8112a688:	da802d17 	ldw	r10,180(sp)
8112a68c:	1001851e 	bne	r2,zero,8112aca4 <___svfiprintf_internal_r+0xc40>
8112a690:	e73ffc04 	addi	fp,fp,-16
8112a694:	d8c01c17 	ldw	r3,112(sp)
8112a698:	d8801b17 	ldw	r2,108(sp)
8112a69c:	d811883a 	mov	r8,sp
8112a6a0:	4f3feb16 	blt	r9,fp,8112a650 <__reset+0xfb10a650>
8112a6a4:	dac02817 	ldw	r11,160(sp)
8112a6a8:	e0c7883a 	add	r3,fp,r3
8112a6ac:	10800044 	addi	r2,r2,1
8112a6b0:	42c00015 	stw	r11,0(r8)
8112a6b4:	47000115 	stw	fp,4(r8)
8112a6b8:	d8c01c15 	stw	r3,112(sp)
8112a6bc:	d8801b15 	stw	r2,108(sp)
8112a6c0:	010001c4 	movi	r4,7
8112a6c4:	2081ee16 	blt	r4,r2,8112ae80 <___svfiprintf_internal_r+0xe1c>
8112a6c8:	42000204 	addi	r8,r8,8
8112a6cc:	0000e506 	br	8112aa64 <___svfiprintf_internal_r+0xa00>
8112a6d0:	21003fcc 	andi	r4,r4,255
8112a6d4:	2002dd1e 	bne	r4,zero,8112b24c <___svfiprintf_internal_r+0x11e8>
8112a6d8:	00a04574 	movhi	r2,33045
8112a6dc:	10a97a04 	addi	r2,r2,-23064
8112a6e0:	d8802915 	stw	r2,164(sp)
8112a6e4:	9080080c 	andi	r2,r18,32
8112a6e8:	103f461e 	bne	r2,zero,8112a404 <__reset+0xfb10a404>
8112a6ec:	9080040c 	andi	r2,r18,16
8112a6f0:	10022e1e 	bne	r2,zero,8112afac <___svfiprintf_internal_r+0xf48>
8112a6f4:	9080100c 	andi	r2,r18,64
8112a6f8:	dac02317 	ldw	r11,140(sp)
8112a6fc:	10027326 	beq	r2,zero,8112b0cc <___svfiprintf_internal_r+0x1068>
8112a700:	5f00000b 	ldhu	fp,0(r11)
8112a704:	5ac00104 	addi	r11,r11,4
8112a708:	0013883a 	mov	r9,zero
8112a70c:	dac02315 	stw	r11,140(sp)
8112a710:	003f4106 	br	8112a418 <__reset+0xfb10a418>
8112a714:	21003fcc 	andi	r4,r4,255
8112a718:	2002e11e 	bne	r4,zero,8112b2a0 <___svfiprintf_internal_r+0x123c>
8112a71c:	9080080c 	andi	r2,r18,32
8112a720:	1002011e 	bne	r2,zero,8112af28 <___svfiprintf_internal_r+0xec4>
8112a724:	9080040c 	andi	r2,r18,16
8112a728:	10023e1e 	bne	r2,zero,8112b024 <___svfiprintf_internal_r+0xfc0>
8112a72c:	9480100c 	andi	r18,r18,64
8112a730:	90023c26 	beq	r18,zero,8112b024 <___svfiprintf_internal_r+0xfc0>
8112a734:	dac02317 	ldw	r11,140(sp)
8112a738:	58800017 	ldw	r2,0(r11)
8112a73c:	5ac00104 	addi	r11,r11,4
8112a740:	dac02315 	stw	r11,140(sp)
8112a744:	dac02517 	ldw	r11,148(sp)
8112a748:	12c0000d 	sth	r11,0(r2)
8112a74c:	003e6e06 	br	8112a108 <__reset+0xfb10a108>
8112a750:	98c00007 	ldb	r3,0(r19)
8112a754:	1a422926 	beq	r3,r9,8112affc <___svfiprintf_internal_r+0xf98>
8112a758:	94800414 	ori	r18,r18,16
8112a75c:	003e9206 	br	8112a1a8 <__reset+0xfb10a1a8>
8112a760:	94801014 	ori	r18,r18,64
8112a764:	98c00007 	ldb	r3,0(r19)
8112a768:	003e8f06 	br	8112a1a8 <__reset+0xfb10a1a8>
8112a76c:	21003fcc 	andi	r4,r4,255
8112a770:	2002c71e 	bne	r4,zero,8112b290 <___svfiprintf_internal_r+0x122c>
8112a774:	9080080c 	andi	r2,r18,32
8112a778:	10004926 	beq	r2,zero,8112a8a0 <___svfiprintf_internal_r+0x83c>
8112a77c:	dac02317 	ldw	r11,140(sp)
8112a780:	58800117 	ldw	r2,4(r11)
8112a784:	5f000017 	ldw	fp,0(r11)
8112a788:	5ac00204 	addi	r11,r11,8
8112a78c:	dac02315 	stw	r11,140(sp)
8112a790:	1013883a 	mov	r9,r2
8112a794:	10004b16 	blt	r2,zero,8112a8c4 <___svfiprintf_internal_r+0x860>
8112a798:	da801d83 	ldbu	r10,118(sp)
8112a79c:	8001cb16 	blt	r16,zero,8112aecc <___svfiprintf_internal_r+0xe68>
8112a7a0:	00ffdfc4 	movi	r3,-129
8112a7a4:	e244b03a 	or	r2,fp,r9
8112a7a8:	90e4703a 	and	r18,r18,r3
8112a7ac:	103f4726 	beq	r2,zero,8112a4cc <__reset+0xfb10a4cc>
8112a7b0:	48008c26 	beq	r9,zero,8112a9e4 <___svfiprintf_internal_r+0x980>
8112a7b4:	dc802015 	stw	r18,128(sp)
8112a7b8:	dc002115 	stw	r16,132(sp)
8112a7bc:	dc401a04 	addi	r17,sp,104
8112a7c0:	e021883a 	mov	r16,fp
8112a7c4:	da002215 	stw	r8,136(sp)
8112a7c8:	5039883a 	mov	fp,r10
8112a7cc:	4825883a 	mov	r18,r9
8112a7d0:	8009883a 	mov	r4,r16
8112a7d4:	900b883a 	mov	r5,r18
8112a7d8:	01800284 	movi	r6,10
8112a7dc:	000f883a 	mov	r7,zero
8112a7e0:	112e3f00 	call	8112e3f0 <__umoddi3>
8112a7e4:	10800c04 	addi	r2,r2,48
8112a7e8:	8c7fffc4 	addi	r17,r17,-1
8112a7ec:	8009883a 	mov	r4,r16
8112a7f0:	900b883a 	mov	r5,r18
8112a7f4:	88800005 	stb	r2,0(r17)
8112a7f8:	01800284 	movi	r6,10
8112a7fc:	000f883a 	mov	r7,zero
8112a800:	112de700 	call	8112de70 <__udivdi3>
8112a804:	1021883a 	mov	r16,r2
8112a808:	10c4b03a 	or	r2,r2,r3
8112a80c:	1825883a 	mov	r18,r3
8112a810:	103fef1e 	bne	r2,zero,8112a7d0 <__reset+0xfb10a7d0>
8112a814:	dc802017 	ldw	r18,128(sp)
8112a818:	dc002117 	ldw	r16,132(sp)
8112a81c:	da002217 	ldw	r8,136(sp)
8112a820:	e015883a 	mov	r10,fp
8112a824:	d8c01e17 	ldw	r3,120(sp)
8112a828:	1c47c83a 	sub	r3,r3,r17
8112a82c:	d8c02115 	stw	r3,132(sp)
8112a830:	003f2a06 	br	8112a4dc <__reset+0xfb10a4dc>
8112a834:	dac02317 	ldw	r11,140(sp)
8112a838:	d8001d85 	stb	zero,118(sp)
8112a83c:	5c400017 	ldw	r17,0(r11)
8112a840:	5f000104 	addi	fp,r11,4
8112a844:	88022f26 	beq	r17,zero,8112b104 <___svfiprintf_internal_r+0x10a0>
8112a848:	80022516 	blt	r16,zero,8112b0e0 <___svfiprintf_internal_r+0x107c>
8112a84c:	800d883a 	mov	r6,r16
8112a850:	000b883a 	mov	r5,zero
8112a854:	8809883a 	mov	r4,r17
8112a858:	da002c15 	stw	r8,176(sp)
8112a85c:	11264300 	call	81126430 <memchr>
8112a860:	da002c17 	ldw	r8,176(sp)
8112a864:	10026426 	beq	r2,zero,8112b1f8 <___svfiprintf_internal_r+0x1194>
8112a868:	1445c83a 	sub	r2,r2,r17
8112a86c:	d8802115 	stw	r2,132(sp)
8112a870:	da801d83 	ldbu	r10,118(sp)
8112a874:	df002315 	stw	fp,140(sp)
8112a878:	0021883a 	mov	r16,zero
8112a87c:	003f1706 	br	8112a4dc <__reset+0xfb10a4dc>
8112a880:	94800814 	ori	r18,r18,32
8112a884:	98c00007 	ldb	r3,0(r19)
8112a888:	003e4706 	br	8112a1a8 <__reset+0xfb10a1a8>
8112a88c:	21003fcc 	andi	r4,r4,255
8112a890:	2002701e 	bne	r4,zero,8112b254 <___svfiprintf_internal_r+0x11f0>
8112a894:	94800414 	ori	r18,r18,16
8112a898:	9080080c 	andi	r2,r18,32
8112a89c:	103fb71e 	bne	r2,zero,8112a77c <__reset+0xfb10a77c>
8112a8a0:	9080040c 	andi	r2,r18,16
8112a8a4:	1001ab26 	beq	r2,zero,8112af54 <___svfiprintf_internal_r+0xef0>
8112a8a8:	dac02317 	ldw	r11,140(sp)
8112a8ac:	5f000017 	ldw	fp,0(r11)
8112a8b0:	5ac00104 	addi	r11,r11,4
8112a8b4:	dac02315 	stw	r11,140(sp)
8112a8b8:	e013d7fa 	srai	r9,fp,31
8112a8bc:	4805883a 	mov	r2,r9
8112a8c0:	103fb50e 	bge	r2,zero,8112a798 <__reset+0xfb10a798>
8112a8c4:	0739c83a 	sub	fp,zero,fp
8112a8c8:	02800b44 	movi	r10,45
8112a8cc:	e004c03a 	cmpne	r2,fp,zero
8112a8d0:	0253c83a 	sub	r9,zero,r9
8112a8d4:	da801d85 	stb	r10,118(sp)
8112a8d8:	4893c83a 	sub	r9,r9,r2
8112a8dc:	80023016 	blt	r16,zero,8112b1a0 <___svfiprintf_internal_r+0x113c>
8112a8e0:	00bfdfc4 	movi	r2,-129
8112a8e4:	90a4703a 	and	r18,r18,r2
8112a8e8:	483fb21e 	bne	r9,zero,8112a7b4 <__reset+0xfb10a7b4>
8112a8ec:	00003d06 	br	8112a9e4 <___svfiprintf_internal_r+0x980>
8112a8f0:	9817883a 	mov	r11,r19
8112a8f4:	d8002415 	stw	zero,144(sp)
8112a8f8:	18bff404 	addi	r2,r3,-48
8112a8fc:	0019883a 	mov	r12,zero
8112a900:	58c00007 	ldb	r3,0(r11)
8112a904:	630002a4 	muli	r12,r12,10
8112a908:	9cc00044 	addi	r19,r19,1
8112a90c:	9817883a 	mov	r11,r19
8112a910:	1319883a 	add	r12,r2,r12
8112a914:	18bff404 	addi	r2,r3,-48
8112a918:	30bff92e 	bgeu	r6,r2,8112a900 <__reset+0xfb10a900>
8112a91c:	db002415 	stw	r12,144(sp)
8112a920:	18bff804 	addi	r2,r3,-32
8112a924:	28be232e 	bgeu	r5,r2,8112a1b4 <__reset+0xfb10a1b4>
8112a928:	21003fcc 	andi	r4,r4,255
8112a92c:	20024b1e 	bne	r4,zero,8112b25c <___svfiprintf_internal_r+0x11f8>
8112a930:	1800d626 	beq	r3,zero,8112ac8c <___svfiprintf_internal_r+0xc28>
8112a934:	02c00044 	movi	r11,1
8112a938:	dac02015 	stw	r11,128(sp)
8112a93c:	d8c01005 	stb	r3,64(sp)
8112a940:	d8001d85 	stb	zero,118(sp)
8112a944:	dac02115 	stw	r11,132(sp)
8112a948:	dc401004 	addi	r17,sp,64
8112a94c:	003f2606 	br	8112a5e8 <__reset+0xfb10a5e8>
8112a950:	94802014 	ori	r18,r18,128
8112a954:	98c00007 	ldb	r3,0(r19)
8112a958:	003e1306 	br	8112a1a8 <__reset+0xfb10a1a8>
8112a95c:	98c00007 	ldb	r3,0(r19)
8112a960:	9ac00044 	addi	r11,r19,1
8112a964:	1a822b26 	beq	r3,r10,8112b214 <___svfiprintf_internal_r+0x11b0>
8112a968:	18bff404 	addi	r2,r3,-48
8112a96c:	0021883a 	mov	r16,zero
8112a970:	30821e36 	bltu	r6,r2,8112b1ec <___svfiprintf_internal_r+0x1188>
8112a974:	58c00007 	ldb	r3,0(r11)
8112a978:	840002a4 	muli	r16,r16,10
8112a97c:	5cc00044 	addi	r19,r11,1
8112a980:	9817883a 	mov	r11,r19
8112a984:	80a1883a 	add	r16,r16,r2
8112a988:	18bff404 	addi	r2,r3,-48
8112a98c:	30bff92e 	bgeu	r6,r2,8112a974 <__reset+0xfb10a974>
8112a990:	803e060e 	bge	r16,zero,8112a1ac <__reset+0xfb10a1ac>
8112a994:	043fffc4 	movi	r16,-1
8112a998:	003e0406 	br	8112a1ac <__reset+0xfb10a1ac>
8112a99c:	21003fcc 	andi	r4,r4,255
8112a9a0:	2002371e 	bne	r4,zero,8112b280 <___svfiprintf_internal_r+0x121c>
8112a9a4:	94800414 	ori	r18,r18,16
8112a9a8:	9080080c 	andi	r2,r18,32
8112a9ac:	103ebb1e 	bne	r2,zero,8112a49c <__reset+0xfb10a49c>
8112a9b0:	9080040c 	andi	r2,r18,16
8112a9b4:	10013b26 	beq	r2,zero,8112aea4 <___svfiprintf_internal_r+0xe40>
8112a9b8:	dac02317 	ldw	r11,140(sp)
8112a9bc:	d8001d85 	stb	zero,118(sp)
8112a9c0:	0013883a 	mov	r9,zero
8112a9c4:	58800104 	addi	r2,r11,4
8112a9c8:	5f000017 	ldw	fp,0(r11)
8112a9cc:	80013d16 	blt	r16,zero,8112aec4 <___svfiprintf_internal_r+0xe60>
8112a9d0:	00ffdfc4 	movi	r3,-129
8112a9d4:	d8802315 	stw	r2,140(sp)
8112a9d8:	90e4703a 	and	r18,r18,r3
8112a9dc:	0015883a 	mov	r10,zero
8112a9e0:	e03eba26 	beq	fp,zero,8112a4cc <__reset+0xfb10a4cc>
8112a9e4:	00800244 	movi	r2,9
8112a9e8:	173f7236 	bltu	r2,fp,8112a7b4 <__reset+0xfb10a7b4>
8112a9ec:	dac02b17 	ldw	r11,172(sp)
8112a9f0:	e7000c04 	addi	fp,fp,48
8112a9f4:	df0019c5 	stb	fp,103(sp)
8112a9f8:	dac02115 	stw	r11,132(sp)
8112a9fc:	dc4019c4 	addi	r17,sp,103
8112aa00:	003eb606 	br	8112a4dc <__reset+0xfb10a4dc>
8112aa04:	21003fcc 	andi	r4,r4,255
8112aa08:	20021f1e 	bne	r4,zero,8112b288 <___svfiprintf_internal_r+0x1224>
8112aa0c:	94800414 	ori	r18,r18,16
8112aa10:	9080080c 	andi	r2,r18,32
8112aa14:	103ec51e 	bne	r2,zero,8112a52c <__reset+0xfb10a52c>
8112aa18:	9080040c 	andi	r2,r18,16
8112aa1c:	10016926 	beq	r2,zero,8112afc4 <___svfiprintf_internal_r+0xf60>
8112aa20:	dac02317 	ldw	r11,140(sp)
8112aa24:	d8001d85 	stb	zero,118(sp)
8112aa28:	0013883a 	mov	r9,zero
8112aa2c:	58800104 	addi	r2,r11,4
8112aa30:	5f000017 	ldw	fp,0(r11)
8112aa34:	80016b16 	blt	r16,zero,8112afe4 <___svfiprintf_internal_r+0xf80>
8112aa38:	00ffdfc4 	movi	r3,-129
8112aa3c:	d8802315 	stw	r2,140(sp)
8112aa40:	90e4703a 	and	r18,r18,r3
8112aa44:	e03ec41e 	bne	fp,zero,8112a558 <__reset+0xfb10a558>
8112aa48:	0015883a 	mov	r10,zero
8112aa4c:	8001c226 	beq	r16,zero,8112b158 <___svfiprintf_internal_r+0x10f4>
8112aa50:	0039883a 	mov	fp,zero
8112aa54:	0013883a 	mov	r9,zero
8112aa58:	003ec006 	br	8112a55c <__reset+0xfb10a55c>
8112aa5c:	d8c01c17 	ldw	r3,112(sp)
8112aa60:	d8801b17 	ldw	r2,108(sp)
8112aa64:	d9001d87 	ldb	r4,118(sp)
8112aa68:	20000b26 	beq	r4,zero,8112aa98 <___svfiprintf_internal_r+0xa34>
8112aa6c:	d9001d84 	addi	r4,sp,118
8112aa70:	18c00044 	addi	r3,r3,1
8112aa74:	10800044 	addi	r2,r2,1
8112aa78:	41000015 	stw	r4,0(r8)
8112aa7c:	01000044 	movi	r4,1
8112aa80:	41000115 	stw	r4,4(r8)
8112aa84:	d8c01c15 	stw	r3,112(sp)
8112aa88:	d8801b15 	stw	r2,108(sp)
8112aa8c:	010001c4 	movi	r4,7
8112aa90:	2080e116 	blt	r4,r2,8112ae18 <___svfiprintf_internal_r+0xdb4>
8112aa94:	42000204 	addi	r8,r8,8
8112aa98:	dac02217 	ldw	r11,136(sp)
8112aa9c:	58000b26 	beq	r11,zero,8112aacc <___svfiprintf_internal_r+0xa68>
8112aaa0:	d9001d04 	addi	r4,sp,116
8112aaa4:	18c00084 	addi	r3,r3,2
8112aaa8:	10800044 	addi	r2,r2,1
8112aaac:	41000015 	stw	r4,0(r8)
8112aab0:	01000084 	movi	r4,2
8112aab4:	41000115 	stw	r4,4(r8)
8112aab8:	d8c01c15 	stw	r3,112(sp)
8112aabc:	d8801b15 	stw	r2,108(sp)
8112aac0:	010001c4 	movi	r4,7
8112aac4:	2080dd16 	blt	r4,r2,8112ae3c <___svfiprintf_internal_r+0xdd8>
8112aac8:	42000204 	addi	r8,r8,8
8112aacc:	dac02617 	ldw	r11,152(sp)
8112aad0:	01002004 	movi	r4,128
8112aad4:	59008426 	beq	r11,r4,8112ace8 <___svfiprintf_internal_r+0xc84>
8112aad8:	dac02117 	ldw	r11,132(sp)
8112aadc:	82e1c83a 	sub	r16,r16,r11
8112aae0:	0400270e 	bge	zero,r16,8112ab80 <___svfiprintf_internal_r+0xb1c>
8112aae4:	01c00404 	movi	r7,16
8112aae8:	3c016a0e 	bge	r7,r16,8112b094 <___svfiprintf_internal_r+0x1030>
8112aaec:	01604574 	movhi	r5,33045
8112aaf0:	296a0904 	addi	r5,r5,-22492
8112aaf4:	d9402215 	stw	r5,136(sp)
8112aaf8:	070001c4 	movi	fp,7
8112aafc:	00000306 	br	8112ab0c <___svfiprintf_internal_r+0xaa8>
8112ab00:	843ffc04 	addi	r16,r16,-16
8112ab04:	42000204 	addi	r8,r8,8
8112ab08:	3c00130e 	bge	r7,r16,8112ab58 <___svfiprintf_internal_r+0xaf4>
8112ab0c:	18c00404 	addi	r3,r3,16
8112ab10:	10800044 	addi	r2,r2,1
8112ab14:	45000015 	stw	r20,0(r8)
8112ab18:	41c00115 	stw	r7,4(r8)
8112ab1c:	d8c01c15 	stw	r3,112(sp)
8112ab20:	d8801b15 	stw	r2,108(sp)
8112ab24:	e0bff60e 	bge	fp,r2,8112ab00 <__reset+0xfb10ab00>
8112ab28:	d9801a04 	addi	r6,sp,104
8112ab2c:	b80b883a 	mov	r5,r23
8112ab30:	a809883a 	mov	r4,r21
8112ab34:	d9c02c15 	stw	r7,176(sp)
8112ab38:	1129e8c0 	call	81129e8c <__ssprint_r>
8112ab3c:	d9c02c17 	ldw	r7,176(sp)
8112ab40:	1000581e 	bne	r2,zero,8112aca4 <___svfiprintf_internal_r+0xc40>
8112ab44:	843ffc04 	addi	r16,r16,-16
8112ab48:	d8c01c17 	ldw	r3,112(sp)
8112ab4c:	d8801b17 	ldw	r2,108(sp)
8112ab50:	d811883a 	mov	r8,sp
8112ab54:	3c3fed16 	blt	r7,r16,8112ab0c <__reset+0xfb10ab0c>
8112ab58:	dac02217 	ldw	r11,136(sp)
8112ab5c:	1c07883a 	add	r3,r3,r16
8112ab60:	10800044 	addi	r2,r2,1
8112ab64:	42c00015 	stw	r11,0(r8)
8112ab68:	44000115 	stw	r16,4(r8)
8112ab6c:	d8c01c15 	stw	r3,112(sp)
8112ab70:	d8801b15 	stw	r2,108(sp)
8112ab74:	010001c4 	movi	r4,7
8112ab78:	20809e16 	blt	r4,r2,8112adf4 <___svfiprintf_internal_r+0xd90>
8112ab7c:	42000204 	addi	r8,r8,8
8112ab80:	dac02117 	ldw	r11,132(sp)
8112ab84:	10800044 	addi	r2,r2,1
8112ab88:	44400015 	stw	r17,0(r8)
8112ab8c:	58c7883a 	add	r3,r11,r3
8112ab90:	42c00115 	stw	r11,4(r8)
8112ab94:	d8c01c15 	stw	r3,112(sp)
8112ab98:	d8801b15 	stw	r2,108(sp)
8112ab9c:	010001c4 	movi	r4,7
8112aba0:	20807f16 	blt	r4,r2,8112ada0 <___svfiprintf_internal_r+0xd3c>
8112aba4:	42000204 	addi	r8,r8,8
8112aba8:	9480010c 	andi	r18,r18,4
8112abac:	90002926 	beq	r18,zero,8112ac54 <___svfiprintf_internal_r+0xbf0>
8112abb0:	dac02417 	ldw	r11,144(sp)
8112abb4:	d8802017 	ldw	r2,128(sp)
8112abb8:	58a1c83a 	sub	r16,r11,r2
8112abbc:	0400250e 	bge	zero,r16,8112ac54 <___svfiprintf_internal_r+0xbf0>
8112abc0:	04400404 	movi	r17,16
8112abc4:	d8801b17 	ldw	r2,108(sp)
8112abc8:	8c017c0e 	bge	r17,r16,8112b1bc <___svfiprintf_internal_r+0x1158>
8112abcc:	01604574 	movhi	r5,33045
8112abd0:	296a0d04 	addi	r5,r5,-22476
8112abd4:	d9402815 	stw	r5,160(sp)
8112abd8:	048001c4 	movi	r18,7
8112abdc:	00000306 	br	8112abec <___svfiprintf_internal_r+0xb88>
8112abe0:	843ffc04 	addi	r16,r16,-16
8112abe4:	42000204 	addi	r8,r8,8
8112abe8:	8c00110e 	bge	r17,r16,8112ac30 <___svfiprintf_internal_r+0xbcc>
8112abec:	18c00404 	addi	r3,r3,16
8112abf0:	10800044 	addi	r2,r2,1
8112abf4:	45800015 	stw	r22,0(r8)
8112abf8:	44400115 	stw	r17,4(r8)
8112abfc:	d8c01c15 	stw	r3,112(sp)
8112ac00:	d8801b15 	stw	r2,108(sp)
8112ac04:	90bff60e 	bge	r18,r2,8112abe0 <__reset+0xfb10abe0>
8112ac08:	d9801a04 	addi	r6,sp,104
8112ac0c:	b80b883a 	mov	r5,r23
8112ac10:	a809883a 	mov	r4,r21
8112ac14:	1129e8c0 	call	81129e8c <__ssprint_r>
8112ac18:	1000221e 	bne	r2,zero,8112aca4 <___svfiprintf_internal_r+0xc40>
8112ac1c:	843ffc04 	addi	r16,r16,-16
8112ac20:	d8c01c17 	ldw	r3,112(sp)
8112ac24:	d8801b17 	ldw	r2,108(sp)
8112ac28:	d811883a 	mov	r8,sp
8112ac2c:	8c3fef16 	blt	r17,r16,8112abec <__reset+0xfb10abec>
8112ac30:	dac02817 	ldw	r11,160(sp)
8112ac34:	1c07883a 	add	r3,r3,r16
8112ac38:	10800044 	addi	r2,r2,1
8112ac3c:	42c00015 	stw	r11,0(r8)
8112ac40:	44000115 	stw	r16,4(r8)
8112ac44:	d8c01c15 	stw	r3,112(sp)
8112ac48:	d8801b15 	stw	r2,108(sp)
8112ac4c:	010001c4 	movi	r4,7
8112ac50:	2080aa16 	blt	r4,r2,8112aefc <___svfiprintf_internal_r+0xe98>
8112ac54:	d8802417 	ldw	r2,144(sp)
8112ac58:	dac02017 	ldw	r11,128(sp)
8112ac5c:	12c0010e 	bge	r2,r11,8112ac64 <___svfiprintf_internal_r+0xc00>
8112ac60:	5805883a 	mov	r2,r11
8112ac64:	dac02517 	ldw	r11,148(sp)
8112ac68:	5897883a 	add	r11,r11,r2
8112ac6c:	dac02515 	stw	r11,148(sp)
8112ac70:	1800531e 	bne	r3,zero,8112adc0 <___svfiprintf_internal_r+0xd5c>
8112ac74:	98800007 	ldb	r2,0(r19)
8112ac78:	d8001b15 	stw	zero,108(sp)
8112ac7c:	d811883a 	mov	r8,sp
8112ac80:	103d231e 	bne	r2,zero,8112a110 <__reset+0xfb10a110>
8112ac84:	9823883a 	mov	r17,r19
8112ac88:	003d3906 	br	8112a170 <__reset+0xfb10a170>
8112ac8c:	d8801c17 	ldw	r2,112(sp)
8112ac90:	10000426 	beq	r2,zero,8112aca4 <___svfiprintf_internal_r+0xc40>
8112ac94:	d9402717 	ldw	r5,156(sp)
8112ac98:	d9002a17 	ldw	r4,168(sp)
8112ac9c:	d9801a04 	addi	r6,sp,104
8112aca0:	1129e8c0 	call	81129e8c <__ssprint_r>
8112aca4:	dac02717 	ldw	r11,156(sp)
8112aca8:	d8802517 	ldw	r2,148(sp)
8112acac:	58c0030b 	ldhu	r3,12(r11)
8112acb0:	18c0100c 	andi	r3,r3,64
8112acb4:	1801381e 	bne	r3,zero,8112b198 <___svfiprintf_internal_r+0x1134>
8112acb8:	dfc03717 	ldw	ra,220(sp)
8112acbc:	df003617 	ldw	fp,216(sp)
8112acc0:	ddc03517 	ldw	r23,212(sp)
8112acc4:	dd803417 	ldw	r22,208(sp)
8112acc8:	dd403317 	ldw	r21,204(sp)
8112accc:	dd003217 	ldw	r20,200(sp)
8112acd0:	dcc03117 	ldw	r19,196(sp)
8112acd4:	dc803017 	ldw	r18,192(sp)
8112acd8:	dc402f17 	ldw	r17,188(sp)
8112acdc:	dc002e17 	ldw	r16,184(sp)
8112ace0:	dec03804 	addi	sp,sp,224
8112ace4:	f800283a 	ret
8112ace8:	dac02417 	ldw	r11,144(sp)
8112acec:	d9002017 	ldw	r4,128(sp)
8112acf0:	5939c83a 	sub	fp,r11,r4
8112acf4:	073f780e 	bge	zero,fp,8112aad8 <__reset+0xfb10aad8>
8112acf8:	02400404 	movi	r9,16
8112acfc:	4f01370e 	bge	r9,fp,8112b1dc <___svfiprintf_internal_r+0x1178>
8112ad00:	02e04574 	movhi	r11,33045
8112ad04:	5aea0904 	addi	r11,r11,-22492
8112ad08:	dac02215 	stw	r11,136(sp)
8112ad0c:	028001c4 	movi	r10,7
8112ad10:	00000306 	br	8112ad20 <___svfiprintf_internal_r+0xcbc>
8112ad14:	e73ffc04 	addi	fp,fp,-16
8112ad18:	42000204 	addi	r8,r8,8
8112ad1c:	4f00150e 	bge	r9,fp,8112ad74 <___svfiprintf_internal_r+0xd10>
8112ad20:	18c00404 	addi	r3,r3,16
8112ad24:	10800044 	addi	r2,r2,1
8112ad28:	45000015 	stw	r20,0(r8)
8112ad2c:	42400115 	stw	r9,4(r8)
8112ad30:	d8c01c15 	stw	r3,112(sp)
8112ad34:	d8801b15 	stw	r2,108(sp)
8112ad38:	50bff60e 	bge	r10,r2,8112ad14 <__reset+0xfb10ad14>
8112ad3c:	d9801a04 	addi	r6,sp,104
8112ad40:	b80b883a 	mov	r5,r23
8112ad44:	a809883a 	mov	r4,r21
8112ad48:	da402c15 	stw	r9,176(sp)
8112ad4c:	da802d15 	stw	r10,180(sp)
8112ad50:	1129e8c0 	call	81129e8c <__ssprint_r>
8112ad54:	da402c17 	ldw	r9,176(sp)
8112ad58:	da802d17 	ldw	r10,180(sp)
8112ad5c:	103fd11e 	bne	r2,zero,8112aca4 <__reset+0xfb10aca4>
8112ad60:	e73ffc04 	addi	fp,fp,-16
8112ad64:	d8c01c17 	ldw	r3,112(sp)
8112ad68:	d8801b17 	ldw	r2,108(sp)
8112ad6c:	d811883a 	mov	r8,sp
8112ad70:	4f3feb16 	blt	r9,fp,8112ad20 <__reset+0xfb10ad20>
8112ad74:	dac02217 	ldw	r11,136(sp)
8112ad78:	1f07883a 	add	r3,r3,fp
8112ad7c:	10800044 	addi	r2,r2,1
8112ad80:	42c00015 	stw	r11,0(r8)
8112ad84:	47000115 	stw	fp,4(r8)
8112ad88:	d8c01c15 	stw	r3,112(sp)
8112ad8c:	d8801b15 	stw	r2,108(sp)
8112ad90:	010001c4 	movi	r4,7
8112ad94:	2080b616 	blt	r4,r2,8112b070 <___svfiprintf_internal_r+0x100c>
8112ad98:	42000204 	addi	r8,r8,8
8112ad9c:	003f4e06 	br	8112aad8 <__reset+0xfb10aad8>
8112ada0:	d9801a04 	addi	r6,sp,104
8112ada4:	b80b883a 	mov	r5,r23
8112ada8:	a809883a 	mov	r4,r21
8112adac:	1129e8c0 	call	81129e8c <__ssprint_r>
8112adb0:	103fbc1e 	bne	r2,zero,8112aca4 <__reset+0xfb10aca4>
8112adb4:	d8c01c17 	ldw	r3,112(sp)
8112adb8:	d811883a 	mov	r8,sp
8112adbc:	003f7a06 	br	8112aba8 <__reset+0xfb10aba8>
8112adc0:	d9801a04 	addi	r6,sp,104
8112adc4:	b80b883a 	mov	r5,r23
8112adc8:	a809883a 	mov	r4,r21
8112adcc:	1129e8c0 	call	81129e8c <__ssprint_r>
8112add0:	103fa826 	beq	r2,zero,8112ac74 <__reset+0xfb10ac74>
8112add4:	003fb306 	br	8112aca4 <__reset+0xfb10aca4>
8112add8:	d9801a04 	addi	r6,sp,104
8112addc:	b80b883a 	mov	r5,r23
8112ade0:	a809883a 	mov	r4,r21
8112ade4:	1129e8c0 	call	81129e8c <__ssprint_r>
8112ade8:	103fae1e 	bne	r2,zero,8112aca4 <__reset+0xfb10aca4>
8112adec:	d811883a 	mov	r8,sp
8112adf0:	003cdc06 	br	8112a164 <__reset+0xfb10a164>
8112adf4:	d9801a04 	addi	r6,sp,104
8112adf8:	b80b883a 	mov	r5,r23
8112adfc:	a809883a 	mov	r4,r21
8112ae00:	1129e8c0 	call	81129e8c <__ssprint_r>
8112ae04:	103fa71e 	bne	r2,zero,8112aca4 <__reset+0xfb10aca4>
8112ae08:	d8c01c17 	ldw	r3,112(sp)
8112ae0c:	d8801b17 	ldw	r2,108(sp)
8112ae10:	d811883a 	mov	r8,sp
8112ae14:	003f5a06 	br	8112ab80 <__reset+0xfb10ab80>
8112ae18:	d9801a04 	addi	r6,sp,104
8112ae1c:	b80b883a 	mov	r5,r23
8112ae20:	a809883a 	mov	r4,r21
8112ae24:	1129e8c0 	call	81129e8c <__ssprint_r>
8112ae28:	103f9e1e 	bne	r2,zero,8112aca4 <__reset+0xfb10aca4>
8112ae2c:	d8c01c17 	ldw	r3,112(sp)
8112ae30:	d8801b17 	ldw	r2,108(sp)
8112ae34:	d811883a 	mov	r8,sp
8112ae38:	003f1706 	br	8112aa98 <__reset+0xfb10aa98>
8112ae3c:	d9801a04 	addi	r6,sp,104
8112ae40:	b80b883a 	mov	r5,r23
8112ae44:	a809883a 	mov	r4,r21
8112ae48:	1129e8c0 	call	81129e8c <__ssprint_r>
8112ae4c:	103f951e 	bne	r2,zero,8112aca4 <__reset+0xfb10aca4>
8112ae50:	d8c01c17 	ldw	r3,112(sp)
8112ae54:	d8801b17 	ldw	r2,108(sp)
8112ae58:	d811883a 	mov	r8,sp
8112ae5c:	003f1b06 	br	8112aacc <__reset+0xfb10aacc>
8112ae60:	d8001d85 	stb	zero,118(sp)
8112ae64:	80007b16 	blt	r16,zero,8112b054 <___svfiprintf_internal_r+0xff0>
8112ae68:	00ffdfc4 	movi	r3,-129
8112ae6c:	e244b03a 	or	r2,fp,r9
8112ae70:	90e4703a 	and	r18,r18,r3
8112ae74:	103d7026 	beq	r2,zero,8112a438 <__reset+0xfb10a438>
8112ae78:	0015883a 	mov	r10,zero
8112ae7c:	003d7206 	br	8112a448 <__reset+0xfb10a448>
8112ae80:	d9801a04 	addi	r6,sp,104
8112ae84:	b80b883a 	mov	r5,r23
8112ae88:	a809883a 	mov	r4,r21
8112ae8c:	1129e8c0 	call	81129e8c <__ssprint_r>
8112ae90:	103f841e 	bne	r2,zero,8112aca4 <__reset+0xfb10aca4>
8112ae94:	d8c01c17 	ldw	r3,112(sp)
8112ae98:	d8801b17 	ldw	r2,108(sp)
8112ae9c:	d811883a 	mov	r8,sp
8112aea0:	003ef006 	br	8112aa64 <__reset+0xfb10aa64>
8112aea4:	9080100c 	andi	r2,r18,64
8112aea8:	d8001d85 	stb	zero,118(sp)
8112aeac:	dac02317 	ldw	r11,140(sp)
8112aeb0:	10008126 	beq	r2,zero,8112b0b8 <___svfiprintf_internal_r+0x1054>
8112aeb4:	58800104 	addi	r2,r11,4
8112aeb8:	5f00000b 	ldhu	fp,0(r11)
8112aebc:	0013883a 	mov	r9,zero
8112aec0:	803ec30e 	bge	r16,zero,8112a9d0 <__reset+0xfb10a9d0>
8112aec4:	d8802315 	stw	r2,140(sp)
8112aec8:	0015883a 	mov	r10,zero
8112aecc:	e244b03a 	or	r2,fp,r9
8112aed0:	103e371e 	bne	r2,zero,8112a7b0 <__reset+0xfb10a7b0>
8112aed4:	00800044 	movi	r2,1
8112aed8:	10803fcc 	andi	r2,r2,255
8112aedc:	00c00044 	movi	r3,1
8112aee0:	10c06126 	beq	r2,r3,8112b068 <___svfiprintf_internal_r+0x1004>
8112aee4:	00c00084 	movi	r3,2
8112aee8:	10fd5526 	beq	r2,r3,8112a440 <__reset+0xfb10a440>
8112aeec:	003ed806 	br	8112aa50 <__reset+0xfb10aa50>
8112aef0:	d8802315 	stw	r2,140(sp)
8112aef4:	98c00007 	ldb	r3,0(r19)
8112aef8:	003cab06 	br	8112a1a8 <__reset+0xfb10a1a8>
8112aefc:	d9801a04 	addi	r6,sp,104
8112af00:	b80b883a 	mov	r5,r23
8112af04:	a809883a 	mov	r4,r21
8112af08:	1129e8c0 	call	81129e8c <__ssprint_r>
8112af0c:	103f651e 	bne	r2,zero,8112aca4 <__reset+0xfb10aca4>
8112af10:	d8c01c17 	ldw	r3,112(sp)
8112af14:	003f4f06 	br	8112ac54 <__reset+0xfb10ac54>
8112af18:	00a04574 	movhi	r2,33045
8112af1c:	10a97f04 	addi	r2,r2,-23044
8112af20:	d8802915 	stw	r2,164(sp)
8112af24:	003d4406 	br	8112a438 <__reset+0xfb10a438>
8112af28:	dac02317 	ldw	r11,140(sp)
8112af2c:	58800017 	ldw	r2,0(r11)
8112af30:	dac02517 	ldw	r11,148(sp)
8112af34:	5807d7fa 	srai	r3,r11,31
8112af38:	dac02317 	ldw	r11,140(sp)
8112af3c:	10c00115 	stw	r3,4(r2)
8112af40:	5ac00104 	addi	r11,r11,4
8112af44:	dac02315 	stw	r11,140(sp)
8112af48:	dac02517 	ldw	r11,148(sp)
8112af4c:	12c00015 	stw	r11,0(r2)
8112af50:	003c6d06 	br	8112a108 <__reset+0xfb10a108>
8112af54:	9080100c 	andi	r2,r18,64
8112af58:	dac02317 	ldw	r11,140(sp)
8112af5c:	103e5326 	beq	r2,zero,8112a8ac <__reset+0xfb10a8ac>
8112af60:	5f00000f 	ldh	fp,0(r11)
8112af64:	5ac00104 	addi	r11,r11,4
8112af68:	dac02315 	stw	r11,140(sp)
8112af6c:	e013d7fa 	srai	r9,fp,31
8112af70:	4805883a 	mov	r2,r9
8112af74:	003e0706 	br	8112a794 <__reset+0xfb10a794>
8112af78:	00800c04 	movi	r2,48
8112af7c:	d8801d05 	stb	r2,116(sp)
8112af80:	d8c01d45 	stb	r3,117(sp)
8112af84:	d8001d85 	stb	zero,118(sp)
8112af88:	90800094 	ori	r2,r18,2
8112af8c:	80008f16 	blt	r16,zero,8112b1cc <___svfiprintf_internal_r+0x1168>
8112af90:	00bfdfc4 	movi	r2,-129
8112af94:	90a4703a 	and	r18,r18,r2
8112af98:	94800094 	ori	r18,r18,2
8112af9c:	0015883a 	mov	r10,zero
8112afa0:	003d2906 	br	8112a448 <__reset+0xfb10a448>
8112afa4:	98c00007 	ldb	r3,0(r19)
8112afa8:	003c7f06 	br	8112a1a8 <__reset+0xfb10a1a8>
8112afac:	dac02317 	ldw	r11,140(sp)
8112afb0:	0013883a 	mov	r9,zero
8112afb4:	5f000017 	ldw	fp,0(r11)
8112afb8:	5ac00104 	addi	r11,r11,4
8112afbc:	dac02315 	stw	r11,140(sp)
8112afc0:	003d1506 	br	8112a418 <__reset+0xfb10a418>
8112afc4:	9080100c 	andi	r2,r18,64
8112afc8:	d8001d85 	stb	zero,118(sp)
8112afcc:	dac02317 	ldw	r11,140(sp)
8112afd0:	10003426 	beq	r2,zero,8112b0a4 <___svfiprintf_internal_r+0x1040>
8112afd4:	58800104 	addi	r2,r11,4
8112afd8:	5f00000b 	ldhu	fp,0(r11)
8112afdc:	0013883a 	mov	r9,zero
8112afe0:	803e950e 	bge	r16,zero,8112aa38 <__reset+0xfb10aa38>
8112afe4:	e246b03a 	or	r3,fp,r9
8112afe8:	d8802315 	stw	r2,140(sp)
8112afec:	183d5a1e 	bne	r3,zero,8112a558 <__reset+0xfb10a558>
8112aff0:	0015883a 	mov	r10,zero
8112aff4:	0005883a 	mov	r2,zero
8112aff8:	003fb706 	br	8112aed8 <__reset+0xfb10aed8>
8112affc:	98c00043 	ldbu	r3,1(r19)
8112b000:	94800814 	ori	r18,r18,32
8112b004:	9cc00044 	addi	r19,r19,1
8112b008:	18c03fcc 	andi	r3,r3,255
8112b00c:	18c0201c 	xori	r3,r3,128
8112b010:	18ffe004 	addi	r3,r3,-128
8112b014:	003c6406 	br	8112a1a8 <__reset+0xfb10a1a8>
8112b018:	d8c02315 	stw	r3,140(sp)
8112b01c:	0015883a 	mov	r10,zero
8112b020:	003faa06 	br	8112aecc <__reset+0xfb10aecc>
8112b024:	dac02317 	ldw	r11,140(sp)
8112b028:	58800017 	ldw	r2,0(r11)
8112b02c:	5ac00104 	addi	r11,r11,4
8112b030:	dac02315 	stw	r11,140(sp)
8112b034:	dac02517 	ldw	r11,148(sp)
8112b038:	12c00015 	stw	r11,0(r2)
8112b03c:	003c3206 	br	8112a108 <__reset+0xfb10a108>
8112b040:	01204574 	movhi	r4,33045
8112b044:	21297f04 	addi	r4,r4,-23044
8112b048:	d9002915 	stw	r4,164(sp)
8112b04c:	d8c02315 	stw	r3,140(sp)
8112b050:	1025883a 	mov	r18,r2
8112b054:	e244b03a 	or	r2,fp,r9
8112b058:	103f871e 	bne	r2,zero,8112ae78 <__reset+0xfb10ae78>
8112b05c:	0015883a 	mov	r10,zero
8112b060:	00800084 	movi	r2,2
8112b064:	003f9c06 	br	8112aed8 <__reset+0xfb10aed8>
8112b068:	0039883a 	mov	fp,zero
8112b06c:	003e5f06 	br	8112a9ec <__reset+0xfb10a9ec>
8112b070:	d9801a04 	addi	r6,sp,104
8112b074:	b80b883a 	mov	r5,r23
8112b078:	a809883a 	mov	r4,r21
8112b07c:	1129e8c0 	call	81129e8c <__ssprint_r>
8112b080:	103f081e 	bne	r2,zero,8112aca4 <__reset+0xfb10aca4>
8112b084:	d8c01c17 	ldw	r3,112(sp)
8112b088:	d8801b17 	ldw	r2,108(sp)
8112b08c:	d811883a 	mov	r8,sp
8112b090:	003e9106 	br	8112aad8 <__reset+0xfb10aad8>
8112b094:	01204574 	movhi	r4,33045
8112b098:	212a0904 	addi	r4,r4,-22492
8112b09c:	d9002215 	stw	r4,136(sp)
8112b0a0:	003ead06 	br	8112ab58 <__reset+0xfb10ab58>
8112b0a4:	58800104 	addi	r2,r11,4
8112b0a8:	5f000017 	ldw	fp,0(r11)
8112b0ac:	0013883a 	mov	r9,zero
8112b0b0:	803e610e 	bge	r16,zero,8112aa38 <__reset+0xfb10aa38>
8112b0b4:	003fcb06 	br	8112afe4 <__reset+0xfb10afe4>
8112b0b8:	58800104 	addi	r2,r11,4
8112b0bc:	5f000017 	ldw	fp,0(r11)
8112b0c0:	0013883a 	mov	r9,zero
8112b0c4:	803e420e 	bge	r16,zero,8112a9d0 <__reset+0xfb10a9d0>
8112b0c8:	003f7e06 	br	8112aec4 <__reset+0xfb10aec4>
8112b0cc:	5f000017 	ldw	fp,0(r11)
8112b0d0:	5ac00104 	addi	r11,r11,4
8112b0d4:	0013883a 	mov	r9,zero
8112b0d8:	dac02315 	stw	r11,140(sp)
8112b0dc:	003cce06 	br	8112a418 <__reset+0xfb10a418>
8112b0e0:	8809883a 	mov	r4,r17
8112b0e4:	da002c15 	stw	r8,176(sp)
8112b0e8:	111cf340 	call	8111cf34 <strlen>
8112b0ec:	d8802115 	stw	r2,132(sp)
8112b0f0:	da801d83 	ldbu	r10,118(sp)
8112b0f4:	df002315 	stw	fp,140(sp)
8112b0f8:	0021883a 	mov	r16,zero
8112b0fc:	da002c17 	ldw	r8,176(sp)
8112b100:	003cf606 	br	8112a4dc <__reset+0xfb10a4dc>
8112b104:	00800184 	movi	r2,6
8112b108:	1400012e 	bgeu	r2,r16,8112b110 <___svfiprintf_internal_r+0x10ac>
8112b10c:	1021883a 	mov	r16,r2
8112b110:	dc002115 	stw	r16,132(sp)
8112b114:	8005883a 	mov	r2,r16
8112b118:	80003c16 	blt	r16,zero,8112b20c <___svfiprintf_internal_r+0x11a8>
8112b11c:	04604574 	movhi	r17,33045
8112b120:	d8802015 	stw	r2,128(sp)
8112b124:	df002315 	stw	fp,140(sp)
8112b128:	8c698404 	addi	r17,r17,-23024
8112b12c:	003d2e06 	br	8112a5e8 <__reset+0xfb10a5e8>
8112b130:	04001004 	movi	r16,64
8112b134:	800b883a 	mov	r5,r16
8112b138:	111bc2c0 	call	8111bc2c <_malloc_r>
8112b13c:	dac02717 	ldw	r11,156(sp)
8112b140:	58800015 	stw	r2,0(r11)
8112b144:	58800415 	stw	r2,16(r11)
8112b148:	10004826 	beq	r2,zero,8112b26c <___svfiprintf_internal_r+0x1208>
8112b14c:	dac02717 	ldw	r11,156(sp)
8112b150:	5c000515 	stw	r16,20(r11)
8112b154:	003bd906 	br	8112a0bc <__reset+0xfb10a0bc>
8112b158:	9080004c 	andi	r2,r18,1
8112b15c:	0015883a 	mov	r10,zero
8112b160:	10000626 	beq	r2,zero,8112b17c <___svfiprintf_internal_r+0x1118>
8112b164:	dac02b17 	ldw	r11,172(sp)
8112b168:	00800c04 	movi	r2,48
8112b16c:	d88019c5 	stb	r2,103(sp)
8112b170:	dac02115 	stw	r11,132(sp)
8112b174:	dc4019c4 	addi	r17,sp,103
8112b178:	003cd806 	br	8112a4dc <__reset+0xfb10a4dc>
8112b17c:	d8002115 	stw	zero,132(sp)
8112b180:	dc401a04 	addi	r17,sp,104
8112b184:	003cd506 	br	8112a4dc <__reset+0xfb10a4dc>
8112b188:	01204574 	movhi	r4,33045
8112b18c:	212a0d04 	addi	r4,r4,-22476
8112b190:	d9002815 	stw	r4,160(sp)
8112b194:	003d4306 	br	8112a6a4 <__reset+0xfb10a6a4>
8112b198:	00bfffc4 	movi	r2,-1
8112b19c:	003ec606 	br	8112acb8 <__reset+0xfb10acb8>
8112b1a0:	00800044 	movi	r2,1
8112b1a4:	10803fcc 	andi	r2,r2,255
8112b1a8:	00c00044 	movi	r3,1
8112b1ac:	10fd8026 	beq	r2,r3,8112a7b0 <__reset+0xfb10a7b0>
8112b1b0:	00c00084 	movi	r3,2
8112b1b4:	10fca426 	beq	r2,r3,8112a448 <__reset+0xfb10a448>
8112b1b8:	003ce806 	br	8112a55c <__reset+0xfb10a55c>
8112b1bc:	01204574 	movhi	r4,33045
8112b1c0:	212a0d04 	addi	r4,r4,-22476
8112b1c4:	d9002815 	stw	r4,160(sp)
8112b1c8:	003e9906 	br	8112ac30 <__reset+0xfb10ac30>
8112b1cc:	1025883a 	mov	r18,r2
8112b1d0:	0015883a 	mov	r10,zero
8112b1d4:	00800084 	movi	r2,2
8112b1d8:	003ff206 	br	8112b1a4 <__reset+0xfb10b1a4>
8112b1dc:	01604574 	movhi	r5,33045
8112b1e0:	296a0904 	addi	r5,r5,-22492
8112b1e4:	d9402215 	stw	r5,136(sp)
8112b1e8:	003ee206 	br	8112ad74 <__reset+0xfb10ad74>
8112b1ec:	5827883a 	mov	r19,r11
8112b1f0:	0021883a 	mov	r16,zero
8112b1f4:	003bed06 	br	8112a1ac <__reset+0xfb10a1ac>
8112b1f8:	dc002115 	stw	r16,132(sp)
8112b1fc:	da801d83 	ldbu	r10,118(sp)
8112b200:	df002315 	stw	fp,140(sp)
8112b204:	0021883a 	mov	r16,zero
8112b208:	003cb406 	br	8112a4dc <__reset+0xfb10a4dc>
8112b20c:	0005883a 	mov	r2,zero
8112b210:	003fc206 	br	8112b11c <__reset+0xfb10b11c>
8112b214:	d8802317 	ldw	r2,140(sp)
8112b218:	98c00043 	ldbu	r3,1(r19)
8112b21c:	5827883a 	mov	r19,r11
8112b220:	14000017 	ldw	r16,0(r2)
8112b224:	10800104 	addi	r2,r2,4
8112b228:	d8802315 	stw	r2,140(sp)
8112b22c:	803f760e 	bge	r16,zero,8112b008 <__reset+0xfb10b008>
8112b230:	18c03fcc 	andi	r3,r3,255
8112b234:	18c0201c 	xori	r3,r3,128
8112b238:	043fffc4 	movi	r16,-1
8112b23c:	18ffe004 	addi	r3,r3,-128
8112b240:	003bd906 	br	8112a1a8 <__reset+0xfb10a1a8>
8112b244:	d9c01d85 	stb	r7,118(sp)
8112b248:	003cb606 	br	8112a524 <__reset+0xfb10a524>
8112b24c:	d9c01d85 	stb	r7,118(sp)
8112b250:	003d2106 	br	8112a6d8 <__reset+0xfb10a6d8>
8112b254:	d9c01d85 	stb	r7,118(sp)
8112b258:	003d8e06 	br	8112a894 <__reset+0xfb10a894>
8112b25c:	d9c01d85 	stb	r7,118(sp)
8112b260:	003db306 	br	8112a930 <__reset+0xfb10a930>
8112b264:	d9c01d85 	stb	r7,118(sp)
8112b268:	003c8a06 	br	8112a494 <__reset+0xfb10a494>
8112b26c:	dac02a17 	ldw	r11,168(sp)
8112b270:	00800304 	movi	r2,12
8112b274:	58800015 	stw	r2,0(r11)
8112b278:	00bfffc4 	movi	r2,-1
8112b27c:	003e8e06 	br	8112acb8 <__reset+0xfb10acb8>
8112b280:	d9c01d85 	stb	r7,118(sp)
8112b284:	003dc706 	br	8112a9a4 <__reset+0xfb10a9a4>
8112b288:	d9c01d85 	stb	r7,118(sp)
8112b28c:	003ddf06 	br	8112aa0c <__reset+0xfb10aa0c>
8112b290:	d9c01d85 	stb	r7,118(sp)
8112b294:	003d3706 	br	8112a774 <__reset+0xfb10a774>
8112b298:	d9c01d85 	stb	r7,118(sp)
8112b29c:	003c5406 	br	8112a3f0 <__reset+0xfb10a3f0>
8112b2a0:	d9c01d85 	stb	r7,118(sp)
8112b2a4:	003d1d06 	br	8112a71c <__reset+0xfb10a71c>

8112b2a8 <__submore>:
8112b2a8:	defffa04 	addi	sp,sp,-24
8112b2ac:	de00012e 	bgeu	sp,et,8112b2b4 <__submore+0xc>
8112b2b0:	003b68fa 	trap	3
8112b2b4:	dc000015 	stw	r16,0(sp)
8112b2b8:	2821883a 	mov	r16,r5
8112b2bc:	29400c17 	ldw	r5,48(r5)
8112b2c0:	dfc00515 	stw	ra,20(sp)
8112b2c4:	dd000415 	stw	r20,16(sp)
8112b2c8:	dcc00315 	stw	r19,12(sp)
8112b2cc:	dc800215 	stw	r18,8(sp)
8112b2d0:	dc400115 	stw	r17,4(sp)
8112b2d4:	80801004 	addi	r2,r16,64
8112b2d8:	28801726 	beq	r5,r2,8112b338 <__submore+0x90>
8112b2dc:	84400d17 	ldw	r17,52(r16)
8112b2e0:	8c67883a 	add	r19,r17,r17
8112b2e4:	980d883a 	mov	r6,r19
8112b2e8:	11277340 	call	81127734 <_realloc_r>
8112b2ec:	1025883a 	mov	r18,r2
8112b2f0:	10002226 	beq	r2,zero,8112b37c <__submore+0xd4>
8112b2f4:	1469883a 	add	r20,r2,r17
8112b2f8:	880d883a 	mov	r6,r17
8112b2fc:	100b883a 	mov	r5,r2
8112b300:	a009883a 	mov	r4,r20
8112b304:	111c4400 	call	8111c440 <memcpy>
8112b308:	0005883a 	mov	r2,zero
8112b30c:	85000015 	stw	r20,0(r16)
8112b310:	84800c15 	stw	r18,48(r16)
8112b314:	84c00d15 	stw	r19,52(r16)
8112b318:	dfc00517 	ldw	ra,20(sp)
8112b31c:	dd000417 	ldw	r20,16(sp)
8112b320:	dcc00317 	ldw	r19,12(sp)
8112b324:	dc800217 	ldw	r18,8(sp)
8112b328:	dc400117 	ldw	r17,4(sp)
8112b32c:	dc000017 	ldw	r16,0(sp)
8112b330:	dec00604 	addi	sp,sp,24
8112b334:	f800283a 	ret
8112b338:	04410004 	movi	r17,1024
8112b33c:	880b883a 	mov	r5,r17
8112b340:	111bc2c0 	call	8111bc2c <_malloc_r>
8112b344:	1007883a 	mov	r3,r2
8112b348:	10000c26 	beq	r2,zero,8112b37c <__submore+0xd4>
8112b34c:	80801083 	ldbu	r2,66(r16)
8112b350:	80c00c15 	stw	r3,48(r16)
8112b354:	84400d15 	stw	r17,52(r16)
8112b358:	1880ffc5 	stb	r2,1023(r3)
8112b35c:	81401043 	ldbu	r5,65(r16)
8112b360:	1900ff44 	addi	r4,r3,1021
8112b364:	0005883a 	mov	r2,zero
8112b368:	1940ff85 	stb	r5,1022(r3)
8112b36c:	81401003 	ldbu	r5,64(r16)
8112b370:	1940ff45 	stb	r5,1021(r3)
8112b374:	81000015 	stw	r4,0(r16)
8112b378:	003fe706 	br	8112b318 <__reset+0xfb10b318>
8112b37c:	00bfffc4 	movi	r2,-1
8112b380:	003fe506 	br	8112b318 <__reset+0xfb10b318>

8112b384 <_ungetc_r>:
8112b384:	00bfffc4 	movi	r2,-1
8112b388:	28806326 	beq	r5,r2,8112b518 <_ungetc_r+0x194>
8112b38c:	defffb04 	addi	sp,sp,-20
8112b390:	de00012e 	bgeu	sp,et,8112b398 <_ungetc_r+0x14>
8112b394:	003b68fa 	trap	3
8112b398:	dcc00315 	stw	r19,12(sp)
8112b39c:	dc400115 	stw	r17,4(sp)
8112b3a0:	dc000015 	stw	r16,0(sp)
8112b3a4:	dfc00415 	stw	ra,16(sp)
8112b3a8:	dc800215 	stw	r18,8(sp)
8112b3ac:	2023883a 	mov	r17,r4
8112b3b0:	3021883a 	mov	r16,r6
8112b3b4:	2827883a 	mov	r19,r5
8112b3b8:	20000226 	beq	r4,zero,8112b3c4 <_ungetc_r+0x40>
8112b3bc:	20800e17 	ldw	r2,56(r4)
8112b3c0:	10002e26 	beq	r2,zero,8112b47c <_ungetc_r+0xf8>
8112b3c4:	80c0030b 	ldhu	r3,12(r16)
8112b3c8:	1888000c 	andi	r2,r3,8192
8112b3cc:	1000051e 	bne	r2,zero,8112b3e4 <_ungetc_r+0x60>
8112b3d0:	81001917 	ldw	r4,100(r16)
8112b3d4:	00b7ffc4 	movi	r2,-8193
8112b3d8:	18c80014 	ori	r3,r3,8192
8112b3dc:	2084703a 	and	r2,r4,r2
8112b3e0:	80801915 	stw	r2,100(r16)
8112b3e4:	00bff7c4 	movi	r2,-33
8112b3e8:	1884703a 	and	r2,r3,r2
8112b3ec:	8080030d 	sth	r2,12(r16)
8112b3f0:	1900010c 	andi	r4,r3,4
8112b3f4:	2000061e 	bne	r4,zero,8112b410 <_ungetc_r+0x8c>
8112b3f8:	1900040c 	andi	r4,r3,16
8112b3fc:	20001d26 	beq	r4,zero,8112b474 <_ungetc_r+0xf0>
8112b400:	18c0020c 	andi	r3,r3,8
8112b404:	1800331e 	bne	r3,zero,8112b4d4 <_ungetc_r+0x150>
8112b408:	10800114 	ori	r2,r2,4
8112b40c:	8080030d 	sth	r2,12(r16)
8112b410:	80800c17 	ldw	r2,48(r16)
8112b414:	9c803fcc 	andi	r18,r19,255
8112b418:	10001a26 	beq	r2,zero,8112b484 <_ungetc_r+0x100>
8112b41c:	80c00117 	ldw	r3,4(r16)
8112b420:	80800d17 	ldw	r2,52(r16)
8112b424:	18800f0e 	bge	r3,r2,8112b464 <_ungetc_r+0xe0>
8112b428:	80c00017 	ldw	r3,0(r16)
8112b42c:	9005883a 	mov	r2,r18
8112b430:	193fffc4 	addi	r4,r3,-1
8112b434:	81000015 	stw	r4,0(r16)
8112b438:	1cffffc5 	stb	r19,-1(r3)
8112b43c:	80c00117 	ldw	r3,4(r16)
8112b440:	18c00044 	addi	r3,r3,1
8112b444:	80c00115 	stw	r3,4(r16)
8112b448:	dfc00417 	ldw	ra,16(sp)
8112b44c:	dcc00317 	ldw	r19,12(sp)
8112b450:	dc800217 	ldw	r18,8(sp)
8112b454:	dc400117 	ldw	r17,4(sp)
8112b458:	dc000017 	ldw	r16,0(sp)
8112b45c:	dec00504 	addi	sp,sp,20
8112b460:	f800283a 	ret
8112b464:	800b883a 	mov	r5,r16
8112b468:	8809883a 	mov	r4,r17
8112b46c:	112b2a80 	call	8112b2a8 <__submore>
8112b470:	103fed26 	beq	r2,zero,8112b428 <__reset+0xfb10b428>
8112b474:	00bfffc4 	movi	r2,-1
8112b478:	003ff306 	br	8112b448 <__reset+0xfb10b448>
8112b47c:	11252080 	call	81125208 <__sinit>
8112b480:	003fd006 	br	8112b3c4 <__reset+0xfb10b3c4>
8112b484:	80c00417 	ldw	r3,16(r16)
8112b488:	80800017 	ldw	r2,0(r16)
8112b48c:	18000326 	beq	r3,zero,8112b49c <_ungetc_r+0x118>
8112b490:	1880022e 	bgeu	r3,r2,8112b49c <_ungetc_r+0x118>
8112b494:	10ffffc3 	ldbu	r3,-1(r2)
8112b498:	90c01826 	beq	r18,r3,8112b4fc <_ungetc_r+0x178>
8112b49c:	81400117 	ldw	r5,4(r16)
8112b4a0:	80800e15 	stw	r2,56(r16)
8112b4a4:	008000c4 	movi	r2,3
8112b4a8:	81001004 	addi	r4,r16,64
8112b4ac:	80c01084 	addi	r3,r16,66
8112b4b0:	80800d15 	stw	r2,52(r16)
8112b4b4:	00800044 	movi	r2,1
8112b4b8:	80800115 	stw	r2,4(r16)
8112b4bc:	81400f15 	stw	r5,60(r16)
8112b4c0:	81000c15 	stw	r4,48(r16)
8112b4c4:	84c01085 	stb	r19,66(r16)
8112b4c8:	80c00015 	stw	r3,0(r16)
8112b4cc:	9005883a 	mov	r2,r18
8112b4d0:	003fdd06 	br	8112b448 <__reset+0xfb10b448>
8112b4d4:	800b883a 	mov	r5,r16
8112b4d8:	8809883a 	mov	r4,r17
8112b4dc:	1124e0c0 	call	81124e0c <_fflush_r>
8112b4e0:	103fe41e 	bne	r2,zero,8112b474 <__reset+0xfb10b474>
8112b4e4:	8080030b 	ldhu	r2,12(r16)
8112b4e8:	00fffdc4 	movi	r3,-9
8112b4ec:	80000215 	stw	zero,8(r16)
8112b4f0:	1884703a 	and	r2,r3,r2
8112b4f4:	80000615 	stw	zero,24(r16)
8112b4f8:	003fc306 	br	8112b408 <__reset+0xfb10b408>
8112b4fc:	80c00117 	ldw	r3,4(r16)
8112b500:	10bfffc4 	addi	r2,r2,-1
8112b504:	80800015 	stw	r2,0(r16)
8112b508:	18800044 	addi	r2,r3,1
8112b50c:	80800115 	stw	r2,4(r16)
8112b510:	9005883a 	mov	r2,r18
8112b514:	003fcc06 	br	8112b448 <__reset+0xfb10b448>
8112b518:	00bfffc4 	movi	r2,-1
8112b51c:	f800283a 	ret

8112b520 <ungetc>:
8112b520:	00a04574 	movhi	r2,33045
8112b524:	10b34e04 	addi	r2,r2,-13000
8112b528:	280d883a 	mov	r6,r5
8112b52c:	200b883a 	mov	r5,r4
8112b530:	11000017 	ldw	r4,0(r2)
8112b534:	112b3841 	jmpi	8112b384 <_ungetc_r>

8112b538 <__sprint_r.part.0>:
8112b538:	defff604 	addi	sp,sp,-40
8112b53c:	de00012e 	bgeu	sp,et,8112b544 <__sprint_r.part.0+0xc>
8112b540:	003b68fa 	trap	3
8112b544:	28801917 	ldw	r2,100(r5)
8112b548:	dd400515 	stw	r21,20(sp)
8112b54c:	dfc00915 	stw	ra,36(sp)
8112b550:	df000815 	stw	fp,32(sp)
8112b554:	ddc00715 	stw	r23,28(sp)
8112b558:	dd800615 	stw	r22,24(sp)
8112b55c:	dd000415 	stw	r20,16(sp)
8112b560:	dcc00315 	stw	r19,12(sp)
8112b564:	dc800215 	stw	r18,8(sp)
8112b568:	dc400115 	stw	r17,4(sp)
8112b56c:	dc000015 	stw	r16,0(sp)
8112b570:	1088000c 	andi	r2,r2,8192
8112b574:	302b883a 	mov	r21,r6
8112b578:	10002e26 	beq	r2,zero,8112b634 <__sprint_r.part.0+0xfc>
8112b57c:	30800217 	ldw	r2,8(r6)
8112b580:	35800017 	ldw	r22,0(r6)
8112b584:	10002926 	beq	r2,zero,8112b62c <__sprint_r.part.0+0xf4>
8112b588:	2827883a 	mov	r19,r5
8112b58c:	2029883a 	mov	r20,r4
8112b590:	b5c00104 	addi	r23,r22,4
8112b594:	04bfffc4 	movi	r18,-1
8112b598:	bc400017 	ldw	r17,0(r23)
8112b59c:	b4000017 	ldw	r16,0(r22)
8112b5a0:	0039883a 	mov	fp,zero
8112b5a4:	8822d0ba 	srli	r17,r17,2
8112b5a8:	8800031e 	bne	r17,zero,8112b5b8 <__sprint_r.part.0+0x80>
8112b5ac:	00001806 	br	8112b610 <__sprint_r.part.0+0xd8>
8112b5b0:	84000104 	addi	r16,r16,4
8112b5b4:	8f001526 	beq	r17,fp,8112b60c <__sprint_r.part.0+0xd4>
8112b5b8:	81400017 	ldw	r5,0(r16)
8112b5bc:	980d883a 	mov	r6,r19
8112b5c0:	a009883a 	mov	r4,r20
8112b5c4:	112cedc0 	call	8112cedc <_fputwc_r>
8112b5c8:	e7000044 	addi	fp,fp,1
8112b5cc:	14bff81e 	bne	r2,r18,8112b5b0 <__reset+0xfb10b5b0>
8112b5d0:	9005883a 	mov	r2,r18
8112b5d4:	a8000215 	stw	zero,8(r21)
8112b5d8:	a8000115 	stw	zero,4(r21)
8112b5dc:	dfc00917 	ldw	ra,36(sp)
8112b5e0:	df000817 	ldw	fp,32(sp)
8112b5e4:	ddc00717 	ldw	r23,28(sp)
8112b5e8:	dd800617 	ldw	r22,24(sp)
8112b5ec:	dd400517 	ldw	r21,20(sp)
8112b5f0:	dd000417 	ldw	r20,16(sp)
8112b5f4:	dcc00317 	ldw	r19,12(sp)
8112b5f8:	dc800217 	ldw	r18,8(sp)
8112b5fc:	dc400117 	ldw	r17,4(sp)
8112b600:	dc000017 	ldw	r16,0(sp)
8112b604:	dec00a04 	addi	sp,sp,40
8112b608:	f800283a 	ret
8112b60c:	a8800217 	ldw	r2,8(r21)
8112b610:	8c63883a 	add	r17,r17,r17
8112b614:	8c63883a 	add	r17,r17,r17
8112b618:	1445c83a 	sub	r2,r2,r17
8112b61c:	a8800215 	stw	r2,8(r21)
8112b620:	b5800204 	addi	r22,r22,8
8112b624:	bdc00204 	addi	r23,r23,8
8112b628:	103fdb1e 	bne	r2,zero,8112b598 <__reset+0xfb10b598>
8112b62c:	0005883a 	mov	r2,zero
8112b630:	003fe806 	br	8112b5d4 <__reset+0xfb10b5d4>
8112b634:	11259b80 	call	811259b8 <__sfvwrite_r>
8112b638:	003fe606 	br	8112b5d4 <__reset+0xfb10b5d4>

8112b63c <__sprint_r>:
8112b63c:	30c00217 	ldw	r3,8(r6)
8112b640:	18000126 	beq	r3,zero,8112b648 <__sprint_r+0xc>
8112b644:	112b5381 	jmpi	8112b538 <__sprint_r.part.0>
8112b648:	30000115 	stw	zero,4(r6)
8112b64c:	0005883a 	mov	r2,zero
8112b650:	f800283a 	ret

8112b654 <___vfiprintf_internal_r>:
8112b654:	deffc904 	addi	sp,sp,-220
8112b658:	de00012e 	bgeu	sp,et,8112b660 <___vfiprintf_internal_r+0xc>
8112b65c:	003b68fa 	trap	3
8112b660:	df003515 	stw	fp,212(sp)
8112b664:	dd003115 	stw	r20,196(sp)
8112b668:	dfc03615 	stw	ra,216(sp)
8112b66c:	ddc03415 	stw	r23,208(sp)
8112b670:	dd803315 	stw	r22,204(sp)
8112b674:	dd403215 	stw	r21,200(sp)
8112b678:	dcc03015 	stw	r19,192(sp)
8112b67c:	dc802f15 	stw	r18,188(sp)
8112b680:	dc402e15 	stw	r17,184(sp)
8112b684:	dc002d15 	stw	r16,180(sp)
8112b688:	d9002015 	stw	r4,128(sp)
8112b68c:	d9c02215 	stw	r7,136(sp)
8112b690:	2829883a 	mov	r20,r5
8112b694:	3039883a 	mov	fp,r6
8112b698:	20000226 	beq	r4,zero,8112b6a4 <___vfiprintf_internal_r+0x50>
8112b69c:	20800e17 	ldw	r2,56(r4)
8112b6a0:	1000cf26 	beq	r2,zero,8112b9e0 <___vfiprintf_internal_r+0x38c>
8112b6a4:	a080030b 	ldhu	r2,12(r20)
8112b6a8:	10c8000c 	andi	r3,r2,8192
8112b6ac:	1800061e 	bne	r3,zero,8112b6c8 <___vfiprintf_internal_r+0x74>
8112b6b0:	a1001917 	ldw	r4,100(r20)
8112b6b4:	00f7ffc4 	movi	r3,-8193
8112b6b8:	10880014 	ori	r2,r2,8192
8112b6bc:	20c6703a 	and	r3,r4,r3
8112b6c0:	a080030d 	sth	r2,12(r20)
8112b6c4:	a0c01915 	stw	r3,100(r20)
8112b6c8:	10c0020c 	andi	r3,r2,8
8112b6cc:	1800a926 	beq	r3,zero,8112b974 <___vfiprintf_internal_r+0x320>
8112b6d0:	a0c00417 	ldw	r3,16(r20)
8112b6d4:	1800a726 	beq	r3,zero,8112b974 <___vfiprintf_internal_r+0x320>
8112b6d8:	1080068c 	andi	r2,r2,26
8112b6dc:	00c00284 	movi	r3,10
8112b6e0:	10c0ac26 	beq	r2,r3,8112b994 <___vfiprintf_internal_r+0x340>
8112b6e4:	da801a04 	addi	r10,sp,104
8112b6e8:	da801e15 	stw	r10,120(sp)
8112b6ec:	d8801e17 	ldw	r2,120(sp)
8112b6f0:	da8019c4 	addi	r10,sp,103
8112b6f4:	05a04574 	movhi	r22,33045
8112b6f8:	05e04574 	movhi	r23,33045
8112b6fc:	da801f15 	stw	r10,124(sp)
8112b700:	1295c83a 	sub	r10,r2,r10
8112b704:	b5aa1504 	addi	r22,r22,-22444
8112b708:	bdea1104 	addi	r23,r23,-22460
8112b70c:	dec01a15 	stw	sp,104(sp)
8112b710:	d8001c15 	stw	zero,112(sp)
8112b714:	d8001b15 	stw	zero,108(sp)
8112b718:	d8002615 	stw	zero,152(sp)
8112b71c:	d8002315 	stw	zero,140(sp)
8112b720:	da802715 	stw	r10,156(sp)
8112b724:	d811883a 	mov	r8,sp
8112b728:	dd002115 	stw	r20,132(sp)
8112b72c:	e021883a 	mov	r16,fp
8112b730:	80800007 	ldb	r2,0(r16)
8112b734:	1003ea26 	beq	r2,zero,8112c6e0 <___vfiprintf_internal_r+0x108c>
8112b738:	00c00944 	movi	r3,37
8112b73c:	8025883a 	mov	r18,r16
8112b740:	10c0021e 	bne	r2,r3,8112b74c <___vfiprintf_internal_r+0xf8>
8112b744:	00001606 	br	8112b7a0 <___vfiprintf_internal_r+0x14c>
8112b748:	10c00326 	beq	r2,r3,8112b758 <___vfiprintf_internal_r+0x104>
8112b74c:	94800044 	addi	r18,r18,1
8112b750:	90800007 	ldb	r2,0(r18)
8112b754:	103ffc1e 	bne	r2,zero,8112b748 <__reset+0xfb10b748>
8112b758:	9423c83a 	sub	r17,r18,r16
8112b75c:	88001026 	beq	r17,zero,8112b7a0 <___vfiprintf_internal_r+0x14c>
8112b760:	d8c01c17 	ldw	r3,112(sp)
8112b764:	d8801b17 	ldw	r2,108(sp)
8112b768:	44000015 	stw	r16,0(r8)
8112b76c:	88c7883a 	add	r3,r17,r3
8112b770:	10800044 	addi	r2,r2,1
8112b774:	44400115 	stw	r17,4(r8)
8112b778:	d8c01c15 	stw	r3,112(sp)
8112b77c:	d8801b15 	stw	r2,108(sp)
8112b780:	010001c4 	movi	r4,7
8112b784:	2080760e 	bge	r4,r2,8112b960 <___vfiprintf_internal_r+0x30c>
8112b788:	1803821e 	bne	r3,zero,8112c594 <___vfiprintf_internal_r+0xf40>
8112b78c:	da802317 	ldw	r10,140(sp)
8112b790:	d8001b15 	stw	zero,108(sp)
8112b794:	d811883a 	mov	r8,sp
8112b798:	5455883a 	add	r10,r10,r17
8112b79c:	da802315 	stw	r10,140(sp)
8112b7a0:	90800007 	ldb	r2,0(r18)
8112b7a4:	10044626 	beq	r2,zero,8112c8c0 <___vfiprintf_internal_r+0x126c>
8112b7a8:	90c00047 	ldb	r3,1(r18)
8112b7ac:	94000044 	addi	r16,r18,1
8112b7b0:	d8001d85 	stb	zero,118(sp)
8112b7b4:	0009883a 	mov	r4,zero
8112b7b8:	000f883a 	mov	r7,zero
8112b7bc:	027fffc4 	movi	r9,-1
8112b7c0:	0023883a 	mov	r17,zero
8112b7c4:	0029883a 	mov	r20,zero
8112b7c8:	01401604 	movi	r5,88
8112b7cc:	01800244 	movi	r6,9
8112b7d0:	03400a84 	movi	r13,42
8112b7d4:	03001b04 	movi	r12,108
8112b7d8:	84000044 	addi	r16,r16,1
8112b7dc:	18bff804 	addi	r2,r3,-32
8112b7e0:	28827336 	bltu	r5,r2,8112c1b0 <___vfiprintf_internal_r+0xb5c>
8112b7e4:	100490ba 	slli	r2,r2,2
8112b7e8:	02a044f4 	movhi	r10,33043
8112b7ec:	52adff04 	addi	r10,r10,-18436
8112b7f0:	1285883a 	add	r2,r2,r10
8112b7f4:	10800017 	ldw	r2,0(r2)
8112b7f8:	1000683a 	jmp	r2
8112b7fc:	8112bee4 	muli	r4,r16,19195
8112b800:	8112c1b0 	cmpltui	r4,r16,19206
8112b804:	8112c1b0 	cmpltui	r4,r16,19206
8112b808:	8112bf04 	addi	r4,r16,19196
8112b80c:	8112c1b0 	cmpltui	r4,r16,19206
8112b810:	8112c1b0 	cmpltui	r4,r16,19206
8112b814:	8112c1b0 	cmpltui	r4,r16,19206
8112b818:	8112c1b0 	cmpltui	r4,r16,19206
8112b81c:	8112c1b0 	cmpltui	r4,r16,19206
8112b820:	8112c1b0 	cmpltui	r4,r16,19206
8112b824:	8112c0ec 	andhi	r4,r16,19203
8112b828:	8112c108 	cmpgei	r4,r16,19204
8112b82c:	8112c1b0 	cmpltui	r4,r16,19206
8112b830:	8112b9f0 	cmpltui	r4,r16,19175
8112b834:	8112c118 	cmpnei	r4,r16,19204
8112b838:	8112c1b0 	cmpltui	r4,r16,19206
8112b83c:	8112bf10 	cmplti	r4,r16,19196
8112b840:	8112bf1c 	xori	r4,r16,19196
8112b844:	8112bf1c 	xori	r4,r16,19196
8112b848:	8112bf1c 	xori	r4,r16,19196
8112b84c:	8112bf1c 	xori	r4,r16,19196
8112b850:	8112bf1c 	xori	r4,r16,19196
8112b854:	8112bf1c 	xori	r4,r16,19196
8112b858:	8112bf1c 	xori	r4,r16,19196
8112b85c:	8112bf1c 	xori	r4,r16,19196
8112b860:	8112bf1c 	xori	r4,r16,19196
8112b864:	8112c1b0 	cmpltui	r4,r16,19206
8112b868:	8112c1b0 	cmpltui	r4,r16,19206
8112b86c:	8112c1b0 	cmpltui	r4,r16,19206
8112b870:	8112c1b0 	cmpltui	r4,r16,19206
8112b874:	8112c1b0 	cmpltui	r4,r16,19206
8112b878:	8112c1b0 	cmpltui	r4,r16,19206
8112b87c:	8112c1b0 	cmpltui	r4,r16,19206
8112b880:	8112c1b0 	cmpltui	r4,r16,19206
8112b884:	8112c1b0 	cmpltui	r4,r16,19206
8112b888:	8112c1b0 	cmpltui	r4,r16,19206
8112b88c:	8112bf48 	cmpgei	r4,r16,19197
8112b890:	8112c1b0 	cmpltui	r4,r16,19206
8112b894:	8112c1b0 	cmpltui	r4,r16,19206
8112b898:	8112c1b0 	cmpltui	r4,r16,19206
8112b89c:	8112c1b0 	cmpltui	r4,r16,19206
8112b8a0:	8112c1b0 	cmpltui	r4,r16,19206
8112b8a4:	8112c1b0 	cmpltui	r4,r16,19206
8112b8a8:	8112c1b0 	cmpltui	r4,r16,19206
8112b8ac:	8112c1b0 	cmpltui	r4,r16,19206
8112b8b0:	8112c1b0 	cmpltui	r4,r16,19206
8112b8b4:	8112c1b0 	cmpltui	r4,r16,19206
8112b8b8:	8112bf80 	call	88112bf8 <__reset+0x20f2bf8>
8112b8bc:	8112c1b0 	cmpltui	r4,r16,19206
8112b8c0:	8112c1b0 	cmpltui	r4,r16,19206
8112b8c4:	8112c1b0 	cmpltui	r4,r16,19206
8112b8c8:	8112c1b0 	cmpltui	r4,r16,19206
8112b8cc:	8112c1b0 	cmpltui	r4,r16,19206
8112b8d0:	8112bfd8 	cmpnei	r4,r16,19199
8112b8d4:	8112c1b0 	cmpltui	r4,r16,19206
8112b8d8:	8112c1b0 	cmpltui	r4,r16,19206
8112b8dc:	8112c048 	cmpgei	r4,r16,19201
8112b8e0:	8112c1b0 	cmpltui	r4,r16,19206
8112b8e4:	8112c1b0 	cmpltui	r4,r16,19206
8112b8e8:	8112c1b0 	cmpltui	r4,r16,19206
8112b8ec:	8112c1b0 	cmpltui	r4,r16,19206
8112b8f0:	8112c1b0 	cmpltui	r4,r16,19206
8112b8f4:	8112c1b0 	cmpltui	r4,r16,19206
8112b8f8:	8112c1b0 	cmpltui	r4,r16,19206
8112b8fc:	8112c1b0 	cmpltui	r4,r16,19206
8112b900:	8112c1b0 	cmpltui	r4,r16,19206
8112b904:	8112c1b0 	cmpltui	r4,r16,19206
8112b908:	8112bdf4 	orhi	r4,r16,19191
8112b90c:	8112be20 	cmpeqi	r4,r16,19192
8112b910:	8112c1b0 	cmpltui	r4,r16,19206
8112b914:	8112c1b0 	cmpltui	r4,r16,19206
8112b918:	8112c1b0 	cmpltui	r4,r16,19206
8112b91c:	8112c158 	cmpnei	r4,r16,19205
8112b920:	8112be20 	cmpeqi	r4,r16,19192
8112b924:	8112c1b0 	cmpltui	r4,r16,19206
8112b928:	8112c1b0 	cmpltui	r4,r16,19206
8112b92c:	8112bcb4 	orhi	r4,r16,19186
8112b930:	8112c1b0 	cmpltui	r4,r16,19206
8112b934:	8112bcc4 	addi	r4,r16,19187
8112b938:	8112bd00 	call	88112bd0 <__reset+0x20f2bd0>
8112b93c:	8112b9fc 	xorhi	r4,r16,19175
8112b940:	8112bca8 	cmpgeui	r4,r16,19186
8112b944:	8112c1b0 	cmpltui	r4,r16,19206
8112b948:	8112c084 	addi	r4,r16,19202
8112b94c:	8112c1b0 	cmpltui	r4,r16,19206
8112b950:	8112c0dc 	xori	r4,r16,19203
8112b954:	8112c1b0 	cmpltui	r4,r16,19206
8112b958:	8112c1b0 	cmpltui	r4,r16,19206
8112b95c:	8112bda0 	cmpeqi	r4,r16,19190
8112b960:	42000204 	addi	r8,r8,8
8112b964:	da802317 	ldw	r10,140(sp)
8112b968:	5455883a 	add	r10,r10,r17
8112b96c:	da802315 	stw	r10,140(sp)
8112b970:	003f8b06 	br	8112b7a0 <__reset+0xfb10b7a0>
8112b974:	d9002017 	ldw	r4,128(sp)
8112b978:	a00b883a 	mov	r5,r20
8112b97c:	11231980 	call	81123198 <__swsetup_r>
8112b980:	1003b11e 	bne	r2,zero,8112c848 <___vfiprintf_internal_r+0x11f4>
8112b984:	a080030b 	ldhu	r2,12(r20)
8112b988:	00c00284 	movi	r3,10
8112b98c:	1080068c 	andi	r2,r2,26
8112b990:	10ff541e 	bne	r2,r3,8112b6e4 <__reset+0xfb10b6e4>
8112b994:	a080038f 	ldh	r2,14(r20)
8112b998:	103f5216 	blt	r2,zero,8112b6e4 <__reset+0xfb10b6e4>
8112b99c:	d9c02217 	ldw	r7,136(sp)
8112b9a0:	d9002017 	ldw	r4,128(sp)
8112b9a4:	e00d883a 	mov	r6,fp
8112b9a8:	a00b883a 	mov	r5,r20
8112b9ac:	112cad40 	call	8112cad4 <__sbprintf>
8112b9b0:	dfc03617 	ldw	ra,216(sp)
8112b9b4:	df003517 	ldw	fp,212(sp)
8112b9b8:	ddc03417 	ldw	r23,208(sp)
8112b9bc:	dd803317 	ldw	r22,204(sp)
8112b9c0:	dd403217 	ldw	r21,200(sp)
8112b9c4:	dd003117 	ldw	r20,196(sp)
8112b9c8:	dcc03017 	ldw	r19,192(sp)
8112b9cc:	dc802f17 	ldw	r18,188(sp)
8112b9d0:	dc402e17 	ldw	r17,184(sp)
8112b9d4:	dc002d17 	ldw	r16,180(sp)
8112b9d8:	dec03704 	addi	sp,sp,220
8112b9dc:	f800283a 	ret
8112b9e0:	11252080 	call	81125208 <__sinit>
8112b9e4:	003f2f06 	br	8112b6a4 <__reset+0xfb10b6a4>
8112b9e8:	0463c83a 	sub	r17,zero,r17
8112b9ec:	d8802215 	stw	r2,136(sp)
8112b9f0:	a5000114 	ori	r20,r20,4
8112b9f4:	80c00007 	ldb	r3,0(r16)
8112b9f8:	003f7706 	br	8112b7d8 <__reset+0xfb10b7d8>
8112b9fc:	00800c04 	movi	r2,48
8112ba00:	da802217 	ldw	r10,136(sp)
8112ba04:	d8801d05 	stb	r2,116(sp)
8112ba08:	00801e04 	movi	r2,120
8112ba0c:	d8801d45 	stb	r2,117(sp)
8112ba10:	d8001d85 	stb	zero,118(sp)
8112ba14:	50c00104 	addi	r3,r10,4
8112ba18:	54800017 	ldw	r18,0(r10)
8112ba1c:	0027883a 	mov	r19,zero
8112ba20:	a0800094 	ori	r2,r20,2
8112ba24:	48030b16 	blt	r9,zero,8112c654 <___vfiprintf_internal_r+0x1000>
8112ba28:	00bfdfc4 	movi	r2,-129
8112ba2c:	a096703a 	and	r11,r20,r2
8112ba30:	d8c02215 	stw	r3,136(sp)
8112ba34:	5d000094 	ori	r20,r11,2
8112ba38:	90032b1e 	bne	r18,zero,8112c6e8 <___vfiprintf_internal_r+0x1094>
8112ba3c:	00a04574 	movhi	r2,33045
8112ba40:	10a97f04 	addi	r2,r2,-23044
8112ba44:	d8802615 	stw	r2,152(sp)
8112ba48:	0039883a 	mov	fp,zero
8112ba4c:	48017b1e 	bne	r9,zero,8112c03c <___vfiprintf_internal_r+0x9e8>
8112ba50:	0013883a 	mov	r9,zero
8112ba54:	0027883a 	mov	r19,zero
8112ba58:	dd401a04 	addi	r21,sp,104
8112ba5c:	4825883a 	mov	r18,r9
8112ba60:	4cc0010e 	bge	r9,r19,8112ba68 <___vfiprintf_internal_r+0x414>
8112ba64:	9825883a 	mov	r18,r19
8112ba68:	e7003fcc 	andi	fp,fp,255
8112ba6c:	e700201c 	xori	fp,fp,128
8112ba70:	e73fe004 	addi	fp,fp,-128
8112ba74:	e0000126 	beq	fp,zero,8112ba7c <___vfiprintf_internal_r+0x428>
8112ba78:	94800044 	addi	r18,r18,1
8112ba7c:	a380008c 	andi	r14,r20,2
8112ba80:	70000126 	beq	r14,zero,8112ba88 <___vfiprintf_internal_r+0x434>
8112ba84:	94800084 	addi	r18,r18,2
8112ba88:	a700210c 	andi	fp,r20,132
8112ba8c:	e001df1e 	bne	fp,zero,8112c20c <___vfiprintf_internal_r+0xbb8>
8112ba90:	8c87c83a 	sub	r3,r17,r18
8112ba94:	00c1dd0e 	bge	zero,r3,8112c20c <___vfiprintf_internal_r+0xbb8>
8112ba98:	01c00404 	movi	r7,16
8112ba9c:	d8801c17 	ldw	r2,112(sp)
8112baa0:	38c3ad0e 	bge	r7,r3,8112c958 <___vfiprintf_internal_r+0x1304>
8112baa4:	02a04574 	movhi	r10,33045
8112baa8:	52aa1504 	addi	r10,r10,-22444
8112baac:	dc002915 	stw	r16,164(sp)
8112bab0:	d9801b17 	ldw	r6,108(sp)
8112bab4:	da802415 	stw	r10,144(sp)
8112bab8:	03c001c4 	movi	r15,7
8112babc:	da402515 	stw	r9,148(sp)
8112bac0:	db802815 	stw	r14,160(sp)
8112bac4:	1821883a 	mov	r16,r3
8112bac8:	00000506 	br	8112bae0 <___vfiprintf_internal_r+0x48c>
8112bacc:	31400084 	addi	r5,r6,2
8112bad0:	42000204 	addi	r8,r8,8
8112bad4:	200d883a 	mov	r6,r4
8112bad8:	843ffc04 	addi	r16,r16,-16
8112badc:	3c000d0e 	bge	r7,r16,8112bb14 <___vfiprintf_internal_r+0x4c0>
8112bae0:	10800404 	addi	r2,r2,16
8112bae4:	31000044 	addi	r4,r6,1
8112bae8:	45800015 	stw	r22,0(r8)
8112baec:	41c00115 	stw	r7,4(r8)
8112baf0:	d8801c15 	stw	r2,112(sp)
8112baf4:	d9001b15 	stw	r4,108(sp)
8112baf8:	793ff40e 	bge	r15,r4,8112bacc <__reset+0xfb10bacc>
8112bafc:	1001b51e 	bne	r2,zero,8112c1d4 <___vfiprintf_internal_r+0xb80>
8112bb00:	843ffc04 	addi	r16,r16,-16
8112bb04:	000d883a 	mov	r6,zero
8112bb08:	01400044 	movi	r5,1
8112bb0c:	d811883a 	mov	r8,sp
8112bb10:	3c3ff316 	blt	r7,r16,8112bae0 <__reset+0xfb10bae0>
8112bb14:	8007883a 	mov	r3,r16
8112bb18:	da402517 	ldw	r9,148(sp)
8112bb1c:	db802817 	ldw	r14,160(sp)
8112bb20:	dc002917 	ldw	r16,164(sp)
8112bb24:	da802417 	ldw	r10,144(sp)
8112bb28:	1885883a 	add	r2,r3,r2
8112bb2c:	40c00115 	stw	r3,4(r8)
8112bb30:	42800015 	stw	r10,0(r8)
8112bb34:	d8801c15 	stw	r2,112(sp)
8112bb38:	d9401b15 	stw	r5,108(sp)
8112bb3c:	00c001c4 	movi	r3,7
8112bb40:	19426016 	blt	r3,r5,8112c4c4 <___vfiprintf_internal_r+0xe70>
8112bb44:	d8c01d87 	ldb	r3,118(sp)
8112bb48:	42000204 	addi	r8,r8,8
8112bb4c:	29000044 	addi	r4,r5,1
8112bb50:	1801b31e 	bne	r3,zero,8112c220 <___vfiprintf_internal_r+0xbcc>
8112bb54:	7001c026 	beq	r14,zero,8112c258 <___vfiprintf_internal_r+0xc04>
8112bb58:	d8c01d04 	addi	r3,sp,116
8112bb5c:	10800084 	addi	r2,r2,2
8112bb60:	40c00015 	stw	r3,0(r8)
8112bb64:	00c00084 	movi	r3,2
8112bb68:	40c00115 	stw	r3,4(r8)
8112bb6c:	d8801c15 	stw	r2,112(sp)
8112bb70:	d9001b15 	stw	r4,108(sp)
8112bb74:	00c001c4 	movi	r3,7
8112bb78:	1902650e 	bge	r3,r4,8112c510 <___vfiprintf_internal_r+0xebc>
8112bb7c:	10029a1e 	bne	r2,zero,8112c5e8 <___vfiprintf_internal_r+0xf94>
8112bb80:	00c02004 	movi	r3,128
8112bb84:	01000044 	movi	r4,1
8112bb88:	000b883a 	mov	r5,zero
8112bb8c:	d811883a 	mov	r8,sp
8112bb90:	e0c1b31e 	bne	fp,r3,8112c260 <___vfiprintf_internal_r+0xc0c>
8112bb94:	8cb9c83a 	sub	fp,r17,r18
8112bb98:	0701b10e 	bge	zero,fp,8112c260 <___vfiprintf_internal_r+0xc0c>
8112bb9c:	01c00404 	movi	r7,16
8112bba0:	3f03890e 	bge	r7,fp,8112c9c8 <___vfiprintf_internal_r+0x1374>
8112bba4:	00e04574 	movhi	r3,33045
8112bba8:	18ea1104 	addi	r3,r3,-22460
8112bbac:	d8c02415 	stw	r3,144(sp)
8112bbb0:	8007883a 	mov	r3,r16
8112bbb4:	034001c4 	movi	r13,7
8112bbb8:	e021883a 	mov	r16,fp
8112bbbc:	da402515 	stw	r9,148(sp)
8112bbc0:	1839883a 	mov	fp,r3
8112bbc4:	00000506 	br	8112bbdc <___vfiprintf_internal_r+0x588>
8112bbc8:	29800084 	addi	r6,r5,2
8112bbcc:	42000204 	addi	r8,r8,8
8112bbd0:	180b883a 	mov	r5,r3
8112bbd4:	843ffc04 	addi	r16,r16,-16
8112bbd8:	3c000d0e 	bge	r7,r16,8112bc10 <___vfiprintf_internal_r+0x5bc>
8112bbdc:	10800404 	addi	r2,r2,16
8112bbe0:	28c00044 	addi	r3,r5,1
8112bbe4:	45c00015 	stw	r23,0(r8)
8112bbe8:	41c00115 	stw	r7,4(r8)
8112bbec:	d8801c15 	stw	r2,112(sp)
8112bbf0:	d8c01b15 	stw	r3,108(sp)
8112bbf4:	68fff40e 	bge	r13,r3,8112bbc8 <__reset+0xfb10bbc8>
8112bbf8:	1002241e 	bne	r2,zero,8112c48c <___vfiprintf_internal_r+0xe38>
8112bbfc:	843ffc04 	addi	r16,r16,-16
8112bc00:	01800044 	movi	r6,1
8112bc04:	000b883a 	mov	r5,zero
8112bc08:	d811883a 	mov	r8,sp
8112bc0c:	3c3ff316 	blt	r7,r16,8112bbdc <__reset+0xfb10bbdc>
8112bc10:	da402517 	ldw	r9,148(sp)
8112bc14:	e007883a 	mov	r3,fp
8112bc18:	8039883a 	mov	fp,r16
8112bc1c:	1821883a 	mov	r16,r3
8112bc20:	d8c02417 	ldw	r3,144(sp)
8112bc24:	1705883a 	add	r2,r2,fp
8112bc28:	47000115 	stw	fp,4(r8)
8112bc2c:	40c00015 	stw	r3,0(r8)
8112bc30:	d8801c15 	stw	r2,112(sp)
8112bc34:	d9801b15 	stw	r6,108(sp)
8112bc38:	00c001c4 	movi	r3,7
8112bc3c:	19827616 	blt	r3,r6,8112c618 <___vfiprintf_internal_r+0xfc4>
8112bc40:	4cf9c83a 	sub	fp,r9,r19
8112bc44:	42000204 	addi	r8,r8,8
8112bc48:	31000044 	addi	r4,r6,1
8112bc4c:	300b883a 	mov	r5,r6
8112bc50:	07018516 	blt	zero,fp,8112c268 <___vfiprintf_internal_r+0xc14>
8112bc54:	9885883a 	add	r2,r19,r2
8112bc58:	45400015 	stw	r21,0(r8)
8112bc5c:	44c00115 	stw	r19,4(r8)
8112bc60:	d8801c15 	stw	r2,112(sp)
8112bc64:	d9001b15 	stw	r4,108(sp)
8112bc68:	00c001c4 	movi	r3,7
8112bc6c:	1901dd0e 	bge	r3,r4,8112c3e4 <___vfiprintf_internal_r+0xd90>
8112bc70:	1002401e 	bne	r2,zero,8112c574 <___vfiprintf_internal_r+0xf20>
8112bc74:	d8001b15 	stw	zero,108(sp)
8112bc78:	a2c0010c 	andi	r11,r20,4
8112bc7c:	58000226 	beq	r11,zero,8112bc88 <___vfiprintf_internal_r+0x634>
8112bc80:	8ca7c83a 	sub	r19,r17,r18
8112bc84:	04c2f216 	blt	zero,r19,8112c850 <___vfiprintf_internal_r+0x11fc>
8112bc88:	8c80010e 	bge	r17,r18,8112bc90 <___vfiprintf_internal_r+0x63c>
8112bc8c:	9023883a 	mov	r17,r18
8112bc90:	da802317 	ldw	r10,140(sp)
8112bc94:	5455883a 	add	r10,r10,r17
8112bc98:	da802315 	stw	r10,140(sp)
8112bc9c:	d8001b15 	stw	zero,108(sp)
8112bca0:	d811883a 	mov	r8,sp
8112bca4:	003ea206 	br	8112b730 <__reset+0xfb10b730>
8112bca8:	a5000814 	ori	r20,r20,32
8112bcac:	80c00007 	ldb	r3,0(r16)
8112bcb0:	003ec906 	br	8112b7d8 <__reset+0xfb10b7d8>
8112bcb4:	80c00007 	ldb	r3,0(r16)
8112bcb8:	1b030926 	beq	r3,r12,8112c8e0 <___vfiprintf_internal_r+0x128c>
8112bcbc:	a5000414 	ori	r20,r20,16
8112bcc0:	003ec506 	br	8112b7d8 <__reset+0xfb10b7d8>
8112bcc4:	21003fcc 	andi	r4,r4,255
8112bcc8:	20035e1e 	bne	r4,zero,8112ca44 <___vfiprintf_internal_r+0x13f0>
8112bccc:	a080080c 	andi	r2,r20,32
8112bcd0:	1002a526 	beq	r2,zero,8112c768 <___vfiprintf_internal_r+0x1114>
8112bcd4:	da802217 	ldw	r10,136(sp)
8112bcd8:	50800017 	ldw	r2,0(r10)
8112bcdc:	da802317 	ldw	r10,140(sp)
8112bce0:	5007d7fa 	srai	r3,r10,31
8112bce4:	da802217 	ldw	r10,136(sp)
8112bce8:	10c00115 	stw	r3,4(r2)
8112bcec:	52800104 	addi	r10,r10,4
8112bcf0:	da802215 	stw	r10,136(sp)
8112bcf4:	da802317 	ldw	r10,140(sp)
8112bcf8:	12800015 	stw	r10,0(r2)
8112bcfc:	003e8c06 	br	8112b730 <__reset+0xfb10b730>
8112bd00:	21003fcc 	andi	r4,r4,255
8112bd04:	2003511e 	bne	r4,zero,8112ca4c <___vfiprintf_internal_r+0x13f8>
8112bd08:	a080080c 	andi	r2,r20,32
8112bd0c:	1000a126 	beq	r2,zero,8112bf94 <___vfiprintf_internal_r+0x940>
8112bd10:	da802217 	ldw	r10,136(sp)
8112bd14:	d8001d85 	stb	zero,118(sp)
8112bd18:	50800204 	addi	r2,r10,8
8112bd1c:	54800017 	ldw	r18,0(r10)
8112bd20:	54c00117 	ldw	r19,4(r10)
8112bd24:	4802b416 	blt	r9,zero,8112c7f8 <___vfiprintf_internal_r+0x11a4>
8112bd28:	013fdfc4 	movi	r4,-129
8112bd2c:	94c6b03a 	or	r3,r18,r19
8112bd30:	d8802215 	stw	r2,136(sp)
8112bd34:	a128703a 	and	r20,r20,r4
8112bd38:	1800a226 	beq	r3,zero,8112bfc4 <___vfiprintf_internal_r+0x970>
8112bd3c:	0039883a 	mov	fp,zero
8112bd40:	dd401a04 	addi	r21,sp,104
8112bd44:	9006d0fa 	srli	r3,r18,3
8112bd48:	9808977a 	slli	r4,r19,29
8112bd4c:	9826d0fa 	srli	r19,r19,3
8112bd50:	948001cc 	andi	r18,r18,7
8112bd54:	90800c04 	addi	r2,r18,48
8112bd58:	ad7fffc4 	addi	r21,r21,-1
8112bd5c:	20e4b03a 	or	r18,r4,r3
8112bd60:	a8800005 	stb	r2,0(r21)
8112bd64:	94c6b03a 	or	r3,r18,r19
8112bd68:	183ff61e 	bne	r3,zero,8112bd44 <__reset+0xfb10bd44>
8112bd6c:	a0c0004c 	andi	r3,r20,1
8112bd70:	18005926 	beq	r3,zero,8112bed8 <___vfiprintf_internal_r+0x884>
8112bd74:	10803fcc 	andi	r2,r2,255
8112bd78:	1080201c 	xori	r2,r2,128
8112bd7c:	10bfe004 	addi	r2,r2,-128
8112bd80:	00c00c04 	movi	r3,48
8112bd84:	10c05426 	beq	r2,r3,8112bed8 <___vfiprintf_internal_r+0x884>
8112bd88:	da801e17 	ldw	r10,120(sp)
8112bd8c:	a8bfffc4 	addi	r2,r21,-1
8112bd90:	a8ffffc5 	stb	r3,-1(r21)
8112bd94:	50a7c83a 	sub	r19,r10,r2
8112bd98:	102b883a 	mov	r21,r2
8112bd9c:	003f2f06 	br	8112ba5c <__reset+0xfb10ba5c>
8112bda0:	21003fcc 	andi	r4,r4,255
8112bda4:	2003421e 	bne	r4,zero,8112cab0 <___vfiprintf_internal_r+0x145c>
8112bda8:	00a04574 	movhi	r2,33045
8112bdac:	10a97f04 	addi	r2,r2,-23044
8112bdb0:	d8802615 	stw	r2,152(sp)
8112bdb4:	a080080c 	andi	r2,r20,32
8112bdb8:	1000aa26 	beq	r2,zero,8112c064 <___vfiprintf_internal_r+0xa10>
8112bdbc:	da802217 	ldw	r10,136(sp)
8112bdc0:	54800017 	ldw	r18,0(r10)
8112bdc4:	54c00117 	ldw	r19,4(r10)
8112bdc8:	52800204 	addi	r10,r10,8
8112bdcc:	da802215 	stw	r10,136(sp)
8112bdd0:	a080004c 	andi	r2,r20,1
8112bdd4:	1001d226 	beq	r2,zero,8112c520 <___vfiprintf_internal_r+0xecc>
8112bdd8:	94c4b03a 	or	r2,r18,r19
8112bddc:	1002351e 	bne	r2,zero,8112c6b4 <___vfiprintf_internal_r+0x1060>
8112bde0:	d8001d85 	stb	zero,118(sp)
8112bde4:	48022216 	blt	r9,zero,8112c670 <___vfiprintf_internal_r+0x101c>
8112bde8:	00bfdfc4 	movi	r2,-129
8112bdec:	a0a8703a 	and	r20,r20,r2
8112bdf0:	003f1506 	br	8112ba48 <__reset+0xfb10ba48>
8112bdf4:	da802217 	ldw	r10,136(sp)
8112bdf8:	04800044 	movi	r18,1
8112bdfc:	d8001d85 	stb	zero,118(sp)
8112be00:	50800017 	ldw	r2,0(r10)
8112be04:	52800104 	addi	r10,r10,4
8112be08:	da802215 	stw	r10,136(sp)
8112be0c:	d8801005 	stb	r2,64(sp)
8112be10:	9027883a 	mov	r19,r18
8112be14:	dd401004 	addi	r21,sp,64
8112be18:	0013883a 	mov	r9,zero
8112be1c:	003f1706 	br	8112ba7c <__reset+0xfb10ba7c>
8112be20:	21003fcc 	andi	r4,r4,255
8112be24:	2003201e 	bne	r4,zero,8112caa8 <___vfiprintf_internal_r+0x1454>
8112be28:	a080080c 	andi	r2,r20,32
8112be2c:	10004b26 	beq	r2,zero,8112bf5c <___vfiprintf_internal_r+0x908>
8112be30:	da802217 	ldw	r10,136(sp)
8112be34:	50800117 	ldw	r2,4(r10)
8112be38:	54800017 	ldw	r18,0(r10)
8112be3c:	52800204 	addi	r10,r10,8
8112be40:	da802215 	stw	r10,136(sp)
8112be44:	1027883a 	mov	r19,r2
8112be48:	10022c16 	blt	r2,zero,8112c6fc <___vfiprintf_internal_r+0x10a8>
8112be4c:	df001d83 	ldbu	fp,118(sp)
8112be50:	48007216 	blt	r9,zero,8112c01c <___vfiprintf_internal_r+0x9c8>
8112be54:	00ffdfc4 	movi	r3,-129
8112be58:	94c4b03a 	or	r2,r18,r19
8112be5c:	a0e8703a 	and	r20,r20,r3
8112be60:	1000cc26 	beq	r2,zero,8112c194 <___vfiprintf_internal_r+0xb40>
8112be64:	98021026 	beq	r19,zero,8112c6a8 <___vfiprintf_internal_r+0x1054>
8112be68:	dc402415 	stw	r17,144(sp)
8112be6c:	dc002515 	stw	r16,148(sp)
8112be70:	9823883a 	mov	r17,r19
8112be74:	9021883a 	mov	r16,r18
8112be78:	dd401a04 	addi	r21,sp,104
8112be7c:	4825883a 	mov	r18,r9
8112be80:	4027883a 	mov	r19,r8
8112be84:	8009883a 	mov	r4,r16
8112be88:	880b883a 	mov	r5,r17
8112be8c:	01800284 	movi	r6,10
8112be90:	000f883a 	mov	r7,zero
8112be94:	112e3f00 	call	8112e3f0 <__umoddi3>
8112be98:	10800c04 	addi	r2,r2,48
8112be9c:	ad7fffc4 	addi	r21,r21,-1
8112bea0:	8009883a 	mov	r4,r16
8112bea4:	880b883a 	mov	r5,r17
8112bea8:	a8800005 	stb	r2,0(r21)
8112beac:	01800284 	movi	r6,10
8112beb0:	000f883a 	mov	r7,zero
8112beb4:	112de700 	call	8112de70 <__udivdi3>
8112beb8:	1021883a 	mov	r16,r2
8112bebc:	10c4b03a 	or	r2,r2,r3
8112bec0:	1823883a 	mov	r17,r3
8112bec4:	103fef1e 	bne	r2,zero,8112be84 <__reset+0xfb10be84>
8112bec8:	dc402417 	ldw	r17,144(sp)
8112becc:	dc002517 	ldw	r16,148(sp)
8112bed0:	9013883a 	mov	r9,r18
8112bed4:	9811883a 	mov	r8,r19
8112bed8:	da801e17 	ldw	r10,120(sp)
8112bedc:	5567c83a 	sub	r19,r10,r21
8112bee0:	003ede06 	br	8112ba5c <__reset+0xfb10ba5c>
8112bee4:	38803fcc 	andi	r2,r7,255
8112bee8:	1080201c 	xori	r2,r2,128
8112beec:	10bfe004 	addi	r2,r2,-128
8112bef0:	1002371e 	bne	r2,zero,8112c7d0 <___vfiprintf_internal_r+0x117c>
8112bef4:	01000044 	movi	r4,1
8112bef8:	01c00804 	movi	r7,32
8112befc:	80c00007 	ldb	r3,0(r16)
8112bf00:	003e3506 	br	8112b7d8 <__reset+0xfb10b7d8>
8112bf04:	a5000054 	ori	r20,r20,1
8112bf08:	80c00007 	ldb	r3,0(r16)
8112bf0c:	003e3206 	br	8112b7d8 <__reset+0xfb10b7d8>
8112bf10:	a5002014 	ori	r20,r20,128
8112bf14:	80c00007 	ldb	r3,0(r16)
8112bf18:	003e2f06 	br	8112b7d8 <__reset+0xfb10b7d8>
8112bf1c:	8015883a 	mov	r10,r16
8112bf20:	0023883a 	mov	r17,zero
8112bf24:	18bff404 	addi	r2,r3,-48
8112bf28:	50c00007 	ldb	r3,0(r10)
8112bf2c:	8c4002a4 	muli	r17,r17,10
8112bf30:	84000044 	addi	r16,r16,1
8112bf34:	8015883a 	mov	r10,r16
8112bf38:	1463883a 	add	r17,r2,r17
8112bf3c:	18bff404 	addi	r2,r3,-48
8112bf40:	30bff92e 	bgeu	r6,r2,8112bf28 <__reset+0xfb10bf28>
8112bf44:	003e2506 	br	8112b7dc <__reset+0xfb10b7dc>
8112bf48:	21003fcc 	andi	r4,r4,255
8112bf4c:	2002d41e 	bne	r4,zero,8112caa0 <___vfiprintf_internal_r+0x144c>
8112bf50:	a5000414 	ori	r20,r20,16
8112bf54:	a080080c 	andi	r2,r20,32
8112bf58:	103fb51e 	bne	r2,zero,8112be30 <__reset+0xfb10be30>
8112bf5c:	a080040c 	andi	r2,r20,16
8112bf60:	1001f826 	beq	r2,zero,8112c744 <___vfiprintf_internal_r+0x10f0>
8112bf64:	da802217 	ldw	r10,136(sp)
8112bf68:	54800017 	ldw	r18,0(r10)
8112bf6c:	52800104 	addi	r10,r10,4
8112bf70:	da802215 	stw	r10,136(sp)
8112bf74:	9027d7fa 	srai	r19,r18,31
8112bf78:	9805883a 	mov	r2,r19
8112bf7c:	003fb206 	br	8112be48 <__reset+0xfb10be48>
8112bf80:	21003fcc 	andi	r4,r4,255
8112bf84:	2002c41e 	bne	r4,zero,8112ca98 <___vfiprintf_internal_r+0x1444>
8112bf88:	a5000414 	ori	r20,r20,16
8112bf8c:	a080080c 	andi	r2,r20,32
8112bf90:	103f5f1e 	bne	r2,zero,8112bd10 <__reset+0xfb10bd10>
8112bf94:	a080040c 	andi	r2,r20,16
8112bf98:	10020f26 	beq	r2,zero,8112c7d8 <___vfiprintf_internal_r+0x1184>
8112bf9c:	da802217 	ldw	r10,136(sp)
8112bfa0:	d8001d85 	stb	zero,118(sp)
8112bfa4:	0027883a 	mov	r19,zero
8112bfa8:	50800104 	addi	r2,r10,4
8112bfac:	54800017 	ldw	r18,0(r10)
8112bfb0:	48021116 	blt	r9,zero,8112c7f8 <___vfiprintf_internal_r+0x11a4>
8112bfb4:	00ffdfc4 	movi	r3,-129
8112bfb8:	d8802215 	stw	r2,136(sp)
8112bfbc:	a0e8703a 	and	r20,r20,r3
8112bfc0:	903f5e1e 	bne	r18,zero,8112bd3c <__reset+0xfb10bd3c>
8112bfc4:	0039883a 	mov	fp,zero
8112bfc8:	4802a626 	beq	r9,zero,8112ca64 <___vfiprintf_internal_r+0x1410>
8112bfcc:	0025883a 	mov	r18,zero
8112bfd0:	0027883a 	mov	r19,zero
8112bfd4:	003f5a06 	br	8112bd40 <__reset+0xfb10bd40>
8112bfd8:	21003fcc 	andi	r4,r4,255
8112bfdc:	20029f1e 	bne	r4,zero,8112ca5c <___vfiprintf_internal_r+0x1408>
8112bfe0:	a5000414 	ori	r20,r20,16
8112bfe4:	a080080c 	andi	r2,r20,32
8112bfe8:	10005e1e 	bne	r2,zero,8112c164 <___vfiprintf_internal_r+0xb10>
8112bfec:	a080040c 	andi	r2,r20,16
8112bff0:	1001a21e 	bne	r2,zero,8112c67c <___vfiprintf_internal_r+0x1028>
8112bff4:	a080100c 	andi	r2,r20,64
8112bff8:	d8001d85 	stb	zero,118(sp)
8112bffc:	da802217 	ldw	r10,136(sp)
8112c000:	1002231e 	bne	r2,zero,8112c890 <___vfiprintf_internal_r+0x123c>
8112c004:	50800104 	addi	r2,r10,4
8112c008:	54800017 	ldw	r18,0(r10)
8112c00c:	0027883a 	mov	r19,zero
8112c010:	4801a00e 	bge	r9,zero,8112c694 <___vfiprintf_internal_r+0x1040>
8112c014:	d8802215 	stw	r2,136(sp)
8112c018:	0039883a 	mov	fp,zero
8112c01c:	94c4b03a 	or	r2,r18,r19
8112c020:	103f901e 	bne	r2,zero,8112be64 <__reset+0xfb10be64>
8112c024:	00800044 	movi	r2,1
8112c028:	10803fcc 	andi	r2,r2,255
8112c02c:	00c00044 	movi	r3,1
8112c030:	10c05926 	beq	r2,r3,8112c198 <___vfiprintf_internal_r+0xb44>
8112c034:	00c00084 	movi	r3,2
8112c038:	10ffe41e 	bne	r2,r3,8112bfcc <__reset+0xfb10bfcc>
8112c03c:	0025883a 	mov	r18,zero
8112c040:	0027883a 	mov	r19,zero
8112c044:	00013d06 	br	8112c53c <___vfiprintf_internal_r+0xee8>
8112c048:	21003fcc 	andi	r4,r4,255
8112c04c:	2002811e 	bne	r4,zero,8112ca54 <___vfiprintf_internal_r+0x1400>
8112c050:	00a04574 	movhi	r2,33045
8112c054:	10a97a04 	addi	r2,r2,-23064
8112c058:	d8802615 	stw	r2,152(sp)
8112c05c:	a080080c 	andi	r2,r20,32
8112c060:	103f561e 	bne	r2,zero,8112bdbc <__reset+0xfb10bdbc>
8112c064:	a080040c 	andi	r2,r20,16
8112c068:	1001d126 	beq	r2,zero,8112c7b0 <___vfiprintf_internal_r+0x115c>
8112c06c:	da802217 	ldw	r10,136(sp)
8112c070:	0027883a 	mov	r19,zero
8112c074:	54800017 	ldw	r18,0(r10)
8112c078:	52800104 	addi	r10,r10,4
8112c07c:	da802215 	stw	r10,136(sp)
8112c080:	003f5306 	br	8112bdd0 <__reset+0xfb10bdd0>
8112c084:	da802217 	ldw	r10,136(sp)
8112c088:	d8001d85 	stb	zero,118(sp)
8112c08c:	55400017 	ldw	r21,0(r10)
8112c090:	50c00104 	addi	r3,r10,4
8112c094:	a8024226 	beq	r21,zero,8112c9a0 <___vfiprintf_internal_r+0x134c>
8112c098:	48021816 	blt	r9,zero,8112c8fc <___vfiprintf_internal_r+0x12a8>
8112c09c:	480d883a 	mov	r6,r9
8112c0a0:	000b883a 	mov	r5,zero
8112c0a4:	a809883a 	mov	r4,r21
8112c0a8:	d8c02a15 	stw	r3,168(sp)
8112c0ac:	da002b15 	stw	r8,172(sp)
8112c0b0:	da402c15 	stw	r9,176(sp)
8112c0b4:	11264300 	call	81126430 <memchr>
8112c0b8:	d8c02a17 	ldw	r3,168(sp)
8112c0bc:	da002b17 	ldw	r8,172(sp)
8112c0c0:	da402c17 	ldw	r9,176(sp)
8112c0c4:	10024826 	beq	r2,zero,8112c9e8 <___vfiprintf_internal_r+0x1394>
8112c0c8:	1567c83a 	sub	r19,r2,r21
8112c0cc:	df001d83 	ldbu	fp,118(sp)
8112c0d0:	d8c02215 	stw	r3,136(sp)
8112c0d4:	0013883a 	mov	r9,zero
8112c0d8:	003e6006 	br	8112ba5c <__reset+0xfb10ba5c>
8112c0dc:	21003fcc 	andi	r4,r4,255
8112c0e0:	203fc026 	beq	r4,zero,8112bfe4 <__reset+0xfb10bfe4>
8112c0e4:	d9c01d85 	stb	r7,118(sp)
8112c0e8:	003fbe06 	br	8112bfe4 <__reset+0xfb10bfe4>
8112c0ec:	da802217 	ldw	r10,136(sp)
8112c0f0:	54400017 	ldw	r17,0(r10)
8112c0f4:	50800104 	addi	r2,r10,4
8112c0f8:	883e3b16 	blt	r17,zero,8112b9e8 <__reset+0xfb10b9e8>
8112c0fc:	d8802215 	stw	r2,136(sp)
8112c100:	80c00007 	ldb	r3,0(r16)
8112c104:	003db406 	br	8112b7d8 <__reset+0xfb10b7d8>
8112c108:	01000044 	movi	r4,1
8112c10c:	01c00ac4 	movi	r7,43
8112c110:	80c00007 	ldb	r3,0(r16)
8112c114:	003db006 	br	8112b7d8 <__reset+0xfb10b7d8>
8112c118:	80c00007 	ldb	r3,0(r16)
8112c11c:	82800044 	addi	r10,r16,1
8112c120:	1b423c26 	beq	r3,r13,8112ca14 <___vfiprintf_internal_r+0x13c0>
8112c124:	18bff404 	addi	r2,r3,-48
8112c128:	0013883a 	mov	r9,zero
8112c12c:	30822b36 	bltu	r6,r2,8112c9dc <___vfiprintf_internal_r+0x1388>
8112c130:	50c00007 	ldb	r3,0(r10)
8112c134:	4a4002a4 	muli	r9,r9,10
8112c138:	54000044 	addi	r16,r10,1
8112c13c:	8015883a 	mov	r10,r16
8112c140:	4893883a 	add	r9,r9,r2
8112c144:	18bff404 	addi	r2,r3,-48
8112c148:	30bff92e 	bgeu	r6,r2,8112c130 <__reset+0xfb10c130>
8112c14c:	483da30e 	bge	r9,zero,8112b7dc <__reset+0xfb10b7dc>
8112c150:	027fffc4 	movi	r9,-1
8112c154:	003da106 	br	8112b7dc <__reset+0xfb10b7dc>
8112c158:	a5001014 	ori	r20,r20,64
8112c15c:	80c00007 	ldb	r3,0(r16)
8112c160:	003d9d06 	br	8112b7d8 <__reset+0xfb10b7d8>
8112c164:	da802217 	ldw	r10,136(sp)
8112c168:	d8001d85 	stb	zero,118(sp)
8112c16c:	50c00204 	addi	r3,r10,8
8112c170:	54800017 	ldw	r18,0(r10)
8112c174:	54c00117 	ldw	r19,4(r10)
8112c178:	4801ca16 	blt	r9,zero,8112c8a4 <___vfiprintf_internal_r+0x1250>
8112c17c:	013fdfc4 	movi	r4,-129
8112c180:	94c4b03a 	or	r2,r18,r19
8112c184:	d8c02215 	stw	r3,136(sp)
8112c188:	a128703a 	and	r20,r20,r4
8112c18c:	0039883a 	mov	fp,zero
8112c190:	103f341e 	bne	r2,zero,8112be64 <__reset+0xfb10be64>
8112c194:	483e2e26 	beq	r9,zero,8112ba50 <__reset+0xfb10ba50>
8112c198:	0025883a 	mov	r18,zero
8112c19c:	94800c04 	addi	r18,r18,48
8112c1a0:	dc8019c5 	stb	r18,103(sp)
8112c1a4:	dcc02717 	ldw	r19,156(sp)
8112c1a8:	dd4019c4 	addi	r21,sp,103
8112c1ac:	003e2b06 	br	8112ba5c <__reset+0xfb10ba5c>
8112c1b0:	21003fcc 	andi	r4,r4,255
8112c1b4:	2002361e 	bne	r4,zero,8112ca90 <___vfiprintf_internal_r+0x143c>
8112c1b8:	1801c126 	beq	r3,zero,8112c8c0 <___vfiprintf_internal_r+0x126c>
8112c1bc:	04800044 	movi	r18,1
8112c1c0:	d8c01005 	stb	r3,64(sp)
8112c1c4:	d8001d85 	stb	zero,118(sp)
8112c1c8:	9027883a 	mov	r19,r18
8112c1cc:	dd401004 	addi	r21,sp,64
8112c1d0:	003f1106 	br	8112be18 <__reset+0xfb10be18>
8112c1d4:	d9402117 	ldw	r5,132(sp)
8112c1d8:	d9002017 	ldw	r4,128(sp)
8112c1dc:	d9801a04 	addi	r6,sp,104
8112c1e0:	d9c02b15 	stw	r7,172(sp)
8112c1e4:	dbc02a15 	stw	r15,168(sp)
8112c1e8:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c1ec:	d9c02b17 	ldw	r7,172(sp)
8112c1f0:	dbc02a17 	ldw	r15,168(sp)
8112c1f4:	10006d1e 	bne	r2,zero,8112c3ac <___vfiprintf_internal_r+0xd58>
8112c1f8:	d9801b17 	ldw	r6,108(sp)
8112c1fc:	d8801c17 	ldw	r2,112(sp)
8112c200:	d811883a 	mov	r8,sp
8112c204:	31400044 	addi	r5,r6,1
8112c208:	003e3306 	br	8112bad8 <__reset+0xfb10bad8>
8112c20c:	d9401b17 	ldw	r5,108(sp)
8112c210:	d8801c17 	ldw	r2,112(sp)
8112c214:	29000044 	addi	r4,r5,1
8112c218:	d8c01d87 	ldb	r3,118(sp)
8112c21c:	183e4d26 	beq	r3,zero,8112bb54 <__reset+0xfb10bb54>
8112c220:	00c00044 	movi	r3,1
8112c224:	d9401d84 	addi	r5,sp,118
8112c228:	10c5883a 	add	r2,r2,r3
8112c22c:	41400015 	stw	r5,0(r8)
8112c230:	40c00115 	stw	r3,4(r8)
8112c234:	d8801c15 	stw	r2,112(sp)
8112c238:	d9001b15 	stw	r4,108(sp)
8112c23c:	014001c4 	movi	r5,7
8112c240:	2900a90e 	bge	r5,r4,8112c4e8 <___vfiprintf_internal_r+0xe94>
8112c244:	1000da1e 	bne	r2,zero,8112c5b0 <___vfiprintf_internal_r+0xf5c>
8112c248:	7000ab1e 	bne	r14,zero,8112c4f8 <___vfiprintf_internal_r+0xea4>
8112c24c:	000b883a 	mov	r5,zero
8112c250:	1809883a 	mov	r4,r3
8112c254:	d811883a 	mov	r8,sp
8112c258:	00c02004 	movi	r3,128
8112c25c:	e0fe4d26 	beq	fp,r3,8112bb94 <__reset+0xfb10bb94>
8112c260:	4cf9c83a 	sub	fp,r9,r19
8112c264:	073e7b0e 	bge	zero,fp,8112bc54 <__reset+0xfb10bc54>
8112c268:	01c00404 	movi	r7,16
8112c26c:	3f01900e 	bge	r7,fp,8112c8b0 <___vfiprintf_internal_r+0x125c>
8112c270:	00e04574 	movhi	r3,33045
8112c274:	18ea1104 	addi	r3,r3,-22460
8112c278:	d8c02415 	stw	r3,144(sp)
8112c27c:	034001c4 	movi	r13,7
8112c280:	00000506 	br	8112c298 <___vfiprintf_internal_r+0xc44>
8112c284:	29000084 	addi	r4,r5,2
8112c288:	42000204 	addi	r8,r8,8
8112c28c:	180b883a 	mov	r5,r3
8112c290:	e73ffc04 	addi	fp,fp,-16
8112c294:	3f000d0e 	bge	r7,fp,8112c2cc <___vfiprintf_internal_r+0xc78>
8112c298:	10800404 	addi	r2,r2,16
8112c29c:	28c00044 	addi	r3,r5,1
8112c2a0:	45c00015 	stw	r23,0(r8)
8112c2a4:	41c00115 	stw	r7,4(r8)
8112c2a8:	d8801c15 	stw	r2,112(sp)
8112c2ac:	d8c01b15 	stw	r3,108(sp)
8112c2b0:	68fff40e 	bge	r13,r3,8112c284 <__reset+0xfb10c284>
8112c2b4:	1000101e 	bne	r2,zero,8112c2f8 <___vfiprintf_internal_r+0xca4>
8112c2b8:	e73ffc04 	addi	fp,fp,-16
8112c2bc:	01000044 	movi	r4,1
8112c2c0:	000b883a 	mov	r5,zero
8112c2c4:	d811883a 	mov	r8,sp
8112c2c8:	3f3ff316 	blt	r7,fp,8112c298 <__reset+0xfb10c298>
8112c2cc:	da802417 	ldw	r10,144(sp)
8112c2d0:	1705883a 	add	r2,r2,fp
8112c2d4:	47000115 	stw	fp,4(r8)
8112c2d8:	42800015 	stw	r10,0(r8)
8112c2dc:	d8801c15 	stw	r2,112(sp)
8112c2e0:	d9001b15 	stw	r4,108(sp)
8112c2e4:	00c001c4 	movi	r3,7
8112c2e8:	19003616 	blt	r3,r4,8112c3c4 <___vfiprintf_internal_r+0xd70>
8112c2ec:	42000204 	addi	r8,r8,8
8112c2f0:	21000044 	addi	r4,r4,1
8112c2f4:	003e5706 	br	8112bc54 <__reset+0xfb10bc54>
8112c2f8:	d9402117 	ldw	r5,132(sp)
8112c2fc:	d9002017 	ldw	r4,128(sp)
8112c300:	d9801a04 	addi	r6,sp,104
8112c304:	d9c02b15 	stw	r7,172(sp)
8112c308:	db402a15 	stw	r13,168(sp)
8112c30c:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c310:	d9c02b17 	ldw	r7,172(sp)
8112c314:	db402a17 	ldw	r13,168(sp)
8112c318:	1000241e 	bne	r2,zero,8112c3ac <___vfiprintf_internal_r+0xd58>
8112c31c:	d9401b17 	ldw	r5,108(sp)
8112c320:	d8801c17 	ldw	r2,112(sp)
8112c324:	d811883a 	mov	r8,sp
8112c328:	29000044 	addi	r4,r5,1
8112c32c:	003fd806 	br	8112c290 <__reset+0xfb10c290>
8112c330:	d9401b17 	ldw	r5,108(sp)
8112c334:	00e04574 	movhi	r3,33045
8112c338:	18ea1504 	addi	r3,r3,-22444
8112c33c:	d8c02415 	stw	r3,144(sp)
8112c340:	29400044 	addi	r5,r5,1
8112c344:	d8c02417 	ldw	r3,144(sp)
8112c348:	14c5883a 	add	r2,r2,r19
8112c34c:	44c00115 	stw	r19,4(r8)
8112c350:	40c00015 	stw	r3,0(r8)
8112c354:	d8801c15 	stw	r2,112(sp)
8112c358:	d9401b15 	stw	r5,108(sp)
8112c35c:	00c001c4 	movi	r3,7
8112c360:	1940070e 	bge	r3,r5,8112c380 <___vfiprintf_internal_r+0xd2c>
8112c364:	103e4826 	beq	r2,zero,8112bc88 <__reset+0xfb10bc88>
8112c368:	d9402117 	ldw	r5,132(sp)
8112c36c:	d9002017 	ldw	r4,128(sp)
8112c370:	d9801a04 	addi	r6,sp,104
8112c374:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c378:	10000c1e 	bne	r2,zero,8112c3ac <___vfiprintf_internal_r+0xd58>
8112c37c:	d8801c17 	ldw	r2,112(sp)
8112c380:	8c80010e 	bge	r17,r18,8112c388 <___vfiprintf_internal_r+0xd34>
8112c384:	9023883a 	mov	r17,r18
8112c388:	da802317 	ldw	r10,140(sp)
8112c38c:	5455883a 	add	r10,r10,r17
8112c390:	da802315 	stw	r10,140(sp)
8112c394:	103e4126 	beq	r2,zero,8112bc9c <__reset+0xfb10bc9c>
8112c398:	d9402117 	ldw	r5,132(sp)
8112c39c:	d9002017 	ldw	r4,128(sp)
8112c3a0:	d9801a04 	addi	r6,sp,104
8112c3a4:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c3a8:	103e3c26 	beq	r2,zero,8112bc9c <__reset+0xfb10bc9c>
8112c3ac:	dd002117 	ldw	r20,132(sp)
8112c3b0:	a080030b 	ldhu	r2,12(r20)
8112c3b4:	1080100c 	andi	r2,r2,64
8112c3b8:	1001231e 	bne	r2,zero,8112c848 <___vfiprintf_internal_r+0x11f4>
8112c3bc:	d8802317 	ldw	r2,140(sp)
8112c3c0:	003d7b06 	br	8112b9b0 <__reset+0xfb10b9b0>
8112c3c4:	1000991e 	bne	r2,zero,8112c62c <___vfiprintf_internal_r+0xfd8>
8112c3c8:	00c00044 	movi	r3,1
8112c3cc:	9805883a 	mov	r2,r19
8112c3d0:	dd400015 	stw	r21,0(sp)
8112c3d4:	dcc00115 	stw	r19,4(sp)
8112c3d8:	dcc01c15 	stw	r19,112(sp)
8112c3dc:	d8c01b15 	stw	r3,108(sp)
8112c3e0:	d811883a 	mov	r8,sp
8112c3e4:	42000204 	addi	r8,r8,8
8112c3e8:	a2c0010c 	andi	r11,r20,4
8112c3ec:	583fe426 	beq	r11,zero,8112c380 <__reset+0xfb10c380>
8112c3f0:	8ca7c83a 	sub	r19,r17,r18
8112c3f4:	04ffe20e 	bge	zero,r19,8112c380 <__reset+0xfb10c380>
8112c3f8:	01c00404 	movi	r7,16
8112c3fc:	3cffcc0e 	bge	r7,r19,8112c330 <__reset+0xfb10c330>
8112c400:	02a04574 	movhi	r10,33045
8112c404:	52aa1504 	addi	r10,r10,-22444
8112c408:	d9001b17 	ldw	r4,108(sp)
8112c40c:	da802415 	stw	r10,144(sp)
8112c410:	382b883a 	mov	r21,r7
8112c414:	050001c4 	movi	r20,7
8112c418:	df002017 	ldw	fp,128(sp)
8112c41c:	00000506 	br	8112c434 <___vfiprintf_internal_r+0xde0>
8112c420:	21400084 	addi	r5,r4,2
8112c424:	42000204 	addi	r8,r8,8
8112c428:	1809883a 	mov	r4,r3
8112c42c:	9cfffc04 	addi	r19,r19,-16
8112c430:	acffc40e 	bge	r21,r19,8112c344 <__reset+0xfb10c344>
8112c434:	10800404 	addi	r2,r2,16
8112c438:	20c00044 	addi	r3,r4,1
8112c43c:	45800015 	stw	r22,0(r8)
8112c440:	45400115 	stw	r21,4(r8)
8112c444:	d8801c15 	stw	r2,112(sp)
8112c448:	d8c01b15 	stw	r3,108(sp)
8112c44c:	a0fff40e 	bge	r20,r3,8112c420 <__reset+0xfb10c420>
8112c450:	1000041e 	bne	r2,zero,8112c464 <___vfiprintf_internal_r+0xe10>
8112c454:	01400044 	movi	r5,1
8112c458:	0009883a 	mov	r4,zero
8112c45c:	d811883a 	mov	r8,sp
8112c460:	003ff206 	br	8112c42c <__reset+0xfb10c42c>
8112c464:	d9402117 	ldw	r5,132(sp)
8112c468:	d9801a04 	addi	r6,sp,104
8112c46c:	e009883a 	mov	r4,fp
8112c470:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c474:	103fcd1e 	bne	r2,zero,8112c3ac <__reset+0xfb10c3ac>
8112c478:	d9001b17 	ldw	r4,108(sp)
8112c47c:	d8801c17 	ldw	r2,112(sp)
8112c480:	d811883a 	mov	r8,sp
8112c484:	21400044 	addi	r5,r4,1
8112c488:	003fe806 	br	8112c42c <__reset+0xfb10c42c>
8112c48c:	d9402117 	ldw	r5,132(sp)
8112c490:	d9002017 	ldw	r4,128(sp)
8112c494:	d9801a04 	addi	r6,sp,104
8112c498:	d9c02b15 	stw	r7,172(sp)
8112c49c:	db402a15 	stw	r13,168(sp)
8112c4a0:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c4a4:	d9c02b17 	ldw	r7,172(sp)
8112c4a8:	db402a17 	ldw	r13,168(sp)
8112c4ac:	103fbf1e 	bne	r2,zero,8112c3ac <__reset+0xfb10c3ac>
8112c4b0:	d9401b17 	ldw	r5,108(sp)
8112c4b4:	d8801c17 	ldw	r2,112(sp)
8112c4b8:	d811883a 	mov	r8,sp
8112c4bc:	29800044 	addi	r6,r5,1
8112c4c0:	003dc406 	br	8112bbd4 <__reset+0xfb10bbd4>
8112c4c4:	1000d21e 	bne	r2,zero,8112c810 <___vfiprintf_internal_r+0x11bc>
8112c4c8:	d8c01d87 	ldb	r3,118(sp)
8112c4cc:	18009526 	beq	r3,zero,8112c724 <___vfiprintf_internal_r+0x10d0>
8112c4d0:	00800044 	movi	r2,1
8112c4d4:	d8c01d84 	addi	r3,sp,118
8112c4d8:	1009883a 	mov	r4,r2
8112c4dc:	d8c00015 	stw	r3,0(sp)
8112c4e0:	d8800115 	stw	r2,4(sp)
8112c4e4:	d811883a 	mov	r8,sp
8112c4e8:	200b883a 	mov	r5,r4
8112c4ec:	42000204 	addi	r8,r8,8
8112c4f0:	21000044 	addi	r4,r4,1
8112c4f4:	003d9706 	br	8112bb54 <__reset+0xfb10bb54>
8112c4f8:	d9001d04 	addi	r4,sp,116
8112c4fc:	00800084 	movi	r2,2
8112c500:	d9000015 	stw	r4,0(sp)
8112c504:	d8800115 	stw	r2,4(sp)
8112c508:	1809883a 	mov	r4,r3
8112c50c:	d811883a 	mov	r8,sp
8112c510:	200b883a 	mov	r5,r4
8112c514:	42000204 	addi	r8,r8,8
8112c518:	21000044 	addi	r4,r4,1
8112c51c:	003f4e06 	br	8112c258 <__reset+0xfb10c258>
8112c520:	d8001d85 	stb	zero,118(sp)
8112c524:	48005016 	blt	r9,zero,8112c668 <___vfiprintf_internal_r+0x1014>
8112c528:	00ffdfc4 	movi	r3,-129
8112c52c:	94c4b03a 	or	r2,r18,r19
8112c530:	a0e8703a 	and	r20,r20,r3
8112c534:	103d4426 	beq	r2,zero,8112ba48 <__reset+0xfb10ba48>
8112c538:	0039883a 	mov	fp,zero
8112c53c:	d9002617 	ldw	r4,152(sp)
8112c540:	dd401a04 	addi	r21,sp,104
8112c544:	908003cc 	andi	r2,r18,15
8112c548:	9806973a 	slli	r3,r19,28
8112c54c:	2085883a 	add	r2,r4,r2
8112c550:	9024d13a 	srli	r18,r18,4
8112c554:	10800003 	ldbu	r2,0(r2)
8112c558:	9826d13a 	srli	r19,r19,4
8112c55c:	ad7fffc4 	addi	r21,r21,-1
8112c560:	1ca4b03a 	or	r18,r3,r18
8112c564:	a8800005 	stb	r2,0(r21)
8112c568:	94c4b03a 	or	r2,r18,r19
8112c56c:	103ff51e 	bne	r2,zero,8112c544 <__reset+0xfb10c544>
8112c570:	003e5906 	br	8112bed8 <__reset+0xfb10bed8>
8112c574:	d9402117 	ldw	r5,132(sp)
8112c578:	d9002017 	ldw	r4,128(sp)
8112c57c:	d9801a04 	addi	r6,sp,104
8112c580:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c584:	103f891e 	bne	r2,zero,8112c3ac <__reset+0xfb10c3ac>
8112c588:	d8801c17 	ldw	r2,112(sp)
8112c58c:	d811883a 	mov	r8,sp
8112c590:	003f9506 	br	8112c3e8 <__reset+0xfb10c3e8>
8112c594:	d9402117 	ldw	r5,132(sp)
8112c598:	d9002017 	ldw	r4,128(sp)
8112c59c:	d9801a04 	addi	r6,sp,104
8112c5a0:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c5a4:	103f811e 	bne	r2,zero,8112c3ac <__reset+0xfb10c3ac>
8112c5a8:	d811883a 	mov	r8,sp
8112c5ac:	003ced06 	br	8112b964 <__reset+0xfb10b964>
8112c5b0:	d9402117 	ldw	r5,132(sp)
8112c5b4:	d9002017 	ldw	r4,128(sp)
8112c5b8:	d9801a04 	addi	r6,sp,104
8112c5bc:	da402c15 	stw	r9,176(sp)
8112c5c0:	db802a15 	stw	r14,168(sp)
8112c5c4:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c5c8:	da402c17 	ldw	r9,176(sp)
8112c5cc:	db802a17 	ldw	r14,168(sp)
8112c5d0:	103f761e 	bne	r2,zero,8112c3ac <__reset+0xfb10c3ac>
8112c5d4:	d9401b17 	ldw	r5,108(sp)
8112c5d8:	d8801c17 	ldw	r2,112(sp)
8112c5dc:	d811883a 	mov	r8,sp
8112c5e0:	29000044 	addi	r4,r5,1
8112c5e4:	003d5b06 	br	8112bb54 <__reset+0xfb10bb54>
8112c5e8:	d9402117 	ldw	r5,132(sp)
8112c5ec:	d9002017 	ldw	r4,128(sp)
8112c5f0:	d9801a04 	addi	r6,sp,104
8112c5f4:	da402c15 	stw	r9,176(sp)
8112c5f8:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c5fc:	da402c17 	ldw	r9,176(sp)
8112c600:	103f6a1e 	bne	r2,zero,8112c3ac <__reset+0xfb10c3ac>
8112c604:	d9401b17 	ldw	r5,108(sp)
8112c608:	d8801c17 	ldw	r2,112(sp)
8112c60c:	d811883a 	mov	r8,sp
8112c610:	29000044 	addi	r4,r5,1
8112c614:	003f1006 	br	8112c258 <__reset+0xfb10c258>
8112c618:	1000c31e 	bne	r2,zero,8112c928 <___vfiprintf_internal_r+0x12d4>
8112c61c:	01000044 	movi	r4,1
8112c620:	000b883a 	mov	r5,zero
8112c624:	d811883a 	mov	r8,sp
8112c628:	003f0d06 	br	8112c260 <__reset+0xfb10c260>
8112c62c:	d9402117 	ldw	r5,132(sp)
8112c630:	d9002017 	ldw	r4,128(sp)
8112c634:	d9801a04 	addi	r6,sp,104
8112c638:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c63c:	103f5b1e 	bne	r2,zero,8112c3ac <__reset+0xfb10c3ac>
8112c640:	d9001b17 	ldw	r4,108(sp)
8112c644:	d8801c17 	ldw	r2,112(sp)
8112c648:	d811883a 	mov	r8,sp
8112c64c:	21000044 	addi	r4,r4,1
8112c650:	003d8006 	br	8112bc54 <__reset+0xfb10bc54>
8112c654:	01204574 	movhi	r4,33045
8112c658:	21297f04 	addi	r4,r4,-23044
8112c65c:	d9002615 	stw	r4,152(sp)
8112c660:	d8c02215 	stw	r3,136(sp)
8112c664:	1029883a 	mov	r20,r2
8112c668:	94c4b03a 	or	r2,r18,r19
8112c66c:	103fb21e 	bne	r2,zero,8112c538 <__reset+0xfb10c538>
8112c670:	0039883a 	mov	fp,zero
8112c674:	00800084 	movi	r2,2
8112c678:	003e6b06 	br	8112c028 <__reset+0xfb10c028>
8112c67c:	da802217 	ldw	r10,136(sp)
8112c680:	d8001d85 	stb	zero,118(sp)
8112c684:	0027883a 	mov	r19,zero
8112c688:	50800104 	addi	r2,r10,4
8112c68c:	54800017 	ldw	r18,0(r10)
8112c690:	483e6016 	blt	r9,zero,8112c014 <__reset+0xfb10c014>
8112c694:	00ffdfc4 	movi	r3,-129
8112c698:	d8802215 	stw	r2,136(sp)
8112c69c:	a0e8703a 	and	r20,r20,r3
8112c6a0:	0039883a 	mov	fp,zero
8112c6a4:	903ebb26 	beq	r18,zero,8112c194 <__reset+0xfb10c194>
8112c6a8:	00800244 	movi	r2,9
8112c6ac:	14bdee36 	bltu	r2,r18,8112be68 <__reset+0xfb10be68>
8112c6b0:	003eba06 	br	8112c19c <__reset+0xfb10c19c>
8112c6b4:	00800c04 	movi	r2,48
8112c6b8:	d8c01d45 	stb	r3,117(sp)
8112c6bc:	d8801d05 	stb	r2,116(sp)
8112c6c0:	d8001d85 	stb	zero,118(sp)
8112c6c4:	a0c00094 	ori	r3,r20,2
8112c6c8:	4800a916 	blt	r9,zero,8112c970 <___vfiprintf_internal_r+0x131c>
8112c6cc:	00bfdfc4 	movi	r2,-129
8112c6d0:	a096703a 	and	r11,r20,r2
8112c6d4:	5d000094 	ori	r20,r11,2
8112c6d8:	0039883a 	mov	fp,zero
8112c6dc:	003f9706 	br	8112c53c <__reset+0xfb10c53c>
8112c6e0:	8025883a 	mov	r18,r16
8112c6e4:	003c2e06 	br	8112b7a0 <__reset+0xfb10b7a0>
8112c6e8:	00a04574 	movhi	r2,33045
8112c6ec:	10a97f04 	addi	r2,r2,-23044
8112c6f0:	0039883a 	mov	fp,zero
8112c6f4:	d8802615 	stw	r2,152(sp)
8112c6f8:	003f9006 	br	8112c53c <__reset+0xfb10c53c>
8112c6fc:	04a5c83a 	sub	r18,zero,r18
8112c700:	07000b44 	movi	fp,45
8112c704:	9004c03a 	cmpne	r2,r18,zero
8112c708:	04e7c83a 	sub	r19,zero,r19
8112c70c:	df001d85 	stb	fp,118(sp)
8112c710:	98a7c83a 	sub	r19,r19,r2
8112c714:	48009f16 	blt	r9,zero,8112c994 <___vfiprintf_internal_r+0x1340>
8112c718:	00bfdfc4 	movi	r2,-129
8112c71c:	a0a8703a 	and	r20,r20,r2
8112c720:	003dd006 	br	8112be64 <__reset+0xfb10be64>
8112c724:	70004c26 	beq	r14,zero,8112c858 <___vfiprintf_internal_r+0x1204>
8112c728:	00800084 	movi	r2,2
8112c72c:	d8c01d04 	addi	r3,sp,116
8112c730:	d8c00015 	stw	r3,0(sp)
8112c734:	d8800115 	stw	r2,4(sp)
8112c738:	01000044 	movi	r4,1
8112c73c:	d811883a 	mov	r8,sp
8112c740:	003f7306 	br	8112c510 <__reset+0xfb10c510>
8112c744:	a080100c 	andi	r2,r20,64
8112c748:	da802217 	ldw	r10,136(sp)
8112c74c:	103e0626 	beq	r2,zero,8112bf68 <__reset+0xfb10bf68>
8112c750:	5480000f 	ldh	r18,0(r10)
8112c754:	52800104 	addi	r10,r10,4
8112c758:	da802215 	stw	r10,136(sp)
8112c75c:	9027d7fa 	srai	r19,r18,31
8112c760:	9805883a 	mov	r2,r19
8112c764:	003db806 	br	8112be48 <__reset+0xfb10be48>
8112c768:	a080040c 	andi	r2,r20,16
8112c76c:	1000091e 	bne	r2,zero,8112c794 <___vfiprintf_internal_r+0x1140>
8112c770:	a2c0100c 	andi	r11,r20,64
8112c774:	58000726 	beq	r11,zero,8112c794 <___vfiprintf_internal_r+0x1140>
8112c778:	da802217 	ldw	r10,136(sp)
8112c77c:	50800017 	ldw	r2,0(r10)
8112c780:	52800104 	addi	r10,r10,4
8112c784:	da802215 	stw	r10,136(sp)
8112c788:	da802317 	ldw	r10,140(sp)
8112c78c:	1280000d 	sth	r10,0(r2)
8112c790:	003be706 	br	8112b730 <__reset+0xfb10b730>
8112c794:	da802217 	ldw	r10,136(sp)
8112c798:	50800017 	ldw	r2,0(r10)
8112c79c:	52800104 	addi	r10,r10,4
8112c7a0:	da802215 	stw	r10,136(sp)
8112c7a4:	da802317 	ldw	r10,140(sp)
8112c7a8:	12800015 	stw	r10,0(r2)
8112c7ac:	003be006 	br	8112b730 <__reset+0xfb10b730>
8112c7b0:	a080100c 	andi	r2,r20,64
8112c7b4:	da802217 	ldw	r10,136(sp)
8112c7b8:	10003026 	beq	r2,zero,8112c87c <___vfiprintf_internal_r+0x1228>
8112c7bc:	5480000b 	ldhu	r18,0(r10)
8112c7c0:	52800104 	addi	r10,r10,4
8112c7c4:	0027883a 	mov	r19,zero
8112c7c8:	da802215 	stw	r10,136(sp)
8112c7cc:	003d8006 	br	8112bdd0 <__reset+0xfb10bdd0>
8112c7d0:	80c00007 	ldb	r3,0(r16)
8112c7d4:	003c0006 	br	8112b7d8 <__reset+0xfb10b7d8>
8112c7d8:	a080100c 	andi	r2,r20,64
8112c7dc:	d8001d85 	stb	zero,118(sp)
8112c7e0:	da802217 	ldw	r10,136(sp)
8112c7e4:	1000201e 	bne	r2,zero,8112c868 <___vfiprintf_internal_r+0x1214>
8112c7e8:	50800104 	addi	r2,r10,4
8112c7ec:	54800017 	ldw	r18,0(r10)
8112c7f0:	0027883a 	mov	r19,zero
8112c7f4:	483def0e 	bge	r9,zero,8112bfb4 <__reset+0xfb10bfb4>
8112c7f8:	94c6b03a 	or	r3,r18,r19
8112c7fc:	d8802215 	stw	r2,136(sp)
8112c800:	183d4e1e 	bne	r3,zero,8112bd3c <__reset+0xfb10bd3c>
8112c804:	0039883a 	mov	fp,zero
8112c808:	0005883a 	mov	r2,zero
8112c80c:	003e0606 	br	8112c028 <__reset+0xfb10c028>
8112c810:	d9402117 	ldw	r5,132(sp)
8112c814:	d9002017 	ldw	r4,128(sp)
8112c818:	d9801a04 	addi	r6,sp,104
8112c81c:	da402c15 	stw	r9,176(sp)
8112c820:	db802a15 	stw	r14,168(sp)
8112c824:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c828:	da402c17 	ldw	r9,176(sp)
8112c82c:	db802a17 	ldw	r14,168(sp)
8112c830:	103ede1e 	bne	r2,zero,8112c3ac <__reset+0xfb10c3ac>
8112c834:	d9401b17 	ldw	r5,108(sp)
8112c838:	d8801c17 	ldw	r2,112(sp)
8112c83c:	d811883a 	mov	r8,sp
8112c840:	29000044 	addi	r4,r5,1
8112c844:	003e7406 	br	8112c218 <__reset+0xfb10c218>
8112c848:	00bfffc4 	movi	r2,-1
8112c84c:	003c5806 	br	8112b9b0 <__reset+0xfb10b9b0>
8112c850:	d811883a 	mov	r8,sp
8112c854:	003ee806 	br	8112c3f8 <__reset+0xfb10c3f8>
8112c858:	000b883a 	mov	r5,zero
8112c85c:	01000044 	movi	r4,1
8112c860:	d811883a 	mov	r8,sp
8112c864:	003e7c06 	br	8112c258 <__reset+0xfb10c258>
8112c868:	50800104 	addi	r2,r10,4
8112c86c:	5480000b 	ldhu	r18,0(r10)
8112c870:	0027883a 	mov	r19,zero
8112c874:	483dcf0e 	bge	r9,zero,8112bfb4 <__reset+0xfb10bfb4>
8112c878:	003fdf06 	br	8112c7f8 <__reset+0xfb10c7f8>
8112c87c:	54800017 	ldw	r18,0(r10)
8112c880:	52800104 	addi	r10,r10,4
8112c884:	0027883a 	mov	r19,zero
8112c888:	da802215 	stw	r10,136(sp)
8112c88c:	003d5006 	br	8112bdd0 <__reset+0xfb10bdd0>
8112c890:	50800104 	addi	r2,r10,4
8112c894:	5480000b 	ldhu	r18,0(r10)
8112c898:	0027883a 	mov	r19,zero
8112c89c:	483f7d0e 	bge	r9,zero,8112c694 <__reset+0xfb10c694>
8112c8a0:	003ddc06 	br	8112c014 <__reset+0xfb10c014>
8112c8a4:	d8c02215 	stw	r3,136(sp)
8112c8a8:	0039883a 	mov	fp,zero
8112c8ac:	003ddb06 	br	8112c01c <__reset+0xfb10c01c>
8112c8b0:	02a04574 	movhi	r10,33045
8112c8b4:	52aa1104 	addi	r10,r10,-22460
8112c8b8:	da802415 	stw	r10,144(sp)
8112c8bc:	003e8306 	br	8112c2cc <__reset+0xfb10c2cc>
8112c8c0:	d8801c17 	ldw	r2,112(sp)
8112c8c4:	dd002117 	ldw	r20,132(sp)
8112c8c8:	103eb926 	beq	r2,zero,8112c3b0 <__reset+0xfb10c3b0>
8112c8cc:	d9002017 	ldw	r4,128(sp)
8112c8d0:	d9801a04 	addi	r6,sp,104
8112c8d4:	a00b883a 	mov	r5,r20
8112c8d8:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c8dc:	003eb406 	br	8112c3b0 <__reset+0xfb10c3b0>
8112c8e0:	80c00043 	ldbu	r3,1(r16)
8112c8e4:	a5000814 	ori	r20,r20,32
8112c8e8:	84000044 	addi	r16,r16,1
8112c8ec:	18c03fcc 	andi	r3,r3,255
8112c8f0:	18c0201c 	xori	r3,r3,128
8112c8f4:	18ffe004 	addi	r3,r3,-128
8112c8f8:	003bb706 	br	8112b7d8 <__reset+0xfb10b7d8>
8112c8fc:	a809883a 	mov	r4,r21
8112c900:	d8c02a15 	stw	r3,168(sp)
8112c904:	da002b15 	stw	r8,172(sp)
8112c908:	111cf340 	call	8111cf34 <strlen>
8112c90c:	d8c02a17 	ldw	r3,168(sp)
8112c910:	1027883a 	mov	r19,r2
8112c914:	df001d83 	ldbu	fp,118(sp)
8112c918:	d8c02215 	stw	r3,136(sp)
8112c91c:	0013883a 	mov	r9,zero
8112c920:	da002b17 	ldw	r8,172(sp)
8112c924:	003c4d06 	br	8112ba5c <__reset+0xfb10ba5c>
8112c928:	d9402117 	ldw	r5,132(sp)
8112c92c:	d9002017 	ldw	r4,128(sp)
8112c930:	d9801a04 	addi	r6,sp,104
8112c934:	da402c15 	stw	r9,176(sp)
8112c938:	112b5380 	call	8112b538 <__sprint_r.part.0>
8112c93c:	da402c17 	ldw	r9,176(sp)
8112c940:	103e9a1e 	bne	r2,zero,8112c3ac <__reset+0xfb10c3ac>
8112c944:	d9401b17 	ldw	r5,108(sp)
8112c948:	d8801c17 	ldw	r2,112(sp)
8112c94c:	d811883a 	mov	r8,sp
8112c950:	29000044 	addi	r4,r5,1
8112c954:	003e4206 	br	8112c260 <__reset+0xfb10c260>
8112c958:	d9401b17 	ldw	r5,108(sp)
8112c95c:	01204574 	movhi	r4,33045
8112c960:	212a1504 	addi	r4,r4,-22444
8112c964:	d9002415 	stw	r4,144(sp)
8112c968:	29400044 	addi	r5,r5,1
8112c96c:	003c6d06 	br	8112bb24 <__reset+0xfb10bb24>
8112c970:	0039883a 	mov	fp,zero
8112c974:	00800084 	movi	r2,2
8112c978:	10803fcc 	andi	r2,r2,255
8112c97c:	01000044 	movi	r4,1
8112c980:	11001e26 	beq	r2,r4,8112c9fc <___vfiprintf_internal_r+0x13a8>
8112c984:	01000084 	movi	r4,2
8112c988:	11001e1e 	bne	r2,r4,8112ca04 <___vfiprintf_internal_r+0x13b0>
8112c98c:	1829883a 	mov	r20,r3
8112c990:	003eea06 	br	8112c53c <__reset+0xfb10c53c>
8112c994:	a007883a 	mov	r3,r20
8112c998:	00800044 	movi	r2,1
8112c99c:	003ff606 	br	8112c978 <__reset+0xfb10c978>
8112c9a0:	00800184 	movi	r2,6
8112c9a4:	1240012e 	bgeu	r2,r9,8112c9ac <___vfiprintf_internal_r+0x1358>
8112c9a8:	1013883a 	mov	r9,r2
8112c9ac:	4827883a 	mov	r19,r9
8112c9b0:	4825883a 	mov	r18,r9
8112c9b4:	48001516 	blt	r9,zero,8112ca0c <___vfiprintf_internal_r+0x13b8>
8112c9b8:	05604574 	movhi	r21,33045
8112c9bc:	d8c02215 	stw	r3,136(sp)
8112c9c0:	ad698404 	addi	r21,r21,-23024
8112c9c4:	003d1406 	br	8112be18 <__reset+0xfb10be18>
8112c9c8:	02a04574 	movhi	r10,33045
8112c9cc:	52aa1104 	addi	r10,r10,-22460
8112c9d0:	da802415 	stw	r10,144(sp)
8112c9d4:	200d883a 	mov	r6,r4
8112c9d8:	003c9106 	br	8112bc20 <__reset+0xfb10bc20>
8112c9dc:	5021883a 	mov	r16,r10
8112c9e0:	0013883a 	mov	r9,zero
8112c9e4:	003b7d06 	br	8112b7dc <__reset+0xfb10b7dc>
8112c9e8:	4827883a 	mov	r19,r9
8112c9ec:	df001d83 	ldbu	fp,118(sp)
8112c9f0:	d8c02215 	stw	r3,136(sp)
8112c9f4:	0013883a 	mov	r9,zero
8112c9f8:	003c1806 	br	8112ba5c <__reset+0xfb10ba5c>
8112c9fc:	1829883a 	mov	r20,r3
8112ca00:	003d1806 	br	8112be64 <__reset+0xfb10be64>
8112ca04:	1829883a 	mov	r20,r3
8112ca08:	003ccd06 	br	8112bd40 <__reset+0xfb10bd40>
8112ca0c:	0025883a 	mov	r18,zero
8112ca10:	003fe906 	br	8112c9b8 <__reset+0xfb10c9b8>
8112ca14:	d8802217 	ldw	r2,136(sp)
8112ca18:	80c00043 	ldbu	r3,1(r16)
8112ca1c:	5021883a 	mov	r16,r10
8112ca20:	12400017 	ldw	r9,0(r2)
8112ca24:	10800104 	addi	r2,r2,4
8112ca28:	d8802215 	stw	r2,136(sp)
8112ca2c:	483faf0e 	bge	r9,zero,8112c8ec <__reset+0xfb10c8ec>
8112ca30:	18c03fcc 	andi	r3,r3,255
8112ca34:	18c0201c 	xori	r3,r3,128
8112ca38:	027fffc4 	movi	r9,-1
8112ca3c:	18ffe004 	addi	r3,r3,-128
8112ca40:	003b6506 	br	8112b7d8 <__reset+0xfb10b7d8>
8112ca44:	d9c01d85 	stb	r7,118(sp)
8112ca48:	003ca006 	br	8112bccc <__reset+0xfb10bccc>
8112ca4c:	d9c01d85 	stb	r7,118(sp)
8112ca50:	003cad06 	br	8112bd08 <__reset+0xfb10bd08>
8112ca54:	d9c01d85 	stb	r7,118(sp)
8112ca58:	003d7d06 	br	8112c050 <__reset+0xfb10c050>
8112ca5c:	d9c01d85 	stb	r7,118(sp)
8112ca60:	003d5f06 	br	8112bfe0 <__reset+0xfb10bfe0>
8112ca64:	a080004c 	andi	r2,r20,1
8112ca68:	0039883a 	mov	fp,zero
8112ca6c:	10000526 	beq	r2,zero,8112ca84 <___vfiprintf_internal_r+0x1430>
8112ca70:	00800c04 	movi	r2,48
8112ca74:	d88019c5 	stb	r2,103(sp)
8112ca78:	dcc02717 	ldw	r19,156(sp)
8112ca7c:	dd4019c4 	addi	r21,sp,103
8112ca80:	003bf606 	br	8112ba5c <__reset+0xfb10ba5c>
8112ca84:	0027883a 	mov	r19,zero
8112ca88:	dd401a04 	addi	r21,sp,104
8112ca8c:	003bf306 	br	8112ba5c <__reset+0xfb10ba5c>
8112ca90:	d9c01d85 	stb	r7,118(sp)
8112ca94:	003dc806 	br	8112c1b8 <__reset+0xfb10c1b8>
8112ca98:	d9c01d85 	stb	r7,118(sp)
8112ca9c:	003d3a06 	br	8112bf88 <__reset+0xfb10bf88>
8112caa0:	d9c01d85 	stb	r7,118(sp)
8112caa4:	003d2a06 	br	8112bf50 <__reset+0xfb10bf50>
8112caa8:	d9c01d85 	stb	r7,118(sp)
8112caac:	003cde06 	br	8112be28 <__reset+0xfb10be28>
8112cab0:	d9c01d85 	stb	r7,118(sp)
8112cab4:	003cbc06 	br	8112bda8 <__reset+0xfb10bda8>

8112cab8 <__vfiprintf_internal>:
8112cab8:	00a04574 	movhi	r2,33045
8112cabc:	10b34e04 	addi	r2,r2,-13000
8112cac0:	300f883a 	mov	r7,r6
8112cac4:	280d883a 	mov	r6,r5
8112cac8:	200b883a 	mov	r5,r4
8112cacc:	11000017 	ldw	r4,0(r2)
8112cad0:	112b6541 	jmpi	8112b654 <___vfiprintf_internal_r>

8112cad4 <__sbprintf>:
8112cad4:	defee204 	addi	sp,sp,-1144
8112cad8:	de00012e 	bgeu	sp,et,8112cae0 <__sbprintf+0xc>
8112cadc:	003b68fa 	trap	3
8112cae0:	2880030b 	ldhu	r2,12(r5)
8112cae4:	2ac01917 	ldw	r11,100(r5)
8112cae8:	2a80038b 	ldhu	r10,14(r5)
8112caec:	2a400717 	ldw	r9,28(r5)
8112caf0:	2a000917 	ldw	r8,36(r5)
8112caf4:	00c10004 	movi	r3,1024
8112caf8:	dc011a15 	stw	r16,1128(sp)
8112cafc:	10bfff4c 	andi	r2,r2,65533
8112cb00:	2821883a 	mov	r16,r5
8112cb04:	d8cb883a 	add	r5,sp,r3
8112cb08:	dc811c15 	stw	r18,1136(sp)
8112cb0c:	dc411b15 	stw	r17,1132(sp)
8112cb10:	dfc11d15 	stw	ra,1140(sp)
8112cb14:	2025883a 	mov	r18,r4
8112cb18:	d881030d 	sth	r2,1036(sp)
8112cb1c:	dac11915 	stw	r11,1124(sp)
8112cb20:	da81038d 	sth	r10,1038(sp)
8112cb24:	da410715 	stw	r9,1052(sp)
8112cb28:	da010915 	stw	r8,1060(sp)
8112cb2c:	dec10015 	stw	sp,1024(sp)
8112cb30:	dec10415 	stw	sp,1040(sp)
8112cb34:	d8c10215 	stw	r3,1032(sp)
8112cb38:	d8c10515 	stw	r3,1044(sp)
8112cb3c:	d8010615 	stw	zero,1048(sp)
8112cb40:	112b6540 	call	8112b654 <___vfiprintf_internal_r>
8112cb44:	1023883a 	mov	r17,r2
8112cb48:	10000416 	blt	r2,zero,8112cb5c <__sbprintf+0x88>
8112cb4c:	d9410004 	addi	r5,sp,1024
8112cb50:	9009883a 	mov	r4,r18
8112cb54:	1124e0c0 	call	81124e0c <_fflush_r>
8112cb58:	10000d1e 	bne	r2,zero,8112cb90 <__sbprintf+0xbc>
8112cb5c:	d881030b 	ldhu	r2,1036(sp)
8112cb60:	1080100c 	andi	r2,r2,64
8112cb64:	10000326 	beq	r2,zero,8112cb74 <__sbprintf+0xa0>
8112cb68:	8080030b 	ldhu	r2,12(r16)
8112cb6c:	10801014 	ori	r2,r2,64
8112cb70:	8080030d 	sth	r2,12(r16)
8112cb74:	8805883a 	mov	r2,r17
8112cb78:	dfc11d17 	ldw	ra,1140(sp)
8112cb7c:	dc811c17 	ldw	r18,1136(sp)
8112cb80:	dc411b17 	ldw	r17,1132(sp)
8112cb84:	dc011a17 	ldw	r16,1128(sp)
8112cb88:	dec11e04 	addi	sp,sp,1144
8112cb8c:	f800283a 	ret
8112cb90:	047fffc4 	movi	r17,-1
8112cb94:	003ff106 	br	8112cb5c <__reset+0xfb10cb5c>

8112cb98 <_calloc_r>:
8112cb98:	298b383a 	mul	r5,r5,r6
8112cb9c:	defffe04 	addi	sp,sp,-8
8112cba0:	de00012e 	bgeu	sp,et,8112cba8 <_calloc_r+0x10>
8112cba4:	003b68fa 	trap	3
8112cba8:	dfc00115 	stw	ra,4(sp)
8112cbac:	dc000015 	stw	r16,0(sp)
8112cbb0:	111bc2c0 	call	8111bc2c <_malloc_r>
8112cbb4:	10002926 	beq	r2,zero,8112cc5c <_calloc_r+0xc4>
8112cbb8:	11bfff17 	ldw	r6,-4(r2)
8112cbbc:	1021883a 	mov	r16,r2
8112cbc0:	00bfff04 	movi	r2,-4
8112cbc4:	308c703a 	and	r6,r6,r2
8112cbc8:	00c00904 	movi	r3,36
8112cbcc:	308d883a 	add	r6,r6,r2
8112cbd0:	19801636 	bltu	r3,r6,8112cc2c <_calloc_r+0x94>
8112cbd4:	008004c4 	movi	r2,19
8112cbd8:	11800b2e 	bgeu	r2,r6,8112cc08 <_calloc_r+0x70>
8112cbdc:	80000015 	stw	zero,0(r16)
8112cbe0:	80000115 	stw	zero,4(r16)
8112cbe4:	008006c4 	movi	r2,27
8112cbe8:	11801a2e 	bgeu	r2,r6,8112cc54 <_calloc_r+0xbc>
8112cbec:	80000215 	stw	zero,8(r16)
8112cbf0:	80000315 	stw	zero,12(r16)
8112cbf4:	30c0151e 	bne	r6,r3,8112cc4c <_calloc_r+0xb4>
8112cbf8:	80000415 	stw	zero,16(r16)
8112cbfc:	80800604 	addi	r2,r16,24
8112cc00:	80000515 	stw	zero,20(r16)
8112cc04:	00000106 	br	8112cc0c <_calloc_r+0x74>
8112cc08:	8005883a 	mov	r2,r16
8112cc0c:	10000015 	stw	zero,0(r2)
8112cc10:	10000115 	stw	zero,4(r2)
8112cc14:	10000215 	stw	zero,8(r2)
8112cc18:	8005883a 	mov	r2,r16
8112cc1c:	dfc00117 	ldw	ra,4(sp)
8112cc20:	dc000017 	ldw	r16,0(sp)
8112cc24:	dec00204 	addi	sp,sp,8
8112cc28:	f800283a 	ret
8112cc2c:	000b883a 	mov	r5,zero
8112cc30:	8009883a 	mov	r4,r16
8112cc34:	111c5900 	call	8111c590 <memset>
8112cc38:	8005883a 	mov	r2,r16
8112cc3c:	dfc00117 	ldw	ra,4(sp)
8112cc40:	dc000017 	ldw	r16,0(sp)
8112cc44:	dec00204 	addi	sp,sp,8
8112cc48:	f800283a 	ret
8112cc4c:	80800404 	addi	r2,r16,16
8112cc50:	003fee06 	br	8112cc0c <__reset+0xfb10cc0c>
8112cc54:	80800204 	addi	r2,r16,8
8112cc58:	003fec06 	br	8112cc0c <__reset+0xfb10cc0c>
8112cc5c:	0005883a 	mov	r2,zero
8112cc60:	003fee06 	br	8112cc1c <__reset+0xfb10cc1c>

8112cc64 <_fclose_r>:
8112cc64:	28003b26 	beq	r5,zero,8112cd54 <_fclose_r+0xf0>
8112cc68:	defffc04 	addi	sp,sp,-16
8112cc6c:	de00012e 	bgeu	sp,et,8112cc74 <_fclose_r+0x10>
8112cc70:	003b68fa 	trap	3
8112cc74:	dc400115 	stw	r17,4(sp)
8112cc78:	dc000015 	stw	r16,0(sp)
8112cc7c:	dfc00315 	stw	ra,12(sp)
8112cc80:	dc800215 	stw	r18,8(sp)
8112cc84:	2023883a 	mov	r17,r4
8112cc88:	2821883a 	mov	r16,r5
8112cc8c:	20000226 	beq	r4,zero,8112cc98 <_fclose_r+0x34>
8112cc90:	20800e17 	ldw	r2,56(r4)
8112cc94:	10002726 	beq	r2,zero,8112cd34 <_fclose_r+0xd0>
8112cc98:	8080030f 	ldh	r2,12(r16)
8112cc9c:	1000071e 	bne	r2,zero,8112ccbc <_fclose_r+0x58>
8112cca0:	0005883a 	mov	r2,zero
8112cca4:	dfc00317 	ldw	ra,12(sp)
8112cca8:	dc800217 	ldw	r18,8(sp)
8112ccac:	dc400117 	ldw	r17,4(sp)
8112ccb0:	dc000017 	ldw	r16,0(sp)
8112ccb4:	dec00404 	addi	sp,sp,16
8112ccb8:	f800283a 	ret
8112ccbc:	800b883a 	mov	r5,r16
8112ccc0:	8809883a 	mov	r4,r17
8112ccc4:	1124be80 	call	81124be8 <__sflush_r>
8112ccc8:	1025883a 	mov	r18,r2
8112cccc:	80800b17 	ldw	r2,44(r16)
8112ccd0:	10000426 	beq	r2,zero,8112cce4 <_fclose_r+0x80>
8112ccd4:	81400717 	ldw	r5,28(r16)
8112ccd8:	8809883a 	mov	r4,r17
8112ccdc:	103ee83a 	callr	r2
8112cce0:	10001616 	blt	r2,zero,8112cd3c <_fclose_r+0xd8>
8112cce4:	8080030b 	ldhu	r2,12(r16)
8112cce8:	1080200c 	andi	r2,r2,128
8112ccec:	1000151e 	bne	r2,zero,8112cd44 <_fclose_r+0xe0>
8112ccf0:	81400c17 	ldw	r5,48(r16)
8112ccf4:	28000526 	beq	r5,zero,8112cd0c <_fclose_r+0xa8>
8112ccf8:	80801004 	addi	r2,r16,64
8112ccfc:	28800226 	beq	r5,r2,8112cd08 <_fclose_r+0xa4>
8112cd00:	8809883a 	mov	r4,r17
8112cd04:	11256a00 	call	811256a0 <_free_r>
8112cd08:	80000c15 	stw	zero,48(r16)
8112cd0c:	81401117 	ldw	r5,68(r16)
8112cd10:	28000326 	beq	r5,zero,8112cd20 <_fclose_r+0xbc>
8112cd14:	8809883a 	mov	r4,r17
8112cd18:	11256a00 	call	811256a0 <_free_r>
8112cd1c:	80001115 	stw	zero,68(r16)
8112cd20:	11252180 	call	81125218 <__sfp_lock_acquire>
8112cd24:	8000030d 	sth	zero,12(r16)
8112cd28:	112521c0 	call	8112521c <__sfp_lock_release>
8112cd2c:	9005883a 	mov	r2,r18
8112cd30:	003fdc06 	br	8112cca4 <__reset+0xfb10cca4>
8112cd34:	11252080 	call	81125208 <__sinit>
8112cd38:	003fd706 	br	8112cc98 <__reset+0xfb10cc98>
8112cd3c:	04bfffc4 	movi	r18,-1
8112cd40:	003fe806 	br	8112cce4 <__reset+0xfb10cce4>
8112cd44:	81400417 	ldw	r5,16(r16)
8112cd48:	8809883a 	mov	r4,r17
8112cd4c:	11256a00 	call	811256a0 <_free_r>
8112cd50:	003fe706 	br	8112ccf0 <__reset+0xfb10ccf0>
8112cd54:	0005883a 	mov	r2,zero
8112cd58:	f800283a 	ret

8112cd5c <fclose>:
8112cd5c:	00a04574 	movhi	r2,33045
8112cd60:	10b34e04 	addi	r2,r2,-13000
8112cd64:	200b883a 	mov	r5,r4
8112cd68:	11000017 	ldw	r4,0(r2)
8112cd6c:	112cc641 	jmpi	8112cc64 <_fclose_r>

8112cd70 <__fputwc>:
8112cd70:	defff804 	addi	sp,sp,-32
8112cd74:	de00012e 	bgeu	sp,et,8112cd7c <__fputwc+0xc>
8112cd78:	003b68fa 	trap	3
8112cd7c:	dcc00415 	stw	r19,16(sp)
8112cd80:	dc800315 	stw	r18,12(sp)
8112cd84:	dc000115 	stw	r16,4(sp)
8112cd88:	dfc00715 	stw	ra,28(sp)
8112cd8c:	dd400615 	stw	r21,24(sp)
8112cd90:	dd000515 	stw	r20,20(sp)
8112cd94:	dc400215 	stw	r17,8(sp)
8112cd98:	2027883a 	mov	r19,r4
8112cd9c:	2825883a 	mov	r18,r5
8112cda0:	3021883a 	mov	r16,r6
8112cda4:	11261300 	call	81126130 <__locale_mb_cur_max>
8112cda8:	00c00044 	movi	r3,1
8112cdac:	10c03e26 	beq	r2,r3,8112cea8 <__fputwc+0x138>
8112cdb0:	81c01704 	addi	r7,r16,92
8112cdb4:	900d883a 	mov	r6,r18
8112cdb8:	d80b883a 	mov	r5,sp
8112cdbc:	9809883a 	mov	r4,r19
8112cdc0:	112dbf40 	call	8112dbf4 <_wcrtomb_r>
8112cdc4:	1029883a 	mov	r20,r2
8112cdc8:	00bfffc4 	movi	r2,-1
8112cdcc:	a0802026 	beq	r20,r2,8112ce50 <__fputwc+0xe0>
8112cdd0:	d9400003 	ldbu	r5,0(sp)
8112cdd4:	a0001c26 	beq	r20,zero,8112ce48 <__fputwc+0xd8>
8112cdd8:	0023883a 	mov	r17,zero
8112cddc:	05400284 	movi	r21,10
8112cde0:	00000906 	br	8112ce08 <__fputwc+0x98>
8112cde4:	80800017 	ldw	r2,0(r16)
8112cde8:	11400005 	stb	r5,0(r2)
8112cdec:	80c00017 	ldw	r3,0(r16)
8112cdf0:	18c00044 	addi	r3,r3,1
8112cdf4:	80c00015 	stw	r3,0(r16)
8112cdf8:	8c400044 	addi	r17,r17,1
8112cdfc:	dc45883a 	add	r2,sp,r17
8112ce00:	8d00112e 	bgeu	r17,r20,8112ce48 <__fputwc+0xd8>
8112ce04:	11400003 	ldbu	r5,0(r2)
8112ce08:	80c00217 	ldw	r3,8(r16)
8112ce0c:	18ffffc4 	addi	r3,r3,-1
8112ce10:	80c00215 	stw	r3,8(r16)
8112ce14:	183ff30e 	bge	r3,zero,8112cde4 <__reset+0xfb10cde4>
8112ce18:	80800617 	ldw	r2,24(r16)
8112ce1c:	18801916 	blt	r3,r2,8112ce84 <__fputwc+0x114>
8112ce20:	80800017 	ldw	r2,0(r16)
8112ce24:	11400005 	stb	r5,0(r2)
8112ce28:	80800017 	ldw	r2,0(r16)
8112ce2c:	10c00003 	ldbu	r3,0(r2)
8112ce30:	10800044 	addi	r2,r2,1
8112ce34:	1d402326 	beq	r3,r21,8112cec4 <__fputwc+0x154>
8112ce38:	80800015 	stw	r2,0(r16)
8112ce3c:	8c400044 	addi	r17,r17,1
8112ce40:	dc45883a 	add	r2,sp,r17
8112ce44:	8d3fef36 	bltu	r17,r20,8112ce04 <__reset+0xfb10ce04>
8112ce48:	9005883a 	mov	r2,r18
8112ce4c:	00000406 	br	8112ce60 <__fputwc+0xf0>
8112ce50:	80c0030b 	ldhu	r3,12(r16)
8112ce54:	a005883a 	mov	r2,r20
8112ce58:	18c01014 	ori	r3,r3,64
8112ce5c:	80c0030d 	sth	r3,12(r16)
8112ce60:	dfc00717 	ldw	ra,28(sp)
8112ce64:	dd400617 	ldw	r21,24(sp)
8112ce68:	dd000517 	ldw	r20,20(sp)
8112ce6c:	dcc00417 	ldw	r19,16(sp)
8112ce70:	dc800317 	ldw	r18,12(sp)
8112ce74:	dc400217 	ldw	r17,8(sp)
8112ce78:	dc000117 	ldw	r16,4(sp)
8112ce7c:	dec00804 	addi	sp,sp,32
8112ce80:	f800283a 	ret
8112ce84:	800d883a 	mov	r6,r16
8112ce88:	29403fcc 	andi	r5,r5,255
8112ce8c:	9809883a 	mov	r4,r19
8112ce90:	1122fd00 	call	81122fd0 <__swbuf_r>
8112ce94:	10bfffe0 	cmpeqi	r2,r2,-1
8112ce98:	10803fcc 	andi	r2,r2,255
8112ce9c:	103fd626 	beq	r2,zero,8112cdf8 <__reset+0xfb10cdf8>
8112cea0:	00bfffc4 	movi	r2,-1
8112cea4:	003fee06 	br	8112ce60 <__reset+0xfb10ce60>
8112cea8:	90ffffc4 	addi	r3,r18,-1
8112ceac:	01003f84 	movi	r4,254
8112ceb0:	20ffbf36 	bltu	r4,r3,8112cdb0 <__reset+0xfb10cdb0>
8112ceb4:	900b883a 	mov	r5,r18
8112ceb8:	dc800005 	stb	r18,0(sp)
8112cebc:	1029883a 	mov	r20,r2
8112cec0:	003fc506 	br	8112cdd8 <__reset+0xfb10cdd8>
8112cec4:	800d883a 	mov	r6,r16
8112cec8:	a80b883a 	mov	r5,r21
8112cecc:	9809883a 	mov	r4,r19
8112ced0:	1122fd00 	call	81122fd0 <__swbuf_r>
8112ced4:	10bfffe0 	cmpeqi	r2,r2,-1
8112ced8:	003fef06 	br	8112ce98 <__reset+0xfb10ce98>

8112cedc <_fputwc_r>:
8112cedc:	3080030b 	ldhu	r2,12(r6)
8112cee0:	10c8000c 	andi	r3,r2,8192
8112cee4:	1800051e 	bne	r3,zero,8112cefc <_fputwc_r+0x20>
8112cee8:	30c01917 	ldw	r3,100(r6)
8112ceec:	10880014 	ori	r2,r2,8192
8112cef0:	3080030d 	sth	r2,12(r6)
8112cef4:	18880014 	ori	r2,r3,8192
8112cef8:	30801915 	stw	r2,100(r6)
8112cefc:	112cd701 	jmpi	8112cd70 <__fputwc>

8112cf00 <fputwc>:
8112cf00:	00a04574 	movhi	r2,33045
8112cf04:	defffc04 	addi	sp,sp,-16
8112cf08:	10b34e04 	addi	r2,r2,-13000
8112cf0c:	de00012e 	bgeu	sp,et,8112cf14 <fputwc+0x14>
8112cf10:	003b68fa 	trap	3
8112cf14:	dc000115 	stw	r16,4(sp)
8112cf18:	14000017 	ldw	r16,0(r2)
8112cf1c:	dc400215 	stw	r17,8(sp)
8112cf20:	dfc00315 	stw	ra,12(sp)
8112cf24:	2023883a 	mov	r17,r4
8112cf28:	80000226 	beq	r16,zero,8112cf34 <fputwc+0x34>
8112cf2c:	80800e17 	ldw	r2,56(r16)
8112cf30:	10001026 	beq	r2,zero,8112cf74 <fputwc+0x74>
8112cf34:	2880030b 	ldhu	r2,12(r5)
8112cf38:	10c8000c 	andi	r3,r2,8192
8112cf3c:	1800051e 	bne	r3,zero,8112cf54 <fputwc+0x54>
8112cf40:	28c01917 	ldw	r3,100(r5)
8112cf44:	10880014 	ori	r2,r2,8192
8112cf48:	2880030d 	sth	r2,12(r5)
8112cf4c:	18880014 	ori	r2,r3,8192
8112cf50:	28801915 	stw	r2,100(r5)
8112cf54:	280d883a 	mov	r6,r5
8112cf58:	8009883a 	mov	r4,r16
8112cf5c:	880b883a 	mov	r5,r17
8112cf60:	dfc00317 	ldw	ra,12(sp)
8112cf64:	dc400217 	ldw	r17,8(sp)
8112cf68:	dc000117 	ldw	r16,4(sp)
8112cf6c:	dec00404 	addi	sp,sp,16
8112cf70:	112cd701 	jmpi	8112cd70 <__fputwc>
8112cf74:	8009883a 	mov	r4,r16
8112cf78:	d9400015 	stw	r5,0(sp)
8112cf7c:	11252080 	call	81125208 <__sinit>
8112cf80:	d9400017 	ldw	r5,0(sp)
8112cf84:	003feb06 	br	8112cf34 <__reset+0xfb10cf34>

8112cf88 <rshift>:
8112cf88:	2807d17a 	srai	r3,r5,5
8112cf8c:	20800417 	ldw	r2,16(r4)
8112cf90:	22000504 	addi	r8,r4,20
8112cf94:	1880250e 	bge	r3,r2,8112d02c <rshift+0xa4>
8112cf98:	1085883a 	add	r2,r2,r2
8112cf9c:	18c7883a 	add	r3,r3,r3
8112cfa0:	1085883a 	add	r2,r2,r2
8112cfa4:	18c7883a 	add	r3,r3,r3
8112cfa8:	294007cc 	andi	r5,r5,31
8112cfac:	4085883a 	add	r2,r8,r2
8112cfb0:	40c7883a 	add	r3,r8,r3
8112cfb4:	28002026 	beq	r5,zero,8112d038 <rshift+0xb0>
8112cfb8:	19800017 	ldw	r6,0(r3)
8112cfbc:	02c00804 	movi	r11,32
8112cfc0:	19c00104 	addi	r7,r3,4
8112cfc4:	5957c83a 	sub	r11,r11,r5
8112cfc8:	314cd83a 	srl	r6,r6,r5
8112cfcc:	38802c2e 	bgeu	r7,r2,8112d080 <rshift+0xf8>
8112cfd0:	4015883a 	mov	r10,r8
8112cfd4:	3a400017 	ldw	r9,0(r7)
8112cfd8:	52800104 	addi	r10,r10,4
8112cfdc:	39c00104 	addi	r7,r7,4
8112cfe0:	4ad2983a 	sll	r9,r9,r11
8112cfe4:	498cb03a 	or	r6,r9,r6
8112cfe8:	51bfff15 	stw	r6,-4(r10)
8112cfec:	39bfff17 	ldw	r6,-4(r7)
8112cff0:	314cd83a 	srl	r6,r6,r5
8112cff4:	38bff736 	bltu	r7,r2,8112cfd4 <__reset+0xfb10cfd4>
8112cff8:	10c7c83a 	sub	r3,r2,r3
8112cffc:	18fffec4 	addi	r3,r3,-5
8112d000:	1806d0ba 	srli	r3,r3,2
8112d004:	18c00044 	addi	r3,r3,1
8112d008:	18c7883a 	add	r3,r3,r3
8112d00c:	18c7883a 	add	r3,r3,r3
8112d010:	40c7883a 	add	r3,r8,r3
8112d014:	19800015 	stw	r6,0(r3)
8112d018:	30000126 	beq	r6,zero,8112d020 <rshift+0x98>
8112d01c:	18c00104 	addi	r3,r3,4
8112d020:	1a05c83a 	sub	r2,r3,r8
8112d024:	1005d0ba 	srai	r2,r2,2
8112d028:	00001206 	br	8112d074 <rshift+0xec>
8112d02c:	20000415 	stw	zero,16(r4)
8112d030:	20000515 	stw	zero,20(r4)
8112d034:	f800283a 	ret
8112d038:	18bffc2e 	bgeu	r3,r2,8112d02c <__reset+0xfb10d02c>
8112d03c:	180d883a 	mov	r6,r3
8112d040:	400b883a 	mov	r5,r8
8112d044:	31c00017 	ldw	r7,0(r6)
8112d048:	29400104 	addi	r5,r5,4
8112d04c:	31800104 	addi	r6,r6,4
8112d050:	29ffff15 	stw	r7,-4(r5)
8112d054:	30bffb36 	bltu	r6,r2,8112d044 <__reset+0xfb10d044>
8112d058:	00c6303a 	nor	r3,zero,r3
8112d05c:	1885883a 	add	r2,r3,r2
8112d060:	1004d0ba 	srli	r2,r2,2
8112d064:	10800044 	addi	r2,r2,1
8112d068:	1085883a 	add	r2,r2,r2
8112d06c:	1085883a 	add	r2,r2,r2
8112d070:	1005d0ba 	srai	r2,r2,2
8112d074:	20800415 	stw	r2,16(r4)
8112d078:	103fed26 	beq	r2,zero,8112d030 <__reset+0xfb10d030>
8112d07c:	f800283a 	ret
8112d080:	4007883a 	mov	r3,r8
8112d084:	003fe306 	br	8112d014 <__reset+0xfb10d014>

8112d088 <__gethex>:
8112d088:	deffeb04 	addi	sp,sp,-84
8112d08c:	de00012e 	bgeu	sp,et,8112d094 <__gethex+0xc>
8112d090:	003b68fa 	trap	3
8112d094:	dfc01415 	stw	ra,80(sp)
8112d098:	dd801115 	stw	r22,68(sp)
8112d09c:	dcc00e15 	stw	r19,56(sp)
8112d0a0:	dc800d15 	stw	r18,52(sp)
8112d0a4:	2827883a 	mov	r19,r5
8112d0a8:	d9000115 	stw	r4,4(sp)
8112d0ac:	d9800015 	stw	r6,0(sp)
8112d0b0:	d9c00415 	stw	r7,16(sp)
8112d0b4:	df001315 	stw	fp,76(sp)
8112d0b8:	ddc01215 	stw	r23,72(sp)
8112d0bc:	dd401015 	stw	r21,64(sp)
8112d0c0:	dd000f15 	stw	r20,60(sp)
8112d0c4:	dc400c15 	stw	r17,48(sp)
8112d0c8:	dc000b15 	stw	r16,44(sp)
8112d0cc:	11261540 	call	81126154 <_localeconv_r>
8112d0d0:	14800017 	ldw	r18,0(r2)
8112d0d4:	9009883a 	mov	r4,r18
8112d0d8:	111cf340 	call	8111cf34 <strlen>
8112d0dc:	98c00017 	ldw	r3,0(r19)
8112d0e0:	102d883a 	mov	r22,r2
8112d0e4:	9085883a 	add	r2,r18,r2
8112d0e8:	10bfffc3 	ldbu	r2,-1(r2)
8112d0ec:	19000083 	ldbu	r4,2(r3)
8112d0f0:	d8800305 	stb	r2,12(sp)
8112d0f4:	00800c04 	movi	r2,48
8112d0f8:	2081521e 	bne	r4,r2,8112d644 <__gethex+0x5bc>
8112d0fc:	017fff84 	movi	r5,-2
8112d100:	188000c4 	addi	r2,r3,3
8112d104:	28cbc83a 	sub	r5,r5,r3
8112d108:	200d883a 	mov	r6,r4
8112d10c:	28a3883a 	add	r17,r5,r2
8112d110:	102b883a 	mov	r21,r2
8112d114:	10800044 	addi	r2,r2,1
8112d118:	113fffc3 	ldbu	r4,-1(r2)
8112d11c:	21bffb26 	beq	r4,r6,8112d10c <__reset+0xfb10d10c>
8112d120:	05204574 	movhi	r20,33045
8112d124:	a52a1904 	addi	r20,r20,-22428
8112d128:	a109883a 	add	r4,r20,r4
8112d12c:	20800003 	ldbu	r2,0(r4)
8112d130:	10008826 	beq	r2,zero,8112d354 <__gethex+0x2cc>
8112d134:	a8800003 	ldbu	r2,0(r21)
8112d138:	0015883a 	mov	r10,zero
8112d13c:	002f883a 	mov	r23,zero
8112d140:	a085883a 	add	r2,r20,r2
8112d144:	10800003 	ldbu	r2,0(r2)
8112d148:	a821883a 	mov	r16,r21
8112d14c:	10000526 	beq	r2,zero,8112d164 <__gethex+0xdc>
8112d150:	84000044 	addi	r16,r16,1
8112d154:	80800003 	ldbu	r2,0(r16)
8112d158:	a085883a 	add	r2,r20,r2
8112d15c:	10800003 	ldbu	r2,0(r2)
8112d160:	103ffb1e 	bne	r2,zero,8112d150 <__reset+0xfb10d150>
8112d164:	b00d883a 	mov	r6,r22
8112d168:	900b883a 	mov	r5,r18
8112d16c:	8009883a 	mov	r4,r16
8112d170:	da800a15 	stw	r10,40(sp)
8112d174:	112db240 	call	8112db24 <strncmp>
8112d178:	da800a17 	ldw	r10,40(sp)
8112d17c:	1000031e 	bne	r2,zero,8112d18c <__gethex+0x104>
8112d180:	b8015226 	beq	r23,zero,8112d6cc <__gethex+0x644>
8112d184:	80800003 	ldbu	r2,0(r16)
8112d188:	00000206 	br	8112d194 <__gethex+0x10c>
8112d18c:	80800003 	ldbu	r2,0(r16)
8112d190:	b8011f26 	beq	r23,zero,8112d610 <__gethex+0x588>
8112d194:	85efc83a 	sub	r23,r16,r23
8112d198:	bdef883a 	add	r23,r23,r23
8112d19c:	bdef883a 	add	r23,r23,r23
8112d1a0:	05efc83a 	sub	r23,zero,r23
8112d1a4:	10803fcc 	andi	r2,r2,255
8112d1a8:	01001404 	movi	r4,80
8112d1ac:	11008626 	beq	r2,r4,8112d3c8 <__gethex+0x340>
8112d1b0:	01001c04 	movi	r4,112
8112d1b4:	11008426 	beq	r2,r4,8112d3c8 <__gethex+0x340>
8112d1b8:	8039883a 	mov	fp,r16
8112d1bc:	9c000015 	stw	r16,0(r19)
8112d1c0:	5000711e 	bne	r10,zero,8112d388 <__gethex+0x300>
8112d1c4:	e545c83a 	sub	r2,fp,r21
8112d1c8:	10bfffc4 	addi	r2,r2,-1
8112d1cc:	010001c4 	movi	r4,7
8112d1d0:	000b883a 	mov	r5,zero
8112d1d4:	2080030e 	bge	r4,r2,8112d1e4 <__gethex+0x15c>
8112d1d8:	1005d07a 	srai	r2,r2,1
8112d1dc:	29400044 	addi	r5,r5,1
8112d1e0:	20bffd16 	blt	r4,r2,8112d1d8 <__reset+0xfb10d1d8>
8112d1e4:	d9000117 	ldw	r4,4(sp)
8112d1e8:	11266700 	call	81126670 <_Balloc>
8112d1ec:	10c00504 	addi	r3,r2,20
8112d1f0:	d8c00215 	stw	r3,8(sp)
8112d1f4:	1021883a 	mov	r16,r2
8112d1f8:	af01732e 	bgeu	r21,fp,8112d7c8 <__gethex+0x740>
8112d1fc:	dc400303 	ldbu	r17,12(sp)
8112d200:	03400044 	movi	r13,1
8112d204:	1815883a 	mov	r10,r3
8112d208:	0013883a 	mov	r9,zero
8112d20c:	0027883a 	mov	r19,zero
8112d210:	6d9bc83a 	sub	r13,r13,r22
8112d214:	02c00804 	movi	r11,32
8112d218:	e0bfffc3 	ldbu	r2,-1(fp)
8112d21c:	e3bfffc4 	addi	r14,fp,-1
8112d220:	88803026 	beq	r17,r2,8112d2e4 <__gethex+0x25c>
8112d224:	9ac04526 	beq	r19,r11,8112d33c <__gethex+0x2b4>
8112d228:	980b883a 	mov	r5,r19
8112d22c:	9cc00104 	addi	r19,r19,4
8112d230:	e13fffc3 	ldbu	r4,-1(fp)
8112d234:	7039883a 	mov	fp,r14
8112d238:	a109883a 	add	r4,r20,r4
8112d23c:	20800003 	ldbu	r2,0(r4)
8112d240:	108003cc 	andi	r2,r2,15
8112d244:	1144983a 	sll	r2,r2,r5
8112d248:	4892b03a 	or	r9,r9,r2
8112d24c:	af3ff236 	bltu	r21,fp,8112d218 <__reset+0xfb10d218>
8112d250:	d8c00217 	ldw	r3,8(sp)
8112d254:	50800104 	addi	r2,r10,4
8112d258:	52400015 	stw	r9,0(r10)
8112d25c:	10c5c83a 	sub	r2,r2,r3
8112d260:	1005d0ba 	srai	r2,r2,2
8112d264:	4809883a 	mov	r4,r9
8112d268:	80800415 	stw	r2,16(r16)
8112d26c:	1022917a 	slli	r17,r2,5
8112d270:	112697c0 	call	8112697c <__hi0bits>
8112d274:	d8c00017 	ldw	r3,0(sp)
8112d278:	8885c83a 	sub	r2,r17,r2
8112d27c:	1c800017 	ldw	r18,0(r3)
8112d280:	9080c716 	blt	r18,r2,8112d5a0 <__gethex+0x518>
8112d284:	1480e416 	blt	r2,r18,8112d618 <__gethex+0x590>
8112d288:	0027883a 	mov	r19,zero
8112d28c:	d8c00017 	ldw	r3,0(sp)
8112d290:	18800217 	ldw	r2,8(r3)
8112d294:	15c08d16 	blt	r2,r23,8112d4cc <__gethex+0x444>
8112d298:	d8c00017 	ldw	r3,0(sp)
8112d29c:	18800117 	ldw	r2,4(r3)
8112d2a0:	b880aa0e 	bge	r23,r2,8112d54c <__gethex+0x4c4>
8112d2a4:	15efc83a 	sub	r23,r2,r23
8112d2a8:	bc80ed16 	blt	r23,r18,8112d660 <__gethex+0x5d8>
8112d2ac:	18c00317 	ldw	r3,12(r3)
8112d2b0:	01000084 	movi	r4,2
8112d2b4:	19014926 	beq	r3,r4,8112d7dc <__gethex+0x754>
8112d2b8:	010000c4 	movi	r4,3
8112d2bc:	19012e26 	beq	r3,r4,8112d778 <__gethex+0x6f0>
8112d2c0:	01000044 	movi	r4,1
8112d2c4:	19014826 	beq	r3,r4,8112d7e8 <__gethex+0x760>
8112d2c8:	d9000117 	ldw	r4,4(sp)
8112d2cc:	800b883a 	mov	r5,r16
8112d2d0:	11267200 	call	81126720 <_Bfree>
8112d2d4:	d8801517 	ldw	r2,84(sp)
8112d2d8:	10000015 	stw	zero,0(r2)
8112d2dc:	00801404 	movi	r2,80
8112d2e0:	00002b06 	br	8112d390 <__gethex+0x308>
8112d2e4:	735f883a 	add	r15,r14,r13
8112d2e8:	7d7fce36 	bltu	r15,r21,8112d224 <__reset+0xfb10d224>
8112d2ec:	7809883a 	mov	r4,r15
8112d2f0:	b00d883a 	mov	r6,r22
8112d2f4:	900b883a 	mov	r5,r18
8112d2f8:	da400515 	stw	r9,20(sp)
8112d2fc:	da800a15 	stw	r10,40(sp)
8112d300:	dac00915 	stw	r11,36(sp)
8112d304:	db400815 	stw	r13,32(sp)
8112d308:	db800615 	stw	r14,24(sp)
8112d30c:	dbc00715 	stw	r15,28(sp)
8112d310:	112db240 	call	8112db24 <strncmp>
8112d314:	da400517 	ldw	r9,20(sp)
8112d318:	da800a17 	ldw	r10,40(sp)
8112d31c:	dac00917 	ldw	r11,36(sp)
8112d320:	db400817 	ldw	r13,32(sp)
8112d324:	db800617 	ldw	r14,24(sp)
8112d328:	dbc00717 	ldw	r15,28(sp)
8112d32c:	103fbd1e 	bne	r2,zero,8112d224 <__reset+0xfb10d224>
8112d330:	7839883a 	mov	fp,r15
8112d334:	af3fb836 	bltu	r21,fp,8112d218 <__reset+0xfb10d218>
8112d338:	003fc506 	br	8112d250 <__reset+0xfb10d250>
8112d33c:	04c00104 	movi	r19,4
8112d340:	52400015 	stw	r9,0(r10)
8112d344:	000b883a 	mov	r5,zero
8112d348:	54d5883a 	add	r10,r10,r19
8112d34c:	0013883a 	mov	r9,zero
8112d350:	003fb706 	br	8112d230 <__reset+0xfb10d230>
8112d354:	b00d883a 	mov	r6,r22
8112d358:	900b883a 	mov	r5,r18
8112d35c:	a809883a 	mov	r4,r21
8112d360:	112db240 	call	8112db24 <strncmp>
8112d364:	10006426 	beq	r2,zero,8112d4f8 <__gethex+0x470>
8112d368:	a8800003 	ldbu	r2,0(r21)
8112d36c:	a821883a 	mov	r16,r21
8112d370:	10803fcc 	andi	r2,r2,255
8112d374:	01001404 	movi	r4,80
8112d378:	11001126 	beq	r2,r4,8112d3c0 <__gethex+0x338>
8112d37c:	01001c04 	movi	r4,112
8112d380:	11000f26 	beq	r2,r4,8112d3c0 <__gethex+0x338>
8112d384:	9c000015 	stw	r16,0(r19)
8112d388:	8800831e 	bne	r17,zero,8112d598 <__gethex+0x510>
8112d38c:	00800184 	movi	r2,6
8112d390:	dfc01417 	ldw	ra,80(sp)
8112d394:	df001317 	ldw	fp,76(sp)
8112d398:	ddc01217 	ldw	r23,72(sp)
8112d39c:	dd801117 	ldw	r22,68(sp)
8112d3a0:	dd401017 	ldw	r21,64(sp)
8112d3a4:	dd000f17 	ldw	r20,60(sp)
8112d3a8:	dcc00e17 	ldw	r19,56(sp)
8112d3ac:	dc800d17 	ldw	r18,52(sp)
8112d3b0:	dc400c17 	ldw	r17,48(sp)
8112d3b4:	dc000b17 	ldw	r16,44(sp)
8112d3b8:	dec01504 	addi	sp,sp,84
8112d3bc:	f800283a 	ret
8112d3c0:	002f883a 	mov	r23,zero
8112d3c4:	02800044 	movi	r10,1
8112d3c8:	80800043 	ldbu	r2,1(r16)
8112d3cc:	01400ac4 	movi	r5,43
8112d3d0:	11003fcc 	andi	r4,r2,255
8112d3d4:	21406e26 	beq	r4,r5,8112d590 <__gethex+0x508>
8112d3d8:	01400b44 	movi	r5,45
8112d3dc:	21404226 	beq	r4,r5,8112d4e8 <__gethex+0x460>
8112d3e0:	81400044 	addi	r5,r16,1
8112d3e4:	000d883a 	mov	r6,zero
8112d3e8:	10803fcc 	andi	r2,r2,255
8112d3ec:	a085883a 	add	r2,r20,r2
8112d3f0:	11000003 	ldbu	r4,0(r2)
8112d3f4:	03000604 	movi	r12,24
8112d3f8:	20bfffc4 	addi	r2,r4,-1
8112d3fc:	10803fcc 	andi	r2,r2,255
8112d400:	60bf6d36 	bltu	r12,r2,8112d1b8 <__reset+0xfb10d1b8>
8112d404:	2ac00043 	ldbu	r11,1(r5)
8112d408:	20803fcc 	andi	r2,r4,255
8112d40c:	01204574 	movhi	r4,33045
8112d410:	212a1904 	addi	r4,r4,-22428
8112d414:	22c9883a 	add	r4,r4,r11
8112d418:	23400003 	ldbu	r13,0(r4)
8112d41c:	10bffc04 	addi	r2,r2,-16
8112d420:	29400044 	addi	r5,r5,1
8112d424:	693fffc4 	addi	r4,r13,-1
8112d428:	21003fcc 	andi	r4,r4,255
8112d42c:	6b403fcc 	andi	r13,r13,255
8112d430:	61000b36 	bltu	r12,r4,8112d460 <__gethex+0x3d8>
8112d434:	29400044 	addi	r5,r5,1
8112d438:	29000003 	ldbu	r4,0(r5)
8112d43c:	108002a4 	muli	r2,r2,10
8112d440:	a109883a 	add	r4,r20,r4
8112d444:	22c00003 	ldbu	r11,0(r4)
8112d448:	1345883a 	add	r2,r2,r13
8112d44c:	10bffc04 	addi	r2,r2,-16
8112d450:	593fffc4 	addi	r4,r11,-1
8112d454:	21003fcc 	andi	r4,r4,255
8112d458:	5b403fcc 	andi	r13,r11,255
8112d45c:	613ff52e 	bgeu	r12,r4,8112d434 <__reset+0xfb10d434>
8112d460:	30000126 	beq	r6,zero,8112d468 <__gethex+0x3e0>
8112d464:	0085c83a 	sub	r2,zero,r2
8112d468:	8039883a 	mov	fp,r16
8112d46c:	b8af883a 	add	r23,r23,r2
8112d470:	2821883a 	mov	r16,r5
8112d474:	003f5106 	br	8112d1bc <__reset+0xfb10d1bc>
8112d478:	80800217 	ldw	r2,8(r16)
8112d47c:	e080f00e 	bge	fp,r2,8112d840 <__gethex+0x7b8>
8112d480:	e007883a 	mov	r3,fp
8112d484:	18800144 	addi	r2,r3,5
8112d488:	1085883a 	add	r2,r2,r2
8112d48c:	18c00044 	addi	r3,r3,1
8112d490:	1085883a 	add	r2,r2,r2
8112d494:	8085883a 	add	r2,r16,r2
8112d498:	80c00415 	stw	r3,16(r16)
8112d49c:	01000044 	movi	r4,1
8112d4a0:	11000015 	stw	r4,0(r2)
8112d4a4:	00800084 	movi	r2,2
8112d4a8:	8880d826 	beq	r17,r2,8112d80c <__gethex+0x784>
8112d4ac:	e0c0ac0e 	bge	fp,r3,8112d760 <__gethex+0x6d8>
8112d4b0:	01400044 	movi	r5,1
8112d4b4:	8009883a 	mov	r4,r16
8112d4b8:	112cf880 	call	8112cf88 <rshift>
8112d4bc:	d8c00017 	ldw	r3,0(sp)
8112d4c0:	bdc00044 	addi	r23,r23,1
8112d4c4:	18800217 	ldw	r2,8(r3)
8112d4c8:	15c0a70e 	bge	r2,r23,8112d768 <__gethex+0x6e0>
8112d4cc:	d9000117 	ldw	r4,4(sp)
8112d4d0:	800b883a 	mov	r5,r16
8112d4d4:	11267200 	call	81126720 <_Bfree>
8112d4d8:	d9001517 	ldw	r4,84(sp)
8112d4dc:	008028c4 	movi	r2,163
8112d4e0:	20000015 	stw	zero,0(r4)
8112d4e4:	003faa06 	br	8112d390 <__reset+0xfb10d390>
8112d4e8:	01800044 	movi	r6,1
8112d4ec:	80800083 	ldbu	r2,2(r16)
8112d4f0:	81400084 	addi	r5,r16,2
8112d4f4:	003fbc06 	br	8112d3e8 <__reset+0xfb10d3e8>
8112d4f8:	ada1883a 	add	r16,r21,r22
8112d4fc:	81000003 	ldbu	r4,0(r16)
8112d500:	21403fcc 	andi	r5,r4,255
8112d504:	a145883a 	add	r2,r20,r5
8112d508:	10800003 	ldbu	r2,0(r2)
8112d50c:	11803fcc 	andi	r6,r2,255
8112d510:	30004f26 	beq	r6,zero,8112d650 <__gethex+0x5c8>
8112d514:	00c00c04 	movi	r3,48
8112d518:	802b883a 	mov	r21,r16
8112d51c:	28c0061e 	bne	r5,r3,8112d538 <__gethex+0x4b0>
8112d520:	2809883a 	mov	r4,r5
8112d524:	ad400044 	addi	r21,r21,1
8112d528:	a8800003 	ldbu	r2,0(r21)
8112d52c:	113ffd26 	beq	r2,r4,8112d524 <__reset+0xfb10d524>
8112d530:	a085883a 	add	r2,r20,r2
8112d534:	10800003 	ldbu	r2,0(r2)
8112d538:	10803fcc 	andi	r2,r2,255
8112d53c:	1015003a 	cmpeq	r10,r2,zero
8112d540:	802f883a 	mov	r23,r16
8112d544:	04400044 	movi	r17,1
8112d548:	003eff06 	br	8112d148 <__reset+0xfb10d148>
8112d54c:	04400044 	movi	r17,1
8112d550:	98000926 	beq	r19,zero,8112d578 <__gethex+0x4f0>
8112d554:	d8c00017 	ldw	r3,0(sp)
8112d558:	18800317 	ldw	r2,12(r3)
8112d55c:	00c00084 	movi	r3,2
8112d560:	10c06826 	beq	r2,r3,8112d704 <__gethex+0x67c>
8112d564:	00c000c4 	movi	r3,3
8112d568:	10c06a26 	beq	r2,r3,8112d714 <__gethex+0x68c>
8112d56c:	00c00044 	movi	r3,1
8112d570:	10c08d26 	beq	r2,r3,8112d7a8 <__gethex+0x720>
8112d574:	8c400414 	ori	r17,r17,16
8112d578:	d9001517 	ldw	r4,84(sp)
8112d57c:	d8c00417 	ldw	r3,16(sp)
8112d580:	8805883a 	mov	r2,r17
8112d584:	24000015 	stw	r16,0(r4)
8112d588:	1dc00015 	stw	r23,0(r3)
8112d58c:	003f8006 	br	8112d390 <__reset+0xfb10d390>
8112d590:	000d883a 	mov	r6,zero
8112d594:	003fd506 	br	8112d4ec <__reset+0xfb10d4ec>
8112d598:	0005883a 	mov	r2,zero
8112d59c:	003f7c06 	br	8112d390 <__reset+0xfb10d390>
8112d5a0:	14a3c83a 	sub	r17,r2,r18
8112d5a4:	880b883a 	mov	r5,r17
8112d5a8:	8009883a 	mov	r4,r16
8112d5ac:	11276400 	call	81127640 <__any_on>
8112d5b0:	10002926 	beq	r2,zero,8112d658 <__gethex+0x5d0>
8112d5b4:	897fffc4 	addi	r5,r17,-1
8112d5b8:	2807d17a 	srai	r3,r5,5
8112d5bc:	d8800217 	ldw	r2,8(sp)
8112d5c0:	290007cc 	andi	r4,r5,31
8112d5c4:	18c7883a 	add	r3,r3,r3
8112d5c8:	18c7883a 	add	r3,r3,r3
8112d5cc:	04c00044 	movi	r19,1
8112d5d0:	10c7883a 	add	r3,r2,r3
8112d5d4:	9908983a 	sll	r4,r19,r4
8112d5d8:	18c00017 	ldw	r3,0(r3)
8112d5dc:	20c6703a 	and	r3,r4,r3
8112d5e0:	18000626 	beq	r3,zero,8112d5fc <__gethex+0x574>
8112d5e4:	99407b0e 	bge	r19,r5,8112d7d4 <__gethex+0x74c>
8112d5e8:	897fff84 	addi	r5,r17,-2
8112d5ec:	8009883a 	mov	r4,r16
8112d5f0:	11276400 	call	81127640 <__any_on>
8112d5f4:	10007726 	beq	r2,zero,8112d7d4 <__gethex+0x74c>
8112d5f8:	04c000c4 	movi	r19,3
8112d5fc:	880b883a 	mov	r5,r17
8112d600:	8009883a 	mov	r4,r16
8112d604:	112cf880 	call	8112cf88 <rshift>
8112d608:	bc6f883a 	add	r23,r23,r17
8112d60c:	003f1f06 	br	8112d28c <__reset+0xfb10d28c>
8112d610:	002f883a 	mov	r23,zero
8112d614:	003ee306 	br	8112d1a4 <__reset+0xfb10d1a4>
8112d618:	d9000117 	ldw	r4,4(sp)
8112d61c:	90a3c83a 	sub	r17,r18,r2
8112d620:	800b883a 	mov	r5,r16
8112d624:	880d883a 	mov	r6,r17
8112d628:	1126e200 	call	81126e20 <__lshift>
8112d62c:	10c00504 	addi	r3,r2,20
8112d630:	1021883a 	mov	r16,r2
8112d634:	bc6fc83a 	sub	r23,r23,r17
8112d638:	d8c00215 	stw	r3,8(sp)
8112d63c:	0027883a 	mov	r19,zero
8112d640:	003f1206 	br	8112d28c <__reset+0xfb10d28c>
8112d644:	1d400084 	addi	r21,r3,2
8112d648:	0023883a 	mov	r17,zero
8112d64c:	003eb406 	br	8112d120 <__reset+0xfb10d120>
8112d650:	2005883a 	mov	r2,r4
8112d654:	003f4606 	br	8112d370 <__reset+0xfb10d370>
8112d658:	0027883a 	mov	r19,zero
8112d65c:	003fe706 	br	8112d5fc <__reset+0xfb10d5fc>
8112d660:	bc7fffc4 	addi	r17,r23,-1
8112d664:	9800421e 	bne	r19,zero,8112d770 <__gethex+0x6e8>
8112d668:	88000426 	beq	r17,zero,8112d67c <__gethex+0x5f4>
8112d66c:	880b883a 	mov	r5,r17
8112d670:	8009883a 	mov	r4,r16
8112d674:	11276400 	call	81127640 <__any_on>
8112d678:	1027883a 	mov	r19,r2
8112d67c:	8805d17a 	srai	r2,r17,5
8112d680:	d8c00217 	ldw	r3,8(sp)
8112d684:	8c4007cc 	andi	r17,r17,31
8112d688:	1085883a 	add	r2,r2,r2
8112d68c:	1085883a 	add	r2,r2,r2
8112d690:	1885883a 	add	r2,r3,r2
8112d694:	00c00044 	movi	r3,1
8112d698:	1c62983a 	sll	r17,r3,r17
8112d69c:	10800017 	ldw	r2,0(r2)
8112d6a0:	8884703a 	and	r2,r17,r2
8112d6a4:	10000126 	beq	r2,zero,8112d6ac <__gethex+0x624>
8112d6a8:	9cc00094 	ori	r19,r19,2
8112d6ac:	b80b883a 	mov	r5,r23
8112d6b0:	8009883a 	mov	r4,r16
8112d6b4:	112cf880 	call	8112cf88 <rshift>
8112d6b8:	d8c00017 	ldw	r3,0(sp)
8112d6bc:	95e5c83a 	sub	r18,r18,r23
8112d6c0:	04400084 	movi	r17,2
8112d6c4:	1dc00117 	ldw	r23,4(r3)
8112d6c8:	003fa106 	br	8112d550 <__reset+0xfb10d550>
8112d6cc:	85af883a 	add	r23,r16,r22
8112d6d0:	b8800003 	ldbu	r2,0(r23)
8112d6d4:	b821883a 	mov	r16,r23
8112d6d8:	11003fcc 	andi	r4,r2,255
8112d6dc:	a109883a 	add	r4,r20,r4
8112d6e0:	21000003 	ldbu	r4,0(r4)
8112d6e4:	203eaa26 	beq	r4,zero,8112d190 <__reset+0xfb10d190>
8112d6e8:	84000044 	addi	r16,r16,1
8112d6ec:	80800003 	ldbu	r2,0(r16)
8112d6f0:	11003fcc 	andi	r4,r2,255
8112d6f4:	a109883a 	add	r4,r20,r4
8112d6f8:	21000003 	ldbu	r4,0(r4)
8112d6fc:	203ffa1e 	bne	r4,zero,8112d6e8 <__reset+0xfb10d6e8>
8112d700:	003ea306 	br	8112d190 <__reset+0xfb10d190>
8112d704:	d9001617 	ldw	r4,88(sp)
8112d708:	00800044 	movi	r2,1
8112d70c:	1109c83a 	sub	r4,r2,r4
8112d710:	d9001615 	stw	r4,88(sp)
8112d714:	d8801617 	ldw	r2,88(sp)
8112d718:	103f9626 	beq	r2,zero,8112d574 <__reset+0xfb10d574>
8112d71c:	87000417 	ldw	fp,16(r16)
8112d720:	d9800217 	ldw	r6,8(sp)
8112d724:	013fffc4 	movi	r4,-1
8112d728:	e727883a 	add	r19,fp,fp
8112d72c:	9ce7883a 	add	r19,r19,r19
8112d730:	3005883a 	mov	r2,r6
8112d734:	34cb883a 	add	r5,r6,r19
8112d738:	00000306 	br	8112d748 <__gethex+0x6c0>
8112d73c:	10000015 	stw	zero,0(r2)
8112d740:	10800104 	addi	r2,r2,4
8112d744:	117f4c2e 	bgeu	r2,r5,8112d478 <__reset+0xfb10d478>
8112d748:	10c00017 	ldw	r3,0(r2)
8112d74c:	193ffb26 	beq	r3,r4,8112d73c <__reset+0xfb10d73c>
8112d750:	18c00044 	addi	r3,r3,1
8112d754:	10c00015 	stw	r3,0(r2)
8112d758:	00800084 	movi	r2,2
8112d75c:	88802b26 	beq	r17,r2,8112d80c <__gethex+0x784>
8112d760:	948007cc 	andi	r18,r18,31
8112d764:	90002f1e 	bne	r18,zero,8112d824 <__gethex+0x79c>
8112d768:	04400844 	movi	r17,33
8112d76c:	003f8206 	br	8112d578 <__reset+0xfb10d578>
8112d770:	04c00044 	movi	r19,1
8112d774:	003fc106 	br	8112d67c <__reset+0xfb10d67c>
8112d778:	d8c01617 	ldw	r3,88(sp)
8112d77c:	183ed226 	beq	r3,zero,8112d2c8 <__reset+0xfb10d2c8>
8112d780:	d8c00417 	ldw	r3,16(sp)
8112d784:	d9001517 	ldw	r4,84(sp)
8112d788:	18800015 	stw	r2,0(r3)
8112d78c:	d8c00217 	ldw	r3,8(sp)
8112d790:	00800044 	movi	r2,1
8112d794:	80800415 	stw	r2,16(r16)
8112d798:	18800015 	stw	r2,0(r3)
8112d79c:	24000015 	stw	r16,0(r4)
8112d7a0:	00801884 	movi	r2,98
8112d7a4:	003efa06 	br	8112d390 <__reset+0xfb10d390>
8112d7a8:	9880008c 	andi	r2,r19,2
8112d7ac:	103f7126 	beq	r2,zero,8112d574 <__reset+0xfb10d574>
8112d7b0:	d8c00217 	ldw	r3,8(sp)
8112d7b4:	18800017 	ldw	r2,0(r3)
8112d7b8:	9884b03a 	or	r2,r19,r2
8112d7bc:	1080004c 	andi	r2,r2,1
8112d7c0:	103fd61e 	bne	r2,zero,8112d71c <__reset+0xfb10d71c>
8112d7c4:	003f6b06 	br	8112d574 <__reset+0xfb10d574>
8112d7c8:	da800217 	ldw	r10,8(sp)
8112d7cc:	0013883a 	mov	r9,zero
8112d7d0:	003e9f06 	br	8112d250 <__reset+0xfb10d250>
8112d7d4:	04c00084 	movi	r19,2
8112d7d8:	003f8806 	br	8112d5fc <__reset+0xfb10d5fc>
8112d7dc:	d9001617 	ldw	r4,88(sp)
8112d7e0:	203fe726 	beq	r4,zero,8112d780 <__reset+0xfb10d780>
8112d7e4:	003eb806 	br	8112d2c8 <__reset+0xfb10d2c8>
8112d7e8:	95feb71e 	bne	r18,r23,8112d2c8 <__reset+0xfb10d2c8>
8112d7ec:	1cbfe40e 	bge	r3,r18,8112d780 <__reset+0xfb10d780>
8112d7f0:	917fffc4 	addi	r5,r18,-1
8112d7f4:	8009883a 	mov	r4,r16
8112d7f8:	11276400 	call	81127640 <__any_on>
8112d7fc:	103eb226 	beq	r2,zero,8112d2c8 <__reset+0xfb10d2c8>
8112d800:	d8c00017 	ldw	r3,0(sp)
8112d804:	18800117 	ldw	r2,4(r3)
8112d808:	003fdd06 	br	8112d780 <__reset+0xfb10d780>
8112d80c:	d8c00017 	ldw	r3,0(sp)
8112d810:	18800017 	ldw	r2,0(r3)
8112d814:	10bfffc4 	addi	r2,r2,-1
8112d818:	90801c26 	beq	r18,r2,8112d88c <__gethex+0x804>
8112d81c:	04400884 	movi	r17,34
8112d820:	003f5506 	br	8112d578 <__reset+0xfb10d578>
8112d824:	34c5883a 	add	r2,r6,r19
8112d828:	113fff17 	ldw	r4,-4(r2)
8112d82c:	112697c0 	call	8112697c <__hi0bits>
8112d830:	00c00804 	movi	r3,32
8112d834:	1ca5c83a 	sub	r18,r3,r18
8112d838:	14bfcb0e 	bge	r2,r18,8112d768 <__reset+0xfb10d768>
8112d83c:	003f1c06 	br	8112d4b0 <__reset+0xfb10d4b0>
8112d840:	81400117 	ldw	r5,4(r16)
8112d844:	d9000117 	ldw	r4,4(sp)
8112d848:	29400044 	addi	r5,r5,1
8112d84c:	11266700 	call	81126670 <_Balloc>
8112d850:	81800417 	ldw	r6,16(r16)
8112d854:	81400304 	addi	r5,r16,12
8112d858:	11000304 	addi	r4,r2,12
8112d85c:	31800084 	addi	r6,r6,2
8112d860:	318d883a 	add	r6,r6,r6
8112d864:	318d883a 	add	r6,r6,r6
8112d868:	1029883a 	mov	r20,r2
8112d86c:	111c4400 	call	8111c440 <memcpy>
8112d870:	d9000117 	ldw	r4,4(sp)
8112d874:	800b883a 	mov	r5,r16
8112d878:	a021883a 	mov	r16,r20
8112d87c:	11267200 	call	81126720 <_Bfree>
8112d880:	a0c00417 	ldw	r3,16(r20)
8112d884:	a1800504 	addi	r6,r20,20
8112d888:	003efe06 	br	8112d484 <__reset+0xfb10d484>
8112d88c:	9005d17a 	srai	r2,r18,5
8112d890:	944007cc 	andi	r17,r18,31
8112d894:	1085883a 	add	r2,r2,r2
8112d898:	1085883a 	add	r2,r2,r2
8112d89c:	3087883a 	add	r3,r6,r2
8112d8a0:	00800044 	movi	r2,1
8112d8a4:	1462983a 	sll	r17,r2,r17
8112d8a8:	18800017 	ldw	r2,0(r3)
8112d8ac:	8884703a 	and	r2,r17,r2
8112d8b0:	1022c03a 	cmpne	r17,r2,zero
8112d8b4:	00800884 	movi	r2,34
8112d8b8:	1463c83a 	sub	r17,r2,r17
8112d8bc:	003f2e06 	br	8112d578 <__reset+0xfb10d578>

8112d8c0 <__hexnan>:
8112d8c0:	defff904 	addi	sp,sp,-28
8112d8c4:	de00012e 	bgeu	sp,et,8112d8cc <__hexnan+0xc>
8112d8c8:	003b68fa 	trap	3
8112d8cc:	dc800215 	stw	r18,8(sp)
8112d8d0:	2c800017 	ldw	r18,0(r5)
8112d8d4:	dfc00615 	stw	ra,24(sp)
8112d8d8:	dd400515 	stw	r21,20(sp)
8112d8dc:	901fd17a 	srai	r15,r18,5
8112d8e0:	dd000415 	stw	r20,16(sp)
8112d8e4:	dcc00315 	stw	r19,12(sp)
8112d8e8:	7bdf883a 	add	r15,r15,r15
8112d8ec:	7bdf883a 	add	r15,r15,r15
8112d8f0:	dc400115 	stw	r17,4(sp)
8112d8f4:	dc000015 	stw	r16,0(sp)
8112d8f8:	948007cc 	andi	r18,r18,31
8112d8fc:	33df883a 	add	r15,r6,r15
8112d900:	90000126 	beq	r18,zero,8112d908 <__hexnan+0x48>
8112d904:	7bc00104 	addi	r15,r15,4
8112d908:	22000017 	ldw	r8,0(r4)
8112d90c:	7affff04 	addi	r11,r15,-4
8112d910:	03a04574 	movhi	r14,33045
8112d914:	783fff15 	stw	zero,-4(r15)
8112d918:	581b883a 	mov	r13,r11
8112d91c:	580b883a 	mov	r5,r11
8112d920:	000f883a 	mov	r7,zero
8112d924:	003f883a 	mov	ra,zero
8112d928:	0019883a 	mov	r12,zero
8112d92c:	73aa1904 	addi	r14,r14,-22428
8112d930:	04400204 	movi	r17,8
8112d934:	04000804 	movi	r16,32
8112d938:	04c001c4 	movi	r19,7
8112d93c:	42000044 	addi	r8,r8,1
8112d940:	40c00003 	ldbu	r3,0(r8)
8112d944:	18001d26 	beq	r3,zero,8112d9bc <__hexnan+0xfc>
8112d948:	70c5883a 	add	r2,r14,r3
8112d94c:	10800003 	ldbu	r2,0(r2)
8112d950:	12403fcc 	andi	r9,r2,255
8112d954:	4800301e 	bne	r9,zero,8112da18 <__hexnan+0x158>
8112d958:	80c04236 	bltu	r16,r3,8112da64 <__hexnan+0x1a4>
8112d95c:	fb3ff70e 	bge	ra,r12,8112d93c <__reset+0xfb10d93c>
8112d960:	2b40112e 	bgeu	r5,r13,8112d9a8 <__hexnan+0xe8>
8112d964:	99c01016 	blt	r19,r7,8112d9a8 <__hexnan+0xe8>
8112d968:	89e9c83a 	sub	r20,r17,r7
8112d96c:	a529883a 	add	r20,r20,r20
8112d970:	2a800017 	ldw	r10,0(r5)
8112d974:	a529883a 	add	r20,r20,r20
8112d978:	852bc83a 	sub	r21,r16,r20
8112d97c:	28c00104 	addi	r3,r5,4
8112d980:	2805883a 	mov	r2,r5
8112d984:	19c00017 	ldw	r7,0(r3)
8112d988:	10800104 	addi	r2,r2,4
8112d98c:	18c00104 	addi	r3,r3,4
8112d990:	3d52983a 	sll	r9,r7,r21
8112d994:	4a92b03a 	or	r9,r9,r10
8112d998:	3d14d83a 	srl	r10,r7,r20
8112d99c:	127fff15 	stw	r9,-4(r2)
8112d9a0:	1abfff15 	stw	r10,-4(r3)
8112d9a4:	137ff736 	bltu	r2,r13,8112d984 <__reset+0xfb10d984>
8112d9a8:	31402836 	bltu	r6,r5,8112da4c <__hexnan+0x18c>
8112d9ac:	42000044 	addi	r8,r8,1
8112d9b0:	40c00003 	ldbu	r3,0(r8)
8112d9b4:	01c00204 	movi	r7,8
8112d9b8:	183fe31e 	bne	r3,zero,8112d948 <__reset+0xfb10d948>
8112d9bc:	60002b26 	beq	r12,zero,8112da6c <__hexnan+0x1ac>
8112d9c0:	2b40022e 	bgeu	r5,r13,8112d9cc <__hexnan+0x10c>
8112d9c4:	008001c4 	movi	r2,7
8112d9c8:	11c0430e 	bge	r2,r7,8112dad8 <__hexnan+0x218>
8112d9cc:	3140312e 	bgeu	r6,r5,8112da94 <__hexnan+0x1d4>
8112d9d0:	3007883a 	mov	r3,r6
8112d9d4:	29000017 	ldw	r4,0(r5)
8112d9d8:	18800104 	addi	r2,r3,4
8112d9dc:	29400104 	addi	r5,r5,4
8112d9e0:	19000015 	stw	r4,0(r3)
8112d9e4:	1007883a 	mov	r3,r2
8112d9e8:	597ffa2e 	bgeu	r11,r5,8112d9d4 <__reset+0xfb10d9d4>
8112d9ec:	10000015 	stw	zero,0(r2)
8112d9f0:	10800104 	addi	r2,r2,4
8112d9f4:	58bffd2e 	bgeu	r11,r2,8112d9ec <__reset+0xfb10d9ec>
8112d9f8:	78bfff17 	ldw	r2,-4(r15)
8112d9fc:	1000041e 	bne	r2,zero,8112da10 <__hexnan+0x150>
8112da00:	32c02d26 	beq	r6,r11,8112dab8 <__hexnan+0x1f8>
8112da04:	5affff04 	addi	r11,r11,-4
8112da08:	58800017 	ldw	r2,0(r11)
8112da0c:	103ffc26 	beq	r2,zero,8112da00 <__reset+0xfb10da00>
8112da10:	00800144 	movi	r2,5
8112da14:	00001606 	br	8112da70 <__hexnan+0x1b0>
8112da18:	39c00044 	addi	r7,r7,1
8112da1c:	63000044 	addi	r12,r12,1
8112da20:	89c0040e 	bge	r17,r7,8112da34 <__hexnan+0x174>
8112da24:	317fc52e 	bgeu	r6,r5,8112d93c <__reset+0xfb10d93c>
8112da28:	283fff15 	stw	zero,-4(r5)
8112da2c:	01c00044 	movi	r7,1
8112da30:	297fff04 	addi	r5,r5,-4
8112da34:	28c00017 	ldw	r3,0(r5)
8112da38:	108003cc 	andi	r2,r2,15
8112da3c:	1806913a 	slli	r3,r3,4
8112da40:	1884b03a 	or	r2,r3,r2
8112da44:	28800015 	stw	r2,0(r5)
8112da48:	003fbc06 	br	8112d93c <__reset+0xfb10d93c>
8112da4c:	2b7fff04 	addi	r13,r5,-4
8112da50:	283fff15 	stw	zero,-4(r5)
8112da54:	603f883a 	mov	ra,r12
8112da58:	680b883a 	mov	r5,r13
8112da5c:	000f883a 	mov	r7,zero
8112da60:	003fb606 	br	8112d93c <__reset+0xfb10d93c>
8112da64:	00800a44 	movi	r2,41
8112da68:	18801726 	beq	r3,r2,8112dac8 <__hexnan+0x208>
8112da6c:	00800104 	movi	r2,4
8112da70:	dfc00617 	ldw	ra,24(sp)
8112da74:	dd400517 	ldw	r21,20(sp)
8112da78:	dd000417 	ldw	r20,16(sp)
8112da7c:	dcc00317 	ldw	r19,12(sp)
8112da80:	dc800217 	ldw	r18,8(sp)
8112da84:	dc400117 	ldw	r17,4(sp)
8112da88:	dc000017 	ldw	r16,0(sp)
8112da8c:	dec00704 	addi	sp,sp,28
8112da90:	f800283a 	ret
8112da94:	903fd826 	beq	r18,zero,8112d9f8 <__reset+0xfb10d9f8>
8112da98:	00c00804 	movi	r3,32
8112da9c:	1ca5c83a 	sub	r18,r3,r18
8112daa0:	00ffffc4 	movi	r3,-1
8112daa4:	78bfff17 	ldw	r2,-4(r15)
8112daa8:	1c86d83a 	srl	r3,r3,r18
8112daac:	1884703a 	and	r2,r3,r2
8112dab0:	78bfff15 	stw	r2,-4(r15)
8112dab4:	003fd106 	br	8112d9fc <__reset+0xfb10d9fc>
8112dab8:	00800044 	movi	r2,1
8112dabc:	58800015 	stw	r2,0(r11)
8112dac0:	00800144 	movi	r2,5
8112dac4:	003fea06 	br	8112da70 <__reset+0xfb10da70>
8112dac8:	42000044 	addi	r8,r8,1
8112dacc:	22000015 	stw	r8,0(r4)
8112dad0:	603fbb1e 	bne	r12,zero,8112d9c0 <__reset+0xfb10d9c0>
8112dad4:	003fe506 	br	8112da6c <__reset+0xfb10da6c>
8112dad8:	02400204 	movi	r9,8
8112dadc:	49d3c83a 	sub	r9,r9,r7
8112dae0:	4a53883a 	add	r9,r9,r9
8112dae4:	2a000017 	ldw	r8,0(r5)
8112dae8:	4a53883a 	add	r9,r9,r9
8112daec:	02800804 	movi	r10,32
8112daf0:	5255c83a 	sub	r10,r10,r9
8112daf4:	28c00104 	addi	r3,r5,4
8112daf8:	2805883a 	mov	r2,r5
8112dafc:	19c00017 	ldw	r7,0(r3)
8112db00:	10800104 	addi	r2,r2,4
8112db04:	18c00104 	addi	r3,r3,4
8112db08:	3a88983a 	sll	r4,r7,r10
8112db0c:	2208b03a 	or	r4,r4,r8
8112db10:	3a50d83a 	srl	r8,r7,r9
8112db14:	113fff15 	stw	r4,-4(r2)
8112db18:	1a3fff15 	stw	r8,-4(r3)
8112db1c:	137ff736 	bltu	r2,r13,8112dafc <__reset+0xfb10dafc>
8112db20:	003faa06 	br	8112d9cc <__reset+0xfb10d9cc>

8112db24 <strncmp>:
8112db24:	30003126 	beq	r6,zero,8112dbec <strncmp+0xc8>
8112db28:	2144b03a 	or	r2,r4,r5
8112db2c:	108000cc 	andi	r2,r2,3
8112db30:	10001e1e 	bne	r2,zero,8112dbac <strncmp+0x88>
8112db34:	024000c4 	movi	r9,3
8112db38:	49801c2e 	bgeu	r9,r6,8112dbac <strncmp+0x88>
8112db3c:	20800017 	ldw	r2,0(r4)
8112db40:	28c00017 	ldw	r3,0(r5)
8112db44:	10c0191e 	bne	r2,r3,8112dbac <strncmp+0x88>
8112db48:	31bfff04 	addi	r6,r6,-4
8112db4c:	30002726 	beq	r6,zero,8112dbec <strncmp+0xc8>
8112db50:	02ffbff4 	movhi	r11,65279
8112db54:	5affbfc4 	addi	r11,r11,-257
8112db58:	0086303a 	nor	r3,zero,r2
8112db5c:	02a02074 	movhi	r10,32897
8112db60:	12c5883a 	add	r2,r2,r11
8112db64:	52a02004 	addi	r10,r10,-32640
8112db68:	10c4703a 	and	r2,r2,r3
8112db6c:	1284703a 	and	r2,r2,r10
8112db70:	10000b26 	beq	r2,zero,8112dba0 <strncmp+0x7c>
8112db74:	00001d06 	br	8112dbec <strncmp+0xc8>
8112db78:	20c00017 	ldw	r3,0(r4)
8112db7c:	29c00017 	ldw	r7,0(r5)
8112db80:	1ad1883a 	add	r8,r3,r11
8112db84:	00c4303a 	nor	r2,zero,r3
8112db88:	4084703a 	and	r2,r8,r2
8112db8c:	1284703a 	and	r2,r2,r10
8112db90:	19c0061e 	bne	r3,r7,8112dbac <strncmp+0x88>
8112db94:	31bfff04 	addi	r6,r6,-4
8112db98:	30001426 	beq	r6,zero,8112dbec <strncmp+0xc8>
8112db9c:	1000131e 	bne	r2,zero,8112dbec <strncmp+0xc8>
8112dba0:	21000104 	addi	r4,r4,4
8112dba4:	29400104 	addi	r5,r5,4
8112dba8:	49bff336 	bltu	r9,r6,8112db78 <__reset+0xfb10db78>
8112dbac:	28800007 	ldb	r2,0(r5)
8112dbb0:	20c00007 	ldb	r3,0(r4)
8112dbb4:	31bfffc4 	addi	r6,r6,-1
8112dbb8:	10c0081e 	bne	r2,r3,8112dbdc <strncmp+0xb8>
8112dbbc:	30000b26 	beq	r6,zero,8112dbec <strncmp+0xc8>
8112dbc0:	10000a26 	beq	r2,zero,8112dbec <strncmp+0xc8>
8112dbc4:	21000044 	addi	r4,r4,1
8112dbc8:	29400044 	addi	r5,r5,1
8112dbcc:	20800007 	ldb	r2,0(r4)
8112dbd0:	28c00007 	ldb	r3,0(r5)
8112dbd4:	31bfffc4 	addi	r6,r6,-1
8112dbd8:	10fff826 	beq	r2,r3,8112dbbc <__reset+0xfb10dbbc>
8112dbdc:	20800003 	ldbu	r2,0(r4)
8112dbe0:	28c00003 	ldbu	r3,0(r5)
8112dbe4:	10c5c83a 	sub	r2,r2,r3
8112dbe8:	f800283a 	ret
8112dbec:	0005883a 	mov	r2,zero
8112dbf0:	f800283a 	ret

8112dbf4 <_wcrtomb_r>:
8112dbf4:	defff604 	addi	sp,sp,-40
8112dbf8:	00a04574 	movhi	r2,33045
8112dbfc:	de00012e 	bgeu	sp,et,8112dc04 <_wcrtomb_r+0x10>
8112dc00:	003b68fa 	trap	3
8112dc04:	10b35304 	addi	r2,r2,-12980
8112dc08:	dc800815 	stw	r18,32(sp)
8112dc0c:	dc400715 	stw	r17,28(sp)
8112dc10:	dc000615 	stw	r16,24(sp)
8112dc14:	dfc00915 	stw	ra,36(sp)
8112dc18:	2021883a 	mov	r16,r4
8112dc1c:	3823883a 	mov	r17,r7
8112dc20:	14800017 	ldw	r18,0(r2)
8112dc24:	28001426 	beq	r5,zero,8112dc78 <_wcrtomb_r+0x84>
8112dc28:	d9400415 	stw	r5,16(sp)
8112dc2c:	d9800515 	stw	r6,20(sp)
8112dc30:	11261240 	call	81126124 <__locale_charset>
8112dc34:	d9800517 	ldw	r6,20(sp)
8112dc38:	d9400417 	ldw	r5,16(sp)
8112dc3c:	100f883a 	mov	r7,r2
8112dc40:	dc400015 	stw	r17,0(sp)
8112dc44:	8009883a 	mov	r4,r16
8112dc48:	903ee83a 	callr	r18
8112dc4c:	00ffffc4 	movi	r3,-1
8112dc50:	10c0031e 	bne	r2,r3,8112dc60 <_wcrtomb_r+0x6c>
8112dc54:	88000015 	stw	zero,0(r17)
8112dc58:	00c02284 	movi	r3,138
8112dc5c:	80c00015 	stw	r3,0(r16)
8112dc60:	dfc00917 	ldw	ra,36(sp)
8112dc64:	dc800817 	ldw	r18,32(sp)
8112dc68:	dc400717 	ldw	r17,28(sp)
8112dc6c:	dc000617 	ldw	r16,24(sp)
8112dc70:	dec00a04 	addi	sp,sp,40
8112dc74:	f800283a 	ret
8112dc78:	11261240 	call	81126124 <__locale_charset>
8112dc7c:	100f883a 	mov	r7,r2
8112dc80:	dc400015 	stw	r17,0(sp)
8112dc84:	000d883a 	mov	r6,zero
8112dc88:	d9400104 	addi	r5,sp,4
8112dc8c:	8009883a 	mov	r4,r16
8112dc90:	903ee83a 	callr	r18
8112dc94:	003fed06 	br	8112dc4c <__reset+0xfb10dc4c>

8112dc98 <wcrtomb>:
8112dc98:	defff604 	addi	sp,sp,-40
8112dc9c:	00a04574 	movhi	r2,33045
8112dca0:	de00012e 	bgeu	sp,et,8112dca8 <wcrtomb+0x10>
8112dca4:	003b68fa 	trap	3
8112dca8:	10b34e04 	addi	r2,r2,-13000
8112dcac:	dc800615 	stw	r18,24(sp)
8112dcb0:	dc400515 	stw	r17,20(sp)
8112dcb4:	dfc00915 	stw	ra,36(sp)
8112dcb8:	dd000815 	stw	r20,32(sp)
8112dcbc:	dcc00715 	stw	r19,28(sp)
8112dcc0:	dc000415 	stw	r16,16(sp)
8112dcc4:	3025883a 	mov	r18,r6
8112dcc8:	14400017 	ldw	r17,0(r2)
8112dccc:	20001926 	beq	r4,zero,8112dd34 <wcrtomb+0x9c>
8112dcd0:	00a04574 	movhi	r2,33045
8112dcd4:	10b35304 	addi	r2,r2,-12980
8112dcd8:	15000017 	ldw	r20,0(r2)
8112dcdc:	2021883a 	mov	r16,r4
8112dce0:	2827883a 	mov	r19,r5
8112dce4:	11261240 	call	81126124 <__locale_charset>
8112dce8:	100f883a 	mov	r7,r2
8112dcec:	dc800015 	stw	r18,0(sp)
8112dcf0:	980d883a 	mov	r6,r19
8112dcf4:	800b883a 	mov	r5,r16
8112dcf8:	8809883a 	mov	r4,r17
8112dcfc:	a03ee83a 	callr	r20
8112dd00:	00ffffc4 	movi	r3,-1
8112dd04:	10c0031e 	bne	r2,r3,8112dd14 <wcrtomb+0x7c>
8112dd08:	90000015 	stw	zero,0(r18)
8112dd0c:	00c02284 	movi	r3,138
8112dd10:	88c00015 	stw	r3,0(r17)
8112dd14:	dfc00917 	ldw	ra,36(sp)
8112dd18:	dd000817 	ldw	r20,32(sp)
8112dd1c:	dcc00717 	ldw	r19,28(sp)
8112dd20:	dc800617 	ldw	r18,24(sp)
8112dd24:	dc400517 	ldw	r17,20(sp)
8112dd28:	dc000417 	ldw	r16,16(sp)
8112dd2c:	dec00a04 	addi	sp,sp,40
8112dd30:	f800283a 	ret
8112dd34:	00a04574 	movhi	r2,33045
8112dd38:	10b35304 	addi	r2,r2,-12980
8112dd3c:	14000017 	ldw	r16,0(r2)
8112dd40:	11261240 	call	81126124 <__locale_charset>
8112dd44:	100f883a 	mov	r7,r2
8112dd48:	dc800015 	stw	r18,0(sp)
8112dd4c:	000d883a 	mov	r6,zero
8112dd50:	d9400104 	addi	r5,sp,4
8112dd54:	8809883a 	mov	r4,r17
8112dd58:	803ee83a 	callr	r16
8112dd5c:	003fe806 	br	8112dd00 <__reset+0xfb10dd00>

8112dd60 <__ascii_wctomb>:
8112dd60:	28000526 	beq	r5,zero,8112dd78 <__ascii_wctomb+0x18>
8112dd64:	00803fc4 	movi	r2,255
8112dd68:	11800536 	bltu	r2,r6,8112dd80 <__ascii_wctomb+0x20>
8112dd6c:	29800005 	stb	r6,0(r5)
8112dd70:	00800044 	movi	r2,1
8112dd74:	f800283a 	ret
8112dd78:	0005883a 	mov	r2,zero
8112dd7c:	f800283a 	ret
8112dd80:	00802284 	movi	r2,138
8112dd84:	20800015 	stw	r2,0(r4)
8112dd88:	00bfffc4 	movi	r2,-1
8112dd8c:	f800283a 	ret

8112dd90 <_wctomb_r>:
8112dd90:	00a04574 	movhi	r2,33045
8112dd94:	defff904 	addi	sp,sp,-28
8112dd98:	10b35304 	addi	r2,r2,-12980
8112dd9c:	de00012e 	bgeu	sp,et,8112dda4 <_wctomb_r+0x14>
8112dda0:	003b68fa 	trap	3
8112dda4:	dfc00615 	stw	ra,24(sp)
8112dda8:	dc400515 	stw	r17,20(sp)
8112ddac:	dc000415 	stw	r16,16(sp)
8112ddb0:	3823883a 	mov	r17,r7
8112ddb4:	14000017 	ldw	r16,0(r2)
8112ddb8:	d9000115 	stw	r4,4(sp)
8112ddbc:	d9400215 	stw	r5,8(sp)
8112ddc0:	d9800315 	stw	r6,12(sp)
8112ddc4:	11261240 	call	81126124 <__locale_charset>
8112ddc8:	d9800317 	ldw	r6,12(sp)
8112ddcc:	d9400217 	ldw	r5,8(sp)
8112ddd0:	d9000117 	ldw	r4,4(sp)
8112ddd4:	100f883a 	mov	r7,r2
8112ddd8:	dc400015 	stw	r17,0(sp)
8112dddc:	803ee83a 	callr	r16
8112dde0:	dfc00617 	ldw	ra,24(sp)
8112dde4:	dc400517 	ldw	r17,20(sp)
8112dde8:	dc000417 	ldw	r16,16(sp)
8112ddec:	dec00704 	addi	sp,sp,28
8112ddf0:	f800283a 	ret

8112ddf4 <__fixunsdfsi>:
8112ddf4:	defffd04 	addi	sp,sp,-12
8112ddf8:	000d883a 	mov	r6,zero
8112ddfc:	01d07834 	movhi	r7,16864
8112de00:	de00012e 	bgeu	sp,et,8112de08 <__fixunsdfsi+0x14>
8112de04:	003b68fa 	trap	3
8112de08:	dc400115 	stw	r17,4(sp)
8112de0c:	dc000015 	stw	r16,0(sp)
8112de10:	dfc00215 	stw	ra,8(sp)
8112de14:	2023883a 	mov	r17,r4
8112de18:	2821883a 	mov	r16,r5
8112de1c:	112ff0c0 	call	8112ff0c <__gedf2>
8112de20:	1000080e 	bge	r2,zero,8112de44 <__fixunsdfsi+0x50>
8112de24:	8809883a 	mov	r4,r17
8112de28:	800b883a 	mov	r5,r16
8112de2c:	11309e00 	call	811309e0 <__fixdfsi>
8112de30:	dfc00217 	ldw	ra,8(sp)
8112de34:	dc400117 	ldw	r17,4(sp)
8112de38:	dc000017 	ldw	r16,0(sp)
8112de3c:	dec00304 	addi	sp,sp,12
8112de40:	f800283a 	ret
8112de44:	000d883a 	mov	r6,zero
8112de48:	01d07834 	movhi	r7,16864
8112de4c:	8809883a 	mov	r4,r17
8112de50:	800b883a 	mov	r5,r16
8112de54:	11300dc0 	call	811300dc <__subdf3>
8112de58:	180b883a 	mov	r5,r3
8112de5c:	1009883a 	mov	r4,r2
8112de60:	11309e00 	call	811309e0 <__fixdfsi>
8112de64:	00e00034 	movhi	r3,32768
8112de68:	10c5883a 	add	r2,r2,r3
8112de6c:	003ff006 	br	8112de30 <__reset+0xfb10de30>

8112de70 <__udivdi3>:
8112de70:	defff504 	addi	sp,sp,-44
8112de74:	de00012e 	bgeu	sp,et,8112de7c <__udivdi3+0xc>
8112de78:	003b68fa 	trap	3
8112de7c:	dcc00415 	stw	r19,16(sp)
8112de80:	dc000115 	stw	r16,4(sp)
8112de84:	dfc00a15 	stw	ra,40(sp)
8112de88:	df000915 	stw	fp,36(sp)
8112de8c:	ddc00815 	stw	r23,32(sp)
8112de90:	dd800715 	stw	r22,28(sp)
8112de94:	dd400615 	stw	r21,24(sp)
8112de98:	dd000515 	stw	r20,20(sp)
8112de9c:	dc800315 	stw	r18,12(sp)
8112dea0:	dc400215 	stw	r17,8(sp)
8112dea4:	2027883a 	mov	r19,r4
8112dea8:	2821883a 	mov	r16,r5
8112deac:	3800411e 	bne	r7,zero,8112dfb4 <__udivdi3+0x144>
8112deb0:	3023883a 	mov	r17,r6
8112deb4:	2025883a 	mov	r18,r4
8112deb8:	2980522e 	bgeu	r5,r6,8112e004 <__udivdi3+0x194>
8112debc:	00bfffd4 	movui	r2,65535
8112dec0:	282d883a 	mov	r22,r5
8112dec4:	1180a836 	bltu	r2,r6,8112e168 <__udivdi3+0x2f8>
8112dec8:	00803fc4 	movi	r2,255
8112decc:	1185803a 	cmpltu	r2,r2,r6
8112ded0:	100490fa 	slli	r2,r2,3
8112ded4:	3086d83a 	srl	r3,r6,r2
8112ded8:	01204574 	movhi	r4,33045
8112dedc:	21289304 	addi	r4,r4,-23988
8112dee0:	20c7883a 	add	r3,r4,r3
8112dee4:	18c00003 	ldbu	r3,0(r3)
8112dee8:	1885883a 	add	r2,r3,r2
8112deec:	00c00804 	movi	r3,32
8112def0:	1887c83a 	sub	r3,r3,r2
8112def4:	18000526 	beq	r3,zero,8112df0c <__udivdi3+0x9c>
8112def8:	80e0983a 	sll	r16,r16,r3
8112defc:	9884d83a 	srl	r2,r19,r2
8112df00:	30e2983a 	sll	r17,r6,r3
8112df04:	98e4983a 	sll	r18,r19,r3
8112df08:	142cb03a 	or	r22,r2,r16
8112df0c:	882ad43a 	srli	r21,r17,16
8112df10:	b009883a 	mov	r4,r22
8112df14:	8d3fffcc 	andi	r20,r17,65535
8112df18:	a80b883a 	mov	r5,r21
8112df1c:	112ea8c0 	call	8112ea8c <__umodsi3>
8112df20:	b009883a 	mov	r4,r22
8112df24:	a80b883a 	mov	r5,r21
8112df28:	1027883a 	mov	r19,r2
8112df2c:	112ea280 	call	8112ea28 <__udivsi3>
8112df30:	102d883a 	mov	r22,r2
8112df34:	9826943a 	slli	r19,r19,16
8112df38:	9004d43a 	srli	r2,r18,16
8112df3c:	a5a1383a 	mul	r16,r20,r22
8112df40:	14c4b03a 	or	r2,r2,r19
8112df44:	1400052e 	bgeu	r2,r16,8112df5c <__udivdi3+0xec>
8112df48:	1445883a 	add	r2,r2,r17
8112df4c:	b0ffffc4 	addi	r3,r22,-1
8112df50:	14400136 	bltu	r2,r17,8112df58 <__udivdi3+0xe8>
8112df54:	14012336 	bltu	r2,r16,8112e3e4 <__udivdi3+0x574>
8112df58:	182d883a 	mov	r22,r3
8112df5c:	1421c83a 	sub	r16,r2,r16
8112df60:	a80b883a 	mov	r5,r21
8112df64:	8009883a 	mov	r4,r16
8112df68:	112ea8c0 	call	8112ea8c <__umodsi3>
8112df6c:	1027883a 	mov	r19,r2
8112df70:	a80b883a 	mov	r5,r21
8112df74:	8009883a 	mov	r4,r16
8112df78:	112ea280 	call	8112ea28 <__udivsi3>
8112df7c:	9826943a 	slli	r19,r19,16
8112df80:	a0a9383a 	mul	r20,r20,r2
8112df84:	94bfffcc 	andi	r18,r18,65535
8112df88:	94e4b03a 	or	r18,r18,r19
8112df8c:	9500052e 	bgeu	r18,r20,8112dfa4 <__udivdi3+0x134>
8112df90:	8ca5883a 	add	r18,r17,r18
8112df94:	10ffffc4 	addi	r3,r2,-1
8112df98:	9440f136 	bltu	r18,r17,8112e360 <__udivdi3+0x4f0>
8112df9c:	9500f02e 	bgeu	r18,r20,8112e360 <__udivdi3+0x4f0>
8112dfa0:	10bfff84 	addi	r2,r2,-2
8112dfa4:	b00c943a 	slli	r6,r22,16
8112dfa8:	0007883a 	mov	r3,zero
8112dfac:	3084b03a 	or	r2,r6,r2
8112dfb0:	00005906 	br	8112e118 <__udivdi3+0x2a8>
8112dfb4:	29c05636 	bltu	r5,r7,8112e110 <__udivdi3+0x2a0>
8112dfb8:	00bfffd4 	movui	r2,65535
8112dfbc:	11c0622e 	bgeu	r2,r7,8112e148 <__udivdi3+0x2d8>
8112dfc0:	00804034 	movhi	r2,256
8112dfc4:	10bfffc4 	addi	r2,r2,-1
8112dfc8:	11c0ee36 	bltu	r2,r7,8112e384 <__udivdi3+0x514>
8112dfcc:	00800404 	movi	r2,16
8112dfd0:	3886d83a 	srl	r3,r7,r2
8112dfd4:	01204574 	movhi	r4,33045
8112dfd8:	21289304 	addi	r4,r4,-23988
8112dfdc:	20c7883a 	add	r3,r4,r3
8112dfe0:	18c00003 	ldbu	r3,0(r3)
8112dfe4:	05400804 	movi	r21,32
8112dfe8:	1885883a 	add	r2,r3,r2
8112dfec:	a8abc83a 	sub	r21,r21,r2
8112dff0:	a800621e 	bne	r21,zero,8112e17c <__udivdi3+0x30c>
8112dff4:	3c00e936 	bltu	r7,r16,8112e39c <__udivdi3+0x52c>
8112dff8:	9985403a 	cmpgeu	r2,r19,r6
8112dffc:	0007883a 	mov	r3,zero
8112e000:	00004506 	br	8112e118 <__udivdi3+0x2a8>
8112e004:	3000041e 	bne	r6,zero,8112e018 <__udivdi3+0x1a8>
8112e008:	000b883a 	mov	r5,zero
8112e00c:	01000044 	movi	r4,1
8112e010:	112ea280 	call	8112ea28 <__udivsi3>
8112e014:	1023883a 	mov	r17,r2
8112e018:	00bfffd4 	movui	r2,65535
8112e01c:	14404e2e 	bgeu	r2,r17,8112e158 <__udivdi3+0x2e8>
8112e020:	00804034 	movhi	r2,256
8112e024:	10bfffc4 	addi	r2,r2,-1
8112e028:	1440d836 	bltu	r2,r17,8112e38c <__udivdi3+0x51c>
8112e02c:	00800404 	movi	r2,16
8112e030:	8886d83a 	srl	r3,r17,r2
8112e034:	01204574 	movhi	r4,33045
8112e038:	21289304 	addi	r4,r4,-23988
8112e03c:	20c7883a 	add	r3,r4,r3
8112e040:	18c00003 	ldbu	r3,0(r3)
8112e044:	1885883a 	add	r2,r3,r2
8112e048:	00c00804 	movi	r3,32
8112e04c:	1887c83a 	sub	r3,r3,r2
8112e050:	18008f1e 	bne	r3,zero,8112e290 <__udivdi3+0x420>
8112e054:	882ad43a 	srli	r21,r17,16
8112e058:	8461c83a 	sub	r16,r16,r17
8112e05c:	8d3fffcc 	andi	r20,r17,65535
8112e060:	00c00044 	movi	r3,1
8112e064:	8009883a 	mov	r4,r16
8112e068:	a80b883a 	mov	r5,r21
8112e06c:	d8c00015 	stw	r3,0(sp)
8112e070:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e074:	8009883a 	mov	r4,r16
8112e078:	a80b883a 	mov	r5,r21
8112e07c:	1027883a 	mov	r19,r2
8112e080:	112ea280 	call	8112ea28 <__udivsi3>
8112e084:	9826943a 	slli	r19,r19,16
8112e088:	9008d43a 	srli	r4,r18,16
8112e08c:	1521383a 	mul	r16,r2,r20
8112e090:	102d883a 	mov	r22,r2
8112e094:	24c8b03a 	or	r4,r4,r19
8112e098:	d8c00017 	ldw	r3,0(sp)
8112e09c:	2400052e 	bgeu	r4,r16,8112e0b4 <__udivdi3+0x244>
8112e0a0:	2449883a 	add	r4,r4,r17
8112e0a4:	b0bfffc4 	addi	r2,r22,-1
8112e0a8:	24400136 	bltu	r4,r17,8112e0b0 <__udivdi3+0x240>
8112e0ac:	2400ca36 	bltu	r4,r16,8112e3d8 <__udivdi3+0x568>
8112e0b0:	102d883a 	mov	r22,r2
8112e0b4:	2421c83a 	sub	r16,r4,r16
8112e0b8:	a80b883a 	mov	r5,r21
8112e0bc:	8009883a 	mov	r4,r16
8112e0c0:	d8c00015 	stw	r3,0(sp)
8112e0c4:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e0c8:	1027883a 	mov	r19,r2
8112e0cc:	a80b883a 	mov	r5,r21
8112e0d0:	8009883a 	mov	r4,r16
8112e0d4:	112ea280 	call	8112ea28 <__udivsi3>
8112e0d8:	9826943a 	slli	r19,r19,16
8112e0dc:	1529383a 	mul	r20,r2,r20
8112e0e0:	94bfffcc 	andi	r18,r18,65535
8112e0e4:	94e4b03a 	or	r18,r18,r19
8112e0e8:	d8c00017 	ldw	r3,0(sp)
8112e0ec:	9500052e 	bgeu	r18,r20,8112e104 <__udivdi3+0x294>
8112e0f0:	8ca5883a 	add	r18,r17,r18
8112e0f4:	113fffc4 	addi	r4,r2,-1
8112e0f8:	94409736 	bltu	r18,r17,8112e358 <__udivdi3+0x4e8>
8112e0fc:	9500962e 	bgeu	r18,r20,8112e358 <__udivdi3+0x4e8>
8112e100:	10bfff84 	addi	r2,r2,-2
8112e104:	b00c943a 	slli	r6,r22,16
8112e108:	3084b03a 	or	r2,r6,r2
8112e10c:	00000206 	br	8112e118 <__udivdi3+0x2a8>
8112e110:	0007883a 	mov	r3,zero
8112e114:	0005883a 	mov	r2,zero
8112e118:	dfc00a17 	ldw	ra,40(sp)
8112e11c:	df000917 	ldw	fp,36(sp)
8112e120:	ddc00817 	ldw	r23,32(sp)
8112e124:	dd800717 	ldw	r22,28(sp)
8112e128:	dd400617 	ldw	r21,24(sp)
8112e12c:	dd000517 	ldw	r20,20(sp)
8112e130:	dcc00417 	ldw	r19,16(sp)
8112e134:	dc800317 	ldw	r18,12(sp)
8112e138:	dc400217 	ldw	r17,8(sp)
8112e13c:	dc000117 	ldw	r16,4(sp)
8112e140:	dec00b04 	addi	sp,sp,44
8112e144:	f800283a 	ret
8112e148:	00803fc4 	movi	r2,255
8112e14c:	11c5803a 	cmpltu	r2,r2,r7
8112e150:	100490fa 	slli	r2,r2,3
8112e154:	003f9e06 	br	8112dfd0 <__reset+0xfb10dfd0>
8112e158:	00803fc4 	movi	r2,255
8112e15c:	1445803a 	cmpltu	r2,r2,r17
8112e160:	100490fa 	slli	r2,r2,3
8112e164:	003fb206 	br	8112e030 <__reset+0xfb10e030>
8112e168:	00804034 	movhi	r2,256
8112e16c:	10bfffc4 	addi	r2,r2,-1
8112e170:	11808836 	bltu	r2,r6,8112e394 <__udivdi3+0x524>
8112e174:	00800404 	movi	r2,16
8112e178:	003f5606 	br	8112ded4 <__reset+0xfb10ded4>
8112e17c:	30aed83a 	srl	r23,r6,r2
8112e180:	3d4e983a 	sll	r7,r7,r21
8112e184:	80acd83a 	srl	r22,r16,r2
8112e188:	9884d83a 	srl	r2,r19,r2
8112e18c:	3deeb03a 	or	r23,r7,r23
8112e190:	b824d43a 	srli	r18,r23,16
8112e194:	8560983a 	sll	r16,r16,r21
8112e198:	b009883a 	mov	r4,r22
8112e19c:	900b883a 	mov	r5,r18
8112e1a0:	3568983a 	sll	r20,r6,r21
8112e1a4:	1420b03a 	or	r16,r2,r16
8112e1a8:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e1ac:	b009883a 	mov	r4,r22
8112e1b0:	900b883a 	mov	r5,r18
8112e1b4:	1023883a 	mov	r17,r2
8112e1b8:	112ea280 	call	8112ea28 <__udivsi3>
8112e1bc:	8808943a 	slli	r4,r17,16
8112e1c0:	bf3fffcc 	andi	fp,r23,65535
8112e1c4:	8006d43a 	srli	r3,r16,16
8112e1c8:	e0a3383a 	mul	r17,fp,r2
8112e1cc:	100d883a 	mov	r6,r2
8112e1d0:	1906b03a 	or	r3,r3,r4
8112e1d4:	1c40042e 	bgeu	r3,r17,8112e1e8 <__udivdi3+0x378>
8112e1d8:	1dc7883a 	add	r3,r3,r23
8112e1dc:	10bfffc4 	addi	r2,r2,-1
8112e1e0:	1dc0752e 	bgeu	r3,r23,8112e3b8 <__udivdi3+0x548>
8112e1e4:	100d883a 	mov	r6,r2
8112e1e8:	1c63c83a 	sub	r17,r3,r17
8112e1ec:	900b883a 	mov	r5,r18
8112e1f0:	8809883a 	mov	r4,r17
8112e1f4:	d9800015 	stw	r6,0(sp)
8112e1f8:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e1fc:	102d883a 	mov	r22,r2
8112e200:	8809883a 	mov	r4,r17
8112e204:	900b883a 	mov	r5,r18
8112e208:	112ea280 	call	8112ea28 <__udivsi3>
8112e20c:	b02c943a 	slli	r22,r22,16
8112e210:	e089383a 	mul	r4,fp,r2
8112e214:	843fffcc 	andi	r16,r16,65535
8112e218:	85a0b03a 	or	r16,r16,r22
8112e21c:	d9800017 	ldw	r6,0(sp)
8112e220:	8100042e 	bgeu	r16,r4,8112e234 <__udivdi3+0x3c4>
8112e224:	85e1883a 	add	r16,r16,r23
8112e228:	10ffffc4 	addi	r3,r2,-1
8112e22c:	85c05e2e 	bgeu	r16,r23,8112e3a8 <__udivdi3+0x538>
8112e230:	1805883a 	mov	r2,r3
8112e234:	300c943a 	slli	r6,r6,16
8112e238:	a17fffcc 	andi	r5,r20,65535
8112e23c:	a028d43a 	srli	r20,r20,16
8112e240:	3084b03a 	or	r2,r6,r2
8112e244:	10ffffcc 	andi	r3,r2,65535
8112e248:	100cd43a 	srli	r6,r2,16
8112e24c:	194f383a 	mul	r7,r3,r5
8112e250:	1d07383a 	mul	r3,r3,r20
8112e254:	314b383a 	mul	r5,r6,r5
8112e258:	3810d43a 	srli	r8,r7,16
8112e25c:	8121c83a 	sub	r16,r16,r4
8112e260:	1947883a 	add	r3,r3,r5
8112e264:	40c7883a 	add	r3,r8,r3
8112e268:	350d383a 	mul	r6,r6,r20
8112e26c:	1940022e 	bgeu	r3,r5,8112e278 <__udivdi3+0x408>
8112e270:	01000074 	movhi	r4,1
8112e274:	310d883a 	add	r6,r6,r4
8112e278:	1828d43a 	srli	r20,r3,16
8112e27c:	a18d883a 	add	r6,r20,r6
8112e280:	81803e36 	bltu	r16,r6,8112e37c <__udivdi3+0x50c>
8112e284:	81803826 	beq	r16,r6,8112e368 <__udivdi3+0x4f8>
8112e288:	0007883a 	mov	r3,zero
8112e28c:	003fa206 	br	8112e118 <__reset+0xfb10e118>
8112e290:	88e2983a 	sll	r17,r17,r3
8112e294:	80a8d83a 	srl	r20,r16,r2
8112e298:	80e0983a 	sll	r16,r16,r3
8112e29c:	882ad43a 	srli	r21,r17,16
8112e2a0:	9884d83a 	srl	r2,r19,r2
8112e2a4:	a009883a 	mov	r4,r20
8112e2a8:	a80b883a 	mov	r5,r21
8112e2ac:	142eb03a 	or	r23,r2,r16
8112e2b0:	98e4983a 	sll	r18,r19,r3
8112e2b4:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e2b8:	a009883a 	mov	r4,r20
8112e2bc:	a80b883a 	mov	r5,r21
8112e2c0:	1021883a 	mov	r16,r2
8112e2c4:	112ea280 	call	8112ea28 <__udivsi3>
8112e2c8:	1039883a 	mov	fp,r2
8112e2cc:	8d3fffcc 	andi	r20,r17,65535
8112e2d0:	8020943a 	slli	r16,r16,16
8112e2d4:	b804d43a 	srli	r2,r23,16
8112e2d8:	a72d383a 	mul	r22,r20,fp
8112e2dc:	1404b03a 	or	r2,r2,r16
8112e2e0:	1580062e 	bgeu	r2,r22,8112e2fc <__udivdi3+0x48c>
8112e2e4:	1445883a 	add	r2,r2,r17
8112e2e8:	e0ffffc4 	addi	r3,fp,-1
8112e2ec:	14403836 	bltu	r2,r17,8112e3d0 <__udivdi3+0x560>
8112e2f0:	1580372e 	bgeu	r2,r22,8112e3d0 <__udivdi3+0x560>
8112e2f4:	e73fff84 	addi	fp,fp,-2
8112e2f8:	1445883a 	add	r2,r2,r17
8112e2fc:	15adc83a 	sub	r22,r2,r22
8112e300:	a80b883a 	mov	r5,r21
8112e304:	b009883a 	mov	r4,r22
8112e308:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e30c:	1027883a 	mov	r19,r2
8112e310:	b009883a 	mov	r4,r22
8112e314:	a80b883a 	mov	r5,r21
8112e318:	112ea280 	call	8112ea28 <__udivsi3>
8112e31c:	9826943a 	slli	r19,r19,16
8112e320:	a0a1383a 	mul	r16,r20,r2
8112e324:	b93fffcc 	andi	r4,r23,65535
8112e328:	24c8b03a 	or	r4,r4,r19
8112e32c:	2400062e 	bgeu	r4,r16,8112e348 <__udivdi3+0x4d8>
8112e330:	2449883a 	add	r4,r4,r17
8112e334:	10ffffc4 	addi	r3,r2,-1
8112e338:	24402336 	bltu	r4,r17,8112e3c8 <__udivdi3+0x558>
8112e33c:	2400222e 	bgeu	r4,r16,8112e3c8 <__udivdi3+0x558>
8112e340:	10bfff84 	addi	r2,r2,-2
8112e344:	2449883a 	add	r4,r4,r17
8112e348:	e038943a 	slli	fp,fp,16
8112e34c:	2421c83a 	sub	r16,r4,r16
8112e350:	e086b03a 	or	r3,fp,r2
8112e354:	003f4306 	br	8112e064 <__reset+0xfb10e064>
8112e358:	2005883a 	mov	r2,r4
8112e35c:	003f6906 	br	8112e104 <__reset+0xfb10e104>
8112e360:	1805883a 	mov	r2,r3
8112e364:	003f0f06 	br	8112dfa4 <__reset+0xfb10dfa4>
8112e368:	1806943a 	slli	r3,r3,16
8112e36c:	9d66983a 	sll	r19,r19,r21
8112e370:	39ffffcc 	andi	r7,r7,65535
8112e374:	19c7883a 	add	r3,r3,r7
8112e378:	98ffc32e 	bgeu	r19,r3,8112e288 <__reset+0xfb10e288>
8112e37c:	10bfffc4 	addi	r2,r2,-1
8112e380:	003fc106 	br	8112e288 <__reset+0xfb10e288>
8112e384:	00800604 	movi	r2,24
8112e388:	003f1106 	br	8112dfd0 <__reset+0xfb10dfd0>
8112e38c:	00800604 	movi	r2,24
8112e390:	003f2706 	br	8112e030 <__reset+0xfb10e030>
8112e394:	00800604 	movi	r2,24
8112e398:	003ece06 	br	8112ded4 <__reset+0xfb10ded4>
8112e39c:	0007883a 	mov	r3,zero
8112e3a0:	00800044 	movi	r2,1
8112e3a4:	003f5c06 	br	8112e118 <__reset+0xfb10e118>
8112e3a8:	813fa12e 	bgeu	r16,r4,8112e230 <__reset+0xfb10e230>
8112e3ac:	10bfff84 	addi	r2,r2,-2
8112e3b0:	85e1883a 	add	r16,r16,r23
8112e3b4:	003f9f06 	br	8112e234 <__reset+0xfb10e234>
8112e3b8:	1c7f8a2e 	bgeu	r3,r17,8112e1e4 <__reset+0xfb10e1e4>
8112e3bc:	31bfff84 	addi	r6,r6,-2
8112e3c0:	1dc7883a 	add	r3,r3,r23
8112e3c4:	003f8806 	br	8112e1e8 <__reset+0xfb10e1e8>
8112e3c8:	1805883a 	mov	r2,r3
8112e3cc:	003fde06 	br	8112e348 <__reset+0xfb10e348>
8112e3d0:	1839883a 	mov	fp,r3
8112e3d4:	003fc906 	br	8112e2fc <__reset+0xfb10e2fc>
8112e3d8:	b5bfff84 	addi	r22,r22,-2
8112e3dc:	2449883a 	add	r4,r4,r17
8112e3e0:	003f3406 	br	8112e0b4 <__reset+0xfb10e0b4>
8112e3e4:	b5bfff84 	addi	r22,r22,-2
8112e3e8:	1445883a 	add	r2,r2,r17
8112e3ec:	003edb06 	br	8112df5c <__reset+0xfb10df5c>

8112e3f0 <__umoddi3>:
8112e3f0:	defff404 	addi	sp,sp,-48
8112e3f4:	de00012e 	bgeu	sp,et,8112e3fc <__umoddi3+0xc>
8112e3f8:	003b68fa 	trap	3
8112e3fc:	df000a15 	stw	fp,40(sp)
8112e400:	dc400315 	stw	r17,12(sp)
8112e404:	dc000215 	stw	r16,8(sp)
8112e408:	dfc00b15 	stw	ra,44(sp)
8112e40c:	ddc00915 	stw	r23,36(sp)
8112e410:	dd800815 	stw	r22,32(sp)
8112e414:	dd400715 	stw	r21,28(sp)
8112e418:	dd000615 	stw	r20,24(sp)
8112e41c:	dcc00515 	stw	r19,20(sp)
8112e420:	dc800415 	stw	r18,16(sp)
8112e424:	2021883a 	mov	r16,r4
8112e428:	2823883a 	mov	r17,r5
8112e42c:	2839883a 	mov	fp,r5
8112e430:	38003c1e 	bne	r7,zero,8112e524 <__umoddi3+0x134>
8112e434:	3027883a 	mov	r19,r6
8112e438:	2029883a 	mov	r20,r4
8112e43c:	2980512e 	bgeu	r5,r6,8112e584 <__umoddi3+0x194>
8112e440:	00bfffd4 	movui	r2,65535
8112e444:	11809a36 	bltu	r2,r6,8112e6b0 <__umoddi3+0x2c0>
8112e448:	01003fc4 	movi	r4,255
8112e44c:	2189803a 	cmpltu	r4,r4,r6
8112e450:	200890fa 	slli	r4,r4,3
8112e454:	3104d83a 	srl	r2,r6,r4
8112e458:	00e04574 	movhi	r3,33045
8112e45c:	18e89304 	addi	r3,r3,-23988
8112e460:	1885883a 	add	r2,r3,r2
8112e464:	10c00003 	ldbu	r3,0(r2)
8112e468:	00800804 	movi	r2,32
8112e46c:	1909883a 	add	r4,r3,r4
8112e470:	1125c83a 	sub	r18,r2,r4
8112e474:	90000526 	beq	r18,zero,8112e48c <__umoddi3+0x9c>
8112e478:	8ca2983a 	sll	r17,r17,r18
8112e47c:	8108d83a 	srl	r4,r16,r4
8112e480:	34a6983a 	sll	r19,r6,r18
8112e484:	84a8983a 	sll	r20,r16,r18
8112e488:	2478b03a 	or	fp,r4,r17
8112e48c:	982ed43a 	srli	r23,r19,16
8112e490:	e009883a 	mov	r4,fp
8112e494:	9dbfffcc 	andi	r22,r19,65535
8112e498:	b80b883a 	mov	r5,r23
8112e49c:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e4a0:	e009883a 	mov	r4,fp
8112e4a4:	b80b883a 	mov	r5,r23
8112e4a8:	102b883a 	mov	r21,r2
8112e4ac:	112ea280 	call	8112ea28 <__udivsi3>
8112e4b0:	a806943a 	slli	r3,r21,16
8112e4b4:	a008d43a 	srli	r4,r20,16
8112e4b8:	b085383a 	mul	r2,r22,r2
8112e4bc:	20c8b03a 	or	r4,r4,r3
8112e4c0:	2080032e 	bgeu	r4,r2,8112e4d0 <__umoddi3+0xe0>
8112e4c4:	24c9883a 	add	r4,r4,r19
8112e4c8:	24c00136 	bltu	r4,r19,8112e4d0 <__umoddi3+0xe0>
8112e4cc:	20811036 	bltu	r4,r2,8112e910 <__umoddi3+0x520>
8112e4d0:	20abc83a 	sub	r21,r4,r2
8112e4d4:	b80b883a 	mov	r5,r23
8112e4d8:	a809883a 	mov	r4,r21
8112e4dc:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e4e0:	1023883a 	mov	r17,r2
8112e4e4:	b80b883a 	mov	r5,r23
8112e4e8:	a809883a 	mov	r4,r21
8112e4ec:	112ea280 	call	8112ea28 <__udivsi3>
8112e4f0:	8822943a 	slli	r17,r17,16
8112e4f4:	b085383a 	mul	r2,r22,r2
8112e4f8:	a0ffffcc 	andi	r3,r20,65535
8112e4fc:	1c46b03a 	or	r3,r3,r17
8112e500:	1880042e 	bgeu	r3,r2,8112e514 <__umoddi3+0x124>
8112e504:	1cc7883a 	add	r3,r3,r19
8112e508:	1cc00236 	bltu	r3,r19,8112e514 <__umoddi3+0x124>
8112e50c:	1880012e 	bgeu	r3,r2,8112e514 <__umoddi3+0x124>
8112e510:	1cc7883a 	add	r3,r3,r19
8112e514:	1885c83a 	sub	r2,r3,r2
8112e518:	1484d83a 	srl	r2,r2,r18
8112e51c:	0007883a 	mov	r3,zero
8112e520:	00004f06 	br	8112e660 <__umoddi3+0x270>
8112e524:	29c04c36 	bltu	r5,r7,8112e658 <__umoddi3+0x268>
8112e528:	00bfffd4 	movui	r2,65535
8112e52c:	11c0582e 	bgeu	r2,r7,8112e690 <__umoddi3+0x2a0>
8112e530:	00804034 	movhi	r2,256
8112e534:	10bfffc4 	addi	r2,r2,-1
8112e538:	11c0e736 	bltu	r2,r7,8112e8d8 <__umoddi3+0x4e8>
8112e53c:	01000404 	movi	r4,16
8112e540:	3904d83a 	srl	r2,r7,r4
8112e544:	00e04574 	movhi	r3,33045
8112e548:	18e89304 	addi	r3,r3,-23988
8112e54c:	1885883a 	add	r2,r3,r2
8112e550:	14c00003 	ldbu	r19,0(r2)
8112e554:	00c00804 	movi	r3,32
8112e558:	9927883a 	add	r19,r19,r4
8112e55c:	1ce9c83a 	sub	r20,r3,r19
8112e560:	a000581e 	bne	r20,zero,8112e6c4 <__umoddi3+0x2d4>
8112e564:	3c400136 	bltu	r7,r17,8112e56c <__umoddi3+0x17c>
8112e568:	8180eb36 	bltu	r16,r6,8112e918 <__umoddi3+0x528>
8112e56c:	8185c83a 	sub	r2,r16,r6
8112e570:	89e3c83a 	sub	r17,r17,r7
8112e574:	8089803a 	cmpltu	r4,r16,r2
8112e578:	8939c83a 	sub	fp,r17,r4
8112e57c:	e007883a 	mov	r3,fp
8112e580:	00003706 	br	8112e660 <__umoddi3+0x270>
8112e584:	3000041e 	bne	r6,zero,8112e598 <__umoddi3+0x1a8>
8112e588:	000b883a 	mov	r5,zero
8112e58c:	01000044 	movi	r4,1
8112e590:	112ea280 	call	8112ea28 <__udivsi3>
8112e594:	1027883a 	mov	r19,r2
8112e598:	00bfffd4 	movui	r2,65535
8112e59c:	14c0402e 	bgeu	r2,r19,8112e6a0 <__umoddi3+0x2b0>
8112e5a0:	00804034 	movhi	r2,256
8112e5a4:	10bfffc4 	addi	r2,r2,-1
8112e5a8:	14c0cd36 	bltu	r2,r19,8112e8e0 <__umoddi3+0x4f0>
8112e5ac:	00800404 	movi	r2,16
8112e5b0:	9886d83a 	srl	r3,r19,r2
8112e5b4:	01204574 	movhi	r4,33045
8112e5b8:	21289304 	addi	r4,r4,-23988
8112e5bc:	20c7883a 	add	r3,r4,r3
8112e5c0:	18c00003 	ldbu	r3,0(r3)
8112e5c4:	1887883a 	add	r3,r3,r2
8112e5c8:	00800804 	movi	r2,32
8112e5cc:	10e5c83a 	sub	r18,r2,r3
8112e5d0:	9000901e 	bne	r18,zero,8112e814 <__umoddi3+0x424>
8112e5d4:	982cd43a 	srli	r22,r19,16
8112e5d8:	8ce3c83a 	sub	r17,r17,r19
8112e5dc:	9d7fffcc 	andi	r21,r19,65535
8112e5e0:	b00b883a 	mov	r5,r22
8112e5e4:	8809883a 	mov	r4,r17
8112e5e8:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e5ec:	8809883a 	mov	r4,r17
8112e5f0:	b00b883a 	mov	r5,r22
8112e5f4:	1021883a 	mov	r16,r2
8112e5f8:	112ea280 	call	8112ea28 <__udivsi3>
8112e5fc:	8006943a 	slli	r3,r16,16
8112e600:	a008d43a 	srli	r4,r20,16
8112e604:	1545383a 	mul	r2,r2,r21
8112e608:	20c8b03a 	or	r4,r4,r3
8112e60c:	2080042e 	bgeu	r4,r2,8112e620 <__umoddi3+0x230>
8112e610:	24c9883a 	add	r4,r4,r19
8112e614:	24c00236 	bltu	r4,r19,8112e620 <__umoddi3+0x230>
8112e618:	2080012e 	bgeu	r4,r2,8112e620 <__umoddi3+0x230>
8112e61c:	24c9883a 	add	r4,r4,r19
8112e620:	20a1c83a 	sub	r16,r4,r2
8112e624:	b00b883a 	mov	r5,r22
8112e628:	8009883a 	mov	r4,r16
8112e62c:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e630:	1023883a 	mov	r17,r2
8112e634:	b00b883a 	mov	r5,r22
8112e638:	8009883a 	mov	r4,r16
8112e63c:	112ea280 	call	8112ea28 <__udivsi3>
8112e640:	8822943a 	slli	r17,r17,16
8112e644:	1545383a 	mul	r2,r2,r21
8112e648:	a53fffcc 	andi	r20,r20,65535
8112e64c:	a446b03a 	or	r3,r20,r17
8112e650:	18bfb02e 	bgeu	r3,r2,8112e514 <__reset+0xfb10e514>
8112e654:	003fab06 	br	8112e504 <__reset+0xfb10e504>
8112e658:	2005883a 	mov	r2,r4
8112e65c:	2807883a 	mov	r3,r5
8112e660:	dfc00b17 	ldw	ra,44(sp)
8112e664:	df000a17 	ldw	fp,40(sp)
8112e668:	ddc00917 	ldw	r23,36(sp)
8112e66c:	dd800817 	ldw	r22,32(sp)
8112e670:	dd400717 	ldw	r21,28(sp)
8112e674:	dd000617 	ldw	r20,24(sp)
8112e678:	dcc00517 	ldw	r19,20(sp)
8112e67c:	dc800417 	ldw	r18,16(sp)
8112e680:	dc400317 	ldw	r17,12(sp)
8112e684:	dc000217 	ldw	r16,8(sp)
8112e688:	dec00c04 	addi	sp,sp,48
8112e68c:	f800283a 	ret
8112e690:	04c03fc4 	movi	r19,255
8112e694:	99c9803a 	cmpltu	r4,r19,r7
8112e698:	200890fa 	slli	r4,r4,3
8112e69c:	003fa806 	br	8112e540 <__reset+0xfb10e540>
8112e6a0:	00803fc4 	movi	r2,255
8112e6a4:	14c5803a 	cmpltu	r2,r2,r19
8112e6a8:	100490fa 	slli	r2,r2,3
8112e6ac:	003fc006 	br	8112e5b0 <__reset+0xfb10e5b0>
8112e6b0:	00804034 	movhi	r2,256
8112e6b4:	10bfffc4 	addi	r2,r2,-1
8112e6b8:	11808b36 	bltu	r2,r6,8112e8e8 <__umoddi3+0x4f8>
8112e6bc:	01000404 	movi	r4,16
8112e6c0:	003f6406 	br	8112e454 <__reset+0xfb10e454>
8112e6c4:	34c4d83a 	srl	r2,r6,r19
8112e6c8:	3d0e983a 	sll	r7,r7,r20
8112e6cc:	8cf8d83a 	srl	fp,r17,r19
8112e6d0:	8d10983a 	sll	r8,r17,r20
8112e6d4:	38aab03a 	or	r21,r7,r2
8112e6d8:	a82cd43a 	srli	r22,r21,16
8112e6dc:	84e2d83a 	srl	r17,r16,r19
8112e6e0:	e009883a 	mov	r4,fp
8112e6e4:	b00b883a 	mov	r5,r22
8112e6e8:	8a22b03a 	or	r17,r17,r8
8112e6ec:	3524983a 	sll	r18,r6,r20
8112e6f0:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e6f4:	e009883a 	mov	r4,fp
8112e6f8:	b00b883a 	mov	r5,r22
8112e6fc:	102f883a 	mov	r23,r2
8112e700:	112ea280 	call	8112ea28 <__udivsi3>
8112e704:	100d883a 	mov	r6,r2
8112e708:	b808943a 	slli	r4,r23,16
8112e70c:	aa3fffcc 	andi	r8,r21,65535
8112e710:	8804d43a 	srli	r2,r17,16
8112e714:	41af383a 	mul	r23,r8,r6
8112e718:	8520983a 	sll	r16,r16,r20
8112e71c:	1104b03a 	or	r2,r2,r4
8112e720:	15c0042e 	bgeu	r2,r23,8112e734 <__umoddi3+0x344>
8112e724:	1545883a 	add	r2,r2,r21
8112e728:	30ffffc4 	addi	r3,r6,-1
8112e72c:	1540742e 	bgeu	r2,r21,8112e900 <__umoddi3+0x510>
8112e730:	180d883a 	mov	r6,r3
8112e734:	15efc83a 	sub	r23,r2,r23
8112e738:	b00b883a 	mov	r5,r22
8112e73c:	b809883a 	mov	r4,r23
8112e740:	d9800115 	stw	r6,4(sp)
8112e744:	da000015 	stw	r8,0(sp)
8112e748:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e74c:	b00b883a 	mov	r5,r22
8112e750:	b809883a 	mov	r4,r23
8112e754:	1039883a 	mov	fp,r2
8112e758:	112ea280 	call	8112ea28 <__udivsi3>
8112e75c:	da000017 	ldw	r8,0(sp)
8112e760:	e038943a 	slli	fp,fp,16
8112e764:	100b883a 	mov	r5,r2
8112e768:	4089383a 	mul	r4,r8,r2
8112e76c:	8a3fffcc 	andi	r8,r17,65535
8112e770:	4710b03a 	or	r8,r8,fp
8112e774:	d9800117 	ldw	r6,4(sp)
8112e778:	4100042e 	bgeu	r8,r4,8112e78c <__umoddi3+0x39c>
8112e77c:	4551883a 	add	r8,r8,r21
8112e780:	10bfffc4 	addi	r2,r2,-1
8112e784:	45405a2e 	bgeu	r8,r21,8112e8f0 <__umoddi3+0x500>
8112e788:	100b883a 	mov	r5,r2
8112e78c:	300c943a 	slli	r6,r6,16
8112e790:	91ffffcc 	andi	r7,r18,65535
8112e794:	9004d43a 	srli	r2,r18,16
8112e798:	314cb03a 	or	r6,r6,r5
8112e79c:	317fffcc 	andi	r5,r6,65535
8112e7a0:	300cd43a 	srli	r6,r6,16
8112e7a4:	29d3383a 	mul	r9,r5,r7
8112e7a8:	288b383a 	mul	r5,r5,r2
8112e7ac:	31cf383a 	mul	r7,r6,r7
8112e7b0:	4806d43a 	srli	r3,r9,16
8112e7b4:	4111c83a 	sub	r8,r8,r4
8112e7b8:	29cb883a 	add	r5,r5,r7
8112e7bc:	194b883a 	add	r5,r3,r5
8112e7c0:	3085383a 	mul	r2,r6,r2
8112e7c4:	29c0022e 	bgeu	r5,r7,8112e7d0 <__umoddi3+0x3e0>
8112e7c8:	00c00074 	movhi	r3,1
8112e7cc:	10c5883a 	add	r2,r2,r3
8112e7d0:	2808d43a 	srli	r4,r5,16
8112e7d4:	280a943a 	slli	r5,r5,16
8112e7d8:	4a7fffcc 	andi	r9,r9,65535
8112e7dc:	2085883a 	add	r2,r4,r2
8112e7e0:	2a4b883a 	add	r5,r5,r9
8112e7e4:	40803636 	bltu	r8,r2,8112e8c0 <__umoddi3+0x4d0>
8112e7e8:	40804d26 	beq	r8,r2,8112e920 <__umoddi3+0x530>
8112e7ec:	4089c83a 	sub	r4,r8,r2
8112e7f0:	280f883a 	mov	r7,r5
8112e7f4:	81cfc83a 	sub	r7,r16,r7
8112e7f8:	81c7803a 	cmpltu	r3,r16,r7
8112e7fc:	20c7c83a 	sub	r3,r4,r3
8112e800:	1cc4983a 	sll	r2,r3,r19
8112e804:	3d0ed83a 	srl	r7,r7,r20
8112e808:	1d06d83a 	srl	r3,r3,r20
8112e80c:	11c4b03a 	or	r2,r2,r7
8112e810:	003f9306 	br	8112e660 <__reset+0xfb10e660>
8112e814:	9ca6983a 	sll	r19,r19,r18
8112e818:	88e8d83a 	srl	r20,r17,r3
8112e81c:	80c4d83a 	srl	r2,r16,r3
8112e820:	982cd43a 	srli	r22,r19,16
8112e824:	8ca2983a 	sll	r17,r17,r18
8112e828:	a009883a 	mov	r4,r20
8112e82c:	b00b883a 	mov	r5,r22
8112e830:	1478b03a 	or	fp,r2,r17
8112e834:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e838:	a009883a 	mov	r4,r20
8112e83c:	b00b883a 	mov	r5,r22
8112e840:	1023883a 	mov	r17,r2
8112e844:	112ea280 	call	8112ea28 <__udivsi3>
8112e848:	9d7fffcc 	andi	r21,r19,65535
8112e84c:	880a943a 	slli	r5,r17,16
8112e850:	e008d43a 	srli	r4,fp,16
8112e854:	a885383a 	mul	r2,r21,r2
8112e858:	84a8983a 	sll	r20,r16,r18
8112e85c:	2148b03a 	or	r4,r4,r5
8112e860:	2080042e 	bgeu	r4,r2,8112e874 <__umoddi3+0x484>
8112e864:	24c9883a 	add	r4,r4,r19
8112e868:	24c00236 	bltu	r4,r19,8112e874 <__umoddi3+0x484>
8112e86c:	2080012e 	bgeu	r4,r2,8112e874 <__umoddi3+0x484>
8112e870:	24c9883a 	add	r4,r4,r19
8112e874:	20a3c83a 	sub	r17,r4,r2
8112e878:	b00b883a 	mov	r5,r22
8112e87c:	8809883a 	mov	r4,r17
8112e880:	112ea8c0 	call	8112ea8c <__umodsi3>
8112e884:	102f883a 	mov	r23,r2
8112e888:	8809883a 	mov	r4,r17
8112e88c:	b00b883a 	mov	r5,r22
8112e890:	112ea280 	call	8112ea28 <__udivsi3>
8112e894:	b82e943a 	slli	r23,r23,16
8112e898:	a885383a 	mul	r2,r21,r2
8112e89c:	e13fffcc 	andi	r4,fp,65535
8112e8a0:	25c8b03a 	or	r4,r4,r23
8112e8a4:	2080042e 	bgeu	r4,r2,8112e8b8 <__umoddi3+0x4c8>
8112e8a8:	24c9883a 	add	r4,r4,r19
8112e8ac:	24c00236 	bltu	r4,r19,8112e8b8 <__umoddi3+0x4c8>
8112e8b0:	2080012e 	bgeu	r4,r2,8112e8b8 <__umoddi3+0x4c8>
8112e8b4:	24c9883a 	add	r4,r4,r19
8112e8b8:	20a3c83a 	sub	r17,r4,r2
8112e8bc:	003f4806 	br	8112e5e0 <__reset+0xfb10e5e0>
8112e8c0:	2c8fc83a 	sub	r7,r5,r18
8112e8c4:	1545c83a 	sub	r2,r2,r21
8112e8c8:	29cb803a 	cmpltu	r5,r5,r7
8112e8cc:	1145c83a 	sub	r2,r2,r5
8112e8d0:	4089c83a 	sub	r4,r8,r2
8112e8d4:	003fc706 	br	8112e7f4 <__reset+0xfb10e7f4>
8112e8d8:	01000604 	movi	r4,24
8112e8dc:	003f1806 	br	8112e540 <__reset+0xfb10e540>
8112e8e0:	00800604 	movi	r2,24
8112e8e4:	003f3206 	br	8112e5b0 <__reset+0xfb10e5b0>
8112e8e8:	01000604 	movi	r4,24
8112e8ec:	003ed906 	br	8112e454 <__reset+0xfb10e454>
8112e8f0:	413fa52e 	bgeu	r8,r4,8112e788 <__reset+0xfb10e788>
8112e8f4:	297fff84 	addi	r5,r5,-2
8112e8f8:	4551883a 	add	r8,r8,r21
8112e8fc:	003fa306 	br	8112e78c <__reset+0xfb10e78c>
8112e900:	15ff8b2e 	bgeu	r2,r23,8112e730 <__reset+0xfb10e730>
8112e904:	31bfff84 	addi	r6,r6,-2
8112e908:	1545883a 	add	r2,r2,r21
8112e90c:	003f8906 	br	8112e734 <__reset+0xfb10e734>
8112e910:	24c9883a 	add	r4,r4,r19
8112e914:	003eee06 	br	8112e4d0 <__reset+0xfb10e4d0>
8112e918:	8005883a 	mov	r2,r16
8112e91c:	003f1706 	br	8112e57c <__reset+0xfb10e57c>
8112e920:	817fe736 	bltu	r16,r5,8112e8c0 <__reset+0xfb10e8c0>
8112e924:	280f883a 	mov	r7,r5
8112e928:	0009883a 	mov	r4,zero
8112e92c:	003fb106 	br	8112e7f4 <__reset+0xfb10e7f4>

8112e930 <__divsi3>:
8112e930:	20001b16 	blt	r4,zero,8112e9a0 <__divsi3+0x70>
8112e934:	000f883a 	mov	r7,zero
8112e938:	28001616 	blt	r5,zero,8112e994 <__divsi3+0x64>
8112e93c:	200d883a 	mov	r6,r4
8112e940:	29001a2e 	bgeu	r5,r4,8112e9ac <__divsi3+0x7c>
8112e944:	00800804 	movi	r2,32
8112e948:	00c00044 	movi	r3,1
8112e94c:	00000106 	br	8112e954 <__divsi3+0x24>
8112e950:	10000d26 	beq	r2,zero,8112e988 <__divsi3+0x58>
8112e954:	294b883a 	add	r5,r5,r5
8112e958:	10bfffc4 	addi	r2,r2,-1
8112e95c:	18c7883a 	add	r3,r3,r3
8112e960:	293ffb36 	bltu	r5,r4,8112e950 <__reset+0xfb10e950>
8112e964:	0005883a 	mov	r2,zero
8112e968:	18000726 	beq	r3,zero,8112e988 <__divsi3+0x58>
8112e96c:	0005883a 	mov	r2,zero
8112e970:	31400236 	bltu	r6,r5,8112e97c <__divsi3+0x4c>
8112e974:	314dc83a 	sub	r6,r6,r5
8112e978:	10c4b03a 	or	r2,r2,r3
8112e97c:	1806d07a 	srli	r3,r3,1
8112e980:	280ad07a 	srli	r5,r5,1
8112e984:	183ffa1e 	bne	r3,zero,8112e970 <__reset+0xfb10e970>
8112e988:	38000126 	beq	r7,zero,8112e990 <__divsi3+0x60>
8112e98c:	0085c83a 	sub	r2,zero,r2
8112e990:	f800283a 	ret
8112e994:	014bc83a 	sub	r5,zero,r5
8112e998:	39c0005c 	xori	r7,r7,1
8112e99c:	003fe706 	br	8112e93c <__reset+0xfb10e93c>
8112e9a0:	0109c83a 	sub	r4,zero,r4
8112e9a4:	01c00044 	movi	r7,1
8112e9a8:	003fe306 	br	8112e938 <__reset+0xfb10e938>
8112e9ac:	00c00044 	movi	r3,1
8112e9b0:	003fee06 	br	8112e96c <__reset+0xfb10e96c>

8112e9b4 <__modsi3>:
8112e9b4:	20001716 	blt	r4,zero,8112ea14 <__modsi3+0x60>
8112e9b8:	000f883a 	mov	r7,zero
8112e9bc:	2005883a 	mov	r2,r4
8112e9c0:	28001216 	blt	r5,zero,8112ea0c <__modsi3+0x58>
8112e9c4:	2900162e 	bgeu	r5,r4,8112ea20 <__modsi3+0x6c>
8112e9c8:	01800804 	movi	r6,32
8112e9cc:	00c00044 	movi	r3,1
8112e9d0:	00000106 	br	8112e9d8 <__modsi3+0x24>
8112e9d4:	30000a26 	beq	r6,zero,8112ea00 <__modsi3+0x4c>
8112e9d8:	294b883a 	add	r5,r5,r5
8112e9dc:	31bfffc4 	addi	r6,r6,-1
8112e9e0:	18c7883a 	add	r3,r3,r3
8112e9e4:	293ffb36 	bltu	r5,r4,8112e9d4 <__reset+0xfb10e9d4>
8112e9e8:	18000526 	beq	r3,zero,8112ea00 <__modsi3+0x4c>
8112e9ec:	1806d07a 	srli	r3,r3,1
8112e9f0:	11400136 	bltu	r2,r5,8112e9f8 <__modsi3+0x44>
8112e9f4:	1145c83a 	sub	r2,r2,r5
8112e9f8:	280ad07a 	srli	r5,r5,1
8112e9fc:	183ffb1e 	bne	r3,zero,8112e9ec <__reset+0xfb10e9ec>
8112ea00:	38000126 	beq	r7,zero,8112ea08 <__modsi3+0x54>
8112ea04:	0085c83a 	sub	r2,zero,r2
8112ea08:	f800283a 	ret
8112ea0c:	014bc83a 	sub	r5,zero,r5
8112ea10:	003fec06 	br	8112e9c4 <__reset+0xfb10e9c4>
8112ea14:	0109c83a 	sub	r4,zero,r4
8112ea18:	01c00044 	movi	r7,1
8112ea1c:	003fe706 	br	8112e9bc <__reset+0xfb10e9bc>
8112ea20:	00c00044 	movi	r3,1
8112ea24:	003ff106 	br	8112e9ec <__reset+0xfb10e9ec>

8112ea28 <__udivsi3>:
8112ea28:	200d883a 	mov	r6,r4
8112ea2c:	2900152e 	bgeu	r5,r4,8112ea84 <__udivsi3+0x5c>
8112ea30:	28001416 	blt	r5,zero,8112ea84 <__udivsi3+0x5c>
8112ea34:	00800804 	movi	r2,32
8112ea38:	00c00044 	movi	r3,1
8112ea3c:	00000206 	br	8112ea48 <__udivsi3+0x20>
8112ea40:	10000e26 	beq	r2,zero,8112ea7c <__udivsi3+0x54>
8112ea44:	28000516 	blt	r5,zero,8112ea5c <__udivsi3+0x34>
8112ea48:	294b883a 	add	r5,r5,r5
8112ea4c:	10bfffc4 	addi	r2,r2,-1
8112ea50:	18c7883a 	add	r3,r3,r3
8112ea54:	293ffa36 	bltu	r5,r4,8112ea40 <__reset+0xfb10ea40>
8112ea58:	18000826 	beq	r3,zero,8112ea7c <__udivsi3+0x54>
8112ea5c:	0005883a 	mov	r2,zero
8112ea60:	31400236 	bltu	r6,r5,8112ea6c <__udivsi3+0x44>
8112ea64:	314dc83a 	sub	r6,r6,r5
8112ea68:	10c4b03a 	or	r2,r2,r3
8112ea6c:	1806d07a 	srli	r3,r3,1
8112ea70:	280ad07a 	srli	r5,r5,1
8112ea74:	183ffa1e 	bne	r3,zero,8112ea60 <__reset+0xfb10ea60>
8112ea78:	f800283a 	ret
8112ea7c:	0005883a 	mov	r2,zero
8112ea80:	f800283a 	ret
8112ea84:	00c00044 	movi	r3,1
8112ea88:	003ff406 	br	8112ea5c <__reset+0xfb10ea5c>

8112ea8c <__umodsi3>:
8112ea8c:	2005883a 	mov	r2,r4
8112ea90:	2900122e 	bgeu	r5,r4,8112eadc <__umodsi3+0x50>
8112ea94:	28001116 	blt	r5,zero,8112eadc <__umodsi3+0x50>
8112ea98:	01800804 	movi	r6,32
8112ea9c:	00c00044 	movi	r3,1
8112eaa0:	00000206 	br	8112eaac <__umodsi3+0x20>
8112eaa4:	30000c26 	beq	r6,zero,8112ead8 <__umodsi3+0x4c>
8112eaa8:	28000516 	blt	r5,zero,8112eac0 <__umodsi3+0x34>
8112eaac:	294b883a 	add	r5,r5,r5
8112eab0:	31bfffc4 	addi	r6,r6,-1
8112eab4:	18c7883a 	add	r3,r3,r3
8112eab8:	293ffa36 	bltu	r5,r4,8112eaa4 <__reset+0xfb10eaa4>
8112eabc:	18000626 	beq	r3,zero,8112ead8 <__umodsi3+0x4c>
8112eac0:	1806d07a 	srli	r3,r3,1
8112eac4:	11400136 	bltu	r2,r5,8112eacc <__umodsi3+0x40>
8112eac8:	1145c83a 	sub	r2,r2,r5
8112eacc:	280ad07a 	srli	r5,r5,1
8112ead0:	183ffb1e 	bne	r3,zero,8112eac0 <__reset+0xfb10eac0>
8112ead4:	f800283a 	ret
8112ead8:	f800283a 	ret
8112eadc:	00c00044 	movi	r3,1
8112eae0:	003ff706 	br	8112eac0 <__reset+0xfb10eac0>

8112eae4 <__eqsf2>:
8112eae4:	2006d5fa 	srli	r3,r4,23
8112eae8:	280cd5fa 	srli	r6,r5,23
8112eaec:	01c02034 	movhi	r7,128
8112eaf0:	39ffffc4 	addi	r7,r7,-1
8112eaf4:	18c03fcc 	andi	r3,r3,255
8112eaf8:	02003fc4 	movi	r8,255
8112eafc:	3904703a 	and	r2,r7,r4
8112eb00:	31803fcc 	andi	r6,r6,255
8112eb04:	394e703a 	and	r7,r7,r5
8112eb08:	2008d7fa 	srli	r4,r4,31
8112eb0c:	280ad7fa 	srli	r5,r5,31
8112eb10:	1a000d26 	beq	r3,r8,8112eb48 <__eqsf2+0x64>
8112eb14:	02003fc4 	movi	r8,255
8112eb18:	32000826 	beq	r6,r8,8112eb3c <__eqsf2+0x58>
8112eb1c:	19800226 	beq	r3,r6,8112eb28 <__eqsf2+0x44>
8112eb20:	00800044 	movi	r2,1
8112eb24:	f800283a 	ret
8112eb28:	11fffd1e 	bne	r2,r7,8112eb20 <__reset+0xfb10eb20>
8112eb2c:	21400926 	beq	r4,r5,8112eb54 <__eqsf2+0x70>
8112eb30:	183ffb1e 	bne	r3,zero,8112eb20 <__reset+0xfb10eb20>
8112eb34:	1004c03a 	cmpne	r2,r2,zero
8112eb38:	f800283a 	ret
8112eb3c:	383ff726 	beq	r7,zero,8112eb1c <__reset+0xfb10eb1c>
8112eb40:	00800044 	movi	r2,1
8112eb44:	f800283a 	ret
8112eb48:	103ff226 	beq	r2,zero,8112eb14 <__reset+0xfb10eb14>
8112eb4c:	00800044 	movi	r2,1
8112eb50:	f800283a 	ret
8112eb54:	0005883a 	mov	r2,zero
8112eb58:	f800283a 	ret

8112eb5c <__gesf2>:
8112eb5c:	2004d5fa 	srli	r2,r4,23
8112eb60:	2806d5fa 	srli	r3,r5,23
8112eb64:	01802034 	movhi	r6,128
8112eb68:	31bfffc4 	addi	r6,r6,-1
8112eb6c:	10803fcc 	andi	r2,r2,255
8112eb70:	01c03fc4 	movi	r7,255
8112eb74:	3110703a 	and	r8,r6,r4
8112eb78:	18c03fcc 	andi	r3,r3,255
8112eb7c:	314c703a 	and	r6,r6,r5
8112eb80:	2008d7fa 	srli	r4,r4,31
8112eb84:	280ad7fa 	srli	r5,r5,31
8112eb88:	11c01926 	beq	r2,r7,8112ebf0 <__gesf2+0x94>
8112eb8c:	01c03fc4 	movi	r7,255
8112eb90:	19c00f26 	beq	r3,r7,8112ebd0 <__gesf2+0x74>
8112eb94:	1000061e 	bne	r2,zero,8112ebb0 <__gesf2+0x54>
8112eb98:	400f003a 	cmpeq	r7,r8,zero
8112eb9c:	1800071e 	bne	r3,zero,8112ebbc <__gesf2+0x60>
8112eba0:	3000061e 	bne	r6,zero,8112ebbc <__gesf2+0x60>
8112eba4:	0005883a 	mov	r2,zero
8112eba8:	40000e1e 	bne	r8,zero,8112ebe4 <__gesf2+0x88>
8112ebac:	f800283a 	ret
8112ebb0:	18000a1e 	bne	r3,zero,8112ebdc <__gesf2+0x80>
8112ebb4:	30000b26 	beq	r6,zero,8112ebe4 <__gesf2+0x88>
8112ebb8:	000f883a 	mov	r7,zero
8112ebbc:	29403fcc 	andi	r5,r5,255
8112ebc0:	38000726 	beq	r7,zero,8112ebe0 <__gesf2+0x84>
8112ebc4:	28000826 	beq	r5,zero,8112ebe8 <__gesf2+0x8c>
8112ebc8:	00800044 	movi	r2,1
8112ebcc:	f800283a 	ret
8112ebd0:	303ff026 	beq	r6,zero,8112eb94 <__reset+0xfb10eb94>
8112ebd4:	00bfff84 	movi	r2,-2
8112ebd8:	f800283a 	ret
8112ebdc:	29403fcc 	andi	r5,r5,255
8112ebe0:	21400526 	beq	r4,r5,8112ebf8 <__gesf2+0x9c>
8112ebe4:	203ff826 	beq	r4,zero,8112ebc8 <__reset+0xfb10ebc8>
8112ebe8:	00bfffc4 	movi	r2,-1
8112ebec:	f800283a 	ret
8112ebf0:	403fe626 	beq	r8,zero,8112eb8c <__reset+0xfb10eb8c>
8112ebf4:	003ff706 	br	8112ebd4 <__reset+0xfb10ebd4>
8112ebf8:	18bffa16 	blt	r3,r2,8112ebe4 <__reset+0xfb10ebe4>
8112ebfc:	10c00216 	blt	r2,r3,8112ec08 <__gesf2+0xac>
8112ec00:	323ff836 	bltu	r6,r8,8112ebe4 <__reset+0xfb10ebe4>
8112ec04:	4180022e 	bgeu	r8,r6,8112ec10 <__gesf2+0xb4>
8112ec08:	203fef1e 	bne	r4,zero,8112ebc8 <__reset+0xfb10ebc8>
8112ec0c:	003ff606 	br	8112ebe8 <__reset+0xfb10ebe8>
8112ec10:	0005883a 	mov	r2,zero
8112ec14:	f800283a 	ret

8112ec18 <__lesf2>:
8112ec18:	2004d5fa 	srli	r2,r4,23
8112ec1c:	280cd5fa 	srli	r6,r5,23
8112ec20:	00c02034 	movhi	r3,128
8112ec24:	18ffffc4 	addi	r3,r3,-1
8112ec28:	10803fcc 	andi	r2,r2,255
8112ec2c:	01c03fc4 	movi	r7,255
8112ec30:	1910703a 	and	r8,r3,r4
8112ec34:	31803fcc 	andi	r6,r6,255
8112ec38:	1946703a 	and	r3,r3,r5
8112ec3c:	2008d7fa 	srli	r4,r4,31
8112ec40:	280ad7fa 	srli	r5,r5,31
8112ec44:	11c01b26 	beq	r2,r7,8112ecb4 <__lesf2+0x9c>
8112ec48:	01c03fc4 	movi	r7,255
8112ec4c:	31c01126 	beq	r6,r7,8112ec94 <__lesf2+0x7c>
8112ec50:	1000071e 	bne	r2,zero,8112ec70 <__lesf2+0x58>
8112ec54:	400f003a 	cmpeq	r7,r8,zero
8112ec58:	21003fcc 	andi	r4,r4,255
8112ec5c:	3000081e 	bne	r6,zero,8112ec80 <__lesf2+0x68>
8112ec60:	1800071e 	bne	r3,zero,8112ec80 <__lesf2+0x68>
8112ec64:	0005883a 	mov	r2,zero
8112ec68:	40000f1e 	bne	r8,zero,8112eca8 <__lesf2+0x90>
8112ec6c:	f800283a 	ret
8112ec70:	21003fcc 	andi	r4,r4,255
8112ec74:	30000a1e 	bne	r6,zero,8112eca0 <__lesf2+0x88>
8112ec78:	18000b26 	beq	r3,zero,8112eca8 <__lesf2+0x90>
8112ec7c:	000f883a 	mov	r7,zero
8112ec80:	29403fcc 	andi	r5,r5,255
8112ec84:	38000726 	beq	r7,zero,8112eca4 <__lesf2+0x8c>
8112ec88:	28000826 	beq	r5,zero,8112ecac <__lesf2+0x94>
8112ec8c:	00800044 	movi	r2,1
8112ec90:	f800283a 	ret
8112ec94:	183fee26 	beq	r3,zero,8112ec50 <__reset+0xfb10ec50>
8112ec98:	00800084 	movi	r2,2
8112ec9c:	f800283a 	ret
8112eca0:	29403fcc 	andi	r5,r5,255
8112eca4:	21400626 	beq	r4,r5,8112ecc0 <__lesf2+0xa8>
8112eca8:	203ff826 	beq	r4,zero,8112ec8c <__reset+0xfb10ec8c>
8112ecac:	00bfffc4 	movi	r2,-1
8112ecb0:	f800283a 	ret
8112ecb4:	403fe426 	beq	r8,zero,8112ec48 <__reset+0xfb10ec48>
8112ecb8:	00800084 	movi	r2,2
8112ecbc:	f800283a 	ret
8112ecc0:	30bff916 	blt	r6,r2,8112eca8 <__reset+0xfb10eca8>
8112ecc4:	11800216 	blt	r2,r6,8112ecd0 <__lesf2+0xb8>
8112ecc8:	1a3ff736 	bltu	r3,r8,8112eca8 <__reset+0xfb10eca8>
8112eccc:	40c0022e 	bgeu	r8,r3,8112ecd8 <__lesf2+0xc0>
8112ecd0:	203fee1e 	bne	r4,zero,8112ec8c <__reset+0xfb10ec8c>
8112ecd4:	003ff506 	br	8112ecac <__reset+0xfb10ecac>
8112ecd8:	0005883a 	mov	r2,zero
8112ecdc:	f800283a 	ret

8112ece0 <__adddf3>:
8112ece0:	02c00434 	movhi	r11,16
8112ece4:	5affffc4 	addi	r11,r11,-1
8112ece8:	2806d7fa 	srli	r3,r5,31
8112ecec:	2ad4703a 	and	r10,r5,r11
8112ecf0:	3ad2703a 	and	r9,r7,r11
8112ecf4:	3804d53a 	srli	r2,r7,20
8112ecf8:	3018d77a 	srli	r12,r6,29
8112ecfc:	280ad53a 	srli	r5,r5,20
8112ed00:	501490fa 	slli	r10,r10,3
8112ed04:	2010d77a 	srli	r8,r4,29
8112ed08:	481290fa 	slli	r9,r9,3
8112ed0c:	380ed7fa 	srli	r7,r7,31
8112ed10:	defffb04 	addi	sp,sp,-20
8112ed14:	de00012e 	bgeu	sp,et,8112ed1c <__adddf3+0x3c>
8112ed18:	003b68fa 	trap	3
8112ed1c:	dc800215 	stw	r18,8(sp)
8112ed20:	dc400115 	stw	r17,4(sp)
8112ed24:	dc000015 	stw	r16,0(sp)
8112ed28:	dfc00415 	stw	ra,16(sp)
8112ed2c:	dcc00315 	stw	r19,12(sp)
8112ed30:	1c803fcc 	andi	r18,r3,255
8112ed34:	2c01ffcc 	andi	r16,r5,2047
8112ed38:	5210b03a 	or	r8,r10,r8
8112ed3c:	202290fa 	slli	r17,r4,3
8112ed40:	1081ffcc 	andi	r2,r2,2047
8112ed44:	4b12b03a 	or	r9,r9,r12
8112ed48:	300c90fa 	slli	r6,r6,3
8112ed4c:	91c07526 	beq	r18,r7,8112ef24 <__adddf3+0x244>
8112ed50:	8087c83a 	sub	r3,r16,r2
8112ed54:	00c0ab0e 	bge	zero,r3,8112f004 <__adddf3+0x324>
8112ed58:	10002a1e 	bne	r2,zero,8112ee04 <__adddf3+0x124>
8112ed5c:	4984b03a 	or	r2,r9,r6
8112ed60:	1000961e 	bne	r2,zero,8112efbc <__adddf3+0x2dc>
8112ed64:	888001cc 	andi	r2,r17,7
8112ed68:	10000726 	beq	r2,zero,8112ed88 <__adddf3+0xa8>
8112ed6c:	888003cc 	andi	r2,r17,15
8112ed70:	00c00104 	movi	r3,4
8112ed74:	10c00426 	beq	r2,r3,8112ed88 <__adddf3+0xa8>
8112ed78:	88c7883a 	add	r3,r17,r3
8112ed7c:	1c63803a 	cmpltu	r17,r3,r17
8112ed80:	4451883a 	add	r8,r8,r17
8112ed84:	1823883a 	mov	r17,r3
8112ed88:	4080202c 	andhi	r2,r8,128
8112ed8c:	10005926 	beq	r2,zero,8112eef4 <__adddf3+0x214>
8112ed90:	84000044 	addi	r16,r16,1
8112ed94:	0081ffc4 	movi	r2,2047
8112ed98:	8080ba26 	beq	r16,r2,8112f084 <__adddf3+0x3a4>
8112ed9c:	00bfe034 	movhi	r2,65408
8112eda0:	10bfffc4 	addi	r2,r2,-1
8112eda4:	4090703a 	and	r8,r8,r2
8112eda8:	4004977a 	slli	r2,r8,29
8112edac:	4010927a 	slli	r8,r8,9
8112edb0:	8822d0fa 	srli	r17,r17,3
8112edb4:	8401ffcc 	andi	r16,r16,2047
8112edb8:	4010d33a 	srli	r8,r8,12
8112edbc:	9007883a 	mov	r3,r18
8112edc0:	1444b03a 	or	r2,r2,r17
8112edc4:	8401ffcc 	andi	r16,r16,2047
8112edc8:	8020953a 	slli	r16,r16,20
8112edcc:	18c03fcc 	andi	r3,r3,255
8112edd0:	01000434 	movhi	r4,16
8112edd4:	213fffc4 	addi	r4,r4,-1
8112edd8:	180697fa 	slli	r3,r3,31
8112eddc:	4110703a 	and	r8,r8,r4
8112ede0:	4410b03a 	or	r8,r8,r16
8112ede4:	40c6b03a 	or	r3,r8,r3
8112ede8:	dfc00417 	ldw	ra,16(sp)
8112edec:	dcc00317 	ldw	r19,12(sp)
8112edf0:	dc800217 	ldw	r18,8(sp)
8112edf4:	dc400117 	ldw	r17,4(sp)
8112edf8:	dc000017 	ldw	r16,0(sp)
8112edfc:	dec00504 	addi	sp,sp,20
8112ee00:	f800283a 	ret
8112ee04:	0081ffc4 	movi	r2,2047
8112ee08:	80bfd626 	beq	r16,r2,8112ed64 <__reset+0xfb10ed64>
8112ee0c:	4a402034 	orhi	r9,r9,128
8112ee10:	00800e04 	movi	r2,56
8112ee14:	10c09f16 	blt	r2,r3,8112f094 <__adddf3+0x3b4>
8112ee18:	008007c4 	movi	r2,31
8112ee1c:	10c0c216 	blt	r2,r3,8112f128 <__adddf3+0x448>
8112ee20:	00800804 	movi	r2,32
8112ee24:	10c5c83a 	sub	r2,r2,r3
8112ee28:	488a983a 	sll	r5,r9,r2
8112ee2c:	30c8d83a 	srl	r4,r6,r3
8112ee30:	3084983a 	sll	r2,r6,r2
8112ee34:	48c6d83a 	srl	r3,r9,r3
8112ee38:	290cb03a 	or	r6,r5,r4
8112ee3c:	1004c03a 	cmpne	r2,r2,zero
8112ee40:	308cb03a 	or	r6,r6,r2
8112ee44:	898dc83a 	sub	r6,r17,r6
8112ee48:	89a3803a 	cmpltu	r17,r17,r6
8112ee4c:	40d1c83a 	sub	r8,r8,r3
8112ee50:	4451c83a 	sub	r8,r8,r17
8112ee54:	3023883a 	mov	r17,r6
8112ee58:	4080202c 	andhi	r2,r8,128
8112ee5c:	10002326 	beq	r2,zero,8112eeec <__adddf3+0x20c>
8112ee60:	04c02034 	movhi	r19,128
8112ee64:	9cffffc4 	addi	r19,r19,-1
8112ee68:	44e6703a 	and	r19,r8,r19
8112ee6c:	98007626 	beq	r19,zero,8112f048 <__adddf3+0x368>
8112ee70:	9809883a 	mov	r4,r19
8112ee74:	111b1d00 	call	8111b1d0 <__clzsi2>
8112ee78:	10fffe04 	addi	r3,r2,-8
8112ee7c:	010007c4 	movi	r4,31
8112ee80:	20c07716 	blt	r4,r3,8112f060 <__adddf3+0x380>
8112ee84:	00800804 	movi	r2,32
8112ee88:	10c5c83a 	sub	r2,r2,r3
8112ee8c:	8884d83a 	srl	r2,r17,r2
8112ee90:	98d0983a 	sll	r8,r19,r3
8112ee94:	88e2983a 	sll	r17,r17,r3
8112ee98:	1204b03a 	or	r2,r2,r8
8112ee9c:	1c007416 	blt	r3,r16,8112f070 <__adddf3+0x390>
8112eea0:	1c21c83a 	sub	r16,r3,r16
8112eea4:	82000044 	addi	r8,r16,1
8112eea8:	00c007c4 	movi	r3,31
8112eeac:	1a009116 	blt	r3,r8,8112f0f4 <__adddf3+0x414>
8112eeb0:	00c00804 	movi	r3,32
8112eeb4:	1a07c83a 	sub	r3,r3,r8
8112eeb8:	8a08d83a 	srl	r4,r17,r8
8112eebc:	88e2983a 	sll	r17,r17,r3
8112eec0:	10c6983a 	sll	r3,r2,r3
8112eec4:	1210d83a 	srl	r8,r2,r8
8112eec8:	8804c03a 	cmpne	r2,r17,zero
8112eecc:	1906b03a 	or	r3,r3,r4
8112eed0:	18a2b03a 	or	r17,r3,r2
8112eed4:	0021883a 	mov	r16,zero
8112eed8:	003fa206 	br	8112ed64 <__reset+0xfb10ed64>
8112eedc:	1890b03a 	or	r8,r3,r2
8112eee0:	40017d26 	beq	r8,zero,8112f4d8 <__adddf3+0x7f8>
8112eee4:	1011883a 	mov	r8,r2
8112eee8:	1823883a 	mov	r17,r3
8112eeec:	888001cc 	andi	r2,r17,7
8112eef0:	103f9e1e 	bne	r2,zero,8112ed6c <__reset+0xfb10ed6c>
8112eef4:	4004977a 	slli	r2,r8,29
8112eef8:	8822d0fa 	srli	r17,r17,3
8112eefc:	4010d0fa 	srli	r8,r8,3
8112ef00:	9007883a 	mov	r3,r18
8112ef04:	1444b03a 	or	r2,r2,r17
8112ef08:	0101ffc4 	movi	r4,2047
8112ef0c:	81002426 	beq	r16,r4,8112efa0 <__adddf3+0x2c0>
8112ef10:	8120703a 	and	r16,r16,r4
8112ef14:	01000434 	movhi	r4,16
8112ef18:	213fffc4 	addi	r4,r4,-1
8112ef1c:	4110703a 	and	r8,r8,r4
8112ef20:	003fa806 	br	8112edc4 <__reset+0xfb10edc4>
8112ef24:	8089c83a 	sub	r4,r16,r2
8112ef28:	01005e0e 	bge	zero,r4,8112f0a4 <__adddf3+0x3c4>
8112ef2c:	10002b26 	beq	r2,zero,8112efdc <__adddf3+0x2fc>
8112ef30:	0081ffc4 	movi	r2,2047
8112ef34:	80bf8b26 	beq	r16,r2,8112ed64 <__reset+0xfb10ed64>
8112ef38:	4a402034 	orhi	r9,r9,128
8112ef3c:	00800e04 	movi	r2,56
8112ef40:	1100a40e 	bge	r2,r4,8112f1d4 <__adddf3+0x4f4>
8112ef44:	498cb03a 	or	r6,r9,r6
8112ef48:	300ac03a 	cmpne	r5,r6,zero
8112ef4c:	0013883a 	mov	r9,zero
8112ef50:	2c4b883a 	add	r5,r5,r17
8112ef54:	2c63803a 	cmpltu	r17,r5,r17
8112ef58:	4a11883a 	add	r8,r9,r8
8112ef5c:	8a11883a 	add	r8,r17,r8
8112ef60:	2823883a 	mov	r17,r5
8112ef64:	4080202c 	andhi	r2,r8,128
8112ef68:	103fe026 	beq	r2,zero,8112eeec <__reset+0xfb10eeec>
8112ef6c:	84000044 	addi	r16,r16,1
8112ef70:	0081ffc4 	movi	r2,2047
8112ef74:	8080d226 	beq	r16,r2,8112f2c0 <__adddf3+0x5e0>
8112ef78:	00bfe034 	movhi	r2,65408
8112ef7c:	10bfffc4 	addi	r2,r2,-1
8112ef80:	4090703a 	and	r8,r8,r2
8112ef84:	880ad07a 	srli	r5,r17,1
8112ef88:	400897fa 	slli	r4,r8,31
8112ef8c:	88c0004c 	andi	r3,r17,1
8112ef90:	28e2b03a 	or	r17,r5,r3
8112ef94:	4010d07a 	srli	r8,r8,1
8112ef98:	2462b03a 	or	r17,r4,r17
8112ef9c:	003f7106 	br	8112ed64 <__reset+0xfb10ed64>
8112efa0:	4088b03a 	or	r4,r8,r2
8112efa4:	20014526 	beq	r4,zero,8112f4bc <__adddf3+0x7dc>
8112efa8:	01000434 	movhi	r4,16
8112efac:	42000234 	orhi	r8,r8,8
8112efb0:	213fffc4 	addi	r4,r4,-1
8112efb4:	4110703a 	and	r8,r8,r4
8112efb8:	003f8206 	br	8112edc4 <__reset+0xfb10edc4>
8112efbc:	18ffffc4 	addi	r3,r3,-1
8112efc0:	1800491e 	bne	r3,zero,8112f0e8 <__adddf3+0x408>
8112efc4:	898bc83a 	sub	r5,r17,r6
8112efc8:	8963803a 	cmpltu	r17,r17,r5
8112efcc:	4251c83a 	sub	r8,r8,r9
8112efd0:	4451c83a 	sub	r8,r8,r17
8112efd4:	2823883a 	mov	r17,r5
8112efd8:	003f9f06 	br	8112ee58 <__reset+0xfb10ee58>
8112efdc:	4984b03a 	or	r2,r9,r6
8112efe0:	103f6026 	beq	r2,zero,8112ed64 <__reset+0xfb10ed64>
8112efe4:	213fffc4 	addi	r4,r4,-1
8112efe8:	2000931e 	bne	r4,zero,8112f238 <__adddf3+0x558>
8112efec:	898d883a 	add	r6,r17,r6
8112eff0:	3463803a 	cmpltu	r17,r6,r17
8112eff4:	4251883a 	add	r8,r8,r9
8112eff8:	8a11883a 	add	r8,r17,r8
8112effc:	3023883a 	mov	r17,r6
8112f000:	003fd806 	br	8112ef64 <__reset+0xfb10ef64>
8112f004:	1800541e 	bne	r3,zero,8112f158 <__adddf3+0x478>
8112f008:	80800044 	addi	r2,r16,1
8112f00c:	1081ffcc 	andi	r2,r2,2047
8112f010:	00c00044 	movi	r3,1
8112f014:	1880a00e 	bge	r3,r2,8112f298 <__adddf3+0x5b8>
8112f018:	8989c83a 	sub	r4,r17,r6
8112f01c:	8905803a 	cmpltu	r2,r17,r4
8112f020:	4267c83a 	sub	r19,r8,r9
8112f024:	98a7c83a 	sub	r19,r19,r2
8112f028:	9880202c 	andhi	r2,r19,128
8112f02c:	10006326 	beq	r2,zero,8112f1bc <__adddf3+0x4dc>
8112f030:	3463c83a 	sub	r17,r6,r17
8112f034:	4a07c83a 	sub	r3,r9,r8
8112f038:	344d803a 	cmpltu	r6,r6,r17
8112f03c:	19a7c83a 	sub	r19,r3,r6
8112f040:	3825883a 	mov	r18,r7
8112f044:	983f8a1e 	bne	r19,zero,8112ee70 <__reset+0xfb10ee70>
8112f048:	8809883a 	mov	r4,r17
8112f04c:	111b1d00 	call	8111b1d0 <__clzsi2>
8112f050:	10800804 	addi	r2,r2,32
8112f054:	10fffe04 	addi	r3,r2,-8
8112f058:	010007c4 	movi	r4,31
8112f05c:	20ff890e 	bge	r4,r3,8112ee84 <__reset+0xfb10ee84>
8112f060:	10bff604 	addi	r2,r2,-40
8112f064:	8884983a 	sll	r2,r17,r2
8112f068:	0023883a 	mov	r17,zero
8112f06c:	1c3f8c0e 	bge	r3,r16,8112eea0 <__reset+0xfb10eea0>
8112f070:	023fe034 	movhi	r8,65408
8112f074:	423fffc4 	addi	r8,r8,-1
8112f078:	80e1c83a 	sub	r16,r16,r3
8112f07c:	1210703a 	and	r8,r2,r8
8112f080:	003f3806 	br	8112ed64 <__reset+0xfb10ed64>
8112f084:	9007883a 	mov	r3,r18
8112f088:	0011883a 	mov	r8,zero
8112f08c:	0005883a 	mov	r2,zero
8112f090:	003f4c06 	br	8112edc4 <__reset+0xfb10edc4>
8112f094:	498cb03a 	or	r6,r9,r6
8112f098:	300cc03a 	cmpne	r6,r6,zero
8112f09c:	0007883a 	mov	r3,zero
8112f0a0:	003f6806 	br	8112ee44 <__reset+0xfb10ee44>
8112f0a4:	20009c1e 	bne	r4,zero,8112f318 <__adddf3+0x638>
8112f0a8:	80800044 	addi	r2,r16,1
8112f0ac:	1141ffcc 	andi	r5,r2,2047
8112f0b0:	01000044 	movi	r4,1
8112f0b4:	2140670e 	bge	r4,r5,8112f254 <__adddf3+0x574>
8112f0b8:	0101ffc4 	movi	r4,2047
8112f0bc:	11007f26 	beq	r2,r4,8112f2bc <__adddf3+0x5dc>
8112f0c0:	898d883a 	add	r6,r17,r6
8112f0c4:	4247883a 	add	r3,r8,r9
8112f0c8:	3451803a 	cmpltu	r8,r6,r17
8112f0cc:	40d1883a 	add	r8,r8,r3
8112f0d0:	402297fa 	slli	r17,r8,31
8112f0d4:	300cd07a 	srli	r6,r6,1
8112f0d8:	4010d07a 	srli	r8,r8,1
8112f0dc:	1021883a 	mov	r16,r2
8112f0e0:	89a2b03a 	or	r17,r17,r6
8112f0e4:	003f1f06 	br	8112ed64 <__reset+0xfb10ed64>
8112f0e8:	0081ffc4 	movi	r2,2047
8112f0ec:	80bf481e 	bne	r16,r2,8112ee10 <__reset+0xfb10ee10>
8112f0f0:	003f1c06 	br	8112ed64 <__reset+0xfb10ed64>
8112f0f4:	843ff844 	addi	r16,r16,-31
8112f0f8:	01000804 	movi	r4,32
8112f0fc:	1406d83a 	srl	r3,r2,r16
8112f100:	41005026 	beq	r8,r4,8112f244 <__adddf3+0x564>
8112f104:	01001004 	movi	r4,64
8112f108:	2211c83a 	sub	r8,r4,r8
8112f10c:	1204983a 	sll	r2,r2,r8
8112f110:	88a2b03a 	or	r17,r17,r2
8112f114:	8822c03a 	cmpne	r17,r17,zero
8112f118:	1c62b03a 	or	r17,r3,r17
8112f11c:	0011883a 	mov	r8,zero
8112f120:	0021883a 	mov	r16,zero
8112f124:	003f7106 	br	8112eeec <__reset+0xfb10eeec>
8112f128:	193ff804 	addi	r4,r3,-32
8112f12c:	00800804 	movi	r2,32
8112f130:	4908d83a 	srl	r4,r9,r4
8112f134:	18804526 	beq	r3,r2,8112f24c <__adddf3+0x56c>
8112f138:	00801004 	movi	r2,64
8112f13c:	10c5c83a 	sub	r2,r2,r3
8112f140:	4886983a 	sll	r3,r9,r2
8112f144:	198cb03a 	or	r6,r3,r6
8112f148:	300cc03a 	cmpne	r6,r6,zero
8112f14c:	218cb03a 	or	r6,r4,r6
8112f150:	0007883a 	mov	r3,zero
8112f154:	003f3b06 	br	8112ee44 <__reset+0xfb10ee44>
8112f158:	80002a26 	beq	r16,zero,8112f204 <__adddf3+0x524>
8112f15c:	0101ffc4 	movi	r4,2047
8112f160:	11006826 	beq	r2,r4,8112f304 <__adddf3+0x624>
8112f164:	00c7c83a 	sub	r3,zero,r3
8112f168:	42002034 	orhi	r8,r8,128
8112f16c:	01000e04 	movi	r4,56
8112f170:	20c07c16 	blt	r4,r3,8112f364 <__adddf3+0x684>
8112f174:	010007c4 	movi	r4,31
8112f178:	20c0da16 	blt	r4,r3,8112f4e4 <__adddf3+0x804>
8112f17c:	01000804 	movi	r4,32
8112f180:	20c9c83a 	sub	r4,r4,r3
8112f184:	4114983a 	sll	r10,r8,r4
8112f188:	88cad83a 	srl	r5,r17,r3
8112f18c:	8908983a 	sll	r4,r17,r4
8112f190:	40c6d83a 	srl	r3,r8,r3
8112f194:	5162b03a 	or	r17,r10,r5
8112f198:	2008c03a 	cmpne	r4,r4,zero
8112f19c:	8922b03a 	or	r17,r17,r4
8112f1a0:	3463c83a 	sub	r17,r6,r17
8112f1a4:	48c7c83a 	sub	r3,r9,r3
8112f1a8:	344d803a 	cmpltu	r6,r6,r17
8112f1ac:	1991c83a 	sub	r8,r3,r6
8112f1b0:	1021883a 	mov	r16,r2
8112f1b4:	3825883a 	mov	r18,r7
8112f1b8:	003f2706 	br	8112ee58 <__reset+0xfb10ee58>
8112f1bc:	24d0b03a 	or	r8,r4,r19
8112f1c0:	40001b1e 	bne	r8,zero,8112f230 <__adddf3+0x550>
8112f1c4:	0005883a 	mov	r2,zero
8112f1c8:	0007883a 	mov	r3,zero
8112f1cc:	0021883a 	mov	r16,zero
8112f1d0:	003f4d06 	br	8112ef08 <__reset+0xfb10ef08>
8112f1d4:	008007c4 	movi	r2,31
8112f1d8:	11003c16 	blt	r2,r4,8112f2cc <__adddf3+0x5ec>
8112f1dc:	00800804 	movi	r2,32
8112f1e0:	1105c83a 	sub	r2,r2,r4
8112f1e4:	488e983a 	sll	r7,r9,r2
8112f1e8:	310ad83a 	srl	r5,r6,r4
8112f1ec:	3084983a 	sll	r2,r6,r2
8112f1f0:	4912d83a 	srl	r9,r9,r4
8112f1f4:	394ab03a 	or	r5,r7,r5
8112f1f8:	1004c03a 	cmpne	r2,r2,zero
8112f1fc:	288ab03a 	or	r5,r5,r2
8112f200:	003f5306 	br	8112ef50 <__reset+0xfb10ef50>
8112f204:	4448b03a 	or	r4,r8,r17
8112f208:	20003e26 	beq	r4,zero,8112f304 <__adddf3+0x624>
8112f20c:	00c6303a 	nor	r3,zero,r3
8112f210:	18003a1e 	bne	r3,zero,8112f2fc <__adddf3+0x61c>
8112f214:	3463c83a 	sub	r17,r6,r17
8112f218:	4a07c83a 	sub	r3,r9,r8
8112f21c:	344d803a 	cmpltu	r6,r6,r17
8112f220:	1991c83a 	sub	r8,r3,r6
8112f224:	1021883a 	mov	r16,r2
8112f228:	3825883a 	mov	r18,r7
8112f22c:	003f0a06 	br	8112ee58 <__reset+0xfb10ee58>
8112f230:	2023883a 	mov	r17,r4
8112f234:	003f0d06 	br	8112ee6c <__reset+0xfb10ee6c>
8112f238:	0081ffc4 	movi	r2,2047
8112f23c:	80bf3f1e 	bne	r16,r2,8112ef3c <__reset+0xfb10ef3c>
8112f240:	003ec806 	br	8112ed64 <__reset+0xfb10ed64>
8112f244:	0005883a 	mov	r2,zero
8112f248:	003fb106 	br	8112f110 <__reset+0xfb10f110>
8112f24c:	0007883a 	mov	r3,zero
8112f250:	003fbc06 	br	8112f144 <__reset+0xfb10f144>
8112f254:	4444b03a 	or	r2,r8,r17
8112f258:	8000871e 	bne	r16,zero,8112f478 <__adddf3+0x798>
8112f25c:	1000ba26 	beq	r2,zero,8112f548 <__adddf3+0x868>
8112f260:	4984b03a 	or	r2,r9,r6
8112f264:	103ebf26 	beq	r2,zero,8112ed64 <__reset+0xfb10ed64>
8112f268:	8985883a 	add	r2,r17,r6
8112f26c:	4247883a 	add	r3,r8,r9
8112f270:	1451803a 	cmpltu	r8,r2,r17
8112f274:	40d1883a 	add	r8,r8,r3
8112f278:	40c0202c 	andhi	r3,r8,128
8112f27c:	1023883a 	mov	r17,r2
8112f280:	183f1a26 	beq	r3,zero,8112eeec <__reset+0xfb10eeec>
8112f284:	00bfe034 	movhi	r2,65408
8112f288:	10bfffc4 	addi	r2,r2,-1
8112f28c:	2021883a 	mov	r16,r4
8112f290:	4090703a 	and	r8,r8,r2
8112f294:	003eb306 	br	8112ed64 <__reset+0xfb10ed64>
8112f298:	4444b03a 	or	r2,r8,r17
8112f29c:	8000291e 	bne	r16,zero,8112f344 <__adddf3+0x664>
8112f2a0:	10004b1e 	bne	r2,zero,8112f3d0 <__adddf3+0x6f0>
8112f2a4:	4990b03a 	or	r8,r9,r6
8112f2a8:	40008b26 	beq	r8,zero,8112f4d8 <__adddf3+0x7f8>
8112f2ac:	4811883a 	mov	r8,r9
8112f2b0:	3023883a 	mov	r17,r6
8112f2b4:	3825883a 	mov	r18,r7
8112f2b8:	003eaa06 	br	8112ed64 <__reset+0xfb10ed64>
8112f2bc:	1021883a 	mov	r16,r2
8112f2c0:	0011883a 	mov	r8,zero
8112f2c4:	0005883a 	mov	r2,zero
8112f2c8:	003f0f06 	br	8112ef08 <__reset+0xfb10ef08>
8112f2cc:	217ff804 	addi	r5,r4,-32
8112f2d0:	00800804 	movi	r2,32
8112f2d4:	494ad83a 	srl	r5,r9,r5
8112f2d8:	20807d26 	beq	r4,r2,8112f4d0 <__adddf3+0x7f0>
8112f2dc:	00801004 	movi	r2,64
8112f2e0:	1109c83a 	sub	r4,r2,r4
8112f2e4:	4912983a 	sll	r9,r9,r4
8112f2e8:	498cb03a 	or	r6,r9,r6
8112f2ec:	300cc03a 	cmpne	r6,r6,zero
8112f2f0:	298ab03a 	or	r5,r5,r6
8112f2f4:	0013883a 	mov	r9,zero
8112f2f8:	003f1506 	br	8112ef50 <__reset+0xfb10ef50>
8112f2fc:	0101ffc4 	movi	r4,2047
8112f300:	113f9a1e 	bne	r2,r4,8112f16c <__reset+0xfb10f16c>
8112f304:	4811883a 	mov	r8,r9
8112f308:	3023883a 	mov	r17,r6
8112f30c:	1021883a 	mov	r16,r2
8112f310:	3825883a 	mov	r18,r7
8112f314:	003e9306 	br	8112ed64 <__reset+0xfb10ed64>
8112f318:	8000161e 	bne	r16,zero,8112f374 <__adddf3+0x694>
8112f31c:	444ab03a 	or	r5,r8,r17
8112f320:	28005126 	beq	r5,zero,8112f468 <__adddf3+0x788>
8112f324:	0108303a 	nor	r4,zero,r4
8112f328:	20004d1e 	bne	r4,zero,8112f460 <__adddf3+0x780>
8112f32c:	89a3883a 	add	r17,r17,r6
8112f330:	4253883a 	add	r9,r8,r9
8112f334:	898d803a 	cmpltu	r6,r17,r6
8112f338:	3251883a 	add	r8,r6,r9
8112f33c:	1021883a 	mov	r16,r2
8112f340:	003f0806 	br	8112ef64 <__reset+0xfb10ef64>
8112f344:	1000301e 	bne	r2,zero,8112f408 <__adddf3+0x728>
8112f348:	4984b03a 	or	r2,r9,r6
8112f34c:	10007126 	beq	r2,zero,8112f514 <__adddf3+0x834>
8112f350:	4811883a 	mov	r8,r9
8112f354:	3023883a 	mov	r17,r6
8112f358:	3825883a 	mov	r18,r7
8112f35c:	0401ffc4 	movi	r16,2047
8112f360:	003e8006 	br	8112ed64 <__reset+0xfb10ed64>
8112f364:	4462b03a 	or	r17,r8,r17
8112f368:	8822c03a 	cmpne	r17,r17,zero
8112f36c:	0007883a 	mov	r3,zero
8112f370:	003f8b06 	br	8112f1a0 <__reset+0xfb10f1a0>
8112f374:	0141ffc4 	movi	r5,2047
8112f378:	11403b26 	beq	r2,r5,8112f468 <__adddf3+0x788>
8112f37c:	0109c83a 	sub	r4,zero,r4
8112f380:	42002034 	orhi	r8,r8,128
8112f384:	01400e04 	movi	r5,56
8112f388:	29006716 	blt	r5,r4,8112f528 <__adddf3+0x848>
8112f38c:	014007c4 	movi	r5,31
8112f390:	29007016 	blt	r5,r4,8112f554 <__adddf3+0x874>
8112f394:	01400804 	movi	r5,32
8112f398:	290bc83a 	sub	r5,r5,r4
8112f39c:	4154983a 	sll	r10,r8,r5
8112f3a0:	890ed83a 	srl	r7,r17,r4
8112f3a4:	894a983a 	sll	r5,r17,r5
8112f3a8:	4108d83a 	srl	r4,r8,r4
8112f3ac:	51e2b03a 	or	r17,r10,r7
8112f3b0:	280ac03a 	cmpne	r5,r5,zero
8112f3b4:	8962b03a 	or	r17,r17,r5
8112f3b8:	89a3883a 	add	r17,r17,r6
8112f3bc:	2253883a 	add	r9,r4,r9
8112f3c0:	898d803a 	cmpltu	r6,r17,r6
8112f3c4:	3251883a 	add	r8,r6,r9
8112f3c8:	1021883a 	mov	r16,r2
8112f3cc:	003ee506 	br	8112ef64 <__reset+0xfb10ef64>
8112f3d0:	4984b03a 	or	r2,r9,r6
8112f3d4:	103e6326 	beq	r2,zero,8112ed64 <__reset+0xfb10ed64>
8112f3d8:	8987c83a 	sub	r3,r17,r6
8112f3dc:	88c9803a 	cmpltu	r4,r17,r3
8112f3e0:	4245c83a 	sub	r2,r8,r9
8112f3e4:	1105c83a 	sub	r2,r2,r4
8112f3e8:	1100202c 	andhi	r4,r2,128
8112f3ec:	203ebb26 	beq	r4,zero,8112eedc <__reset+0xfb10eedc>
8112f3f0:	3463c83a 	sub	r17,r6,r17
8112f3f4:	4a07c83a 	sub	r3,r9,r8
8112f3f8:	344d803a 	cmpltu	r6,r6,r17
8112f3fc:	1991c83a 	sub	r8,r3,r6
8112f400:	3825883a 	mov	r18,r7
8112f404:	003e5706 	br	8112ed64 <__reset+0xfb10ed64>
8112f408:	4984b03a 	or	r2,r9,r6
8112f40c:	10002e26 	beq	r2,zero,8112f4c8 <__adddf3+0x7e8>
8112f410:	4004d0fa 	srli	r2,r8,3
8112f414:	8822d0fa 	srli	r17,r17,3
8112f418:	4010977a 	slli	r8,r8,29
8112f41c:	10c0022c 	andhi	r3,r2,8
8112f420:	4462b03a 	or	r17,r8,r17
8112f424:	18000826 	beq	r3,zero,8112f448 <__adddf3+0x768>
8112f428:	4808d0fa 	srli	r4,r9,3
8112f42c:	20c0022c 	andhi	r3,r4,8
8112f430:	1800051e 	bne	r3,zero,8112f448 <__adddf3+0x768>
8112f434:	300cd0fa 	srli	r6,r6,3
8112f438:	4806977a 	slli	r3,r9,29
8112f43c:	2005883a 	mov	r2,r4
8112f440:	3825883a 	mov	r18,r7
8112f444:	19a2b03a 	or	r17,r3,r6
8112f448:	8810d77a 	srli	r8,r17,29
8112f44c:	100490fa 	slli	r2,r2,3
8112f450:	882290fa 	slli	r17,r17,3
8112f454:	0401ffc4 	movi	r16,2047
8112f458:	4090b03a 	or	r8,r8,r2
8112f45c:	003e4106 	br	8112ed64 <__reset+0xfb10ed64>
8112f460:	0141ffc4 	movi	r5,2047
8112f464:	117fc71e 	bne	r2,r5,8112f384 <__reset+0xfb10f384>
8112f468:	4811883a 	mov	r8,r9
8112f46c:	3023883a 	mov	r17,r6
8112f470:	1021883a 	mov	r16,r2
8112f474:	003e3b06 	br	8112ed64 <__reset+0xfb10ed64>
8112f478:	10002f26 	beq	r2,zero,8112f538 <__adddf3+0x858>
8112f47c:	4984b03a 	or	r2,r9,r6
8112f480:	10001126 	beq	r2,zero,8112f4c8 <__adddf3+0x7e8>
8112f484:	4004d0fa 	srli	r2,r8,3
8112f488:	8822d0fa 	srli	r17,r17,3
8112f48c:	4010977a 	slli	r8,r8,29
8112f490:	10c0022c 	andhi	r3,r2,8
8112f494:	4462b03a 	or	r17,r8,r17
8112f498:	183feb26 	beq	r3,zero,8112f448 <__reset+0xfb10f448>
8112f49c:	4808d0fa 	srli	r4,r9,3
8112f4a0:	20c0022c 	andhi	r3,r4,8
8112f4a4:	183fe81e 	bne	r3,zero,8112f448 <__reset+0xfb10f448>
8112f4a8:	300cd0fa 	srli	r6,r6,3
8112f4ac:	4806977a 	slli	r3,r9,29
8112f4b0:	2005883a 	mov	r2,r4
8112f4b4:	19a2b03a 	or	r17,r3,r6
8112f4b8:	003fe306 	br	8112f448 <__reset+0xfb10f448>
8112f4bc:	0011883a 	mov	r8,zero
8112f4c0:	0005883a 	mov	r2,zero
8112f4c4:	003e3f06 	br	8112edc4 <__reset+0xfb10edc4>
8112f4c8:	0401ffc4 	movi	r16,2047
8112f4cc:	003e2506 	br	8112ed64 <__reset+0xfb10ed64>
8112f4d0:	0013883a 	mov	r9,zero
8112f4d4:	003f8406 	br	8112f2e8 <__reset+0xfb10f2e8>
8112f4d8:	0005883a 	mov	r2,zero
8112f4dc:	0007883a 	mov	r3,zero
8112f4e0:	003e8906 	br	8112ef08 <__reset+0xfb10ef08>
8112f4e4:	197ff804 	addi	r5,r3,-32
8112f4e8:	01000804 	movi	r4,32
8112f4ec:	414ad83a 	srl	r5,r8,r5
8112f4f0:	19002426 	beq	r3,r4,8112f584 <__adddf3+0x8a4>
8112f4f4:	01001004 	movi	r4,64
8112f4f8:	20c7c83a 	sub	r3,r4,r3
8112f4fc:	40c6983a 	sll	r3,r8,r3
8112f500:	1c46b03a 	or	r3,r3,r17
8112f504:	1806c03a 	cmpne	r3,r3,zero
8112f508:	28e2b03a 	or	r17,r5,r3
8112f50c:	0007883a 	mov	r3,zero
8112f510:	003f2306 	br	8112f1a0 <__reset+0xfb10f1a0>
8112f514:	0007883a 	mov	r3,zero
8112f518:	5811883a 	mov	r8,r11
8112f51c:	00bfffc4 	movi	r2,-1
8112f520:	0401ffc4 	movi	r16,2047
8112f524:	003e7806 	br	8112ef08 <__reset+0xfb10ef08>
8112f528:	4462b03a 	or	r17,r8,r17
8112f52c:	8822c03a 	cmpne	r17,r17,zero
8112f530:	0009883a 	mov	r4,zero
8112f534:	003fa006 	br	8112f3b8 <__reset+0xfb10f3b8>
8112f538:	4811883a 	mov	r8,r9
8112f53c:	3023883a 	mov	r17,r6
8112f540:	0401ffc4 	movi	r16,2047
8112f544:	003e0706 	br	8112ed64 <__reset+0xfb10ed64>
8112f548:	4811883a 	mov	r8,r9
8112f54c:	3023883a 	mov	r17,r6
8112f550:	003e0406 	br	8112ed64 <__reset+0xfb10ed64>
8112f554:	21fff804 	addi	r7,r4,-32
8112f558:	01400804 	movi	r5,32
8112f55c:	41ced83a 	srl	r7,r8,r7
8112f560:	21400a26 	beq	r4,r5,8112f58c <__adddf3+0x8ac>
8112f564:	01401004 	movi	r5,64
8112f568:	2909c83a 	sub	r4,r5,r4
8112f56c:	4108983a 	sll	r4,r8,r4
8112f570:	2448b03a 	or	r4,r4,r17
8112f574:	2008c03a 	cmpne	r4,r4,zero
8112f578:	3922b03a 	or	r17,r7,r4
8112f57c:	0009883a 	mov	r4,zero
8112f580:	003f8d06 	br	8112f3b8 <__reset+0xfb10f3b8>
8112f584:	0007883a 	mov	r3,zero
8112f588:	003fdd06 	br	8112f500 <__reset+0xfb10f500>
8112f58c:	0009883a 	mov	r4,zero
8112f590:	003ff706 	br	8112f570 <__reset+0xfb10f570>

8112f594 <__divdf3>:
8112f594:	defff204 	addi	sp,sp,-56
8112f598:	de00012e 	bgeu	sp,et,8112f5a0 <__divdf3+0xc>
8112f59c:	003b68fa 	trap	3
8112f5a0:	dd400915 	stw	r21,36(sp)
8112f5a4:	282ad53a 	srli	r21,r5,20
8112f5a8:	dd000815 	stw	r20,32(sp)
8112f5ac:	2828d7fa 	srli	r20,r5,31
8112f5b0:	dc000415 	stw	r16,16(sp)
8112f5b4:	04000434 	movhi	r16,16
8112f5b8:	df000c15 	stw	fp,48(sp)
8112f5bc:	843fffc4 	addi	r16,r16,-1
8112f5c0:	dfc00d15 	stw	ra,52(sp)
8112f5c4:	ddc00b15 	stw	r23,44(sp)
8112f5c8:	dd800a15 	stw	r22,40(sp)
8112f5cc:	dcc00715 	stw	r19,28(sp)
8112f5d0:	dc800615 	stw	r18,24(sp)
8112f5d4:	dc400515 	stw	r17,20(sp)
8112f5d8:	ad41ffcc 	andi	r21,r21,2047
8112f5dc:	2c20703a 	and	r16,r5,r16
8112f5e0:	a7003fcc 	andi	fp,r20,255
8112f5e4:	a8006126 	beq	r21,zero,8112f76c <__divdf3+0x1d8>
8112f5e8:	0081ffc4 	movi	r2,2047
8112f5ec:	2025883a 	mov	r18,r4
8112f5f0:	a8803726 	beq	r21,r2,8112f6d0 <__divdf3+0x13c>
8112f5f4:	80800434 	orhi	r2,r16,16
8112f5f8:	100490fa 	slli	r2,r2,3
8112f5fc:	2020d77a 	srli	r16,r4,29
8112f600:	202490fa 	slli	r18,r4,3
8112f604:	ad7f0044 	addi	r21,r21,-1023
8112f608:	80a0b03a 	or	r16,r16,r2
8112f60c:	0027883a 	mov	r19,zero
8112f610:	0013883a 	mov	r9,zero
8112f614:	3804d53a 	srli	r2,r7,20
8112f618:	382cd7fa 	srli	r22,r7,31
8112f61c:	04400434 	movhi	r17,16
8112f620:	8c7fffc4 	addi	r17,r17,-1
8112f624:	1081ffcc 	andi	r2,r2,2047
8112f628:	3011883a 	mov	r8,r6
8112f62c:	3c62703a 	and	r17,r7,r17
8112f630:	b5c03fcc 	andi	r23,r22,255
8112f634:	10006c26 	beq	r2,zero,8112f7e8 <__divdf3+0x254>
8112f638:	00c1ffc4 	movi	r3,2047
8112f63c:	10c06426 	beq	r2,r3,8112f7d0 <__divdf3+0x23c>
8112f640:	88c00434 	orhi	r3,r17,16
8112f644:	180690fa 	slli	r3,r3,3
8112f648:	3022d77a 	srli	r17,r6,29
8112f64c:	301090fa 	slli	r8,r6,3
8112f650:	10bf0044 	addi	r2,r2,-1023
8112f654:	88e2b03a 	or	r17,r17,r3
8112f658:	000f883a 	mov	r7,zero
8112f65c:	a58cf03a 	xor	r6,r20,r22
8112f660:	3cc8b03a 	or	r4,r7,r19
8112f664:	a8abc83a 	sub	r21,r21,r2
8112f668:	008003c4 	movi	r2,15
8112f66c:	3007883a 	mov	r3,r6
8112f670:	34c03fcc 	andi	r19,r6,255
8112f674:	11009036 	bltu	r2,r4,8112f8b8 <__divdf3+0x324>
8112f678:	200890ba 	slli	r4,r4,2
8112f67c:	00a044f4 	movhi	r2,33043
8112f680:	10bda404 	addi	r2,r2,-2416
8112f684:	2089883a 	add	r4,r4,r2
8112f688:	20800017 	ldw	r2,0(r4)
8112f68c:	1000683a 	jmp	r2
8112f690:	8112f8b8 	rdprs	r4,r16,19426
8112f694:	8112f708 	cmpgei	r4,r16,19420
8112f698:	8112f8a8 	cmpgeui	r4,r16,19426
8112f69c:	8112f6fc 	xorhi	r4,r16,19419
8112f6a0:	8112f8a8 	cmpgeui	r4,r16,19426
8112f6a4:	8112f87c 	xorhi	r4,r16,19425
8112f6a8:	8112f8a8 	cmpgeui	r4,r16,19426
8112f6ac:	8112f6fc 	xorhi	r4,r16,19419
8112f6b0:	8112f708 	cmpgei	r4,r16,19420
8112f6b4:	8112f708 	cmpgei	r4,r16,19420
8112f6b8:	8112f87c 	xorhi	r4,r16,19425
8112f6bc:	8112f6fc 	xorhi	r4,r16,19419
8112f6c0:	8112f6ec 	andhi	r4,r16,19419
8112f6c4:	8112f6ec 	andhi	r4,r16,19419
8112f6c8:	8112f6ec 	andhi	r4,r16,19419
8112f6cc:	8112fb9c 	xori	r4,r16,19438
8112f6d0:	2404b03a 	or	r2,r4,r16
8112f6d4:	1000661e 	bne	r2,zero,8112f870 <__divdf3+0x2dc>
8112f6d8:	04c00204 	movi	r19,8
8112f6dc:	0021883a 	mov	r16,zero
8112f6e0:	0025883a 	mov	r18,zero
8112f6e4:	02400084 	movi	r9,2
8112f6e8:	003fca06 	br	8112f614 <__reset+0xfb10f614>
8112f6ec:	8023883a 	mov	r17,r16
8112f6f0:	9011883a 	mov	r8,r18
8112f6f4:	e02f883a 	mov	r23,fp
8112f6f8:	480f883a 	mov	r7,r9
8112f6fc:	00800084 	movi	r2,2
8112f700:	3881311e 	bne	r7,r2,8112fbc8 <__divdf3+0x634>
8112f704:	b827883a 	mov	r19,r23
8112f708:	98c0004c 	andi	r3,r19,1
8112f70c:	0081ffc4 	movi	r2,2047
8112f710:	000b883a 	mov	r5,zero
8112f714:	0025883a 	mov	r18,zero
8112f718:	1004953a 	slli	r2,r2,20
8112f71c:	18c03fcc 	andi	r3,r3,255
8112f720:	04400434 	movhi	r17,16
8112f724:	8c7fffc4 	addi	r17,r17,-1
8112f728:	180697fa 	slli	r3,r3,31
8112f72c:	2c4a703a 	and	r5,r5,r17
8112f730:	288ab03a 	or	r5,r5,r2
8112f734:	28c6b03a 	or	r3,r5,r3
8112f738:	9005883a 	mov	r2,r18
8112f73c:	dfc00d17 	ldw	ra,52(sp)
8112f740:	df000c17 	ldw	fp,48(sp)
8112f744:	ddc00b17 	ldw	r23,44(sp)
8112f748:	dd800a17 	ldw	r22,40(sp)
8112f74c:	dd400917 	ldw	r21,36(sp)
8112f750:	dd000817 	ldw	r20,32(sp)
8112f754:	dcc00717 	ldw	r19,28(sp)
8112f758:	dc800617 	ldw	r18,24(sp)
8112f75c:	dc400517 	ldw	r17,20(sp)
8112f760:	dc000417 	ldw	r16,16(sp)
8112f764:	dec00e04 	addi	sp,sp,56
8112f768:	f800283a 	ret
8112f76c:	2404b03a 	or	r2,r4,r16
8112f770:	2027883a 	mov	r19,r4
8112f774:	10003926 	beq	r2,zero,8112f85c <__divdf3+0x2c8>
8112f778:	80012e26 	beq	r16,zero,8112fc34 <__divdf3+0x6a0>
8112f77c:	8009883a 	mov	r4,r16
8112f780:	d9800315 	stw	r6,12(sp)
8112f784:	d9c00215 	stw	r7,8(sp)
8112f788:	111b1d00 	call	8111b1d0 <__clzsi2>
8112f78c:	d9800317 	ldw	r6,12(sp)
8112f790:	d9c00217 	ldw	r7,8(sp)
8112f794:	113ffd44 	addi	r4,r2,-11
8112f798:	00c00704 	movi	r3,28
8112f79c:	19012116 	blt	r3,r4,8112fc24 <__divdf3+0x690>
8112f7a0:	00c00744 	movi	r3,29
8112f7a4:	147ffe04 	addi	r17,r2,-8
8112f7a8:	1907c83a 	sub	r3,r3,r4
8112f7ac:	8460983a 	sll	r16,r16,r17
8112f7b0:	98c6d83a 	srl	r3,r19,r3
8112f7b4:	9c64983a 	sll	r18,r19,r17
8112f7b8:	1c20b03a 	or	r16,r3,r16
8112f7bc:	1080fcc4 	addi	r2,r2,1011
8112f7c0:	00abc83a 	sub	r21,zero,r2
8112f7c4:	0027883a 	mov	r19,zero
8112f7c8:	0013883a 	mov	r9,zero
8112f7cc:	003f9106 	br	8112f614 <__reset+0xfb10f614>
8112f7d0:	3446b03a 	or	r3,r6,r17
8112f7d4:	18001f1e 	bne	r3,zero,8112f854 <__divdf3+0x2c0>
8112f7d8:	0023883a 	mov	r17,zero
8112f7dc:	0011883a 	mov	r8,zero
8112f7e0:	01c00084 	movi	r7,2
8112f7e4:	003f9d06 	br	8112f65c <__reset+0xfb10f65c>
8112f7e8:	3446b03a 	or	r3,r6,r17
8112f7ec:	18001526 	beq	r3,zero,8112f844 <__divdf3+0x2b0>
8112f7f0:	88011b26 	beq	r17,zero,8112fc60 <__divdf3+0x6cc>
8112f7f4:	8809883a 	mov	r4,r17
8112f7f8:	d9800315 	stw	r6,12(sp)
8112f7fc:	da400115 	stw	r9,4(sp)
8112f800:	111b1d00 	call	8111b1d0 <__clzsi2>
8112f804:	d9800317 	ldw	r6,12(sp)
8112f808:	da400117 	ldw	r9,4(sp)
8112f80c:	113ffd44 	addi	r4,r2,-11
8112f810:	00c00704 	movi	r3,28
8112f814:	19010e16 	blt	r3,r4,8112fc50 <__divdf3+0x6bc>
8112f818:	00c00744 	movi	r3,29
8112f81c:	123ffe04 	addi	r8,r2,-8
8112f820:	1907c83a 	sub	r3,r3,r4
8112f824:	8a22983a 	sll	r17,r17,r8
8112f828:	30c6d83a 	srl	r3,r6,r3
8112f82c:	3210983a 	sll	r8,r6,r8
8112f830:	1c62b03a 	or	r17,r3,r17
8112f834:	1080fcc4 	addi	r2,r2,1011
8112f838:	0085c83a 	sub	r2,zero,r2
8112f83c:	000f883a 	mov	r7,zero
8112f840:	003f8606 	br	8112f65c <__reset+0xfb10f65c>
8112f844:	0023883a 	mov	r17,zero
8112f848:	0011883a 	mov	r8,zero
8112f84c:	01c00044 	movi	r7,1
8112f850:	003f8206 	br	8112f65c <__reset+0xfb10f65c>
8112f854:	01c000c4 	movi	r7,3
8112f858:	003f8006 	br	8112f65c <__reset+0xfb10f65c>
8112f85c:	04c00104 	movi	r19,4
8112f860:	0021883a 	mov	r16,zero
8112f864:	0025883a 	mov	r18,zero
8112f868:	02400044 	movi	r9,1
8112f86c:	003f6906 	br	8112f614 <__reset+0xfb10f614>
8112f870:	04c00304 	movi	r19,12
8112f874:	024000c4 	movi	r9,3
8112f878:	003f6606 	br	8112f614 <__reset+0xfb10f614>
8112f87c:	01400434 	movhi	r5,16
8112f880:	0007883a 	mov	r3,zero
8112f884:	297fffc4 	addi	r5,r5,-1
8112f888:	04bfffc4 	movi	r18,-1
8112f88c:	0081ffc4 	movi	r2,2047
8112f890:	003fa106 	br	8112f718 <__reset+0xfb10f718>
8112f894:	00c00044 	movi	r3,1
8112f898:	1887c83a 	sub	r3,r3,r2
8112f89c:	01000e04 	movi	r4,56
8112f8a0:	20c1210e 	bge	r4,r3,8112fd28 <__divdf3+0x794>
8112f8a4:	98c0004c 	andi	r3,r19,1
8112f8a8:	0005883a 	mov	r2,zero
8112f8ac:	000b883a 	mov	r5,zero
8112f8b0:	0025883a 	mov	r18,zero
8112f8b4:	003f9806 	br	8112f718 <__reset+0xfb10f718>
8112f8b8:	8c00fd36 	bltu	r17,r16,8112fcb0 <__divdf3+0x71c>
8112f8bc:	8440fb26 	beq	r16,r17,8112fcac <__divdf3+0x718>
8112f8c0:	8007883a 	mov	r3,r16
8112f8c4:	ad7fffc4 	addi	r21,r21,-1
8112f8c8:	0021883a 	mov	r16,zero
8112f8cc:	4004d63a 	srli	r2,r8,24
8112f8d0:	8822923a 	slli	r17,r17,8
8112f8d4:	1809883a 	mov	r4,r3
8112f8d8:	402c923a 	slli	r22,r8,8
8112f8dc:	88b8b03a 	or	fp,r17,r2
8112f8e0:	e028d43a 	srli	r20,fp,16
8112f8e4:	d8c00015 	stw	r3,0(sp)
8112f8e8:	e5ffffcc 	andi	r23,fp,65535
8112f8ec:	a00b883a 	mov	r5,r20
8112f8f0:	112ea280 	call	8112ea28 <__udivsi3>
8112f8f4:	d8c00017 	ldw	r3,0(sp)
8112f8f8:	a00b883a 	mov	r5,r20
8112f8fc:	d8800315 	stw	r2,12(sp)
8112f900:	1809883a 	mov	r4,r3
8112f904:	112ea8c0 	call	8112ea8c <__umodsi3>
8112f908:	d9800317 	ldw	r6,12(sp)
8112f90c:	1006943a 	slli	r3,r2,16
8112f910:	9004d43a 	srli	r2,r18,16
8112f914:	b9a3383a 	mul	r17,r23,r6
8112f918:	10c4b03a 	or	r2,r2,r3
8112f91c:	1440062e 	bgeu	r2,r17,8112f938 <__divdf3+0x3a4>
8112f920:	1705883a 	add	r2,r2,fp
8112f924:	30ffffc4 	addi	r3,r6,-1
8112f928:	1700ee36 	bltu	r2,fp,8112fce4 <__divdf3+0x750>
8112f92c:	1440ed2e 	bgeu	r2,r17,8112fce4 <__divdf3+0x750>
8112f930:	31bfff84 	addi	r6,r6,-2
8112f934:	1705883a 	add	r2,r2,fp
8112f938:	1463c83a 	sub	r17,r2,r17
8112f93c:	a00b883a 	mov	r5,r20
8112f940:	8809883a 	mov	r4,r17
8112f944:	d9800315 	stw	r6,12(sp)
8112f948:	112ea280 	call	8112ea28 <__udivsi3>
8112f94c:	a00b883a 	mov	r5,r20
8112f950:	8809883a 	mov	r4,r17
8112f954:	d8800215 	stw	r2,8(sp)
8112f958:	112ea8c0 	call	8112ea8c <__umodsi3>
8112f95c:	d9c00217 	ldw	r7,8(sp)
8112f960:	1004943a 	slli	r2,r2,16
8112f964:	94bfffcc 	andi	r18,r18,65535
8112f968:	b9d1383a 	mul	r8,r23,r7
8112f96c:	90a4b03a 	or	r18,r18,r2
8112f970:	d9800317 	ldw	r6,12(sp)
8112f974:	9200062e 	bgeu	r18,r8,8112f990 <__divdf3+0x3fc>
8112f978:	9725883a 	add	r18,r18,fp
8112f97c:	38bfffc4 	addi	r2,r7,-1
8112f980:	9700d636 	bltu	r18,fp,8112fcdc <__divdf3+0x748>
8112f984:	9200d52e 	bgeu	r18,r8,8112fcdc <__divdf3+0x748>
8112f988:	39ffff84 	addi	r7,r7,-2
8112f98c:	9725883a 	add	r18,r18,fp
8112f990:	3004943a 	slli	r2,r6,16
8112f994:	b012d43a 	srli	r9,r22,16
8112f998:	b1bfffcc 	andi	r6,r22,65535
8112f99c:	11e2b03a 	or	r17,r2,r7
8112f9a0:	8806d43a 	srli	r3,r17,16
8112f9a4:	893fffcc 	andi	r4,r17,65535
8112f9a8:	218b383a 	mul	r5,r4,r6
8112f9ac:	30c5383a 	mul	r2,r6,r3
8112f9b0:	2249383a 	mul	r4,r4,r9
8112f9b4:	280ed43a 	srli	r7,r5,16
8112f9b8:	9225c83a 	sub	r18,r18,r8
8112f9bc:	2089883a 	add	r4,r4,r2
8112f9c0:	3909883a 	add	r4,r7,r4
8112f9c4:	1a47383a 	mul	r3,r3,r9
8112f9c8:	2080022e 	bgeu	r4,r2,8112f9d4 <__divdf3+0x440>
8112f9cc:	00800074 	movhi	r2,1
8112f9d0:	1887883a 	add	r3,r3,r2
8112f9d4:	2004d43a 	srli	r2,r4,16
8112f9d8:	2008943a 	slli	r4,r4,16
8112f9dc:	297fffcc 	andi	r5,r5,65535
8112f9e0:	10c7883a 	add	r3,r2,r3
8112f9e4:	2149883a 	add	r4,r4,r5
8112f9e8:	90c0a536 	bltu	r18,r3,8112fc80 <__divdf3+0x6ec>
8112f9ec:	90c0bf26 	beq	r18,r3,8112fcec <__divdf3+0x758>
8112f9f0:	90c7c83a 	sub	r3,r18,r3
8112f9f4:	810fc83a 	sub	r7,r16,r4
8112f9f8:	81e5803a 	cmpltu	r18,r16,r7
8112f9fc:	1ca5c83a 	sub	r18,r3,r18
8112fa00:	e480c126 	beq	fp,r18,8112fd08 <__divdf3+0x774>
8112fa04:	a00b883a 	mov	r5,r20
8112fa08:	9009883a 	mov	r4,r18
8112fa0c:	d9800315 	stw	r6,12(sp)
8112fa10:	d9c00215 	stw	r7,8(sp)
8112fa14:	da400115 	stw	r9,4(sp)
8112fa18:	112ea280 	call	8112ea28 <__udivsi3>
8112fa1c:	a00b883a 	mov	r5,r20
8112fa20:	9009883a 	mov	r4,r18
8112fa24:	d8800015 	stw	r2,0(sp)
8112fa28:	112ea8c0 	call	8112ea8c <__umodsi3>
8112fa2c:	d9c00217 	ldw	r7,8(sp)
8112fa30:	da000017 	ldw	r8,0(sp)
8112fa34:	1006943a 	slli	r3,r2,16
8112fa38:	3804d43a 	srli	r2,r7,16
8112fa3c:	ba21383a 	mul	r16,r23,r8
8112fa40:	d9800317 	ldw	r6,12(sp)
8112fa44:	10c4b03a 	or	r2,r2,r3
8112fa48:	da400117 	ldw	r9,4(sp)
8112fa4c:	1400062e 	bgeu	r2,r16,8112fa68 <__divdf3+0x4d4>
8112fa50:	1705883a 	add	r2,r2,fp
8112fa54:	40ffffc4 	addi	r3,r8,-1
8112fa58:	1700ad36 	bltu	r2,fp,8112fd10 <__divdf3+0x77c>
8112fa5c:	1400ac2e 	bgeu	r2,r16,8112fd10 <__divdf3+0x77c>
8112fa60:	423fff84 	addi	r8,r8,-2
8112fa64:	1705883a 	add	r2,r2,fp
8112fa68:	1421c83a 	sub	r16,r2,r16
8112fa6c:	a00b883a 	mov	r5,r20
8112fa70:	8009883a 	mov	r4,r16
8112fa74:	d9800315 	stw	r6,12(sp)
8112fa78:	d9c00215 	stw	r7,8(sp)
8112fa7c:	da000015 	stw	r8,0(sp)
8112fa80:	da400115 	stw	r9,4(sp)
8112fa84:	112ea280 	call	8112ea28 <__udivsi3>
8112fa88:	8009883a 	mov	r4,r16
8112fa8c:	a00b883a 	mov	r5,r20
8112fa90:	1025883a 	mov	r18,r2
8112fa94:	112ea8c0 	call	8112ea8c <__umodsi3>
8112fa98:	d9c00217 	ldw	r7,8(sp)
8112fa9c:	1004943a 	slli	r2,r2,16
8112faa0:	bcaf383a 	mul	r23,r23,r18
8112faa4:	393fffcc 	andi	r4,r7,65535
8112faa8:	2088b03a 	or	r4,r4,r2
8112faac:	d9800317 	ldw	r6,12(sp)
8112fab0:	da000017 	ldw	r8,0(sp)
8112fab4:	da400117 	ldw	r9,4(sp)
8112fab8:	25c0062e 	bgeu	r4,r23,8112fad4 <__divdf3+0x540>
8112fabc:	2709883a 	add	r4,r4,fp
8112fac0:	90bfffc4 	addi	r2,r18,-1
8112fac4:	27009436 	bltu	r4,fp,8112fd18 <__divdf3+0x784>
8112fac8:	25c0932e 	bgeu	r4,r23,8112fd18 <__divdf3+0x784>
8112facc:	94bfff84 	addi	r18,r18,-2
8112fad0:	2709883a 	add	r4,r4,fp
8112fad4:	4004943a 	slli	r2,r8,16
8112fad8:	25efc83a 	sub	r23,r4,r23
8112fadc:	1490b03a 	or	r8,r2,r18
8112fae0:	4008d43a 	srli	r4,r8,16
8112fae4:	40ffffcc 	andi	r3,r8,65535
8112fae8:	30c5383a 	mul	r2,r6,r3
8112faec:	1a47383a 	mul	r3,r3,r9
8112faf0:	310d383a 	mul	r6,r6,r4
8112faf4:	100ad43a 	srli	r5,r2,16
8112faf8:	4913383a 	mul	r9,r9,r4
8112fafc:	1987883a 	add	r3,r3,r6
8112fb00:	28c7883a 	add	r3,r5,r3
8112fb04:	1980022e 	bgeu	r3,r6,8112fb10 <__divdf3+0x57c>
8112fb08:	01000074 	movhi	r4,1
8112fb0c:	4913883a 	add	r9,r9,r4
8112fb10:	1808d43a 	srli	r4,r3,16
8112fb14:	1806943a 	slli	r3,r3,16
8112fb18:	10bfffcc 	andi	r2,r2,65535
8112fb1c:	2253883a 	add	r9,r4,r9
8112fb20:	1887883a 	add	r3,r3,r2
8112fb24:	ba403836 	bltu	r23,r9,8112fc08 <__divdf3+0x674>
8112fb28:	ba403626 	beq	r23,r9,8112fc04 <__divdf3+0x670>
8112fb2c:	42000054 	ori	r8,r8,1
8112fb30:	a880ffc4 	addi	r2,r21,1023
8112fb34:	00bf570e 	bge	zero,r2,8112f894 <__reset+0xfb10f894>
8112fb38:	40c001cc 	andi	r3,r8,7
8112fb3c:	18000726 	beq	r3,zero,8112fb5c <__divdf3+0x5c8>
8112fb40:	40c003cc 	andi	r3,r8,15
8112fb44:	01000104 	movi	r4,4
8112fb48:	19000426 	beq	r3,r4,8112fb5c <__divdf3+0x5c8>
8112fb4c:	4107883a 	add	r3,r8,r4
8112fb50:	1a11803a 	cmpltu	r8,r3,r8
8112fb54:	8a23883a 	add	r17,r17,r8
8112fb58:	1811883a 	mov	r8,r3
8112fb5c:	88c0402c 	andhi	r3,r17,256
8112fb60:	18000426 	beq	r3,zero,8112fb74 <__divdf3+0x5e0>
8112fb64:	00ffc034 	movhi	r3,65280
8112fb68:	18ffffc4 	addi	r3,r3,-1
8112fb6c:	a8810004 	addi	r2,r21,1024
8112fb70:	88e2703a 	and	r17,r17,r3
8112fb74:	00c1ff84 	movi	r3,2046
8112fb78:	18bee316 	blt	r3,r2,8112f708 <__reset+0xfb10f708>
8112fb7c:	8824977a 	slli	r18,r17,29
8112fb80:	4010d0fa 	srli	r8,r8,3
8112fb84:	8822927a 	slli	r17,r17,9
8112fb88:	1081ffcc 	andi	r2,r2,2047
8112fb8c:	9224b03a 	or	r18,r18,r8
8112fb90:	880ad33a 	srli	r5,r17,12
8112fb94:	98c0004c 	andi	r3,r19,1
8112fb98:	003edf06 	br	8112f718 <__reset+0xfb10f718>
8112fb9c:	8080022c 	andhi	r2,r16,8
8112fba0:	10001226 	beq	r2,zero,8112fbec <__divdf3+0x658>
8112fba4:	8880022c 	andhi	r2,r17,8
8112fba8:	1000101e 	bne	r2,zero,8112fbec <__divdf3+0x658>
8112fbac:	00800434 	movhi	r2,16
8112fbb0:	89400234 	orhi	r5,r17,8
8112fbb4:	10bfffc4 	addi	r2,r2,-1
8112fbb8:	b007883a 	mov	r3,r22
8112fbbc:	288a703a 	and	r5,r5,r2
8112fbc0:	4025883a 	mov	r18,r8
8112fbc4:	003f3106 	br	8112f88c <__reset+0xfb10f88c>
8112fbc8:	008000c4 	movi	r2,3
8112fbcc:	3880a626 	beq	r7,r2,8112fe68 <__divdf3+0x8d4>
8112fbd0:	00800044 	movi	r2,1
8112fbd4:	3880521e 	bne	r7,r2,8112fd20 <__divdf3+0x78c>
8112fbd8:	b807883a 	mov	r3,r23
8112fbdc:	0005883a 	mov	r2,zero
8112fbe0:	000b883a 	mov	r5,zero
8112fbe4:	0025883a 	mov	r18,zero
8112fbe8:	003ecb06 	br	8112f718 <__reset+0xfb10f718>
8112fbec:	00800434 	movhi	r2,16
8112fbf0:	81400234 	orhi	r5,r16,8
8112fbf4:	10bfffc4 	addi	r2,r2,-1
8112fbf8:	a007883a 	mov	r3,r20
8112fbfc:	288a703a 	and	r5,r5,r2
8112fc00:	003f2206 	br	8112f88c <__reset+0xfb10f88c>
8112fc04:	183fca26 	beq	r3,zero,8112fb30 <__reset+0xfb10fb30>
8112fc08:	e5ef883a 	add	r23,fp,r23
8112fc0c:	40bfffc4 	addi	r2,r8,-1
8112fc10:	bf00392e 	bgeu	r23,fp,8112fcf8 <__divdf3+0x764>
8112fc14:	1011883a 	mov	r8,r2
8112fc18:	ba7fc41e 	bne	r23,r9,8112fb2c <__reset+0xfb10fb2c>
8112fc1c:	b0ffc31e 	bne	r22,r3,8112fb2c <__reset+0xfb10fb2c>
8112fc20:	003fc306 	br	8112fb30 <__reset+0xfb10fb30>
8112fc24:	143ff604 	addi	r16,r2,-40
8112fc28:	9c20983a 	sll	r16,r19,r16
8112fc2c:	0025883a 	mov	r18,zero
8112fc30:	003ee206 	br	8112f7bc <__reset+0xfb10f7bc>
8112fc34:	d9800315 	stw	r6,12(sp)
8112fc38:	d9c00215 	stw	r7,8(sp)
8112fc3c:	111b1d00 	call	8111b1d0 <__clzsi2>
8112fc40:	10800804 	addi	r2,r2,32
8112fc44:	d9c00217 	ldw	r7,8(sp)
8112fc48:	d9800317 	ldw	r6,12(sp)
8112fc4c:	003ed106 	br	8112f794 <__reset+0xfb10f794>
8112fc50:	147ff604 	addi	r17,r2,-40
8112fc54:	3462983a 	sll	r17,r6,r17
8112fc58:	0011883a 	mov	r8,zero
8112fc5c:	003ef506 	br	8112f834 <__reset+0xfb10f834>
8112fc60:	3009883a 	mov	r4,r6
8112fc64:	d9800315 	stw	r6,12(sp)
8112fc68:	da400115 	stw	r9,4(sp)
8112fc6c:	111b1d00 	call	8111b1d0 <__clzsi2>
8112fc70:	10800804 	addi	r2,r2,32
8112fc74:	da400117 	ldw	r9,4(sp)
8112fc78:	d9800317 	ldw	r6,12(sp)
8112fc7c:	003ee306 	br	8112f80c <__reset+0xfb10f80c>
8112fc80:	85a1883a 	add	r16,r16,r22
8112fc84:	8585803a 	cmpltu	r2,r16,r22
8112fc88:	1705883a 	add	r2,r2,fp
8112fc8c:	14a5883a 	add	r18,r2,r18
8112fc90:	88bfffc4 	addi	r2,r17,-1
8112fc94:	e4800c2e 	bgeu	fp,r18,8112fcc8 <__divdf3+0x734>
8112fc98:	90c03e36 	bltu	r18,r3,8112fd94 <__divdf3+0x800>
8112fc9c:	1c806926 	beq	r3,r18,8112fe44 <__divdf3+0x8b0>
8112fca0:	90c7c83a 	sub	r3,r18,r3
8112fca4:	1023883a 	mov	r17,r2
8112fca8:	003f5206 	br	8112f9f4 <__reset+0xfb10f9f4>
8112fcac:	923f0436 	bltu	r18,r8,8112f8c0 <__reset+0xfb10f8c0>
8112fcb0:	800897fa 	slli	r4,r16,31
8112fcb4:	9004d07a 	srli	r2,r18,1
8112fcb8:	8006d07a 	srli	r3,r16,1
8112fcbc:	902097fa 	slli	r16,r18,31
8112fcc0:	20a4b03a 	or	r18,r4,r2
8112fcc4:	003f0106 	br	8112f8cc <__reset+0xfb10f8cc>
8112fcc8:	e4bff51e 	bne	fp,r18,8112fca0 <__reset+0xfb10fca0>
8112fccc:	85bff22e 	bgeu	r16,r22,8112fc98 <__reset+0xfb10fc98>
8112fcd0:	e0c7c83a 	sub	r3,fp,r3
8112fcd4:	1023883a 	mov	r17,r2
8112fcd8:	003f4606 	br	8112f9f4 <__reset+0xfb10f9f4>
8112fcdc:	100f883a 	mov	r7,r2
8112fce0:	003f2b06 	br	8112f990 <__reset+0xfb10f990>
8112fce4:	180d883a 	mov	r6,r3
8112fce8:	003f1306 	br	8112f938 <__reset+0xfb10f938>
8112fcec:	813fe436 	bltu	r16,r4,8112fc80 <__reset+0xfb10fc80>
8112fcf0:	0007883a 	mov	r3,zero
8112fcf4:	003f3f06 	br	8112f9f4 <__reset+0xfb10f9f4>
8112fcf8:	ba402c36 	bltu	r23,r9,8112fdac <__divdf3+0x818>
8112fcfc:	4dc05426 	beq	r9,r23,8112fe50 <__divdf3+0x8bc>
8112fd00:	1011883a 	mov	r8,r2
8112fd04:	003f8906 	br	8112fb2c <__reset+0xfb10fb2c>
8112fd08:	023fffc4 	movi	r8,-1
8112fd0c:	003f8806 	br	8112fb30 <__reset+0xfb10fb30>
8112fd10:	1811883a 	mov	r8,r3
8112fd14:	003f5406 	br	8112fa68 <__reset+0xfb10fa68>
8112fd18:	1025883a 	mov	r18,r2
8112fd1c:	003f6d06 	br	8112fad4 <__reset+0xfb10fad4>
8112fd20:	b827883a 	mov	r19,r23
8112fd24:	003f8206 	br	8112fb30 <__reset+0xfb10fb30>
8112fd28:	010007c4 	movi	r4,31
8112fd2c:	20c02616 	blt	r4,r3,8112fdc8 <__divdf3+0x834>
8112fd30:	00800804 	movi	r2,32
8112fd34:	10c5c83a 	sub	r2,r2,r3
8112fd38:	888a983a 	sll	r5,r17,r2
8112fd3c:	40c8d83a 	srl	r4,r8,r3
8112fd40:	4084983a 	sll	r2,r8,r2
8112fd44:	88e2d83a 	srl	r17,r17,r3
8112fd48:	2906b03a 	or	r3,r5,r4
8112fd4c:	1004c03a 	cmpne	r2,r2,zero
8112fd50:	1886b03a 	or	r3,r3,r2
8112fd54:	188001cc 	andi	r2,r3,7
8112fd58:	10000726 	beq	r2,zero,8112fd78 <__divdf3+0x7e4>
8112fd5c:	188003cc 	andi	r2,r3,15
8112fd60:	01000104 	movi	r4,4
8112fd64:	11000426 	beq	r2,r4,8112fd78 <__divdf3+0x7e4>
8112fd68:	1805883a 	mov	r2,r3
8112fd6c:	10c00104 	addi	r3,r2,4
8112fd70:	1885803a 	cmpltu	r2,r3,r2
8112fd74:	88a3883a 	add	r17,r17,r2
8112fd78:	8880202c 	andhi	r2,r17,128
8112fd7c:	10002726 	beq	r2,zero,8112fe1c <__divdf3+0x888>
8112fd80:	98c0004c 	andi	r3,r19,1
8112fd84:	00800044 	movi	r2,1
8112fd88:	000b883a 	mov	r5,zero
8112fd8c:	0025883a 	mov	r18,zero
8112fd90:	003e6106 	br	8112f718 <__reset+0xfb10f718>
8112fd94:	85a1883a 	add	r16,r16,r22
8112fd98:	8585803a 	cmpltu	r2,r16,r22
8112fd9c:	1705883a 	add	r2,r2,fp
8112fda0:	14a5883a 	add	r18,r2,r18
8112fda4:	8c7fff84 	addi	r17,r17,-2
8112fda8:	003f1106 	br	8112f9f0 <__reset+0xfb10f9f0>
8112fdac:	b589883a 	add	r4,r22,r22
8112fdb0:	25ad803a 	cmpltu	r22,r4,r22
8112fdb4:	b739883a 	add	fp,r22,fp
8112fdb8:	40bfff84 	addi	r2,r8,-2
8112fdbc:	bf2f883a 	add	r23,r23,fp
8112fdc0:	202d883a 	mov	r22,r4
8112fdc4:	003f9306 	br	8112fc14 <__reset+0xfb10fc14>
8112fdc8:	013ff844 	movi	r4,-31
8112fdcc:	2085c83a 	sub	r2,r4,r2
8112fdd0:	8888d83a 	srl	r4,r17,r2
8112fdd4:	00800804 	movi	r2,32
8112fdd8:	18802126 	beq	r3,r2,8112fe60 <__divdf3+0x8cc>
8112fddc:	00801004 	movi	r2,64
8112fde0:	10c5c83a 	sub	r2,r2,r3
8112fde4:	8884983a 	sll	r2,r17,r2
8112fde8:	1204b03a 	or	r2,r2,r8
8112fdec:	1004c03a 	cmpne	r2,r2,zero
8112fdf0:	2084b03a 	or	r2,r4,r2
8112fdf4:	144001cc 	andi	r17,r2,7
8112fdf8:	88000d1e 	bne	r17,zero,8112fe30 <__divdf3+0x89c>
8112fdfc:	000b883a 	mov	r5,zero
8112fe00:	1024d0fa 	srli	r18,r2,3
8112fe04:	98c0004c 	andi	r3,r19,1
8112fe08:	0005883a 	mov	r2,zero
8112fe0c:	9464b03a 	or	r18,r18,r17
8112fe10:	003e4106 	br	8112f718 <__reset+0xfb10f718>
8112fe14:	1007883a 	mov	r3,r2
8112fe18:	0023883a 	mov	r17,zero
8112fe1c:	880a927a 	slli	r5,r17,9
8112fe20:	1805883a 	mov	r2,r3
8112fe24:	8822977a 	slli	r17,r17,29
8112fe28:	280ad33a 	srli	r5,r5,12
8112fe2c:	003ff406 	br	8112fe00 <__reset+0xfb10fe00>
8112fe30:	10c003cc 	andi	r3,r2,15
8112fe34:	01000104 	movi	r4,4
8112fe38:	193ff626 	beq	r3,r4,8112fe14 <__reset+0xfb10fe14>
8112fe3c:	0023883a 	mov	r17,zero
8112fe40:	003fca06 	br	8112fd6c <__reset+0xfb10fd6c>
8112fe44:	813fd336 	bltu	r16,r4,8112fd94 <__reset+0xfb10fd94>
8112fe48:	1023883a 	mov	r17,r2
8112fe4c:	003fa806 	br	8112fcf0 <__reset+0xfb10fcf0>
8112fe50:	b0ffd636 	bltu	r22,r3,8112fdac <__reset+0xfb10fdac>
8112fe54:	1011883a 	mov	r8,r2
8112fe58:	b0ff341e 	bne	r22,r3,8112fb2c <__reset+0xfb10fb2c>
8112fe5c:	003f3406 	br	8112fb30 <__reset+0xfb10fb30>
8112fe60:	0005883a 	mov	r2,zero
8112fe64:	003fe006 	br	8112fde8 <__reset+0xfb10fde8>
8112fe68:	00800434 	movhi	r2,16
8112fe6c:	89400234 	orhi	r5,r17,8
8112fe70:	10bfffc4 	addi	r2,r2,-1
8112fe74:	b807883a 	mov	r3,r23
8112fe78:	288a703a 	and	r5,r5,r2
8112fe7c:	4025883a 	mov	r18,r8
8112fe80:	003e8206 	br	8112f88c <__reset+0xfb10f88c>

8112fe84 <__eqdf2>:
8112fe84:	2804d53a 	srli	r2,r5,20
8112fe88:	3806d53a 	srli	r3,r7,20
8112fe8c:	02000434 	movhi	r8,16
8112fe90:	423fffc4 	addi	r8,r8,-1
8112fe94:	1081ffcc 	andi	r2,r2,2047
8112fe98:	0281ffc4 	movi	r10,2047
8112fe9c:	2a12703a 	and	r9,r5,r8
8112fea0:	18c1ffcc 	andi	r3,r3,2047
8112fea4:	3a10703a 	and	r8,r7,r8
8112fea8:	280ad7fa 	srli	r5,r5,31
8112feac:	380ed7fa 	srli	r7,r7,31
8112feb0:	12801026 	beq	r2,r10,8112fef4 <__eqdf2+0x70>
8112feb4:	0281ffc4 	movi	r10,2047
8112feb8:	1a800a26 	beq	r3,r10,8112fee4 <__eqdf2+0x60>
8112febc:	10c00226 	beq	r2,r3,8112fec8 <__eqdf2+0x44>
8112fec0:	00800044 	movi	r2,1
8112fec4:	f800283a 	ret
8112fec8:	4a3ffd1e 	bne	r9,r8,8112fec0 <__reset+0xfb10fec0>
8112fecc:	21bffc1e 	bne	r4,r6,8112fec0 <__reset+0xfb10fec0>
8112fed0:	29c00c26 	beq	r5,r7,8112ff04 <__eqdf2+0x80>
8112fed4:	103ffa1e 	bne	r2,zero,8112fec0 <__reset+0xfb10fec0>
8112fed8:	2244b03a 	or	r2,r4,r9
8112fedc:	1004c03a 	cmpne	r2,r2,zero
8112fee0:	f800283a 	ret
8112fee4:	3214b03a 	or	r10,r6,r8
8112fee8:	503ff426 	beq	r10,zero,8112febc <__reset+0xfb10febc>
8112feec:	00800044 	movi	r2,1
8112fef0:	f800283a 	ret
8112fef4:	2254b03a 	or	r10,r4,r9
8112fef8:	503fee26 	beq	r10,zero,8112feb4 <__reset+0xfb10feb4>
8112fefc:	00800044 	movi	r2,1
8112ff00:	f800283a 	ret
8112ff04:	0005883a 	mov	r2,zero
8112ff08:	f800283a 	ret

8112ff0c <__gedf2>:
8112ff0c:	2804d53a 	srli	r2,r5,20
8112ff10:	3806d53a 	srli	r3,r7,20
8112ff14:	02000434 	movhi	r8,16
8112ff18:	423fffc4 	addi	r8,r8,-1
8112ff1c:	1081ffcc 	andi	r2,r2,2047
8112ff20:	0241ffc4 	movi	r9,2047
8112ff24:	2a14703a 	and	r10,r5,r8
8112ff28:	18c1ffcc 	andi	r3,r3,2047
8112ff2c:	3a10703a 	and	r8,r7,r8
8112ff30:	280ad7fa 	srli	r5,r5,31
8112ff34:	380ed7fa 	srli	r7,r7,31
8112ff38:	12401d26 	beq	r2,r9,8112ffb0 <__gedf2+0xa4>
8112ff3c:	0241ffc4 	movi	r9,2047
8112ff40:	1a401226 	beq	r3,r9,8112ff8c <__gedf2+0x80>
8112ff44:	1000081e 	bne	r2,zero,8112ff68 <__gedf2+0x5c>
8112ff48:	2296b03a 	or	r11,r4,r10
8112ff4c:	5813003a 	cmpeq	r9,r11,zero
8112ff50:	1800091e 	bne	r3,zero,8112ff78 <__gedf2+0x6c>
8112ff54:	3218b03a 	or	r12,r6,r8
8112ff58:	6000071e 	bne	r12,zero,8112ff78 <__gedf2+0x6c>
8112ff5c:	0005883a 	mov	r2,zero
8112ff60:	5800101e 	bne	r11,zero,8112ffa4 <__gedf2+0x98>
8112ff64:	f800283a 	ret
8112ff68:	18000c1e 	bne	r3,zero,8112ff9c <__gedf2+0x90>
8112ff6c:	3212b03a 	or	r9,r6,r8
8112ff70:	48000c26 	beq	r9,zero,8112ffa4 <__gedf2+0x98>
8112ff74:	0013883a 	mov	r9,zero
8112ff78:	39c03fcc 	andi	r7,r7,255
8112ff7c:	48000826 	beq	r9,zero,8112ffa0 <__gedf2+0x94>
8112ff80:	38000926 	beq	r7,zero,8112ffa8 <__gedf2+0x9c>
8112ff84:	00800044 	movi	r2,1
8112ff88:	f800283a 	ret
8112ff8c:	3212b03a 	or	r9,r6,r8
8112ff90:	483fec26 	beq	r9,zero,8112ff44 <__reset+0xfb10ff44>
8112ff94:	00bfff84 	movi	r2,-2
8112ff98:	f800283a 	ret
8112ff9c:	39c03fcc 	andi	r7,r7,255
8112ffa0:	29c00626 	beq	r5,r7,8112ffbc <__gedf2+0xb0>
8112ffa4:	283ff726 	beq	r5,zero,8112ff84 <__reset+0xfb10ff84>
8112ffa8:	00bfffc4 	movi	r2,-1
8112ffac:	f800283a 	ret
8112ffb0:	2292b03a 	or	r9,r4,r10
8112ffb4:	483fe126 	beq	r9,zero,8112ff3c <__reset+0xfb10ff3c>
8112ffb8:	003ff606 	br	8112ff94 <__reset+0xfb10ff94>
8112ffbc:	18bff916 	blt	r3,r2,8112ffa4 <__reset+0xfb10ffa4>
8112ffc0:	10c00316 	blt	r2,r3,8112ffd0 <__gedf2+0xc4>
8112ffc4:	42bff736 	bltu	r8,r10,8112ffa4 <__reset+0xfb10ffa4>
8112ffc8:	52000326 	beq	r10,r8,8112ffd8 <__gedf2+0xcc>
8112ffcc:	5200042e 	bgeu	r10,r8,8112ffe0 <__gedf2+0xd4>
8112ffd0:	283fec1e 	bne	r5,zero,8112ff84 <__reset+0xfb10ff84>
8112ffd4:	003ff406 	br	8112ffa8 <__reset+0xfb10ffa8>
8112ffd8:	313ff236 	bltu	r6,r4,8112ffa4 <__reset+0xfb10ffa4>
8112ffdc:	21bffc36 	bltu	r4,r6,8112ffd0 <__reset+0xfb10ffd0>
8112ffe0:	0005883a 	mov	r2,zero
8112ffe4:	f800283a 	ret

8112ffe8 <__ledf2>:
8112ffe8:	2804d53a 	srli	r2,r5,20
8112ffec:	3810d53a 	srli	r8,r7,20
8112fff0:	00c00434 	movhi	r3,16
8112fff4:	18ffffc4 	addi	r3,r3,-1
8112fff8:	1081ffcc 	andi	r2,r2,2047
8112fffc:	0241ffc4 	movi	r9,2047
81130000:	28d4703a 	and	r10,r5,r3
81130004:	4201ffcc 	andi	r8,r8,2047
81130008:	38c6703a 	and	r3,r7,r3
8113000c:	280ad7fa 	srli	r5,r5,31
81130010:	380ed7fa 	srli	r7,r7,31
81130014:	12401f26 	beq	r2,r9,81130094 <__ledf2+0xac>
81130018:	0241ffc4 	movi	r9,2047
8113001c:	42401426 	beq	r8,r9,81130070 <__ledf2+0x88>
81130020:	1000091e 	bne	r2,zero,81130048 <__ledf2+0x60>
81130024:	2296b03a 	or	r11,r4,r10
81130028:	5813003a 	cmpeq	r9,r11,zero
8113002c:	29403fcc 	andi	r5,r5,255
81130030:	40000a1e 	bne	r8,zero,8113005c <__ledf2+0x74>
81130034:	30d8b03a 	or	r12,r6,r3
81130038:	6000081e 	bne	r12,zero,8113005c <__ledf2+0x74>
8113003c:	0005883a 	mov	r2,zero
81130040:	5800111e 	bne	r11,zero,81130088 <__ledf2+0xa0>
81130044:	f800283a 	ret
81130048:	29403fcc 	andi	r5,r5,255
8113004c:	40000c1e 	bne	r8,zero,81130080 <__ledf2+0x98>
81130050:	30d2b03a 	or	r9,r6,r3
81130054:	48000c26 	beq	r9,zero,81130088 <__ledf2+0xa0>
81130058:	0013883a 	mov	r9,zero
8113005c:	39c03fcc 	andi	r7,r7,255
81130060:	48000826 	beq	r9,zero,81130084 <__ledf2+0x9c>
81130064:	38001126 	beq	r7,zero,811300ac <__ledf2+0xc4>
81130068:	00800044 	movi	r2,1
8113006c:	f800283a 	ret
81130070:	30d2b03a 	or	r9,r6,r3
81130074:	483fea26 	beq	r9,zero,81130020 <__reset+0xfb110020>
81130078:	00800084 	movi	r2,2
8113007c:	f800283a 	ret
81130080:	39c03fcc 	andi	r7,r7,255
81130084:	39400726 	beq	r7,r5,811300a4 <__ledf2+0xbc>
81130088:	2800081e 	bne	r5,zero,811300ac <__ledf2+0xc4>
8113008c:	00800044 	movi	r2,1
81130090:	f800283a 	ret
81130094:	2292b03a 	or	r9,r4,r10
81130098:	483fdf26 	beq	r9,zero,81130018 <__reset+0xfb110018>
8113009c:	00800084 	movi	r2,2
811300a0:	f800283a 	ret
811300a4:	4080030e 	bge	r8,r2,811300b4 <__ledf2+0xcc>
811300a8:	383fef26 	beq	r7,zero,81130068 <__reset+0xfb110068>
811300ac:	00bfffc4 	movi	r2,-1
811300b0:	f800283a 	ret
811300b4:	123feb16 	blt	r2,r8,81130064 <__reset+0xfb110064>
811300b8:	1abff336 	bltu	r3,r10,81130088 <__reset+0xfb110088>
811300bc:	50c00326 	beq	r10,r3,811300cc <__ledf2+0xe4>
811300c0:	50c0042e 	bgeu	r10,r3,811300d4 <__ledf2+0xec>
811300c4:	283fe81e 	bne	r5,zero,81130068 <__reset+0xfb110068>
811300c8:	003ff806 	br	811300ac <__reset+0xfb1100ac>
811300cc:	313fee36 	bltu	r6,r4,81130088 <__reset+0xfb110088>
811300d0:	21bffc36 	bltu	r4,r6,811300c4 <__reset+0xfb1100c4>
811300d4:	0005883a 	mov	r2,zero
811300d8:	f800283a 	ret

811300dc <__subdf3>:
811300dc:	02000434 	movhi	r8,16
811300e0:	423fffc4 	addi	r8,r8,-1
811300e4:	defffb04 	addi	sp,sp,-20
811300e8:	2a14703a 	and	r10,r5,r8
811300ec:	3812d53a 	srli	r9,r7,20
811300f0:	3a10703a 	and	r8,r7,r8
811300f4:	de00012e 	bgeu	sp,et,811300fc <__subdf3+0x20>
811300f8:	003b68fa 	trap	3
811300fc:	2006d77a 	srli	r3,r4,29
81130100:	3004d77a 	srli	r2,r6,29
81130104:	dc000015 	stw	r16,0(sp)
81130108:	501490fa 	slli	r10,r10,3
8113010c:	2820d53a 	srli	r16,r5,20
81130110:	401090fa 	slli	r8,r8,3
81130114:	dc800215 	stw	r18,8(sp)
81130118:	dc400115 	stw	r17,4(sp)
8113011c:	dfc00415 	stw	ra,16(sp)
81130120:	202290fa 	slli	r17,r4,3
81130124:	dcc00315 	stw	r19,12(sp)
81130128:	4a41ffcc 	andi	r9,r9,2047
8113012c:	0101ffc4 	movi	r4,2047
81130130:	2824d7fa 	srli	r18,r5,31
81130134:	8401ffcc 	andi	r16,r16,2047
81130138:	50c6b03a 	or	r3,r10,r3
8113013c:	380ed7fa 	srli	r7,r7,31
81130140:	408ab03a 	or	r5,r8,r2
81130144:	300c90fa 	slli	r6,r6,3
81130148:	49009626 	beq	r9,r4,811303a4 <__subdf3+0x2c8>
8113014c:	39c0005c 	xori	r7,r7,1
81130150:	8245c83a 	sub	r2,r16,r9
81130154:	3c807426 	beq	r7,r18,81130328 <__subdf3+0x24c>
81130158:	0080af0e 	bge	zero,r2,81130418 <__subdf3+0x33c>
8113015c:	48002a1e 	bne	r9,zero,81130208 <__subdf3+0x12c>
81130160:	2988b03a 	or	r4,r5,r6
81130164:	20009a1e 	bne	r4,zero,811303d0 <__subdf3+0x2f4>
81130168:	888001cc 	andi	r2,r17,7
8113016c:	10000726 	beq	r2,zero,8113018c <__subdf3+0xb0>
81130170:	888003cc 	andi	r2,r17,15
81130174:	01000104 	movi	r4,4
81130178:	11000426 	beq	r2,r4,8113018c <__subdf3+0xb0>
8113017c:	890b883a 	add	r5,r17,r4
81130180:	2c63803a 	cmpltu	r17,r5,r17
81130184:	1c47883a 	add	r3,r3,r17
81130188:	2823883a 	mov	r17,r5
8113018c:	1880202c 	andhi	r2,r3,128
81130190:	10005926 	beq	r2,zero,811302f8 <__subdf3+0x21c>
81130194:	84000044 	addi	r16,r16,1
81130198:	0081ffc4 	movi	r2,2047
8113019c:	8080be26 	beq	r16,r2,81130498 <__subdf3+0x3bc>
811301a0:	017fe034 	movhi	r5,65408
811301a4:	297fffc4 	addi	r5,r5,-1
811301a8:	1946703a 	and	r3,r3,r5
811301ac:	1804977a 	slli	r2,r3,29
811301b0:	1806927a 	slli	r3,r3,9
811301b4:	8822d0fa 	srli	r17,r17,3
811301b8:	8401ffcc 	andi	r16,r16,2047
811301bc:	180ad33a 	srli	r5,r3,12
811301c0:	9100004c 	andi	r4,r18,1
811301c4:	1444b03a 	or	r2,r2,r17
811301c8:	80c1ffcc 	andi	r3,r16,2047
811301cc:	1820953a 	slli	r16,r3,20
811301d0:	20c03fcc 	andi	r3,r4,255
811301d4:	180897fa 	slli	r4,r3,31
811301d8:	00c00434 	movhi	r3,16
811301dc:	18ffffc4 	addi	r3,r3,-1
811301e0:	28c6703a 	and	r3,r5,r3
811301e4:	1c06b03a 	or	r3,r3,r16
811301e8:	1906b03a 	or	r3,r3,r4
811301ec:	dfc00417 	ldw	ra,16(sp)
811301f0:	dcc00317 	ldw	r19,12(sp)
811301f4:	dc800217 	ldw	r18,8(sp)
811301f8:	dc400117 	ldw	r17,4(sp)
811301fc:	dc000017 	ldw	r16,0(sp)
81130200:	dec00504 	addi	sp,sp,20
81130204:	f800283a 	ret
81130208:	0101ffc4 	movi	r4,2047
8113020c:	813fd626 	beq	r16,r4,81130168 <__reset+0xfb110168>
81130210:	29402034 	orhi	r5,r5,128
81130214:	01000e04 	movi	r4,56
81130218:	2080a316 	blt	r4,r2,811304a8 <__subdf3+0x3cc>
8113021c:	010007c4 	movi	r4,31
81130220:	2080c616 	blt	r4,r2,8113053c <__subdf3+0x460>
81130224:	01000804 	movi	r4,32
81130228:	2089c83a 	sub	r4,r4,r2
8113022c:	2910983a 	sll	r8,r5,r4
81130230:	308ed83a 	srl	r7,r6,r2
81130234:	3108983a 	sll	r4,r6,r4
81130238:	2884d83a 	srl	r2,r5,r2
8113023c:	41ccb03a 	or	r6,r8,r7
81130240:	2008c03a 	cmpne	r4,r4,zero
81130244:	310cb03a 	or	r6,r6,r4
81130248:	898dc83a 	sub	r6,r17,r6
8113024c:	89a3803a 	cmpltu	r17,r17,r6
81130250:	1887c83a 	sub	r3,r3,r2
81130254:	1c47c83a 	sub	r3,r3,r17
81130258:	3023883a 	mov	r17,r6
8113025c:	1880202c 	andhi	r2,r3,128
81130260:	10002326 	beq	r2,zero,811302f0 <__subdf3+0x214>
81130264:	04c02034 	movhi	r19,128
81130268:	9cffffc4 	addi	r19,r19,-1
8113026c:	1ce6703a 	and	r19,r3,r19
81130270:	98007a26 	beq	r19,zero,8113045c <__subdf3+0x380>
81130274:	9809883a 	mov	r4,r19
81130278:	111b1d00 	call	8111b1d0 <__clzsi2>
8113027c:	113ffe04 	addi	r4,r2,-8
81130280:	00c007c4 	movi	r3,31
81130284:	19007b16 	blt	r3,r4,81130474 <__subdf3+0x398>
81130288:	00800804 	movi	r2,32
8113028c:	1105c83a 	sub	r2,r2,r4
81130290:	8884d83a 	srl	r2,r17,r2
81130294:	9906983a 	sll	r3,r19,r4
81130298:	8922983a 	sll	r17,r17,r4
8113029c:	10c4b03a 	or	r2,r2,r3
811302a0:	24007816 	blt	r4,r16,81130484 <__subdf3+0x3a8>
811302a4:	2421c83a 	sub	r16,r4,r16
811302a8:	80c00044 	addi	r3,r16,1
811302ac:	010007c4 	movi	r4,31
811302b0:	20c09516 	blt	r4,r3,81130508 <__subdf3+0x42c>
811302b4:	01400804 	movi	r5,32
811302b8:	28cbc83a 	sub	r5,r5,r3
811302bc:	88c8d83a 	srl	r4,r17,r3
811302c0:	8962983a 	sll	r17,r17,r5
811302c4:	114a983a 	sll	r5,r2,r5
811302c8:	10c6d83a 	srl	r3,r2,r3
811302cc:	8804c03a 	cmpne	r2,r17,zero
811302d0:	290ab03a 	or	r5,r5,r4
811302d4:	28a2b03a 	or	r17,r5,r2
811302d8:	0021883a 	mov	r16,zero
811302dc:	003fa206 	br	81130168 <__reset+0xfb110168>
811302e0:	2090b03a 	or	r8,r4,r2
811302e4:	40018e26 	beq	r8,zero,81130920 <__subdf3+0x844>
811302e8:	1007883a 	mov	r3,r2
811302ec:	2023883a 	mov	r17,r4
811302f0:	888001cc 	andi	r2,r17,7
811302f4:	103f9e1e 	bne	r2,zero,81130170 <__reset+0xfb110170>
811302f8:	1804977a 	slli	r2,r3,29
811302fc:	8822d0fa 	srli	r17,r17,3
81130300:	1810d0fa 	srli	r8,r3,3
81130304:	9100004c 	andi	r4,r18,1
81130308:	1444b03a 	or	r2,r2,r17
8113030c:	00c1ffc4 	movi	r3,2047
81130310:	80c02826 	beq	r16,r3,811303b4 <__subdf3+0x2d8>
81130314:	01400434 	movhi	r5,16
81130318:	297fffc4 	addi	r5,r5,-1
8113031c:	80e0703a 	and	r16,r16,r3
81130320:	414a703a 	and	r5,r8,r5
81130324:	003fa806 	br	811301c8 <__reset+0xfb1101c8>
81130328:	0080630e 	bge	zero,r2,811304b8 <__subdf3+0x3dc>
8113032c:	48003026 	beq	r9,zero,811303f0 <__subdf3+0x314>
81130330:	0101ffc4 	movi	r4,2047
81130334:	813f8c26 	beq	r16,r4,81130168 <__reset+0xfb110168>
81130338:	29402034 	orhi	r5,r5,128
8113033c:	01000e04 	movi	r4,56
81130340:	2080a90e 	bge	r4,r2,811305e8 <__subdf3+0x50c>
81130344:	298cb03a 	or	r6,r5,r6
81130348:	3012c03a 	cmpne	r9,r6,zero
8113034c:	0005883a 	mov	r2,zero
81130350:	4c53883a 	add	r9,r9,r17
81130354:	4c63803a 	cmpltu	r17,r9,r17
81130358:	10c7883a 	add	r3,r2,r3
8113035c:	88c7883a 	add	r3,r17,r3
81130360:	4823883a 	mov	r17,r9
81130364:	1880202c 	andhi	r2,r3,128
81130368:	1000d026 	beq	r2,zero,811306ac <__subdf3+0x5d0>
8113036c:	84000044 	addi	r16,r16,1
81130370:	0081ffc4 	movi	r2,2047
81130374:	8080fe26 	beq	r16,r2,81130770 <__subdf3+0x694>
81130378:	00bfe034 	movhi	r2,65408
8113037c:	10bfffc4 	addi	r2,r2,-1
81130380:	1886703a 	and	r3,r3,r2
81130384:	880ad07a 	srli	r5,r17,1
81130388:	180497fa 	slli	r2,r3,31
8113038c:	8900004c 	andi	r4,r17,1
81130390:	2922b03a 	or	r17,r5,r4
81130394:	1806d07a 	srli	r3,r3,1
81130398:	1462b03a 	or	r17,r2,r17
8113039c:	3825883a 	mov	r18,r7
811303a0:	003f7106 	br	81130168 <__reset+0xfb110168>
811303a4:	2984b03a 	or	r2,r5,r6
811303a8:	103f6826 	beq	r2,zero,8113014c <__reset+0xfb11014c>
811303ac:	39c03fcc 	andi	r7,r7,255
811303b0:	003f6706 	br	81130150 <__reset+0xfb110150>
811303b4:	4086b03a 	or	r3,r8,r2
811303b8:	18015226 	beq	r3,zero,81130904 <__subdf3+0x828>
811303bc:	00c00434 	movhi	r3,16
811303c0:	41400234 	orhi	r5,r8,8
811303c4:	18ffffc4 	addi	r3,r3,-1
811303c8:	28ca703a 	and	r5,r5,r3
811303cc:	003f7e06 	br	811301c8 <__reset+0xfb1101c8>
811303d0:	10bfffc4 	addi	r2,r2,-1
811303d4:	1000491e 	bne	r2,zero,811304fc <__subdf3+0x420>
811303d8:	898fc83a 	sub	r7,r17,r6
811303dc:	89e3803a 	cmpltu	r17,r17,r7
811303e0:	1947c83a 	sub	r3,r3,r5
811303e4:	1c47c83a 	sub	r3,r3,r17
811303e8:	3823883a 	mov	r17,r7
811303ec:	003f9b06 	br	8113025c <__reset+0xfb11025c>
811303f0:	2988b03a 	or	r4,r5,r6
811303f4:	203f5c26 	beq	r4,zero,81130168 <__reset+0xfb110168>
811303f8:	10bfffc4 	addi	r2,r2,-1
811303fc:	1000931e 	bne	r2,zero,8113064c <__subdf3+0x570>
81130400:	898d883a 	add	r6,r17,r6
81130404:	3463803a 	cmpltu	r17,r6,r17
81130408:	1947883a 	add	r3,r3,r5
8113040c:	88c7883a 	add	r3,r17,r3
81130410:	3023883a 	mov	r17,r6
81130414:	003fd306 	br	81130364 <__reset+0xfb110364>
81130418:	1000541e 	bne	r2,zero,8113056c <__subdf3+0x490>
8113041c:	80800044 	addi	r2,r16,1
81130420:	1081ffcc 	andi	r2,r2,2047
81130424:	01000044 	movi	r4,1
81130428:	2080a20e 	bge	r4,r2,811306b4 <__subdf3+0x5d8>
8113042c:	8989c83a 	sub	r4,r17,r6
81130430:	8905803a 	cmpltu	r2,r17,r4
81130434:	1967c83a 	sub	r19,r3,r5
81130438:	98a7c83a 	sub	r19,r19,r2
8113043c:	9880202c 	andhi	r2,r19,128
81130440:	10006326 	beq	r2,zero,811305d0 <__subdf3+0x4f4>
81130444:	3463c83a 	sub	r17,r6,r17
81130448:	28c7c83a 	sub	r3,r5,r3
8113044c:	344d803a 	cmpltu	r6,r6,r17
81130450:	19a7c83a 	sub	r19,r3,r6
81130454:	3825883a 	mov	r18,r7
81130458:	983f861e 	bne	r19,zero,81130274 <__reset+0xfb110274>
8113045c:	8809883a 	mov	r4,r17
81130460:	111b1d00 	call	8111b1d0 <__clzsi2>
81130464:	10800804 	addi	r2,r2,32
81130468:	113ffe04 	addi	r4,r2,-8
8113046c:	00c007c4 	movi	r3,31
81130470:	193f850e 	bge	r3,r4,81130288 <__reset+0xfb110288>
81130474:	10bff604 	addi	r2,r2,-40
81130478:	8884983a 	sll	r2,r17,r2
8113047c:	0023883a 	mov	r17,zero
81130480:	243f880e 	bge	r4,r16,811302a4 <__reset+0xfb1102a4>
81130484:	00ffe034 	movhi	r3,65408
81130488:	18ffffc4 	addi	r3,r3,-1
8113048c:	8121c83a 	sub	r16,r16,r4
81130490:	10c6703a 	and	r3,r2,r3
81130494:	003f3406 	br	81130168 <__reset+0xfb110168>
81130498:	9100004c 	andi	r4,r18,1
8113049c:	000b883a 	mov	r5,zero
811304a0:	0005883a 	mov	r2,zero
811304a4:	003f4806 	br	811301c8 <__reset+0xfb1101c8>
811304a8:	298cb03a 	or	r6,r5,r6
811304ac:	300cc03a 	cmpne	r6,r6,zero
811304b0:	0005883a 	mov	r2,zero
811304b4:	003f6406 	br	81130248 <__reset+0xfb110248>
811304b8:	10009a1e 	bne	r2,zero,81130724 <__subdf3+0x648>
811304bc:	82400044 	addi	r9,r16,1
811304c0:	4881ffcc 	andi	r2,r9,2047
811304c4:	02800044 	movi	r10,1
811304c8:	5080670e 	bge	r10,r2,81130668 <__subdf3+0x58c>
811304cc:	0081ffc4 	movi	r2,2047
811304d0:	4880af26 	beq	r9,r2,81130790 <__subdf3+0x6b4>
811304d4:	898d883a 	add	r6,r17,r6
811304d8:	1945883a 	add	r2,r3,r5
811304dc:	3447803a 	cmpltu	r3,r6,r17
811304e0:	1887883a 	add	r3,r3,r2
811304e4:	182297fa 	slli	r17,r3,31
811304e8:	300cd07a 	srli	r6,r6,1
811304ec:	1806d07a 	srli	r3,r3,1
811304f0:	4821883a 	mov	r16,r9
811304f4:	89a2b03a 	or	r17,r17,r6
811304f8:	003f1b06 	br	81130168 <__reset+0xfb110168>
811304fc:	0101ffc4 	movi	r4,2047
81130500:	813f441e 	bne	r16,r4,81130214 <__reset+0xfb110214>
81130504:	003f1806 	br	81130168 <__reset+0xfb110168>
81130508:	843ff844 	addi	r16,r16,-31
8113050c:	01400804 	movi	r5,32
81130510:	1408d83a 	srl	r4,r2,r16
81130514:	19405026 	beq	r3,r5,81130658 <__subdf3+0x57c>
81130518:	01401004 	movi	r5,64
8113051c:	28c7c83a 	sub	r3,r5,r3
81130520:	10c4983a 	sll	r2,r2,r3
81130524:	88a2b03a 	or	r17,r17,r2
81130528:	8822c03a 	cmpne	r17,r17,zero
8113052c:	2462b03a 	or	r17,r4,r17
81130530:	0007883a 	mov	r3,zero
81130534:	0021883a 	mov	r16,zero
81130538:	003f6d06 	br	811302f0 <__reset+0xfb1102f0>
8113053c:	11fff804 	addi	r7,r2,-32
81130540:	01000804 	movi	r4,32
81130544:	29ced83a 	srl	r7,r5,r7
81130548:	11004526 	beq	r2,r4,81130660 <__subdf3+0x584>
8113054c:	01001004 	movi	r4,64
81130550:	2089c83a 	sub	r4,r4,r2
81130554:	2904983a 	sll	r2,r5,r4
81130558:	118cb03a 	or	r6,r2,r6
8113055c:	300cc03a 	cmpne	r6,r6,zero
81130560:	398cb03a 	or	r6,r7,r6
81130564:	0005883a 	mov	r2,zero
81130568:	003f3706 	br	81130248 <__reset+0xfb110248>
8113056c:	80002a26 	beq	r16,zero,81130618 <__subdf3+0x53c>
81130570:	0101ffc4 	movi	r4,2047
81130574:	49006626 	beq	r9,r4,81130710 <__subdf3+0x634>
81130578:	0085c83a 	sub	r2,zero,r2
8113057c:	18c02034 	orhi	r3,r3,128
81130580:	01000e04 	movi	r4,56
81130584:	20807e16 	blt	r4,r2,81130780 <__subdf3+0x6a4>
81130588:	010007c4 	movi	r4,31
8113058c:	2080e716 	blt	r4,r2,8113092c <__subdf3+0x850>
81130590:	01000804 	movi	r4,32
81130594:	2089c83a 	sub	r4,r4,r2
81130598:	1914983a 	sll	r10,r3,r4
8113059c:	8890d83a 	srl	r8,r17,r2
811305a0:	8908983a 	sll	r4,r17,r4
811305a4:	1884d83a 	srl	r2,r3,r2
811305a8:	5222b03a 	or	r17,r10,r8
811305ac:	2006c03a 	cmpne	r3,r4,zero
811305b0:	88e2b03a 	or	r17,r17,r3
811305b4:	3463c83a 	sub	r17,r6,r17
811305b8:	2885c83a 	sub	r2,r5,r2
811305bc:	344d803a 	cmpltu	r6,r6,r17
811305c0:	1187c83a 	sub	r3,r2,r6
811305c4:	4821883a 	mov	r16,r9
811305c8:	3825883a 	mov	r18,r7
811305cc:	003f2306 	br	8113025c <__reset+0xfb11025c>
811305d0:	24d0b03a 	or	r8,r4,r19
811305d4:	40001b1e 	bne	r8,zero,81130644 <__subdf3+0x568>
811305d8:	0005883a 	mov	r2,zero
811305dc:	0009883a 	mov	r4,zero
811305e0:	0021883a 	mov	r16,zero
811305e4:	003f4906 	br	8113030c <__reset+0xfb11030c>
811305e8:	010007c4 	movi	r4,31
811305ec:	20803a16 	blt	r4,r2,811306d8 <__subdf3+0x5fc>
811305f0:	01000804 	movi	r4,32
811305f4:	2089c83a 	sub	r4,r4,r2
811305f8:	2912983a 	sll	r9,r5,r4
811305fc:	3090d83a 	srl	r8,r6,r2
81130600:	3108983a 	sll	r4,r6,r4
81130604:	2884d83a 	srl	r2,r5,r2
81130608:	4a12b03a 	or	r9,r9,r8
8113060c:	2008c03a 	cmpne	r4,r4,zero
81130610:	4912b03a 	or	r9,r9,r4
81130614:	003f4e06 	br	81130350 <__reset+0xfb110350>
81130618:	1c48b03a 	or	r4,r3,r17
8113061c:	20003c26 	beq	r4,zero,81130710 <__subdf3+0x634>
81130620:	0084303a 	nor	r2,zero,r2
81130624:	1000381e 	bne	r2,zero,81130708 <__subdf3+0x62c>
81130628:	3463c83a 	sub	r17,r6,r17
8113062c:	28c5c83a 	sub	r2,r5,r3
81130630:	344d803a 	cmpltu	r6,r6,r17
81130634:	1187c83a 	sub	r3,r2,r6
81130638:	4821883a 	mov	r16,r9
8113063c:	3825883a 	mov	r18,r7
81130640:	003f0606 	br	8113025c <__reset+0xfb11025c>
81130644:	2023883a 	mov	r17,r4
81130648:	003f0906 	br	81130270 <__reset+0xfb110270>
8113064c:	0101ffc4 	movi	r4,2047
81130650:	813f3a1e 	bne	r16,r4,8113033c <__reset+0xfb11033c>
81130654:	003ec406 	br	81130168 <__reset+0xfb110168>
81130658:	0005883a 	mov	r2,zero
8113065c:	003fb106 	br	81130524 <__reset+0xfb110524>
81130660:	0005883a 	mov	r2,zero
81130664:	003fbc06 	br	81130558 <__reset+0xfb110558>
81130668:	1c44b03a 	or	r2,r3,r17
8113066c:	80008e1e 	bne	r16,zero,811308a8 <__subdf3+0x7cc>
81130670:	1000c826 	beq	r2,zero,81130994 <__subdf3+0x8b8>
81130674:	2984b03a 	or	r2,r5,r6
81130678:	103ebb26 	beq	r2,zero,81130168 <__reset+0xfb110168>
8113067c:	8989883a 	add	r4,r17,r6
81130680:	1945883a 	add	r2,r3,r5
81130684:	2447803a 	cmpltu	r3,r4,r17
81130688:	1887883a 	add	r3,r3,r2
8113068c:	1880202c 	andhi	r2,r3,128
81130690:	2023883a 	mov	r17,r4
81130694:	103f1626 	beq	r2,zero,811302f0 <__reset+0xfb1102f0>
81130698:	00bfe034 	movhi	r2,65408
8113069c:	10bfffc4 	addi	r2,r2,-1
811306a0:	5021883a 	mov	r16,r10
811306a4:	1886703a 	and	r3,r3,r2
811306a8:	003eaf06 	br	81130168 <__reset+0xfb110168>
811306ac:	3825883a 	mov	r18,r7
811306b0:	003f0f06 	br	811302f0 <__reset+0xfb1102f0>
811306b4:	1c44b03a 	or	r2,r3,r17
811306b8:	8000251e 	bne	r16,zero,81130750 <__subdf3+0x674>
811306bc:	1000661e 	bne	r2,zero,81130858 <__subdf3+0x77c>
811306c0:	2990b03a 	or	r8,r5,r6
811306c4:	40009626 	beq	r8,zero,81130920 <__subdf3+0x844>
811306c8:	2807883a 	mov	r3,r5
811306cc:	3023883a 	mov	r17,r6
811306d0:	3825883a 	mov	r18,r7
811306d4:	003ea406 	br	81130168 <__reset+0xfb110168>
811306d8:	127ff804 	addi	r9,r2,-32
811306dc:	01000804 	movi	r4,32
811306e0:	2a52d83a 	srl	r9,r5,r9
811306e4:	11008c26 	beq	r2,r4,81130918 <__subdf3+0x83c>
811306e8:	01001004 	movi	r4,64
811306ec:	2085c83a 	sub	r2,r4,r2
811306f0:	2884983a 	sll	r2,r5,r2
811306f4:	118cb03a 	or	r6,r2,r6
811306f8:	300cc03a 	cmpne	r6,r6,zero
811306fc:	4992b03a 	or	r9,r9,r6
81130700:	0005883a 	mov	r2,zero
81130704:	003f1206 	br	81130350 <__reset+0xfb110350>
81130708:	0101ffc4 	movi	r4,2047
8113070c:	493f9c1e 	bne	r9,r4,81130580 <__reset+0xfb110580>
81130710:	2807883a 	mov	r3,r5
81130714:	3023883a 	mov	r17,r6
81130718:	4821883a 	mov	r16,r9
8113071c:	3825883a 	mov	r18,r7
81130720:	003e9106 	br	81130168 <__reset+0xfb110168>
81130724:	80001f1e 	bne	r16,zero,811307a4 <__subdf3+0x6c8>
81130728:	1c48b03a 	or	r4,r3,r17
8113072c:	20005a26 	beq	r4,zero,81130898 <__subdf3+0x7bc>
81130730:	0084303a 	nor	r2,zero,r2
81130734:	1000561e 	bne	r2,zero,81130890 <__subdf3+0x7b4>
81130738:	89a3883a 	add	r17,r17,r6
8113073c:	1945883a 	add	r2,r3,r5
81130740:	898d803a 	cmpltu	r6,r17,r6
81130744:	3087883a 	add	r3,r6,r2
81130748:	4821883a 	mov	r16,r9
8113074c:	003f0506 	br	81130364 <__reset+0xfb110364>
81130750:	10002b1e 	bne	r2,zero,81130800 <__subdf3+0x724>
81130754:	2984b03a 	or	r2,r5,r6
81130758:	10008026 	beq	r2,zero,8113095c <__subdf3+0x880>
8113075c:	2807883a 	mov	r3,r5
81130760:	3023883a 	mov	r17,r6
81130764:	3825883a 	mov	r18,r7
81130768:	0401ffc4 	movi	r16,2047
8113076c:	003e7e06 	br	81130168 <__reset+0xfb110168>
81130770:	3809883a 	mov	r4,r7
81130774:	0011883a 	mov	r8,zero
81130778:	0005883a 	mov	r2,zero
8113077c:	003ee306 	br	8113030c <__reset+0xfb11030c>
81130780:	1c62b03a 	or	r17,r3,r17
81130784:	8822c03a 	cmpne	r17,r17,zero
81130788:	0005883a 	mov	r2,zero
8113078c:	003f8906 	br	811305b4 <__reset+0xfb1105b4>
81130790:	3809883a 	mov	r4,r7
81130794:	4821883a 	mov	r16,r9
81130798:	0011883a 	mov	r8,zero
8113079c:	0005883a 	mov	r2,zero
811307a0:	003eda06 	br	8113030c <__reset+0xfb11030c>
811307a4:	0101ffc4 	movi	r4,2047
811307a8:	49003b26 	beq	r9,r4,81130898 <__subdf3+0x7bc>
811307ac:	0085c83a 	sub	r2,zero,r2
811307b0:	18c02034 	orhi	r3,r3,128
811307b4:	01000e04 	movi	r4,56
811307b8:	20806e16 	blt	r4,r2,81130974 <__subdf3+0x898>
811307bc:	010007c4 	movi	r4,31
811307c0:	20807716 	blt	r4,r2,811309a0 <__subdf3+0x8c4>
811307c4:	01000804 	movi	r4,32
811307c8:	2089c83a 	sub	r4,r4,r2
811307cc:	1914983a 	sll	r10,r3,r4
811307d0:	8890d83a 	srl	r8,r17,r2
811307d4:	8908983a 	sll	r4,r17,r4
811307d8:	1884d83a 	srl	r2,r3,r2
811307dc:	5222b03a 	or	r17,r10,r8
811307e0:	2006c03a 	cmpne	r3,r4,zero
811307e4:	88e2b03a 	or	r17,r17,r3
811307e8:	89a3883a 	add	r17,r17,r6
811307ec:	1145883a 	add	r2,r2,r5
811307f0:	898d803a 	cmpltu	r6,r17,r6
811307f4:	3087883a 	add	r3,r6,r2
811307f8:	4821883a 	mov	r16,r9
811307fc:	003ed906 	br	81130364 <__reset+0xfb110364>
81130800:	2984b03a 	or	r2,r5,r6
81130804:	10004226 	beq	r2,zero,81130910 <__subdf3+0x834>
81130808:	1808d0fa 	srli	r4,r3,3
8113080c:	8822d0fa 	srli	r17,r17,3
81130810:	1806977a 	slli	r3,r3,29
81130814:	2080022c 	andhi	r2,r4,8
81130818:	1c62b03a 	or	r17,r3,r17
8113081c:	10000826 	beq	r2,zero,81130840 <__subdf3+0x764>
81130820:	2812d0fa 	srli	r9,r5,3
81130824:	4880022c 	andhi	r2,r9,8
81130828:	1000051e 	bne	r2,zero,81130840 <__subdf3+0x764>
8113082c:	300cd0fa 	srli	r6,r6,3
81130830:	2804977a 	slli	r2,r5,29
81130834:	4809883a 	mov	r4,r9
81130838:	3825883a 	mov	r18,r7
8113083c:	11a2b03a 	or	r17,r2,r6
81130840:	8806d77a 	srli	r3,r17,29
81130844:	200890fa 	slli	r4,r4,3
81130848:	882290fa 	slli	r17,r17,3
8113084c:	0401ffc4 	movi	r16,2047
81130850:	1906b03a 	or	r3,r3,r4
81130854:	003e4406 	br	81130168 <__reset+0xfb110168>
81130858:	2984b03a 	or	r2,r5,r6
8113085c:	103e4226 	beq	r2,zero,81130168 <__reset+0xfb110168>
81130860:	8989c83a 	sub	r4,r17,r6
81130864:	8911803a 	cmpltu	r8,r17,r4
81130868:	1945c83a 	sub	r2,r3,r5
8113086c:	1205c83a 	sub	r2,r2,r8
81130870:	1200202c 	andhi	r8,r2,128
81130874:	403e9a26 	beq	r8,zero,811302e0 <__reset+0xfb1102e0>
81130878:	3463c83a 	sub	r17,r6,r17
8113087c:	28c5c83a 	sub	r2,r5,r3
81130880:	344d803a 	cmpltu	r6,r6,r17
81130884:	1187c83a 	sub	r3,r2,r6
81130888:	3825883a 	mov	r18,r7
8113088c:	003e3606 	br	81130168 <__reset+0xfb110168>
81130890:	0101ffc4 	movi	r4,2047
81130894:	493fc71e 	bne	r9,r4,811307b4 <__reset+0xfb1107b4>
81130898:	2807883a 	mov	r3,r5
8113089c:	3023883a 	mov	r17,r6
811308a0:	4821883a 	mov	r16,r9
811308a4:	003e3006 	br	81130168 <__reset+0xfb110168>
811308a8:	10003626 	beq	r2,zero,81130984 <__subdf3+0x8a8>
811308ac:	2984b03a 	or	r2,r5,r6
811308b0:	10001726 	beq	r2,zero,81130910 <__subdf3+0x834>
811308b4:	1808d0fa 	srli	r4,r3,3
811308b8:	8822d0fa 	srli	r17,r17,3
811308bc:	1806977a 	slli	r3,r3,29
811308c0:	2080022c 	andhi	r2,r4,8
811308c4:	1c62b03a 	or	r17,r3,r17
811308c8:	10000726 	beq	r2,zero,811308e8 <__subdf3+0x80c>
811308cc:	2812d0fa 	srli	r9,r5,3
811308d0:	4880022c 	andhi	r2,r9,8
811308d4:	1000041e 	bne	r2,zero,811308e8 <__subdf3+0x80c>
811308d8:	300cd0fa 	srli	r6,r6,3
811308dc:	2804977a 	slli	r2,r5,29
811308e0:	4809883a 	mov	r4,r9
811308e4:	11a2b03a 	or	r17,r2,r6
811308e8:	8806d77a 	srli	r3,r17,29
811308ec:	200890fa 	slli	r4,r4,3
811308f0:	882290fa 	slli	r17,r17,3
811308f4:	3825883a 	mov	r18,r7
811308f8:	1906b03a 	or	r3,r3,r4
811308fc:	0401ffc4 	movi	r16,2047
81130900:	003e1906 	br	81130168 <__reset+0xfb110168>
81130904:	000b883a 	mov	r5,zero
81130908:	0005883a 	mov	r2,zero
8113090c:	003e2e06 	br	811301c8 <__reset+0xfb1101c8>
81130910:	0401ffc4 	movi	r16,2047
81130914:	003e1406 	br	81130168 <__reset+0xfb110168>
81130918:	0005883a 	mov	r2,zero
8113091c:	003f7506 	br	811306f4 <__reset+0xfb1106f4>
81130920:	0005883a 	mov	r2,zero
81130924:	0009883a 	mov	r4,zero
81130928:	003e7806 	br	8113030c <__reset+0xfb11030c>
8113092c:	123ff804 	addi	r8,r2,-32
81130930:	01000804 	movi	r4,32
81130934:	1a10d83a 	srl	r8,r3,r8
81130938:	11002526 	beq	r2,r4,811309d0 <__subdf3+0x8f4>
8113093c:	01001004 	movi	r4,64
81130940:	2085c83a 	sub	r2,r4,r2
81130944:	1884983a 	sll	r2,r3,r2
81130948:	1444b03a 	or	r2,r2,r17
8113094c:	1004c03a 	cmpne	r2,r2,zero
81130950:	40a2b03a 	or	r17,r8,r2
81130954:	0005883a 	mov	r2,zero
81130958:	003f1606 	br	811305b4 <__reset+0xfb1105b4>
8113095c:	02000434 	movhi	r8,16
81130960:	0009883a 	mov	r4,zero
81130964:	423fffc4 	addi	r8,r8,-1
81130968:	00bfffc4 	movi	r2,-1
8113096c:	0401ffc4 	movi	r16,2047
81130970:	003e6606 	br	8113030c <__reset+0xfb11030c>
81130974:	1c62b03a 	or	r17,r3,r17
81130978:	8822c03a 	cmpne	r17,r17,zero
8113097c:	0005883a 	mov	r2,zero
81130980:	003f9906 	br	811307e8 <__reset+0xfb1107e8>
81130984:	2807883a 	mov	r3,r5
81130988:	3023883a 	mov	r17,r6
8113098c:	0401ffc4 	movi	r16,2047
81130990:	003df506 	br	81130168 <__reset+0xfb110168>
81130994:	2807883a 	mov	r3,r5
81130998:	3023883a 	mov	r17,r6
8113099c:	003df206 	br	81130168 <__reset+0xfb110168>
811309a0:	123ff804 	addi	r8,r2,-32
811309a4:	01000804 	movi	r4,32
811309a8:	1a10d83a 	srl	r8,r3,r8
811309ac:	11000a26 	beq	r2,r4,811309d8 <__subdf3+0x8fc>
811309b0:	01001004 	movi	r4,64
811309b4:	2085c83a 	sub	r2,r4,r2
811309b8:	1884983a 	sll	r2,r3,r2
811309bc:	1444b03a 	or	r2,r2,r17
811309c0:	1004c03a 	cmpne	r2,r2,zero
811309c4:	40a2b03a 	or	r17,r8,r2
811309c8:	0005883a 	mov	r2,zero
811309cc:	003f8606 	br	811307e8 <__reset+0xfb1107e8>
811309d0:	0005883a 	mov	r2,zero
811309d4:	003fdc06 	br	81130948 <__reset+0xfb110948>
811309d8:	0005883a 	mov	r2,zero
811309dc:	003ff706 	br	811309bc <__reset+0xfb1109bc>

811309e0 <__fixdfsi>:
811309e0:	280cd53a 	srli	r6,r5,20
811309e4:	00c00434 	movhi	r3,16
811309e8:	18ffffc4 	addi	r3,r3,-1
811309ec:	3181ffcc 	andi	r6,r6,2047
811309f0:	01c0ff84 	movi	r7,1022
811309f4:	28c6703a 	and	r3,r5,r3
811309f8:	280ad7fa 	srli	r5,r5,31
811309fc:	3980120e 	bge	r7,r6,81130a48 <__fixdfsi+0x68>
81130a00:	00810744 	movi	r2,1053
81130a04:	11800c16 	blt	r2,r6,81130a38 <__fixdfsi+0x58>
81130a08:	00810cc4 	movi	r2,1075
81130a0c:	1185c83a 	sub	r2,r2,r6
81130a10:	01c007c4 	movi	r7,31
81130a14:	18c00434 	orhi	r3,r3,16
81130a18:	38800d16 	blt	r7,r2,81130a50 <__fixdfsi+0x70>
81130a1c:	31befb44 	addi	r6,r6,-1043
81130a20:	2084d83a 	srl	r2,r4,r2
81130a24:	1986983a 	sll	r3,r3,r6
81130a28:	1884b03a 	or	r2,r3,r2
81130a2c:	28000726 	beq	r5,zero,81130a4c <__fixdfsi+0x6c>
81130a30:	0085c83a 	sub	r2,zero,r2
81130a34:	f800283a 	ret
81130a38:	00a00034 	movhi	r2,32768
81130a3c:	10bfffc4 	addi	r2,r2,-1
81130a40:	2885883a 	add	r2,r5,r2
81130a44:	f800283a 	ret
81130a48:	0005883a 	mov	r2,zero
81130a4c:	f800283a 	ret
81130a50:	008104c4 	movi	r2,1043
81130a54:	1185c83a 	sub	r2,r2,r6
81130a58:	1884d83a 	srl	r2,r3,r2
81130a5c:	003ff306 	br	81130a2c <__reset+0xfb110a2c>

81130a60 <__floatsidf>:
81130a60:	defffd04 	addi	sp,sp,-12
81130a64:	de00012e 	bgeu	sp,et,81130a6c <__floatsidf+0xc>
81130a68:	003b68fa 	trap	3
81130a6c:	dfc00215 	stw	ra,8(sp)
81130a70:	dc400115 	stw	r17,4(sp)
81130a74:	dc000015 	stw	r16,0(sp)
81130a78:	20002b26 	beq	r4,zero,81130b28 <__floatsidf+0xc8>
81130a7c:	2023883a 	mov	r17,r4
81130a80:	2020d7fa 	srli	r16,r4,31
81130a84:	20002d16 	blt	r4,zero,81130b3c <__floatsidf+0xdc>
81130a88:	8809883a 	mov	r4,r17
81130a8c:	111b1d00 	call	8111b1d0 <__clzsi2>
81130a90:	01410784 	movi	r5,1054
81130a94:	288bc83a 	sub	r5,r5,r2
81130a98:	01010cc4 	movi	r4,1075
81130a9c:	2149c83a 	sub	r4,r4,r5
81130aa0:	00c007c4 	movi	r3,31
81130aa4:	1900160e 	bge	r3,r4,81130b00 <__floatsidf+0xa0>
81130aa8:	00c104c4 	movi	r3,1043
81130aac:	1947c83a 	sub	r3,r3,r5
81130ab0:	88c6983a 	sll	r3,r17,r3
81130ab4:	00800434 	movhi	r2,16
81130ab8:	10bfffc4 	addi	r2,r2,-1
81130abc:	1886703a 	and	r3,r3,r2
81130ac0:	2941ffcc 	andi	r5,r5,2047
81130ac4:	800d883a 	mov	r6,r16
81130ac8:	0005883a 	mov	r2,zero
81130acc:	280a953a 	slli	r5,r5,20
81130ad0:	31803fcc 	andi	r6,r6,255
81130ad4:	01000434 	movhi	r4,16
81130ad8:	300c97fa 	slli	r6,r6,31
81130adc:	213fffc4 	addi	r4,r4,-1
81130ae0:	1906703a 	and	r3,r3,r4
81130ae4:	1946b03a 	or	r3,r3,r5
81130ae8:	1986b03a 	or	r3,r3,r6
81130aec:	dfc00217 	ldw	ra,8(sp)
81130af0:	dc400117 	ldw	r17,4(sp)
81130af4:	dc000017 	ldw	r16,0(sp)
81130af8:	dec00304 	addi	sp,sp,12
81130afc:	f800283a 	ret
81130b00:	00c002c4 	movi	r3,11
81130b04:	1887c83a 	sub	r3,r3,r2
81130b08:	88c6d83a 	srl	r3,r17,r3
81130b0c:	8904983a 	sll	r2,r17,r4
81130b10:	01000434 	movhi	r4,16
81130b14:	213fffc4 	addi	r4,r4,-1
81130b18:	2941ffcc 	andi	r5,r5,2047
81130b1c:	1906703a 	and	r3,r3,r4
81130b20:	800d883a 	mov	r6,r16
81130b24:	003fe906 	br	81130acc <__reset+0xfb110acc>
81130b28:	000d883a 	mov	r6,zero
81130b2c:	000b883a 	mov	r5,zero
81130b30:	0007883a 	mov	r3,zero
81130b34:	0005883a 	mov	r2,zero
81130b38:	003fe406 	br	81130acc <__reset+0xfb110acc>
81130b3c:	0123c83a 	sub	r17,zero,r4
81130b40:	003fd106 	br	81130a88 <__reset+0xfb110a88>

81130b44 <__floatunsidf>:
81130b44:	defffe04 	addi	sp,sp,-8
81130b48:	de00012e 	bgeu	sp,et,81130b50 <__floatunsidf+0xc>
81130b4c:	003b68fa 	trap	3
81130b50:	dc000015 	stw	r16,0(sp)
81130b54:	dfc00115 	stw	ra,4(sp)
81130b58:	2021883a 	mov	r16,r4
81130b5c:	20002226 	beq	r4,zero,81130be8 <__floatunsidf+0xa4>
81130b60:	111b1d00 	call	8111b1d0 <__clzsi2>
81130b64:	01010784 	movi	r4,1054
81130b68:	2089c83a 	sub	r4,r4,r2
81130b6c:	01810cc4 	movi	r6,1075
81130b70:	310dc83a 	sub	r6,r6,r4
81130b74:	00c007c4 	movi	r3,31
81130b78:	1980120e 	bge	r3,r6,81130bc4 <__floatunsidf+0x80>
81130b7c:	00c104c4 	movi	r3,1043
81130b80:	1907c83a 	sub	r3,r3,r4
81130b84:	80ca983a 	sll	r5,r16,r3
81130b88:	00800434 	movhi	r2,16
81130b8c:	10bfffc4 	addi	r2,r2,-1
81130b90:	2101ffcc 	andi	r4,r4,2047
81130b94:	0021883a 	mov	r16,zero
81130b98:	288a703a 	and	r5,r5,r2
81130b9c:	2008953a 	slli	r4,r4,20
81130ba0:	00c00434 	movhi	r3,16
81130ba4:	18ffffc4 	addi	r3,r3,-1
81130ba8:	28c6703a 	and	r3,r5,r3
81130bac:	8005883a 	mov	r2,r16
81130bb0:	1906b03a 	or	r3,r3,r4
81130bb4:	dfc00117 	ldw	ra,4(sp)
81130bb8:	dc000017 	ldw	r16,0(sp)
81130bbc:	dec00204 	addi	sp,sp,8
81130bc0:	f800283a 	ret
81130bc4:	00c002c4 	movi	r3,11
81130bc8:	188bc83a 	sub	r5,r3,r2
81130bcc:	814ad83a 	srl	r5,r16,r5
81130bd0:	00c00434 	movhi	r3,16
81130bd4:	18ffffc4 	addi	r3,r3,-1
81130bd8:	81a0983a 	sll	r16,r16,r6
81130bdc:	2101ffcc 	andi	r4,r4,2047
81130be0:	28ca703a 	and	r5,r5,r3
81130be4:	003fed06 	br	81130b9c <__reset+0xfb110b9c>
81130be8:	0009883a 	mov	r4,zero
81130bec:	000b883a 	mov	r5,zero
81130bf0:	003fea06 	br	81130b9c <__reset+0xfb110b9c>

81130bf4 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81130bf4:	defffb04 	addi	sp,sp,-20
81130bf8:	de00012e 	bgeu	sp,et,81130c00 <alt_busy_sleep+0xc>
81130bfc:	003b68fa 	trap	3
81130c00:	df000415 	stw	fp,16(sp)
81130c04:	df000404 	addi	fp,sp,16
81130c08:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
81130c0c:	008000c4 	movi	r2,3
81130c10:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
81130c14:	e0fffd17 	ldw	r3,-12(fp)
81130c18:	008003f4 	movhi	r2,15
81130c1c:	10909004 	addi	r2,r2,16960
81130c20:	1887383a 	mul	r3,r3,r2
81130c24:	00817db4 	movhi	r2,1526
81130c28:	10b84004 	addi	r2,r2,-7936
81130c2c:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
81130c30:	00a00034 	movhi	r2,32768
81130c34:	10bfffc4 	addi	r2,r2,-1
81130c38:	10c5203a 	divu	r2,r2,r3
81130c3c:	e0ffff17 	ldw	r3,-4(fp)
81130c40:	1885203a 	divu	r2,r3,r2
81130c44:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
81130c48:	e0bffe17 	ldw	r2,-8(fp)
81130c4c:	10002526 	beq	r2,zero,81130ce4 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
81130c50:	e03ffc15 	stw	zero,-16(fp)
81130c54:	00001406 	br	81130ca8 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81130c58:	00a00034 	movhi	r2,32768
81130c5c:	10bfffc4 	addi	r2,r2,-1
81130c60:	10bfffc4 	addi	r2,r2,-1
81130c64:	103ffe1e 	bne	r2,zero,81130c60 <__reset+0xfb110c60>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81130c68:	e0fffd17 	ldw	r3,-12(fp)
81130c6c:	008003f4 	movhi	r2,15
81130c70:	10909004 	addi	r2,r2,16960
81130c74:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81130c78:	00817db4 	movhi	r2,1526
81130c7c:	10b84004 	addi	r2,r2,-7936
81130c80:	10c7203a 	divu	r3,r2,r3
81130c84:	00a00034 	movhi	r2,32768
81130c88:	10bfffc4 	addi	r2,r2,-1
81130c8c:	10c5203a 	divu	r2,r2,r3
81130c90:	e0ffff17 	ldw	r3,-4(fp)
81130c94:	1885c83a 	sub	r2,r3,r2
81130c98:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81130c9c:	e0bffc17 	ldw	r2,-16(fp)
81130ca0:	10800044 	addi	r2,r2,1
81130ca4:	e0bffc15 	stw	r2,-16(fp)
81130ca8:	e0fffc17 	ldw	r3,-16(fp)
81130cac:	e0bffe17 	ldw	r2,-8(fp)
81130cb0:	18bfe916 	blt	r3,r2,81130c58 <__reset+0xfb110c58>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81130cb4:	e0fffd17 	ldw	r3,-12(fp)
81130cb8:	008003f4 	movhi	r2,15
81130cbc:	10909004 	addi	r2,r2,16960
81130cc0:	1887383a 	mul	r3,r3,r2
81130cc4:	00817db4 	movhi	r2,1526
81130cc8:	10b84004 	addi	r2,r2,-7936
81130ccc:	10c7203a 	divu	r3,r2,r3
81130cd0:	e0bfff17 	ldw	r2,-4(fp)
81130cd4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81130cd8:	10bfffc4 	addi	r2,r2,-1
81130cdc:	103ffe1e 	bne	r2,zero,81130cd8 <__reset+0xfb110cd8>
81130ce0:	00000b06 	br	81130d10 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81130ce4:	e0fffd17 	ldw	r3,-12(fp)
81130ce8:	008003f4 	movhi	r2,15
81130cec:	10909004 	addi	r2,r2,16960
81130cf0:	1887383a 	mul	r3,r3,r2
81130cf4:	00817db4 	movhi	r2,1526
81130cf8:	10b84004 	addi	r2,r2,-7936
81130cfc:	10c7203a 	divu	r3,r2,r3
81130d00:	e0bfff17 	ldw	r2,-4(fp)
81130d04:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81130d08:	10bfffc4 	addi	r2,r2,-1
81130d0c:	00bffe16 	blt	zero,r2,81130d08 <__reset+0xfb110d08>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81130d10:	0005883a 	mov	r2,zero
}
81130d14:	e037883a 	mov	sp,fp
81130d18:	df000017 	ldw	fp,0(sp)
81130d1c:	dec00104 	addi	sp,sp,4
81130d20:	f800283a 	ret

81130d24 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81130d24:	defffe04 	addi	sp,sp,-8
81130d28:	de00012e 	bgeu	sp,et,81130d30 <alt_get_errno+0xc>
81130d2c:	003b68fa 	trap	3
81130d30:	dfc00115 	stw	ra,4(sp)
81130d34:	df000015 	stw	fp,0(sp)
81130d38:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81130d3c:	d0a01017 	ldw	r2,-32704(gp)
81130d40:	10000326 	beq	r2,zero,81130d50 <alt_get_errno+0x2c>
81130d44:	d0a01017 	ldw	r2,-32704(gp)
81130d48:	103ee83a 	callr	r2
81130d4c:	00000106 	br	81130d54 <alt_get_errno+0x30>
81130d50:	d0a07204 	addi	r2,gp,-32312
}
81130d54:	e037883a 	mov	sp,fp
81130d58:	dfc00117 	ldw	ra,4(sp)
81130d5c:	df000017 	ldw	fp,0(sp)
81130d60:	dec00204 	addi	sp,sp,8
81130d64:	f800283a 	ret

81130d68 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81130d68:	defffb04 	addi	sp,sp,-20
81130d6c:	de00012e 	bgeu	sp,et,81130d74 <close+0xc>
81130d70:	003b68fa 	trap	3
81130d74:	dfc00415 	stw	ra,16(sp)
81130d78:	df000315 	stw	fp,12(sp)
81130d7c:	df000304 	addi	fp,sp,12
81130d80:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81130d84:	e0bfff17 	ldw	r2,-4(fp)
81130d88:	10000616 	blt	r2,zero,81130da4 <close+0x3c>
81130d8c:	e0bfff17 	ldw	r2,-4(fp)
81130d90:	10c00324 	muli	r3,r2,12
81130d94:	00a04574 	movhi	r2,33045
81130d98:	10ae3604 	addi	r2,r2,-18216
81130d9c:	1885883a 	add	r2,r3,r2
81130da0:	00000106 	br	81130da8 <close+0x40>
81130da4:	0005883a 	mov	r2,zero
81130da8:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81130dac:	e0bffd17 	ldw	r2,-12(fp)
81130db0:	10001926 	beq	r2,zero,81130e18 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81130db4:	e0bffd17 	ldw	r2,-12(fp)
81130db8:	10800017 	ldw	r2,0(r2)
81130dbc:	10800417 	ldw	r2,16(r2)
81130dc0:	10000626 	beq	r2,zero,81130ddc <close+0x74>
81130dc4:	e0bffd17 	ldw	r2,-12(fp)
81130dc8:	10800017 	ldw	r2,0(r2)
81130dcc:	10800417 	ldw	r2,16(r2)
81130dd0:	e13ffd17 	ldw	r4,-12(fp)
81130dd4:	103ee83a 	callr	r2
81130dd8:	00000106 	br	81130de0 <close+0x78>
81130ddc:	0005883a 	mov	r2,zero
81130de0:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
81130de4:	e13fff17 	ldw	r4,-4(fp)
81130de8:	113234c0 	call	8113234c <alt_release_fd>
    if (rval < 0)
81130dec:	e0bffe17 	ldw	r2,-8(fp)
81130df0:	1000070e 	bge	r2,zero,81130e10 <close+0xa8>
    {
      ALT_ERRNO = -rval;
81130df4:	1130d240 	call	81130d24 <alt_get_errno>
81130df8:	1007883a 	mov	r3,r2
81130dfc:	e0bffe17 	ldw	r2,-8(fp)
81130e00:	0085c83a 	sub	r2,zero,r2
81130e04:	18800015 	stw	r2,0(r3)
      return -1;
81130e08:	00bfffc4 	movi	r2,-1
81130e0c:	00000706 	br	81130e2c <close+0xc4>
    }
    return 0;
81130e10:	0005883a 	mov	r2,zero
81130e14:	00000506 	br	81130e2c <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
81130e18:	1130d240 	call	81130d24 <alt_get_errno>
81130e1c:	1007883a 	mov	r3,r2
81130e20:	00801444 	movi	r2,81
81130e24:	18800015 	stw	r2,0(r3)
    return -1;
81130e28:	00bfffc4 	movi	r2,-1
  }
}
81130e2c:	e037883a 	mov	sp,fp
81130e30:	dfc00117 	ldw	ra,4(sp)
81130e34:	df000017 	ldw	fp,0(sp)
81130e38:	dec00204 	addi	sp,sp,8
81130e3c:	f800283a 	ret

81130e40 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
81130e40:	deffff04 	addi	sp,sp,-4
81130e44:	de00012e 	bgeu	sp,et,81130e4c <alt_dcache_flush_all+0xc>
81130e48:	003b68fa 	trap	3
81130e4c:	df000015 	stw	fp,0(sp)
81130e50:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81130e54:	0001883a 	nop
81130e58:	e037883a 	mov	sp,fp
81130e5c:	df000017 	ldw	fp,0(sp)
81130e60:	dec00104 	addi	sp,sp,4
81130e64:	f800283a 	ret

81130e68 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81130e68:	defffc04 	addi	sp,sp,-16
81130e6c:	de00012e 	bgeu	sp,et,81130e74 <alt_dev_null_write+0xc>
81130e70:	003b68fa 	trap	3
81130e74:	df000315 	stw	fp,12(sp)
81130e78:	df000304 	addi	fp,sp,12
81130e7c:	e13ffd15 	stw	r4,-12(fp)
81130e80:	e17ffe15 	stw	r5,-8(fp)
81130e84:	e1bfff15 	stw	r6,-4(fp)
  return len;
81130e88:	e0bfff17 	ldw	r2,-4(fp)
}
81130e8c:	e037883a 	mov	sp,fp
81130e90:	df000017 	ldw	fp,0(sp)
81130e94:	dec00104 	addi	sp,sp,4
81130e98:	f800283a 	ret

81130e9c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81130e9c:	defffe04 	addi	sp,sp,-8
81130ea0:	de00012e 	bgeu	sp,et,81130ea8 <alt_get_errno+0xc>
81130ea4:	003b68fa 	trap	3
81130ea8:	dfc00115 	stw	ra,4(sp)
81130eac:	df000015 	stw	fp,0(sp)
81130eb0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81130eb4:	d0a01017 	ldw	r2,-32704(gp)
81130eb8:	10000326 	beq	r2,zero,81130ec8 <alt_get_errno+0x2c>
81130ebc:	d0a01017 	ldw	r2,-32704(gp)
81130ec0:	103ee83a 	callr	r2
81130ec4:	00000106 	br	81130ecc <alt_get_errno+0x30>
81130ec8:	d0a07204 	addi	r2,gp,-32312
}
81130ecc:	e037883a 	mov	sp,fp
81130ed0:	dfc00117 	ldw	ra,4(sp)
81130ed4:	df000017 	ldw	fp,0(sp)
81130ed8:	dec00204 	addi	sp,sp,8
81130edc:	f800283a 	ret

81130ee0 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
81130ee0:	defffb04 	addi	sp,sp,-20
81130ee4:	de00012e 	bgeu	sp,et,81130eec <fstat+0xc>
81130ee8:	003b68fa 	trap	3
81130eec:	dfc00415 	stw	ra,16(sp)
81130ef0:	df000315 	stw	fp,12(sp)
81130ef4:	df000304 	addi	fp,sp,12
81130ef8:	e13ffe15 	stw	r4,-8(fp)
81130efc:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81130f00:	e0bffe17 	ldw	r2,-8(fp)
81130f04:	10000616 	blt	r2,zero,81130f20 <fstat+0x40>
81130f08:	e0bffe17 	ldw	r2,-8(fp)
81130f0c:	10c00324 	muli	r3,r2,12
81130f10:	00a04574 	movhi	r2,33045
81130f14:	10ae3604 	addi	r2,r2,-18216
81130f18:	1885883a 	add	r2,r3,r2
81130f1c:	00000106 	br	81130f24 <fstat+0x44>
81130f20:	0005883a 	mov	r2,zero
81130f24:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
81130f28:	e0bffd17 	ldw	r2,-12(fp)
81130f2c:	10001026 	beq	r2,zero,81130f70 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
81130f30:	e0bffd17 	ldw	r2,-12(fp)
81130f34:	10800017 	ldw	r2,0(r2)
81130f38:	10800817 	ldw	r2,32(r2)
81130f3c:	10000726 	beq	r2,zero,81130f5c <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
81130f40:	e0bffd17 	ldw	r2,-12(fp)
81130f44:	10800017 	ldw	r2,0(r2)
81130f48:	10800817 	ldw	r2,32(r2)
81130f4c:	e17fff17 	ldw	r5,-4(fp)
81130f50:	e13ffd17 	ldw	r4,-12(fp)
81130f54:	103ee83a 	callr	r2
81130f58:	00000a06 	br	81130f84 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
81130f5c:	e0bfff17 	ldw	r2,-4(fp)
81130f60:	00c80004 	movi	r3,8192
81130f64:	10c00115 	stw	r3,4(r2)
      return 0;
81130f68:	0005883a 	mov	r2,zero
81130f6c:	00000506 	br	81130f84 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81130f70:	1130e9c0 	call	81130e9c <alt_get_errno>
81130f74:	1007883a 	mov	r3,r2
81130f78:	00801444 	movi	r2,81
81130f7c:	18800015 	stw	r2,0(r3)
    return -1;
81130f80:	00bfffc4 	movi	r2,-1
  }
}
81130f84:	e037883a 	mov	sp,fp
81130f88:	dfc00117 	ldw	ra,4(sp)
81130f8c:	df000017 	ldw	fp,0(sp)
81130f90:	dec00204 	addi	sp,sp,8
81130f94:	f800283a 	ret

81130f98 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81130f98:	defff004 	addi	sp,sp,-64
81130f9c:	de00012e 	bgeu	sp,et,81130fa4 <alt_irq_register+0xc>
81130fa0:	003b68fa 	trap	3
81130fa4:	df000f15 	stw	fp,60(sp)
81130fa8:	df000f04 	addi	fp,sp,60
81130fac:	e13ffd15 	stw	r4,-12(fp)
81130fb0:	e17ffe15 	stw	r5,-8(fp)
81130fb4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81130fb8:	00bffa84 	movi	r2,-22
81130fbc:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81130fc0:	e0bffd17 	ldw	r2,-12(fp)
81130fc4:	10800828 	cmpgeui	r2,r2,32
81130fc8:	1000501e 	bne	r2,zero,8113110c <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130fcc:	0005303a 	rdctl	r2,status
81130fd0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130fd4:	e0fff617 	ldw	r3,-40(fp)
81130fd8:	00bfff84 	movi	r2,-2
81130fdc:	1884703a 	and	r2,r3,r2
81130fe0:	1001703a 	wrctl	status,r2
  
  return context;
81130fe4:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
81130fe8:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
81130fec:	00a045b4 	movhi	r2,33046
81130ff0:	10991b04 	addi	r2,r2,25708
81130ff4:	e0fffd17 	ldw	r3,-12(fp)
81130ff8:	180690fa 	slli	r3,r3,3
81130ffc:	10c5883a 	add	r2,r2,r3
81131000:	e0ffff17 	ldw	r3,-4(fp)
81131004:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
81131008:	00a045b4 	movhi	r2,33046
8113100c:	10991b04 	addi	r2,r2,25708
81131010:	e0fffd17 	ldw	r3,-12(fp)
81131014:	180690fa 	slli	r3,r3,3
81131018:	10c5883a 	add	r2,r2,r3
8113101c:	10800104 	addi	r2,r2,4
81131020:	e0fffe17 	ldw	r3,-8(fp)
81131024:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
81131028:	e0bfff17 	ldw	r2,-4(fp)
8113102c:	10001926 	beq	r2,zero,81131094 <alt_irq_register+0xfc>
81131030:	e0bffd17 	ldw	r2,-12(fp)
81131034:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131038:	0005303a 	rdctl	r2,status
8113103c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131040:	e0fff717 	ldw	r3,-36(fp)
81131044:	00bfff84 	movi	r2,-2
81131048:	1884703a 	and	r2,r3,r2
8113104c:	1001703a 	wrctl	status,r2
  
  return context;
81131050:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81131054:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81131058:	00c00044 	movi	r3,1
8113105c:	e0bff217 	ldw	r2,-56(fp)
81131060:	1884983a 	sll	r2,r3,r2
81131064:	1007883a 	mov	r3,r2
81131068:	d0a07a17 	ldw	r2,-32280(gp)
8113106c:	1884b03a 	or	r2,r3,r2
81131070:	d0a07a15 	stw	r2,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81131074:	d0a07a17 	ldw	r2,-32280(gp)
81131078:	100170fa 	wrctl	ienable,r2
8113107c:	e0bff817 	ldw	r2,-32(fp)
81131080:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131084:	e0bff917 	ldw	r2,-28(fp)
81131088:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113108c:	0005883a 	mov	r2,zero
81131090:	00001906 	br	811310f8 <alt_irq_register+0x160>
81131094:	e0bffd17 	ldw	r2,-12(fp)
81131098:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113109c:	0005303a 	rdctl	r2,status
811310a0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811310a4:	e0fffa17 	ldw	r3,-24(fp)
811310a8:	00bfff84 	movi	r2,-2
811310ac:	1884703a 	and	r2,r3,r2
811310b0:	1001703a 	wrctl	status,r2
  
  return context;
811310b4:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811310b8:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
811310bc:	00c00044 	movi	r3,1
811310c0:	e0bff417 	ldw	r2,-48(fp)
811310c4:	1884983a 	sll	r2,r3,r2
811310c8:	0084303a 	nor	r2,zero,r2
811310cc:	1007883a 	mov	r3,r2
811310d0:	d0a07a17 	ldw	r2,-32280(gp)
811310d4:	1884703a 	and	r2,r3,r2
811310d8:	d0a07a15 	stw	r2,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811310dc:	d0a07a17 	ldw	r2,-32280(gp)
811310e0:	100170fa 	wrctl	ienable,r2
811310e4:	e0bffb17 	ldw	r2,-20(fp)
811310e8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811310ec:	e0bffc17 	ldw	r2,-16(fp)
811310f0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811310f4:	0005883a 	mov	r2,zero
811310f8:	e0bff115 	stw	r2,-60(fp)
811310fc:	e0bff317 	ldw	r2,-52(fp)
81131100:	e0bff515 	stw	r2,-44(fp)
81131104:	e0bff517 	ldw	r2,-44(fp)
81131108:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
8113110c:	e0bff117 	ldw	r2,-60(fp)
}
81131110:	e037883a 	mov	sp,fp
81131114:	df000017 	ldw	fp,0(sp)
81131118:	dec00104 	addi	sp,sp,4
8113111c:	f800283a 	ret

81131120 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81131120:	defffe04 	addi	sp,sp,-8
81131124:	de00012e 	bgeu	sp,et,8113112c <alt_get_errno+0xc>
81131128:	003b68fa 	trap	3
8113112c:	dfc00115 	stw	ra,4(sp)
81131130:	df000015 	stw	fp,0(sp)
81131134:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131138:	d0a01017 	ldw	r2,-32704(gp)
8113113c:	10000326 	beq	r2,zero,8113114c <alt_get_errno+0x2c>
81131140:	d0a01017 	ldw	r2,-32704(gp)
81131144:	103ee83a 	callr	r2
81131148:	00000106 	br	81131150 <alt_get_errno+0x30>
8113114c:	d0a07204 	addi	r2,gp,-32312
}
81131150:	e037883a 	mov	sp,fp
81131154:	dfc00117 	ldw	ra,4(sp)
81131158:	df000017 	ldw	fp,0(sp)
8113115c:	dec00204 	addi	sp,sp,8
81131160:	f800283a 	ret

81131164 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81131164:	deffed04 	addi	sp,sp,-76
81131168:	de00012e 	bgeu	sp,et,81131170 <isatty+0xc>
8113116c:	003b68fa 	trap	3
81131170:	dfc01215 	stw	ra,72(sp)
81131174:	df001115 	stw	fp,68(sp)
81131178:	df001104 	addi	fp,sp,68
8113117c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81131180:	e0bfff17 	ldw	r2,-4(fp)
81131184:	10000616 	blt	r2,zero,811311a0 <isatty+0x3c>
81131188:	e0bfff17 	ldw	r2,-4(fp)
8113118c:	10c00324 	muli	r3,r2,12
81131190:	00a04574 	movhi	r2,33045
81131194:	10ae3604 	addi	r2,r2,-18216
81131198:	1885883a 	add	r2,r3,r2
8113119c:	00000106 	br	811311a4 <isatty+0x40>
811311a0:	0005883a 	mov	r2,zero
811311a4:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
811311a8:	e0bfef17 	ldw	r2,-68(fp)
811311ac:	10000e26 	beq	r2,zero,811311e8 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
811311b0:	e0bfef17 	ldw	r2,-68(fp)
811311b4:	10800017 	ldw	r2,0(r2)
811311b8:	10800817 	ldw	r2,32(r2)
811311bc:	1000021e 	bne	r2,zero,811311c8 <isatty+0x64>
    {
      return 1;
811311c0:	00800044 	movi	r2,1
811311c4:	00000d06 	br	811311fc <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
811311c8:	e0bff004 	addi	r2,fp,-64
811311cc:	100b883a 	mov	r5,r2
811311d0:	e13fff17 	ldw	r4,-4(fp)
811311d4:	1130ee00 	call	81130ee0 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
811311d8:	e0bff117 	ldw	r2,-60(fp)
811311dc:	10880020 	cmpeqi	r2,r2,8192
811311e0:	10803fcc 	andi	r2,r2,255
811311e4:	00000506 	br	811311fc <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
811311e8:	11311200 	call	81131120 <alt_get_errno>
811311ec:	1007883a 	mov	r3,r2
811311f0:	00801444 	movi	r2,81
811311f4:	18800015 	stw	r2,0(r3)
    return 0;
811311f8:	0005883a 	mov	r2,zero
  }
}
811311fc:	e037883a 	mov	sp,fp
81131200:	dfc00117 	ldw	ra,4(sp)
81131204:	df000017 	ldw	fp,0(sp)
81131208:	dec00204 	addi	sp,sp,8
8113120c:	f800283a 	ret

81131210 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81131210:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81131214:	318c2404 	addi	r6,r6,12432

81131218 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
81131218:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
8113121c:	01c00826 	beq	zero,r7,81131240 <end_tx>

81131220 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
81131220:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
81131224:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
81131228:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
8113122c:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
81131230:	283ffb26 	beq	r5,zero,81131220 <__reset+0xfb111220>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81131234:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
81131238:	21000044 	addi	r4,r4,1
	br tx_next_char
8113123c:	003ff606 	br	81131218 <__reset+0xfb111218>

81131240 <end_tx>:
end_tx:	
        ret
81131240:	f800283a 	ret

81131244 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81131244:	defffd04 	addi	sp,sp,-12
81131248:	de00012e 	bgeu	sp,et,81131250 <alt_log_txchar+0xc>
8113124c:	003b68fa 	trap	3
81131250:	df000215 	stw	fp,8(sp)
81131254:	df000204 	addi	fp,sp,8
81131258:	e13ffe15 	stw	r4,-8(fp)
8113125c:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
81131260:	0001883a 	nop
81131264:	e0bfff17 	ldw	r2,-4(fp)
81131268:	10800104 	addi	r2,r2,4
8113126c:	10800037 	ldwio	r2,0(r2)
81131270:	10bfffec 	andhi	r2,r2,65535
81131274:	103ffb26 	beq	r2,zero,81131264 <__reset+0xfb111264>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81131278:	e0bfff17 	ldw	r2,-4(fp)
8113127c:	e0fffe17 	ldw	r3,-8(fp)
81131280:	10c00035 	stwio	r3,0(r2)
}
81131284:	0001883a 	nop
81131288:	e037883a 	mov	sp,fp
8113128c:	df000017 	ldw	fp,0(sp)
81131290:	dec00104 	addi	sp,sp,4
81131294:	f800283a 	ret

81131298 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81131298:	defffb04 	addi	sp,sp,-20
8113129c:	de00012e 	bgeu	sp,et,811312a4 <alt_log_repchar+0xc>
811312a0:	003b68fa 	trap	3
811312a4:	dfc00415 	stw	ra,16(sp)
811312a8:	df000315 	stw	fp,12(sp)
811312ac:	df000304 	addi	fp,sp,12
811312b0:	2005883a 	mov	r2,r4
811312b4:	e17ffe15 	stw	r5,-8(fp)
811312b8:	e1bfff15 	stw	r6,-4(fp)
811312bc:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
811312c0:	00000506 	br	811312d8 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
811312c4:	e0bffd07 	ldb	r2,-12(fp)
811312c8:	e0ffff17 	ldw	r3,-4(fp)
811312cc:	180b883a 	mov	r5,r3
811312d0:	1009883a 	mov	r4,r2
811312d4:	11312440 	call	81131244 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
811312d8:	e0bffe17 	ldw	r2,-8(fp)
811312dc:	10ffffc4 	addi	r3,r2,-1
811312e0:	e0fffe15 	stw	r3,-8(fp)
811312e4:	00bff716 	blt	zero,r2,811312c4 <__reset+0xfb1112c4>
    alt_log_txchar(c,(char*) base);
}
811312e8:	0001883a 	nop
811312ec:	e037883a 	mov	sp,fp
811312f0:	dfc00117 	ldw	ra,4(sp)
811312f4:	df000017 	ldw	fp,0(sp)
811312f8:	dec00204 	addi	sp,sp,8
811312fc:	f800283a 	ret

81131300 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
81131300:	deffe904 	addi	sp,sp,-92
81131304:	de00012e 	bgeu	sp,et,8113130c <alt_log_private_printf+0xc>
81131308:	003b68fa 	trap	3
8113130c:	dfc01615 	stw	ra,88(sp)
81131310:	df001515 	stw	fp,84(sp)
81131314:	dc001415 	stw	r16,80(sp)
81131318:	df001504 	addi	fp,sp,84
8113131c:	e13ffc15 	stw	r4,-16(fp)
81131320:	e17ffd15 	stw	r5,-12(fp)
81131324:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
81131328:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
8113132c:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
81131330:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
81131334:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
81131338:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
8113133c:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
81131340:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
81131344:	e0bffc17 	ldw	r2,-16(fp)
81131348:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
8113134c:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
81131350:	00014b06 	br	81131880 <alt_log_private_printf+0x580>
    {
    switch(state)
81131354:	e0bfec17 	ldw	r2,-80(fp)
81131358:	10c00060 	cmpeqi	r3,r2,1
8113135c:	18001b1e 	bne	r3,zero,811313cc <alt_log_private_printf+0xcc>
81131360:	10c000a0 	cmpeqi	r3,r2,2
81131364:	18002d1e 	bne	r3,zero,8113141c <alt_log_private_printf+0x11c>
81131368:	10000126 	beq	r2,zero,81131370 <alt_log_private_printf+0x70>
8113136c:	00014406 	br	81131880 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81131370:	e0bffb07 	ldb	r2,-20(fp)
81131374:	10800958 	cmpnei	r2,r2,37
81131378:	10000e1e 	bne	r2,zero,811313b4 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
8113137c:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81131380:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81131384:	00800284 	movi	r2,10
81131388:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
8113138c:	00800044 	movi	r2,1
81131390:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81131394:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81131398:	00bfffc4 	movi	r2,-1
8113139c:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
811313a0:	00bfffc4 	movi	r2,-1
811313a4:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
811313a8:	00800044 	movi	r2,1
811313ac:	e0bfec15 	stw	r2,-80(fp)
811313b0:	00013306 	br	81131880 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
811313b4:	e0bffb07 	ldb	r2,-20(fp)
811313b8:	e0fffd17 	ldw	r3,-12(fp)
811313bc:	180b883a 	mov	r5,r3
811313c0:	1009883a 	mov	r4,r2
811313c4:	11312440 	call	81131244 <alt_log_txchar>
        }
        break;
811313c8:	00012d06 	br	81131880 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
811313cc:	e0bffb07 	ldb	r2,-20(fp)
811313d0:	10800c18 	cmpnei	r2,r2,48
811313d4:	1000051e 	bne	r2,zero,811313ec <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
811313d8:	00800044 	movi	r2,1
811313dc:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
811313e0:	00800084 	movi	r2,2
811313e4:	e0bfec15 	stw	r2,-80(fp)
811313e8:	00012506 	br	81131880 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
811313ec:	e0bffb07 	ldb	r2,-20(fp)
811313f0:	10800958 	cmpnei	r2,r2,37
811313f4:	1000071e 	bne	r2,zero,81131414 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
811313f8:	e0bffb07 	ldb	r2,-20(fp)
811313fc:	e0fffd17 	ldw	r3,-12(fp)
81131400:	180b883a 	mov	r5,r3
81131404:	1009883a 	mov	r4,r2
81131408:	11312440 	call	81131244 <alt_log_txchar>
          state = pfState_chars;
8113140c:	e03fec15 	stw	zero,-80(fp)
81131410:	00011b06 	br	81131880 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81131414:	00800084 	movi	r2,2
81131418:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
8113141c:	e0bffb07 	ldb	r2,-20(fp)
81131420:	10800b98 	cmpnei	r2,r2,46
81131424:	1000021e 	bne	r2,zero,81131430 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81131428:	e03ff015 	stw	zero,-64(fp)
8113142c:	00011306 	br	8113187c <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81131430:	e0bffb07 	ldb	r2,-20(fp)
81131434:	10800c10 	cmplti	r2,r2,48
81131438:	10001a1e 	bne	r2,zero,811314a4 <alt_log_private_printf+0x1a4>
8113143c:	e0bffb07 	ldb	r2,-20(fp)
81131440:	10800e88 	cmpgei	r2,r2,58
81131444:	1000171e 	bne	r2,zero,811314a4 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81131448:	e0bffb03 	ldbu	r2,-20(fp)
8113144c:	10bff404 	addi	r2,r2,-48
81131450:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81131454:	e0bff017 	ldw	r2,-64(fp)
81131458:	10000c0e 	bge	r2,zero,8113148c <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
8113145c:	e0bfef17 	ldw	r2,-68(fp)
81131460:	1000020e 	bge	r2,zero,8113146c <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81131464:	e03fef15 	stw	zero,-68(fp)
81131468:	00000306 	br	81131478 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
8113146c:	e0bfef17 	ldw	r2,-68(fp)
81131470:	108002a4 	muli	r2,r2,10
81131474:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81131478:	e0bffb07 	ldb	r2,-20(fp)
8113147c:	e0ffef17 	ldw	r3,-68(fp)
81131480:	1885883a 	add	r2,r3,r2
81131484:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81131488:	0000fc06 	br	8113187c <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
8113148c:	e0bff017 	ldw	r2,-64(fp)
81131490:	10c002a4 	muli	r3,r2,10
81131494:	e0bffb07 	ldb	r2,-20(fp)
81131498:	1885883a 	add	r2,r3,r2
8113149c:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
811314a0:	0000f606 	br	8113187c <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
811314a4:	e0bffb07 	ldb	r2,-20(fp)
811314a8:	10801b18 	cmpnei	r2,r2,108
811314ac:	1000031e 	bne	r2,zero,811314bc <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
811314b0:	00800044 	movi	r2,1
811314b4:	e0bfee15 	stw	r2,-72(fp)
811314b8:	0000f006 	br	8113187c <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
811314bc:	e0bffb07 	ldb	r2,-20(fp)
811314c0:	10bfea04 	addi	r2,r2,-88
811314c4:	10c00868 	cmpgeui	r3,r2,33
811314c8:	1800eb1e 	bne	r3,zero,81131878 <alt_log_private_printf+0x578>
811314cc:	100690ba 	slli	r3,r2,2
811314d0:	00a044f4 	movhi	r2,33043
811314d4:	10853904 	addi	r2,r2,5348
811314d8:	1885883a 	add	r2,r3,r2
811314dc:	10800017 	ldw	r2,0(r2)
811314e0:	1000683a 	jmp	r2
811314e4:	811317a4 	muli	r4,r16,19550
811314e8:	81131878 	rdprs	r4,r16,19553
811314ec:	81131878 	rdprs	r4,r16,19553
811314f0:	81131878 	rdprs	r4,r16,19553
811314f4:	81131878 	rdprs	r4,r16,19553
811314f8:	81131878 	rdprs	r4,r16,19553
811314fc:	81131878 	rdprs	r4,r16,19553
81131500:	81131878 	rdprs	r4,r16,19553
81131504:	81131878 	rdprs	r4,r16,19553
81131508:	81131878 	rdprs	r4,r16,19553
8113150c:	81131878 	rdprs	r4,r16,19553
81131510:	811317bc 	xorhi	r4,r16,19550
81131514:	81131568 	cmpgeui	r4,r16,19541
81131518:	81131878 	rdprs	r4,r16,19553
8113151c:	81131878 	rdprs	r4,r16,19553
81131520:	81131878 	rdprs	r4,r16,19553
81131524:	81131878 	rdprs	r4,r16,19553
81131528:	81131568 	cmpgeui	r4,r16,19541
8113152c:	81131878 	rdprs	r4,r16,19553
81131530:	81131878 	rdprs	r4,r16,19553
81131534:	81131878 	rdprs	r4,r16,19553
81131538:	81131878 	rdprs	r4,r16,19553
8113153c:	81131878 	rdprs	r4,r16,19553
81131540:	81131784 	addi	r4,r16,19550
81131544:	81131878 	rdprs	r4,r16,19553
81131548:	81131878 	rdprs	r4,r16,19553
8113154c:	81131878 	rdprs	r4,r16,19553
81131550:	811317f8 	rdprs	r4,r16,19551
81131554:	81131878 	rdprs	r4,r16,19553
81131558:	8113177c 	xorhi	r4,r16,19549
8113155c:	81131878 	rdprs	r4,r16,19553
81131560:	81131878 	rdprs	r4,r16,19553
81131564:	81131794 	ori	r4,r16,19550
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81131568:	e0bfee17 	ldw	r2,-72(fp)
8113156c:	10000e26 	beq	r2,zero,811315a8 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81131570:	e0bff217 	ldw	r2,-56(fp)
81131574:	10000626 	beq	r2,zero,81131590 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81131578:	e0bffe17 	ldw	r2,-8(fp)
8113157c:	10c00104 	addi	r3,r2,4
81131580:	e0fffe15 	stw	r3,-8(fp)
81131584:	10800017 	ldw	r2,0(r2)
81131588:	e0bff415 	stw	r2,-48(fp)
8113158c:	00001306 	br	811315dc <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81131590:	e0bffe17 	ldw	r2,-8(fp)
81131594:	10c00104 	addi	r3,r2,4
81131598:	e0fffe15 	stw	r3,-8(fp)
8113159c:	10800017 	ldw	r2,0(r2)
811315a0:	e0bff415 	stw	r2,-48(fp)
811315a4:	00000d06 	br	811315dc <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
811315a8:	e0bff217 	ldw	r2,-56(fp)
811315ac:	10000626 	beq	r2,zero,811315c8 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
811315b0:	e0bffe17 	ldw	r2,-8(fp)
811315b4:	10c00104 	addi	r3,r2,4
811315b8:	e0fffe15 	stw	r3,-8(fp)
811315bc:	10800017 	ldw	r2,0(r2)
811315c0:	e0bff415 	stw	r2,-48(fp)
811315c4:	00000506 	br	811315dc <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
811315c8:	e0bffe17 	ldw	r2,-8(fp)
811315cc:	10c00104 	addi	r3,r2,4
811315d0:	e0fffe15 	stw	r3,-8(fp)
811315d4:	10800017 	ldw	r2,0(r2)
811315d8:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
811315dc:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
811315e0:	e0bff217 	ldw	r2,-56(fp)
811315e4:	10000726 	beq	r2,zero,81131604 <alt_log_private_printf+0x304>
811315e8:	e0bff417 	ldw	r2,-48(fp)
811315ec:	1000050e 	bge	r2,zero,81131604 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
811315f0:	e0bff417 	ldw	r2,-48(fp)
811315f4:	0085c83a 	sub	r2,zero,r2
811315f8:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
811315fc:	00800044 	movi	r2,1
81131600:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81131604:	e0bff417 	ldw	r2,-48(fp)
81131608:	e0bff615 	stw	r2,-40(fp)
                p = 1;
8113160c:	00800044 	movi	r2,1
81131610:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81131614:	00800044 	movi	r2,1
81131618:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
8113161c:	00000706 	br	8113163c <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81131620:	e0bff817 	ldw	r2,-32(fp)
81131624:	10800044 	addi	r2,r2,1
81131628:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
8113162c:	e0bff117 	ldw	r2,-60(fp)
81131630:	e0fff517 	ldw	r3,-44(fp)
81131634:	1885383a 	mul	r2,r3,r2
81131638:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
8113163c:	e0bff117 	ldw	r2,-60(fp)
81131640:	e0fff617 	ldw	r3,-40(fp)
81131644:	1885203a 	divu	r2,r3,r2
81131648:	e0bff615 	stw	r2,-40(fp)
8113164c:	e0bff617 	ldw	r2,-40(fp)
81131650:	103ff31e 	bne	r2,zero,81131620 <__reset+0xfb111620>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81131654:	e0ffef17 	ldw	r3,-68(fp)
81131658:	e0bff817 	ldw	r2,-32(fp)
8113165c:	1885c83a 	sub	r2,r3,r2
81131660:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81131664:	e0bfed17 	ldw	r2,-76(fp)
81131668:	10000e26 	beq	r2,zero,811316a4 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
8113166c:	e0bff717 	ldw	r2,-36(fp)
81131670:	10000726 	beq	r2,zero,81131690 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81131674:	e0bffd17 	ldw	r2,-12(fp)
81131678:	100b883a 	mov	r5,r2
8113167c:	01000b44 	movi	r4,45
81131680:	11312440 	call	81131244 <alt_log_txchar>
                    fmtBeforeDecimal--;
81131684:	e0bfef17 	ldw	r2,-68(fp)
81131688:	10bfffc4 	addi	r2,r2,-1
8113168c:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81131690:	e1bffd17 	ldw	r6,-12(fp)
81131694:	e17fef17 	ldw	r5,-68(fp)
81131698:	01000c04 	movi	r4,48
8113169c:	11312980 	call	81131298 <alt_log_repchar>
811316a0:	00003206 	br	8113176c <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
811316a4:	e0bff717 	ldw	r2,-36(fp)
811316a8:	10000326 	beq	r2,zero,811316b8 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
811316ac:	e0bfef17 	ldw	r2,-68(fp)
811316b0:	10bfffc4 	addi	r2,r2,-1
811316b4:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
811316b8:	e1bffd17 	ldw	r6,-12(fp)
811316bc:	e17fef17 	ldw	r5,-68(fp)
811316c0:	01000804 	movi	r4,32
811316c4:	11312980 	call	81131298 <alt_log_repchar>
                    if(sign)
811316c8:	e0bff717 	ldw	r2,-36(fp)
811316cc:	10002726 	beq	r2,zero,8113176c <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
811316d0:	e0bffd17 	ldw	r2,-12(fp)
811316d4:	100b883a 	mov	r5,r2
811316d8:	01000b44 	movi	r4,45
811316dc:	11312440 	call	81131244 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
811316e0:	00002206 	br	8113176c <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
811316e4:	e0fff417 	ldw	r3,-48(fp)
811316e8:	e0bff517 	ldw	r2,-44(fp)
811316ec:	1885203a 	divu	r2,r3,r2
811316f0:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
811316f4:	e0bff903 	ldbu	r2,-28(fp)
811316f8:	10800c04 	addi	r2,r2,48
811316fc:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81131700:	e0bff903 	ldbu	r2,-28(fp)
81131704:	10800eb0 	cmpltui	r2,r2,58
81131708:	1000081e 	bne	r2,zero,8113172c <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
8113170c:	e0bff317 	ldw	r2,-52(fp)
81131710:	10000226 	beq	r2,zero,8113171c <alt_log_private_printf+0x41c>
81131714:	008001c4 	movi	r2,7
81131718:	00000106 	br	81131720 <alt_log_private_printf+0x420>
8113171c:	008009c4 	movi	r2,39
81131720:	e0fff903 	ldbu	r3,-28(fp)
81131724:	10c5883a 	add	r2,r2,r3
81131728:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
8113172c:	e0bff903 	ldbu	r2,-28(fp)
81131730:	e0fffd17 	ldw	r3,-12(fp)
81131734:	180b883a 	mov	r5,r3
81131738:	1009883a 	mov	r4,r2
8113173c:	11312440 	call	81131244 <alt_log_txchar>

                  v = v % p;
81131740:	e0bff417 	ldw	r2,-48(fp)
81131744:	e0fff517 	ldw	r3,-44(fp)
81131748:	10c9203a 	divu	r4,r2,r3
8113174c:	e0fff517 	ldw	r3,-44(fp)
81131750:	20c7383a 	mul	r3,r4,r3
81131754:	10c5c83a 	sub	r2,r2,r3
81131758:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
8113175c:	e0bff117 	ldw	r2,-60(fp)
81131760:	e0fff517 	ldw	r3,-44(fp)
81131764:	1885203a 	divu	r2,r3,r2
81131768:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
8113176c:	e0bff517 	ldw	r2,-44(fp)
81131770:	103fdc1e 	bne	r2,zero,811316e4 <__reset+0xfb1116e4>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81131774:	e03fec15 	stw	zero,-80(fp)
              break;
81131778:	00003f06 	br	81131878 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
8113177c:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81131780:	003f7906 	br	81131568 <__reset+0xfb111568>
            case 'o':
              fmtSigned = 0;
81131784:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81131788:	00800204 	movi	r2,8
8113178c:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81131790:	003f7506 	br	81131568 <__reset+0xfb111568>
            case 'x':
              fmtSigned = 0;
81131794:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81131798:	00800404 	movi	r2,16
8113179c:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
811317a0:	003f7106 	br	81131568 <__reset+0xfb111568>
            case 'X':
              fmtSigned = 0;
811317a4:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
811317a8:	00800404 	movi	r2,16
811317ac:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
811317b0:	00800044 	movi	r2,1
811317b4:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
811317b8:	003f6b06 	br	81131568 <__reset+0xfb111568>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
811317bc:	e0bfef17 	ldw	r2,-68(fp)
811317c0:	10bfffc4 	addi	r2,r2,-1
811317c4:	e1bffd17 	ldw	r6,-12(fp)
811317c8:	100b883a 	mov	r5,r2
811317cc:	01000804 	movi	r4,32
811317d0:	11312980 	call	81131298 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
811317d4:	e0bffe17 	ldw	r2,-8(fp)
811317d8:	10c00104 	addi	r3,r2,4
811317dc:	e0fffe15 	stw	r3,-8(fp)
811317e0:	10800017 	ldw	r2,0(r2)
811317e4:	e0fffd17 	ldw	r3,-12(fp)
811317e8:	180b883a 	mov	r5,r3
811317ec:	1009883a 	mov	r4,r2
811317f0:	11312440 	call	81131244 <alt_log_txchar>
              break;
811317f4:	00002006 	br	81131878 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
811317f8:	e0bffe17 	ldw	r2,-8(fp)
811317fc:	10c00104 	addi	r3,r2,4
81131800:	e0fffe15 	stw	r3,-8(fp)
81131804:	10800017 	ldw	r2,0(r2)
81131808:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
8113180c:	e43fef17 	ldw	r16,-68(fp)
81131810:	e13ffa17 	ldw	r4,-24(fp)
81131814:	111cf340 	call	8111cf34 <strlen>
81131818:	8085c83a 	sub	r2,r16,r2
8113181c:	e1bffd17 	ldw	r6,-12(fp)
81131820:	100b883a 	mov	r5,r2
81131824:	01000804 	movi	r4,32
81131828:	11312980 	call	81131298 <alt_log_repchar>

                while(*s)
8113182c:	00000b06 	br	8113185c <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81131830:	e0bffa17 	ldw	r2,-24(fp)
81131834:	10c00044 	addi	r3,r2,1
81131838:	e0fffa15 	stw	r3,-24(fp)
8113183c:	10800003 	ldbu	r2,0(r2)
81131840:	10803fcc 	andi	r2,r2,255
81131844:	1080201c 	xori	r2,r2,128
81131848:	10bfe004 	addi	r2,r2,-128
8113184c:	e0fffd17 	ldw	r3,-12(fp)
81131850:	180b883a 	mov	r5,r3
81131854:	1009883a 	mov	r4,r2
81131858:	11312440 	call	81131244 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
8113185c:	e0bffa17 	ldw	r2,-24(fp)
81131860:	10800003 	ldbu	r2,0(r2)
81131864:	10803fcc 	andi	r2,r2,255
81131868:	1080201c 	xori	r2,r2,128
8113186c:	10bfe004 	addi	r2,r2,-128
81131870:	103fef1e 	bne	r2,zero,81131830 <__reset+0xfb111830>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81131874:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81131878:	e03fec15 	stw	zero,-80(fp)
          }
        break;
8113187c:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81131880:	e0bfeb17 	ldw	r2,-84(fp)
81131884:	10c00044 	addi	r3,r2,1
81131888:	e0ffeb15 	stw	r3,-84(fp)
8113188c:	10800003 	ldbu	r2,0(r2)
81131890:	e0bffb05 	stb	r2,-20(fp)
81131894:	e0bffb07 	ldb	r2,-20(fp)
81131898:	103eae1e 	bne	r2,zero,81131354 <__reset+0xfb111354>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
8113189c:	0001883a 	nop
811318a0:	e6ffff04 	addi	sp,fp,-4
811318a4:	dfc00217 	ldw	ra,8(sp)
811318a8:	df000117 	ldw	fp,4(sp)
811318ac:	dc000017 	ldw	r16,0(sp)
811318b0:	dec00304 	addi	sp,sp,12
811318b4:	f800283a 	ret

811318b8 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
811318b8:	defff904 	addi	sp,sp,-28
811318bc:	de00012e 	bgeu	sp,et,811318c4 <alt_log_printf_proc+0xc>
811318c0:	003b68fa 	trap	3
811318c4:	dfc00315 	stw	ra,12(sp)
811318c8:	df000215 	stw	fp,8(sp)
811318cc:	df000204 	addi	fp,sp,8
811318d0:	e13fff15 	stw	r4,-4(fp)
811318d4:	e1400215 	stw	r5,8(fp)
811318d8:	e1800315 	stw	r6,12(fp)
811318dc:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
811318e0:	e0800204 	addi	r2,fp,8
811318e4:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
811318e8:	e0bffe17 	ldw	r2,-8(fp)
811318ec:	100d883a 	mov	r6,r2
811318f0:	01604834 	movhi	r5,33056
811318f4:	294c2404 	addi	r5,r5,12432
811318f8:	e13fff17 	ldw	r4,-4(fp)
811318fc:	11313000 	call	81131300 <alt_log_private_printf>
    return (0);
81131900:	0005883a 	mov	r2,zero
}
81131904:	e037883a 	mov	sp,fp
81131908:	dfc00117 	ldw	ra,4(sp)
8113190c:	df000017 	ldw	fp,0(sp)
81131910:	dec00504 	addi	sp,sp,20
81131914:	f800283a 	ret

81131918 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81131918:	defff904 	addi	sp,sp,-28
8113191c:	de00012e 	bgeu	sp,et,81131924 <altera_avalon_jtag_uart_report_log+0xc>
81131920:	003b68fa 	trap	3
81131924:	dfc00615 	stw	ra,24(sp)
81131928:	df000515 	stw	fp,20(sp)
8113192c:	dc400415 	stw	r17,16(sp)
81131930:	dc000315 	stw	r16,12(sp)
81131934:	df000504 	addi	fp,sp,20
81131938:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
8113193c:	d0a07b83 	ldbu	r2,-32274(gp)
81131940:	10803fcc 	andi	r2,r2,255
81131944:	10001426 	beq	r2,zero,81131998 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81131948:	e0bffd17 	ldw	r2,-12(fp)
8113194c:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81131950:	00a04574 	movhi	r2,33045
81131954:	10aa5c04 	addi	r2,r2,-22160
81131958:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
8113195c:	e0bffb17 	ldw	r2,-20(fp)
81131960:	10800017 	ldw	r2,0(r2)
81131964:	e1bffc17 	ldw	r6,-16(fp)
81131968:	100b883a 	mov	r5,r2
8113196c:	e13ffb17 	ldw	r4,-20(fp)
81131970:	11319b80 	call	811319b8 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81131974:	d0e08217 	ldw	r3,-32248(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81131978:	00b33374 	movhi	r2,52429
8113197c:	10b33344 	addi	r2,r2,-13107
81131980:	1888383a 	mulxuu	r4,r3,r2
81131984:	1885383a 	mul	r2,r3,r2
81131988:	1021883a 	mov	r16,r2
8113198c:	2023883a 	mov	r17,r4
81131990:	8804d0fa 	srli	r2,r17,3
81131994:	00000106 	br	8113199c <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81131998:	0005883a 	mov	r2,zero
    }
}
8113199c:	e6fffe04 	addi	sp,fp,-8
811319a0:	dfc00317 	ldw	ra,12(sp)
811319a4:	df000217 	ldw	fp,8(sp)
811319a8:	dc400117 	ldw	r17,4(sp)
811319ac:	dc000017 	ldw	r16,0(sp)
811319b0:	dec00404 	addi	sp,sp,16
811319b4:	f800283a 	ret

811319b8 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
811319b8:	deffef04 	addi	sp,sp,-68
811319bc:	de00012e 	bgeu	sp,et,811319c4 <alt_log_jtag_uart_print_control_reg+0xc>
811319c0:	003b68fa 	trap	3
811319c4:	dfc01015 	stw	ra,64(sp)
811319c8:	df000f15 	stw	fp,60(sp)
811319cc:	df000f04 	addi	fp,sp,60
811319d0:	e13ffd15 	stw	r4,-12(fp)
811319d4:	e17ffe15 	stw	r5,-8(fp)
811319d8:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811319dc:	e0bffe17 	ldw	r2,-8(fp)
811319e0:	10800104 	addi	r2,r2,4
811319e4:	10800037 	ldwio	r2,0(r2)
811319e8:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
811319ec:	e0bff617 	ldw	r2,-40(fp)
811319f0:	1004d43a 	srli	r2,r2,16
811319f4:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
811319f8:	e0bff617 	ldw	r2,-40(fp)
811319fc:	1080008c 	andi	r2,r2,2
81131a00:	1004d07a 	srli	r2,r2,1
81131a04:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81131a08:	e0bff617 	ldw	r2,-40(fp)
81131a0c:	1080004c 	andi	r2,r2,1
81131a10:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
81131a14:	e0bff617 	ldw	r2,-40(fp)
81131a18:	1080400c 	andi	r2,r2,256
81131a1c:	1004d23a 	srli	r2,r2,8
81131a20:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
81131a24:	e0bff617 	ldw	r2,-40(fp)
81131a28:	1080800c 	andi	r2,r2,512
81131a2c:	1004d27a 	srli	r2,r2,9
81131a30:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
81131a34:	e0bff617 	ldw	r2,-40(fp)
81131a38:	1081000c 	andi	r2,r2,1024
81131a3c:	1004d2ba 	srli	r2,r2,10
81131a40:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
81131a44:	e0bffd17 	ldw	r2,-12(fp)
81131a48:	10c01017 	ldw	r3,64(r2)
81131a4c:	e0bffd17 	ldw	r2,-12(fp)
81131a50:	10800f17 	ldw	r2,60(r2)
81131a54:	1887c83a 	sub	r3,r3,r2
81131a58:	e0bff917 	ldw	r2,-28(fp)
81131a5c:	d8800415 	stw	r2,16(sp)
81131a60:	e0bff817 	ldw	r2,-32(fp)
81131a64:	d8800315 	stw	r2,12(sp)
81131a68:	e0bffa17 	ldw	r2,-24(fp)
81131a6c:	d8800215 	stw	r2,8(sp)
81131a70:	e0bffb17 	ldw	r2,-20(fp)
81131a74:	d8800115 	stw	r2,4(sp)
81131a78:	e0bffc17 	ldw	r2,-16(fp)
81131a7c:	d8800015 	stw	r2,0(sp)
81131a80:	e1fff717 	ldw	r7,-36(fp)
81131a84:	180d883a 	mov	r6,r3
81131a88:	e17fff17 	ldw	r5,-4(fp)
81131a8c:	01204574 	movhi	r4,33045
81131a90:	212a5f04 	addi	r4,r4,-22148
81131a94:	11318b80 	call	811318b8 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81131a98:	0001883a 	nop

}
81131a9c:	e037883a 	mov	sp,fp
81131aa0:	dfc00117 	ldw	ra,4(sp)
81131aa4:	df000017 	ldw	fp,0(sp)
81131aa8:	dec00204 	addi	sp,sp,8
81131aac:	f800283a 	ret

81131ab0 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81131ab0:	defffb04 	addi	sp,sp,-20
81131ab4:	de00012e 	bgeu	sp,et,81131abc <alt_log_jtag_uart_startup_info+0xc>
81131ab8:	003b68fa 	trap	3
81131abc:	dfc00415 	stw	ra,16(sp)
81131ac0:	df000315 	stw	fp,12(sp)
81131ac4:	df000304 	addi	fp,sp,12
81131ac8:	e13ffe15 	stw	r4,-8(fp)
81131acc:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81131ad0:	00a04574 	movhi	r2,33045
81131ad4:	10aa7104 	addi	r2,r2,-22076
81131ad8:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81131adc:	e1bffd17 	ldw	r6,-12(fp)
81131ae0:	e17fff17 	ldw	r5,-4(fp)
81131ae4:	e13ffe17 	ldw	r4,-8(fp)
81131ae8:	11319b80 	call	811319b8 <alt_log_jtag_uart_print_control_reg>
     return;
81131aec:	0001883a 	nop
}
81131af0:	e037883a 	mov	sp,fp
81131af4:	dfc00117 	ldw	ra,4(sp)
81131af8:	df000017 	ldw	fp,0(sp)
81131afc:	dec00204 	addi	sp,sp,8
81131b00:	f800283a 	ret

81131b04 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
81131b04:	defffb04 	addi	sp,sp,-20
81131b08:	de00012e 	bgeu	sp,et,81131b10 <alt_log_jtag_uart_isr_proc+0xc>
81131b0c:	003b68fa 	trap	3
81131b10:	dfc00415 	stw	ra,16(sp)
81131b14:	df000315 	stw	fp,12(sp)
81131b18:	df000304 	addi	fp,sp,12
81131b1c:	e13ffe15 	stw	r4,-8(fp)
81131b20:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
81131b24:	d0a07bc3 	ldbu	r2,-32273(gp)
81131b28:	10803fcc 	andi	r2,r2,255
81131b2c:	10000826 	beq	r2,zero,81131b50 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
81131b30:	00a04574 	movhi	r2,33045
81131b34:	10aa7604 	addi	r2,r2,-22056
81131b38:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
81131b3c:	e1bffd17 	ldw	r6,-12(fp)
81131b40:	e17ffe17 	ldw	r5,-8(fp)
81131b44:	e13fff17 	ldw	r4,-4(fp)
81131b48:	11319b80 	call	811319b8 <alt_log_jtag_uart_print_control_reg>
    }
    return;
81131b4c:	0001883a 	nop
81131b50:	0001883a 	nop
}
81131b54:	e037883a 	mov	sp,fp
81131b58:	dfc00117 	ldw	ra,4(sp)
81131b5c:	df000017 	ldw	fp,0(sp)
81131b60:	dec00204 	addi	sp,sp,8
81131b64:	f800283a 	ret

81131b68 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81131b68:	defffa04 	addi	sp,sp,-24
81131b6c:	de00012e 	bgeu	sp,et,81131b74 <alt_log_write+0xc>
81131b70:	003b68fa 	trap	3
81131b74:	dfc00515 	stw	ra,20(sp)
81131b78:	df000415 	stw	fp,16(sp)
81131b7c:	df000404 	addi	fp,sp,16
81131b80:	e13ffe15 	stw	r4,-8(fp)
81131b84:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81131b88:	d0a07b03 	ldbu	r2,-32276(gp)
81131b8c:	10803fcc 	andi	r2,r2,255
81131b90:	10004026 	beq	r2,zero,81131c94 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81131b94:	e0bfff17 	ldw	r2,-4(fp)
81131b98:	10c00430 	cmpltui	r3,r2,16
81131b9c:	1800011e 	bne	r3,zero,81131ba4 <alt_log_write+0x3c>
81131ba0:	008003c4 	movi	r2,15
81131ba4:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81131ba8:	e0bffd17 	ldw	r2,-12(fp)
81131bac:	10800088 	cmpgei	r2,r2,2
81131bb0:	10003726 	beq	r2,zero,81131c90 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81131bb4:	e0bffd17 	ldw	r2,-12(fp)
81131bb8:	100d883a 	mov	r6,r2
81131bbc:	e17ffe17 	ldw	r5,-8(fp)
81131bc0:	012045b4 	movhi	r4,33046
81131bc4:	21017f04 	addi	r4,r4,1532
81131bc8:	11459800 	call	81145980 <strncpy>
    alt_log_write_buf[length-1]='\n';
81131bcc:	e0bffd17 	ldw	r2,-12(fp)
81131bd0:	10ffffc4 	addi	r3,r2,-1
81131bd4:	00a045b4 	movhi	r2,33046
81131bd8:	10817f04 	addi	r2,r2,1532
81131bdc:	10c5883a 	add	r2,r2,r3
81131be0:	00c00284 	movi	r3,10
81131be4:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81131be8:	00a045b4 	movhi	r2,33046
81131bec:	10817f04 	addi	r2,r2,1532
81131bf0:	e0fffd17 	ldw	r3,-12(fp)
81131bf4:	10c5883a 	add	r2,r2,r3
81131bf8:	00c00344 	movi	r3,13
81131bfc:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
81131c00:	e0bffd17 	ldw	r2,-12(fp)
81131c04:	10c00044 	addi	r3,r2,1
81131c08:	00a045b4 	movhi	r2,33046
81131c0c:	10817f04 	addi	r2,r2,1532
81131c10:	10c5883a 	add	r2,r2,r3
81131c14:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81131c18:	e03ffc15 	stw	zero,-16(fp)
81131c1c:	00001306 	br	81131c6c <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
81131c20:	00a045b4 	movhi	r2,33046
81131c24:	10817f04 	addi	r2,r2,1532
81131c28:	e0fffc17 	ldw	r3,-16(fp)
81131c2c:	10c5883a 	add	r2,r2,r3
81131c30:	10800003 	ldbu	r2,0(r2)
81131c34:	10803fcc 	andi	r2,r2,255
81131c38:	1080201c 	xori	r2,r2,128
81131c3c:	10bfe004 	addi	r2,r2,-128
81131c40:	10800118 	cmpnei	r2,r2,4
81131c44:	1000061e 	bne	r2,zero,81131c60 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
81131c48:	00a045b4 	movhi	r2,33046
81131c4c:	10817f04 	addi	r2,r2,1532
81131c50:	e0fffc17 	ldw	r3,-16(fp)
81131c54:	10c5883a 	add	r2,r2,r3
81131c58:	00c01104 	movi	r3,68
81131c5c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81131c60:	e0bffc17 	ldw	r2,-16(fp)
81131c64:	10800044 	addi	r2,r2,1
81131c68:	e0bffc15 	stw	r2,-16(fp)
81131c6c:	e0fffc17 	ldw	r3,-16(fp)
81131c70:	e0bffd17 	ldw	r2,-12(fp)
81131c74:	18bfea16 	blt	r3,r2,81131c20 <__reset+0xfb111c20>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81131c78:	016045b4 	movhi	r5,33046
81131c7c:	29417f04 	addi	r5,r5,1532
81131c80:	01204574 	movhi	r4,33045
81131c84:	212a7904 	addi	r4,r4,-22044
81131c88:	11318b80 	call	811318b8 <alt_log_printf_proc>
81131c8c:	00000106 	br	81131c94 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81131c90:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
81131c94:	e037883a 	mov	sp,fp
81131c98:	dfc00117 	ldw	ra,4(sp)
81131c9c:	df000017 	ldw	fp,0(sp)
81131ca0:	dec00204 	addi	sp,sp,8
81131ca4:	f800283a 	ret

81131ca8 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81131ca8:	defffe04 	addi	sp,sp,-8
81131cac:	de00012e 	bgeu	sp,et,81131cb4 <alt_log_system_clock+0xc>
81131cb0:	003b68fa 	trap	3
81131cb4:	dfc00115 	stw	ra,4(sp)
81131cb8:	df000015 	stw	fp,0(sp)
81131cbc:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81131cc0:	d0a07b43 	ldbu	r2,-32275(gp)
81131cc4:	10803fcc 	andi	r2,r2,255
81131cc8:	10000e26 	beq	r2,zero,81131d04 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81131ccc:	d0a07e17 	ldw	r2,-32264(gp)
81131cd0:	10800044 	addi	r2,r2,1
81131cd4:	d0a07e15 	stw	r2,-32264(gp)
81131cd8:	d0a08217 	ldw	r2,-32248(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81131cdc:	d0e07e17 	ldw	r3,-32264(gp)
81131ce0:	10c0082e 	bgeu	r2,r3,81131d04 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
81131ce4:	d0207e15 	stw	zero,-32264(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81131ce8:	d0a07d17 	ldw	r2,-32268(gp)
81131cec:	10c00044 	addi	r3,r2,1
81131cf0:	d0e07d15 	stw	r3,-32268(gp)
81131cf4:	100b883a 	mov	r5,r2
81131cf8:	01204574 	movhi	r4,33045
81131cfc:	212a7d04 	addi	r4,r4,-22028
81131d00:	11318b80 	call	811318b8 <alt_log_printf_proc>
        }
    }
}
81131d04:	0001883a 	nop
81131d08:	e037883a 	mov	sp,fp
81131d0c:	dfc00117 	ldw	ra,4(sp)
81131d10:	df000017 	ldw	fp,0(sp)
81131d14:	dec00204 	addi	sp,sp,8
81131d18:	f800283a 	ret

81131d1c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81131d1c:	defffe04 	addi	sp,sp,-8
81131d20:	de00012e 	bgeu	sp,et,81131d28 <alt_get_errno+0xc>
81131d24:	003b68fa 	trap	3
81131d28:	dfc00115 	stw	ra,4(sp)
81131d2c:	df000015 	stw	fp,0(sp)
81131d30:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131d34:	d0a01017 	ldw	r2,-32704(gp)
81131d38:	10000326 	beq	r2,zero,81131d48 <alt_get_errno+0x2c>
81131d3c:	d0a01017 	ldw	r2,-32704(gp)
81131d40:	103ee83a 	callr	r2
81131d44:	00000106 	br	81131d4c <alt_get_errno+0x30>
81131d48:	d0a07204 	addi	r2,gp,-32312
}
81131d4c:	e037883a 	mov	sp,fp
81131d50:	dfc00117 	ldw	ra,4(sp)
81131d54:	df000017 	ldw	fp,0(sp)
81131d58:	dec00204 	addi	sp,sp,8
81131d5c:	f800283a 	ret

81131d60 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
81131d60:	defff904 	addi	sp,sp,-28
81131d64:	de00012e 	bgeu	sp,et,81131d6c <lseek+0xc>
81131d68:	003b68fa 	trap	3
81131d6c:	dfc00615 	stw	ra,24(sp)
81131d70:	df000515 	stw	fp,20(sp)
81131d74:	df000504 	addi	fp,sp,20
81131d78:	e13ffd15 	stw	r4,-12(fp)
81131d7c:	e17ffe15 	stw	r5,-8(fp)
81131d80:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81131d84:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81131d88:	e0bffd17 	ldw	r2,-12(fp)
81131d8c:	10000616 	blt	r2,zero,81131da8 <lseek+0x48>
81131d90:	e0bffd17 	ldw	r2,-12(fp)
81131d94:	10c00324 	muli	r3,r2,12
81131d98:	00a04574 	movhi	r2,33045
81131d9c:	10ae3604 	addi	r2,r2,-18216
81131da0:	1885883a 	add	r2,r3,r2
81131da4:	00000106 	br	81131dac <lseek+0x4c>
81131da8:	0005883a 	mov	r2,zero
81131dac:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81131db0:	e0bffc17 	ldw	r2,-16(fp)
81131db4:	10001026 	beq	r2,zero,81131df8 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81131db8:	e0bffc17 	ldw	r2,-16(fp)
81131dbc:	10800017 	ldw	r2,0(r2)
81131dc0:	10800717 	ldw	r2,28(r2)
81131dc4:	10000926 	beq	r2,zero,81131dec <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81131dc8:	e0bffc17 	ldw	r2,-16(fp)
81131dcc:	10800017 	ldw	r2,0(r2)
81131dd0:	10800717 	ldw	r2,28(r2)
81131dd4:	e1bfff17 	ldw	r6,-4(fp)
81131dd8:	e17ffe17 	ldw	r5,-8(fp)
81131ddc:	e13ffc17 	ldw	r4,-16(fp)
81131de0:	103ee83a 	callr	r2
81131de4:	e0bffb15 	stw	r2,-20(fp)
81131de8:	00000506 	br	81131e00 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81131dec:	00bfde84 	movi	r2,-134
81131df0:	e0bffb15 	stw	r2,-20(fp)
81131df4:	00000206 	br	81131e00 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81131df8:	00bfebc4 	movi	r2,-81
81131dfc:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
81131e00:	e0bffb17 	ldw	r2,-20(fp)
81131e04:	1000070e 	bge	r2,zero,81131e24 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81131e08:	1131d1c0 	call	81131d1c <alt_get_errno>
81131e0c:	1007883a 	mov	r3,r2
81131e10:	e0bffb17 	ldw	r2,-20(fp)
81131e14:	0085c83a 	sub	r2,zero,r2
81131e18:	18800015 	stw	r2,0(r3)
    rc = -1;
81131e1c:	00bfffc4 	movi	r2,-1
81131e20:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
81131e24:	e0bffb17 	ldw	r2,-20(fp)
}
81131e28:	e037883a 	mov	sp,fp
81131e2c:	dfc00117 	ldw	ra,4(sp)
81131e30:	df000017 	ldw	fp,0(sp)
81131e34:	dec00204 	addi	sp,sp,8
81131e38:	f800283a 	ret

81131e3c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
81131e3c:	defff904 	addi	sp,sp,-28
81131e40:	de00012e 	bgeu	sp,et,81131e48 <alt_main+0xc>
81131e44:	003b68fa 	trap	3
81131e48:	dfc00615 	stw	ra,24(sp)
81131e4c:	df000515 	stw	fp,20(sp)
81131e50:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
81131e54:	d0a01217 	ldw	r2,-32696(gp)
81131e58:	10800058 	cmpnei	r2,r2,1
81131e5c:	1000031e 	bne	r2,zero,81131e6c <alt_main+0x30>
81131e60:	01204574 	movhi	r4,33045
81131e64:	212a8304 	addi	r4,r4,-22004
81131e68:	11318b80 	call	811318b8 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
81131e6c:	0009883a 	mov	r4,zero
81131e70:	113c7e00 	call	8113c7e0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81131e74:	d0a01217 	ldw	r2,-32696(gp)
81131e78:	10800058 	cmpnei	r2,r2,1
81131e7c:	1000031e 	bne	r2,zero,81131e8c <alt_main+0x50>
81131e80:	01204574 	movhi	r4,33045
81131e84:	212a9104 	addi	r4,r4,-21948
81131e88:	11318b80 	call	811318b8 <alt_log_printf_proc>
  ALT_OS_INIT();
81131e8c:	11334280 	call	81133428 <OSInit>
81131e90:	01000044 	movi	r4,1
81131e94:	11391440 	call	81139144 <OSSemCreate>
81131e98:	d0a08515 	stw	r2,-32236(gp)
81131e9c:	01000044 	movi	r4,1
81131ea0:	11391440 	call	81139144 <OSSemCreate>
81131ea4:	d0a08715 	stw	r2,-32228(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81131ea8:	d0a01217 	ldw	r2,-32696(gp)
81131eac:	10800058 	cmpnei	r2,r2,1
81131eb0:	1000031e 	bne	r2,zero,81131ec0 <alt_main+0x84>
81131eb4:	01204574 	movhi	r4,33045
81131eb8:	212a9f04 	addi	r4,r4,-21892
81131ebc:	11318b80 	call	811318b8 <alt_log_printf_proc>
81131ec0:	d0a07904 	addi	r2,gp,-32284
81131ec4:	e0bffc15 	stw	r2,-16(fp)
81131ec8:	00800044 	movi	r2,1
81131ecc:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81131ed0:	e0bffd0b 	ldhu	r2,-12(fp)
81131ed4:	1009883a 	mov	r4,r2
81131ed8:	11391440 	call	81139144 <OSSemCreate>
81131edc:	1007883a 	mov	r3,r2
81131ee0:	e0bffc17 	ldw	r2,-16(fp)
81131ee4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81131ee8:	d0a01217 	ldw	r2,-32696(gp)
81131eec:	10800058 	cmpnei	r2,r2,1
81131ef0:	1000031e 	bne	r2,zero,81131f00 <alt_main+0xc4>
81131ef4:	01204574 	movhi	r4,33045
81131ef8:	212aad04 	addi	r4,r4,-21836
81131efc:	11318b80 	call	811318b8 <alt_log_printf_proc>
  alt_sys_init();
81131f00:	113c8200 	call	8113c820 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
81131f04:	d0a01217 	ldw	r2,-32696(gp)
81131f08:	10800058 	cmpnei	r2,r2,1
81131f0c:	1000031e 	bne	r2,zero,81131f1c <alt_main+0xe0>
81131f10:	01204574 	movhi	r4,33045
81131f14:	212ab704 	addi	r4,r4,-21796
81131f18:	11318b80 	call	811318b8 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
81131f1c:	d0a01217 	ldw	r2,-32696(gp)
81131f20:	10800058 	cmpnei	r2,r2,1
81131f24:	1000031e 	bne	r2,zero,81131f34 <alt_main+0xf8>
81131f28:	01204574 	movhi	r4,33045
81131f2c:	212ac004 	addi	r4,r4,-21760
81131f30:	11318b80 	call	811318b8 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
81131f34:	01a04574 	movhi	r6,33045
81131f38:	31aac804 	addi	r6,r6,-21728
81131f3c:	01604574 	movhi	r5,33045
81131f40:	296acd04 	addi	r5,r5,-21708
81131f44:	01204574 	movhi	r4,33045
81131f48:	212acd04 	addi	r4,r4,-21708
81131f4c:	11451100 	call	81145110 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
81131f50:	d0a01217 	ldw	r2,-32696(gp)
81131f54:	10800058 	cmpnei	r2,r2,1
81131f58:	1000031e 	bne	r2,zero,81131f68 <alt_main+0x12c>
81131f5c:	01204574 	movhi	r4,33045
81131f60:	212ad104 	addi	r4,r4,-21692
81131f64:	11318b80 	call	811318b8 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81131f68:	d0a07f17 	ldw	r2,-32260(gp)
81131f6c:	d0e08017 	ldw	r3,-32256(gp)
81131f70:	d1208117 	ldw	r4,-32252(gp)
81131f74:	200d883a 	mov	r6,r4
81131f78:	180b883a 	mov	r5,r3
81131f7c:	1009883a 	mov	r4,r2
81131f80:	1113c100 	call	81113c10 <main>
81131f84:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81131f88:	01000044 	movi	r4,1
81131f8c:	1130d680 	call	81130d68 <close>
  exit (result);
81131f90:	e13ffb17 	ldw	r4,-20(fp)
81131f94:	11458c40 	call	811458c4 <exit>

81131f98 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81131f98:	defffe04 	addi	sp,sp,-8
81131f9c:	de00012e 	bgeu	sp,et,81131fa4 <alt_get_errno+0xc>
81131fa0:	003b68fa 	trap	3
81131fa4:	dfc00115 	stw	ra,4(sp)
81131fa8:	df000015 	stw	fp,0(sp)
81131fac:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131fb0:	d0a01017 	ldw	r2,-32704(gp)
81131fb4:	10000326 	beq	r2,zero,81131fc4 <alt_get_errno+0x2c>
81131fb8:	d0a01017 	ldw	r2,-32704(gp)
81131fbc:	103ee83a 	callr	r2
81131fc0:	00000106 	br	81131fc8 <alt_get_errno+0x30>
81131fc4:	d0a07204 	addi	r2,gp,-32312
}
81131fc8:	e037883a 	mov	sp,fp
81131fcc:	dfc00117 	ldw	ra,4(sp)
81131fd0:	df000017 	ldw	fp,0(sp)
81131fd4:	dec00204 	addi	sp,sp,8
81131fd8:	f800283a 	ret

81131fdc <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
81131fdc:	defffd04 	addi	sp,sp,-12
81131fe0:	de00012e 	bgeu	sp,et,81131fe8 <alt_file_locked+0xc>
81131fe4:	003b68fa 	trap	3
81131fe8:	df000215 	stw	fp,8(sp)
81131fec:	df000204 	addi	fp,sp,8
81131ff0:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
81131ff4:	e0bfff17 	ldw	r2,-4(fp)
81131ff8:	10800217 	ldw	r2,8(r2)
81131ffc:	10d00034 	orhi	r3,r2,16384
81132000:	e0bfff17 	ldw	r2,-4(fp)
81132004:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81132008:	e03ffe15 	stw	zero,-8(fp)
8113200c:	00001d06 	br	81132084 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81132010:	00a04574 	movhi	r2,33045
81132014:	10ae3604 	addi	r2,r2,-18216
81132018:	e0fffe17 	ldw	r3,-8(fp)
8113201c:	18c00324 	muli	r3,r3,12
81132020:	10c5883a 	add	r2,r2,r3
81132024:	10c00017 	ldw	r3,0(r2)
81132028:	e0bfff17 	ldw	r2,-4(fp)
8113202c:	10800017 	ldw	r2,0(r2)
81132030:	1880111e 	bne	r3,r2,81132078 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81132034:	00a04574 	movhi	r2,33045
81132038:	10ae3604 	addi	r2,r2,-18216
8113203c:	e0fffe17 	ldw	r3,-8(fp)
81132040:	18c00324 	muli	r3,r3,12
81132044:	10c5883a 	add	r2,r2,r3
81132048:	10800204 	addi	r2,r2,8
8113204c:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81132050:	1000090e 	bge	r2,zero,81132078 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
81132054:	e0bffe17 	ldw	r2,-8(fp)
81132058:	10c00324 	muli	r3,r2,12
8113205c:	00a04574 	movhi	r2,33045
81132060:	10ae3604 	addi	r2,r2,-18216
81132064:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81132068:	e0bfff17 	ldw	r2,-4(fp)
8113206c:	18800226 	beq	r3,r2,81132078 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
81132070:	00bffcc4 	movi	r2,-13
81132074:	00000806 	br	81132098 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81132078:	e0bffe17 	ldw	r2,-8(fp)
8113207c:	10800044 	addi	r2,r2,1
81132080:	e0bffe15 	stw	r2,-8(fp)
81132084:	d0a00f17 	ldw	r2,-32708(gp)
81132088:	1007883a 	mov	r3,r2
8113208c:	e0bffe17 	ldw	r2,-8(fp)
81132090:	18bfdf2e 	bgeu	r3,r2,81132010 <__reset+0xfb112010>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81132094:	0005883a 	mov	r2,zero
}
81132098:	e037883a 	mov	sp,fp
8113209c:	df000017 	ldw	fp,0(sp)
811320a0:	dec00104 	addi	sp,sp,4
811320a4:	f800283a 	ret

811320a8 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
811320a8:	defff604 	addi	sp,sp,-40
811320ac:	de00012e 	bgeu	sp,et,811320b4 <open+0xc>
811320b0:	003b68fa 	trap	3
811320b4:	dfc00915 	stw	ra,36(sp)
811320b8:	df000815 	stw	fp,32(sp)
811320bc:	df000804 	addi	fp,sp,32
811320c0:	e13ffd15 	stw	r4,-12(fp)
811320c4:	e17ffe15 	stw	r5,-8(fp)
811320c8:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
811320cc:	00bfffc4 	movi	r2,-1
811320d0:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
811320d4:	00bffb44 	movi	r2,-19
811320d8:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
811320dc:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
811320e0:	d1600d04 	addi	r5,gp,-32716
811320e4:	e13ffd17 	ldw	r4,-12(fp)
811320e8:	1144af00 	call	81144af0 <alt_find_dev>
811320ec:	e0bff815 	stw	r2,-32(fp)
811320f0:	e0bff817 	ldw	r2,-32(fp)
811320f4:	1000051e 	bne	r2,zero,8113210c <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
811320f8:	e13ffd17 	ldw	r4,-12(fp)
811320fc:	1144b880 	call	81144b88 <alt_find_file>
81132100:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
81132104:	00800044 	movi	r2,1
81132108:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
8113210c:	e0bff817 	ldw	r2,-32(fp)
81132110:	10002926 	beq	r2,zero,811321b8 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81132114:	e13ff817 	ldw	r4,-32(fp)
81132118:	1144c980 	call	81144c98 <alt_get_fd>
8113211c:	e0bff915 	stw	r2,-28(fp)
81132120:	e0bff917 	ldw	r2,-28(fp)
81132124:	1000030e 	bge	r2,zero,81132134 <open+0x8c>
    {
      status = index;
81132128:	e0bff917 	ldw	r2,-28(fp)
8113212c:	e0bffa15 	stw	r2,-24(fp)
81132130:	00002306 	br	811321c0 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
81132134:	e0bff917 	ldw	r2,-28(fp)
81132138:	10c00324 	muli	r3,r2,12
8113213c:	00a04574 	movhi	r2,33045
81132140:	10ae3604 	addi	r2,r2,-18216
81132144:	1885883a 	add	r2,r3,r2
81132148:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
8113214c:	e0fffe17 	ldw	r3,-8(fp)
81132150:	00900034 	movhi	r2,16384
81132154:	10bfffc4 	addi	r2,r2,-1
81132158:	1886703a 	and	r3,r3,r2
8113215c:	e0bffc17 	ldw	r2,-16(fp)
81132160:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81132164:	e0bffb17 	ldw	r2,-20(fp)
81132168:	1000051e 	bne	r2,zero,81132180 <open+0xd8>
8113216c:	e13ffc17 	ldw	r4,-16(fp)
81132170:	1131fdc0 	call	81131fdc <alt_file_locked>
81132174:	e0bffa15 	stw	r2,-24(fp)
81132178:	e0bffa17 	ldw	r2,-24(fp)
8113217c:	10001016 	blt	r2,zero,811321c0 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81132180:	e0bff817 	ldw	r2,-32(fp)
81132184:	10800317 	ldw	r2,12(r2)
81132188:	10000826 	beq	r2,zero,811321ac <open+0x104>
8113218c:	e0bff817 	ldw	r2,-32(fp)
81132190:	10800317 	ldw	r2,12(r2)
81132194:	e1ffff17 	ldw	r7,-4(fp)
81132198:	e1bffe17 	ldw	r6,-8(fp)
8113219c:	e17ffd17 	ldw	r5,-12(fp)
811321a0:	e13ffc17 	ldw	r4,-16(fp)
811321a4:	103ee83a 	callr	r2
811321a8:	00000106 	br	811321b0 <open+0x108>
811321ac:	0005883a 	mov	r2,zero
811321b0:	e0bffa15 	stw	r2,-24(fp)
811321b4:	00000206 	br	811321c0 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
811321b8:	00bffb44 	movi	r2,-19
811321bc:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
811321c0:	e0bffa17 	ldw	r2,-24(fp)
811321c4:	1000090e 	bge	r2,zero,811321ec <open+0x144>
  {
    alt_release_fd (index);  
811321c8:	e13ff917 	ldw	r4,-28(fp)
811321cc:	113234c0 	call	8113234c <alt_release_fd>
    ALT_ERRNO = -status;
811321d0:	1131f980 	call	81131f98 <alt_get_errno>
811321d4:	1007883a 	mov	r3,r2
811321d8:	e0bffa17 	ldw	r2,-24(fp)
811321dc:	0085c83a 	sub	r2,zero,r2
811321e0:	18800015 	stw	r2,0(r3)
    return -1;
811321e4:	00bfffc4 	movi	r2,-1
811321e8:	00000106 	br	811321f0 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
811321ec:	e0bff917 	ldw	r2,-28(fp)
}
811321f0:	e037883a 	mov	sp,fp
811321f4:	dfc00117 	ldw	ra,4(sp)
811321f8:	df000017 	ldw	fp,0(sp)
811321fc:	dec00204 	addi	sp,sp,8
81132200:	f800283a 	ret

81132204 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81132204:	defffe04 	addi	sp,sp,-8
81132208:	de00012e 	bgeu	sp,et,81132210 <alt_get_errno+0xc>
8113220c:	003b68fa 	trap	3
81132210:	dfc00115 	stw	ra,4(sp)
81132214:	df000015 	stw	fp,0(sp)
81132218:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113221c:	d0a01017 	ldw	r2,-32704(gp)
81132220:	10000326 	beq	r2,zero,81132230 <alt_get_errno+0x2c>
81132224:	d0a01017 	ldw	r2,-32704(gp)
81132228:	103ee83a 	callr	r2
8113222c:	00000106 	br	81132234 <alt_get_errno+0x30>
81132230:	d0a07204 	addi	r2,gp,-32312
}
81132234:	e037883a 	mov	sp,fp
81132238:	dfc00117 	ldw	ra,4(sp)
8113223c:	df000017 	ldw	fp,0(sp)
81132240:	dec00204 	addi	sp,sp,8
81132244:	f800283a 	ret

81132248 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81132248:	defff904 	addi	sp,sp,-28
8113224c:	de00012e 	bgeu	sp,et,81132254 <read+0xc>
81132250:	003b68fa 	trap	3
81132254:	dfc00615 	stw	ra,24(sp)
81132258:	df000515 	stw	fp,20(sp)
8113225c:	df000504 	addi	fp,sp,20
81132260:	e13ffd15 	stw	r4,-12(fp)
81132264:	e17ffe15 	stw	r5,-8(fp)
81132268:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113226c:	e0bffd17 	ldw	r2,-12(fp)
81132270:	10000616 	blt	r2,zero,8113228c <read+0x44>
81132274:	e0bffd17 	ldw	r2,-12(fp)
81132278:	10c00324 	muli	r3,r2,12
8113227c:	00a04574 	movhi	r2,33045
81132280:	10ae3604 	addi	r2,r2,-18216
81132284:	1885883a 	add	r2,r3,r2
81132288:	00000106 	br	81132290 <read+0x48>
8113228c:	0005883a 	mov	r2,zero
81132290:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81132294:	e0bffb17 	ldw	r2,-20(fp)
81132298:	10002226 	beq	r2,zero,81132324 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8113229c:	e0bffb17 	ldw	r2,-20(fp)
811322a0:	10800217 	ldw	r2,8(r2)
811322a4:	108000cc 	andi	r2,r2,3
811322a8:	10800060 	cmpeqi	r2,r2,1
811322ac:	1000181e 	bne	r2,zero,81132310 <read+0xc8>
        (fd->dev->read))
811322b0:	e0bffb17 	ldw	r2,-20(fp)
811322b4:	10800017 	ldw	r2,0(r2)
811322b8:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
811322bc:	10001426 	beq	r2,zero,81132310 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
811322c0:	e0bffb17 	ldw	r2,-20(fp)
811322c4:	10800017 	ldw	r2,0(r2)
811322c8:	10800517 	ldw	r2,20(r2)
811322cc:	e0ffff17 	ldw	r3,-4(fp)
811322d0:	180d883a 	mov	r6,r3
811322d4:	e17ffe17 	ldw	r5,-8(fp)
811322d8:	e13ffb17 	ldw	r4,-20(fp)
811322dc:	103ee83a 	callr	r2
811322e0:	e0bffc15 	stw	r2,-16(fp)
811322e4:	e0bffc17 	ldw	r2,-16(fp)
811322e8:	1000070e 	bge	r2,zero,81132308 <read+0xc0>
        {
          ALT_ERRNO = -rval;
811322ec:	11322040 	call	81132204 <alt_get_errno>
811322f0:	1007883a 	mov	r3,r2
811322f4:	e0bffc17 	ldw	r2,-16(fp)
811322f8:	0085c83a 	sub	r2,zero,r2
811322fc:	18800015 	stw	r2,0(r3)
          return -1;
81132300:	00bfffc4 	movi	r2,-1
81132304:	00000c06 	br	81132338 <read+0xf0>
        }
        return rval;
81132308:	e0bffc17 	ldw	r2,-16(fp)
8113230c:	00000a06 	br	81132338 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81132310:	11322040 	call	81132204 <alt_get_errno>
81132314:	1007883a 	mov	r3,r2
81132318:	00800344 	movi	r2,13
8113231c:	18800015 	stw	r2,0(r3)
81132320:	00000406 	br	81132334 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
81132324:	11322040 	call	81132204 <alt_get_errno>
81132328:	1007883a 	mov	r3,r2
8113232c:	00801444 	movi	r2,81
81132330:	18800015 	stw	r2,0(r3)
  }
  return -1;
81132334:	00bfffc4 	movi	r2,-1
}
81132338:	e037883a 	mov	sp,fp
8113233c:	dfc00117 	ldw	ra,4(sp)
81132340:	df000017 	ldw	fp,0(sp)
81132344:	dec00204 	addi	sp,sp,8
81132348:	f800283a 	ret

8113234c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
8113234c:	defffe04 	addi	sp,sp,-8
81132350:	de00012e 	bgeu	sp,et,81132358 <alt_release_fd+0xc>
81132354:	003b68fa 	trap	3
81132358:	df000115 	stw	fp,4(sp)
8113235c:	df000104 	addi	fp,sp,4
81132360:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81132364:	e0bfff17 	ldw	r2,-4(fp)
81132368:	108000d0 	cmplti	r2,r2,3
8113236c:	10000d1e 	bne	r2,zero,811323a4 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81132370:	00a04574 	movhi	r2,33045
81132374:	10ae3604 	addi	r2,r2,-18216
81132378:	e0ffff17 	ldw	r3,-4(fp)
8113237c:	18c00324 	muli	r3,r3,12
81132380:	10c5883a 	add	r2,r2,r3
81132384:	10800204 	addi	r2,r2,8
81132388:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
8113238c:	00a04574 	movhi	r2,33045
81132390:	10ae3604 	addi	r2,r2,-18216
81132394:	e0ffff17 	ldw	r3,-4(fp)
81132398:	18c00324 	muli	r3,r3,12
8113239c:	10c5883a 	add	r2,r2,r3
811323a0:	10000015 	stw	zero,0(r2)
  }
}
811323a4:	0001883a 	nop
811323a8:	e037883a 	mov	sp,fp
811323ac:	df000017 	ldw	fp,0(sp)
811323b0:	dec00104 	addi	sp,sp,4
811323b4:	f800283a 	ret

811323b8 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
811323b8:	defff604 	addi	sp,sp,-40
811323bc:	de00012e 	bgeu	sp,et,811323c4 <sbrk+0xc>
811323c0:	003b68fa 	trap	3
811323c4:	df000915 	stw	fp,36(sp)
811323c8:	df000904 	addi	fp,sp,36
811323cc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811323d0:	0005303a 	rdctl	r2,status
811323d4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811323d8:	e0fffe17 	ldw	r3,-8(fp)
811323dc:	00bfff84 	movi	r2,-2
811323e0:	1884703a 	and	r2,r3,r2
811323e4:	1001703a 	wrctl	status,r2
  
  return context;
811323e8:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
811323ec:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
811323f0:	d0a01317 	ldw	r2,-32692(gp)
811323f4:	10c000c4 	addi	r3,r2,3
811323f8:	00bfff04 	movi	r2,-4
811323fc:	1884703a 	and	r2,r3,r2
81132400:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81132404:	d0e01317 	ldw	r3,-32692(gp)
81132408:	e0bfff17 	ldw	r2,-4(fp)
8113240c:	1887883a 	add	r3,r3,r2
81132410:	00a04834 	movhi	r2,33056
81132414:	10a80004 	addi	r2,r2,-24576
81132418:	10c0062e 	bgeu	r2,r3,81132434 <sbrk+0x7c>
8113241c:	e0bff817 	ldw	r2,-32(fp)
81132420:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132424:	e0bff717 	ldw	r2,-36(fp)
81132428:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
8113242c:	00bfffc4 	movi	r2,-1
81132430:	00001c06 	br	811324a4 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81132434:	d0a01317 	ldw	r2,-32692(gp)
81132438:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
8113243c:	d0e01317 	ldw	r3,-32692(gp)
81132440:	e0bfff17 	ldw	r2,-4(fp)
81132444:	1885883a 	add	r2,r3,r2
81132448:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
8113244c:	c005883a 	mov	r2,et
81132450:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81132454:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81132458:	e0bffa17 	ldw	r2,-24(fp)
8113245c:	18800c1e 	bne	r3,r2,81132490 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81132460:	d805883a 	mov	r2,sp
81132464:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81132468:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
8113246c:	d0e01317 	ldw	r3,-32692(gp)
81132470:	18800136 	bltu	r3,r2,81132478 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81132474:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81132478:	d0a01317 	ldw	r2,-32692(gp)
8113247c:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81132480:	e0bffc17 	ldw	r2,-16(fp)
81132484:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81132488:	e0bffc17 	ldw	r2,-16(fp)
8113248c:	1031883a 	mov	et,r2
81132490:	e0bff817 	ldw	r2,-32(fp)
81132494:	e0bffd15 	stw	r2,-12(fp)
81132498:	e0bffd17 	ldw	r2,-12(fp)
8113249c:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
811324a0:	e0bffa17 	ldw	r2,-24(fp)
} 
811324a4:	e037883a 	mov	sp,fp
811324a8:	df000017 	ldw	fp,0(sp)
811324ac:	dec00104 	addi	sp,sp,4
811324b0:	f800283a 	ret

811324b4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
811324b4:	defffa04 	addi	sp,sp,-24
811324b8:	de00012e 	bgeu	sp,et,811324c0 <alt_alarm_stop+0xc>
811324bc:	003b68fa 	trap	3
811324c0:	df000515 	stw	fp,20(sp)
811324c4:	df000504 	addi	fp,sp,20
811324c8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811324cc:	0005303a 	rdctl	r2,status
811324d0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811324d4:	e0fffc17 	ldw	r3,-16(fp)
811324d8:	00bfff84 	movi	r2,-2
811324dc:	1884703a 	and	r2,r3,r2
811324e0:	1001703a 	wrctl	status,r2
  
  return context;
811324e4:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
811324e8:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
811324ec:	e0bfff17 	ldw	r2,-4(fp)
811324f0:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
811324f4:	e0bffd17 	ldw	r2,-12(fp)
811324f8:	10800017 	ldw	r2,0(r2)
811324fc:	e0fffd17 	ldw	r3,-12(fp)
81132500:	18c00117 	ldw	r3,4(r3)
81132504:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81132508:	e0bffd17 	ldw	r2,-12(fp)
8113250c:	10800117 	ldw	r2,4(r2)
81132510:	e0fffd17 	ldw	r3,-12(fp)
81132514:	18c00017 	ldw	r3,0(r3)
81132518:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
8113251c:	e0bffd17 	ldw	r2,-12(fp)
81132520:	e0fffd17 	ldw	r3,-12(fp)
81132524:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81132528:	e0bffd17 	ldw	r2,-12(fp)
8113252c:	e0fffd17 	ldw	r3,-12(fp)
81132530:	10c00015 	stw	r3,0(r2)
81132534:	e0bffb17 	ldw	r2,-20(fp)
81132538:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113253c:	e0bffe17 	ldw	r2,-8(fp)
81132540:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81132544:	0001883a 	nop
81132548:	e037883a 	mov	sp,fp
8113254c:	df000017 	ldw	fp,0(sp)
81132550:	dec00104 	addi	sp,sp,4
81132554:	f800283a 	ret

81132558 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81132558:	defffb04 	addi	sp,sp,-20
8113255c:	de00012e 	bgeu	sp,et,81132564 <alt_tick+0xc>
81132560:	003b68fa 	trap	3
81132564:	dfc00415 	stw	ra,16(sp)
81132568:	df000315 	stw	fp,12(sp)
8113256c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81132570:	d0a01417 	ldw	r2,-32688(gp)
81132574:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81132578:	d0a08317 	ldw	r2,-32244(gp)
8113257c:	10800044 	addi	r2,r2,1
81132580:	d0a08315 	stw	r2,-32244(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81132584:	00002e06 	br	81132640 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81132588:	e0bffd17 	ldw	r2,-12(fp)
8113258c:	10800017 	ldw	r2,0(r2)
81132590:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81132594:	e0bffd17 	ldw	r2,-12(fp)
81132598:	10800403 	ldbu	r2,16(r2)
8113259c:	10803fcc 	andi	r2,r2,255
811325a0:	10000426 	beq	r2,zero,811325b4 <alt_tick+0x5c>
811325a4:	d0a08317 	ldw	r2,-32244(gp)
811325a8:	1000021e 	bne	r2,zero,811325b4 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
811325ac:	e0bffd17 	ldw	r2,-12(fp)
811325b0:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
811325b4:	e0bffd17 	ldw	r2,-12(fp)
811325b8:	10800217 	ldw	r2,8(r2)
811325bc:	d0e08317 	ldw	r3,-32244(gp)
811325c0:	18801d36 	bltu	r3,r2,81132638 <alt_tick+0xe0>
811325c4:	e0bffd17 	ldw	r2,-12(fp)
811325c8:	10800403 	ldbu	r2,16(r2)
811325cc:	10803fcc 	andi	r2,r2,255
811325d0:	1000191e 	bne	r2,zero,81132638 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
811325d4:	e0bffd17 	ldw	r2,-12(fp)
811325d8:	10800317 	ldw	r2,12(r2)
811325dc:	e0fffd17 	ldw	r3,-12(fp)
811325e0:	18c00517 	ldw	r3,20(r3)
811325e4:	1809883a 	mov	r4,r3
811325e8:	103ee83a 	callr	r2
811325ec:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
811325f0:	e0bfff17 	ldw	r2,-4(fp)
811325f4:	1000031e 	bne	r2,zero,81132604 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
811325f8:	e13ffd17 	ldw	r4,-12(fp)
811325fc:	11324b40 	call	811324b4 <alt_alarm_stop>
81132600:	00000d06 	br	81132638 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81132604:	e0bffd17 	ldw	r2,-12(fp)
81132608:	10c00217 	ldw	r3,8(r2)
8113260c:	e0bfff17 	ldw	r2,-4(fp)
81132610:	1887883a 	add	r3,r3,r2
81132614:	e0bffd17 	ldw	r2,-12(fp)
81132618:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
8113261c:	e0bffd17 	ldw	r2,-12(fp)
81132620:	10c00217 	ldw	r3,8(r2)
81132624:	d0a08317 	ldw	r2,-32244(gp)
81132628:	1880032e 	bgeu	r3,r2,81132638 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
8113262c:	e0bffd17 	ldw	r2,-12(fp)
81132630:	00c00044 	movi	r3,1
81132634:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81132638:	e0bffe17 	ldw	r2,-8(fp)
8113263c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81132640:	e0fffd17 	ldw	r3,-12(fp)
81132644:	d0a01404 	addi	r2,gp,-32688
81132648:	18bfcf1e 	bne	r3,r2,81132588 <__reset+0xfb112588>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
8113264c:	11338880 	call	81133888 <OSTimeTick>
}
81132650:	0001883a 	nop
81132654:	e037883a 	mov	sp,fp
81132658:	dfc00117 	ldw	ra,4(sp)
8113265c:	df000017 	ldw	fp,0(sp)
81132660:	dec00204 	addi	sp,sp,8
81132664:	f800283a 	ret

81132668 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81132668:	defffb04 	addi	sp,sp,-20
8113266c:	de00012e 	bgeu	sp,et,81132674 <usleep+0xc>
81132670:	003b68fa 	trap	3
81132674:	dfc00415 	stw	ra,16(sp)
81132678:	df000315 	stw	fp,12(sp)
8113267c:	df000304 	addi	fp,sp,12
81132680:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81132684:	d0a08b03 	ldbu	r2,-32212(gp)
81132688:	10803fcc 	andi	r2,r2,255
8113268c:	1000031e 	bne	r2,zero,8113269c <usleep+0x34>
  {
    return alt_busy_sleep (us);
81132690:	e13fff17 	ldw	r4,-4(fp)
81132694:	1130bf40 	call	81130bf4 <alt_busy_sleep>
81132698:	00003d06 	br	81132790 <usleep+0x128>
8113269c:	d0a08217 	ldw	r2,-32248(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
811326a0:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
811326a4:	e0ffff17 	ldw	r3,-4(fp)
811326a8:	0090c734 	movhi	r2,17180
811326ac:	10b7a0c4 	addi	r2,r2,-8573
811326b0:	1888383a 	mulxuu	r4,r3,r2
811326b4:	1885383a 	mul	r2,r3,r2
811326b8:	1013883a 	mov	r9,r2
811326bc:	2015883a 	mov	r10,r4
811326c0:	5006d4ba 	srli	r3,r10,18
811326c4:	e0bffe17 	ldw	r2,-8(fp)
811326c8:	1893383a 	mul	r9,r3,r2
811326cc:	e0ffff17 	ldw	r3,-4(fp)
811326d0:	0090c734 	movhi	r2,17180
811326d4:	10b7a0c4 	addi	r2,r2,-8573
811326d8:	1888383a 	mulxuu	r4,r3,r2
811326dc:	1885383a 	mul	r2,r3,r2
811326e0:	100f883a 	mov	r7,r2
811326e4:	2011883a 	mov	r8,r4
811326e8:	4004d4ba 	srli	r2,r8,18
811326ec:	010003f4 	movhi	r4,15
811326f0:	21109004 	addi	r4,r4,16960
811326f4:	1105383a 	mul	r2,r2,r4
811326f8:	1885c83a 	sub	r2,r3,r2
811326fc:	e0fffe17 	ldw	r3,-8(fp)
81132700:	10c7383a 	mul	r3,r2,r3
81132704:	0090c734 	movhi	r2,17180
81132708:	10b7a0c4 	addi	r2,r2,-8573
8113270c:	1888383a 	mulxuu	r4,r3,r2
81132710:	1885383a 	mul	r2,r3,r2
81132714:	100b883a 	mov	r5,r2
81132718:	200d883a 	mov	r6,r4
8113271c:	3004d4ba 	srli	r2,r6,18
81132720:	4885883a 	add	r2,r9,r2
81132724:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81132728:	00000706 	br	81132748 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
8113272c:	013fffd4 	movui	r4,65535
81132730:	113b1440 	call	8113b144 <OSTimeDly>
    ticks -= 0xffff;
81132734:	e0fffd17 	ldw	r3,-12(fp)
81132738:	00bffff4 	movhi	r2,65535
8113273c:	10800044 	addi	r2,r2,1
81132740:	1885883a 	add	r2,r3,r2
81132744:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81132748:	e0bffd17 	ldw	r2,-12(fp)
8113274c:	00ffffd4 	movui	r3,65535
81132750:	18bff636 	bltu	r3,r2,8113272c <__reset+0xfb11272c>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81132754:	e0bffd17 	ldw	r2,-12(fp)
81132758:	10bfffcc 	andi	r2,r2,65535
8113275c:	1009883a 	mov	r4,r2
81132760:	113b1440 	call	8113b144 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81132764:	008003f4 	movhi	r2,15
81132768:	10909004 	addi	r2,r2,16960
8113276c:	e0fffe17 	ldw	r3,-8(fp)
81132770:	10c7203a 	divu	r3,r2,r3
81132774:	e0bfff17 	ldw	r2,-4(fp)
81132778:	10c9203a 	divu	r4,r2,r3
8113277c:	20c7383a 	mul	r3,r4,r3
81132780:	10c5c83a 	sub	r2,r2,r3
81132784:	1009883a 	mov	r4,r2
81132788:	1130bf40 	call	81130bf4 <alt_busy_sleep>

  return 0;  
8113278c:	0005883a 	mov	r2,zero
}
81132790:	e037883a 	mov	sp,fp
81132794:	dfc00117 	ldw	ra,4(sp)
81132798:	df000017 	ldw	fp,0(sp)
8113279c:	dec00204 	addi	sp,sp,8
811327a0:	f800283a 	ret

811327a4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811327a4:	defffe04 	addi	sp,sp,-8
811327a8:	de00012e 	bgeu	sp,et,811327b0 <alt_get_errno+0xc>
811327ac:	003b68fa 	trap	3
811327b0:	dfc00115 	stw	ra,4(sp)
811327b4:	df000015 	stw	fp,0(sp)
811327b8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811327bc:	d0a01017 	ldw	r2,-32704(gp)
811327c0:	10000326 	beq	r2,zero,811327d0 <alt_get_errno+0x2c>
811327c4:	d0a01017 	ldw	r2,-32704(gp)
811327c8:	103ee83a 	callr	r2
811327cc:	00000106 	br	811327d4 <alt_get_errno+0x30>
811327d0:	d0a07204 	addi	r2,gp,-32312
}
811327d4:	e037883a 	mov	sp,fp
811327d8:	dfc00117 	ldw	ra,4(sp)
811327dc:	df000017 	ldw	fp,0(sp)
811327e0:	dec00204 	addi	sp,sp,8
811327e4:	f800283a 	ret

811327e8 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
811327e8:	defff904 	addi	sp,sp,-28
811327ec:	de00012e 	bgeu	sp,et,811327f4 <write+0xc>
811327f0:	003b68fa 	trap	3
811327f4:	dfc00615 	stw	ra,24(sp)
811327f8:	df000515 	stw	fp,20(sp)
811327fc:	df000504 	addi	fp,sp,20
81132800:	e13ffd15 	stw	r4,-12(fp)
81132804:	e17ffe15 	stw	r5,-8(fp)
81132808:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113280c:	e0bffd17 	ldw	r2,-12(fp)
81132810:	10000616 	blt	r2,zero,8113282c <write+0x44>
81132814:	e0bffd17 	ldw	r2,-12(fp)
81132818:	10c00324 	muli	r3,r2,12
8113281c:	00a04574 	movhi	r2,33045
81132820:	10ae3604 	addi	r2,r2,-18216
81132824:	1885883a 	add	r2,r3,r2
81132828:	00000106 	br	81132830 <write+0x48>
8113282c:	0005883a 	mov	r2,zero
81132830:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81132834:	e0bffb17 	ldw	r2,-20(fp)
81132838:	10002426 	beq	r2,zero,811328cc <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
8113283c:	e0bffb17 	ldw	r2,-20(fp)
81132840:	10800217 	ldw	r2,8(r2)
81132844:	108000cc 	andi	r2,r2,3
81132848:	10001b26 	beq	r2,zero,811328b8 <write+0xd0>
8113284c:	e0bffb17 	ldw	r2,-20(fp)
81132850:	10800017 	ldw	r2,0(r2)
81132854:	10800617 	ldw	r2,24(r2)
81132858:	10001726 	beq	r2,zero,811328b8 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
8113285c:	e17fff17 	ldw	r5,-4(fp)
81132860:	e13ffe17 	ldw	r4,-8(fp)
81132864:	1131b680 	call	81131b68 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81132868:	e0bffb17 	ldw	r2,-20(fp)
8113286c:	10800017 	ldw	r2,0(r2)
81132870:	10800617 	ldw	r2,24(r2)
81132874:	e0ffff17 	ldw	r3,-4(fp)
81132878:	180d883a 	mov	r6,r3
8113287c:	e17ffe17 	ldw	r5,-8(fp)
81132880:	e13ffb17 	ldw	r4,-20(fp)
81132884:	103ee83a 	callr	r2
81132888:	e0bffc15 	stw	r2,-16(fp)
8113288c:	e0bffc17 	ldw	r2,-16(fp)
81132890:	1000070e 	bge	r2,zero,811328b0 <write+0xc8>
      {
        ALT_ERRNO = -rval;
81132894:	11327a40 	call	811327a4 <alt_get_errno>
81132898:	1007883a 	mov	r3,r2
8113289c:	e0bffc17 	ldw	r2,-16(fp)
811328a0:	0085c83a 	sub	r2,zero,r2
811328a4:	18800015 	stw	r2,0(r3)
        return -1;
811328a8:	00bfffc4 	movi	r2,-1
811328ac:	00000c06 	br	811328e0 <write+0xf8>
      }
      return rval;
811328b0:	e0bffc17 	ldw	r2,-16(fp)
811328b4:	00000a06 	br	811328e0 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
811328b8:	11327a40 	call	811327a4 <alt_get_errno>
811328bc:	1007883a 	mov	r3,r2
811328c0:	00800344 	movi	r2,13
811328c4:	18800015 	stw	r2,0(r3)
811328c8:	00000406 	br	811328dc <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
811328cc:	11327a40 	call	811327a4 <alt_get_errno>
811328d0:	1007883a 	mov	r3,r2
811328d4:	00801444 	movi	r2,81
811328d8:	18800015 	stw	r2,0(r3)
  }
  return -1;
811328dc:	00bfffc4 	movi	r2,-1
}
811328e0:	e037883a 	mov	sp,fp
811328e4:	dfc00117 	ldw	ra,4(sp)
811328e8:	df000017 	ldw	fp,0(sp)
811328ec:	dec00204 	addi	sp,sp,8
811328f0:	f800283a 	ret

811328f4 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
811328f4:	deffde04 	addi	sp,sp,-136
811328f8:	de00012e 	bgeu	sp,et,81132900 <__env_lock+0xc>
811328fc:	003b68fa 	trap	3
81132900:	dfc02115 	stw	ra,132(sp)
81132904:	df002015 	stw	fp,128(sp)
81132908:	df002004 	addi	fp,sp,128
8113290c:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81132910:	e0bfe104 	addi	r2,fp,-124
81132914:	100b883a 	mov	r5,r2
81132918:	01003fc4 	movi	r4,255
8113291c:	113afa00 	call	8113afa0 <OSTaskQuery>
81132920:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81132924:	e0bffe83 	ldbu	r2,-6(fp)
81132928:	10803fcc 	andi	r2,r2,255
8113292c:	10001e1e 	bne	r2,zero,811329a8 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81132930:	e0bfed83 	ldbu	r2,-74(fp)
81132934:	10803fcc 	andi	r2,r2,255
81132938:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
8113293c:	d0a08517 	ldw	r2,-32236(gp)
81132940:	e0fffc04 	addi	r3,fp,-16
81132944:	180b883a 	mov	r5,r3
81132948:	1009883a 	mov	r4,r2
8113294c:	113990c0 	call	8113990c <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81132950:	e0bffe03 	ldbu	r2,-8(fp)
81132954:	10803fcc 	andi	r2,r2,255
81132958:	10000726 	beq	r2,zero,81132978 <__env_lock+0x84>
8113295c:	d0a01617 	ldw	r2,-32680(gp)
81132960:	e0ffe017 	ldw	r3,-128(fp)
81132964:	1880041e 	bne	r3,r2,81132978 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81132968:	d0a08417 	ldw	r2,-32240(gp)
8113296c:	10800044 	addi	r2,r2,1
81132970:	d0a08415 	stw	r2,-32240(gp)
81132974:	00000a06 	br	811329a0 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81132978:	d0a08517 	ldw	r2,-32236(gp)
8113297c:	e0fffe84 	addi	r3,fp,-6
81132980:	180d883a 	mov	r6,r3
81132984:	000b883a 	mov	r5,zero
81132988:	1009883a 	mov	r4,r2
8113298c:	113946c0 	call	8113946c <OSSemPend>
    locks  = 1;
81132990:	00800044 	movi	r2,1
81132994:	d0a08415 	stw	r2,-32240(gp)
    lockid = id;
81132998:	e0bfe017 	ldw	r2,-128(fp)
8113299c:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811329a0:	0001883a 	nop
811329a4:	00000106 	br	811329ac <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
811329a8:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
811329ac:	e037883a 	mov	sp,fp
811329b0:	dfc00117 	ldw	ra,4(sp)
811329b4:	df000017 	ldw	fp,0(sp)
811329b8:	dec00204 	addi	sp,sp,8
811329bc:	f800283a 	ret

811329c0 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
811329c0:	defffd04 	addi	sp,sp,-12
811329c4:	de00012e 	bgeu	sp,et,811329cc <__env_unlock+0xc>
811329c8:	003b68fa 	trap	3
811329cc:	dfc00215 	stw	ra,8(sp)
811329d0:	df000115 	stw	fp,4(sp)
811329d4:	df000104 	addi	fp,sp,4
811329d8:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
811329dc:	d0a08417 	ldw	r2,-32240(gp)
811329e0:	10000b26 	beq	r2,zero,81132a10 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
811329e4:	d0a08417 	ldw	r2,-32240(gp)
811329e8:	10bfffc4 	addi	r2,r2,-1
811329ec:	d0a08415 	stw	r2,-32240(gp)
811329f0:	d0a08417 	ldw	r2,-32240(gp)
811329f4:	1000071e 	bne	r2,zero,81132a14 <__env_unlock+0x54>
  {
    lockid = -1;
811329f8:	00bfffc4 	movi	r2,-1
811329fc:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81132a00:	d0a08517 	ldw	r2,-32236(gp)
81132a04:	1009883a 	mov	r4,r2
81132a08:	11397f40 	call	811397f4 <OSSemPost>
81132a0c:	00000106 	br	81132a14 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81132a10:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81132a14:	e037883a 	mov	sp,fp
81132a18:	dfc00117 	ldw	ra,4(sp)
81132a1c:	df000017 	ldw	fp,0(sp)
81132a20:	dec00204 	addi	sp,sp,8
81132a24:	f800283a 	ret

81132a28 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81132a28:	deffda04 	addi	sp,sp,-152
81132a2c:	de00012e 	bgeu	sp,et,81132a34 <__malloc_lock+0xc>
81132a30:	003b68fa 	trap	3
81132a34:	dfc02515 	stw	ra,148(sp)
81132a38:	df002415 	stw	fp,144(sp)
81132a3c:	df002404 	addi	fp,sp,144
81132a40:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132a44:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81132a48:	d0a08b03 	ldbu	r2,-32212(gp)
81132a4c:	10803fcc 	andi	r2,r2,255
81132a50:	10800060 	cmpeqi	r2,r2,1
81132a54:	10003626 	beq	r2,zero,81132b30 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81132a58:	e0bfe104 	addi	r2,fp,-124
81132a5c:	100b883a 	mov	r5,r2
81132a60:	01003fc4 	movi	r4,255
81132a64:	113afa00 	call	8113afa0 <OSTaskQuery>
81132a68:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81132a6c:	e0bffe83 	ldbu	r2,-6(fp)
81132a70:	10803fcc 	andi	r2,r2,255
81132a74:	1000301e 	bne	r2,zero,81132b38 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81132a78:	e0bfed83 	ldbu	r2,-74(fp)
81132a7c:	10803fcc 	andi	r2,r2,255
81132a80:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81132a84:	d0a08717 	ldw	r2,-32228(gp)
81132a88:	e0fffc04 	addi	r3,fp,-16
81132a8c:	180b883a 	mov	r5,r3
81132a90:	1009883a 	mov	r4,r2
81132a94:	113990c0 	call	8113990c <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132a98:	0005303a 	rdctl	r2,status
81132a9c:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132aa0:	e0ffe017 	ldw	r3,-128(fp)
81132aa4:	00bfff84 	movi	r2,-2
81132aa8:	1884703a 	and	r2,r3,r2
81132aac:	1001703a 	wrctl	status,r2
  
  return context;
81132ab0:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81132ab4:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81132ab8:	e0bffc0b 	ldhu	r2,-16(fp)
81132abc:	10bfffcc 	andi	r2,r2,65535
81132ac0:	10000b1e 	bne	r2,zero,81132af0 <__malloc_lock+0xc8>
81132ac4:	d0a01717 	ldw	r2,-32676(gp)
81132ac8:	e0ffdd17 	ldw	r3,-140(fp)
81132acc:	1880081e 	bne	r3,r2,81132af0 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81132ad0:	d0a08617 	ldw	r2,-32232(gp)
81132ad4:	10800044 	addi	r2,r2,1
81132ad8:	d0a08615 	stw	r2,-32232(gp)
81132adc:	e0bfdc17 	ldw	r2,-144(fp)
81132ae0:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132ae4:	e0bfde17 	ldw	r2,-136(fp)
81132ae8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81132aec:	00000e06 	br	81132b28 <__malloc_lock+0x100>
81132af0:	e0bfdc17 	ldw	r2,-144(fp)
81132af4:	e0bfdf15 	stw	r2,-132(fp)
81132af8:	e0bfdf17 	ldw	r2,-132(fp)
81132afc:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81132b00:	d0a08717 	ldw	r2,-32228(gp)
81132b04:	e0fffe84 	addi	r3,fp,-6
81132b08:	180d883a 	mov	r6,r3
81132b0c:	000b883a 	mov	r5,zero
81132b10:	1009883a 	mov	r4,r2
81132b14:	113946c0 	call	8113946c <OSSemPend>
    locks  = 1;
81132b18:	00800044 	movi	r2,1
81132b1c:	d0a08615 	stw	r2,-32232(gp)
    lockid = id;
81132b20:	e0bfdd17 	ldw	r2,-140(fp)
81132b24:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81132b28:	0001883a 	nop
81132b2c:	00000306 	br	81132b3c <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
81132b30:	0001883a 	nop
81132b34:	00000106 	br	81132b3c <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81132b38:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81132b3c:	e037883a 	mov	sp,fp
81132b40:	dfc00117 	ldw	ra,4(sp)
81132b44:	df000017 	ldw	fp,0(sp)
81132b48:	dec00204 	addi	sp,sp,8
81132b4c:	f800283a 	ret

81132b50 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
81132b50:	defff804 	addi	sp,sp,-32
81132b54:	de00012e 	bgeu	sp,et,81132b5c <__malloc_unlock+0xc>
81132b58:	003b68fa 	trap	3
81132b5c:	dfc00715 	stw	ra,28(sp)
81132b60:	df000615 	stw	fp,24(sp)
81132b64:	df000604 	addi	fp,sp,24
81132b68:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132b6c:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
81132b70:	d0a08b03 	ldbu	r2,-32212(gp)
81132b74:	10803fcc 	andi	r2,r2,255
81132b78:	10800060 	cmpeqi	r2,r2,1
81132b7c:	10002326 	beq	r2,zero,81132c0c <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132b80:	0005303a 	rdctl	r2,status
81132b84:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132b88:	e0fffe17 	ldw	r3,-8(fp)
81132b8c:	00bfff84 	movi	r2,-2
81132b90:	1884703a 	and	r2,r3,r2
81132b94:	1001703a 	wrctl	status,r2
  
  return context;
81132b98:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81132b9c:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81132ba0:	d0a08617 	ldw	r2,-32232(gp)
81132ba4:	1000051e 	bne	r2,zero,81132bbc <__malloc_unlock+0x6c>
81132ba8:	e0bffa17 	ldw	r2,-24(fp)
81132bac:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132bb0:	e0bffb17 	ldw	r2,-20(fp)
81132bb4:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81132bb8:	00001506 	br	81132c10 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81132bbc:	d0a08617 	ldw	r2,-32232(gp)
81132bc0:	10bfffc4 	addi	r2,r2,-1
81132bc4:	d0a08615 	stw	r2,-32232(gp)
81132bc8:	d0a08617 	ldw	r2,-32232(gp)
81132bcc:	10000a1e 	bne	r2,zero,81132bf8 <__malloc_unlock+0xa8>
  {
    lockid = -1;
81132bd0:	00bfffc4 	movi	r2,-1
81132bd4:	d0a01715 	stw	r2,-32676(gp)
81132bd8:	e0bffa17 	ldw	r2,-24(fp)
81132bdc:	e0bffc15 	stw	r2,-16(fp)
81132be0:	e0bffc17 	ldw	r2,-16(fp)
81132be4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81132be8:	d0a08717 	ldw	r2,-32228(gp)
81132bec:	1009883a 	mov	r4,r2
81132bf0:	11397f40 	call	811397f4 <OSSemPost>
81132bf4:	00000606 	br	81132c10 <__malloc_unlock+0xc0>
81132bf8:	e0bffa17 	ldw	r2,-24(fp)
81132bfc:	e0bffd15 	stw	r2,-12(fp)
81132c00:	e0bffd17 	ldw	r2,-12(fp)
81132c04:	1001703a 	wrctl	status,r2
81132c08:	00000106 	br	81132c10 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81132c0c:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81132c10:	e037883a 	mov	sp,fp
81132c14:	dfc00117 	ldw	ra,4(sp)
81132c18:	df000017 	ldw	fp,0(sp)
81132c1c:	dec00204 	addi	sp,sp,8
81132c20:	f800283a 	ret

81132c24 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81132c24:	defff704 	addi	sp,sp,-36
81132c28:	de00012e 	bgeu	sp,et,81132c30 <OSEventNameGet+0xc>
81132c2c:	003b68fa 	trap	3
81132c30:	dfc00815 	stw	ra,32(sp)
81132c34:	df000715 	stw	fp,28(sp)
81132c38:	df000704 	addi	fp,sp,28
81132c3c:	e13ffd15 	stw	r4,-12(fp)
81132c40:	e17ffe15 	stw	r5,-8(fp)
81132c44:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132c48:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81132c4c:	e0bfff17 	ldw	r2,-4(fp)
81132c50:	1000021e 	bne	r2,zero,81132c5c <OSEventNameGet+0x38>
        return (0);
81132c54:	0005883a 	mov	r2,zero
81132c58:	00003706 	br	81132d38 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81132c5c:	e0bffd17 	ldw	r2,-12(fp)
81132c60:	1000051e 	bne	r2,zero,81132c78 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81132c64:	e0bfff17 	ldw	r2,-4(fp)
81132c68:	00c00104 	movi	r3,4
81132c6c:	10c00005 	stb	r3,0(r2)
        return (0);
81132c70:	0005883a 	mov	r2,zero
81132c74:	00003006 	br	81132d38 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81132c78:	e0bffe17 	ldw	r2,-8(fp)
81132c7c:	1000051e 	bne	r2,zero,81132c94 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81132c80:	e0bfff17 	ldw	r2,-4(fp)
81132c84:	00c00304 	movi	r3,12
81132c88:	10c00005 	stb	r3,0(r2)
        return (0);
81132c8c:	0005883a 	mov	r2,zero
81132c90:	00002906 	br	81132d38 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81132c94:	d0a09b03 	ldbu	r2,-32148(gp)
81132c98:	10803fcc 	andi	r2,r2,255
81132c9c:	10000526 	beq	r2,zero,81132cb4 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81132ca0:	e0bfff17 	ldw	r2,-4(fp)
81132ca4:	00c00444 	movi	r3,17
81132ca8:	10c00005 	stb	r3,0(r2)
        return (0);
81132cac:	0005883a 	mov	r2,zero
81132cb0:	00002106 	br	81132d38 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81132cb4:	e0bffd17 	ldw	r2,-12(fp)
81132cb8:	10800003 	ldbu	r2,0(r2)
81132cbc:	10803fcc 	andi	r2,r2,255
81132cc0:	10bfffc4 	addi	r2,r2,-1
81132cc4:	10800128 	cmpgeui	r2,r2,4
81132cc8:	10000526 	beq	r2,zero,81132ce0 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81132ccc:	e0bfff17 	ldw	r2,-4(fp)
81132cd0:	00c00044 	movi	r3,1
81132cd4:	10c00005 	stb	r3,0(r2)
             return (0);
81132cd8:	0005883a 	mov	r2,zero
81132cdc:	00001606 	br	81132d38 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81132ce0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132ce4:	0005303a 	rdctl	r2,status
81132ce8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132cec:	e0fffb17 	ldw	r3,-20(fp)
81132cf0:	00bfff84 	movi	r2,-2
81132cf4:	1884703a 	and	r2,r3,r2
81132cf8:	1001703a 	wrctl	status,r2
  
  return context;
81132cfc:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81132d00:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
81132d04:	e0bffd17 	ldw	r2,-12(fp)
81132d08:	10800444 	addi	r2,r2,17
81132d0c:	100b883a 	mov	r5,r2
81132d10:	e13ffe17 	ldw	r4,-8(fp)
81132d14:	11347100 	call	81134710 <OS_StrCopy>
81132d18:	e0bffa05 	stb	r2,-24(fp)
81132d1c:	e0bff917 	ldw	r2,-28(fp)
81132d20:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132d24:	e0bffc17 	ldw	r2,-16(fp)
81132d28:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81132d2c:	e0bfff17 	ldw	r2,-4(fp)
81132d30:	10000005 	stb	zero,0(r2)
    return (len);
81132d34:	e0bffa03 	ldbu	r2,-24(fp)
}
81132d38:	e037883a 	mov	sp,fp
81132d3c:	dfc00117 	ldw	ra,4(sp)
81132d40:	df000017 	ldw	fp,0(sp)
81132d44:	dec00204 	addi	sp,sp,8
81132d48:	f800283a 	ret

81132d4c <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81132d4c:	defff604 	addi	sp,sp,-40
81132d50:	de00012e 	bgeu	sp,et,81132d58 <OSEventNameSet+0xc>
81132d54:	003b68fa 	trap	3
81132d58:	dfc00915 	stw	ra,36(sp)
81132d5c:	df000815 	stw	fp,32(sp)
81132d60:	df000804 	addi	fp,sp,32
81132d64:	e13ffd15 	stw	r4,-12(fp)
81132d68:	e17ffe15 	stw	r5,-8(fp)
81132d6c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132d70:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81132d74:	e0bfff17 	ldw	r2,-4(fp)
81132d78:	10004026 	beq	r2,zero,81132e7c <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81132d7c:	e0bffd17 	ldw	r2,-12(fp)
81132d80:	1000041e 	bne	r2,zero,81132d94 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81132d84:	e0bfff17 	ldw	r2,-4(fp)
81132d88:	00c00104 	movi	r3,4
81132d8c:	10c00005 	stb	r3,0(r2)
        return;
81132d90:	00003b06 	br	81132e80 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81132d94:	e0bffe17 	ldw	r2,-8(fp)
81132d98:	1000041e 	bne	r2,zero,81132dac <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81132d9c:	e0bfff17 	ldw	r2,-4(fp)
81132da0:	00c00304 	movi	r3,12
81132da4:	10c00005 	stb	r3,0(r2)
        return;
81132da8:	00003506 	br	81132e80 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81132dac:	d0a09b03 	ldbu	r2,-32148(gp)
81132db0:	10803fcc 	andi	r2,r2,255
81132db4:	10000426 	beq	r2,zero,81132dc8 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81132db8:	e0bfff17 	ldw	r2,-4(fp)
81132dbc:	00c00484 	movi	r3,18
81132dc0:	10c00005 	stb	r3,0(r2)
        return;
81132dc4:	00002e06 	br	81132e80 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81132dc8:	e0bffd17 	ldw	r2,-12(fp)
81132dcc:	10800003 	ldbu	r2,0(r2)
81132dd0:	10803fcc 	andi	r2,r2,255
81132dd4:	10bfffc4 	addi	r2,r2,-1
81132dd8:	10800128 	cmpgeui	r2,r2,4
81132ddc:	10000426 	beq	r2,zero,81132df0 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81132de0:	e0bfff17 	ldw	r2,-4(fp)
81132de4:	00c00044 	movi	r3,1
81132de8:	10c00005 	stb	r3,0(r2)
             return;
81132dec:	00002406 	br	81132e80 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81132df0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132df4:	0005303a 	rdctl	r2,status
81132df8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132dfc:	e0fffc17 	ldw	r3,-16(fp)
81132e00:	00bfff84 	movi	r2,-2
81132e04:	1884703a 	and	r2,r3,r2
81132e08:	1001703a 	wrctl	status,r2
  
  return context;
81132e0c:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81132e10:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
81132e14:	e13ffe17 	ldw	r4,-8(fp)
81132e18:	113478c0 	call	8113478c <OS_StrLen>
81132e1c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
81132e20:	e0bffa03 	ldbu	r2,-24(fp)
81132e24:	10800830 	cmpltui	r2,r2,32
81132e28:	1000081e 	bne	r2,zero,81132e4c <OSEventNameSet+0x100>
81132e2c:	e0bff817 	ldw	r2,-32(fp)
81132e30:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132e34:	e0bff917 	ldw	r2,-28(fp)
81132e38:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
81132e3c:	e0bfff17 	ldw	r2,-4(fp)
81132e40:	00c002c4 	movi	r3,11
81132e44:	10c00005 	stb	r3,0(r2)
        return;
81132e48:	00000d06 	br	81132e80 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
81132e4c:	e0bffd17 	ldw	r2,-12(fp)
81132e50:	10800444 	addi	r2,r2,17
81132e54:	e17ffe17 	ldw	r5,-8(fp)
81132e58:	1009883a 	mov	r4,r2
81132e5c:	11347100 	call	81134710 <OS_StrCopy>
81132e60:	e0bff817 	ldw	r2,-32(fp)
81132e64:	e0bffb15 	stw	r2,-20(fp)
81132e68:	e0bffb17 	ldw	r2,-20(fp)
81132e6c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81132e70:	e0bfff17 	ldw	r2,-4(fp)
81132e74:	10000005 	stb	zero,0(r2)
81132e78:	00000106 	br	81132e80 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81132e7c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81132e80:	e037883a 	mov	sp,fp
81132e84:	dfc00117 	ldw	ra,4(sp)
81132e88:	df000017 	ldw	fp,0(sp)
81132e8c:	dec00204 	addi	sp,sp,8
81132e90:	f800283a 	ret

81132e94 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
81132e94:	deffed04 	addi	sp,sp,-76
81132e98:	de00012e 	bgeu	sp,et,81132ea0 <OSEventPendMulti+0xc>
81132e9c:	003b68fa 	trap	3
81132ea0:	dfc01215 	stw	ra,72(sp)
81132ea4:	df001115 	stw	fp,68(sp)
81132ea8:	df001104 	addi	fp,sp,68
81132eac:	e13ffc15 	stw	r4,-16(fp)
81132eb0:	e17ffd15 	stw	r5,-12(fp)
81132eb4:	e1bffe15 	stw	r6,-8(fp)
81132eb8:	3805883a 	mov	r2,r7
81132ebc:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81132ec0:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
81132ec4:	e0800217 	ldw	r2,8(fp)
81132ec8:	1000021e 	bne	r2,zero,81132ed4 <OSEventPendMulti+0x40>
        return (0);
81132ecc:	0005883a 	mov	r2,zero
81132ed0:	00015006 	br	81133414 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
81132ed4:	e0bffc17 	ldw	r2,-16(fp)
81132ed8:	1000051e 	bne	r2,zero,81132ef0 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81132edc:	e0800217 	ldw	r2,8(fp)
81132ee0:	00c00104 	movi	r3,4
81132ee4:	10c00005 	stb	r3,0(r2)
        return (0);
81132ee8:	0005883a 	mov	r2,zero
81132eec:	00014906 	br	81133414 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81132ef0:	e0bffd17 	ldw	r2,-12(fp)
81132ef4:	1000051e 	bne	r2,zero,81132f0c <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81132ef8:	e0800217 	ldw	r2,8(fp)
81132efc:	00c00104 	movi	r3,4
81132f00:	10c00005 	stb	r3,0(r2)
        return (0);
81132f04:	0005883a 	mov	r2,zero
81132f08:	00014206 	br	81133414 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
81132f0c:	e0bffe17 	ldw	r2,-8(fp)
81132f10:	1000051e 	bne	r2,zero,81132f28 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
81132f14:	e0800217 	ldw	r2,8(fp)
81132f18:	00c00104 	movi	r3,4
81132f1c:	10c00005 	stb	r3,0(r2)
        return (0);
81132f20:	0005883a 	mov	r2,zero
81132f24:	00013b06 	br	81133414 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
81132f28:	e0bffd17 	ldw	r2,-12(fp)
81132f2c:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
81132f30:	e0bffc17 	ldw	r2,-16(fp)
81132f34:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
81132f38:	e0bfef17 	ldw	r2,-68(fp)
81132f3c:	10800017 	ldw	r2,0(r2)
81132f40:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
81132f44:	00001506 	br	81132f9c <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
81132f48:	e0bff017 	ldw	r2,-64(fp)
81132f4c:	10800003 	ldbu	r2,0(r2)
81132f50:	10803fcc 	andi	r2,r2,255
81132f54:	10c000a0 	cmpeqi	r3,r2,2
81132f58:	1800071e 	bne	r3,zero,81132f78 <OSEventPendMulti+0xe4>
81132f5c:	108000e0 	cmpeqi	r2,r2,3
81132f60:	1000071e 	bne	r2,zero,81132f80 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
81132f64:	e0800217 	ldw	r2,8(fp)
81132f68:	00c00044 	movi	r3,1
81132f6c:	10c00005 	stb	r3,0(r2)
                 return (0);
81132f70:	0005883a 	mov	r2,zero
81132f74:	00012706 	br	81133414 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81132f78:	0001883a 	nop
81132f7c:	00000106 	br	81132f84 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
81132f80:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81132f84:	e0bfef17 	ldw	r2,-68(fp)
81132f88:	10800104 	addi	r2,r2,4
81132f8c:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81132f90:	e0bfef17 	ldw	r2,-68(fp)
81132f94:	10800017 	ldw	r2,0(r2)
81132f98:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81132f9c:	e0bff017 	ldw	r2,-64(fp)
81132fa0:	103fe91e 	bne	r2,zero,81132f48 <__reset+0xfb112f48>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
81132fa4:	d0a09b03 	ldbu	r2,-32148(gp)
81132fa8:	10803fcc 	andi	r2,r2,255
81132fac:	10000526 	beq	r2,zero,81132fc4 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81132fb0:	e0800217 	ldw	r2,8(fp)
81132fb4:	00c00084 	movi	r3,2
81132fb8:	10c00005 	stb	r3,0(r2)
        return (0);
81132fbc:	0005883a 	mov	r2,zero
81132fc0:	00011406 	br	81133414 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
81132fc4:	d0a08903 	ldbu	r2,-32220(gp)
81132fc8:	10803fcc 	andi	r2,r2,255
81132fcc:	10000526 	beq	r2,zero,81132fe4 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
81132fd0:	e0800217 	ldw	r2,8(fp)
81132fd4:	00c00344 	movi	r3,13
81132fd8:	10c00005 	stb	r3,0(r2)
        return (0);
81132fdc:	0005883a 	mov	r2,zero
81132fe0:	00010c06 	br	81133414 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132fe4:	0005303a 	rdctl	r2,status
81132fe8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132fec:	e0fffb17 	ldw	r3,-20(fp)
81132ff0:	00bfff84 	movi	r2,-2
81132ff4:	1884703a 	and	r2,r3,r2
81132ff8:	1001703a 	wrctl	status,r2
  
  return context;
81132ffc:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
81133000:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
81133004:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
81133008:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
8113300c:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
81133010:	e0bffc17 	ldw	r2,-16(fp)
81133014:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
81133018:	e0bfef17 	ldw	r2,-68(fp)
8113301c:	10800017 	ldw	r2,0(r2)
81133020:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81133024:	00006406 	br	811331b8 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
81133028:	e0bff017 	ldw	r2,-64(fp)
8113302c:	10800003 	ldbu	r2,0(r2)
81133030:	10803fcc 	andi	r2,r2,255
81133034:	10c000a0 	cmpeqi	r3,r2,2
81133038:	18001f1e 	bne	r3,zero,811330b8 <OSEventPendMulti+0x224>
8113303c:	108000e0 	cmpeqi	r2,r2,3
81133040:	10004c26 	beq	r2,zero,81133174 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
81133044:	e0bff017 	ldw	r2,-64(fp)
81133048:	1080020b 	ldhu	r2,8(r2)
8113304c:	10bfffcc 	andi	r2,r2,65535
81133050:	10001526 	beq	r2,zero,811330a8 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
81133054:	e0bff017 	ldw	r2,-64(fp)
81133058:	1080020b 	ldhu	r2,8(r2)
8113305c:	10bfffc4 	addi	r2,r2,-1
81133060:	1007883a 	mov	r3,r2
81133064:	e0bff017 	ldw	r2,-64(fp)
81133068:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
8113306c:	e0bffd17 	ldw	r2,-12(fp)
81133070:	10c00104 	addi	r3,r2,4
81133074:	e0fffd15 	stw	r3,-12(fp)
81133078:	e0fff017 	ldw	r3,-64(fp)
8113307c:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
81133080:	00800044 	movi	r2,1
81133084:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81133088:	e0bffe17 	ldw	r2,-8(fp)
8113308c:	10c00104 	addi	r3,r2,4
81133090:	e0fffe15 	stw	r3,-8(fp)
81133094:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
81133098:	e0bff18b 	ldhu	r2,-58(fp)
8113309c:	10800044 	addi	r2,r2,1
811330a0:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
811330a4:	00003e06 	br	811331a0 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
811330a8:	e0bff203 	ldbu	r2,-56(fp)
811330ac:	10800054 	ori	r2,r2,1
811330b0:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
811330b4:	00003a06 	br	811331a0 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
811330b8:	e0bff017 	ldw	r2,-64(fp)
811330bc:	10800117 	ldw	r2,4(r2)
811330c0:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
811330c4:	e0bff517 	ldw	r2,-44(fp)
811330c8:	1080058b 	ldhu	r2,22(r2)
811330cc:	10bfffcc 	andi	r2,r2,65535
811330d0:	10002426 	beq	r2,zero,81133164 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
811330d4:	e0bffe17 	ldw	r2,-8(fp)
811330d8:	10c00104 	addi	r3,r2,4
811330dc:	e0fffe15 	stw	r3,-8(fp)
811330e0:	e0fff517 	ldw	r3,-44(fp)
811330e4:	18c00417 	ldw	r3,16(r3)
811330e8:	19400104 	addi	r5,r3,4
811330ec:	e13ff517 	ldw	r4,-44(fp)
811330f0:	21400415 	stw	r5,16(r4)
811330f4:	18c00017 	ldw	r3,0(r3)
811330f8:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
811330fc:	e0bff517 	ldw	r2,-44(fp)
81133100:	10c00417 	ldw	r3,16(r2)
81133104:	e0bff517 	ldw	r2,-44(fp)
81133108:	10800217 	ldw	r2,8(r2)
8113310c:	1880041e 	bne	r3,r2,81133120 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
81133110:	e0bff517 	ldw	r2,-44(fp)
81133114:	10c00117 	ldw	r3,4(r2)
81133118:	e0bff517 	ldw	r2,-44(fp)
8113311c:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
81133120:	e0bff517 	ldw	r2,-44(fp)
81133124:	1080058b 	ldhu	r2,22(r2)
81133128:	10bfffc4 	addi	r2,r2,-1
8113312c:	1007883a 	mov	r3,r2
81133130:	e0bff517 	ldw	r2,-44(fp)
81133134:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
81133138:	e0bffd17 	ldw	r2,-12(fp)
8113313c:	10c00104 	addi	r3,r2,4
81133140:	e0fffd15 	stw	r3,-12(fp)
81133144:	e0fff017 	ldw	r3,-64(fp)
81133148:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
8113314c:	00800044 	movi	r2,1
81133150:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81133154:	e0bff18b 	ldhu	r2,-58(fp)
81133158:	10800044 	addi	r2,r2,1
8113315c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
81133160:	00000f06 	br	811331a0 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81133164:	e0bff203 	ldbu	r2,-56(fp)
81133168:	10800114 	ori	r2,r2,4
8113316c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81133170:	00000b06 	br	811331a0 <OSEventPendMulti+0x30c>
81133174:	e0bff317 	ldw	r2,-52(fp)
81133178:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113317c:	e0bff417 	ldw	r2,-48(fp)
81133180:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81133184:	e0bffd17 	ldw	r2,-12(fp)
81133188:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
8113318c:	e0800217 	ldw	r2,8(fp)
81133190:	00c00044 	movi	r3,1
81133194:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81133198:	e0bff18b 	ldhu	r2,-58(fp)
8113319c:	00009d06 	br	81133414 <OSEventPendMulti+0x580>
        }
        pevents++;
811331a0:	e0bfef17 	ldw	r2,-68(fp)
811331a4:	10800104 	addi	r2,r2,4
811331a8:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
811331ac:	e0bfef17 	ldw	r2,-68(fp)
811331b0:	10800017 	ldw	r2,0(r2)
811331b4:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811331b8:	e0bff017 	ldw	r2,-64(fp)
811331bc:	103f9a1e 	bne	r2,zero,81133028 <__reset+0xfb113028>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
811331c0:	e0bff103 	ldbu	r2,-60(fp)
811331c4:	10800058 	cmpnei	r2,r2,1
811331c8:	10000a1e 	bne	r2,zero,811331f4 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
811331cc:	e0bffd17 	ldw	r2,-12(fp)
811331d0:	10000015 	stw	zero,0(r2)
811331d4:	e0bff317 	ldw	r2,-52(fp)
811331d8:	e0bff615 	stw	r2,-40(fp)
811331dc:	e0bff617 	ldw	r2,-40(fp)
811331e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
811331e4:	e0800217 	ldw	r2,8(fp)
811331e8:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
811331ec:	e0bff18b 	ldhu	r2,-58(fp)
811331f0:	00008806 	br	81133414 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
811331f4:	d0a09c17 	ldw	r2,-32144(gp)
811331f8:	d0e09c17 	ldw	r3,-32144(gp)
811331fc:	19000c03 	ldbu	r4,48(r3)
81133200:	e0fff203 	ldbu	r3,-56(fp)
81133204:	20c6b03a 	or	r3,r4,r3
81133208:	1809883a 	mov	r4,r3
8113320c:	00ffe004 	movi	r3,-128
81133210:	20c6b03a 	or	r3,r4,r3
81133214:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81133218:	d0a09c17 	ldw	r2,-32144(gp)
8113321c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
81133220:	d0a09c17 	ldw	r2,-32144(gp)
81133224:	e0ffff0b 	ldhu	r3,-4(fp)
81133228:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
8113322c:	e13ffc17 	ldw	r4,-16(fp)
81133230:	1133db80 	call	81133db8 <OS_EventTaskWaitMulti>
81133234:	e0bff317 	ldw	r2,-52(fp)
81133238:	e0bff915 	stw	r2,-28(fp)
8113323c:	e0bff917 	ldw	r2,-28(fp)
81133240:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81133244:	11345bc0 	call	811345bc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133248:	0005303a 	rdctl	r2,status
8113324c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133250:	e0fff717 	ldw	r3,-36(fp)
81133254:	00bfff84 	movi	r2,-2
81133258:	1884703a 	and	r2,r3,r2
8113325c:	1001703a 	wrctl	status,r2
  
  return context;
81133260:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81133264:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81133268:	d0a09c17 	ldw	r2,-32144(gp)
8113326c:	10800c43 	ldbu	r2,49(r2)
81133270:	10803fcc 	andi	r2,r2,255
81133274:	10000226 	beq	r2,zero,81133280 <OSEventPendMulti+0x3ec>
81133278:	108000a0 	cmpeqi	r2,r2,2
8113327c:	10001826 	beq	r2,zero,811332e0 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
81133280:	d0a09c17 	ldw	r2,-32144(gp)
81133284:	10800717 	ldw	r2,28(r2)
81133288:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
8113328c:	e0bff017 	ldw	r2,-64(fp)
81133290:	10000b26 	beq	r2,zero,811332c0 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81133294:	e0bffd17 	ldw	r2,-12(fp)
81133298:	10c00104 	addi	r3,r2,4
8113329c:	e0fffd15 	stw	r3,-12(fp)
811332a0:	e0fff017 	ldw	r3,-64(fp)
811332a4:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
811332a8:	e0bffd17 	ldw	r2,-12(fp)
811332ac:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
811332b0:	e0bff18b 	ldhu	r2,-58(fp)
811332b4:	10800044 	addi	r2,r2,1
811332b8:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
811332bc:	00000d06 	br	811332f4 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
811332c0:	d0a09c17 	ldw	r2,-32144(gp)
811332c4:	00c00044 	movi	r3,1
811332c8:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811332cc:	d0a09c17 	ldw	r2,-32144(gp)
811332d0:	e17ffc17 	ldw	r5,-16(fp)
811332d4:	1009883a 	mov	r4,r2
811332d8:	1133fd00 	call	81133fd0 <OS_EventTaskRemoveMulti>
             }
			 break;
811332dc:	00000506 	br	811332f4 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811332e0:	d0a09c17 	ldw	r2,-32144(gp)
811332e4:	e17ffc17 	ldw	r5,-16(fp)
811332e8:	1009883a 	mov	r4,r2
811332ec:	1133fd00 	call	81133fd0 <OS_EventTaskRemoveMulti>
             break;
811332f0:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
811332f4:	d0a09c17 	ldw	r2,-32144(gp)
811332f8:	10800c43 	ldbu	r2,49(r2)
811332fc:	10803fcc 	andi	r2,r2,255
81133300:	10000326 	beq	r2,zero,81133310 <OSEventPendMulti+0x47c>
81133304:	108000a0 	cmpeqi	r2,r2,2
81133308:	1000231e 	bne	r2,zero,81133398 <OSEventPendMulti+0x504>
8113330c:	00002a06 	br	811333b8 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
81133310:	e0bff017 	ldw	r2,-64(fp)
81133314:	10800003 	ldbu	r2,0(r2)
81133318:	10803fcc 	andi	r2,r2,255
8113331c:	0080100e 	bge	zero,r2,81133360 <OSEventPendMulti+0x4cc>
81133320:	10c000d0 	cmplti	r3,r2,3
81133324:	1800071e 	bne	r3,zero,81133344 <OSEventPendMulti+0x4b0>
81133328:	108000e0 	cmpeqi	r2,r2,3
8113332c:	10000c26 	beq	r2,zero,81133360 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
81133330:	e0bffe17 	ldw	r2,-8(fp)
81133334:	10c00104 	addi	r3,r2,4
81133338:	e0fffe15 	stw	r3,-8(fp)
8113333c:	10000015 	stw	zero,0(r2)
                      break;
81133340:	00001206 	br	8113338c <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81133344:	e0bffe17 	ldw	r2,-8(fp)
81133348:	10c00104 	addi	r3,r2,4
8113334c:	e0fffe15 	stw	r3,-8(fp)
81133350:	d0e09c17 	ldw	r3,-32144(gp)
81133354:	18c00917 	ldw	r3,36(r3)
81133358:	10c00015 	stw	r3,0(r2)
                      break;
8113335c:	00000b06 	br	8113338c <OSEventPendMulti+0x4f8>
81133360:	e0bff317 	ldw	r2,-52(fp)
81133364:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133368:	e0bff817 	ldw	r2,-32(fp)
8113336c:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
81133370:	e0bffd17 	ldw	r2,-12(fp)
81133374:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81133378:	e0800217 	ldw	r2,8(fp)
8113337c:	00c00044 	movi	r3,1
81133380:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81133384:	e0bff18b 	ldhu	r2,-58(fp)
81133388:	00002206 	br	81133414 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
8113338c:	e0800217 	ldw	r2,8(fp)
81133390:	10000005 	stb	zero,0(r2)
             break;
81133394:	00001006 	br	811333d8 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81133398:	e0bffe17 	ldw	r2,-8(fp)
8113339c:	10c00104 	addi	r3,r2,4
811333a0:	e0fffe15 	stw	r3,-8(fp)
811333a4:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
811333a8:	e0800217 	ldw	r2,8(fp)
811333ac:	00c00384 	movi	r3,14
811333b0:	10c00005 	stb	r3,0(r2)
             break;
811333b4:	00000806 	br	811333d8 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
811333b8:	e0bffe17 	ldw	r2,-8(fp)
811333bc:	10c00104 	addi	r3,r2,4
811333c0:	e0fffe15 	stw	r3,-8(fp)
811333c4:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
811333c8:	e0800217 	ldw	r2,8(fp)
811333cc:	00c00284 	movi	r3,10
811333d0:	10c00005 	stb	r3,0(r2)
             break;
811333d4:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
811333d8:	d0a09c17 	ldw	r2,-32144(gp)
811333dc:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
811333e0:	d0a09c17 	ldw	r2,-32144(gp)
811333e4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
811333e8:	d0a09c17 	ldw	r2,-32144(gp)
811333ec:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
811333f0:	d0a09c17 	ldw	r2,-32144(gp)
811333f4:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
811333f8:	d0a09c17 	ldw	r2,-32144(gp)
811333fc:	10000915 	stw	zero,36(r2)
81133400:	e0bff317 	ldw	r2,-52(fp)
81133404:	e0bffa15 	stw	r2,-24(fp)
81133408:	e0bffa17 	ldw	r2,-24(fp)
8113340c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81133410:	e0bff18b 	ldhu	r2,-58(fp)
}
81133414:	e037883a 	mov	sp,fp
81133418:	dfc00117 	ldw	ra,4(sp)
8113341c:	df000017 	ldw	fp,0(sp)
81133420:	dec00204 	addi	sp,sp,8
81133424:	f800283a 	ret

81133428 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81133428:	defffe04 	addi	sp,sp,-8
8113342c:	de00012e 	bgeu	sp,et,81133434 <OSInit+0xc>
81133430:	003b68fa 	trap	3
81133434:	dfc00115 	stw	ra,4(sp)
81133438:	df000015 	stw	fp,0(sp)
8113343c:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81133440:	11457780 	call	81145778 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81133444:	11342300 	call	81134230 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81133448:	11342800 	call	81134280 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
8113344c:	11344040 	call	81134404 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81133450:	11341480 	call	81134148 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81133454:	11363c40 	call	811363c4 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81133458:	1136d0c0 	call	81136d0c <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
8113345c:	1138fdc0 	call	81138fdc <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81133460:	11342f40 	call	811342f4 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81133464:	113437c0 	call	8113437c <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81133468:	113c1cc0 	call	8113c1cc <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
8113346c:	11457a40 	call	811457a4 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81133470:	1134ce00 	call	81134ce0 <OSDebugInit>
#endif
}
81133474:	0001883a 	nop
81133478:	e037883a 	mov	sp,fp
8113347c:	dfc00117 	ldw	ra,4(sp)
81133480:	df000017 	ldw	fp,0(sp)
81133484:	dec00204 	addi	sp,sp,8
81133488:	f800283a 	ret

8113348c <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
8113348c:	deffff04 	addi	sp,sp,-4
81133490:	de00012e 	bgeu	sp,et,81133498 <OSIntEnter+0xc>
81133494:	003b68fa 	trap	3
81133498:	df000015 	stw	fp,0(sp)
8113349c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
811334a0:	d0a08b03 	ldbu	r2,-32212(gp)
811334a4:	10803fcc 	andi	r2,r2,255
811334a8:	10800058 	cmpnei	r2,r2,1
811334ac:	1000071e 	bne	r2,zero,811334cc <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
811334b0:	d0a09b03 	ldbu	r2,-32148(gp)
811334b4:	10803fcc 	andi	r2,r2,255
811334b8:	10803fe0 	cmpeqi	r2,r2,255
811334bc:	1000031e 	bne	r2,zero,811334cc <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
811334c0:	d0a09b03 	ldbu	r2,-32148(gp)
811334c4:	10800044 	addi	r2,r2,1
811334c8:	d0a09b05 	stb	r2,-32148(gp)
        }
    }
}
811334cc:	0001883a 	nop
811334d0:	e037883a 	mov	sp,fp
811334d4:	df000017 	ldw	fp,0(sp)
811334d8:	dec00104 	addi	sp,sp,4
811334dc:	f800283a 	ret

811334e0 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
811334e0:	defffb04 	addi	sp,sp,-20
811334e4:	de00012e 	bgeu	sp,et,811334ec <OSIntExit+0xc>
811334e8:	003b68fa 	trap	3
811334ec:	dfc00415 	stw	ra,16(sp)
811334f0:	df000315 	stw	fp,12(sp)
811334f4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811334f8:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
811334fc:	d0a08b03 	ldbu	r2,-32212(gp)
81133500:	10803fcc 	andi	r2,r2,255
81133504:	10800058 	cmpnei	r2,r2,1
81133508:	10002f1e 	bne	r2,zero,811335c8 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113350c:	0005303a 	rdctl	r2,status
81133510:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133514:	e0ffff17 	ldw	r3,-4(fp)
81133518:	00bfff84 	movi	r2,-2
8113351c:	1884703a 	and	r2,r3,r2
81133520:	1001703a 	wrctl	status,r2
  
  return context;
81133524:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81133528:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
8113352c:	d0a09b03 	ldbu	r2,-32148(gp)
81133530:	10803fcc 	andi	r2,r2,255
81133534:	10000326 	beq	r2,zero,81133544 <OSIntExit+0x64>
            OSIntNesting--;
81133538:	d0a09b03 	ldbu	r2,-32148(gp)
8113353c:	10bfffc4 	addi	r2,r2,-1
81133540:	d0a09b05 	stb	r2,-32148(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81133544:	d0a09b03 	ldbu	r2,-32148(gp)
81133548:	10803fcc 	andi	r2,r2,255
8113354c:	10001a1e 	bne	r2,zero,811335b8 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81133550:	d0a08903 	ldbu	r2,-32220(gp)
81133554:	10803fcc 	andi	r2,r2,255
81133558:	1000171e 	bne	r2,zero,811335b8 <OSIntExit+0xd8>
                OS_SchedNew();
8113355c:	11346940 	call	81134694 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81133560:	d0e08d83 	ldbu	r3,-32202(gp)
81133564:	d0a08dc3 	ldbu	r2,-32201(gp)
81133568:	18c03fcc 	andi	r3,r3,255
8113356c:	10803fcc 	andi	r2,r2,255
81133570:	18801126 	beq	r3,r2,811335b8 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81133574:	d0a08d83 	ldbu	r2,-32202(gp)
81133578:	10c03fcc 	andi	r3,r2,255
8113357c:	00a045b4 	movhi	r2,33046
81133580:	10979804 	addi	r2,r2,24160
81133584:	18c7883a 	add	r3,r3,r3
81133588:	18c7883a 	add	r3,r3,r3
8113358c:	10c5883a 	add	r2,r2,r3
81133590:	10800017 	ldw	r2,0(r2)
81133594:	d0a09615 	stw	r2,-32168(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81133598:	d0a09617 	ldw	r2,-32168(gp)
8113359c:	10c00e17 	ldw	r3,56(r2)
811335a0:	18c00044 	addi	r3,r3,1
811335a4:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
811335a8:	d0a09017 	ldw	r2,-32192(gp)
811335ac:	10800044 	addi	r2,r2,1
811335b0:	d0a09015 	stw	r2,-32192(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
811335b4:	11454380 	call	81145438 <OSCtxSw>
811335b8:	e0bffd17 	ldw	r2,-12(fp)
811335bc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811335c0:	e0bffe17 	ldw	r2,-8(fp)
811335c4:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
811335c8:	0001883a 	nop
811335cc:	e037883a 	mov	sp,fp
811335d0:	dfc00117 	ldw	ra,4(sp)
811335d4:	df000017 	ldw	fp,0(sp)
811335d8:	dec00204 	addi	sp,sp,8
811335dc:	f800283a 	ret

811335e0 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
811335e0:	defffc04 	addi	sp,sp,-16
811335e4:	de00012e 	bgeu	sp,et,811335ec <OSSchedLock+0xc>
811335e8:	003b68fa 	trap	3
811335ec:	df000315 	stw	fp,12(sp)
811335f0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811335f4:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
811335f8:	d0a08b03 	ldbu	r2,-32212(gp)
811335fc:	10803fcc 	andi	r2,r2,255
81133600:	10800058 	cmpnei	r2,r2,1
81133604:	1000161e 	bne	r2,zero,81133660 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133608:	0005303a 	rdctl	r2,status
8113360c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133610:	e0ffff17 	ldw	r3,-4(fp)
81133614:	00bfff84 	movi	r2,-2
81133618:	1884703a 	and	r2,r3,r2
8113361c:	1001703a 	wrctl	status,r2
  
  return context;
81133620:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81133624:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81133628:	d0a09b03 	ldbu	r2,-32148(gp)
8113362c:	10803fcc 	andi	r2,r2,255
81133630:	1000071e 	bne	r2,zero,81133650 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81133634:	d0a08903 	ldbu	r2,-32220(gp)
81133638:	10803fcc 	andi	r2,r2,255
8113363c:	10803fe0 	cmpeqi	r2,r2,255
81133640:	1000031e 	bne	r2,zero,81133650 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81133644:	d0a08903 	ldbu	r2,-32220(gp)
81133648:	10800044 	addi	r2,r2,1
8113364c:	d0a08905 	stb	r2,-32220(gp)
81133650:	e0bffd17 	ldw	r2,-12(fp)
81133654:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133658:	e0bffe17 	ldw	r2,-8(fp)
8113365c:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81133660:	0001883a 	nop
81133664:	e037883a 	mov	sp,fp
81133668:	df000017 	ldw	fp,0(sp)
8113366c:	dec00104 	addi	sp,sp,4
81133670:	f800283a 	ret

81133674 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81133674:	defff804 	addi	sp,sp,-32
81133678:	de00012e 	bgeu	sp,et,81133680 <OSSchedUnlock+0xc>
8113367c:	003b68fa 	trap	3
81133680:	dfc00715 	stw	ra,28(sp)
81133684:	df000615 	stw	fp,24(sp)
81133688:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113368c:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81133690:	d0a08b03 	ldbu	r2,-32212(gp)
81133694:	10803fcc 	andi	r2,r2,255
81133698:	10800058 	cmpnei	r2,r2,1
8113369c:	1000281e 	bne	r2,zero,81133740 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811336a0:	0005303a 	rdctl	r2,status
811336a4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811336a8:	e0ffff17 	ldw	r3,-4(fp)
811336ac:	00bfff84 	movi	r2,-2
811336b0:	1884703a 	and	r2,r3,r2
811336b4:	1001703a 	wrctl	status,r2
  
  return context;
811336b8:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
811336bc:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
811336c0:	d0a08903 	ldbu	r2,-32220(gp)
811336c4:	10803fcc 	andi	r2,r2,255
811336c8:	10001926 	beq	r2,zero,81133730 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
811336cc:	d0a08903 	ldbu	r2,-32220(gp)
811336d0:	10bfffc4 	addi	r2,r2,-1
811336d4:	d0a08905 	stb	r2,-32220(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
811336d8:	d0a08903 	ldbu	r2,-32220(gp)
811336dc:	10803fcc 	andi	r2,r2,255
811336e0:	10000e1e 	bne	r2,zero,8113371c <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
811336e4:	d0a09b03 	ldbu	r2,-32148(gp)
811336e8:	10803fcc 	andi	r2,r2,255
811336ec:	1000061e 	bne	r2,zero,81133708 <OSSchedUnlock+0x94>
811336f0:	e0bffa17 	ldw	r2,-24(fp)
811336f4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811336f8:	e0bffb17 	ldw	r2,-20(fp)
811336fc:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81133700:	11345bc0 	call	811345bc <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81133704:	00000e06 	br	81133740 <OSSchedUnlock+0xcc>
81133708:	e0bffa17 	ldw	r2,-24(fp)
8113370c:	e0bffc15 	stw	r2,-16(fp)
81133710:	e0bffc17 	ldw	r2,-16(fp)
81133714:	1001703a 	wrctl	status,r2
81133718:	00000906 	br	81133740 <OSSchedUnlock+0xcc>
8113371c:	e0bffa17 	ldw	r2,-24(fp)
81133720:	e0bffd15 	stw	r2,-12(fp)
81133724:	e0bffd17 	ldw	r2,-12(fp)
81133728:	1001703a 	wrctl	status,r2
8113372c:	00000406 	br	81133740 <OSSchedUnlock+0xcc>
81133730:	e0bffa17 	ldw	r2,-24(fp)
81133734:	e0bffe15 	stw	r2,-8(fp)
81133738:	e0bffe17 	ldw	r2,-8(fp)
8113373c:	1001703a 	wrctl	status,r2
81133740:	0001883a 	nop
81133744:	e037883a 	mov	sp,fp
81133748:	dfc00117 	ldw	ra,4(sp)
8113374c:	df000017 	ldw	fp,0(sp)
81133750:	dec00204 	addi	sp,sp,8
81133754:	f800283a 	ret

81133758 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81133758:	defffe04 	addi	sp,sp,-8
8113375c:	de00012e 	bgeu	sp,et,81133764 <OSStart+0xc>
81133760:	003b68fa 	trap	3
81133764:	dfc00115 	stw	ra,4(sp)
81133768:	df000015 	stw	fp,0(sp)
8113376c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
81133770:	d0a08b03 	ldbu	r2,-32212(gp)
81133774:	10803fcc 	andi	r2,r2,255
81133778:	10000f1e 	bne	r2,zero,811337b8 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
8113377c:	11346940 	call	81134694 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81133780:	d0a08d83 	ldbu	r2,-32202(gp)
81133784:	d0a08dc5 	stb	r2,-32201(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81133788:	d0a08d83 	ldbu	r2,-32202(gp)
8113378c:	10c03fcc 	andi	r3,r2,255
81133790:	00a045b4 	movhi	r2,33046
81133794:	10979804 	addi	r2,r2,24160
81133798:	18c7883a 	add	r3,r3,r3
8113379c:	18c7883a 	add	r3,r3,r3
811337a0:	10c5883a 	add	r2,r2,r3
811337a4:	10800017 	ldw	r2,0(r2)
811337a8:	d0a09615 	stw	r2,-32168(gp)
        OSTCBCur      = OSTCBHighRdy;
811337ac:	d0a09617 	ldw	r2,-32168(gp)
811337b0:	d0a09c15 	stw	r2,-32144(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
811337b4:	11454d40 	call	811454d4 <OSStartHighRdy>
    }
}
811337b8:	0001883a 	nop
811337bc:	e037883a 	mov	sp,fp
811337c0:	dfc00117 	ldw	ra,4(sp)
811337c4:	df000017 	ldw	fp,0(sp)
811337c8:	dec00204 	addi	sp,sp,8
811337cc:	f800283a 	ret

811337d0 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
811337d0:	defff904 	addi	sp,sp,-28
811337d4:	de00012e 	bgeu	sp,et,811337dc <OSStatInit+0xc>
811337d8:	003b68fa 	trap	3
811337dc:	dfc00615 	stw	ra,24(sp)
811337e0:	df000515 	stw	fp,20(sp)
811337e4:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811337e8:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
811337ec:	01000084 	movi	r4,2
811337f0:	113b1440 	call	8113b144 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811337f4:	0005303a 	rdctl	r2,status
811337f8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811337fc:	e0fffc17 	ldw	r3,-16(fp)
81133800:	00bfff84 	movi	r2,-2
81133804:	1884703a 	and	r2,r3,r2
81133808:	1001703a 	wrctl	status,r2
  
  return context;
8113380c:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81133810:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81133814:	d0208c15 	stw	zero,-32208(gp)
81133818:	e0bffb17 	ldw	r2,-20(fp)
8113381c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133820:	e0bffd17 	ldw	r2,-12(fp)
81133824:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81133828:	01001904 	movi	r4,100
8113382c:	113b1440 	call	8113b144 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133830:	0005303a 	rdctl	r2,status
81133834:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133838:	e0fffe17 	ldw	r3,-8(fp)
8113383c:	00bfff84 	movi	r2,-2
81133840:	1884703a 	and	r2,r3,r2
81133844:	1001703a 	wrctl	status,r2
  
  return context;
81133848:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
8113384c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
81133850:	d0a08c17 	ldw	r2,-32208(gp)
81133854:	d0a09215 	stw	r2,-32184(gp)
    OSStatRdy    = OS_TRUE;
81133858:	00800044 	movi	r2,1
8113385c:	d0a0a105 	stb	r2,-32124(gp)
81133860:	e0bffb17 	ldw	r2,-20(fp)
81133864:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133868:	e0bfff17 	ldw	r2,-4(fp)
8113386c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81133870:	0001883a 	nop
81133874:	e037883a 	mov	sp,fp
81133878:	dfc00117 	ldw	ra,4(sp)
8113387c:	df000017 	ldw	fp,0(sp)
81133880:	dec00204 	addi	sp,sp,8
81133884:	f800283a 	ret

81133888 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81133888:	defff704 	addi	sp,sp,-36
8113388c:	de00012e 	bgeu	sp,et,81133894 <OSTimeTick+0xc>
81133890:	003b68fa 	trap	3
81133894:	dfc00815 	stw	ra,32(sp)
81133898:	df000715 	stw	fp,28(sp)
8113389c:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811338a0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
811338a4:	11457240 	call	81145724 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811338a8:	0005303a 	rdctl	r2,status
811338ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811338b0:	e0fffd17 	ldw	r3,-12(fp)
811338b4:	00bfff84 	movi	r2,-2
811338b8:	1884703a 	and	r2,r3,r2
811338bc:	1001703a 	wrctl	status,r2
  
  return context;
811338c0:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
811338c4:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
811338c8:	d0a09e17 	ldw	r2,-32136(gp)
811338cc:	10800044 	addi	r2,r2,1
811338d0:	d0a09e15 	stw	r2,-32136(gp)
811338d4:	e0bffb17 	ldw	r2,-20(fp)
811338d8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811338dc:	e0bfff17 	ldw	r2,-4(fp)
811338e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
811338e4:	d0a08b03 	ldbu	r2,-32212(gp)
811338e8:	10803fcc 	andi	r2,r2,255
811338ec:	10800058 	cmpnei	r2,r2,1
811338f0:	10006a1e 	bne	r2,zero,81133a9c <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
811338f4:	d0a08f03 	ldbu	r2,-32196(gp)
811338f8:	10803fcc 	andi	r2,r2,255
811338fc:	10c00060 	cmpeqi	r3,r2,1
81133900:	1800061e 	bne	r3,zero,8113391c <OSTimeTick+0x94>
81133904:	10c000a0 	cmpeqi	r3,r2,2
81133908:	1800061e 	bne	r3,zero,81133924 <OSTimeTick+0x9c>
8113390c:	10000a1e 	bne	r2,zero,81133938 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81133910:	00800044 	movi	r2,1
81133914:	e0bffa05 	stb	r2,-24(fp)
                 break;
81133918:	00000b06 	br	81133948 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
8113391c:	e03ffa05 	stb	zero,-24(fp)
                 break;
81133920:	00000906 	br	81133948 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81133924:	00800044 	movi	r2,1
81133928:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
8113392c:	00800044 	movi	r2,1
81133930:	d0a08f05 	stb	r2,-32196(gp)
                 break;
81133934:	00000406 	br	81133948 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81133938:	00800044 	movi	r2,1
8113393c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81133940:	d0208f05 	stb	zero,-32196(gp)
                 break;
81133944:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81133948:	e0bffa03 	ldbu	r2,-24(fp)
8113394c:	10005226 	beq	r2,zero,81133a98 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
81133950:	d0a08e17 	ldw	r2,-32200(gp)
81133954:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81133958:	00004906 	br	81133a80 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113395c:	0005303a 	rdctl	r2,status
81133960:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133964:	e0fffc17 	ldw	r3,-16(fp)
81133968:	00bfff84 	movi	r2,-2
8113396c:	1884703a 	and	r2,r3,r2
81133970:	1001703a 	wrctl	status,r2
  
  return context;
81133974:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81133978:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
8113397c:	e0bff917 	ldw	r2,-28(fp)
81133980:	10800b8b 	ldhu	r2,46(r2)
81133984:	10bfffcc 	andi	r2,r2,65535
81133988:	10003626 	beq	r2,zero,81133a64 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
8113398c:	e0bff917 	ldw	r2,-28(fp)
81133990:	10800b8b 	ldhu	r2,46(r2)
81133994:	10bfffc4 	addi	r2,r2,-1
81133998:	1007883a 	mov	r3,r2
8113399c:	e0bff917 	ldw	r2,-28(fp)
811339a0:	10c00b8d 	sth	r3,46(r2)
811339a4:	e0bff917 	ldw	r2,-28(fp)
811339a8:	10800b8b 	ldhu	r2,46(r2)
811339ac:	10bfffcc 	andi	r2,r2,65535
811339b0:	10002c1e 	bne	r2,zero,81133a64 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
811339b4:	e0bff917 	ldw	r2,-28(fp)
811339b8:	10800c03 	ldbu	r2,48(r2)
811339bc:	10803fcc 	andi	r2,r2,255
811339c0:	10800dcc 	andi	r2,r2,55
811339c4:	10000b26 	beq	r2,zero,811339f4 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
811339c8:	e0bff917 	ldw	r2,-28(fp)
811339cc:	10c00c03 	ldbu	r3,48(r2)
811339d0:	00bff204 	movi	r2,-56
811339d4:	1884703a 	and	r2,r3,r2
811339d8:	1007883a 	mov	r3,r2
811339dc:	e0bff917 	ldw	r2,-28(fp)
811339e0:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
811339e4:	e0bff917 	ldw	r2,-28(fp)
811339e8:	00c00044 	movi	r3,1
811339ec:	10c00c45 	stb	r3,49(r2)
811339f0:	00000206 	br	811339fc <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
811339f4:	e0bff917 	ldw	r2,-28(fp)
811339f8:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
811339fc:	e0bff917 	ldw	r2,-28(fp)
81133a00:	10800c03 	ldbu	r2,48(r2)
81133a04:	10803fcc 	andi	r2,r2,255
81133a08:	1080020c 	andi	r2,r2,8
81133a0c:	1000151e 	bne	r2,zero,81133a64 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
81133a10:	e0bff917 	ldw	r2,-28(fp)
81133a14:	10c00d83 	ldbu	r3,54(r2)
81133a18:	d0a09803 	ldbu	r2,-32160(gp)
81133a1c:	1884b03a 	or	r2,r3,r2
81133a20:	d0a09805 	stb	r2,-32160(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81133a24:	e0bff917 	ldw	r2,-28(fp)
81133a28:	10800d03 	ldbu	r2,52(r2)
81133a2c:	10c03fcc 	andi	r3,r2,255
81133a30:	e0bff917 	ldw	r2,-28(fp)
81133a34:	10800d03 	ldbu	r2,52(r2)
81133a38:	11003fcc 	andi	r4,r2,255
81133a3c:	d0a09844 	addi	r2,gp,-32159
81133a40:	2085883a 	add	r2,r4,r2
81133a44:	11000003 	ldbu	r4,0(r2)
81133a48:	e0bff917 	ldw	r2,-28(fp)
81133a4c:	10800d43 	ldbu	r2,53(r2)
81133a50:	2084b03a 	or	r2,r4,r2
81133a54:	1009883a 	mov	r4,r2
81133a58:	d0a09844 	addi	r2,gp,-32159
81133a5c:	1885883a 	add	r2,r3,r2
81133a60:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
81133a64:	e0bff917 	ldw	r2,-28(fp)
81133a68:	10800517 	ldw	r2,20(r2)
81133a6c:	e0bff915 	stw	r2,-28(fp)
81133a70:	e0bffb17 	ldw	r2,-20(fp)
81133a74:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133a78:	e0bffe17 	ldw	r2,-8(fp)
81133a7c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81133a80:	e0bff917 	ldw	r2,-28(fp)
81133a84:	10800c83 	ldbu	r2,50(r2)
81133a88:	10803fcc 	andi	r2,r2,255
81133a8c:	10800a18 	cmpnei	r2,r2,40
81133a90:	103fb21e 	bne	r2,zero,8113395c <__reset+0xfb11395c>
81133a94:	00000106 	br	81133a9c <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81133a98:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81133a9c:	e037883a 	mov	sp,fp
81133aa0:	dfc00117 	ldw	ra,4(sp)
81133aa4:	df000017 	ldw	fp,0(sp)
81133aa8:	dec00204 	addi	sp,sp,8
81133aac:	f800283a 	ret

81133ab0 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
81133ab0:	deffff04 	addi	sp,sp,-4
81133ab4:	de00012e 	bgeu	sp,et,81133abc <OSVersion+0xc>
81133ab8:	003b68fa 	trap	3
81133abc:	df000015 	stw	fp,0(sp)
81133ac0:	d839883a 	mov	fp,sp
    return (OS_VERSION);
81133ac4:	00804784 	movi	r2,286
}
81133ac8:	e037883a 	mov	sp,fp
81133acc:	df000017 	ldw	fp,0(sp)
81133ad0:	dec00104 	addi	sp,sp,4
81133ad4:	f800283a 	ret

81133ad8 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81133ad8:	deffff04 	addi	sp,sp,-4
81133adc:	de00012e 	bgeu	sp,et,81133ae4 <OS_Dummy+0xc>
81133ae0:	003b68fa 	trap	3
81133ae4:	df000015 	stw	fp,0(sp)
81133ae8:	d839883a 	mov	fp,sp
}
81133aec:	0001883a 	nop
81133af0:	e037883a 	mov	sp,fp
81133af4:	df000017 	ldw	fp,0(sp)
81133af8:	dec00104 	addi	sp,sp,4
81133afc:	f800283a 	ret

81133b00 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
81133b00:	defff804 	addi	sp,sp,-32
81133b04:	de00012e 	bgeu	sp,et,81133b0c <OS_EventTaskRdy+0xc>
81133b08:	003b68fa 	trap	3
81133b0c:	dfc00715 	stw	ra,28(sp)
81133b10:	df000615 	stw	fp,24(sp)
81133b14:	df000604 	addi	fp,sp,24
81133b18:	e13ffc15 	stw	r4,-16(fp)
81133b1c:	e17ffd15 	stw	r5,-12(fp)
81133b20:	3007883a 	mov	r3,r6
81133b24:	3805883a 	mov	r2,r7
81133b28:	e0fffe05 	stb	r3,-8(fp)
81133b2c:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
81133b30:	e0bffc17 	ldw	r2,-16(fp)
81133b34:	10800283 	ldbu	r2,10(r2)
81133b38:	10c03fcc 	andi	r3,r2,255
81133b3c:	00a04574 	movhi	r2,33045
81133b40:	10aad904 	addi	r2,r2,-21660
81133b44:	10c5883a 	add	r2,r2,r3
81133b48:	10800003 	ldbu	r2,0(r2)
81133b4c:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
81133b50:	e0bffa03 	ldbu	r2,-24(fp)
81133b54:	e0fffc17 	ldw	r3,-16(fp)
81133b58:	1885883a 	add	r2,r3,r2
81133b5c:	108002c4 	addi	r2,r2,11
81133b60:	10800003 	ldbu	r2,0(r2)
81133b64:	10c03fcc 	andi	r3,r2,255
81133b68:	00a04574 	movhi	r2,33045
81133b6c:	10aad904 	addi	r2,r2,-21660
81133b70:	10c5883a 	add	r2,r2,r3
81133b74:	10800003 	ldbu	r2,0(r2)
81133b78:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81133b7c:	e0bffa03 	ldbu	r2,-24(fp)
81133b80:	100490fa 	slli	r2,r2,3
81133b84:	1007883a 	mov	r3,r2
81133b88:	e0bffa43 	ldbu	r2,-23(fp)
81133b8c:	1885883a 	add	r2,r3,r2
81133b90:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
81133b94:	e0fffa83 	ldbu	r3,-22(fp)
81133b98:	00a045b4 	movhi	r2,33046
81133b9c:	10979804 	addi	r2,r2,24160
81133ba0:	18c7883a 	add	r3,r3,r3
81133ba4:	18c7883a 	add	r3,r3,r3
81133ba8:	10c5883a 	add	r2,r2,r3
81133bac:	10800017 	ldw	r2,0(r2)
81133bb0:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
81133bb4:	e0bffb17 	ldw	r2,-20(fp)
81133bb8:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81133bbc:	e0bffb17 	ldw	r2,-20(fp)
81133bc0:	e0fffd17 	ldw	r3,-12(fp)
81133bc4:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81133bc8:	e0bffb17 	ldw	r2,-20(fp)
81133bcc:	10800c03 	ldbu	r2,48(r2)
81133bd0:	1007883a 	mov	r3,r2
81133bd4:	e0bffe03 	ldbu	r2,-8(fp)
81133bd8:	0084303a 	nor	r2,zero,r2
81133bdc:	1884703a 	and	r2,r3,r2
81133be0:	1007883a 	mov	r3,r2
81133be4:	e0bffb17 	ldw	r2,-20(fp)
81133be8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81133bec:	e0bffb17 	ldw	r2,-20(fp)
81133bf0:	e0ffff03 	ldbu	r3,-4(fp)
81133bf4:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
81133bf8:	e0bffb17 	ldw	r2,-20(fp)
81133bfc:	10800c03 	ldbu	r2,48(r2)
81133c00:	10803fcc 	andi	r2,r2,255
81133c04:	1080020c 	andi	r2,r2,8
81133c08:	1000111e 	bne	r2,zero,81133c50 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
81133c0c:	e0bffb17 	ldw	r2,-20(fp)
81133c10:	10c00d83 	ldbu	r3,54(r2)
81133c14:	d0a09803 	ldbu	r2,-32160(gp)
81133c18:	1884b03a 	or	r2,r3,r2
81133c1c:	d0a09805 	stb	r2,-32160(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
81133c20:	e0fffa03 	ldbu	r3,-24(fp)
81133c24:	e13ffa03 	ldbu	r4,-24(fp)
81133c28:	d0a09844 	addi	r2,gp,-32159
81133c2c:	2085883a 	add	r2,r4,r2
81133c30:	11000003 	ldbu	r4,0(r2)
81133c34:	e0bffb17 	ldw	r2,-20(fp)
81133c38:	10800d43 	ldbu	r2,53(r2)
81133c3c:	2084b03a 	or	r2,r4,r2
81133c40:	1009883a 	mov	r4,r2
81133c44:	d0a09844 	addi	r2,gp,-32159
81133c48:	1885883a 	add	r2,r3,r2
81133c4c:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
81133c50:	e17ffc17 	ldw	r5,-16(fp)
81133c54:	e13ffb17 	ldw	r4,-20(fp)
81133c58:	1133f100 	call	81133f10 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
81133c5c:	e0bffb17 	ldw	r2,-20(fp)
81133c60:	10800817 	ldw	r2,32(r2)
81133c64:	10000826 	beq	r2,zero,81133c88 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81133c68:	e0bffb17 	ldw	r2,-20(fp)
81133c6c:	10800817 	ldw	r2,32(r2)
81133c70:	100b883a 	mov	r5,r2
81133c74:	e13ffb17 	ldw	r4,-20(fp)
81133c78:	1133fd00 	call	81133fd0 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
81133c7c:	e0bffb17 	ldw	r2,-20(fp)
81133c80:	e0fffc17 	ldw	r3,-16(fp)
81133c84:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81133c88:	e0bffa83 	ldbu	r2,-22(fp)
}
81133c8c:	e037883a 	mov	sp,fp
81133c90:	dfc00117 	ldw	ra,4(sp)
81133c94:	df000017 	ldw	fp,0(sp)
81133c98:	dec00204 	addi	sp,sp,8
81133c9c:	f800283a 	ret

81133ca0 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
81133ca0:	defffd04 	addi	sp,sp,-12
81133ca4:	de00012e 	bgeu	sp,et,81133cac <OS_EventTaskWait+0xc>
81133ca8:	003b68fa 	trap	3
81133cac:	df000215 	stw	fp,8(sp)
81133cb0:	df000204 	addi	fp,sp,8
81133cb4:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81133cb8:	d0a09c17 	ldw	r2,-32144(gp)
81133cbc:	e0ffff17 	ldw	r3,-4(fp)
81133cc0:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
81133cc4:	d0a09c17 	ldw	r2,-32144(gp)
81133cc8:	10800d03 	ldbu	r2,52(r2)
81133ccc:	10803fcc 	andi	r2,r2,255
81133cd0:	d0e09c17 	ldw	r3,-32144(gp)
81133cd4:	18c00d03 	ldbu	r3,52(r3)
81133cd8:	18c03fcc 	andi	r3,r3,255
81133cdc:	e13fff17 	ldw	r4,-4(fp)
81133ce0:	20c7883a 	add	r3,r4,r3
81133ce4:	18c002c4 	addi	r3,r3,11
81133ce8:	19000003 	ldbu	r4,0(r3)
81133cec:	d0e09c17 	ldw	r3,-32144(gp)
81133cf0:	18c00d43 	ldbu	r3,53(r3)
81133cf4:	20c6b03a 	or	r3,r4,r3
81133cf8:	1809883a 	mov	r4,r3
81133cfc:	e0ffff17 	ldw	r3,-4(fp)
81133d00:	1885883a 	add	r2,r3,r2
81133d04:	108002c4 	addi	r2,r2,11
81133d08:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81133d0c:	e0bfff17 	ldw	r2,-4(fp)
81133d10:	10c00283 	ldbu	r3,10(r2)
81133d14:	d0a09c17 	ldw	r2,-32144(gp)
81133d18:	10800d83 	ldbu	r2,54(r2)
81133d1c:	1884b03a 	or	r2,r3,r2
81133d20:	1007883a 	mov	r3,r2
81133d24:	e0bfff17 	ldw	r2,-4(fp)
81133d28:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81133d2c:	d0a09c17 	ldw	r2,-32144(gp)
81133d30:	10800d03 	ldbu	r2,52(r2)
81133d34:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81133d38:	e0fffe03 	ldbu	r3,-8(fp)
81133d3c:	e13ffe03 	ldbu	r4,-8(fp)
81133d40:	d0a09844 	addi	r2,gp,-32159
81133d44:	2085883a 	add	r2,r4,r2
81133d48:	10800003 	ldbu	r2,0(r2)
81133d4c:	1009883a 	mov	r4,r2
81133d50:	d0a09c17 	ldw	r2,-32144(gp)
81133d54:	10800d43 	ldbu	r2,53(r2)
81133d58:	0084303a 	nor	r2,zero,r2
81133d5c:	2084703a 	and	r2,r4,r2
81133d60:	1009883a 	mov	r4,r2
81133d64:	d0a09844 	addi	r2,gp,-32159
81133d68:	1885883a 	add	r2,r3,r2
81133d6c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81133d70:	e0fffe03 	ldbu	r3,-8(fp)
81133d74:	d0a09844 	addi	r2,gp,-32159
81133d78:	1885883a 	add	r2,r3,r2
81133d7c:	10800003 	ldbu	r2,0(r2)
81133d80:	10803fcc 	andi	r2,r2,255
81133d84:	1000071e 	bne	r2,zero,81133da4 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81133d88:	d0a09c17 	ldw	r2,-32144(gp)
81133d8c:	10800d83 	ldbu	r2,54(r2)
81133d90:	0084303a 	nor	r2,zero,r2
81133d94:	1007883a 	mov	r3,r2
81133d98:	d0a09803 	ldbu	r2,-32160(gp)
81133d9c:	1884703a 	and	r2,r3,r2
81133da0:	d0a09805 	stb	r2,-32160(gp)
    }
}
81133da4:	0001883a 	nop
81133da8:	e037883a 	mov	sp,fp
81133dac:	df000017 	ldw	fp,0(sp)
81133db0:	dec00104 	addi	sp,sp,4
81133db4:	f800283a 	ret

81133db8 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
81133db8:	defffb04 	addi	sp,sp,-20
81133dbc:	de00012e 	bgeu	sp,et,81133dc4 <OS_EventTaskWaitMulti+0xc>
81133dc0:	003b68fa 	trap	3
81133dc4:	df000415 	stw	fp,16(sp)
81133dc8:	df000404 	addi	fp,sp,16
81133dcc:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
81133dd0:	d0a09c17 	ldw	r2,-32144(gp)
81133dd4:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
81133dd8:	d0a09c17 	ldw	r2,-32144(gp)
81133ddc:	e0ffff17 	ldw	r3,-4(fp)
81133de0:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
81133de4:	e0bfff17 	ldw	r2,-4(fp)
81133de8:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
81133dec:	e0bffc17 	ldw	r2,-16(fp)
81133df0:	10800017 	ldw	r2,0(r2)
81133df4:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81133df8:	00002006 	br	81133e7c <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
81133dfc:	d0a09c17 	ldw	r2,-32144(gp)
81133e00:	10800d03 	ldbu	r2,52(r2)
81133e04:	10803fcc 	andi	r2,r2,255
81133e08:	d0e09c17 	ldw	r3,-32144(gp)
81133e0c:	18c00d03 	ldbu	r3,52(r3)
81133e10:	18c03fcc 	andi	r3,r3,255
81133e14:	e13ffd17 	ldw	r4,-12(fp)
81133e18:	20c7883a 	add	r3,r4,r3
81133e1c:	18c002c4 	addi	r3,r3,11
81133e20:	19000003 	ldbu	r4,0(r3)
81133e24:	d0e09c17 	ldw	r3,-32144(gp)
81133e28:	18c00d43 	ldbu	r3,53(r3)
81133e2c:	20c6b03a 	or	r3,r4,r3
81133e30:	1809883a 	mov	r4,r3
81133e34:	e0fffd17 	ldw	r3,-12(fp)
81133e38:	1885883a 	add	r2,r3,r2
81133e3c:	108002c4 	addi	r2,r2,11
81133e40:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81133e44:	e0bffd17 	ldw	r2,-12(fp)
81133e48:	10c00283 	ldbu	r3,10(r2)
81133e4c:	d0a09c17 	ldw	r2,-32144(gp)
81133e50:	10800d83 	ldbu	r2,54(r2)
81133e54:	1884b03a 	or	r2,r3,r2
81133e58:	1007883a 	mov	r3,r2
81133e5c:	e0bffd17 	ldw	r2,-12(fp)
81133e60:	10c00285 	stb	r3,10(r2)
        pevents++;
81133e64:	e0bffc17 	ldw	r2,-16(fp)
81133e68:	10800104 	addi	r2,r2,4
81133e6c:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
81133e70:	e0bffc17 	ldw	r2,-16(fp)
81133e74:	10800017 	ldw	r2,0(r2)
81133e78:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81133e7c:	e0bffd17 	ldw	r2,-12(fp)
81133e80:	103fde1e 	bne	r2,zero,81133dfc <__reset+0xfb113dfc>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81133e84:	d0a09c17 	ldw	r2,-32144(gp)
81133e88:	10800d03 	ldbu	r2,52(r2)
81133e8c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81133e90:	e0fffe03 	ldbu	r3,-8(fp)
81133e94:	e13ffe03 	ldbu	r4,-8(fp)
81133e98:	d0a09844 	addi	r2,gp,-32159
81133e9c:	2085883a 	add	r2,r4,r2
81133ea0:	10800003 	ldbu	r2,0(r2)
81133ea4:	1009883a 	mov	r4,r2
81133ea8:	d0a09c17 	ldw	r2,-32144(gp)
81133eac:	10800d43 	ldbu	r2,53(r2)
81133eb0:	0084303a 	nor	r2,zero,r2
81133eb4:	2084703a 	and	r2,r4,r2
81133eb8:	1009883a 	mov	r4,r2
81133ebc:	d0a09844 	addi	r2,gp,-32159
81133ec0:	1885883a 	add	r2,r3,r2
81133ec4:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81133ec8:	e0fffe03 	ldbu	r3,-8(fp)
81133ecc:	d0a09844 	addi	r2,gp,-32159
81133ed0:	1885883a 	add	r2,r3,r2
81133ed4:	10800003 	ldbu	r2,0(r2)
81133ed8:	10803fcc 	andi	r2,r2,255
81133edc:	1000071e 	bne	r2,zero,81133efc <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81133ee0:	d0a09c17 	ldw	r2,-32144(gp)
81133ee4:	10800d83 	ldbu	r2,54(r2)
81133ee8:	0084303a 	nor	r2,zero,r2
81133eec:	1007883a 	mov	r3,r2
81133ef0:	d0a09803 	ldbu	r2,-32160(gp)
81133ef4:	1884703a 	and	r2,r3,r2
81133ef8:	d0a09805 	stb	r2,-32160(gp)
    }
}
81133efc:	0001883a 	nop
81133f00:	e037883a 	mov	sp,fp
81133f04:	df000017 	ldw	fp,0(sp)
81133f08:	dec00104 	addi	sp,sp,4
81133f0c:	f800283a 	ret

81133f10 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
81133f10:	defffc04 	addi	sp,sp,-16
81133f14:	de00012e 	bgeu	sp,et,81133f1c <OS_EventTaskRemove+0xc>
81133f18:	003b68fa 	trap	3
81133f1c:	df000315 	stw	fp,12(sp)
81133f20:	df000304 	addi	fp,sp,12
81133f24:	e13ffe15 	stw	r4,-8(fp)
81133f28:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
81133f2c:	e0bffe17 	ldw	r2,-8(fp)
81133f30:	10800d03 	ldbu	r2,52(r2)
81133f34:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
81133f38:	e0bffd03 	ldbu	r2,-12(fp)
81133f3c:	e0fffd03 	ldbu	r3,-12(fp)
81133f40:	e13fff17 	ldw	r4,-4(fp)
81133f44:	20c7883a 	add	r3,r4,r3
81133f48:	18c002c4 	addi	r3,r3,11
81133f4c:	18c00003 	ldbu	r3,0(r3)
81133f50:	1809883a 	mov	r4,r3
81133f54:	e0fffe17 	ldw	r3,-8(fp)
81133f58:	18c00d43 	ldbu	r3,53(r3)
81133f5c:	00c6303a 	nor	r3,zero,r3
81133f60:	20c6703a 	and	r3,r4,r3
81133f64:	1809883a 	mov	r4,r3
81133f68:	e0ffff17 	ldw	r3,-4(fp)
81133f6c:	1885883a 	add	r2,r3,r2
81133f70:	108002c4 	addi	r2,r2,11
81133f74:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81133f78:	e0bffd03 	ldbu	r2,-12(fp)
81133f7c:	e0ffff17 	ldw	r3,-4(fp)
81133f80:	1885883a 	add	r2,r3,r2
81133f84:	108002c4 	addi	r2,r2,11
81133f88:	10800003 	ldbu	r2,0(r2)
81133f8c:	10803fcc 	andi	r2,r2,255
81133f90:	10000a1e 	bne	r2,zero,81133fbc <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
81133f94:	e0bfff17 	ldw	r2,-4(fp)
81133f98:	10800283 	ldbu	r2,10(r2)
81133f9c:	1007883a 	mov	r3,r2
81133fa0:	e0bffe17 	ldw	r2,-8(fp)
81133fa4:	10800d83 	ldbu	r2,54(r2)
81133fa8:	0084303a 	nor	r2,zero,r2
81133fac:	1884703a 	and	r2,r3,r2
81133fb0:	1007883a 	mov	r3,r2
81133fb4:	e0bfff17 	ldw	r2,-4(fp)
81133fb8:	10c00285 	stb	r3,10(r2)
    }
}
81133fbc:	0001883a 	nop
81133fc0:	e037883a 	mov	sp,fp
81133fc4:	df000017 	ldw	fp,0(sp)
81133fc8:	dec00104 	addi	sp,sp,4
81133fcc:	f800283a 	ret

81133fd0 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
81133fd0:	defffa04 	addi	sp,sp,-24
81133fd4:	de00012e 	bgeu	sp,et,81133fdc <OS_EventTaskRemoveMulti+0xc>
81133fd8:	003b68fa 	trap	3
81133fdc:	df000515 	stw	fp,20(sp)
81133fe0:	df000504 	addi	fp,sp,20
81133fe4:	e13ffe15 	stw	r4,-8(fp)
81133fe8:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
81133fec:	e0bffe17 	ldw	r2,-8(fp)
81133ff0:	10800d03 	ldbu	r2,52(r2)
81133ff4:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
81133ff8:	e0bffe17 	ldw	r2,-8(fp)
81133ffc:	10800d83 	ldbu	r2,54(r2)
81134000:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
81134004:	e0bffe17 	ldw	r2,-8(fp)
81134008:	10800d43 	ldbu	r2,53(r2)
8113400c:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
81134010:	e0bfff17 	ldw	r2,-4(fp)
81134014:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
81134018:	e0bffb17 	ldw	r2,-20(fp)
8113401c:	10800017 	ldw	r2,0(r2)
81134020:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81134024:	00002506 	br	811340bc <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
81134028:	e0bffd03 	ldbu	r2,-12(fp)
8113402c:	e0fffd03 	ldbu	r3,-12(fp)
81134030:	e13ffc17 	ldw	r4,-16(fp)
81134034:	20c7883a 	add	r3,r4,r3
81134038:	18c002c4 	addi	r3,r3,11
8113403c:	18c00003 	ldbu	r3,0(r3)
81134040:	1809883a 	mov	r4,r3
81134044:	e0fffd83 	ldbu	r3,-10(fp)
81134048:	00c6303a 	nor	r3,zero,r3
8113404c:	20c6703a 	and	r3,r4,r3
81134050:	1809883a 	mov	r4,r3
81134054:	e0fffc17 	ldw	r3,-16(fp)
81134058:	1885883a 	add	r2,r3,r2
8113405c:	108002c4 	addi	r2,r2,11
81134060:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
81134064:	e0bffd03 	ldbu	r2,-12(fp)
81134068:	e0fffc17 	ldw	r3,-16(fp)
8113406c:	1885883a 	add	r2,r3,r2
81134070:	108002c4 	addi	r2,r2,11
81134074:	10800003 	ldbu	r2,0(r2)
81134078:	10803fcc 	andi	r2,r2,255
8113407c:	1000091e 	bne	r2,zero,811340a4 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
81134080:	e0bffc17 	ldw	r2,-16(fp)
81134084:	10800283 	ldbu	r2,10(r2)
81134088:	1007883a 	mov	r3,r2
8113408c:	e0bffd43 	ldbu	r2,-11(fp)
81134090:	0084303a 	nor	r2,zero,r2
81134094:	1884703a 	and	r2,r3,r2
81134098:	1007883a 	mov	r3,r2
8113409c:	e0bffc17 	ldw	r2,-16(fp)
811340a0:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
811340a4:	e0bffb17 	ldw	r2,-20(fp)
811340a8:	10800104 	addi	r2,r2,4
811340ac:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
811340b0:	e0bffb17 	ldw	r2,-20(fp)
811340b4:	10800017 	ldw	r2,0(r2)
811340b8:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
811340bc:	e0bffc17 	ldw	r2,-16(fp)
811340c0:	103fd91e 	bne	r2,zero,81134028 <__reset+0xfb114028>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
811340c4:	0001883a 	nop
811340c8:	e037883a 	mov	sp,fp
811340cc:	df000017 	ldw	fp,0(sp)
811340d0:	dec00104 	addi	sp,sp,4
811340d4:	f800283a 	ret

811340d8 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
811340d8:	defffc04 	addi	sp,sp,-16
811340dc:	de00012e 	bgeu	sp,et,811340e4 <OS_EventWaitListInit+0xc>
811340e0:	003b68fa 	trap	3
811340e4:	df000315 	stw	fp,12(sp)
811340e8:	df000304 	addi	fp,sp,12
811340ec:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
811340f0:	e0bfff17 	ldw	r2,-4(fp)
811340f4:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
811340f8:	e0bfff17 	ldw	r2,-4(fp)
811340fc:	108002c4 	addi	r2,r2,11
81134100:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81134104:	e03ffe05 	stb	zero,-8(fp)
81134108:	00000706 	br	81134128 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
8113410c:	e0bffd17 	ldw	r2,-12(fp)
81134110:	10c00044 	addi	r3,r2,1
81134114:	e0fffd15 	stw	r3,-12(fp)
81134118:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113411c:	e0bffe03 	ldbu	r2,-8(fp)
81134120:	10800044 	addi	r2,r2,1
81134124:	e0bffe05 	stb	r2,-8(fp)
81134128:	e0bffe03 	ldbu	r2,-8(fp)
8113412c:	108001b0 	cmpltui	r2,r2,6
81134130:	103ff61e 	bne	r2,zero,8113410c <__reset+0xfb11410c>
        *ptbl++ = 0;
    }
}
81134134:	0001883a 	nop
81134138:	e037883a 	mov	sp,fp
8113413c:	df000017 	ldw	fp,0(sp)
81134140:	dec00104 	addi	sp,sp,4
81134144:	f800283a 	ret

81134148 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
81134148:	defffb04 	addi	sp,sp,-20
8113414c:	de00012e 	bgeu	sp,et,81134154 <OS_InitEventList+0xc>
81134150:	003b68fa 	trap	3
81134154:	dfc00415 	stw	ra,16(sp)
81134158:	df000315 	stw	fp,12(sp)
8113415c:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
81134160:	01434004 	movi	r5,3328
81134164:	012045b4 	movhi	r4,33046
81134168:	2110c204 	addi	r4,r4,17160
8113416c:	11344f00 	call	811344f0 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
81134170:	00a045b4 	movhi	r2,33046
81134174:	1090c204 	addi	r2,r2,17160
81134178:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8113417c:	00a045b4 	movhi	r2,33046
81134180:	1090cf04 	addi	r2,r2,17212
81134184:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81134188:	e03ffd0d 	sth	zero,-12(fp)
8113418c:	00001306 	br	811341dc <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
81134190:	e0bffe17 	ldw	r2,-8(fp)
81134194:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
81134198:	e0bffe17 	ldw	r2,-8(fp)
8113419c:	e0ffff17 	ldw	r3,-4(fp)
811341a0:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
811341a4:	e0bffe17 	ldw	r2,-8(fp)
811341a8:	00c00fc4 	movi	r3,63
811341ac:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
811341b0:	e0bffe17 	ldw	r2,-8(fp)
811341b4:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
811341b8:	e0bffe17 	ldw	r2,-8(fp)
811341bc:	10800d04 	addi	r2,r2,52
811341c0:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
811341c4:	e0bfff17 	ldw	r2,-4(fp)
811341c8:	10800d04 	addi	r2,r2,52
811341cc:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
811341d0:	e0bffd0b 	ldhu	r2,-12(fp)
811341d4:	10800044 	addi	r2,r2,1
811341d8:	e0bffd0d 	sth	r2,-12(fp)
811341dc:	e0bffd0b 	ldhu	r2,-12(fp)
811341e0:	10800ff0 	cmpltui	r2,r2,63
811341e4:	103fea1e 	bne	r2,zero,81134190 <__reset+0xfb114190>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
811341e8:	e0bffe17 	ldw	r2,-8(fp)
811341ec:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
811341f0:	e0bffe17 	ldw	r2,-8(fp)
811341f4:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
811341f8:	e0bffe17 	ldw	r2,-8(fp)
811341fc:	00c00fc4 	movi	r3,63
81134200:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
81134204:	e0bffe17 	ldw	r2,-8(fp)
81134208:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
8113420c:	00a045b4 	movhi	r2,33046
81134210:	1090c204 	addi	r2,r2,17160
81134214:	d0a09a15 	stw	r2,-32152(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
81134218:	0001883a 	nop
8113421c:	e037883a 	mov	sp,fp
81134220:	dfc00117 	ldw	ra,4(sp)
81134224:	df000017 	ldw	fp,0(sp)
81134228:	dec00204 	addi	sp,sp,8
8113422c:	f800283a 	ret

81134230 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
81134230:	deffff04 	addi	sp,sp,-4
81134234:	de00012e 	bgeu	sp,et,8113423c <OS_InitMisc+0xc>
81134238:	003b68fa 	trap	3
8113423c:	df000015 	stw	fp,0(sp)
81134240:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
81134244:	d0209e15 	stw	zero,-32136(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
81134248:	d0209b05 	stb	zero,-32148(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8113424c:	d0208905 	stb	zero,-32220(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
81134250:	d0209445 	stb	zero,-32175(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
81134254:	d0208b05 	stb	zero,-32212(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
81134258:	d0209015 	stw	zero,-32192(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8113425c:	d0208c15 	stw	zero,-32208(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
81134260:	d020a215 	stw	zero,-32120(gp)
    OSIdleCtrMax  = 0L;
81134264:	d0209215 	stw	zero,-32184(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
81134268:	d020a105 	stb	zero,-32124(gp)
#endif
}
8113426c:	0001883a 	nop
81134270:	e037883a 	mov	sp,fp
81134274:	df000017 	ldw	fp,0(sp)
81134278:	dec00104 	addi	sp,sp,4
8113427c:	f800283a 	ret

81134280 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
81134280:	defffd04 	addi	sp,sp,-12
81134284:	de00012e 	bgeu	sp,et,8113428c <OS_InitRdyList+0xc>
81134288:	003b68fa 	trap	3
8113428c:	df000215 	stw	fp,8(sp)
81134290:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
81134294:	d0209805 	stb	zero,-32160(gp)
    prdytbl       = &OSRdyTbl[0];
81134298:	d0a09844 	addi	r2,gp,-32159
8113429c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
811342a0:	e03ffe05 	stb	zero,-8(fp)
811342a4:	00000706 	br	811342c4 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
811342a8:	e0bfff17 	ldw	r2,-4(fp)
811342ac:	10c00044 	addi	r3,r2,1
811342b0:	e0ffff15 	stw	r3,-4(fp)
811342b4:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
811342b8:	e0bffe03 	ldbu	r2,-8(fp)
811342bc:	10800044 	addi	r2,r2,1
811342c0:	e0bffe05 	stb	r2,-8(fp)
811342c4:	e0bffe03 	ldbu	r2,-8(fp)
811342c8:	108001b0 	cmpltui	r2,r2,6
811342cc:	103ff61e 	bne	r2,zero,811342a8 <__reset+0xfb1142a8>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
811342d0:	d0208dc5 	stb	zero,-32201(gp)
    OSPrioHighRdy = 0;
811342d4:	d0208d85 	stb	zero,-32202(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
811342d8:	d0209615 	stw	zero,-32168(gp)
    OSTCBCur      = (OS_TCB *)0;
811342dc:	d0209c15 	stw	zero,-32144(gp)
}
811342e0:	0001883a 	nop
811342e4:	e037883a 	mov	sp,fp
811342e8:	df000017 	ldw	fp,0(sp)
811342ec:	dec00104 	addi	sp,sp,4
811342f0:	f800283a 	ret

811342f4 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
811342f4:	defff804 	addi	sp,sp,-32
811342f8:	de00012e 	bgeu	sp,et,81134300 <OS_InitTaskIdle+0xc>
811342fc:	003b68fa 	trap	3
81134300:	dfc00715 	stw	ra,28(sp)
81134304:	df000615 	stw	fp,24(sp)
81134308:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
8113430c:	008000c4 	movi	r2,3
81134310:	d8800415 	stw	r2,16(sp)
81134314:	d8000315 	stw	zero,12(sp)
81134318:	00810004 	movi	r2,1024
8113431c:	d8800215 	stw	r2,8(sp)
81134320:	00a045b4 	movhi	r2,33046
81134324:	108cc204 	addi	r2,r2,13064
81134328:	d8800115 	stw	r2,4(sp)
8113432c:	00bfffd4 	movui	r2,65535
81134330:	d8800015 	stw	r2,0(sp)
81134334:	01c00a04 	movi	r7,40
81134338:	01a045b4 	movhi	r6,33046
8113433c:	3190c104 	addi	r6,r6,17156
81134340:	000b883a 	mov	r5,zero
81134344:	012044f4 	movhi	r4,33043
81134348:	2111fa04 	addi	r4,r4,18408
8113434c:	113a0240 	call	8113a024 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
81134350:	e1bfff04 	addi	r6,fp,-4
81134354:	01604574 	movhi	r5,33045
81134358:	296b1904 	addi	r5,r5,-21404
8113435c:	01000a04 	movi	r4,40
81134360:	113a8540 	call	8113a854 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
81134364:	0001883a 	nop
81134368:	e037883a 	mov	sp,fp
8113436c:	dfc00117 	ldw	ra,4(sp)
81134370:	df000017 	ldw	fp,0(sp)
81134374:	dec00204 	addi	sp,sp,8
81134378:	f800283a 	ret

8113437c <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8113437c:	defff804 	addi	sp,sp,-32
81134380:	de00012e 	bgeu	sp,et,81134388 <OS_InitTaskStat+0xc>
81134384:	003b68fa 	trap	3
81134388:	dfc00715 	stw	ra,28(sp)
8113438c:	df000615 	stw	fp,24(sp)
81134390:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
81134394:	008000c4 	movi	r2,3
81134398:	d8800415 	stw	r2,16(sp)
8113439c:	d8000315 	stw	zero,12(sp)
811343a0:	00810004 	movi	r2,1024
811343a4:	d8800215 	stw	r2,8(sp)
811343a8:	00a045b4 	movhi	r2,33046
811343ac:	10866204 	addi	r2,r2,6536
811343b0:	d8800115 	stw	r2,4(sp)
811343b4:	00bfff94 	movui	r2,65534
811343b8:	d8800015 	stw	r2,0(sp)
811343bc:	01c009c4 	movi	r7,39
811343c0:	01a045b4 	movhi	r6,33046
811343c4:	318a6104 	addi	r6,r6,10628
811343c8:	000b883a 	mov	r5,zero
811343cc:	012044f4 	movhi	r4,33043
811343d0:	21121304 	addi	r4,r4,18508
811343d4:	113a0240 	call	8113a024 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
811343d8:	e1bfff04 	addi	r6,fp,-4
811343dc:	01604574 	movhi	r5,33045
811343e0:	296b1d04 	addi	r5,r5,-21388
811343e4:	010009c4 	movi	r4,39
811343e8:	113a8540 	call	8113a854 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
811343ec:	0001883a 	nop
811343f0:	e037883a 	mov	sp,fp
811343f4:	dfc00117 	ldw	ra,4(sp)
811343f8:	df000017 	ldw	fp,0(sp)
811343fc:	dec00204 	addi	sp,sp,8
81134400:	f800283a 	ret

81134404 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81134404:	defffb04 	addi	sp,sp,-20
81134408:	de00012e 	bgeu	sp,et,81134410 <OS_InitTCBList+0xc>
8113440c:	003b68fa 	trap	3
81134410:	dfc00415 	stw	ra,16(sp)
81134414:	df000315 	stw	fp,12(sp)
81134418:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
8113441c:	01439604 	movi	r5,3672
81134420:	012045b4 	movhi	r4,33046
81134424:	21140204 	addi	r4,r4,20488
81134428:	11344f00 	call	811344f0 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
8113442c:	01402904 	movi	r5,164
81134430:	012045b4 	movhi	r4,33046
81134434:	21179804 	addi	r4,r4,24160
81134438:	11344f00 	call	811344f0 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
8113443c:	00a045b4 	movhi	r2,33046
81134440:	10940204 	addi	r2,r2,20488
81134444:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
81134448:	00a045b4 	movhi	r2,33046
8113444c:	10941d04 	addi	r2,r2,20596
81134450:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81134454:	e03ffd05 	stb	zero,-12(fp)
81134458:	00001106 	br	811344a0 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
8113445c:	e0bffe17 	ldw	r2,-8(fp)
81134460:	e0ffff17 	ldw	r3,-4(fp)
81134464:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
81134468:	e0bffe17 	ldw	r2,-8(fp)
8113446c:	00c00fc4 	movi	r3,63
81134470:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81134474:	e0bffe17 	ldw	r2,-8(fp)
81134478:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
8113447c:	e0bffe17 	ldw	r2,-8(fp)
81134480:	10801b04 	addi	r2,r2,108
81134484:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81134488:	e0bfff17 	ldw	r2,-4(fp)
8113448c:	10801b04 	addi	r2,r2,108
81134490:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81134494:	e0bffd03 	ldbu	r2,-12(fp)
81134498:	10800044 	addi	r2,r2,1
8113449c:	e0bffd05 	stb	r2,-12(fp)
811344a0:	e0bffd03 	ldbu	r2,-12(fp)
811344a4:	10800870 	cmpltui	r2,r2,33
811344a8:	103fec1e 	bne	r2,zero,8113445c <__reset+0xfb11445c>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
811344ac:	e0bffe17 	ldw	r2,-8(fp)
811344b0:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
811344b4:	e0bffe17 	ldw	r2,-8(fp)
811344b8:	00c00fc4 	movi	r3,63
811344bc:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
811344c0:	e0bffe17 	ldw	r2,-8(fp)
811344c4:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
811344c8:	d0208e15 	stw	zero,-32200(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
811344cc:	00a045b4 	movhi	r2,33046
811344d0:	10940204 	addi	r2,r2,20488
811344d4:	d0a09315 	stw	r2,-32180(gp)
}
811344d8:	0001883a 	nop
811344dc:	e037883a 	mov	sp,fp
811344e0:	dfc00117 	ldw	ra,4(sp)
811344e4:	df000017 	ldw	fp,0(sp)
811344e8:	dec00204 	addi	sp,sp,8
811344ec:	f800283a 	ret

811344f0 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
811344f0:	defffd04 	addi	sp,sp,-12
811344f4:	de00012e 	bgeu	sp,et,811344fc <OS_MemClr+0xc>
811344f8:	003b68fa 	trap	3
811344fc:	df000215 	stw	fp,8(sp)
81134500:	df000204 	addi	fp,sp,8
81134504:	e13ffe15 	stw	r4,-8(fp)
81134508:	2805883a 	mov	r2,r5
8113450c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81134510:	00000706 	br	81134530 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81134514:	e0bffe17 	ldw	r2,-8(fp)
81134518:	10c00044 	addi	r3,r2,1
8113451c:	e0fffe15 	stw	r3,-8(fp)
81134520:	10000005 	stb	zero,0(r2)
        size--;
81134524:	e0bfff0b 	ldhu	r2,-4(fp)
81134528:	10bfffc4 	addi	r2,r2,-1
8113452c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
81134530:	e0bfff0b 	ldhu	r2,-4(fp)
81134534:	103ff71e 	bne	r2,zero,81134514 <__reset+0xfb114514>
        *pdest++ = (INT8U)0;
        size--;
    }
}
81134538:	0001883a 	nop
8113453c:	e037883a 	mov	sp,fp
81134540:	df000017 	ldw	fp,0(sp)
81134544:	dec00104 	addi	sp,sp,4
81134548:	f800283a 	ret

8113454c <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
8113454c:	defffc04 	addi	sp,sp,-16
81134550:	de00012e 	bgeu	sp,et,81134558 <OS_MemCopy+0xc>
81134554:	003b68fa 	trap	3
81134558:	df000315 	stw	fp,12(sp)
8113455c:	df000304 	addi	fp,sp,12
81134560:	e13ffd15 	stw	r4,-12(fp)
81134564:	e17ffe15 	stw	r5,-8(fp)
81134568:	3005883a 	mov	r2,r6
8113456c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81134570:	00000b06 	br	811345a0 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81134574:	e0bffd17 	ldw	r2,-12(fp)
81134578:	10c00044 	addi	r3,r2,1
8113457c:	e0fffd15 	stw	r3,-12(fp)
81134580:	e0fffe17 	ldw	r3,-8(fp)
81134584:	19000044 	addi	r4,r3,1
81134588:	e13ffe15 	stw	r4,-8(fp)
8113458c:	18c00003 	ldbu	r3,0(r3)
81134590:	10c00005 	stb	r3,0(r2)
        size--;
81134594:	e0bfff0b 	ldhu	r2,-4(fp)
81134598:	10bfffc4 	addi	r2,r2,-1
8113459c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
811345a0:	e0bfff0b 	ldhu	r2,-4(fp)
811345a4:	103ff31e 	bne	r2,zero,81134574 <__reset+0xfb114574>
        *pdest++ = *psrc++;
        size--;
    }
}
811345a8:	0001883a 	nop
811345ac:	e037883a 	mov	sp,fp
811345b0:	df000017 	ldw	fp,0(sp)
811345b4:	dec00104 	addi	sp,sp,4
811345b8:	f800283a 	ret

811345bc <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
811345bc:	defffb04 	addi	sp,sp,-20
811345c0:	de00012e 	bgeu	sp,et,811345c8 <OS_Sched+0xc>
811345c4:	003b68fa 	trap	3
811345c8:	dfc00415 	stw	ra,16(sp)
811345cc:	df000315 	stw	fp,12(sp)
811345d0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811345d4:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811345d8:	0005303a 	rdctl	r2,status
811345dc:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811345e0:	e0ffff17 	ldw	r3,-4(fp)
811345e4:	00bfff84 	movi	r2,-2
811345e8:	1884703a 	and	r2,r3,r2
811345ec:	1001703a 	wrctl	status,r2
  
  return context;
811345f0:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
811345f4:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
811345f8:	d0a09b03 	ldbu	r2,-32148(gp)
811345fc:	10803fcc 	andi	r2,r2,255
81134600:	10001a1e 	bne	r2,zero,8113466c <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81134604:	d0a08903 	ldbu	r2,-32220(gp)
81134608:	10803fcc 	andi	r2,r2,255
8113460c:	1000171e 	bne	r2,zero,8113466c <OS_Sched+0xb0>
            OS_SchedNew();
81134610:	11346940 	call	81134694 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81134614:	d0e08d83 	ldbu	r3,-32202(gp)
81134618:	d0a08dc3 	ldbu	r2,-32201(gp)
8113461c:	18c03fcc 	andi	r3,r3,255
81134620:	10803fcc 	andi	r2,r2,255
81134624:	18801126 	beq	r3,r2,8113466c <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
81134628:	d0a08d83 	ldbu	r2,-32202(gp)
8113462c:	10c03fcc 	andi	r3,r2,255
81134630:	00a045b4 	movhi	r2,33046
81134634:	10979804 	addi	r2,r2,24160
81134638:	18c7883a 	add	r3,r3,r3
8113463c:	18c7883a 	add	r3,r3,r3
81134640:	10c5883a 	add	r2,r2,r3
81134644:	10800017 	ldw	r2,0(r2)
81134648:	d0a09615 	stw	r2,-32168(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
8113464c:	d0a09617 	ldw	r2,-32168(gp)
81134650:	10c00e17 	ldw	r3,56(r2)
81134654:	18c00044 	addi	r3,r3,1
81134658:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
8113465c:	d0a09017 	ldw	r2,-32192(gp)
81134660:	10800044 	addi	r2,r2,1
81134664:	d0a09015 	stw	r2,-32192(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
81134668:	11454380 	call	81145438 <OSCtxSw>
8113466c:	e0bffd17 	ldw	r2,-12(fp)
81134670:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134674:	e0bffe17 	ldw	r2,-8(fp)
81134678:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
8113467c:	0001883a 	nop
81134680:	e037883a 	mov	sp,fp
81134684:	dfc00117 	ldw	ra,4(sp)
81134688:	df000017 	ldw	fp,0(sp)
8113468c:	dec00204 	addi	sp,sp,8
81134690:	f800283a 	ret

81134694 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81134694:	defffe04 	addi	sp,sp,-8
81134698:	de00012e 	bgeu	sp,et,811346a0 <OS_SchedNew+0xc>
8113469c:	003b68fa 	trap	3
811346a0:	df000115 	stw	fp,4(sp)
811346a4:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
811346a8:	d0a09803 	ldbu	r2,-32160(gp)
811346ac:	10c03fcc 	andi	r3,r2,255
811346b0:	00a04574 	movhi	r2,33045
811346b4:	10aad904 	addi	r2,r2,-21660
811346b8:	10c5883a 	add	r2,r2,r3
811346bc:	10800003 	ldbu	r2,0(r2)
811346c0:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
811346c4:	e0bfff03 	ldbu	r2,-4(fp)
811346c8:	100490fa 	slli	r2,r2,3
811346cc:	1009883a 	mov	r4,r2
811346d0:	e0ffff03 	ldbu	r3,-4(fp)
811346d4:	d0a09844 	addi	r2,gp,-32159
811346d8:	1885883a 	add	r2,r3,r2
811346dc:	10800003 	ldbu	r2,0(r2)
811346e0:	10c03fcc 	andi	r3,r2,255
811346e4:	00a04574 	movhi	r2,33045
811346e8:	10aad904 	addi	r2,r2,-21660
811346ec:	10c5883a 	add	r2,r2,r3
811346f0:	10800003 	ldbu	r2,0(r2)
811346f4:	2085883a 	add	r2,r4,r2
811346f8:	d0a08d85 	stb	r2,-32202(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
811346fc:	0001883a 	nop
81134700:	e037883a 	mov	sp,fp
81134704:	df000017 	ldw	fp,0(sp)
81134708:	dec00104 	addi	sp,sp,4
8113470c:	f800283a 	ret

81134710 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81134710:	defffc04 	addi	sp,sp,-16
81134714:	de00012e 	bgeu	sp,et,8113471c <OS_StrCopy+0xc>
81134718:	003b68fa 	trap	3
8113471c:	df000315 	stw	fp,12(sp)
81134720:	df000304 	addi	fp,sp,12
81134724:	e13ffe15 	stw	r4,-8(fp)
81134728:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
8113472c:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
81134730:	00000b06 	br	81134760 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81134734:	e0bffe17 	ldw	r2,-8(fp)
81134738:	10c00044 	addi	r3,r2,1
8113473c:	e0fffe15 	stw	r3,-8(fp)
81134740:	e0ffff17 	ldw	r3,-4(fp)
81134744:	19000044 	addi	r4,r3,1
81134748:	e13fff15 	stw	r4,-4(fp)
8113474c:	18c00003 	ldbu	r3,0(r3)
81134750:	10c00005 	stb	r3,0(r2)
        len++;
81134754:	e0bffd03 	ldbu	r2,-12(fp)
81134758:	10800044 	addi	r2,r2,1
8113475c:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81134760:	e0bfff17 	ldw	r2,-4(fp)
81134764:	10800003 	ldbu	r2,0(r2)
81134768:	10803fcc 	andi	r2,r2,255
8113476c:	103ff11e 	bne	r2,zero,81134734 <__reset+0xfb114734>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
81134770:	e0bffe17 	ldw	r2,-8(fp)
81134774:	10000005 	stb	zero,0(r2)
    return (len);
81134778:	e0bffd03 	ldbu	r2,-12(fp)
}
8113477c:	e037883a 	mov	sp,fp
81134780:	df000017 	ldw	fp,0(sp)
81134784:	dec00104 	addi	sp,sp,4
81134788:	f800283a 	ret

8113478c <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
8113478c:	defffd04 	addi	sp,sp,-12
81134790:	de00012e 	bgeu	sp,et,81134798 <OS_StrLen+0xc>
81134794:	003b68fa 	trap	3
81134798:	df000215 	stw	fp,8(sp)
8113479c:	df000204 	addi	fp,sp,8
811347a0:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
811347a4:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
811347a8:	00000606 	br	811347c4 <OS_StrLen+0x38>
        psrc++;
811347ac:	e0bfff17 	ldw	r2,-4(fp)
811347b0:	10800044 	addi	r2,r2,1
811347b4:	e0bfff15 	stw	r2,-4(fp)
        len++;
811347b8:	e0bffe03 	ldbu	r2,-8(fp)
811347bc:	10800044 	addi	r2,r2,1
811347c0:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
811347c4:	e0bfff17 	ldw	r2,-4(fp)
811347c8:	10800003 	ldbu	r2,0(r2)
811347cc:	10803fcc 	andi	r2,r2,255
811347d0:	103ff61e 	bne	r2,zero,811347ac <__reset+0xfb1147ac>
        psrc++;
        len++;
    }
    return (len);
811347d4:	e0bffe03 	ldbu	r2,-8(fp)
}
811347d8:	e037883a 	mov	sp,fp
811347dc:	df000017 	ldw	fp,0(sp)
811347e0:	dec00104 	addi	sp,sp,4
811347e4:	f800283a 	ret

811347e8 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
811347e8:	defffa04 	addi	sp,sp,-24
811347ec:	de00012e 	bgeu	sp,et,811347f4 <OS_TaskIdle+0xc>
811347f0:	003b68fa 	trap	3
811347f4:	dfc00515 	stw	ra,20(sp)
811347f8:	df000415 	stw	fp,16(sp)
811347fc:	df000404 	addi	fp,sp,16
81134800:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134804:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134808:	0005303a 	rdctl	r2,status
8113480c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134810:	e0fffd17 	ldw	r3,-12(fp)
81134814:	00bfff84 	movi	r2,-2
81134818:	1884703a 	and	r2,r3,r2
8113481c:	1001703a 	wrctl	status,r2
  
  return context;
81134820:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81134824:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81134828:	d0a08c17 	ldw	r2,-32208(gp)
8113482c:	10800044 	addi	r2,r2,1
81134830:	d0a08c15 	stw	r2,-32208(gp)
81134834:	e0bffc17 	ldw	r2,-16(fp)
81134838:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113483c:	e0bffe17 	ldw	r2,-8(fp)
81134840:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81134844:	11457cc0 	call	811457cc <OSTaskIdleHook>
    }
81134848:	003fef06 	br	81134808 <__reset+0xfb114808>

8113484c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
8113484c:	defff804 	addi	sp,sp,-32
81134850:	de00012e 	bgeu	sp,et,81134858 <OS_TaskStat+0xc>
81134854:	003b68fa 	trap	3
81134858:	dfc00715 	stw	ra,28(sp)
8113485c:	df000615 	stw	fp,24(sp)
81134860:	dc400515 	stw	r17,20(sp)
81134864:	dc000415 	stw	r16,16(sp)
81134868:	df000604 	addi	fp,sp,24
8113486c:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134870:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81134874:	00000206 	br	81134880 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81134878:	01003204 	movi	r4,200
8113487c:	113b1440 	call	8113b144 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81134880:	d0a0a103 	ldbu	r2,-32124(gp)
81134884:	10803fcc 	andi	r2,r2,255
81134888:	103ffb26 	beq	r2,zero,81134878 <__reset+0xfb114878>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
8113488c:	d0e09217 	ldw	r3,-32184(gp)
81134890:	00947b34 	movhi	r2,20972
81134894:	10a147c4 	addi	r2,r2,-31457
81134898:	1888383a 	mulxuu	r4,r3,r2
8113489c:	1885383a 	mul	r2,r3,r2
811348a0:	1021883a 	mov	r16,r2
811348a4:	2023883a 	mov	r17,r4
811348a8:	8804d17a 	srli	r2,r17,5
811348ac:	d0a09215 	stw	r2,-32184(gp)
    if (OSIdleCtrMax == 0L) {
811348b0:	d0a09217 	ldw	r2,-32184(gp)
811348b4:	1000031e 	bne	r2,zero,811348c4 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
811348b8:	d0209405 	stb	zero,-32176(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
811348bc:	01003fc4 	movi	r4,255
811348c0:	113adb40 	call	8113adb4 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811348c4:	0005303a 	rdctl	r2,status
811348c8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811348cc:	e0fffb17 	ldw	r3,-20(fp)
811348d0:	00bfff84 	movi	r2,-2
811348d4:	1884703a 	and	r2,r3,r2
811348d8:	1001703a 	wrctl	status,r2
  
  return context;
811348dc:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
811348e0:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
811348e4:	d0a08c17 	ldw	r2,-32208(gp)
811348e8:	d0a0a215 	stw	r2,-32120(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
811348ec:	d0208c15 	stw	zero,-32208(gp)
811348f0:	e0bffa17 	ldw	r2,-24(fp)
811348f4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811348f8:	e0bffc17 	ldw	r2,-16(fp)
811348fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81134900:	d0e0a217 	ldw	r3,-32120(gp)
81134904:	d0a09217 	ldw	r2,-32184(gp)
81134908:	1885203a 	divu	r2,r3,r2
8113490c:	1007883a 	mov	r3,r2
81134910:	00801904 	movi	r2,100
81134914:	10c5c83a 	sub	r2,r2,r3
81134918:	d0a09405 	stb	r2,-32176(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
8113491c:	11456fc0 	call	811456fc <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81134920:	11349300 	call	81134930 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81134924:	01001904 	movi	r4,100
81134928:	113b1440 	call	8113b144 <OSTimeDly>
    }
8113492c:	003fe506 	br	811348c4 <__reset+0xfb1148c4>

81134930 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81134930:	defffa04 	addi	sp,sp,-24
81134934:	de00012e 	bgeu	sp,et,8113493c <OS_TaskStatStkChk+0xc>
81134938:	003b68fa 	trap	3
8113493c:	dfc00515 	stw	ra,20(sp)
81134940:	df000415 	stw	fp,16(sp)
81134944:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81134948:	e03ffc05 	stb	zero,-16(fp)
8113494c:	00002406 	br	811349e0 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
81134950:	e0bffc03 	ldbu	r2,-16(fp)
81134954:	e0fffe04 	addi	r3,fp,-8
81134958:	180b883a 	mov	r5,r3
8113495c:	1009883a 	mov	r4,r2
81134960:	113abec0 	call	8113abec <OSTaskStkChk>
81134964:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
81134968:	e0bffc43 	ldbu	r2,-15(fp)
8113496c:	1000191e 	bne	r2,zero,811349d4 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
81134970:	e0fffc03 	ldbu	r3,-16(fp)
81134974:	00a045b4 	movhi	r2,33046
81134978:	10979804 	addi	r2,r2,24160
8113497c:	18c7883a 	add	r3,r3,r3
81134980:	18c7883a 	add	r3,r3,r3
81134984:	10c5883a 	add	r2,r2,r3
81134988:	10800017 	ldw	r2,0(r2)
8113498c:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
81134990:	e0bffd17 	ldw	r2,-12(fp)
81134994:	10000f26 	beq	r2,zero,811349d4 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81134998:	e0bffd17 	ldw	r2,-12(fp)
8113499c:	10800060 	cmpeqi	r2,r2,1
811349a0:	10000c1e 	bne	r2,zero,811349d4 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
811349a4:	e0bffd17 	ldw	r2,-12(fp)
811349a8:	10c00217 	ldw	r3,8(r2)
811349ac:	e0bffd17 	ldw	r2,-12(fp)
811349b0:	10800317 	ldw	r2,12(r2)
811349b4:	1085883a 	add	r2,r2,r2
811349b8:	1085883a 	add	r2,r2,r2
811349bc:	1887883a 	add	r3,r3,r2
811349c0:	e0bffd17 	ldw	r2,-12(fp)
811349c4:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
811349c8:	e0ffff17 	ldw	r3,-4(fp)
811349cc:	e0bffd17 	ldw	r2,-12(fp)
811349d0:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
811349d4:	e0bffc03 	ldbu	r2,-16(fp)
811349d8:	10800044 	addi	r2,r2,1
811349dc:	e0bffc05 	stb	r2,-16(fp)
811349e0:	e0bffc03 	ldbu	r2,-16(fp)
811349e4:	10800a70 	cmpltui	r2,r2,41
811349e8:	103fd91e 	bne	r2,zero,81134950 <__reset+0xfb114950>
#endif
                }
            }
        }
    }
}
811349ec:	0001883a 	nop
811349f0:	e037883a 	mov	sp,fp
811349f4:	dfc00117 	ldw	ra,4(sp)
811349f8:	df000017 	ldw	fp,0(sp)
811349fc:	dec00204 	addi	sp,sp,8
81134a00:	f800283a 	ret

81134a04 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
81134a04:	defff204 	addi	sp,sp,-56
81134a08:	de00012e 	bgeu	sp,et,81134a10 <OS_TCBInit+0xc>
81134a0c:	003b68fa 	trap	3
81134a10:	dfc00d15 	stw	ra,52(sp)
81134a14:	df000c15 	stw	fp,48(sp)
81134a18:	df000c04 	addi	fp,sp,48
81134a1c:	e17ffc15 	stw	r5,-16(fp)
81134a20:	e1bffd15 	stw	r6,-12(fp)
81134a24:	3807883a 	mov	r3,r7
81134a28:	e0800417 	ldw	r2,16(fp)
81134a2c:	e13ffb05 	stb	r4,-20(fp)
81134a30:	e0fffe0d 	sth	r3,-8(fp)
81134a34:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81134a38:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134a3c:	0005303a 	rdctl	r2,status
81134a40:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134a44:	e0fffa17 	ldw	r3,-24(fp)
81134a48:	00bfff84 	movi	r2,-2
81134a4c:	1884703a 	and	r2,r3,r2
81134a50:	1001703a 	wrctl	status,r2
  
  return context;
81134a54:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
81134a58:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
81134a5c:	d0a09317 	ldw	r2,-32180(gp)
81134a60:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
81134a64:	e0bff617 	ldw	r2,-40(fp)
81134a68:	10009326 	beq	r2,zero,81134cb8 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
81134a6c:	e0bff617 	ldw	r2,-40(fp)
81134a70:	10800517 	ldw	r2,20(r2)
81134a74:	d0a09315 	stw	r2,-32180(gp)
81134a78:	e0bff417 	ldw	r2,-48(fp)
81134a7c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134a80:	e0bff817 	ldw	r2,-32(fp)
81134a84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81134a88:	e0bff617 	ldw	r2,-40(fp)
81134a8c:	e0fffc17 	ldw	r3,-16(fp)
81134a90:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
81134a94:	e0bff617 	ldw	r2,-40(fp)
81134a98:	e0fffb03 	ldbu	r3,-20(fp)
81134a9c:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
81134aa0:	e0bff617 	ldw	r2,-40(fp)
81134aa4:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81134aa8:	e0bff617 	ldw	r2,-40(fp)
81134aac:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
81134ab0:	e0bff617 	ldw	r2,-40(fp)
81134ab4:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81134ab8:	e0bff617 	ldw	r2,-40(fp)
81134abc:	e0c00317 	ldw	r3,12(fp)
81134ac0:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
81134ac4:	e0bff617 	ldw	r2,-40(fp)
81134ac8:	e0c00217 	ldw	r3,8(fp)
81134acc:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
81134ad0:	e0bff617 	ldw	r2,-40(fp)
81134ad4:	e0fffd17 	ldw	r3,-12(fp)
81134ad8:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81134adc:	e0bff617 	ldw	r2,-40(fp)
81134ae0:	e0ffff0b 	ldhu	r3,-4(fp)
81134ae4:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81134ae8:	e0bff617 	ldw	r2,-40(fp)
81134aec:	e0fffe0b 	ldhu	r3,-8(fp)
81134af0:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
81134af4:	e0bff617 	ldw	r2,-40(fp)
81134af8:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81134afc:	e0bffb03 	ldbu	r2,-20(fp)
81134b00:	1004d0fa 	srli	r2,r2,3
81134b04:	1007883a 	mov	r3,r2
81134b08:	e0bff617 	ldw	r2,-40(fp)
81134b0c:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
81134b10:	e0bffb03 	ldbu	r2,-20(fp)
81134b14:	108001cc 	andi	r2,r2,7
81134b18:	1007883a 	mov	r3,r2
81134b1c:	e0bff617 	ldw	r2,-40(fp)
81134b20:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
81134b24:	e0bff617 	ldw	r2,-40(fp)
81134b28:	10800d03 	ldbu	r2,52(r2)
81134b2c:	10803fcc 	andi	r2,r2,255
81134b30:	00c00044 	movi	r3,1
81134b34:	1884983a 	sll	r2,r3,r2
81134b38:	1007883a 	mov	r3,r2
81134b3c:	e0bff617 	ldw	r2,-40(fp)
81134b40:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
81134b44:	e0bff617 	ldw	r2,-40(fp)
81134b48:	10800cc3 	ldbu	r2,51(r2)
81134b4c:	10803fcc 	andi	r2,r2,255
81134b50:	00c00044 	movi	r3,1
81134b54:	1884983a 	sll	r2,r3,r2
81134b58:	1007883a 	mov	r3,r2
81134b5c:	e0bff617 	ldw	r2,-40(fp)
81134b60:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
81134b64:	e0bff617 	ldw	r2,-40(fp)
81134b68:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
81134b6c:	e0bff617 	ldw	r2,-40(fp)
81134b70:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81134b74:	e0bff617 	ldw	r2,-40(fp)
81134b78:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81134b7c:	e0bff617 	ldw	r2,-40(fp)
81134b80:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81134b84:	e0bff617 	ldw	r2,-40(fp)
81134b88:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81134b8c:	e0bff617 	ldw	r2,-40(fp)
81134b90:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
81134b94:	e0bff617 	ldw	r2,-40(fp)
81134b98:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81134b9c:	e0bff617 	ldw	r2,-40(fp)
81134ba0:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
81134ba4:	e0bff617 	ldw	r2,-40(fp)
81134ba8:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81134bac:	e0bff617 	ldw	r2,-40(fp)
81134bb0:	00c00fc4 	movi	r3,63
81134bb4:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81134bb8:	e0bff617 	ldw	r2,-40(fp)
81134bbc:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
81134bc0:	e13ff617 	ldw	r4,-40(fp)
81134bc4:	11457f40 	call	811457f4 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81134bc8:	e13ff617 	ldw	r4,-40(fp)
81134bcc:	114567c0 	call	8114567c <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134bd0:	0005303a 	rdctl	r2,status
81134bd4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134bd8:	e0fff517 	ldw	r3,-44(fp)
81134bdc:	00bfff84 	movi	r2,-2
81134be0:	1884703a 	and	r2,r3,r2
81134be4:	1001703a 	wrctl	status,r2
  
  return context;
81134be8:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81134bec:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
81134bf0:	e0fffb03 	ldbu	r3,-20(fp)
81134bf4:	00a045b4 	movhi	r2,33046
81134bf8:	10979804 	addi	r2,r2,24160
81134bfc:	18c7883a 	add	r3,r3,r3
81134c00:	18c7883a 	add	r3,r3,r3
81134c04:	10c5883a 	add	r2,r2,r3
81134c08:	e0fff617 	ldw	r3,-40(fp)
81134c0c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
81134c10:	d0e08e17 	ldw	r3,-32200(gp)
81134c14:	e0bff617 	ldw	r2,-40(fp)
81134c18:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
81134c1c:	e0bff617 	ldw	r2,-40(fp)
81134c20:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
81134c24:	d0a08e17 	ldw	r2,-32200(gp)
81134c28:	10000326 	beq	r2,zero,81134c38 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
81134c2c:	d0a08e17 	ldw	r2,-32200(gp)
81134c30:	e0fff617 	ldw	r3,-40(fp)
81134c34:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
81134c38:	e0bff617 	ldw	r2,-40(fp)
81134c3c:	d0a08e15 	stw	r2,-32200(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
81134c40:	e0bff617 	ldw	r2,-40(fp)
81134c44:	10c00d83 	ldbu	r3,54(r2)
81134c48:	d0a09803 	ldbu	r2,-32160(gp)
81134c4c:	1884b03a 	or	r2,r3,r2
81134c50:	d0a09805 	stb	r2,-32160(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81134c54:	e0bff617 	ldw	r2,-40(fp)
81134c58:	10800d03 	ldbu	r2,52(r2)
81134c5c:	10c03fcc 	andi	r3,r2,255
81134c60:	e0bff617 	ldw	r2,-40(fp)
81134c64:	10800d03 	ldbu	r2,52(r2)
81134c68:	11003fcc 	andi	r4,r2,255
81134c6c:	d0a09844 	addi	r2,gp,-32159
81134c70:	2085883a 	add	r2,r4,r2
81134c74:	11000003 	ldbu	r4,0(r2)
81134c78:	e0bff617 	ldw	r2,-40(fp)
81134c7c:	10800d43 	ldbu	r2,53(r2)
81134c80:	2084b03a 	or	r2,r4,r2
81134c84:	1009883a 	mov	r4,r2
81134c88:	d0a09844 	addi	r2,gp,-32159
81134c8c:	1885883a 	add	r2,r3,r2
81134c90:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
81134c94:	d0a09443 	ldbu	r2,-32175(gp)
81134c98:	10800044 	addi	r2,r2,1
81134c9c:	d0a09445 	stb	r2,-32175(gp)
81134ca0:	e0bff417 	ldw	r2,-48(fp)
81134ca4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134ca8:	e0bff717 	ldw	r2,-36(fp)
81134cac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81134cb0:	0005883a 	mov	r2,zero
81134cb4:	00000506 	br	81134ccc <OS_TCBInit+0x2c8>
81134cb8:	e0bff417 	ldw	r2,-48(fp)
81134cbc:	e0bff915 	stw	r2,-28(fp)
81134cc0:	e0bff917 	ldw	r2,-28(fp)
81134cc4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81134cc8:	00801084 	movi	r2,66
}
81134ccc:	e037883a 	mov	sp,fp
81134cd0:	dfc00117 	ldw	ra,4(sp)
81134cd4:	df000017 	ldw	fp,0(sp)
81134cd8:	dec00204 	addi	sp,sp,8
81134cdc:	f800283a 	ret

81134ce0 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
81134ce0:	defffe04 	addi	sp,sp,-8
81134ce4:	de00012e 	bgeu	sp,et,81134cec <OSDebugInit+0xc>
81134ce8:	003b68fa 	trap	3
81134cec:	df000115 	stw	fp,4(sp)
81134cf0:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
81134cf4:	d0a01804 	addi	r2,gp,-32672
81134cf8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
81134cfc:	d0a01904 	addi	r2,gp,-32668
81134d00:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
81134d04:	d0a01a84 	addi	r2,gp,-32662
81134d08:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
81134d0c:	d0a01b04 	addi	r2,gp,-32660
81134d10:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
81134d14:	d0a01a04 	addi	r2,gp,-32664
81134d18:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
81134d1c:	d0a01b84 	addi	r2,gp,-32658
81134d20:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
81134d24:	d0a01c04 	addi	r2,gp,-32656
81134d28:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
81134d2c:	d0a01c84 	addi	r2,gp,-32654
81134d30:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
81134d34:	d0a01d04 	addi	r2,gp,-32652
81134d38:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
81134d3c:	d0a01d84 	addi	r2,gp,-32650
81134d40:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
81134d44:	d0a01e04 	addi	r2,gp,-32648
81134d48:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
81134d4c:	d0a01e84 	addi	r2,gp,-32646
81134d50:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
81134d54:	d0a01f04 	addi	r2,gp,-32644
81134d58:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
81134d5c:	d0a01f84 	addi	r2,gp,-32642
81134d60:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
81134d64:	d0a02004 	addi	r2,gp,-32640
81134d68:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
81134d6c:	d0a02084 	addi	r2,gp,-32638
81134d70:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
81134d74:	d0a02104 	addi	r2,gp,-32636
81134d78:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
81134d7c:	d0a02184 	addi	r2,gp,-32634
81134d80:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
81134d84:	d0a02204 	addi	r2,gp,-32632
81134d88:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
81134d8c:	d0a02284 	addi	r2,gp,-32630
81134d90:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
81134d94:	d0a02304 	addi	r2,gp,-32628
81134d98:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
81134d9c:	d0a02384 	addi	r2,gp,-32626
81134da0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
81134da4:	d0a02404 	addi	r2,gp,-32624
81134da8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
81134dac:	d0a02484 	addi	r2,gp,-32622
81134db0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
81134db4:	d0a02504 	addi	r2,gp,-32620
81134db8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
81134dbc:	d0a02584 	addi	r2,gp,-32618
81134dc0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
81134dc4:	d0a02604 	addi	r2,gp,-32616
81134dc8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
81134dcc:	d0a02684 	addi	r2,gp,-32614
81134dd0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
81134dd4:	d0a02704 	addi	r2,gp,-32612
81134dd8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
81134ddc:	d0a02784 	addi	r2,gp,-32610
81134de0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
81134de4:	d0a02804 	addi	r2,gp,-32608
81134de8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
81134dec:	d0a02884 	addi	r2,gp,-32606
81134df0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
81134df4:	d0a02904 	addi	r2,gp,-32604
81134df8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
81134dfc:	d0a02984 	addi	r2,gp,-32602
81134e00:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
81134e04:	d0a02a04 	addi	r2,gp,-32600
81134e08:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
81134e0c:	d0a02a84 	addi	r2,gp,-32598
81134e10:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
81134e14:	d0a02b04 	addi	r2,gp,-32596
81134e18:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
81134e1c:	d0a02b84 	addi	r2,gp,-32594
81134e20:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
81134e24:	d0a02c04 	addi	r2,gp,-32592
81134e28:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
81134e2c:	d0a02c84 	addi	r2,gp,-32590
81134e30:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
81134e34:	d0a02d04 	addi	r2,gp,-32588
81134e38:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
81134e3c:	d0a02d84 	addi	r2,gp,-32586
81134e40:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
81134e44:	d0a02e04 	addi	r2,gp,-32584
81134e48:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
81134e4c:	d0a02e84 	addi	r2,gp,-32582
81134e50:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
81134e54:	00a045b4 	movhi	r2,33046
81134e58:	1082ee04 	addi	r2,r2,3000
81134e5c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
81134e60:	00a045b4 	movhi	r2,33046
81134e64:	10818a04 	addi	r2,r2,1576
81134e68:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
81134e6c:	d0a02f84 	addi	r2,gp,-32578
81134e70:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
81134e74:	d0a03004 	addi	r2,gp,-32576
81134e78:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
81134e7c:	d0a03084 	addi	r2,gp,-32574
81134e80:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
81134e84:	d0a03104 	addi	r2,gp,-32572
81134e88:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
81134e8c:	d0a03184 	addi	r2,gp,-32570
81134e90:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
81134e94:	d0a03204 	addi	r2,gp,-32568
81134e98:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
81134e9c:	d0a03284 	addi	r2,gp,-32566
81134ea0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
81134ea4:	d0a03304 	addi	r2,gp,-32564
81134ea8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
81134eac:	d0a03384 	addi	r2,gp,-32562
81134eb0:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
81134eb4:	d0a02f04 	addi	r2,gp,-32580
81134eb8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
81134ebc:	d0a03404 	addi	r2,gp,-32560
81134ec0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
81134ec4:	0001883a 	nop
81134ec8:	e037883a 	mov	sp,fp
81134ecc:	df000017 	ldw	fp,0(sp)
81134ed0:	dec00104 	addi	sp,sp,4
81134ed4:	f800283a 	ret

81134ed8 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
81134ed8:	defff204 	addi	sp,sp,-56
81134edc:	de00012e 	bgeu	sp,et,81134ee4 <OSFlagAccept+0xc>
81134ee0:	003b68fa 	trap	3
81134ee4:	df000d15 	stw	fp,52(sp)
81134ee8:	df000d04 	addi	fp,sp,52
81134eec:	e13ffc15 	stw	r4,-16(fp)
81134ef0:	2807883a 	mov	r3,r5
81134ef4:	3005883a 	mov	r2,r6
81134ef8:	e1ffff15 	stw	r7,-4(fp)
81134efc:	e0fffd0d 	sth	r3,-12(fp)
81134f00:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81134f04:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81134f08:	e0bfff17 	ldw	r2,-4(fp)
81134f0c:	1000021e 	bne	r2,zero,81134f18 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
81134f10:	0005883a 	mov	r2,zero
81134f14:	0000b006 	br	811351d8 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81134f18:	e0bffc17 	ldw	r2,-16(fp)
81134f1c:	1000051e 	bne	r2,zero,81134f34 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81134f20:	e0bfff17 	ldw	r2,-4(fp)
81134f24:	00c01b84 	movi	r3,110
81134f28:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81134f2c:	0005883a 	mov	r2,zero
81134f30:	0000a906 	br	811351d8 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81134f34:	e0bffc17 	ldw	r2,-16(fp)
81134f38:	10800003 	ldbu	r2,0(r2)
81134f3c:	10803fcc 	andi	r2,r2,255
81134f40:	10800160 	cmpeqi	r2,r2,5
81134f44:	1000051e 	bne	r2,zero,81134f5c <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
81134f48:	e0bfff17 	ldw	r2,-4(fp)
81134f4c:	00c00044 	movi	r3,1
81134f50:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81134f54:	0005883a 	mov	r2,zero
81134f58:	00009f06 	br	811351d8 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81134f5c:	e0fffe03 	ldbu	r3,-8(fp)
81134f60:	00bfe004 	movi	r2,-128
81134f64:	1884703a 	and	r2,r3,r2
81134f68:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
81134f6c:	e0bff503 	ldbu	r2,-44(fp)
81134f70:	10000626 	beq	r2,zero,81134f8c <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
81134f74:	e0bffe03 	ldbu	r2,-8(fp)
81134f78:	10801fcc 	andi	r2,r2,127
81134f7c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81134f80:	00800044 	movi	r2,1
81134f84:	e0bff385 	stb	r2,-50(fp)
81134f88:	00000106 	br	81134f90 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
81134f8c:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
81134f90:	e0bfff17 	ldw	r2,-4(fp)
81134f94:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134f98:	0005303a 	rdctl	r2,status
81134f9c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134fa0:	e0fffb17 	ldw	r3,-20(fp)
81134fa4:	00bfff84 	movi	r2,-2
81134fa8:	1884703a 	and	r2,r3,r2
81134fac:	1001703a 	wrctl	status,r2
  
  return context;
81134fb0:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
81134fb4:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
81134fb8:	e0bffe03 	ldbu	r2,-8(fp)
81134fbc:	10c00060 	cmpeqi	r3,r2,1
81134fc0:	18005f1e 	bne	r3,zero,81135140 <OSFlagAccept+0x268>
81134fc4:	10c00088 	cmpgei	r3,r2,2
81134fc8:	1800021e 	bne	r3,zero,81134fd4 <OSFlagAccept+0xfc>
81134fcc:	10003f26 	beq	r2,zero,811350cc <OSFlagAccept+0x1f4>
81134fd0:	00007706 	br	811351b0 <OSFlagAccept+0x2d8>
81134fd4:	10c000a0 	cmpeqi	r3,r2,2
81134fd8:	1800031e 	bne	r3,zero,81134fe8 <OSFlagAccept+0x110>
81134fdc:	108000e0 	cmpeqi	r2,r2,3
81134fe0:	10001e1e 	bne	r2,zero,8113505c <OSFlagAccept+0x184>
81134fe4:	00007206 	br	811351b0 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81134fe8:	e0bffc17 	ldw	r2,-16(fp)
81134fec:	10c0020b 	ldhu	r3,8(r2)
81134ff0:	e0bffd0b 	ldhu	r2,-12(fp)
81134ff4:	1884703a 	and	r2,r3,r2
81134ff8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81134ffc:	e0fff30b 	ldhu	r3,-52(fp)
81135000:	e0bffd0b 	ldhu	r2,-12(fp)
81135004:	18800d1e 	bne	r3,r2,8113503c <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135008:	e0bff383 	ldbu	r2,-50(fp)
8113500c:	10800058 	cmpnei	r2,r2,1
81135010:	10000d1e 	bne	r2,zero,81135048 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81135014:	e0bffc17 	ldw	r2,-16(fp)
81135018:	1080020b 	ldhu	r2,8(r2)
8113501c:	1007883a 	mov	r3,r2
81135020:	e0bff30b 	ldhu	r2,-52(fp)
81135024:	0084303a 	nor	r2,zero,r2
81135028:	1884703a 	and	r2,r3,r2
8113502c:	1007883a 	mov	r3,r2
81135030:	e0bffc17 	ldw	r2,-16(fp)
81135034:	10c0020d 	sth	r3,8(r2)
81135038:	00000306 	br	81135048 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113503c:	e0bfff17 	ldw	r2,-4(fp)
81135040:	00c01c04 	movi	r3,112
81135044:	10c00005 	stb	r3,0(r2)
81135048:	e0bff417 	ldw	r2,-48(fp)
8113504c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135050:	e0bff617 	ldw	r2,-40(fp)
81135054:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81135058:	00005e06 	br	811351d4 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113505c:	e0bffc17 	ldw	r2,-16(fp)
81135060:	10c0020b 	ldhu	r3,8(r2)
81135064:	e0bffd0b 	ldhu	r2,-12(fp)
81135068:	1884703a 	and	r2,r3,r2
8113506c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81135070:	e0bff30b 	ldhu	r2,-52(fp)
81135074:	10000d26 	beq	r2,zero,811350ac <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135078:	e0bff383 	ldbu	r2,-50(fp)
8113507c:	10800058 	cmpnei	r2,r2,1
81135080:	10000d1e 	bne	r2,zero,811350b8 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81135084:	e0bffc17 	ldw	r2,-16(fp)
81135088:	1080020b 	ldhu	r2,8(r2)
8113508c:	1007883a 	mov	r3,r2
81135090:	e0bff30b 	ldhu	r2,-52(fp)
81135094:	0084303a 	nor	r2,zero,r2
81135098:	1884703a 	and	r2,r3,r2
8113509c:	1007883a 	mov	r3,r2
811350a0:	e0bffc17 	ldw	r2,-16(fp)
811350a4:	10c0020d 	sth	r3,8(r2)
811350a8:	00000306 	br	811350b8 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811350ac:	e0bfff17 	ldw	r2,-4(fp)
811350b0:	00c01c04 	movi	r3,112
811350b4:	10c00005 	stb	r3,0(r2)
811350b8:	e0bff417 	ldw	r2,-48(fp)
811350bc:	e0bff715 	stw	r2,-36(fp)
811350c0:	e0bff717 	ldw	r2,-36(fp)
811350c4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811350c8:	00004206 	br	811351d4 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
811350cc:	e0bffc17 	ldw	r2,-16(fp)
811350d0:	1080020b 	ldhu	r2,8(r2)
811350d4:	0084303a 	nor	r2,zero,r2
811350d8:	1007883a 	mov	r3,r2
811350dc:	e0bffd0b 	ldhu	r2,-12(fp)
811350e0:	1884703a 	and	r2,r3,r2
811350e4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
811350e8:	e0fff30b 	ldhu	r3,-52(fp)
811350ec:	e0bffd0b 	ldhu	r2,-12(fp)
811350f0:	18800b1e 	bne	r3,r2,81135120 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811350f4:	e0bff383 	ldbu	r2,-50(fp)
811350f8:	10800058 	cmpnei	r2,r2,1
811350fc:	10000b1e 	bne	r2,zero,8113512c <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81135100:	e0bffc17 	ldw	r2,-16(fp)
81135104:	10c0020b 	ldhu	r3,8(r2)
81135108:	e0bff30b 	ldhu	r2,-52(fp)
8113510c:	1884b03a 	or	r2,r3,r2
81135110:	1007883a 	mov	r3,r2
81135114:	e0bffc17 	ldw	r2,-16(fp)
81135118:	10c0020d 	sth	r3,8(r2)
8113511c:	00000306 	br	8113512c <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81135120:	e0bfff17 	ldw	r2,-4(fp)
81135124:	00c01c04 	movi	r3,112
81135128:	10c00005 	stb	r3,0(r2)
8113512c:	e0bff417 	ldw	r2,-48(fp)
81135130:	e0bff815 	stw	r2,-32(fp)
81135134:	e0bff817 	ldw	r2,-32(fp)
81135138:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113513c:	00002506 	br	811351d4 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
81135140:	e0bffc17 	ldw	r2,-16(fp)
81135144:	1080020b 	ldhu	r2,8(r2)
81135148:	0084303a 	nor	r2,zero,r2
8113514c:	1007883a 	mov	r3,r2
81135150:	e0bffd0b 	ldhu	r2,-12(fp)
81135154:	1884703a 	and	r2,r3,r2
81135158:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113515c:	e0bff30b 	ldhu	r2,-52(fp)
81135160:	10000b26 	beq	r2,zero,81135190 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135164:	e0bff383 	ldbu	r2,-50(fp)
81135168:	10800058 	cmpnei	r2,r2,1
8113516c:	10000b1e 	bne	r2,zero,8113519c <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
81135170:	e0bffc17 	ldw	r2,-16(fp)
81135174:	10c0020b 	ldhu	r3,8(r2)
81135178:	e0bff30b 	ldhu	r2,-52(fp)
8113517c:	1884b03a 	or	r2,r3,r2
81135180:	1007883a 	mov	r3,r2
81135184:	e0bffc17 	ldw	r2,-16(fp)
81135188:	10c0020d 	sth	r3,8(r2)
8113518c:	00000306 	br	8113519c <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81135190:	e0bfff17 	ldw	r2,-4(fp)
81135194:	00c01c04 	movi	r3,112
81135198:	10c00005 	stb	r3,0(r2)
8113519c:	e0bff417 	ldw	r2,-48(fp)
811351a0:	e0bff915 	stw	r2,-28(fp)
811351a4:	e0bff917 	ldw	r2,-28(fp)
811351a8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811351ac:	00000906 	br	811351d4 <OSFlagAccept+0x2fc>
811351b0:	e0bff417 	ldw	r2,-48(fp)
811351b4:	e0bffa15 	stw	r2,-24(fp)
811351b8:	e0bffa17 	ldw	r2,-24(fp)
811351bc:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
811351c0:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
811351c4:	e0bfff17 	ldw	r2,-4(fp)
811351c8:	00c01bc4 	movi	r3,111
811351cc:	10c00005 	stb	r3,0(r2)
             break;
811351d0:	0001883a 	nop
    }
    return (flags_rdy);
811351d4:	e0bff30b 	ldhu	r2,-52(fp)
}
811351d8:	e037883a 	mov	sp,fp
811351dc:	df000017 	ldw	fp,0(sp)
811351e0:	dec00104 	addi	sp,sp,4
811351e4:	f800283a 	ret

811351e8 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
811351e8:	defff804 	addi	sp,sp,-32
811351ec:	de00012e 	bgeu	sp,et,811351f4 <OSFlagCreate+0xc>
811351f0:	003b68fa 	trap	3
811351f4:	df000715 	stw	fp,28(sp)
811351f8:	df000704 	addi	fp,sp,28
811351fc:	2005883a 	mov	r2,r4
81135200:	e17fff15 	stw	r5,-4(fp)
81135204:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
81135208:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8113520c:	e0bfff17 	ldw	r2,-4(fp)
81135210:	1000021e 	bne	r2,zero,8113521c <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
81135214:	0005883a 	mov	r2,zero
81135218:	00003306 	br	811352e8 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8113521c:	d0a09b03 	ldbu	r2,-32148(gp)
81135220:	10803fcc 	andi	r2,r2,255
81135224:	10000526 	beq	r2,zero,8113523c <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
81135228:	e0bfff17 	ldw	r2,-4(fp)
8113522c:	00c00404 	movi	r3,16
81135230:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
81135234:	0005883a 	mov	r2,zero
81135238:	00002b06 	br	811352e8 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113523c:	0005303a 	rdctl	r2,status
81135240:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135244:	e0fffd17 	ldw	r3,-12(fp)
81135248:	00bfff84 	movi	r2,-2
8113524c:	1884703a 	and	r2,r3,r2
81135250:	1001703a 	wrctl	status,r2
  
  return context;
81135254:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81135258:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8113525c:	d0a0a017 	ldw	r2,-32128(gp)
81135260:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
81135264:	e0bffb17 	ldw	r2,-20(fp)
81135268:	10001726 	beq	r2,zero,811352c8 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8113526c:	d0a0a017 	ldw	r2,-32128(gp)
81135270:	10800117 	ldw	r2,4(r2)
81135274:	d0a0a015 	stw	r2,-32128(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
81135278:	e0bffb17 	ldw	r2,-20(fp)
8113527c:	00c00144 	movi	r3,5
81135280:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
81135284:	e0bffb17 	ldw	r2,-20(fp)
81135288:	e0fffe0b 	ldhu	r3,-8(fp)
8113528c:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
81135290:	e0bffb17 	ldw	r2,-20(fp)
81135294:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
81135298:	e0bffb17 	ldw	r2,-20(fp)
8113529c:	00c00fc4 	movi	r3,63
811352a0:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
811352a4:	e0bffb17 	ldw	r2,-20(fp)
811352a8:	100002c5 	stb	zero,11(r2)
811352ac:	e0bff917 	ldw	r2,-28(fp)
811352b0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811352b4:	e0bffa17 	ldw	r2,-24(fp)
811352b8:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
811352bc:	e0bfff17 	ldw	r2,-4(fp)
811352c0:	10000005 	stb	zero,0(r2)
811352c4:	00000706 	br	811352e4 <OSFlagCreate+0xfc>
811352c8:	e0bff917 	ldw	r2,-28(fp)
811352cc:	e0bffc15 	stw	r2,-16(fp)
811352d0:	e0bffc17 	ldw	r2,-16(fp)
811352d4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
811352d8:	e0bfff17 	ldw	r2,-4(fp)
811352dc:	00c01c84 	movi	r3,114
811352e0:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
811352e4:	e0bffb17 	ldw	r2,-20(fp)
}
811352e8:	e037883a 	mov	sp,fp
811352ec:	df000017 	ldw	fp,0(sp)
811352f0:	dec00104 	addi	sp,sp,4
811352f4:	f800283a 	ret

811352f8 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
811352f8:	defff204 	addi	sp,sp,-56
811352fc:	de00012e 	bgeu	sp,et,81135304 <OSFlagDel+0xc>
81135300:	003b68fa 	trap	3
81135304:	dfc00d15 	stw	ra,52(sp)
81135308:	df000c15 	stw	fp,48(sp)
8113530c:	df000c04 	addi	fp,sp,48
81135310:	e13ffd15 	stw	r4,-12(fp)
81135314:	2805883a 	mov	r2,r5
81135318:	e1bfff15 	stw	r6,-4(fp)
8113531c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81135320:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81135324:	e0bfff17 	ldw	r2,-4(fp)
81135328:	1000021e 	bne	r2,zero,81135334 <OSFlagDel+0x3c>
        return (pgrp);
8113532c:	e0bffd17 	ldw	r2,-12(fp)
81135330:	00008006 	br	81135534 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81135334:	e0bffd17 	ldw	r2,-12(fp)
81135338:	1000051e 	bne	r2,zero,81135350 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113533c:	e0bfff17 	ldw	r2,-4(fp)
81135340:	00c01b84 	movi	r3,110
81135344:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81135348:	e0bffd17 	ldw	r2,-12(fp)
8113534c:	00007906 	br	81135534 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81135350:	d0a09b03 	ldbu	r2,-32148(gp)
81135354:	10803fcc 	andi	r2,r2,255
81135358:	10000526 	beq	r2,zero,81135370 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113535c:	e0bfff17 	ldw	r2,-4(fp)
81135360:	00c003c4 	movi	r3,15
81135364:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81135368:	e0bffd17 	ldw	r2,-12(fp)
8113536c:	00007106 	br	81135534 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
81135370:	e0bffd17 	ldw	r2,-12(fp)
81135374:	10800003 	ldbu	r2,0(r2)
81135378:	10803fcc 	andi	r2,r2,255
8113537c:	10800160 	cmpeqi	r2,r2,5
81135380:	1000051e 	bne	r2,zero,81135398 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81135384:	e0bfff17 	ldw	r2,-4(fp)
81135388:	00c00044 	movi	r3,1
8113538c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81135390:	e0bffd17 	ldw	r2,-12(fp)
81135394:	00006706 	br	81135534 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135398:	0005303a 	rdctl	r2,status
8113539c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811353a0:	e0fffc17 	ldw	r3,-16(fp)
811353a4:	00bfff84 	movi	r2,-2
811353a8:	1884703a 	and	r2,r3,r2
811353ac:	1001703a 	wrctl	status,r2
  
  return context;
811353b0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811353b4:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
811353b8:	e0bffd17 	ldw	r2,-12(fp)
811353bc:	10800117 	ldw	r2,4(r2)
811353c0:	10000326 	beq	r2,zero,811353d0 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811353c4:	00800044 	movi	r2,1
811353c8:	e0bff405 	stb	r2,-48(fp)
811353cc:	00000106 	br	811353d4 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811353d0:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
811353d4:	e0bffe03 	ldbu	r2,-8(fp)
811353d8:	10000326 	beq	r2,zero,811353e8 <OSFlagDel+0xf0>
811353dc:	10800060 	cmpeqi	r2,r2,1
811353e0:	1000231e 	bne	r2,zero,81135470 <OSFlagDel+0x178>
811353e4:	00004806 	br	81135508 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
811353e8:	e0bff403 	ldbu	r2,-48(fp)
811353ec:	1000161e 	bne	r2,zero,81135448 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
811353f0:	e0bffd17 	ldw	r2,-12(fp)
811353f4:	00c00fc4 	movi	r3,63
811353f8:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
811353fc:	e0bffd17 	ldw	r2,-12(fp)
81135400:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81135404:	e0bffd17 	ldw	r2,-12(fp)
81135408:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8113540c:	d0e0a017 	ldw	r3,-32128(gp)
81135410:	e0bffd17 	ldw	r2,-12(fp)
81135414:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
81135418:	e0bffd17 	ldw	r2,-12(fp)
8113541c:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
81135420:	e0bffd17 	ldw	r2,-12(fp)
81135424:	d0a0a015 	stw	r2,-32128(gp)
81135428:	e0bff717 	ldw	r2,-36(fp)
8113542c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135430:	e0bff817 	ldw	r2,-32(fp)
81135434:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
81135438:	e0bfff17 	ldw	r2,-4(fp)
8113543c:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
81135440:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
81135444:	00003a06 	br	81135530 <OSFlagDel+0x238>
81135448:	e0bff717 	ldw	r2,-36(fp)
8113544c:	e0bff915 	stw	r2,-28(fp)
81135450:	e0bff917 	ldw	r2,-28(fp)
81135454:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
81135458:	e0bfff17 	ldw	r2,-4(fp)
8113545c:	00c01244 	movi	r3,73
81135460:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
81135464:	e0bffd17 	ldw	r2,-12(fp)
81135468:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113546c:	00003006 	br	81135530 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81135470:	e0bffd17 	ldw	r2,-12(fp)
81135474:	10800117 	ldw	r2,4(r2)
81135478:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113547c:	00000606 	br	81135498 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
81135480:	000b883a 	mov	r5,zero
81135484:	e13ff517 	ldw	r4,-44(fp)
81135488:	11364ac0 	call	811364ac <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113548c:	e0bff517 	ldw	r2,-44(fp)
81135490:	10800017 	ldw	r2,0(r2)
81135494:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81135498:	e0bff517 	ldw	r2,-44(fp)
8113549c:	103ff81e 	bne	r2,zero,81135480 <__reset+0xfb115480>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
811354a0:	e0bffd17 	ldw	r2,-12(fp)
811354a4:	00c00fc4 	movi	r3,63
811354a8:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
811354ac:	e0bffd17 	ldw	r2,-12(fp)
811354b0:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
811354b4:	e0bffd17 	ldw	r2,-12(fp)
811354b8:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
811354bc:	d0e0a017 	ldw	r3,-32128(gp)
811354c0:	e0bffd17 	ldw	r2,-12(fp)
811354c4:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
811354c8:	e0bffd17 	ldw	r2,-12(fp)
811354cc:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
811354d0:	e0bffd17 	ldw	r2,-12(fp)
811354d4:	d0a0a015 	stw	r2,-32128(gp)
811354d8:	e0bff717 	ldw	r2,-36(fp)
811354dc:	e0bffa15 	stw	r2,-24(fp)
811354e0:	e0bffa17 	ldw	r2,-24(fp)
811354e4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
811354e8:	e0bff403 	ldbu	r2,-48(fp)
811354ec:	10800058 	cmpnei	r2,r2,1
811354f0:	1000011e 	bne	r2,zero,811354f8 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
811354f4:	11345bc0 	call	811345bc <OS_Sched>
             }
             *perr = OS_ERR_NONE;
811354f8:	e0bfff17 	ldw	r2,-4(fp)
811354fc:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
81135500:	e03ff615 	stw	zero,-40(fp)
             break;
81135504:	00000a06 	br	81135530 <OSFlagDel+0x238>
81135508:	e0bff717 	ldw	r2,-36(fp)
8113550c:	e0bffb15 	stw	r2,-20(fp)
81135510:	e0bffb17 	ldw	r2,-20(fp)
81135514:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
81135518:	e0bfff17 	ldw	r2,-4(fp)
8113551c:	00c001c4 	movi	r3,7
81135520:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
81135524:	e0bffd17 	ldw	r2,-12(fp)
81135528:	e0bff615 	stw	r2,-40(fp)
             break;
8113552c:	0001883a 	nop
    }
    return (pgrp_return);
81135530:	e0bff617 	ldw	r2,-40(fp)
}
81135534:	e037883a 	mov	sp,fp
81135538:	dfc00117 	ldw	ra,4(sp)
8113553c:	df000017 	ldw	fp,0(sp)
81135540:	dec00204 	addi	sp,sp,8
81135544:	f800283a 	ret

81135548 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81135548:	defff604 	addi	sp,sp,-40
8113554c:	de00012e 	bgeu	sp,et,81135554 <OSFlagNameGet+0xc>
81135550:	003b68fa 	trap	3
81135554:	dfc00915 	stw	ra,36(sp)
81135558:	df000815 	stw	fp,32(sp)
8113555c:	df000804 	addi	fp,sp,32
81135560:	e13ffd15 	stw	r4,-12(fp)
81135564:	e17ffe15 	stw	r5,-8(fp)
81135568:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113556c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81135570:	e0bfff17 	ldw	r2,-4(fp)
81135574:	1000021e 	bne	r2,zero,81135580 <OSFlagNameGet+0x38>
        return (0);
81135578:	0005883a 	mov	r2,zero
8113557c:	00003906 	br	81135664 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81135580:	e0bffd17 	ldw	r2,-12(fp)
81135584:	1000051e 	bne	r2,zero,8113559c <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81135588:	e0bfff17 	ldw	r2,-4(fp)
8113558c:	00c01b84 	movi	r3,110
81135590:	10c00005 	stb	r3,0(r2)
        return (0);
81135594:	0005883a 	mov	r2,zero
81135598:	00003206 	br	81135664 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113559c:	e0bffe17 	ldw	r2,-8(fp)
811355a0:	1000051e 	bne	r2,zero,811355b8 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
811355a4:	e0bfff17 	ldw	r2,-4(fp)
811355a8:	00c00304 	movi	r3,12
811355ac:	10c00005 	stb	r3,0(r2)
        return (0);
811355b0:	0005883a 	mov	r2,zero
811355b4:	00002b06 	br	81135664 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811355b8:	d0a09b03 	ldbu	r2,-32148(gp)
811355bc:	10803fcc 	andi	r2,r2,255
811355c0:	10000526 	beq	r2,zero,811355d8 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
811355c4:	e0bfff17 	ldw	r2,-4(fp)
811355c8:	00c00444 	movi	r3,17
811355cc:	10c00005 	stb	r3,0(r2)
        return (0);
811355d0:	0005883a 	mov	r2,zero
811355d4:	00002306 	br	81135664 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811355d8:	0005303a 	rdctl	r2,status
811355dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811355e0:	e0fffc17 	ldw	r3,-16(fp)
811355e4:	00bfff84 	movi	r2,-2
811355e8:	1884703a 	and	r2,r3,r2
811355ec:	1001703a 	wrctl	status,r2
  
  return context;
811355f0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811355f4:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
811355f8:	e0bffd17 	ldw	r2,-12(fp)
811355fc:	10800003 	ldbu	r2,0(r2)
81135600:	10803fcc 	andi	r2,r2,255
81135604:	10800160 	cmpeqi	r2,r2,5
81135608:	1000091e 	bne	r2,zero,81135630 <OSFlagNameGet+0xe8>
8113560c:	e0bff817 	ldw	r2,-32(fp)
81135610:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135614:	e0bff917 	ldw	r2,-28(fp)
81135618:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113561c:	e0bfff17 	ldw	r2,-4(fp)
81135620:	00c00044 	movi	r3,1
81135624:	10c00005 	stb	r3,0(r2)
        return (0);
81135628:	0005883a 	mov	r2,zero
8113562c:	00000d06 	br	81135664 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
81135630:	e0bffd17 	ldw	r2,-12(fp)
81135634:	10800284 	addi	r2,r2,10
81135638:	100b883a 	mov	r5,r2
8113563c:	e13ffe17 	ldw	r4,-8(fp)
81135640:	11347100 	call	81134710 <OS_StrCopy>
81135644:	e0bffb05 	stb	r2,-20(fp)
81135648:	e0bff817 	ldw	r2,-32(fp)
8113564c:	e0bffa15 	stw	r2,-24(fp)
81135650:	e0bffa17 	ldw	r2,-24(fp)
81135654:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81135658:	e0bfff17 	ldw	r2,-4(fp)
8113565c:	10000005 	stb	zero,0(r2)
    return (len);
81135660:	e0bffb03 	ldbu	r2,-20(fp)
}
81135664:	e037883a 	mov	sp,fp
81135668:	dfc00117 	ldw	ra,4(sp)
8113566c:	df000017 	ldw	fp,0(sp)
81135670:	dec00204 	addi	sp,sp,8
81135674:	f800283a 	ret

81135678 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81135678:	defff504 	addi	sp,sp,-44
8113567c:	de00012e 	bgeu	sp,et,81135684 <OSFlagNameSet+0xc>
81135680:	003b68fa 	trap	3
81135684:	dfc00a15 	stw	ra,40(sp)
81135688:	df000915 	stw	fp,36(sp)
8113568c:	df000904 	addi	fp,sp,36
81135690:	e13ffd15 	stw	r4,-12(fp)
81135694:	e17ffe15 	stw	r5,-8(fp)
81135698:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113569c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811356a0:	e0bfff17 	ldw	r2,-4(fp)
811356a4:	10004326 	beq	r2,zero,811357b4 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
811356a8:	e0bffd17 	ldw	r2,-12(fp)
811356ac:	1000041e 	bne	r2,zero,811356c0 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811356b0:	e0bfff17 	ldw	r2,-4(fp)
811356b4:	00c01b84 	movi	r3,110
811356b8:	10c00005 	stb	r3,0(r2)
        return;
811356bc:	00003e06 	br	811357b8 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811356c0:	e0bffe17 	ldw	r2,-8(fp)
811356c4:	1000041e 	bne	r2,zero,811356d8 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
811356c8:	e0bfff17 	ldw	r2,-4(fp)
811356cc:	00c00304 	movi	r3,12
811356d0:	10c00005 	stb	r3,0(r2)
        return;
811356d4:	00003806 	br	811357b8 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811356d8:	d0a09b03 	ldbu	r2,-32148(gp)
811356dc:	10803fcc 	andi	r2,r2,255
811356e0:	10000426 	beq	r2,zero,811356f4 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
811356e4:	e0bfff17 	ldw	r2,-4(fp)
811356e8:	00c00484 	movi	r3,18
811356ec:	10c00005 	stb	r3,0(r2)
        return;
811356f0:	00003106 	br	811357b8 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811356f4:	0005303a 	rdctl	r2,status
811356f8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811356fc:	e0fffc17 	ldw	r3,-16(fp)
81135700:	00bfff84 	movi	r2,-2
81135704:	1884703a 	and	r2,r3,r2
81135708:	1001703a 	wrctl	status,r2
  
  return context;
8113570c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81135710:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81135714:	e0bffd17 	ldw	r2,-12(fp)
81135718:	10800003 	ldbu	r2,0(r2)
8113571c:	10803fcc 	andi	r2,r2,255
81135720:	10800160 	cmpeqi	r2,r2,5
81135724:	1000081e 	bne	r2,zero,81135748 <OSFlagNameSet+0xd0>
81135728:	e0bff717 	ldw	r2,-36(fp)
8113572c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135730:	e0bff817 	ldw	r2,-32(fp)
81135734:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81135738:	e0bfff17 	ldw	r2,-4(fp)
8113573c:	00c00044 	movi	r3,1
81135740:	10c00005 	stb	r3,0(r2)
        return;
81135744:	00001c06 	br	811357b8 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81135748:	e13ffe17 	ldw	r4,-8(fp)
8113574c:	113478c0 	call	8113478c <OS_StrLen>
81135750:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
81135754:	e0bffa03 	ldbu	r2,-24(fp)
81135758:	10800830 	cmpltui	r2,r2,32
8113575c:	1000081e 	bne	r2,zero,81135780 <OSFlagNameSet+0x108>
81135760:	e0bff717 	ldw	r2,-36(fp)
81135764:	e0bff915 	stw	r2,-28(fp)
81135768:	e0bff917 	ldw	r2,-28(fp)
8113576c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
81135770:	e0bfff17 	ldw	r2,-4(fp)
81135774:	00c01cc4 	movi	r3,115
81135778:	10c00005 	stb	r3,0(r2)
        return;
8113577c:	00000e06 	br	811357b8 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
81135780:	e0bffd17 	ldw	r2,-12(fp)
81135784:	10800284 	addi	r2,r2,10
81135788:	e17ffe17 	ldw	r5,-8(fp)
8113578c:	1009883a 	mov	r4,r2
81135790:	11347100 	call	81134710 <OS_StrCopy>
81135794:	e0bff717 	ldw	r2,-36(fp)
81135798:	e0bffb15 	stw	r2,-20(fp)
8113579c:	e0bffb17 	ldw	r2,-20(fp)
811357a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811357a4:	e0bfff17 	ldw	r2,-4(fp)
811357a8:	10000005 	stb	zero,0(r2)
    return;
811357ac:	0001883a 	nop
811357b0:	00000106 	br	811357b8 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
811357b4:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
811357b8:	e037883a 	mov	sp,fp
811357bc:	dfc00117 	ldw	ra,4(sp)
811357c0:	df000017 	ldw	fp,0(sp)
811357c4:	dec00204 	addi	sp,sp,8
811357c8:	f800283a 	ret

811357cc <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
811357cc:	deffe104 	addi	sp,sp,-124
811357d0:	de00012e 	bgeu	sp,et,811357d8 <OSFlagPend+0xc>
811357d4:	003b68fa 	trap	3
811357d8:	dfc01e15 	stw	ra,120(sp)
811357dc:	df001d15 	stw	fp,116(sp)
811357e0:	df001d04 	addi	fp,sp,116
811357e4:	e13ffc15 	stw	r4,-16(fp)
811357e8:	2809883a 	mov	r4,r5
811357ec:	3007883a 	mov	r3,r6
811357f0:	3805883a 	mov	r2,r7
811357f4:	e13ffd0d 	sth	r4,-12(fp)
811357f8:	e0fffe05 	stb	r3,-8(fp)
811357fc:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81135800:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81135804:	e0800217 	ldw	r2,8(fp)
81135808:	1000021e 	bne	r2,zero,81135814 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8113580c:	0005883a 	mov	r2,zero
81135810:	00015906 	br	81135d78 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81135814:	e0bffc17 	ldw	r2,-16(fp)
81135818:	1000051e 	bne	r2,zero,81135830 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113581c:	e0800217 	ldw	r2,8(fp)
81135820:	00c01b84 	movi	r3,110
81135824:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135828:	0005883a 	mov	r2,zero
8113582c:	00015206 	br	81135d78 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81135830:	d0a09b03 	ldbu	r2,-32148(gp)
81135834:	10803fcc 	andi	r2,r2,255
81135838:	10000526 	beq	r2,zero,81135850 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113583c:	e0800217 	ldw	r2,8(fp)
81135840:	00c00084 	movi	r3,2
81135844:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135848:	0005883a 	mov	r2,zero
8113584c:	00014a06 	br	81135d78 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81135850:	d0a08903 	ldbu	r2,-32220(gp)
81135854:	10803fcc 	andi	r2,r2,255
81135858:	10000526 	beq	r2,zero,81135870 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113585c:	e0800217 	ldw	r2,8(fp)
81135860:	00c00344 	movi	r3,13
81135864:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135868:	0005883a 	mov	r2,zero
8113586c:	00014206 	br	81135d78 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81135870:	e0bffc17 	ldw	r2,-16(fp)
81135874:	10800003 	ldbu	r2,0(r2)
81135878:	10803fcc 	andi	r2,r2,255
8113587c:	10800160 	cmpeqi	r2,r2,5
81135880:	1000051e 	bne	r2,zero,81135898 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
81135884:	e0800217 	ldw	r2,8(fp)
81135888:	00c00044 	movi	r3,1
8113588c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135890:	0005883a 	mov	r2,zero
81135894:	00013806 	br	81135d78 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81135898:	e0fffe03 	ldbu	r3,-8(fp)
8113589c:	00bfe004 	movi	r2,-128
811358a0:	1884703a 	and	r2,r3,r2
811358a4:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
811358a8:	e0bfe603 	ldbu	r2,-104(fp)
811358ac:	10000626 	beq	r2,zero,811358c8 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
811358b0:	e0bffe03 	ldbu	r2,-8(fp)
811358b4:	10801fcc 	andi	r2,r2,127
811358b8:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
811358bc:	00800044 	movi	r2,1
811358c0:	e0bfe405 	stb	r2,-112(fp)
811358c4:	00000106 	br	811358cc <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
811358c8:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811358cc:	0005303a 	rdctl	r2,status
811358d0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811358d4:	e0fff617 	ldw	r3,-40(fp)
811358d8:	00bfff84 	movi	r2,-2
811358dc:	1884703a 	and	r2,r3,r2
811358e0:	1001703a 	wrctl	status,r2
  
  return context;
811358e4:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
811358e8:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
811358ec:	e0bffe03 	ldbu	r2,-8(fp)
811358f0:	10c00060 	cmpeqi	r3,r2,1
811358f4:	1800921e 	bne	r3,zero,81135b40 <OSFlagPend+0x374>
811358f8:	10c00088 	cmpgei	r3,r2,2
811358fc:	1800021e 	bne	r3,zero,81135908 <OSFlagPend+0x13c>
81135900:	10006126 	beq	r2,zero,81135a88 <OSFlagPend+0x2bc>
81135904:	0000bb06 	br	81135bf4 <OSFlagPend+0x428>
81135908:	10c000a0 	cmpeqi	r3,r2,2
8113590c:	1800031e 	bne	r3,zero,8113591c <OSFlagPend+0x150>
81135910:	108000e0 	cmpeqi	r2,r2,3
81135914:	10002f1e 	bne	r2,zero,811359d4 <OSFlagPend+0x208>
81135918:	0000b606 	br	81135bf4 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8113591c:	e0bffc17 	ldw	r2,-16(fp)
81135920:	10c0020b 	ldhu	r3,8(r2)
81135924:	e0bffd0b 	ldhu	r2,-12(fp)
81135928:	1884703a 	and	r2,r3,r2
8113592c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81135930:	e0ffe80b 	ldhu	r3,-96(fp)
81135934:	e0bffd0b 	ldhu	r2,-12(fp)
81135938:	1880171e 	bne	r3,r2,81135998 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113593c:	e0bfe403 	ldbu	r2,-112(fp)
81135940:	10800058 	cmpnei	r2,r2,1
81135944:	1000091e 	bne	r2,zero,8113596c <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81135948:	e0bffc17 	ldw	r2,-16(fp)
8113594c:	1080020b 	ldhu	r2,8(r2)
81135950:	1007883a 	mov	r3,r2
81135954:	e0bfe80b 	ldhu	r2,-96(fp)
81135958:	0084303a 	nor	r2,zero,r2
8113595c:	1884703a 	and	r2,r3,r2
81135960:	1007883a 	mov	r3,r2
81135964:	e0bffc17 	ldw	r2,-16(fp)
81135968:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113596c:	d0a09c17 	ldw	r2,-32144(gp)
81135970:	e0ffe80b 	ldhu	r3,-96(fp)
81135974:	10c00b0d 	sth	r3,44(r2)
81135978:	e0bfe517 	ldw	r2,-108(fp)
8113597c:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135980:	e0bfe717 	ldw	r2,-100(fp)
81135984:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81135988:	e0800217 	ldw	r2,8(fp)
8113598c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81135990:	e0bfe80b 	ldhu	r2,-96(fp)
81135994:	0000f806 	br	81135d78 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81135998:	e13ffd0b 	ldhu	r4,-12(fp)
8113599c:	e17ffe03 	ldbu	r5,-8(fp)
811359a0:	e0bfff0b 	ldhu	r2,-4(fp)
811359a4:	e0fff704 	addi	r3,fp,-36
811359a8:	d8800015 	stw	r2,0(sp)
811359ac:	280f883a 	mov	r7,r5
811359b0:	200d883a 	mov	r6,r4
811359b4:	180b883a 	mov	r5,r3
811359b8:	e13ffc17 	ldw	r4,-16(fp)
811359bc:	113625c0 	call	8113625c <OS_FlagBlock>
811359c0:	e0bfe517 	ldw	r2,-108(fp)
811359c4:	e0bfe915 	stw	r2,-92(fp)
811359c8:	e0bfe917 	ldw	r2,-92(fp)
811359cc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
811359d0:	00009206 	br	81135c1c <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
811359d4:	e0bffc17 	ldw	r2,-16(fp)
811359d8:	10c0020b 	ldhu	r3,8(r2)
811359dc:	e0bffd0b 	ldhu	r2,-12(fp)
811359e0:	1884703a 	and	r2,r3,r2
811359e4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
811359e8:	e0bfe80b 	ldhu	r2,-96(fp)
811359ec:	10001726 	beq	r2,zero,81135a4c <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811359f0:	e0bfe403 	ldbu	r2,-112(fp)
811359f4:	10800058 	cmpnei	r2,r2,1
811359f8:	1000091e 	bne	r2,zero,81135a20 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
811359fc:	e0bffc17 	ldw	r2,-16(fp)
81135a00:	1080020b 	ldhu	r2,8(r2)
81135a04:	1007883a 	mov	r3,r2
81135a08:	e0bfe80b 	ldhu	r2,-96(fp)
81135a0c:	0084303a 	nor	r2,zero,r2
81135a10:	1884703a 	and	r2,r3,r2
81135a14:	1007883a 	mov	r3,r2
81135a18:	e0bffc17 	ldw	r2,-16(fp)
81135a1c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81135a20:	d0a09c17 	ldw	r2,-32144(gp)
81135a24:	e0ffe80b 	ldhu	r3,-96(fp)
81135a28:	10c00b0d 	sth	r3,44(r2)
81135a2c:	e0bfe517 	ldw	r2,-108(fp)
81135a30:	e0bfea15 	stw	r2,-88(fp)
81135a34:	e0bfea17 	ldw	r2,-88(fp)
81135a38:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81135a3c:	e0800217 	ldw	r2,8(fp)
81135a40:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81135a44:	e0bfe80b 	ldhu	r2,-96(fp)
81135a48:	0000cb06 	br	81135d78 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81135a4c:	e13ffd0b 	ldhu	r4,-12(fp)
81135a50:	e17ffe03 	ldbu	r5,-8(fp)
81135a54:	e0bfff0b 	ldhu	r2,-4(fp)
81135a58:	e0fff704 	addi	r3,fp,-36
81135a5c:	d8800015 	stw	r2,0(sp)
81135a60:	280f883a 	mov	r7,r5
81135a64:	200d883a 	mov	r6,r4
81135a68:	180b883a 	mov	r5,r3
81135a6c:	e13ffc17 	ldw	r4,-16(fp)
81135a70:	113625c0 	call	8113625c <OS_FlagBlock>
81135a74:	e0bfe517 	ldw	r2,-108(fp)
81135a78:	e0bfeb15 	stw	r2,-84(fp)
81135a7c:	e0bfeb17 	ldw	r2,-84(fp)
81135a80:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81135a84:	00006506 	br	81135c1c <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81135a88:	e0bffc17 	ldw	r2,-16(fp)
81135a8c:	1080020b 	ldhu	r2,8(r2)
81135a90:	0084303a 	nor	r2,zero,r2
81135a94:	1007883a 	mov	r3,r2
81135a98:	e0bffd0b 	ldhu	r2,-12(fp)
81135a9c:	1884703a 	and	r2,r3,r2
81135aa0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81135aa4:	e0ffe80b 	ldhu	r3,-96(fp)
81135aa8:	e0bffd0b 	ldhu	r2,-12(fp)
81135aac:	1880151e 	bne	r3,r2,81135b04 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135ab0:	e0bfe403 	ldbu	r2,-112(fp)
81135ab4:	10800058 	cmpnei	r2,r2,1
81135ab8:	1000071e 	bne	r2,zero,81135ad8 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81135abc:	e0bffc17 	ldw	r2,-16(fp)
81135ac0:	10c0020b 	ldhu	r3,8(r2)
81135ac4:	e0bfe80b 	ldhu	r2,-96(fp)
81135ac8:	1884b03a 	or	r2,r3,r2
81135acc:	1007883a 	mov	r3,r2
81135ad0:	e0bffc17 	ldw	r2,-16(fp)
81135ad4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81135ad8:	d0a09c17 	ldw	r2,-32144(gp)
81135adc:	e0ffe80b 	ldhu	r3,-96(fp)
81135ae0:	10c00b0d 	sth	r3,44(r2)
81135ae4:	e0bfe517 	ldw	r2,-108(fp)
81135ae8:	e0bfec15 	stw	r2,-80(fp)
81135aec:	e0bfec17 	ldw	r2,-80(fp)
81135af0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81135af4:	e0800217 	ldw	r2,8(fp)
81135af8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81135afc:	e0bfe80b 	ldhu	r2,-96(fp)
81135b00:	00009d06 	br	81135d78 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81135b04:	e13ffd0b 	ldhu	r4,-12(fp)
81135b08:	e17ffe03 	ldbu	r5,-8(fp)
81135b0c:	e0bfff0b 	ldhu	r2,-4(fp)
81135b10:	e0fff704 	addi	r3,fp,-36
81135b14:	d8800015 	stw	r2,0(sp)
81135b18:	280f883a 	mov	r7,r5
81135b1c:	200d883a 	mov	r6,r4
81135b20:	180b883a 	mov	r5,r3
81135b24:	e13ffc17 	ldw	r4,-16(fp)
81135b28:	113625c0 	call	8113625c <OS_FlagBlock>
81135b2c:	e0bfe517 	ldw	r2,-108(fp)
81135b30:	e0bfed15 	stw	r2,-76(fp)
81135b34:	e0bfed17 	ldw	r2,-76(fp)
81135b38:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81135b3c:	00003706 	br	81135c1c <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
81135b40:	e0bffc17 	ldw	r2,-16(fp)
81135b44:	1080020b 	ldhu	r2,8(r2)
81135b48:	0084303a 	nor	r2,zero,r2
81135b4c:	1007883a 	mov	r3,r2
81135b50:	e0bffd0b 	ldhu	r2,-12(fp)
81135b54:	1884703a 	and	r2,r3,r2
81135b58:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
81135b5c:	e0bfe80b 	ldhu	r2,-96(fp)
81135b60:	10001526 	beq	r2,zero,81135bb8 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135b64:	e0bfe403 	ldbu	r2,-112(fp)
81135b68:	10800058 	cmpnei	r2,r2,1
81135b6c:	1000071e 	bne	r2,zero,81135b8c <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
81135b70:	e0bffc17 	ldw	r2,-16(fp)
81135b74:	10c0020b 	ldhu	r3,8(r2)
81135b78:	e0bfe80b 	ldhu	r2,-96(fp)
81135b7c:	1884b03a 	or	r2,r3,r2
81135b80:	1007883a 	mov	r3,r2
81135b84:	e0bffc17 	ldw	r2,-16(fp)
81135b88:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81135b8c:	d0a09c17 	ldw	r2,-32144(gp)
81135b90:	e0ffe80b 	ldhu	r3,-96(fp)
81135b94:	10c00b0d 	sth	r3,44(r2)
81135b98:	e0bfe517 	ldw	r2,-108(fp)
81135b9c:	e0bfee15 	stw	r2,-72(fp)
81135ba0:	e0bfee17 	ldw	r2,-72(fp)
81135ba4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81135ba8:	e0800217 	ldw	r2,8(fp)
81135bac:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81135bb0:	e0bfe80b 	ldhu	r2,-96(fp)
81135bb4:	00007006 	br	81135d78 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81135bb8:	e13ffd0b 	ldhu	r4,-12(fp)
81135bbc:	e17ffe03 	ldbu	r5,-8(fp)
81135bc0:	e0bfff0b 	ldhu	r2,-4(fp)
81135bc4:	e0fff704 	addi	r3,fp,-36
81135bc8:	d8800015 	stw	r2,0(sp)
81135bcc:	280f883a 	mov	r7,r5
81135bd0:	200d883a 	mov	r6,r4
81135bd4:	180b883a 	mov	r5,r3
81135bd8:	e13ffc17 	ldw	r4,-16(fp)
81135bdc:	113625c0 	call	8113625c <OS_FlagBlock>
81135be0:	e0bfe517 	ldw	r2,-108(fp)
81135be4:	e0bfef15 	stw	r2,-68(fp)
81135be8:	e0bfef17 	ldw	r2,-68(fp)
81135bec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81135bf0:	00000a06 	br	81135c1c <OSFlagPend+0x450>
81135bf4:	e0bfe517 	ldw	r2,-108(fp)
81135bf8:	e0bff015 	stw	r2,-64(fp)
81135bfc:	e0bff017 	ldw	r2,-64(fp)
81135c00:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81135c04:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
81135c08:	e0800217 	ldw	r2,8(fp)
81135c0c:	00c01bc4 	movi	r3,111
81135c10:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
81135c14:	e0bfe80b 	ldhu	r2,-96(fp)
81135c18:	00005706 	br	81135d78 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
81135c1c:	11345bc0 	call	811345bc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135c20:	0005303a 	rdctl	r2,status
81135c24:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135c28:	e0fff117 	ldw	r3,-60(fp)
81135c2c:	00bfff84 	movi	r2,-2
81135c30:	1884703a 	and	r2,r3,r2
81135c34:	1001703a 	wrctl	status,r2
  
  return context;
81135c38:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
81135c3c:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
81135c40:	d0a09c17 	ldw	r2,-32144(gp)
81135c44:	10800c43 	ldbu	r2,49(r2)
81135c48:	10803fcc 	andi	r2,r2,255
81135c4c:	10001c26 	beq	r2,zero,81135cc0 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
81135c50:	d0a09c17 	ldw	r2,-32144(gp)
81135c54:	10800c43 	ldbu	r2,49(r2)
81135c58:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81135c5c:	d0a09c17 	ldw	r2,-32144(gp)
81135c60:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
81135c64:	e0bff704 	addi	r2,fp,-36
81135c68:	1009883a 	mov	r4,r2
81135c6c:	11365a80 	call	811365a8 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
81135c70:	d0a09c17 	ldw	r2,-32144(gp)
81135c74:	10000c05 	stb	zero,48(r2)
81135c78:	e0bfe517 	ldw	r2,-108(fp)
81135c7c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135c80:	e0bff217 	ldw	r2,-56(fp)
81135c84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
81135c88:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
81135c8c:	e0bff303 	ldbu	r2,-52(fp)
81135c90:	108000a0 	cmpeqi	r2,r2,2
81135c94:	10000426 	beq	r2,zero,81135ca8 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
81135c98:	e0800217 	ldw	r2,8(fp)
81135c9c:	00c00384 	movi	r3,14
81135ca0:	10c00005 	stb	r3,0(r2)
                 break;
81135ca4:	00000406 	br	81135cb8 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
81135ca8:	e0800217 	ldw	r2,8(fp)
81135cac:	00c00284 	movi	r3,10
81135cb0:	10c00005 	stb	r3,0(r2)
                 break;
81135cb4:	0001883a 	nop
        }
        return (flags_rdy);
81135cb8:	e0bfe80b 	ldhu	r2,-96(fp)
81135cbc:	00002e06 	br	81135d78 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
81135cc0:	d0a09c17 	ldw	r2,-32144(gp)
81135cc4:	10800b0b 	ldhu	r2,44(r2)
81135cc8:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
81135ccc:	e0bfe403 	ldbu	r2,-112(fp)
81135cd0:	10800058 	cmpnei	r2,r2,1
81135cd4:	1000211e 	bne	r2,zero,81135d5c <OSFlagPend+0x590>
        switch (wait_type) {
81135cd8:	e0bffe03 	ldbu	r2,-8(fp)
81135cdc:	10001616 	blt	r2,zero,81135d38 <OSFlagPend+0x56c>
81135ce0:	10c00090 	cmplti	r3,r2,2
81135ce4:	18000c1e 	bne	r3,zero,81135d18 <OSFlagPend+0x54c>
81135ce8:	10800108 	cmpgei	r2,r2,4
81135cec:	1000121e 	bne	r2,zero,81135d38 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
81135cf0:	e0bffc17 	ldw	r2,-16(fp)
81135cf4:	1080020b 	ldhu	r2,8(r2)
81135cf8:	1007883a 	mov	r3,r2
81135cfc:	e0bfe80b 	ldhu	r2,-96(fp)
81135d00:	0084303a 	nor	r2,zero,r2
81135d04:	1884703a 	and	r2,r3,r2
81135d08:	1007883a 	mov	r3,r2
81135d0c:	e0bffc17 	ldw	r2,-16(fp)
81135d10:	10c0020d 	sth	r3,8(r2)
                 break;
81135d14:	00001106 	br	81135d5c <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
81135d18:	e0bffc17 	ldw	r2,-16(fp)
81135d1c:	10c0020b 	ldhu	r3,8(r2)
81135d20:	e0bfe80b 	ldhu	r2,-96(fp)
81135d24:	1884b03a 	or	r2,r3,r2
81135d28:	1007883a 	mov	r3,r2
81135d2c:	e0bffc17 	ldw	r2,-16(fp)
81135d30:	10c0020d 	sth	r3,8(r2)
                 break;
81135d34:	00000906 	br	81135d5c <OSFlagPend+0x590>
81135d38:	e0bfe517 	ldw	r2,-108(fp)
81135d3c:	e0bff415 	stw	r2,-48(fp)
81135d40:	e0bff417 	ldw	r2,-48(fp)
81135d44:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
81135d48:	e0800217 	ldw	r2,8(fp)
81135d4c:	00c01bc4 	movi	r3,111
81135d50:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81135d54:	0005883a 	mov	r2,zero
81135d58:	00000706 	br	81135d78 <OSFlagPend+0x5ac>
81135d5c:	e0bfe517 	ldw	r2,-108(fp)
81135d60:	e0bff515 	stw	r2,-44(fp)
81135d64:	e0bff517 	ldw	r2,-44(fp)
81135d68:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
81135d6c:	e0800217 	ldw	r2,8(fp)
81135d70:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
81135d74:	e0bfe80b 	ldhu	r2,-96(fp)
}
81135d78:	e037883a 	mov	sp,fp
81135d7c:	dfc00117 	ldw	ra,4(sp)
81135d80:	df000017 	ldw	fp,0(sp)
81135d84:	dec00204 	addi	sp,sp,8
81135d88:	f800283a 	ret

81135d8c <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
81135d8c:	defffb04 	addi	sp,sp,-20
81135d90:	de00012e 	bgeu	sp,et,81135d98 <OSFlagPendGetFlagsRdy+0xc>
81135d94:	003b68fa 	trap	3
81135d98:	df000415 	stw	fp,16(sp)
81135d9c:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81135da0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135da4:	0005303a 	rdctl	r2,status
81135da8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135dac:	e0fffe17 	ldw	r3,-8(fp)
81135db0:	00bfff84 	movi	r2,-2
81135db4:	1884703a 	and	r2,r3,r2
81135db8:	1001703a 	wrctl	status,r2
  
  return context;
81135dbc:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81135dc0:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
81135dc4:	d0a09c17 	ldw	r2,-32144(gp)
81135dc8:	10800b0b 	ldhu	r2,44(r2)
81135dcc:	e0bffd0d 	sth	r2,-12(fp)
81135dd0:	e0bffc17 	ldw	r2,-16(fp)
81135dd4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135dd8:	e0bfff17 	ldw	r2,-4(fp)
81135ddc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
81135de0:	e0bffd0b 	ldhu	r2,-12(fp)
}
81135de4:	e037883a 	mov	sp,fp
81135de8:	df000017 	ldw	fp,0(sp)
81135dec:	dec00104 	addi	sp,sp,4
81135df0:	f800283a 	ret

81135df4 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
81135df4:	deffef04 	addi	sp,sp,-68
81135df8:	de00012e 	bgeu	sp,et,81135e00 <OSFlagPost+0xc>
81135dfc:	003b68fa 	trap	3
81135e00:	dfc01015 	stw	ra,64(sp)
81135e04:	df000f15 	stw	fp,60(sp)
81135e08:	df000f04 	addi	fp,sp,60
81135e0c:	e13ffc15 	stw	r4,-16(fp)
81135e10:	2807883a 	mov	r3,r5
81135e14:	3005883a 	mov	r2,r6
81135e18:	e1ffff15 	stw	r7,-4(fp)
81135e1c:	e0fffd0d 	sth	r3,-12(fp)
81135e20:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
81135e24:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81135e28:	e0bfff17 	ldw	r2,-4(fp)
81135e2c:	1000021e 	bne	r2,zero,81135e38 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
81135e30:	0005883a 	mov	r2,zero
81135e34:	0000d106 	br	8113617c <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
81135e38:	e0bffc17 	ldw	r2,-16(fp)
81135e3c:	1000051e 	bne	r2,zero,81135e54 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81135e40:	e0bfff17 	ldw	r2,-4(fp)
81135e44:	00c01b84 	movi	r3,110
81135e48:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135e4c:	0005883a 	mov	r2,zero
81135e50:	0000ca06 	br	8113617c <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
81135e54:	e0bffc17 	ldw	r2,-16(fp)
81135e58:	10800003 	ldbu	r2,0(r2)
81135e5c:	10803fcc 	andi	r2,r2,255
81135e60:	10800160 	cmpeqi	r2,r2,5
81135e64:	1000051e 	bne	r2,zero,81135e7c <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
81135e68:	e0bfff17 	ldw	r2,-4(fp)
81135e6c:	00c00044 	movi	r3,1
81135e70:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135e74:	0005883a 	mov	r2,zero
81135e78:	0000c006 	br	8113617c <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135e7c:	0005303a 	rdctl	r2,status
81135e80:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135e84:	e0fffb17 	ldw	r3,-20(fp)
81135e88:	00bfff84 	movi	r2,-2
81135e8c:	1884703a 	and	r2,r3,r2
81135e90:	1001703a 	wrctl	status,r2
  
  return context;
81135e94:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81135e98:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
81135e9c:	e0bffe03 	ldbu	r2,-8(fp)
81135ea0:	10000326 	beq	r2,zero,81135eb0 <OSFlagPost+0xbc>
81135ea4:	10800060 	cmpeqi	r2,r2,1
81135ea8:	10000b1e 	bne	r2,zero,81135ed8 <OSFlagPost+0xe4>
81135eac:	00001206 	br	81135ef8 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
81135eb0:	e0bffc17 	ldw	r2,-16(fp)
81135eb4:	1080020b 	ldhu	r2,8(r2)
81135eb8:	1007883a 	mov	r3,r2
81135ebc:	e0bffd0b 	ldhu	r2,-12(fp)
81135ec0:	0084303a 	nor	r2,zero,r2
81135ec4:	1884703a 	and	r2,r3,r2
81135ec8:	1007883a 	mov	r3,r2
81135ecc:	e0bffc17 	ldw	r2,-16(fp)
81135ed0:	10c0020d 	sth	r3,8(r2)
             break;
81135ed4:	00001106 	br	81135f1c <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
81135ed8:	e0bffc17 	ldw	r2,-16(fp)
81135edc:	10c0020b 	ldhu	r3,8(r2)
81135ee0:	e0bffd0b 	ldhu	r2,-12(fp)
81135ee4:	1884b03a 	or	r2,r3,r2
81135ee8:	1007883a 	mov	r3,r2
81135eec:	e0bffc17 	ldw	r2,-16(fp)
81135ef0:	10c0020d 	sth	r3,8(r2)
             break;
81135ef4:	00000906 	br	81135f1c <OSFlagPost+0x128>
81135ef8:	e0bff317 	ldw	r2,-52(fp)
81135efc:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135f00:	e0bff417 	ldw	r2,-48(fp)
81135f04:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
81135f08:	e0bfff17 	ldw	r2,-4(fp)
81135f0c:	00c01c44 	movi	r3,113
81135f10:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
81135f14:	0005883a 	mov	r2,zero
81135f18:	00009806 	br	8113617c <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
81135f1c:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81135f20:	e0bffc17 	ldw	r2,-16(fp)
81135f24:	10800117 	ldw	r2,4(r2)
81135f28:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81135f2c:	00007706 	br	8113610c <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
81135f30:	e0bff117 	ldw	r2,-60(fp)
81135f34:	10800483 	ldbu	r2,18(r2)
81135f38:	10803fcc 	andi	r2,r2,255
81135f3c:	10c00060 	cmpeqi	r3,r2,1
81135f40:	18004a1e 	bne	r3,zero,8113606c <OSFlagPost+0x278>
81135f44:	10c00088 	cmpgei	r3,r2,2
81135f48:	1800021e 	bne	r3,zero,81135f54 <OSFlagPost+0x160>
81135f4c:	10002f26 	beq	r2,zero,8113600c <OSFlagPost+0x218>
81135f50:	00005b06 	br	811360c0 <OSFlagPost+0x2cc>
81135f54:	10c000a0 	cmpeqi	r3,r2,2
81135f58:	1800031e 	bne	r3,zero,81135f68 <OSFlagPost+0x174>
81135f5c:	108000e0 	cmpeqi	r2,r2,3
81135f60:	1000171e 	bne	r2,zero,81135fc0 <OSFlagPost+0x1cc>
81135f64:	00005606 	br	811360c0 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81135f68:	e0bffc17 	ldw	r2,-16(fp)
81135f6c:	10c0020b 	ldhu	r3,8(r2)
81135f70:	e0bff117 	ldw	r2,-60(fp)
81135f74:	1080040b 	ldhu	r2,16(r2)
81135f78:	1884703a 	and	r2,r3,r2
81135f7c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81135f80:	e0bff117 	ldw	r2,-60(fp)
81135f84:	1080040b 	ldhu	r2,16(r2)
81135f88:	10ffffcc 	andi	r3,r2,65535
81135f8c:	e0bff60b 	ldhu	r2,-40(fp)
81135f90:	1880541e 	bne	r3,r2,811360e4 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81135f94:	e0bff60b 	ldhu	r2,-40(fp)
81135f98:	100b883a 	mov	r5,r2
81135f9c:	e13ff117 	ldw	r4,-60(fp)
81135fa0:	11364ac0 	call	811364ac <OS_FlagTaskRdy>
81135fa4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81135fa8:	e0bff683 	ldbu	r2,-38(fp)
81135fac:	10800058 	cmpnei	r2,r2,1
81135fb0:	10004c1e 	bne	r2,zero,811360e4 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81135fb4:	00800044 	movi	r2,1
81135fb8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81135fbc:	00004906 	br	811360e4 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81135fc0:	e0bffc17 	ldw	r2,-16(fp)
81135fc4:	10c0020b 	ldhu	r3,8(r2)
81135fc8:	e0bff117 	ldw	r2,-60(fp)
81135fcc:	1080040b 	ldhu	r2,16(r2)
81135fd0:	1884703a 	and	r2,r3,r2
81135fd4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81135fd8:	e0bff60b 	ldhu	r2,-40(fp)
81135fdc:	10004326 	beq	r2,zero,811360ec <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81135fe0:	e0bff60b 	ldhu	r2,-40(fp)
81135fe4:	100b883a 	mov	r5,r2
81135fe8:	e13ff117 	ldw	r4,-60(fp)
81135fec:	11364ac0 	call	811364ac <OS_FlagTaskRdy>
81135ff0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81135ff4:	e0bff683 	ldbu	r2,-38(fp)
81135ff8:	10800058 	cmpnei	r2,r2,1
81135ffc:	10003b1e 	bne	r2,zero,811360ec <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81136000:	00800044 	movi	r2,1
81136004:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81136008:	00003806 	br	811360ec <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113600c:	e0bffc17 	ldw	r2,-16(fp)
81136010:	1080020b 	ldhu	r2,8(r2)
81136014:	0084303a 	nor	r2,zero,r2
81136018:	1007883a 	mov	r3,r2
8113601c:	e0bff117 	ldw	r2,-60(fp)
81136020:	1080040b 	ldhu	r2,16(r2)
81136024:	1884703a 	and	r2,r3,r2
81136028:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113602c:	e0bff117 	ldw	r2,-60(fp)
81136030:	1080040b 	ldhu	r2,16(r2)
81136034:	10ffffcc 	andi	r3,r2,65535
81136038:	e0bff60b 	ldhu	r2,-40(fp)
8113603c:	18802d1e 	bne	r3,r2,811360f4 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81136040:	e0bff60b 	ldhu	r2,-40(fp)
81136044:	100b883a 	mov	r5,r2
81136048:	e13ff117 	ldw	r4,-60(fp)
8113604c:	11364ac0 	call	811364ac <OS_FlagTaskRdy>
81136050:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81136054:	e0bff683 	ldbu	r2,-38(fp)
81136058:	10800058 	cmpnei	r2,r2,1
8113605c:	1000251e 	bne	r2,zero,811360f4 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81136060:	00800044 	movi	r2,1
81136064:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81136068:	00002206 	br	811360f4 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113606c:	e0bffc17 	ldw	r2,-16(fp)
81136070:	1080020b 	ldhu	r2,8(r2)
81136074:	0084303a 	nor	r2,zero,r2
81136078:	1007883a 	mov	r3,r2
8113607c:	e0bff117 	ldw	r2,-60(fp)
81136080:	1080040b 	ldhu	r2,16(r2)
81136084:	1884703a 	and	r2,r3,r2
81136088:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113608c:	e0bff60b 	ldhu	r2,-40(fp)
81136090:	10001a26 	beq	r2,zero,811360fc <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81136094:	e0bff60b 	ldhu	r2,-40(fp)
81136098:	100b883a 	mov	r5,r2
8113609c:	e13ff117 	ldw	r4,-60(fp)
811360a0:	11364ac0 	call	811364ac <OS_FlagTaskRdy>
811360a4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811360a8:	e0bff683 	ldbu	r2,-38(fp)
811360ac:	10800058 	cmpnei	r2,r2,1
811360b0:	1000121e 	bne	r2,zero,811360fc <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811360b4:	00800044 	movi	r2,1
811360b8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811360bc:	00000f06 	br	811360fc <OSFlagPost+0x308>
811360c0:	e0bff317 	ldw	r2,-52(fp)
811360c4:	e0bff515 	stw	r2,-44(fp)
811360c8:	e0bff517 	ldw	r2,-44(fp)
811360cc:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
811360d0:	e0bfff17 	ldw	r2,-4(fp)
811360d4:	00c01bc4 	movi	r3,111
811360d8:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
811360dc:	0005883a 	mov	r2,zero
811360e0:	00002606 	br	8113617c <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811360e4:	0001883a 	nop
811360e8:	00000506 	br	81136100 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811360ec:	0001883a 	nop
811360f0:	00000306 	br	81136100 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811360f4:	0001883a 	nop
811360f8:	00000106 	br	81136100 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811360fc:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
81136100:	e0bff117 	ldw	r2,-60(fp)
81136104:	10800017 	ldw	r2,0(r2)
81136108:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113610c:	e0bff117 	ldw	r2,-60(fp)
81136110:	103f871e 	bne	r2,zero,81135f30 <__reset+0xfb115f30>
81136114:	e0bff317 	ldw	r2,-52(fp)
81136118:	e0bff715 	stw	r2,-36(fp)
8113611c:	e0bff717 	ldw	r2,-36(fp)
81136120:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
81136124:	e0bff203 	ldbu	r2,-56(fp)
81136128:	10800058 	cmpnei	r2,r2,1
8113612c:	1000011e 	bne	r2,zero,81136134 <OSFlagPost+0x340>
        OS_Sched();
81136130:	11345bc0 	call	811345bc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136134:	0005303a 	rdctl	r2,status
81136138:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113613c:	e0fffa17 	ldw	r3,-24(fp)
81136140:	00bfff84 	movi	r2,-2
81136144:	1884703a 	and	r2,r3,r2
81136148:	1001703a 	wrctl	status,r2
  
  return context;
8113614c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
81136150:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
81136154:	e0bffc17 	ldw	r2,-16(fp)
81136158:	1080020b 	ldhu	r2,8(r2)
8113615c:	e0bff90d 	sth	r2,-28(fp)
81136160:	e0bff317 	ldw	r2,-52(fp)
81136164:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136168:	e0bff817 	ldw	r2,-32(fp)
8113616c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
81136170:	e0bfff17 	ldw	r2,-4(fp)
81136174:	10000005 	stb	zero,0(r2)
    return (flags_cur);
81136178:	e0bff90b 	ldhu	r2,-28(fp)
}
8113617c:	e037883a 	mov	sp,fp
81136180:	dfc00117 	ldw	ra,4(sp)
81136184:	df000017 	ldw	fp,0(sp)
81136188:	dec00204 	addi	sp,sp,8
8113618c:	f800283a 	ret

81136190 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
81136190:	defff904 	addi	sp,sp,-28
81136194:	de00012e 	bgeu	sp,et,8113619c <OSFlagQuery+0xc>
81136198:	003b68fa 	trap	3
8113619c:	df000615 	stw	fp,24(sp)
811361a0:	df000604 	addi	fp,sp,24
811361a4:	e13ffe15 	stw	r4,-8(fp)
811361a8:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
811361ac:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
811361b0:	e0bfff17 	ldw	r2,-4(fp)
811361b4:	1000021e 	bne	r2,zero,811361c0 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
811361b8:	0005883a 	mov	r2,zero
811361bc:	00002306 	br	8113624c <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
811361c0:	e0bffe17 	ldw	r2,-8(fp)
811361c4:	1000051e 	bne	r2,zero,811361dc <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811361c8:	e0bfff17 	ldw	r2,-4(fp)
811361cc:	00c01b84 	movi	r3,110
811361d0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811361d4:	0005883a 	mov	r2,zero
811361d8:	00001c06 	br	8113624c <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
811361dc:	e0bffe17 	ldw	r2,-8(fp)
811361e0:	10800003 	ldbu	r2,0(r2)
811361e4:	10803fcc 	andi	r2,r2,255
811361e8:	10800160 	cmpeqi	r2,r2,5
811361ec:	1000051e 	bne	r2,zero,81136204 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
811361f0:	e0bfff17 	ldw	r2,-4(fp)
811361f4:	00c00044 	movi	r3,1
811361f8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811361fc:	0005883a 	mov	r2,zero
81136200:	00001206 	br	8113624c <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136204:	0005303a 	rdctl	r2,status
81136208:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113620c:	e0fffc17 	ldw	r3,-16(fp)
81136210:	00bfff84 	movi	r2,-2
81136214:	1884703a 	and	r2,r3,r2
81136218:	1001703a 	wrctl	status,r2
  
  return context;
8113621c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136220:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
81136224:	e0bffe17 	ldw	r2,-8(fp)
81136228:	1080020b 	ldhu	r2,8(r2)
8113622c:	e0bffb0d 	sth	r2,-20(fp)
81136230:	e0bffa17 	ldw	r2,-24(fp)
81136234:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136238:	e0bffd17 	ldw	r2,-12(fp)
8113623c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136240:	e0bfff17 	ldw	r2,-4(fp)
81136244:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
81136248:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113624c:	e037883a 	mov	sp,fp
81136250:	df000017 	ldw	fp,0(sp)
81136254:	dec00104 	addi	sp,sp,4
81136258:	f800283a 	ret

8113625c <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113625c:	defff804 	addi	sp,sp,-32
81136260:	de00012e 	bgeu	sp,et,81136268 <OS_FlagBlock+0xc>
81136264:	003b68fa 	trap	3
81136268:	df000715 	stw	fp,28(sp)
8113626c:	df000704 	addi	fp,sp,28
81136270:	e13ffb15 	stw	r4,-20(fp)
81136274:	e17ffc15 	stw	r5,-16(fp)
81136278:	3009883a 	mov	r4,r6
8113627c:	3807883a 	mov	r3,r7
81136280:	e0800117 	ldw	r2,4(fp)
81136284:	e13ffd0d 	sth	r4,-12(fp)
81136288:	e0fffe05 	stb	r3,-8(fp)
8113628c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
81136290:	d0a09c17 	ldw	r2,-32144(gp)
81136294:	d0e09c17 	ldw	r3,-32144(gp)
81136298:	18c00c03 	ldbu	r3,48(r3)
8113629c:	18c00814 	ori	r3,r3,32
811362a0:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
811362a4:	d0a09c17 	ldw	r2,-32144(gp)
811362a8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
811362ac:	d0a09c17 	ldw	r2,-32144(gp)
811362b0:	e0ffff0b 	ldhu	r3,-4(fp)
811362b4:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
811362b8:	d0a09c17 	ldw	r2,-32144(gp)
811362bc:	e0fffc17 	ldw	r3,-16(fp)
811362c0:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
811362c4:	e0bffc17 	ldw	r2,-16(fp)
811362c8:	e0fffd0b 	ldhu	r3,-12(fp)
811362cc:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
811362d0:	e0bffc17 	ldw	r2,-16(fp)
811362d4:	e0fffe03 	ldbu	r3,-8(fp)
811362d8:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
811362dc:	d0e09c17 	ldw	r3,-32144(gp)
811362e0:	e0bffc17 	ldw	r2,-16(fp)
811362e4:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
811362e8:	e0bffb17 	ldw	r2,-20(fp)
811362ec:	10c00117 	ldw	r3,4(r2)
811362f0:	e0bffc17 	ldw	r2,-16(fp)
811362f4:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
811362f8:	e0bffc17 	ldw	r2,-16(fp)
811362fc:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
81136300:	e0bffc17 	ldw	r2,-16(fp)
81136304:	e0fffb17 	ldw	r3,-20(fp)
81136308:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113630c:	e0bffb17 	ldw	r2,-20(fp)
81136310:	10800117 	ldw	r2,4(r2)
81136314:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
81136318:	e0bff917 	ldw	r2,-28(fp)
8113631c:	10000326 	beq	r2,zero,8113632c <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
81136320:	e0bff917 	ldw	r2,-28(fp)
81136324:	e0fffc17 	ldw	r3,-16(fp)
81136328:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8113632c:	e0bffb17 	ldw	r2,-20(fp)
81136330:	e0fffc17 	ldw	r3,-16(fp)
81136334:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
81136338:	d0a09c17 	ldw	r2,-32144(gp)
8113633c:	10800d03 	ldbu	r2,52(r2)
81136340:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81136344:	e0fffa03 	ldbu	r3,-24(fp)
81136348:	e13ffa03 	ldbu	r4,-24(fp)
8113634c:	d0a09844 	addi	r2,gp,-32159
81136350:	2085883a 	add	r2,r4,r2
81136354:	10800003 	ldbu	r2,0(r2)
81136358:	1009883a 	mov	r4,r2
8113635c:	d0a09c17 	ldw	r2,-32144(gp)
81136360:	10800d43 	ldbu	r2,53(r2)
81136364:	0084303a 	nor	r2,zero,r2
81136368:	2084703a 	and	r2,r4,r2
8113636c:	1009883a 	mov	r4,r2
81136370:	d0a09844 	addi	r2,gp,-32159
81136374:	1885883a 	add	r2,r3,r2
81136378:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113637c:	e0fffa03 	ldbu	r3,-24(fp)
81136380:	d0a09844 	addi	r2,gp,-32159
81136384:	1885883a 	add	r2,r3,r2
81136388:	10800003 	ldbu	r2,0(r2)
8113638c:	10803fcc 	andi	r2,r2,255
81136390:	1000071e 	bne	r2,zero,811363b0 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81136394:	d0a09c17 	ldw	r2,-32144(gp)
81136398:	10800d83 	ldbu	r2,54(r2)
8113639c:	0084303a 	nor	r2,zero,r2
811363a0:	1007883a 	mov	r3,r2
811363a4:	d0a09803 	ldbu	r2,-32160(gp)
811363a8:	1884703a 	and	r2,r3,r2
811363ac:	d0a09805 	stb	r2,-32160(gp)
    }
}
811363b0:	0001883a 	nop
811363b4:	e037883a 	mov	sp,fp
811363b8:	df000017 	ldw	fp,0(sp)
811363bc:	dec00104 	addi	sp,sp,4
811363c0:	f800283a 	ret

811363c4 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
811363c4:	defffb04 	addi	sp,sp,-20
811363c8:	de00012e 	bgeu	sp,et,811363d0 <OS_FlagInit+0xc>
811363cc:	003b68fa 	trap	3
811363d0:	dfc00415 	stw	ra,16(sp)
811363d4:	df000315 	stw	fp,12(sp)
811363d8:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
811363dc:	01416004 	movi	r5,1408
811363e0:	012045b4 	movhi	r4,33046
811363e4:	21018e04 	addi	r4,r4,1592
811363e8:	11344f00 	call	811344f0 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
811363ec:	00a045b4 	movhi	r2,33046
811363f0:	10818e04 	addi	r2,r2,1592
811363f4:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
811363f8:	00a045b4 	movhi	r2,33046
811363fc:	10819904 	addi	r2,r2,1636
81136400:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81136404:	e03ffd0d 	sth	zero,-12(fp)
81136408:	00001306 	br	81136458 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113640c:	e0bffe17 	ldw	r2,-8(fp)
81136410:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
81136414:	e0bffe17 	ldw	r2,-8(fp)
81136418:	e0ffff17 	ldw	r3,-4(fp)
8113641c:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
81136420:	e0bffe17 	ldw	r2,-8(fp)
81136424:	00c00fc4 	movi	r3,63
81136428:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113642c:	e0bffe17 	ldw	r2,-8(fp)
81136430:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
81136434:	e0bffe17 	ldw	r2,-8(fp)
81136438:	10800b04 	addi	r2,r2,44
8113643c:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
81136440:	e0bfff17 	ldw	r2,-4(fp)
81136444:	10800b04 	addi	r2,r2,44
81136448:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113644c:	e0bffd0b 	ldhu	r2,-12(fp)
81136450:	10800044 	addi	r2,r2,1
81136454:	e0bffd0d 	sth	r2,-12(fp)
81136458:	e0bffd0b 	ldhu	r2,-12(fp)
8113645c:	108007f0 	cmpltui	r2,r2,31
81136460:	103fea1e 	bne	r2,zero,8113640c <__reset+0xfb11640c>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81136464:	e0bffe17 	ldw	r2,-8(fp)
81136468:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8113646c:	e0bffe17 	ldw	r2,-8(fp)
81136470:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
81136474:	e0bffe17 	ldw	r2,-8(fp)
81136478:	00c00fc4 	movi	r3,63
8113647c:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81136480:	e0bffe17 	ldw	r2,-8(fp)
81136484:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
81136488:	00a045b4 	movhi	r2,33046
8113648c:	10818e04 	addi	r2,r2,1592
81136490:	d0a0a015 	stw	r2,-32128(gp)
#endif
}
81136494:	0001883a 	nop
81136498:	e037883a 	mov	sp,fp
8113649c:	dfc00117 	ldw	ra,4(sp)
811364a0:	df000017 	ldw	fp,0(sp)
811364a4:	dec00204 	addi	sp,sp,8
811364a8:	f800283a 	ret

811364ac <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
811364ac:	defffa04 	addi	sp,sp,-24
811364b0:	de00012e 	bgeu	sp,et,811364b8 <OS_FlagTaskRdy+0xc>
811364b4:	003b68fa 	trap	3
811364b8:	dfc00515 	stw	ra,20(sp)
811364bc:	df000415 	stw	fp,16(sp)
811364c0:	df000404 	addi	fp,sp,16
811364c4:	e13ffe15 	stw	r4,-8(fp)
811364c8:	2805883a 	mov	r2,r5
811364cc:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
811364d0:	e0bffe17 	ldw	r2,-8(fp)
811364d4:	10800217 	ldw	r2,8(r2)
811364d8:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
811364dc:	e0bffd17 	ldw	r2,-12(fp)
811364e0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
811364e4:	e0bffd17 	ldw	r2,-12(fp)
811364e8:	e0ffff0b 	ldhu	r3,-4(fp)
811364ec:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
811364f0:	e0bffd17 	ldw	r2,-12(fp)
811364f4:	10c00c03 	ldbu	r3,48(r2)
811364f8:	00bff7c4 	movi	r2,-33
811364fc:	1884703a 	and	r2,r3,r2
81136500:	1007883a 	mov	r3,r2
81136504:	e0bffd17 	ldw	r2,-12(fp)
81136508:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8113650c:	e0bffd17 	ldw	r2,-12(fp)
81136510:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
81136514:	e0bffd17 	ldw	r2,-12(fp)
81136518:	10800c03 	ldbu	r2,48(r2)
8113651c:	10803fcc 	andi	r2,r2,255
81136520:	1000181e 	bne	r2,zero,81136584 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
81136524:	e0bffd17 	ldw	r2,-12(fp)
81136528:	10c00d83 	ldbu	r3,54(r2)
8113652c:	d0a09803 	ldbu	r2,-32160(gp)
81136530:	1884b03a 	or	r2,r3,r2
81136534:	d0a09805 	stb	r2,-32160(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81136538:	e0bffd17 	ldw	r2,-12(fp)
8113653c:	10800d03 	ldbu	r2,52(r2)
81136540:	10c03fcc 	andi	r3,r2,255
81136544:	e0bffd17 	ldw	r2,-12(fp)
81136548:	10800d03 	ldbu	r2,52(r2)
8113654c:	11003fcc 	andi	r4,r2,255
81136550:	d0a09844 	addi	r2,gp,-32159
81136554:	2085883a 	add	r2,r4,r2
81136558:	11000003 	ldbu	r4,0(r2)
8113655c:	e0bffd17 	ldw	r2,-12(fp)
81136560:	10800d43 	ldbu	r2,53(r2)
81136564:	2084b03a 	or	r2,r4,r2
81136568:	1009883a 	mov	r4,r2
8113656c:	d0a09844 	addi	r2,gp,-32159
81136570:	1885883a 	add	r2,r3,r2
81136574:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
81136578:	00800044 	movi	r2,1
8113657c:	e0bffc05 	stb	r2,-16(fp)
81136580:	00000106 	br	81136588 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81136584:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
81136588:	e13ffe17 	ldw	r4,-8(fp)
8113658c:	11365a80 	call	811365a8 <OS_FlagUnlink>
    return (sched);
81136590:	e0bffc03 	ldbu	r2,-16(fp)
}
81136594:	e037883a 	mov	sp,fp
81136598:	dfc00117 	ldw	ra,4(sp)
8113659c:	df000017 	ldw	fp,0(sp)
811365a0:	dec00204 	addi	sp,sp,8
811365a4:	f800283a 	ret

811365a8 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
811365a8:	defffa04 	addi	sp,sp,-24
811365ac:	de00012e 	bgeu	sp,et,811365b4 <OS_FlagUnlink+0xc>
811365b0:	003b68fa 	trap	3
811365b4:	df000515 	stw	fp,20(sp)
811365b8:	df000504 	addi	fp,sp,20
811365bc:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
811365c0:	e0bfff17 	ldw	r2,-4(fp)
811365c4:	10800117 	ldw	r2,4(r2)
811365c8:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
811365cc:	e0bfff17 	ldw	r2,-4(fp)
811365d0:	10800017 	ldw	r2,0(r2)
811365d4:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
811365d8:	e0bffb17 	ldw	r2,-20(fp)
811365dc:	10000b1e 	bne	r2,zero,8113660c <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
811365e0:	e0bfff17 	ldw	r2,-4(fp)
811365e4:	10800317 	ldw	r2,12(r2)
811365e8:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
811365ec:	e0bffd17 	ldw	r2,-12(fp)
811365f0:	e0fffc17 	ldw	r3,-16(fp)
811365f4:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
811365f8:	e0bffc17 	ldw	r2,-16(fp)
811365fc:	10000b26 	beq	r2,zero,8113662c <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
81136600:	e0bffc17 	ldw	r2,-16(fp)
81136604:	10000115 	stw	zero,4(r2)
81136608:	00000806 	br	8113662c <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8113660c:	e0bffb17 	ldw	r2,-20(fp)
81136610:	e0fffc17 	ldw	r3,-16(fp)
81136614:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
81136618:	e0bffc17 	ldw	r2,-16(fp)
8113661c:	10000326 	beq	r2,zero,8113662c <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
81136620:	e0bffc17 	ldw	r2,-16(fp)
81136624:	e0fffb17 	ldw	r3,-20(fp)
81136628:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8113662c:	e0bfff17 	ldw	r2,-4(fp)
81136630:	10800217 	ldw	r2,8(r2)
81136634:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
81136638:	e0bffe17 	ldw	r2,-8(fp)
8113663c:	10000a15 	stw	zero,40(r2)
#endif
}
81136640:	0001883a 	nop
81136644:	e037883a 	mov	sp,fp
81136648:	df000017 	ldw	fp,0(sp)
8113664c:	dec00104 	addi	sp,sp,4
81136650:	f800283a 	ret

81136654 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
81136654:	defff404 	addi	sp,sp,-48
81136658:	de00012e 	bgeu	sp,et,81136660 <OSMemCreate+0xc>
8113665c:	003b68fa 	trap	3
81136660:	df000b15 	stw	fp,44(sp)
81136664:	df000b04 	addi	fp,sp,44
81136668:	e13ffc15 	stw	r4,-16(fp)
8113666c:	e17ffd15 	stw	r5,-12(fp)
81136670:	e1bffe15 	stw	r6,-8(fp)
81136674:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81136678:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113667c:	e0bfff17 	ldw	r2,-4(fp)
81136680:	1000021e 	bne	r2,zero,8113668c <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81136684:	0005883a 	mov	r2,zero
81136688:	00006506 	br	81136820 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8113668c:	e0bffc17 	ldw	r2,-16(fp)
81136690:	1000051e 	bne	r2,zero,811366a8 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81136694:	e0bfff17 	ldw	r2,-4(fp)
81136698:	00c01884 	movi	r3,98
8113669c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811366a0:	0005883a 	mov	r2,zero
811366a4:	00005e06 	br	81136820 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
811366a8:	e0bffc17 	ldw	r2,-16(fp)
811366ac:	108000cc 	andi	r2,r2,3
811366b0:	10000526 	beq	r2,zero,811366c8 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
811366b4:	e0bfff17 	ldw	r2,-4(fp)
811366b8:	00c01884 	movi	r3,98
811366bc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811366c0:	0005883a 	mov	r2,zero
811366c4:	00005606 	br	81136820 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
811366c8:	e0bffd17 	ldw	r2,-12(fp)
811366cc:	108000a8 	cmpgeui	r2,r2,2
811366d0:	1000051e 	bne	r2,zero,811366e8 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
811366d4:	e0bfff17 	ldw	r2,-4(fp)
811366d8:	00c016c4 	movi	r3,91
811366dc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811366e0:	0005883a 	mov	r2,zero
811366e4:	00004e06 	br	81136820 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
811366e8:	e0bffe17 	ldw	r2,-8(fp)
811366ec:	10800128 	cmpgeui	r2,r2,4
811366f0:	1000051e 	bne	r2,zero,81136708 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
811366f4:	e0bfff17 	ldw	r2,-4(fp)
811366f8:	00c01704 	movi	r3,92
811366fc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81136700:	0005883a 	mov	r2,zero
81136704:	00004606 	br	81136820 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136708:	0005303a 	rdctl	r2,status
8113670c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136710:	e0fffb17 	ldw	r3,-20(fp)
81136714:	00bfff84 	movi	r2,-2
81136718:	1884703a 	and	r2,r3,r2
8113671c:	1001703a 	wrctl	status,r2
  
  return context;
81136720:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81136724:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
81136728:	d0a09517 	ldw	r2,-32172(gp)
8113672c:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
81136730:	d0a09517 	ldw	r2,-32172(gp)
81136734:	10000326 	beq	r2,zero,81136744 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
81136738:	d0a09517 	ldw	r2,-32172(gp)
8113673c:	10800117 	ldw	r2,4(r2)
81136740:	d0a09515 	stw	r2,-32172(gp)
81136744:	e0bff817 	ldw	r2,-32(fp)
81136748:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113674c:	e0bff917 	ldw	r2,-28(fp)
81136750:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
81136754:	e0bffa17 	ldw	r2,-24(fp)
81136758:	1000051e 	bne	r2,zero,81136770 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8113675c:	e0bfff17 	ldw	r2,-4(fp)
81136760:	00c01684 	movi	r3,90
81136764:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81136768:	0005883a 	mov	r2,zero
8113676c:	00002c06 	br	81136820 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
81136770:	e0bffc17 	ldw	r2,-16(fp)
81136774:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
81136778:	e0fffc17 	ldw	r3,-16(fp)
8113677c:	e0bffe17 	ldw	r2,-8(fp)
81136780:	1885883a 	add	r2,r3,r2
81136784:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81136788:	e03ff715 	stw	zero,-36(fp)
8113678c:	00000c06 	br	811367c0 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
81136790:	e0bff617 	ldw	r2,-40(fp)
81136794:	e0fff517 	ldw	r3,-44(fp)
81136798:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8113679c:	e0bff517 	ldw	r2,-44(fp)
811367a0:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
811367a4:	e0fff517 	ldw	r3,-44(fp)
811367a8:	e0bffe17 	ldw	r2,-8(fp)
811367ac:	1885883a 	add	r2,r3,r2
811367b0:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
811367b4:	e0bff717 	ldw	r2,-36(fp)
811367b8:	10800044 	addi	r2,r2,1
811367bc:	e0bff715 	stw	r2,-36(fp)
811367c0:	e0bffd17 	ldw	r2,-12(fp)
811367c4:	10bfffc4 	addi	r2,r2,-1
811367c8:	e0fff717 	ldw	r3,-36(fp)
811367cc:	18bff036 	bltu	r3,r2,81136790 <__reset+0xfb116790>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
811367d0:	e0bff617 	ldw	r2,-40(fp)
811367d4:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
811367d8:	e0bffa17 	ldw	r2,-24(fp)
811367dc:	e0fffc17 	ldw	r3,-16(fp)
811367e0:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
811367e4:	e0bffa17 	ldw	r2,-24(fp)
811367e8:	e0fffc17 	ldw	r3,-16(fp)
811367ec:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
811367f0:	e0bffa17 	ldw	r2,-24(fp)
811367f4:	e0fffd17 	ldw	r3,-12(fp)
811367f8:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
811367fc:	e0bffa17 	ldw	r2,-24(fp)
81136800:	e0fffd17 	ldw	r3,-12(fp)
81136804:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81136808:	e0bffa17 	ldw	r2,-24(fp)
8113680c:	e0fffe17 	ldw	r3,-8(fp)
81136810:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
81136814:	e0bfff17 	ldw	r2,-4(fp)
81136818:	10000005 	stb	zero,0(r2)
    return (pmem);
8113681c:	e0bffa17 	ldw	r2,-24(fp)
}
81136820:	e037883a 	mov	sp,fp
81136824:	df000017 	ldw	fp,0(sp)
81136828:	dec00104 	addi	sp,sp,4
8113682c:	f800283a 	ret

81136830 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
81136830:	defff804 	addi	sp,sp,-32
81136834:	de00012e 	bgeu	sp,et,8113683c <OSMemGet+0xc>
81136838:	003b68fa 	trap	3
8113683c:	df000715 	stw	fp,28(sp)
81136840:	df000704 	addi	fp,sp,28
81136844:	e13ffe15 	stw	r4,-8(fp)
81136848:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113684c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81136850:	e0bfff17 	ldw	r2,-4(fp)
81136854:	1000021e 	bne	r2,zero,81136860 <OSMemGet+0x30>
        return ((void *)0);
81136858:	0005883a 	mov	r2,zero
8113685c:	00002e06 	br	81136918 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
81136860:	e0bffe17 	ldw	r2,-8(fp)
81136864:	1000051e 	bne	r2,zero,8113687c <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81136868:	e0bfff17 	ldw	r2,-4(fp)
8113686c:	00c01804 	movi	r3,96
81136870:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81136874:	0005883a 	mov	r2,zero
81136878:	00002706 	br	81136918 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113687c:	0005303a 	rdctl	r2,status
81136880:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136884:	e0fffd17 	ldw	r3,-12(fp)
81136888:	00bfff84 	movi	r2,-2
8113688c:	1884703a 	and	r2,r3,r2
81136890:	1001703a 	wrctl	status,r2
  
  return context;
81136894:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81136898:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8113689c:	e0bffe17 	ldw	r2,-8(fp)
811368a0:	10800417 	ldw	r2,16(r2)
811368a4:	10001426 	beq	r2,zero,811368f8 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
811368a8:	e0bffe17 	ldw	r2,-8(fp)
811368ac:	10800117 	ldw	r2,4(r2)
811368b0:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
811368b4:	e0bffb17 	ldw	r2,-20(fp)
811368b8:	10c00017 	ldw	r3,0(r2)
811368bc:	e0bffe17 	ldw	r2,-8(fp)
811368c0:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
811368c4:	e0bffe17 	ldw	r2,-8(fp)
811368c8:	10800417 	ldw	r2,16(r2)
811368cc:	10ffffc4 	addi	r3,r2,-1
811368d0:	e0bffe17 	ldw	r2,-8(fp)
811368d4:	10c00415 	stw	r3,16(r2)
811368d8:	e0bff917 	ldw	r2,-28(fp)
811368dc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811368e0:	e0bffa17 	ldw	r2,-24(fp)
811368e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
811368e8:	e0bfff17 	ldw	r2,-4(fp)
811368ec:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
811368f0:	e0bffb17 	ldw	r2,-20(fp)
811368f4:	00000806 	br	81136918 <OSMemGet+0xe8>
811368f8:	e0bff917 	ldw	r2,-28(fp)
811368fc:	e0bffc15 	stw	r2,-16(fp)
81136900:	e0bffc17 	ldw	r2,-16(fp)
81136904:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81136908:	e0bfff17 	ldw	r2,-4(fp)
8113690c:	00c01744 	movi	r3,93
81136910:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
81136914:	0005883a 	mov	r2,zero
}
81136918:	e037883a 	mov	sp,fp
8113691c:	df000017 	ldw	fp,0(sp)
81136920:	dec00104 	addi	sp,sp,4
81136924:	f800283a 	ret

81136928 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81136928:	defff704 	addi	sp,sp,-36
8113692c:	de00012e 	bgeu	sp,et,81136934 <OSMemNameGet+0xc>
81136930:	003b68fa 	trap	3
81136934:	dfc00815 	stw	ra,32(sp)
81136938:	df000715 	stw	fp,28(sp)
8113693c:	df000704 	addi	fp,sp,28
81136940:	e13ffd15 	stw	r4,-12(fp)
81136944:	e17ffe15 	stw	r5,-8(fp)
81136948:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113694c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81136950:	e0bfff17 	ldw	r2,-4(fp)
81136954:	1000021e 	bne	r2,zero,81136960 <OSMemNameGet+0x38>
        return (0);
81136958:	0005883a 	mov	r2,zero
8113695c:	00002b06 	br	81136a0c <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81136960:	e0bffd17 	ldw	r2,-12(fp)
81136964:	1000051e 	bne	r2,zero,8113697c <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81136968:	e0bfff17 	ldw	r2,-4(fp)
8113696c:	00c01804 	movi	r3,96
81136970:	10c00005 	stb	r3,0(r2)
        return (0);
81136974:	0005883a 	mov	r2,zero
81136978:	00002406 	br	81136a0c <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113697c:	e0bffe17 	ldw	r2,-8(fp)
81136980:	1000051e 	bne	r2,zero,81136998 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81136984:	e0bfff17 	ldw	r2,-4(fp)
81136988:	00c00304 	movi	r3,12
8113698c:	10c00005 	stb	r3,0(r2)
        return (0);
81136990:	0005883a 	mov	r2,zero
81136994:	00001d06 	br	81136a0c <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136998:	d0a09b03 	ldbu	r2,-32148(gp)
8113699c:	10803fcc 	andi	r2,r2,255
811369a0:	10000526 	beq	r2,zero,811369b8 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
811369a4:	e0bfff17 	ldw	r2,-4(fp)
811369a8:	00c00444 	movi	r3,17
811369ac:	10c00005 	stb	r3,0(r2)
        return (0);
811369b0:	0005883a 	mov	r2,zero
811369b4:	00001506 	br	81136a0c <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811369b8:	0005303a 	rdctl	r2,status
811369bc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811369c0:	e0fffb17 	ldw	r3,-20(fp)
811369c4:	00bfff84 	movi	r2,-2
811369c8:	1884703a 	and	r2,r3,r2
811369cc:	1001703a 	wrctl	status,r2
  
  return context;
811369d0:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
811369d4:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
811369d8:	e0bffd17 	ldw	r2,-12(fp)
811369dc:	10800504 	addi	r2,r2,20
811369e0:	100b883a 	mov	r5,r2
811369e4:	e13ffe17 	ldw	r4,-8(fp)
811369e8:	11347100 	call	81134710 <OS_StrCopy>
811369ec:	e0bffa05 	stb	r2,-24(fp)
811369f0:	e0bff917 	ldw	r2,-28(fp)
811369f4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811369f8:	e0bffc17 	ldw	r2,-16(fp)
811369fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136a00:	e0bfff17 	ldw	r2,-4(fp)
81136a04:	10000005 	stb	zero,0(r2)
    return (len);
81136a08:	e0bffa03 	ldbu	r2,-24(fp)
}
81136a0c:	e037883a 	mov	sp,fp
81136a10:	dfc00117 	ldw	ra,4(sp)
81136a14:	df000017 	ldw	fp,0(sp)
81136a18:	dec00204 	addi	sp,sp,8
81136a1c:	f800283a 	ret

81136a20 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81136a20:	defff604 	addi	sp,sp,-40
81136a24:	de00012e 	bgeu	sp,et,81136a2c <OSMemNameSet+0xc>
81136a28:	003b68fa 	trap	3
81136a2c:	dfc00915 	stw	ra,36(sp)
81136a30:	df000815 	stw	fp,32(sp)
81136a34:	df000804 	addi	fp,sp,32
81136a38:	e13ffd15 	stw	r4,-12(fp)
81136a3c:	e17ffe15 	stw	r5,-8(fp)
81136a40:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136a44:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81136a48:	e0bfff17 	ldw	r2,-4(fp)
81136a4c:	10003526 	beq	r2,zero,81136b24 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81136a50:	e0bffd17 	ldw	r2,-12(fp)
81136a54:	1000041e 	bne	r2,zero,81136a68 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81136a58:	e0bfff17 	ldw	r2,-4(fp)
81136a5c:	00c01804 	movi	r3,96
81136a60:	10c00005 	stb	r3,0(r2)
        return;
81136a64:	00003006 	br	81136b28 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81136a68:	e0bffe17 	ldw	r2,-8(fp)
81136a6c:	1000041e 	bne	r2,zero,81136a80 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81136a70:	e0bfff17 	ldw	r2,-4(fp)
81136a74:	00c00304 	movi	r3,12
81136a78:	10c00005 	stb	r3,0(r2)
        return;
81136a7c:	00002a06 	br	81136b28 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136a80:	d0a09b03 	ldbu	r2,-32148(gp)
81136a84:	10803fcc 	andi	r2,r2,255
81136a88:	10000426 	beq	r2,zero,81136a9c <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81136a8c:	e0bfff17 	ldw	r2,-4(fp)
81136a90:	00c00484 	movi	r3,18
81136a94:	10c00005 	stb	r3,0(r2)
        return;
81136a98:	00002306 	br	81136b28 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136a9c:	0005303a 	rdctl	r2,status
81136aa0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136aa4:	e0fffc17 	ldw	r3,-16(fp)
81136aa8:	00bfff84 	movi	r2,-2
81136aac:	1884703a 	and	r2,r3,r2
81136ab0:	1001703a 	wrctl	status,r2
  
  return context;
81136ab4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136ab8:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81136abc:	e13ffe17 	ldw	r4,-8(fp)
81136ac0:	113478c0 	call	8113478c <OS_StrLen>
81136ac4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
81136ac8:	e0bffa03 	ldbu	r2,-24(fp)
81136acc:	10800830 	cmpltui	r2,r2,32
81136ad0:	1000081e 	bne	r2,zero,81136af4 <OSMemNameSet+0xd4>
81136ad4:	e0bff817 	ldw	r2,-32(fp)
81136ad8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136adc:	e0bff917 	ldw	r2,-28(fp)
81136ae0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
81136ae4:	e0bfff17 	ldw	r2,-4(fp)
81136ae8:	00c018c4 	movi	r3,99
81136aec:	10c00005 	stb	r3,0(r2)
        return;
81136af0:	00000d06 	br	81136b28 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
81136af4:	e0bffd17 	ldw	r2,-12(fp)
81136af8:	10800504 	addi	r2,r2,20
81136afc:	e17ffe17 	ldw	r5,-8(fp)
81136b00:	1009883a 	mov	r4,r2
81136b04:	11347100 	call	81134710 <OS_StrCopy>
81136b08:	e0bff817 	ldw	r2,-32(fp)
81136b0c:	e0bffb15 	stw	r2,-20(fp)
81136b10:	e0bffb17 	ldw	r2,-20(fp)
81136b14:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136b18:	e0bfff17 	ldw	r2,-4(fp)
81136b1c:	10000005 	stb	zero,0(r2)
81136b20:	00000106 	br	81136b28 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81136b24:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81136b28:	e037883a 	mov	sp,fp
81136b2c:	dfc00117 	ldw	ra,4(sp)
81136b30:	df000017 	ldw	fp,0(sp)
81136b34:	dec00204 	addi	sp,sp,8
81136b38:	f800283a 	ret

81136b3c <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
81136b3c:	defff904 	addi	sp,sp,-28
81136b40:	de00012e 	bgeu	sp,et,81136b48 <OSMemPut+0xc>
81136b44:	003b68fa 	trap	3
81136b48:	df000615 	stw	fp,24(sp)
81136b4c:	df000604 	addi	fp,sp,24
81136b50:	e13ffe15 	stw	r4,-8(fp)
81136b54:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136b58:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81136b5c:	e0bffe17 	ldw	r2,-8(fp)
81136b60:	1000021e 	bne	r2,zero,81136b6c <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81136b64:	00801804 	movi	r2,96
81136b68:	00002806 	br	81136c0c <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
81136b6c:	e0bfff17 	ldw	r2,-4(fp)
81136b70:	1000021e 	bne	r2,zero,81136b7c <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
81136b74:	008017c4 	movi	r2,95
81136b78:	00002406 	br	81136c0c <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136b7c:	0005303a 	rdctl	r2,status
81136b80:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136b84:	e0fffd17 	ldw	r3,-12(fp)
81136b88:	00bfff84 	movi	r2,-2
81136b8c:	1884703a 	and	r2,r3,r2
81136b90:	1001703a 	wrctl	status,r2
  
  return context;
81136b94:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81136b98:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
81136b9c:	e0bffe17 	ldw	r2,-8(fp)
81136ba0:	10c00417 	ldw	r3,16(r2)
81136ba4:	e0bffe17 	ldw	r2,-8(fp)
81136ba8:	10800317 	ldw	r2,12(r2)
81136bac:	18800636 	bltu	r3,r2,81136bc8 <OSMemPut+0x8c>
81136bb0:	e0bffa17 	ldw	r2,-24(fp)
81136bb4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136bb8:	e0bffb17 	ldw	r2,-20(fp)
81136bbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
81136bc0:	00801784 	movi	r2,94
81136bc4:	00001106 	br	81136c0c <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
81136bc8:	e0bffe17 	ldw	r2,-8(fp)
81136bcc:	10c00117 	ldw	r3,4(r2)
81136bd0:	e0bfff17 	ldw	r2,-4(fp)
81136bd4:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
81136bd8:	e0bffe17 	ldw	r2,-8(fp)
81136bdc:	e0ffff17 	ldw	r3,-4(fp)
81136be0:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
81136be4:	e0bffe17 	ldw	r2,-8(fp)
81136be8:	10800417 	ldw	r2,16(r2)
81136bec:	10c00044 	addi	r3,r2,1
81136bf0:	e0bffe17 	ldw	r2,-8(fp)
81136bf4:	10c00415 	stw	r3,16(r2)
81136bf8:	e0bffa17 	ldw	r2,-24(fp)
81136bfc:	e0bffc15 	stw	r2,-16(fp)
81136c00:	e0bffc17 	ldw	r2,-16(fp)
81136c04:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
81136c08:	0005883a 	mov	r2,zero
}
81136c0c:	e037883a 	mov	sp,fp
81136c10:	df000017 	ldw	fp,0(sp)
81136c14:	dec00104 	addi	sp,sp,4
81136c18:	f800283a 	ret

81136c1c <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
81136c1c:	defffa04 	addi	sp,sp,-24
81136c20:	de00012e 	bgeu	sp,et,81136c28 <OSMemQuery+0xc>
81136c24:	003b68fa 	trap	3
81136c28:	df000515 	stw	fp,20(sp)
81136c2c:	df000504 	addi	fp,sp,20
81136c30:	e13ffe15 	stw	r4,-8(fp)
81136c34:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136c38:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81136c3c:	e0bffe17 	ldw	r2,-8(fp)
81136c40:	1000021e 	bne	r2,zero,81136c4c <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81136c44:	00801804 	movi	r2,96
81136c48:	00002c06 	br	81136cfc <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
81136c4c:	e0bfff17 	ldw	r2,-4(fp)
81136c50:	1000021e 	bne	r2,zero,81136c5c <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
81136c54:	00801844 	movi	r2,97
81136c58:	00002806 	br	81136cfc <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136c5c:	0005303a 	rdctl	r2,status
81136c60:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136c64:	e0fffc17 	ldw	r3,-16(fp)
81136c68:	00bfff84 	movi	r2,-2
81136c6c:	1884703a 	and	r2,r3,r2
81136c70:	1001703a 	wrctl	status,r2
  
  return context;
81136c74:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81136c78:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
81136c7c:	e0bffe17 	ldw	r2,-8(fp)
81136c80:	10c00017 	ldw	r3,0(r2)
81136c84:	e0bfff17 	ldw	r2,-4(fp)
81136c88:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
81136c8c:	e0bffe17 	ldw	r2,-8(fp)
81136c90:	10c00117 	ldw	r3,4(r2)
81136c94:	e0bfff17 	ldw	r2,-4(fp)
81136c98:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
81136c9c:	e0bffe17 	ldw	r2,-8(fp)
81136ca0:	10c00217 	ldw	r3,8(r2)
81136ca4:	e0bfff17 	ldw	r2,-4(fp)
81136ca8:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
81136cac:	e0bffe17 	ldw	r2,-8(fp)
81136cb0:	10c00317 	ldw	r3,12(r2)
81136cb4:	e0bfff17 	ldw	r2,-4(fp)
81136cb8:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
81136cbc:	e0bffe17 	ldw	r2,-8(fp)
81136cc0:	10c00417 	ldw	r3,16(r2)
81136cc4:	e0bfff17 	ldw	r2,-4(fp)
81136cc8:	10c00415 	stw	r3,16(r2)
81136ccc:	e0bffb17 	ldw	r2,-20(fp)
81136cd0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136cd4:	e0bffd17 	ldw	r2,-12(fp)
81136cd8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
81136cdc:	e0bfff17 	ldw	r2,-4(fp)
81136ce0:	10c00317 	ldw	r3,12(r2)
81136ce4:	e0bfff17 	ldw	r2,-4(fp)
81136ce8:	10800417 	ldw	r2,16(r2)
81136cec:	1887c83a 	sub	r3,r3,r2
81136cf0:	e0bfff17 	ldw	r2,-4(fp)
81136cf4:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
81136cf8:	0005883a 	mov	r2,zero
}
81136cfc:	e037883a 	mov	sp,fp
81136d00:	df000017 	ldw	fp,0(sp)
81136d04:	dec00104 	addi	sp,sp,4
81136d08:	f800283a 	ret

81136d0c <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
81136d0c:	defffc04 	addi	sp,sp,-16
81136d10:	de00012e 	bgeu	sp,et,81136d18 <OS_MemInit+0xc>
81136d14:	003b68fa 	trap	3
81136d18:	dfc00315 	stw	ra,12(sp)
81136d1c:	df000215 	stw	fp,8(sp)
81136d20:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
81136d24:	01430c04 	movi	r5,3120
81136d28:	012045b4 	movhi	r4,33046
81136d2c:	21035604 	addi	r4,r4,3416
81136d30:	11344f00 	call	811344f0 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
81136d34:	00a045b4 	movhi	r2,33046
81136d38:	10835604 	addi	r2,r2,3416
81136d3c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81136d40:	e03fff0d 	sth	zero,-4(fp)
81136d44:	00001306 	br	81136d94 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
81136d48:	e0bfff0b 	ldhu	r2,-4(fp)
81136d4c:	10800044 	addi	r2,r2,1
81136d50:	10c00d24 	muli	r3,r2,52
81136d54:	00a045b4 	movhi	r2,33046
81136d58:	10835604 	addi	r2,r2,3416
81136d5c:	1887883a 	add	r3,r3,r2
81136d60:	e0bffe17 	ldw	r2,-8(fp)
81136d64:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
81136d68:	e0bffe17 	ldw	r2,-8(fp)
81136d6c:	00c00fc4 	movi	r3,63
81136d70:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
81136d74:	e0bffe17 	ldw	r2,-8(fp)
81136d78:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
81136d7c:	e0bffe17 	ldw	r2,-8(fp)
81136d80:	10800d04 	addi	r2,r2,52
81136d84:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81136d88:	e0bfff0b 	ldhu	r2,-4(fp)
81136d8c:	10800044 	addi	r2,r2,1
81136d90:	e0bfff0d 	sth	r2,-4(fp)
81136d94:	e0bfff0b 	ldhu	r2,-4(fp)
81136d98:	10800ef0 	cmpltui	r2,r2,59
81136d9c:	103fea1e 	bne	r2,zero,81136d48 <__reset+0xfb116d48>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
81136da0:	e0bffe17 	ldw	r2,-8(fp)
81136da4:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
81136da8:	e0bffe17 	ldw	r2,-8(fp)
81136dac:	00c00fc4 	movi	r3,63
81136db0:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
81136db4:	e0bffe17 	ldw	r2,-8(fp)
81136db8:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
81136dbc:	00a045b4 	movhi	r2,33046
81136dc0:	10835604 	addi	r2,r2,3416
81136dc4:	d0a09515 	stw	r2,-32172(gp)
#endif
}
81136dc8:	0001883a 	nop
81136dcc:	e037883a 	mov	sp,fp
81136dd0:	dfc00117 	ldw	ra,4(sp)
81136dd4:	df000017 	ldw	fp,0(sp)
81136dd8:	dec00204 	addi	sp,sp,8
81136ddc:	f800283a 	ret

81136de0 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
81136de0:	defff704 	addi	sp,sp,-36
81136de4:	de00012e 	bgeu	sp,et,81136dec <OSMutexAccept+0xc>
81136de8:	003b68fa 	trap	3
81136dec:	df000815 	stw	fp,32(sp)
81136df0:	df000804 	addi	fp,sp,32
81136df4:	e13ffe15 	stw	r4,-8(fp)
81136df8:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81136dfc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
81136e00:	e0bfff17 	ldw	r2,-4(fp)
81136e04:	1000021e 	bne	r2,zero,81136e10 <OSMutexAccept+0x30>
        return (OS_FALSE);
81136e08:	0005883a 	mov	r2,zero
81136e0c:	00005b06 	br	81136f7c <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81136e10:	e0bffe17 	ldw	r2,-8(fp)
81136e14:	1000051e 	bne	r2,zero,81136e2c <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81136e18:	e0bfff17 	ldw	r2,-4(fp)
81136e1c:	00c00104 	movi	r3,4
81136e20:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81136e24:	0005883a 	mov	r2,zero
81136e28:	00005406 	br	81136f7c <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
81136e2c:	e0bffe17 	ldw	r2,-8(fp)
81136e30:	10800003 	ldbu	r2,0(r2)
81136e34:	10803fcc 	andi	r2,r2,255
81136e38:	10800120 	cmpeqi	r2,r2,4
81136e3c:	1000051e 	bne	r2,zero,81136e54 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81136e40:	e0bfff17 	ldw	r2,-4(fp)
81136e44:	00c00044 	movi	r3,1
81136e48:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81136e4c:	0005883a 	mov	r2,zero
81136e50:	00004a06 	br	81136f7c <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
81136e54:	d0a09b03 	ldbu	r2,-32148(gp)
81136e58:	10803fcc 	andi	r2,r2,255
81136e5c:	10000526 	beq	r2,zero,81136e74 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
81136e60:	e0bfff17 	ldw	r2,-4(fp)
81136e64:	00c00084 	movi	r3,2
81136e68:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81136e6c:	0005883a 	mov	r2,zero
81136e70:	00004206 	br	81136f7c <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136e74:	0005303a 	rdctl	r2,status
81136e78:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136e7c:	e0fffd17 	ldw	r3,-12(fp)
81136e80:	00bfff84 	movi	r2,-2
81136e84:	1884703a 	and	r2,r3,r2
81136e88:	1001703a 	wrctl	status,r2
  
  return context;
81136e8c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
81136e90:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
81136e94:	e0bffe17 	ldw	r2,-8(fp)
81136e98:	1080020b 	ldhu	r2,8(r2)
81136e9c:	10bfffcc 	andi	r2,r2,65535
81136ea0:	1004d23a 	srli	r2,r2,8
81136ea4:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81136ea8:	e0bffe17 	ldw	r2,-8(fp)
81136eac:	1080020b 	ldhu	r2,8(r2)
81136eb0:	10bfffcc 	andi	r2,r2,65535
81136eb4:	10803fcc 	andi	r2,r2,255
81136eb8:	10803fd8 	cmpnei	r2,r2,255
81136ebc:	1000281e 	bne	r2,zero,81136f60 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
81136ec0:	e0bffe17 	ldw	r2,-8(fp)
81136ec4:	10c0020b 	ldhu	r3,8(r2)
81136ec8:	00bfc004 	movi	r2,-256
81136ecc:	1884703a 	and	r2,r3,r2
81136ed0:	1007883a 	mov	r3,r2
81136ed4:	e0bffe17 	ldw	r2,-8(fp)
81136ed8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
81136edc:	e0bffe17 	ldw	r2,-8(fp)
81136ee0:	10c0020b 	ldhu	r3,8(r2)
81136ee4:	d0a09c17 	ldw	r2,-32144(gp)
81136ee8:	10800c83 	ldbu	r2,50(r2)
81136eec:	10803fcc 	andi	r2,r2,255
81136ef0:	1884b03a 	or	r2,r3,r2
81136ef4:	1007883a 	mov	r3,r2
81136ef8:	e0bffe17 	ldw	r2,-8(fp)
81136efc:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
81136f00:	d0e09c17 	ldw	r3,-32144(gp)
81136f04:	e0bffe17 	ldw	r2,-8(fp)
81136f08:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
81136f0c:	d0a09c17 	ldw	r2,-32144(gp)
81136f10:	10800c83 	ldbu	r2,50(r2)
81136f14:	10803fcc 	andi	r2,r2,255
81136f18:	e0fffa03 	ldbu	r3,-24(fp)
81136f1c:	18800836 	bltu	r3,r2,81136f40 <OSMutexAccept+0x160>
81136f20:	e0bff817 	ldw	r2,-32(fp)
81136f24:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136f28:	e0bff917 	ldw	r2,-28(fp)
81136f2c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
81136f30:	e0bfff17 	ldw	r2,-4(fp)
81136f34:	00c01e04 	movi	r3,120
81136f38:	10c00005 	stb	r3,0(r2)
81136f3c:	00000606 	br	81136f58 <OSMutexAccept+0x178>
81136f40:	e0bff817 	ldw	r2,-32(fp)
81136f44:	e0bffb15 	stw	r2,-20(fp)
81136f48:	e0bffb17 	ldw	r2,-20(fp)
81136f4c:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
81136f50:	e0bfff17 	ldw	r2,-4(fp)
81136f54:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
81136f58:	00800044 	movi	r2,1
81136f5c:	00000706 	br	81136f7c <OSMutexAccept+0x19c>
81136f60:	e0bff817 	ldw	r2,-32(fp)
81136f64:	e0bffc15 	stw	r2,-16(fp)
81136f68:	e0bffc17 	ldw	r2,-16(fp)
81136f6c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136f70:	e0bfff17 	ldw	r2,-4(fp)
81136f74:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
81136f78:	0005883a 	mov	r2,zero
}
81136f7c:	e037883a 	mov	sp,fp
81136f80:	df000017 	ldw	fp,0(sp)
81136f84:	dec00104 	addi	sp,sp,4
81136f88:	f800283a 	ret

81136f8c <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
81136f8c:	defff604 	addi	sp,sp,-40
81136f90:	de00012e 	bgeu	sp,et,81136f98 <OSMutexCreate+0xc>
81136f94:	003b68fa 	trap	3
81136f98:	dfc00915 	stw	ra,36(sp)
81136f9c:	df000815 	stw	fp,32(sp)
81136fa0:	df000804 	addi	fp,sp,32
81136fa4:	2005883a 	mov	r2,r4
81136fa8:	e17fff15 	stw	r5,-4(fp)
81136fac:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81136fb0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81136fb4:	e0bfff17 	ldw	r2,-4(fp)
81136fb8:	1000021e 	bne	r2,zero,81136fc4 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
81136fbc:	0005883a 	mov	r2,zero
81136fc0:	00006106 	br	81137148 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
81136fc4:	e0bffe03 	ldbu	r2,-8(fp)
81136fc8:	10800a30 	cmpltui	r2,r2,40
81136fcc:	1000051e 	bne	r2,zero,81136fe4 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
81136fd0:	e0bfff17 	ldw	r2,-4(fp)
81136fd4:	00c00a84 	movi	r3,42
81136fd8:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81136fdc:	0005883a 	mov	r2,zero
81136fe0:	00005906 	br	81137148 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81136fe4:	d0a09b03 	ldbu	r2,-32148(gp)
81136fe8:	10803fcc 	andi	r2,r2,255
81136fec:	10000526 	beq	r2,zero,81137004 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
81136ff0:	e0bfff17 	ldw	r2,-4(fp)
81136ff4:	00c00404 	movi	r3,16
81136ff8:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81136ffc:	0005883a 	mov	r2,zero
81137000:	00005106 	br	81137148 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137004:	0005303a 	rdctl	r2,status
81137008:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113700c:	e0fffd17 	ldw	r3,-12(fp)
81137010:	00bfff84 	movi	r2,-2
81137014:	1884703a 	and	r2,r3,r2
81137018:	1001703a 	wrctl	status,r2
  
  return context;
8113701c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81137020:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
81137024:	e0fffe03 	ldbu	r3,-8(fp)
81137028:	00a045b4 	movhi	r2,33046
8113702c:	10979804 	addi	r2,r2,24160
81137030:	18c7883a 	add	r3,r3,r3
81137034:	18c7883a 	add	r3,r3,r3
81137038:	10c5883a 	add	r2,r2,r3
8113703c:	10800017 	ldw	r2,0(r2)
81137040:	10000926 	beq	r2,zero,81137068 <OSMutexCreate+0xdc>
81137044:	e0bff817 	ldw	r2,-32(fp)
81137048:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113704c:	e0bff917 	ldw	r2,-28(fp)
81137050:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
81137054:	e0bfff17 	ldw	r2,-4(fp)
81137058:	00c00a04 	movi	r3,40
8113705c:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81137060:	0005883a 	mov	r2,zero
81137064:	00003806 	br	81137148 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
81137068:	e0fffe03 	ldbu	r3,-8(fp)
8113706c:	00a045b4 	movhi	r2,33046
81137070:	10979804 	addi	r2,r2,24160
81137074:	18c7883a 	add	r3,r3,r3
81137078:	18c7883a 	add	r3,r3,r3
8113707c:	10c5883a 	add	r2,r2,r3
81137080:	00c00044 	movi	r3,1
81137084:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
81137088:	d0a09a17 	ldw	r2,-32152(gp)
8113708c:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
81137090:	e0bffb17 	ldw	r2,-20(fp)
81137094:	1000101e 	bne	r2,zero,811370d8 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
81137098:	e0fffe03 	ldbu	r3,-8(fp)
8113709c:	00a045b4 	movhi	r2,33046
811370a0:	10979804 	addi	r2,r2,24160
811370a4:	18c7883a 	add	r3,r3,r3
811370a8:	18c7883a 	add	r3,r3,r3
811370ac:	10c5883a 	add	r2,r2,r3
811370b0:	10000015 	stw	zero,0(r2)
811370b4:	e0bff817 	ldw	r2,-32(fp)
811370b8:	e0bffa15 	stw	r2,-24(fp)
811370bc:	e0bffa17 	ldw	r2,-24(fp)
811370c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
811370c4:	e0bfff17 	ldw	r2,-4(fp)
811370c8:	00c00104 	movi	r3,4
811370cc:	10c00005 	stb	r3,0(r2)
        return (pevent);
811370d0:	e0bffb17 	ldw	r2,-20(fp)
811370d4:	00001c06 	br	81137148 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
811370d8:	d0a09a17 	ldw	r2,-32152(gp)
811370dc:	10800117 	ldw	r2,4(r2)
811370e0:	d0a09a15 	stw	r2,-32152(gp)
811370e4:	e0bff817 	ldw	r2,-32(fp)
811370e8:	e0bffc15 	stw	r2,-16(fp)
811370ec:	e0bffc17 	ldw	r2,-16(fp)
811370f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
811370f4:	e0bffb17 	ldw	r2,-20(fp)
811370f8:	00c00104 	movi	r3,4
811370fc:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
81137100:	e0bffe03 	ldbu	r2,-8(fp)
81137104:	1004923a 	slli	r2,r2,8
81137108:	10803fd4 	ori	r2,r2,255
8113710c:	1007883a 	mov	r3,r2
81137110:	e0bffb17 	ldw	r2,-20(fp)
81137114:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
81137118:	e0bffb17 	ldw	r2,-20(fp)
8113711c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
81137120:	e0bffb17 	ldw	r2,-20(fp)
81137124:	00c00fc4 	movi	r3,63
81137128:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113712c:	e0bffb17 	ldw	r2,-20(fp)
81137130:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
81137134:	e13ffb17 	ldw	r4,-20(fp)
81137138:	11340d80 	call	811340d8 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113713c:	e0bfff17 	ldw	r2,-4(fp)
81137140:	10000005 	stb	zero,0(r2)
    return (pevent);
81137144:	e0bffb17 	ldw	r2,-20(fp)
}
81137148:	e037883a 	mov	sp,fp
8113714c:	dfc00117 	ldw	ra,4(sp)
81137150:	df000017 	ldw	fp,0(sp)
81137154:	dec00204 	addi	sp,sp,8
81137158:	f800283a 	ret

8113715c <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113715c:	defff004 	addi	sp,sp,-64
81137160:	de00012e 	bgeu	sp,et,81137168 <OSMutexDel+0xc>
81137164:	003b68fa 	trap	3
81137168:	dfc00f15 	stw	ra,60(sp)
8113716c:	df000e15 	stw	fp,56(sp)
81137170:	df000e04 	addi	fp,sp,56
81137174:	e13ffd15 	stw	r4,-12(fp)
81137178:	2805883a 	mov	r2,r5
8113717c:	e1bfff15 	stw	r6,-4(fp)
81137180:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137184:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81137188:	e0bfff17 	ldw	r2,-4(fp)
8113718c:	1000021e 	bne	r2,zero,81137198 <OSMutexDel+0x3c>
        return (pevent);
81137190:	e0bffd17 	ldw	r2,-12(fp)
81137194:	0000ad06 	br	8113744c <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81137198:	e0bffd17 	ldw	r2,-12(fp)
8113719c:	1000051e 	bne	r2,zero,811371b4 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811371a0:	e0bfff17 	ldw	r2,-4(fp)
811371a4:	00c00104 	movi	r3,4
811371a8:	10c00005 	stb	r3,0(r2)
        return (pevent);
811371ac:	e0bffd17 	ldw	r2,-12(fp)
811371b0:	0000a606 	br	8113744c <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
811371b4:	e0bffd17 	ldw	r2,-12(fp)
811371b8:	10800003 	ldbu	r2,0(r2)
811371bc:	10803fcc 	andi	r2,r2,255
811371c0:	10800120 	cmpeqi	r2,r2,4
811371c4:	1000051e 	bne	r2,zero,811371dc <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811371c8:	e0bfff17 	ldw	r2,-4(fp)
811371cc:	00c00044 	movi	r3,1
811371d0:	10c00005 	stb	r3,0(r2)
        return (pevent);
811371d4:	e0bffd17 	ldw	r2,-12(fp)
811371d8:	00009c06 	br	8113744c <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811371dc:	d0a09b03 	ldbu	r2,-32148(gp)
811371e0:	10803fcc 	andi	r2,r2,255
811371e4:	10000526 	beq	r2,zero,811371fc <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811371e8:	e0bfff17 	ldw	r2,-4(fp)
811371ec:	00c003c4 	movi	r3,15
811371f0:	10c00005 	stb	r3,0(r2)
        return (pevent);
811371f4:	e0bffd17 	ldw	r2,-12(fp)
811371f8:	00009406 	br	8113744c <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811371fc:	0005303a 	rdctl	r2,status
81137200:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137204:	e0fffc17 	ldw	r3,-16(fp)
81137208:	00bfff84 	movi	r2,-2
8113720c:	1884703a 	and	r2,r3,r2
81137210:	1001703a 	wrctl	status,r2
  
  return context;
81137214:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137218:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113721c:	e0bffd17 	ldw	r2,-12(fp)
81137220:	10800283 	ldbu	r2,10(r2)
81137224:	10803fcc 	andi	r2,r2,255
81137228:	10000326 	beq	r2,zero,81137238 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113722c:	00800044 	movi	r2,1
81137230:	e0bff205 	stb	r2,-56(fp)
81137234:	00000106 	br	8113723c <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81137238:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113723c:	e0bffe03 	ldbu	r2,-8(fp)
81137240:	10000326 	beq	r2,zero,81137250 <OSMutexDel+0xf4>
81137244:	10800060 	cmpeqi	r2,r2,1
81137248:	10002f1e 	bne	r2,zero,81137308 <OSMutexDel+0x1ac>
8113724c:	00007406 	br	81137420 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
81137250:	e0bff203 	ldbu	r2,-56(fp)
81137254:	1000221e 	bne	r2,zero,811372e0 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81137258:	e0bffd17 	ldw	r2,-12(fp)
8113725c:	00c00fc4 	movi	r3,63
81137260:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81137264:	e0bffd17 	ldw	r2,-12(fp)
81137268:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113726c:	e0bffd17 	ldw	r2,-12(fp)
81137270:	1080020b 	ldhu	r2,8(r2)
81137274:	10bfffcc 	andi	r2,r2,65535
81137278:	1004d23a 	srli	r2,r2,8
8113727c:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
81137280:	e0fff603 	ldbu	r3,-40(fp)
81137284:	00a045b4 	movhi	r2,33046
81137288:	10979804 	addi	r2,r2,24160
8113728c:	18c7883a 	add	r3,r3,r3
81137290:	18c7883a 	add	r3,r3,r3
81137294:	10c5883a 	add	r2,r2,r3
81137298:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113729c:	e0bffd17 	ldw	r2,-12(fp)
811372a0:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
811372a4:	d0e09a17 	ldw	r3,-32152(gp)
811372a8:	e0bffd17 	ldw	r2,-12(fp)
811372ac:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
811372b0:	e0bffd17 	ldw	r2,-12(fp)
811372b4:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
811372b8:	e0bffd17 	ldw	r2,-12(fp)
811372bc:	d0a09a15 	stw	r2,-32152(gp)
811372c0:	e0bff417 	ldw	r2,-48(fp)
811372c4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811372c8:	e0bff517 	ldw	r2,-44(fp)
811372cc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
811372d0:	e0bfff17 	ldw	r2,-4(fp)
811372d4:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
811372d8:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
811372dc:	00005a06 	br	81137448 <OSMutexDel+0x2ec>
811372e0:	e0bff417 	ldw	r2,-48(fp)
811372e4:	e0bff715 	stw	r2,-36(fp)
811372e8:	e0bff717 	ldw	r2,-36(fp)
811372ec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
811372f0:	e0bfff17 	ldw	r2,-4(fp)
811372f4:	00c01244 	movi	r3,73
811372f8:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
811372fc:	e0bffd17 	ldw	r2,-12(fp)
81137300:	e0bff315 	stw	r2,-52(fp)
             }
             break;
81137304:	00005006 	br	81137448 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
81137308:	e0bffd17 	ldw	r2,-12(fp)
8113730c:	1080020b 	ldhu	r2,8(r2)
81137310:	10bfffcc 	andi	r2,r2,65535
81137314:	1004d23a 	srli	r2,r2,8
81137318:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113731c:	e0bffd17 	ldw	r2,-12(fp)
81137320:	1080020b 	ldhu	r2,8(r2)
81137324:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
81137328:	e0bffd17 	ldw	r2,-12(fp)
8113732c:	10800117 	ldw	r2,4(r2)
81137330:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
81137334:	e0bffa17 	ldw	r2,-24(fp)
81137338:	10000f26 	beq	r2,zero,81137378 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113733c:	e0bffa17 	ldw	r2,-24(fp)
81137340:	10800c83 	ldbu	r2,50(r2)
81137344:	10c03fcc 	andi	r3,r2,255
81137348:	e0bff603 	ldbu	r2,-40(fp)
8113734c:	18800a1e 	bne	r3,r2,81137378 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
81137350:	e0bff903 	ldbu	r2,-28(fp)
81137354:	100b883a 	mov	r5,r2
81137358:	e13ffa17 	ldw	r4,-24(fp)
8113735c:	1137d980 	call	81137d98 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81137360:	00000506 	br	81137378 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81137364:	000f883a 	mov	r7,zero
81137368:	01800404 	movi	r6,16
8113736c:	000b883a 	mov	r5,zero
81137370:	e13ffd17 	ldw	r4,-12(fp)
81137374:	1133b000 	call	81133b00 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81137378:	e0bffd17 	ldw	r2,-12(fp)
8113737c:	10800283 	ldbu	r2,10(r2)
81137380:	10803fcc 	andi	r2,r2,255
81137384:	103ff71e 	bne	r2,zero,81137364 <__reset+0xfb117364>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81137388:	e0bffd17 	ldw	r2,-12(fp)
8113738c:	00c00fc4 	movi	r3,63
81137390:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81137394:	e0bffd17 	ldw	r2,-12(fp)
81137398:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113739c:	e0bffd17 	ldw	r2,-12(fp)
811373a0:	1080020b 	ldhu	r2,8(r2)
811373a4:	10bfffcc 	andi	r2,r2,65535
811373a8:	1004d23a 	srli	r2,r2,8
811373ac:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
811373b0:	e0fff603 	ldbu	r3,-40(fp)
811373b4:	00a045b4 	movhi	r2,33046
811373b8:	10979804 	addi	r2,r2,24160
811373bc:	18c7883a 	add	r3,r3,r3
811373c0:	18c7883a 	add	r3,r3,r3
811373c4:	10c5883a 	add	r2,r2,r3
811373c8:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
811373cc:	e0bffd17 	ldw	r2,-12(fp)
811373d0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
811373d4:	d0e09a17 	ldw	r3,-32152(gp)
811373d8:	e0bffd17 	ldw	r2,-12(fp)
811373dc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
811373e0:	e0bffd17 	ldw	r2,-12(fp)
811373e4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
811373e8:	e0bffd17 	ldw	r2,-12(fp)
811373ec:	d0a09a15 	stw	r2,-32152(gp)
811373f0:	e0bff417 	ldw	r2,-48(fp)
811373f4:	e0bff815 	stw	r2,-32(fp)
811373f8:	e0bff817 	ldw	r2,-32(fp)
811373fc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81137400:	e0bff203 	ldbu	r2,-56(fp)
81137404:	10800058 	cmpnei	r2,r2,1
81137408:	1000011e 	bne	r2,zero,81137410 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113740c:	11345bc0 	call	811345bc <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
81137410:	e0bfff17 	ldw	r2,-4(fp)
81137414:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
81137418:	e03ff315 	stw	zero,-52(fp)
             break;
8113741c:	00000a06 	br	81137448 <OSMutexDel+0x2ec>
81137420:	e0bff417 	ldw	r2,-48(fp)
81137424:	e0bffb15 	stw	r2,-20(fp)
81137428:	e0bffb17 	ldw	r2,-20(fp)
8113742c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
81137430:	e0bfff17 	ldw	r2,-4(fp)
81137434:	00c001c4 	movi	r3,7
81137438:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113743c:	e0bffd17 	ldw	r2,-12(fp)
81137440:	e0bff315 	stw	r2,-52(fp)
             break;
81137444:	0001883a 	nop
    }
    return (pevent_return);
81137448:	e0bff317 	ldw	r2,-52(fp)
}
8113744c:	e037883a 	mov	sp,fp
81137450:	dfc00117 	ldw	ra,4(sp)
81137454:	df000017 	ldw	fp,0(sp)
81137458:	dec00204 	addi	sp,sp,8
8113745c:	f800283a 	ret

81137460 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81137460:	deffee04 	addi	sp,sp,-72
81137464:	de00012e 	bgeu	sp,et,8113746c <OSMutexPend+0xc>
81137468:	003b68fa 	trap	3
8113746c:	dfc01115 	stw	ra,68(sp)
81137470:	df001015 	stw	fp,64(sp)
81137474:	df001004 	addi	fp,sp,64
81137478:	e13ffd15 	stw	r4,-12(fp)
8113747c:	2805883a 	mov	r2,r5
81137480:	e1bfff15 	stw	r6,-4(fp)
81137484:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137488:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113748c:	e0bfff17 	ldw	r2,-4(fp)
81137490:	10015626 	beq	r2,zero,811379ec <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81137494:	e0bffd17 	ldw	r2,-12(fp)
81137498:	1000041e 	bne	r2,zero,811374ac <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113749c:	e0bfff17 	ldw	r2,-4(fp)
811374a0:	00c00104 	movi	r3,4
811374a4:	10c00005 	stb	r3,0(r2)
        return;
811374a8:	00015106 	br	811379f0 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
811374ac:	e0bffd17 	ldw	r2,-12(fp)
811374b0:	10800003 	ldbu	r2,0(r2)
811374b4:	10803fcc 	andi	r2,r2,255
811374b8:	10800120 	cmpeqi	r2,r2,4
811374bc:	1000041e 	bne	r2,zero,811374d0 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
811374c0:	e0bfff17 	ldw	r2,-4(fp)
811374c4:	00c00044 	movi	r3,1
811374c8:	10c00005 	stb	r3,0(r2)
        return;
811374cc:	00014806 	br	811379f0 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811374d0:	d0a09b03 	ldbu	r2,-32148(gp)
811374d4:	10803fcc 	andi	r2,r2,255
811374d8:	10000426 	beq	r2,zero,811374ec <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
811374dc:	e0bfff17 	ldw	r2,-4(fp)
811374e0:	00c00084 	movi	r3,2
811374e4:	10c00005 	stb	r3,0(r2)
        return;
811374e8:	00014106 	br	811379f0 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
811374ec:	d0a08903 	ldbu	r2,-32220(gp)
811374f0:	10803fcc 	andi	r2,r2,255
811374f4:	10000426 	beq	r2,zero,81137508 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
811374f8:	e0bfff17 	ldw	r2,-4(fp)
811374fc:	00c00344 	movi	r3,13
81137500:	10c00005 	stb	r3,0(r2)
        return;
81137504:	00013a06 	br	811379f0 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137508:	0005303a 	rdctl	r2,status
8113750c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137510:	e0fffc17 	ldw	r3,-16(fp)
81137514:	00bfff84 	movi	r2,-2
81137518:	1884703a 	and	r2,r3,r2
8113751c:	1001703a 	wrctl	status,r2
  
  return context;
81137520:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81137524:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
81137528:	e0bffd17 	ldw	r2,-12(fp)
8113752c:	1080020b 	ldhu	r2,8(r2)
81137530:	10bfffcc 	andi	r2,r2,65535
81137534:	1004d23a 	srli	r2,r2,8
81137538:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113753c:	e0bffd17 	ldw	r2,-12(fp)
81137540:	1080020b 	ldhu	r2,8(r2)
81137544:	10803fcc 	andi	r2,r2,255
81137548:	10803fd8 	cmpnei	r2,r2,255
8113754c:	1000271e 	bne	r2,zero,811375ec <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
81137550:	e0bffd17 	ldw	r2,-12(fp)
81137554:	10c0020b 	ldhu	r3,8(r2)
81137558:	00bfc004 	movi	r2,-256
8113755c:	1884703a 	and	r2,r3,r2
81137560:	1007883a 	mov	r3,r2
81137564:	e0bffd17 	ldw	r2,-12(fp)
81137568:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113756c:	e0bffd17 	ldw	r2,-12(fp)
81137570:	10c0020b 	ldhu	r3,8(r2)
81137574:	d0a09c17 	ldw	r2,-32144(gp)
81137578:	10800c83 	ldbu	r2,50(r2)
8113757c:	10803fcc 	andi	r2,r2,255
81137580:	1884b03a 	or	r2,r3,r2
81137584:	1007883a 	mov	r3,r2
81137588:	e0bffd17 	ldw	r2,-12(fp)
8113758c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
81137590:	d0e09c17 	ldw	r3,-32144(gp)
81137594:	e0bffd17 	ldw	r2,-12(fp)
81137598:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113759c:	d0a09c17 	ldw	r2,-32144(gp)
811375a0:	10800c83 	ldbu	r2,50(r2)
811375a4:	10803fcc 	andi	r2,r2,255
811375a8:	e0fff303 	ldbu	r3,-52(fp)
811375ac:	18800836 	bltu	r3,r2,811375d0 <OSMutexPend+0x170>
811375b0:	e0bff117 	ldw	r2,-60(fp)
811375b4:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811375b8:	e0bff217 	ldw	r2,-56(fp)
811375bc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
811375c0:	e0bfff17 	ldw	r2,-4(fp)
811375c4:	00c01e04 	movi	r3,120
811375c8:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
811375cc:	00010806 	br	811379f0 <OSMutexPend+0x590>
811375d0:	e0bff117 	ldw	r2,-60(fp)
811375d4:	e0bff415 	stw	r2,-48(fp)
811375d8:	e0bff417 	ldw	r2,-48(fp)
811375dc:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
811375e0:	e0bfff17 	ldw	r2,-4(fp)
811375e4:	10000005 	stb	zero,0(r2)
        }
        return;
811375e8:	00010106 	br	811379f0 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
811375ec:	e0bffd17 	ldw	r2,-12(fp)
811375f0:	1080020b 	ldhu	r2,8(r2)
811375f4:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
811375f8:	e0bffd17 	ldw	r2,-12(fp)
811375fc:	10800117 	ldw	r2,4(r2)
81137600:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
81137604:	e0bff717 	ldw	r2,-36(fp)
81137608:	10800c83 	ldbu	r2,50(r2)
8113760c:	10803fcc 	andi	r2,r2,255
81137610:	e0fff303 	ldbu	r3,-52(fp)
81137614:	1880b92e 	bgeu	r3,r2,811378fc <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
81137618:	d0a09c17 	ldw	r2,-32144(gp)
8113761c:	10800c83 	ldbu	r2,50(r2)
81137620:	10c03fcc 	andi	r3,r2,255
81137624:	e0bff603 	ldbu	r2,-40(fp)
81137628:	1880b42e 	bgeu	r3,r2,811378fc <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113762c:	e0bff717 	ldw	r2,-36(fp)
81137630:	10800d03 	ldbu	r2,52(r2)
81137634:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
81137638:	e0fff803 	ldbu	r3,-32(fp)
8113763c:	d0a09844 	addi	r2,gp,-32159
81137640:	1885883a 	add	r2,r3,r2
81137644:	10c00003 	ldbu	r3,0(r2)
81137648:	e0bff717 	ldw	r2,-36(fp)
8113764c:	10800d43 	ldbu	r2,53(r2)
81137650:	1884703a 	and	r2,r3,r2
81137654:	10803fcc 	andi	r2,r2,255
81137658:	10001e26 	beq	r2,zero,811376d4 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113765c:	e0fff803 	ldbu	r3,-32(fp)
81137660:	e13ff803 	ldbu	r4,-32(fp)
81137664:	d0a09844 	addi	r2,gp,-32159
81137668:	2085883a 	add	r2,r4,r2
8113766c:	10800003 	ldbu	r2,0(r2)
81137670:	1009883a 	mov	r4,r2
81137674:	e0bff717 	ldw	r2,-36(fp)
81137678:	10800d43 	ldbu	r2,53(r2)
8113767c:	0084303a 	nor	r2,zero,r2
81137680:	2084703a 	and	r2,r4,r2
81137684:	1009883a 	mov	r4,r2
81137688:	d0a09844 	addi	r2,gp,-32159
8113768c:	1885883a 	add	r2,r3,r2
81137690:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
81137694:	e0fff803 	ldbu	r3,-32(fp)
81137698:	d0a09844 	addi	r2,gp,-32159
8113769c:	1885883a 	add	r2,r3,r2
811376a0:	10800003 	ldbu	r2,0(r2)
811376a4:	10803fcc 	andi	r2,r2,255
811376a8:	1000071e 	bne	r2,zero,811376c8 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
811376ac:	e0bff717 	ldw	r2,-36(fp)
811376b0:	10800d83 	ldbu	r2,54(r2)
811376b4:	0084303a 	nor	r2,zero,r2
811376b8:	1007883a 	mov	r3,r2
811376bc:	d0a09803 	ldbu	r2,-32160(gp)
811376c0:	1884703a 	and	r2,r3,r2
811376c4:	d0a09805 	stb	r2,-32160(gp)
                }
                rdy = OS_TRUE;
811376c8:	00800044 	movi	r2,1
811376cc:	e0bff005 	stb	r2,-64(fp)
811376d0:	00002a06 	br	8113777c <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
811376d4:	e0bff717 	ldw	r2,-36(fp)
811376d8:	10800717 	ldw	r2,28(r2)
811376dc:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
811376e0:	e0bff917 	ldw	r2,-28(fp)
811376e4:	10002426 	beq	r2,zero,81137778 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
811376e8:	e0bff717 	ldw	r2,-36(fp)
811376ec:	10800d03 	ldbu	r2,52(r2)
811376f0:	10803fcc 	andi	r2,r2,255
811376f4:	e0fff717 	ldw	r3,-36(fp)
811376f8:	18c00d03 	ldbu	r3,52(r3)
811376fc:	18c03fcc 	andi	r3,r3,255
81137700:	e13ff917 	ldw	r4,-28(fp)
81137704:	20c7883a 	add	r3,r4,r3
81137708:	18c002c4 	addi	r3,r3,11
8113770c:	18c00003 	ldbu	r3,0(r3)
81137710:	1809883a 	mov	r4,r3
81137714:	e0fff717 	ldw	r3,-36(fp)
81137718:	18c00d43 	ldbu	r3,53(r3)
8113771c:	00c6303a 	nor	r3,zero,r3
81137720:	20c6703a 	and	r3,r4,r3
81137724:	1809883a 	mov	r4,r3
81137728:	e0fff917 	ldw	r3,-28(fp)
8113772c:	1887883a 	add	r3,r3,r2
81137730:	18c002c4 	addi	r3,r3,11
81137734:	19000005 	stb	r4,0(r3)
81137738:	e0fff917 	ldw	r3,-28(fp)
8113773c:	1885883a 	add	r2,r3,r2
81137740:	108002c4 	addi	r2,r2,11
81137744:	10800003 	ldbu	r2,0(r2)
81137748:	10803fcc 	andi	r2,r2,255
8113774c:	10000a1e 	bne	r2,zero,81137778 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
81137750:	e0bff917 	ldw	r2,-28(fp)
81137754:	10800283 	ldbu	r2,10(r2)
81137758:	1007883a 	mov	r3,r2
8113775c:	e0bff717 	ldw	r2,-36(fp)
81137760:	10800d83 	ldbu	r2,54(r2)
81137764:	0084303a 	nor	r2,zero,r2
81137768:	1884703a 	and	r2,r3,r2
8113776c:	1007883a 	mov	r3,r2
81137770:	e0bff917 	ldw	r2,-28(fp)
81137774:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
81137778:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113777c:	e0bff717 	ldw	r2,-36(fp)
81137780:	e0fff303 	ldbu	r3,-52(fp)
81137784:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
81137788:	e0bff717 	ldw	r2,-36(fp)
8113778c:	10800c83 	ldbu	r2,50(r2)
81137790:	10803fcc 	andi	r2,r2,255
81137794:	1004d0fa 	srli	r2,r2,3
81137798:	1007883a 	mov	r3,r2
8113779c:	e0bff717 	ldw	r2,-36(fp)
811377a0:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
811377a4:	e0bff717 	ldw	r2,-36(fp)
811377a8:	10800c83 	ldbu	r2,50(r2)
811377ac:	108001cc 	andi	r2,r2,7
811377b0:	1007883a 	mov	r3,r2
811377b4:	e0bff717 	ldw	r2,-36(fp)
811377b8:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
811377bc:	e0bff717 	ldw	r2,-36(fp)
811377c0:	10800d03 	ldbu	r2,52(r2)
811377c4:	10803fcc 	andi	r2,r2,255
811377c8:	00c00044 	movi	r3,1
811377cc:	1884983a 	sll	r2,r3,r2
811377d0:	1007883a 	mov	r3,r2
811377d4:	e0bff717 	ldw	r2,-36(fp)
811377d8:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
811377dc:	e0bff717 	ldw	r2,-36(fp)
811377e0:	10800cc3 	ldbu	r2,51(r2)
811377e4:	10803fcc 	andi	r2,r2,255
811377e8:	00c00044 	movi	r3,1
811377ec:	1884983a 	sll	r2,r3,r2
811377f0:	1007883a 	mov	r3,r2
811377f4:	e0bff717 	ldw	r2,-36(fp)
811377f8:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
811377fc:	e0bff003 	ldbu	r2,-64(fp)
81137800:	10800058 	cmpnei	r2,r2,1
81137804:	1000161e 	bne	r2,zero,81137860 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
81137808:	e0bff717 	ldw	r2,-36(fp)
8113780c:	10c00d83 	ldbu	r3,54(r2)
81137810:	d0a09803 	ldbu	r2,-32160(gp)
81137814:	1884b03a 	or	r2,r3,r2
81137818:	d0a09805 	stb	r2,-32160(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113781c:	e0bff717 	ldw	r2,-36(fp)
81137820:	10800d03 	ldbu	r2,52(r2)
81137824:	10c03fcc 	andi	r3,r2,255
81137828:	e0bff717 	ldw	r2,-36(fp)
8113782c:	10800d03 	ldbu	r2,52(r2)
81137830:	11003fcc 	andi	r4,r2,255
81137834:	d0a09844 	addi	r2,gp,-32159
81137838:	2085883a 	add	r2,r4,r2
8113783c:	11000003 	ldbu	r4,0(r2)
81137840:	e0bff717 	ldw	r2,-36(fp)
81137844:	10800d43 	ldbu	r2,53(r2)
81137848:	2084b03a 	or	r2,r4,r2
8113784c:	1009883a 	mov	r4,r2
81137850:	d0a09844 	addi	r2,gp,-32159
81137854:	1885883a 	add	r2,r3,r2
81137858:	11000005 	stb	r4,0(r2)
8113785c:	00001f06 	br	811378dc <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81137860:	e0bff717 	ldw	r2,-36(fp)
81137864:	10800717 	ldw	r2,28(r2)
81137868:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113786c:	e0bff917 	ldw	r2,-28(fp)
81137870:	10001a26 	beq	r2,zero,811378dc <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
81137874:	e0bff917 	ldw	r2,-28(fp)
81137878:	10c00283 	ldbu	r3,10(r2)
8113787c:	e0bff717 	ldw	r2,-36(fp)
81137880:	10800d83 	ldbu	r2,54(r2)
81137884:	1884b03a 	or	r2,r3,r2
81137888:	1007883a 	mov	r3,r2
8113788c:	e0bff917 	ldw	r2,-28(fp)
81137890:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81137894:	e0bff717 	ldw	r2,-36(fp)
81137898:	10800d03 	ldbu	r2,52(r2)
8113789c:	10803fcc 	andi	r2,r2,255
811378a0:	e0fff717 	ldw	r3,-36(fp)
811378a4:	18c00d03 	ldbu	r3,52(r3)
811378a8:	18c03fcc 	andi	r3,r3,255
811378ac:	e13ff917 	ldw	r4,-28(fp)
811378b0:	20c7883a 	add	r3,r4,r3
811378b4:	18c002c4 	addi	r3,r3,11
811378b8:	19000003 	ldbu	r4,0(r3)
811378bc:	e0fff717 	ldw	r3,-36(fp)
811378c0:	18c00d43 	ldbu	r3,53(r3)
811378c4:	20c6b03a 	or	r3,r4,r3
811378c8:	1809883a 	mov	r4,r3
811378cc:	e0fff917 	ldw	r3,-28(fp)
811378d0:	1885883a 	add	r2,r3,r2
811378d4:	108002c4 	addi	r2,r2,11
811378d8:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
811378dc:	e0fff303 	ldbu	r3,-52(fp)
811378e0:	00a045b4 	movhi	r2,33046
811378e4:	10979804 	addi	r2,r2,24160
811378e8:	18c7883a 	add	r3,r3,r3
811378ec:	18c7883a 	add	r3,r3,r3
811378f0:	10c5883a 	add	r2,r2,r3
811378f4:	e0fff717 	ldw	r3,-36(fp)
811378f8:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
811378fc:	d0a09c17 	ldw	r2,-32144(gp)
81137900:	d0e09c17 	ldw	r3,-32144(gp)
81137904:	18c00c03 	ldbu	r3,48(r3)
81137908:	18c00414 	ori	r3,r3,16
8113790c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81137910:	d0a09c17 	ldw	r2,-32144(gp)
81137914:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
81137918:	d0a09c17 	ldw	r2,-32144(gp)
8113791c:	e0fffe0b 	ldhu	r3,-8(fp)
81137920:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81137924:	e13ffd17 	ldw	r4,-12(fp)
81137928:	1133ca00 	call	81133ca0 <OS_EventTaskWait>
8113792c:	e0bff117 	ldw	r2,-60(fp)
81137930:	e0bffb15 	stw	r2,-20(fp)
81137934:	e0bffb17 	ldw	r2,-20(fp)
81137938:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113793c:	11345bc0 	call	811345bc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137940:	0005303a 	rdctl	r2,status
81137944:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137948:	e0fff517 	ldw	r3,-44(fp)
8113794c:	00bfff84 	movi	r2,-2
81137950:	1884703a 	and	r2,r3,r2
81137954:	1001703a 	wrctl	status,r2
  
  return context;
81137958:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113795c:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81137960:	d0a09c17 	ldw	r2,-32144(gp)
81137964:	10800c43 	ldbu	r2,49(r2)
81137968:	10803fcc 	andi	r2,r2,255
8113796c:	10000326 	beq	r2,zero,8113797c <OSMutexPend+0x51c>
81137970:	108000a0 	cmpeqi	r2,r2,2
81137974:	1000041e 	bne	r2,zero,81137988 <OSMutexPend+0x528>
81137978:	00000706 	br	81137998 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113797c:	e0bfff17 	ldw	r2,-4(fp)
81137980:	10000005 	stb	zero,0(r2)
             break;
81137984:	00000c06 	br	811379b8 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
81137988:	e0bfff17 	ldw	r2,-4(fp)
8113798c:	00c00384 	movi	r3,14
81137990:	10c00005 	stb	r3,0(r2)
             break;
81137994:	00000806 	br	811379b8 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81137998:	d0a09c17 	ldw	r2,-32144(gp)
8113799c:	e17ffd17 	ldw	r5,-12(fp)
811379a0:	1009883a 	mov	r4,r2
811379a4:	1133f100 	call	81133f10 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
811379a8:	e0bfff17 	ldw	r2,-4(fp)
811379ac:	00c00284 	movi	r3,10
811379b0:	10c00005 	stb	r3,0(r2)
             break;
811379b4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
811379b8:	d0a09c17 	ldw	r2,-32144(gp)
811379bc:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
811379c0:	d0a09c17 	ldw	r2,-32144(gp)
811379c4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
811379c8:	d0a09c17 	ldw	r2,-32144(gp)
811379cc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
811379d0:	d0a09c17 	ldw	r2,-32144(gp)
811379d4:	10000815 	stw	zero,32(r2)
811379d8:	e0bff117 	ldw	r2,-60(fp)
811379dc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811379e0:	e0bffa17 	ldw	r2,-24(fp)
811379e4:	1001703a 	wrctl	status,r2
811379e8:	00000106 	br	811379f0 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
811379ec:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
811379f0:	e037883a 	mov	sp,fp
811379f4:	dfc00117 	ldw	ra,4(sp)
811379f8:	df000017 	ldw	fp,0(sp)
811379fc:	dec00204 	addi	sp,sp,8
81137a00:	f800283a 	ret

81137a04 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
81137a04:	defff604 	addi	sp,sp,-40
81137a08:	de00012e 	bgeu	sp,et,81137a10 <OSMutexPost+0xc>
81137a0c:	003b68fa 	trap	3
81137a10:	dfc00915 	stw	ra,36(sp)
81137a14:	df000815 	stw	fp,32(sp)
81137a18:	df000804 	addi	fp,sp,32
81137a1c:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81137a20:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81137a24:	d0a09b03 	ldbu	r2,-32148(gp)
81137a28:	10803fcc 	andi	r2,r2,255
81137a2c:	10000226 	beq	r2,zero,81137a38 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
81137a30:	00800144 	movi	r2,5
81137a34:	00007606 	br	81137c10 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81137a38:	e0bfff17 	ldw	r2,-4(fp)
81137a3c:	1000021e 	bne	r2,zero,81137a48 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
81137a40:	00800104 	movi	r2,4
81137a44:	00007206 	br	81137c10 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
81137a48:	e0bfff17 	ldw	r2,-4(fp)
81137a4c:	10800003 	ldbu	r2,0(r2)
81137a50:	10803fcc 	andi	r2,r2,255
81137a54:	10800120 	cmpeqi	r2,r2,4
81137a58:	1000021e 	bne	r2,zero,81137a64 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
81137a5c:	00800044 	movi	r2,1
81137a60:	00006b06 	br	81137c10 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137a64:	0005303a 	rdctl	r2,status
81137a68:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137a6c:	e0fffe17 	ldw	r3,-8(fp)
81137a70:	00bfff84 	movi	r2,-2
81137a74:	1884703a 	and	r2,r3,r2
81137a78:	1001703a 	wrctl	status,r2
  
  return context;
81137a7c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81137a80:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
81137a84:	e0bfff17 	ldw	r2,-4(fp)
81137a88:	1080020b 	ldhu	r2,8(r2)
81137a8c:	10bfffcc 	andi	r2,r2,65535
81137a90:	1004d23a 	srli	r2,r2,8
81137a94:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
81137a98:	e0bfff17 	ldw	r2,-4(fp)
81137a9c:	1080020b 	ldhu	r2,8(r2)
81137aa0:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
81137aa4:	e0bfff17 	ldw	r2,-4(fp)
81137aa8:	10c00117 	ldw	r3,4(r2)
81137aac:	d0a09c17 	ldw	r2,-32144(gp)
81137ab0:	18800626 	beq	r3,r2,81137acc <OSMutexPost+0xc8>
81137ab4:	e0bff817 	ldw	r2,-32(fp)
81137ab8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137abc:	e0bff917 	ldw	r2,-28(fp)
81137ac0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
81137ac4:	00801904 	movi	r2,100
81137ac8:	00005106 	br	81137c10 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
81137acc:	d0a09c17 	ldw	r2,-32144(gp)
81137ad0:	10800c83 	ldbu	r2,50(r2)
81137ad4:	10c03fcc 	andi	r3,r2,255
81137ad8:	e0bffa03 	ldbu	r2,-24(fp)
81137adc:	1880051e 	bne	r3,r2,81137af4 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
81137ae0:	d0a09c17 	ldw	r2,-32144(gp)
81137ae4:	e0fffa43 	ldbu	r3,-23(fp)
81137ae8:	180b883a 	mov	r5,r3
81137aec:	1009883a 	mov	r4,r2
81137af0:	1137d980 	call	81137d98 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
81137af4:	e0fffa03 	ldbu	r3,-24(fp)
81137af8:	00a045b4 	movhi	r2,33046
81137afc:	10979804 	addi	r2,r2,24160
81137b00:	18c7883a 	add	r3,r3,r3
81137b04:	18c7883a 	add	r3,r3,r3
81137b08:	10c5883a 	add	r2,r2,r3
81137b0c:	00c00044 	movi	r3,1
81137b10:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
81137b14:	e0bfff17 	ldw	r2,-4(fp)
81137b18:	10800283 	ldbu	r2,10(r2)
81137b1c:	10803fcc 	andi	r2,r2,255
81137b20:	10002e26 	beq	r2,zero,81137bdc <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81137b24:	000f883a 	mov	r7,zero
81137b28:	01800404 	movi	r6,16
81137b2c:	000b883a 	mov	r5,zero
81137b30:	e13fff17 	ldw	r4,-4(fp)
81137b34:	1133b000 	call	81133b00 <OS_EventTaskRdy>
81137b38:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
81137b3c:	e0bfff17 	ldw	r2,-4(fp)
81137b40:	10c0020b 	ldhu	r3,8(r2)
81137b44:	00bfc004 	movi	r2,-256
81137b48:	1884703a 	and	r2,r3,r2
81137b4c:	1007883a 	mov	r3,r2
81137b50:	e0bfff17 	ldw	r2,-4(fp)
81137b54:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
81137b58:	e0bfff17 	ldw	r2,-4(fp)
81137b5c:	10c0020b 	ldhu	r3,8(r2)
81137b60:	e0bffa43 	ldbu	r2,-23(fp)
81137b64:	1884b03a 	or	r2,r3,r2
81137b68:	1007883a 	mov	r3,r2
81137b6c:	e0bfff17 	ldw	r2,-4(fp)
81137b70:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
81137b74:	e0fffa43 	ldbu	r3,-23(fp)
81137b78:	00a045b4 	movhi	r2,33046
81137b7c:	10979804 	addi	r2,r2,24160
81137b80:	18c7883a 	add	r3,r3,r3
81137b84:	18c7883a 	add	r3,r3,r3
81137b88:	10c5883a 	add	r2,r2,r3
81137b8c:	10c00017 	ldw	r3,0(r2)
81137b90:	e0bfff17 	ldw	r2,-4(fp)
81137b94:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
81137b98:	e0bffa43 	ldbu	r2,-23(fp)
81137b9c:	e0fffa03 	ldbu	r3,-24(fp)
81137ba0:	18800736 	bltu	r3,r2,81137bc0 <OSMutexPost+0x1bc>
81137ba4:	e0bff817 	ldw	r2,-32(fp)
81137ba8:	e0bffb15 	stw	r2,-20(fp)
81137bac:	e0bffb17 	ldw	r2,-20(fp)
81137bb0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
81137bb4:	11345bc0 	call	811345bc <OS_Sched>
            return (OS_ERR_PIP_LOWER);
81137bb8:	00801e04 	movi	r2,120
81137bbc:	00001406 	br	81137c10 <OSMutexPost+0x20c>
81137bc0:	e0bff817 	ldw	r2,-32(fp)
81137bc4:	e0bffc15 	stw	r2,-16(fp)
81137bc8:	e0bffc17 	ldw	r2,-16(fp)
81137bcc:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
81137bd0:	11345bc0 	call	811345bc <OS_Sched>
            return (OS_ERR_NONE);
81137bd4:	0005883a 	mov	r2,zero
81137bd8:	00000d06 	br	81137c10 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
81137bdc:	e0bfff17 	ldw	r2,-4(fp)
81137be0:	1080020b 	ldhu	r2,8(r2)
81137be4:	10803fd4 	ori	r2,r2,255
81137be8:	1007883a 	mov	r3,r2
81137bec:	e0bfff17 	ldw	r2,-4(fp)
81137bf0:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
81137bf4:	e0bfff17 	ldw	r2,-4(fp)
81137bf8:	10000115 	stw	zero,4(r2)
81137bfc:	e0bff817 	ldw	r2,-32(fp)
81137c00:	e0bffd15 	stw	r2,-12(fp)
81137c04:	e0bffd17 	ldw	r2,-12(fp)
81137c08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81137c0c:	0005883a 	mov	r2,zero
}
81137c10:	e037883a 	mov	sp,fp
81137c14:	dfc00117 	ldw	ra,4(sp)
81137c18:	df000017 	ldw	fp,0(sp)
81137c1c:	dec00204 	addi	sp,sp,8
81137c20:	f800283a 	ret

81137c24 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
81137c24:	defff704 	addi	sp,sp,-36
81137c28:	de00012e 	bgeu	sp,et,81137c30 <OSMutexQuery+0xc>
81137c2c:	003b68fa 	trap	3
81137c30:	df000815 	stw	fp,32(sp)
81137c34:	df000804 	addi	fp,sp,32
81137c38:	e13ffe15 	stw	r4,-8(fp)
81137c3c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137c40:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81137c44:	d0a09b03 	ldbu	r2,-32148(gp)
81137c48:	10803fcc 	andi	r2,r2,255
81137c4c:	10000226 	beq	r2,zero,81137c58 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
81137c50:	00800184 	movi	r2,6
81137c54:	00004c06 	br	81137d88 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81137c58:	e0bffe17 	ldw	r2,-8(fp)
81137c5c:	1000021e 	bne	r2,zero,81137c68 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
81137c60:	00800104 	movi	r2,4
81137c64:	00004806 	br	81137d88 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
81137c68:	e0bfff17 	ldw	r2,-4(fp)
81137c6c:	1000021e 	bne	r2,zero,81137c78 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
81137c70:	00800244 	movi	r2,9
81137c74:	00004406 	br	81137d88 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81137c78:	e0bffe17 	ldw	r2,-8(fp)
81137c7c:	10800003 	ldbu	r2,0(r2)
81137c80:	10803fcc 	andi	r2,r2,255
81137c84:	10800120 	cmpeqi	r2,r2,4
81137c88:	1000021e 	bne	r2,zero,81137c94 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
81137c8c:	00800044 	movi	r2,1
81137c90:	00003d06 	br	81137d88 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137c94:	0005303a 	rdctl	r2,status
81137c98:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137c9c:	e0fffd17 	ldw	r3,-12(fp)
81137ca0:	00bfff84 	movi	r2,-2
81137ca4:	1884703a 	and	r2,r3,r2
81137ca8:	1001703a 	wrctl	status,r2
  
  return context;
81137cac:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81137cb0:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
81137cb4:	e0bffe17 	ldw	r2,-8(fp)
81137cb8:	1080020b 	ldhu	r2,8(r2)
81137cbc:	10bfffcc 	andi	r2,r2,65535
81137cc0:	1004d23a 	srli	r2,r2,8
81137cc4:	1007883a 	mov	r3,r2
81137cc8:	e0bfff17 	ldw	r2,-4(fp)
81137ccc:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
81137cd0:	e0bffe17 	ldw	r2,-8(fp)
81137cd4:	1080020b 	ldhu	r2,8(r2)
81137cd8:	1007883a 	mov	r3,r2
81137cdc:	e0bfff17 	ldw	r2,-4(fp)
81137ce0:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
81137ce4:	e0bfff17 	ldw	r2,-4(fp)
81137ce8:	10800203 	ldbu	r2,8(r2)
81137cec:	10803fcc 	andi	r2,r2,255
81137cf0:	10803fd8 	cmpnei	r2,r2,255
81137cf4:	1000041e 	bne	r2,zero,81137d08 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
81137cf8:	e0bfff17 	ldw	r2,-4(fp)
81137cfc:	00c00044 	movi	r3,1
81137d00:	10c001c5 	stb	r3,7(r2)
81137d04:	00000206 	br	81137d10 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
81137d08:	e0bfff17 	ldw	r2,-4(fp)
81137d0c:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
81137d10:	e0bffe17 	ldw	r2,-8(fp)
81137d14:	10c00283 	ldbu	r3,10(r2)
81137d18:	e0bfff17 	ldw	r2,-4(fp)
81137d1c:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
81137d20:	e0bffe17 	ldw	r2,-8(fp)
81137d24:	108002c4 	addi	r2,r2,11
81137d28:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
81137d2c:	e0bfff17 	ldw	r2,-4(fp)
81137d30:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81137d34:	e03ff805 	stb	zero,-32(fp)
81137d38:	00000b06 	br	81137d68 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
81137d3c:	e0bffa17 	ldw	r2,-24(fp)
81137d40:	10c00044 	addi	r3,r2,1
81137d44:	e0fffa15 	stw	r3,-24(fp)
81137d48:	e0fff917 	ldw	r3,-28(fp)
81137d4c:	19000044 	addi	r4,r3,1
81137d50:	e13ff915 	stw	r4,-28(fp)
81137d54:	18c00003 	ldbu	r3,0(r3)
81137d58:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81137d5c:	e0bff803 	ldbu	r2,-32(fp)
81137d60:	10800044 	addi	r2,r2,1
81137d64:	e0bff805 	stb	r2,-32(fp)
81137d68:	e0bff803 	ldbu	r2,-32(fp)
81137d6c:	108001b0 	cmpltui	r2,r2,6
81137d70:	103ff21e 	bne	r2,zero,81137d3c <__reset+0xfb117d3c>
81137d74:	e0bffb17 	ldw	r2,-20(fp)
81137d78:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137d7c:	e0bffc17 	ldw	r2,-16(fp)
81137d80:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81137d84:	0005883a 	mov	r2,zero
}
81137d88:	e037883a 	mov	sp,fp
81137d8c:	df000017 	ldw	fp,0(sp)
81137d90:	dec00104 	addi	sp,sp,4
81137d94:	f800283a 	ret

81137d98 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
81137d98:	defffc04 	addi	sp,sp,-16
81137d9c:	de00012e 	bgeu	sp,et,81137da4 <OSMutex_RdyAtPrio+0xc>
81137da0:	003b68fa 	trap	3
81137da4:	df000315 	stw	fp,12(sp)
81137da8:	df000304 	addi	fp,sp,12
81137dac:	e13ffe15 	stw	r4,-8(fp)
81137db0:	2805883a 	mov	r2,r5
81137db4:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
81137db8:	e0bffe17 	ldw	r2,-8(fp)
81137dbc:	10800d03 	ldbu	r2,52(r2)
81137dc0:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
81137dc4:	e0fffd03 	ldbu	r3,-12(fp)
81137dc8:	e13ffd03 	ldbu	r4,-12(fp)
81137dcc:	d0a09844 	addi	r2,gp,-32159
81137dd0:	2085883a 	add	r2,r4,r2
81137dd4:	10800003 	ldbu	r2,0(r2)
81137dd8:	1009883a 	mov	r4,r2
81137ddc:	e0bffe17 	ldw	r2,-8(fp)
81137de0:	10800d43 	ldbu	r2,53(r2)
81137de4:	0084303a 	nor	r2,zero,r2
81137de8:	2084703a 	and	r2,r4,r2
81137dec:	1009883a 	mov	r4,r2
81137df0:	d0a09844 	addi	r2,gp,-32159
81137df4:	1885883a 	add	r2,r3,r2
81137df8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81137dfc:	e0fffd03 	ldbu	r3,-12(fp)
81137e00:	d0a09844 	addi	r2,gp,-32159
81137e04:	1885883a 	add	r2,r3,r2
81137e08:	10800003 	ldbu	r2,0(r2)
81137e0c:	10803fcc 	andi	r2,r2,255
81137e10:	1000071e 	bne	r2,zero,81137e30 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81137e14:	e0bffe17 	ldw	r2,-8(fp)
81137e18:	10800d83 	ldbu	r2,54(r2)
81137e1c:	0084303a 	nor	r2,zero,r2
81137e20:	1007883a 	mov	r3,r2
81137e24:	d0a09803 	ldbu	r2,-32160(gp)
81137e28:	1884703a 	and	r2,r3,r2
81137e2c:	d0a09805 	stb	r2,-32160(gp)
    }
    ptcb->OSTCBPrio         = prio;
81137e30:	e0bffe17 	ldw	r2,-8(fp)
81137e34:	e0ffff03 	ldbu	r3,-4(fp)
81137e38:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
81137e3c:	e0bfff03 	ldbu	r2,-4(fp)
81137e40:	1004d0fa 	srli	r2,r2,3
81137e44:	108001cc 	andi	r2,r2,7
81137e48:	1007883a 	mov	r3,r2
81137e4c:	e0bffe17 	ldw	r2,-8(fp)
81137e50:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
81137e54:	e0bfff03 	ldbu	r2,-4(fp)
81137e58:	108001cc 	andi	r2,r2,7
81137e5c:	1007883a 	mov	r3,r2
81137e60:	e0bffe17 	ldw	r2,-8(fp)
81137e64:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
81137e68:	e0bffe17 	ldw	r2,-8(fp)
81137e6c:	10800d03 	ldbu	r2,52(r2)
81137e70:	10803fcc 	andi	r2,r2,255
81137e74:	00c00044 	movi	r3,1
81137e78:	1884983a 	sll	r2,r3,r2
81137e7c:	1007883a 	mov	r3,r2
81137e80:	e0bffe17 	ldw	r2,-8(fp)
81137e84:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
81137e88:	e0bffe17 	ldw	r2,-8(fp)
81137e8c:	10800cc3 	ldbu	r2,51(r2)
81137e90:	10803fcc 	andi	r2,r2,255
81137e94:	00c00044 	movi	r3,1
81137e98:	1884983a 	sll	r2,r3,r2
81137e9c:	1007883a 	mov	r3,r2
81137ea0:	e0bffe17 	ldw	r2,-8(fp)
81137ea4:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
81137ea8:	e0bffe17 	ldw	r2,-8(fp)
81137eac:	10c00d83 	ldbu	r3,54(r2)
81137eb0:	d0a09803 	ldbu	r2,-32160(gp)
81137eb4:	1884b03a 	or	r2,r3,r2
81137eb8:	d0a09805 	stb	r2,-32160(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81137ebc:	e0bffe17 	ldw	r2,-8(fp)
81137ec0:	10800d03 	ldbu	r2,52(r2)
81137ec4:	10c03fcc 	andi	r3,r2,255
81137ec8:	e0bffe17 	ldw	r2,-8(fp)
81137ecc:	10800d03 	ldbu	r2,52(r2)
81137ed0:	11003fcc 	andi	r4,r2,255
81137ed4:	d0a09844 	addi	r2,gp,-32159
81137ed8:	2085883a 	add	r2,r4,r2
81137edc:	11000003 	ldbu	r4,0(r2)
81137ee0:	e0bffe17 	ldw	r2,-8(fp)
81137ee4:	10800d43 	ldbu	r2,53(r2)
81137ee8:	2084b03a 	or	r2,r4,r2
81137eec:	1009883a 	mov	r4,r2
81137ef0:	d0a09844 	addi	r2,gp,-32159
81137ef4:	1885883a 	add	r2,r3,r2
81137ef8:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
81137efc:	e0ffff03 	ldbu	r3,-4(fp)
81137f00:	00a045b4 	movhi	r2,33046
81137f04:	10979804 	addi	r2,r2,24160
81137f08:	18c7883a 	add	r3,r3,r3
81137f0c:	18c7883a 	add	r3,r3,r3
81137f10:	10c5883a 	add	r2,r2,r3
81137f14:	e0fffe17 	ldw	r3,-8(fp)
81137f18:	10c00015 	stw	r3,0(r2)
}
81137f1c:	0001883a 	nop
81137f20:	e037883a 	mov	sp,fp
81137f24:	df000017 	ldw	fp,0(sp)
81137f28:	dec00104 	addi	sp,sp,4
81137f2c:	f800283a 	ret

81137f30 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
81137f30:	defff804 	addi	sp,sp,-32
81137f34:	de00012e 	bgeu	sp,et,81137f3c <OSQAccept+0xc>
81137f38:	003b68fa 	trap	3
81137f3c:	df000715 	stw	fp,28(sp)
81137f40:	df000704 	addi	fp,sp,28
81137f44:	e13ffe15 	stw	r4,-8(fp)
81137f48:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137f4c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81137f50:	e0bfff17 	ldw	r2,-4(fp)
81137f54:	1000021e 	bne	r2,zero,81137f60 <OSQAccept+0x30>
        return ((void *)0);
81137f58:	0005883a 	mov	r2,zero
81137f5c:	00004206 	br	81138068 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
81137f60:	e0bffe17 	ldw	r2,-8(fp)
81137f64:	1000051e 	bne	r2,zero,81137f7c <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81137f68:	e0bfff17 	ldw	r2,-4(fp)
81137f6c:	00c00104 	movi	r3,4
81137f70:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81137f74:	0005883a 	mov	r2,zero
81137f78:	00003b06 	br	81138068 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81137f7c:	e0bffe17 	ldw	r2,-8(fp)
81137f80:	10800003 	ldbu	r2,0(r2)
81137f84:	10803fcc 	andi	r2,r2,255
81137f88:	108000a0 	cmpeqi	r2,r2,2
81137f8c:	1000051e 	bne	r2,zero,81137fa4 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81137f90:	e0bfff17 	ldw	r2,-4(fp)
81137f94:	00c00044 	movi	r3,1
81137f98:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81137f9c:	0005883a 	mov	r2,zero
81137fa0:	00003106 	br	81138068 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137fa4:	0005303a 	rdctl	r2,status
81137fa8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137fac:	e0fffd17 	ldw	r3,-12(fp)
81137fb0:	00bfff84 	movi	r2,-2
81137fb4:	1884703a 	and	r2,r3,r2
81137fb8:	1001703a 	wrctl	status,r2
  
  return context;
81137fbc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81137fc0:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81137fc4:	e0bffe17 	ldw	r2,-8(fp)
81137fc8:	10800117 	ldw	r2,4(r2)
81137fcc:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
81137fd0:	e0bffc17 	ldw	r2,-16(fp)
81137fd4:	1080058b 	ldhu	r2,22(r2)
81137fd8:	10bfffcc 	andi	r2,r2,65535
81137fdc:	10001926 	beq	r2,zero,81138044 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
81137fe0:	e0bffc17 	ldw	r2,-16(fp)
81137fe4:	10800417 	ldw	r2,16(r2)
81137fe8:	11000104 	addi	r4,r2,4
81137fec:	e0fffc17 	ldw	r3,-16(fp)
81137ff0:	19000415 	stw	r4,16(r3)
81137ff4:	10800017 	ldw	r2,0(r2)
81137ff8:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81137ffc:	e0bffc17 	ldw	r2,-16(fp)
81138000:	1080058b 	ldhu	r2,22(r2)
81138004:	10bfffc4 	addi	r2,r2,-1
81138008:	1007883a 	mov	r3,r2
8113800c:	e0bffc17 	ldw	r2,-16(fp)
81138010:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81138014:	e0bffc17 	ldw	r2,-16(fp)
81138018:	10c00417 	ldw	r3,16(r2)
8113801c:	e0bffc17 	ldw	r2,-16(fp)
81138020:	10800217 	ldw	r2,8(r2)
81138024:	1880041e 	bne	r3,r2,81138038 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
81138028:	e0bffc17 	ldw	r2,-16(fp)
8113802c:	10c00117 	ldw	r3,4(r2)
81138030:	e0bffc17 	ldw	r2,-16(fp)
81138034:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
81138038:	e0bfff17 	ldw	r2,-4(fp)
8113803c:	10000005 	stb	zero,0(r2)
81138040:	00000406 	br	81138054 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
81138044:	e0bfff17 	ldw	r2,-4(fp)
81138048:	00c007c4 	movi	r3,31
8113804c:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
81138050:	e03ff915 	stw	zero,-28(fp)
81138054:	e0bffa17 	ldw	r2,-24(fp)
81138058:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113805c:	e0bffb17 	ldw	r2,-20(fp)
81138060:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
81138064:	e0bff917 	ldw	r2,-28(fp)
}
81138068:	e037883a 	mov	sp,fp
8113806c:	df000017 	ldw	fp,0(sp)
81138070:	dec00104 	addi	sp,sp,4
81138074:	f800283a 	ret

81138078 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
81138078:	defff404 	addi	sp,sp,-48
8113807c:	de00012e 	bgeu	sp,et,81138084 <OSQCreate+0xc>
81138080:	003b68fa 	trap	3
81138084:	dfc00b15 	stw	ra,44(sp)
81138088:	df000a15 	stw	fp,40(sp)
8113808c:	df000a04 	addi	fp,sp,40
81138090:	e13ffe15 	stw	r4,-8(fp)
81138094:	2805883a 	mov	r2,r5
81138098:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113809c:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
811380a0:	d0a09b03 	ldbu	r2,-32148(gp)
811380a4:	10803fcc 	andi	r2,r2,255
811380a8:	10000226 	beq	r2,zero,811380b4 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
811380ac:	0005883a 	mov	r2,zero
811380b0:	00005906 	br	81138218 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811380b4:	0005303a 	rdctl	r2,status
811380b8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811380bc:	e0fffd17 	ldw	r3,-12(fp)
811380c0:	00bfff84 	movi	r2,-2
811380c4:	1884703a 	and	r2,r3,r2
811380c8:	1001703a 	wrctl	status,r2
  
  return context;
811380cc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811380d0:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
811380d4:	d0a09a17 	ldw	r2,-32152(gp)
811380d8:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
811380dc:	d0a09a17 	ldw	r2,-32152(gp)
811380e0:	10000326 	beq	r2,zero,811380f0 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
811380e4:	d0a09a17 	ldw	r2,-32152(gp)
811380e8:	10800117 	ldw	r2,4(r2)
811380ec:	d0a09a15 	stw	r2,-32152(gp)
811380f0:	e0bff717 	ldw	r2,-36(fp)
811380f4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811380f8:	e0bff817 	ldw	r2,-32(fp)
811380fc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
81138100:	e0bff617 	ldw	r2,-40(fp)
81138104:	10004326 	beq	r2,zero,81138214 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138108:	0005303a 	rdctl	r2,status
8113810c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138110:	e0fff917 	ldw	r3,-28(fp)
81138114:	00bfff84 	movi	r2,-2
81138118:	1884703a 	and	r2,r3,r2
8113811c:	1001703a 	wrctl	status,r2
  
  return context;
81138120:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
81138124:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
81138128:	d0a09717 	ldw	r2,-32164(gp)
8113812c:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
81138130:	e0bffb17 	ldw	r2,-20(fp)
81138134:	10002d26 	beq	r2,zero,811381ec <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
81138138:	d0a09717 	ldw	r2,-32164(gp)
8113813c:	10800017 	ldw	r2,0(r2)
81138140:	d0a09715 	stw	r2,-32164(gp)
81138144:	e0bff717 	ldw	r2,-36(fp)
81138148:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113814c:	e0bffa17 	ldw	r2,-24(fp)
81138150:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
81138154:	e0bffb17 	ldw	r2,-20(fp)
81138158:	e0fffe17 	ldw	r3,-8(fp)
8113815c:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
81138160:	e0bfff0b 	ldhu	r2,-4(fp)
81138164:	1085883a 	add	r2,r2,r2
81138168:	1085883a 	add	r2,r2,r2
8113816c:	1007883a 	mov	r3,r2
81138170:	e0bffe17 	ldw	r2,-8(fp)
81138174:	10c7883a 	add	r3,r2,r3
81138178:	e0bffb17 	ldw	r2,-20(fp)
8113817c:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
81138180:	e0bffb17 	ldw	r2,-20(fp)
81138184:	e0fffe17 	ldw	r3,-8(fp)
81138188:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113818c:	e0bffb17 	ldw	r2,-20(fp)
81138190:	e0fffe17 	ldw	r3,-8(fp)
81138194:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
81138198:	e0bffb17 	ldw	r2,-20(fp)
8113819c:	e0ffff0b 	ldhu	r3,-4(fp)
811381a0:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
811381a4:	e0bffb17 	ldw	r2,-20(fp)
811381a8:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
811381ac:	e0bff617 	ldw	r2,-40(fp)
811381b0:	00c00084 	movi	r3,2
811381b4:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
811381b8:	e0bff617 	ldw	r2,-40(fp)
811381bc:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
811381c0:	e0bff617 	ldw	r2,-40(fp)
811381c4:	e0fffb17 	ldw	r3,-20(fp)
811381c8:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
811381cc:	e0bff617 	ldw	r2,-40(fp)
811381d0:	00c00fc4 	movi	r3,63
811381d4:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
811381d8:	e0bff617 	ldw	r2,-40(fp)
811381dc:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
811381e0:	e13ff617 	ldw	r4,-40(fp)
811381e4:	11340d80 	call	811340d8 <OS_EventWaitListInit>
811381e8:	00000a06 	br	81138214 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
811381ec:	d0e09a17 	ldw	r3,-32152(gp)
811381f0:	e0bff617 	ldw	r2,-40(fp)
811381f4:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
811381f8:	e0bff617 	ldw	r2,-40(fp)
811381fc:	d0a09a15 	stw	r2,-32152(gp)
81138200:	e0bff717 	ldw	r2,-36(fp)
81138204:	e0bffc15 	stw	r2,-16(fp)
81138208:	e0bffc17 	ldw	r2,-16(fp)
8113820c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
81138210:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
81138214:	e0bff617 	ldw	r2,-40(fp)
}
81138218:	e037883a 	mov	sp,fp
8113821c:	dfc00117 	ldw	ra,4(sp)
81138220:	df000017 	ldw	fp,0(sp)
81138224:	dec00204 	addi	sp,sp,8
81138228:	f800283a 	ret

8113822c <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113822c:	defff204 	addi	sp,sp,-56
81138230:	de00012e 	bgeu	sp,et,81138238 <OSQDel+0xc>
81138234:	003b68fa 	trap	3
81138238:	dfc00d15 	stw	ra,52(sp)
8113823c:	df000c15 	stw	fp,48(sp)
81138240:	df000c04 	addi	fp,sp,48
81138244:	e13ffd15 	stw	r4,-12(fp)
81138248:	2805883a 	mov	r2,r5
8113824c:	e1bfff15 	stw	r6,-4(fp)
81138250:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138254:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138258:	e0bfff17 	ldw	r2,-4(fp)
8113825c:	1000021e 	bne	r2,zero,81138268 <OSQDel+0x3c>
        return (pevent);
81138260:	e0bffd17 	ldw	r2,-12(fp)
81138264:	00008e06 	br	811384a0 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138268:	e0bffd17 	ldw	r2,-12(fp)
8113826c:	1000051e 	bne	r2,zero,81138284 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81138270:	e0bfff17 	ldw	r2,-4(fp)
81138274:	00c00104 	movi	r3,4
81138278:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113827c:	e0bffd17 	ldw	r2,-12(fp)
81138280:	00008706 	br	811384a0 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81138284:	e0bffd17 	ldw	r2,-12(fp)
81138288:	10800003 	ldbu	r2,0(r2)
8113828c:	10803fcc 	andi	r2,r2,255
81138290:	108000a0 	cmpeqi	r2,r2,2
81138294:	1000051e 	bne	r2,zero,811382ac <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81138298:	e0bfff17 	ldw	r2,-4(fp)
8113829c:	00c00044 	movi	r3,1
811382a0:	10c00005 	stb	r3,0(r2)
        return (pevent);
811382a4:	e0bffd17 	ldw	r2,-12(fp)
811382a8:	00007d06 	br	811384a0 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811382ac:	d0a09b03 	ldbu	r2,-32148(gp)
811382b0:	10803fcc 	andi	r2,r2,255
811382b4:	10000526 	beq	r2,zero,811382cc <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
811382b8:	e0bfff17 	ldw	r2,-4(fp)
811382bc:	00c003c4 	movi	r3,15
811382c0:	10c00005 	stb	r3,0(r2)
        return (pevent);
811382c4:	e0bffd17 	ldw	r2,-12(fp)
811382c8:	00007506 	br	811384a0 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811382cc:	0005303a 	rdctl	r2,status
811382d0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811382d4:	e0fffc17 	ldw	r3,-16(fp)
811382d8:	00bfff84 	movi	r2,-2
811382dc:	1884703a 	and	r2,r3,r2
811382e0:	1001703a 	wrctl	status,r2
  
  return context;
811382e4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811382e8:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
811382ec:	e0bffd17 	ldw	r2,-12(fp)
811382f0:	10800283 	ldbu	r2,10(r2)
811382f4:	10803fcc 	andi	r2,r2,255
811382f8:	10000326 	beq	r2,zero,81138308 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811382fc:	00800044 	movi	r2,1
81138300:	e0bff405 	stb	r2,-48(fp)
81138304:	00000106 	br	8113830c <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81138308:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113830c:	e0bffe03 	ldbu	r2,-8(fp)
81138310:	10000326 	beq	r2,zero,81138320 <OSQDel+0xf4>
81138314:	10800060 	cmpeqi	r2,r2,1
81138318:	1000301e 	bne	r2,zero,811383dc <OSQDel+0x1b0>
8113831c:	00005506 	br	81138474 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
81138320:	e0bff403 	ldbu	r2,-48(fp)
81138324:	10001e1e 	bne	r2,zero,811383a0 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81138328:	e0bffd17 	ldw	r2,-12(fp)
8113832c:	00c00fc4 	movi	r3,63
81138330:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81138334:	e0bffd17 	ldw	r2,-12(fp)
81138338:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113833c:	e0bffd17 	ldw	r2,-12(fp)
81138340:	10800117 	ldw	r2,4(r2)
81138344:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
81138348:	d0e09717 	ldw	r3,-32164(gp)
8113834c:	e0bff817 	ldw	r2,-32(fp)
81138350:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
81138354:	e0bff817 	ldw	r2,-32(fp)
81138358:	d0a09715 	stw	r2,-32164(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113835c:	e0bffd17 	ldw	r2,-12(fp)
81138360:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81138364:	d0e09a17 	ldw	r3,-32152(gp)
81138368:	e0bffd17 	ldw	r2,-12(fp)
8113836c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81138370:	e0bffd17 	ldw	r2,-12(fp)
81138374:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81138378:	e0bffd17 	ldw	r2,-12(fp)
8113837c:	d0a09a15 	stw	r2,-32152(gp)
81138380:	e0bff617 	ldw	r2,-40(fp)
81138384:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138388:	e0bff717 	ldw	r2,-36(fp)
8113838c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81138390:	e0bfff17 	ldw	r2,-4(fp)
81138394:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
81138398:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113839c:	00003f06 	br	8113849c <OSQDel+0x270>
811383a0:	e0bff617 	ldw	r2,-40(fp)
811383a4:	e0bff915 	stw	r2,-28(fp)
811383a8:	e0bff917 	ldw	r2,-28(fp)
811383ac:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
811383b0:	e0bfff17 	ldw	r2,-4(fp)
811383b4:	00c01244 	movi	r3,73
811383b8:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
811383bc:	e0bffd17 	ldw	r2,-12(fp)
811383c0:	e0bff515 	stw	r2,-44(fp)
             }
             break;
811383c4:	00003506 	br	8113849c <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
811383c8:	000f883a 	mov	r7,zero
811383cc:	01800104 	movi	r6,4
811383d0:	000b883a 	mov	r5,zero
811383d4:	e13ffd17 	ldw	r4,-12(fp)
811383d8:	1133b000 	call	81133b00 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
811383dc:	e0bffd17 	ldw	r2,-12(fp)
811383e0:	10800283 	ldbu	r2,10(r2)
811383e4:	10803fcc 	andi	r2,r2,255
811383e8:	103ff71e 	bne	r2,zero,811383c8 <__reset+0xfb1183c8>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
811383ec:	e0bffd17 	ldw	r2,-12(fp)
811383f0:	00c00fc4 	movi	r3,63
811383f4:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
811383f8:	e0bffd17 	ldw	r2,-12(fp)
811383fc:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
81138400:	e0bffd17 	ldw	r2,-12(fp)
81138404:	10800117 	ldw	r2,4(r2)
81138408:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113840c:	d0e09717 	ldw	r3,-32164(gp)
81138410:	e0bff817 	ldw	r2,-32(fp)
81138414:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
81138418:	e0bff817 	ldw	r2,-32(fp)
8113841c:	d0a09715 	stw	r2,-32164(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81138420:	e0bffd17 	ldw	r2,-12(fp)
81138424:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
81138428:	d0e09a17 	ldw	r3,-32152(gp)
8113842c:	e0bffd17 	ldw	r2,-12(fp)
81138430:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81138434:	e0bffd17 	ldw	r2,-12(fp)
81138438:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113843c:	e0bffd17 	ldw	r2,-12(fp)
81138440:	d0a09a15 	stw	r2,-32152(gp)
81138444:	e0bff617 	ldw	r2,-40(fp)
81138448:	e0bffa15 	stw	r2,-24(fp)
8113844c:	e0bffa17 	ldw	r2,-24(fp)
81138450:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81138454:	e0bff403 	ldbu	r2,-48(fp)
81138458:	10800058 	cmpnei	r2,r2,1
8113845c:	1000011e 	bne	r2,zero,81138464 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81138460:	11345bc0 	call	811345bc <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81138464:	e0bfff17 	ldw	r2,-4(fp)
81138468:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113846c:	e03ff515 	stw	zero,-44(fp)
             break;
81138470:	00000a06 	br	8113849c <OSQDel+0x270>
81138474:	e0bff617 	ldw	r2,-40(fp)
81138478:	e0bffb15 	stw	r2,-20(fp)
8113847c:	e0bffb17 	ldw	r2,-20(fp)
81138480:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81138484:	e0bfff17 	ldw	r2,-4(fp)
81138488:	00c001c4 	movi	r3,7
8113848c:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81138490:	e0bffd17 	ldw	r2,-12(fp)
81138494:	e0bff515 	stw	r2,-44(fp)
             break;
81138498:	0001883a 	nop
    }
    return (pevent_return);
8113849c:	e0bff517 	ldw	r2,-44(fp)
}
811384a0:	e037883a 	mov	sp,fp
811384a4:	dfc00117 	ldw	ra,4(sp)
811384a8:	df000017 	ldw	fp,0(sp)
811384ac:	dec00204 	addi	sp,sp,8
811384b0:	f800283a 	ret

811384b4 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
811384b4:	defffa04 	addi	sp,sp,-24
811384b8:	de00012e 	bgeu	sp,et,811384c0 <OSQFlush+0xc>
811384bc:	003b68fa 	trap	3
811384c0:	df000515 	stw	fp,20(sp)
811384c4:	df000504 	addi	fp,sp,20
811384c8:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811384cc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811384d0:	e0bfff17 	ldw	r2,-4(fp)
811384d4:	1000021e 	bne	r2,zero,811384e0 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
811384d8:	00800104 	movi	r2,4
811384dc:	00002106 	br	81138564 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
811384e0:	e0bfff17 	ldw	r2,-4(fp)
811384e4:	10800003 	ldbu	r2,0(r2)
811384e8:	10803fcc 	andi	r2,r2,255
811384ec:	108000a0 	cmpeqi	r2,r2,2
811384f0:	1000021e 	bne	r2,zero,811384fc <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
811384f4:	00800044 	movi	r2,1
811384f8:	00001a06 	br	81138564 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811384fc:	0005303a 	rdctl	r2,status
81138500:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138504:	e0fffd17 	ldw	r3,-12(fp)
81138508:	00bfff84 	movi	r2,-2
8113850c:	1884703a 	and	r2,r3,r2
81138510:	1001703a 	wrctl	status,r2
  
  return context;
81138514:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138518:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113851c:	e0bfff17 	ldw	r2,-4(fp)
81138520:	10800117 	ldw	r2,4(r2)
81138524:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
81138528:	e0bffc17 	ldw	r2,-16(fp)
8113852c:	10c00117 	ldw	r3,4(r2)
81138530:	e0bffc17 	ldw	r2,-16(fp)
81138534:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
81138538:	e0bffc17 	ldw	r2,-16(fp)
8113853c:	10c00117 	ldw	r3,4(r2)
81138540:	e0bffc17 	ldw	r2,-16(fp)
81138544:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
81138548:	e0bffc17 	ldw	r2,-16(fp)
8113854c:	1000058d 	sth	zero,22(r2)
81138550:	e0bffb17 	ldw	r2,-20(fp)
81138554:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138558:	e0bffe17 	ldw	r2,-8(fp)
8113855c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138560:	0005883a 	mov	r2,zero
}
81138564:	e037883a 	mov	sp,fp
81138568:	df000017 	ldw	fp,0(sp)
8113856c:	dec00104 	addi	sp,sp,4
81138570:	f800283a 	ret

81138574 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81138574:	defff304 	addi	sp,sp,-52
81138578:	de00012e 	bgeu	sp,et,81138580 <OSQPend+0xc>
8113857c:	003b68fa 	trap	3
81138580:	dfc00c15 	stw	ra,48(sp)
81138584:	df000b15 	stw	fp,44(sp)
81138588:	df000b04 	addi	fp,sp,44
8113858c:	e13ffd15 	stw	r4,-12(fp)
81138590:	2805883a 	mov	r2,r5
81138594:	e1bfff15 	stw	r6,-4(fp)
81138598:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113859c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811385a0:	e0bfff17 	ldw	r2,-4(fp)
811385a4:	1000021e 	bne	r2,zero,811385b0 <OSQPend+0x3c>
        return ((void *)0);
811385a8:	0005883a 	mov	r2,zero
811385ac:	00009106 	br	811387f4 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
811385b0:	e0bffd17 	ldw	r2,-12(fp)
811385b4:	1000051e 	bne	r2,zero,811385cc <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811385b8:	e0bfff17 	ldw	r2,-4(fp)
811385bc:	00c00104 	movi	r3,4
811385c0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811385c4:	0005883a 	mov	r2,zero
811385c8:	00008a06 	br	811387f4 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
811385cc:	e0bffd17 	ldw	r2,-12(fp)
811385d0:	10800003 	ldbu	r2,0(r2)
811385d4:	10803fcc 	andi	r2,r2,255
811385d8:	108000a0 	cmpeqi	r2,r2,2
811385dc:	1000051e 	bne	r2,zero,811385f4 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811385e0:	e0bfff17 	ldw	r2,-4(fp)
811385e4:	00c00044 	movi	r3,1
811385e8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811385ec:	0005883a 	mov	r2,zero
811385f0:	00008006 	br	811387f4 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
811385f4:	d0a09b03 	ldbu	r2,-32148(gp)
811385f8:	10803fcc 	andi	r2,r2,255
811385fc:	10000526 	beq	r2,zero,81138614 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
81138600:	e0bfff17 	ldw	r2,-4(fp)
81138604:	00c00084 	movi	r3,2
81138608:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113860c:	0005883a 	mov	r2,zero
81138610:	00007806 	br	811387f4 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
81138614:	d0a08903 	ldbu	r2,-32220(gp)
81138618:	10803fcc 	andi	r2,r2,255
8113861c:	10000526 	beq	r2,zero,81138634 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
81138620:	e0bfff17 	ldw	r2,-4(fp)
81138624:	00c00344 	movi	r3,13
81138628:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113862c:	0005883a 	mov	r2,zero
81138630:	00007006 	br	811387f4 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138634:	0005303a 	rdctl	r2,status
81138638:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113863c:	e0fffc17 	ldw	r3,-16(fp)
81138640:	00bfff84 	movi	r2,-2
81138644:	1884703a 	and	r2,r3,r2
81138648:	1001703a 	wrctl	status,r2
  
  return context;
8113864c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138650:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81138654:	e0bffd17 	ldw	r2,-12(fp)
81138658:	10800117 	ldw	r2,4(r2)
8113865c:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
81138660:	e0bff817 	ldw	r2,-32(fp)
81138664:	1080058b 	ldhu	r2,22(r2)
81138668:	10bfffcc 	andi	r2,r2,65535
8113866c:	10001e26 	beq	r2,zero,811386e8 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
81138670:	e0bff817 	ldw	r2,-32(fp)
81138674:	10800417 	ldw	r2,16(r2)
81138678:	11000104 	addi	r4,r2,4
8113867c:	e0fff817 	ldw	r3,-32(fp)
81138680:	19000415 	stw	r4,16(r3)
81138684:	10800017 	ldw	r2,0(r2)
81138688:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113868c:	e0bff817 	ldw	r2,-32(fp)
81138690:	1080058b 	ldhu	r2,22(r2)
81138694:	10bfffc4 	addi	r2,r2,-1
81138698:	1007883a 	mov	r3,r2
8113869c:	e0bff817 	ldw	r2,-32(fp)
811386a0:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
811386a4:	e0bff817 	ldw	r2,-32(fp)
811386a8:	10c00417 	ldw	r3,16(r2)
811386ac:	e0bff817 	ldw	r2,-32(fp)
811386b0:	10800217 	ldw	r2,8(r2)
811386b4:	1880041e 	bne	r3,r2,811386c8 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
811386b8:	e0bff817 	ldw	r2,-32(fp)
811386bc:	10c00117 	ldw	r3,4(r2)
811386c0:	e0bff817 	ldw	r2,-32(fp)
811386c4:	10c00415 	stw	r3,16(r2)
811386c8:	e0bff617 	ldw	r2,-40(fp)
811386cc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811386d0:	e0bff717 	ldw	r2,-36(fp)
811386d4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
811386d8:	e0bfff17 	ldw	r2,-4(fp)
811386dc:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
811386e0:	e0bff517 	ldw	r2,-44(fp)
811386e4:	00004306 	br	811387f4 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
811386e8:	d0a09c17 	ldw	r2,-32144(gp)
811386ec:	d0e09c17 	ldw	r3,-32144(gp)
811386f0:	18c00c03 	ldbu	r3,48(r3)
811386f4:	18c00114 	ori	r3,r3,4
811386f8:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
811386fc:	d0a09c17 	ldw	r2,-32144(gp)
81138700:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
81138704:	d0a09c17 	ldw	r2,-32144(gp)
81138708:	e0fffe0b 	ldhu	r3,-8(fp)
8113870c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
81138710:	e13ffd17 	ldw	r4,-12(fp)
81138714:	1133ca00 	call	81133ca0 <OS_EventTaskWait>
81138718:	e0bff617 	ldw	r2,-40(fp)
8113871c:	e0bffb15 	stw	r2,-20(fp)
81138720:	e0bffb17 	ldw	r2,-20(fp)
81138724:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
81138728:	11345bc0 	call	811345bc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113872c:	0005303a 	rdctl	r2,status
81138730:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138734:	e0fff917 	ldw	r3,-28(fp)
81138738:	00bfff84 	movi	r2,-2
8113873c:	1884703a 	and	r2,r3,r2
81138740:	1001703a 	wrctl	status,r2
  
  return context;
81138744:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81138748:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113874c:	d0a09c17 	ldw	r2,-32144(gp)
81138750:	10800c43 	ldbu	r2,49(r2)
81138754:	10803fcc 	andi	r2,r2,255
81138758:	10000326 	beq	r2,zero,81138768 <OSQPend+0x1f4>
8113875c:	108000a0 	cmpeqi	r2,r2,2
81138760:	1000071e 	bne	r2,zero,81138780 <OSQPend+0x20c>
81138764:	00000b06 	br	81138794 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
81138768:	d0a09c17 	ldw	r2,-32144(gp)
8113876c:	10800917 	ldw	r2,36(r2)
81138770:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
81138774:	e0bfff17 	ldw	r2,-4(fp)
81138778:	10000005 	stb	zero,0(r2)
             break;
8113877c:	00000e06 	br	811387b8 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
81138780:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81138784:	e0bfff17 	ldw	r2,-4(fp)
81138788:	00c00384 	movi	r3,14
8113878c:	10c00005 	stb	r3,0(r2)
             break;
81138790:	00000906 	br	811387b8 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81138794:	d0a09c17 	ldw	r2,-32144(gp)
81138798:	e17ffd17 	ldw	r5,-12(fp)
8113879c:	1009883a 	mov	r4,r2
811387a0:	1133f100 	call	81133f10 <OS_EventTaskRemove>
             pmsg = (void *)0;
811387a4:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
811387a8:	e0bfff17 	ldw	r2,-4(fp)
811387ac:	00c00284 	movi	r3,10
811387b0:	10c00005 	stb	r3,0(r2)
             break;
811387b4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
811387b8:	d0a09c17 	ldw	r2,-32144(gp)
811387bc:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
811387c0:	d0a09c17 	ldw	r2,-32144(gp)
811387c4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
811387c8:	d0a09c17 	ldw	r2,-32144(gp)
811387cc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
811387d0:	d0a09c17 	ldw	r2,-32144(gp)
811387d4:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
811387d8:	d0a09c17 	ldw	r2,-32144(gp)
811387dc:	10000915 	stw	zero,36(r2)
811387e0:	e0bff617 	ldw	r2,-40(fp)
811387e4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811387e8:	e0bffa17 	ldw	r2,-24(fp)
811387ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
811387f0:	e0bff517 	ldw	r2,-44(fp)
}
811387f4:	e037883a 	mov	sp,fp
811387f8:	dfc00117 	ldw	ra,4(sp)
811387fc:	df000017 	ldw	fp,0(sp)
81138800:	dec00204 	addi	sp,sp,8
81138804:	f800283a 	ret

81138808 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81138808:	defff604 	addi	sp,sp,-40
8113880c:	de00012e 	bgeu	sp,et,81138814 <OSQPendAbort+0xc>
81138810:	003b68fa 	trap	3
81138814:	dfc00915 	stw	ra,36(sp)
81138818:	df000815 	stw	fp,32(sp)
8113881c:	df000804 	addi	fp,sp,32
81138820:	e13ffd15 	stw	r4,-12(fp)
81138824:	2805883a 	mov	r2,r5
81138828:	e1bfff15 	stw	r6,-4(fp)
8113882c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138830:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138834:	e0bfff17 	ldw	r2,-4(fp)
81138838:	1000021e 	bne	r2,zero,81138844 <OSQPendAbort+0x3c>
        return (0);
8113883c:	0005883a 	mov	r2,zero
81138840:	00004906 	br	81138968 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138844:	e0bffd17 	ldw	r2,-12(fp)
81138848:	1000051e 	bne	r2,zero,81138860 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113884c:	e0bfff17 	ldw	r2,-4(fp)
81138850:	00c00104 	movi	r3,4
81138854:	10c00005 	stb	r3,0(r2)
        return (0);
81138858:	0005883a 	mov	r2,zero
8113885c:	00004206 	br	81138968 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81138860:	e0bffd17 	ldw	r2,-12(fp)
81138864:	10800003 	ldbu	r2,0(r2)
81138868:	10803fcc 	andi	r2,r2,255
8113886c:	108000a0 	cmpeqi	r2,r2,2
81138870:	1000051e 	bne	r2,zero,81138888 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81138874:	e0bfff17 	ldw	r2,-4(fp)
81138878:	00c00044 	movi	r3,1
8113887c:	10c00005 	stb	r3,0(r2)
        return (0);
81138880:	0005883a 	mov	r2,zero
81138884:	00003806 	br	81138968 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138888:	0005303a 	rdctl	r2,status
8113888c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138890:	e0fffc17 	ldw	r3,-16(fp)
81138894:	00bfff84 	movi	r2,-2
81138898:	1884703a 	and	r2,r3,r2
8113889c:	1001703a 	wrctl	status,r2
  
  return context;
811388a0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811388a4:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
811388a8:	e0bffd17 	ldw	r2,-12(fp)
811388ac:	10800283 	ldbu	r2,10(r2)
811388b0:	10803fcc 	andi	r2,r2,255
811388b4:	10002526 	beq	r2,zero,8113894c <OSQPendAbort+0x144>
        nbr_tasks = 0;
811388b8:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
811388bc:	e0bffe03 	ldbu	r2,-8(fp)
811388c0:	10800060 	cmpeqi	r2,r2,1
811388c4:	10000e26 	beq	r2,zero,81138900 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
811388c8:	00000806 	br	811388ec <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
811388cc:	01c00084 	movi	r7,2
811388d0:	01800104 	movi	r6,4
811388d4:	000b883a 	mov	r5,zero
811388d8:	e13ffd17 	ldw	r4,-12(fp)
811388dc:	1133b000 	call	81133b00 <OS_EventTaskRdy>
                     nbr_tasks++;
811388e0:	e0bff803 	ldbu	r2,-32(fp)
811388e4:	10800044 	addi	r2,r2,1
811388e8:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
811388ec:	e0bffd17 	ldw	r2,-12(fp)
811388f0:	10800283 	ldbu	r2,10(r2)
811388f4:	10803fcc 	andi	r2,r2,255
811388f8:	103ff41e 	bne	r2,zero,811388cc <__reset+0xfb1188cc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
811388fc:	00000906 	br	81138924 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81138900:	01c00084 	movi	r7,2
81138904:	01800104 	movi	r6,4
81138908:	000b883a 	mov	r5,zero
8113890c:	e13ffd17 	ldw	r4,-12(fp)
81138910:	1133b000 	call	81133b00 <OS_EventTaskRdy>
                 nbr_tasks++;
81138914:	e0bff803 	ldbu	r2,-32(fp)
81138918:	10800044 	addi	r2,r2,1
8113891c:	e0bff805 	stb	r2,-32(fp)
                 break;
81138920:	0001883a 	nop
81138924:	e0bff917 	ldw	r2,-28(fp)
81138928:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113892c:	e0bffa17 	ldw	r2,-24(fp)
81138930:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
81138934:	11345bc0 	call	811345bc <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81138938:	e0bfff17 	ldw	r2,-4(fp)
8113893c:	00c00384 	movi	r3,14
81138940:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81138944:	e0bff803 	ldbu	r2,-32(fp)
81138948:	00000706 	br	81138968 <OSQPendAbort+0x160>
8113894c:	e0bff917 	ldw	r2,-28(fp)
81138950:	e0bffb15 	stw	r2,-20(fp)
81138954:	e0bffb17 	ldw	r2,-20(fp)
81138958:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113895c:	e0bfff17 	ldw	r2,-4(fp)
81138960:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
81138964:	0005883a 	mov	r2,zero
}
81138968:	e037883a 	mov	sp,fp
8113896c:	dfc00117 	ldw	ra,4(sp)
81138970:	df000017 	ldw	fp,0(sp)
81138974:	dec00204 	addi	sp,sp,8
81138978:	f800283a 	ret

8113897c <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113897c:	defff604 	addi	sp,sp,-40
81138980:	de00012e 	bgeu	sp,et,81138988 <OSQPost+0xc>
81138984:	003b68fa 	trap	3
81138988:	dfc00915 	stw	ra,36(sp)
8113898c:	df000815 	stw	fp,32(sp)
81138990:	df000804 	addi	fp,sp,32
81138994:	e13ffe15 	stw	r4,-8(fp)
81138998:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113899c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
811389a0:	e0bffe17 	ldw	r2,-8(fp)
811389a4:	1000021e 	bne	r2,zero,811389b0 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
811389a8:	00800104 	movi	r2,4
811389ac:	00004a06 	br	81138ad8 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
811389b0:	e0bffe17 	ldw	r2,-8(fp)
811389b4:	10800003 	ldbu	r2,0(r2)
811389b8:	10803fcc 	andi	r2,r2,255
811389bc:	108000a0 	cmpeqi	r2,r2,2
811389c0:	1000021e 	bne	r2,zero,811389cc <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
811389c4:	00800044 	movi	r2,1
811389c8:	00004306 	br	81138ad8 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811389cc:	0005303a 	rdctl	r2,status
811389d0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811389d4:	e0fffd17 	ldw	r3,-12(fp)
811389d8:	00bfff84 	movi	r2,-2
811389dc:	1884703a 	and	r2,r3,r2
811389e0:	1001703a 	wrctl	status,r2
  
  return context;
811389e4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811389e8:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
811389ec:	e0bffe17 	ldw	r2,-8(fp)
811389f0:	10800283 	ldbu	r2,10(r2)
811389f4:	10803fcc 	andi	r2,r2,255
811389f8:	10000c26 	beq	r2,zero,81138a2c <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
811389fc:	000f883a 	mov	r7,zero
81138a00:	01800104 	movi	r6,4
81138a04:	e17fff17 	ldw	r5,-4(fp)
81138a08:	e13ffe17 	ldw	r4,-8(fp)
81138a0c:	1133b000 	call	81133b00 <OS_EventTaskRdy>
81138a10:	e0bff817 	ldw	r2,-32(fp)
81138a14:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138a18:	e0bff917 	ldw	r2,-28(fp)
81138a1c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
81138a20:	11345bc0 	call	811345bc <OS_Sched>
        return (OS_ERR_NONE);
81138a24:	0005883a 	mov	r2,zero
81138a28:	00002b06 	br	81138ad8 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
81138a2c:	e0bffe17 	ldw	r2,-8(fp)
81138a30:	10800117 	ldw	r2,4(r2)
81138a34:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
81138a38:	e0bffb17 	ldw	r2,-20(fp)
81138a3c:	10c0058b 	ldhu	r3,22(r2)
81138a40:	e0bffb17 	ldw	r2,-20(fp)
81138a44:	1080050b 	ldhu	r2,20(r2)
81138a48:	18ffffcc 	andi	r3,r3,65535
81138a4c:	10bfffcc 	andi	r2,r2,65535
81138a50:	18800636 	bltu	r3,r2,81138a6c <OSQPost+0xf0>
81138a54:	e0bff817 	ldw	r2,-32(fp)
81138a58:	e0bffa15 	stw	r2,-24(fp)
81138a5c:	e0bffa17 	ldw	r2,-24(fp)
81138a60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81138a64:	00800784 	movi	r2,30
81138a68:	00001b06 	br	81138ad8 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
81138a6c:	e0bffb17 	ldw	r2,-20(fp)
81138a70:	10800317 	ldw	r2,12(r2)
81138a74:	11000104 	addi	r4,r2,4
81138a78:	e0fffb17 	ldw	r3,-20(fp)
81138a7c:	19000315 	stw	r4,12(r3)
81138a80:	e0ffff17 	ldw	r3,-4(fp)
81138a84:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
81138a88:	e0bffb17 	ldw	r2,-20(fp)
81138a8c:	1080058b 	ldhu	r2,22(r2)
81138a90:	10800044 	addi	r2,r2,1
81138a94:	1007883a 	mov	r3,r2
81138a98:	e0bffb17 	ldw	r2,-20(fp)
81138a9c:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
81138aa0:	e0bffb17 	ldw	r2,-20(fp)
81138aa4:	10c00317 	ldw	r3,12(r2)
81138aa8:	e0bffb17 	ldw	r2,-20(fp)
81138aac:	10800217 	ldw	r2,8(r2)
81138ab0:	1880041e 	bne	r3,r2,81138ac4 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
81138ab4:	e0bffb17 	ldw	r2,-20(fp)
81138ab8:	10c00117 	ldw	r3,4(r2)
81138abc:	e0bffb17 	ldw	r2,-20(fp)
81138ac0:	10c00315 	stw	r3,12(r2)
81138ac4:	e0bff817 	ldw	r2,-32(fp)
81138ac8:	e0bffc15 	stw	r2,-16(fp)
81138acc:	e0bffc17 	ldw	r2,-16(fp)
81138ad0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138ad4:	0005883a 	mov	r2,zero
}
81138ad8:	e037883a 	mov	sp,fp
81138adc:	dfc00117 	ldw	ra,4(sp)
81138ae0:	df000017 	ldw	fp,0(sp)
81138ae4:	dec00204 	addi	sp,sp,8
81138ae8:	f800283a 	ret

81138aec <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
81138aec:	defff604 	addi	sp,sp,-40
81138af0:	de00012e 	bgeu	sp,et,81138af8 <OSQPostFront+0xc>
81138af4:	003b68fa 	trap	3
81138af8:	dfc00915 	stw	ra,36(sp)
81138afc:	df000815 	stw	fp,32(sp)
81138b00:	df000804 	addi	fp,sp,32
81138b04:	e13ffe15 	stw	r4,-8(fp)
81138b08:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81138b0c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81138b10:	e0bffe17 	ldw	r2,-8(fp)
81138b14:	1000021e 	bne	r2,zero,81138b20 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
81138b18:	00800104 	movi	r2,4
81138b1c:	00004c06 	br	81138c50 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81138b20:	e0bffe17 	ldw	r2,-8(fp)
81138b24:	10800003 	ldbu	r2,0(r2)
81138b28:	10803fcc 	andi	r2,r2,255
81138b2c:	108000a0 	cmpeqi	r2,r2,2
81138b30:	1000021e 	bne	r2,zero,81138b3c <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
81138b34:	00800044 	movi	r2,1
81138b38:	00004506 	br	81138c50 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138b3c:	0005303a 	rdctl	r2,status
81138b40:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138b44:	e0fffd17 	ldw	r3,-12(fp)
81138b48:	00bfff84 	movi	r2,-2
81138b4c:	1884703a 	and	r2,r3,r2
81138b50:	1001703a 	wrctl	status,r2
  
  return context;
81138b54:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81138b58:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
81138b5c:	e0bffe17 	ldw	r2,-8(fp)
81138b60:	10800283 	ldbu	r2,10(r2)
81138b64:	10803fcc 	andi	r2,r2,255
81138b68:	10000c26 	beq	r2,zero,81138b9c <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81138b6c:	000f883a 	mov	r7,zero
81138b70:	01800104 	movi	r6,4
81138b74:	e17fff17 	ldw	r5,-4(fp)
81138b78:	e13ffe17 	ldw	r4,-8(fp)
81138b7c:	1133b000 	call	81133b00 <OS_EventTaskRdy>
81138b80:	e0bff817 	ldw	r2,-32(fp)
81138b84:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138b88:	e0bff917 	ldw	r2,-28(fp)
81138b8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
81138b90:	11345bc0 	call	811345bc <OS_Sched>
        return (OS_ERR_NONE);
81138b94:	0005883a 	mov	r2,zero
81138b98:	00002d06 	br	81138c50 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81138b9c:	e0bffe17 	ldw	r2,-8(fp)
81138ba0:	10800117 	ldw	r2,4(r2)
81138ba4:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81138ba8:	e0bffb17 	ldw	r2,-20(fp)
81138bac:	10c0058b 	ldhu	r3,22(r2)
81138bb0:	e0bffb17 	ldw	r2,-20(fp)
81138bb4:	1080050b 	ldhu	r2,20(r2)
81138bb8:	18ffffcc 	andi	r3,r3,65535
81138bbc:	10bfffcc 	andi	r2,r2,65535
81138bc0:	18800636 	bltu	r3,r2,81138bdc <OSQPostFront+0xf0>
81138bc4:	e0bff817 	ldw	r2,-32(fp)
81138bc8:	e0bffa15 	stw	r2,-24(fp)
81138bcc:	e0bffa17 	ldw	r2,-24(fp)
81138bd0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81138bd4:	00800784 	movi	r2,30
81138bd8:	00001d06 	br	81138c50 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
81138bdc:	e0bffb17 	ldw	r2,-20(fp)
81138be0:	10c00417 	ldw	r3,16(r2)
81138be4:	e0bffb17 	ldw	r2,-20(fp)
81138be8:	10800117 	ldw	r2,4(r2)
81138bec:	1880041e 	bne	r3,r2,81138c00 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
81138bf0:	e0bffb17 	ldw	r2,-20(fp)
81138bf4:	10c00217 	ldw	r3,8(r2)
81138bf8:	e0bffb17 	ldw	r2,-20(fp)
81138bfc:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
81138c00:	e0bffb17 	ldw	r2,-20(fp)
81138c04:	10800417 	ldw	r2,16(r2)
81138c08:	10ffff04 	addi	r3,r2,-4
81138c0c:	e0bffb17 	ldw	r2,-20(fp)
81138c10:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
81138c14:	e0bffb17 	ldw	r2,-20(fp)
81138c18:	10800417 	ldw	r2,16(r2)
81138c1c:	e0ffff17 	ldw	r3,-4(fp)
81138c20:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81138c24:	e0bffb17 	ldw	r2,-20(fp)
81138c28:	1080058b 	ldhu	r2,22(r2)
81138c2c:	10800044 	addi	r2,r2,1
81138c30:	1007883a 	mov	r3,r2
81138c34:	e0bffb17 	ldw	r2,-20(fp)
81138c38:	10c0058d 	sth	r3,22(r2)
81138c3c:	e0bff817 	ldw	r2,-32(fp)
81138c40:	e0bffc15 	stw	r2,-16(fp)
81138c44:	e0bffc17 	ldw	r2,-16(fp)
81138c48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138c4c:	0005883a 	mov	r2,zero
}
81138c50:	e037883a 	mov	sp,fp
81138c54:	dfc00117 	ldw	ra,4(sp)
81138c58:	df000017 	ldw	fp,0(sp)
81138c5c:	dec00204 	addi	sp,sp,8
81138c60:	f800283a 	ret

81138c64 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
81138c64:	defff504 	addi	sp,sp,-44
81138c68:	de00012e 	bgeu	sp,et,81138c70 <OSQPostOpt+0xc>
81138c6c:	003b68fa 	trap	3
81138c70:	dfc00a15 	stw	ra,40(sp)
81138c74:	df000915 	stw	fp,36(sp)
81138c78:	df000904 	addi	fp,sp,36
81138c7c:	e13ffd15 	stw	r4,-12(fp)
81138c80:	e17ffe15 	stw	r5,-8(fp)
81138c84:	3005883a 	mov	r2,r6
81138c88:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81138c8c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81138c90:	e0bffd17 	ldw	r2,-12(fp)
81138c94:	1000021e 	bne	r2,zero,81138ca0 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
81138c98:	00800104 	movi	r2,4
81138c9c:	00007106 	br	81138e64 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81138ca0:	e0bffd17 	ldw	r2,-12(fp)
81138ca4:	10800003 	ldbu	r2,0(r2)
81138ca8:	10803fcc 	andi	r2,r2,255
81138cac:	108000a0 	cmpeqi	r2,r2,2
81138cb0:	1000021e 	bne	r2,zero,81138cbc <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
81138cb4:	00800044 	movi	r2,1
81138cb8:	00006a06 	br	81138e64 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138cbc:	0005303a 	rdctl	r2,status
81138cc0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138cc4:	e0fffc17 	ldw	r3,-16(fp)
81138cc8:	00bfff84 	movi	r2,-2
81138ccc:	1884703a 	and	r2,r3,r2
81138cd0:	1001703a 	wrctl	status,r2
  
  return context;
81138cd4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138cd8:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
81138cdc:	e0bffd17 	ldw	r2,-12(fp)
81138ce0:	10800283 	ldbu	r2,10(r2)
81138ce4:	10803fcc 	andi	r2,r2,255
81138ce8:	10001d26 	beq	r2,zero,81138d60 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
81138cec:	e0bfff03 	ldbu	r2,-4(fp)
81138cf0:	1080004c 	andi	r2,r2,1
81138cf4:	10000b26 	beq	r2,zero,81138d24 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81138cf8:	00000506 	br	81138d10 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81138cfc:	000f883a 	mov	r7,zero
81138d00:	01800104 	movi	r6,4
81138d04:	e17ffe17 	ldw	r5,-8(fp)
81138d08:	e13ffd17 	ldw	r4,-12(fp)
81138d0c:	1133b000 	call	81133b00 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81138d10:	e0bffd17 	ldw	r2,-12(fp)
81138d14:	10800283 	ldbu	r2,10(r2)
81138d18:	10803fcc 	andi	r2,r2,255
81138d1c:	103ff71e 	bne	r2,zero,81138cfc <__reset+0xfb118cfc>
81138d20:	00000506 	br	81138d38 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81138d24:	000f883a 	mov	r7,zero
81138d28:	01800104 	movi	r6,4
81138d2c:	e17ffe17 	ldw	r5,-8(fp)
81138d30:	e13ffd17 	ldw	r4,-12(fp)
81138d34:	1133b000 	call	81133b00 <OS_EventTaskRdy>
81138d38:	e0bff717 	ldw	r2,-36(fp)
81138d3c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138d40:	e0bff817 	ldw	r2,-32(fp)
81138d44:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
81138d48:	e0bfff03 	ldbu	r2,-4(fp)
81138d4c:	1080010c 	andi	r2,r2,4
81138d50:	1000011e 	bne	r2,zero,81138d58 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
81138d54:	11345bc0 	call	811345bc <OS_Sched>
        }
        return (OS_ERR_NONE);
81138d58:	0005883a 	mov	r2,zero
81138d5c:	00004106 	br	81138e64 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81138d60:	e0bffd17 	ldw	r2,-12(fp)
81138d64:	10800117 	ldw	r2,4(r2)
81138d68:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81138d6c:	e0bffa17 	ldw	r2,-24(fp)
81138d70:	10c0058b 	ldhu	r3,22(r2)
81138d74:	e0bffa17 	ldw	r2,-24(fp)
81138d78:	1080050b 	ldhu	r2,20(r2)
81138d7c:	18ffffcc 	andi	r3,r3,65535
81138d80:	10bfffcc 	andi	r2,r2,65535
81138d84:	18800636 	bltu	r3,r2,81138da0 <OSQPostOpt+0x13c>
81138d88:	e0bff717 	ldw	r2,-36(fp)
81138d8c:	e0bff915 	stw	r2,-28(fp)
81138d90:	e0bff917 	ldw	r2,-28(fp)
81138d94:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81138d98:	00800784 	movi	r2,30
81138d9c:	00003106 	br	81138e64 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
81138da0:	e0bfff03 	ldbu	r2,-4(fp)
81138da4:	1080008c 	andi	r2,r2,2
81138da8:	10001326 	beq	r2,zero,81138df8 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
81138dac:	e0bffa17 	ldw	r2,-24(fp)
81138db0:	10c00417 	ldw	r3,16(r2)
81138db4:	e0bffa17 	ldw	r2,-24(fp)
81138db8:	10800117 	ldw	r2,4(r2)
81138dbc:	1880041e 	bne	r3,r2,81138dd0 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
81138dc0:	e0bffa17 	ldw	r2,-24(fp)
81138dc4:	10c00217 	ldw	r3,8(r2)
81138dc8:	e0bffa17 	ldw	r2,-24(fp)
81138dcc:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
81138dd0:	e0bffa17 	ldw	r2,-24(fp)
81138dd4:	10800417 	ldw	r2,16(r2)
81138dd8:	10ffff04 	addi	r3,r2,-4
81138ddc:	e0bffa17 	ldw	r2,-24(fp)
81138de0:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
81138de4:	e0bffa17 	ldw	r2,-24(fp)
81138de8:	10800417 	ldw	r2,16(r2)
81138dec:	e0fffe17 	ldw	r3,-8(fp)
81138df0:	10c00015 	stw	r3,0(r2)
81138df4:	00001006 	br	81138e38 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
81138df8:	e0bffa17 	ldw	r2,-24(fp)
81138dfc:	10800317 	ldw	r2,12(r2)
81138e00:	11000104 	addi	r4,r2,4
81138e04:	e0fffa17 	ldw	r3,-24(fp)
81138e08:	19000315 	stw	r4,12(r3)
81138e0c:	e0fffe17 	ldw	r3,-8(fp)
81138e10:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
81138e14:	e0bffa17 	ldw	r2,-24(fp)
81138e18:	10c00317 	ldw	r3,12(r2)
81138e1c:	e0bffa17 	ldw	r2,-24(fp)
81138e20:	10800217 	ldw	r2,8(r2)
81138e24:	1880041e 	bne	r3,r2,81138e38 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
81138e28:	e0bffa17 	ldw	r2,-24(fp)
81138e2c:	10c00117 	ldw	r3,4(r2)
81138e30:	e0bffa17 	ldw	r2,-24(fp)
81138e34:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81138e38:	e0bffa17 	ldw	r2,-24(fp)
81138e3c:	1080058b 	ldhu	r2,22(r2)
81138e40:	10800044 	addi	r2,r2,1
81138e44:	1007883a 	mov	r3,r2
81138e48:	e0bffa17 	ldw	r2,-24(fp)
81138e4c:	10c0058d 	sth	r3,22(r2)
81138e50:	e0bff717 	ldw	r2,-36(fp)
81138e54:	e0bffb15 	stw	r2,-20(fp)
81138e58:	e0bffb17 	ldw	r2,-20(fp)
81138e5c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138e60:	0005883a 	mov	r2,zero
}
81138e64:	e037883a 	mov	sp,fp
81138e68:	dfc00117 	ldw	ra,4(sp)
81138e6c:	df000017 	ldw	fp,0(sp)
81138e70:	dec00204 	addi	sp,sp,8
81138e74:	f800283a 	ret

81138e78 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
81138e78:	defff604 	addi	sp,sp,-40
81138e7c:	de00012e 	bgeu	sp,et,81138e84 <OSQQuery+0xc>
81138e80:	003b68fa 	trap	3
81138e84:	df000915 	stw	fp,36(sp)
81138e88:	df000904 	addi	fp,sp,36
81138e8c:	e13ffe15 	stw	r4,-8(fp)
81138e90:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81138e94:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81138e98:	e0bffe17 	ldw	r2,-8(fp)
81138e9c:	1000021e 	bne	r2,zero,81138ea8 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81138ea0:	00800104 	movi	r2,4
81138ea4:	00004906 	br	81138fcc <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
81138ea8:	e0bfff17 	ldw	r2,-4(fp)
81138eac:	1000021e 	bne	r2,zero,81138eb8 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81138eb0:	00800244 	movi	r2,9
81138eb4:	00004506 	br	81138fcc <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81138eb8:	e0bffe17 	ldw	r2,-8(fp)
81138ebc:	10800003 	ldbu	r2,0(r2)
81138ec0:	10803fcc 	andi	r2,r2,255
81138ec4:	108000a0 	cmpeqi	r2,r2,2
81138ec8:	1000021e 	bne	r2,zero,81138ed4 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81138ecc:	00800044 	movi	r2,1
81138ed0:	00003e06 	br	81138fcc <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138ed4:	0005303a 	rdctl	r2,status
81138ed8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138edc:	e0fffd17 	ldw	r3,-12(fp)
81138ee0:	00bfff84 	movi	r2,-2
81138ee4:	1884703a 	and	r2,r3,r2
81138ee8:	1001703a 	wrctl	status,r2
  
  return context;
81138eec:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81138ef0:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
81138ef4:	e0bffe17 	ldw	r2,-8(fp)
81138ef8:	10c00283 	ldbu	r3,10(r2)
81138efc:	e0bfff17 	ldw	r2,-4(fp)
81138f00:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
81138f04:	e0bffe17 	ldw	r2,-8(fp)
81138f08:	108002c4 	addi	r2,r2,11
81138f0c:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
81138f10:	e0bfff17 	ldw	r2,-4(fp)
81138f14:	10800204 	addi	r2,r2,8
81138f18:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138f1c:	e03ff705 	stb	zero,-36(fp)
81138f20:	00000b06 	br	81138f50 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
81138f24:	e0bff917 	ldw	r2,-28(fp)
81138f28:	10c00044 	addi	r3,r2,1
81138f2c:	e0fff915 	stw	r3,-28(fp)
81138f30:	e0fff817 	ldw	r3,-32(fp)
81138f34:	19000044 	addi	r4,r3,1
81138f38:	e13ff815 	stw	r4,-32(fp)
81138f3c:	18c00003 	ldbu	r3,0(r3)
81138f40:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138f44:	e0bff703 	ldbu	r2,-36(fp)
81138f48:	10800044 	addi	r2,r2,1
81138f4c:	e0bff705 	stb	r2,-36(fp)
81138f50:	e0bff703 	ldbu	r2,-36(fp)
81138f54:	108001b0 	cmpltui	r2,r2,6
81138f58:	103ff21e 	bne	r2,zero,81138f24 <__reset+0xfb118f24>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
81138f5c:	e0bffe17 	ldw	r2,-8(fp)
81138f60:	10800117 	ldw	r2,4(r2)
81138f64:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
81138f68:	e0bffc17 	ldw	r2,-16(fp)
81138f6c:	1080058b 	ldhu	r2,22(r2)
81138f70:	10bfffcc 	andi	r2,r2,65535
81138f74:	10000626 	beq	r2,zero,81138f90 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
81138f78:	e0bffc17 	ldw	r2,-16(fp)
81138f7c:	10800417 	ldw	r2,16(r2)
81138f80:	10c00017 	ldw	r3,0(r2)
81138f84:	e0bfff17 	ldw	r2,-4(fp)
81138f88:	10c00015 	stw	r3,0(r2)
81138f8c:	00000206 	br	81138f98 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
81138f90:	e0bfff17 	ldw	r2,-4(fp)
81138f94:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
81138f98:	e0bffc17 	ldw	r2,-16(fp)
81138f9c:	10c0058b 	ldhu	r3,22(r2)
81138fa0:	e0bfff17 	ldw	r2,-4(fp)
81138fa4:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
81138fa8:	e0bffc17 	ldw	r2,-16(fp)
81138fac:	10c0050b 	ldhu	r3,20(r2)
81138fb0:	e0bfff17 	ldw	r2,-4(fp)
81138fb4:	10c0018d 	sth	r3,6(r2)
81138fb8:	e0bffa17 	ldw	r2,-24(fp)
81138fbc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138fc0:	e0bffb17 	ldw	r2,-20(fp)
81138fc4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138fc8:	0005883a 	mov	r2,zero
}
81138fcc:	e037883a 	mov	sp,fp
81138fd0:	df000017 	ldw	fp,0(sp)
81138fd4:	dec00104 	addi	sp,sp,4
81138fd8:	f800283a 	ret

81138fdc <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
81138fdc:	defffb04 	addi	sp,sp,-20
81138fe0:	de00012e 	bgeu	sp,et,81138fe8 <OS_QInit+0xc>
81138fe4:	003b68fa 	trap	3
81138fe8:	dfc00415 	stw	ra,16(sp)
81138fec:	df000315 	stw	fp,12(sp)
81138ff0:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
81138ff4:	01406004 	movi	r5,384
81138ff8:	012045b4 	movhi	r4,33046
81138ffc:	210a6204 	addi	r4,r4,10632
81139000:	11344f00 	call	811344f0 <OS_MemClr>
    pq1 = &OSQTbl[0];
81139004:	00a045b4 	movhi	r2,33046
81139008:	108a6204 	addi	r2,r2,10632
8113900c:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
81139010:	00a045b4 	movhi	r2,33046
81139014:	108a6804 	addi	r2,r2,10656
81139018:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113901c:	e03ffd0d 	sth	zero,-12(fp)
81139020:	00000c06 	br	81139054 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
81139024:	e0bffe17 	ldw	r2,-8(fp)
81139028:	e0ffff17 	ldw	r3,-4(fp)
8113902c:	10c00015 	stw	r3,0(r2)
        pq1++;
81139030:	e0bffe17 	ldw	r2,-8(fp)
81139034:	10800604 	addi	r2,r2,24
81139038:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113903c:	e0bfff17 	ldw	r2,-4(fp)
81139040:	10800604 	addi	r2,r2,24
81139044:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81139048:	e0bffd0b 	ldhu	r2,-12(fp)
8113904c:	10800044 	addi	r2,r2,1
81139050:	e0bffd0d 	sth	r2,-12(fp)
81139054:	e0bffd0b 	ldhu	r2,-12(fp)
81139058:	108003f0 	cmpltui	r2,r2,15
8113905c:	103ff11e 	bne	r2,zero,81139024 <__reset+0xfb119024>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
81139060:	e0bffe17 	ldw	r2,-8(fp)
81139064:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
81139068:	00a045b4 	movhi	r2,33046
8113906c:	108a6204 	addi	r2,r2,10632
81139070:	d0a09715 	stw	r2,-32164(gp)
#endif
}
81139074:	0001883a 	nop
81139078:	e037883a 	mov	sp,fp
8113907c:	dfc00117 	ldw	ra,4(sp)
81139080:	df000017 	ldw	fp,0(sp)
81139084:	dec00204 	addi	sp,sp,8
81139088:	f800283a 	ret

8113908c <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113908c:	defffa04 	addi	sp,sp,-24
81139090:	de00012e 	bgeu	sp,et,81139098 <OSSemAccept+0xc>
81139094:	003b68fa 	trap	3
81139098:	df000515 	stw	fp,20(sp)
8113909c:	df000504 	addi	fp,sp,20
811390a0:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811390a4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811390a8:	e0bfff17 	ldw	r2,-4(fp)
811390ac:	1000021e 	bne	r2,zero,811390b8 <OSSemAccept+0x2c>
        return (0);
811390b0:	0005883a 	mov	r2,zero
811390b4:	00001f06 	br	81139134 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811390b8:	e0bfff17 	ldw	r2,-4(fp)
811390bc:	10800003 	ldbu	r2,0(r2)
811390c0:	10803fcc 	andi	r2,r2,255
811390c4:	108000e0 	cmpeqi	r2,r2,3
811390c8:	1000021e 	bne	r2,zero,811390d4 <OSSemAccept+0x48>
        return (0);
811390cc:	0005883a 	mov	r2,zero
811390d0:	00001806 	br	81139134 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811390d4:	0005303a 	rdctl	r2,status
811390d8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811390dc:	e0fffe17 	ldw	r3,-8(fp)
811390e0:	00bfff84 	movi	r2,-2
811390e4:	1884703a 	and	r2,r3,r2
811390e8:	1001703a 	wrctl	status,r2
  
  return context;
811390ec:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811390f0:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
811390f4:	e0bfff17 	ldw	r2,-4(fp)
811390f8:	1080020b 	ldhu	r2,8(r2)
811390fc:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
81139100:	e0bffd0b 	ldhu	r2,-12(fp)
81139104:	10000626 	beq	r2,zero,81139120 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
81139108:	e0bfff17 	ldw	r2,-4(fp)
8113910c:	1080020b 	ldhu	r2,8(r2)
81139110:	10bfffc4 	addi	r2,r2,-1
81139114:	1007883a 	mov	r3,r2
81139118:	e0bfff17 	ldw	r2,-4(fp)
8113911c:	10c0020d 	sth	r3,8(r2)
81139120:	e0bffb17 	ldw	r2,-20(fp)
81139124:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139128:	e0bffc17 	ldw	r2,-16(fp)
8113912c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
81139130:	e0bffd0b 	ldhu	r2,-12(fp)
}
81139134:	e037883a 	mov	sp,fp
81139138:	df000017 	ldw	fp,0(sp)
8113913c:	dec00104 	addi	sp,sp,4
81139140:	f800283a 	ret

81139144 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
81139144:	defff904 	addi	sp,sp,-28
81139148:	de00012e 	bgeu	sp,et,81139150 <OSSemCreate+0xc>
8113914c:	003b68fa 	trap	3
81139150:	dfc00615 	stw	ra,24(sp)
81139154:	df000515 	stw	fp,20(sp)
81139158:	df000504 	addi	fp,sp,20
8113915c:	2005883a 	mov	r2,r4
81139160:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139164:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139168:	d0a09b03 	ldbu	r2,-32148(gp)
8113916c:	10803fcc 	andi	r2,r2,255
81139170:	10000226 	beq	r2,zero,8113917c <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
81139174:	0005883a 	mov	r2,zero
81139178:	00002506 	br	81139210 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113917c:	0005303a 	rdctl	r2,status
81139180:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139184:	e0fffe17 	ldw	r3,-8(fp)
81139188:	00bfff84 	movi	r2,-2
8113918c:	1884703a 	and	r2,r3,r2
81139190:	1001703a 	wrctl	status,r2
  
  return context;
81139194:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81139198:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113919c:	d0a09a17 	ldw	r2,-32152(gp)
811391a0:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
811391a4:	d0a09a17 	ldw	r2,-32152(gp)
811391a8:	10000326 	beq	r2,zero,811391b8 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
811391ac:	d0a09a17 	ldw	r2,-32152(gp)
811391b0:	10800117 	ldw	r2,4(r2)
811391b4:	d0a09a15 	stw	r2,-32152(gp)
811391b8:	e0bffb17 	ldw	r2,-20(fp)
811391bc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811391c0:	e0bffc17 	ldw	r2,-16(fp)
811391c4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
811391c8:	e0bffd17 	ldw	r2,-12(fp)
811391cc:	10000f26 	beq	r2,zero,8113920c <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
811391d0:	e0bffd17 	ldw	r2,-12(fp)
811391d4:	00c000c4 	movi	r3,3
811391d8:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
811391dc:	e0bffd17 	ldw	r2,-12(fp)
811391e0:	e0ffff0b 	ldhu	r3,-4(fp)
811391e4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
811391e8:	e0bffd17 	ldw	r2,-12(fp)
811391ec:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
811391f0:	e0bffd17 	ldw	r2,-12(fp)
811391f4:	00c00fc4 	movi	r3,63
811391f8:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
811391fc:	e0bffd17 	ldw	r2,-12(fp)
81139200:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
81139204:	e13ffd17 	ldw	r4,-12(fp)
81139208:	11340d80 	call	811340d8 <OS_EventWaitListInit>
    }
    return (pevent);
8113920c:	e0bffd17 	ldw	r2,-12(fp)
}
81139210:	e037883a 	mov	sp,fp
81139214:	dfc00117 	ldw	ra,4(sp)
81139218:	df000017 	ldw	fp,0(sp)
8113921c:	dec00204 	addi	sp,sp,8
81139220:	f800283a 	ret

81139224 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81139224:	defff304 	addi	sp,sp,-52
81139228:	de00012e 	bgeu	sp,et,81139230 <OSSemDel+0xc>
8113922c:	003b68fa 	trap	3
81139230:	dfc00c15 	stw	ra,48(sp)
81139234:	df000b15 	stw	fp,44(sp)
81139238:	df000b04 	addi	fp,sp,44
8113923c:	e13ffd15 	stw	r4,-12(fp)
81139240:	2805883a 	mov	r2,r5
81139244:	e1bfff15 	stw	r6,-4(fp)
81139248:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113924c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81139250:	e0bfff17 	ldw	r2,-4(fp)
81139254:	1000021e 	bne	r2,zero,81139260 <OSSemDel+0x3c>
        return (pevent);
81139258:	e0bffd17 	ldw	r2,-12(fp)
8113925c:	00007e06 	br	81139458 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81139260:	e0bffd17 	ldw	r2,-12(fp)
81139264:	1000051e 	bne	r2,zero,8113927c <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81139268:	e0bfff17 	ldw	r2,-4(fp)
8113926c:	00c00104 	movi	r3,4
81139270:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139274:	e0bffd17 	ldw	r2,-12(fp)
81139278:	00007706 	br	81139458 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113927c:	e0bffd17 	ldw	r2,-12(fp)
81139280:	10800003 	ldbu	r2,0(r2)
81139284:	10803fcc 	andi	r2,r2,255
81139288:	108000e0 	cmpeqi	r2,r2,3
8113928c:	1000051e 	bne	r2,zero,811392a4 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81139290:	e0bfff17 	ldw	r2,-4(fp)
81139294:	00c00044 	movi	r3,1
81139298:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113929c:	e0bffd17 	ldw	r2,-12(fp)
811392a0:	00006d06 	br	81139458 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811392a4:	d0a09b03 	ldbu	r2,-32148(gp)
811392a8:	10803fcc 	andi	r2,r2,255
811392ac:	10000526 	beq	r2,zero,811392c4 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811392b0:	e0bfff17 	ldw	r2,-4(fp)
811392b4:	00c003c4 	movi	r3,15
811392b8:	10c00005 	stb	r3,0(r2)
        return (pevent);
811392bc:	e0bffd17 	ldw	r2,-12(fp)
811392c0:	00006506 	br	81139458 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811392c4:	0005303a 	rdctl	r2,status
811392c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811392cc:	e0fffc17 	ldw	r3,-16(fp)
811392d0:	00bfff84 	movi	r2,-2
811392d4:	1884703a 	and	r2,r3,r2
811392d8:	1001703a 	wrctl	status,r2
  
  return context;
811392dc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811392e0:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
811392e4:	e0bffd17 	ldw	r2,-12(fp)
811392e8:	10800283 	ldbu	r2,10(r2)
811392ec:	10803fcc 	andi	r2,r2,255
811392f0:	10000326 	beq	r2,zero,81139300 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811392f4:	00800044 	movi	r2,1
811392f8:	e0bff505 	stb	r2,-44(fp)
811392fc:	00000106 	br	81139304 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81139300:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
81139304:	e0bffe03 	ldbu	r2,-8(fp)
81139308:	10000326 	beq	r2,zero,81139318 <OSSemDel+0xf4>
8113930c:	10800060 	cmpeqi	r2,r2,1
81139310:	1000281e 	bne	r2,zero,811393b4 <OSSemDel+0x190>
81139314:	00004506 	br	8113942c <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
81139318:	e0bff503 	ldbu	r2,-44(fp)
8113931c:	1000161e 	bne	r2,zero,81139378 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81139320:	e0bffd17 	ldw	r2,-12(fp)
81139324:	00c00fc4 	movi	r3,63
81139328:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113932c:	e0bffd17 	ldw	r2,-12(fp)
81139330:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81139334:	e0bffd17 	ldw	r2,-12(fp)
81139338:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113933c:	d0e09a17 	ldw	r3,-32152(gp)
81139340:	e0bffd17 	ldw	r2,-12(fp)
81139344:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81139348:	e0bffd17 	ldw	r2,-12(fp)
8113934c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81139350:	e0bffd17 	ldw	r2,-12(fp)
81139354:	d0a09a15 	stw	r2,-32152(gp)
81139358:	e0bff717 	ldw	r2,-36(fp)
8113935c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139360:	e0bff817 	ldw	r2,-32(fp)
81139364:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81139368:	e0bfff17 	ldw	r2,-4(fp)
8113936c:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
81139370:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81139374:	00003706 	br	81139454 <OSSemDel+0x230>
81139378:	e0bff717 	ldw	r2,-36(fp)
8113937c:	e0bff915 	stw	r2,-28(fp)
81139380:	e0bff917 	ldw	r2,-28(fp)
81139384:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81139388:	e0bfff17 	ldw	r2,-4(fp)
8113938c:	00c01244 	movi	r3,73
81139390:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81139394:	e0bffd17 	ldw	r2,-12(fp)
81139398:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113939c:	00002d06 	br	81139454 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
811393a0:	000f883a 	mov	r7,zero
811393a4:	01800044 	movi	r6,1
811393a8:	000b883a 	mov	r5,zero
811393ac:	e13ffd17 	ldw	r4,-12(fp)
811393b0:	1133b000 	call	81133b00 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
811393b4:	e0bffd17 	ldw	r2,-12(fp)
811393b8:	10800283 	ldbu	r2,10(r2)
811393bc:	10803fcc 	andi	r2,r2,255
811393c0:	103ff71e 	bne	r2,zero,811393a0 <__reset+0xfb1193a0>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
811393c4:	e0bffd17 	ldw	r2,-12(fp)
811393c8:	00c00fc4 	movi	r3,63
811393cc:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
811393d0:	e0bffd17 	ldw	r2,-12(fp)
811393d4:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811393d8:	e0bffd17 	ldw	r2,-12(fp)
811393dc:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
811393e0:	d0e09a17 	ldw	r3,-32152(gp)
811393e4:	e0bffd17 	ldw	r2,-12(fp)
811393e8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
811393ec:	e0bffd17 	ldw	r2,-12(fp)
811393f0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
811393f4:	e0bffd17 	ldw	r2,-12(fp)
811393f8:	d0a09a15 	stw	r2,-32152(gp)
811393fc:	e0bff717 	ldw	r2,-36(fp)
81139400:	e0bffa15 	stw	r2,-24(fp)
81139404:	e0bffa17 	ldw	r2,-24(fp)
81139408:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113940c:	e0bff503 	ldbu	r2,-44(fp)
81139410:	10800058 	cmpnei	r2,r2,1
81139414:	1000011e 	bne	r2,zero,8113941c <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81139418:	11345bc0 	call	811345bc <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113941c:	e0bfff17 	ldw	r2,-4(fp)
81139420:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
81139424:	e03ff615 	stw	zero,-40(fp)
             break;
81139428:	00000a06 	br	81139454 <OSSemDel+0x230>
8113942c:	e0bff717 	ldw	r2,-36(fp)
81139430:	e0bffb15 	stw	r2,-20(fp)
81139434:	e0bffb17 	ldw	r2,-20(fp)
81139438:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113943c:	e0bfff17 	ldw	r2,-4(fp)
81139440:	00c001c4 	movi	r3,7
81139444:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81139448:	e0bffd17 	ldw	r2,-12(fp)
8113944c:	e0bff615 	stw	r2,-40(fp)
             break;
81139450:	0001883a 	nop
    }
    return (pevent_return);
81139454:	e0bff617 	ldw	r2,-40(fp)
}
81139458:	e037883a 	mov	sp,fp
8113945c:	dfc00117 	ldw	ra,4(sp)
81139460:	df000017 	ldw	fp,0(sp)
81139464:	dec00204 	addi	sp,sp,8
81139468:	f800283a 	ret

8113946c <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113946c:	defff504 	addi	sp,sp,-44
81139470:	de00012e 	bgeu	sp,et,81139478 <OSSemPend+0xc>
81139474:	003b68fa 	trap	3
81139478:	dfc00a15 	stw	ra,40(sp)
8113947c:	df000915 	stw	fp,36(sp)
81139480:	df000904 	addi	fp,sp,36
81139484:	e13ffd15 	stw	r4,-12(fp)
81139488:	2805883a 	mov	r2,r5
8113948c:	e1bfff15 	stw	r6,-4(fp)
81139490:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139494:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81139498:	e0bfff17 	ldw	r2,-4(fp)
8113949c:	10007226 	beq	r2,zero,81139668 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811394a0:	e0bffd17 	ldw	r2,-12(fp)
811394a4:	1000041e 	bne	r2,zero,811394b8 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
811394a8:	e0bfff17 	ldw	r2,-4(fp)
811394ac:	00c00104 	movi	r3,4
811394b0:	10c00005 	stb	r3,0(r2)
        return;
811394b4:	00006d06 	br	8113966c <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811394b8:	e0bffd17 	ldw	r2,-12(fp)
811394bc:	10800003 	ldbu	r2,0(r2)
811394c0:	10803fcc 	andi	r2,r2,255
811394c4:	108000e0 	cmpeqi	r2,r2,3
811394c8:	1000041e 	bne	r2,zero,811394dc <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
811394cc:	e0bfff17 	ldw	r2,-4(fp)
811394d0:	00c00044 	movi	r3,1
811394d4:	10c00005 	stb	r3,0(r2)
        return;
811394d8:	00006406 	br	8113966c <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
811394dc:	d0a09b03 	ldbu	r2,-32148(gp)
811394e0:	10803fcc 	andi	r2,r2,255
811394e4:	10000426 	beq	r2,zero,811394f8 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
811394e8:	e0bfff17 	ldw	r2,-4(fp)
811394ec:	00c00084 	movi	r3,2
811394f0:	10c00005 	stb	r3,0(r2)
        return;
811394f4:	00005d06 	br	8113966c <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
811394f8:	d0a08903 	ldbu	r2,-32220(gp)
811394fc:	10803fcc 	andi	r2,r2,255
81139500:	10000426 	beq	r2,zero,81139514 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
81139504:	e0bfff17 	ldw	r2,-4(fp)
81139508:	00c00344 	movi	r3,13
8113950c:	10c00005 	stb	r3,0(r2)
        return;
81139510:	00005606 	br	8113966c <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139514:	0005303a 	rdctl	r2,status
81139518:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113951c:	e0fffc17 	ldw	r3,-16(fp)
81139520:	00bfff84 	movi	r2,-2
81139524:	1884703a 	and	r2,r3,r2
81139528:	1001703a 	wrctl	status,r2
  
  return context;
8113952c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139530:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
81139534:	e0bffd17 	ldw	r2,-12(fp)
81139538:	1080020b 	ldhu	r2,8(r2)
8113953c:	10bfffcc 	andi	r2,r2,65535
81139540:	10000d26 	beq	r2,zero,81139578 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
81139544:	e0bffd17 	ldw	r2,-12(fp)
81139548:	1080020b 	ldhu	r2,8(r2)
8113954c:	10bfffc4 	addi	r2,r2,-1
81139550:	1007883a 	mov	r3,r2
81139554:	e0bffd17 	ldw	r2,-12(fp)
81139558:	10c0020d 	sth	r3,8(r2)
8113955c:	e0bff717 	ldw	r2,-36(fp)
81139560:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139564:	e0bff817 	ldw	r2,-32(fp)
81139568:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113956c:	e0bfff17 	ldw	r2,-4(fp)
81139570:	10000005 	stb	zero,0(r2)
        return;
81139574:	00003d06 	br	8113966c <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
81139578:	d0a09c17 	ldw	r2,-32144(gp)
8113957c:	d0e09c17 	ldw	r3,-32144(gp)
81139580:	18c00c03 	ldbu	r3,48(r3)
81139584:	18c00054 	ori	r3,r3,1
81139588:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113958c:	d0a09c17 	ldw	r2,-32144(gp)
81139590:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
81139594:	d0a09c17 	ldw	r2,-32144(gp)
81139598:	e0fffe0b 	ldhu	r3,-8(fp)
8113959c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
811395a0:	e13ffd17 	ldw	r4,-12(fp)
811395a4:	1133ca00 	call	81133ca0 <OS_EventTaskWait>
811395a8:	e0bff717 	ldw	r2,-36(fp)
811395ac:	e0bffb15 	stw	r2,-20(fp)
811395b0:	e0bffb17 	ldw	r2,-20(fp)
811395b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
811395b8:	11345bc0 	call	811345bc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811395bc:	0005303a 	rdctl	r2,status
811395c0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811395c4:	e0fff917 	ldw	r3,-28(fp)
811395c8:	00bfff84 	movi	r2,-2
811395cc:	1884703a 	and	r2,r3,r2
811395d0:	1001703a 	wrctl	status,r2
  
  return context;
811395d4:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
811395d8:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
811395dc:	d0a09c17 	ldw	r2,-32144(gp)
811395e0:	10800c43 	ldbu	r2,49(r2)
811395e4:	10803fcc 	andi	r2,r2,255
811395e8:	10000326 	beq	r2,zero,811395f8 <OSSemPend+0x18c>
811395ec:	108000a0 	cmpeqi	r2,r2,2
811395f0:	1000041e 	bne	r2,zero,81139604 <OSSemPend+0x198>
811395f4:	00000706 	br	81139614 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
811395f8:	e0bfff17 	ldw	r2,-4(fp)
811395fc:	10000005 	stb	zero,0(r2)
             break;
81139600:	00000c06 	br	81139634 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81139604:	e0bfff17 	ldw	r2,-4(fp)
81139608:	00c00384 	movi	r3,14
8113960c:	10c00005 	stb	r3,0(r2)
             break;
81139610:	00000806 	br	81139634 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
81139614:	d0a09c17 	ldw	r2,-32144(gp)
81139618:	e17ffd17 	ldw	r5,-12(fp)
8113961c:	1009883a 	mov	r4,r2
81139620:	1133f100 	call	81133f10 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81139624:	e0bfff17 	ldw	r2,-4(fp)
81139628:	00c00284 	movi	r3,10
8113962c:	10c00005 	stb	r3,0(r2)
             break;
81139630:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81139634:	d0a09c17 	ldw	r2,-32144(gp)
81139638:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113963c:	d0a09c17 	ldw	r2,-32144(gp)
81139640:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81139644:	d0a09c17 	ldw	r2,-32144(gp)
81139648:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113964c:	d0a09c17 	ldw	r2,-32144(gp)
81139650:	10000815 	stw	zero,32(r2)
81139654:	e0bff717 	ldw	r2,-36(fp)
81139658:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113965c:	e0bffa17 	ldw	r2,-24(fp)
81139660:	1001703a 	wrctl	status,r2
81139664:	00000106 	br	8113966c <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81139668:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113966c:	e037883a 	mov	sp,fp
81139670:	dfc00117 	ldw	ra,4(sp)
81139674:	df000017 	ldw	fp,0(sp)
81139678:	dec00204 	addi	sp,sp,8
8113967c:	f800283a 	ret

81139680 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81139680:	defff604 	addi	sp,sp,-40
81139684:	de00012e 	bgeu	sp,et,8113968c <OSSemPendAbort+0xc>
81139688:	003b68fa 	trap	3
8113968c:	dfc00915 	stw	ra,36(sp)
81139690:	df000815 	stw	fp,32(sp)
81139694:	df000804 	addi	fp,sp,32
81139698:	e13ffd15 	stw	r4,-12(fp)
8113969c:	2805883a 	mov	r2,r5
811396a0:	e1bfff15 	stw	r6,-4(fp)
811396a4:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811396a8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
811396ac:	e0bfff17 	ldw	r2,-4(fp)
811396b0:	1000021e 	bne	r2,zero,811396bc <OSSemPendAbort+0x3c>
        return (0);
811396b4:	0005883a 	mov	r2,zero
811396b8:	00004906 	br	811397e0 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811396bc:	e0bffd17 	ldw	r2,-12(fp)
811396c0:	1000051e 	bne	r2,zero,811396d8 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811396c4:	e0bfff17 	ldw	r2,-4(fp)
811396c8:	00c00104 	movi	r3,4
811396cc:	10c00005 	stb	r3,0(r2)
        return (0);
811396d0:	0005883a 	mov	r2,zero
811396d4:	00004206 	br	811397e0 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811396d8:	e0bffd17 	ldw	r2,-12(fp)
811396dc:	10800003 	ldbu	r2,0(r2)
811396e0:	10803fcc 	andi	r2,r2,255
811396e4:	108000e0 	cmpeqi	r2,r2,3
811396e8:	1000051e 	bne	r2,zero,81139700 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811396ec:	e0bfff17 	ldw	r2,-4(fp)
811396f0:	00c00044 	movi	r3,1
811396f4:	10c00005 	stb	r3,0(r2)
        return (0);
811396f8:	0005883a 	mov	r2,zero
811396fc:	00003806 	br	811397e0 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139700:	0005303a 	rdctl	r2,status
81139704:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139708:	e0fffc17 	ldw	r3,-16(fp)
8113970c:	00bfff84 	movi	r2,-2
81139710:	1884703a 	and	r2,r3,r2
81139714:	1001703a 	wrctl	status,r2
  
  return context;
81139718:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113971c:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
81139720:	e0bffd17 	ldw	r2,-12(fp)
81139724:	10800283 	ldbu	r2,10(r2)
81139728:	10803fcc 	andi	r2,r2,255
8113972c:	10002526 	beq	r2,zero,811397c4 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
81139730:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81139734:	e0bffe03 	ldbu	r2,-8(fp)
81139738:	10800060 	cmpeqi	r2,r2,1
8113973c:	10000e26 	beq	r2,zero,81139778 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81139740:	00000806 	br	81139764 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81139744:	01c00084 	movi	r7,2
81139748:	01800044 	movi	r6,1
8113974c:	000b883a 	mov	r5,zero
81139750:	e13ffd17 	ldw	r4,-12(fp)
81139754:	1133b000 	call	81133b00 <OS_EventTaskRdy>
                     nbr_tasks++;
81139758:	e0bff803 	ldbu	r2,-32(fp)
8113975c:	10800044 	addi	r2,r2,1
81139760:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81139764:	e0bffd17 	ldw	r2,-12(fp)
81139768:	10800283 	ldbu	r2,10(r2)
8113976c:	10803fcc 	andi	r2,r2,255
81139770:	103ff41e 	bne	r2,zero,81139744 <__reset+0xfb119744>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81139774:	00000906 	br	8113979c <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81139778:	01c00084 	movi	r7,2
8113977c:	01800044 	movi	r6,1
81139780:	000b883a 	mov	r5,zero
81139784:	e13ffd17 	ldw	r4,-12(fp)
81139788:	1133b000 	call	81133b00 <OS_EventTaskRdy>
                 nbr_tasks++;
8113978c:	e0bff803 	ldbu	r2,-32(fp)
81139790:	10800044 	addi	r2,r2,1
81139794:	e0bff805 	stb	r2,-32(fp)
                 break;
81139798:	0001883a 	nop
8113979c:	e0bff917 	ldw	r2,-28(fp)
811397a0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811397a4:	e0bffa17 	ldw	r2,-24(fp)
811397a8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
811397ac:	11345bc0 	call	811345bc <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
811397b0:	e0bfff17 	ldw	r2,-4(fp)
811397b4:	00c00384 	movi	r3,14
811397b8:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
811397bc:	e0bff803 	ldbu	r2,-32(fp)
811397c0:	00000706 	br	811397e0 <OSSemPendAbort+0x160>
811397c4:	e0bff917 	ldw	r2,-28(fp)
811397c8:	e0bffb15 	stw	r2,-20(fp)
811397cc:	e0bffb17 	ldw	r2,-20(fp)
811397d0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811397d4:	e0bfff17 	ldw	r2,-4(fp)
811397d8:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
811397dc:	0005883a 	mov	r2,zero
}
811397e0:	e037883a 	mov	sp,fp
811397e4:	dfc00117 	ldw	ra,4(sp)
811397e8:	df000017 	ldw	fp,0(sp)
811397ec:	dec00204 	addi	sp,sp,8
811397f0:	f800283a 	ret

811397f4 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
811397f4:	defff804 	addi	sp,sp,-32
811397f8:	de00012e 	bgeu	sp,et,81139800 <OSSemPost+0xc>
811397fc:	003b68fa 	trap	3
81139800:	dfc00715 	stw	ra,28(sp)
81139804:	df000615 	stw	fp,24(sp)
81139808:	df000604 	addi	fp,sp,24
8113980c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139810:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139814:	e0bfff17 	ldw	r2,-4(fp)
81139818:	1000021e 	bne	r2,zero,81139824 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8113981c:	00800104 	movi	r2,4
81139820:	00003506 	br	811398f8 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81139824:	e0bfff17 	ldw	r2,-4(fp)
81139828:	10800003 	ldbu	r2,0(r2)
8113982c:	10803fcc 	andi	r2,r2,255
81139830:	108000e0 	cmpeqi	r2,r2,3
81139834:	1000021e 	bne	r2,zero,81139840 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
81139838:	00800044 	movi	r2,1
8113983c:	00002e06 	br	811398f8 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139840:	0005303a 	rdctl	r2,status
81139844:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139848:	e0fffe17 	ldw	r3,-8(fp)
8113984c:	00bfff84 	movi	r2,-2
81139850:	1884703a 	and	r2,r3,r2
81139854:	1001703a 	wrctl	status,r2
  
  return context;
81139858:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113985c:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
81139860:	e0bfff17 	ldw	r2,-4(fp)
81139864:	10800283 	ldbu	r2,10(r2)
81139868:	10803fcc 	andi	r2,r2,255
8113986c:	10000c26 	beq	r2,zero,811398a0 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81139870:	000f883a 	mov	r7,zero
81139874:	01800044 	movi	r6,1
81139878:	000b883a 	mov	r5,zero
8113987c:	e13fff17 	ldw	r4,-4(fp)
81139880:	1133b000 	call	81133b00 <OS_EventTaskRdy>
81139884:	e0bffa17 	ldw	r2,-24(fp)
81139888:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113988c:	e0bffb17 	ldw	r2,-20(fp)
81139890:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81139894:	11345bc0 	call	811345bc <OS_Sched>
        return (OS_ERR_NONE);
81139898:	0005883a 	mov	r2,zero
8113989c:	00001606 	br	811398f8 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
811398a0:	e0bfff17 	ldw	r2,-4(fp)
811398a4:	1080020b 	ldhu	r2,8(r2)
811398a8:	10ffffcc 	andi	r3,r2,65535
811398ac:	00bfffd4 	movui	r2,65535
811398b0:	18800c26 	beq	r3,r2,811398e4 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
811398b4:	e0bfff17 	ldw	r2,-4(fp)
811398b8:	1080020b 	ldhu	r2,8(r2)
811398bc:	10800044 	addi	r2,r2,1
811398c0:	1007883a 	mov	r3,r2
811398c4:	e0bfff17 	ldw	r2,-4(fp)
811398c8:	10c0020d 	sth	r3,8(r2)
811398cc:	e0bffa17 	ldw	r2,-24(fp)
811398d0:	e0bffc15 	stw	r2,-16(fp)
811398d4:	e0bffc17 	ldw	r2,-16(fp)
811398d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
811398dc:	0005883a 	mov	r2,zero
811398e0:	00000506 	br	811398f8 <OSSemPost+0x104>
811398e4:	e0bffa17 	ldw	r2,-24(fp)
811398e8:	e0bffd15 	stw	r2,-12(fp)
811398ec:	e0bffd17 	ldw	r2,-12(fp)
811398f0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
811398f4:	00800c84 	movi	r2,50
}
811398f8:	e037883a 	mov	sp,fp
811398fc:	dfc00117 	ldw	ra,4(sp)
81139900:	df000017 	ldw	fp,0(sp)
81139904:	dec00204 	addi	sp,sp,8
81139908:	f800283a 	ret

8113990c <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113990c:	defff704 	addi	sp,sp,-36
81139910:	de00012e 	bgeu	sp,et,81139918 <OSSemQuery+0xc>
81139914:	003b68fa 	trap	3
81139918:	df000815 	stw	fp,32(sp)
8113991c:	df000804 	addi	fp,sp,32
81139920:	e13ffe15 	stw	r4,-8(fp)
81139924:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139928:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113992c:	e0bffe17 	ldw	r2,-8(fp)
81139930:	1000021e 	bne	r2,zero,8113993c <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81139934:	00800104 	movi	r2,4
81139938:	00003606 	br	81139a14 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113993c:	e0bfff17 	ldw	r2,-4(fp)
81139940:	1000021e 	bne	r2,zero,8113994c <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81139944:	00800244 	movi	r2,9
81139948:	00003206 	br	81139a14 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113994c:	e0bffe17 	ldw	r2,-8(fp)
81139950:	10800003 	ldbu	r2,0(r2)
81139954:	10803fcc 	andi	r2,r2,255
81139958:	108000e0 	cmpeqi	r2,r2,3
8113995c:	1000021e 	bne	r2,zero,81139968 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81139960:	00800044 	movi	r2,1
81139964:	00002b06 	br	81139a14 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139968:	0005303a 	rdctl	r2,status
8113996c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139970:	e0fffd17 	ldw	r3,-12(fp)
81139974:	00bfff84 	movi	r2,-2
81139978:	1884703a 	and	r2,r3,r2
8113997c:	1001703a 	wrctl	status,r2
  
  return context;
81139980:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81139984:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
81139988:	e0bffe17 	ldw	r2,-8(fp)
8113998c:	10c00283 	ldbu	r3,10(r2)
81139990:	e0bfff17 	ldw	r2,-4(fp)
81139994:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
81139998:	e0bffe17 	ldw	r2,-8(fp)
8113999c:	108002c4 	addi	r2,r2,11
811399a0:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
811399a4:	e0bfff17 	ldw	r2,-4(fp)
811399a8:	10800084 	addi	r2,r2,2
811399ac:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811399b0:	e03ffa05 	stb	zero,-24(fp)
811399b4:	00000b06 	br	811399e4 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
811399b8:	e0bff917 	ldw	r2,-28(fp)
811399bc:	10c00044 	addi	r3,r2,1
811399c0:	e0fff915 	stw	r3,-28(fp)
811399c4:	e0fff817 	ldw	r3,-32(fp)
811399c8:	19000044 	addi	r4,r3,1
811399cc:	e13ff815 	stw	r4,-32(fp)
811399d0:	18c00003 	ldbu	r3,0(r3)
811399d4:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811399d8:	e0bffa03 	ldbu	r2,-24(fp)
811399dc:	10800044 	addi	r2,r2,1
811399e0:	e0bffa05 	stb	r2,-24(fp)
811399e4:	e0bffa03 	ldbu	r2,-24(fp)
811399e8:	108001b0 	cmpltui	r2,r2,6
811399ec:	103ff21e 	bne	r2,zero,811399b8 <__reset+0xfb1199b8>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
811399f0:	e0bffe17 	ldw	r2,-8(fp)
811399f4:	10c0020b 	ldhu	r3,8(r2)
811399f8:	e0bfff17 	ldw	r2,-4(fp)
811399fc:	10c0000d 	sth	r3,0(r2)
81139a00:	e0bffb17 	ldw	r2,-20(fp)
81139a04:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139a08:	e0bffc17 	ldw	r2,-16(fp)
81139a0c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139a10:	0005883a 	mov	r2,zero
}
81139a14:	e037883a 	mov	sp,fp
81139a18:	df000017 	ldw	fp,0(sp)
81139a1c:	dec00104 	addi	sp,sp,4
81139a20:	f800283a 	ret

81139a24 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
81139a24:	defff904 	addi	sp,sp,-28
81139a28:	de00012e 	bgeu	sp,et,81139a30 <OSSemSet+0xc>
81139a2c:	003b68fa 	trap	3
81139a30:	df000615 	stw	fp,24(sp)
81139a34:	df000604 	addi	fp,sp,24
81139a38:	e13ffd15 	stw	r4,-12(fp)
81139a3c:	2805883a 	mov	r2,r5
81139a40:	e1bfff15 	stw	r6,-4(fp)
81139a44:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139a48:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81139a4c:	e0bfff17 	ldw	r2,-4(fp)
81139a50:	10003126 	beq	r2,zero,81139b18 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139a54:	e0bffd17 	ldw	r2,-12(fp)
81139a58:	1000041e 	bne	r2,zero,81139a6c <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81139a5c:	e0bfff17 	ldw	r2,-4(fp)
81139a60:	00c00104 	movi	r3,4
81139a64:	10c00005 	stb	r3,0(r2)
        return;
81139a68:	00002c06 	br	81139b1c <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81139a6c:	e0bffd17 	ldw	r2,-12(fp)
81139a70:	10800003 	ldbu	r2,0(r2)
81139a74:	10803fcc 	andi	r2,r2,255
81139a78:	108000e0 	cmpeqi	r2,r2,3
81139a7c:	1000041e 	bne	r2,zero,81139a90 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
81139a80:	e0bfff17 	ldw	r2,-4(fp)
81139a84:	00c00044 	movi	r3,1
81139a88:	10c00005 	stb	r3,0(r2)
        return;
81139a8c:	00002306 	br	81139b1c <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139a90:	0005303a 	rdctl	r2,status
81139a94:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139a98:	e0fffc17 	ldw	r3,-16(fp)
81139a9c:	00bfff84 	movi	r2,-2
81139aa0:	1884703a 	and	r2,r3,r2
81139aa4:	1001703a 	wrctl	status,r2
  
  return context;
81139aa8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139aac:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
81139ab0:	e0bfff17 	ldw	r2,-4(fp)
81139ab4:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
81139ab8:	e0bffd17 	ldw	r2,-12(fp)
81139abc:	1080020b 	ldhu	r2,8(r2)
81139ac0:	10bfffcc 	andi	r2,r2,65535
81139ac4:	10000426 	beq	r2,zero,81139ad8 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
81139ac8:	e0bffd17 	ldw	r2,-12(fp)
81139acc:	e0fffe0b 	ldhu	r3,-8(fp)
81139ad0:	10c0020d 	sth	r3,8(r2)
81139ad4:	00000b06 	br	81139b04 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
81139ad8:	e0bffd17 	ldw	r2,-12(fp)
81139adc:	10800283 	ldbu	r2,10(r2)
81139ae0:	10803fcc 	andi	r2,r2,255
81139ae4:	1000041e 	bne	r2,zero,81139af8 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
81139ae8:	e0bffd17 	ldw	r2,-12(fp)
81139aec:	e0fffe0b 	ldhu	r3,-8(fp)
81139af0:	10c0020d 	sth	r3,8(r2)
81139af4:	00000306 	br	81139b04 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
81139af8:	e0bfff17 	ldw	r2,-4(fp)
81139afc:	00c01244 	movi	r3,73
81139b00:	10c00005 	stb	r3,0(r2)
81139b04:	e0bffa17 	ldw	r2,-24(fp)
81139b08:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139b0c:	e0bffb17 	ldw	r2,-20(fp)
81139b10:	1001703a 	wrctl	status,r2
81139b14:	00000106 	br	81139b1c <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81139b18:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
81139b1c:	e037883a 	mov	sp,fp
81139b20:	df000017 	ldw	fp,0(sp)
81139b24:	dec00104 	addi	sp,sp,4
81139b28:	f800283a 	ret

81139b2c <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
81139b2c:	defff104 	addi	sp,sp,-60
81139b30:	de00012e 	bgeu	sp,et,81139b38 <OSTaskChangePrio+0xc>
81139b34:	003b68fa 	trap	3
81139b38:	dfc00e15 	stw	ra,56(sp)
81139b3c:	df000d15 	stw	fp,52(sp)
81139b40:	df000d04 	addi	fp,sp,52
81139b44:	2007883a 	mov	r3,r4
81139b48:	2805883a 	mov	r2,r5
81139b4c:	e0fffe05 	stb	r3,-8(fp)
81139b50:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
81139b54:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
81139b58:	e0bffe03 	ldbu	r2,-8(fp)
81139b5c:	10800a30 	cmpltui	r2,r2,40
81139b60:	1000051e 	bne	r2,zero,81139b78 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
81139b64:	e0bffe03 	ldbu	r2,-8(fp)
81139b68:	10803fe0 	cmpeqi	r2,r2,255
81139b6c:	1000021e 	bne	r2,zero,81139b78 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
81139b70:	00800a84 	movi	r2,42
81139b74:	00012606 	br	8113a010 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
81139b78:	e0bfff03 	ldbu	r2,-4(fp)
81139b7c:	10800a30 	cmpltui	r2,r2,40
81139b80:	1000021e 	bne	r2,zero,81139b8c <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
81139b84:	00800a84 	movi	r2,42
81139b88:	00012106 	br	8113a010 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139b8c:	0005303a 	rdctl	r2,status
81139b90:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139b94:	e0fffd17 	ldw	r3,-12(fp)
81139b98:	00bfff84 	movi	r2,-2
81139b9c:	1884703a 	and	r2,r3,r2
81139ba0:	1001703a 	wrctl	status,r2
  
  return context;
81139ba4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81139ba8:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
81139bac:	e0ffff03 	ldbu	r3,-4(fp)
81139bb0:	00a045b4 	movhi	r2,33046
81139bb4:	10979804 	addi	r2,r2,24160
81139bb8:	18c7883a 	add	r3,r3,r3
81139bbc:	18c7883a 	add	r3,r3,r3
81139bc0:	10c5883a 	add	r2,r2,r3
81139bc4:	10800017 	ldw	r2,0(r2)
81139bc8:	10000626 	beq	r2,zero,81139be4 <OSTaskChangePrio+0xb8>
81139bcc:	e0bff517 	ldw	r2,-44(fp)
81139bd0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139bd4:	e0bff617 	ldw	r2,-40(fp)
81139bd8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
81139bdc:	00800a04 	movi	r2,40
81139be0:	00010b06 	br	8113a010 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
81139be4:	e0bffe03 	ldbu	r2,-8(fp)
81139be8:	10803fd8 	cmpnei	r2,r2,255
81139bec:	1000031e 	bne	r2,zero,81139bfc <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
81139bf0:	d0a09c17 	ldw	r2,-32144(gp)
81139bf4:	10800c83 	ldbu	r2,50(r2)
81139bf8:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
81139bfc:	e0fffe03 	ldbu	r3,-8(fp)
81139c00:	00a045b4 	movhi	r2,33046
81139c04:	10979804 	addi	r2,r2,24160
81139c08:	18c7883a 	add	r3,r3,r3
81139c0c:	18c7883a 	add	r3,r3,r3
81139c10:	10c5883a 	add	r2,r2,r3
81139c14:	10800017 	ldw	r2,0(r2)
81139c18:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
81139c1c:	e0bff817 	ldw	r2,-32(fp)
81139c20:	1000061e 	bne	r2,zero,81139c3c <OSTaskChangePrio+0x110>
81139c24:	e0bff517 	ldw	r2,-44(fp)
81139c28:	e0bff715 	stw	r2,-36(fp)
81139c2c:	e0bff717 	ldw	r2,-36(fp)
81139c30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
81139c34:	00800a44 	movi	r2,41
81139c38:	0000f506 	br	8113a010 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
81139c3c:	e0bff817 	ldw	r2,-32(fp)
81139c40:	10800058 	cmpnei	r2,r2,1
81139c44:	1000061e 	bne	r2,zero,81139c60 <OSTaskChangePrio+0x134>
81139c48:	e0bff517 	ldw	r2,-44(fp)
81139c4c:	e0bff915 	stw	r2,-28(fp)
81139c50:	e0bff917 	ldw	r2,-28(fp)
81139c54:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
81139c58:	008010c4 	movi	r2,67
81139c5c:	0000ec06 	br	8113a010 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
81139c60:	e0bfff03 	ldbu	r2,-4(fp)
81139c64:	1004d0fa 	srli	r2,r2,3
81139c68:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
81139c6c:	e0bfff03 	ldbu	r2,-4(fp)
81139c70:	108001cc 	andi	r2,r2,7
81139c74:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
81139c78:	e0bffb03 	ldbu	r2,-20(fp)
81139c7c:	00c00044 	movi	r3,1
81139c80:	1884983a 	sll	r2,r3,r2
81139c84:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
81139c88:	e0bffb43 	ldbu	r2,-19(fp)
81139c8c:	00c00044 	movi	r3,1
81139c90:	1884983a 	sll	r2,r3,r2
81139c94:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
81139c98:	e0fffe03 	ldbu	r3,-8(fp)
81139c9c:	00a045b4 	movhi	r2,33046
81139ca0:	10979804 	addi	r2,r2,24160
81139ca4:	18c7883a 	add	r3,r3,r3
81139ca8:	18c7883a 	add	r3,r3,r3
81139cac:	10c5883a 	add	r2,r2,r3
81139cb0:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
81139cb4:	e0ffff03 	ldbu	r3,-4(fp)
81139cb8:	00a045b4 	movhi	r2,33046
81139cbc:	10979804 	addi	r2,r2,24160
81139cc0:	18c7883a 	add	r3,r3,r3
81139cc4:	18c7883a 	add	r3,r3,r3
81139cc8:	10c5883a 	add	r2,r2,r3
81139ccc:	e0fff817 	ldw	r3,-32(fp)
81139cd0:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
81139cd4:	e0bff817 	ldw	r2,-32(fp)
81139cd8:	10800d03 	ldbu	r2,52(r2)
81139cdc:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
81139ce0:	e0bff817 	ldw	r2,-32(fp)
81139ce4:	10800d83 	ldbu	r2,54(r2)
81139ce8:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
81139cec:	e0bff817 	ldw	r2,-32(fp)
81139cf0:	10800d43 	ldbu	r2,53(r2)
81139cf4:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
81139cf8:	e0fffc03 	ldbu	r3,-16(fp)
81139cfc:	d0a09844 	addi	r2,gp,-32159
81139d00:	1885883a 	add	r2,r3,r2
81139d04:	10c00003 	ldbu	r3,0(r2)
81139d08:	e0bffc83 	ldbu	r2,-14(fp)
81139d0c:	1884703a 	and	r2,r3,r2
81139d10:	10803fcc 	andi	r2,r2,255
81139d14:	10002826 	beq	r2,zero,81139db8 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
81139d18:	e0fffc03 	ldbu	r3,-16(fp)
81139d1c:	e13ffc03 	ldbu	r4,-16(fp)
81139d20:	d0a09844 	addi	r2,gp,-32159
81139d24:	2085883a 	add	r2,r4,r2
81139d28:	10800003 	ldbu	r2,0(r2)
81139d2c:	1009883a 	mov	r4,r2
81139d30:	e0bffc83 	ldbu	r2,-14(fp)
81139d34:	0084303a 	nor	r2,zero,r2
81139d38:	2084703a 	and	r2,r4,r2
81139d3c:	1009883a 	mov	r4,r2
81139d40:	d0a09844 	addi	r2,gp,-32159
81139d44:	1885883a 	add	r2,r3,r2
81139d48:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
81139d4c:	e0fffc03 	ldbu	r3,-16(fp)
81139d50:	d0a09844 	addi	r2,gp,-32159
81139d54:	1885883a 	add	r2,r3,r2
81139d58:	10800003 	ldbu	r2,0(r2)
81139d5c:	10803fcc 	andi	r2,r2,255
81139d60:	1000061e 	bne	r2,zero,81139d7c <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
81139d64:	e0bffc43 	ldbu	r2,-15(fp)
81139d68:	0084303a 	nor	r2,zero,r2
81139d6c:	1007883a 	mov	r3,r2
81139d70:	d0a09803 	ldbu	r2,-32160(gp)
81139d74:	1884703a 	and	r2,r3,r2
81139d78:	d0a09805 	stb	r2,-32160(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
81139d7c:	d0e09803 	ldbu	r3,-32160(gp)
81139d80:	e0bffb83 	ldbu	r2,-18(fp)
81139d84:	1884b03a 	or	r2,r3,r2
81139d88:	d0a09805 	stb	r2,-32160(gp)
         OSRdyTbl[y_new] |= bitx_new;
81139d8c:	e0fffb03 	ldbu	r3,-20(fp)
81139d90:	e13ffb03 	ldbu	r4,-20(fp)
81139d94:	d0a09844 	addi	r2,gp,-32159
81139d98:	2085883a 	add	r2,r4,r2
81139d9c:	11000003 	ldbu	r4,0(r2)
81139da0:	e0bffbc3 	ldbu	r2,-17(fp)
81139da4:	2084b03a 	or	r2,r4,r2
81139da8:	1009883a 	mov	r4,r2
81139dac:	d0a09844 	addi	r2,gp,-32159
81139db0:	1885883a 	add	r2,r3,r2
81139db4:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
81139db8:	e0bff817 	ldw	r2,-32(fp)
81139dbc:	10800717 	ldw	r2,28(r2)
81139dc0:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
81139dc4:	e0bff317 	ldw	r2,-52(fp)
81139dc8:	10003326 	beq	r2,zero,81139e98 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
81139dcc:	e0bffc03 	ldbu	r2,-16(fp)
81139dd0:	e0fffc03 	ldbu	r3,-16(fp)
81139dd4:	e13ff317 	ldw	r4,-52(fp)
81139dd8:	20c7883a 	add	r3,r4,r3
81139ddc:	18c002c4 	addi	r3,r3,11
81139de0:	18c00003 	ldbu	r3,0(r3)
81139de4:	1809883a 	mov	r4,r3
81139de8:	e0fffc83 	ldbu	r3,-14(fp)
81139dec:	00c6303a 	nor	r3,zero,r3
81139df0:	20c6703a 	and	r3,r4,r3
81139df4:	1809883a 	mov	r4,r3
81139df8:	e0fff317 	ldw	r3,-52(fp)
81139dfc:	1885883a 	add	r2,r3,r2
81139e00:	108002c4 	addi	r2,r2,11
81139e04:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
81139e08:	e0bffc03 	ldbu	r2,-16(fp)
81139e0c:	e0fff317 	ldw	r3,-52(fp)
81139e10:	1885883a 	add	r2,r3,r2
81139e14:	108002c4 	addi	r2,r2,11
81139e18:	10800003 	ldbu	r2,0(r2)
81139e1c:	10803fcc 	andi	r2,r2,255
81139e20:	1000091e 	bne	r2,zero,81139e48 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
81139e24:	e0bff317 	ldw	r2,-52(fp)
81139e28:	10800283 	ldbu	r2,10(r2)
81139e2c:	1007883a 	mov	r3,r2
81139e30:	e0bffc43 	ldbu	r2,-15(fp)
81139e34:	0084303a 	nor	r2,zero,r2
81139e38:	1884703a 	and	r2,r3,r2
81139e3c:	1007883a 	mov	r3,r2
81139e40:	e0bff317 	ldw	r2,-52(fp)
81139e44:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
81139e48:	e0bff317 	ldw	r2,-52(fp)
81139e4c:	10c00283 	ldbu	r3,10(r2)
81139e50:	e0bffb83 	ldbu	r2,-18(fp)
81139e54:	1884b03a 	or	r2,r3,r2
81139e58:	1007883a 	mov	r3,r2
81139e5c:	e0bff317 	ldw	r2,-52(fp)
81139e60:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
81139e64:	e0bffb03 	ldbu	r2,-20(fp)
81139e68:	e0fffb03 	ldbu	r3,-20(fp)
81139e6c:	e13ff317 	ldw	r4,-52(fp)
81139e70:	20c7883a 	add	r3,r4,r3
81139e74:	18c002c4 	addi	r3,r3,11
81139e78:	19000003 	ldbu	r4,0(r3)
81139e7c:	e0fffbc3 	ldbu	r3,-17(fp)
81139e80:	20c6b03a 	or	r3,r4,r3
81139e84:	1809883a 	mov	r4,r3
81139e88:	e0fff317 	ldw	r3,-52(fp)
81139e8c:	1885883a 	add	r2,r3,r2
81139e90:	108002c4 	addi	r2,r2,11
81139e94:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
81139e98:	e0bff817 	ldw	r2,-32(fp)
81139e9c:	10800817 	ldw	r2,32(r2)
81139ea0:	10004226 	beq	r2,zero,81139fac <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
81139ea4:	e0bff817 	ldw	r2,-32(fp)
81139ea8:	10800817 	ldw	r2,32(r2)
81139eac:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
81139eb0:	e0bff417 	ldw	r2,-48(fp)
81139eb4:	10800017 	ldw	r2,0(r2)
81139eb8:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
81139ebc:	00003906 	br	81139fa4 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
81139ec0:	e0bffc03 	ldbu	r2,-16(fp)
81139ec4:	e0fffc03 	ldbu	r3,-16(fp)
81139ec8:	e13ff317 	ldw	r4,-52(fp)
81139ecc:	20c7883a 	add	r3,r4,r3
81139ed0:	18c002c4 	addi	r3,r3,11
81139ed4:	18c00003 	ldbu	r3,0(r3)
81139ed8:	1809883a 	mov	r4,r3
81139edc:	e0fffc83 	ldbu	r3,-14(fp)
81139ee0:	00c6303a 	nor	r3,zero,r3
81139ee4:	20c6703a 	and	r3,r4,r3
81139ee8:	1809883a 	mov	r4,r3
81139eec:	e0fff317 	ldw	r3,-52(fp)
81139ef0:	1885883a 	add	r2,r3,r2
81139ef4:	108002c4 	addi	r2,r2,11
81139ef8:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
81139efc:	e0bffc03 	ldbu	r2,-16(fp)
81139f00:	e0fff317 	ldw	r3,-52(fp)
81139f04:	1885883a 	add	r2,r3,r2
81139f08:	108002c4 	addi	r2,r2,11
81139f0c:	10800003 	ldbu	r2,0(r2)
81139f10:	10803fcc 	andi	r2,r2,255
81139f14:	1000091e 	bne	r2,zero,81139f3c <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
81139f18:	e0bff317 	ldw	r2,-52(fp)
81139f1c:	10800283 	ldbu	r2,10(r2)
81139f20:	1007883a 	mov	r3,r2
81139f24:	e0bffc43 	ldbu	r2,-15(fp)
81139f28:	0084303a 	nor	r2,zero,r2
81139f2c:	1884703a 	and	r2,r3,r2
81139f30:	1007883a 	mov	r3,r2
81139f34:	e0bff317 	ldw	r2,-52(fp)
81139f38:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
81139f3c:	e0bff317 	ldw	r2,-52(fp)
81139f40:	10c00283 	ldbu	r3,10(r2)
81139f44:	e0bffb83 	ldbu	r2,-18(fp)
81139f48:	1884b03a 	or	r2,r3,r2
81139f4c:	1007883a 	mov	r3,r2
81139f50:	e0bff317 	ldw	r2,-52(fp)
81139f54:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
81139f58:	e0bffb03 	ldbu	r2,-20(fp)
81139f5c:	e0fffb03 	ldbu	r3,-20(fp)
81139f60:	e13ff317 	ldw	r4,-52(fp)
81139f64:	20c7883a 	add	r3,r4,r3
81139f68:	18c002c4 	addi	r3,r3,11
81139f6c:	19000003 	ldbu	r4,0(r3)
81139f70:	e0fffbc3 	ldbu	r3,-17(fp)
81139f74:	20c6b03a 	or	r3,r4,r3
81139f78:	1809883a 	mov	r4,r3
81139f7c:	e0fff317 	ldw	r3,-52(fp)
81139f80:	1885883a 	add	r2,r3,r2
81139f84:	108002c4 	addi	r2,r2,11
81139f88:	11000005 	stb	r4,0(r2)
            pevents++;
81139f8c:	e0bff417 	ldw	r2,-48(fp)
81139f90:	10800104 	addi	r2,r2,4
81139f94:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
81139f98:	e0bff417 	ldw	r2,-48(fp)
81139f9c:	10800017 	ldw	r2,0(r2)
81139fa0:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
81139fa4:	e0bff317 	ldw	r2,-52(fp)
81139fa8:	103fc51e 	bne	r2,zero,81139ec0 <__reset+0xfb119ec0>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
81139fac:	e0bff817 	ldw	r2,-32(fp)
81139fb0:	e0ffff03 	ldbu	r3,-4(fp)
81139fb4:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
81139fb8:	e0bff817 	ldw	r2,-32(fp)
81139fbc:	e0fffb03 	ldbu	r3,-20(fp)
81139fc0:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
81139fc4:	e0bff817 	ldw	r2,-32(fp)
81139fc8:	e0fffb43 	ldbu	r3,-19(fp)
81139fcc:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
81139fd0:	e0bff817 	ldw	r2,-32(fp)
81139fd4:	e0fffb83 	ldbu	r3,-18(fp)
81139fd8:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
81139fdc:	e0bff817 	ldw	r2,-32(fp)
81139fe0:	e0fffbc3 	ldbu	r3,-17(fp)
81139fe4:	10c00d45 	stb	r3,53(r2)
81139fe8:	e0bff517 	ldw	r2,-44(fp)
81139fec:	e0bffa15 	stw	r2,-24(fp)
81139ff0:	e0bffa17 	ldw	r2,-24(fp)
81139ff4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81139ff8:	d0a08b03 	ldbu	r2,-32212(gp)
81139ffc:	10803fcc 	andi	r2,r2,255
8113a000:	10800058 	cmpnei	r2,r2,1
8113a004:	1000011e 	bne	r2,zero,8113a00c <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113a008:	11345bc0 	call	811345bc <OS_Sched>
    }
    return (OS_ERR_NONE);
8113a00c:	0005883a 	mov	r2,zero
}
8113a010:	e037883a 	mov	sp,fp
8113a014:	dfc00117 	ldw	ra,4(sp)
8113a018:	df000017 	ldw	fp,0(sp)
8113a01c:	dec00204 	addi	sp,sp,8
8113a020:	f800283a 	ret

8113a024 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113a024:	deffec04 	addi	sp,sp,-80
8113a028:	de00012e 	bgeu	sp,et,8113a030 <OSTaskCreateExt+0xc>
8113a02c:	003b68fa 	trap	3
8113a030:	dfc01315 	stw	ra,76(sp)
8113a034:	df001215 	stw	fp,72(sp)
8113a038:	df001204 	addi	fp,sp,72
8113a03c:	e13ffa15 	stw	r4,-24(fp)
8113a040:	e17ffb15 	stw	r5,-20(fp)
8113a044:	e1bffc15 	stw	r6,-16(fp)
8113a048:	3809883a 	mov	r4,r7
8113a04c:	e0c00217 	ldw	r3,8(fp)
8113a050:	e0800617 	ldw	r2,24(fp)
8113a054:	e13ffd05 	stb	r4,-12(fp)
8113a058:	e0fffe0d 	sth	r3,-8(fp)
8113a05c:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113a060:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113a064:	e0bffd03 	ldbu	r2,-12(fp)
8113a068:	10800a70 	cmpltui	r2,r2,41
8113a06c:	1000021e 	bne	r2,zero,8113a078 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113a070:	00800a84 	movi	r2,42
8113a074:	00006106 	br	8113a1fc <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a078:	0005303a 	rdctl	r2,status
8113a07c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a080:	e0fff917 	ldw	r3,-28(fp)
8113a084:	00bfff84 	movi	r2,-2
8113a088:	1884703a 	and	r2,r3,r2
8113a08c:	1001703a 	wrctl	status,r2
  
  return context;
8113a090:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113a094:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113a098:	d0a09b03 	ldbu	r2,-32148(gp)
8113a09c:	10803fcc 	andi	r2,r2,255
8113a0a0:	10000626 	beq	r2,zero,8113a0bc <OSTaskCreateExt+0x98>
8113a0a4:	e0bff117 	ldw	r2,-60(fp)
8113a0a8:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a0ac:	e0bff217 	ldw	r2,-56(fp)
8113a0b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113a0b4:	00800f04 	movi	r2,60
8113a0b8:	00005006 	br	8113a1fc <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113a0bc:	e0fffd03 	ldbu	r3,-12(fp)
8113a0c0:	00a045b4 	movhi	r2,33046
8113a0c4:	10979804 	addi	r2,r2,24160
8113a0c8:	18c7883a 	add	r3,r3,r3
8113a0cc:	18c7883a 	add	r3,r3,r3
8113a0d0:	10c5883a 	add	r2,r2,r3
8113a0d4:	10800017 	ldw	r2,0(r2)
8113a0d8:	1000431e 	bne	r2,zero,8113a1e8 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113a0dc:	e0fffd03 	ldbu	r3,-12(fp)
8113a0e0:	00a045b4 	movhi	r2,33046
8113a0e4:	10979804 	addi	r2,r2,24160
8113a0e8:	18c7883a 	add	r3,r3,r3
8113a0ec:	18c7883a 	add	r3,r3,r3
8113a0f0:	10c5883a 	add	r2,r2,r3
8113a0f4:	00c00044 	movi	r3,1
8113a0f8:	10c00015 	stw	r3,0(r2)
8113a0fc:	e0bff117 	ldw	r2,-60(fp)
8113a100:	e0bff315 	stw	r2,-52(fp)
8113a104:	e0bff317 	ldw	r2,-52(fp)
8113a108:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113a10c:	e0bfff0b 	ldhu	r2,-4(fp)
8113a110:	100d883a 	mov	r6,r2
8113a114:	e1400417 	ldw	r5,16(fp)
8113a118:	e1000317 	ldw	r4,12(fp)
8113a11c:	113b0cc0 	call	8113b0cc <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113a120:	e0bfff0b 	ldhu	r2,-4(fp)
8113a124:	100f883a 	mov	r7,r2
8113a128:	e1bffc17 	ldw	r6,-16(fp)
8113a12c:	e17ffb17 	ldw	r5,-20(fp)
8113a130:	e13ffa17 	ldw	r4,-24(fp)
8113a134:	11455180 	call	81145518 <OSTaskStkInit>
8113a138:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113a13c:	e0fffd03 	ldbu	r3,-12(fp)
8113a140:	e13ffe0b 	ldhu	r4,-8(fp)
8113a144:	e0bfff0b 	ldhu	r2,-4(fp)
8113a148:	d8800215 	stw	r2,8(sp)
8113a14c:	e0800517 	ldw	r2,20(fp)
8113a150:	d8800115 	stw	r2,4(sp)
8113a154:	e0800417 	ldw	r2,16(fp)
8113a158:	d8800015 	stw	r2,0(sp)
8113a15c:	200f883a 	mov	r7,r4
8113a160:	e1800317 	ldw	r6,12(fp)
8113a164:	e17ff517 	ldw	r5,-44(fp)
8113a168:	1809883a 	mov	r4,r3
8113a16c:	1134a040 	call	81134a04 <OS_TCBInit>
8113a170:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113a174:	e0bff603 	ldbu	r2,-40(fp)
8113a178:	1000061e 	bne	r2,zero,8113a194 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113a17c:	d0a08b03 	ldbu	r2,-32212(gp)
8113a180:	10803fcc 	andi	r2,r2,255
8113a184:	10800058 	cmpnei	r2,r2,1
8113a188:	1000151e 	bne	r2,zero,8113a1e0 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113a18c:	11345bc0 	call	811345bc <OS_Sched>
8113a190:	00001306 	br	8113a1e0 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a194:	0005303a 	rdctl	r2,status
8113a198:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a19c:	e0fff817 	ldw	r3,-32(fp)
8113a1a0:	00bfff84 	movi	r2,-2
8113a1a4:	1884703a 	and	r2,r3,r2
8113a1a8:	1001703a 	wrctl	status,r2
  
  return context;
8113a1ac:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113a1b0:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113a1b4:	e0fffd03 	ldbu	r3,-12(fp)
8113a1b8:	00a045b4 	movhi	r2,33046
8113a1bc:	10979804 	addi	r2,r2,24160
8113a1c0:	18c7883a 	add	r3,r3,r3
8113a1c4:	18c7883a 	add	r3,r3,r3
8113a1c8:	10c5883a 	add	r2,r2,r3
8113a1cc:	10000015 	stw	zero,0(r2)
8113a1d0:	e0bff117 	ldw	r2,-60(fp)
8113a1d4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a1d8:	e0bff417 	ldw	r2,-48(fp)
8113a1dc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113a1e0:	e0bff603 	ldbu	r2,-40(fp)
8113a1e4:	00000506 	br	8113a1fc <OSTaskCreateExt+0x1d8>
8113a1e8:	e0bff117 	ldw	r2,-60(fp)
8113a1ec:	e0bff715 	stw	r2,-36(fp)
8113a1f0:	e0bff717 	ldw	r2,-36(fp)
8113a1f4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113a1f8:	00800a04 	movi	r2,40
}
8113a1fc:	e037883a 	mov	sp,fp
8113a200:	dfc00117 	ldw	ra,4(sp)
8113a204:	df000017 	ldw	fp,0(sp)
8113a208:	dec00204 	addi	sp,sp,8
8113a20c:	f800283a 	ret

8113a210 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113a210:	defff404 	addi	sp,sp,-48
8113a214:	de00012e 	bgeu	sp,et,8113a21c <OSTaskDel+0xc>
8113a218:	003b68fa 	trap	3
8113a21c:	dfc00b15 	stw	ra,44(sp)
8113a220:	df000a15 	stw	fp,40(sp)
8113a224:	df000a04 	addi	fp,sp,40
8113a228:	2005883a 	mov	r2,r4
8113a22c:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113a230:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113a234:	d0a09b03 	ldbu	r2,-32148(gp)
8113a238:	10803fcc 	andi	r2,r2,255
8113a23c:	10000226 	beq	r2,zero,8113a248 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113a240:	00801004 	movi	r2,64
8113a244:	0000c006 	br	8113a548 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113a248:	e0bfff03 	ldbu	r2,-4(fp)
8113a24c:	10800a18 	cmpnei	r2,r2,40
8113a250:	1000021e 	bne	r2,zero,8113a25c <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113a254:	00800f84 	movi	r2,62
8113a258:	0000bb06 	br	8113a548 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113a25c:	e0bfff03 	ldbu	r2,-4(fp)
8113a260:	10800a30 	cmpltui	r2,r2,40
8113a264:	1000051e 	bne	r2,zero,8113a27c <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113a268:	e0bfff03 	ldbu	r2,-4(fp)
8113a26c:	10803fe0 	cmpeqi	r2,r2,255
8113a270:	1000021e 	bne	r2,zero,8113a27c <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113a274:	00800a84 	movi	r2,42
8113a278:	0000b306 	br	8113a548 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a27c:	0005303a 	rdctl	r2,status
8113a280:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a284:	e0fffe17 	ldw	r3,-8(fp)
8113a288:	00bfff84 	movi	r2,-2
8113a28c:	1884703a 	and	r2,r3,r2
8113a290:	1001703a 	wrctl	status,r2
  
  return context;
8113a294:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113a298:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113a29c:	e0bfff03 	ldbu	r2,-4(fp)
8113a2a0:	10803fd8 	cmpnei	r2,r2,255
8113a2a4:	1000031e 	bne	r2,zero,8113a2b4 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113a2a8:	d0a09c17 	ldw	r2,-32144(gp)
8113a2ac:	10800c83 	ldbu	r2,50(r2)
8113a2b0:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113a2b4:	e0ffff03 	ldbu	r3,-4(fp)
8113a2b8:	00a045b4 	movhi	r2,33046
8113a2bc:	10979804 	addi	r2,r2,24160
8113a2c0:	18c7883a 	add	r3,r3,r3
8113a2c4:	18c7883a 	add	r3,r3,r3
8113a2c8:	10c5883a 	add	r2,r2,r3
8113a2cc:	10800017 	ldw	r2,0(r2)
8113a2d0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113a2d4:	e0bff817 	ldw	r2,-32(fp)
8113a2d8:	1000061e 	bne	r2,zero,8113a2f4 <OSTaskDel+0xe4>
8113a2dc:	e0bff617 	ldw	r2,-40(fp)
8113a2e0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a2e4:	e0bff717 	ldw	r2,-36(fp)
8113a2e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113a2ec:	008010c4 	movi	r2,67
8113a2f0:	00009506 	br	8113a548 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113a2f4:	e0bff817 	ldw	r2,-32(fp)
8113a2f8:	10800058 	cmpnei	r2,r2,1
8113a2fc:	1000061e 	bne	r2,zero,8113a318 <OSTaskDel+0x108>
8113a300:	e0bff617 	ldw	r2,-40(fp)
8113a304:	e0bff915 	stw	r2,-28(fp)
8113a308:	e0bff917 	ldw	r2,-28(fp)
8113a30c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113a310:	00800f44 	movi	r2,61
8113a314:	00008c06 	br	8113a548 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113a318:	e0bff817 	ldw	r2,-32(fp)
8113a31c:	10800d03 	ldbu	r2,52(r2)
8113a320:	10c03fcc 	andi	r3,r2,255
8113a324:	e0bff817 	ldw	r2,-32(fp)
8113a328:	10800d03 	ldbu	r2,52(r2)
8113a32c:	11003fcc 	andi	r4,r2,255
8113a330:	d0a09844 	addi	r2,gp,-32159
8113a334:	2085883a 	add	r2,r4,r2
8113a338:	10800003 	ldbu	r2,0(r2)
8113a33c:	1009883a 	mov	r4,r2
8113a340:	e0bff817 	ldw	r2,-32(fp)
8113a344:	10800d43 	ldbu	r2,53(r2)
8113a348:	0084303a 	nor	r2,zero,r2
8113a34c:	2084703a 	and	r2,r4,r2
8113a350:	1009883a 	mov	r4,r2
8113a354:	d0a09844 	addi	r2,gp,-32159
8113a358:	1885883a 	add	r2,r3,r2
8113a35c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113a360:	e0bff817 	ldw	r2,-32(fp)
8113a364:	10800d03 	ldbu	r2,52(r2)
8113a368:	10c03fcc 	andi	r3,r2,255
8113a36c:	d0a09844 	addi	r2,gp,-32159
8113a370:	1885883a 	add	r2,r3,r2
8113a374:	10800003 	ldbu	r2,0(r2)
8113a378:	10803fcc 	andi	r2,r2,255
8113a37c:	1000071e 	bne	r2,zero,8113a39c <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113a380:	e0bff817 	ldw	r2,-32(fp)
8113a384:	10800d83 	ldbu	r2,54(r2)
8113a388:	0084303a 	nor	r2,zero,r2
8113a38c:	1007883a 	mov	r3,r2
8113a390:	d0a09803 	ldbu	r2,-32160(gp)
8113a394:	1884703a 	and	r2,r3,r2
8113a398:	d0a09805 	stb	r2,-32160(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113a39c:	e0bff817 	ldw	r2,-32(fp)
8113a3a0:	10800717 	ldw	r2,28(r2)
8113a3a4:	10000526 	beq	r2,zero,8113a3bc <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113a3a8:	e0bff817 	ldw	r2,-32(fp)
8113a3ac:	10800717 	ldw	r2,28(r2)
8113a3b0:	100b883a 	mov	r5,r2
8113a3b4:	e13ff817 	ldw	r4,-32(fp)
8113a3b8:	1133f100 	call	81133f10 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113a3bc:	e0bff817 	ldw	r2,-32(fp)
8113a3c0:	10800817 	ldw	r2,32(r2)
8113a3c4:	10000526 	beq	r2,zero,8113a3dc <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113a3c8:	e0bff817 	ldw	r2,-32(fp)
8113a3cc:	10800817 	ldw	r2,32(r2)
8113a3d0:	100b883a 	mov	r5,r2
8113a3d4:	e13ff817 	ldw	r4,-32(fp)
8113a3d8:	1133fd00 	call	81133fd0 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113a3dc:	e0bff817 	ldw	r2,-32(fp)
8113a3e0:	10800a17 	ldw	r2,40(r2)
8113a3e4:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113a3e8:	e0bffb17 	ldw	r2,-20(fp)
8113a3ec:	10000226 	beq	r2,zero,8113a3f8 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113a3f0:	e13ffb17 	ldw	r4,-20(fp)
8113a3f4:	11365a80 	call	811365a8 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113a3f8:	e0bff817 	ldw	r2,-32(fp)
8113a3fc:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113a400:	e0bff817 	ldw	r2,-32(fp)
8113a404:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113a408:	e0bff817 	ldw	r2,-32(fp)
8113a40c:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113a410:	d0a08903 	ldbu	r2,-32220(gp)
8113a414:	10803fcc 	andi	r2,r2,255
8113a418:	10803fe0 	cmpeqi	r2,r2,255
8113a41c:	1000031e 	bne	r2,zero,8113a42c <OSTaskDel+0x21c>
        OSLockNesting++;
8113a420:	d0a08903 	ldbu	r2,-32220(gp)
8113a424:	10800044 	addi	r2,r2,1
8113a428:	d0a08905 	stb	r2,-32220(gp)
8113a42c:	e0bff617 	ldw	r2,-40(fp)
8113a430:	e0bffd15 	stw	r2,-12(fp)
8113a434:	e0bffd17 	ldw	r2,-12(fp)
8113a438:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113a43c:	1133ad80 	call	81133ad8 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a440:	0005303a 	rdctl	r2,status
8113a444:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a448:	e0fffa17 	ldw	r3,-24(fp)
8113a44c:	00bfff84 	movi	r2,-2
8113a450:	1884703a 	and	r2,r3,r2
8113a454:	1001703a 	wrctl	status,r2
  
  return context;
8113a458:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113a45c:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113a460:	d0a08903 	ldbu	r2,-32220(gp)
8113a464:	10803fcc 	andi	r2,r2,255
8113a468:	10000326 	beq	r2,zero,8113a478 <OSTaskDel+0x268>
        OSLockNesting--;
8113a46c:	d0a08903 	ldbu	r2,-32220(gp)
8113a470:	10bfffc4 	addi	r2,r2,-1
8113a474:	d0a08905 	stb	r2,-32220(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113a478:	e13ff817 	ldw	r4,-32(fp)
8113a47c:	11456a80 	call	811456a8 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113a480:	d0a09443 	ldbu	r2,-32175(gp)
8113a484:	10bfffc4 	addi	r2,r2,-1
8113a488:	d0a09445 	stb	r2,-32175(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113a48c:	e0ffff03 	ldbu	r3,-4(fp)
8113a490:	00a045b4 	movhi	r2,33046
8113a494:	10979804 	addi	r2,r2,24160
8113a498:	18c7883a 	add	r3,r3,r3
8113a49c:	18c7883a 	add	r3,r3,r3
8113a4a0:	10c5883a 	add	r2,r2,r3
8113a4a4:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113a4a8:	e0bff817 	ldw	r2,-32(fp)
8113a4ac:	10800617 	ldw	r2,24(r2)
8113a4b0:	1000071e 	bne	r2,zero,8113a4d0 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113a4b4:	e0bff817 	ldw	r2,-32(fp)
8113a4b8:	10800517 	ldw	r2,20(r2)
8113a4bc:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113a4c0:	e0bff817 	ldw	r2,-32(fp)
8113a4c4:	10800517 	ldw	r2,20(r2)
8113a4c8:	d0a08e15 	stw	r2,-32200(gp)
8113a4cc:	00000a06 	br	8113a4f8 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113a4d0:	e0bff817 	ldw	r2,-32(fp)
8113a4d4:	10800617 	ldw	r2,24(r2)
8113a4d8:	e0fff817 	ldw	r3,-32(fp)
8113a4dc:	18c00517 	ldw	r3,20(r3)
8113a4e0:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113a4e4:	e0bff817 	ldw	r2,-32(fp)
8113a4e8:	10800517 	ldw	r2,20(r2)
8113a4ec:	e0fff817 	ldw	r3,-32(fp)
8113a4f0:	18c00617 	ldw	r3,24(r3)
8113a4f4:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113a4f8:	d0e09317 	ldw	r3,-32180(gp)
8113a4fc:	e0bff817 	ldw	r2,-32(fp)
8113a500:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113a504:	e0bff817 	ldw	r2,-32(fp)
8113a508:	d0a09315 	stw	r2,-32180(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113a50c:	e0bff817 	ldw	r2,-32(fp)
8113a510:	00c00fc4 	movi	r3,63
8113a514:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113a518:	e0bff817 	ldw	r2,-32(fp)
8113a51c:	10001345 	stb	zero,77(r2)
8113a520:	e0bff617 	ldw	r2,-40(fp)
8113a524:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a528:	e0bffc17 	ldw	r2,-16(fp)
8113a52c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113a530:	d0a08b03 	ldbu	r2,-32212(gp)
8113a534:	10803fcc 	andi	r2,r2,255
8113a538:	10800058 	cmpnei	r2,r2,1
8113a53c:	1000011e 	bne	r2,zero,8113a544 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113a540:	11345bc0 	call	811345bc <OS_Sched>
    }
    return (OS_ERR_NONE);
8113a544:	0005883a 	mov	r2,zero
}
8113a548:	e037883a 	mov	sp,fp
8113a54c:	dfc00117 	ldw	ra,4(sp)
8113a550:	df000017 	ldw	fp,0(sp)
8113a554:	dec00204 	addi	sp,sp,8
8113a558:	f800283a 	ret

8113a55c <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113a55c:	defff504 	addi	sp,sp,-44
8113a560:	de00012e 	bgeu	sp,et,8113a568 <OSTaskDelReq+0xc>
8113a564:	003b68fa 	trap	3
8113a568:	df000a15 	stw	fp,40(sp)
8113a56c:	df000a04 	addi	fp,sp,40
8113a570:	2005883a 	mov	r2,r4
8113a574:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a578:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113a57c:	e0bfff03 	ldbu	r2,-4(fp)
8113a580:	10800a18 	cmpnei	r2,r2,40
8113a584:	1000021e 	bne	r2,zero,8113a590 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113a588:	00800f84 	movi	r2,62
8113a58c:	00004506 	br	8113a6a4 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113a590:	e0bfff03 	ldbu	r2,-4(fp)
8113a594:	10800a30 	cmpltui	r2,r2,40
8113a598:	1000051e 	bne	r2,zero,8113a5b0 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113a59c:	e0bfff03 	ldbu	r2,-4(fp)
8113a5a0:	10803fe0 	cmpeqi	r2,r2,255
8113a5a4:	1000021e 	bne	r2,zero,8113a5b0 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113a5a8:	00800a84 	movi	r2,42
8113a5ac:	00003d06 	br	8113a6a4 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113a5b0:	e0bfff03 	ldbu	r2,-4(fp)
8113a5b4:	10803fd8 	cmpnei	r2,r2,255
8113a5b8:	1000111e 	bne	r2,zero,8113a600 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a5bc:	0005303a 	rdctl	r2,status
8113a5c0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a5c4:	e0fff917 	ldw	r3,-28(fp)
8113a5c8:	00bfff84 	movi	r2,-2
8113a5cc:	1884703a 	and	r2,r3,r2
8113a5d0:	1001703a 	wrctl	status,r2
  
  return context;
8113a5d4:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113a5d8:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113a5dc:	d0a09c17 	ldw	r2,-32144(gp)
8113a5e0:	10800dc3 	ldbu	r2,55(r2)
8113a5e4:	e0bff805 	stb	r2,-32(fp)
8113a5e8:	e0bff617 	ldw	r2,-40(fp)
8113a5ec:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a5f0:	e0bffe17 	ldw	r2,-8(fp)
8113a5f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113a5f8:	e0bff803 	ldbu	r2,-32(fp)
8113a5fc:	00002906 	br	8113a6a4 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a600:	0005303a 	rdctl	r2,status
8113a604:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a608:	e0fff717 	ldw	r3,-36(fp)
8113a60c:	00bfff84 	movi	r2,-2
8113a610:	1884703a 	and	r2,r3,r2
8113a614:	1001703a 	wrctl	status,r2
  
  return context;
8113a618:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113a61c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113a620:	e0ffff03 	ldbu	r3,-4(fp)
8113a624:	00a045b4 	movhi	r2,33046
8113a628:	10979804 	addi	r2,r2,24160
8113a62c:	18c7883a 	add	r3,r3,r3
8113a630:	18c7883a 	add	r3,r3,r3
8113a634:	10c5883a 	add	r2,r2,r3
8113a638:	10800017 	ldw	r2,0(r2)
8113a63c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113a640:	e0bffb17 	ldw	r2,-20(fp)
8113a644:	1000061e 	bne	r2,zero,8113a660 <OSTaskDelReq+0x104>
8113a648:	e0bff617 	ldw	r2,-40(fp)
8113a64c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a650:	e0bffa17 	ldw	r2,-24(fp)
8113a654:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113a658:	008010c4 	movi	r2,67
8113a65c:	00001106 	br	8113a6a4 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113a660:	e0bffb17 	ldw	r2,-20(fp)
8113a664:	10800058 	cmpnei	r2,r2,1
8113a668:	1000061e 	bne	r2,zero,8113a684 <OSTaskDelReq+0x128>
8113a66c:	e0bff617 	ldw	r2,-40(fp)
8113a670:	e0bffc15 	stw	r2,-16(fp)
8113a674:	e0bffc17 	ldw	r2,-16(fp)
8113a678:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113a67c:	00800f44 	movi	r2,61
8113a680:	00000806 	br	8113a6a4 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113a684:	e0bffb17 	ldw	r2,-20(fp)
8113a688:	00c00fc4 	movi	r3,63
8113a68c:	10c00dc5 	stb	r3,55(r2)
8113a690:	e0bff617 	ldw	r2,-40(fp)
8113a694:	e0bffd15 	stw	r2,-12(fp)
8113a698:	e0bffd17 	ldw	r2,-12(fp)
8113a69c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a6a0:	0005883a 	mov	r2,zero
}
8113a6a4:	e037883a 	mov	sp,fp
8113a6a8:	df000017 	ldw	fp,0(sp)
8113a6ac:	dec00104 	addi	sp,sp,4
8113a6b0:	f800283a 	ret

8113a6b4 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113a6b4:	defff404 	addi	sp,sp,-48
8113a6b8:	de00012e 	bgeu	sp,et,8113a6c0 <OSTaskNameGet+0xc>
8113a6bc:	003b68fa 	trap	3
8113a6c0:	dfc00b15 	stw	ra,44(sp)
8113a6c4:	df000a15 	stw	fp,40(sp)
8113a6c8:	df000a04 	addi	fp,sp,40
8113a6cc:	2005883a 	mov	r2,r4
8113a6d0:	e17ffe15 	stw	r5,-8(fp)
8113a6d4:	e1bfff15 	stw	r6,-4(fp)
8113a6d8:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113a6dc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113a6e0:	e0bfff17 	ldw	r2,-4(fp)
8113a6e4:	1000021e 	bne	r2,zero,8113a6f0 <OSTaskNameGet+0x3c>
        return (0);
8113a6e8:	0005883a 	mov	r2,zero
8113a6ec:	00005406 	br	8113a840 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113a6f0:	e0bffd03 	ldbu	r2,-12(fp)
8113a6f4:	10800a70 	cmpltui	r2,r2,41
8113a6f8:	1000081e 	bne	r2,zero,8113a71c <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113a6fc:	e0bffd03 	ldbu	r2,-12(fp)
8113a700:	10803fe0 	cmpeqi	r2,r2,255
8113a704:	1000051e 	bne	r2,zero,8113a71c <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113a708:	e0bfff17 	ldw	r2,-4(fp)
8113a70c:	00c00a84 	movi	r3,42
8113a710:	10c00005 	stb	r3,0(r2)
            return (0);
8113a714:	0005883a 	mov	r2,zero
8113a718:	00004906 	br	8113a840 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113a71c:	e0bffe17 	ldw	r2,-8(fp)
8113a720:	1000051e 	bne	r2,zero,8113a738 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113a724:	e0bfff17 	ldw	r2,-4(fp)
8113a728:	00c00304 	movi	r3,12
8113a72c:	10c00005 	stb	r3,0(r2)
        return (0);
8113a730:	0005883a 	mov	r2,zero
8113a734:	00004206 	br	8113a840 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113a738:	d0a09b03 	ldbu	r2,-32148(gp)
8113a73c:	10803fcc 	andi	r2,r2,255
8113a740:	10000526 	beq	r2,zero,8113a758 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113a744:	e0bfff17 	ldw	r2,-4(fp)
8113a748:	00c00444 	movi	r3,17
8113a74c:	10c00005 	stb	r3,0(r2)
        return (0);
8113a750:	0005883a 	mov	r2,zero
8113a754:	00003a06 	br	8113a840 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a758:	0005303a 	rdctl	r2,status
8113a75c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a760:	e0fffc17 	ldw	r3,-16(fp)
8113a764:	00bfff84 	movi	r2,-2
8113a768:	1884703a 	and	r2,r3,r2
8113a76c:	1001703a 	wrctl	status,r2
  
  return context;
8113a770:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a774:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113a778:	e0bffd03 	ldbu	r2,-12(fp)
8113a77c:	10803fd8 	cmpnei	r2,r2,255
8113a780:	1000031e 	bne	r2,zero,8113a790 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113a784:	d0a09c17 	ldw	r2,-32144(gp)
8113a788:	10800c83 	ldbu	r2,50(r2)
8113a78c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113a790:	e0fffd03 	ldbu	r3,-12(fp)
8113a794:	00a045b4 	movhi	r2,33046
8113a798:	10979804 	addi	r2,r2,24160
8113a79c:	18c7883a 	add	r3,r3,r3
8113a7a0:	18c7883a 	add	r3,r3,r3
8113a7a4:	10c5883a 	add	r2,r2,r3
8113a7a8:	10800017 	ldw	r2,0(r2)
8113a7ac:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113a7b0:	e0bff817 	ldw	r2,-32(fp)
8113a7b4:	1000091e 	bne	r2,zero,8113a7dc <OSTaskNameGet+0x128>
8113a7b8:	e0bff617 	ldw	r2,-40(fp)
8113a7bc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a7c0:	e0bff717 	ldw	r2,-36(fp)
8113a7c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113a7c8:	e0bfff17 	ldw	r2,-4(fp)
8113a7cc:	00c010c4 	movi	r3,67
8113a7d0:	10c00005 	stb	r3,0(r2)
        return (0);
8113a7d4:	0005883a 	mov	r2,zero
8113a7d8:	00001906 	br	8113a840 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8113a7dc:	e0bff817 	ldw	r2,-32(fp)
8113a7e0:	10800058 	cmpnei	r2,r2,1
8113a7e4:	1000091e 	bne	r2,zero,8113a80c <OSTaskNameGet+0x158>
8113a7e8:	e0bff617 	ldw	r2,-40(fp)
8113a7ec:	e0bff915 	stw	r2,-28(fp)
8113a7f0:	e0bff917 	ldw	r2,-28(fp)
8113a7f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113a7f8:	e0bfff17 	ldw	r2,-4(fp)
8113a7fc:	00c010c4 	movi	r3,67
8113a800:	10c00005 	stb	r3,0(r2)
        return (0);
8113a804:	0005883a 	mov	r2,zero
8113a808:	00000d06 	br	8113a840 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8113a80c:	e0bff817 	ldw	r2,-32(fp)
8113a810:	10801304 	addi	r2,r2,76
8113a814:	100b883a 	mov	r5,r2
8113a818:	e13ffe17 	ldw	r4,-8(fp)
8113a81c:	11347100 	call	81134710 <OS_StrCopy>
8113a820:	e0bffb05 	stb	r2,-20(fp)
8113a824:	e0bff617 	ldw	r2,-40(fp)
8113a828:	e0bffa15 	stw	r2,-24(fp)
8113a82c:	e0bffa17 	ldw	r2,-24(fp)
8113a830:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a834:	e0bfff17 	ldw	r2,-4(fp)
8113a838:	10000005 	stb	zero,0(r2)
    return (len);
8113a83c:	e0bffb03 	ldbu	r2,-20(fp)
}
8113a840:	e037883a 	mov	sp,fp
8113a844:	dfc00117 	ldw	ra,4(sp)
8113a848:	df000017 	ldw	fp,0(sp)
8113a84c:	dec00204 	addi	sp,sp,8
8113a850:	f800283a 	ret

8113a854 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113a854:	defff304 	addi	sp,sp,-52
8113a858:	de00012e 	bgeu	sp,et,8113a860 <OSTaskNameSet+0xc>
8113a85c:	003b68fa 	trap	3
8113a860:	dfc00c15 	stw	ra,48(sp)
8113a864:	df000b15 	stw	fp,44(sp)
8113a868:	df000b04 	addi	fp,sp,44
8113a86c:	2005883a 	mov	r2,r4
8113a870:	e17ffe15 	stw	r5,-8(fp)
8113a874:	e1bfff15 	stw	r6,-4(fp)
8113a878:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113a87c:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113a880:	e0bfff17 	ldw	r2,-4(fp)
8113a884:	10005c26 	beq	r2,zero,8113a9f8 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8113a888:	e0bffd03 	ldbu	r2,-12(fp)
8113a88c:	10800a70 	cmpltui	r2,r2,41
8113a890:	1000071e 	bne	r2,zero,8113a8b0 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8113a894:	e0bffd03 	ldbu	r2,-12(fp)
8113a898:	10803fe0 	cmpeqi	r2,r2,255
8113a89c:	1000041e 	bne	r2,zero,8113a8b0 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113a8a0:	e0bfff17 	ldw	r2,-4(fp)
8113a8a4:	00c00a84 	movi	r3,42
8113a8a8:	10c00005 	stb	r3,0(r2)
            return;
8113a8ac:	00005306 	br	8113a9fc <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113a8b0:	e0bffe17 	ldw	r2,-8(fp)
8113a8b4:	1000041e 	bne	r2,zero,8113a8c8 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8113a8b8:	e0bfff17 	ldw	r2,-4(fp)
8113a8bc:	00c00304 	movi	r3,12
8113a8c0:	10c00005 	stb	r3,0(r2)
        return;
8113a8c4:	00004d06 	br	8113a9fc <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8113a8c8:	d0a09b03 	ldbu	r2,-32148(gp)
8113a8cc:	10803fcc 	andi	r2,r2,255
8113a8d0:	10000426 	beq	r2,zero,8113a8e4 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8113a8d4:	e0bfff17 	ldw	r2,-4(fp)
8113a8d8:	00c00484 	movi	r3,18
8113a8dc:	10c00005 	stb	r3,0(r2)
        return;
8113a8e0:	00004606 	br	8113a9fc <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a8e4:	0005303a 	rdctl	r2,status
8113a8e8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a8ec:	e0fffc17 	ldw	r3,-16(fp)
8113a8f0:	00bfff84 	movi	r2,-2
8113a8f4:	1884703a 	and	r2,r3,r2
8113a8f8:	1001703a 	wrctl	status,r2
  
  return context;
8113a8fc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a900:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8113a904:	e0bffd03 	ldbu	r2,-12(fp)
8113a908:	10803fd8 	cmpnei	r2,r2,255
8113a90c:	1000031e 	bne	r2,zero,8113a91c <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113a910:	d0a09c17 	ldw	r2,-32144(gp)
8113a914:	10800c83 	ldbu	r2,50(r2)
8113a918:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113a91c:	e0fffd03 	ldbu	r3,-12(fp)
8113a920:	00a045b4 	movhi	r2,33046
8113a924:	10979804 	addi	r2,r2,24160
8113a928:	18c7883a 	add	r3,r3,r3
8113a92c:	18c7883a 	add	r3,r3,r3
8113a930:	10c5883a 	add	r2,r2,r3
8113a934:	10800017 	ldw	r2,0(r2)
8113a938:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8113a93c:	e0bff717 	ldw	r2,-36(fp)
8113a940:	1000081e 	bne	r2,zero,8113a964 <OSTaskNameSet+0x110>
8113a944:	e0bff517 	ldw	r2,-44(fp)
8113a948:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a94c:	e0bff617 	ldw	r2,-40(fp)
8113a950:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113a954:	e0bfff17 	ldw	r2,-4(fp)
8113a958:	00c010c4 	movi	r3,67
8113a95c:	10c00005 	stb	r3,0(r2)
        return;
8113a960:	00002606 	br	8113a9fc <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8113a964:	e0bff717 	ldw	r2,-36(fp)
8113a968:	10800058 	cmpnei	r2,r2,1
8113a96c:	1000081e 	bne	r2,zero,8113a990 <OSTaskNameSet+0x13c>
8113a970:	e0bff517 	ldw	r2,-44(fp)
8113a974:	e0bff815 	stw	r2,-32(fp)
8113a978:	e0bff817 	ldw	r2,-32(fp)
8113a97c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113a980:	e0bfff17 	ldw	r2,-4(fp)
8113a984:	00c010c4 	movi	r3,67
8113a988:	10c00005 	stb	r3,0(r2)
        return;
8113a98c:	00001b06 	br	8113a9fc <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113a990:	e13ffe17 	ldw	r4,-8(fp)
8113a994:	113478c0 	call	8113478c <OS_StrLen>
8113a998:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113a99c:	e0bffa03 	ldbu	r2,-24(fp)
8113a9a0:	10800830 	cmpltui	r2,r2,32
8113a9a4:	1000081e 	bne	r2,zero,8113a9c8 <OSTaskNameSet+0x174>
8113a9a8:	e0bff517 	ldw	r2,-44(fp)
8113a9ac:	e0bff915 	stw	r2,-28(fp)
8113a9b0:	e0bff917 	ldw	r2,-28(fp)
8113a9b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8113a9b8:	e0bfff17 	ldw	r2,-4(fp)
8113a9bc:	00c01044 	movi	r3,65
8113a9c0:	10c00005 	stb	r3,0(r2)
        return;
8113a9c4:	00000d06 	br	8113a9fc <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8113a9c8:	e0bff717 	ldw	r2,-36(fp)
8113a9cc:	10801304 	addi	r2,r2,76
8113a9d0:	e17ffe17 	ldw	r5,-8(fp)
8113a9d4:	1009883a 	mov	r4,r2
8113a9d8:	11347100 	call	81134710 <OS_StrCopy>
8113a9dc:	e0bff517 	ldw	r2,-44(fp)
8113a9e0:	e0bffb15 	stw	r2,-20(fp)
8113a9e4:	e0bffb17 	ldw	r2,-20(fp)
8113a9e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a9ec:	e0bfff17 	ldw	r2,-4(fp)
8113a9f0:	10000005 	stb	zero,0(r2)
8113a9f4:	00000106 	br	8113a9fc <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8113a9f8:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113a9fc:	e037883a 	mov	sp,fp
8113aa00:	dfc00117 	ldw	ra,4(sp)
8113aa04:	df000017 	ldw	fp,0(sp)
8113aa08:	dec00204 	addi	sp,sp,8
8113aa0c:	f800283a 	ret

8113aa10 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113aa10:	defff404 	addi	sp,sp,-48
8113aa14:	de00012e 	bgeu	sp,et,8113aa1c <OSTaskResume+0xc>
8113aa18:	003b68fa 	trap	3
8113aa1c:	dfc00b15 	stw	ra,44(sp)
8113aa20:	df000a15 	stw	fp,40(sp)
8113aa24:	df000a04 	addi	fp,sp,40
8113aa28:	2005883a 	mov	r2,r4
8113aa2c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113aa30:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113aa34:	e0bfff03 	ldbu	r2,-4(fp)
8113aa38:	10800a30 	cmpltui	r2,r2,40
8113aa3c:	1000021e 	bne	r2,zero,8113aa48 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113aa40:	00800a84 	movi	r2,42
8113aa44:	00006406 	br	8113abd8 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aa48:	0005303a 	rdctl	r2,status
8113aa4c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aa50:	e0fffe17 	ldw	r3,-8(fp)
8113aa54:	00bfff84 	movi	r2,-2
8113aa58:	1884703a 	and	r2,r3,r2
8113aa5c:	1001703a 	wrctl	status,r2
  
  return context;
8113aa60:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113aa64:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113aa68:	e0ffff03 	ldbu	r3,-4(fp)
8113aa6c:	00a045b4 	movhi	r2,33046
8113aa70:	10979804 	addi	r2,r2,24160
8113aa74:	18c7883a 	add	r3,r3,r3
8113aa78:	18c7883a 	add	r3,r3,r3
8113aa7c:	10c5883a 	add	r2,r2,r3
8113aa80:	10800017 	ldw	r2,0(r2)
8113aa84:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8113aa88:	e0bff817 	ldw	r2,-32(fp)
8113aa8c:	1000061e 	bne	r2,zero,8113aaa8 <OSTaskResume+0x98>
8113aa90:	e0bff617 	ldw	r2,-40(fp)
8113aa94:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aa98:	e0bff717 	ldw	r2,-36(fp)
8113aa9c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113aaa0:	00801184 	movi	r2,70
8113aaa4:	00004c06 	br	8113abd8 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8113aaa8:	e0bff817 	ldw	r2,-32(fp)
8113aaac:	10800058 	cmpnei	r2,r2,1
8113aab0:	1000061e 	bne	r2,zero,8113aacc <OSTaskResume+0xbc>
8113aab4:	e0bff617 	ldw	r2,-40(fp)
8113aab8:	e0bff915 	stw	r2,-28(fp)
8113aabc:	e0bff917 	ldw	r2,-28(fp)
8113aac0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113aac4:	008010c4 	movi	r2,67
8113aac8:	00004306 	br	8113abd8 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113aacc:	e0bff817 	ldw	r2,-32(fp)
8113aad0:	10800c03 	ldbu	r2,48(r2)
8113aad4:	10803fcc 	andi	r2,r2,255
8113aad8:	1080020c 	andi	r2,r2,8
8113aadc:	10003926 	beq	r2,zero,8113abc4 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113aae0:	e0bff817 	ldw	r2,-32(fp)
8113aae4:	10c00c03 	ldbu	r3,48(r2)
8113aae8:	00bffdc4 	movi	r2,-9
8113aaec:	1884703a 	and	r2,r3,r2
8113aaf0:	1007883a 	mov	r3,r2
8113aaf4:	e0bff817 	ldw	r2,-32(fp)
8113aaf8:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8113aafc:	e0bff817 	ldw	r2,-32(fp)
8113ab00:	10800c03 	ldbu	r2,48(r2)
8113ab04:	10803fcc 	andi	r2,r2,255
8113ab08:	1000281e 	bne	r2,zero,8113abac <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8113ab0c:	e0bff817 	ldw	r2,-32(fp)
8113ab10:	10800b8b 	ldhu	r2,46(r2)
8113ab14:	10bfffcc 	andi	r2,r2,65535
8113ab18:	10001f1e 	bne	r2,zero,8113ab98 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8113ab1c:	e0bff817 	ldw	r2,-32(fp)
8113ab20:	10c00d83 	ldbu	r3,54(r2)
8113ab24:	d0a09803 	ldbu	r2,-32160(gp)
8113ab28:	1884b03a 	or	r2,r3,r2
8113ab2c:	d0a09805 	stb	r2,-32160(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113ab30:	e0bff817 	ldw	r2,-32(fp)
8113ab34:	10800d03 	ldbu	r2,52(r2)
8113ab38:	10c03fcc 	andi	r3,r2,255
8113ab3c:	e0bff817 	ldw	r2,-32(fp)
8113ab40:	10800d03 	ldbu	r2,52(r2)
8113ab44:	11003fcc 	andi	r4,r2,255
8113ab48:	d0a09844 	addi	r2,gp,-32159
8113ab4c:	2085883a 	add	r2,r4,r2
8113ab50:	11000003 	ldbu	r4,0(r2)
8113ab54:	e0bff817 	ldw	r2,-32(fp)
8113ab58:	10800d43 	ldbu	r2,53(r2)
8113ab5c:	2084b03a 	or	r2,r4,r2
8113ab60:	1009883a 	mov	r4,r2
8113ab64:	d0a09844 	addi	r2,gp,-32159
8113ab68:	1885883a 	add	r2,r3,r2
8113ab6c:	11000005 	stb	r4,0(r2)
8113ab70:	e0bff617 	ldw	r2,-40(fp)
8113ab74:	e0bffa15 	stw	r2,-24(fp)
8113ab78:	e0bffa17 	ldw	r2,-24(fp)
8113ab7c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113ab80:	d0a08b03 	ldbu	r2,-32212(gp)
8113ab84:	10803fcc 	andi	r2,r2,255
8113ab88:	10800058 	cmpnei	r2,r2,1
8113ab8c:	10000b1e 	bne	r2,zero,8113abbc <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113ab90:	11345bc0 	call	811345bc <OS_Sched>
8113ab94:	00000906 	br	8113abbc <OSTaskResume+0x1ac>
8113ab98:	e0bff617 	ldw	r2,-40(fp)
8113ab9c:	e0bffb15 	stw	r2,-20(fp)
8113aba0:	e0bffb17 	ldw	r2,-20(fp)
8113aba4:	1001703a 	wrctl	status,r2
8113aba8:	00000406 	br	8113abbc <OSTaskResume+0x1ac>
8113abac:	e0bff617 	ldw	r2,-40(fp)
8113abb0:	e0bffc15 	stw	r2,-16(fp)
8113abb4:	e0bffc17 	ldw	r2,-16(fp)
8113abb8:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113abbc:	0005883a 	mov	r2,zero
8113abc0:	00000506 	br	8113abd8 <OSTaskResume+0x1c8>
8113abc4:	e0bff617 	ldw	r2,-40(fp)
8113abc8:	e0bffd15 	stw	r2,-12(fp)
8113abcc:	e0bffd17 	ldw	r2,-12(fp)
8113abd0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8113abd4:	00801104 	movi	r2,68
}
8113abd8:	e037883a 	mov	sp,fp
8113abdc:	dfc00117 	ldw	ra,4(sp)
8113abe0:	df000017 	ldw	fp,0(sp)
8113abe4:	dec00204 	addi	sp,sp,8
8113abe8:	f800283a 	ret

8113abec <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113abec:	defff304 	addi	sp,sp,-52
8113abf0:	de00012e 	bgeu	sp,et,8113abf8 <OSTaskStkChk+0xc>
8113abf4:	003b68fa 	trap	3
8113abf8:	df000c15 	stw	fp,48(sp)
8113abfc:	df000c04 	addi	fp,sp,48
8113ac00:	2005883a 	mov	r2,r4
8113ac04:	e17fff15 	stw	r5,-4(fp)
8113ac08:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113ac0c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113ac10:	e0bffe03 	ldbu	r2,-8(fp)
8113ac14:	10800a70 	cmpltui	r2,r2,41
8113ac18:	1000051e 	bne	r2,zero,8113ac30 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8113ac1c:	e0bffe03 	ldbu	r2,-8(fp)
8113ac20:	10803fe0 	cmpeqi	r2,r2,255
8113ac24:	1000021e 	bne	r2,zero,8113ac30 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8113ac28:	00800a84 	movi	r2,42
8113ac2c:	00005d06 	br	8113ada4 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8113ac30:	e0bfff17 	ldw	r2,-4(fp)
8113ac34:	1000021e 	bne	r2,zero,8113ac40 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8113ac38:	00800244 	movi	r2,9
8113ac3c:	00005906 	br	8113ada4 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8113ac40:	e0bfff17 	ldw	r2,-4(fp)
8113ac44:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8113ac48:	e0bfff17 	ldw	r2,-4(fp)
8113ac4c:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ac50:	0005303a 	rdctl	r2,status
8113ac54:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ac58:	e0fffd17 	ldw	r3,-12(fp)
8113ac5c:	00bfff84 	movi	r2,-2
8113ac60:	1884703a 	and	r2,r3,r2
8113ac64:	1001703a 	wrctl	status,r2
  
  return context;
8113ac68:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113ac6c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8113ac70:	e0bffe03 	ldbu	r2,-8(fp)
8113ac74:	10803fd8 	cmpnei	r2,r2,255
8113ac78:	1000031e 	bne	r2,zero,8113ac88 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113ac7c:	d0a09c17 	ldw	r2,-32144(gp)
8113ac80:	10800c83 	ldbu	r2,50(r2)
8113ac84:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113ac88:	e0fffe03 	ldbu	r3,-8(fp)
8113ac8c:	00a045b4 	movhi	r2,33046
8113ac90:	10979804 	addi	r2,r2,24160
8113ac94:	18c7883a 	add	r3,r3,r3
8113ac98:	18c7883a 	add	r3,r3,r3
8113ac9c:	10c5883a 	add	r2,r2,r3
8113aca0:	10800017 	ldw	r2,0(r2)
8113aca4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8113aca8:	e0bff817 	ldw	r2,-32(fp)
8113acac:	1000061e 	bne	r2,zero,8113acc8 <OSTaskStkChk+0xdc>
8113acb0:	e0bff617 	ldw	r2,-40(fp)
8113acb4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113acb8:	e0bff717 	ldw	r2,-36(fp)
8113acbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113acc0:	008010c4 	movi	r2,67
8113acc4:	00003706 	br	8113ada4 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113acc8:	e0bff817 	ldw	r2,-32(fp)
8113accc:	10800058 	cmpnei	r2,r2,1
8113acd0:	1000061e 	bne	r2,zero,8113acec <OSTaskStkChk+0x100>
8113acd4:	e0bff617 	ldw	r2,-40(fp)
8113acd8:	e0bff915 	stw	r2,-28(fp)
8113acdc:	e0bff917 	ldw	r2,-28(fp)
8113ace0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113ace4:	008010c4 	movi	r2,67
8113ace8:	00002e06 	br	8113ada4 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113acec:	e0bff817 	ldw	r2,-32(fp)
8113acf0:	1080040b 	ldhu	r2,16(r2)
8113acf4:	10bfffcc 	andi	r2,r2,65535
8113acf8:	1080004c 	andi	r2,r2,1
8113acfc:	1000061e 	bne	r2,zero,8113ad18 <OSTaskStkChk+0x12c>
8113ad00:	e0bff617 	ldw	r2,-40(fp)
8113ad04:	e0bffa15 	stw	r2,-24(fp)
8113ad08:	e0bffa17 	ldw	r2,-24(fp)
8113ad0c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113ad10:	00801144 	movi	r2,69
8113ad14:	00002306 	br	8113ada4 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113ad18:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8113ad1c:	e0bff817 	ldw	r2,-32(fp)
8113ad20:	10800317 	ldw	r2,12(r2)
8113ad24:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113ad28:	e0bff817 	ldw	r2,-32(fp)
8113ad2c:	10800217 	ldw	r2,8(r2)
8113ad30:	e0bff415 	stw	r2,-48(fp)
8113ad34:	e0bff617 	ldw	r2,-40(fp)
8113ad38:	e0bffb15 	stw	r2,-20(fp)
8113ad3c:	e0bffb17 	ldw	r2,-20(fp)
8113ad40:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113ad44:	00000306 	br	8113ad54 <OSTaskStkChk+0x168>
        nfree++;
8113ad48:	e0bff517 	ldw	r2,-44(fp)
8113ad4c:	10800044 	addi	r2,r2,1
8113ad50:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113ad54:	e0bff417 	ldw	r2,-48(fp)
8113ad58:	10c00104 	addi	r3,r2,4
8113ad5c:	e0fff415 	stw	r3,-48(fp)
8113ad60:	10800017 	ldw	r2,0(r2)
8113ad64:	103ff826 	beq	r2,zero,8113ad48 <__reset+0xfb11ad48>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113ad68:	e0bff517 	ldw	r2,-44(fp)
8113ad6c:	1085883a 	add	r2,r2,r2
8113ad70:	1085883a 	add	r2,r2,r2
8113ad74:	1007883a 	mov	r3,r2
8113ad78:	e0bfff17 	ldw	r2,-4(fp)
8113ad7c:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113ad80:	e0fffc17 	ldw	r3,-16(fp)
8113ad84:	e0bff517 	ldw	r2,-44(fp)
8113ad88:	1885c83a 	sub	r2,r3,r2
8113ad8c:	1085883a 	add	r2,r2,r2
8113ad90:	1085883a 	add	r2,r2,r2
8113ad94:	1007883a 	mov	r3,r2
8113ad98:	e0bfff17 	ldw	r2,-4(fp)
8113ad9c:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113ada0:	0005883a 	mov	r2,zero
}
8113ada4:	e037883a 	mov	sp,fp
8113ada8:	df000017 	ldw	fp,0(sp)
8113adac:	dec00104 	addi	sp,sp,4
8113adb0:	f800283a 	ret

8113adb4 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8113adb4:	defff504 	addi	sp,sp,-44
8113adb8:	de00012e 	bgeu	sp,et,8113adc0 <OSTaskSuspend+0xc>
8113adbc:	003b68fa 	trap	3
8113adc0:	dfc00a15 	stw	ra,40(sp)
8113adc4:	df000915 	stw	fp,36(sp)
8113adc8:	df000904 	addi	fp,sp,36
8113adcc:	2005883a 	mov	r2,r4
8113add0:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113add4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8113add8:	e0bfff03 	ldbu	r2,-4(fp)
8113addc:	10800a18 	cmpnei	r2,r2,40
8113ade0:	1000021e 	bne	r2,zero,8113adec <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8113ade4:	008011c4 	movi	r2,71
8113ade8:	00006806 	br	8113af8c <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113adec:	e0bfff03 	ldbu	r2,-4(fp)
8113adf0:	10800a30 	cmpltui	r2,r2,40
8113adf4:	1000051e 	bne	r2,zero,8113ae0c <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8113adf8:	e0bfff03 	ldbu	r2,-4(fp)
8113adfc:	10803fe0 	cmpeqi	r2,r2,255
8113ae00:	1000021e 	bne	r2,zero,8113ae0c <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8113ae04:	00800a84 	movi	r2,42
8113ae08:	00006006 	br	8113af8c <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ae0c:	0005303a 	rdctl	r2,status
8113ae10:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ae14:	e0fffe17 	ldw	r3,-8(fp)
8113ae18:	00bfff84 	movi	r2,-2
8113ae1c:	1884703a 	and	r2,r3,r2
8113ae20:	1001703a 	wrctl	status,r2
  
  return context;
8113ae24:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8113ae28:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8113ae2c:	e0bfff03 	ldbu	r2,-4(fp)
8113ae30:	10803fd8 	cmpnei	r2,r2,255
8113ae34:	1000061e 	bne	r2,zero,8113ae50 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113ae38:	d0a09c17 	ldw	r2,-32144(gp)
8113ae3c:	10800c83 	ldbu	r2,50(r2)
8113ae40:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8113ae44:	00800044 	movi	r2,1
8113ae48:	e0bff705 	stb	r2,-36(fp)
8113ae4c:	00000906 	br	8113ae74 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
8113ae50:	d0a09c17 	ldw	r2,-32144(gp)
8113ae54:	10800c83 	ldbu	r2,50(r2)
8113ae58:	10c03fcc 	andi	r3,r2,255
8113ae5c:	e0bfff03 	ldbu	r2,-4(fp)
8113ae60:	1880031e 	bne	r3,r2,8113ae70 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8113ae64:	00800044 	movi	r2,1
8113ae68:	e0bff705 	stb	r2,-36(fp)
8113ae6c:	00000106 	br	8113ae74 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
8113ae70:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113ae74:	e0ffff03 	ldbu	r3,-4(fp)
8113ae78:	00a045b4 	movhi	r2,33046
8113ae7c:	10979804 	addi	r2,r2,24160
8113ae80:	18c7883a 	add	r3,r3,r3
8113ae84:	18c7883a 	add	r3,r3,r3
8113ae88:	10c5883a 	add	r2,r2,r3
8113ae8c:	10800017 	ldw	r2,0(r2)
8113ae90:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8113ae94:	e0bffa17 	ldw	r2,-24(fp)
8113ae98:	1000061e 	bne	r2,zero,8113aeb4 <OSTaskSuspend+0x100>
8113ae9c:	e0bff817 	ldw	r2,-32(fp)
8113aea0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aea4:	e0bff917 	ldw	r2,-28(fp)
8113aea8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113aeac:	00801204 	movi	r2,72
8113aeb0:	00003606 	br	8113af8c <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
8113aeb4:	e0bffa17 	ldw	r2,-24(fp)
8113aeb8:	10800058 	cmpnei	r2,r2,1
8113aebc:	1000061e 	bne	r2,zero,8113aed8 <OSTaskSuspend+0x124>
8113aec0:	e0bff817 	ldw	r2,-32(fp)
8113aec4:	e0bffb15 	stw	r2,-20(fp)
8113aec8:	e0bffb17 	ldw	r2,-20(fp)
8113aecc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113aed0:	008010c4 	movi	r2,67
8113aed4:	00002d06 	br	8113af8c <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8113aed8:	e0bffa17 	ldw	r2,-24(fp)
8113aedc:	10800d03 	ldbu	r2,52(r2)
8113aee0:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
8113aee4:	e0fffd03 	ldbu	r3,-12(fp)
8113aee8:	e13ffd03 	ldbu	r4,-12(fp)
8113aeec:	d0a09844 	addi	r2,gp,-32159
8113aef0:	2085883a 	add	r2,r4,r2
8113aef4:	10800003 	ldbu	r2,0(r2)
8113aef8:	1009883a 	mov	r4,r2
8113aefc:	e0bffa17 	ldw	r2,-24(fp)
8113af00:	10800d43 	ldbu	r2,53(r2)
8113af04:	0084303a 	nor	r2,zero,r2
8113af08:	2084703a 	and	r2,r4,r2
8113af0c:	1009883a 	mov	r4,r2
8113af10:	d0a09844 	addi	r2,gp,-32159
8113af14:	1885883a 	add	r2,r3,r2
8113af18:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113af1c:	e0fffd03 	ldbu	r3,-12(fp)
8113af20:	d0a09844 	addi	r2,gp,-32159
8113af24:	1885883a 	add	r2,r3,r2
8113af28:	10800003 	ldbu	r2,0(r2)
8113af2c:	10803fcc 	andi	r2,r2,255
8113af30:	1000071e 	bne	r2,zero,8113af50 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113af34:	e0bffa17 	ldw	r2,-24(fp)
8113af38:	10800d83 	ldbu	r2,54(r2)
8113af3c:	0084303a 	nor	r2,zero,r2
8113af40:	1007883a 	mov	r3,r2
8113af44:	d0a09803 	ldbu	r2,-32160(gp)
8113af48:	1884703a 	and	r2,r3,r2
8113af4c:	d0a09805 	stb	r2,-32160(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
8113af50:	e0bffa17 	ldw	r2,-24(fp)
8113af54:	10800c03 	ldbu	r2,48(r2)
8113af58:	10800214 	ori	r2,r2,8
8113af5c:	1007883a 	mov	r3,r2
8113af60:	e0bffa17 	ldw	r2,-24(fp)
8113af64:	10c00c05 	stb	r3,48(r2)
8113af68:	e0bff817 	ldw	r2,-32(fp)
8113af6c:	e0bffc15 	stw	r2,-16(fp)
8113af70:	e0bffc17 	ldw	r2,-16(fp)
8113af74:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8113af78:	e0bff703 	ldbu	r2,-36(fp)
8113af7c:	10800058 	cmpnei	r2,r2,1
8113af80:	1000011e 	bne	r2,zero,8113af88 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8113af84:	11345bc0 	call	811345bc <OS_Sched>
    }
    return (OS_ERR_NONE);
8113af88:	0005883a 	mov	r2,zero
}
8113af8c:	e037883a 	mov	sp,fp
8113af90:	dfc00117 	ldw	ra,4(sp)
8113af94:	df000017 	ldw	fp,0(sp)
8113af98:	dec00204 	addi	sp,sp,8
8113af9c:	f800283a 	ret

8113afa0 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8113afa0:	defff604 	addi	sp,sp,-40
8113afa4:	de00012e 	bgeu	sp,et,8113afac <OSTaskQuery+0xc>
8113afa8:	003b68fa 	trap	3
8113afac:	dfc00915 	stw	ra,36(sp)
8113afb0:	df000815 	stw	fp,32(sp)
8113afb4:	df000804 	addi	fp,sp,32
8113afb8:	2005883a 	mov	r2,r4
8113afbc:	e17fff15 	stw	r5,-4(fp)
8113afc0:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113afc4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8113afc8:	e0bffe03 	ldbu	r2,-8(fp)
8113afcc:	10800a70 	cmpltui	r2,r2,41
8113afd0:	1000051e 	bne	r2,zero,8113afe8 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
8113afd4:	e0bffe03 	ldbu	r2,-8(fp)
8113afd8:	10803fe0 	cmpeqi	r2,r2,255
8113afdc:	1000021e 	bne	r2,zero,8113afe8 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8113afe0:	00800a84 	movi	r2,42
8113afe4:	00003406 	br	8113b0b8 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8113afe8:	e0bfff17 	ldw	r2,-4(fp)
8113afec:	1000021e 	bne	r2,zero,8113aff8 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8113aff0:	00800244 	movi	r2,9
8113aff4:	00003006 	br	8113b0b8 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aff8:	0005303a 	rdctl	r2,status
8113affc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b000:	e0fffd17 	ldw	r3,-12(fp)
8113b004:	00bfff84 	movi	r2,-2
8113b008:	1884703a 	and	r2,r3,r2
8113b00c:	1001703a 	wrctl	status,r2
  
  return context;
8113b010:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b014:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8113b018:	e0bffe03 	ldbu	r2,-8(fp)
8113b01c:	10803fd8 	cmpnei	r2,r2,255
8113b020:	1000031e 	bne	r2,zero,8113b030 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8113b024:	d0a09c17 	ldw	r2,-32144(gp)
8113b028:	10800c83 	ldbu	r2,50(r2)
8113b02c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113b030:	e0fffe03 	ldbu	r3,-8(fp)
8113b034:	00a045b4 	movhi	r2,33046
8113b038:	10979804 	addi	r2,r2,24160
8113b03c:	18c7883a 	add	r3,r3,r3
8113b040:	18c7883a 	add	r3,r3,r3
8113b044:	10c5883a 	add	r2,r2,r3
8113b048:	10800017 	ldw	r2,0(r2)
8113b04c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
8113b050:	e0bffa17 	ldw	r2,-24(fp)
8113b054:	1000061e 	bne	r2,zero,8113b070 <OSTaskQuery+0xd0>
8113b058:	e0bff817 	ldw	r2,-32(fp)
8113b05c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b060:	e0bff917 	ldw	r2,-28(fp)
8113b064:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8113b068:	00800a44 	movi	r2,41
8113b06c:	00001206 	br	8113b0b8 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
8113b070:	e0bffa17 	ldw	r2,-24(fp)
8113b074:	10800058 	cmpnei	r2,r2,1
8113b078:	1000061e 	bne	r2,zero,8113b094 <OSTaskQuery+0xf4>
8113b07c:	e0bff817 	ldw	r2,-32(fp)
8113b080:	e0bffb15 	stw	r2,-20(fp)
8113b084:	e0bffb17 	ldw	r2,-20(fp)
8113b088:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113b08c:	008010c4 	movi	r2,67
8113b090:	00000906 	br	8113b0b8 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8113b094:	01801b04 	movi	r6,108
8113b098:	e17ffa17 	ldw	r5,-24(fp)
8113b09c:	e13fff17 	ldw	r4,-4(fp)
8113b0a0:	113454c0 	call	8113454c <OS_MemCopy>
8113b0a4:	e0bff817 	ldw	r2,-32(fp)
8113b0a8:	e0bffc15 	stw	r2,-16(fp)
8113b0ac:	e0bffc17 	ldw	r2,-16(fp)
8113b0b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113b0b4:	0005883a 	mov	r2,zero
}
8113b0b8:	e037883a 	mov	sp,fp
8113b0bc:	dfc00117 	ldw	ra,4(sp)
8113b0c0:	df000017 	ldw	fp,0(sp)
8113b0c4:	dec00204 	addi	sp,sp,8
8113b0c8:	f800283a 	ret

8113b0cc <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113b0cc:	defffc04 	addi	sp,sp,-16
8113b0d0:	de00012e 	bgeu	sp,et,8113b0d8 <OS_TaskStkClr+0xc>
8113b0d4:	003b68fa 	trap	3
8113b0d8:	df000315 	stw	fp,12(sp)
8113b0dc:	df000304 	addi	fp,sp,12
8113b0e0:	e13ffd15 	stw	r4,-12(fp)
8113b0e4:	e17ffe15 	stw	r5,-8(fp)
8113b0e8:	3005883a 	mov	r2,r6
8113b0ec:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8113b0f0:	e0bfff0b 	ldhu	r2,-4(fp)
8113b0f4:	1080004c 	andi	r2,r2,1
8113b0f8:	10000d26 	beq	r2,zero,8113b130 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8113b0fc:	e0bfff0b 	ldhu	r2,-4(fp)
8113b100:	1080008c 	andi	r2,r2,2
8113b104:	10000a26 	beq	r2,zero,8113b130 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113b108:	00000706 	br	8113b128 <OS_TaskStkClr+0x5c>
                size--;
8113b10c:	e0bffe17 	ldw	r2,-8(fp)
8113b110:	10bfffc4 	addi	r2,r2,-1
8113b114:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8113b118:	e0bffd17 	ldw	r2,-12(fp)
8113b11c:	10c00104 	addi	r3,r2,4
8113b120:	e0fffd15 	stw	r3,-12(fp)
8113b124:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113b128:	e0bffe17 	ldw	r2,-8(fp)
8113b12c:	103ff71e 	bne	r2,zero,8113b10c <__reset+0xfb11b10c>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
8113b130:	0001883a 	nop
8113b134:	e037883a 	mov	sp,fp
8113b138:	df000017 	ldw	fp,0(sp)
8113b13c:	dec00104 	addi	sp,sp,4
8113b140:	f800283a 	ret

8113b144 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8113b144:	defff904 	addi	sp,sp,-28
8113b148:	de00012e 	bgeu	sp,et,8113b150 <OSTimeDly+0xc>
8113b14c:	003b68fa 	trap	3
8113b150:	dfc00615 	stw	ra,24(sp)
8113b154:	df000515 	stw	fp,20(sp)
8113b158:	df000504 	addi	fp,sp,20
8113b15c:	2005883a 	mov	r2,r4
8113b160:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b164:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113b168:	d0a09b03 	ldbu	r2,-32148(gp)
8113b16c:	10803fcc 	andi	r2,r2,255
8113b170:	1000311e 	bne	r2,zero,8113b238 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8113b174:	e0bfff0b 	ldhu	r2,-4(fp)
8113b178:	10003026 	beq	r2,zero,8113b23c <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b17c:	0005303a 	rdctl	r2,status
8113b180:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b184:	e0fffe17 	ldw	r3,-8(fp)
8113b188:	00bfff84 	movi	r2,-2
8113b18c:	1884703a 	and	r2,r3,r2
8113b190:	1001703a 	wrctl	status,r2
  
  return context;
8113b194:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8113b198:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113b19c:	d0a09c17 	ldw	r2,-32144(gp)
8113b1a0:	10800d03 	ldbu	r2,52(r2)
8113b1a4:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113b1a8:	e0fffd03 	ldbu	r3,-12(fp)
8113b1ac:	e13ffd03 	ldbu	r4,-12(fp)
8113b1b0:	d0a09844 	addi	r2,gp,-32159
8113b1b4:	2085883a 	add	r2,r4,r2
8113b1b8:	10800003 	ldbu	r2,0(r2)
8113b1bc:	1009883a 	mov	r4,r2
8113b1c0:	d0a09c17 	ldw	r2,-32144(gp)
8113b1c4:	10800d43 	ldbu	r2,53(r2)
8113b1c8:	0084303a 	nor	r2,zero,r2
8113b1cc:	2084703a 	and	r2,r4,r2
8113b1d0:	1009883a 	mov	r4,r2
8113b1d4:	d0a09844 	addi	r2,gp,-32159
8113b1d8:	1885883a 	add	r2,r3,r2
8113b1dc:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
8113b1e0:	e0fffd03 	ldbu	r3,-12(fp)
8113b1e4:	d0a09844 	addi	r2,gp,-32159
8113b1e8:	1885883a 	add	r2,r3,r2
8113b1ec:	10800003 	ldbu	r2,0(r2)
8113b1f0:	10803fcc 	andi	r2,r2,255
8113b1f4:	1000071e 	bne	r2,zero,8113b214 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113b1f8:	d0a09c17 	ldw	r2,-32144(gp)
8113b1fc:	10800d83 	ldbu	r2,54(r2)
8113b200:	0084303a 	nor	r2,zero,r2
8113b204:	1007883a 	mov	r3,r2
8113b208:	d0a09803 	ldbu	r2,-32160(gp)
8113b20c:	1884703a 	and	r2,r3,r2
8113b210:	d0a09805 	stb	r2,-32160(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8113b214:	d0a09c17 	ldw	r2,-32144(gp)
8113b218:	e0ffff0b 	ldhu	r3,-4(fp)
8113b21c:	10c00b8d 	sth	r3,46(r2)
8113b220:	e0bffb17 	ldw	r2,-20(fp)
8113b224:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b228:	e0bffc17 	ldw	r2,-16(fp)
8113b22c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
8113b230:	11345bc0 	call	811345bc <OS_Sched>
8113b234:	00000106 	br	8113b23c <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8113b238:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
8113b23c:	e037883a 	mov	sp,fp
8113b240:	dfc00117 	ldw	ra,4(sp)
8113b244:	df000017 	ldw	fp,0(sp)
8113b248:	dec00204 	addi	sp,sp,8
8113b24c:	f800283a 	ret

8113b250 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
8113b250:	defff804 	addi	sp,sp,-32
8113b254:	de00012e 	bgeu	sp,et,8113b25c <OSTimeDlyHMSM+0xc>
8113b258:	003b68fa 	trap	3
8113b25c:	dfc00715 	stw	ra,28(sp)
8113b260:	df000615 	stw	fp,24(sp)
8113b264:	df000604 	addi	fp,sp,24
8113b268:	2015883a 	mov	r10,r4
8113b26c:	2809883a 	mov	r4,r5
8113b270:	3007883a 	mov	r3,r6
8113b274:	3805883a 	mov	r2,r7
8113b278:	e2bffc05 	stb	r10,-16(fp)
8113b27c:	e13ffd05 	stb	r4,-12(fp)
8113b280:	e0fffe05 	stb	r3,-8(fp)
8113b284:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113b288:	d0a09b03 	ldbu	r2,-32148(gp)
8113b28c:	10803fcc 	andi	r2,r2,255
8113b290:	10000226 	beq	r2,zero,8113b29c <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8113b294:	00801544 	movi	r2,85
8113b298:	00004106 	br	8113b3a0 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8113b29c:	e0bffc03 	ldbu	r2,-16(fp)
8113b2a0:	1000081e 	bne	r2,zero,8113b2c4 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
8113b2a4:	e0bffd03 	ldbu	r2,-12(fp)
8113b2a8:	1000061e 	bne	r2,zero,8113b2c4 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8113b2ac:	e0bffe03 	ldbu	r2,-8(fp)
8113b2b0:	1000041e 	bne	r2,zero,8113b2c4 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
8113b2b4:	e0bfff0b 	ldhu	r2,-4(fp)
8113b2b8:	1000021e 	bne	r2,zero,8113b2c4 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8113b2bc:	00801504 	movi	r2,84
8113b2c0:	00003706 	br	8113b3a0 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
8113b2c4:	e0bffd03 	ldbu	r2,-12(fp)
8113b2c8:	10800f30 	cmpltui	r2,r2,60
8113b2cc:	1000021e 	bne	r2,zero,8113b2d8 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
8113b2d0:	00801444 	movi	r2,81
8113b2d4:	00003206 	br	8113b3a0 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8113b2d8:	e0bffe03 	ldbu	r2,-8(fp)
8113b2dc:	10800f30 	cmpltui	r2,r2,60
8113b2e0:	1000021e 	bne	r2,zero,8113b2ec <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
8113b2e4:	00801484 	movi	r2,82
8113b2e8:	00002d06 	br	8113b3a0 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
8113b2ec:	e0bfff0b 	ldhu	r2,-4(fp)
8113b2f0:	1080fa30 	cmpltui	r2,r2,1000
8113b2f4:	1000021e 	bne	r2,zero,8113b300 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8113b2f8:	008014c4 	movi	r2,83
8113b2fc:	00002806 	br	8113b3a0 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113b300:	e0bffc03 	ldbu	r2,-16(fp)
8113b304:	10c38424 	muli	r3,r2,3600
8113b308:	e0bffd03 	ldbu	r2,-12(fp)
8113b30c:	10800f24 	muli	r2,r2,60
8113b310:	1887883a 	add	r3,r3,r2
8113b314:	e0bffe03 	ldbu	r2,-8(fp)
8113b318:	1885883a 	add	r2,r3,r2
8113b31c:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
8113b320:	e0bfff0b 	ldhu	r2,-4(fp)
8113b324:	10c0fa24 	muli	r3,r2,1000
8113b328:	008418b4 	movhi	r2,4194
8113b32c:	109374c4 	addi	r2,r2,19923
8113b330:	188a383a 	mulxuu	r5,r3,r2
8113b334:	1885383a 	mul	r2,r3,r2
8113b338:	1011883a 	mov	r8,r2
8113b33c:	2813883a 	mov	r9,r5
8113b340:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113b344:	2085883a 	add	r2,r4,r2
8113b348:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8113b34c:	e0bffb17 	ldw	r2,-20(fp)
8113b350:	1004d43a 	srli	r2,r2,16
8113b354:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8113b358:	e0bffb17 	ldw	r2,-20(fp)
8113b35c:	10bfffcc 	andi	r2,r2,65535
8113b360:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8113b364:	e0bffb17 	ldw	r2,-20(fp)
8113b368:	10bfffcc 	andi	r2,r2,65535
8113b36c:	1009883a 	mov	r4,r2
8113b370:	113b1440 	call	8113b144 <OSTimeDly>
    while (loops > 0) {
8113b374:	00000706 	br	8113b394 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8113b378:	01200014 	movui	r4,32768
8113b37c:	113b1440 	call	8113b144 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
8113b380:	01200014 	movui	r4,32768
8113b384:	113b1440 	call	8113b144 <OSTimeDly>
        loops--;
8113b388:	e0bffa0b 	ldhu	r2,-24(fp)
8113b38c:	10bfffc4 	addi	r2,r2,-1
8113b390:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8113b394:	e0bffa0b 	ldhu	r2,-24(fp)
8113b398:	103ff71e 	bne	r2,zero,8113b378 <__reset+0xfb11b378>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8113b39c:	0005883a 	mov	r2,zero
}
8113b3a0:	e037883a 	mov	sp,fp
8113b3a4:	dfc00117 	ldw	ra,4(sp)
8113b3a8:	df000017 	ldw	fp,0(sp)
8113b3ac:	dec00204 	addi	sp,sp,8
8113b3b0:	f800283a 	ret

8113b3b4 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
8113b3b4:	defff504 	addi	sp,sp,-44
8113b3b8:	de00012e 	bgeu	sp,et,8113b3c0 <OSTimeDlyResume+0xc>
8113b3bc:	003b68fa 	trap	3
8113b3c0:	dfc00a15 	stw	ra,40(sp)
8113b3c4:	df000915 	stw	fp,36(sp)
8113b3c8:	df000904 	addi	fp,sp,36
8113b3cc:	2005883a 	mov	r2,r4
8113b3d0:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113b3d4:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8113b3d8:	e0bfff03 	ldbu	r2,-4(fp)
8113b3dc:	10800a30 	cmpltui	r2,r2,40
8113b3e0:	1000021e 	bne	r2,zero,8113b3ec <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113b3e4:	00800a84 	movi	r2,42
8113b3e8:	00006406 	br	8113b57c <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b3ec:	0005303a 	rdctl	r2,status
8113b3f0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b3f4:	e0fffe17 	ldw	r3,-8(fp)
8113b3f8:	00bfff84 	movi	r2,-2
8113b3fc:	1884703a 	and	r2,r3,r2
8113b400:	1001703a 	wrctl	status,r2
  
  return context;
8113b404:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113b408:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
8113b40c:	e0ffff03 	ldbu	r3,-4(fp)
8113b410:	00a045b4 	movhi	r2,33046
8113b414:	10979804 	addi	r2,r2,24160
8113b418:	18c7883a 	add	r3,r3,r3
8113b41c:	18c7883a 	add	r3,r3,r3
8113b420:	10c5883a 	add	r2,r2,r3
8113b424:	10800017 	ldw	r2,0(r2)
8113b428:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
8113b42c:	e0bff917 	ldw	r2,-28(fp)
8113b430:	1000061e 	bne	r2,zero,8113b44c <OSTimeDlyResume+0x98>
8113b434:	e0bff717 	ldw	r2,-36(fp)
8113b438:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b43c:	e0bff817 	ldw	r2,-32(fp)
8113b440:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113b444:	008010c4 	movi	r2,67
8113b448:	00004c06 	br	8113b57c <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113b44c:	e0bff917 	ldw	r2,-28(fp)
8113b450:	10800058 	cmpnei	r2,r2,1
8113b454:	1000061e 	bne	r2,zero,8113b470 <OSTimeDlyResume+0xbc>
8113b458:	e0bff717 	ldw	r2,-36(fp)
8113b45c:	e0bffa15 	stw	r2,-24(fp)
8113b460:	e0bffa17 	ldw	r2,-24(fp)
8113b464:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113b468:	008010c4 	movi	r2,67
8113b46c:	00004306 	br	8113b57c <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
8113b470:	e0bff917 	ldw	r2,-28(fp)
8113b474:	10800b8b 	ldhu	r2,46(r2)
8113b478:	10bfffcc 	andi	r2,r2,65535
8113b47c:	1000061e 	bne	r2,zero,8113b498 <OSTimeDlyResume+0xe4>
8113b480:	e0bff717 	ldw	r2,-36(fp)
8113b484:	e0bffb15 	stw	r2,-20(fp)
8113b488:	e0bffb17 	ldw	r2,-20(fp)
8113b48c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8113b490:	00801404 	movi	r2,80
8113b494:	00003906 	br	8113b57c <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8113b498:	e0bff917 	ldw	r2,-28(fp)
8113b49c:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113b4a0:	e0bff917 	ldw	r2,-28(fp)
8113b4a4:	10800c03 	ldbu	r2,48(r2)
8113b4a8:	10803fcc 	andi	r2,r2,255
8113b4ac:	10800dcc 	andi	r2,r2,55
8113b4b0:	10000b26 	beq	r2,zero,8113b4e0 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
8113b4b4:	e0bff917 	ldw	r2,-28(fp)
8113b4b8:	10c00c03 	ldbu	r3,48(r2)
8113b4bc:	00bff204 	movi	r2,-56
8113b4c0:	1884703a 	and	r2,r3,r2
8113b4c4:	1007883a 	mov	r3,r2
8113b4c8:	e0bff917 	ldw	r2,-28(fp)
8113b4cc:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8113b4d0:	e0bff917 	ldw	r2,-28(fp)
8113b4d4:	00c00044 	movi	r3,1
8113b4d8:	10c00c45 	stb	r3,49(r2)
8113b4dc:	00000206 	br	8113b4e8 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8113b4e0:	e0bff917 	ldw	r2,-28(fp)
8113b4e4:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8113b4e8:	e0bff917 	ldw	r2,-28(fp)
8113b4ec:	10800c03 	ldbu	r2,48(r2)
8113b4f0:	10803fcc 	andi	r2,r2,255
8113b4f4:	1080020c 	andi	r2,r2,8
8113b4f8:	10001b1e 	bne	r2,zero,8113b568 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
8113b4fc:	e0bff917 	ldw	r2,-28(fp)
8113b500:	10c00d83 	ldbu	r3,54(r2)
8113b504:	d0a09803 	ldbu	r2,-32160(gp)
8113b508:	1884b03a 	or	r2,r3,r2
8113b50c:	d0a09805 	stb	r2,-32160(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113b510:	e0bff917 	ldw	r2,-28(fp)
8113b514:	10800d03 	ldbu	r2,52(r2)
8113b518:	10c03fcc 	andi	r3,r2,255
8113b51c:	e0bff917 	ldw	r2,-28(fp)
8113b520:	10800d03 	ldbu	r2,52(r2)
8113b524:	11003fcc 	andi	r4,r2,255
8113b528:	d0a09844 	addi	r2,gp,-32159
8113b52c:	2085883a 	add	r2,r4,r2
8113b530:	11000003 	ldbu	r4,0(r2)
8113b534:	e0bff917 	ldw	r2,-28(fp)
8113b538:	10800d43 	ldbu	r2,53(r2)
8113b53c:	2084b03a 	or	r2,r4,r2
8113b540:	1009883a 	mov	r4,r2
8113b544:	d0a09844 	addi	r2,gp,-32159
8113b548:	1885883a 	add	r2,r3,r2
8113b54c:	11000005 	stb	r4,0(r2)
8113b550:	e0bff717 	ldw	r2,-36(fp)
8113b554:	e0bffc15 	stw	r2,-16(fp)
8113b558:	e0bffc17 	ldw	r2,-16(fp)
8113b55c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
8113b560:	11345bc0 	call	811345bc <OS_Sched>
8113b564:	00000406 	br	8113b578 <OSTimeDlyResume+0x1c4>
8113b568:	e0bff717 	ldw	r2,-36(fp)
8113b56c:	e0bffd15 	stw	r2,-12(fp)
8113b570:	e0bffd17 	ldw	r2,-12(fp)
8113b574:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8113b578:	0005883a 	mov	r2,zero
}
8113b57c:	e037883a 	mov	sp,fp
8113b580:	dfc00117 	ldw	ra,4(sp)
8113b584:	df000017 	ldw	fp,0(sp)
8113b588:	dec00204 	addi	sp,sp,8
8113b58c:	f800283a 	ret

8113b590 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8113b590:	defffb04 	addi	sp,sp,-20
8113b594:	de00012e 	bgeu	sp,et,8113b59c <OSTimeGet+0xc>
8113b598:	003b68fa 	trap	3
8113b59c:	df000415 	stw	fp,16(sp)
8113b5a0:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b5a4:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b5a8:	0005303a 	rdctl	r2,status
8113b5ac:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b5b0:	e0fffe17 	ldw	r3,-8(fp)
8113b5b4:	00bfff84 	movi	r2,-2
8113b5b8:	1884703a 	and	r2,r3,r2
8113b5bc:	1001703a 	wrctl	status,r2
  
  return context;
8113b5c0:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113b5c4:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
8113b5c8:	d0a09e17 	ldw	r2,-32136(gp)
8113b5cc:	e0bffd15 	stw	r2,-12(fp)
8113b5d0:	e0bffc17 	ldw	r2,-16(fp)
8113b5d4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b5d8:	e0bfff17 	ldw	r2,-4(fp)
8113b5dc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8113b5e0:	e0bffd17 	ldw	r2,-12(fp)
}
8113b5e4:	e037883a 	mov	sp,fp
8113b5e8:	df000017 	ldw	fp,0(sp)
8113b5ec:	dec00104 	addi	sp,sp,4
8113b5f0:	f800283a 	ret

8113b5f4 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
8113b5f4:	defffb04 	addi	sp,sp,-20
8113b5f8:	de00012e 	bgeu	sp,et,8113b600 <OSTimeSet+0xc>
8113b5fc:	003b68fa 	trap	3
8113b600:	df000415 	stw	fp,16(sp)
8113b604:	df000404 	addi	fp,sp,16
8113b608:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b60c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b610:	0005303a 	rdctl	r2,status
8113b614:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b618:	e0fffd17 	ldw	r3,-12(fp)
8113b61c:	00bfff84 	movi	r2,-2
8113b620:	1884703a 	and	r2,r3,r2
8113b624:	1001703a 	wrctl	status,r2
  
  return context;
8113b628:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
8113b62c:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
8113b630:	e0bfff17 	ldw	r2,-4(fp)
8113b634:	d0a09e15 	stw	r2,-32136(gp)
8113b638:	e0bffc17 	ldw	r2,-16(fp)
8113b63c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b640:	e0bffe17 	ldw	r2,-8(fp)
8113b644:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113b648:	0001883a 	nop
8113b64c:	e037883a 	mov	sp,fp
8113b650:	df000017 	ldw	fp,0(sp)
8113b654:	dec00104 	addi	sp,sp,4
8113b658:	f800283a 	ret

8113b65c <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
8113b65c:	defff804 	addi	sp,sp,-32
8113b660:	de00012e 	bgeu	sp,et,8113b668 <OSTmrCreate+0xc>
8113b664:	003b68fa 	trap	3
8113b668:	dfc00715 	stw	ra,28(sp)
8113b66c:	df000615 	stw	fp,24(sp)
8113b670:	df000604 	addi	fp,sp,24
8113b674:	e13ffc15 	stw	r4,-16(fp)
8113b678:	e17ffd15 	stw	r5,-12(fp)
8113b67c:	3005883a 	mov	r2,r6
8113b680:	e1ffff15 	stw	r7,-4(fp)
8113b684:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113b688:	e0800417 	ldw	r2,16(fp)
8113b68c:	1000021e 	bne	r2,zero,8113b698 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
8113b690:	0005883a 	mov	r2,zero
8113b694:	00005d06 	br	8113b80c <OSTmrCreate+0x1b0>
    }
    switch (opt) {
8113b698:	e0bffe03 	ldbu	r2,-8(fp)
8113b69c:	10c00060 	cmpeqi	r3,r2,1
8113b6a0:	1800091e 	bne	r3,zero,8113b6c8 <OSTmrCreate+0x6c>
8113b6a4:	108000a0 	cmpeqi	r2,r2,2
8113b6a8:	10000e26 	beq	r2,zero,8113b6e4 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
8113b6ac:	e0bffd17 	ldw	r2,-12(fp)
8113b6b0:	1000111e 	bne	r2,zero,8113b6f8 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
8113b6b4:	e0800417 	ldw	r2,16(fp)
8113b6b8:	00ffe0c4 	movi	r3,-125
8113b6bc:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113b6c0:	0005883a 	mov	r2,zero
8113b6c4:	00005106 	br	8113b80c <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
8113b6c8:	e0bffc17 	ldw	r2,-16(fp)
8113b6cc:	10000c1e 	bne	r2,zero,8113b700 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
8113b6d0:	e0800417 	ldw	r2,16(fp)
8113b6d4:	00ffe084 	movi	r3,-126
8113b6d8:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113b6dc:	0005883a 	mov	r2,zero
8113b6e0:	00004a06 	br	8113b80c <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
8113b6e4:	e0800417 	ldw	r2,16(fp)
8113b6e8:	00ffe104 	movi	r3,-124
8113b6ec:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8113b6f0:	0005883a 	mov	r2,zero
8113b6f4:	00004506 	br	8113b80c <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
8113b6f8:	0001883a 	nop
8113b6fc:	00000106 	br	8113b704 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8113b700:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113b704:	d0a09b03 	ldbu	r2,-32148(gp)
8113b708:	10803fcc 	andi	r2,r2,255
8113b70c:	10000526 	beq	r2,zero,8113b724 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8113b710:	e0800417 	ldw	r2,16(fp)
8113b714:	00ffe2c4 	movi	r3,-117
8113b718:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113b71c:	0005883a 	mov	r2,zero
8113b720:	00003a06 	br	8113b80c <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
8113b724:	113c6140 	call	8113c614 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
8113b728:	113c0b40 	call	8113c0b4 <OSTmr_Alloc>
8113b72c:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
8113b730:	e0bffa17 	ldw	r2,-24(fp)
8113b734:	1000061e 	bne	r2,zero,8113b750 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
8113b738:	113c6580 	call	8113c658 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
8113b73c:	e0800417 	ldw	r2,16(fp)
8113b740:	00ffe184 	movi	r3,-122
8113b744:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113b748:	0005883a 	mov	r2,zero
8113b74c:	00002f06 	br	8113b80c <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
8113b750:	e0bffa17 	ldw	r2,-24(fp)
8113b754:	00c00044 	movi	r3,1
8113b758:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
8113b75c:	e0bffa17 	ldw	r2,-24(fp)
8113b760:	e0fffc17 	ldw	r3,-16(fp)
8113b764:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
8113b768:	e0bffa17 	ldw	r2,-24(fp)
8113b76c:	e0fffd17 	ldw	r3,-12(fp)
8113b770:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
8113b774:	e0bffa17 	ldw	r2,-24(fp)
8113b778:	e0fffe03 	ldbu	r3,-8(fp)
8113b77c:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8113b780:	e0bffa17 	ldw	r2,-24(fp)
8113b784:	e0ffff17 	ldw	r3,-4(fp)
8113b788:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
8113b78c:	e0bffa17 	ldw	r2,-24(fp)
8113b790:	e0c00217 	ldw	r3,8(fp)
8113b794:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
8113b798:	e0800317 	ldw	r2,12(fp)
8113b79c:	10001726 	beq	r2,zero,8113b7fc <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8113b7a0:	e1000317 	ldw	r4,12(fp)
8113b7a4:	113478c0 	call	8113478c <OS_StrLen>
8113b7a8:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
8113b7ac:	e0bffb03 	ldbu	r2,-20(fp)
8113b7b0:	10800428 	cmpgeui	r2,r2,16
8113b7b4:	1000061e 	bne	r2,zero,8113b7d0 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
8113b7b8:	e0bffa17 	ldw	r2,-24(fp)
8113b7bc:	10800804 	addi	r2,r2,32
8113b7c0:	e1400317 	ldw	r5,12(fp)
8113b7c4:	1009883a 	mov	r4,r2
8113b7c8:	11347100 	call	81134710 <OS_StrCopy>
8113b7cc:	00000b06 	br	8113b7fc <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8113b7d0:	e0bffa17 	ldw	r2,-24(fp)
8113b7d4:	00c008c4 	movi	r3,35
8113b7d8:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
8113b7dc:	e0bffa17 	ldw	r2,-24(fp)
8113b7e0:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
8113b7e4:	e0800417 	ldw	r2,16(fp)
8113b7e8:	00ffe304 	movi	r3,-116
8113b7ec:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8113b7f0:	113c6580 	call	8113c658 <OSTmr_Unlock>
            return (ptmr);
8113b7f4:	e0bffa17 	ldw	r2,-24(fp)
8113b7f8:	00000406 	br	8113b80c <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
8113b7fc:	113c6580 	call	8113c658 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8113b800:	e0800417 	ldw	r2,16(fp)
8113b804:	10000005 	stb	zero,0(r2)
    return (ptmr);
8113b808:	e0bffa17 	ldw	r2,-24(fp)
}
8113b80c:	e037883a 	mov	sp,fp
8113b810:	dfc00117 	ldw	ra,4(sp)
8113b814:	df000017 	ldw	fp,0(sp)
8113b818:	dec00204 	addi	sp,sp,8
8113b81c:	f800283a 	ret

8113b820 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8113b820:	defffc04 	addi	sp,sp,-16
8113b824:	de00012e 	bgeu	sp,et,8113b82c <OSTmrDel+0xc>
8113b828:	003b68fa 	trap	3
8113b82c:	dfc00315 	stw	ra,12(sp)
8113b830:	df000215 	stw	fp,8(sp)
8113b834:	df000204 	addi	fp,sp,8
8113b838:	e13ffe15 	stw	r4,-8(fp)
8113b83c:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113b840:	e0bfff17 	ldw	r2,-4(fp)
8113b844:	1000021e 	bne	r2,zero,8113b850 <OSTmrDel+0x30>
        return (OS_FALSE);
8113b848:	0005883a 	mov	r2,zero
8113b84c:	00003f06 	br	8113b94c <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113b850:	e0bffe17 	ldw	r2,-8(fp)
8113b854:	1000051e 	bne	r2,zero,8113b86c <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113b858:	e0bfff17 	ldw	r2,-4(fp)
8113b85c:	00ffe284 	movi	r3,-118
8113b860:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b864:	0005883a 	mov	r2,zero
8113b868:	00003806 	br	8113b94c <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113b86c:	e0bffe17 	ldw	r2,-8(fp)
8113b870:	10800003 	ldbu	r2,0(r2)
8113b874:	10803fcc 	andi	r2,r2,255
8113b878:	10801920 	cmpeqi	r2,r2,100
8113b87c:	1000051e 	bne	r2,zero,8113b894 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113b880:	e0bfff17 	ldw	r2,-4(fp)
8113b884:	00ffe244 	movi	r3,-119
8113b888:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b88c:	0005883a 	mov	r2,zero
8113b890:	00002e06 	br	8113b94c <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113b894:	d0a09b03 	ldbu	r2,-32148(gp)
8113b898:	10803fcc 	andi	r2,r2,255
8113b89c:	10000526 	beq	r2,zero,8113b8b4 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113b8a0:	e0bfff17 	ldw	r2,-4(fp)
8113b8a4:	00ffe2c4 	movi	r3,-117
8113b8a8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b8ac:	0005883a 	mov	r2,zero
8113b8b0:	00002606 	br	8113b94c <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
8113b8b4:	113c6140 	call	8113c614 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113b8b8:	e0bffe17 	ldw	r2,-8(fp)
8113b8bc:	10800c43 	ldbu	r2,49(r2)
8113b8c0:	10803fcc 	andi	r2,r2,255
8113b8c4:	10c000c8 	cmpgei	r3,r2,3
8113b8c8:	1800031e 	bne	r3,zero,8113b8d8 <OSTmrDel+0xb8>
8113b8cc:	00800d16 	blt	zero,r2,8113b904 <OSTmrDel+0xe4>
8113b8d0:	10001326 	beq	r2,zero,8113b920 <OSTmrDel+0x100>
8113b8d4:	00001806 	br	8113b938 <OSTmrDel+0x118>
8113b8d8:	108000e0 	cmpeqi	r2,r2,3
8113b8dc:	10001626 	beq	r2,zero,8113b938 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8113b8e0:	e13ffe17 	ldw	r4,-8(fp)
8113b8e4:	113c5180 	call	8113c518 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113b8e8:	e13ffe17 	ldw	r4,-8(fp)
8113b8ec:	113c1280 	call	8113c128 <OSTmr_Free>
             OSTmr_Unlock();
8113b8f0:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113b8f4:	e0bfff17 	ldw	r2,-4(fp)
8113b8f8:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113b8fc:	00800044 	movi	r2,1
8113b900:	00001206 	br	8113b94c <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113b904:	e13ffe17 	ldw	r4,-8(fp)
8113b908:	113c1280 	call	8113c128 <OSTmr_Free>
             OSTmr_Unlock();
8113b90c:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113b910:	e0bfff17 	ldw	r2,-4(fp)
8113b914:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113b918:	00800044 	movi	r2,1
8113b91c:	00000b06 	br	8113b94c <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8113b920:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113b924:	e0bfff17 	ldw	r2,-4(fp)
8113b928:	00ffe1c4 	movi	r3,-121
8113b92c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113b930:	0005883a 	mov	r2,zero
8113b934:	00000506 	br	8113b94c <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8113b938:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113b93c:	e0bfff17 	ldw	r2,-4(fp)
8113b940:	00ffe344 	movi	r3,-115
8113b944:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113b948:	0005883a 	mov	r2,zero
    }
}
8113b94c:	e037883a 	mov	sp,fp
8113b950:	dfc00117 	ldw	ra,4(sp)
8113b954:	df000017 	ldw	fp,0(sp)
8113b958:	dec00204 	addi	sp,sp,8
8113b95c:	f800283a 	ret

8113b960 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
8113b960:	defffa04 	addi	sp,sp,-24
8113b964:	de00012e 	bgeu	sp,et,8113b96c <OSTmrNameGet+0xc>
8113b968:	003b68fa 	trap	3
8113b96c:	dfc00515 	stw	ra,20(sp)
8113b970:	df000415 	stw	fp,16(sp)
8113b974:	df000404 	addi	fp,sp,16
8113b978:	e13ffd15 	stw	r4,-12(fp)
8113b97c:	e17ffe15 	stw	r5,-8(fp)
8113b980:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113b984:	e0bfff17 	ldw	r2,-4(fp)
8113b988:	1000021e 	bne	r2,zero,8113b994 <OSTmrNameGet+0x34>
        return (0);
8113b98c:	0005883a 	mov	r2,zero
8113b990:	00003e06 	br	8113ba8c <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
8113b994:	e0bffe17 	ldw	r2,-8(fp)
8113b998:	1000051e 	bne	r2,zero,8113b9b0 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
8113b99c:	e0bfff17 	ldw	r2,-4(fp)
8113b9a0:	00ffe204 	movi	r3,-120
8113b9a4:	10c00005 	stb	r3,0(r2)
        return (0);
8113b9a8:	0005883a 	mov	r2,zero
8113b9ac:	00003706 	br	8113ba8c <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113b9b0:	e0bffd17 	ldw	r2,-12(fp)
8113b9b4:	1000051e 	bne	r2,zero,8113b9cc <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
8113b9b8:	e0bfff17 	ldw	r2,-4(fp)
8113b9bc:	00ffe284 	movi	r3,-118
8113b9c0:	10c00005 	stb	r3,0(r2)
        return (0);
8113b9c4:	0005883a 	mov	r2,zero
8113b9c8:	00003006 	br	8113ba8c <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113b9cc:	e0bffd17 	ldw	r2,-12(fp)
8113b9d0:	10800003 	ldbu	r2,0(r2)
8113b9d4:	10803fcc 	andi	r2,r2,255
8113b9d8:	10801920 	cmpeqi	r2,r2,100
8113b9dc:	1000051e 	bne	r2,zero,8113b9f4 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113b9e0:	e0bfff17 	ldw	r2,-4(fp)
8113b9e4:	00ffe244 	movi	r3,-119
8113b9e8:	10c00005 	stb	r3,0(r2)
        return (0);
8113b9ec:	0005883a 	mov	r2,zero
8113b9f0:	00002606 	br	8113ba8c <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113b9f4:	d0a09b03 	ldbu	r2,-32148(gp)
8113b9f8:	10803fcc 	andi	r2,r2,255
8113b9fc:	10000526 	beq	r2,zero,8113ba14 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8113ba00:	e0bfff17 	ldw	r2,-4(fp)
8113ba04:	00c00444 	movi	r3,17
8113ba08:	10c00005 	stb	r3,0(r2)
        return (0);
8113ba0c:	0005883a 	mov	r2,zero
8113ba10:	00001e06 	br	8113ba8c <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
8113ba14:	113c6140 	call	8113c614 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113ba18:	e0bffd17 	ldw	r2,-12(fp)
8113ba1c:	10800c43 	ldbu	r2,49(r2)
8113ba20:	10803fcc 	andi	r2,r2,255
8113ba24:	10000e26 	beq	r2,zero,8113ba60 <OSTmrNameGet+0x100>
8113ba28:	10001316 	blt	r2,zero,8113ba78 <OSTmrNameGet+0x118>
8113ba2c:	10800108 	cmpgei	r2,r2,4
8113ba30:	1000111e 	bne	r2,zero,8113ba78 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
8113ba34:	e0bffd17 	ldw	r2,-12(fp)
8113ba38:	10800804 	addi	r2,r2,32
8113ba3c:	100b883a 	mov	r5,r2
8113ba40:	e13ffe17 	ldw	r4,-8(fp)
8113ba44:	11347100 	call	81134710 <OS_StrCopy>
8113ba48:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
8113ba4c:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113ba50:	e0bfff17 	ldw	r2,-4(fp)
8113ba54:	10000005 	stb	zero,0(r2)
             return (len);
8113ba58:	e0bffc03 	ldbu	r2,-16(fp)
8113ba5c:	00000b06 	br	8113ba8c <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
8113ba60:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113ba64:	e0bfff17 	ldw	r2,-4(fp)
8113ba68:	00ffe1c4 	movi	r3,-121
8113ba6c:	10c00005 	stb	r3,0(r2)
             return (0);
8113ba70:	0005883a 	mov	r2,zero
8113ba74:	00000506 	br	8113ba8c <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8113ba78:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113ba7c:	e0bfff17 	ldw	r2,-4(fp)
8113ba80:	00ffe344 	movi	r3,-115
8113ba84:	10c00005 	stb	r3,0(r2)
             return (0);
8113ba88:	0005883a 	mov	r2,zero
    }
}
8113ba8c:	e037883a 	mov	sp,fp
8113ba90:	dfc00117 	ldw	ra,4(sp)
8113ba94:	df000017 	ldw	fp,0(sp)
8113ba98:	dec00204 	addi	sp,sp,8
8113ba9c:	f800283a 	ret

8113baa0 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8113baa0:	defffb04 	addi	sp,sp,-20
8113baa4:	de00012e 	bgeu	sp,et,8113baac <OSTmrRemainGet+0xc>
8113baa8:	003b68fa 	trap	3
8113baac:	dfc00415 	stw	ra,16(sp)
8113bab0:	df000315 	stw	fp,12(sp)
8113bab4:	df000304 	addi	fp,sp,12
8113bab8:	e13ffe15 	stw	r4,-8(fp)
8113babc:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113bac0:	e0bfff17 	ldw	r2,-4(fp)
8113bac4:	1000021e 	bne	r2,zero,8113bad0 <OSTmrRemainGet+0x30>
        return (0);
8113bac8:	0005883a 	mov	r2,zero
8113bacc:	00005d06 	br	8113bc44 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8113bad0:	e0bffe17 	ldw	r2,-8(fp)
8113bad4:	1000051e 	bne	r2,zero,8113baec <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113bad8:	e0bfff17 	ldw	r2,-4(fp)
8113badc:	00ffe284 	movi	r3,-118
8113bae0:	10c00005 	stb	r3,0(r2)
        return (0);
8113bae4:	0005883a 	mov	r2,zero
8113bae8:	00005606 	br	8113bc44 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113baec:	e0bffe17 	ldw	r2,-8(fp)
8113baf0:	10800003 	ldbu	r2,0(r2)
8113baf4:	10803fcc 	andi	r2,r2,255
8113baf8:	10801920 	cmpeqi	r2,r2,100
8113bafc:	1000051e 	bne	r2,zero,8113bb14 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113bb00:	e0bfff17 	ldw	r2,-4(fp)
8113bb04:	00ffe244 	movi	r3,-119
8113bb08:	10c00005 	stb	r3,0(r2)
        return (0);
8113bb0c:	0005883a 	mov	r2,zero
8113bb10:	00004c06 	br	8113bc44 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113bb14:	d0a09b03 	ldbu	r2,-32148(gp)
8113bb18:	10803fcc 	andi	r2,r2,255
8113bb1c:	10000526 	beq	r2,zero,8113bb34 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113bb20:	e0bfff17 	ldw	r2,-4(fp)
8113bb24:	00ffe2c4 	movi	r3,-117
8113bb28:	10c00005 	stb	r3,0(r2)
        return (0);
8113bb2c:	0005883a 	mov	r2,zero
8113bb30:	00004406 	br	8113bc44 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
8113bb34:	113c6140 	call	8113c614 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113bb38:	e0bffe17 	ldw	r2,-8(fp)
8113bb3c:	10800c43 	ldbu	r2,49(r2)
8113bb40:	10803fcc 	andi	r2,r2,255
8113bb44:	10c00060 	cmpeqi	r3,r2,1
8113bb48:	1800121e 	bne	r3,zero,8113bb94 <OSTmrRemainGet+0xf4>
8113bb4c:	10c00088 	cmpgei	r3,r2,2
8113bb50:	1800021e 	bne	r3,zero,8113bb5c <OSTmrRemainGet+0xbc>
8113bb54:	10003026 	beq	r2,zero,8113bc18 <OSTmrRemainGet+0x178>
8113bb58:	00003506 	br	8113bc30 <OSTmrRemainGet+0x190>
8113bb5c:	10c000a0 	cmpeqi	r3,r2,2
8113bb60:	1800281e 	bne	r3,zero,8113bc04 <OSTmrRemainGet+0x164>
8113bb64:	108000e0 	cmpeqi	r2,r2,3
8113bb68:	10003126 	beq	r2,zero,8113bc30 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
8113bb6c:	e0bffe17 	ldw	r2,-8(fp)
8113bb70:	10c00517 	ldw	r3,20(r2)
8113bb74:	d0a09d17 	ldw	r2,-32140(gp)
8113bb78:	1885c83a 	sub	r2,r3,r2
8113bb7c:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8113bb80:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
8113bb84:	e0bfff17 	ldw	r2,-4(fp)
8113bb88:	10000005 	stb	zero,0(r2)
             return (remain);
8113bb8c:	e0bffd17 	ldw	r2,-12(fp)
8113bb90:	00002c06 	br	8113bc44 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
8113bb94:	e0bffe17 	ldw	r2,-8(fp)
8113bb98:	10800c03 	ldbu	r2,48(r2)
8113bb9c:	10803fcc 	andi	r2,r2,255
8113bba0:	108000a0 	cmpeqi	r2,r2,2
8113bba4:	10000e26 	beq	r2,zero,8113bbe0 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8113bba8:	e0bffe17 	ldw	r2,-8(fp)
8113bbac:	10800617 	ldw	r2,24(r2)
8113bbb0:	1000041e 	bne	r2,zero,8113bbc4 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
8113bbb4:	e0bffe17 	ldw	r2,-8(fp)
8113bbb8:	10800717 	ldw	r2,28(r2)
8113bbbc:	e0bffd15 	stw	r2,-12(fp)
8113bbc0:	00000306 	br	8113bbd0 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
8113bbc4:	e0bffe17 	ldw	r2,-8(fp)
8113bbc8:	10800617 	ldw	r2,24(r2)
8113bbcc:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8113bbd0:	113c6580 	call	8113c658 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113bbd4:	e0bfff17 	ldw	r2,-4(fp)
8113bbd8:	10000005 	stb	zero,0(r2)
                      break;
8113bbdc:	00000706 	br	8113bbfc <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8113bbe0:	e0bffe17 	ldw	r2,-8(fp)
8113bbe4:	10800617 	ldw	r2,24(r2)
8113bbe8:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8113bbec:	113c6580 	call	8113c658 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113bbf0:	e0bfff17 	ldw	r2,-4(fp)
8113bbf4:	10000005 	stb	zero,0(r2)
                      break;
8113bbf8:	0001883a 	nop
             }
             return (remain);
8113bbfc:	e0bffd17 	ldw	r2,-12(fp)
8113bc00:	00001006 	br	8113bc44 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
8113bc04:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113bc08:	e0bfff17 	ldw	r2,-4(fp)
8113bc0c:	10000005 	stb	zero,0(r2)
             return (0);
8113bc10:	0005883a 	mov	r2,zero
8113bc14:	00000b06 	br	8113bc44 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8113bc18:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113bc1c:	e0bfff17 	ldw	r2,-4(fp)
8113bc20:	00ffe1c4 	movi	r3,-121
8113bc24:	10c00005 	stb	r3,0(r2)
             return (0);
8113bc28:	0005883a 	mov	r2,zero
8113bc2c:	00000506 	br	8113bc44 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
8113bc30:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113bc34:	e0bfff17 	ldw	r2,-4(fp)
8113bc38:	00ffe344 	movi	r3,-115
8113bc3c:	10c00005 	stb	r3,0(r2)
             return (0);
8113bc40:	0005883a 	mov	r2,zero
    }
}
8113bc44:	e037883a 	mov	sp,fp
8113bc48:	dfc00117 	ldw	ra,4(sp)
8113bc4c:	df000017 	ldw	fp,0(sp)
8113bc50:	dec00204 	addi	sp,sp,8
8113bc54:	f800283a 	ret

8113bc58 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8113bc58:	defffb04 	addi	sp,sp,-20
8113bc5c:	de00012e 	bgeu	sp,et,8113bc64 <OSTmrStateGet+0xc>
8113bc60:	003b68fa 	trap	3
8113bc64:	dfc00415 	stw	ra,16(sp)
8113bc68:	df000315 	stw	fp,12(sp)
8113bc6c:	df000304 	addi	fp,sp,12
8113bc70:	e13ffe15 	stw	r4,-8(fp)
8113bc74:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113bc78:	e0bfff17 	ldw	r2,-4(fp)
8113bc7c:	1000021e 	bne	r2,zero,8113bc88 <OSTmrStateGet+0x30>
        return (0);
8113bc80:	0005883a 	mov	r2,zero
8113bc84:	00002a06 	br	8113bd30 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8113bc88:	e0bffe17 	ldw	r2,-8(fp)
8113bc8c:	1000051e 	bne	r2,zero,8113bca4 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113bc90:	e0bfff17 	ldw	r2,-4(fp)
8113bc94:	00ffe284 	movi	r3,-118
8113bc98:	10c00005 	stb	r3,0(r2)
        return (0);
8113bc9c:	0005883a 	mov	r2,zero
8113bca0:	00002306 	br	8113bd30 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113bca4:	e0bffe17 	ldw	r2,-8(fp)
8113bca8:	10800003 	ldbu	r2,0(r2)
8113bcac:	10803fcc 	andi	r2,r2,255
8113bcb0:	10801920 	cmpeqi	r2,r2,100
8113bcb4:	1000051e 	bne	r2,zero,8113bccc <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113bcb8:	e0bfff17 	ldw	r2,-4(fp)
8113bcbc:	00ffe244 	movi	r3,-119
8113bcc0:	10c00005 	stb	r3,0(r2)
        return (0);
8113bcc4:	0005883a 	mov	r2,zero
8113bcc8:	00001906 	br	8113bd30 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113bccc:	d0a09b03 	ldbu	r2,-32148(gp)
8113bcd0:	10803fcc 	andi	r2,r2,255
8113bcd4:	10000526 	beq	r2,zero,8113bcec <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113bcd8:	e0bfff17 	ldw	r2,-4(fp)
8113bcdc:	00ffe2c4 	movi	r3,-117
8113bce0:	10c00005 	stb	r3,0(r2)
        return (0);
8113bce4:	0005883a 	mov	r2,zero
8113bce8:	00001106 	br	8113bd30 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8113bcec:	113c6140 	call	8113c614 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8113bcf0:	e0bffe17 	ldw	r2,-8(fp)
8113bcf4:	10800c43 	ldbu	r2,49(r2)
8113bcf8:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
8113bcfc:	e0bffd03 	ldbu	r2,-12(fp)
8113bd00:	1005883a 	mov	r2,r2
8113bd04:	10800128 	cmpgeui	r2,r2,4
8113bd08:	1000031e 	bne	r2,zero,8113bd18 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
8113bd0c:	e0bfff17 	ldw	r2,-4(fp)
8113bd10:	10000005 	stb	zero,0(r2)
             break;
8113bd14:	00000406 	br	8113bd28 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8113bd18:	e0bfff17 	ldw	r2,-4(fp)
8113bd1c:	00ffe344 	movi	r3,-115
8113bd20:	10c00005 	stb	r3,0(r2)
             break;
8113bd24:	0001883a 	nop
    }
    OSTmr_Unlock();
8113bd28:	113c6580 	call	8113c658 <OSTmr_Unlock>
    return (state);
8113bd2c:	e0bffd03 	ldbu	r2,-12(fp)
}
8113bd30:	e037883a 	mov	sp,fp
8113bd34:	dfc00117 	ldw	ra,4(sp)
8113bd38:	df000017 	ldw	fp,0(sp)
8113bd3c:	dec00204 	addi	sp,sp,8
8113bd40:	f800283a 	ret

8113bd44 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
8113bd44:	defffc04 	addi	sp,sp,-16
8113bd48:	de00012e 	bgeu	sp,et,8113bd50 <OSTmrStart+0xc>
8113bd4c:	003b68fa 	trap	3
8113bd50:	dfc00315 	stw	ra,12(sp)
8113bd54:	df000215 	stw	fp,8(sp)
8113bd58:	df000204 	addi	fp,sp,8
8113bd5c:	e13ffe15 	stw	r4,-8(fp)
8113bd60:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113bd64:	e0bfff17 	ldw	r2,-4(fp)
8113bd68:	1000021e 	bne	r2,zero,8113bd74 <OSTmrStart+0x30>
        return (OS_FALSE);
8113bd6c:	0005883a 	mov	r2,zero
8113bd70:	00004106 	br	8113be78 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
8113bd74:	e0bffe17 	ldw	r2,-8(fp)
8113bd78:	1000051e 	bne	r2,zero,8113bd90 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113bd7c:	e0bfff17 	ldw	r2,-4(fp)
8113bd80:	00ffe284 	movi	r3,-118
8113bd84:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bd88:	0005883a 	mov	r2,zero
8113bd8c:	00003a06 	br	8113be78 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113bd90:	e0bffe17 	ldw	r2,-8(fp)
8113bd94:	10800003 	ldbu	r2,0(r2)
8113bd98:	10803fcc 	andi	r2,r2,255
8113bd9c:	10801920 	cmpeqi	r2,r2,100
8113bda0:	1000051e 	bne	r2,zero,8113bdb8 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113bda4:	e0bfff17 	ldw	r2,-4(fp)
8113bda8:	00ffe244 	movi	r3,-119
8113bdac:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bdb0:	0005883a 	mov	r2,zero
8113bdb4:	00003006 	br	8113be78 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113bdb8:	d0a09b03 	ldbu	r2,-32148(gp)
8113bdbc:	10803fcc 	andi	r2,r2,255
8113bdc0:	10000526 	beq	r2,zero,8113bdd8 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113bdc4:	e0bfff17 	ldw	r2,-4(fp)
8113bdc8:	00ffe2c4 	movi	r3,-117
8113bdcc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bdd0:	0005883a 	mov	r2,zero
8113bdd4:	00002806 	br	8113be78 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8113bdd8:	113c6140 	call	8113c614 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113bddc:	e0bffe17 	ldw	r2,-8(fp)
8113bde0:	10800c43 	ldbu	r2,49(r2)
8113bde4:	10803fcc 	andi	r2,r2,255
8113bde8:	10c000c8 	cmpgei	r3,r2,3
8113bdec:	1800031e 	bne	r3,zero,8113bdfc <OSTmrStart+0xb8>
8113bdf0:	00800e16 	blt	zero,r2,8113be2c <OSTmrStart+0xe8>
8113bdf4:	10001526 	beq	r2,zero,8113be4c <OSTmrStart+0x108>
8113bdf8:	00001a06 	br	8113be64 <OSTmrStart+0x120>
8113bdfc:	108000e0 	cmpeqi	r2,r2,3
8113be00:	10001826 	beq	r2,zero,8113be64 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8113be04:	e13ffe17 	ldw	r4,-8(fp)
8113be08:	113c5180 	call	8113c518 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113be0c:	000b883a 	mov	r5,zero
8113be10:	e13ffe17 	ldw	r4,-8(fp)
8113be14:	113c3c80 	call	8113c3c8 <OSTmr_Link>
             OSTmr_Unlock();
8113be18:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113be1c:	e0bfff17 	ldw	r2,-4(fp)
8113be20:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113be24:	00800044 	movi	r2,1
8113be28:	00001306 	br	8113be78 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113be2c:	000b883a 	mov	r5,zero
8113be30:	e13ffe17 	ldw	r4,-8(fp)
8113be34:	113c3c80 	call	8113c3c8 <OSTmr_Link>
             OSTmr_Unlock();
8113be38:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113be3c:	e0bfff17 	ldw	r2,-4(fp)
8113be40:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113be44:	00800044 	movi	r2,1
8113be48:	00000b06 	br	8113be78 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
8113be4c:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113be50:	e0bfff17 	ldw	r2,-4(fp)
8113be54:	00ffe1c4 	movi	r3,-121
8113be58:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113be5c:	0005883a 	mov	r2,zero
8113be60:	00000506 	br	8113be78 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8113be64:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113be68:	e0bfff17 	ldw	r2,-4(fp)
8113be6c:	00ffe344 	movi	r3,-115
8113be70:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113be74:	0005883a 	mov	r2,zero
    }
}
8113be78:	e037883a 	mov	sp,fp
8113be7c:	dfc00117 	ldw	ra,4(sp)
8113be80:	df000017 	ldw	fp,0(sp)
8113be84:	dec00204 	addi	sp,sp,8
8113be88:	f800283a 	ret

8113be8c <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8113be8c:	defff904 	addi	sp,sp,-28
8113be90:	de00012e 	bgeu	sp,et,8113be98 <OSTmrStop+0xc>
8113be94:	003b68fa 	trap	3
8113be98:	dfc00615 	stw	ra,24(sp)
8113be9c:	df000515 	stw	fp,20(sp)
8113bea0:	df000504 	addi	fp,sp,20
8113bea4:	e13ffc15 	stw	r4,-16(fp)
8113bea8:	2805883a 	mov	r2,r5
8113beac:	e1bffe15 	stw	r6,-8(fp)
8113beb0:	e1ffff15 	stw	r7,-4(fp)
8113beb4:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8113beb8:	e0bfff17 	ldw	r2,-4(fp)
8113bebc:	1000021e 	bne	r2,zero,8113bec8 <OSTmrStop+0x3c>
        return (OS_FALSE);
8113bec0:	0005883a 	mov	r2,zero
8113bec4:	00006606 	br	8113c060 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8113bec8:	e0bffc17 	ldw	r2,-16(fp)
8113becc:	1000051e 	bne	r2,zero,8113bee4 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8113bed0:	e0bfff17 	ldw	r2,-4(fp)
8113bed4:	00ffe284 	movi	r3,-118
8113bed8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bedc:	0005883a 	mov	r2,zero
8113bee0:	00005f06 	br	8113c060 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
8113bee4:	e0bffc17 	ldw	r2,-16(fp)
8113bee8:	10800003 	ldbu	r2,0(r2)
8113beec:	10803fcc 	andi	r2,r2,255
8113bef0:	10801920 	cmpeqi	r2,r2,100
8113bef4:	1000051e 	bne	r2,zero,8113bf0c <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113bef8:	e0bfff17 	ldw	r2,-4(fp)
8113befc:	00ffe244 	movi	r3,-119
8113bf00:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bf04:	0005883a 	mov	r2,zero
8113bf08:	00005506 	br	8113c060 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8113bf0c:	d0a09b03 	ldbu	r2,-32148(gp)
8113bf10:	10803fcc 	andi	r2,r2,255
8113bf14:	10000526 	beq	r2,zero,8113bf2c <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8113bf18:	e0bfff17 	ldw	r2,-4(fp)
8113bf1c:	00ffe2c4 	movi	r3,-117
8113bf20:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bf24:	0005883a 	mov	r2,zero
8113bf28:	00004d06 	br	8113c060 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8113bf2c:	113c6140 	call	8113c614 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113bf30:	e0bffc17 	ldw	r2,-16(fp)
8113bf34:	10800c43 	ldbu	r2,49(r2)
8113bf38:	10803fcc 	andi	r2,r2,255
8113bf3c:	10c000c8 	cmpgei	r3,r2,3
8113bf40:	1800031e 	bne	r3,zero,8113bf50 <OSTmrStop+0xc4>
8113bf44:	00803516 	blt	zero,r2,8113c01c <OSTmrStop+0x190>
8113bf48:	10003a26 	beq	r2,zero,8113c034 <OSTmrStop+0x1a8>
8113bf4c:	00003f06 	br	8113c04c <OSTmrStop+0x1c0>
8113bf50:	108000e0 	cmpeqi	r2,r2,3
8113bf54:	10003d26 	beq	r2,zero,8113c04c <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8113bf58:	e13ffc17 	ldw	r4,-16(fp)
8113bf5c:	113c5180 	call	8113c518 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8113bf60:	e0bfff17 	ldw	r2,-4(fp)
8113bf64:	10000005 	stb	zero,0(r2)
             switch (opt) {
8113bf68:	e0bffd03 	ldbu	r2,-12(fp)
8113bf6c:	10c000e0 	cmpeqi	r3,r2,3
8113bf70:	1800041e 	bne	r3,zero,8113bf84 <OSTmrStop+0xf8>
8113bf74:	10c00120 	cmpeqi	r3,r2,4
8113bf78:	1800121e 	bne	r3,zero,8113bfc4 <OSTmrStop+0x138>
8113bf7c:	10002326 	beq	r2,zero,8113c00c <OSTmrStop+0x180>
8113bf80:	00001e06 	br	8113bffc <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113bf84:	e0bffc17 	ldw	r2,-16(fp)
8113bf88:	10800117 	ldw	r2,4(r2)
8113bf8c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113bf90:	e0bffb17 	ldw	r2,-20(fp)
8113bf94:	10000726 	beq	r2,zero,8113bfb4 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8113bf98:	e0bffc17 	ldw	r2,-16(fp)
8113bf9c:	10c00217 	ldw	r3,8(r2)
8113bfa0:	e0bffb17 	ldw	r2,-20(fp)
8113bfa4:	180b883a 	mov	r5,r3
8113bfa8:	e13ffc17 	ldw	r4,-16(fp)
8113bfac:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113bfb0:	00001706 	br	8113c010 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113bfb4:	e0bfff17 	ldw	r2,-4(fp)
8113bfb8:	00ffe3c4 	movi	r3,-113
8113bfbc:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113bfc0:	00001306 	br	8113c010 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113bfc4:	e0bffc17 	ldw	r2,-16(fp)
8113bfc8:	10800117 	ldw	r2,4(r2)
8113bfcc:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113bfd0:	e0bffb17 	ldw	r2,-20(fp)
8113bfd4:	10000526 	beq	r2,zero,8113bfec <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8113bfd8:	e0bffb17 	ldw	r2,-20(fp)
8113bfdc:	e17ffe17 	ldw	r5,-8(fp)
8113bfe0:	e13ffc17 	ldw	r4,-16(fp)
8113bfe4:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113bfe8:	00000906 	br	8113c010 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113bfec:	e0bfff17 	ldw	r2,-4(fp)
8113bff0:	00ffe3c4 	movi	r3,-113
8113bff4:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113bff8:	00000506 	br	8113c010 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8113bffc:	e0bfff17 	ldw	r2,-4(fp)
8113c000:	00ffe104 	movi	r3,-124
8113c004:	10c00005 	stb	r3,0(r2)
                     break;
8113c008:	00000106 	br	8113c010 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8113c00c:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8113c010:	113c6580 	call	8113c658 <OSTmr_Unlock>
             return (OS_TRUE);
8113c014:	00800044 	movi	r2,1
8113c018:	00001106 	br	8113c060 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8113c01c:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
8113c020:	e0bfff17 	ldw	r2,-4(fp)
8113c024:	00ffe384 	movi	r3,-114
8113c028:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8113c02c:	00800044 	movi	r2,1
8113c030:	00000b06 	br	8113c060 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8113c034:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113c038:	e0bfff17 	ldw	r2,-4(fp)
8113c03c:	00ffe1c4 	movi	r3,-121
8113c040:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c044:	0005883a 	mov	r2,zero
8113c048:	00000506 	br	8113c060 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
8113c04c:	113c6580 	call	8113c658 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113c050:	e0bfff17 	ldw	r2,-4(fp)
8113c054:	00ffe344 	movi	r3,-115
8113c058:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c05c:	0005883a 	mov	r2,zero
    }
}
8113c060:	e037883a 	mov	sp,fp
8113c064:	dfc00117 	ldw	ra,4(sp)
8113c068:	df000017 	ldw	fp,0(sp)
8113c06c:	dec00204 	addi	sp,sp,8
8113c070:	f800283a 	ret

8113c074 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8113c074:	defffd04 	addi	sp,sp,-12
8113c078:	de00012e 	bgeu	sp,et,8113c080 <OSTmrSignal+0xc>
8113c07c:	003b68fa 	trap	3
8113c080:	dfc00215 	stw	ra,8(sp)
8113c084:	df000115 	stw	fp,4(sp)
8113c088:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8113c08c:	d0a08a17 	ldw	r2,-32216(gp)
8113c090:	1009883a 	mov	r4,r2
8113c094:	11397f40 	call	811397f4 <OSSemPost>
8113c098:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8113c09c:	e0bfff03 	ldbu	r2,-4(fp)
}
8113c0a0:	e037883a 	mov	sp,fp
8113c0a4:	dfc00117 	ldw	ra,4(sp)
8113c0a8:	df000017 	ldw	fp,0(sp)
8113c0ac:	dec00204 	addi	sp,sp,8
8113c0b0:	f800283a 	ret

8113c0b4 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
8113c0b4:	defffe04 	addi	sp,sp,-8
8113c0b8:	de00012e 	bgeu	sp,et,8113c0c0 <OSTmr_Alloc+0xc>
8113c0bc:	003b68fa 	trap	3
8113c0c0:	df000115 	stw	fp,4(sp)
8113c0c4:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8113c0c8:	d0a08817 	ldw	r2,-32224(gp)
8113c0cc:	1000021e 	bne	r2,zero,8113c0d8 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8113c0d0:	0005883a 	mov	r2,zero
8113c0d4:	00001006 	br	8113c118 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8113c0d8:	d0a08817 	ldw	r2,-32224(gp)
8113c0dc:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8113c0e0:	e0bfff17 	ldw	r2,-4(fp)
8113c0e4:	10800317 	ldw	r2,12(r2)
8113c0e8:	d0a08815 	stw	r2,-32224(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8113c0ec:	e0bfff17 	ldw	r2,-4(fp)
8113c0f0:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
8113c0f4:	e0bfff17 	ldw	r2,-4(fp)
8113c0f8:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8113c0fc:	d0a08d0b 	ldhu	r2,-32204(gp)
8113c100:	10800044 	addi	r2,r2,1
8113c104:	d0a08d0d 	sth	r2,-32204(gp)
    OSTmrFree--;
8113c108:	d0a0910b 	ldhu	r2,-32188(gp)
8113c10c:	10bfffc4 	addi	r2,r2,-1
8113c110:	d0a0910d 	sth	r2,-32188(gp)
    return (ptmr);
8113c114:	e0bfff17 	ldw	r2,-4(fp)
}
8113c118:	e037883a 	mov	sp,fp
8113c11c:	df000017 	ldw	fp,0(sp)
8113c120:	dec00104 	addi	sp,sp,4
8113c124:	f800283a 	ret

8113c128 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8113c128:	defffe04 	addi	sp,sp,-8
8113c12c:	de00012e 	bgeu	sp,et,8113c134 <OSTmr_Free+0xc>
8113c130:	003b68fa 	trap	3
8113c134:	df000115 	stw	fp,4(sp)
8113c138:	df000104 	addi	fp,sp,4
8113c13c:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
8113c140:	e0bfff17 	ldw	r2,-4(fp)
8113c144:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8113c148:	e0bfff17 	ldw	r2,-4(fp)
8113c14c:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
8113c150:	e0bfff17 	ldw	r2,-4(fp)
8113c154:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8113c158:	e0bfff17 	ldw	r2,-4(fp)
8113c15c:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
8113c160:	e0bfff17 	ldw	r2,-4(fp)
8113c164:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8113c168:	e0bfff17 	ldw	r2,-4(fp)
8113c16c:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
8113c170:	e0bfff17 	ldw	r2,-4(fp)
8113c174:	00c00fc4 	movi	r3,63
8113c178:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8113c17c:	e0bfff17 	ldw	r2,-4(fp)
8113c180:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8113c184:	e0bfff17 	ldw	r2,-4(fp)
8113c188:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8113c18c:	d0e08817 	ldw	r3,-32224(gp)
8113c190:	e0bfff17 	ldw	r2,-4(fp)
8113c194:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8113c198:	e0bfff17 	ldw	r2,-4(fp)
8113c19c:	d0a08815 	stw	r2,-32224(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
8113c1a0:	d0a08d0b 	ldhu	r2,-32204(gp)
8113c1a4:	10bfffc4 	addi	r2,r2,-1
8113c1a8:	d0a08d0d 	sth	r2,-32204(gp)
    OSTmrFree++;
8113c1ac:	d0a0910b 	ldhu	r2,-32188(gp)
8113c1b0:	10800044 	addi	r2,r2,1
8113c1b4:	d0a0910d 	sth	r2,-32188(gp)
}
8113c1b8:	0001883a 	nop
8113c1bc:	e037883a 	mov	sp,fp
8113c1c0:	df000017 	ldw	fp,0(sp)
8113c1c4:	dec00104 	addi	sp,sp,4
8113c1c8:	f800283a 	ret

8113c1cc <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8113c1cc:	defffa04 	addi	sp,sp,-24
8113c1d0:	de00012e 	bgeu	sp,et,8113c1d8 <OSTmr_Init+0xc>
8113c1d4:	003b68fa 	trap	3
8113c1d8:	dfc00515 	stw	ra,20(sp)
8113c1dc:	df000415 	stw	fp,16(sp)
8113c1e0:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
8113c1e4:	01406804 	movi	r5,416
8113c1e8:	012045b4 	movhi	r4,33046
8113c1ec:	2102ee04 	addi	r4,r4,3000
8113c1f0:	11344f00 	call	811344f0 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
8113c1f4:	01400404 	movi	r5,16
8113c1f8:	012045b4 	movhi	r4,33046
8113c1fc:	21018a04 	addi	r4,r4,1576
8113c200:	11344f00 	call	811344f0 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8113c204:	00a045b4 	movhi	r2,33046
8113c208:	1082ee04 	addi	r2,r2,3000
8113c20c:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
8113c210:	00a045b4 	movhi	r2,33046
8113c214:	1082fb04 	addi	r2,r2,3052
8113c218:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113c21c:	e03ffc0d 	sth	zero,-16(fp)
8113c220:	00001606 	br	8113c27c <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8113c224:	e0bffd17 	ldw	r2,-12(fp)
8113c228:	00c01904 	movi	r3,100
8113c22c:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
8113c230:	e0bffd17 	ldw	r2,-12(fp)
8113c234:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8113c238:	e0bffd17 	ldw	r2,-12(fp)
8113c23c:	e0fffe17 	ldw	r3,-8(fp)
8113c240:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8113c244:	e0bffd17 	ldw	r2,-12(fp)
8113c248:	00c00fc4 	movi	r3,63
8113c24c:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113c250:	e0bffd17 	ldw	r2,-12(fp)
8113c254:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8113c258:	e0bffd17 	ldw	r2,-12(fp)
8113c25c:	10800d04 	addi	r2,r2,52
8113c260:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8113c264:	e0bffe17 	ldw	r2,-8(fp)
8113c268:	10800d04 	addi	r2,r2,52
8113c26c:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113c270:	e0bffc0b 	ldhu	r2,-16(fp)
8113c274:	10800044 	addi	r2,r2,1
8113c278:	e0bffc0d 	sth	r2,-16(fp)
8113c27c:	e0bffc0b 	ldhu	r2,-16(fp)
8113c280:	108001f0 	cmpltui	r2,r2,7
8113c284:	103fe71e 	bne	r2,zero,8113c224 <__reset+0xfb11c224>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8113c288:	e0bffd17 	ldw	r2,-12(fp)
8113c28c:	00c01904 	movi	r3,100
8113c290:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8113c294:	e0bffd17 	ldw	r2,-12(fp)
8113c298:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
8113c29c:	e0bffd17 	ldw	r2,-12(fp)
8113c2a0:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
8113c2a4:	e0bffd17 	ldw	r2,-12(fp)
8113c2a8:	00c00fc4 	movi	r3,63
8113c2ac:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113c2b0:	e0bffd17 	ldw	r2,-12(fp)
8113c2b4:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8113c2b8:	d0209d15 	stw	zero,-32140(gp)
    OSTmrUsed           = 0;
8113c2bc:	d0208d0d 	sth	zero,-32204(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
8113c2c0:	00800204 	movi	r2,8
8113c2c4:	d0a0910d 	sth	r2,-32188(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8113c2c8:	00a045b4 	movhi	r2,33046
8113c2cc:	1082ee04 	addi	r2,r2,3000
8113c2d0:	d0a08815 	stw	r2,-32224(gp)
    OSTmrSem            = OSSemCreate(1);
8113c2d4:	01000044 	movi	r4,1
8113c2d8:	11391440 	call	81139144 <OSSemCreate>
8113c2dc:	d0a09f15 	stw	r2,-32132(gp)
    OSTmrSemSignal      = OSSemCreate(0);
8113c2e0:	0009883a 	mov	r4,zero
8113c2e4:	11391440 	call	81139144 <OSSemCreate>
8113c2e8:	d0a08a15 	stw	r2,-32216(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
8113c2ec:	d0a09f17 	ldw	r2,-32132(gp)
8113c2f0:	e0ffff04 	addi	r3,fp,-4
8113c2f4:	180d883a 	mov	r6,r3
8113c2f8:	01604574 	movhi	r5,33045
8113c2fc:	296b2104 	addi	r5,r5,-21372
8113c300:	1009883a 	mov	r4,r2
8113c304:	1132d4c0 	call	81132d4c <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
8113c308:	d0a08a17 	ldw	r2,-32216(gp)
8113c30c:	e0ffff04 	addi	r3,fp,-4
8113c310:	180d883a 	mov	r6,r3
8113c314:	01604574 	movhi	r5,33045
8113c318:	296b2604 	addi	r5,r5,-21352
8113c31c:	1009883a 	mov	r4,r2
8113c320:	1132d4c0 	call	81132d4c <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8113c324:	113c3400 	call	8113c340 <OSTmr_InitTask>
}
8113c328:	0001883a 	nop
8113c32c:	e037883a 	mov	sp,fp
8113c330:	dfc00117 	ldw	ra,4(sp)
8113c334:	df000017 	ldw	fp,0(sp)
8113c338:	dec00204 	addi	sp,sp,8
8113c33c:	f800283a 	ret

8113c340 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
8113c340:	defff804 	addi	sp,sp,-32
8113c344:	de00012e 	bgeu	sp,et,8113c34c <OSTmr_InitTask+0xc>
8113c348:	003b68fa 	trap	3
8113c34c:	dfc00715 	stw	ra,28(sp)
8113c350:	df000615 	stw	fp,24(sp)
8113c354:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8113c358:	008000c4 	movi	r2,3
8113c35c:	d8800415 	stw	r2,16(sp)
8113c360:	d8000315 	stw	zero,12(sp)
8113c364:	00808004 	movi	r2,512
8113c368:	d8800215 	stw	r2,8(sp)
8113c36c:	00a045b4 	movhi	r2,33046
8113c370:	108ac204 	addi	r2,r2,11016
8113c374:	d8800115 	stw	r2,4(sp)
8113c378:	00bfff54 	movui	r2,65533
8113c37c:	d8800015 	stw	r2,0(sp)
8113c380:	01c00744 	movi	r7,29
8113c384:	01a045b4 	movhi	r6,33046
8113c388:	318cc104 	addi	r6,r6,13060
8113c38c:	000b883a 	mov	r5,zero
8113c390:	01204534 	movhi	r4,33044
8113c394:	2131a504 	addi	r4,r4,-14700
8113c398:	113a0240 	call	8113a024 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
8113c39c:	e1bfff04 	addi	r6,fp,-4
8113c3a0:	01604574 	movhi	r5,33045
8113c3a4:	296b2b04 	addi	r5,r5,-21332
8113c3a8:	01000744 	movi	r4,29
8113c3ac:	113a8540 	call	8113a854 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
8113c3b0:	0001883a 	nop
8113c3b4:	e037883a 	mov	sp,fp
8113c3b8:	dfc00117 	ldw	ra,4(sp)
8113c3bc:	df000017 	ldw	fp,0(sp)
8113c3c0:	dec00204 	addi	sp,sp,8
8113c3c4:	f800283a 	ret

8113c3c8 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8113c3c8:	defffa04 	addi	sp,sp,-24
8113c3cc:	de00012e 	bgeu	sp,et,8113c3d4 <OSTmr_Link+0xc>
8113c3d0:	003b68fa 	trap	3
8113c3d4:	df000515 	stw	fp,20(sp)
8113c3d8:	df000504 	addi	fp,sp,20
8113c3dc:	e13ffe15 	stw	r4,-8(fp)
8113c3e0:	2805883a 	mov	r2,r5
8113c3e4:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8113c3e8:	e0bffe17 	ldw	r2,-8(fp)
8113c3ec:	00c000c4 	movi	r3,3
8113c3f0:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
8113c3f4:	e0bfff03 	ldbu	r2,-4(fp)
8113c3f8:	10800058 	cmpnei	r2,r2,1
8113c3fc:	1000071e 	bne	r2,zero,8113c41c <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113c400:	e0bffe17 	ldw	r2,-8(fp)
8113c404:	10c00717 	ldw	r3,28(r2)
8113c408:	d0a09d17 	ldw	r2,-32140(gp)
8113c40c:	1887883a 	add	r3,r3,r2
8113c410:	e0bffe17 	ldw	r2,-8(fp)
8113c414:	10c00515 	stw	r3,20(r2)
8113c418:	00001006 	br	8113c45c <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
8113c41c:	e0bffe17 	ldw	r2,-8(fp)
8113c420:	10800617 	ldw	r2,24(r2)
8113c424:	1000071e 	bne	r2,zero,8113c444 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113c428:	e0bffe17 	ldw	r2,-8(fp)
8113c42c:	10c00717 	ldw	r3,28(r2)
8113c430:	d0a09d17 	ldw	r2,-32140(gp)
8113c434:	1887883a 	add	r3,r3,r2
8113c438:	e0bffe17 	ldw	r2,-8(fp)
8113c43c:	10c00515 	stw	r3,20(r2)
8113c440:	00000606 	br	8113c45c <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8113c444:	e0bffe17 	ldw	r2,-8(fp)
8113c448:	10c00617 	ldw	r3,24(r2)
8113c44c:	d0a09d17 	ldw	r2,-32140(gp)
8113c450:	1887883a 	add	r3,r3,r2
8113c454:	e0bffe17 	ldw	r2,-8(fp)
8113c458:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113c45c:	e0bffe17 	ldw	r2,-8(fp)
8113c460:	10800517 	ldw	r2,20(r2)
8113c464:	1080004c 	andi	r2,r2,1
8113c468:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113c46c:	e0bffb0b 	ldhu	r2,-20(fp)
8113c470:	100690fa 	slli	r3,r2,3
8113c474:	00a045b4 	movhi	r2,33046
8113c478:	10818a04 	addi	r2,r2,1576
8113c47c:	1885883a 	add	r2,r3,r2
8113c480:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8113c484:	e0bffc17 	ldw	r2,-16(fp)
8113c488:	10800017 	ldw	r2,0(r2)
8113c48c:	1000091e 	bne	r2,zero,8113c4b4 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8113c490:	e0bffc17 	ldw	r2,-16(fp)
8113c494:	e0fffe17 	ldw	r3,-8(fp)
8113c498:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
8113c49c:	e0bffe17 	ldw	r2,-8(fp)
8113c4a0:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
8113c4a4:	e0bffc17 	ldw	r2,-16(fp)
8113c4a8:	00c00044 	movi	r3,1
8113c4ac:	10c0010d 	sth	r3,4(r2)
8113c4b0:	00001206 	br	8113c4fc <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
8113c4b4:	e0bffc17 	ldw	r2,-16(fp)
8113c4b8:	10800017 	ldw	r2,0(r2)
8113c4bc:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8113c4c0:	e0bffc17 	ldw	r2,-16(fp)
8113c4c4:	e0fffe17 	ldw	r3,-8(fp)
8113c4c8:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
8113c4cc:	e0bffe17 	ldw	r2,-8(fp)
8113c4d0:	e0fffd17 	ldw	r3,-12(fp)
8113c4d4:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8113c4d8:	e0bffd17 	ldw	r2,-12(fp)
8113c4dc:	e0fffe17 	ldw	r3,-8(fp)
8113c4e0:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
8113c4e4:	e0bffc17 	ldw	r2,-16(fp)
8113c4e8:	1080010b 	ldhu	r2,4(r2)
8113c4ec:	10800044 	addi	r2,r2,1
8113c4f0:	1007883a 	mov	r3,r2
8113c4f4:	e0bffc17 	ldw	r2,-16(fp)
8113c4f8:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
8113c4fc:	e0bffe17 	ldw	r2,-8(fp)
8113c500:	10000415 	stw	zero,16(r2)
}
8113c504:	0001883a 	nop
8113c508:	e037883a 	mov	sp,fp
8113c50c:	df000017 	ldw	fp,0(sp)
8113c510:	dec00104 	addi	sp,sp,4
8113c514:	f800283a 	ret

8113c518 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8113c518:	defffa04 	addi	sp,sp,-24
8113c51c:	de00012e 	bgeu	sp,et,8113c524 <OSTmr_Unlink+0xc>
8113c520:	003b68fa 	trap	3
8113c524:	df000515 	stw	fp,20(sp)
8113c528:	df000504 	addi	fp,sp,20
8113c52c:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113c530:	e0bfff17 	ldw	r2,-4(fp)
8113c534:	10800517 	ldw	r2,20(r2)
8113c538:	1080004c 	andi	r2,r2,1
8113c53c:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113c540:	e0bffb0b 	ldhu	r2,-20(fp)
8113c544:	100690fa 	slli	r3,r2,3
8113c548:	00a045b4 	movhi	r2,33046
8113c54c:	10818a04 	addi	r2,r2,1576
8113c550:	1885883a 	add	r2,r3,r2
8113c554:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8113c558:	e0bffc17 	ldw	r2,-16(fp)
8113c55c:	10c00017 	ldw	r3,0(r2)
8113c560:	e0bfff17 	ldw	r2,-4(fp)
8113c564:	18800b1e 	bne	r3,r2,8113c594 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8113c568:	e0bfff17 	ldw	r2,-4(fp)
8113c56c:	10800317 	ldw	r2,12(r2)
8113c570:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8113c574:	e0bffc17 	ldw	r2,-16(fp)
8113c578:	e0fffd17 	ldw	r3,-12(fp)
8113c57c:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
8113c580:	e0bffd17 	ldw	r2,-12(fp)
8113c584:	10001126 	beq	r2,zero,8113c5cc <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8113c588:	e0bffd17 	ldw	r2,-12(fp)
8113c58c:	10000415 	stw	zero,16(r2)
8113c590:	00000e06 	br	8113c5cc <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8113c594:	e0bfff17 	ldw	r2,-4(fp)
8113c598:	10800417 	ldw	r2,16(r2)
8113c59c:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8113c5a0:	e0bfff17 	ldw	r2,-4(fp)
8113c5a4:	10800317 	ldw	r2,12(r2)
8113c5a8:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
8113c5ac:	e0bffd17 	ldw	r2,-12(fp)
8113c5b0:	e0fffe17 	ldw	r3,-8(fp)
8113c5b4:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
8113c5b8:	e0bffe17 	ldw	r2,-8(fp)
8113c5bc:	10000326 	beq	r2,zero,8113c5cc <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8113c5c0:	e0bffe17 	ldw	r2,-8(fp)
8113c5c4:	e0fffd17 	ldw	r3,-12(fp)
8113c5c8:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
8113c5cc:	e0bfff17 	ldw	r2,-4(fp)
8113c5d0:	00c00044 	movi	r3,1
8113c5d4:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
8113c5d8:	e0bfff17 	ldw	r2,-4(fp)
8113c5dc:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8113c5e0:	e0bfff17 	ldw	r2,-4(fp)
8113c5e4:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
8113c5e8:	e0bffc17 	ldw	r2,-16(fp)
8113c5ec:	1080010b 	ldhu	r2,4(r2)
8113c5f0:	10bfffc4 	addi	r2,r2,-1
8113c5f4:	1007883a 	mov	r3,r2
8113c5f8:	e0bffc17 	ldw	r2,-16(fp)
8113c5fc:	10c0010d 	sth	r3,4(r2)
}
8113c600:	0001883a 	nop
8113c604:	e037883a 	mov	sp,fp
8113c608:	df000017 	ldw	fp,0(sp)
8113c60c:	dec00104 	addi	sp,sp,4
8113c610:	f800283a 	ret

8113c614 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8113c614:	defffd04 	addi	sp,sp,-12
8113c618:	de00012e 	bgeu	sp,et,8113c620 <OSTmr_Lock+0xc>
8113c61c:	003b68fa 	trap	3
8113c620:	dfc00215 	stw	ra,8(sp)
8113c624:	df000115 	stw	fp,4(sp)
8113c628:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
8113c62c:	d0a09f17 	ldw	r2,-32132(gp)
8113c630:	e1bfff04 	addi	r6,fp,-4
8113c634:	000b883a 	mov	r5,zero
8113c638:	1009883a 	mov	r4,r2
8113c63c:	113946c0 	call	8113946c <OSSemPend>
    (void)err;
}
8113c640:	0001883a 	nop
8113c644:	e037883a 	mov	sp,fp
8113c648:	dfc00117 	ldw	ra,4(sp)
8113c64c:	df000017 	ldw	fp,0(sp)
8113c650:	dec00204 	addi	sp,sp,8
8113c654:	f800283a 	ret

8113c658 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8113c658:	defffe04 	addi	sp,sp,-8
8113c65c:	de00012e 	bgeu	sp,et,8113c664 <OSTmr_Unlock+0xc>
8113c660:	003b68fa 	trap	3
8113c664:	dfc00115 	stw	ra,4(sp)
8113c668:	df000015 	stw	fp,0(sp)
8113c66c:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8113c670:	d0a09f17 	ldw	r2,-32132(gp)
8113c674:	1009883a 	mov	r4,r2
8113c678:	11397f40 	call	811397f4 <OSSemPost>
}
8113c67c:	0001883a 	nop
8113c680:	e037883a 	mov	sp,fp
8113c684:	dfc00117 	ldw	ra,4(sp)
8113c688:	df000017 	ldw	fp,0(sp)
8113c68c:	dec00204 	addi	sp,sp,8
8113c690:	f800283a 	ret

8113c694 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8113c694:	defff704 	addi	sp,sp,-36
8113c698:	de00012e 	bgeu	sp,et,8113c6a0 <OSTmr_Task+0xc>
8113c69c:	003b68fa 	trap	3
8113c6a0:	dfc00815 	stw	ra,32(sp)
8113c6a4:	df000715 	stw	fp,28(sp)
8113c6a8:	df000704 	addi	fp,sp,28
8113c6ac:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8113c6b0:	d0a08a17 	ldw	r2,-32216(gp)
8113c6b4:	e0fffe04 	addi	r3,fp,-8
8113c6b8:	180d883a 	mov	r6,r3
8113c6bc:	000b883a 	mov	r5,zero
8113c6c0:	1009883a 	mov	r4,r2
8113c6c4:	113946c0 	call	8113946c <OSSemPend>
        OSTmr_Lock();
8113c6c8:	113c6140 	call	8113c614 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
8113c6cc:	d0a09d17 	ldw	r2,-32140(gp)
8113c6d0:	10800044 	addi	r2,r2,1
8113c6d4:	d0a09d15 	stw	r2,-32140(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
8113c6d8:	d0a09d17 	ldw	r2,-32140(gp)
8113c6dc:	1080004c 	andi	r2,r2,1
8113c6e0:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
8113c6e4:	e0bffa0b 	ldhu	r2,-24(fp)
8113c6e8:	100690fa 	slli	r3,r2,3
8113c6ec:	00a045b4 	movhi	r2,33046
8113c6f0:	10818a04 	addi	r2,r2,1576
8113c6f4:	1885883a 	add	r2,r3,r2
8113c6f8:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
8113c6fc:	e0bffb17 	ldw	r2,-20(fp)
8113c700:	10800017 	ldw	r2,0(r2)
8113c704:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8113c708:	00002206 	br	8113c794 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
8113c70c:	e0bff917 	ldw	r2,-28(fp)
8113c710:	10800317 	ldw	r2,12(r2)
8113c714:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8113c718:	e0bff917 	ldw	r2,-28(fp)
8113c71c:	10c00517 	ldw	r3,20(r2)
8113c720:	d0a09d17 	ldw	r2,-32140(gp)
8113c724:	1880191e 	bne	r3,r2,8113c78c <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8113c728:	e0bff917 	ldw	r2,-28(fp)
8113c72c:	10800117 	ldw	r2,4(r2)
8113c730:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8113c734:	e0bffd17 	ldw	r2,-12(fp)
8113c738:	10000626 	beq	r2,zero,8113c754 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
8113c73c:	e0bff917 	ldw	r2,-28(fp)
8113c740:	10c00217 	ldw	r3,8(r2)
8113c744:	e0bffd17 	ldw	r2,-12(fp)
8113c748:	180b883a 	mov	r5,r3
8113c74c:	e13ff917 	ldw	r4,-28(fp)
8113c750:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8113c754:	e13ff917 	ldw	r4,-28(fp)
8113c758:	113c5180 	call	8113c518 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
8113c75c:	e0bff917 	ldw	r2,-28(fp)
8113c760:	10800c03 	ldbu	r2,48(r2)
8113c764:	10803fcc 	andi	r2,r2,255
8113c768:	10800098 	cmpnei	r2,r2,2
8113c76c:	1000041e 	bne	r2,zero,8113c780 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8113c770:	01400044 	movi	r5,1
8113c774:	e13ff917 	ldw	r4,-28(fp)
8113c778:	113c3c80 	call	8113c3c8 <OSTmr_Link>
8113c77c:	00000306 	br	8113c78c <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8113c780:	e0bff917 	ldw	r2,-28(fp)
8113c784:	00c00084 	movi	r3,2
8113c788:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
8113c78c:	e0bffc17 	ldw	r2,-16(fp)
8113c790:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8113c794:	e0bff917 	ldw	r2,-28(fp)
8113c798:	103fdc1e 	bne	r2,zero,8113c70c <__reset+0xfb11c70c>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
8113c79c:	113c6580 	call	8113c658 <OSTmr_Unlock>
    }
8113c7a0:	003fc306 	br	8113c6b0 <__reset+0xfb11c6b0>

8113c7a4 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
8113c7a4:	defffd04 	addi	sp,sp,-12
8113c7a8:	de00012e 	bgeu	sp,et,8113c7b0 <alt_dev_reg+0xc>
8113c7ac:	003b68fa 	trap	3
8113c7b0:	dfc00215 	stw	ra,8(sp)
8113c7b4:	df000115 	stw	fp,4(sp)
8113c7b8:	df000104 	addi	fp,sp,4
8113c7bc:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8113c7c0:	d1600d04 	addi	r5,gp,-32716
8113c7c4:	e13fff17 	ldw	r4,-4(fp)
8113c7c8:	1144a440 	call	81144a44 <alt_dev_llist_insert>
}
8113c7cc:	e037883a 	mov	sp,fp
8113c7d0:	dfc00117 	ldw	ra,4(sp)
8113c7d4:	df000017 	ldw	fp,0(sp)
8113c7d8:	dec00204 	addi	sp,sp,8
8113c7dc:	f800283a 	ret

8113c7e0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8113c7e0:	defffd04 	addi	sp,sp,-12
8113c7e4:	de00012e 	bgeu	sp,et,8113c7ec <alt_irq_init+0xc>
8113c7e8:	003b68fa 	trap	3
8113c7ec:	dfc00215 	stw	ra,8(sp)
8113c7f0:	df000115 	stw	fp,4(sp)
8113c7f4:	df000104 	addi	fp,sp,4
8113c7f8:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8113c7fc:	114540c0 	call	8114540c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8113c800:	00800044 	movi	r2,1
8113c804:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8113c808:	0001883a 	nop
8113c80c:	e037883a 	mov	sp,fp
8113c810:	dfc00117 	ldw	ra,4(sp)
8113c814:	df000017 	ldw	fp,0(sp)
8113c818:	dec00204 	addi	sp,sp,8
8113c81c:	f800283a 	ret

8113c820 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8113c820:	defffe04 	addi	sp,sp,-8
8113c824:	de00012e 	bgeu	sp,et,8113c82c <alt_sys_init+0xc>
8113c828:	003b68fa 	trap	3
8113c82c:	dfc00115 	stw	ra,4(sp)
8113c830:	df000015 	stw	fp,0(sp)
8113c834:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8113c838:	01c0fa04 	movi	r7,1000
8113c83c:	01800304 	movi	r6,12
8113c840:	000b883a 	mov	r5,zero
8113c844:	01200034 	movhi	r4,32768
8113c848:	21022004 	addi	r4,r4,2176
8113c84c:	1141b780 	call	81141b78 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
8113c850:	018002c4 	movi	r6,11
8113c854:	000b883a 	mov	r5,zero
8113c858:	01204574 	movhi	r4,33045
8113c85c:	212ec704 	addi	r4,r4,-17636
8113c860:	1140e640 	call	81140e64 <altera_avalon_jtag_uart_init>
8113c864:	01204574 	movhi	r4,33045
8113c868:	212ebd04 	addi	r4,r4,-17676
8113c86c:	113c7a40 	call	8113c7a4 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
8113c870:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
8113c874:	018003c4 	movi	r6,15
8113c878:	000b883a 	mov	r5,zero
8113c87c:	01204574 	movhi	r4,33045
8113c880:	2132e204 	addi	r4,r4,-13432
8113c884:	1141d240 	call	81141d24 <altera_avalon_uart_init>
8113c888:	01204574 	movhi	r4,33045
8113c88c:	2132d804 	addi	r4,r4,-13472
8113c890:	113c7a40 	call	8113c7a4 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
8113c894:	00a04574 	movhi	r2,33045
8113c898:	10b30c04 	addi	r2,r2,-13264
8113c89c:	10c00717 	ldw	r3,28(r2)
8113c8a0:	00a04574 	movhi	r2,33045
8113c8a4:	10b30c04 	addi	r2,r2,-13264
8113c8a8:	10800817 	ldw	r2,32(r2)
8113c8ac:	100d883a 	mov	r6,r2
8113c8b0:	180b883a 	mov	r5,r3
8113c8b4:	01204574 	movhi	r4,33045
8113c8b8:	21330c04 	addi	r4,r4,-13264
8113c8bc:	11445ac0 	call	811445ac <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8113c8c0:	00a04574 	movhi	r2,33045
8113c8c4:	10b32504 	addi	r2,r2,-13164
8113c8c8:	10c00717 	ldw	r3,28(r2)
8113c8cc:	00a04574 	movhi	r2,33045
8113c8d0:	10b32504 	addi	r2,r2,-13164
8113c8d4:	10800817 	ldw	r2,32(r2)
8113c8d8:	100d883a 	mov	r6,r2
8113c8dc:	180b883a 	mov	r5,r3
8113c8e0:	01204574 	movhi	r4,33045
8113c8e4:	21332504 	addi	r4,r4,-13164
8113c8e8:	11445ac0 	call	811445ac <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8113c8ec:	01204574 	movhi	r4,33045
8113c8f0:	21333e04 	addi	r4,r4,-13064
8113c8f4:	113c7a40 	call	8113c7a4 <alt_dev_reg>
}
8113c8f8:	0001883a 	nop
8113c8fc:	e037883a 	mov	sp,fp
8113c900:	dfc00117 	ldw	ra,4(sp)
8113c904:	df000017 	ldw	fp,0(sp)
8113c908:	dec00204 	addi	sp,sp,8
8113c90c:	f800283a 	ret

8113c910 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8113c910:	defffa04 	addi	sp,sp,-24
8113c914:	de00012e 	bgeu	sp,et,8113c91c <Write_Sector_Data+0xc>
8113c918:	003b68fa 	trap	3
8113c91c:	dfc00515 	stw	ra,20(sp)
8113c920:	df000415 	stw	fp,16(sp)
8113c924:	df000404 	addi	fp,sp,16
8113c928:	e13ffe15 	stw	r4,-8(fp)
8113c92c:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113c930:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
8113c934:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
8113c938:	10001e26 	beq	r2,zero,8113c9b4 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8113c93c:	00803fc4 	movi	r2,255
8113c940:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113c944:	d0a0a917 	ldw	r2,-32092(gp)
8113c948:	e13ffe17 	ldw	r4,-8(fp)
8113c94c:	e0ffff17 	ldw	r3,-4(fp)
8113c950:	20c7883a 	add	r3,r4,r3
8113c954:	1806927a 	slli	r3,r3,9
8113c958:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
8113c95c:	d0a0a817 	ldw	r2,-32096(gp)
8113c960:	00c00604 	movi	r3,24
8113c964:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113c968:	d0a0a517 	ldw	r2,-32108(gp)
8113c96c:	1080002b 	ldhuio	r2,0(r2)
8113c970:	10bfffcc 	andi	r2,r2,65535
8113c974:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
8113c978:	e0bffd0b 	ldhu	r2,-12(fp)
8113c97c:	10bfffcc 	andi	r2,r2,65535
8113c980:	1080010c 	andi	r2,r2,4
8113c984:	103ff81e 	bne	r2,zero,8113c968 <__reset+0xfb11c968>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
8113c988:	e0bffd0b 	ldhu	r2,-12(fp)
8113c98c:	10bfffcc 	andi	r2,r2,65535
8113c990:	1080040c 	andi	r2,r2,16
8113c994:	1000071e 	bne	r2,zero,8113c9b4 <Write_Sector_Data+0xa4>
        {
            result = true;
8113c998:	00800044 	movi	r2,1
8113c99c:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113c9a0:	d020ae15 	stw	zero,-32072(gp)
            current_sector_index = sector_index+partition_offset;
8113c9a4:	e0fffe17 	ldw	r3,-8(fp)
8113c9a8:	e0bfff17 	ldw	r2,-4(fp)
8113c9ac:	1885883a 	add	r2,r3,r2
8113c9b0:	d0a0af15 	stw	r2,-32068(gp)
        }
    }
    return result;
8113c9b4:	e0bffc17 	ldw	r2,-16(fp)
}
8113c9b8:	e037883a 	mov	sp,fp
8113c9bc:	dfc00117 	ldw	ra,4(sp)
8113c9c0:	df000017 	ldw	fp,0(sp)
8113c9c4:	dec00204 	addi	sp,sp,8
8113c9c8:	f800283a 	ret

8113c9cc <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8113c9cc:	defffd04 	addi	sp,sp,-12
8113c9d0:	de00012e 	bgeu	sp,et,8113c9d8 <Save_Modified_Sector+0xc>
8113c9d4:	003b68fa 	trap	3
8113c9d8:	dfc00215 	stw	ra,8(sp)
8113c9dc:	df000115 	stw	fp,4(sp)
8113c9e0:	df000104 	addi	fp,sp,4
    bool result = true;
8113c9e4:	00800044 	movi	r2,1
8113c9e8:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8113c9ec:	d0a0ae17 	ldw	r2,-32072(gp)
8113c9f0:	10000526 	beq	r2,zero,8113ca08 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
8113c9f4:	d0a0af17 	ldw	r2,-32068(gp)
8113c9f8:	000b883a 	mov	r5,zero
8113c9fc:	1009883a 	mov	r4,r2
8113ca00:	113c9100 	call	8113c910 <Write_Sector_Data>
8113ca04:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8113ca08:	e0bfff17 	ldw	r2,-4(fp)
}
8113ca0c:	e037883a 	mov	sp,fp
8113ca10:	dfc00117 	ldw	ra,4(sp)
8113ca14:	df000017 	ldw	fp,0(sp)
8113ca18:	dec00204 	addi	sp,sp,8
8113ca1c:	f800283a 	ret

8113ca20 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8113ca20:	defffa04 	addi	sp,sp,-24
8113ca24:	de00012e 	bgeu	sp,et,8113ca2c <Read_Sector_Data+0xc>
8113ca28:	003b68fa 	trap	3
8113ca2c:	dfc00515 	stw	ra,20(sp)
8113ca30:	df000415 	stw	fp,16(sp)
8113ca34:	df000404 	addi	fp,sp,16
8113ca38:	e13ffe15 	stw	r4,-8(fp)
8113ca3c:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
8113ca40:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
8113ca44:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
8113ca48:	10002726 	beq	r2,zero,8113cae8 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
8113ca4c:	00803fc4 	movi	r2,255
8113ca50:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
8113ca54:	d0a0ae17 	ldw	r2,-32072(gp)
8113ca58:	10000726 	beq	r2,zero,8113ca78 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
8113ca5c:	d0a0af17 	ldw	r2,-32068(gp)
8113ca60:	000b883a 	mov	r5,zero
8113ca64:	1009883a 	mov	r4,r2
8113ca68:	113c9100 	call	8113c910 <Write_Sector_Data>
8113ca6c:	1000021e 	bne	r2,zero,8113ca78 <Read_Sector_Data+0x58>
            {
                return false;
8113ca70:	0005883a 	mov	r2,zero
8113ca74:	00001d06 	br	8113caec <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113ca78:	d0a0a917 	ldw	r2,-32092(gp)
8113ca7c:	e13ffe17 	ldw	r4,-8(fp)
8113ca80:	e0ffff17 	ldw	r3,-4(fp)
8113ca84:	20c7883a 	add	r3,r4,r3
8113ca88:	1806927a 	slli	r3,r3,9
8113ca8c:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8113ca90:	d0a0a817 	ldw	r2,-32096(gp)
8113ca94:	00c00444 	movi	r3,17
8113ca98:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113ca9c:	d0a0a517 	ldw	r2,-32108(gp)
8113caa0:	1080002b 	ldhuio	r2,0(r2)
8113caa4:	10bfffcc 	andi	r2,r2,65535
8113caa8:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8113caac:	e0bffd0b 	ldhu	r2,-12(fp)
8113cab0:	10bfffcc 	andi	r2,r2,65535
8113cab4:	1080010c 	andi	r2,r2,4
8113cab8:	103ff81e 	bne	r2,zero,8113ca9c <__reset+0xfb11ca9c>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8113cabc:	e0bffd0b 	ldhu	r2,-12(fp)
8113cac0:	10bfffcc 	andi	r2,r2,65535
8113cac4:	1080040c 	andi	r2,r2,16
8113cac8:	1000071e 	bne	r2,zero,8113cae8 <Read_Sector_Data+0xc8>
		{
			result = true;
8113cacc:	00800044 	movi	r2,1
8113cad0:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113cad4:	d020ae15 	stw	zero,-32072(gp)
            current_sector_index = sector_index+partition_offset;
8113cad8:	e0fffe17 	ldw	r3,-8(fp)
8113cadc:	e0bfff17 	ldw	r2,-4(fp)
8113cae0:	1885883a 	add	r2,r3,r2
8113cae4:	d0a0af15 	stw	r2,-32068(gp)
		}
	}
	return result;
8113cae8:	e0bffc17 	ldw	r2,-16(fp)
}
8113caec:	e037883a 	mov	sp,fp
8113caf0:	dfc00117 	ldw	ra,4(sp)
8113caf4:	df000017 	ldw	fp,0(sp)
8113caf8:	dec00204 	addi	sp,sp,8
8113cafc:	f800283a 	ret

8113cb00 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8113cb00:	defffb04 	addi	sp,sp,-20
8113cb04:	de00012e 	bgeu	sp,et,8113cb0c <get_cluster_flag+0xc>
8113cb08:	003b68fa 	trap	3
8113cb0c:	dfc00415 	stw	ra,16(sp)
8113cb10:	df000315 	stw	fp,12(sp)
8113cb14:	df000304 	addi	fp,sp,12
8113cb18:	e13ffe15 	stw	r4,-8(fp)
8113cb1c:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8113cb20:	e0bffe17 	ldw	r2,-8(fp)
8113cb24:	1004d23a 	srli	r2,r2,8
8113cb28:	d0e0ab17 	ldw	r3,-32084(gp)
8113cb2c:	10c5883a 	add	r2,r2,r3
8113cb30:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113cb34:	00a045b4 	movhi	r2,33046
8113cb38:	1097c604 	addi	r2,r2,24344
8113cb3c:	10801117 	ldw	r2,68(r2)
8113cb40:	e0fffd17 	ldw	r3,-12(fp)
8113cb44:	1885883a 	add	r2,r3,r2
8113cb48:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
8113cb4c:	d0a0af17 	ldw	r2,-32068(gp)
8113cb50:	e0fffd17 	ldw	r3,-12(fp)
8113cb54:	18800726 	beq	r3,r2,8113cb74 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113cb58:	e0bffd17 	ldw	r2,-12(fp)
8113cb5c:	000b883a 	mov	r5,zero
8113cb60:	1009883a 	mov	r4,r2
8113cb64:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113cb68:	1000021e 	bne	r2,zero,8113cb74 <get_cluster_flag+0x74>
        {
            return false;
8113cb6c:	0005883a 	mov	r2,zero
8113cb70:	00000d06 	br	8113cba8 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
8113cb74:	e0bffe17 	ldw	r2,-8(fp)
8113cb78:	10803fcc 	andi	r2,r2,255
8113cb7c:	1085883a 	add	r2,r2,r2
8113cb80:	1007883a 	mov	r3,r2
8113cb84:	d0a0ad17 	ldw	r2,-32076(gp)
8113cb88:	10800a17 	ldw	r2,40(r2)
8113cb8c:	1885883a 	add	r2,r3,r2
8113cb90:	1080002b 	ldhuio	r2,0(r2)
8113cb94:	10bfffcc 	andi	r2,r2,65535
8113cb98:	1007883a 	mov	r3,r2
8113cb9c:	e0bfff17 	ldw	r2,-4(fp)
8113cba0:	10c0000d 	sth	r3,0(r2)
    return true;
8113cba4:	00800044 	movi	r2,1
}
8113cba8:	e037883a 	mov	sp,fp
8113cbac:	dfc00117 	ldw	ra,4(sp)
8113cbb0:	df000017 	ldw	fp,0(sp)
8113cbb4:	dec00204 	addi	sp,sp,8
8113cbb8:	f800283a 	ret

8113cbbc <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8113cbbc:	defffa04 	addi	sp,sp,-24
8113cbc0:	de00012e 	bgeu	sp,et,8113cbc8 <mark_cluster+0xc>
8113cbc4:	003b68fa 	trap	3
8113cbc8:	dfc00515 	stw	ra,20(sp)
8113cbcc:	df000415 	stw	fp,16(sp)
8113cbd0:	df000404 	addi	fp,sp,16
8113cbd4:	e13ffd15 	stw	r4,-12(fp)
8113cbd8:	2805883a 	mov	r2,r5
8113cbdc:	e1bfff15 	stw	r6,-4(fp)
8113cbe0:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
8113cbe4:	e0bffd17 	ldw	r2,-12(fp)
8113cbe8:	1004d23a 	srli	r2,r2,8
8113cbec:	d0e0ab17 	ldw	r3,-32084(gp)
8113cbf0:	10c5883a 	add	r2,r2,r3
8113cbf4:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8113cbf8:	e0bfff17 	ldw	r2,-4(fp)
8113cbfc:	10000726 	beq	r2,zero,8113cc1c <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113cc00:	00a045b4 	movhi	r2,33046
8113cc04:	1097c604 	addi	r2,r2,24344
8113cc08:	10801117 	ldw	r2,68(r2)
8113cc0c:	e0fffc17 	ldw	r3,-16(fp)
8113cc10:	1885883a 	add	r2,r3,r2
8113cc14:	e0bffc15 	stw	r2,-16(fp)
8113cc18:	00000606 	br	8113cc34 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8113cc1c:	00a045b4 	movhi	r2,33046
8113cc20:	1097c604 	addi	r2,r2,24344
8113cc24:	10801217 	ldw	r2,72(r2)
8113cc28:	e0fffc17 	ldw	r3,-16(fp)
8113cc2c:	1885883a 	add	r2,r3,r2
8113cc30:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
8113cc34:	d0a0af17 	ldw	r2,-32068(gp)
8113cc38:	e0fffc17 	ldw	r3,-16(fp)
8113cc3c:	18800726 	beq	r3,r2,8113cc5c <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113cc40:	e0bffc17 	ldw	r2,-16(fp)
8113cc44:	000b883a 	mov	r5,zero
8113cc48:	1009883a 	mov	r4,r2
8113cc4c:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113cc50:	1000021e 	bne	r2,zero,8113cc5c <mark_cluster+0xa0>
        {
            return false;
8113cc54:	0005883a 	mov	r2,zero
8113cc58:	00000d06 	br	8113cc90 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
8113cc5c:	e0bffd17 	ldw	r2,-12(fp)
8113cc60:	10803fcc 	andi	r2,r2,255
8113cc64:	1085883a 	add	r2,r2,r2
8113cc68:	1007883a 	mov	r3,r2
8113cc6c:	d0a0ad17 	ldw	r2,-32076(gp)
8113cc70:	10800a17 	ldw	r2,40(r2)
8113cc74:	1885883a 	add	r2,r3,r2
8113cc78:	1007883a 	mov	r3,r2
8113cc7c:	e0bffe0f 	ldh	r2,-8(fp)
8113cc80:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
8113cc84:	00800044 	movi	r2,1
8113cc88:	d0a0ae15 	stw	r2,-32072(gp)
    return true;
8113cc8c:	00800044 	movi	r2,1
}
8113cc90:	e037883a 	mov	sp,fp
8113cc94:	dfc00117 	ldw	ra,4(sp)
8113cc98:	df000017 	ldw	fp,0(sp)
8113cc9c:	dec00204 	addi	sp,sp,8
8113cca0:	f800283a 	ret

8113cca4 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
8113cca4:	defff704 	addi	sp,sp,-36
8113cca8:	de00012e 	bgeu	sp,et,8113ccb0 <Check_for_Master_Boot_Record+0xc>
8113ccac:	003b68fa 	trap	3
8113ccb0:	dfc00815 	stw	ra,32(sp)
8113ccb4:	df000715 	stw	fp,28(sp)
8113ccb8:	df000704 	addi	fp,sp,28
	bool result = false;
8113ccbc:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8113ccc0:	000b883a 	mov	r5,zero
8113ccc4:	0009883a 	mov	r4,zero
8113ccc8:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113cccc:	10005a26 	beq	r2,zero,8113ce38 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8113ccd0:	d0a0ad17 	ldw	r2,-32076(gp)
8113ccd4:	10800a17 	ldw	r2,40(r2)
8113ccd8:	10807f84 	addi	r2,r2,510
8113ccdc:	1080002b 	ldhuio	r2,0(r2)
8113cce0:	10bfffcc 	andi	r2,r2,65535
8113cce4:	10bfffcc 	andi	r2,r2,65535
8113cce8:	10a0001c 	xori	r2,r2,32768
8113ccec:	10a00004 	addi	r2,r2,-32768
8113ccf0:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
8113ccf4:	e0bffb17 	ldw	r2,-20(fp)
8113ccf8:	10ffffcc 	andi	r3,r2,65535
8113ccfc:	00aa9554 	movui	r2,43605
8113cd00:	18804d1e 	bne	r3,r2,8113ce38 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113cd04:	e03ffa15 	stw	zero,-24(fp)
8113cd08:	00004806 	br	8113ce2c <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8113cd0c:	e0bffa17 	ldw	r2,-24(fp)
8113cd10:	1004913a 	slli	r2,r2,4
8113cd14:	10806f84 	addi	r2,r2,446
8113cd18:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8113cd1c:	d0a0ad17 	ldw	r2,-32076(gp)
8113cd20:	10c00a17 	ldw	r3,40(r2)
8113cd24:	e0bffc17 	ldw	r2,-16(fp)
8113cd28:	1885883a 	add	r2,r3,r2
8113cd2c:	10800104 	addi	r2,r2,4
8113cd30:	10800023 	ldbuio	r2,0(r2)
8113cd34:	10803fcc 	andi	r2,r2,255
8113cd38:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8113cd3c:	e0bffd07 	ldb	r2,-12(fp)
8113cd40:	10800060 	cmpeqi	r2,r2,1
8113cd44:	1000091e 	bne	r2,zero,8113cd6c <Check_for_Master_Boot_Record+0xc8>
8113cd48:	e0bffd07 	ldb	r2,-12(fp)
8113cd4c:	10800120 	cmpeqi	r2,r2,4
8113cd50:	1000061e 	bne	r2,zero,8113cd6c <Check_for_Master_Boot_Record+0xc8>
8113cd54:	e0bffd07 	ldb	r2,-12(fp)
8113cd58:	108001a0 	cmpeqi	r2,r2,6
8113cd5c:	1000031e 	bne	r2,zero,8113cd6c <Check_for_Master_Boot_Record+0xc8>
8113cd60:	e0bffd07 	ldb	r2,-12(fp)
8113cd64:	10800398 	cmpnei	r2,r2,14
8113cd68:	10002d1e 	bne	r2,zero,8113ce20 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
8113cd6c:	d0a0ad17 	ldw	r2,-32076(gp)
8113cd70:	10c00a17 	ldw	r3,40(r2)
8113cd74:	e0bffc17 	ldw	r2,-16(fp)
8113cd78:	1885883a 	add	r2,r3,r2
8113cd7c:	10800284 	addi	r2,r2,10
8113cd80:	1080002b 	ldhuio	r2,0(r2)
8113cd84:	10bfffcc 	andi	r2,r2,65535
8113cd88:	1006943a 	slli	r3,r2,16
8113cd8c:	d0a0ad17 	ldw	r2,-32076(gp)
8113cd90:	11000a17 	ldw	r4,40(r2)
8113cd94:	e0bffc17 	ldw	r2,-16(fp)
8113cd98:	2085883a 	add	r2,r4,r2
8113cd9c:	10800204 	addi	r2,r2,8
8113cda0:	1080002b 	ldhuio	r2,0(r2)
8113cda4:	10bfffcc 	andi	r2,r2,65535
8113cda8:	10bfffcc 	andi	r2,r2,65535
8113cdac:	1884b03a 	or	r2,r3,r2
8113cdb0:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
8113cdb4:	d0a0ad17 	ldw	r2,-32076(gp)
8113cdb8:	10c00a17 	ldw	r3,40(r2)
8113cdbc:	e0bffc17 	ldw	r2,-16(fp)
8113cdc0:	1885883a 	add	r2,r3,r2
8113cdc4:	10800384 	addi	r2,r2,14
8113cdc8:	1080002b 	ldhuio	r2,0(r2)
8113cdcc:	10bfffcc 	andi	r2,r2,65535
8113cdd0:	1006943a 	slli	r3,r2,16
8113cdd4:	d0a0ad17 	ldw	r2,-32076(gp)
8113cdd8:	11000a17 	ldw	r4,40(r2)
8113cddc:	e0bffc17 	ldw	r2,-16(fp)
8113cde0:	2085883a 	add	r2,r4,r2
8113cde4:	10800304 	addi	r2,r2,12
8113cde8:	1080002b 	ldhuio	r2,0(r2)
8113cdec:	10bfffcc 	andi	r2,r2,65535
8113cdf0:	10bfffcc 	andi	r2,r2,65535
8113cdf4:	1884b03a 	or	r2,r3,r2
8113cdf8:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8113cdfc:	e0bfff17 	ldw	r2,-4(fp)
8113ce00:	0080070e 	bge	zero,r2,8113ce20 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
8113ce04:	00800044 	movi	r2,1
8113ce08:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8113ce0c:	e0bfff17 	ldw	r2,-4(fp)
8113ce10:	d0a0ac15 	stw	r2,-32080(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
8113ce14:	e0bffe17 	ldw	r2,-8(fp)
8113ce18:	d0a0ab15 	stw	r2,-32084(gp)
						break;
8113ce1c:	00000606 	br	8113ce38 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113ce20:	e0bffa17 	ldw	r2,-24(fp)
8113ce24:	10800044 	addi	r2,r2,1
8113ce28:	e0bffa15 	stw	r2,-24(fp)
8113ce2c:	e0bffa17 	ldw	r2,-24(fp)
8113ce30:	10800110 	cmplti	r2,r2,4
8113ce34:	103fb51e 	bne	r2,zero,8113cd0c <__reset+0xfb11cd0c>
				}
			}
		}
	}

	return result;
8113ce38:	e0bff917 	ldw	r2,-28(fp)
}
8113ce3c:	e037883a 	mov	sp,fp
8113ce40:	dfc00117 	ldw	ra,4(sp)
8113ce44:	df000017 	ldw	fp,0(sp)
8113ce48:	dec00204 	addi	sp,sp,8
8113ce4c:	f800283a 	ret

8113ce50 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
8113ce50:	defff804 	addi	sp,sp,-32
8113ce54:	de00012e 	bgeu	sp,et,8113ce5c <Read_File_Record_At_Offset+0xc>
8113ce58:	003b68fa 	trap	3
8113ce5c:	dfc00715 	stw	ra,28(sp)
8113ce60:	df000615 	stw	fp,24(sp)
8113ce64:	df000604 	addi	fp,sp,24
8113ce68:	e13ffc15 	stw	r4,-16(fp)
8113ce6c:	e17ffd15 	stw	r5,-12(fp)
8113ce70:	e1bffe15 	stw	r6,-8(fp)
8113ce74:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8113ce78:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113ce7c:	e0bffc17 	ldw	r2,-16(fp)
8113ce80:	108007cc 	andi	r2,r2,31
8113ce84:	10008d1e 	bne	r2,zero,8113d0bc <Read_File_Record_At_Offset+0x26c>
8113ce88:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
8113ce8c:	10008b26 	beq	r2,zero,8113d0bc <Read_File_Record_At_Offset+0x26c>
8113ce90:	d0a0a417 	ldw	r2,-32112(gp)
8113ce94:	10008926 	beq	r2,zero,8113d0bc <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113ce98:	e03ffb15 	stw	zero,-20(fp)
8113ce9c:	00001106 	br	8113cee4 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
8113cea0:	e0fffc17 	ldw	r3,-16(fp)
8113cea4:	e0bffb17 	ldw	r2,-20(fp)
8113cea8:	1885883a 	add	r2,r3,r2
8113ceac:	1007883a 	mov	r3,r2
8113ceb0:	d0a0ad17 	ldw	r2,-32076(gp)
8113ceb4:	10800a17 	ldw	r2,40(r2)
8113ceb8:	1885883a 	add	r2,r3,r2
8113cebc:	10800023 	ldbuio	r2,0(r2)
8113cec0:	10803fcc 	andi	r2,r2,255
8113cec4:	1009883a 	mov	r4,r2
8113cec8:	e0fffd17 	ldw	r3,-12(fp)
8113cecc:	e0bffb17 	ldw	r2,-20(fp)
8113ced0:	1885883a 	add	r2,r3,r2
8113ced4:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113ced8:	e0bffb17 	ldw	r2,-20(fp)
8113cedc:	10800044 	addi	r2,r2,1
8113cee0:	e0bffb15 	stw	r2,-20(fp)
8113cee4:	e0bffb17 	ldw	r2,-20(fp)
8113cee8:	10800210 	cmplti	r2,r2,8
8113ceec:	103fec1e 	bne	r2,zero,8113cea0 <__reset+0xfb11cea0>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113cef0:	e03ffb15 	stw	zero,-20(fp)
8113cef4:	00001306 	br	8113cf44 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8113cef8:	e0fffc17 	ldw	r3,-16(fp)
8113cefc:	e0bffb17 	ldw	r2,-20(fp)
8113cf00:	1885883a 	add	r2,r3,r2
8113cf04:	1007883a 	mov	r3,r2
8113cf08:	d0a0ad17 	ldw	r2,-32076(gp)
8113cf0c:	10800a17 	ldw	r2,40(r2)
8113cf10:	1885883a 	add	r2,r3,r2
8113cf14:	10800204 	addi	r2,r2,8
8113cf18:	10800023 	ldbuio	r2,0(r2)
8113cf1c:	10803fcc 	andi	r2,r2,255
8113cf20:	1009883a 	mov	r4,r2
8113cf24:	e0fffd17 	ldw	r3,-12(fp)
8113cf28:	e0bffb17 	ldw	r2,-20(fp)
8113cf2c:	1885883a 	add	r2,r3,r2
8113cf30:	10800204 	addi	r2,r2,8
8113cf34:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113cf38:	e0bffb17 	ldw	r2,-20(fp)
8113cf3c:	10800044 	addi	r2,r2,1
8113cf40:	e0bffb15 	stw	r2,-20(fp)
8113cf44:	e0bffb17 	ldw	r2,-20(fp)
8113cf48:	108000d0 	cmplti	r2,r2,3
8113cf4c:	103fea1e 	bne	r2,zero,8113cef8 <__reset+0xfb11cef8>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
8113cf50:	d0a0ad17 	ldw	r2,-32076(gp)
8113cf54:	10c00a17 	ldw	r3,40(r2)
8113cf58:	e0bffc17 	ldw	r2,-16(fp)
8113cf5c:	1885883a 	add	r2,r3,r2
8113cf60:	108002c4 	addi	r2,r2,11
8113cf64:	10800023 	ldbuio	r2,0(r2)
8113cf68:	10803fcc 	andi	r2,r2,255
8113cf6c:	1007883a 	mov	r3,r2
8113cf70:	e0bffd17 	ldw	r2,-12(fp)
8113cf74:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8113cf78:	d0a0ad17 	ldw	r2,-32076(gp)
8113cf7c:	10c00a17 	ldw	r3,40(r2)
8113cf80:	e0bffc17 	ldw	r2,-16(fp)
8113cf84:	1885883a 	add	r2,r3,r2
8113cf88:	10800384 	addi	r2,r2,14
8113cf8c:	1080002b 	ldhuio	r2,0(r2)
8113cf90:	10bfffcc 	andi	r2,r2,65535
8113cf94:	1007883a 	mov	r3,r2
8113cf98:	e0bffd17 	ldw	r2,-12(fp)
8113cf9c:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
8113cfa0:	d0a0ad17 	ldw	r2,-32076(gp)
8113cfa4:	10c00a17 	ldw	r3,40(r2)
8113cfa8:	e0bffc17 	ldw	r2,-16(fp)
8113cfac:	1885883a 	add	r2,r3,r2
8113cfb0:	10800404 	addi	r2,r2,16
8113cfb4:	1080002b 	ldhuio	r2,0(r2)
8113cfb8:	10bfffcc 	andi	r2,r2,65535
8113cfbc:	1007883a 	mov	r3,r2
8113cfc0:	e0bffd17 	ldw	r2,-12(fp)
8113cfc4:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8113cfc8:	d0a0ad17 	ldw	r2,-32076(gp)
8113cfcc:	10c00a17 	ldw	r3,40(r2)
8113cfd0:	e0bffc17 	ldw	r2,-16(fp)
8113cfd4:	1885883a 	add	r2,r3,r2
8113cfd8:	10800484 	addi	r2,r2,18
8113cfdc:	1080002b 	ldhuio	r2,0(r2)
8113cfe0:	10bfffcc 	andi	r2,r2,65535
8113cfe4:	1007883a 	mov	r3,r2
8113cfe8:	e0bffd17 	ldw	r2,-12(fp)
8113cfec:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
8113cff0:	d0a0ad17 	ldw	r2,-32076(gp)
8113cff4:	10c00a17 	ldw	r3,40(r2)
8113cff8:	e0bffc17 	ldw	r2,-16(fp)
8113cffc:	1885883a 	add	r2,r3,r2
8113d000:	10800584 	addi	r2,r2,22
8113d004:	1080002b 	ldhuio	r2,0(r2)
8113d008:	10bfffcc 	andi	r2,r2,65535
8113d00c:	1007883a 	mov	r3,r2
8113d010:	e0bffd17 	ldw	r2,-12(fp)
8113d014:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8113d018:	d0a0ad17 	ldw	r2,-32076(gp)
8113d01c:	10c00a17 	ldw	r3,40(r2)
8113d020:	e0bffc17 	ldw	r2,-16(fp)
8113d024:	1885883a 	add	r2,r3,r2
8113d028:	10800604 	addi	r2,r2,24
8113d02c:	1080002b 	ldhuio	r2,0(r2)
8113d030:	10bfffcc 	andi	r2,r2,65535
8113d034:	1007883a 	mov	r3,r2
8113d038:	e0bffd17 	ldw	r2,-12(fp)
8113d03c:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
8113d040:	d0a0ad17 	ldw	r2,-32076(gp)
8113d044:	10c00a17 	ldw	r3,40(r2)
8113d048:	e0bffc17 	ldw	r2,-16(fp)
8113d04c:	1885883a 	add	r2,r3,r2
8113d050:	10800684 	addi	r2,r2,26
8113d054:	1080002b 	ldhuio	r2,0(r2)
8113d058:	10bfffcc 	andi	r2,r2,65535
8113d05c:	1007883a 	mov	r3,r2
8113d060:	e0bffd17 	ldw	r2,-12(fp)
8113d064:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8113d068:	d0a0ad17 	ldw	r2,-32076(gp)
8113d06c:	10c00a17 	ldw	r3,40(r2)
8113d070:	e0bffc17 	ldw	r2,-16(fp)
8113d074:	1885883a 	add	r2,r3,r2
8113d078:	10800704 	addi	r2,r2,28
8113d07c:	10800037 	ldwio	r2,0(r2)
8113d080:	1007883a 	mov	r3,r2
8113d084:	e0bffd17 	ldw	r2,-12(fp)
8113d088:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
8113d08c:	e0bffd17 	ldw	r2,-12(fp)
8113d090:	e0fffe17 	ldw	r3,-8(fp)
8113d094:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8113d098:	e0bffd17 	ldw	r2,-12(fp)
8113d09c:	e0ffff17 	ldw	r3,-4(fp)
8113d0a0:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
8113d0a4:	e0bffc17 	ldw	r2,-16(fp)
8113d0a8:	1007883a 	mov	r3,r2
8113d0ac:	e0bffd17 	ldw	r2,-12(fp)
8113d0b0:	10c00c0d 	sth	r3,48(r2)
		result = true;
8113d0b4:	00800044 	movi	r2,1
8113d0b8:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8113d0bc:	e0bffa17 	ldw	r2,-24(fp)
}
8113d0c0:	e037883a 	mov	sp,fp
8113d0c4:	dfc00117 	ldw	ra,4(sp)
8113d0c8:	df000017 	ldw	fp,0(sp)
8113d0cc:	dec00204 	addi	sp,sp,8
8113d0d0:	f800283a 	ret

8113d0d4 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
8113d0d4:	defff904 	addi	sp,sp,-28
8113d0d8:	de00012e 	bgeu	sp,et,8113d0e0 <Write_File_Record_At_Offset+0xc>
8113d0dc:	003b68fa 	trap	3
8113d0e0:	dfc00615 	stw	ra,24(sp)
8113d0e4:	df000515 	stw	fp,20(sp)
8113d0e8:	df000504 	addi	fp,sp,20
8113d0ec:	e13ffe15 	stw	r4,-8(fp)
8113d0f0:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113d0f4:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113d0f8:	e0bffe17 	ldw	r2,-8(fp)
8113d0fc:	108007cc 	andi	r2,r2,31
8113d100:	1000931e 	bne	r2,zero,8113d350 <Write_File_Record_At_Offset+0x27c>
8113d104:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
8113d108:	10009126 	beq	r2,zero,8113d350 <Write_File_Record_At_Offset+0x27c>
8113d10c:	d0a0a417 	ldw	r2,-32112(gp)
8113d110:	10008f26 	beq	r2,zero,8113d350 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113d114:	e03ffc15 	stw	zero,-16(fp)
8113d118:	00001f06 	br	8113d198 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8113d11c:	e0bffc17 	ldw	r2,-16(fp)
8113d120:	10800044 	addi	r2,r2,1
8113d124:	e0ffff17 	ldw	r3,-4(fp)
8113d128:	1885883a 	add	r2,r3,r2
8113d12c:	10800003 	ldbu	r2,0(r2)
8113d130:	10803fcc 	andi	r2,r2,255
8113d134:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8113d138:	e0bffd0f 	ldh	r2,-12(fp)
8113d13c:	1004923a 	slli	r2,r2,8
8113d140:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
8113d144:	e0ffff17 	ldw	r3,-4(fp)
8113d148:	e0bffc17 	ldw	r2,-16(fp)
8113d14c:	1885883a 	add	r2,r3,r2
8113d150:	10800003 	ldbu	r2,0(r2)
8113d154:	10c03fcc 	andi	r3,r2,255
8113d158:	e0bffd0b 	ldhu	r2,-12(fp)
8113d15c:	1884b03a 	or	r2,r3,r2
8113d160:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
8113d164:	e0fffe17 	ldw	r3,-8(fp)
8113d168:	e0bffc17 	ldw	r2,-16(fp)
8113d16c:	1885883a 	add	r2,r3,r2
8113d170:	1007883a 	mov	r3,r2
8113d174:	d0a0ad17 	ldw	r2,-32076(gp)
8113d178:	10800a17 	ldw	r2,40(r2)
8113d17c:	1885883a 	add	r2,r3,r2
8113d180:	1007883a 	mov	r3,r2
8113d184:	e0bffd0f 	ldh	r2,-12(fp)
8113d188:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113d18c:	e0bffc17 	ldw	r2,-16(fp)
8113d190:	10800084 	addi	r2,r2,2
8113d194:	e0bffc15 	stw	r2,-16(fp)
8113d198:	e0bffc17 	ldw	r2,-16(fp)
8113d19c:	10800210 	cmplti	r2,r2,8
8113d1a0:	103fde1e 	bne	r2,zero,8113d11c <__reset+0xfb11d11c>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113d1a4:	e03ffc15 	stw	zero,-16(fp)
8113d1a8:	00001306 	br	8113d1f8 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
8113d1ac:	e0fffe17 	ldw	r3,-8(fp)
8113d1b0:	e0bffc17 	ldw	r2,-16(fp)
8113d1b4:	1885883a 	add	r2,r3,r2
8113d1b8:	1007883a 	mov	r3,r2
8113d1bc:	d0a0ad17 	ldw	r2,-32076(gp)
8113d1c0:	10800a17 	ldw	r2,40(r2)
8113d1c4:	1885883a 	add	r2,r3,r2
8113d1c8:	10800204 	addi	r2,r2,8
8113d1cc:	1009883a 	mov	r4,r2
8113d1d0:	e0ffff17 	ldw	r3,-4(fp)
8113d1d4:	e0bffc17 	ldw	r2,-16(fp)
8113d1d8:	1885883a 	add	r2,r3,r2
8113d1dc:	10800204 	addi	r2,r2,8
8113d1e0:	10800003 	ldbu	r2,0(r2)
8113d1e4:	10803fcc 	andi	r2,r2,255
8113d1e8:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113d1ec:	e0bffc17 	ldw	r2,-16(fp)
8113d1f0:	10800044 	addi	r2,r2,1
8113d1f4:	e0bffc15 	stw	r2,-16(fp)
8113d1f8:	e0bffc17 	ldw	r2,-16(fp)
8113d1fc:	108000d0 	cmplti	r2,r2,3
8113d200:	103fea1e 	bne	r2,zero,8113d1ac <__reset+0xfb11d1ac>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
8113d204:	d0a0ad17 	ldw	r2,-32076(gp)
8113d208:	10c00a17 	ldw	r3,40(r2)
8113d20c:	e0bffe17 	ldw	r2,-8(fp)
8113d210:	1885883a 	add	r2,r3,r2
8113d214:	108002c4 	addi	r2,r2,11
8113d218:	1007883a 	mov	r3,r2
8113d21c:	e0bfff17 	ldw	r2,-4(fp)
8113d220:	108002c3 	ldbu	r2,11(r2)
8113d224:	10803fcc 	andi	r2,r2,255
8113d228:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
8113d22c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d230:	10c00a17 	ldw	r3,40(r2)
8113d234:	e0bffe17 	ldw	r2,-8(fp)
8113d238:	1885883a 	add	r2,r3,r2
8113d23c:	10800384 	addi	r2,r2,14
8113d240:	1007883a 	mov	r3,r2
8113d244:	e0bfff17 	ldw	r2,-4(fp)
8113d248:	1080030b 	ldhu	r2,12(r2)
8113d24c:	10bfffcc 	andi	r2,r2,65535
8113d250:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
8113d254:	d0a0ad17 	ldw	r2,-32076(gp)
8113d258:	10c00a17 	ldw	r3,40(r2)
8113d25c:	e0bffe17 	ldw	r2,-8(fp)
8113d260:	1885883a 	add	r2,r3,r2
8113d264:	10800404 	addi	r2,r2,16
8113d268:	1007883a 	mov	r3,r2
8113d26c:	e0bfff17 	ldw	r2,-4(fp)
8113d270:	1080038b 	ldhu	r2,14(r2)
8113d274:	10bfffcc 	andi	r2,r2,65535
8113d278:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
8113d27c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d280:	10c00a17 	ldw	r3,40(r2)
8113d284:	e0bffe17 	ldw	r2,-8(fp)
8113d288:	1885883a 	add	r2,r3,r2
8113d28c:	10800484 	addi	r2,r2,18
8113d290:	1007883a 	mov	r3,r2
8113d294:	e0bfff17 	ldw	r2,-4(fp)
8113d298:	1080040b 	ldhu	r2,16(r2)
8113d29c:	10bfffcc 	andi	r2,r2,65535
8113d2a0:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
8113d2a4:	d0a0ad17 	ldw	r2,-32076(gp)
8113d2a8:	10c00a17 	ldw	r3,40(r2)
8113d2ac:	e0bffe17 	ldw	r2,-8(fp)
8113d2b0:	1885883a 	add	r2,r3,r2
8113d2b4:	10800584 	addi	r2,r2,22
8113d2b8:	1007883a 	mov	r3,r2
8113d2bc:	e0bfff17 	ldw	r2,-4(fp)
8113d2c0:	1080048b 	ldhu	r2,18(r2)
8113d2c4:	10bfffcc 	andi	r2,r2,65535
8113d2c8:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
8113d2cc:	d0a0ad17 	ldw	r2,-32076(gp)
8113d2d0:	10c00a17 	ldw	r3,40(r2)
8113d2d4:	e0bffe17 	ldw	r2,-8(fp)
8113d2d8:	1885883a 	add	r2,r3,r2
8113d2dc:	10800604 	addi	r2,r2,24
8113d2e0:	1007883a 	mov	r3,r2
8113d2e4:	e0bfff17 	ldw	r2,-4(fp)
8113d2e8:	1080050b 	ldhu	r2,20(r2)
8113d2ec:	10bfffcc 	andi	r2,r2,65535
8113d2f0:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
8113d2f4:	d0a0ad17 	ldw	r2,-32076(gp)
8113d2f8:	10c00a17 	ldw	r3,40(r2)
8113d2fc:	e0bffe17 	ldw	r2,-8(fp)
8113d300:	1885883a 	add	r2,r3,r2
8113d304:	10800684 	addi	r2,r2,26
8113d308:	1007883a 	mov	r3,r2
8113d30c:	e0bfff17 	ldw	r2,-4(fp)
8113d310:	1080058b 	ldhu	r2,22(r2)
8113d314:	10bfffcc 	andi	r2,r2,65535
8113d318:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
8113d31c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d320:	10c00a17 	ldw	r3,40(r2)
8113d324:	e0bffe17 	ldw	r2,-8(fp)
8113d328:	1885883a 	add	r2,r3,r2
8113d32c:	10800704 	addi	r2,r2,28
8113d330:	1007883a 	mov	r3,r2
8113d334:	e0bfff17 	ldw	r2,-4(fp)
8113d338:	10800617 	ldw	r2,24(r2)
8113d33c:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
8113d340:	00800044 	movi	r2,1
8113d344:	d0a0ae15 	stw	r2,-32072(gp)
        result = true;
8113d348:	00800044 	movi	r2,1
8113d34c:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
8113d350:	e0bffb17 	ldw	r2,-20(fp)
}
8113d354:	e037883a 	mov	sp,fp
8113d358:	dfc00117 	ldw	ra,4(sp)
8113d35c:	df000017 	ldw	fp,0(sp)
8113d360:	dec00204 	addi	sp,sp,8
8113d364:	f800283a 	ret

8113d368 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8113d368:	defff904 	addi	sp,sp,-28
8113d36c:	de00012e 	bgeu	sp,et,8113d374 <Check_for_DOS_FAT+0xc>
8113d370:	003b68fa 	trap	3
8113d374:	dfc00615 	stw	ra,24(sp)
8113d378:	df000515 	stw	fp,20(sp)
8113d37c:	df000504 	addi	fp,sp,20
8113d380:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
8113d384:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8113d388:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
8113d38c:	e17fff17 	ldw	r5,-4(fp)
8113d390:	0009883a 	mov	r4,zero
8113d394:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113d398:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
8113d39c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d3a0:	10800a17 	ldw	r2,40(r2)
8113d3a4:	10807f84 	addi	r2,r2,510
8113d3a8:	1080002b 	ldhuio	r2,0(r2)
8113d3ac:	10bfffcc 	andi	r2,r2,65535
8113d3b0:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
8113d3b4:	e0bffe0f 	ldh	r2,-8(fp)
8113d3b8:	10ffffcc 	andi	r3,r2,65535
8113d3bc:	00aa9554 	movui	r2,43605
8113d3c0:	1881841e 	bne	r3,r2,8113d9d4 <Check_for_DOS_FAT+0x66c>
8113d3c4:	e0bffb17 	ldw	r2,-20(fp)
8113d3c8:	10018226 	beq	r2,zero,8113d9d4 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
8113d3cc:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
8113d3d0:	d0a0ad17 	ldw	r2,-32076(gp)
8113d3d4:	10800a17 	ldw	r2,40(r2)
8113d3d8:	10800023 	ldbuio	r2,0(r2)
8113d3dc:	10803fcc 	andi	r2,r2,255
8113d3e0:	1007883a 	mov	r3,r2
8113d3e4:	00a045b4 	movhi	r2,33046
8113d3e8:	1097c604 	addi	r2,r2,24344
8113d3ec:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
8113d3f0:	d0a0ad17 	ldw	r2,-32076(gp)
8113d3f4:	10800a17 	ldw	r2,40(r2)
8113d3f8:	10800044 	addi	r2,r2,1
8113d3fc:	10800023 	ldbuio	r2,0(r2)
8113d400:	10803fcc 	andi	r2,r2,255
8113d404:	1007883a 	mov	r3,r2
8113d408:	00a045b4 	movhi	r2,33046
8113d40c:	1097c604 	addi	r2,r2,24344
8113d410:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
8113d414:	d0a0ad17 	ldw	r2,-32076(gp)
8113d418:	10800a17 	ldw	r2,40(r2)
8113d41c:	10800084 	addi	r2,r2,2
8113d420:	10800023 	ldbuio	r2,0(r2)
8113d424:	10803fcc 	andi	r2,r2,255
8113d428:	1007883a 	mov	r3,r2
8113d42c:	00a045b4 	movhi	r2,33046
8113d430:	1097c604 	addi	r2,r2,24344
8113d434:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
8113d438:	e03ffc15 	stw	zero,-16(fp)
8113d43c:	00001106 	br	8113d484 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
8113d440:	d0a0ad17 	ldw	r2,-32076(gp)
8113d444:	10c00a17 	ldw	r3,40(r2)
8113d448:	e0bffc17 	ldw	r2,-16(fp)
8113d44c:	1885883a 	add	r2,r3,r2
8113d450:	108000c4 	addi	r2,r2,3
8113d454:	10800023 	ldbuio	r2,0(r2)
8113d458:	10803fcc 	andi	r2,r2,255
8113d45c:	1009883a 	mov	r4,r2
8113d460:	00a045b4 	movhi	r2,33046
8113d464:	1097c604 	addi	r2,r2,24344
8113d468:	e0fffc17 	ldw	r3,-16(fp)
8113d46c:	10c5883a 	add	r2,r2,r3
8113d470:	108000c4 	addi	r2,r2,3
8113d474:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8113d478:	e0bffc17 	ldw	r2,-16(fp)
8113d47c:	10800044 	addi	r2,r2,1
8113d480:	e0bffc15 	stw	r2,-16(fp)
8113d484:	e0bffc17 	ldw	r2,-16(fp)
8113d488:	10800210 	cmplti	r2,r2,8
8113d48c:	103fec1e 	bne	r2,zero,8113d440 <__reset+0xfb11d440>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
8113d490:	d0a0ad17 	ldw	r2,-32076(gp)
8113d494:	10800a17 	ldw	r2,40(r2)
8113d498:	10800304 	addi	r2,r2,12
8113d49c:	10800023 	ldbuio	r2,0(r2)
8113d4a0:	10803fcc 	andi	r2,r2,255
8113d4a4:	1004923a 	slli	r2,r2,8
8113d4a8:	1007883a 	mov	r3,r2
8113d4ac:	d0a0ad17 	ldw	r2,-32076(gp)
8113d4b0:	10800a17 	ldw	r2,40(r2)
8113d4b4:	108002c4 	addi	r2,r2,11
8113d4b8:	10800023 	ldbuio	r2,0(r2)
8113d4bc:	10803fcc 	andi	r2,r2,255
8113d4c0:	10803fcc 	andi	r2,r2,255
8113d4c4:	1080201c 	xori	r2,r2,128
8113d4c8:	10bfe004 	addi	r2,r2,-128
8113d4cc:	1884b03a 	or	r2,r3,r2
8113d4d0:	1007883a 	mov	r3,r2
8113d4d4:	00a045b4 	movhi	r2,33046
8113d4d8:	1097c604 	addi	r2,r2,24344
8113d4dc:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
8113d4e0:	d0a0ad17 	ldw	r2,-32076(gp)
8113d4e4:	10800a17 	ldw	r2,40(r2)
8113d4e8:	10800344 	addi	r2,r2,13
8113d4ec:	10800023 	ldbuio	r2,0(r2)
8113d4f0:	10803fcc 	andi	r2,r2,255
8113d4f4:	1007883a 	mov	r3,r2
8113d4f8:	00a045b4 	movhi	r2,33046
8113d4fc:	1097c604 	addi	r2,r2,24344
8113d500:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
8113d504:	d0a0ad17 	ldw	r2,-32076(gp)
8113d508:	10800a17 	ldw	r2,40(r2)
8113d50c:	10800384 	addi	r2,r2,14
8113d510:	1080002b 	ldhuio	r2,0(r2)
8113d514:	10bfffcc 	andi	r2,r2,65535
8113d518:	1007883a 	mov	r3,r2
8113d51c:	00a045b4 	movhi	r2,33046
8113d520:	1097c604 	addi	r2,r2,24344
8113d524:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8113d528:	d0a0ad17 	ldw	r2,-32076(gp)
8113d52c:	10800a17 	ldw	r2,40(r2)
8113d530:	10800404 	addi	r2,r2,16
8113d534:	10800023 	ldbuio	r2,0(r2)
8113d538:	10803fcc 	andi	r2,r2,255
8113d53c:	1007883a 	mov	r3,r2
8113d540:	00a045b4 	movhi	r2,33046
8113d544:	1097c604 	addi	r2,r2,24344
8113d548:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
8113d54c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d550:	10800a17 	ldw	r2,40(r2)
8113d554:	10800484 	addi	r2,r2,18
8113d558:	10800023 	ldbuio	r2,0(r2)
8113d55c:	10803fcc 	andi	r2,r2,255
8113d560:	1004923a 	slli	r2,r2,8
8113d564:	1007883a 	mov	r3,r2
8113d568:	d0a0ad17 	ldw	r2,-32076(gp)
8113d56c:	10800a17 	ldw	r2,40(r2)
8113d570:	10800444 	addi	r2,r2,17
8113d574:	10800023 	ldbuio	r2,0(r2)
8113d578:	10803fcc 	andi	r2,r2,255
8113d57c:	10803fcc 	andi	r2,r2,255
8113d580:	1884b03a 	or	r2,r3,r2
8113d584:	1007883a 	mov	r3,r2
8113d588:	00a045b4 	movhi	r2,33046
8113d58c:	1097c604 	addi	r2,r2,24344
8113d590:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
8113d594:	d0a0ad17 	ldw	r2,-32076(gp)
8113d598:	10800a17 	ldw	r2,40(r2)
8113d59c:	10800504 	addi	r2,r2,20
8113d5a0:	10800023 	ldbuio	r2,0(r2)
8113d5a4:	10803fcc 	andi	r2,r2,255
8113d5a8:	1004923a 	slli	r2,r2,8
8113d5ac:	1007883a 	mov	r3,r2
8113d5b0:	d0a0ad17 	ldw	r2,-32076(gp)
8113d5b4:	10800a17 	ldw	r2,40(r2)
8113d5b8:	108004c4 	addi	r2,r2,19
8113d5bc:	10800023 	ldbuio	r2,0(r2)
8113d5c0:	10803fcc 	andi	r2,r2,255
8113d5c4:	10803fcc 	andi	r2,r2,255
8113d5c8:	1884b03a 	or	r2,r3,r2
8113d5cc:	1007883a 	mov	r3,r2
8113d5d0:	00a045b4 	movhi	r2,33046
8113d5d4:	1097c604 	addi	r2,r2,24344
8113d5d8:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
8113d5dc:	d0a0ad17 	ldw	r2,-32076(gp)
8113d5e0:	10800a17 	ldw	r2,40(r2)
8113d5e4:	10800544 	addi	r2,r2,21
8113d5e8:	10800023 	ldbuio	r2,0(r2)
8113d5ec:	10803fcc 	andi	r2,r2,255
8113d5f0:	1007883a 	mov	r3,r2
8113d5f4:	00a045b4 	movhi	r2,33046
8113d5f8:	1097c604 	addi	r2,r2,24344
8113d5fc:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8113d600:	d0a0ad17 	ldw	r2,-32076(gp)
8113d604:	10800a17 	ldw	r2,40(r2)
8113d608:	10800584 	addi	r2,r2,22
8113d60c:	1080002b 	ldhuio	r2,0(r2)
8113d610:	10bfffcc 	andi	r2,r2,65535
8113d614:	1007883a 	mov	r3,r2
8113d618:	00a045b4 	movhi	r2,33046
8113d61c:	1097c604 	addi	r2,r2,24344
8113d620:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
8113d624:	d0a0ad17 	ldw	r2,-32076(gp)
8113d628:	10800a17 	ldw	r2,40(r2)
8113d62c:	10800604 	addi	r2,r2,24
8113d630:	1080002b 	ldhuio	r2,0(r2)
8113d634:	10bfffcc 	andi	r2,r2,65535
8113d638:	1007883a 	mov	r3,r2
8113d63c:	00a045b4 	movhi	r2,33046
8113d640:	1097c604 	addi	r2,r2,24344
8113d644:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8113d648:	d0a0ad17 	ldw	r2,-32076(gp)
8113d64c:	10800a17 	ldw	r2,40(r2)
8113d650:	10800684 	addi	r2,r2,26
8113d654:	1080002b 	ldhuio	r2,0(r2)
8113d658:	10bfffcc 	andi	r2,r2,65535
8113d65c:	1007883a 	mov	r3,r2
8113d660:	00a045b4 	movhi	r2,33046
8113d664:	1097c604 	addi	r2,r2,24344
8113d668:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
8113d66c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d670:	10800a17 	ldw	r2,40(r2)
8113d674:	10800704 	addi	r2,r2,28
8113d678:	10800037 	ldwio	r2,0(r2)
8113d67c:	1007883a 	mov	r3,r2
8113d680:	00a045b4 	movhi	r2,33046
8113d684:	1097c604 	addi	r2,r2,24344
8113d688:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
8113d68c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d690:	10800a17 	ldw	r2,40(r2)
8113d694:	10800804 	addi	r2,r2,32
8113d698:	10800037 	ldwio	r2,0(r2)
8113d69c:	1007883a 	mov	r3,r2
8113d6a0:	00a045b4 	movhi	r2,33046
8113d6a4:	1097c604 	addi	r2,r2,24344
8113d6a8:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
8113d6ac:	d0a0ad17 	ldw	r2,-32076(gp)
8113d6b0:	10800a17 	ldw	r2,40(r2)
8113d6b4:	10800904 	addi	r2,r2,36
8113d6b8:	10800023 	ldbuio	r2,0(r2)
8113d6bc:	10803fcc 	andi	r2,r2,255
8113d6c0:	1007883a 	mov	r3,r2
8113d6c4:	00a045b4 	movhi	r2,33046
8113d6c8:	1097c604 	addi	r2,r2,24344
8113d6cc:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
8113d6d0:	d0a0ad17 	ldw	r2,-32076(gp)
8113d6d4:	10800a17 	ldw	r2,40(r2)
8113d6d8:	10800944 	addi	r2,r2,37
8113d6dc:	10800023 	ldbuio	r2,0(r2)
8113d6e0:	10803fcc 	andi	r2,r2,255
8113d6e4:	1007883a 	mov	r3,r2
8113d6e8:	00a045b4 	movhi	r2,33046
8113d6ec:	1097c604 	addi	r2,r2,24344
8113d6f0:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
8113d6f4:	d0a0ad17 	ldw	r2,-32076(gp)
8113d6f8:	10800a17 	ldw	r2,40(r2)
8113d6fc:	10800984 	addi	r2,r2,38
8113d700:	10800023 	ldbuio	r2,0(r2)
8113d704:	10803fcc 	andi	r2,r2,255
8113d708:	1007883a 	mov	r3,r2
8113d70c:	00a045b4 	movhi	r2,33046
8113d710:	1097c604 	addi	r2,r2,24344
8113d714:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
8113d718:	00a045b4 	movhi	r2,33046
8113d71c:	1097c604 	addi	r2,r2,24344
8113d720:	1080040b 	ldhu	r2,16(r2)
8113d724:	10ffffcc 	andi	r3,r2,65535
8113d728:	00a045b4 	movhi	r2,33046
8113d72c:	1097c604 	addi	r2,r2,24344
8113d730:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
8113d734:	00a045b4 	movhi	r2,33046
8113d738:	1097c604 	addi	r2,r2,24344
8113d73c:	10c01117 	ldw	r3,68(r2)
8113d740:	00a045b4 	movhi	r2,33046
8113d744:	1097c604 	addi	r2,r2,24344
8113d748:	1080068b 	ldhu	r2,26(r2)
8113d74c:	10bfffcc 	andi	r2,r2,65535
8113d750:	1887883a 	add	r3,r3,r2
8113d754:	00a045b4 	movhi	r2,33046
8113d758:	1097c604 	addi	r2,r2,24344
8113d75c:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
8113d760:	00a045b4 	movhi	r2,33046
8113d764:	1097c604 	addi	r2,r2,24344
8113d768:	10c01217 	ldw	r3,72(r2)
8113d76c:	00a045b4 	movhi	r2,33046
8113d770:	1097c604 	addi	r2,r2,24344
8113d774:	1080068b 	ldhu	r2,26(r2)
8113d778:	10bfffcc 	andi	r2,r2,65535
8113d77c:	1887883a 	add	r3,r3,r2
8113d780:	00a045b4 	movhi	r2,33046
8113d784:	1097c604 	addi	r2,r2,24344
8113d788:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
8113d78c:	00a045b4 	movhi	r2,33046
8113d790:	1097c604 	addi	r2,r2,24344
8113d794:	10c01317 	ldw	r3,76(r2)
8113d798:	00a045b4 	movhi	r2,33046
8113d79c:	1097c604 	addi	r2,r2,24344
8113d7a0:	1080050b 	ldhu	r2,20(r2)
8113d7a4:	10bfffcc 	andi	r2,r2,65535
8113d7a8:	1008917a 	slli	r4,r2,5
8113d7ac:	00a045b4 	movhi	r2,33046
8113d7b0:	1097c604 	addi	r2,r2,24344
8113d7b4:	1080030b 	ldhu	r2,12(r2)
8113d7b8:	10bfffcc 	andi	r2,r2,65535
8113d7bc:	2085283a 	div	r2,r4,r2
8113d7c0:	1887883a 	add	r3,r3,r2
8113d7c4:	00a045b4 	movhi	r2,33046
8113d7c8:	1097c604 	addi	r2,r2,24344
8113d7cc:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8113d7d0:	00a045b4 	movhi	r2,33046
8113d7d4:	1097c604 	addi	r2,r2,24344
8113d7d8:	1080058b 	ldhu	r2,22(r2)
8113d7dc:	10bfffcc 	andi	r2,r2,65535
8113d7e0:	10000b26 	beq	r2,zero,8113d810 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
8113d7e4:	00a045b4 	movhi	r2,33046
8113d7e8:	1097c604 	addi	r2,r2,24344
8113d7ec:	1080058b 	ldhu	r2,22(r2)
8113d7f0:	10ffffcc 	andi	r3,r2,65535
8113d7f4:	00a045b4 	movhi	r2,33046
8113d7f8:	1097c604 	addi	r2,r2,24344
8113d7fc:	10800383 	ldbu	r2,14(r2)
8113d800:	10803fcc 	andi	r2,r2,255
8113d804:	1885283a 	div	r2,r3,r2
8113d808:	e0bffd15 	stw	r2,-12(fp)
8113d80c:	00000906 	br	8113d834 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8113d810:	00a045b4 	movhi	r2,33046
8113d814:	1097c604 	addi	r2,r2,24344
8113d818:	10c00917 	ldw	r3,36(r2)
8113d81c:	00a045b4 	movhi	r2,33046
8113d820:	1097c604 	addi	r2,r2,24344
8113d824:	10800383 	ldbu	r2,14(r2)
8113d828:	10803fcc 	andi	r2,r2,255
8113d82c:	1885203a 	divu	r2,r3,r2
8113d830:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
8113d834:	e0bffd17 	ldw	r2,-12(fp)
8113d838:	1083fdc8 	cmpgei	r2,r2,4087
8113d83c:	1000051e 	bne	r2,zero,8113d854 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
8113d840:	00a045b4 	movhi	r2,33046
8113d844:	1097c604 	addi	r2,r2,24344
8113d848:	00c00304 	movi	r3,12
8113d84c:	10c01085 	stb	r3,66(r2)
8113d850:	00000c06 	br	8113d884 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
8113d854:	e0bffd17 	ldw	r2,-12(fp)
8113d858:	00fffb54 	movui	r3,65517
8113d85c:	18800516 	blt	r3,r2,8113d874 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
8113d860:	00a045b4 	movhi	r2,33046
8113d864:	1097c604 	addi	r2,r2,24344
8113d868:	00c00404 	movi	r3,16
8113d86c:	10c01085 	stb	r3,66(r2)
8113d870:	00000406 	br	8113d884 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
8113d874:	00a045b4 	movhi	r2,33046
8113d878:	1097c604 	addi	r2,r2,24344
8113d87c:	00c00804 	movi	r3,32
8113d880:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
8113d884:	e03ffc15 	stw	zero,-16(fp)
8113d888:	00001106 	br	8113d8d0 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
8113d88c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d890:	10c00a17 	ldw	r3,40(r2)
8113d894:	e0bffc17 	ldw	r2,-16(fp)
8113d898:	1885883a 	add	r2,r3,r2
8113d89c:	108009c4 	addi	r2,r2,39
8113d8a0:	10800023 	ldbuio	r2,0(r2)
8113d8a4:	10803fcc 	andi	r2,r2,255
8113d8a8:	1009883a 	mov	r4,r2
8113d8ac:	00a045b4 	movhi	r2,33046
8113d8b0:	1097c604 	addi	r2,r2,24344
8113d8b4:	e0fffc17 	ldw	r3,-16(fp)
8113d8b8:	10c5883a 	add	r2,r2,r3
8113d8bc:	10800ac4 	addi	r2,r2,43
8113d8c0:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
8113d8c4:	e0bffc17 	ldw	r2,-16(fp)
8113d8c8:	10800044 	addi	r2,r2,1
8113d8cc:	e0bffc15 	stw	r2,-16(fp)
8113d8d0:	e0bffc17 	ldw	r2,-16(fp)
8113d8d4:	10800110 	cmplti	r2,r2,4
8113d8d8:	103fec1e 	bne	r2,zero,8113d88c <__reset+0xfb11d88c>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113d8dc:	e03ffc15 	stw	zero,-16(fp)
8113d8e0:	00001106 	br	8113d928 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
8113d8e4:	d0a0ad17 	ldw	r2,-32076(gp)
8113d8e8:	10c00a17 	ldw	r3,40(r2)
8113d8ec:	e0bffc17 	ldw	r2,-16(fp)
8113d8f0:	1885883a 	add	r2,r3,r2
8113d8f4:	10800ac4 	addi	r2,r2,43
8113d8f8:	10800023 	ldbuio	r2,0(r2)
8113d8fc:	10803fcc 	andi	r2,r2,255
8113d900:	1009883a 	mov	r4,r2
8113d904:	00a045b4 	movhi	r2,33046
8113d908:	1097c604 	addi	r2,r2,24344
8113d90c:	e0fffc17 	ldw	r3,-16(fp)
8113d910:	10c5883a 	add	r2,r2,r3
8113d914:	10800bc4 	addi	r2,r2,47
8113d918:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113d91c:	e0bffc17 	ldw	r2,-16(fp)
8113d920:	10800044 	addi	r2,r2,1
8113d924:	e0bffc15 	stw	r2,-16(fp)
8113d928:	e0bffc17 	ldw	r2,-16(fp)
8113d92c:	108002d0 	cmplti	r2,r2,11
8113d930:	103fec1e 	bne	r2,zero,8113d8e4 <__reset+0xfb11d8e4>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113d934:	e03ffc15 	stw	zero,-16(fp)
8113d938:	00001106 	br	8113d980 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8113d93c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d940:	10c00a17 	ldw	r3,40(r2)
8113d944:	e0bffc17 	ldw	r2,-16(fp)
8113d948:	1885883a 	add	r2,r3,r2
8113d94c:	10800d84 	addi	r2,r2,54
8113d950:	10800023 	ldbuio	r2,0(r2)
8113d954:	10803fcc 	andi	r2,r2,255
8113d958:	1009883a 	mov	r4,r2
8113d95c:	00a045b4 	movhi	r2,33046
8113d960:	1097c604 	addi	r2,r2,24344
8113d964:	e0fffc17 	ldw	r3,-16(fp)
8113d968:	10c5883a 	add	r2,r2,r3
8113d96c:	10800e84 	addi	r2,r2,58
8113d970:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113d974:	e0bffc17 	ldw	r2,-16(fp)
8113d978:	10800044 	addi	r2,r2,1
8113d97c:	e0bffc15 	stw	r2,-16(fp)
8113d980:	e0bffc17 	ldw	r2,-16(fp)
8113d984:	10800210 	cmplti	r2,r2,8
8113d988:	103fec1e 	bne	r2,zero,8113d93c <__reset+0xfb11d93c>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113d98c:	e03ffc15 	stw	zero,-16(fp)
8113d990:	00000a06 	br	8113d9bc <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
8113d994:	00a045b4 	movhi	r2,33046
8113d998:	1097db04 	addi	r2,r2,24428
8113d99c:	e0fffc17 	ldw	r3,-16(fp)
8113d9a0:	180691ba 	slli	r3,r3,6
8113d9a4:	10c5883a 	add	r2,r2,r3
8113d9a8:	10800f04 	addi	r2,r2,60
8113d9ac:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113d9b0:	e0bffc17 	ldw	r2,-16(fp)
8113d9b4:	10800044 	addi	r2,r2,1
8113d9b8:	e0bffc15 	stw	r2,-16(fp)
8113d9bc:	e0bffc17 	ldw	r2,-16(fp)
8113d9c0:	10800510 	cmplti	r2,r2,20
8113d9c4:	103ff31e 	bne	r2,zero,8113d994 <__reset+0xfb11d994>
		{
			active_files[counter].in_use = false;
		}
		result = true;
8113d9c8:	00800044 	movi	r2,1
8113d9cc:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8113d9d0:	00000106 	br	8113d9d8 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
8113d9d4:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
8113d9d8:	e0bffb17 	ldw	r2,-20(fp)
}
8113d9dc:	e037883a 	mov	sp,fp
8113d9e0:	dfc00117 	ldw	ra,4(sp)
8113d9e4:	df000017 	ldw	fp,0(sp)
8113d9e8:	dec00204 	addi	sp,sp,8
8113d9ec:	f800283a 	ret

8113d9f0 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8113d9f0:	defffc04 	addi	sp,sp,-16
8113d9f4:	de00012e 	bgeu	sp,et,8113d9fc <Look_for_FAT16+0xc>
8113d9f8:	003b68fa 	trap	3
8113d9fc:	dfc00315 	stw	ra,12(sp)
8113da00:	df000215 	stw	fp,8(sp)
8113da04:	df000204 	addi	fp,sp,8
	bool result = false;
8113da08:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8113da0c:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
8113da10:	10002e26 	beq	r2,zero,8113dacc <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
8113da14:	d0a0a717 	ldw	r2,-32100(gp)
8113da18:	1080000b 	ldhu	r2,0(r2)
8113da1c:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8113da20:	d020ab15 	stw	zero,-32084(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
8113da24:	d020ac15 	stw	zero,-32080(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8113da28:	e0bfff0f 	ldh	r2,-4(fp)
8113da2c:	10002716 	blt	r2,zero,8113dacc <Look_for_FAT16+0xdc>
8113da30:	e0bfff0b 	ldhu	r2,-4(fp)
8113da34:	10bfffcc 	andi	r2,r2,65535
8113da38:	1083000c 	andi	r2,r2,3072
8113da3c:	10830020 	cmpeqi	r2,r2,3072
8113da40:	1000221e 	bne	r2,zero,8113dacc <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
8113da44:	e0bfff0b 	ldhu	r2,-4(fp)
8113da48:	10bfffcc 	andi	r2,r2,65535
8113da4c:	1083000c 	andi	r2,r2,3072
8113da50:	10810018 	cmpnei	r2,r2,1024
8113da54:	1000031e 	bne	r2,zero,8113da64 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8113da58:	0009883a 	mov	r4,zero
8113da5c:	113d3680 	call	8113d368 <Check_for_DOS_FAT>
8113da60:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
8113da64:	e0bfff0b 	ldhu	r2,-4(fp)
8113da68:	10bfffcc 	andi	r2,r2,65535
8113da6c:	1083000c 	andi	r2,r2,3072
8113da70:	1000061e 	bne	r2,zero,8113da8c <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
8113da74:	113cca40 	call	8113cca4 <Check_for_Master_Boot_Record>
8113da78:	10000426 	beq	r2,zero,8113da8c <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
8113da7c:	d0a0ab17 	ldw	r2,-32084(gp)
8113da80:	1009883a 	mov	r4,r2
8113da84:	113d3680 	call	8113d368 <Check_for_DOS_FAT>
8113da88:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
8113da8c:	e0bffe17 	ldw	r2,-8(fp)
8113da90:	10800058 	cmpnei	r2,r2,1
8113da94:	10000d1e 	bne	r2,zero,8113dacc <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
8113da98:	00a045b4 	movhi	r2,33046
8113da9c:	1097c604 	addi	r2,r2,24344
8113daa0:	10801083 	ldbu	r2,66(r2)
8113daa4:	10803fcc 	andi	r2,r2,255
8113daa8:	10800420 	cmpeqi	r2,r2,16
8113daac:	1000021e 	bne	r2,zero,8113dab8 <Look_for_FAT16+0xc8>
				{
					result = false;
8113dab0:	e03ffe15 	stw	zero,-8(fp)
8113dab4:	00000506 	br	8113dacc <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8113dab8:	00a045b4 	movhi	r2,33046
8113dabc:	1097c604 	addi	r2,r2,24344
8113dac0:	1080058b 	ldhu	r2,22(r2)
8113dac4:	10bfffcc 	andi	r2,r2,65535
8113dac8:	d0a0ac15 	stw	r2,-32080(gp)
				}
			}
		}
	}
	return result;
8113dacc:	e0bffe17 	ldw	r2,-8(fp)
}
8113dad0:	e037883a 	mov	sp,fp
8113dad4:	dfc00117 	ldw	ra,4(sp)
8113dad8:	df000017 	ldw	fp,0(sp)
8113dadc:	dec00204 	addi	sp,sp,8
8113dae0:	f800283a 	ret

8113dae4 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
8113dae4:	defffb04 	addi	sp,sp,-20
8113dae8:	de00012e 	bgeu	sp,et,8113daf0 <filename_to_upper_case+0xc>
8113daec:	003b68fa 	trap	3
8113daf0:	dfc00415 	stw	ra,16(sp)
8113daf4:	df000315 	stw	fp,12(sp)
8113daf8:	df000304 	addi	fp,sp,12
8113dafc:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8113db00:	e13fff17 	ldw	r4,-4(fp)
8113db04:	111cf340 	call	8111cf34 <strlen>
8113db08:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8113db0c:	e03ffd15 	stw	zero,-12(fp)
8113db10:	00001e06 	br	8113db8c <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
8113db14:	e0bffd17 	ldw	r2,-12(fp)
8113db18:	e0ffff17 	ldw	r3,-4(fp)
8113db1c:	1885883a 	add	r2,r3,r2
8113db20:	10800003 	ldbu	r2,0(r2)
8113db24:	10803fcc 	andi	r2,r2,255
8113db28:	1080201c 	xori	r2,r2,128
8113db2c:	10bfe004 	addi	r2,r2,-128
8113db30:	10801850 	cmplti	r2,r2,97
8113db34:	1000121e 	bne	r2,zero,8113db80 <filename_to_upper_case+0x9c>
8113db38:	e0bffd17 	ldw	r2,-12(fp)
8113db3c:	e0ffff17 	ldw	r3,-4(fp)
8113db40:	1885883a 	add	r2,r3,r2
8113db44:	10800003 	ldbu	r2,0(r2)
8113db48:	10803fcc 	andi	r2,r2,255
8113db4c:	1080201c 	xori	r2,r2,128
8113db50:	10bfe004 	addi	r2,r2,-128
8113db54:	10801ec8 	cmpgei	r2,r2,123
8113db58:	1000091e 	bne	r2,zero,8113db80 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
8113db5c:	e0bffd17 	ldw	r2,-12(fp)
8113db60:	e0ffff17 	ldw	r3,-4(fp)
8113db64:	1885883a 	add	r2,r3,r2
8113db68:	e0fffd17 	ldw	r3,-12(fp)
8113db6c:	e13fff17 	ldw	r4,-4(fp)
8113db70:	20c7883a 	add	r3,r4,r3
8113db74:	18c00003 	ldbu	r3,0(r3)
8113db78:	18fff804 	addi	r3,r3,-32
8113db7c:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8113db80:	e0bffd17 	ldw	r2,-12(fp)
8113db84:	10800044 	addi	r2,r2,1
8113db88:	e0bffd15 	stw	r2,-12(fp)
8113db8c:	e0fffd17 	ldw	r3,-12(fp)
8113db90:	e0bffe17 	ldw	r2,-8(fp)
8113db94:	18bfdf16 	blt	r3,r2,8113db14 <__reset+0xfb11db14>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8113db98:	0001883a 	nop
8113db9c:	e037883a 	mov	sp,fp
8113dba0:	dfc00117 	ldw	ra,4(sp)
8113dba4:	df000017 	ldw	fp,0(sp)
8113dba8:	dec00204 	addi	sp,sp,8
8113dbac:	f800283a 	ret

8113dbb0 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8113dbb0:	defff804 	addi	sp,sp,-32
8113dbb4:	de00012e 	bgeu	sp,et,8113dbbc <check_file_name_for_FAT16_compliance+0xc>
8113dbb8:	003b68fa 	trap	3
8113dbbc:	dfc00715 	stw	ra,28(sp)
8113dbc0:	df000615 	stw	fp,24(sp)
8113dbc4:	df000604 	addi	fp,sp,24
8113dbc8:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8113dbcc:	e13fff17 	ldw	r4,-4(fp)
8113dbd0:	111cf340 	call	8111cf34 <strlen>
8113dbd4:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8113dbd8:	00bfffc4 	movi	r2,-1
8113dbdc:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
8113dbe0:	00bfffc4 	movi	r2,-1
8113dbe4:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
8113dbe8:	00800044 	movi	r2,1
8113dbec:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8113dbf0:	e03ffa15 	stw	zero,-24(fp)
8113dbf4:	00006d06 	br	8113ddac <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8113dbf8:	e0bffa17 	ldw	r2,-24(fp)
8113dbfc:	e0ffff17 	ldw	r3,-4(fp)
8113dc00:	1885883a 	add	r2,r3,r2
8113dc04:	10800003 	ldbu	r2,0(r2)
8113dc08:	10803fcc 	andi	r2,r2,255
8113dc0c:	1080201c 	xori	r2,r2,128
8113dc10:	10bfe004 	addi	r2,r2,-128
8113dc14:	10800820 	cmpeqi	r2,r2,32
8113dc18:	10003e1e 	bne	r2,zero,8113dd14 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113dc1c:	e0bffa17 	ldw	r2,-24(fp)
8113dc20:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
8113dc24:	e0bffb17 	ldw	r2,-20(fp)
8113dc28:	1880121e 	bne	r3,r2,8113dc74 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113dc2c:	e0bffa17 	ldw	r2,-24(fp)
8113dc30:	e0ffff17 	ldw	r3,-4(fp)
8113dc34:	1885883a 	add	r2,r3,r2
8113dc38:	10800003 	ldbu	r2,0(r2)
8113dc3c:	10803fcc 	andi	r2,r2,255
8113dc40:	1080201c 	xori	r2,r2,128
8113dc44:	10bfe004 	addi	r2,r2,-128
8113dc48:	10801720 	cmpeqi	r2,r2,92
8113dc4c:	1000311e 	bne	r2,zero,8113dd14 <check_file_name_for_FAT16_compliance+0x164>
8113dc50:	e0bffa17 	ldw	r2,-24(fp)
8113dc54:	e0ffff17 	ldw	r3,-4(fp)
8113dc58:	1885883a 	add	r2,r3,r2
8113dc5c:	10800003 	ldbu	r2,0(r2)
8113dc60:	10803fcc 	andi	r2,r2,255
8113dc64:	1080201c 	xori	r2,r2,128
8113dc68:	10bfe004 	addi	r2,r2,-128
8113dc6c:	10800be0 	cmpeqi	r2,r2,47
8113dc70:	1000281e 	bne	r2,zero,8113dd14 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113dc74:	e0fffa17 	ldw	r3,-24(fp)
8113dc78:	e0bffc17 	ldw	r2,-16(fp)
8113dc7c:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113dc80:	10800258 	cmpnei	r2,r2,9
8113dc84:	1000091e 	bne	r2,zero,8113dcac <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113dc88:	e0bffa17 	ldw	r2,-24(fp)
8113dc8c:	e0ffff17 	ldw	r3,-4(fp)
8113dc90:	1885883a 	add	r2,r3,r2
8113dc94:	10800003 	ldbu	r2,0(r2)
8113dc98:	10803fcc 	andi	r2,r2,255
8113dc9c:	1080201c 	xori	r2,r2,128
8113dca0:	10bfe004 	addi	r2,r2,-128
8113dca4:	10800b98 	cmpnei	r2,r2,46
8113dca8:	10001a1e 	bne	r2,zero,8113dd14 <check_file_name_for_FAT16_compliance+0x164>
8113dcac:	e0fffb17 	ldw	r3,-20(fp)
8113dcb0:	e0bffc17 	ldw	r2,-16(fp)
8113dcb4:	18801926 	beq	r3,r2,8113dd1c <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113dcb8:	e0fffa17 	ldw	r3,-24(fp)
8113dcbc:	e0bffc17 	ldw	r2,-16(fp)
8113dcc0:	1885c83a 	sub	r2,r3,r2
8113dcc4:	10800110 	cmplti	r2,r2,4
8113dcc8:	1000141e 	bne	r2,zero,8113dd1c <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113dccc:	e0bffa17 	ldw	r2,-24(fp)
8113dcd0:	e0ffff17 	ldw	r3,-4(fp)
8113dcd4:	1885883a 	add	r2,r3,r2
8113dcd8:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113dcdc:	10803fcc 	andi	r2,r2,255
8113dce0:	1080201c 	xori	r2,r2,128
8113dce4:	10bfe004 	addi	r2,r2,-128
8113dce8:	10801720 	cmpeqi	r2,r2,92
8113dcec:	10000b1e 	bne	r2,zero,8113dd1c <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113dcf0:	e0bffa17 	ldw	r2,-24(fp)
8113dcf4:	e0ffff17 	ldw	r3,-4(fp)
8113dcf8:	1885883a 	add	r2,r3,r2
8113dcfc:	10800003 	ldbu	r2,0(r2)
8113dd00:	10803fcc 	andi	r2,r2,255
8113dd04:	1080201c 	xori	r2,r2,128
8113dd08:	10bfe004 	addi	r2,r2,-128
8113dd0c:	10800be0 	cmpeqi	r2,r2,47
8113dd10:	1000021e 	bne	r2,zero,8113dd1c <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
8113dd14:	e03ffd15 	stw	zero,-12(fp)
            break;
8113dd18:	00002706 	br	8113ddb8 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
8113dd1c:	e0bffa17 	ldw	r2,-24(fp)
8113dd20:	e0ffff17 	ldw	r3,-4(fp)
8113dd24:	1885883a 	add	r2,r3,r2
8113dd28:	10800003 	ldbu	r2,0(r2)
8113dd2c:	10803fcc 	andi	r2,r2,255
8113dd30:	1080201c 	xori	r2,r2,128
8113dd34:	10bfe004 	addi	r2,r2,-128
8113dd38:	10801720 	cmpeqi	r2,r2,92
8113dd3c:	1000091e 	bne	r2,zero,8113dd64 <check_file_name_for_FAT16_compliance+0x1b4>
8113dd40:	e0bffa17 	ldw	r2,-24(fp)
8113dd44:	e0ffff17 	ldw	r3,-4(fp)
8113dd48:	1885883a 	add	r2,r3,r2
8113dd4c:	10800003 	ldbu	r2,0(r2)
8113dd50:	10803fcc 	andi	r2,r2,255
8113dd54:	1080201c 	xori	r2,r2,128
8113dd58:	10bfe004 	addi	r2,r2,-128
8113dd5c:	10800bd8 	cmpnei	r2,r2,47
8113dd60:	1000041e 	bne	r2,zero,8113dd74 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
8113dd64:	e0bffa17 	ldw	r2,-24(fp)
8113dd68:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
8113dd6c:	e0bffa17 	ldw	r2,-24(fp)
8113dd70:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
8113dd74:	e0bffa17 	ldw	r2,-24(fp)
8113dd78:	e0ffff17 	ldw	r3,-4(fp)
8113dd7c:	1885883a 	add	r2,r3,r2
8113dd80:	10800003 	ldbu	r2,0(r2)
8113dd84:	10803fcc 	andi	r2,r2,255
8113dd88:	1080201c 	xori	r2,r2,128
8113dd8c:	10bfe004 	addi	r2,r2,-128
8113dd90:	10800b98 	cmpnei	r2,r2,46
8113dd94:	1000021e 	bne	r2,zero,8113dda0 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8113dd98:	e0bffa17 	ldw	r2,-24(fp)
8113dd9c:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
8113dda0:	e0bffa17 	ldw	r2,-24(fp)
8113dda4:	10800044 	addi	r2,r2,1
8113dda8:	e0bffa15 	stw	r2,-24(fp)
8113ddac:	e0fffa17 	ldw	r3,-24(fp)
8113ddb0:	e0bffe17 	ldw	r2,-8(fp)
8113ddb4:	18bf9016 	blt	r3,r2,8113dbf8 <__reset+0xfb11dbf8>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8113ddb8:	e0bffe17 	ldw	r2,-8(fp)
8113ddbc:	10bfffc4 	addi	r2,r2,-1
8113ddc0:	e0ffff17 	ldw	r3,-4(fp)
8113ddc4:	1885883a 	add	r2,r3,r2
8113ddc8:	10800003 	ldbu	r2,0(r2)
8113ddcc:	10803fcc 	andi	r2,r2,255
8113ddd0:	1080201c 	xori	r2,r2,128
8113ddd4:	10bfe004 	addi	r2,r2,-128
8113ddd8:	10801720 	cmpeqi	r2,r2,92
8113dddc:	10000a1e 	bne	r2,zero,8113de08 <check_file_name_for_FAT16_compliance+0x258>
8113dde0:	e0bffe17 	ldw	r2,-8(fp)
8113dde4:	10bfffc4 	addi	r2,r2,-1
8113dde8:	e0ffff17 	ldw	r3,-4(fp)
8113ddec:	1885883a 	add	r2,r3,r2
8113ddf0:	10800003 	ldbu	r2,0(r2)
8113ddf4:	10803fcc 	andi	r2,r2,255
8113ddf8:	1080201c 	xori	r2,r2,128
8113ddfc:	10bfe004 	addi	r2,r2,-128
8113de00:	10800bd8 	cmpnei	r2,r2,47
8113de04:	1000011e 	bne	r2,zero,8113de0c <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
8113de08:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
8113de0c:	e0bffd17 	ldw	r2,-12(fp)
}
8113de10:	e037883a 	mov	sp,fp
8113de14:	dfc00117 	ldw	ra,4(sp)
8113de18:	df000017 	ldw	fp,0(sp)
8113de1c:	dec00204 	addi	sp,sp,8
8113de20:	f800283a 	ret

8113de24 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
8113de24:	defffb04 	addi	sp,sp,-20
8113de28:	de00012e 	bgeu	sp,et,8113de30 <get_dir_divider_location+0xc>
8113de2c:	003b68fa 	trap	3
8113de30:	dfc00415 	stw	ra,16(sp)
8113de34:	df000315 	stw	fp,12(sp)
8113de38:	df000304 	addi	fp,sp,12
8113de3c:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
8113de40:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
8113de44:	e13fff17 	ldw	r4,-4(fp)
8113de48:	111cf340 	call	8111cf34 <strlen>
8113de4c:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
8113de50:	e03ffd15 	stw	zero,-12(fp)
8113de54:	00001506 	br	8113deac <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8113de58:	e0bffd17 	ldw	r2,-12(fp)
8113de5c:	e0ffff17 	ldw	r3,-4(fp)
8113de60:	1885883a 	add	r2,r3,r2
8113de64:	10800003 	ldbu	r2,0(r2)
8113de68:	10803fcc 	andi	r2,r2,255
8113de6c:	1080201c 	xori	r2,r2,128
8113de70:	10bfe004 	addi	r2,r2,-128
8113de74:	10801720 	cmpeqi	r2,r2,92
8113de78:	10000f1e 	bne	r2,zero,8113deb8 <get_dir_divider_location+0x94>
8113de7c:	e0bffd17 	ldw	r2,-12(fp)
8113de80:	e0ffff17 	ldw	r3,-4(fp)
8113de84:	1885883a 	add	r2,r3,r2
8113de88:	10800003 	ldbu	r2,0(r2)
8113de8c:	10803fcc 	andi	r2,r2,255
8113de90:	1080201c 	xori	r2,r2,128
8113de94:	10bfe004 	addi	r2,r2,-128
8113de98:	10800be0 	cmpeqi	r2,r2,47
8113de9c:	1000061e 	bne	r2,zero,8113deb8 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
8113dea0:	e0bffd17 	ldw	r2,-12(fp)
8113dea4:	10800044 	addi	r2,r2,1
8113dea8:	e0bffd15 	stw	r2,-12(fp)
8113deac:	e0fffd17 	ldw	r3,-12(fp)
8113deb0:	e0bffe17 	ldw	r2,-8(fp)
8113deb4:	18bfe816 	blt	r3,r2,8113de58 <__reset+0xfb11de58>
        {
            break;
        }
    }
    
    if (index == length)
8113deb8:	e0fffd17 	ldw	r3,-12(fp)
8113debc:	e0bffe17 	ldw	r2,-8(fp)
8113dec0:	1880021e 	bne	r3,r2,8113decc <get_dir_divider_location+0xa8>
    {
        index = -1;
8113dec4:	00bfffc4 	movi	r2,-1
8113dec8:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8113decc:	e0bffd17 	ldw	r2,-12(fp)
}
8113ded0:	e037883a 	mov	sp,fp
8113ded4:	dfc00117 	ldw	ra,4(sp)
8113ded8:	df000017 	ldw	fp,0(sp)
8113dedc:	dec00204 	addi	sp,sp,8
8113dee0:	f800283a 	ret

8113dee4 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
8113dee4:	defffa04 	addi	sp,sp,-24
8113dee8:	de00012e 	bgeu	sp,et,8113def0 <match_file_record_to_name_ext+0xc>
8113deec:	003b68fa 	trap	3
8113def0:	df000515 	stw	fp,20(sp)
8113def4:	df000504 	addi	fp,sp,20
8113def8:	e13ffd15 	stw	r4,-12(fp)
8113defc:	e17ffe15 	stw	r5,-8(fp)
8113df00:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
8113df04:	00800044 	movi	r2,1
8113df08:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
8113df0c:	e03ffc15 	stw	zero,-16(fp)
8113df10:	00004606 	br	8113e02c <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
8113df14:	e0fffd17 	ldw	r3,-12(fp)
8113df18:	e0bffc17 	ldw	r2,-16(fp)
8113df1c:	1885883a 	add	r2,r3,r2
8113df20:	10800003 	ldbu	r2,0(r2)
8113df24:	10803fcc 	andi	r2,r2,255
8113df28:	10801870 	cmpltui	r2,r2,97
8113df2c:	1000101e 	bne	r2,zero,8113df70 <match_file_record_to_name_ext+0x8c>
8113df30:	e0fffd17 	ldw	r3,-12(fp)
8113df34:	e0bffc17 	ldw	r2,-16(fp)
8113df38:	1885883a 	add	r2,r3,r2
8113df3c:	10800003 	ldbu	r2,0(r2)
8113df40:	10803fcc 	andi	r2,r2,255
8113df44:	10801ee8 	cmpgeui	r2,r2,123
8113df48:	1000091e 	bne	r2,zero,8113df70 <match_file_record_to_name_ext+0x8c>
8113df4c:	e0fffd17 	ldw	r3,-12(fp)
8113df50:	e0bffc17 	ldw	r2,-16(fp)
8113df54:	1885883a 	add	r2,r3,r2
8113df58:	10800003 	ldbu	r2,0(r2)
8113df5c:	10bff804 	addi	r2,r2,-32
8113df60:	10c03fcc 	andi	r3,r2,255
8113df64:	18c0201c 	xori	r3,r3,128
8113df68:	18ffe004 	addi	r3,r3,-128
8113df6c:	00000706 	br	8113df8c <match_file_record_to_name_ext+0xa8>
8113df70:	e0fffd17 	ldw	r3,-12(fp)
8113df74:	e0bffc17 	ldw	r2,-16(fp)
8113df78:	1885883a 	add	r2,r3,r2
8113df7c:	10800003 	ldbu	r2,0(r2)
8113df80:	10c03fcc 	andi	r3,r2,255
8113df84:	18c0201c 	xori	r3,r3,128
8113df88:	18ffe004 	addi	r3,r3,-128
8113df8c:	e0bffc17 	ldw	r2,-16(fp)
8113df90:	e13ffe17 	ldw	r4,-8(fp)
8113df94:	2085883a 	add	r2,r4,r2
8113df98:	10800003 	ldbu	r2,0(r2)
8113df9c:	10803fcc 	andi	r2,r2,255
8113dfa0:	1080201c 	xori	r2,r2,128
8113dfa4:	10bfe004 	addi	r2,r2,-128
8113dfa8:	10801850 	cmplti	r2,r2,97
8113dfac:	1000121e 	bne	r2,zero,8113dff8 <match_file_record_to_name_ext+0x114>
8113dfb0:	e0bffc17 	ldw	r2,-16(fp)
8113dfb4:	e13ffe17 	ldw	r4,-8(fp)
8113dfb8:	2085883a 	add	r2,r4,r2
8113dfbc:	10800003 	ldbu	r2,0(r2)
8113dfc0:	10803fcc 	andi	r2,r2,255
8113dfc4:	1080201c 	xori	r2,r2,128
8113dfc8:	10bfe004 	addi	r2,r2,-128
8113dfcc:	10801ec8 	cmpgei	r2,r2,123
8113dfd0:	1000091e 	bne	r2,zero,8113dff8 <match_file_record_to_name_ext+0x114>
8113dfd4:	e0bffc17 	ldw	r2,-16(fp)
8113dfd8:	e13ffe17 	ldw	r4,-8(fp)
8113dfdc:	2085883a 	add	r2,r4,r2
8113dfe0:	10800003 	ldbu	r2,0(r2)
8113dfe4:	10bff804 	addi	r2,r2,-32
8113dfe8:	10803fcc 	andi	r2,r2,255
8113dfec:	1080201c 	xori	r2,r2,128
8113dff0:	10bfe004 	addi	r2,r2,-128
8113dff4:	00000706 	br	8113e014 <match_file_record_to_name_ext+0x130>
8113dff8:	e0bffc17 	ldw	r2,-16(fp)
8113dffc:	e13ffe17 	ldw	r4,-8(fp)
8113e000:	2085883a 	add	r2,r4,r2
8113e004:	10800003 	ldbu	r2,0(r2)
8113e008:	10803fcc 	andi	r2,r2,255
8113e00c:	1080201c 	xori	r2,r2,128
8113e010:	10bfe004 	addi	r2,r2,-128
8113e014:	18800226 	beq	r3,r2,8113e020 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
8113e018:	e03ffb15 	stw	zero,-20(fp)
			break;
8113e01c:	00000606 	br	8113e038 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
8113e020:	e0bffc17 	ldw	r2,-16(fp)
8113e024:	10800044 	addi	r2,r2,1
8113e028:	e0bffc15 	stw	r2,-16(fp)
8113e02c:	e0bffc17 	ldw	r2,-16(fp)
8113e030:	10800210 	cmplti	r2,r2,8
8113e034:	103fb71e 	bne	r2,zero,8113df14 <__reset+0xfb11df14>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113e038:	e03ffc15 	stw	zero,-16(fp)
8113e03c:	00004a06 	br	8113e168 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
8113e040:	e0fffd17 	ldw	r3,-12(fp)
8113e044:	e0bffc17 	ldw	r2,-16(fp)
8113e048:	1885883a 	add	r2,r3,r2
8113e04c:	10800204 	addi	r2,r2,8
8113e050:	10800003 	ldbu	r2,0(r2)
8113e054:	10803fcc 	andi	r2,r2,255
8113e058:	10801870 	cmpltui	r2,r2,97
8113e05c:	1000121e 	bne	r2,zero,8113e0a8 <match_file_record_to_name_ext+0x1c4>
8113e060:	e0fffd17 	ldw	r3,-12(fp)
8113e064:	e0bffc17 	ldw	r2,-16(fp)
8113e068:	1885883a 	add	r2,r3,r2
8113e06c:	10800204 	addi	r2,r2,8
8113e070:	10800003 	ldbu	r2,0(r2)
8113e074:	10803fcc 	andi	r2,r2,255
8113e078:	10801ee8 	cmpgeui	r2,r2,123
8113e07c:	10000a1e 	bne	r2,zero,8113e0a8 <match_file_record_to_name_ext+0x1c4>
8113e080:	e0fffd17 	ldw	r3,-12(fp)
8113e084:	e0bffc17 	ldw	r2,-16(fp)
8113e088:	1885883a 	add	r2,r3,r2
8113e08c:	10800204 	addi	r2,r2,8
8113e090:	10800003 	ldbu	r2,0(r2)
8113e094:	10bff804 	addi	r2,r2,-32
8113e098:	10c03fcc 	andi	r3,r2,255
8113e09c:	18c0201c 	xori	r3,r3,128
8113e0a0:	18ffe004 	addi	r3,r3,-128
8113e0a4:	00000806 	br	8113e0c8 <match_file_record_to_name_ext+0x1e4>
8113e0a8:	e0fffd17 	ldw	r3,-12(fp)
8113e0ac:	e0bffc17 	ldw	r2,-16(fp)
8113e0b0:	1885883a 	add	r2,r3,r2
8113e0b4:	10800204 	addi	r2,r2,8
8113e0b8:	10800003 	ldbu	r2,0(r2)
8113e0bc:	10c03fcc 	andi	r3,r2,255
8113e0c0:	18c0201c 	xori	r3,r3,128
8113e0c4:	18ffe004 	addi	r3,r3,-128
8113e0c8:	e0bffc17 	ldw	r2,-16(fp)
8113e0cc:	e13fff17 	ldw	r4,-4(fp)
8113e0d0:	2085883a 	add	r2,r4,r2
8113e0d4:	10800003 	ldbu	r2,0(r2)
8113e0d8:	10803fcc 	andi	r2,r2,255
8113e0dc:	1080201c 	xori	r2,r2,128
8113e0e0:	10bfe004 	addi	r2,r2,-128
8113e0e4:	10801850 	cmplti	r2,r2,97
8113e0e8:	1000121e 	bne	r2,zero,8113e134 <match_file_record_to_name_ext+0x250>
8113e0ec:	e0bffc17 	ldw	r2,-16(fp)
8113e0f0:	e13fff17 	ldw	r4,-4(fp)
8113e0f4:	2085883a 	add	r2,r4,r2
8113e0f8:	10800003 	ldbu	r2,0(r2)
8113e0fc:	10803fcc 	andi	r2,r2,255
8113e100:	1080201c 	xori	r2,r2,128
8113e104:	10bfe004 	addi	r2,r2,-128
8113e108:	10801ec8 	cmpgei	r2,r2,123
8113e10c:	1000091e 	bne	r2,zero,8113e134 <match_file_record_to_name_ext+0x250>
8113e110:	e0bffc17 	ldw	r2,-16(fp)
8113e114:	e13fff17 	ldw	r4,-4(fp)
8113e118:	2085883a 	add	r2,r4,r2
8113e11c:	10800003 	ldbu	r2,0(r2)
8113e120:	10bff804 	addi	r2,r2,-32
8113e124:	10803fcc 	andi	r2,r2,255
8113e128:	1080201c 	xori	r2,r2,128
8113e12c:	10bfe004 	addi	r2,r2,-128
8113e130:	00000706 	br	8113e150 <match_file_record_to_name_ext+0x26c>
8113e134:	e0bffc17 	ldw	r2,-16(fp)
8113e138:	e13fff17 	ldw	r4,-4(fp)
8113e13c:	2085883a 	add	r2,r4,r2
8113e140:	10800003 	ldbu	r2,0(r2)
8113e144:	10803fcc 	andi	r2,r2,255
8113e148:	1080201c 	xori	r2,r2,128
8113e14c:	10bfe004 	addi	r2,r2,-128
8113e150:	18800226 	beq	r3,r2,8113e15c <match_file_record_to_name_ext+0x278>
        {
            match = false;
8113e154:	e03ffb15 	stw	zero,-20(fp)
			break;
8113e158:	00000606 	br	8113e174 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113e15c:	e0bffc17 	ldw	r2,-16(fp)
8113e160:	10800044 	addi	r2,r2,1
8113e164:	e0bffc15 	stw	r2,-16(fp)
8113e168:	e0bffc17 	ldw	r2,-16(fp)
8113e16c:	108000d0 	cmplti	r2,r2,3
8113e170:	103fb31e 	bne	r2,zero,8113e040 <__reset+0xfb11e040>
        {
            match = false;
			break;
        }
    }
	return match;
8113e174:	e0bffb17 	ldw	r2,-20(fp)
}
8113e178:	e037883a 	mov	sp,fp
8113e17c:	df000017 	ldw	fp,0(sp)
8113e180:	dec00104 	addi	sp,sp,4
8113e184:	f800283a 	ret

8113e188 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8113e188:	deffe704 	addi	sp,sp,-100
8113e18c:	de00012e 	bgeu	sp,et,8113e194 <get_home_directory_cluster_for_file+0xc>
8113e190:	003b68fa 	trap	3
8113e194:	dfc01815 	stw	ra,96(sp)
8113e198:	df001715 	stw	fp,92(sp)
8113e19c:	df001704 	addi	fp,sp,92
8113e1a0:	e13ffd15 	stw	r4,-12(fp)
8113e1a4:	e17ffe15 	stw	r5,-8(fp)
8113e1a8:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
8113e1ac:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
8113e1b0:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
8113e1b4:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
8113e1b8:	e13ffd17 	ldw	r4,-12(fp)
8113e1bc:	113de240 	call	8113de24 <get_dir_divider_location>
8113e1c0:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
8113e1c4:	00012f06 	br	8113e684 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113e1c8:	00800804 	movi	r2,32
8113e1cc:	e0bff905 	stb	r2,-28(fp)
8113e1d0:	00800804 	movi	r2,32
8113e1d4:	e0bff945 	stb	r2,-27(fp)
8113e1d8:	00800804 	movi	r2,32
8113e1dc:	e0bff985 	stb	r2,-26(fp)
8113e1e0:	00800804 	movi	r2,32
8113e1e4:	e0bff9c5 	stb	r2,-25(fp)
8113e1e8:	00800804 	movi	r2,32
8113e1ec:	e0bffa05 	stb	r2,-24(fp)
8113e1f0:	00800804 	movi	r2,32
8113e1f4:	e0bffa45 	stb	r2,-23(fp)
8113e1f8:	00800804 	movi	r2,32
8113e1fc:	e0bffa85 	stb	r2,-22(fp)
8113e200:	00800804 	movi	r2,32
8113e204:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
8113e208:	00800804 	movi	r2,32
8113e20c:	e0bffb05 	stb	r2,-20(fp)
8113e210:	00800804 	movi	r2,32
8113e214:	e0bffb45 	stb	r2,-19(fp)
8113e218:	00800804 	movi	r2,32
8113e21c:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
8113e220:	00bfffc4 	movi	r2,-1
8113e224:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
8113e228:	e0bfea17 	ldw	r2,-88(fp)
8113e22c:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113e230:	e03fec15 	stw	zero,-80(fp)
8113e234:	00002d06 	br	8113e2ec <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
8113e238:	e0ffec17 	ldw	r3,-80(fp)
8113e23c:	e0bfed17 	ldw	r2,-76(fp)
8113e240:	1885883a 	add	r2,r3,r2
8113e244:	1007883a 	mov	r3,r2
8113e248:	e0bffd17 	ldw	r2,-12(fp)
8113e24c:	10c5883a 	add	r2,r2,r3
8113e250:	10800003 	ldbu	r2,0(r2)
8113e254:	10803fcc 	andi	r2,r2,255
8113e258:	1080201c 	xori	r2,r2,128
8113e25c:	10bfe004 	addi	r2,r2,-128
8113e260:	10800b98 	cmpnei	r2,r2,46
8113e264:	1000031e 	bne	r2,zero,8113e274 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8113e268:	e0bfec17 	ldw	r2,-80(fp)
8113e26c:	e0bfee15 	stw	r2,-72(fp)
8113e270:	00001b06 	br	8113e2e0 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
8113e274:	e0bfee17 	ldw	r2,-72(fp)
8113e278:	10000c0e 	bge	r2,zero,8113e2ac <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
8113e27c:	e0ffec17 	ldw	r3,-80(fp)
8113e280:	e0bfed17 	ldw	r2,-76(fp)
8113e284:	1885883a 	add	r2,r3,r2
8113e288:	1007883a 	mov	r3,r2
8113e28c:	e0bffd17 	ldw	r2,-12(fp)
8113e290:	10c5883a 	add	r2,r2,r3
8113e294:	10c00003 	ldbu	r3,0(r2)
8113e298:	e13ff904 	addi	r4,fp,-28
8113e29c:	e0bfec17 	ldw	r2,-80(fp)
8113e2a0:	2085883a 	add	r2,r4,r2
8113e2a4:	10c00005 	stb	r3,0(r2)
8113e2a8:	00000d06 	br	8113e2e0 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
8113e2ac:	e0ffec17 	ldw	r3,-80(fp)
8113e2b0:	e0bfee17 	ldw	r2,-72(fp)
8113e2b4:	1885c83a 	sub	r2,r3,r2
8113e2b8:	e13fec17 	ldw	r4,-80(fp)
8113e2bc:	e0ffed17 	ldw	r3,-76(fp)
8113e2c0:	20c7883a 	add	r3,r4,r3
8113e2c4:	1809883a 	mov	r4,r3
8113e2c8:	e0fffd17 	ldw	r3,-12(fp)
8113e2cc:	1907883a 	add	r3,r3,r4
8113e2d0:	18c00003 	ldbu	r3,0(r3)
8113e2d4:	e13ffb04 	addi	r4,fp,-20
8113e2d8:	2085883a 	add	r2,r4,r2
8113e2dc:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113e2e0:	e0bfec17 	ldw	r2,-80(fp)
8113e2e4:	10800044 	addi	r2,r2,1
8113e2e8:	e0bfec15 	stw	r2,-80(fp)
8113e2ec:	e0ffec17 	ldw	r3,-80(fp)
8113e2f0:	e0bfeb17 	ldw	r2,-84(fp)
8113e2f4:	18bfd016 	blt	r3,r2,8113e238 <__reset+0xfb11e238>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
8113e2f8:	e0bfea17 	ldw	r2,-88(fp)
8113e2fc:	10005c1e 	bne	r2,zero,8113e470 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113e300:	00a045b4 	movhi	r2,33046
8113e304:	1097c604 	addi	r2,r2,24344
8113e308:	1080050b 	ldhu	r2,20(r2)
8113e30c:	10bfffcc 	andi	r2,r2,65535
8113e310:	1006917a 	slli	r3,r2,5
8113e314:	00a045b4 	movhi	r2,33046
8113e318:	1097c604 	addi	r2,r2,24344
8113e31c:	1080030b 	ldhu	r2,12(r2)
8113e320:	10bfffcc 	andi	r2,r2,65535
8113e324:	1885283a 	div	r2,r3,r2
8113e328:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113e32c:	e03ff015 	stw	zero,-64(fp)
8113e330:	00003b06 	br	8113e420 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
8113e334:	00a045b4 	movhi	r2,33046
8113e338:	1097c604 	addi	r2,r2,24344
8113e33c:	10c01317 	ldw	r3,76(r2)
8113e340:	e0bff017 	ldw	r2,-64(fp)
8113e344:	1885883a 	add	r2,r3,r2
8113e348:	1007883a 	mov	r3,r2
8113e34c:	d0a0ab17 	ldw	r2,-32084(gp)
8113e350:	100b883a 	mov	r5,r2
8113e354:	1809883a 	mov	r4,r3
8113e358:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113e35c:	10003426 	beq	r2,zero,8113e430 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113e360:	e03ff115 	stw	zero,-60(fp)
8113e364:	00002506 	br	8113e3fc <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113e368:	e0bff117 	ldw	r2,-60(fp)
8113e36c:	1004917a 	slli	r2,r2,5
8113e370:	e0fff017 	ldw	r3,-64(fp)
8113e374:	180f883a 	mov	r7,r3
8113e378:	000d883a 	mov	r6,zero
8113e37c:	e17fff17 	ldw	r5,-4(fp)
8113e380:	1009883a 	mov	r4,r2
8113e384:	113ce500 	call	8113ce50 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113e388:	e0bfff17 	ldw	r2,-4(fp)
8113e38c:	10800003 	ldbu	r2,0(r2)
8113e390:	10803fcc 	andi	r2,r2,255
8113e394:	10803960 	cmpeqi	r2,r2,229
8113e398:	1000151e 	bne	r2,zero,8113e3f0 <get_home_directory_cluster_for_file+0x268>
8113e39c:	e0bfff17 	ldw	r2,-4(fp)
8113e3a0:	10800003 	ldbu	r2,0(r2)
8113e3a4:	10803fcc 	andi	r2,r2,255
8113e3a8:	10001126 	beq	r2,zero,8113e3f0 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113e3ac:	e0fffb04 	addi	r3,fp,-20
8113e3b0:	e0bff904 	addi	r2,fp,-28
8113e3b4:	180d883a 	mov	r6,r3
8113e3b8:	100b883a 	mov	r5,r2
8113e3bc:	e13fff17 	ldw	r4,-4(fp)
8113e3c0:	113dee40 	call	8113dee4 <match_file_record_to_name_ext>
8113e3c4:	e0bff815 	stw	r2,-32(fp)
                            if (match)
8113e3c8:	e0bff817 	ldw	r2,-32(fp)
8113e3cc:	10000826 	beq	r2,zero,8113e3f0 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
8113e3d0:	e0bfff17 	ldw	r2,-4(fp)
8113e3d4:	1080058b 	ldhu	r2,22(r2)
8113e3d8:	10bfffcc 	andi	r2,r2,65535
8113e3dc:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
8113e3e0:	e0bfff17 	ldw	r2,-4(fp)
8113e3e4:	00c00044 	movi	r3,1
8113e3e8:	10c00a15 	stw	r3,40(r2)
                                break;
8113e3ec:	00000606 	br	8113e408 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113e3f0:	e0bff117 	ldw	r2,-60(fp)
8113e3f4:	10800044 	addi	r2,r2,1
8113e3f8:	e0bff115 	stw	r2,-60(fp)
8113e3fc:	e0bff117 	ldw	r2,-60(fp)
8113e400:	10800410 	cmplti	r2,r2,16
8113e404:	103fd81e 	bne	r2,zero,8113e368 <__reset+0xfb11e368>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
8113e408:	e0ffef17 	ldw	r3,-68(fp)
8113e40c:	e0bfea17 	ldw	r2,-88(fp)
8113e410:	1880091e 	bne	r3,r2,8113e438 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113e414:	e0bff017 	ldw	r2,-64(fp)
8113e418:	10800044 	addi	r2,r2,1
8113e41c:	e0bff015 	stw	r2,-64(fp)
8113e420:	e0fff017 	ldw	r3,-64(fp)
8113e424:	e0bff717 	ldw	r2,-36(fp)
8113e428:	18bfc216 	blt	r3,r2,8113e334 <__reset+0xfb11e334>
8113e42c:	00000306 	br	8113e43c <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
8113e430:	0001883a 	nop
8113e434:	00000106 	br	8113e43c <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
8113e438:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
8113e43c:	e0ffef17 	ldw	r3,-68(fp)
8113e440:	e0bfea17 	ldw	r2,-88(fp)
8113e444:	18800826 	beq	r3,r2,8113e468 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113e448:	e0bfef17 	ldw	r2,-68(fp)
8113e44c:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113e450:	e0ffed17 	ldw	r3,-76(fp)
8113e454:	e0bfeb17 	ldw	r2,-84(fp)
8113e458:	1885883a 	add	r2,r3,r2
8113e45c:	10800044 	addi	r2,r2,1
8113e460:	e0bfed15 	stw	r2,-76(fp)
8113e464:	00007d06 	br	8113e65c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113e468:	0005883a 	mov	r2,zero
8113e46c:	00009106 	br	8113e6b4 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
8113e470:	e0bfea17 	ldw	r2,-88(fp)
8113e474:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113e478:	e0bff417 	ldw	r2,-48(fp)
8113e47c:	10ffff84 	addi	r3,r2,-2
8113e480:	00a045b4 	movhi	r2,33046
8113e484:	1097c604 	addi	r2,r2,24344
8113e488:	10800383 	ldbu	r2,14(r2)
8113e48c:	10803fcc 	andi	r2,r2,255
8113e490:	1885383a 	mul	r2,r3,r2
8113e494:	1007883a 	mov	r3,r2
8113e498:	00a045b4 	movhi	r2,33046
8113e49c:	1097c604 	addi	r2,r2,24344
8113e4a0:	10801417 	ldw	r2,80(r2)
8113e4a4:	1885883a 	add	r2,r3,r2
8113e4a8:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113e4ac:	e03ff215 	stw	zero,-56(fp)
8113e4b0:	00003606 	br	8113e58c <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113e4b4:	e0fff217 	ldw	r3,-56(fp)
8113e4b8:	e0bff517 	ldw	r2,-44(fp)
8113e4bc:	1885883a 	add	r2,r3,r2
8113e4c0:	d0e0ab17 	ldw	r3,-32084(gp)
8113e4c4:	180b883a 	mov	r5,r3
8113e4c8:	1009883a 	mov	r4,r2
8113e4cc:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113e4d0:	10003526 	beq	r2,zero,8113e5a8 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113e4d4:	e03ff315 	stw	zero,-52(fp)
8113e4d8:	00002306 	br	8113e568 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113e4dc:	e0bff317 	ldw	r2,-52(fp)
8113e4e0:	1004917a 	slli	r2,r2,5
8113e4e4:	e0fff417 	ldw	r3,-48(fp)
8113e4e8:	e13ff217 	ldw	r4,-56(fp)
8113e4ec:	200f883a 	mov	r7,r4
8113e4f0:	180d883a 	mov	r6,r3
8113e4f4:	e17fff17 	ldw	r5,-4(fp)
8113e4f8:	1009883a 	mov	r4,r2
8113e4fc:	113ce500 	call	8113ce50 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113e500:	e0bfff17 	ldw	r2,-4(fp)
8113e504:	10800003 	ldbu	r2,0(r2)
8113e508:	10803fcc 	andi	r2,r2,255
8113e50c:	10803960 	cmpeqi	r2,r2,229
8113e510:	1000121e 	bne	r2,zero,8113e55c <get_home_directory_cluster_for_file+0x3d4>
8113e514:	e0bfff17 	ldw	r2,-4(fp)
8113e518:	10800003 	ldbu	r2,0(r2)
8113e51c:	10803fcc 	andi	r2,r2,255
8113e520:	10000e26 	beq	r2,zero,8113e55c <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
8113e524:	e0fffb04 	addi	r3,fp,-20
8113e528:	e0bff904 	addi	r2,fp,-28
8113e52c:	180d883a 	mov	r6,r3
8113e530:	100b883a 	mov	r5,r2
8113e534:	e13fff17 	ldw	r4,-4(fp)
8113e538:	113dee40 	call	8113dee4 <match_file_record_to_name_ext>
8113e53c:	e0bff615 	stw	r2,-40(fp)
                                if (match)
8113e540:	e0bff617 	ldw	r2,-40(fp)
8113e544:	10000526 	beq	r2,zero,8113e55c <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
8113e548:	e0bfff17 	ldw	r2,-4(fp)
8113e54c:	1080058b 	ldhu	r2,22(r2)
8113e550:	10bfffcc 	andi	r2,r2,65535
8113e554:	e0bfef15 	stw	r2,-68(fp)
                                    break;
8113e558:	00000606 	br	8113e574 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113e55c:	e0bff317 	ldw	r2,-52(fp)
8113e560:	10800044 	addi	r2,r2,1
8113e564:	e0bff315 	stw	r2,-52(fp)
8113e568:	e0bff317 	ldw	r2,-52(fp)
8113e56c:	10800410 	cmplti	r2,r2,16
8113e570:	103fda1e 	bne	r2,zero,8113e4dc <__reset+0xfb11e4dc>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
8113e574:	e0ffef17 	ldw	r3,-68(fp)
8113e578:	e0bfea17 	ldw	r2,-88(fp)
8113e57c:	18800c1e 	bne	r3,r2,8113e5b0 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113e580:	e0bff217 	ldw	r2,-56(fp)
8113e584:	10800044 	addi	r2,r2,1
8113e588:	e0bff215 	stw	r2,-56(fp)
8113e58c:	00a045b4 	movhi	r2,33046
8113e590:	1097c604 	addi	r2,r2,24344
8113e594:	10800383 	ldbu	r2,14(r2)
8113e598:	10803fcc 	andi	r2,r2,255
8113e59c:	e0fff217 	ldw	r3,-56(fp)
8113e5a0:	18bfc416 	blt	r3,r2,8113e4b4 <__reset+0xfb11e4b4>
8113e5a4:	00000306 	br	8113e5b4 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
8113e5a8:	0001883a 	nop
8113e5ac:	00000106 	br	8113e5b4 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
8113e5b0:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
8113e5b4:	e0ffef17 	ldw	r3,-68(fp)
8113e5b8:	e0bfea17 	ldw	r2,-88(fp)
8113e5bc:	1880141e 	bne	r3,r2,8113e610 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
8113e5c0:	e0bfef17 	ldw	r2,-68(fp)
8113e5c4:	e0fffc04 	addi	r3,fp,-16
8113e5c8:	180b883a 	mov	r5,r3
8113e5cc:	1009883a 	mov	r4,r2
8113e5d0:	113cb000 	call	8113cb00 <get_cluster_flag>
8113e5d4:	10000c26 	beq	r2,zero,8113e608 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113e5d8:	e0bffc0b 	ldhu	r2,-16(fp)
8113e5dc:	10bfffcc 	andi	r2,r2,65535
8113e5e0:	10fffe0c 	andi	r3,r2,65528
8113e5e4:	00bffe14 	movui	r2,65528
8113e5e8:	1880021e 	bne	r3,r2,8113e5f4 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
8113e5ec:	0005883a 	mov	r2,zero
8113e5f0:	00003006 	br	8113e6b4 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
8113e5f4:	e0bffc0b 	ldhu	r2,-16(fp)
8113e5f8:	10bfffcc 	andi	r2,r2,65535
8113e5fc:	10bffe0c 	andi	r2,r2,65528
8113e600:	e0bfef15 	stw	r2,-68(fp)
8113e604:	00000206 	br	8113e610 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
8113e608:	0005883a 	mov	r2,zero
8113e60c:	00002906 	br	8113e6b4 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
8113e610:	e0bff417 	ldw	r2,-48(fp)
8113e614:	00fffdd4 	movui	r3,65527
8113e618:	18800316 	blt	r3,r2,8113e628 <get_home_directory_cluster_for_file+0x4a0>
8113e61c:	e0ffef17 	ldw	r3,-68(fp)
8113e620:	e0bfea17 	ldw	r2,-88(fp)
8113e624:	18bf9426 	beq	r3,r2,8113e478 <__reset+0xfb11e478>
            if (new_cluster != home_dir_cluster)
8113e628:	e0ffef17 	ldw	r3,-68(fp)
8113e62c:	e0bfea17 	ldw	r2,-88(fp)
8113e630:	18800826 	beq	r3,r2,8113e654 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113e634:	e0bfef17 	ldw	r2,-68(fp)
8113e638:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113e63c:	e0ffed17 	ldw	r3,-76(fp)
8113e640:	e0bfeb17 	ldw	r2,-84(fp)
8113e644:	1885883a 	add	r2,r3,r2
8113e648:	10800044 	addi	r2,r2,1
8113e64c:	e0bfed15 	stw	r2,-76(fp)
8113e650:	00000206 	br	8113e65c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113e654:	0005883a 	mov	r2,zero
8113e658:	00001606 	br	8113e6b4 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
8113e65c:	e0bfed17 	ldw	r2,-76(fp)
8113e660:	e0fffd17 	ldw	r3,-12(fp)
8113e664:	1885883a 	add	r2,r3,r2
8113e668:	1009883a 	mov	r4,r2
8113e66c:	113de240 	call	8113de24 <get_dir_divider_location>
8113e670:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
8113e674:	e0bfeb17 	ldw	r2,-84(fp)
8113e678:	1000020e 	bge	r2,zero,8113e684 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
8113e67c:	00800044 	movi	r2,1
8113e680:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
8113e684:	e0bfeb17 	ldw	r2,-84(fp)
8113e688:	00becf16 	blt	zero,r2,8113e1c8 <__reset+0xfb11e1c8>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
8113e68c:	e0bffe17 	ldw	r2,-8(fp)
8113e690:	e0ffea17 	ldw	r3,-88(fp)
8113e694:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
8113e698:	e0bfea17 	ldw	r2,-88(fp)
8113e69c:	1000041e 	bne	r2,zero,8113e6b0 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
8113e6a0:	e0bfff17 	ldw	r2,-4(fp)
8113e6a4:	10000a15 	stw	zero,40(r2)
		result = true;
8113e6a8:	00800044 	movi	r2,1
8113e6ac:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
8113e6b0:	e0bfe917 	ldw	r2,-92(fp)
}
8113e6b4:	e037883a 	mov	sp,fp
8113e6b8:	dfc00117 	ldw	ra,4(sp)
8113e6bc:	df000017 	ldw	fp,0(sp)
8113e6c0:	dec00204 	addi	sp,sp,8
8113e6c4:	f800283a 	ret

8113e6c8 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
8113e6c8:	deffe804 	addi	sp,sp,-96
8113e6cc:	de00012e 	bgeu	sp,et,8113e6d4 <find_file_in_directory+0xc>
8113e6d0:	003b68fa 	trap	3
8113e6d4:	dfc01715 	stw	ra,92(sp)
8113e6d8:	df001615 	stw	fp,88(sp)
8113e6dc:	df001604 	addi	fp,sp,88
8113e6e0:	e13ffd15 	stw	r4,-12(fp)
8113e6e4:	e17ffe15 	stw	r5,-8(fp)
8113e6e8:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
8113e6ec:	e13ffe17 	ldw	r4,-8(fp)
8113e6f0:	113de240 	call	8113de24 <get_dir_divider_location>
8113e6f4:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
8113e6f8:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113e6fc:	00800804 	movi	r2,32
8113e700:	e0bff905 	stb	r2,-28(fp)
8113e704:	00800804 	movi	r2,32
8113e708:	e0bff945 	stb	r2,-27(fp)
8113e70c:	00800804 	movi	r2,32
8113e710:	e0bff985 	stb	r2,-26(fp)
8113e714:	00800804 	movi	r2,32
8113e718:	e0bff9c5 	stb	r2,-25(fp)
8113e71c:	00800804 	movi	r2,32
8113e720:	e0bffa05 	stb	r2,-24(fp)
8113e724:	00800804 	movi	r2,32
8113e728:	e0bffa45 	stb	r2,-23(fp)
8113e72c:	00800804 	movi	r2,32
8113e730:	e0bffa85 	stb	r2,-22(fp)
8113e734:	00800804 	movi	r2,32
8113e738:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
8113e73c:	00800804 	movi	r2,32
8113e740:	e0bffb05 	stb	r2,-20(fp)
8113e744:	00800804 	movi	r2,32
8113e748:	e0bffb45 	stb	r2,-19(fp)
8113e74c:	00800804 	movi	r2,32
8113e750:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
8113e754:	00bfffc4 	movi	r2,-1
8113e758:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
8113e75c:	e0bffd17 	ldw	r2,-12(fp)
8113e760:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
8113e764:	e13ffe17 	ldw	r4,-8(fp)
8113e768:	111cf340 	call	8111cf34 <strlen>
8113e76c:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
8113e770:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
8113e774:	00000b06 	br	8113e7a4 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
8113e778:	e0ffeb17 	ldw	r3,-84(fp)
8113e77c:	e0bfea17 	ldw	r2,-88(fp)
8113e780:	1885883a 	add	r2,r3,r2
8113e784:	10800044 	addi	r2,r2,1
8113e788:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
8113e78c:	e0bfeb17 	ldw	r2,-84(fp)
8113e790:	e0fffe17 	ldw	r3,-8(fp)
8113e794:	1885883a 	add	r2,r3,r2
8113e798:	1009883a 	mov	r4,r2
8113e79c:	113de240 	call	8113de24 <get_dir_divider_location>
8113e7a0:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
8113e7a4:	e0bfea17 	ldw	r2,-88(fp)
8113e7a8:	00bff316 	blt	zero,r2,8113e778 <__reset+0xfb11e778>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113e7ac:	e0bfeb17 	ldw	r2,-84(fp)
8113e7b0:	e0bfee15 	stw	r2,-72(fp)
8113e7b4:	00002706 	br	8113e854 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
8113e7b8:	e0bfee17 	ldw	r2,-72(fp)
8113e7bc:	e0fffe17 	ldw	r3,-8(fp)
8113e7c0:	1885883a 	add	r2,r3,r2
8113e7c4:	10800003 	ldbu	r2,0(r2)
8113e7c8:	10803fcc 	andi	r2,r2,255
8113e7cc:	1080201c 	xori	r2,r2,128
8113e7d0:	10bfe004 	addi	r2,r2,-128
8113e7d4:	10800b98 	cmpnei	r2,r2,46
8113e7d8:	1000031e 	bne	r2,zero,8113e7e8 <find_file_in_directory+0x120>
        {
            ext_index = index;
8113e7dc:	e0bfee17 	ldw	r2,-72(fp)
8113e7e0:	e0bfec15 	stw	r2,-80(fp)
8113e7e4:	00001806 	br	8113e848 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
8113e7e8:	e0bfec17 	ldw	r2,-80(fp)
8113e7ec:	10000b0e 	bge	r2,zero,8113e81c <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8113e7f0:	e0ffee17 	ldw	r3,-72(fp)
8113e7f4:	e0bfeb17 	ldw	r2,-84(fp)
8113e7f8:	1885c83a 	sub	r2,r3,r2
8113e7fc:	e0ffee17 	ldw	r3,-72(fp)
8113e800:	e13ffe17 	ldw	r4,-8(fp)
8113e804:	20c7883a 	add	r3,r4,r3
8113e808:	18c00003 	ldbu	r3,0(r3)
8113e80c:	e13ff904 	addi	r4,fp,-28
8113e810:	2085883a 	add	r2,r4,r2
8113e814:	10c00005 	stb	r3,0(r2)
8113e818:	00000b06 	br	8113e848 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
8113e81c:	e0ffee17 	ldw	r3,-72(fp)
8113e820:	e0bfec17 	ldw	r2,-80(fp)
8113e824:	1885c83a 	sub	r2,r3,r2
8113e828:	10bfffc4 	addi	r2,r2,-1
8113e82c:	e0ffee17 	ldw	r3,-72(fp)
8113e830:	e13ffe17 	ldw	r4,-8(fp)
8113e834:	20c7883a 	add	r3,r4,r3
8113e838:	18c00003 	ldbu	r3,0(r3)
8113e83c:	e13ffb04 	addi	r4,fp,-20
8113e840:	2085883a 	add	r2,r4,r2
8113e844:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113e848:	e0bfee17 	ldw	r2,-72(fp)
8113e84c:	10800044 	addi	r2,r2,1
8113e850:	e0bfee15 	stw	r2,-72(fp)
8113e854:	e0ffee17 	ldw	r3,-72(fp)
8113e858:	e0bff417 	ldw	r2,-48(fp)
8113e85c:	18bfd616 	blt	r3,r2,8113e7b8 <__reset+0xfb11e7b8>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
8113e860:	e0bffd17 	ldw	r2,-12(fp)
8113e864:	1000461e 	bne	r2,zero,8113e980 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113e868:	00a045b4 	movhi	r2,33046
8113e86c:	1097c604 	addi	r2,r2,24344
8113e870:	1080050b 	ldhu	r2,20(r2)
8113e874:	10bfffcc 	andi	r2,r2,65535
8113e878:	1006917a 	slli	r3,r2,5
8113e87c:	00a045b4 	movhi	r2,33046
8113e880:	1097c604 	addi	r2,r2,24344
8113e884:	1080030b 	ldhu	r2,12(r2)
8113e888:	10bfffcc 	andi	r2,r2,65535
8113e88c:	1885283a 	div	r2,r3,r2
8113e890:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113e894:	e03ff015 	stw	zero,-64(fp)
8113e898:	00003506 	br	8113e970 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113e89c:	00a045b4 	movhi	r2,33046
8113e8a0:	1097c604 	addi	r2,r2,24344
8113e8a4:	10c01317 	ldw	r3,76(r2)
8113e8a8:	e0bff017 	ldw	r2,-64(fp)
8113e8ac:	1885883a 	add	r2,r3,r2
8113e8b0:	1007883a 	mov	r3,r2
8113e8b4:	d0a0ab17 	ldw	r2,-32084(gp)
8113e8b8:	100b883a 	mov	r5,r2
8113e8bc:	1809883a 	mov	r4,r3
8113e8c0:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113e8c4:	10009626 	beq	r2,zero,8113eb20 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113e8c8:	e03ff115 	stw	zero,-60(fp)
8113e8cc:	00002006 	br	8113e950 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113e8d0:	e0bff117 	ldw	r2,-60(fp)
8113e8d4:	1004917a 	slli	r2,r2,5
8113e8d8:	e0fff017 	ldw	r3,-64(fp)
8113e8dc:	180f883a 	mov	r7,r3
8113e8e0:	000d883a 	mov	r6,zero
8113e8e4:	e17fff17 	ldw	r5,-4(fp)
8113e8e8:	1009883a 	mov	r4,r2
8113e8ec:	113ce500 	call	8113ce50 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113e8f0:	e0bfff17 	ldw	r2,-4(fp)
8113e8f4:	10800003 	ldbu	r2,0(r2)
8113e8f8:	10803fcc 	andi	r2,r2,255
8113e8fc:	10803960 	cmpeqi	r2,r2,229
8113e900:	1000101e 	bne	r2,zero,8113e944 <find_file_in_directory+0x27c>
8113e904:	e0bfff17 	ldw	r2,-4(fp)
8113e908:	10800003 	ldbu	r2,0(r2)
8113e90c:	10803fcc 	andi	r2,r2,255
8113e910:	10000c26 	beq	r2,zero,8113e944 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
8113e914:	e0fffb04 	addi	r3,fp,-20
8113e918:	e0bff904 	addi	r2,fp,-28
8113e91c:	180d883a 	mov	r6,r3
8113e920:	100b883a 	mov	r5,r2
8113e924:	e13fff17 	ldw	r4,-4(fp)
8113e928:	113dee40 	call	8113dee4 <match_file_record_to_name_ext>
8113e92c:	e0bff815 	stw	r2,-32(fp)

                        if (match)
8113e930:	e0bff817 	ldw	r2,-32(fp)
8113e934:	10000326 	beq	r2,zero,8113e944 <find_file_in_directory+0x27c>
                        {
                            result = true;
8113e938:	00800044 	movi	r2,1
8113e93c:	e0bfef15 	stw	r2,-68(fp)
                            break;
8113e940:	00000606 	br	8113e95c <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113e944:	e0bff117 	ldw	r2,-60(fp)
8113e948:	10800044 	addi	r2,r2,1
8113e94c:	e0bff115 	stw	r2,-60(fp)
8113e950:	e0bff117 	ldw	r2,-60(fp)
8113e954:	10800410 	cmplti	r2,r2,16
8113e958:	103fdd1e 	bne	r2,zero,8113e8d0 <__reset+0xfb11e8d0>
            }
            else
            {
                break;
            }
            if (result)
8113e95c:	e0bfef17 	ldw	r2,-68(fp)
8113e960:	1000711e 	bne	r2,zero,8113eb28 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113e964:	e0bff017 	ldw	r2,-64(fp)
8113e968:	10800044 	addi	r2,r2,1
8113e96c:	e0bff015 	stw	r2,-64(fp)
8113e970:	e0fff017 	ldw	r3,-64(fp)
8113e974:	e0bff717 	ldw	r2,-36(fp)
8113e978:	18bfc816 	blt	r3,r2,8113e89c <__reset+0xfb11e89c>
8113e97c:	00006b06 	br	8113eb2c <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113e980:	e0bfed17 	ldw	r2,-76(fp)
8113e984:	10ffff84 	addi	r3,r2,-2
8113e988:	00a045b4 	movhi	r2,33046
8113e98c:	1097c604 	addi	r2,r2,24344
8113e990:	10800383 	ldbu	r2,14(r2)
8113e994:	10803fcc 	andi	r2,r2,255
8113e998:	1885383a 	mul	r2,r3,r2
8113e99c:	1007883a 	mov	r3,r2
8113e9a0:	00a045b4 	movhi	r2,33046
8113e9a4:	1097c604 	addi	r2,r2,24344
8113e9a8:	10801417 	ldw	r2,80(r2)
8113e9ac:	1885883a 	add	r2,r3,r2
8113e9b0:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113e9b4:	e03ff215 	stw	zero,-56(fp)
8113e9b8:	00003306 	br	8113ea88 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113e9bc:	e0fff217 	ldw	r3,-56(fp)
8113e9c0:	e0bff517 	ldw	r2,-44(fp)
8113e9c4:	1885883a 	add	r2,r3,r2
8113e9c8:	d0e0ab17 	ldw	r3,-32084(gp)
8113e9cc:	180b883a 	mov	r5,r3
8113e9d0:	1009883a 	mov	r4,r2
8113e9d4:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113e9d8:	10003226 	beq	r2,zero,8113eaa4 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113e9dc:	e03ff315 	stw	zero,-52(fp)
8113e9e0:	00002106 	br	8113ea68 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113e9e4:	e0bff317 	ldw	r2,-52(fp)
8113e9e8:	1004917a 	slli	r2,r2,5
8113e9ec:	e0ffed17 	ldw	r3,-76(fp)
8113e9f0:	e13ff217 	ldw	r4,-56(fp)
8113e9f4:	200f883a 	mov	r7,r4
8113e9f8:	180d883a 	mov	r6,r3
8113e9fc:	e17fff17 	ldw	r5,-4(fp)
8113ea00:	1009883a 	mov	r4,r2
8113ea04:	113ce500 	call	8113ce50 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113ea08:	e0bfff17 	ldw	r2,-4(fp)
8113ea0c:	10800003 	ldbu	r2,0(r2)
8113ea10:	10803fcc 	andi	r2,r2,255
8113ea14:	10803960 	cmpeqi	r2,r2,229
8113ea18:	1000101e 	bne	r2,zero,8113ea5c <find_file_in_directory+0x394>
8113ea1c:	e0bfff17 	ldw	r2,-4(fp)
8113ea20:	10800003 	ldbu	r2,0(r2)
8113ea24:	10803fcc 	andi	r2,r2,255
8113ea28:	10000c26 	beq	r2,zero,8113ea5c <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113ea2c:	e0fffb04 	addi	r3,fp,-20
8113ea30:	e0bff904 	addi	r2,fp,-28
8113ea34:	180d883a 	mov	r6,r3
8113ea38:	100b883a 	mov	r5,r2
8113ea3c:	e13fff17 	ldw	r4,-4(fp)
8113ea40:	113dee40 	call	8113dee4 <match_file_record_to_name_ext>
8113ea44:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8113ea48:	e0bff617 	ldw	r2,-40(fp)
8113ea4c:	10000326 	beq	r2,zero,8113ea5c <find_file_in_directory+0x394>
                            {                               
                                result = true;
8113ea50:	00800044 	movi	r2,1
8113ea54:	e0bfef15 	stw	r2,-68(fp)
                                break;
8113ea58:	00000606 	br	8113ea74 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113ea5c:	e0bff317 	ldw	r2,-52(fp)
8113ea60:	10800044 	addi	r2,r2,1
8113ea64:	e0bff315 	stw	r2,-52(fp)
8113ea68:	e0bff317 	ldw	r2,-52(fp)
8113ea6c:	10800410 	cmplti	r2,r2,16
8113ea70:	103fdc1e 	bne	r2,zero,8113e9e4 <__reset+0xfb11e9e4>
                }
                else
                {
                    break;
                }
                if (result)
8113ea74:	e0bfef17 	ldw	r2,-68(fp)
8113ea78:	10000c1e 	bne	r2,zero,8113eaac <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113ea7c:	e0bff217 	ldw	r2,-56(fp)
8113ea80:	10800044 	addi	r2,r2,1
8113ea84:	e0bff215 	stw	r2,-56(fp)
8113ea88:	00a045b4 	movhi	r2,33046
8113ea8c:	1097c604 	addi	r2,r2,24344
8113ea90:	10800383 	ldbu	r2,14(r2)
8113ea94:	10803fcc 	andi	r2,r2,255
8113ea98:	e0fff217 	ldw	r3,-56(fp)
8113ea9c:	18bfc716 	blt	r3,r2,8113e9bc <__reset+0xfb11e9bc>
8113eaa0:	00000306 	br	8113eab0 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
8113eaa4:	0001883a 	nop
8113eaa8:	00000106 	br	8113eab0 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8113eaac:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
8113eab0:	e0bfef17 	ldw	r2,-68(fp)
8113eab4:	1000141e 	bne	r2,zero,8113eb08 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
8113eab8:	e0bfed17 	ldw	r2,-76(fp)
8113eabc:	e0fffc04 	addi	r3,fp,-16
8113eac0:	180b883a 	mov	r5,r3
8113eac4:	1009883a 	mov	r4,r2
8113eac8:	113cb000 	call	8113cb00 <get_cluster_flag>
8113eacc:	10000c26 	beq	r2,zero,8113eb00 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113ead0:	e0bffc0b 	ldhu	r2,-16(fp)
8113ead4:	10bfffcc 	andi	r2,r2,65535
8113ead8:	10fffe0c 	andi	r3,r2,65528
8113eadc:	00bffe14 	movui	r2,65528
8113eae0:	1880021e 	bne	r3,r2,8113eaec <find_file_in_directory+0x424>
					{
						return false;
8113eae4:	0005883a 	mov	r2,zero
8113eae8:	00001106 	br	8113eb30 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8113eaec:	e0bffc0b 	ldhu	r2,-16(fp)
8113eaf0:	10bfffcc 	andi	r2,r2,65535
8113eaf4:	10bffe0c 	andi	r2,r2,65528
8113eaf8:	e0bfed15 	stw	r2,-76(fp)
8113eafc:	00000206 	br	8113eb08 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8113eb00:	0005883a 	mov	r2,zero
8113eb04:	00000a06 	br	8113eb30 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
8113eb08:	e0bfed17 	ldw	r2,-76(fp)
8113eb0c:	00fffdd4 	movui	r3,65527
8113eb10:	18800616 	blt	r3,r2,8113eb2c <find_file_in_directory+0x464>
8113eb14:	e0bfef17 	ldw	r2,-68(fp)
8113eb18:	103f9926 	beq	r2,zero,8113e980 <__reset+0xfb11e980>
8113eb1c:	00000306 	br	8113eb2c <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8113eb20:	0001883a 	nop
8113eb24:	00000106 	br	8113eb2c <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
8113eb28:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
8113eb2c:	e0bfef17 	ldw	r2,-68(fp)
}
8113eb30:	e037883a 	mov	sp,fp
8113eb34:	dfc00117 	ldw	ra,4(sp)
8113eb38:	df000017 	ldw	fp,0(sp)
8113eb3c:	dec00204 	addi	sp,sp,8
8113eb40:	f800283a 	ret

8113eb44 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
8113eb44:	defff504 	addi	sp,sp,-44
8113eb48:	de00012e 	bgeu	sp,et,8113eb50 <find_first_empty_cluster+0xc>
8113eb4c:	003b68fa 	trap	3
8113eb50:	dfc00a15 	stw	ra,40(sp)
8113eb54:	df000915 	stw	fp,36(sp)
8113eb58:	df000904 	addi	fp,sp,36
8113eb5c:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
8113eb60:	00a045b4 	movhi	r2,33046
8113eb64:	1097c604 	addi	r2,r2,24344
8113eb68:	10801117 	ldw	r2,68(r2)
8113eb6c:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
8113eb70:	00800084 	movi	r2,2
8113eb74:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8113eb78:	00bfffc4 	movi	r2,-1
8113eb7c:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
8113eb80:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
8113eb84:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8113eb88:	00a045b4 	movhi	r2,33046
8113eb8c:	1097c604 	addi	r2,r2,24344
8113eb90:	10801417 	ldw	r2,80(r2)
8113eb94:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
8113eb98:	00a045b4 	movhi	r2,33046
8113eb9c:	1097c604 	addi	r2,r2,24344
8113eba0:	1080058b 	ldhu	r2,22(r2)
8113eba4:	10bfffcc 	andi	r2,r2,65535
8113eba8:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8113ebac:	00a045b4 	movhi	r2,33046
8113ebb0:	1097c604 	addi	r2,r2,24344
8113ebb4:	10800917 	ldw	r2,36(r2)
8113ebb8:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8113ebbc:	e0bffd17 	ldw	r2,-12(fp)
8113ebc0:	e0fffe17 	ldw	r3,-8(fp)
8113ebc4:	18800b2e 	bgeu	r3,r2,8113ebf4 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113ebc8:	e0fffd17 	ldw	r3,-12(fp)
8113ebcc:	e0bffc17 	ldw	r2,-16(fp)
8113ebd0:	1887c83a 	sub	r3,r3,r2
8113ebd4:	00a045b4 	movhi	r2,33046
8113ebd8:	1097c604 	addi	r2,r2,24344
8113ebdc:	10800383 	ldbu	r2,14(r2)
8113ebe0:	10803fcc 	andi	r2,r2,255
8113ebe4:	1885203a 	divu	r2,r3,r2
8113ebe8:	10800044 	addi	r2,r2,1
8113ebec:	e0bffb15 	stw	r2,-20(fp)
8113ebf0:	00002a06 	br	8113ec9c <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113ebf4:	e0fffe17 	ldw	r3,-8(fp)
8113ebf8:	e0bffc17 	ldw	r2,-16(fp)
8113ebfc:	1887c83a 	sub	r3,r3,r2
8113ec00:	00a045b4 	movhi	r2,33046
8113ec04:	1097c604 	addi	r2,r2,24344
8113ec08:	10800383 	ldbu	r2,14(r2)
8113ec0c:	10803fcc 	andi	r2,r2,255
8113ec10:	1885203a 	divu	r2,r3,r2
8113ec14:	10800044 	addi	r2,r2,1
8113ec18:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113ec1c:	00001f06 	br	8113ec9c <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8113ec20:	e0bff717 	ldw	r2,-36(fp)
8113ec24:	d0e0ab17 	ldw	r3,-32084(gp)
8113ec28:	180b883a 	mov	r5,r3
8113ec2c:	1009883a 	mov	r4,r2
8113ec30:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113ec34:	10001426 	beq	r2,zero,8113ec88 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
8113ec38:	e0bff817 	ldw	r2,-32(fp)
8113ec3c:	10803fcc 	andi	r2,r2,255
8113ec40:	1085883a 	add	r2,r2,r2
8113ec44:	1007883a 	mov	r3,r2
8113ec48:	d0a0ad17 	ldw	r2,-32076(gp)
8113ec4c:	10800a17 	ldw	r2,40(r2)
8113ec50:	1885883a 	add	r2,r3,r2
8113ec54:	1080002b 	ldhuio	r2,0(r2)
8113ec58:	10bfffcc 	andi	r2,r2,65535
8113ec5c:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
8113ec60:	e0bff90f 	ldh	r2,-28(fp)
8113ec64:	10000726 	beq	r2,zero,8113ec84 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8113ec68:	e0bff817 	ldw	r2,-32(fp)
8113ec6c:	10800044 	addi	r2,r2,1
8113ec70:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
8113ec74:	e0bff817 	ldw	r2,-32(fp)
8113ec78:	10803fcc 	andi	r2,r2,255
8113ec7c:	103fee1e 	bne	r2,zero,8113ec38 <__reset+0xfb11ec38>
8113ec80:	00000106 	br	8113ec88 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
8113ec84:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8113ec88:	e0bff90f 	ldh	r2,-28(fp)
8113ec8c:	10000926 	beq	r2,zero,8113ecb4 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
8113ec90:	e0bff717 	ldw	r2,-36(fp)
8113ec94:	10800044 	addi	r2,r2,1
8113ec98:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113ec9c:	00a045b4 	movhi	r2,33046
8113eca0:	1097c604 	addi	r2,r2,24344
8113eca4:	10c01217 	ldw	r3,72(r2)
8113eca8:	e0bff717 	ldw	r2,-36(fp)
8113ecac:	18bfdc1e 	bne	r3,r2,8113ec20 <__reset+0xfb11ec20>
8113ecb0:	00000106 	br	8113ecb8 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
8113ecb4:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8113ecb8:	e0bff90f 	ldh	r2,-28(fp)
8113ecbc:	1000081e 	bne	r2,zero,8113ece0 <find_first_empty_cluster+0x19c>
8113ecc0:	e0bff90f 	ldh	r2,-28(fp)
8113ecc4:	e0fffb17 	ldw	r3,-20(fp)
8113ecc8:	18800536 	bltu	r3,r2,8113ece0 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8113eccc:	e0bfff17 	ldw	r2,-4(fp)
8113ecd0:	e0fff817 	ldw	r3,-32(fp)
8113ecd4:	10c00015 	stw	r3,0(r2)
		result = true;
8113ecd8:	00800044 	movi	r2,1
8113ecdc:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
8113ece0:	e0bffa17 	ldw	r2,-24(fp)
}
8113ece4:	e037883a 	mov	sp,fp
8113ece8:	dfc00117 	ldw	ra,4(sp)
8113ecec:	df000017 	ldw	fp,0(sp)
8113ecf0:	dec00204 	addi	sp,sp,8
8113ecf4:	f800283a 	ret

8113ecf8 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8113ecf8:	defff604 	addi	sp,sp,-40
8113ecfc:	de00012e 	bgeu	sp,et,8113ed04 <find_first_empty_record_in_a_subdirectory+0xc>
8113ed00:	003b68fa 	trap	3
8113ed04:	dfc00915 	stw	ra,36(sp)
8113ed08:	df000815 	stw	fp,32(sp)
8113ed0c:	df000804 	addi	fp,sp,32
8113ed10:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
8113ed14:	00bfffc4 	movi	r2,-1
8113ed18:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
8113ed1c:	e0bfff17 	ldw	r2,-4(fp)
8113ed20:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113ed24:	e0bff917 	ldw	r2,-28(fp)
8113ed28:	10ffff84 	addi	r3,r2,-2
8113ed2c:	00a045b4 	movhi	r2,33046
8113ed30:	1097c604 	addi	r2,r2,24344
8113ed34:	10800383 	ldbu	r2,14(r2)
8113ed38:	10803fcc 	andi	r2,r2,255
8113ed3c:	1885383a 	mul	r2,r3,r2
8113ed40:	1007883a 	mov	r3,r2
8113ed44:	00a045b4 	movhi	r2,33046
8113ed48:	1097c604 	addi	r2,r2,24344
8113ed4c:	10801417 	ldw	r2,80(r2)
8113ed50:	1885883a 	add	r2,r3,r2
8113ed54:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113ed58:	e03ffa15 	stw	zero,-24(fp)
8113ed5c:	00002c06 	br	8113ee10 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113ed60:	e0fffa17 	ldw	r3,-24(fp)
8113ed64:	e0bffc17 	ldw	r2,-16(fp)
8113ed68:	1885883a 	add	r2,r3,r2
8113ed6c:	d0e0ab17 	ldw	r3,-32084(gp)
8113ed70:	180b883a 	mov	r5,r3
8113ed74:	1009883a 	mov	r4,r2
8113ed78:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113ed7c:	10002b26 	beq	r2,zero,8113ee2c <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113ed80:	e03ffb15 	stw	zero,-20(fp)
8113ed84:	00001c06 	br	8113edf8 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113ed88:	e0bffb17 	ldw	r2,-20(fp)
8113ed8c:	1004917a 	slli	r2,r2,5
8113ed90:	1007883a 	mov	r3,r2
8113ed94:	d0a0ad17 	ldw	r2,-32076(gp)
8113ed98:	10800a17 	ldw	r2,40(r2)
8113ed9c:	1885883a 	add	r2,r3,r2
8113eda0:	10800023 	ldbuio	r2,0(r2)
8113eda4:	10803fcc 	andi	r2,r2,255
8113eda8:	10803fcc 	andi	r2,r2,255
8113edac:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
8113edb0:	e0bffd0b 	ldhu	r2,-12(fp)
8113edb4:	10803960 	cmpeqi	r2,r2,229
8113edb8:	1000021e 	bne	r2,zero,8113edc4 <find_first_empty_record_in_a_subdirectory+0xcc>
8113edbc:	e0bffd0b 	ldhu	r2,-12(fp)
8113edc0:	10000a1e 	bne	r2,zero,8113edec <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
8113edc4:	e0bffa17 	ldw	r2,-24(fp)
8113edc8:	1006913a 	slli	r3,r2,4
8113edcc:	e0bffb17 	ldw	r2,-20(fp)
8113edd0:	1885883a 	add	r2,r3,r2
8113edd4:	1006943a 	slli	r3,r2,16
8113edd8:	e0bff917 	ldw	r2,-28(fp)
8113eddc:	1884b03a 	or	r2,r3,r2
8113ede0:	e0bff815 	stw	r2,-32(fp)
                        return result;
8113ede4:	e0bff817 	ldw	r2,-32(fp)
8113ede8:	00005306 	br	8113ef38 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113edec:	e0bffb17 	ldw	r2,-20(fp)
8113edf0:	10800044 	addi	r2,r2,1
8113edf4:	e0bffb15 	stw	r2,-20(fp)
8113edf8:	e0bffb17 	ldw	r2,-20(fp)
8113edfc:	10800410 	cmplti	r2,r2,16
8113ee00:	103fe11e 	bne	r2,zero,8113ed88 <__reset+0xfb11ed88>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113ee04:	e0bffa17 	ldw	r2,-24(fp)
8113ee08:	10800044 	addi	r2,r2,1
8113ee0c:	e0bffa15 	stw	r2,-24(fp)
8113ee10:	00a045b4 	movhi	r2,33046
8113ee14:	1097c604 	addi	r2,r2,24344
8113ee18:	10800383 	ldbu	r2,14(r2)
8113ee1c:	10803fcc 	andi	r2,r2,255
8113ee20:	e0fffa17 	ldw	r3,-24(fp)
8113ee24:	18bfce16 	blt	r3,r2,8113ed60 <__reset+0xfb11ed60>
8113ee28:	00000106 	br	8113ee30 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
8113ee2c:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
8113ee30:	e0bff817 	ldw	r2,-32(fp)
8113ee34:	1000390e 	bge	r2,zero,8113ef1c <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8113ee38:	e0bff917 	ldw	r2,-28(fp)
8113ee3c:	e0fffd84 	addi	r3,fp,-10
8113ee40:	180b883a 	mov	r5,r3
8113ee44:	1009883a 	mov	r4,r2
8113ee48:	113cb000 	call	8113cb00 <get_cluster_flag>
8113ee4c:	10003126 	beq	r2,zero,8113ef14 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113ee50:	e0bffd8b 	ldhu	r2,-10(fp)
8113ee54:	10bfffcc 	andi	r2,r2,65535
8113ee58:	10fffe0c 	andi	r3,r2,65528
8113ee5c:	00bffe14 	movui	r2,65528
8113ee60:	18802e1e 	bne	r3,r2,8113ef1c <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
8113ee64:	e0bffe04 	addi	r2,fp,-8
8113ee68:	1009883a 	mov	r4,r2
8113ee6c:	113eb440 	call	8113eb44 <find_first_empty_cluster>
8113ee70:	10002326 	beq	r2,zero,8113ef00 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113ee74:	e0bff917 	ldw	r2,-28(fp)
8113ee78:	e0fffe17 	ldw	r3,-8(fp)
8113ee7c:	18ffffcc 	andi	r3,r3,65535
8113ee80:	18e0001c 	xori	r3,r3,32768
8113ee84:	18e00004 	addi	r3,r3,-32768
8113ee88:	01800044 	movi	r6,1
8113ee8c:	180b883a 	mov	r5,r3
8113ee90:	1009883a 	mov	r4,r2
8113ee94:	113cbbc0 	call	8113cbbc <mark_cluster>
8113ee98:	10001926 	beq	r2,zero,8113ef00 <find_first_empty_record_in_a_subdirectory+0x208>
8113ee9c:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113eea0:	01800044 	movi	r6,1
8113eea4:	017fffc4 	movi	r5,-1
8113eea8:	1009883a 	mov	r4,r2
8113eeac:	113cbbc0 	call	8113cbbc <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113eeb0:	10001326 	beq	r2,zero,8113ef00 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113eeb4:	e0bff917 	ldw	r2,-28(fp)
8113eeb8:	e0fffe17 	ldw	r3,-8(fp)
8113eebc:	18ffffcc 	andi	r3,r3,65535
8113eec0:	18e0001c 	xori	r3,r3,32768
8113eec4:	18e00004 	addi	r3,r3,-32768
8113eec8:	000d883a 	mov	r6,zero
8113eecc:	180b883a 	mov	r5,r3
8113eed0:	1009883a 	mov	r4,r2
8113eed4:	113cbbc0 	call	8113cbbc <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113eed8:	10000926 	beq	r2,zero,8113ef00 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113eedc:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
8113eee0:	000d883a 	mov	r6,zero
8113eee4:	017fffc4 	movi	r5,-1
8113eee8:	1009883a 	mov	r4,r2
8113eeec:	113cbbc0 	call	8113cbbc <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113eef0:	10000326 	beq	r2,zero,8113ef00 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
8113eef4:	113c9cc0 	call	8113c9cc <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
8113eef8:	e0bffe17 	ldw	r2,-8(fp)
8113eefc:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
8113ef00:	e0bffd8b 	ldhu	r2,-10(fp)
8113ef04:	10bfffcc 	andi	r2,r2,65535
8113ef08:	10bffe0c 	andi	r2,r2,65528
8113ef0c:	e0bff915 	stw	r2,-28(fp)
8113ef10:	00000206 	br	8113ef1c <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
8113ef14:	00bfffc4 	movi	r2,-1
8113ef18:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
8113ef1c:	e0bff917 	ldw	r2,-28(fp)
8113ef20:	00fffdd4 	movui	r3,65527
8113ef24:	18800316 	blt	r3,r2,8113ef34 <find_first_empty_record_in_a_subdirectory+0x23c>
8113ef28:	e0bff817 	ldw	r2,-32(fp)
8113ef2c:	10bfffe0 	cmpeqi	r2,r2,-1
8113ef30:	103f7c1e 	bne	r2,zero,8113ed24 <__reset+0xfb11ed24>
    return result; 
8113ef34:	e0bff817 	ldw	r2,-32(fp)
}
8113ef38:	e037883a 	mov	sp,fp
8113ef3c:	dfc00117 	ldw	ra,4(sp)
8113ef40:	df000017 	ldw	fp,0(sp)
8113ef44:	dec00204 	addi	sp,sp,8
8113ef48:	f800283a 	ret

8113ef4c <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
8113ef4c:	defff904 	addi	sp,sp,-28
8113ef50:	de00012e 	bgeu	sp,et,8113ef58 <find_first_empty_record_in_root_directory+0xc>
8113ef54:	003b68fa 	trap	3
8113ef58:	dfc00615 	stw	ra,24(sp)
8113ef5c:	df000515 	stw	fp,20(sp)
8113ef60:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113ef64:	00a045b4 	movhi	r2,33046
8113ef68:	1097c604 	addi	r2,r2,24344
8113ef6c:	1080050b 	ldhu	r2,20(r2)
8113ef70:	10bfffcc 	andi	r2,r2,65535
8113ef74:	1006917a 	slli	r3,r2,5
8113ef78:	00a045b4 	movhi	r2,33046
8113ef7c:	1097c604 	addi	r2,r2,24344
8113ef80:	1080030b 	ldhu	r2,12(r2)
8113ef84:	10bfffcc 	andi	r2,r2,65535
8113ef88:	1885283a 	div	r2,r3,r2
8113ef8c:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
8113ef90:	00bfffc4 	movi	r2,-1
8113ef94:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113ef98:	e03ffb15 	stw	zero,-20(fp)
8113ef9c:	00002d06 	br	8113f054 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113efa0:	00a045b4 	movhi	r2,33046
8113efa4:	1097c604 	addi	r2,r2,24344
8113efa8:	10c01317 	ldw	r3,76(r2)
8113efac:	e0bffb17 	ldw	r2,-20(fp)
8113efb0:	1885883a 	add	r2,r3,r2
8113efb4:	1007883a 	mov	r3,r2
8113efb8:	d0a0ab17 	ldw	r2,-32084(gp)
8113efbc:	100b883a 	mov	r5,r2
8113efc0:	1809883a 	mov	r4,r3
8113efc4:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113efc8:	10002626 	beq	r2,zero,8113f064 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113efcc:	e03ffc15 	stw	zero,-16(fp)
8113efd0:	00001a06 	br	8113f03c <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113efd4:	e0bffc17 	ldw	r2,-16(fp)
8113efd8:	1004917a 	slli	r2,r2,5
8113efdc:	1007883a 	mov	r3,r2
8113efe0:	d0a0ad17 	ldw	r2,-32076(gp)
8113efe4:	10800a17 	ldw	r2,40(r2)
8113efe8:	1885883a 	add	r2,r3,r2
8113efec:	10800023 	ldbuio	r2,0(r2)
8113eff0:	10803fcc 	andi	r2,r2,255
8113eff4:	10803fcc 	andi	r2,r2,255
8113eff8:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
8113effc:	e0bfff0b 	ldhu	r2,-4(fp)
8113f000:	10803960 	cmpeqi	r2,r2,229
8113f004:	1000021e 	bne	r2,zero,8113f010 <find_first_empty_record_in_root_directory+0xc4>
8113f008:	e0bfff0b 	ldhu	r2,-4(fp)
8113f00c:	1000081e 	bne	r2,zero,8113f030 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
8113f010:	e0bffb17 	ldw	r2,-20(fp)
8113f014:	1006913a 	slli	r3,r2,4
8113f018:	e0bffc17 	ldw	r2,-16(fp)
8113f01c:	1885883a 	add	r2,r3,r2
8113f020:	1004943a 	slli	r2,r2,16
8113f024:	e0bffe15 	stw	r2,-8(fp)
                    return result;
8113f028:	e0bffe17 	ldw	r2,-8(fp)
8113f02c:	00000f06 	br	8113f06c <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113f030:	e0bffc17 	ldw	r2,-16(fp)
8113f034:	10800044 	addi	r2,r2,1
8113f038:	e0bffc15 	stw	r2,-16(fp)
8113f03c:	e0bffc17 	ldw	r2,-16(fp)
8113f040:	10800410 	cmplti	r2,r2,16
8113f044:	103fe31e 	bne	r2,zero,8113efd4 <__reset+0xfb11efd4>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113f048:	e0bffb17 	ldw	r2,-20(fp)
8113f04c:	10800044 	addi	r2,r2,1
8113f050:	e0bffb15 	stw	r2,-20(fp)
8113f054:	e0fffb17 	ldw	r3,-20(fp)
8113f058:	e0bffd17 	ldw	r2,-12(fp)
8113f05c:	18bfd016 	blt	r3,r2,8113efa0 <__reset+0xfb11efa0>
8113f060:	00000106 	br	8113f068 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
8113f064:	0001883a 	nop
        }
    }
    return result;
8113f068:	e0bffe17 	ldw	r2,-8(fp)
}
8113f06c:	e037883a 	mov	sp,fp
8113f070:	dfc00117 	ldw	ra,4(sp)
8113f074:	df000017 	ldw	fp,0(sp)
8113f078:	dec00204 	addi	sp,sp,8
8113f07c:	f800283a 	ret

8113f080 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
8113f080:	defffa04 	addi	sp,sp,-24
8113f084:	de00012e 	bgeu	sp,et,8113f08c <convert_filename_to_name_extension+0xc>
8113f088:	003b68fa 	trap	3
8113f08c:	df000515 	stw	fp,20(sp)
8113f090:	df000504 	addi	fp,sp,20
8113f094:	e13ffd15 	stw	r4,-12(fp)
8113f098:	e17ffe15 	stw	r5,-8(fp)
8113f09c:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
8113f0a0:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
8113f0a4:	e03ffb15 	stw	zero,-20(fp)
8113f0a8:	00002506 	br	8113f140 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8113f0ac:	e0bffc17 	ldw	r2,-16(fp)
8113f0b0:	e0fffd17 	ldw	r3,-12(fp)
8113f0b4:	1885883a 	add	r2,r3,r2
8113f0b8:	10800003 	ldbu	r2,0(r2)
8113f0bc:	10803fcc 	andi	r2,r2,255
8113f0c0:	1080201c 	xori	r2,r2,128
8113f0c4:	10bfe004 	addi	r2,r2,-128
8113f0c8:	10800ba0 	cmpeqi	r2,r2,46
8113f0cc:	1000141e 	bne	r2,zero,8113f120 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
8113f0d0:	e0bffb17 	ldw	r2,-20(fp)
8113f0d4:	e0fffe17 	ldw	r3,-8(fp)
8113f0d8:	1885883a 	add	r2,r3,r2
8113f0dc:	e0fffc17 	ldw	r3,-16(fp)
8113f0e0:	e13ffd17 	ldw	r4,-12(fp)
8113f0e4:	20c7883a 	add	r3,r4,r3
8113f0e8:	18c00003 	ldbu	r3,0(r3)
8113f0ec:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
8113f0f0:	e0bffc17 	ldw	r2,-16(fp)
8113f0f4:	e0fffd17 	ldw	r3,-12(fp)
8113f0f8:	1885883a 	add	r2,r3,r2
8113f0fc:	10800003 	ldbu	r2,0(r2)
8113f100:	10803fcc 	andi	r2,r2,255
8113f104:	1080201c 	xori	r2,r2,128
8113f108:	10bfe004 	addi	r2,r2,-128
8113f10c:	10000926 	beq	r2,zero,8113f134 <convert_filename_to_name_extension+0xb4>
8113f110:	e0bffc17 	ldw	r2,-16(fp)
8113f114:	10800044 	addi	r2,r2,1
8113f118:	e0bffc15 	stw	r2,-16(fp)
8113f11c:	00000506 	br	8113f134 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
8113f120:	e0bffb17 	ldw	r2,-20(fp)
8113f124:	e0fffe17 	ldw	r3,-8(fp)
8113f128:	1885883a 	add	r2,r3,r2
8113f12c:	00c00804 	movi	r3,32
8113f130:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
8113f134:	e0bffb17 	ldw	r2,-20(fp)
8113f138:	10800044 	addi	r2,r2,1
8113f13c:	e0bffb15 	stw	r2,-20(fp)
8113f140:	e0bffb17 	ldw	r2,-20(fp)
8113f144:	10800210 	cmplti	r2,r2,8
8113f148:	103fd81e 	bne	r2,zero,8113f0ac <__reset+0xfb11f0ac>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
8113f14c:	e0bffc17 	ldw	r2,-16(fp)
8113f150:	e0fffd17 	ldw	r3,-12(fp)
8113f154:	1885883a 	add	r2,r3,r2
8113f158:	10800003 	ldbu	r2,0(r2)
8113f15c:	10803fcc 	andi	r2,r2,255
8113f160:	1080201c 	xori	r2,r2,128
8113f164:	10bfe004 	addi	r2,r2,-128
8113f168:	10800b98 	cmpnei	r2,r2,46
8113f16c:	1000031e 	bne	r2,zero,8113f17c <convert_filename_to_name_extension+0xfc>
8113f170:	e0bffc17 	ldw	r2,-16(fp)
8113f174:	10800044 	addi	r2,r2,1
8113f178:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
8113f17c:	e03ffb15 	stw	zero,-20(fp)
8113f180:	00001c06 	br	8113f1f4 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
8113f184:	e0bffc17 	ldw	r2,-16(fp)
8113f188:	e0fffd17 	ldw	r3,-12(fp)
8113f18c:	1885883a 	add	r2,r3,r2
8113f190:	10800003 	ldbu	r2,0(r2)
8113f194:	10803fcc 	andi	r2,r2,255
8113f198:	1080201c 	xori	r2,r2,128
8113f19c:	10bfe004 	addi	r2,r2,-128
8113f1a0:	10000c26 	beq	r2,zero,8113f1d4 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
8113f1a4:	e0bffb17 	ldw	r2,-20(fp)
8113f1a8:	e0ffff17 	ldw	r3,-4(fp)
8113f1ac:	1885883a 	add	r2,r3,r2
8113f1b0:	e0fffc17 	ldw	r3,-16(fp)
8113f1b4:	e13ffd17 	ldw	r4,-12(fp)
8113f1b8:	20c7883a 	add	r3,r4,r3
8113f1bc:	18c00003 	ldbu	r3,0(r3)
8113f1c0:	10c00005 	stb	r3,0(r2)
            local++;
8113f1c4:	e0bffc17 	ldw	r2,-16(fp)
8113f1c8:	10800044 	addi	r2,r2,1
8113f1cc:	e0bffc15 	stw	r2,-16(fp)
8113f1d0:	00000506 	br	8113f1e8 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
8113f1d4:	e0bffb17 	ldw	r2,-20(fp)
8113f1d8:	e0ffff17 	ldw	r3,-4(fp)
8113f1dc:	1885883a 	add	r2,r3,r2
8113f1e0:	00c00804 	movi	r3,32
8113f1e4:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
8113f1e8:	e0bffb17 	ldw	r2,-20(fp)
8113f1ec:	10800044 	addi	r2,r2,1
8113f1f0:	e0bffb15 	stw	r2,-20(fp)
8113f1f4:	e0bffb17 	ldw	r2,-20(fp)
8113f1f8:	108000d0 	cmplti	r2,r2,3
8113f1fc:	103fe11e 	bne	r2,zero,8113f184 <__reset+0xfb11f184>
        {
            extension[counter] = ' ';
        }
    }

}
8113f200:	0001883a 	nop
8113f204:	e037883a 	mov	sp,fp
8113f208:	df000017 	ldw	fp,0(sp)
8113f20c:	dec00104 	addi	sp,sp,4
8113f210:	f800283a 	ret

8113f214 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
8113f214:	defff504 	addi	sp,sp,-44
8113f218:	de00012e 	bgeu	sp,et,8113f220 <create_file+0xc>
8113f21c:	003b68fa 	trap	3
8113f220:	dfc00a15 	stw	ra,40(sp)
8113f224:	df000915 	stw	fp,36(sp)
8113f228:	df000904 	addi	fp,sp,36
8113f22c:	e13ffd15 	stw	r4,-12(fp)
8113f230:	e17ffe15 	stw	r5,-8(fp)
8113f234:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
8113f238:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
8113f23c:	e0bffc04 	addi	r2,fp,-16
8113f240:	1009883a 	mov	r4,r2
8113f244:	113eb440 	call	8113eb44 <find_first_empty_cluster>
8113f248:	1000a026 	beq	r2,zero,8113f4cc <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
8113f24c:	e0bfff17 	ldw	r2,-4(fp)
8113f250:	10800a17 	ldw	r2,40(r2)
8113f254:	1000031e 	bne	r2,zero,8113f264 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
8113f258:	113ef4c0 	call	8113ef4c <find_first_empty_record_in_root_directory>
8113f25c:	e0bff815 	stw	r2,-32(fp)
8113f260:	00000606 	br	8113f27c <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
8113f264:	e0bfff17 	ldw	r2,-4(fp)
8113f268:	1080058b 	ldhu	r2,22(r2)
8113f26c:	10bfffcc 	andi	r2,r2,65535
8113f270:	1009883a 	mov	r4,r2
8113f274:	113ecf80 	call	8113ecf8 <find_first_empty_record_in_a_subdirectory>
8113f278:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
8113f27c:	e0bff817 	ldw	r2,-32(fp)
8113f280:	10009216 	blt	r2,zero,8113f4cc <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
8113f284:	e13ffd17 	ldw	r4,-12(fp)
8113f288:	113de240 	call	8113de24 <get_dir_divider_location>
8113f28c:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
8113f290:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
8113f294:	00000b06 	br	8113f2c4 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
8113f298:	e0fffa17 	ldw	r3,-24(fp)
8113f29c:	e0bff917 	ldw	r2,-28(fp)
8113f2a0:	1885883a 	add	r2,r3,r2
8113f2a4:	10800044 	addi	r2,r2,1
8113f2a8:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
8113f2ac:	e0bffa17 	ldw	r2,-24(fp)
8113f2b0:	e0fffd17 	ldw	r3,-12(fp)
8113f2b4:	1885883a 	add	r2,r3,r2
8113f2b8:	1009883a 	mov	r4,r2
8113f2bc:	113de240 	call	8113de24 <get_dir_divider_location>
8113f2c0:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
8113f2c4:	e0bff917 	ldw	r2,-28(fp)
8113f2c8:	00bff316 	blt	zero,r2,8113f298 <__reset+0xfb11f298>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
8113f2cc:	e0bffa17 	ldw	r2,-24(fp)
8113f2d0:	e0fffd17 	ldw	r3,-12(fp)
8113f2d4:	1887883a 	add	r3,r3,r2
8113f2d8:	e13ffe17 	ldw	r4,-8(fp)
8113f2dc:	e0bffe17 	ldw	r2,-8(fp)
8113f2e0:	10800204 	addi	r2,r2,8
8113f2e4:	100d883a 	mov	r6,r2
8113f2e8:	200b883a 	mov	r5,r4
8113f2ec:	1809883a 	mov	r4,r3
8113f2f0:	113f0800 	call	8113f080 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
8113f2f4:	e0bffe17 	ldw	r2,-8(fp)
8113f2f8:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
8113f2fc:	e0bffe17 	ldw	r2,-8(fp)
8113f300:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
8113f304:	e0bffe17 	ldw	r2,-8(fp)
8113f308:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
8113f30c:	e0bffe17 	ldw	r2,-8(fp)
8113f310:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
8113f314:	e0bffe17 	ldw	r2,-8(fp)
8113f318:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
8113f31c:	e0bffe17 	ldw	r2,-8(fp)
8113f320:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
8113f324:	e0bffc17 	ldw	r2,-16(fp)
8113f328:	1007883a 	mov	r3,r2
8113f32c:	e0bffe17 	ldw	r2,-8(fp)
8113f330:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
8113f334:	e0bffe17 	ldw	r2,-8(fp)
8113f338:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
8113f33c:	e0fffc17 	ldw	r3,-16(fp)
8113f340:	e0bffe17 	ldw	r2,-8(fp)
8113f344:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
8113f348:	e0bffe17 	ldw	r2,-8(fp)
8113f34c:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
8113f350:	e0bffe17 	ldw	r2,-8(fp)
8113f354:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
8113f358:	e0bff817 	ldw	r2,-32(fp)
8113f35c:	10ffffcc 	andi	r3,r2,65535
8113f360:	e0bffe17 	ldw	r2,-8(fp)
8113f364:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
8113f368:	e0bff817 	ldw	r2,-32(fp)
8113f36c:	1004d43a 	srli	r2,r2,16
8113f370:	1000010e 	bge	r2,zero,8113f378 <create_file+0x164>
8113f374:	108003c4 	addi	r2,r2,15
8113f378:	1005d13a 	srai	r2,r2,4
8113f37c:	1007883a 	mov	r3,r2
8113f380:	e0bffe17 	ldw	r2,-8(fp)
8113f384:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
8113f388:	e0bff817 	ldw	r2,-32(fp)
8113f38c:	1004d43a 	srli	r2,r2,16
8113f390:	1007883a 	mov	r3,r2
8113f394:	00a00034 	movhi	r2,32768
8113f398:	108003c4 	addi	r2,r2,15
8113f39c:	1884703a 	and	r2,r3,r2
8113f3a0:	1000040e 	bge	r2,zero,8113f3b4 <create_file+0x1a0>
8113f3a4:	10bfffc4 	addi	r2,r2,-1
8113f3a8:	00fffc04 	movi	r3,-16
8113f3ac:	10c4b03a 	or	r2,r2,r3
8113f3b0:	10800044 	addi	r2,r2,1
8113f3b4:	1004917a 	slli	r2,r2,5
8113f3b8:	1007883a 	mov	r3,r2
8113f3bc:	e0bffe17 	ldw	r2,-8(fp)
8113f3c0:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
8113f3c4:	e0bfff17 	ldw	r2,-4(fp)
8113f3c8:	1080058b 	ldhu	r2,22(r2)
8113f3cc:	10ffffcc 	andi	r3,r2,65535
8113f3d0:	e0bffe17 	ldw	r2,-8(fp)
8113f3d4:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
8113f3d8:	e0bffe17 	ldw	r2,-8(fp)
8113f3dc:	00c00044 	movi	r3,1
8113f3e0:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
8113f3e4:	e0bffe17 	ldw	r2,-8(fp)
8113f3e8:	00c00044 	movi	r3,1
8113f3ec:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113f3f0:	e0bffe17 	ldw	r2,-8(fp)
8113f3f4:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113f3f8:	1000071e 	bne	r2,zero,8113f418 <create_file+0x204>
8113f3fc:	00a045b4 	movhi	r2,33046
8113f400:	1097c604 	addi	r2,r2,24344
8113f404:	10c01317 	ldw	r3,76(r2)
8113f408:	e0bffe17 	ldw	r2,-8(fp)
8113f40c:	10800b17 	ldw	r2,44(r2)
8113f410:	1885883a 	add	r2,r3,r2
8113f414:	00000f06 	br	8113f454 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
8113f418:	00a045b4 	movhi	r2,33046
8113f41c:	1097c604 	addi	r2,r2,24344
8113f420:	10c01417 	ldw	r3,80(r2)
8113f424:	e0bffe17 	ldw	r2,-8(fp)
8113f428:	10800a17 	ldw	r2,40(r2)
8113f42c:	113fff84 	addi	r4,r2,-2
8113f430:	00a045b4 	movhi	r2,33046
8113f434:	1097c604 	addi	r2,r2,24344
8113f438:	10800383 	ldbu	r2,14(r2)
8113f43c:	10803fcc 	andi	r2,r2,255
8113f440:	2085383a 	mul	r2,r4,r2
8113f444:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
8113f448:	e0bffe17 	ldw	r2,-8(fp)
8113f44c:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113f450:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113f454:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
8113f458:	e0bffb17 	ldw	r2,-20(fp)
8113f45c:	d0e0ab17 	ldw	r3,-32084(gp)
8113f460:	180b883a 	mov	r5,r3
8113f464:	1009883a 	mov	r4,r2
8113f468:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113f46c:	10001726 	beq	r2,zero,8113f4cc <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
8113f470:	e0bffe17 	ldw	r2,-8(fp)
8113f474:	10800c0b 	ldhu	r2,48(r2)
8113f478:	10bfffcc 	andi	r2,r2,65535
8113f47c:	10a0001c 	xori	r2,r2,32768
8113f480:	10a00004 	addi	r2,r2,-32768
8113f484:	e17ffe17 	ldw	r5,-8(fp)
8113f488:	1009883a 	mov	r4,r2
8113f48c:	113d0d40 	call	8113d0d4 <Write_File_Record_At_Offset>
8113f490:	10000e26 	beq	r2,zero,8113f4cc <create_file+0x2b8>
                {
                    Save_Modified_Sector();
8113f494:	113c9cc0 	call	8113c9cc <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
8113f498:	e0bffc17 	ldw	r2,-16(fp)
8113f49c:	01800044 	movi	r6,1
8113f4a0:	017fffc4 	movi	r5,-1
8113f4a4:	1009883a 	mov	r4,r2
8113f4a8:	113cbbc0 	call	8113cbbc <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
8113f4ac:	e0bffc17 	ldw	r2,-16(fp)
8113f4b0:	000d883a 	mov	r6,zero
8113f4b4:	017fffc4 	movi	r5,-1
8113f4b8:	1009883a 	mov	r4,r2
8113f4bc:	113cbbc0 	call	8113cbbc <mark_cluster>
8113f4c0:	10000226 	beq	r2,zero,8113f4cc <create_file+0x2b8>
                    {
                        result = true;
8113f4c4:	00800044 	movi	r2,1
8113f4c8:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
8113f4cc:	e0bff717 	ldw	r2,-36(fp)
}
8113f4d0:	e037883a 	mov	sp,fp
8113f4d4:	dfc00117 	ldw	ra,4(sp)
8113f4d8:	df000017 	ldw	fp,0(sp)
8113f4dc:	dec00204 	addi	sp,sp,8
8113f4e0:	f800283a 	ret

8113f4e4 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
8113f4e4:	defffb04 	addi	sp,sp,-20
8113f4e8:	de00012e 	bgeu	sp,et,8113f4f0 <copy_file_record_name_to_string+0xc>
8113f4ec:	003b68fa 	trap	3
8113f4f0:	df000415 	stw	fp,16(sp)
8113f4f4:	df000404 	addi	fp,sp,16
8113f4f8:	e13ffe15 	stw	r4,-8(fp)
8113f4fc:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
8113f500:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113f504:	e03ffc15 	stw	zero,-16(fp)
8113f508:	00001506 	br	8113f560 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
8113f50c:	e0fffe17 	ldw	r3,-8(fp)
8113f510:	e0bffc17 	ldw	r2,-16(fp)
8113f514:	1885883a 	add	r2,r3,r2
8113f518:	10800003 	ldbu	r2,0(r2)
8113f51c:	10803fcc 	andi	r2,r2,255
8113f520:	10800820 	cmpeqi	r2,r2,32
8113f524:	10000b1e 	bne	r2,zero,8113f554 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
8113f528:	e0bffd17 	ldw	r2,-12(fp)
8113f52c:	e0ffff17 	ldw	r3,-4(fp)
8113f530:	1885883a 	add	r2,r3,r2
8113f534:	e13ffe17 	ldw	r4,-8(fp)
8113f538:	e0fffc17 	ldw	r3,-16(fp)
8113f53c:	20c7883a 	add	r3,r4,r3
8113f540:	18c00003 	ldbu	r3,0(r3)
8113f544:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
8113f548:	e0bffd17 	ldw	r2,-12(fp)
8113f54c:	10800044 	addi	r2,r2,1
8113f550:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113f554:	e0bffc17 	ldw	r2,-16(fp)
8113f558:	10800044 	addi	r2,r2,1
8113f55c:	e0bffc15 	stw	r2,-16(fp)
8113f560:	e0bffc17 	ldw	r2,-16(fp)
8113f564:	10800210 	cmplti	r2,r2,8
8113f568:	103fe81e 	bne	r2,zero,8113f50c <__reset+0xfb11f50c>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
8113f56c:	e0bffe17 	ldw	r2,-8(fp)
8113f570:	10800203 	ldbu	r2,8(r2)
8113f574:	10803fcc 	andi	r2,r2,255
8113f578:	10800820 	cmpeqi	r2,r2,32
8113f57c:	1000241e 	bne	r2,zero,8113f610 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
8113f580:	e0bffd17 	ldw	r2,-12(fp)
8113f584:	e0ffff17 	ldw	r3,-4(fp)
8113f588:	1885883a 	add	r2,r3,r2
8113f58c:	00c00b84 	movi	r3,46
8113f590:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
8113f594:	e0bffd17 	ldw	r2,-12(fp)
8113f598:	10800044 	addi	r2,r2,1
8113f59c:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
8113f5a0:	e03ffc15 	stw	zero,-16(fp)
8113f5a4:	00001706 	br	8113f604 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
8113f5a8:	e0fffe17 	ldw	r3,-8(fp)
8113f5ac:	e0bffc17 	ldw	r2,-16(fp)
8113f5b0:	1885883a 	add	r2,r3,r2
8113f5b4:	10800204 	addi	r2,r2,8
8113f5b8:	10800003 	ldbu	r2,0(r2)
8113f5bc:	10803fcc 	andi	r2,r2,255
8113f5c0:	10800820 	cmpeqi	r2,r2,32
8113f5c4:	10000c1e 	bne	r2,zero,8113f5f8 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
8113f5c8:	e0bffd17 	ldw	r2,-12(fp)
8113f5cc:	e0ffff17 	ldw	r3,-4(fp)
8113f5d0:	1885883a 	add	r2,r3,r2
8113f5d4:	e13ffe17 	ldw	r4,-8(fp)
8113f5d8:	e0fffc17 	ldw	r3,-16(fp)
8113f5dc:	20c7883a 	add	r3,r4,r3
8113f5e0:	18c00204 	addi	r3,r3,8
8113f5e4:	18c00003 	ldbu	r3,0(r3)
8113f5e8:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
8113f5ec:	e0bffd17 	ldw	r2,-12(fp)
8113f5f0:	10800044 	addi	r2,r2,1
8113f5f4:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
8113f5f8:	e0bffc17 	ldw	r2,-16(fp)
8113f5fc:	10800044 	addi	r2,r2,1
8113f600:	e0bffc15 	stw	r2,-16(fp)
8113f604:	e0bffc17 	ldw	r2,-16(fp)
8113f608:	108000d0 	cmplti	r2,r2,3
8113f60c:	103fe61e 	bne	r2,zero,8113f5a8 <__reset+0xfb11f5a8>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
8113f610:	e0bffd17 	ldw	r2,-12(fp)
8113f614:	e0ffff17 	ldw	r3,-4(fp)
8113f618:	1885883a 	add	r2,r3,r2
8113f61c:	10000005 	stb	zero,0(r2)
}
8113f620:	0001883a 	nop
8113f624:	e037883a 	mov	sp,fp
8113f628:	df000017 	ldw	fp,0(sp)
8113f62c:	dec00104 	addi	sp,sp,4
8113f630:	f800283a 	ret

8113f634 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
8113f634:	defffc04 	addi	sp,sp,-16
8113f638:	de00012e 	bgeu	sp,et,8113f640 <alt_up_sd_card_open_dev+0xc>
8113f63c:	003b68fa 	trap	3
8113f640:	dfc00315 	stw	ra,12(sp)
8113f644:	df000215 	stw	fp,8(sp)
8113f648:	df000204 	addi	fp,sp,8
8113f64c:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
8113f650:	d1600d04 	addi	r5,gp,-32716
8113f654:	e13fff17 	ldw	r4,-4(fp)
8113f658:	1144af00 	call	81144af0 <alt_find_dev>
8113f65c:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
8113f660:	e0bffe17 	ldw	r2,-8(fp)
8113f664:	10001e26 	beq	r2,zero,8113f6e0 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
8113f668:	e0bffe17 	ldw	r2,-8(fp)
8113f66c:	10800a17 	ldw	r2,40(r2)
8113f670:	10808d04 	addi	r2,r2,564
8113f674:	d0a0a515 	stw	r2,-32108(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
8113f678:	e0bffe17 	ldw	r2,-8(fp)
8113f67c:	10800a17 	ldw	r2,40(r2)
8113f680:	10808904 	addi	r2,r2,548
8113f684:	d0a0a615 	stw	r2,-32104(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
8113f688:	e0bffe17 	ldw	r2,-8(fp)
8113f68c:	10800a17 	ldw	r2,40(r2)
8113f690:	10808404 	addi	r2,r2,528
8113f694:	d0a0a715 	stw	r2,-32100(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
8113f698:	e0bffe17 	ldw	r2,-8(fp)
8113f69c:	10800a17 	ldw	r2,40(r2)
8113f6a0:	10808c04 	addi	r2,r2,560
8113f6a4:	d0a0a815 	stw	r2,-32096(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
8113f6a8:	e0bffe17 	ldw	r2,-8(fp)
8113f6ac:	10800a17 	ldw	r2,40(r2)
8113f6b0:	10808b04 	addi	r2,r2,556
8113f6b4:	d0a0a915 	stw	r2,-32092(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
8113f6b8:	e0bffe17 	ldw	r2,-8(fp)
8113f6bc:	10800a17 	ldw	r2,40(r2)
8113f6c0:	d0a0aa15 	stw	r2,-32088(gp)
		device_pointer = dev;
8113f6c4:	e0bffe17 	ldw	r2,-8(fp)
8113f6c8:	d0a0ad15 	stw	r2,-32076(gp)
		initialized = false;
8113f6cc:	d020a315 	stw	zero,-32116(gp)
		is_sd_card_formated_as_FAT16 = false;
8113f6d0:	d020a415 	stw	zero,-32112(gp)
		search_data.valid = false;
8113f6d4:	00a045b4 	movhi	r2,33046
8113f6d8:	1097c104 	addi	r2,r2,24324
8113f6dc:	10000415 	stw	zero,16(r2)
	}
	return dev;
8113f6e0:	e0bffe17 	ldw	r2,-8(fp)
}
8113f6e4:	e037883a 	mov	sp,fp
8113f6e8:	dfc00117 	ldw	ra,4(sp)
8113f6ec:	df000017 	ldw	fp,0(sp)
8113f6f0:	dec00204 	addi	sp,sp,8
8113f6f4:	f800283a 	ret

8113f6f8 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
8113f6f8:	defffd04 	addi	sp,sp,-12
8113f6fc:	de00012e 	bgeu	sp,et,8113f704 <alt_up_sd_card_is_Present+0xc>
8113f700:	003b68fa 	trap	3
8113f704:	df000215 	stw	fp,8(sp)
8113f708:	df000204 	addi	fp,sp,8
    bool result = false;
8113f70c:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
8113f710:	d0a0ad17 	ldw	r2,-32076(gp)
8113f714:	10000826 	beq	r2,zero,8113f738 <alt_up_sd_card_is_Present+0x40>
8113f718:	d0a0a517 	ldw	r2,-32108(gp)
8113f71c:	1080002b 	ldhuio	r2,0(r2)
8113f720:	10bfffcc 	andi	r2,r2,65535
8113f724:	1080008c 	andi	r2,r2,2
8113f728:	10000326 	beq	r2,zero,8113f738 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
8113f72c:	00800044 	movi	r2,1
8113f730:	e0bffe15 	stw	r2,-8(fp)
8113f734:	00001e06 	br	8113f7b0 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
8113f738:	d0a0a317 	ldw	r2,-32116(gp)
8113f73c:	10800058 	cmpnei	r2,r2,1
8113f740:	10001b1e 	bne	r2,zero,8113f7b0 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
8113f744:	d020a315 	stw	zero,-32116(gp)
		search_data.valid = false;
8113f748:	00a045b4 	movhi	r2,33046
8113f74c:	1097c104 	addi	r2,r2,24324
8113f750:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
8113f754:	d020a415 	stw	zero,-32112(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113f758:	e03fff15 	stw	zero,-4(fp)
8113f75c:	00001106 	br	8113f7a4 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
8113f760:	00a045b4 	movhi	r2,33046
8113f764:	1097db04 	addi	r2,r2,24428
8113f768:	e0ffff17 	ldw	r3,-4(fp)
8113f76c:	180691ba 	slli	r3,r3,6
8113f770:	10c5883a 	add	r2,r2,r3
8113f774:	10800f04 	addi	r2,r2,60
8113f778:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
8113f77c:	00a045b4 	movhi	r2,33046
8113f780:	1097db04 	addi	r2,r2,24428
8113f784:	e0ffff17 	ldw	r3,-4(fp)
8113f788:	180691ba 	slli	r3,r3,6
8113f78c:	10c5883a 	add	r2,r2,r3
8113f790:	10800e04 	addi	r2,r2,56
8113f794:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113f798:	e0bfff17 	ldw	r2,-4(fp)
8113f79c:	10800044 	addi	r2,r2,1
8113f7a0:	e0bfff15 	stw	r2,-4(fp)
8113f7a4:	e0bfff17 	ldw	r2,-4(fp)
8113f7a8:	10800510 	cmplti	r2,r2,20
8113f7ac:	103fec1e 	bne	r2,zero,8113f760 <__reset+0xfb11f760>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
8113f7b0:	e0bffe17 	ldw	r2,-8(fp)
}
8113f7b4:	e037883a 	mov	sp,fp
8113f7b8:	df000017 	ldw	fp,0(sp)
8113f7bc:	dec00104 	addi	sp,sp,4
8113f7c0:	f800283a 	ret

8113f7c4 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
8113f7c4:	defffd04 	addi	sp,sp,-12
8113f7c8:	de00012e 	bgeu	sp,et,8113f7d0 <alt_up_sd_card_is_FAT16+0xc>
8113f7cc:	003b68fa 	trap	3
8113f7d0:	dfc00215 	stw	ra,8(sp)
8113f7d4:	df000115 	stw	fp,4(sp)
8113f7d8:	df000104 	addi	fp,sp,4
	bool result = false;
8113f7dc:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
8113f7e0:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
8113f7e4:	10000c26 	beq	r2,zero,8113f818 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
8113f7e8:	d0a0a317 	ldw	r2,-32116(gp)
8113f7ec:	1000071e 	bne	r2,zero,8113f80c <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
8113f7f0:	113d9f00 	call	8113d9f0 <Look_for_FAT16>
8113f7f4:	d0a0a415 	stw	r2,-32112(gp)
			initialized = is_sd_card_formated_as_FAT16;
8113f7f8:	d0a0a417 	ldw	r2,-32112(gp)
8113f7fc:	d0a0a315 	stw	r2,-32116(gp)
			search_data.valid = false;
8113f800:	00a045b4 	movhi	r2,33046
8113f804:	1097c104 	addi	r2,r2,24324
8113f808:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
8113f80c:	d0a0a417 	ldw	r2,-32112(gp)
8113f810:	e0bfff15 	stw	r2,-4(fp)
8113f814:	00000206 	br	8113f820 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
8113f818:	d020a315 	stw	zero,-32116(gp)
		is_sd_card_formated_as_FAT16 = false;
8113f81c:	d020a415 	stw	zero,-32112(gp)
	}

	return result;
8113f820:	e0bfff17 	ldw	r2,-4(fp)
}
8113f824:	e037883a 	mov	sp,fp
8113f828:	dfc00117 	ldw	ra,4(sp)
8113f82c:	df000017 	ldw	fp,0(sp)
8113f830:	dec00204 	addi	sp,sp,8
8113f834:	f800283a 	ret

8113f838 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
8113f838:	deffea04 	addi	sp,sp,-88
8113f83c:	de00012e 	bgeu	sp,et,8113f844 <alt_up_sd_card_find_first+0xc>
8113f840:	003b68fa 	trap	3
8113f844:	dfc01515 	stw	ra,84(sp)
8113f848:	df001415 	stw	fp,80(sp)
8113f84c:	df001404 	addi	fp,sp,80
8113f850:	e13ffe15 	stw	r4,-8(fp)
8113f854:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
8113f858:	00800084 	movi	r2,2
8113f85c:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113f860:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
8113f864:	10002426 	beq	r2,zero,8113f8f8 <alt_up_sd_card_find_first+0xc0>
8113f868:	d0a0a417 	ldw	r2,-32112(gp)
8113f86c:	10002226 	beq	r2,zero,8113f8f8 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
8113f870:	e0ffee04 	addi	r3,fp,-72
8113f874:	e0bfed04 	addi	r2,fp,-76
8113f878:	180d883a 	mov	r6,r3
8113f87c:	100b883a 	mov	r5,r2
8113f880:	e13ffe17 	ldw	r4,-8(fp)
8113f884:	113e1880 	call	8113e188 <get_home_directory_cluster_for_file>
8113f888:	10001926 	beq	r2,zero,8113f8f0 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
8113f88c:	e0bfed17 	ldw	r2,-76(fp)
8113f890:	1007883a 	mov	r3,r2
8113f894:	00a045b4 	movhi	r2,33046
8113f898:	1097c104 	addi	r2,r2,24324
8113f89c:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
8113f8a0:	e0bfed17 	ldw	r2,-76(fp)
8113f8a4:	1007883a 	mov	r3,r2
8113f8a8:	00a045b4 	movhi	r2,33046
8113f8ac:	1097c104 	addi	r2,r2,24324
8113f8b0:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
8113f8b4:	00a045b4 	movhi	r2,33046
8113f8b8:	1097c104 	addi	r2,r2,24324
8113f8bc:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
8113f8c0:	00a045b4 	movhi	r2,33046
8113f8c4:	1097c104 	addi	r2,r2,24324
8113f8c8:	00ffffc4 	movi	r3,-1
8113f8cc:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
8113f8d0:	00a045b4 	movhi	r2,33046
8113f8d4:	1097c104 	addi	r2,r2,24324
8113f8d8:	00c00044 	movi	r3,1
8113f8dc:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
8113f8e0:	e13fff17 	ldw	r4,-4(fp)
8113f8e4:	113f9100 	call	8113f910 <alt_up_sd_card_find_next>
8113f8e8:	e0bfec0d 	sth	r2,-80(fp)
8113f8ec:	00000206 	br	8113f8f8 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
8113f8f0:	00800044 	movi	r2,1
8113f8f4:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
8113f8f8:	e0bfec0b 	ldhu	r2,-80(fp)
}
8113f8fc:	e037883a 	mov	sp,fp
8113f900:	dfc00117 	ldw	ra,4(sp)
8113f904:	df000017 	ldw	fp,0(sp)
8113f908:	dec00204 	addi	sp,sp,8
8113f90c:	f800283a 	ret

8113f910 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
8113f910:	deffe404 	addi	sp,sp,-112
8113f914:	de00012e 	bgeu	sp,et,8113f91c <alt_up_sd_card_find_next+0xc>
8113f918:	003b68fa 	trap	3
8113f91c:	dfc01b15 	stw	ra,108(sp)
8113f920:	df001a15 	stw	fp,104(sp)
8113f924:	df001a04 	addi	fp,sp,104
8113f928:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
8113f92c:	00800084 	movi	r2,2
8113f930:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113f934:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
8113f938:	1000df26 	beq	r2,zero,8113fcb8 <alt_up_sd_card_find_next+0x3a8>
8113f93c:	d0a0a417 	ldw	r2,-32112(gp)
8113f940:	1000dd26 	beq	r2,zero,8113fcb8 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
8113f944:	00a045b4 	movhi	r2,33046
8113f948:	1097c104 	addi	r2,r2,24324
8113f94c:	10800417 	ldw	r2,16(r2)
8113f950:	1000d726 	beq	r2,zero,8113fcb0 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
8113f954:	00a045b4 	movhi	r2,33046
8113f958:	1097c104 	addi	r2,r2,24324
8113f95c:	10800117 	ldw	r2,4(r2)
8113f960:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
8113f964:	e0bfe717 	ldw	r2,-100(fp)
8113f968:	1000561e 	bne	r2,zero,8113fac4 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113f96c:	00a045b4 	movhi	r2,33046
8113f970:	1097c604 	addi	r2,r2,24344
8113f974:	1080050b 	ldhu	r2,20(r2)
8113f978:	10bfffcc 	andi	r2,r2,65535
8113f97c:	1006917a 	slli	r3,r2,5
8113f980:	00a045b4 	movhi	r2,33046
8113f984:	1097c604 	addi	r2,r2,24344
8113f988:	1080030b 	ldhu	r2,12(r2)
8113f98c:	10bfffcc 	andi	r2,r2,65535
8113f990:	1885283a 	div	r2,r3,r2
8113f994:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
8113f998:	00a045b4 	movhi	r2,33046
8113f99c:	1097c104 	addi	r2,r2,24324
8113f9a0:	10800217 	ldw	r2,8(r2)
8113f9a4:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
8113f9a8:	00a045b4 	movhi	r2,33046
8113f9ac:	1097c104 	addi	r2,r2,24324
8113f9b0:	1080030b 	ldhu	r2,12(r2)
8113f9b4:	10bfffcc 	andi	r2,r2,65535
8113f9b8:	10a0001c 	xori	r2,r2,32768
8113f9bc:	10a00004 	addi	r2,r2,-32768
8113f9c0:	10800044 	addi	r2,r2,1
8113f9c4:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8113f9c8:	00003606 	br	8113faa4 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113f9cc:	00a045b4 	movhi	r2,33046
8113f9d0:	1097c604 	addi	r2,r2,24344
8113f9d4:	10c01317 	ldw	r3,76(r2)
8113f9d8:	e0bfe817 	ldw	r2,-96(fp)
8113f9dc:	1885883a 	add	r2,r3,r2
8113f9e0:	1007883a 	mov	r3,r2
8113f9e4:	d0a0ab17 	ldw	r2,-32084(gp)
8113f9e8:	100b883a 	mov	r5,r2
8113f9ec:	1809883a 	mov	r4,r3
8113f9f0:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113f9f4:	10002f26 	beq	r2,zero,8113fab4 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8113f9f8:	00002306 	br	8113fa88 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
8113f9fc:	e0bfe917 	ldw	r2,-92(fp)
8113fa00:	1004917a 	slli	r2,r2,5
8113fa04:	e13fe817 	ldw	r4,-96(fp)
8113fa08:	e0ffef04 	addi	r3,fp,-68
8113fa0c:	200f883a 	mov	r7,r4
8113fa10:	000d883a 	mov	r6,zero
8113fa14:	180b883a 	mov	r5,r3
8113fa18:	1009883a 	mov	r4,r2
8113fa1c:	113ce500 	call	8113ce50 <Read_File_Record_At_Offset>
8113fa20:	10001626 	beq	r2,zero,8113fa7c <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
8113fa24:	e0bfef03 	ldbu	r2,-68(fp)
8113fa28:	10803fcc 	andi	r2,r2,255
8113fa2c:	10001326 	beq	r2,zero,8113fa7c <alt_up_sd_card_find_next+0x16c>
8113fa30:	e0bfef03 	ldbu	r2,-68(fp)
8113fa34:	10803fcc 	andi	r2,r2,255
8113fa38:	10803960 	cmpeqi	r2,r2,229
8113fa3c:	10000f1e 	bne	r2,zero,8113fa7c <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
8113fa40:	e0bfe917 	ldw	r2,-92(fp)
8113fa44:	1007883a 	mov	r3,r2
8113fa48:	00a045b4 	movhi	r2,33046
8113fa4c:	1097c104 	addi	r2,r2,24324
8113fa50:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
8113fa54:	e0ffe817 	ldw	r3,-96(fp)
8113fa58:	00a045b4 	movhi	r2,33046
8113fa5c:	1097c104 	addi	r2,r2,24324
8113fa60:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
8113fa64:	e0bfef04 	addi	r2,fp,-68
8113fa68:	e17fff17 	ldw	r5,-4(fp)
8113fa6c:	1009883a 	mov	r4,r2
8113fa70:	113f4e40 	call	8113f4e4 <copy_file_record_name_to_string>
									return 0;
8113fa74:	0005883a 	mov	r2,zero
8113fa78:	00009006 	br	8113fcbc <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8113fa7c:	e0bfe917 	ldw	r2,-92(fp)
8113fa80:	10800044 	addi	r2,r2,1
8113fa84:	e0bfe915 	stw	r2,-92(fp)
8113fa88:	e0bfe917 	ldw	r2,-92(fp)
8113fa8c:	10800410 	cmplti	r2,r2,16
8113fa90:	103fda1e 	bne	r2,zero,8113f9fc <__reset+0xfb11f9fc>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
8113fa94:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8113fa98:	e0bfe817 	ldw	r2,-96(fp)
8113fa9c:	10800044 	addi	r2,r2,1
8113faa0:	e0bfe815 	stw	r2,-96(fp)
8113faa4:	e0ffe817 	ldw	r3,-96(fp)
8113faa8:	e0bfec17 	ldw	r2,-80(fp)
8113faac:	18bfc716 	blt	r3,r2,8113f9cc <__reset+0xfb11f9cc>
8113fab0:	00000106 	br	8113fab8 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
8113fab4:	0001883a 	nop
					}
				}
				result = -1;
8113fab8:	00bfffc4 	movi	r2,-1
8113fabc:	e0bfe60d 	sth	r2,-104(fp)
8113fac0:	00007d06 	br	8113fcb8 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
8113fac4:	00a045b4 	movhi	r2,33046
8113fac8:	1097c104 	addi	r2,r2,24324
8113facc:	1080030b 	ldhu	r2,12(r2)
8113fad0:	10bfffcc 	andi	r2,r2,65535
8113fad4:	10a0001c 	xori	r2,r2,32768
8113fad8:	10a00004 	addi	r2,r2,-32768
8113fadc:	10800044 	addi	r2,r2,1
8113fae0:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113fae4:	e0bfe717 	ldw	r2,-100(fp)
8113fae8:	10ffff84 	addi	r3,r2,-2
8113faec:	00a045b4 	movhi	r2,33046
8113faf0:	1097c604 	addi	r2,r2,24344
8113faf4:	10800383 	ldbu	r2,14(r2)
8113faf8:	10803fcc 	andi	r2,r2,255
8113fafc:	1885383a 	mul	r2,r3,r2
8113fb00:	1007883a 	mov	r3,r2
8113fb04:	00a045b4 	movhi	r2,33046
8113fb08:	1097c604 	addi	r2,r2,24344
8113fb0c:	10801417 	ldw	r2,80(r2)
8113fb10:	1885883a 	add	r2,r3,r2
8113fb14:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
8113fb18:	00a045b4 	movhi	r2,33046
8113fb1c:	1097c104 	addi	r2,r2,24324
8113fb20:	10800217 	ldw	r2,8(r2)
8113fb24:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113fb28:	00003806 	br	8113fc0c <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113fb2c:	e0ffeb17 	ldw	r3,-84(fp)
8113fb30:	e0bfed17 	ldw	r2,-76(fp)
8113fb34:	1885883a 	add	r2,r3,r2
8113fb38:	d0e0ab17 	ldw	r3,-32084(gp)
8113fb3c:	180b883a 	mov	r5,r3
8113fb40:	1009883a 	mov	r4,r2
8113fb44:	113ca200 	call	8113ca20 <Read_Sector_Data>
8113fb48:	10003726 	beq	r2,zero,8113fc28 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
8113fb4c:	00002806 	br	8113fbf0 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
8113fb50:	e0bfea17 	ldw	r2,-88(fp)
8113fb54:	1004917a 	slli	r2,r2,5
8113fb58:	e13fe717 	ldw	r4,-100(fp)
8113fb5c:	e17feb17 	ldw	r5,-84(fp)
8113fb60:	e0ffef04 	addi	r3,fp,-68
8113fb64:	280f883a 	mov	r7,r5
8113fb68:	200d883a 	mov	r6,r4
8113fb6c:	180b883a 	mov	r5,r3
8113fb70:	1009883a 	mov	r4,r2
8113fb74:	113ce500 	call	8113ce50 <Read_File_Record_At_Offset>
8113fb78:	10001a26 	beq	r2,zero,8113fbe4 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
8113fb7c:	e0bfef03 	ldbu	r2,-68(fp)
8113fb80:	10803fcc 	andi	r2,r2,255
8113fb84:	10001726 	beq	r2,zero,8113fbe4 <alt_up_sd_card_find_next+0x2d4>
8113fb88:	e0bfef03 	ldbu	r2,-68(fp)
8113fb8c:	10803fcc 	andi	r2,r2,255
8113fb90:	10803960 	cmpeqi	r2,r2,229
8113fb94:	1000131e 	bne	r2,zero,8113fbe4 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
8113fb98:	e0ffe717 	ldw	r3,-100(fp)
8113fb9c:	00a045b4 	movhi	r2,33046
8113fba0:	1097c104 	addi	r2,r2,24324
8113fba4:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
8113fba8:	e0bfea17 	ldw	r2,-88(fp)
8113fbac:	1007883a 	mov	r3,r2
8113fbb0:	00a045b4 	movhi	r2,33046
8113fbb4:	1097c104 	addi	r2,r2,24324
8113fbb8:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
8113fbbc:	e0ffeb17 	ldw	r3,-84(fp)
8113fbc0:	00a045b4 	movhi	r2,33046
8113fbc4:	1097c104 	addi	r2,r2,24324
8113fbc8:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
8113fbcc:	e0bfef04 	addi	r2,fp,-68
8113fbd0:	e17fff17 	ldw	r5,-4(fp)
8113fbd4:	1009883a 	mov	r4,r2
8113fbd8:	113f4e40 	call	8113f4e4 <copy_file_record_name_to_string>
										return 0;
8113fbdc:	0005883a 	mov	r2,zero
8113fbe0:	00003606 	br	8113fcbc <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
8113fbe4:	e0bfea17 	ldw	r2,-88(fp)
8113fbe8:	10800044 	addi	r2,r2,1
8113fbec:	e0bfea15 	stw	r2,-88(fp)
8113fbf0:	e0bfea17 	ldw	r2,-88(fp)
8113fbf4:	10800410 	cmplti	r2,r2,16
8113fbf8:	103fd51e 	bne	r2,zero,8113fb50 <__reset+0xfb11fb50>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
8113fbfc:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113fc00:	e0bfeb17 	ldw	r2,-84(fp)
8113fc04:	10800044 	addi	r2,r2,1
8113fc08:	e0bfeb15 	stw	r2,-84(fp)
8113fc0c:	00a045b4 	movhi	r2,33046
8113fc10:	1097c604 	addi	r2,r2,24344
8113fc14:	10800383 	ldbu	r2,14(r2)
8113fc18:	10803fcc 	andi	r2,r2,255
8113fc1c:	e0ffeb17 	ldw	r3,-84(fp)
8113fc20:	18bfc216 	blt	r3,r2,8113fb2c <__reset+0xfb11fb2c>
8113fc24:	00000106 	br	8113fc2c <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
8113fc28:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
8113fc2c:	00a045b4 	movhi	r2,33046
8113fc30:	1097c604 	addi	r2,r2,24344
8113fc34:	10800383 	ldbu	r2,14(r2)
8113fc38:	10803fcc 	andi	r2,r2,255
8113fc3c:	e0ffeb17 	ldw	r3,-84(fp)
8113fc40:	18801716 	blt	r3,r2,8113fca0 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
8113fc44:	e0bfe717 	ldw	r2,-100(fp)
8113fc48:	e0ffee04 	addi	r3,fp,-72
8113fc4c:	180b883a 	mov	r5,r3
8113fc50:	1009883a 	mov	r4,r2
8113fc54:	113cb000 	call	8113cb00 <get_cluster_flag>
8113fc58:	10000f26 	beq	r2,zero,8113fc98 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113fc5c:	e0bfee0b 	ldhu	r2,-72(fp)
8113fc60:	10bfffcc 	andi	r2,r2,65535
8113fc64:	10fffe0c 	andi	r3,r2,65528
8113fc68:	00bffe14 	movui	r2,65528
8113fc6c:	1880051e 	bne	r3,r2,8113fc84 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
8113fc70:	00bfffc4 	movi	r2,-1
8113fc74:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
8113fc78:	00a045b4 	movhi	r2,33046
8113fc7c:	1097c104 	addi	r2,r2,24324
8113fc80:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
8113fc84:	e0bfee0b 	ldhu	r2,-72(fp)
8113fc88:	10bfffcc 	andi	r2,r2,65535
8113fc8c:	10bffe0c 	andi	r2,r2,65528
8113fc90:	e0bfe715 	stw	r2,-100(fp)
8113fc94:	00000206 	br	8113fca0 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
8113fc98:	00bfffc4 	movi	r2,-1
8113fc9c:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
8113fca0:	e0bfe717 	ldw	r2,-100(fp)
8113fca4:	00fffdd4 	movui	r3,65527
8113fca8:	18bf8e0e 	bge	r3,r2,8113fae4 <__reset+0xfb11fae4>
8113fcac:	00000206 	br	8113fcb8 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
8113fcb0:	008000c4 	movi	r2,3
8113fcb4:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
8113fcb8:	e0bfe60b 	ldhu	r2,-104(fp)
}
8113fcbc:	e037883a 	mov	sp,fp
8113fcc0:	dfc00117 	ldw	ra,4(sp)
8113fcc4:	df000017 	ldw	fp,0(sp)
8113fcc8:	dec00204 	addi	sp,sp,8
8113fccc:	f800283a 	ret

8113fcd0 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
8113fcd0:	deffe904 	addi	sp,sp,-92
8113fcd4:	de00012e 	bgeu	sp,et,8113fcdc <alt_up_sd_card_fopen+0xc>
8113fcd8:	003b68fa 	trap	3
8113fcdc:	dfc01615 	stw	ra,88(sp)
8113fce0:	df001515 	stw	fp,84(sp)
8113fce4:	df001504 	addi	fp,sp,84
8113fce8:	e13ffe15 	stw	r4,-8(fp)
8113fcec:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
8113fcf0:	00bfffc4 	movi	r2,-1
8113fcf4:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113fcf8:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
8113fcfc:	1000cf26 	beq	r2,zero,8114003c <alt_up_sd_card_fopen+0x36c>
8113fd00:	d0a0a417 	ldw	r2,-32112(gp)
8113fd04:	1000cd26 	beq	r2,zero,8114003c <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
8113fd08:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
8113fd0c:	e13ffe17 	ldw	r4,-8(fp)
8113fd10:	113dae40 	call	8113dae4 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
8113fd14:	e13ffe17 	ldw	r4,-8(fp)
8113fd18:	113dbb00 	call	8113dbb0 <check_file_name_for_FAT16_compliance>
8113fd1c:	1000c726 	beq	r2,zero,8114003c <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
8113fd20:	e0ffee04 	addi	r3,fp,-72
8113fd24:	e0bfed04 	addi	r2,fp,-76
8113fd28:	180d883a 	mov	r6,r3
8113fd2c:	100b883a 	mov	r5,r2
8113fd30:	e13ffe17 	ldw	r4,-8(fp)
8113fd34:	113e1880 	call	8113e188 <get_home_directory_cluster_for_file>
8113fd38:	1000021e 	bne	r2,zero,8113fd44 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
8113fd3c:	e0bfeb0b 	ldhu	r2,-84(fp)
8113fd40:	0000bf06 	br	81140040 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113fd44:	e03fec15 	stw	zero,-80(fp)
8113fd48:	00000e06 	br	8113fd84 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
8113fd4c:	00a045b4 	movhi	r2,33046
8113fd50:	1097db04 	addi	r2,r2,24428
8113fd54:	e0ffec17 	ldw	r3,-80(fp)
8113fd58:	180691ba 	slli	r3,r3,6
8113fd5c:	10c5883a 	add	r2,r2,r3
8113fd60:	10800f04 	addi	r2,r2,60
8113fd64:	10800017 	ldw	r2,0(r2)
8113fd68:	1000031e 	bne	r2,zero,8113fd78 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
8113fd6c:	e0bfec17 	ldw	r2,-80(fp)
8113fd70:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
8113fd74:	00000606 	br	8113fd90 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113fd78:	e0bfec17 	ldw	r2,-80(fp)
8113fd7c:	10800044 	addi	r2,r2,1
8113fd80:	e0bfec15 	stw	r2,-80(fp)
8113fd84:	e0bfec17 	ldw	r2,-80(fp)
8113fd88:	10800510 	cmplti	r2,r2,20
8113fd8c:	103fef1e 	bne	r2,zero,8113fd4c <__reset+0xfb11fd4c>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
8113fd90:	e0bfeb0f 	ldh	r2,-84(fp)
8113fd94:	1000a916 	blt	r2,zero,8114003c <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
8113fd98:	e0bfed17 	ldw	r2,-76(fp)
8113fd9c:	1009883a 	mov	r4,r2
8113fda0:	e0bfeb0f 	ldh	r2,-84(fp)
8113fda4:	100691ba 	slli	r3,r2,6
8113fda8:	00a045b4 	movhi	r2,33046
8113fdac:	1097db04 	addi	r2,r2,24428
8113fdb0:	1885883a 	add	r2,r3,r2
8113fdb4:	100d883a 	mov	r6,r2
8113fdb8:	e17ffe17 	ldw	r5,-8(fp)
8113fdbc:	113e6c80 	call	8113e6c8 <find_file_in_directory>
8113fdc0:	10007b26 	beq	r2,zero,8113ffb0 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
8113fdc4:	e0bfff17 	ldw	r2,-4(fp)
8113fdc8:	10000226 	beq	r2,zero,8113fdd4 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
8113fdcc:	00bfffc4 	movi	r2,-1
8113fdd0:	00009b06 	br	81140040 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
8113fdd4:	e13feb0f 	ldh	r4,-84(fp)
8113fdd8:	e0ffeb0f 	ldh	r3,-84(fp)
8113fddc:	00a045b4 	movhi	r2,33046
8113fde0:	1097db04 	addi	r2,r2,24428
8113fde4:	180691ba 	slli	r3,r3,6
8113fde8:	10c5883a 	add	r2,r2,r3
8113fdec:	10800584 	addi	r2,r2,22
8113fdf0:	1080000b 	ldhu	r2,0(r2)
8113fdf4:	10ffffcc 	andi	r3,r2,65535
8113fdf8:	00a045b4 	movhi	r2,33046
8113fdfc:	1097db04 	addi	r2,r2,24428
8113fe00:	200891ba 	slli	r4,r4,6
8113fe04:	1105883a 	add	r2,r2,r4
8113fe08:	10800704 	addi	r2,r2,28
8113fe0c:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
8113fe10:	e0ffeb0f 	ldh	r3,-84(fp)
8113fe14:	00a045b4 	movhi	r2,33046
8113fe18:	1097db04 	addi	r2,r2,24428
8113fe1c:	180691ba 	slli	r3,r3,6
8113fe20:	10c5883a 	add	r2,r2,r3
8113fe24:	10800804 	addi	r2,r2,32
8113fe28:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
8113fe2c:	e0ffeb0f 	ldh	r3,-84(fp)
8113fe30:	00a045b4 	movhi	r2,33046
8113fe34:	1097db04 	addi	r2,r2,24428
8113fe38:	180691ba 	slli	r3,r3,6
8113fe3c:	10c5883a 	add	r2,r2,r3
8113fe40:	10800904 	addi	r2,r2,36
8113fe44:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
8113fe48:	e0ffeb0f 	ldh	r3,-84(fp)
8113fe4c:	00a045b4 	movhi	r2,33046
8113fe50:	1097db04 	addi	r2,r2,24428
8113fe54:	180691ba 	slli	r3,r3,6
8113fe58:	10c5883a 	add	r2,r2,r3
8113fe5c:	10800f04 	addi	r2,r2,60
8113fe60:	00c00044 	movi	r3,1
8113fe64:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
8113fe68:	e0ffeb0f 	ldh	r3,-84(fp)
8113fe6c:	00a045b4 	movhi	r2,33046
8113fe70:	1097db04 	addi	r2,r2,24428
8113fe74:	180691ba 	slli	r3,r3,6
8113fe78:	10c5883a 	add	r2,r2,r3
8113fe7c:	10800e04 	addi	r2,r2,56
8113fe80:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113fe84:	e03fec15 	stw	zero,-80(fp)
8113fe88:	00004506 	br	8113ffa0 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
8113fe8c:	e0ffeb0f 	ldh	r3,-84(fp)
8113fe90:	e0bfec17 	ldw	r2,-80(fp)
8113fe94:	18803f26 	beq	r3,r2,8113ff94 <alt_up_sd_card_fopen+0x2c4>
8113fe98:	00a045b4 	movhi	r2,33046
8113fe9c:	1097db04 	addi	r2,r2,24428
8113fea0:	e0ffec17 	ldw	r3,-80(fp)
8113fea4:	180691ba 	slli	r3,r3,6
8113fea8:	10c5883a 	add	r2,r2,r3
8113feac:	10800f04 	addi	r2,r2,60
8113feb0:	10800017 	ldw	r2,0(r2)
8113feb4:	10800058 	cmpnei	r2,r2,1
8113feb8:	1000361e 	bne	r2,zero,8113ff94 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113febc:	e0ffeb0f 	ldh	r3,-84(fp)
8113fec0:	00a045b4 	movhi	r2,33046
8113fec4:	1097db04 	addi	r2,r2,24428
8113fec8:	180691ba 	slli	r3,r3,6
8113fecc:	10c5883a 	add	r2,r2,r3
8113fed0:	10800a04 	addi	r2,r2,40
8113fed4:	10c00017 	ldw	r3,0(r2)
8113fed8:	00a045b4 	movhi	r2,33046
8113fedc:	1097db04 	addi	r2,r2,24428
8113fee0:	e13fec17 	ldw	r4,-80(fp)
8113fee4:	200891ba 	slli	r4,r4,6
8113fee8:	1105883a 	add	r2,r2,r4
8113feec:	10800a04 	addi	r2,r2,40
8113fef0:	10800017 	ldw	r2,0(r2)
8113fef4:	1880271e 	bne	r3,r2,8113ff94 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113fef8:	e0ffeb0f 	ldh	r3,-84(fp)
8113fefc:	00a045b4 	movhi	r2,33046
8113ff00:	1097db04 	addi	r2,r2,24428
8113ff04:	180691ba 	slli	r3,r3,6
8113ff08:	10c5883a 	add	r2,r2,r3
8113ff0c:	10800b04 	addi	r2,r2,44
8113ff10:	10c00017 	ldw	r3,0(r2)
8113ff14:	00a045b4 	movhi	r2,33046
8113ff18:	1097db04 	addi	r2,r2,24428
8113ff1c:	e13fec17 	ldw	r4,-80(fp)
8113ff20:	200891ba 	slli	r4,r4,6
8113ff24:	1105883a 	add	r2,r2,r4
8113ff28:	10800b04 	addi	r2,r2,44
8113ff2c:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113ff30:	1880181e 	bne	r3,r2,8113ff94 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
8113ff34:	e0ffeb0f 	ldh	r3,-84(fp)
8113ff38:	00a045b4 	movhi	r2,33046
8113ff3c:	1097db04 	addi	r2,r2,24428
8113ff40:	180691ba 	slli	r3,r3,6
8113ff44:	10c5883a 	add	r2,r2,r3
8113ff48:	10800c04 	addi	r2,r2,48
8113ff4c:	1100000b 	ldhu	r4,0(r2)
8113ff50:	00a045b4 	movhi	r2,33046
8113ff54:	1097db04 	addi	r2,r2,24428
8113ff58:	e0ffec17 	ldw	r3,-80(fp)
8113ff5c:	180691ba 	slli	r3,r3,6
8113ff60:	10c5883a 	add	r2,r2,r3
8113ff64:	10800c04 	addi	r2,r2,48
8113ff68:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113ff6c:	20ffffcc 	andi	r3,r4,65535
8113ff70:	18e0001c 	xori	r3,r3,32768
8113ff74:	18e00004 	addi	r3,r3,-32768
8113ff78:	10bfffcc 	andi	r2,r2,65535
8113ff7c:	10a0001c 	xori	r2,r2,32768
8113ff80:	10a00004 	addi	r2,r2,-32768
8113ff84:	1880031e 	bne	r3,r2,8113ff94 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
8113ff88:	00bfff84 	movi	r2,-2
8113ff8c:	e0bfeb0d 	sth	r2,-84(fp)
								break;
8113ff90:	00002a06 	br	8114003c <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113ff94:	e0bfec17 	ldw	r2,-80(fp)
8113ff98:	10800044 	addi	r2,r2,1
8113ff9c:	e0bfec15 	stw	r2,-80(fp)
8113ffa0:	e0bfec17 	ldw	r2,-80(fp)
8113ffa4:	10800510 	cmplti	r2,r2,20
8113ffa8:	103fb81e 	bne	r2,zero,8113fe8c <__reset+0xfb11fe8c>
8113ffac:	00002306 	br	8114003c <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
8113ffb0:	e0bfff17 	ldw	r2,-4(fp)
8113ffb4:	10001f26 	beq	r2,zero,81140034 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
8113ffb8:	e0bfeb0f 	ldh	r2,-84(fp)
8113ffbc:	100691ba 	slli	r3,r2,6
8113ffc0:	00a045b4 	movhi	r2,33046
8113ffc4:	1097db04 	addi	r2,r2,24428
8113ffc8:	1885883a 	add	r2,r3,r2
8113ffcc:	e0ffee04 	addi	r3,fp,-72
8113ffd0:	180d883a 	mov	r6,r3
8113ffd4:	100b883a 	mov	r5,r2
8113ffd8:	e13ffe17 	ldw	r4,-8(fp)
8113ffdc:	113f2140 	call	8113f214 <create_file>
8113ffe0:	10001126 	beq	r2,zero,81140028 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
8113ffe4:	e0ffeb0f 	ldh	r3,-84(fp)
8113ffe8:	00a045b4 	movhi	r2,33046
8113ffec:	1097db04 	addi	r2,r2,24428
8113fff0:	180691ba 	slli	r3,r3,6
8113fff4:	10c5883a 	add	r2,r2,r3
8113fff8:	10800f04 	addi	r2,r2,60
8113fffc:	00c00044 	movi	r3,1
81140000:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81140004:	e0ffeb0f 	ldh	r3,-84(fp)
81140008:	00a045b4 	movhi	r2,33046
8114000c:	1097db04 	addi	r2,r2,24428
81140010:	180691ba 	slli	r3,r3,6
81140014:	10c5883a 	add	r2,r2,r3
81140018:	10800e04 	addi	r2,r2,56
8114001c:	00c00044 	movi	r3,1
81140020:	10c00015 	stw	r3,0(r2)
81140024:	00000506 	br	8114003c <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81140028:	00bfffc4 	movi	r2,-1
8114002c:	e0bfeb0d 	sth	r2,-84(fp)
81140030:	00000206 	br	8114003c <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81140034:	00bfffc4 	movi	r2,-1
81140038:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
8114003c:	e0bfeb0b 	ldhu	r2,-84(fp)
}
81140040:	e037883a 	mov	sp,fp
81140044:	dfc00117 	ldw	ra,4(sp)
81140048:	df000017 	ldw	fp,0(sp)
8114004c:	dec00204 	addi	sp,sp,8
81140050:	f800283a 	ret

81140054 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81140054:	defffd04 	addi	sp,sp,-12
81140058:	de00012e 	bgeu	sp,et,81140060 <alt_up_sd_card_set_attributes+0xc>
8114005c:	003b68fa 	trap	3
81140060:	df000215 	stw	fp,8(sp)
81140064:	df000204 	addi	fp,sp,8
81140068:	2007883a 	mov	r3,r4
8114006c:	2805883a 	mov	r2,r5
81140070:	e0fffe0d 	sth	r3,-8(fp)
81140074:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81140078:	e0bffe0f 	ldh	r2,-8(fp)
8114007c:	10001416 	blt	r2,zero,811400d0 <alt_up_sd_card_set_attributes+0x7c>
81140080:	e0bffe0f 	ldh	r2,-8(fp)
81140084:	10800508 	cmpgei	r2,r2,20
81140088:	1000111e 	bne	r2,zero,811400d0 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8114008c:	e0fffe0f 	ldh	r3,-8(fp)
81140090:	00a045b4 	movhi	r2,33046
81140094:	1097db04 	addi	r2,r2,24428
81140098:	180691ba 	slli	r3,r3,6
8114009c:	10c5883a 	add	r2,r2,r3
811400a0:	10800f04 	addi	r2,r2,60
811400a4:	10800017 	ldw	r2,0(r2)
811400a8:	10000926 	beq	r2,zero,811400d0 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
811400ac:	e0fffe0f 	ldh	r3,-8(fp)
811400b0:	e0bfff0b 	ldhu	r2,-4(fp)
811400b4:	1009883a 	mov	r4,r2
811400b8:	00a045b4 	movhi	r2,33046
811400bc:	1097db04 	addi	r2,r2,24428
811400c0:	180691ba 	slli	r3,r3,6
811400c4:	10c5883a 	add	r2,r2,r3
811400c8:	108002c4 	addi	r2,r2,11
811400cc:	11000005 	stb	r4,0(r2)
        }
    }
}
811400d0:	0001883a 	nop
811400d4:	e037883a 	mov	sp,fp
811400d8:	df000017 	ldw	fp,0(sp)
811400dc:	dec00104 	addi	sp,sp,4
811400e0:	f800283a 	ret

811400e4 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
811400e4:	defffd04 	addi	sp,sp,-12
811400e8:	de00012e 	bgeu	sp,et,811400f0 <alt_up_sd_card_get_attributes+0xc>
811400ec:	003b68fa 	trap	3
811400f0:	df000215 	stw	fp,8(sp)
811400f4:	df000204 	addi	fp,sp,8
811400f8:	2005883a 	mov	r2,r4
811400fc:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81140100:	00bfffc4 	movi	r2,-1
81140104:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81140108:	e0bfff0f 	ldh	r2,-4(fp)
8114010c:	10001416 	blt	r2,zero,81140160 <alt_up_sd_card_get_attributes+0x7c>
81140110:	e0bfff0f 	ldh	r2,-4(fp)
81140114:	10800508 	cmpgei	r2,r2,20
81140118:	1000111e 	bne	r2,zero,81140160 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8114011c:	e0ffff0f 	ldh	r3,-4(fp)
81140120:	00a045b4 	movhi	r2,33046
81140124:	1097db04 	addi	r2,r2,24428
81140128:	180691ba 	slli	r3,r3,6
8114012c:	10c5883a 	add	r2,r2,r3
81140130:	10800f04 	addi	r2,r2,60
81140134:	10800017 	ldw	r2,0(r2)
81140138:	10000926 	beq	r2,zero,81140160 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
8114013c:	e0ffff0f 	ldh	r3,-4(fp)
81140140:	00a045b4 	movhi	r2,33046
81140144:	1097db04 	addi	r2,r2,24428
81140148:	180691ba 	slli	r3,r3,6
8114014c:	10c5883a 	add	r2,r2,r3
81140150:	108002c4 	addi	r2,r2,11
81140154:	10800003 	ldbu	r2,0(r2)
81140158:	10803fcc 	andi	r2,r2,255
8114015c:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
81140160:	e0bffe0b 	ldhu	r2,-8(fp)
}
81140164:	e037883a 	mov	sp,fp
81140168:	df000017 	ldw	fp,0(sp)
8114016c:	dec00104 	addi	sp,sp,4
81140170:	f800283a 	ret

81140174 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
81140174:	defffa04 	addi	sp,sp,-24
81140178:	de00012e 	bgeu	sp,et,81140180 <alt_up_sd_card_read+0xc>
8114017c:	003b68fa 	trap	3
81140180:	dfc00515 	stw	ra,20(sp)
81140184:	df000415 	stw	fp,16(sp)
81140188:	df000404 	addi	fp,sp,16
8114018c:	2005883a 	mov	r2,r4
81140190:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
81140194:	00bfffc4 	movi	r2,-1
81140198:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8114019c:	e0bfff0f 	ldh	r2,-4(fp)
811401a0:	1000ce16 	blt	r2,zero,811404dc <alt_up_sd_card_read+0x368>
811401a4:	e0bfff0f 	ldh	r2,-4(fp)
811401a8:	10800508 	cmpgei	r2,r2,20
811401ac:	1000cb1e 	bne	r2,zero,811404dc <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
811401b0:	e0ffff0f 	ldh	r3,-4(fp)
811401b4:	00a045b4 	movhi	r2,33046
811401b8:	1097db04 	addi	r2,r2,24428
811401bc:	180691ba 	slli	r3,r3,6
811401c0:	10c5883a 	add	r2,r2,r3
811401c4:	10800f04 	addi	r2,r2,60
811401c8:	10800017 	ldw	r2,0(r2)
811401cc:	1000c326 	beq	r2,zero,811404dc <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
811401d0:	e0ffff0f 	ldh	r3,-4(fp)
811401d4:	00a045b4 	movhi	r2,33046
811401d8:	1097db04 	addi	r2,r2,24428
811401dc:	180691ba 	slli	r3,r3,6
811401e0:	10c5883a 	add	r2,r2,r3
811401e4:	10800904 	addi	r2,r2,36
811401e8:	10c00017 	ldw	r3,0(r2)
811401ec:	e13fff0f 	ldh	r4,-4(fp)
811401f0:	00a045b4 	movhi	r2,33046
811401f4:	1097db04 	addi	r2,r2,24428
811401f8:	200891ba 	slli	r4,r4,6
811401fc:	1105883a 	add	r2,r2,r4
81140200:	10800604 	addi	r2,r2,24
81140204:	10800017 	ldw	r2,0(r2)
81140208:	1880b42e 	bgeu	r3,r2,811404dc <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114020c:	00a045b4 	movhi	r2,33046
81140210:	1097c604 	addi	r2,r2,24344
81140214:	10c01417 	ldw	r3,80(r2)
81140218:	e13fff0f 	ldh	r4,-4(fp)
8114021c:	00a045b4 	movhi	r2,33046
81140220:	1097db04 	addi	r2,r2,24428
81140224:	200891ba 	slli	r4,r4,6
81140228:	1105883a 	add	r2,r2,r4
8114022c:	10800704 	addi	r2,r2,28
81140230:	10800017 	ldw	r2,0(r2)
81140234:	113fff84 	addi	r4,r2,-2
81140238:	00a045b4 	movhi	r2,33046
8114023c:	1097c604 	addi	r2,r2,24344
81140240:	10800383 	ldbu	r2,14(r2)
81140244:	10803fcc 	andi	r2,r2,255
81140248:	2085383a 	mul	r2,r4,r2
8114024c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81140250:	e13fff0f 	ldh	r4,-4(fp)
81140254:	00a045b4 	movhi	r2,33046
81140258:	1097db04 	addi	r2,r2,24428
8114025c:	200891ba 	slli	r4,r4,6
81140260:	1105883a 	add	r2,r2,r4
81140264:	10800804 	addi	r2,r2,32
81140268:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114026c:	1885883a 	add	r2,r3,r2
81140270:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81140274:	e0ffff0f 	ldh	r3,-4(fp)
81140278:	00a045b4 	movhi	r2,33046
8114027c:	1097db04 	addi	r2,r2,24428
81140280:	180691ba 	slli	r3,r3,6
81140284:	10c5883a 	add	r2,r2,r3
81140288:	10800904 	addi	r2,r2,36
8114028c:	10800017 	ldw	r2,0(r2)
81140290:	10006826 	beq	r2,zero,81140434 <alt_up_sd_card_read+0x2c0>
81140294:	e0ffff0f 	ldh	r3,-4(fp)
81140298:	00a045b4 	movhi	r2,33046
8114029c:	1097db04 	addi	r2,r2,24428
811402a0:	180691ba 	slli	r3,r3,6
811402a4:	10c5883a 	add	r2,r2,r3
811402a8:	10800904 	addi	r2,r2,36
811402ac:	10800017 	ldw	r2,0(r2)
811402b0:	10807fcc 	andi	r2,r2,511
811402b4:	10005f1e 	bne	r2,zero,81140434 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
811402b8:	e0ffff0f 	ldh	r3,-4(fp)
811402bc:	00a045b4 	movhi	r2,33046
811402c0:	1097db04 	addi	r2,r2,24428
811402c4:	180691ba 	slli	r3,r3,6
811402c8:	10c5883a 	add	r2,r2,r3
811402cc:	10800804 	addi	r2,r2,32
811402d0:	10c00017 	ldw	r3,0(r2)
811402d4:	00a045b4 	movhi	r2,33046
811402d8:	1097c604 	addi	r2,r2,24344
811402dc:	10800383 	ldbu	r2,14(r2)
811402e0:	10803fcc 	andi	r2,r2,255
811402e4:	10bfffc4 	addi	r2,r2,-1
811402e8:	1880401e 	bne	r3,r2,811403ec <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
811402ec:	e0ffff0f 	ldh	r3,-4(fp)
811402f0:	00a045b4 	movhi	r2,33046
811402f4:	1097db04 	addi	r2,r2,24428
811402f8:	180691ba 	slli	r3,r3,6
811402fc:	10c5883a 	add	r2,r2,r3
81140300:	10800704 	addi	r2,r2,28
81140304:	10800017 	ldw	r2,0(r2)
81140308:	e0fffe04 	addi	r3,fp,-8
8114030c:	180b883a 	mov	r5,r3
81140310:	1009883a 	mov	r4,r2
81140314:	113cb000 	call	8113cb00 <get_cluster_flag>
81140318:	10003226 	beq	r2,zero,811403e4 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8114031c:	e0bffe0b 	ldhu	r2,-8(fp)
81140320:	10bfffcc 	andi	r2,r2,65535
81140324:	10fffe0c 	andi	r3,r2,65528
81140328:	00bffe14 	movui	r2,65528
8114032c:	1880021e 	bne	r3,r2,81140338 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81140330:	00bfffc4 	movi	r2,-1
81140334:	00006a06 	br	811404e0 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81140338:	e13fff0f 	ldh	r4,-4(fp)
8114033c:	e0bffe0b 	ldhu	r2,-8(fp)
81140340:	10ffffcc 	andi	r3,r2,65535
81140344:	00a045b4 	movhi	r2,33046
81140348:	1097db04 	addi	r2,r2,24428
8114034c:	200891ba 	slli	r4,r4,6
81140350:	1105883a 	add	r2,r2,r4
81140354:	10800704 	addi	r2,r2,28
81140358:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8114035c:	e0ffff0f 	ldh	r3,-4(fp)
81140360:	00a045b4 	movhi	r2,33046
81140364:	1097db04 	addi	r2,r2,24428
81140368:	180691ba 	slli	r3,r3,6
8114036c:	10c5883a 	add	r2,r2,r3
81140370:	10800804 	addi	r2,r2,32
81140374:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140378:	00a045b4 	movhi	r2,33046
8114037c:	1097c604 	addi	r2,r2,24344
81140380:	10c01417 	ldw	r3,80(r2)
81140384:	e13fff0f 	ldh	r4,-4(fp)
81140388:	00a045b4 	movhi	r2,33046
8114038c:	1097db04 	addi	r2,r2,24428
81140390:	200891ba 	slli	r4,r4,6
81140394:	1105883a 	add	r2,r2,r4
81140398:	10800704 	addi	r2,r2,28
8114039c:	10800017 	ldw	r2,0(r2)
811403a0:	113fff84 	addi	r4,r2,-2
811403a4:	00a045b4 	movhi	r2,33046
811403a8:	1097c604 	addi	r2,r2,24344
811403ac:	10800383 	ldbu	r2,14(r2)
811403b0:	10803fcc 	andi	r2,r2,255
811403b4:	2085383a 	mul	r2,r4,r2
811403b8:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
811403bc:	e13fff0f 	ldh	r4,-4(fp)
811403c0:	00a045b4 	movhi	r2,33046
811403c4:	1097db04 	addi	r2,r2,24428
811403c8:	200891ba 	slli	r4,r4,6
811403cc:	1105883a 	add	r2,r2,r4
811403d0:	10800804 	addi	r2,r2,32
811403d4:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811403d8:	1885883a 	add	r2,r3,r2
811403dc:	e0bffd15 	stw	r2,-12(fp)
811403e0:	00001406 	br	81140434 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
811403e4:	00bfff84 	movi	r2,-2
811403e8:	00003d06 	br	811404e0 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
811403ec:	e13fff0f 	ldh	r4,-4(fp)
811403f0:	e0ffff0f 	ldh	r3,-4(fp)
811403f4:	00a045b4 	movhi	r2,33046
811403f8:	1097db04 	addi	r2,r2,24428
811403fc:	180691ba 	slli	r3,r3,6
81140400:	10c5883a 	add	r2,r2,r3
81140404:	10800804 	addi	r2,r2,32
81140408:	10800017 	ldw	r2,0(r2)
8114040c:	10c00044 	addi	r3,r2,1
81140410:	00a045b4 	movhi	r2,33046
81140414:	1097db04 	addi	r2,r2,24428
81140418:	200891ba 	slli	r4,r4,6
8114041c:	1105883a 	add	r2,r2,r4
81140420:	10800804 	addi	r2,r2,32
81140424:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81140428:	e0bffd17 	ldw	r2,-12(fp)
8114042c:	10800044 	addi	r2,r2,1
81140430:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81140434:	d0e0ab17 	ldw	r3,-32084(gp)
81140438:	e0bffd17 	ldw	r2,-12(fp)
8114043c:	1885883a 	add	r2,r3,r2
81140440:	1007883a 	mov	r3,r2
81140444:	d0a0af17 	ldw	r2,-32068(gp)
81140448:	18800726 	beq	r3,r2,81140468 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8114044c:	d0a0ab17 	ldw	r2,-32084(gp)
81140450:	100b883a 	mov	r5,r2
81140454:	e13ffd17 	ldw	r4,-12(fp)
81140458:	113ca200 	call	8113ca20 <Read_Sector_Data>
8114045c:	1000021e 	bne	r2,zero,81140468 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81140460:	00bfff84 	movi	r2,-2
81140464:	00001e06 	br	811404e0 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81140468:	d0e0aa17 	ldw	r3,-32088(gp)
8114046c:	e13fff0f 	ldh	r4,-4(fp)
81140470:	00a045b4 	movhi	r2,33046
81140474:	1097db04 	addi	r2,r2,24428
81140478:	200891ba 	slli	r4,r4,6
8114047c:	1105883a 	add	r2,r2,r4
81140480:	10800904 	addi	r2,r2,36
81140484:	10800017 	ldw	r2,0(r2)
81140488:	10807fcc 	andi	r2,r2,511
8114048c:	1885883a 	add	r2,r3,r2
81140490:	10800023 	ldbuio	r2,0(r2)
81140494:	10803fcc 	andi	r2,r2,255
81140498:	10803fcc 	andi	r2,r2,255
8114049c:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
811404a0:	e13fff0f 	ldh	r4,-4(fp)
811404a4:	e0ffff0f 	ldh	r3,-4(fp)
811404a8:	00a045b4 	movhi	r2,33046
811404ac:	1097db04 	addi	r2,r2,24428
811404b0:	180691ba 	slli	r3,r3,6
811404b4:	10c5883a 	add	r2,r2,r3
811404b8:	10800904 	addi	r2,r2,36
811404bc:	10800017 	ldw	r2,0(r2)
811404c0:	10c00044 	addi	r3,r2,1
811404c4:	00a045b4 	movhi	r2,33046
811404c8:	1097db04 	addi	r2,r2,24428
811404cc:	200891ba 	slli	r4,r4,6
811404d0:	1105883a 	add	r2,r2,r4
811404d4:	10800904 	addi	r2,r2,36
811404d8:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
811404dc:	e0bffc0b 	ldhu	r2,-16(fp)
}
811404e0:	e037883a 	mov	sp,fp
811404e4:	dfc00117 	ldw	ra,4(sp)
811404e8:	df000017 	ldw	fp,0(sp)
811404ec:	dec00204 	addi	sp,sp,8
811404f0:	f800283a 	ret

811404f4 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
811404f4:	defff804 	addi	sp,sp,-32
811404f8:	de00012e 	bgeu	sp,et,81140500 <alt_up_sd_card_write+0xc>
811404fc:	003b68fa 	trap	3
81140500:	dfc00715 	stw	ra,28(sp)
81140504:	df000615 	stw	fp,24(sp)
81140508:	df000604 	addi	fp,sp,24
8114050c:	2007883a 	mov	r3,r4
81140510:	2805883a 	mov	r2,r5
81140514:	e0fffe0d 	sth	r3,-8(fp)
81140518:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
8114051c:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81140520:	e0bffe0f 	ldh	r2,-8(fp)
81140524:	10017716 	blt	r2,zero,81140b04 <alt_up_sd_card_write+0x610>
81140528:	e0bffe0f 	ldh	r2,-8(fp)
8114052c:	10800508 	cmpgei	r2,r2,20
81140530:	1001741e 	bne	r2,zero,81140b04 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81140534:	e0fffe0f 	ldh	r3,-8(fp)
81140538:	00a045b4 	movhi	r2,33046
8114053c:	1097db04 	addi	r2,r2,24428
81140540:	180691ba 	slli	r3,r3,6
81140544:	10c5883a 	add	r2,r2,r3
81140548:	10800f04 	addi	r2,r2,60
8114054c:	10800017 	ldw	r2,0(r2)
81140550:	10016c26 	beq	r2,zero,81140b04 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140554:	00a045b4 	movhi	r2,33046
81140558:	1097c604 	addi	r2,r2,24344
8114055c:	10c01417 	ldw	r3,80(r2)
81140560:	e13ffe0f 	ldh	r4,-8(fp)
81140564:	00a045b4 	movhi	r2,33046
81140568:	1097db04 	addi	r2,r2,24428
8114056c:	200891ba 	slli	r4,r4,6
81140570:	1105883a 	add	r2,r2,r4
81140574:	10800704 	addi	r2,r2,28
81140578:	10800017 	ldw	r2,0(r2)
8114057c:	113fff84 	addi	r4,r2,-2
81140580:	00a045b4 	movhi	r2,33046
81140584:	1097c604 	addi	r2,r2,24344
81140588:	10800383 	ldbu	r2,14(r2)
8114058c:	10803fcc 	andi	r2,r2,255
81140590:	2085383a 	mul	r2,r4,r2
81140594:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81140598:	e13ffe0f 	ldh	r4,-8(fp)
8114059c:	00a045b4 	movhi	r2,33046
811405a0:	1097db04 	addi	r2,r2,24428
811405a4:	200891ba 	slli	r4,r4,6
811405a8:	1105883a 	add	r2,r2,r4
811405ac:	10800804 	addi	r2,r2,32
811405b0:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811405b4:	1885883a 	add	r2,r3,r2
811405b8:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
811405bc:	e0fffe0f 	ldh	r3,-8(fp)
811405c0:	00a045b4 	movhi	r2,33046
811405c4:	1097db04 	addi	r2,r2,24428
811405c8:	180691ba 	slli	r3,r3,6
811405cc:	10c5883a 	add	r2,r2,r3
811405d0:	10800904 	addi	r2,r2,36
811405d4:	10c00017 	ldw	r3,0(r2)
811405d8:	00a045b4 	movhi	r2,33046
811405dc:	1097c604 	addi	r2,r2,24344
811405e0:	1080030b 	ldhu	r2,12(r2)
811405e4:	10bfffcc 	andi	r2,r2,65535
811405e8:	1889203a 	divu	r4,r3,r2
811405ec:	2085383a 	mul	r2,r4,r2
811405f0:	1885c83a 	sub	r2,r3,r2
811405f4:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
811405f8:	e0fffe0f 	ldh	r3,-8(fp)
811405fc:	00a045b4 	movhi	r2,33046
81140600:	1097db04 	addi	r2,r2,24428
81140604:	180691ba 	slli	r3,r3,6
81140608:	10c5883a 	add	r2,r2,r3
8114060c:	10800904 	addi	r2,r2,36
81140610:	10c00017 	ldw	r3,0(r2)
81140614:	e13ffe0f 	ldh	r4,-8(fp)
81140618:	00a045b4 	movhi	r2,33046
8114061c:	1097db04 	addi	r2,r2,24428
81140620:	200891ba 	slli	r4,r4,6
81140624:	1105883a 	add	r2,r2,r4
81140628:	10800604 	addi	r2,r2,24
8114062c:	10800017 	ldw	r2,0(r2)
81140630:	1880672e 	bgeu	r3,r2,811407d0 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81140634:	e0fffe0f 	ldh	r3,-8(fp)
81140638:	00a045b4 	movhi	r2,33046
8114063c:	1097db04 	addi	r2,r2,24428
81140640:	180691ba 	slli	r3,r3,6
81140644:	10c5883a 	add	r2,r2,r3
81140648:	10800904 	addi	r2,r2,36
8114064c:	10800017 	ldw	r2,0(r2)
81140650:	1000e126 	beq	r2,zero,811409d8 <alt_up_sd_card_write+0x4e4>
81140654:	e0bffc0f 	ldh	r2,-16(fp)
81140658:	1000df1e 	bne	r2,zero,811409d8 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8114065c:	e0fffe0f 	ldh	r3,-8(fp)
81140660:	00a045b4 	movhi	r2,33046
81140664:	1097db04 	addi	r2,r2,24428
81140668:	180691ba 	slli	r3,r3,6
8114066c:	10c5883a 	add	r2,r2,r3
81140670:	10800804 	addi	r2,r2,32
81140674:	10c00017 	ldw	r3,0(r2)
81140678:	00a045b4 	movhi	r2,33046
8114067c:	1097c604 	addi	r2,r2,24344
81140680:	10800383 	ldbu	r2,14(r2)
81140684:	10803fcc 	andi	r2,r2,255
81140688:	10bfffc4 	addi	r2,r2,-1
8114068c:	18803d1e 	bne	r3,r2,81140784 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81140690:	e0fffe0f 	ldh	r3,-8(fp)
81140694:	00a045b4 	movhi	r2,33046
81140698:	1097db04 	addi	r2,r2,24428
8114069c:	180691ba 	slli	r3,r3,6
811406a0:	10c5883a 	add	r2,r2,r3
811406a4:	10800704 	addi	r2,r2,28
811406a8:	10800017 	ldw	r2,0(r2)
811406ac:	e0fffc84 	addi	r3,fp,-14
811406b0:	180b883a 	mov	r5,r3
811406b4:	1009883a 	mov	r4,r2
811406b8:	113cb000 	call	8113cb00 <get_cluster_flag>
811406bc:	10002f26 	beq	r2,zero,8114077c <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
811406c0:	e0bffc8b 	ldhu	r2,-14(fp)
811406c4:	10bfffcc 	andi	r2,r2,65535
811406c8:	10bffe28 	cmpgeui	r2,r2,65528
811406cc:	1000c21e 	bne	r2,zero,811409d8 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
811406d0:	e13ffe0f 	ldh	r4,-8(fp)
811406d4:	e0bffc8b 	ldhu	r2,-14(fp)
811406d8:	10ffffcc 	andi	r3,r2,65535
811406dc:	00a045b4 	movhi	r2,33046
811406e0:	1097db04 	addi	r2,r2,24428
811406e4:	200891ba 	slli	r4,r4,6
811406e8:	1105883a 	add	r2,r2,r4
811406ec:	10800704 	addi	r2,r2,28
811406f0:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
811406f4:	e0fffe0f 	ldh	r3,-8(fp)
811406f8:	00a045b4 	movhi	r2,33046
811406fc:	1097db04 	addi	r2,r2,24428
81140700:	180691ba 	slli	r3,r3,6
81140704:	10c5883a 	add	r2,r2,r3
81140708:	10800804 	addi	r2,r2,32
8114070c:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140710:	00a045b4 	movhi	r2,33046
81140714:	1097c604 	addi	r2,r2,24344
81140718:	10c01417 	ldw	r3,80(r2)
8114071c:	e13ffe0f 	ldh	r4,-8(fp)
81140720:	00a045b4 	movhi	r2,33046
81140724:	1097db04 	addi	r2,r2,24428
81140728:	200891ba 	slli	r4,r4,6
8114072c:	1105883a 	add	r2,r2,r4
81140730:	10800704 	addi	r2,r2,28
81140734:	10800017 	ldw	r2,0(r2)
81140738:	113fff84 	addi	r4,r2,-2
8114073c:	00a045b4 	movhi	r2,33046
81140740:	1097c604 	addi	r2,r2,24344
81140744:	10800383 	ldbu	r2,14(r2)
81140748:	10803fcc 	andi	r2,r2,255
8114074c:	2085383a 	mul	r2,r4,r2
81140750:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81140754:	e13ffe0f 	ldh	r4,-8(fp)
81140758:	00a045b4 	movhi	r2,33046
8114075c:	1097db04 	addi	r2,r2,24428
81140760:	200891ba 	slli	r4,r4,6
81140764:	1105883a 	add	r2,r2,r4
81140768:	10800804 	addi	r2,r2,32
8114076c:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140770:	1885883a 	add	r2,r3,r2
81140774:	e0bffb15 	stw	r2,-20(fp)
81140778:	00009706 	br	811409d8 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
8114077c:	0005883a 	mov	r2,zero
81140780:	0000e106 	br	81140b08 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81140784:	e13ffe0f 	ldh	r4,-8(fp)
81140788:	e0fffe0f 	ldh	r3,-8(fp)
8114078c:	00a045b4 	movhi	r2,33046
81140790:	1097db04 	addi	r2,r2,24428
81140794:	180691ba 	slli	r3,r3,6
81140798:	10c5883a 	add	r2,r2,r3
8114079c:	10800804 	addi	r2,r2,32
811407a0:	10800017 	ldw	r2,0(r2)
811407a4:	10c00044 	addi	r3,r2,1
811407a8:	00a045b4 	movhi	r2,33046
811407ac:	1097db04 	addi	r2,r2,24428
811407b0:	200891ba 	slli	r4,r4,6
811407b4:	1105883a 	add	r2,r2,r4
811407b8:	10800804 	addi	r2,r2,32
811407bc:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
811407c0:	e0bffb17 	ldw	r2,-20(fp)
811407c4:	10800044 	addi	r2,r2,1
811407c8:	e0bffb15 	stw	r2,-20(fp)
811407cc:	00008206 	br	811409d8 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
811407d0:	e0fffe0f 	ldh	r3,-8(fp)
811407d4:	00a045b4 	movhi	r2,33046
811407d8:	1097db04 	addi	r2,r2,24428
811407dc:	180691ba 	slli	r3,r3,6
811407e0:	10c5883a 	add	r2,r2,r3
811407e4:	10800904 	addi	r2,r2,36
811407e8:	10800017 	ldw	r2,0(r2)
811407ec:	10007a26 	beq	r2,zero,811409d8 <alt_up_sd_card_write+0x4e4>
811407f0:	e0bffc0f 	ldh	r2,-16(fp)
811407f4:	1000781e 	bne	r2,zero,811409d8 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
811407f8:	e0fffe0f 	ldh	r3,-8(fp)
811407fc:	00a045b4 	movhi	r2,33046
81140800:	1097db04 	addi	r2,r2,24428
81140804:	180691ba 	slli	r3,r3,6
81140808:	10c5883a 	add	r2,r2,r3
8114080c:	10800804 	addi	r2,r2,32
81140810:	10c00017 	ldw	r3,0(r2)
81140814:	00a045b4 	movhi	r2,33046
81140818:	1097c604 	addi	r2,r2,24344
8114081c:	10800383 	ldbu	r2,14(r2)
81140820:	10803fcc 	andi	r2,r2,255
81140824:	10bfffc4 	addi	r2,r2,-1
81140828:	18803e1e 	bne	r3,r2,81140924 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
8114082c:	e0bffd04 	addi	r2,fp,-12
81140830:	1009883a 	mov	r4,r2
81140834:	113eb440 	call	8113eb44 <find_first_empty_cluster>
81140838:	10003826 	beq	r2,zero,8114091c <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
8114083c:	e0fffe0f 	ldh	r3,-8(fp)
81140840:	00a045b4 	movhi	r2,33046
81140844:	1097db04 	addi	r2,r2,24428
81140848:	180691ba 	slli	r3,r3,6
8114084c:	10c5883a 	add	r2,r2,r3
81140850:	10800704 	addi	r2,r2,28
81140854:	10800017 	ldw	r2,0(r2)
81140858:	e0fffd17 	ldw	r3,-12(fp)
8114085c:	18ffffcc 	andi	r3,r3,65535
81140860:	18e0001c 	xori	r3,r3,32768
81140864:	18e00004 	addi	r3,r3,-32768
81140868:	01800044 	movi	r6,1
8114086c:	180b883a 	mov	r5,r3
81140870:	1009883a 	mov	r4,r2
81140874:	113cbbc0 	call	8113cbbc <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
81140878:	e0bffd17 	ldw	r2,-12(fp)
8114087c:	01800044 	movi	r6,1
81140880:	017fffc4 	movi	r5,-1
81140884:	1009883a 	mov	r4,r2
81140888:	113cbbc0 	call	8113cbbc <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
8114088c:	e0fffe0f 	ldh	r3,-8(fp)
81140890:	00a045b4 	movhi	r2,33046
81140894:	1097db04 	addi	r2,r2,24428
81140898:	180691ba 	slli	r3,r3,6
8114089c:	10c5883a 	add	r2,r2,r3
811408a0:	10800704 	addi	r2,r2,28
811408a4:	10800017 	ldw	r2,0(r2)
811408a8:	e0fffd17 	ldw	r3,-12(fp)
811408ac:	18ffffcc 	andi	r3,r3,65535
811408b0:	18e0001c 	xori	r3,r3,32768
811408b4:	18e00004 	addi	r3,r3,-32768
811408b8:	000d883a 	mov	r6,zero
811408bc:	180b883a 	mov	r5,r3
811408c0:	1009883a 	mov	r4,r2
811408c4:	113cbbc0 	call	8113cbbc <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
811408c8:	e0bffd17 	ldw	r2,-12(fp)
811408cc:	000d883a 	mov	r6,zero
811408d0:	017fffc4 	movi	r5,-1
811408d4:	1009883a 	mov	r4,r2
811408d8:	113cbbc0 	call	8113cbbc <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
811408dc:	e13ffe0f 	ldh	r4,-8(fp)
811408e0:	e0fffd17 	ldw	r3,-12(fp)
811408e4:	00a045b4 	movhi	r2,33046
811408e8:	1097db04 	addi	r2,r2,24428
811408ec:	200891ba 	slli	r4,r4,6
811408f0:	1105883a 	add	r2,r2,r4
811408f4:	10800704 	addi	r2,r2,28
811408f8:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
811408fc:	e0fffe0f 	ldh	r3,-8(fp)
81140900:	00a045b4 	movhi	r2,33046
81140904:	1097db04 	addi	r2,r2,24428
81140908:	180691ba 	slli	r3,r3,6
8114090c:	10c5883a 	add	r2,r2,r3
81140910:	10800804 	addi	r2,r2,32
81140914:	10000015 	stw	zero,0(r2)
81140918:	00001506 	br	81140970 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
8114091c:	0005883a 	mov	r2,zero
81140920:	00007906 	br	81140b08 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81140924:	e13ffe0f 	ldh	r4,-8(fp)
81140928:	e0fffe0f 	ldh	r3,-8(fp)
8114092c:	00a045b4 	movhi	r2,33046
81140930:	1097db04 	addi	r2,r2,24428
81140934:	180691ba 	slli	r3,r3,6
81140938:	10c5883a 	add	r2,r2,r3
8114093c:	10800904 	addi	r2,r2,36
81140940:	10c00017 	ldw	r3,0(r2)
81140944:	00a045b4 	movhi	r2,33046
81140948:	1097c604 	addi	r2,r2,24344
8114094c:	1080030b 	ldhu	r2,12(r2)
81140950:	10bfffcc 	andi	r2,r2,65535
81140954:	1887203a 	divu	r3,r3,r2
81140958:	00a045b4 	movhi	r2,33046
8114095c:	1097db04 	addi	r2,r2,24428
81140960:	200891ba 	slli	r4,r4,6
81140964:	1105883a 	add	r2,r2,r4
81140968:	10800804 	addi	r2,r2,32
8114096c:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140970:	00a045b4 	movhi	r2,33046
81140974:	1097c604 	addi	r2,r2,24344
81140978:	10c01417 	ldw	r3,80(r2)
8114097c:	e13ffe0f 	ldh	r4,-8(fp)
81140980:	00a045b4 	movhi	r2,33046
81140984:	1097db04 	addi	r2,r2,24428
81140988:	200891ba 	slli	r4,r4,6
8114098c:	1105883a 	add	r2,r2,r4
81140990:	10800704 	addi	r2,r2,28
81140994:	10800017 	ldw	r2,0(r2)
81140998:	113fff84 	addi	r4,r2,-2
8114099c:	00a045b4 	movhi	r2,33046
811409a0:	1097c604 	addi	r2,r2,24344
811409a4:	10800383 	ldbu	r2,14(r2)
811409a8:	10803fcc 	andi	r2,r2,255
811409ac:	2085383a 	mul	r2,r4,r2
811409b0:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
811409b4:	e13ffe0f 	ldh	r4,-8(fp)
811409b8:	00a045b4 	movhi	r2,33046
811409bc:	1097db04 	addi	r2,r2,24428
811409c0:	200891ba 	slli	r4,r4,6
811409c4:	1105883a 	add	r2,r2,r4
811409c8:	10800804 	addi	r2,r2,32
811409cc:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811409d0:	1885883a 	add	r2,r3,r2
811409d4:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
811409d8:	d0e0ab17 	ldw	r3,-32084(gp)
811409dc:	e0bffb17 	ldw	r2,-20(fp)
811409e0:	1885883a 	add	r2,r3,r2
811409e4:	1007883a 	mov	r3,r2
811409e8:	d0a0af17 	ldw	r2,-32068(gp)
811409ec:	18800726 	beq	r3,r2,81140a0c <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
811409f0:	d0a0ab17 	ldw	r2,-32084(gp)
811409f4:	100b883a 	mov	r5,r2
811409f8:	e13ffb17 	ldw	r4,-20(fp)
811409fc:	113ca200 	call	8113ca20 <Read_Sector_Data>
81140a00:	1000021e 	bne	r2,zero,81140a0c <alt_up_sd_card_write+0x518>
                {
					return false;
81140a04:	0005883a 	mov	r2,zero
81140a08:	00003f06 	br	81140b08 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81140a0c:	d0e0aa17 	ldw	r3,-32088(gp)
81140a10:	e0bffc0f 	ldh	r2,-16(fp)
81140a14:	1885883a 	add	r2,r3,r2
81140a18:	e0ffff07 	ldb	r3,-4(fp)
81140a1c:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81140a20:	e13ffe0f 	ldh	r4,-8(fp)
81140a24:	e0fffe0f 	ldh	r3,-8(fp)
81140a28:	00a045b4 	movhi	r2,33046
81140a2c:	1097db04 	addi	r2,r2,24428
81140a30:	180691ba 	slli	r3,r3,6
81140a34:	10c5883a 	add	r2,r2,r3
81140a38:	10800904 	addi	r2,r2,36
81140a3c:	10800017 	ldw	r2,0(r2)
81140a40:	10c00044 	addi	r3,r2,1
81140a44:	00a045b4 	movhi	r2,33046
81140a48:	1097db04 	addi	r2,r2,24428
81140a4c:	200891ba 	slli	r4,r4,6
81140a50:	1105883a 	add	r2,r2,r4
81140a54:	10800904 	addi	r2,r2,36
81140a58:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
81140a5c:	e0fffe0f 	ldh	r3,-8(fp)
81140a60:	00a045b4 	movhi	r2,33046
81140a64:	1097db04 	addi	r2,r2,24428
81140a68:	180691ba 	slli	r3,r3,6
81140a6c:	10c5883a 	add	r2,r2,r3
81140a70:	10800904 	addi	r2,r2,36
81140a74:	10c00017 	ldw	r3,0(r2)
81140a78:	e13ffe0f 	ldh	r4,-8(fp)
81140a7c:	00a045b4 	movhi	r2,33046
81140a80:	1097db04 	addi	r2,r2,24428
81140a84:	200891ba 	slli	r4,r4,6
81140a88:	1105883a 	add	r2,r2,r4
81140a8c:	10800604 	addi	r2,r2,24
81140a90:	10800017 	ldw	r2,0(r2)
81140a94:	18801736 	bltu	r3,r2,81140af4 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
81140a98:	e13ffe0f 	ldh	r4,-8(fp)
81140a9c:	e0fffe0f 	ldh	r3,-8(fp)
81140aa0:	00a045b4 	movhi	r2,33046
81140aa4:	1097db04 	addi	r2,r2,24428
81140aa8:	180691ba 	slli	r3,r3,6
81140aac:	10c5883a 	add	r2,r2,r3
81140ab0:	10800604 	addi	r2,r2,24
81140ab4:	10800017 	ldw	r2,0(r2)
81140ab8:	10c00044 	addi	r3,r2,1
81140abc:	00a045b4 	movhi	r2,33046
81140ac0:	1097db04 	addi	r2,r2,24428
81140ac4:	200891ba 	slli	r4,r4,6
81140ac8:	1105883a 	add	r2,r2,r4
81140acc:	10800604 	addi	r2,r2,24
81140ad0:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81140ad4:	e0fffe0f 	ldh	r3,-8(fp)
81140ad8:	00a045b4 	movhi	r2,33046
81140adc:	1097db04 	addi	r2,r2,24428
81140ae0:	180691ba 	slli	r3,r3,6
81140ae4:	10c5883a 	add	r2,r2,r3
81140ae8:	10800e04 	addi	r2,r2,56
81140aec:	00c00044 	movi	r3,1
81140af0:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81140af4:	00800044 	movi	r2,1
81140af8:	d0a0ae15 	stw	r2,-32072(gp)
			result = true;
81140afc:	00800044 	movi	r2,1
81140b00:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81140b04:	e0bffa17 	ldw	r2,-24(fp)
}
81140b08:	e037883a 	mov	sp,fp
81140b0c:	dfc00117 	ldw	ra,4(sp)
81140b10:	df000017 	ldw	fp,0(sp)
81140b14:	dec00204 	addi	sp,sp,8
81140b18:	f800283a 	ret

81140b1c <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81140b1c:	defffb04 	addi	sp,sp,-20
81140b20:	de00012e 	bgeu	sp,et,81140b28 <alt_up_sd_card_fclose+0xc>
81140b24:	003b68fa 	trap	3
81140b28:	dfc00415 	stw	ra,16(sp)
81140b2c:	df000315 	stw	fp,12(sp)
81140b30:	df000304 	addi	fp,sp,12
81140b34:	2005883a 	mov	r2,r4
81140b38:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81140b3c:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81140b40:	113f6f80 	call	8113f6f8 <alt_up_sd_card_is_Present>
81140b44:	10006026 	beq	r2,zero,81140cc8 <alt_up_sd_card_fclose+0x1ac>
81140b48:	d0a0a417 	ldw	r2,-32112(gp)
81140b4c:	10005e26 	beq	r2,zero,81140cc8 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
81140b50:	e0ffff0f 	ldh	r3,-4(fp)
81140b54:	00a045b4 	movhi	r2,33046
81140b58:	1097db04 	addi	r2,r2,24428
81140b5c:	180691ba 	slli	r3,r3,6
81140b60:	10c5883a 	add	r2,r2,r3
81140b64:	10800f04 	addi	r2,r2,60
81140b68:	10800017 	ldw	r2,0(r2)
81140b6c:	10005626 	beq	r2,zero,81140cc8 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
81140b70:	e0ffff0f 	ldh	r3,-4(fp)
81140b74:	00a045b4 	movhi	r2,33046
81140b78:	1097db04 	addi	r2,r2,24428
81140b7c:	180691ba 	slli	r3,r3,6
81140b80:	10c5883a 	add	r2,r2,r3
81140b84:	10800e04 	addi	r2,r2,56
81140b88:	10800017 	ldw	r2,0(r2)
81140b8c:	10004526 	beq	r2,zero,81140ca4 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
81140b90:	e0ffff0f 	ldh	r3,-4(fp)
81140b94:	00a045b4 	movhi	r2,33046
81140b98:	1097db04 	addi	r2,r2,24428
81140b9c:	180691ba 	slli	r3,r3,6
81140ba0:	10c5883a 	add	r2,r2,r3
81140ba4:	10800b04 	addi	r2,r2,44
81140ba8:	10800017 	ldw	r2,0(r2)
81140bac:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81140bb0:	e0ffff0f 	ldh	r3,-4(fp)
81140bb4:	00a045b4 	movhi	r2,33046
81140bb8:	1097db04 	addi	r2,r2,24428
81140bbc:	180691ba 	slli	r3,r3,6
81140bc0:	10c5883a 	add	r2,r2,r3
81140bc4:	10800a04 	addi	r2,r2,40
81140bc8:	10800017 	ldw	r2,0(r2)
81140bcc:	1000071e 	bne	r2,zero,81140bec <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81140bd0:	00a045b4 	movhi	r2,33046
81140bd4:	1097c604 	addi	r2,r2,24344
81140bd8:	10801317 	ldw	r2,76(r2)
81140bdc:	e0fffe17 	ldw	r3,-8(fp)
81140be0:	1885883a 	add	r2,r3,r2
81140be4:	e0bffe15 	stw	r2,-8(fp)
81140be8:	00001406 	br	81140c3c <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81140bec:	00a045b4 	movhi	r2,33046
81140bf0:	1097c604 	addi	r2,r2,24344
81140bf4:	10c01417 	ldw	r3,80(r2)
81140bf8:	e0bffe17 	ldw	r2,-8(fp)
81140bfc:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
81140c00:	e13fff0f 	ldh	r4,-4(fp)
81140c04:	00a045b4 	movhi	r2,33046
81140c08:	1097db04 	addi	r2,r2,24428
81140c0c:	200891ba 	slli	r4,r4,6
81140c10:	1105883a 	add	r2,r2,r4
81140c14:	10800a04 	addi	r2,r2,40
81140c18:	10800017 	ldw	r2,0(r2)
81140c1c:	113fff84 	addi	r4,r2,-2
81140c20:	00a045b4 	movhi	r2,33046
81140c24:	1097c604 	addi	r2,r2,24344
81140c28:	10800383 	ldbu	r2,14(r2)
81140c2c:	10803fcc 	andi	r2,r2,255
81140c30:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81140c34:	1885883a 	add	r2,r3,r2
81140c38:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81140c3c:	e0bffe17 	ldw	r2,-8(fp)
81140c40:	d0e0ab17 	ldw	r3,-32084(gp)
81140c44:	180b883a 	mov	r5,r3
81140c48:	1009883a 	mov	r4,r2
81140c4c:	113ca200 	call	8113ca20 <Read_Sector_Data>
81140c50:	10001426 	beq	r2,zero,81140ca4 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81140c54:	e0ffff0f 	ldh	r3,-4(fp)
81140c58:	00a045b4 	movhi	r2,33046
81140c5c:	1097db04 	addi	r2,r2,24428
81140c60:	180691ba 	slli	r3,r3,6
81140c64:	10c5883a 	add	r2,r2,r3
81140c68:	10800c04 	addi	r2,r2,48
81140c6c:	1080000b 	ldhu	r2,0(r2)
81140c70:	113fffcc 	andi	r4,r2,65535
81140c74:	2120001c 	xori	r4,r4,32768
81140c78:	21200004 	addi	r4,r4,-32768
81140c7c:	e0bfff0f 	ldh	r2,-4(fp)
81140c80:	100691ba 	slli	r3,r2,6
81140c84:	00a045b4 	movhi	r2,33046
81140c88:	1097db04 	addi	r2,r2,24428
81140c8c:	1885883a 	add	r2,r3,r2
81140c90:	100b883a 	mov	r5,r2
81140c94:	113d0d40 	call	8113d0d4 <Write_File_Record_At_Offset>
81140c98:	10000226 	beq	r2,zero,81140ca4 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
81140c9c:	113c9cc0 	call	8113c9cc <Save_Modified_Sector>
81140ca0:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81140ca4:	e0ffff0f 	ldh	r3,-4(fp)
81140ca8:	00a045b4 	movhi	r2,33046
81140cac:	1097db04 	addi	r2,r2,24428
81140cb0:	180691ba 	slli	r3,r3,6
81140cb4:	10c5883a 	add	r2,r2,r3
81140cb8:	10800f04 	addi	r2,r2,60
81140cbc:	10000015 	stw	zero,0(r2)
			result = true;
81140cc0:	00800044 	movi	r2,1
81140cc4:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81140cc8:	e0bffd17 	ldw	r2,-12(fp)
}
81140ccc:	e037883a 	mov	sp,fp
81140cd0:	dfc00117 	ldw	ra,4(sp)
81140cd4:	df000017 	ldw	fp,0(sp)
81140cd8:	dec00204 	addi	sp,sp,8
81140cdc:	f800283a 	ret

81140ce0 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81140ce0:	defffa04 	addi	sp,sp,-24
81140ce4:	de00012e 	bgeu	sp,et,81140cec <altera_avalon_jtag_uart_read_fd+0xc>
81140ce8:	003b68fa 	trap	3
81140cec:	dfc00515 	stw	ra,20(sp)
81140cf0:	df000415 	stw	fp,16(sp)
81140cf4:	df000404 	addi	fp,sp,16
81140cf8:	e13ffd15 	stw	r4,-12(fp)
81140cfc:	e17ffe15 	stw	r5,-8(fp)
81140d00:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81140d04:	e0bffd17 	ldw	r2,-12(fp)
81140d08:	10800017 	ldw	r2,0(r2)
81140d0c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
81140d10:	e0bffc17 	ldw	r2,-16(fp)
81140d14:	10c00a04 	addi	r3,r2,40
81140d18:	e0bffd17 	ldw	r2,-12(fp)
81140d1c:	10800217 	ldw	r2,8(r2)
81140d20:	100f883a 	mov	r7,r2
81140d24:	e1bfff17 	ldw	r6,-4(fp)
81140d28:	e17ffe17 	ldw	r5,-8(fp)
81140d2c:	1809883a 	mov	r4,r3
81140d30:	11415640 	call	81141564 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81140d34:	e037883a 	mov	sp,fp
81140d38:	dfc00117 	ldw	ra,4(sp)
81140d3c:	df000017 	ldw	fp,0(sp)
81140d40:	dec00204 	addi	sp,sp,8
81140d44:	f800283a 	ret

81140d48 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81140d48:	defffa04 	addi	sp,sp,-24
81140d4c:	de00012e 	bgeu	sp,et,81140d54 <altera_avalon_jtag_uart_write_fd+0xc>
81140d50:	003b68fa 	trap	3
81140d54:	dfc00515 	stw	ra,20(sp)
81140d58:	df000415 	stw	fp,16(sp)
81140d5c:	df000404 	addi	fp,sp,16
81140d60:	e13ffd15 	stw	r4,-12(fp)
81140d64:	e17ffe15 	stw	r5,-8(fp)
81140d68:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81140d6c:	e0bffd17 	ldw	r2,-12(fp)
81140d70:	10800017 	ldw	r2,0(r2)
81140d74:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
81140d78:	e0bffc17 	ldw	r2,-16(fp)
81140d7c:	10c00a04 	addi	r3,r2,40
81140d80:	e0bffd17 	ldw	r2,-12(fp)
81140d84:	10800217 	ldw	r2,8(r2)
81140d88:	100f883a 	mov	r7,r2
81140d8c:	e1bfff17 	ldw	r6,-4(fp)
81140d90:	e17ffe17 	ldw	r5,-8(fp)
81140d94:	1809883a 	mov	r4,r3
81140d98:	11418280 	call	81141828 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
81140d9c:	e037883a 	mov	sp,fp
81140da0:	dfc00117 	ldw	ra,4(sp)
81140da4:	df000017 	ldw	fp,0(sp)
81140da8:	dec00204 	addi	sp,sp,8
81140dac:	f800283a 	ret

81140db0 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81140db0:	defffc04 	addi	sp,sp,-16
81140db4:	de00012e 	bgeu	sp,et,81140dbc <altera_avalon_jtag_uart_close_fd+0xc>
81140db8:	003b68fa 	trap	3
81140dbc:	dfc00315 	stw	ra,12(sp)
81140dc0:	df000215 	stw	fp,8(sp)
81140dc4:	df000204 	addi	fp,sp,8
81140dc8:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81140dcc:	e0bfff17 	ldw	r2,-4(fp)
81140dd0:	10800017 	ldw	r2,0(r2)
81140dd4:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
81140dd8:	e0bffe17 	ldw	r2,-8(fp)
81140ddc:	10c00a04 	addi	r3,r2,40
81140de0:	e0bfff17 	ldw	r2,-4(fp)
81140de4:	10800217 	ldw	r2,8(r2)
81140de8:	100b883a 	mov	r5,r2
81140dec:	1809883a 	mov	r4,r3
81140df0:	11413fc0 	call	811413fc <altera_avalon_jtag_uart_close>
}
81140df4:	e037883a 	mov	sp,fp
81140df8:	dfc00117 	ldw	ra,4(sp)
81140dfc:	df000017 	ldw	fp,0(sp)
81140e00:	dec00204 	addi	sp,sp,8
81140e04:	f800283a 	ret

81140e08 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81140e08:	defffa04 	addi	sp,sp,-24
81140e0c:	de00012e 	bgeu	sp,et,81140e14 <altera_avalon_jtag_uart_ioctl_fd+0xc>
81140e10:	003b68fa 	trap	3
81140e14:	dfc00515 	stw	ra,20(sp)
81140e18:	df000415 	stw	fp,16(sp)
81140e1c:	df000404 	addi	fp,sp,16
81140e20:	e13ffd15 	stw	r4,-12(fp)
81140e24:	e17ffe15 	stw	r5,-8(fp)
81140e28:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
81140e2c:	e0bffd17 	ldw	r2,-12(fp)
81140e30:	10800017 	ldw	r2,0(r2)
81140e34:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81140e38:	e0bffc17 	ldw	r2,-16(fp)
81140e3c:	10800a04 	addi	r2,r2,40
81140e40:	e1bfff17 	ldw	r6,-4(fp)
81140e44:	e17ffe17 	ldw	r5,-8(fp)
81140e48:	1009883a 	mov	r4,r2
81140e4c:	114146c0 	call	8114146c <altera_avalon_jtag_uart_ioctl>
}
81140e50:	e037883a 	mov	sp,fp
81140e54:	dfc00117 	ldw	ra,4(sp)
81140e58:	df000017 	ldw	fp,0(sp)
81140e5c:	dec00204 	addi	sp,sp,8
81140e60:	f800283a 	ret

81140e64 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
81140e64:	deffef04 	addi	sp,sp,-68
81140e68:	de00012e 	bgeu	sp,et,81140e70 <altera_avalon_jtag_uart_init+0xc>
81140e6c:	003b68fa 	trap	3
81140e70:	dfc01015 	stw	ra,64(sp)
81140e74:	df000f15 	stw	fp,60(sp)
81140e78:	dc400e15 	stw	r17,56(sp)
81140e7c:	dc000d15 	stw	r16,52(sp)
81140e80:	df000f04 	addi	fp,sp,60
81140e84:	e13ff715 	stw	r4,-36(fp)
81140e88:	e17ff815 	stw	r5,-32(fp)
81140e8c:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
81140e90:	e0bff717 	ldw	r2,-36(fp)
81140e94:	10800c04 	addi	r2,r2,48
81140e98:	e0bff215 	stw	r2,-56(fp)
81140e9c:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81140ea0:	e0bff60b 	ldhu	r2,-40(fp)
81140ea4:	e0fff684 	addi	r3,fp,-38
81140ea8:	180b883a 	mov	r5,r3
81140eac:	1009883a 	mov	r4,r2
81140eb0:	11351e80 	call	811351e8 <OSFlagCreate>
81140eb4:	1007883a 	mov	r3,r2
81140eb8:	e0bff217 	ldw	r2,-56(fp)
81140ebc:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81140ec0:	e0bff717 	ldw	r2,-36(fp)
81140ec4:	10800a04 	addi	r2,r2,40
81140ec8:	e0bff315 	stw	r2,-52(fp)
81140ecc:	00800044 	movi	r2,1
81140ed0:	e0bff58d 	sth	r2,-42(fp)
81140ed4:	e0bff58b 	ldhu	r2,-42(fp)
81140ed8:	1009883a 	mov	r4,r2
81140edc:	11391440 	call	81139144 <OSSemCreate>
81140ee0:	1007883a 	mov	r3,r2
81140ee4:	e0bff317 	ldw	r2,-52(fp)
81140ee8:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81140eec:	e0bff717 	ldw	r2,-36(fp)
81140ef0:	10800b04 	addi	r2,r2,44
81140ef4:	e0bff415 	stw	r2,-48(fp)
81140ef8:	00800044 	movi	r2,1
81140efc:	e0bff50d 	sth	r2,-44(fp)
81140f00:	e0bff50b 	ldhu	r2,-44(fp)
81140f04:	1009883a 	mov	r4,r2
81140f08:	11391440 	call	81139144 <OSSemCreate>
81140f0c:	1007883a 	mov	r3,r2
81140f10:	e0bff417 	ldw	r2,-48(fp)
81140f14:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81140f18:	e0bff717 	ldw	r2,-36(fp)
81140f1c:	00c00044 	movi	r3,1
81140f20:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81140f24:	e0bff717 	ldw	r2,-36(fp)
81140f28:	10800017 	ldw	r2,0(r2)
81140f2c:	10800104 	addi	r2,r2,4
81140f30:	1007883a 	mov	r3,r2
81140f34:	e0bff717 	ldw	r2,-36(fp)
81140f38:	10800817 	ldw	r2,32(r2)
81140f3c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
81140f40:	e0bff817 	ldw	r2,-32(fp)
81140f44:	e0fff917 	ldw	r3,-28(fp)
81140f48:	d8000015 	stw	zero,0(sp)
81140f4c:	e1fff717 	ldw	r7,-36(fp)
81140f50:	01a04534 	movhi	r6,33044
81140f54:	31840d04 	addi	r6,r6,4148
81140f58:	180b883a 	mov	r5,r3
81140f5c:	1009883a 	mov	r4,r2
81140f60:	1144d7c0 	call	81144d7c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
81140f64:	e0bff717 	ldw	r2,-36(fp)
81140f68:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81140f6c:	e0bff717 	ldw	r2,-36(fp)
81140f70:	10800204 	addi	r2,r2,8
81140f74:	d0e08217 	ldw	r3,-32248(gp)
81140f78:	e1fff717 	ldw	r7,-36(fp)
81140f7c:	01a04534 	movhi	r6,33044
81140f80:	3184bc04 	addi	r6,r6,4848
81140f84:	180b883a 	mov	r5,r3
81140f88:	1009883a 	mov	r4,r2
81140f8c:	11448cc0 	call	811448cc <alt_alarm_start>
81140f90:	1000040e 	bge	r2,zero,81140fa4 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
81140f94:	e0fff717 	ldw	r3,-36(fp)
81140f98:	00a00034 	movhi	r2,32768
81140f9c:	10bfffc4 	addi	r2,r2,-1
81140fa0:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
81140fa4:	d0a07b83 	ldbu	r2,-32274(gp)
81140fa8:	10803fcc 	andi	r2,r2,255
81140fac:	10800058 	cmpnei	r2,r2,1
81140fb0:	10000f1e 	bne	r2,zero,81140ff0 <altera_avalon_jtag_uart_init+0x18c>
81140fb4:	d0e08217 	ldw	r3,-32248(gp)
81140fb8:	00b33374 	movhi	r2,52429
81140fbc:	10b33344 	addi	r2,r2,-13107
81140fc0:	1888383a 	mulxuu	r4,r3,r2
81140fc4:	1885383a 	mul	r2,r3,r2
81140fc8:	1021883a 	mov	r16,r2
81140fcc:	2023883a 	mov	r17,r4
81140fd0:	8804d0fa 	srli	r2,r17,3
81140fd4:	e1fff717 	ldw	r7,-36(fp)
81140fd8:	01a044f4 	movhi	r6,33043
81140fdc:	31864604 	addi	r6,r6,6424
81140fe0:	100b883a 	mov	r5,r2
81140fe4:	012045b4 	movhi	r4,33046
81140fe8:	21018404 	addi	r4,r4,1552
81140fec:	11448cc0 	call	811448cc <alt_alarm_start>
81140ff0:	d0a07c03 	ldbu	r2,-32272(gp)
81140ff4:	10803fcc 	andi	r2,r2,255
81140ff8:	10800058 	cmpnei	r2,r2,1
81140ffc:	1000051e 	bne	r2,zero,81141014 <altera_avalon_jtag_uart_init+0x1b0>
81141000:	e0bff717 	ldw	r2,-36(fp)
81141004:	10800017 	ldw	r2,0(r2)
81141008:	100b883a 	mov	r5,r2
8114100c:	e13ff717 	ldw	r4,-36(fp)
81141010:	1131ab00 	call	81131ab0 <alt_log_jtag_uart_startup_info>
}
81141014:	0001883a 	nop
81141018:	e6fffe04 	addi	sp,fp,-8
8114101c:	dfc00317 	ldw	ra,12(sp)
81141020:	df000217 	ldw	fp,8(sp)
81141024:	dc400117 	ldw	r17,4(sp)
81141028:	dc000017 	ldw	r16,0(sp)
8114102c:	dec00404 	addi	sp,sp,16
81141030:	f800283a 	ret

81141034 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81141034:	defff204 	addi	sp,sp,-56
81141038:	de00012e 	bgeu	sp,et,81141040 <altera_avalon_jtag_uart_irq+0xc>
8114103c:	003b68fa 	trap	3
81141040:	dfc00d15 	stw	ra,52(sp)
81141044:	df000c15 	stw	fp,48(sp)
81141048:	df000c04 	addi	fp,sp,48
8114104c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81141050:	e0bfff17 	ldw	r2,-4(fp)
81141054:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81141058:	e0bff617 	ldw	r2,-40(fp)
8114105c:	10800017 	ldw	r2,0(r2)
81141060:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
81141064:	e0bff717 	ldw	r2,-36(fp)
81141068:	e17ff617 	ldw	r5,-40(fp)
8114106c:	1009883a 	mov	r4,r2
81141070:	1131b040 	call	81131b04 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81141074:	e0bff717 	ldw	r2,-36(fp)
81141078:	10800104 	addi	r2,r2,4
8114107c:	10800037 	ldwio	r2,0(r2)
81141080:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
81141084:	e0bff817 	ldw	r2,-32(fp)
81141088:	1080c00c 	andi	r2,r2,768
8114108c:	10009126 	beq	r2,zero,811412d4 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
81141090:	e0bff817 	ldw	r2,-32(fp)
81141094:	1080400c 	andi	r2,r2,256
81141098:	10004726 	beq	r2,zero,811411b8 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
8114109c:	00800074 	movhi	r2,1
811410a0:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811410a4:	e0bff617 	ldw	r2,-40(fp)
811410a8:	10800d17 	ldw	r2,52(r2)
811410ac:	10800044 	addi	r2,r2,1
811410b0:	1081ffcc 	andi	r2,r2,2047
811410b4:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
811410b8:	e0bff617 	ldw	r2,-40(fp)
811410bc:	10c00e17 	ldw	r3,56(r2)
811410c0:	e0bff917 	ldw	r2,-28(fp)
811410c4:	18802726 	beq	r3,r2,81141164 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
811410c8:	e0bff717 	ldw	r2,-36(fp)
811410cc:	10800037 	ldwio	r2,0(r2)
811410d0:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
811410d4:	e0bff417 	ldw	r2,-48(fp)
811410d8:	10a0000c 	andi	r2,r2,32768
811410dc:	10002326 	beq	r2,zero,8114116c <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
811410e0:	e0bff617 	ldw	r2,-40(fp)
811410e4:	10800d17 	ldw	r2,52(r2)
811410e8:	e0fff417 	ldw	r3,-48(fp)
811410ec:	1809883a 	mov	r4,r3
811410f0:	e0fff617 	ldw	r3,-40(fp)
811410f4:	1885883a 	add	r2,r3,r2
811410f8:	10801104 	addi	r2,r2,68
811410fc:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81141100:	e0bff617 	ldw	r2,-40(fp)
81141104:	10800d17 	ldw	r2,52(r2)
81141108:	10800044 	addi	r2,r2,1
8114110c:	10c1ffcc 	andi	r3,r2,2047
81141110:	e0bff617 	ldw	r2,-40(fp)
81141114:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81141118:	e0bff617 	ldw	r2,-40(fp)
8114111c:	10800c17 	ldw	r2,48(r2)
81141120:	e0bffb15 	stw	r2,-20(fp)
81141124:	00800044 	movi	r2,1
81141128:	e0bffc0d 	sth	r2,-16(fp)
8114112c:	00800044 	movi	r2,1
81141130:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81141134:	d0a08b03 	ldbu	r2,-32212(gp)
81141138:	10803fcc 	andi	r2,r2,255
8114113c:	103fd926 	beq	r2,zero,811410a4 <__reset+0xfb1210a4>
  {
    OSFlagPost (group, flags, opt, &err);
81141140:	e0bffc0b 	ldhu	r2,-16(fp)
81141144:	e0fffc83 	ldbu	r3,-14(fp)
81141148:	e13ffdc4 	addi	r4,fp,-9
8114114c:	200f883a 	mov	r7,r4
81141150:	180d883a 	mov	r6,r3
81141154:	100b883a 	mov	r5,r2
81141158:	e13ffb17 	ldw	r4,-20(fp)
8114115c:	1135df40 	call	81135df4 <OSFlagPost>
      }
81141160:	003fd006 	br	811410a4 <__reset+0xfb1210a4>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
81141164:	0001883a 	nop
81141168:	00000106 	br	81141170 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
8114116c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
81141170:	e0bff417 	ldw	r2,-48(fp)
81141174:	10bfffec 	andhi	r2,r2,65535
81141178:	10000f26 	beq	r2,zero,811411b8 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8114117c:	e0bff617 	ldw	r2,-40(fp)
81141180:	10c00817 	ldw	r3,32(r2)
81141184:	00bfff84 	movi	r2,-2
81141188:	1886703a 	and	r3,r3,r2
8114118c:	e0bff617 	ldw	r2,-40(fp)
81141190:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
81141194:	e0bff717 	ldw	r2,-36(fp)
81141198:	10800104 	addi	r2,r2,4
8114119c:	1007883a 	mov	r3,r2
811411a0:	e0bff617 	ldw	r2,-40(fp)
811411a4:	10800817 	ldw	r2,32(r2)
811411a8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811411ac:	e0bff717 	ldw	r2,-36(fp)
811411b0:	10800104 	addi	r2,r2,4
811411b4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
811411b8:	e0bff817 	ldw	r2,-32(fp)
811411bc:	1080800c 	andi	r2,r2,512
811411c0:	103fac26 	beq	r2,zero,81141074 <__reset+0xfb121074>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
811411c4:	e0bff817 	ldw	r2,-32(fp)
811411c8:	1004d43a 	srli	r2,r2,16
811411cc:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
811411d0:	00002606 	br	8114126c <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
811411d4:	e0bff717 	ldw	r2,-36(fp)
811411d8:	e0fff617 	ldw	r3,-40(fp)
811411dc:	18c01017 	ldw	r3,64(r3)
811411e0:	e13ff617 	ldw	r4,-40(fp)
811411e4:	20c7883a 	add	r3,r4,r3
811411e8:	18c21104 	addi	r3,r3,2116
811411ec:	18c00003 	ldbu	r3,0(r3)
811411f0:	18c03fcc 	andi	r3,r3,255
811411f4:	18c0201c 	xori	r3,r3,128
811411f8:	18ffe004 	addi	r3,r3,-128
811411fc:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81141200:	e0bff617 	ldw	r2,-40(fp)
81141204:	10801017 	ldw	r2,64(r2)
81141208:	10800044 	addi	r2,r2,1
8114120c:	10c1ffcc 	andi	r3,r2,2047
81141210:	e0bff617 	ldw	r2,-40(fp)
81141214:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81141218:	e0bff617 	ldw	r2,-40(fp)
8114121c:	10800c17 	ldw	r2,48(r2)
81141220:	e0bffa15 	stw	r2,-24(fp)
81141224:	00800084 	movi	r2,2
81141228:	e0bffd0d 	sth	r2,-12(fp)
8114122c:	00800044 	movi	r2,1
81141230:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81141234:	d0a08b03 	ldbu	r2,-32212(gp)
81141238:	10803fcc 	andi	r2,r2,255
8114123c:	10000826 	beq	r2,zero,81141260 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81141240:	e0bffd0b 	ldhu	r2,-12(fp)
81141244:	e0fffd83 	ldbu	r3,-10(fp)
81141248:	e13ffe04 	addi	r4,fp,-8
8114124c:	200f883a 	mov	r7,r4
81141250:	180d883a 	mov	r6,r3
81141254:	100b883a 	mov	r5,r2
81141258:	e13ffa17 	ldw	r4,-24(fp)
8114125c:	1135df40 	call	81135df4 <OSFlagPost>

        space--;
81141260:	e0bff517 	ldw	r2,-44(fp)
81141264:	10bfffc4 	addi	r2,r2,-1
81141268:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
8114126c:	e0bff517 	ldw	r2,-44(fp)
81141270:	10000526 	beq	r2,zero,81141288 <altera_avalon_jtag_uart_irq+0x254>
81141274:	e0bff617 	ldw	r2,-40(fp)
81141278:	10c01017 	ldw	r3,64(r2)
8114127c:	e0bff617 	ldw	r2,-40(fp)
81141280:	10800f17 	ldw	r2,60(r2)
81141284:	18bfd31e 	bne	r3,r2,811411d4 <__reset+0xfb1211d4>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81141288:	e0bff517 	ldw	r2,-44(fp)
8114128c:	103f7926 	beq	r2,zero,81141074 <__reset+0xfb121074>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81141290:	e0bff617 	ldw	r2,-40(fp)
81141294:	10c00817 	ldw	r3,32(r2)
81141298:	00bfff44 	movi	r2,-3
8114129c:	1886703a 	and	r3,r3,r2
811412a0:	e0bff617 	ldw	r2,-40(fp)
811412a4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811412a8:	e0bff617 	ldw	r2,-40(fp)
811412ac:	10800017 	ldw	r2,0(r2)
811412b0:	10800104 	addi	r2,r2,4
811412b4:	1007883a 	mov	r3,r2
811412b8:	e0bff617 	ldw	r2,-40(fp)
811412bc:	10800817 	ldw	r2,32(r2)
811412c0:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811412c4:	e0bff717 	ldw	r2,-36(fp)
811412c8:	10800104 	addi	r2,r2,4
811412cc:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
811412d0:	003f6806 	br	81141074 <__reset+0xfb121074>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
811412d4:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
811412d8:	0001883a 	nop
811412dc:	e037883a 	mov	sp,fp
811412e0:	dfc00117 	ldw	ra,4(sp)
811412e4:	df000017 	ldw	fp,0(sp)
811412e8:	dec00204 	addi	sp,sp,8
811412ec:	f800283a 	ret

811412f0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
811412f0:	defff904 	addi	sp,sp,-28
811412f4:	de00012e 	bgeu	sp,et,811412fc <altera_avalon_jtag_uart_timeout+0xc>
811412f8:	003b68fa 	trap	3
811412fc:	dfc00615 	stw	ra,24(sp)
81141300:	df000515 	stw	fp,20(sp)
81141304:	df000504 	addi	fp,sp,20
81141308:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
8114130c:	e0bfff17 	ldw	r2,-4(fp)
81141310:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81141314:	e0bffb17 	ldw	r2,-20(fp)
81141318:	10800017 	ldw	r2,0(r2)
8114131c:	10800104 	addi	r2,r2,4
81141320:	10800037 	ldwio	r2,0(r2)
81141324:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81141328:	e0bffc17 	ldw	r2,-16(fp)
8114132c:	1081000c 	andi	r2,r2,1024
81141330:	10000b26 	beq	r2,zero,81141360 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81141334:	e0bffb17 	ldw	r2,-20(fp)
81141338:	10800017 	ldw	r2,0(r2)
8114133c:	10800104 	addi	r2,r2,4
81141340:	1007883a 	mov	r3,r2
81141344:	e0bffb17 	ldw	r2,-20(fp)
81141348:	10800817 	ldw	r2,32(r2)
8114134c:	10810014 	ori	r2,r2,1024
81141350:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81141354:	e0bffb17 	ldw	r2,-20(fp)
81141358:	10000915 	stw	zero,36(r2)
8114135c:	00002106 	br	811413e4 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81141360:	e0bffb17 	ldw	r2,-20(fp)
81141364:	10c00917 	ldw	r3,36(r2)
81141368:	00a00034 	movhi	r2,32768
8114136c:	10bfff04 	addi	r2,r2,-4
81141370:	10c01c36 	bltu	r2,r3,811413e4 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81141374:	e0bffb17 	ldw	r2,-20(fp)
81141378:	10800917 	ldw	r2,36(r2)
8114137c:	10c00044 	addi	r3,r2,1
81141380:	e0bffb17 	ldw	r2,-20(fp)
81141384:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81141388:	e0bffb17 	ldw	r2,-20(fp)
8114138c:	10c00917 	ldw	r3,36(r2)
81141390:	e0bffb17 	ldw	r2,-20(fp)
81141394:	10800117 	ldw	r2,4(r2)
81141398:	18801236 	bltu	r3,r2,811413e4 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
8114139c:	e0bffb17 	ldw	r2,-20(fp)
811413a0:	10800c17 	ldw	r2,48(r2)
811413a4:	e0bffd15 	stw	r2,-12(fp)
811413a8:	00800104 	movi	r2,4
811413ac:	e0bffe0d 	sth	r2,-8(fp)
811413b0:	00800044 	movi	r2,1
811413b4:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811413b8:	d0a08b03 	ldbu	r2,-32212(gp)
811413bc:	10803fcc 	andi	r2,r2,255
811413c0:	10000826 	beq	r2,zero,811413e4 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
811413c4:	e0bffe0b 	ldhu	r2,-8(fp)
811413c8:	e0fffe83 	ldbu	r3,-6(fp)
811413cc:	e13ffec4 	addi	r4,fp,-5
811413d0:	200f883a 	mov	r7,r4
811413d4:	180d883a 	mov	r6,r3
811413d8:	100b883a 	mov	r5,r2
811413dc:	e13ffd17 	ldw	r4,-12(fp)
811413e0:	1135df40 	call	81135df4 <OSFlagPost>
811413e4:	d0a08217 	ldw	r2,-32248(gp)
    }
  }

  return alt_ticks_per_second();
}
811413e8:	e037883a 	mov	sp,fp
811413ec:	dfc00117 	ldw	ra,4(sp)
811413f0:	df000017 	ldw	fp,0(sp)
811413f4:	dec00204 	addi	sp,sp,8
811413f8:	f800283a 	ret

811413fc <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
811413fc:	defffd04 	addi	sp,sp,-12
81141400:	de00012e 	bgeu	sp,et,81141408 <altera_avalon_jtag_uart_close+0xc>
81141404:	003b68fa 	trap	3
81141408:	df000215 	stw	fp,8(sp)
8114140c:	df000204 	addi	fp,sp,8
81141410:	e13ffe15 	stw	r4,-8(fp)
81141414:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81141418:	00000506 	br	81141430 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8114141c:	e0bfff17 	ldw	r2,-4(fp)
81141420:	1090000c 	andi	r2,r2,16384
81141424:	10000226 	beq	r2,zero,81141430 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81141428:	00bffd44 	movi	r2,-11
8114142c:	00000b06 	br	8114145c <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81141430:	e0bffe17 	ldw	r2,-8(fp)
81141434:	10c01017 	ldw	r3,64(r2)
81141438:	e0bffe17 	ldw	r2,-8(fp)
8114143c:	10800f17 	ldw	r2,60(r2)
81141440:	18800526 	beq	r3,r2,81141458 <altera_avalon_jtag_uart_close+0x5c>
81141444:	e0bffe17 	ldw	r2,-8(fp)
81141448:	10c00917 	ldw	r3,36(r2)
8114144c:	e0bffe17 	ldw	r2,-8(fp)
81141450:	10800117 	ldw	r2,4(r2)
81141454:	18bff136 	bltu	r3,r2,8114141c <__reset+0xfb12141c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81141458:	0005883a 	mov	r2,zero
}
8114145c:	e037883a 	mov	sp,fp
81141460:	df000017 	ldw	fp,0(sp)
81141464:	dec00104 	addi	sp,sp,4
81141468:	f800283a 	ret

8114146c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
8114146c:	defffa04 	addi	sp,sp,-24
81141470:	de00012e 	bgeu	sp,et,81141478 <altera_avalon_jtag_uart_ioctl+0xc>
81141474:	003b68fa 	trap	3
81141478:	df000515 	stw	fp,20(sp)
8114147c:	df000504 	addi	fp,sp,20
81141480:	e13ffd15 	stw	r4,-12(fp)
81141484:	e17ffe15 	stw	r5,-8(fp)
81141488:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
8114148c:	00bff9c4 	movi	r2,-25
81141490:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81141494:	e0bffe17 	ldw	r2,-8(fp)
81141498:	10da8060 	cmpeqi	r3,r2,27137
8114149c:	1800031e 	bne	r3,zero,811414ac <altera_avalon_jtag_uart_ioctl+0x40>
811414a0:	109a80a0 	cmpeqi	r2,r2,27138
811414a4:	1000181e 	bne	r2,zero,81141508 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
811414a8:	00002906 	br	81141550 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
811414ac:	e0bffd17 	ldw	r2,-12(fp)
811414b0:	10c00117 	ldw	r3,4(r2)
811414b4:	00a00034 	movhi	r2,32768
811414b8:	10bfffc4 	addi	r2,r2,-1
811414bc:	18802126 	beq	r3,r2,81141544 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
811414c0:	e0bfff17 	ldw	r2,-4(fp)
811414c4:	10800017 	ldw	r2,0(r2)
811414c8:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
811414cc:	e0bffc17 	ldw	r2,-16(fp)
811414d0:	10800090 	cmplti	r2,r2,2
811414d4:	1000061e 	bne	r2,zero,811414f0 <altera_avalon_jtag_uart_ioctl+0x84>
811414d8:	e0fffc17 	ldw	r3,-16(fp)
811414dc:	00a00034 	movhi	r2,32768
811414e0:	10bfffc4 	addi	r2,r2,-1
811414e4:	18800226 	beq	r3,r2,811414f0 <altera_avalon_jtag_uart_ioctl+0x84>
811414e8:	e0bffc17 	ldw	r2,-16(fp)
811414ec:	00000206 	br	811414f8 <altera_avalon_jtag_uart_ioctl+0x8c>
811414f0:	00a00034 	movhi	r2,32768
811414f4:	10bfff84 	addi	r2,r2,-2
811414f8:	e0fffd17 	ldw	r3,-12(fp)
811414fc:	18800115 	stw	r2,4(r3)
      rc = 0;
81141500:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81141504:	00000f06 	br	81141544 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81141508:	e0bffd17 	ldw	r2,-12(fp)
8114150c:	10c00117 	ldw	r3,4(r2)
81141510:	00a00034 	movhi	r2,32768
81141514:	10bfffc4 	addi	r2,r2,-1
81141518:	18800c26 	beq	r3,r2,8114154c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
8114151c:	e0bffd17 	ldw	r2,-12(fp)
81141520:	10c00917 	ldw	r3,36(r2)
81141524:	e0bffd17 	ldw	r2,-12(fp)
81141528:	10800117 	ldw	r2,4(r2)
8114152c:	1885803a 	cmpltu	r2,r3,r2
81141530:	10c03fcc 	andi	r3,r2,255
81141534:	e0bfff17 	ldw	r2,-4(fp)
81141538:	10c00015 	stw	r3,0(r2)
      rc = 0;
8114153c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81141540:	00000206 	br	8114154c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81141544:	0001883a 	nop
81141548:	00000106 	br	81141550 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
8114154c:	0001883a 	nop

  default:
    break;
  }

  return rc;
81141550:	e0bffb17 	ldw	r2,-20(fp)
}
81141554:	e037883a 	mov	sp,fp
81141558:	df000017 	ldw	fp,0(sp)
8114155c:	dec00104 	addi	sp,sp,4
81141560:	f800283a 	ret

81141564 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81141564:	deffed04 	addi	sp,sp,-76
81141568:	de00012e 	bgeu	sp,et,81141570 <altera_avalon_jtag_uart_read+0xc>
8114156c:	003b68fa 	trap	3
81141570:	dfc01215 	stw	ra,72(sp)
81141574:	df001115 	stw	fp,68(sp)
81141578:	df001104 	addi	fp,sp,68
8114157c:	e13ffc15 	stw	r4,-16(fp)
81141580:	e17ffd15 	stw	r5,-12(fp)
81141584:	e1bffe15 	stw	r6,-8(fp)
81141588:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
8114158c:	e0bffd17 	ldw	r2,-12(fp)
81141590:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81141594:	e0bffc17 	ldw	r2,-16(fp)
81141598:	10800a17 	ldw	r2,40(r2)
8114159c:	e0bff815 	stw	r2,-32(fp)
811415a0:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811415a4:	e0bff90b 	ldhu	r2,-28(fp)
811415a8:	e0fffb04 	addi	r3,fp,-20
811415ac:	180d883a 	mov	r6,r3
811415b0:	100b883a 	mov	r5,r2
811415b4:	e13ff817 	ldw	r4,-32(fp)
811415b8:	113946c0 	call	8113946c <OSSemPend>

  while (space > 0)
811415bc:	00006106 	br	81141744 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
811415c0:	e0bffc17 	ldw	r2,-16(fp)
811415c4:	10800d17 	ldw	r2,52(r2)
811415c8:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
811415cc:	e0bffc17 	ldw	r2,-16(fp)
811415d0:	10800e17 	ldw	r2,56(r2)
811415d4:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
811415d8:	e0fff317 	ldw	r3,-52(fp)
811415dc:	e0bff417 	ldw	r2,-48(fp)
811415e0:	18800536 	bltu	r3,r2,811415f8 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
811415e4:	e0fff317 	ldw	r3,-52(fp)
811415e8:	e0bff417 	ldw	r2,-48(fp)
811415ec:	1885c83a 	sub	r2,r3,r2
811415f0:	e0bff115 	stw	r2,-60(fp)
811415f4:	00000406 	br	81141608 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
811415f8:	00c20004 	movi	r3,2048
811415fc:	e0bff417 	ldw	r2,-48(fp)
81141600:	1885c83a 	sub	r2,r3,r2
81141604:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81141608:	e0bff117 	ldw	r2,-60(fp)
8114160c:	10001e26 	beq	r2,zero,81141688 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81141610:	e0fffe17 	ldw	r3,-8(fp)
81141614:	e0bff117 	ldw	r2,-60(fp)
81141618:	1880022e 	bgeu	r3,r2,81141624 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
8114161c:	e0bffe17 	ldw	r2,-8(fp)
81141620:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81141624:	e0bffc17 	ldw	r2,-16(fp)
81141628:	10c01104 	addi	r3,r2,68
8114162c:	e0bff417 	ldw	r2,-48(fp)
81141630:	1885883a 	add	r2,r3,r2
81141634:	e1bff117 	ldw	r6,-60(fp)
81141638:	100b883a 	mov	r5,r2
8114163c:	e13ff017 	ldw	r4,-64(fp)
81141640:	111c4400 	call	8111c440 <memcpy>
      ptr   += n;
81141644:	e0fff017 	ldw	r3,-64(fp)
81141648:	e0bff117 	ldw	r2,-60(fp)
8114164c:	1885883a 	add	r2,r3,r2
81141650:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81141654:	e0fffe17 	ldw	r3,-8(fp)
81141658:	e0bff117 	ldw	r2,-60(fp)
8114165c:	1885c83a 	sub	r2,r3,r2
81141660:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81141664:	e0fff417 	ldw	r3,-48(fp)
81141668:	e0bff117 	ldw	r2,-60(fp)
8114166c:	1885883a 	add	r2,r3,r2
81141670:	10c1ffcc 	andi	r3,r2,2047
81141674:	e0bffc17 	ldw	r2,-16(fp)
81141678:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
8114167c:	e0bffe17 	ldw	r2,-8(fp)
81141680:	00bfcf16 	blt	zero,r2,811415c0 <__reset+0xfb1215c0>
81141684:	00000106 	br	8114168c <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81141688:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
8114168c:	e0fff017 	ldw	r3,-64(fp)
81141690:	e0bffd17 	ldw	r2,-12(fp)
81141694:	18802e1e 	bne	r3,r2,81141750 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81141698:	e0bfff17 	ldw	r2,-4(fp)
8114169c:	1090000c 	andi	r2,r2,16384
811416a0:	10002d1e 	bne	r2,zero,81141758 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
811416a4:	d0a08b03 	ldbu	r2,-32212(gp)
811416a8:	10803fcc 	andi	r2,r2,255
811416ac:	10800058 	cmpnei	r2,r2,1
811416b0:	1000161e 	bne	r2,zero,8114170c <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
811416b4:	e0bffc17 	ldw	r2,-16(fp)
811416b8:	10800c17 	ldw	r2,48(r2)
811416bc:	e0bff215 	stw	r2,-56(fp)
811416c0:	00800144 	movi	r2,5
811416c4:	e0bff98d 	sth	r2,-26(fp)
811416c8:	00bfe0c4 	movi	r2,-125
811416cc:	e0bffa05 	stb	r2,-24(fp)
811416d0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
811416d4:	d0a08b03 	ldbu	r2,-32212(gp)
811416d8:	10803fcc 	andi	r2,r2,255
811416dc:	10001526 	beq	r2,zero,81141734 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811416e0:	e0fff98b 	ldhu	r3,-26(fp)
811416e4:	e13ffa03 	ldbu	r4,-24(fp)
811416e8:	e17ffa8b 	ldhu	r5,-22(fp)
811416ec:	e0bffb44 	addi	r2,fp,-19
811416f0:	d8800015 	stw	r2,0(sp)
811416f4:	280f883a 	mov	r7,r5
811416f8:	200d883a 	mov	r6,r4
811416fc:	180b883a 	mov	r5,r3
81141700:	e13ff217 	ldw	r4,-56(fp)
81141704:	11357cc0 	call	811357cc <OSFlagPend>
81141708:	00000a06 	br	81141734 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
8114170c:	0001883a 	nop
81141710:	e0bffc17 	ldw	r2,-16(fp)
81141714:	10c00d17 	ldw	r3,52(r2)
81141718:	e0bff317 	ldw	r2,-52(fp)
8114171c:	1880051e 	bne	r3,r2,81141734 <altera_avalon_jtag_uart_read+0x1d0>
81141720:	e0bffc17 	ldw	r2,-16(fp)
81141724:	10c00917 	ldw	r3,36(r2)
81141728:	e0bffc17 	ldw	r2,-16(fp)
8114172c:	10800117 	ldw	r2,4(r2)
81141730:	18bff736 	bltu	r3,r2,81141710 <__reset+0xfb121710>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81141734:	e0bffc17 	ldw	r2,-16(fp)
81141738:	10c00d17 	ldw	r3,52(r2)
8114173c:	e0bff317 	ldw	r2,-52(fp)
81141740:	18800726 	beq	r3,r2,81141760 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81141744:	e0bffe17 	ldw	r2,-8(fp)
81141748:	00bf9d16 	blt	zero,r2,811415c0 <__reset+0xfb1215c0>
8114174c:	00000506 	br	81141764 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81141750:	0001883a 	nop
81141754:	00000306 	br	81141764 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81141758:	0001883a 	nop
8114175c:	00000106 	br	81141764 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81141760:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81141764:	e0bffc17 	ldw	r2,-16(fp)
81141768:	10800a17 	ldw	r2,40(r2)
8114176c:	1009883a 	mov	r4,r2
81141770:	11397f40 	call	811397f4 <OSSemPost>

  if (ptr != buffer)
81141774:	e0fff017 	ldw	r3,-64(fp)
81141778:	e0bffd17 	ldw	r2,-12(fp)
8114177c:	18801826 	beq	r3,r2,811417e0 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141780:	0005303a 	rdctl	r2,status
81141784:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141788:	e0fff717 	ldw	r3,-36(fp)
8114178c:	00bfff84 	movi	r2,-2
81141790:	1884703a 	and	r2,r3,r2
81141794:	1001703a 	wrctl	status,r2
  
  return context;
81141798:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
8114179c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811417a0:	e0bffc17 	ldw	r2,-16(fp)
811417a4:	10800817 	ldw	r2,32(r2)
811417a8:	10c00054 	ori	r3,r2,1
811417ac:	e0bffc17 	ldw	r2,-16(fp)
811417b0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811417b4:	e0bffc17 	ldw	r2,-16(fp)
811417b8:	10800017 	ldw	r2,0(r2)
811417bc:	10800104 	addi	r2,r2,4
811417c0:	1007883a 	mov	r3,r2
811417c4:	e0bffc17 	ldw	r2,-16(fp)
811417c8:	10800817 	ldw	r2,32(r2)
811417cc:	18800035 	stwio	r2,0(r3)
811417d0:	e0bff617 	ldw	r2,-40(fp)
811417d4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811417d8:	e0bff517 	ldw	r2,-44(fp)
811417dc:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
811417e0:	e0fff017 	ldw	r3,-64(fp)
811417e4:	e0bffd17 	ldw	r2,-12(fp)
811417e8:	18800426 	beq	r3,r2,811417fc <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
811417ec:	e0fff017 	ldw	r3,-64(fp)
811417f0:	e0bffd17 	ldw	r2,-12(fp)
811417f4:	1885c83a 	sub	r2,r3,r2
811417f8:	00000606 	br	81141814 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
811417fc:	e0bfff17 	ldw	r2,-4(fp)
81141800:	1090000c 	andi	r2,r2,16384
81141804:	10000226 	beq	r2,zero,81141810 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81141808:	00bffd44 	movi	r2,-11
8114180c:	00000106 	br	81141814 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81141810:	00bffec4 	movi	r2,-5
}
81141814:	e037883a 	mov	sp,fp
81141818:	dfc00117 	ldw	ra,4(sp)
8114181c:	df000017 	ldw	fp,0(sp)
81141820:	dec00204 	addi	sp,sp,8
81141824:	f800283a 	ret

81141828 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81141828:	deffed04 	addi	sp,sp,-76
8114182c:	de00012e 	bgeu	sp,et,81141834 <altera_avalon_jtag_uart_write+0xc>
81141830:	003b68fa 	trap	3
81141834:	dfc01215 	stw	ra,72(sp)
81141838:	df001115 	stw	fp,68(sp)
8114183c:	df001104 	addi	fp,sp,68
81141840:	e13ffc15 	stw	r4,-16(fp)
81141844:	e17ffd15 	stw	r5,-12(fp)
81141848:	e1bffe15 	stw	r6,-8(fp)
8114184c:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81141850:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81141854:	e0bffd17 	ldw	r2,-12(fp)
81141858:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
8114185c:	e0bffc17 	ldw	r2,-16(fp)
81141860:	10800b17 	ldw	r2,44(r2)
81141864:	e0bff815 	stw	r2,-32(fp)
81141868:	e03ff90d 	sth	zero,-28(fp)
8114186c:	e0bff90b 	ldhu	r2,-28(fp)
81141870:	e0fffb44 	addi	r3,fp,-19
81141874:	180d883a 	mov	r6,r3
81141878:	100b883a 	mov	r5,r2
8114187c:	e13ff817 	ldw	r4,-32(fp)
81141880:	113946c0 	call	8113946c <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81141884:	00003706 	br	81141964 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
81141888:	e0bffc17 	ldw	r2,-16(fp)
8114188c:	10800f17 	ldw	r2,60(r2)
81141890:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
81141894:	e0bffc17 	ldw	r2,-16(fp)
81141898:	10801017 	ldw	r2,64(r2)
8114189c:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
811418a0:	e0fff417 	ldw	r3,-48(fp)
811418a4:	e0bff017 	ldw	r2,-64(fp)
811418a8:	1880062e 	bgeu	r3,r2,811418c4 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
811418ac:	e0fff017 	ldw	r3,-64(fp)
811418b0:	e0bff417 	ldw	r2,-48(fp)
811418b4:	1885c83a 	sub	r2,r3,r2
811418b8:	10bfffc4 	addi	r2,r2,-1
811418bc:	e0bff115 	stw	r2,-60(fp)
811418c0:	00000b06 	br	811418f0 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
811418c4:	e0bff017 	ldw	r2,-64(fp)
811418c8:	10000526 	beq	r2,zero,811418e0 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
811418cc:	00c20004 	movi	r3,2048
811418d0:	e0bff417 	ldw	r2,-48(fp)
811418d4:	1885c83a 	sub	r2,r3,r2
811418d8:	e0bff115 	stw	r2,-60(fp)
811418dc:	00000406 	br	811418f0 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
811418e0:	00c1ffc4 	movi	r3,2047
811418e4:	e0bff417 	ldw	r2,-48(fp)
811418e8:	1885c83a 	sub	r2,r3,r2
811418ec:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
811418f0:	e0bff117 	ldw	r2,-60(fp)
811418f4:	10001e26 	beq	r2,zero,81141970 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
811418f8:	e0fffe17 	ldw	r3,-8(fp)
811418fc:	e0bff117 	ldw	r2,-60(fp)
81141900:	1880022e 	bgeu	r3,r2,8114190c <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81141904:	e0bffe17 	ldw	r2,-8(fp)
81141908:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
8114190c:	e0bffc17 	ldw	r2,-16(fp)
81141910:	10c21104 	addi	r3,r2,2116
81141914:	e0bff417 	ldw	r2,-48(fp)
81141918:	1885883a 	add	r2,r3,r2
8114191c:	e1bff117 	ldw	r6,-60(fp)
81141920:	e17ffd17 	ldw	r5,-12(fp)
81141924:	1009883a 	mov	r4,r2
81141928:	111c4400 	call	8111c440 <memcpy>
      ptr   += n;
8114192c:	e0fffd17 	ldw	r3,-12(fp)
81141930:	e0bff117 	ldw	r2,-60(fp)
81141934:	1885883a 	add	r2,r3,r2
81141938:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
8114193c:	e0fffe17 	ldw	r3,-8(fp)
81141940:	e0bff117 	ldw	r2,-60(fp)
81141944:	1885c83a 	sub	r2,r3,r2
81141948:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8114194c:	e0fff417 	ldw	r3,-48(fp)
81141950:	e0bff117 	ldw	r2,-60(fp)
81141954:	1885883a 	add	r2,r3,r2
81141958:	10c1ffcc 	andi	r3,r2,2047
8114195c:	e0bffc17 	ldw	r2,-16(fp)
81141960:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81141964:	e0bffe17 	ldw	r2,-8(fp)
81141968:	00bfc716 	blt	zero,r2,81141888 <__reset+0xfb121888>
8114196c:	00000106 	br	81141974 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
81141970:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141974:	0005303a 	rdctl	r2,status
81141978:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114197c:	e0fff717 	ldw	r3,-36(fp)
81141980:	00bfff84 	movi	r2,-2
81141984:	1884703a 	and	r2,r3,r2
81141988:	1001703a 	wrctl	status,r2
  
  return context;
8114198c:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
81141990:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81141994:	e0bffc17 	ldw	r2,-16(fp)
81141998:	10800817 	ldw	r2,32(r2)
8114199c:	10c00094 	ori	r3,r2,2
811419a0:	e0bffc17 	ldw	r2,-16(fp)
811419a4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811419a8:	e0bffc17 	ldw	r2,-16(fp)
811419ac:	10800017 	ldw	r2,0(r2)
811419b0:	10800104 	addi	r2,r2,4
811419b4:	1007883a 	mov	r3,r2
811419b8:	e0bffc17 	ldw	r2,-16(fp)
811419bc:	10800817 	ldw	r2,32(r2)
811419c0:	18800035 	stwio	r2,0(r3)
811419c4:	e0bff617 	ldw	r2,-40(fp)
811419c8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811419cc:	e0bff317 	ldw	r2,-52(fp)
811419d0:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
811419d4:	e0bffe17 	ldw	r2,-8(fp)
811419d8:	00802a0e 	bge	zero,r2,81141a84 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
811419dc:	e0bfff17 	ldw	r2,-4(fp)
811419e0:	1090000c 	andi	r2,r2,16384
811419e4:	10002a1e 	bne	r2,zero,81141a90 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
811419e8:	d0a08b03 	ldbu	r2,-32212(gp)
811419ec:	10803fcc 	andi	r2,r2,255
811419f0:	10800058 	cmpnei	r2,r2,1
811419f4:	1000161e 	bne	r2,zero,81141a50 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
811419f8:	e0bffc17 	ldw	r2,-16(fp)
811419fc:	10800c17 	ldw	r2,48(r2)
81141a00:	e0bff515 	stw	r2,-44(fp)
81141a04:	00800184 	movi	r2,6
81141a08:	e0bff98d 	sth	r2,-26(fp)
81141a0c:	00bfe0c4 	movi	r2,-125
81141a10:	e0bffa05 	stb	r2,-24(fp)
81141a14:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81141a18:	d0a08b03 	ldbu	r2,-32212(gp)
81141a1c:	10803fcc 	andi	r2,r2,255
81141a20:	10001526 	beq	r2,zero,81141a78 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81141a24:	e0fff98b 	ldhu	r3,-26(fp)
81141a28:	e13ffa03 	ldbu	r4,-24(fp)
81141a2c:	e17ffa8b 	ldhu	r5,-22(fp)
81141a30:	e0bffb04 	addi	r2,fp,-20
81141a34:	d8800015 	stw	r2,0(sp)
81141a38:	280f883a 	mov	r7,r5
81141a3c:	200d883a 	mov	r6,r4
81141a40:	180b883a 	mov	r5,r3
81141a44:	e13ff517 	ldw	r4,-44(fp)
81141a48:	11357cc0 	call	811357cc <OSFlagPend>
81141a4c:	00000a06 	br	81141a78 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
81141a50:	0001883a 	nop
81141a54:	e0bffc17 	ldw	r2,-16(fp)
81141a58:	10c01017 	ldw	r3,64(r2)
81141a5c:	e0bff017 	ldw	r2,-64(fp)
81141a60:	1880051e 	bne	r3,r2,81141a78 <altera_avalon_jtag_uart_write+0x250>
81141a64:	e0bffc17 	ldw	r2,-16(fp)
81141a68:	10c00917 	ldw	r3,36(r2)
81141a6c:	e0bffc17 	ldw	r2,-16(fp)
81141a70:	10800117 	ldw	r2,4(r2)
81141a74:	18bff736 	bltu	r3,r2,81141a54 <__reset+0xfb121a54>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
81141a78:	e0bffc17 	ldw	r2,-16(fp)
81141a7c:	10800917 	ldw	r2,36(r2)
81141a80:	1000051e 	bne	r2,zero,81141a98 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
81141a84:	e0bffe17 	ldw	r2,-8(fp)
81141a88:	00bfb616 	blt	zero,r2,81141964 <__reset+0xfb121964>
81141a8c:	00000306 	br	81141a9c <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
81141a90:	0001883a 	nop
81141a94:	00000106 	br	81141a9c <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
81141a98:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
81141a9c:	e0bffc17 	ldw	r2,-16(fp)
81141aa0:	10800b17 	ldw	r2,44(r2)
81141aa4:	1009883a 	mov	r4,r2
81141aa8:	11397f40 	call	811397f4 <OSSemPost>

  if (ptr != start)
81141aac:	e0fffd17 	ldw	r3,-12(fp)
81141ab0:	e0bff217 	ldw	r2,-56(fp)
81141ab4:	18800426 	beq	r3,r2,81141ac8 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
81141ab8:	e0fffd17 	ldw	r3,-12(fp)
81141abc:	e0bff217 	ldw	r2,-56(fp)
81141ac0:	1885c83a 	sub	r2,r3,r2
81141ac4:	00000606 	br	81141ae0 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81141ac8:	e0bfff17 	ldw	r2,-4(fp)
81141acc:	1090000c 	andi	r2,r2,16384
81141ad0:	10000226 	beq	r2,zero,81141adc <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81141ad4:	00bffd44 	movi	r2,-11
81141ad8:	00000106 	br	81141ae0 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
81141adc:	00bffec4 	movi	r2,-5
}
81141ae0:	e037883a 	mov	sp,fp
81141ae4:	dfc00117 	ldw	ra,4(sp)
81141ae8:	df000017 	ldw	fp,0(sp)
81141aec:	dec00204 	addi	sp,sp,8
81141af0:	f800283a 	ret

81141af4 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81141af4:	defffa04 	addi	sp,sp,-24
81141af8:	de00012e 	bgeu	sp,et,81141b00 <alt_avalon_timer_sc_irq+0xc>
81141afc:	003b68fa 	trap	3
81141b00:	dfc00515 	stw	ra,20(sp)
81141b04:	df000415 	stw	fp,16(sp)
81141b08:	df000404 	addi	fp,sp,16
81141b0c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81141b10:	0007883a 	mov	r3,zero
81141b14:	e0bfff17 	ldw	r2,-4(fp)
81141b18:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81141b1c:	e0bfff17 	ldw	r2,-4(fp)
81141b20:	10800104 	addi	r2,r2,4
81141b24:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81141b28:	1131ca80 	call	81131ca8 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141b2c:	0005303a 	rdctl	r2,status
81141b30:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141b34:	e0fffd17 	ldw	r3,-12(fp)
81141b38:	00bfff84 	movi	r2,-2
81141b3c:	1884703a 	and	r2,r3,r2
81141b40:	1001703a 	wrctl	status,r2
  
  return context;
81141b44:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81141b48:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81141b4c:	11325580 	call	81132558 <alt_tick>
81141b50:	e0bffc17 	ldw	r2,-16(fp)
81141b54:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141b58:	e0bffe17 	ldw	r2,-8(fp)
81141b5c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
81141b60:	0001883a 	nop
81141b64:	e037883a 	mov	sp,fp
81141b68:	dfc00117 	ldw	ra,4(sp)
81141b6c:	df000017 	ldw	fp,0(sp)
81141b70:	dec00204 	addi	sp,sp,8
81141b74:	f800283a 	ret

81141b78 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
81141b78:	defff804 	addi	sp,sp,-32
81141b7c:	de00012e 	bgeu	sp,et,81141b84 <alt_avalon_timer_sc_init+0xc>
81141b80:	003b68fa 	trap	3
81141b84:	dfc00715 	stw	ra,28(sp)
81141b88:	df000615 	stw	fp,24(sp)
81141b8c:	df000604 	addi	fp,sp,24
81141b90:	e13ffc15 	stw	r4,-16(fp)
81141b94:	e17ffd15 	stw	r5,-12(fp)
81141b98:	e1bffe15 	stw	r6,-8(fp)
81141b9c:	e1ffff15 	stw	r7,-4(fp)
81141ba0:	e0bfff17 	ldw	r2,-4(fp)
81141ba4:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
81141ba8:	d0a08217 	ldw	r2,-32248(gp)
81141bac:	1000021e 	bne	r2,zero,81141bb8 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81141bb0:	e0bffb17 	ldw	r2,-20(fp)
81141bb4:	d0a08215 	stw	r2,-32248(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
81141bb8:	e0bffc17 	ldw	r2,-16(fp)
81141bbc:	10800104 	addi	r2,r2,4
81141bc0:	00c001c4 	movi	r3,7
81141bc4:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
81141bc8:	d8000015 	stw	zero,0(sp)
81141bcc:	e1fffc17 	ldw	r7,-16(fp)
81141bd0:	01a04534 	movhi	r6,33044
81141bd4:	3186bd04 	addi	r6,r6,6900
81141bd8:	e17ffe17 	ldw	r5,-8(fp)
81141bdc:	e13ffd17 	ldw	r4,-12(fp)
81141be0:	1144d7c0 	call	81144d7c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81141be4:	0001883a 	nop
81141be8:	e037883a 	mov	sp,fp
81141bec:	dfc00117 	ldw	ra,4(sp)
81141bf0:	df000017 	ldw	fp,0(sp)
81141bf4:	dec00204 	addi	sp,sp,8
81141bf8:	f800283a 	ret

81141bfc <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81141bfc:	defffa04 	addi	sp,sp,-24
81141c00:	de00012e 	bgeu	sp,et,81141c08 <altera_avalon_uart_read_fd+0xc>
81141c04:	003b68fa 	trap	3
81141c08:	dfc00515 	stw	ra,20(sp)
81141c0c:	df000415 	stw	fp,16(sp)
81141c10:	df000404 	addi	fp,sp,16
81141c14:	e13ffd15 	stw	r4,-12(fp)
81141c18:	e17ffe15 	stw	r5,-8(fp)
81141c1c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81141c20:	e0bffd17 	ldw	r2,-12(fp)
81141c24:	10800017 	ldw	r2,0(r2)
81141c28:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81141c2c:	e0bffc17 	ldw	r2,-16(fp)
81141c30:	10c00a04 	addi	r3,r2,40
81141c34:	e0bffd17 	ldw	r2,-12(fp)
81141c38:	10800217 	ldw	r2,8(r2)
81141c3c:	100f883a 	mov	r7,r2
81141c40:	e1bfff17 	ldw	r6,-4(fp)
81141c44:	e17ffe17 	ldw	r5,-8(fp)
81141c48:	1809883a 	mov	r4,r3
81141c4c:	11422bc0 	call	811422bc <altera_avalon_uart_read>
      fd->fd_flags);
}
81141c50:	e037883a 	mov	sp,fp
81141c54:	dfc00117 	ldw	ra,4(sp)
81141c58:	df000017 	ldw	fp,0(sp)
81141c5c:	dec00204 	addi	sp,sp,8
81141c60:	f800283a 	ret

81141c64 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81141c64:	defffa04 	addi	sp,sp,-24
81141c68:	de00012e 	bgeu	sp,et,81141c70 <altera_avalon_uart_write_fd+0xc>
81141c6c:	003b68fa 	trap	3
81141c70:	dfc00515 	stw	ra,20(sp)
81141c74:	df000415 	stw	fp,16(sp)
81141c78:	df000404 	addi	fp,sp,16
81141c7c:	e13ffd15 	stw	r4,-12(fp)
81141c80:	e17ffe15 	stw	r5,-8(fp)
81141c84:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81141c88:	e0bffd17 	ldw	r2,-12(fp)
81141c8c:	10800017 	ldw	r2,0(r2)
81141c90:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
81141c94:	e0bffc17 	ldw	r2,-16(fp)
81141c98:	10c00a04 	addi	r3,r2,40
81141c9c:	e0bffd17 	ldw	r2,-12(fp)
81141ca0:	10800217 	ldw	r2,8(r2)
81141ca4:	100f883a 	mov	r7,r2
81141ca8:	e1bfff17 	ldw	r6,-4(fp)
81141cac:	e17ffe17 	ldw	r5,-8(fp)
81141cb0:	1809883a 	mov	r4,r3
81141cb4:	11425700 	call	81142570 <altera_avalon_uart_write>
      fd->fd_flags);
}
81141cb8:	e037883a 	mov	sp,fp
81141cbc:	dfc00117 	ldw	ra,4(sp)
81141cc0:	df000017 	ldw	fp,0(sp)
81141cc4:	dec00204 	addi	sp,sp,8
81141cc8:	f800283a 	ret

81141ccc <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
81141ccc:	defffc04 	addi	sp,sp,-16
81141cd0:	de00012e 	bgeu	sp,et,81141cd8 <altera_avalon_uart_close_fd+0xc>
81141cd4:	003b68fa 	trap	3
81141cd8:	dfc00315 	stw	ra,12(sp)
81141cdc:	df000215 	stw	fp,8(sp)
81141ce0:	df000204 	addi	fp,sp,8
81141ce4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81141ce8:	e0bfff17 	ldw	r2,-4(fp)
81141cec:	10800017 	ldw	r2,0(r2)
81141cf0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81141cf4:	e0bffe17 	ldw	r2,-8(fp)
81141cf8:	10c00a04 	addi	r3,r2,40
81141cfc:	e0bfff17 	ldw	r2,-4(fp)
81141d00:	10800217 	ldw	r2,8(r2)
81141d04:	100b883a 	mov	r5,r2
81141d08:	1809883a 	mov	r4,r3
81141d0c:	114221c0 	call	8114221c <altera_avalon_uart_close>
}
81141d10:	e037883a 	mov	sp,fp
81141d14:	dfc00117 	ldw	ra,4(sp)
81141d18:	df000017 	ldw	fp,0(sp)
81141d1c:	dec00204 	addi	sp,sp,8
81141d20:	f800283a 	ret

81141d24 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81141d24:	defff304 	addi	sp,sp,-52
81141d28:	de00012e 	bgeu	sp,et,81141d30 <altera_avalon_uart_init+0xc>
81141d2c:	003b68fa 	trap	3
81141d30:	dfc00c15 	stw	ra,48(sp)
81141d34:	df000b15 	stw	fp,44(sp)
81141d38:	df000b04 	addi	fp,sp,44
81141d3c:	e13ffd15 	stw	r4,-12(fp)
81141d40:	e17ffe15 	stw	r5,-8(fp)
81141d44:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81141d48:	e0bffd17 	ldw	r2,-12(fp)
81141d4c:	10800017 	ldw	r2,0(r2)
81141d50:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81141d54:	e0bffd17 	ldw	r2,-12(fp)
81141d58:	10800704 	addi	r2,r2,28
81141d5c:	e0bffa15 	stw	r2,-24(fp)
81141d60:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81141d64:	e0bffb0b 	ldhu	r2,-20(fp)
81141d68:	e0fffc84 	addi	r3,fp,-14
81141d6c:	180b883a 	mov	r5,r3
81141d70:	1009883a 	mov	r4,r2
81141d74:	11351e80 	call	811351e8 <OSFlagCreate>
81141d78:	1007883a 	mov	r3,r2
81141d7c:	e0bffa17 	ldw	r2,-24(fp)
81141d80:	10c00015 	stw	r3,0(r2)
  return err;
81141d84:	e0bffc83 	ldbu	r2,-14(fp)
81141d88:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81141d8c:	1000241e 	bne	r2,zero,81141e20 <altera_avalon_uart_init+0xfc>
81141d90:	e0bffd17 	ldw	r2,-12(fp)
81141d94:	10800804 	addi	r2,r2,32
81141d98:	e0bff715 	stw	r2,-36(fp)
81141d9c:	00800044 	movi	r2,1
81141da0:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81141da4:	e0bffb8b 	ldhu	r2,-18(fp)
81141da8:	1009883a 	mov	r4,r2
81141dac:	11391440 	call	81139144 <OSSemCreate>
81141db0:	1007883a 	mov	r3,r2
81141db4:	e0bff717 	ldw	r2,-36(fp)
81141db8:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81141dbc:	e0bff717 	ldw	r2,-36(fp)
81141dc0:	10800017 	ldw	r2,0(r2)
81141dc4:	10000226 	beq	r2,zero,81141dd0 <altera_avalon_uart_init+0xac>
81141dc8:	0005883a 	mov	r2,zero
81141dcc:	00000106 	br	81141dd4 <altera_avalon_uart_init+0xb0>
81141dd0:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81141dd4:	1000121e 	bne	r2,zero,81141e20 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
81141dd8:	e0bffd17 	ldw	r2,-12(fp)
81141ddc:	10800904 	addi	r2,r2,36
81141de0:	e0bff815 	stw	r2,-32(fp)
81141de4:	00800044 	movi	r2,1
81141de8:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81141dec:	e0bffc0b 	ldhu	r2,-16(fp)
81141df0:	1009883a 	mov	r4,r2
81141df4:	11391440 	call	81139144 <OSSemCreate>
81141df8:	1007883a 	mov	r3,r2
81141dfc:	e0bff817 	ldw	r2,-32(fp)
81141e00:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81141e04:	e0bff817 	ldw	r2,-32(fp)
81141e08:	10800017 	ldw	r2,0(r2)
81141e0c:	10000226 	beq	r2,zero,81141e18 <altera_avalon_uart_init+0xf4>
81141e10:	0005883a 	mov	r2,zero
81141e14:	00000106 	br	81141e1c <altera_avalon_uart_init+0xf8>
81141e18:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81141e1c:	10000226 	beq	r2,zero,81141e28 <altera_avalon_uart_init+0x104>
81141e20:	00800044 	movi	r2,1
81141e24:	00000106 	br	81141e2c <altera_avalon_uart_init+0x108>
81141e28:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81141e2c:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
81141e30:	e0bff917 	ldw	r2,-28(fp)
81141e34:	10000f1e 	bne	r2,zero,81141e74 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81141e38:	e0bffd17 	ldw	r2,-12(fp)
81141e3c:	00c32004 	movi	r3,3200
81141e40:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81141e44:	e0bff617 	ldw	r2,-40(fp)
81141e48:	10800304 	addi	r2,r2,12
81141e4c:	e0fffd17 	ldw	r3,-12(fp)
81141e50:	18c00117 	ldw	r3,4(r3)
81141e54:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81141e58:	d8000015 	stw	zero,0(sp)
81141e5c:	e1fffd17 	ldw	r7,-12(fp)
81141e60:	01a04534 	movhi	r6,33044
81141e64:	3187a304 	addi	r6,r6,7820
81141e68:	e17fff17 	ldw	r5,-4(fp)
81141e6c:	e13ffe17 	ldw	r4,-8(fp)
81141e70:	1144d7c0 	call	81144d7c <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81141e74:	0001883a 	nop
81141e78:	e037883a 	mov	sp,fp
81141e7c:	dfc00117 	ldw	ra,4(sp)
81141e80:	df000017 	ldw	fp,0(sp)
81141e84:	dec00204 	addi	sp,sp,8
81141e88:	f800283a 	ret

81141e8c <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
81141e8c:	defffa04 	addi	sp,sp,-24
81141e90:	de00012e 	bgeu	sp,et,81141e98 <altera_avalon_uart_irq+0xc>
81141e94:	003b68fa 	trap	3
81141e98:	dfc00515 	stw	ra,20(sp)
81141e9c:	df000415 	stw	fp,16(sp)
81141ea0:	df000404 	addi	fp,sp,16
81141ea4:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
81141ea8:	e0bfff17 	ldw	r2,-4(fp)
81141eac:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81141eb0:	e0bffc17 	ldw	r2,-16(fp)
81141eb4:	10800017 	ldw	r2,0(r2)
81141eb8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
81141ebc:	e0bffd17 	ldw	r2,-12(fp)
81141ec0:	10800204 	addi	r2,r2,8
81141ec4:	10800037 	ldwio	r2,0(r2)
81141ec8:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
81141ecc:	e0bffd17 	ldw	r2,-12(fp)
81141ed0:	10800204 	addi	r2,r2,8
81141ed4:	0007883a 	mov	r3,zero
81141ed8:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
81141edc:	e0bffd17 	ldw	r2,-12(fp)
81141ee0:	10800204 	addi	r2,r2,8
81141ee4:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
81141ee8:	e0bffe17 	ldw	r2,-8(fp)
81141eec:	1080200c 	andi	r2,r2,128
81141ef0:	10000326 	beq	r2,zero,81141f00 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81141ef4:	e17ffe17 	ldw	r5,-8(fp)
81141ef8:	e13ffc17 	ldw	r4,-16(fp)
81141efc:	1141f300 	call	81141f30 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
81141f00:	e0bffe17 	ldw	r2,-8(fp)
81141f04:	1081100c 	andi	r2,r2,1088
81141f08:	10000326 	beq	r2,zero,81141f18 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81141f0c:	e17ffe17 	ldw	r5,-8(fp)
81141f10:	e13ffc17 	ldw	r4,-16(fp)
81141f14:	11420700 	call	81142070 <altera_avalon_uart_txirq>
  }
  

}
81141f18:	0001883a 	nop
81141f1c:	e037883a 	mov	sp,fp
81141f20:	dfc00117 	ldw	ra,4(sp)
81141f24:	df000017 	ldw	fp,0(sp)
81141f28:	dec00204 	addi	sp,sp,8
81141f2c:	f800283a 	ret

81141f30 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81141f30:	defff904 	addi	sp,sp,-28
81141f34:	de00012e 	bgeu	sp,et,81141f3c <altera_avalon_uart_rxirq+0xc>
81141f38:	003b68fa 	trap	3
81141f3c:	dfc00615 	stw	ra,24(sp)
81141f40:	df000515 	stw	fp,20(sp)
81141f44:	df000504 	addi	fp,sp,20
81141f48:	e13ffe15 	stw	r4,-8(fp)
81141f4c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
81141f50:	e0bfff17 	ldw	r2,-4(fp)
81141f54:	108000cc 	andi	r2,r2,3
81141f58:	10003f1e 	bne	r2,zero,81142058 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81141f5c:	e0bffe17 	ldw	r2,-8(fp)
81141f60:	10c00317 	ldw	r3,12(r2)
81141f64:	e0bffe17 	ldw	r2,-8(fp)
81141f68:	10800217 	ldw	r2,8(r2)
81141f6c:	1880121e 	bne	r3,r2,81141fb8 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
81141f70:	e0bffe17 	ldw	r2,-8(fp)
81141f74:	10800717 	ldw	r2,28(r2)
81141f78:	e0bffc15 	stw	r2,-16(fp)
81141f7c:	00800044 	movi	r2,1
81141f80:	e0bffd0d 	sth	r2,-12(fp)
81141f84:	00800044 	movi	r2,1
81141f88:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81141f8c:	d0a08b03 	ldbu	r2,-32212(gp)
81141f90:	10803fcc 	andi	r2,r2,255
81141f94:	10000826 	beq	r2,zero,81141fb8 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
81141f98:	e0bffd0b 	ldhu	r2,-12(fp)
81141f9c:	e0fffd83 	ldbu	r3,-10(fp)
81141fa0:	e13ffdc4 	addi	r4,fp,-9
81141fa4:	200f883a 	mov	r7,r4
81141fa8:	180d883a 	mov	r6,r3
81141fac:	100b883a 	mov	r5,r2
81141fb0:	e13ffc17 	ldw	r4,-16(fp)
81141fb4:	1135df40 	call	81135df4 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81141fb8:	e0bffe17 	ldw	r2,-8(fp)
81141fbc:	10800317 	ldw	r2,12(r2)
81141fc0:	10800044 	addi	r2,r2,1
81141fc4:	10800fcc 	andi	r2,r2,63
81141fc8:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
81141fcc:	e0bffe17 	ldw	r2,-8(fp)
81141fd0:	10800317 	ldw	r2,12(r2)
81141fd4:	e0fffe17 	ldw	r3,-8(fp)
81141fd8:	18c00017 	ldw	r3,0(r3)
81141fdc:	18c00037 	ldwio	r3,0(r3)
81141fe0:	1809883a 	mov	r4,r3
81141fe4:	e0fffe17 	ldw	r3,-8(fp)
81141fe8:	1885883a 	add	r2,r3,r2
81141fec:	10800a04 	addi	r2,r2,40
81141ff0:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81141ff4:	e0bffe17 	ldw	r2,-8(fp)
81141ff8:	e0fffb17 	ldw	r3,-20(fp)
81141ffc:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81142000:	e0bffe17 	ldw	r2,-8(fp)
81142004:	10800317 	ldw	r2,12(r2)
81142008:	10800044 	addi	r2,r2,1
8114200c:	10800fcc 	andi	r2,r2,63
81142010:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81142014:	e0bffe17 	ldw	r2,-8(fp)
81142018:	10c00217 	ldw	r3,8(r2)
8114201c:	e0bffb17 	ldw	r2,-20(fp)
81142020:	18800e1e 	bne	r3,r2,8114205c <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81142024:	e0bffe17 	ldw	r2,-8(fp)
81142028:	10c00117 	ldw	r3,4(r2)
8114202c:	00bfdfc4 	movi	r2,-129
81142030:	1886703a 	and	r3,r3,r2
81142034:	e0bffe17 	ldw	r2,-8(fp)
81142038:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
8114203c:	e0bffe17 	ldw	r2,-8(fp)
81142040:	10800017 	ldw	r2,0(r2)
81142044:	10800304 	addi	r2,r2,12
81142048:	e0fffe17 	ldw	r3,-8(fp)
8114204c:	18c00117 	ldw	r3,4(r3)
81142050:	10c00035 	stwio	r3,0(r2)
81142054:	00000106 	br	8114205c <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81142058:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
8114205c:	e037883a 	mov	sp,fp
81142060:	dfc00117 	ldw	ra,4(sp)
81142064:	df000017 	ldw	fp,0(sp)
81142068:	dec00204 	addi	sp,sp,8
8114206c:	f800283a 	ret

81142070 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81142070:	defffa04 	addi	sp,sp,-24
81142074:	de00012e 	bgeu	sp,et,8114207c <altera_avalon_uart_txirq+0xc>
81142078:	003b68fa 	trap	3
8114207c:	dfc00515 	stw	ra,20(sp)
81142080:	df000415 	stw	fp,16(sp)
81142084:	df000404 	addi	fp,sp,16
81142088:	e13ffe15 	stw	r4,-8(fp)
8114208c:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81142090:	e0bffe17 	ldw	r2,-8(fp)
81142094:	10c00417 	ldw	r3,16(r2)
81142098:	e0bffe17 	ldw	r2,-8(fp)
8114209c:	10800517 	ldw	r2,20(r2)
811420a0:	18804726 	beq	r3,r2,811421c0 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811420a4:	e0bffe17 	ldw	r2,-8(fp)
811420a8:	10800617 	ldw	r2,24(r2)
811420ac:	1080008c 	andi	r2,r2,2
811420b0:	10000326 	beq	r2,zero,811420c0 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811420b4:	e0bfff17 	ldw	r2,-4(fp)
811420b8:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811420bc:	10003226 	beq	r2,zero,81142188 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
811420c0:	e0bffe17 	ldw	r2,-8(fp)
811420c4:	10c00417 	ldw	r3,16(r2)
811420c8:	e0bffe17 	ldw	r2,-8(fp)
811420cc:	10800517 	ldw	r2,20(r2)
811420d0:	10800044 	addi	r2,r2,1
811420d4:	10800fcc 	andi	r2,r2,63
811420d8:	1880121e 	bne	r3,r2,81142124 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
811420dc:	e0bffe17 	ldw	r2,-8(fp)
811420e0:	10800717 	ldw	r2,28(r2)
811420e4:	e0bffc15 	stw	r2,-16(fp)
811420e8:	00800084 	movi	r2,2
811420ec:	e0bffd0d 	sth	r2,-12(fp)
811420f0:	00800044 	movi	r2,1
811420f4:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811420f8:	d0a08b03 	ldbu	r2,-32212(gp)
811420fc:	10803fcc 	andi	r2,r2,255
81142100:	10000826 	beq	r2,zero,81142124 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81142104:	e0bffd0b 	ldhu	r2,-12(fp)
81142108:	e0fffd83 	ldbu	r3,-10(fp)
8114210c:	e13ffdc4 	addi	r4,fp,-9
81142110:	200f883a 	mov	r7,r4
81142114:	180d883a 	mov	r6,r3
81142118:	100b883a 	mov	r5,r2
8114211c:	e13ffc17 	ldw	r4,-16(fp)
81142120:	1135df40 	call	81135df4 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81142124:	e0bffe17 	ldw	r2,-8(fp)
81142128:	10800017 	ldw	r2,0(r2)
8114212c:	10800104 	addi	r2,r2,4
81142130:	e0fffe17 	ldw	r3,-8(fp)
81142134:	18c00417 	ldw	r3,16(r3)
81142138:	e13ffe17 	ldw	r4,-8(fp)
8114213c:	20c7883a 	add	r3,r4,r3
81142140:	18c01a04 	addi	r3,r3,104
81142144:	18c00003 	ldbu	r3,0(r3)
81142148:	18c03fcc 	andi	r3,r3,255
8114214c:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81142150:	e0bffe17 	ldw	r2,-8(fp)
81142154:	10800417 	ldw	r2,16(r2)
81142158:	10800044 	addi	r2,r2,1
8114215c:	e0fffe17 	ldw	r3,-8(fp)
81142160:	18800415 	stw	r2,16(r3)
81142164:	10c00fcc 	andi	r3,r2,63
81142168:	e0bffe17 	ldw	r2,-8(fp)
8114216c:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81142170:	e0bffe17 	ldw	r2,-8(fp)
81142174:	10800117 	ldw	r2,4(r2)
81142178:	10c01014 	ori	r3,r2,64
8114217c:	e0bffe17 	ldw	r2,-8(fp)
81142180:	10c00115 	stw	r3,4(r2)
81142184:	00000e06 	br	811421c0 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
81142188:	e0bffe17 	ldw	r2,-8(fp)
8114218c:	10800017 	ldw	r2,0(r2)
81142190:	10800204 	addi	r2,r2,8
81142194:	10800037 	ldwio	r2,0(r2)
81142198:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
8114219c:	e0bfff17 	ldw	r2,-4(fp)
811421a0:	1082000c 	andi	r2,r2,2048
811421a4:	1000061e 	bne	r2,zero,811421c0 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811421a8:	e0bffe17 	ldw	r2,-8(fp)
811421ac:	10c00117 	ldw	r3,4(r2)
811421b0:	00bfefc4 	movi	r2,-65
811421b4:	1886703a 	and	r3,r3,r2
811421b8:	e0bffe17 	ldw	r2,-8(fp)
811421bc:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
811421c0:	e0bffe17 	ldw	r2,-8(fp)
811421c4:	10c00417 	ldw	r3,16(r2)
811421c8:	e0bffe17 	ldw	r2,-8(fp)
811421cc:	10800517 	ldw	r2,20(r2)
811421d0:	1880061e 	bne	r3,r2,811421ec <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
811421d4:	e0bffe17 	ldw	r2,-8(fp)
811421d8:	10c00117 	ldw	r3,4(r2)
811421dc:	00beefc4 	movi	r2,-1089
811421e0:	1886703a 	and	r3,r3,r2
811421e4:	e0bffe17 	ldw	r2,-8(fp)
811421e8:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811421ec:	e0bffe17 	ldw	r2,-8(fp)
811421f0:	10800017 	ldw	r2,0(r2)
811421f4:	10800304 	addi	r2,r2,12
811421f8:	e0fffe17 	ldw	r3,-8(fp)
811421fc:	18c00117 	ldw	r3,4(r3)
81142200:	10c00035 	stwio	r3,0(r2)
}
81142204:	0001883a 	nop
81142208:	e037883a 	mov	sp,fp
8114220c:	dfc00117 	ldw	ra,4(sp)
81142210:	df000017 	ldw	fp,0(sp)
81142214:	dec00204 	addi	sp,sp,8
81142218:	f800283a 	ret

8114221c <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
8114221c:	defffd04 	addi	sp,sp,-12
81142220:	de00012e 	bgeu	sp,et,81142228 <altera_avalon_uart_close+0xc>
81142224:	003b68fa 	trap	3
81142228:	df000215 	stw	fp,8(sp)
8114222c:	df000204 	addi	fp,sp,8
81142230:	e13ffe15 	stw	r4,-8(fp)
81142234:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81142238:	00000506 	br	81142250 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8114223c:	e0bfff17 	ldw	r2,-4(fp)
81142240:	1090000c 	andi	r2,r2,16384
81142244:	10000226 	beq	r2,zero,81142250 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81142248:	00bffd44 	movi	r2,-11
8114224c:	00000606 	br	81142268 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81142250:	e0bffe17 	ldw	r2,-8(fp)
81142254:	10c00417 	ldw	r3,16(r2)
81142258:	e0bffe17 	ldw	r2,-8(fp)
8114225c:	10800517 	ldw	r2,20(r2)
81142260:	18bff61e 	bne	r3,r2,8114223c <__reset+0xfb12223c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81142264:	0005883a 	mov	r2,zero
}
81142268:	e037883a 	mov	sp,fp
8114226c:	df000017 	ldw	fp,0(sp)
81142270:	dec00104 	addi	sp,sp,4
81142274:	f800283a 	ret

81142278 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81142278:	defffe04 	addi	sp,sp,-8
8114227c:	de00012e 	bgeu	sp,et,81142284 <alt_get_errno+0xc>
81142280:	003b68fa 	trap	3
81142284:	dfc00115 	stw	ra,4(sp)
81142288:	df000015 	stw	fp,0(sp)
8114228c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81142290:	d0a01017 	ldw	r2,-32704(gp)
81142294:	10000326 	beq	r2,zero,811422a4 <alt_get_errno+0x2c>
81142298:	d0a01017 	ldw	r2,-32704(gp)
8114229c:	103ee83a 	callr	r2
811422a0:	00000106 	br	811422a8 <alt_get_errno+0x30>
811422a4:	d0a07204 	addi	r2,gp,-32312
}
811422a8:	e037883a 	mov	sp,fp
811422ac:	dfc00117 	ldw	ra,4(sp)
811422b0:	df000017 	ldw	fp,0(sp)
811422b4:	dec00204 	addi	sp,sp,8
811422b8:	f800283a 	ret

811422bc <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
811422bc:	deffec04 	addi	sp,sp,-80
811422c0:	de00012e 	bgeu	sp,et,811422c8 <altera_avalon_uart_read+0xc>
811422c4:	003b68fa 	trap	3
811422c8:	dfc01315 	stw	ra,76(sp)
811422cc:	df001215 	stw	fp,72(sp)
811422d0:	df001204 	addi	fp,sp,72
811422d4:	e13ffc15 	stw	r4,-16(fp)
811422d8:	e17ffd15 	stw	r5,-12(fp)
811422dc:	e1bffe15 	stw	r6,-8(fp)
811422e0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
811422e4:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
811422e8:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
811422ec:	e0bfff17 	ldw	r2,-4(fp)
811422f0:	1090000c 	andi	r2,r2,16384
811422f4:	1005003a 	cmpeq	r2,r2,zero
811422f8:	10803fcc 	andi	r2,r2,255
811422fc:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81142300:	e0bffc17 	ldw	r2,-16(fp)
81142304:	10800817 	ldw	r2,32(r2)
81142308:	e0bff815 	stw	r2,-32(fp)
8114230c:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81142310:	e0bff90b 	ldhu	r2,-28(fp)
81142314:	e0fffb44 	addi	r3,fp,-19
81142318:	180d883a 	mov	r6,r3
8114231c:	100b883a 	mov	r5,r2
81142320:	e13ff817 	ldw	r4,-32(fp)
81142324:	113946c0 	call	8113946c <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81142328:	00001306 	br	81142378 <altera_avalon_uart_read+0xbc>
    {
      count++;
8114232c:	e0bff017 	ldw	r2,-64(fp)
81142330:	10800044 	addi	r2,r2,1
81142334:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81142338:	e0bffd17 	ldw	r2,-12(fp)
8114233c:	10c00044 	addi	r3,r2,1
81142340:	e0fffd15 	stw	r3,-12(fp)
81142344:	e0fffc17 	ldw	r3,-16(fp)
81142348:	18c00217 	ldw	r3,8(r3)
8114234c:	e13ffc17 	ldw	r4,-16(fp)
81142350:	20c7883a 	add	r3,r4,r3
81142354:	18c00a04 	addi	r3,r3,40
81142358:	18c00003 	ldbu	r3,0(r3)
8114235c:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81142360:	e0bffc17 	ldw	r2,-16(fp)
81142364:	10800217 	ldw	r2,8(r2)
81142368:	10800044 	addi	r2,r2,1
8114236c:	10c00fcc 	andi	r3,r2,63
81142370:	e0bffc17 	ldw	r2,-16(fp)
81142374:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81142378:	e0fff017 	ldw	r3,-64(fp)
8114237c:	e0bffe17 	ldw	r2,-8(fp)
81142380:	1880050e 	bge	r3,r2,81142398 <altera_avalon_uart_read+0xdc>
81142384:	e0bffc17 	ldw	r2,-16(fp)
81142388:	10c00217 	ldw	r3,8(r2)
8114238c:	e0bffc17 	ldw	r2,-16(fp)
81142390:	10800317 	ldw	r2,12(r2)
81142394:	18bfe51e 	bne	r3,r2,8114232c <__reset+0xfb12232c>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81142398:	e0bff017 	ldw	r2,-64(fp)
8114239c:	10003a1e 	bne	r2,zero,81142488 <altera_avalon_uart_read+0x1cc>
811423a0:	e0bffc17 	ldw	r2,-16(fp)
811423a4:	10c00217 	ldw	r3,8(r2)
811423a8:	e0bffc17 	ldw	r2,-16(fp)
811423ac:	10800317 	ldw	r2,12(r2)
811423b0:	1880351e 	bne	r3,r2,81142488 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
811423b4:	e0bff117 	ldw	r2,-60(fp)
811423b8:	1000071e 	bne	r2,zero,811423d8 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
811423bc:	11422780 	call	81142278 <alt_get_errno>
811423c0:	1007883a 	mov	r3,r2
811423c4:	008002c4 	movi	r2,11
811423c8:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
811423cc:	00800044 	movi	r2,1
811423d0:	e0bfef05 	stb	r2,-68(fp)
        break;
811423d4:	00003006 	br	81142498 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811423d8:	0005303a 	rdctl	r2,status
811423dc:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811423e0:	e0fff517 	ldw	r3,-44(fp)
811423e4:	00bfff84 	movi	r2,-2
811423e8:	1884703a 	and	r2,r3,r2
811423ec:	1001703a 	wrctl	status,r2
  
  return context;
811423f0:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
811423f4:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811423f8:	e0bffc17 	ldw	r2,-16(fp)
811423fc:	10800117 	ldw	r2,4(r2)
81142400:	10c02014 	ori	r3,r2,128
81142404:	e0bffc17 	ldw	r2,-16(fp)
81142408:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8114240c:	e0bffc17 	ldw	r2,-16(fp)
81142410:	10800017 	ldw	r2,0(r2)
81142414:	10800304 	addi	r2,r2,12
81142418:	e0fffc17 	ldw	r3,-16(fp)
8114241c:	18c00117 	ldw	r3,4(r3)
81142420:	10c00035 	stwio	r3,0(r2)
81142424:	e0bff417 	ldw	r2,-48(fp)
81142428:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114242c:	e0bff617 	ldw	r2,-40(fp)
81142430:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81142434:	e0bffc17 	ldw	r2,-16(fp)
81142438:	10800717 	ldw	r2,28(r2)
8114243c:	e0bff215 	stw	r2,-56(fp)
81142440:	00800044 	movi	r2,1
81142444:	e0bff98d 	sth	r2,-26(fp)
81142448:	00bfe0c4 	movi	r2,-125
8114244c:	e0bffa05 	stb	r2,-24(fp)
81142450:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81142454:	d0a08b03 	ldbu	r2,-32212(gp)
81142458:	10803fcc 	andi	r2,r2,255
8114245c:	10000a26 	beq	r2,zero,81142488 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81142460:	e0fff98b 	ldhu	r3,-26(fp)
81142464:	e13ffa03 	ldbu	r4,-24(fp)
81142468:	e17ffa8b 	ldhu	r5,-22(fp)
8114246c:	e0bffb04 	addi	r2,fp,-20
81142470:	d8800015 	stw	r2,0(sp)
81142474:	280f883a 	mov	r7,r5
81142478:	200d883a 	mov	r6,r4
8114247c:	180b883a 	mov	r5,r3
81142480:	e13ff217 	ldw	r4,-56(fp)
81142484:	11357cc0 	call	811357cc <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81142488:	e0bff017 	ldw	r2,-64(fp)
8114248c:	1000021e 	bne	r2,zero,81142498 <altera_avalon_uart_read+0x1dc>
81142490:	e0bffe17 	ldw	r2,-8(fp)
81142494:	103fb81e 	bne	r2,zero,81142378 <__reset+0xfb122378>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81142498:	e0bffc17 	ldw	r2,-16(fp)
8114249c:	10800817 	ldw	r2,32(r2)
811424a0:	1009883a 	mov	r4,r2
811424a4:	11397f40 	call	811397f4 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811424a8:	0005303a 	rdctl	r2,status
811424ac:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811424b0:	e0fff717 	ldw	r3,-36(fp)
811424b4:	00bfff84 	movi	r2,-2
811424b8:	1884703a 	and	r2,r3,r2
811424bc:	1001703a 	wrctl	status,r2
  
  return context;
811424c0:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
811424c4:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811424c8:	e0bffc17 	ldw	r2,-16(fp)
811424cc:	10800117 	ldw	r2,4(r2)
811424d0:	10c02014 	ori	r3,r2,128
811424d4:	e0bffc17 	ldw	r2,-16(fp)
811424d8:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811424dc:	e0bffc17 	ldw	r2,-16(fp)
811424e0:	10800017 	ldw	r2,0(r2)
811424e4:	10800304 	addi	r2,r2,12
811424e8:	e0fffc17 	ldw	r3,-16(fp)
811424ec:	18c00117 	ldw	r3,4(r3)
811424f0:	10c00035 	stwio	r3,0(r2)
811424f4:	e0bff417 	ldw	r2,-48(fp)
811424f8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811424fc:	e0bff317 	ldw	r2,-52(fp)
81142500:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81142504:	e0bfef03 	ldbu	r2,-68(fp)
81142508:	10000226 	beq	r2,zero,81142514 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
8114250c:	00bffd44 	movi	r2,-11
81142510:	00000106 	br	81142518 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81142514:	e0bff017 	ldw	r2,-64(fp)
  }
}
81142518:	e037883a 	mov	sp,fp
8114251c:	dfc00117 	ldw	ra,4(sp)
81142520:	df000017 	ldw	fp,0(sp)
81142524:	dec00204 	addi	sp,sp,8
81142528:	f800283a 	ret

8114252c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114252c:	defffe04 	addi	sp,sp,-8
81142530:	de00012e 	bgeu	sp,et,81142538 <alt_get_errno+0xc>
81142534:	003b68fa 	trap	3
81142538:	dfc00115 	stw	ra,4(sp)
8114253c:	df000015 	stw	fp,0(sp)
81142540:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81142544:	d0a01017 	ldw	r2,-32704(gp)
81142548:	10000326 	beq	r2,zero,81142558 <alt_get_errno+0x2c>
8114254c:	d0a01017 	ldw	r2,-32704(gp)
81142550:	103ee83a 	callr	r2
81142554:	00000106 	br	8114255c <alt_get_errno+0x30>
81142558:	d0a07204 	addi	r2,gp,-32312
}
8114255c:	e037883a 	mov	sp,fp
81142560:	dfc00117 	ldw	ra,4(sp)
81142564:	df000017 	ldw	fp,0(sp)
81142568:	dec00204 	addi	sp,sp,8
8114256c:	f800283a 	ret

81142570 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81142570:	deffec04 	addi	sp,sp,-80
81142574:	de00012e 	bgeu	sp,et,8114257c <altera_avalon_uart_write+0xc>
81142578:	003b68fa 	trap	3
8114257c:	dfc01315 	stw	ra,76(sp)
81142580:	df001215 	stw	fp,72(sp)
81142584:	df001204 	addi	fp,sp,72
81142588:	e13ffc15 	stw	r4,-16(fp)
8114258c:	e17ffd15 	stw	r5,-12(fp)
81142590:	e1bffe15 	stw	r6,-8(fp)
81142594:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81142598:	e0bffe17 	ldw	r2,-8(fp)
8114259c:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
811425a0:	e0bfff17 	ldw	r2,-4(fp)
811425a4:	1090000c 	andi	r2,r2,16384
811425a8:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
811425ac:	e0bffc17 	ldw	r2,-16(fp)
811425b0:	10800917 	ldw	r2,36(r2)
811425b4:	e0bff815 	stw	r2,-32(fp)
811425b8:	e03ff90d 	sth	zero,-28(fp)
811425bc:	e0bff90b 	ldhu	r2,-28(fp)
811425c0:	e0fffb44 	addi	r3,fp,-19
811425c4:	180d883a 	mov	r6,r3
811425c8:	100b883a 	mov	r5,r2
811425cc:	e13ff817 	ldw	r4,-32(fp)
811425d0:	113946c0 	call	8113946c <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
811425d4:	00005106 	br	8114271c <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811425d8:	e0bffc17 	ldw	r2,-16(fp)
811425dc:	10800517 	ldw	r2,20(r2)
811425e0:	10800044 	addi	r2,r2,1
811425e4:	10800fcc 	andi	r2,r2,63
811425e8:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
811425ec:	e0bffc17 	ldw	r2,-16(fp)
811425f0:	10c00417 	ldw	r3,16(r2)
811425f4:	e0bff217 	ldw	r2,-56(fp)
811425f8:	1880371e 	bne	r3,r2,811426d8 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
811425fc:	e0bff017 	ldw	r2,-64(fp)
81142600:	10000526 	beq	r2,zero,81142618 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81142604:	114252c0 	call	8114252c <alt_get_errno>
81142608:	1007883a 	mov	r3,r2
8114260c:	008002c4 	movi	r2,11
81142610:	18800015 	stw	r2,0(r3)
        break;
81142614:	00004306 	br	81142724 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142618:	0005303a 	rdctl	r2,status
8114261c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142620:	e0fff517 	ldw	r3,-44(fp)
81142624:	00bfff84 	movi	r2,-2
81142628:	1884703a 	and	r2,r3,r2
8114262c:	1001703a 	wrctl	status,r2
  
  return context;
81142630:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81142634:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81142638:	e0bffc17 	ldw	r2,-16(fp)
8114263c:	10800117 	ldw	r2,4(r2)
81142640:	10c11014 	ori	r3,r2,1088
81142644:	e0bffc17 	ldw	r2,-16(fp)
81142648:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8114264c:	e0bffc17 	ldw	r2,-16(fp)
81142650:	10800017 	ldw	r2,0(r2)
81142654:	10800304 	addi	r2,r2,12
81142658:	e0fffc17 	ldw	r3,-16(fp)
8114265c:	18c00117 	ldw	r3,4(r3)
81142660:	10c00035 	stwio	r3,0(r2)
81142664:	e0bff417 	ldw	r2,-48(fp)
81142668:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114266c:	e0bff117 	ldw	r2,-60(fp)
81142670:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81142674:	e0bffc17 	ldw	r2,-16(fp)
81142678:	10800717 	ldw	r2,28(r2)
8114267c:	e0bff315 	stw	r2,-52(fp)
81142680:	00800084 	movi	r2,2
81142684:	e0bff98d 	sth	r2,-26(fp)
81142688:	00bfe0c4 	movi	r2,-125
8114268c:	e0bffa05 	stb	r2,-24(fp)
81142690:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81142694:	d0a08b03 	ldbu	r2,-32212(gp)
81142698:	10803fcc 	andi	r2,r2,255
8114269c:	10000a26 	beq	r2,zero,811426c8 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811426a0:	e0fff98b 	ldhu	r3,-26(fp)
811426a4:	e13ffa03 	ldbu	r4,-24(fp)
811426a8:	e17ffa8b 	ldhu	r5,-22(fp)
811426ac:	e0bffb04 	addi	r2,fp,-20
811426b0:	d8800015 	stw	r2,0(sp)
811426b4:	280f883a 	mov	r7,r5
811426b8:	200d883a 	mov	r6,r4
811426bc:	180b883a 	mov	r5,r3
811426c0:	e13ff317 	ldw	r4,-52(fp)
811426c4:	11357cc0 	call	811357cc <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
811426c8:	e0bffc17 	ldw	r2,-16(fp)
811426cc:	10c00417 	ldw	r3,16(r2)
811426d0:	e0bff217 	ldw	r2,-56(fp)
811426d4:	18bfe726 	beq	r3,r2,81142674 <__reset+0xfb122674>
      }
    }

    count--;
811426d8:	e0bfef17 	ldw	r2,-68(fp)
811426dc:	10bfffc4 	addi	r2,r2,-1
811426e0:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
811426e4:	e0bffc17 	ldw	r2,-16(fp)
811426e8:	10c00517 	ldw	r3,20(r2)
811426ec:	e0bffd17 	ldw	r2,-12(fp)
811426f0:	11000044 	addi	r4,r2,1
811426f4:	e13ffd15 	stw	r4,-12(fp)
811426f8:	10800003 	ldbu	r2,0(r2)
811426fc:	1009883a 	mov	r4,r2
81142700:	e0bffc17 	ldw	r2,-16(fp)
81142704:	10c5883a 	add	r2,r2,r3
81142708:	10801a04 	addi	r2,r2,104
8114270c:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81142710:	e0bffc17 	ldw	r2,-16(fp)
81142714:	e0fff217 	ldw	r3,-56(fp)
81142718:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
8114271c:	e0bfef17 	ldw	r2,-68(fp)
81142720:	103fad1e 	bne	r2,zero,811425d8 <__reset+0xfb1225d8>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81142724:	e0bffc17 	ldw	r2,-16(fp)
81142728:	10800917 	ldw	r2,36(r2)
8114272c:	1009883a 	mov	r4,r2
81142730:	11397f40 	call	811397f4 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142734:	0005303a 	rdctl	r2,status
81142738:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114273c:	e0fff717 	ldw	r3,-36(fp)
81142740:	00bfff84 	movi	r2,-2
81142744:	1884703a 	and	r2,r3,r2
81142748:	1001703a 	wrctl	status,r2
  
  return context;
8114274c:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81142750:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81142754:	e0bffc17 	ldw	r2,-16(fp)
81142758:	10800117 	ldw	r2,4(r2)
8114275c:	10c11014 	ori	r3,r2,1088
81142760:	e0bffc17 	ldw	r2,-16(fp)
81142764:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81142768:	e0bffc17 	ldw	r2,-16(fp)
8114276c:	10800017 	ldw	r2,0(r2)
81142770:	10800304 	addi	r2,r2,12
81142774:	e0fffc17 	ldw	r3,-16(fp)
81142778:	18c00117 	ldw	r3,4(r3)
8114277c:	10c00035 	stwio	r3,0(r2)
81142780:	e0bff417 	ldw	r2,-48(fp)
81142784:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142788:	e0bff617 	ldw	r2,-40(fp)
8114278c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81142790:	e0fffe17 	ldw	r3,-8(fp)
81142794:	e0bfef17 	ldw	r2,-68(fp)
81142798:	1885c83a 	sub	r2,r3,r2
}
8114279c:	e037883a 	mov	sp,fp
811427a0:	dfc00117 	ldw	ra,4(sp)
811427a4:	df000017 	ldw	fp,0(sp)
811427a8:	dec00204 	addi	sp,sp,8
811427ac:	f800283a 	ret

811427b0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811427b0:	defffe04 	addi	sp,sp,-8
811427b4:	de00012e 	bgeu	sp,et,811427bc <alt_get_errno+0xc>
811427b8:	003b68fa 	trap	3
811427bc:	dfc00115 	stw	ra,4(sp)
811427c0:	df000015 	stw	fp,0(sp)
811427c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811427c8:	d0a01017 	ldw	r2,-32704(gp)
811427cc:	10000326 	beq	r2,zero,811427dc <alt_get_errno+0x2c>
811427d0:	d0a01017 	ldw	r2,-32704(gp)
811427d4:	103ee83a 	callr	r2
811427d8:	00000106 	br	811427e0 <alt_get_errno+0x30>
811427dc:	d0a07204 	addi	r2,gp,-32312
}
811427e0:	e037883a 	mov	sp,fp
811427e4:	dfc00117 	ldw	ra,4(sp)
811427e8:	df000017 	ldw	fp,0(sp)
811427ec:	dec00204 	addi	sp,sp,8
811427f0:	f800283a 	ret

811427f4 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
811427f4:	defffc04 	addi	sp,sp,-16
811427f8:	de00012e 	bgeu	sp,et,81142800 <alt_msgdma_write_standard_descriptor+0xc>
811427fc:	003b68fa 	trap	3
81142800:	df000315 	stw	fp,12(sp)
81142804:	df000304 	addi	fp,sp,12
81142808:	e13ffd15 	stw	r4,-12(fp)
8114280c:	e17ffe15 	stw	r5,-8(fp)
81142810:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81142814:	e0bffd17 	ldw	r2,-12(fp)
81142818:	10800037 	ldwio	r2,0(r2)
8114281c:	1080010c 	andi	r2,r2,4
81142820:	10000226 	beq	r2,zero,8114282c <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81142824:	00bff904 	movi	r2,-28
81142828:	00001506 	br	81142880 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
8114282c:	e0bfff17 	ldw	r2,-4(fp)
81142830:	10800017 	ldw	r2,0(r2)
81142834:	1007883a 	mov	r3,r2
81142838:	e0bffe17 	ldw	r2,-8(fp)
8114283c:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81142840:	e0bffe17 	ldw	r2,-8(fp)
81142844:	10800104 	addi	r2,r2,4
81142848:	e0ffff17 	ldw	r3,-4(fp)
8114284c:	18c00117 	ldw	r3,4(r3)
81142850:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81142854:	e0bffe17 	ldw	r2,-8(fp)
81142858:	10800204 	addi	r2,r2,8
8114285c:	e0ffff17 	ldw	r3,-4(fp)
81142860:	18c00217 	ldw	r3,8(r3)
81142864:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81142868:	e0bffe17 	ldw	r2,-8(fp)
8114286c:	10800304 	addi	r2,r2,12
81142870:	e0ffff17 	ldw	r3,-4(fp)
81142874:	18c00317 	ldw	r3,12(r3)
81142878:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
8114287c:	0005883a 	mov	r2,zero
}
81142880:	e037883a 	mov	sp,fp
81142884:	df000017 	ldw	fp,0(sp)
81142888:	dec00104 	addi	sp,sp,4
8114288c:	f800283a 	ret

81142890 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
81142890:	defffc04 	addi	sp,sp,-16
81142894:	de00012e 	bgeu	sp,et,8114289c <alt_msgdma_write_extended_descriptor+0xc>
81142898:	003b68fa 	trap	3
8114289c:	df000315 	stw	fp,12(sp)
811428a0:	df000304 	addi	fp,sp,12
811428a4:	e13ffd15 	stw	r4,-12(fp)
811428a8:	e17ffe15 	stw	r5,-8(fp)
811428ac:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
811428b0:	e0bffd17 	ldw	r2,-12(fp)
811428b4:	10800037 	ldwio	r2,0(r2)
811428b8:	1080010c 	andi	r2,r2,4
811428bc:	10000226 	beq	r2,zero,811428c8 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
811428c0:	00bff904 	movi	r2,-28
811428c4:	00003b06 	br	811429b4 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
811428c8:	e0bfff17 	ldw	r2,-4(fp)
811428cc:	10800017 	ldw	r2,0(r2)
811428d0:	1007883a 	mov	r3,r2
811428d4:	e0bffe17 	ldw	r2,-8(fp)
811428d8:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
811428dc:	e0bffe17 	ldw	r2,-8(fp)
811428e0:	10800104 	addi	r2,r2,4
811428e4:	e0ffff17 	ldw	r3,-4(fp)
811428e8:	18c00117 	ldw	r3,4(r3)
811428ec:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
811428f0:	e0bffe17 	ldw	r2,-8(fp)
811428f4:	10800204 	addi	r2,r2,8
811428f8:	e0ffff17 	ldw	r3,-4(fp)
811428fc:	18c00217 	ldw	r3,8(r3)
81142900:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81142904:	e0bffe17 	ldw	r2,-8(fp)
81142908:	10800304 	addi	r2,r2,12
8114290c:	e0ffff17 	ldw	r3,-4(fp)
81142910:	18c0030b 	ldhu	r3,12(r3)
81142914:	18ffffcc 	andi	r3,r3,65535
81142918:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
8114291c:	e0bffe17 	ldw	r2,-8(fp)
81142920:	10800384 	addi	r2,r2,14
81142924:	e0ffff17 	ldw	r3,-4(fp)
81142928:	18c00383 	ldbu	r3,14(r3)
8114292c:	18c03fcc 	andi	r3,r3,255
81142930:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81142934:	e0bffe17 	ldw	r2,-8(fp)
81142938:	108003c4 	addi	r2,r2,15
8114293c:	e0ffff17 	ldw	r3,-4(fp)
81142940:	18c003c3 	ldbu	r3,15(r3)
81142944:	18c03fcc 	andi	r3,r3,255
81142948:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
8114294c:	e0bffe17 	ldw	r2,-8(fp)
81142950:	10800404 	addi	r2,r2,16
81142954:	e0ffff17 	ldw	r3,-4(fp)
81142958:	18c0040b 	ldhu	r3,16(r3)
8114295c:	18ffffcc 	andi	r3,r3,65535
81142960:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81142964:	e0bffe17 	ldw	r2,-8(fp)
81142968:	10800484 	addi	r2,r2,18
8114296c:	e0ffff17 	ldw	r3,-4(fp)
81142970:	18c0048b 	ldhu	r3,18(r3)
81142974:	18ffffcc 	andi	r3,r3,65535
81142978:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
8114297c:	e0bffe17 	ldw	r2,-8(fp)
81142980:	10800504 	addi	r2,r2,20
81142984:	0007883a 	mov	r3,zero
81142988:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
8114298c:	e0bffe17 	ldw	r2,-8(fp)
81142990:	10800604 	addi	r2,r2,24
81142994:	0007883a 	mov	r3,zero
81142998:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
8114299c:	e0bffe17 	ldw	r2,-8(fp)
811429a0:	10800704 	addi	r2,r2,28
811429a4:	e0ffff17 	ldw	r3,-4(fp)
811429a8:	18c00717 	ldw	r3,28(r3)
811429ac:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
811429b0:	0005883a 	mov	r2,zero
}
811429b4:	e037883a 	mov	sp,fp
811429b8:	df000017 	ldw	fp,0(sp)
811429bc:	dec00104 	addi	sp,sp,4
811429c0:	f800283a 	ret

811429c4 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
811429c4:	defff804 	addi	sp,sp,-32
811429c8:	de00012e 	bgeu	sp,et,811429d0 <alt_msgdma_irq+0xc>
811429cc:	003b68fa 	trap	3
811429d0:	dfc00715 	stw	ra,28(sp)
811429d4:	df000615 	stw	fp,24(sp)
811429d8:	df000604 	addi	fp,sp,24
811429dc:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
811429e0:	e0bfff17 	ldw	r2,-4(fp)
811429e4:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
811429e8:	e0bffa17 	ldw	r2,-24(fp)
811429ec:	10801783 	ldbu	r2,94(r2)
811429f0:	10803fcc 	andi	r2,r2,255
811429f4:	10001126 	beq	r2,zero,81142a3c <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
811429f8:	e0bffa17 	ldw	r2,-24(fp)
811429fc:	10800617 	ldw	r2,24(r2)
81142a00:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81142a04:	1007883a 	mov	r3,r2
81142a08:	00bffdc4 	movi	r2,-9
81142a0c:	1884703a 	and	r2,r3,r2
81142a10:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81142a14:	e0bffa17 	ldw	r2,-24(fp)
81142a18:	10800617 	ldw	r2,24(r2)
81142a1c:	e0fffb17 	ldw	r3,-20(fp)
81142a20:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81142a24:	e0bffa17 	ldw	r2,-24(fp)
81142a28:	10800617 	ldw	r2,24(r2)
81142a2c:	10800404 	addi	r2,r2,16
81142a30:	00c00044 	movi	r3,1
81142a34:	10c00035 	stwio	r3,0(r2)
81142a38:	00001106 	br	81142a80 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81142a3c:	e0bffa17 	ldw	r2,-24(fp)
81142a40:	10800317 	ldw	r2,12(r2)
81142a44:	10800104 	addi	r2,r2,4
81142a48:	10800037 	ldwio	r2,0(r2)
81142a4c:	1007883a 	mov	r3,r2
81142a50:	00bffbc4 	movi	r2,-17
81142a54:	1884703a 	and	r2,r3,r2
81142a58:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81142a5c:	e0bffa17 	ldw	r2,-24(fp)
81142a60:	10800317 	ldw	r2,12(r2)
81142a64:	10800104 	addi	r2,r2,4
81142a68:	e0fffb17 	ldw	r3,-20(fp)
81142a6c:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81142a70:	e0bffa17 	ldw	r2,-24(fp)
81142a74:	10800317 	ldw	r2,12(r2)
81142a78:	00c08004 	movi	r3,512
81142a7c:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
81142a80:	e0bffa17 	ldw	r2,-24(fp)
81142a84:	10800b17 	ldw	r2,44(r2)
81142a88:	10001226 	beq	r2,zero,81142ad4 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142a8c:	0005303a 	rdctl	r2,status
81142a90:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142a94:	e0fffd17 	ldw	r3,-12(fp)
81142a98:	00bfff84 	movi	r2,-2
81142a9c:	1884703a 	and	r2,r3,r2
81142aa0:	1001703a 	wrctl	status,r2
  
  return context;
81142aa4:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
81142aa8:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
81142aac:	e0bffa17 	ldw	r2,-24(fp)
81142ab0:	10800b17 	ldw	r2,44(r2)
81142ab4:	e0fffa17 	ldw	r3,-24(fp)
81142ab8:	18c00c17 	ldw	r3,48(r3)
81142abc:	1809883a 	mov	r4,r3
81142ac0:	103ee83a 	callr	r2
81142ac4:	e0bffc17 	ldw	r2,-16(fp)
81142ac8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142acc:	e0bffe17 	ldw	r2,-8(fp)
81142ad0:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81142ad4:	e0bffa17 	ldw	r2,-24(fp)
81142ad8:	10801783 	ldbu	r2,94(r2)
81142adc:	10803fcc 	andi	r2,r2,255
81142ae0:	10000a26 	beq	r2,zero,81142b0c <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81142ae4:	e0bffa17 	ldw	r2,-24(fp)
81142ae8:	10800617 	ldw	r2,24(r2)
81142aec:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81142af0:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81142af4:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81142af8:	e0bffa17 	ldw	r2,-24(fp)
81142afc:	10800617 	ldw	r2,24(r2)
81142b00:	e0fffb17 	ldw	r3,-20(fp)
81142b04:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81142b08:	00000c06 	br	81142b3c <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81142b0c:	e0bffa17 	ldw	r2,-24(fp)
81142b10:	10800317 	ldw	r2,12(r2)
81142b14:	10800104 	addi	r2,r2,4
81142b18:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81142b1c:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81142b20:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81142b24:	e0bffa17 	ldw	r2,-24(fp)
81142b28:	10800317 	ldw	r2,12(r2)
81142b2c:	10800104 	addi	r2,r2,4
81142b30:	e0fffb17 	ldw	r3,-20(fp)
81142b34:	10c00035 	stwio	r3,0(r2)
    }

    return;
81142b38:	0001883a 	nop
}
81142b3c:	e037883a 	mov	sp,fp
81142b40:	dfc00117 	ldw	ra,4(sp)
81142b44:	df000017 	ldw	fp,0(sp)
81142b48:	dec00204 	addi	sp,sp,8
81142b4c:	f800283a 	ret

81142b50 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81142b50:	defffb04 	addi	sp,sp,-20
81142b54:	de00012e 	bgeu	sp,et,81142b5c <alt_msgdma_construct_standard_descriptor+0xc>
81142b58:	003b68fa 	trap	3
81142b5c:	df000415 	stw	fp,16(sp)
81142b60:	df000404 	addi	fp,sp,16
81142b64:	e13ffc15 	stw	r4,-16(fp)
81142b68:	e17ffd15 	stw	r5,-12(fp)
81142b6c:	e1bffe15 	stw	r6,-8(fp)
81142b70:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81142b74:	e0bffc17 	ldw	r2,-16(fp)
81142b78:	10c01217 	ldw	r3,72(r2)
81142b7c:	e0800117 	ldw	r2,4(fp)
81142b80:	18800436 	bltu	r3,r2,81142b94 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81142b84:	e0bffc17 	ldw	r2,-16(fp)
81142b88:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81142b8c:	10803fcc 	andi	r2,r2,255
81142b90:	10000226 	beq	r2,zero,81142b9c <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81142b94:	00bffa84 	movi	r2,-22
81142b98:	00000e06 	br	81142bd4 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
81142b9c:	e0bffd17 	ldw	r2,-12(fp)
81142ba0:	e0fffe17 	ldw	r3,-8(fp)
81142ba4:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81142ba8:	e0bffd17 	ldw	r2,-12(fp)
81142bac:	e0ffff17 	ldw	r3,-4(fp)
81142bb0:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81142bb4:	e0bffd17 	ldw	r2,-12(fp)
81142bb8:	e0c00117 	ldw	r3,4(fp)
81142bbc:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81142bc0:	e0800217 	ldw	r2,8(fp)
81142bc4:	10e00034 	orhi	r3,r2,32768
81142bc8:	e0bffd17 	ldw	r2,-12(fp)
81142bcc:	10c00315 	stw	r3,12(r2)
    
    return 0;
81142bd0:	0005883a 	mov	r2,zero
}
81142bd4:	e037883a 	mov	sp,fp
81142bd8:	df000017 	ldw	fp,0(sp)
81142bdc:	dec00104 	addi	sp,sp,4
81142be0:	f800283a 	ret

81142be4 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81142be4:	defff604 	addi	sp,sp,-40
81142be8:	de00012e 	bgeu	sp,et,81142bf0 <alt_msgdma_construct_extended_descriptor+0xc>
81142bec:	003b68fa 	trap	3
81142bf0:	df000915 	stw	fp,36(sp)
81142bf4:	df000904 	addi	fp,sp,36
81142bf8:	e13ff715 	stw	r4,-36(fp)
81142bfc:	e17ff815 	stw	r5,-32(fp)
81142c00:	e1bff915 	stw	r6,-28(fp)
81142c04:	e1fffa15 	stw	r7,-24(fp)
81142c08:	e1800317 	ldw	r6,12(fp)
81142c0c:	e1400417 	ldw	r5,16(fp)
81142c10:	e1000517 	ldw	r4,20(fp)
81142c14:	e0c00617 	ldw	r3,24(fp)
81142c18:	e0800717 	ldw	r2,28(fp)
81142c1c:	e1bffb0d 	sth	r6,-20(fp)
81142c20:	e17ffc05 	stb	r5,-16(fp)
81142c24:	e13ffd05 	stb	r4,-12(fp)
81142c28:	e0fffe0d 	sth	r3,-8(fp)
81142c2c:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
81142c30:	e0bff717 	ldw	r2,-36(fp)
81142c34:	10c01217 	ldw	r3,72(r2)
81142c38:	e0800117 	ldw	r2,4(fp)
81142c3c:	18801936 	bltu	r3,r2,81142ca4 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81142c40:	e13ff717 	ldw	r4,-36(fp)
81142c44:	20801317 	ldw	r2,76(r4)
81142c48:	20c01417 	ldw	r3,80(r4)
81142c4c:	e13ffe0b 	ldhu	r4,-8(fp)
81142c50:	213fffcc 	andi	r4,r4,65535
81142c54:	2015883a 	mov	r10,r4
81142c58:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81142c5c:	1ac01136 	bltu	r3,r11,81142ca4 <alt_msgdma_construct_extended_descriptor+0xc0>
81142c60:	58c0011e 	bne	r11,r3,81142c68 <alt_msgdma_construct_extended_descriptor+0x84>
81142c64:	12800f36 	bltu	r2,r10,81142ca4 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81142c68:	e13ff717 	ldw	r4,-36(fp)
81142c6c:	20801317 	ldw	r2,76(r4)
81142c70:	20c01417 	ldw	r3,80(r4)
81142c74:	e13fff0b 	ldhu	r4,-4(fp)
81142c78:	213fffcc 	andi	r4,r4,65535
81142c7c:	2011883a 	mov	r8,r4
81142c80:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81142c84:	1a400736 	bltu	r3,r9,81142ca4 <alt_msgdma_construct_extended_descriptor+0xc0>
81142c88:	48c0011e 	bne	r9,r3,81142c90 <alt_msgdma_construct_extended_descriptor+0xac>
81142c8c:	12000536 	bltu	r2,r8,81142ca4 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81142c90:	e0bff717 	ldw	r2,-36(fp)
81142c94:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81142c98:	10803fcc 	andi	r2,r2,255
81142c9c:	10800060 	cmpeqi	r2,r2,1
81142ca0:	1000021e 	bne	r2,zero,81142cac <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81142ca4:	00bffa84 	movi	r2,-22
81142ca8:	00002106 	br	81142d30 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
81142cac:	e0bff817 	ldw	r2,-32(fp)
81142cb0:	e0fff917 	ldw	r3,-28(fp)
81142cb4:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
81142cb8:	e0bff817 	ldw	r2,-32(fp)
81142cbc:	e0fffa17 	ldw	r3,-24(fp)
81142cc0:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81142cc4:	e0bff817 	ldw	r2,-32(fp)
81142cc8:	e0c00117 	ldw	r3,4(fp)
81142ccc:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81142cd0:	e0bff817 	ldw	r2,-32(fp)
81142cd4:	e0fffb0b 	ldhu	r3,-20(fp)
81142cd8:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
81142cdc:	e0bff817 	ldw	r2,-32(fp)
81142ce0:	e0fffc03 	ldbu	r3,-16(fp)
81142ce4:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81142ce8:	e0bff817 	ldw	r2,-32(fp)
81142cec:	e0fffd03 	ldbu	r3,-12(fp)
81142cf0:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81142cf4:	e0bff817 	ldw	r2,-32(fp)
81142cf8:	e0fffe0b 	ldhu	r3,-8(fp)
81142cfc:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
81142d00:	e0bff817 	ldw	r2,-32(fp)
81142d04:	e0ffff0b 	ldhu	r3,-4(fp)
81142d08:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81142d0c:	e0bff817 	ldw	r2,-32(fp)
81142d10:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81142d14:	e0bff817 	ldw	r2,-32(fp)
81142d18:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81142d1c:	e0800217 	ldw	r2,8(fp)
81142d20:	10e00034 	orhi	r3,r2,32768
81142d24:	e0bff817 	ldw	r2,-32(fp)
81142d28:	10c00715 	stw	r3,28(r2)

  return 0 ;
81142d2c:	0005883a 	mov	r2,zero

}
81142d30:	e037883a 	mov	sp,fp
81142d34:	df000017 	ldw	fp,0(sp)
81142d38:	dec00104 	addi	sp,sp,4
81142d3c:	f800283a 	ret

81142d40 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81142d40:	deffee04 	addi	sp,sp,-72
81142d44:	de00012e 	bgeu	sp,et,81142d4c <alt_msgdma_descriptor_async_transfer+0xc>
81142d48:	003b68fa 	trap	3
81142d4c:	dfc01115 	stw	ra,68(sp)
81142d50:	df001015 	stw	fp,64(sp)
81142d54:	df001004 	addi	fp,sp,64
81142d58:	e13ffd15 	stw	r4,-12(fp)
81142d5c:	e17ffe15 	stw	r5,-8(fp)
81142d60:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81142d64:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
81142d68:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
81142d6c:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81142d70:	e0bffd17 	ldw	r2,-12(fp)
81142d74:	10800317 	ldw	r2,12(r2)
81142d78:	10800204 	addi	r2,r2,8
81142d7c:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81142d80:	10bfffcc 	andi	r2,r2,65535
81142d84:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81142d88:	e0bffd17 	ldw	r2,-12(fp)
81142d8c:	10800317 	ldw	r2,12(r2)
81142d90:	10800204 	addi	r2,r2,8
81142d94:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81142d98:	1004d43a 	srli	r2,r2,16
81142d9c:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81142da0:	e0bffd17 	ldw	r2,-12(fp)
81142da4:	10800917 	ldw	r2,36(r2)
81142da8:	e0fff417 	ldw	r3,-48(fp)
81142dac:	1880042e 	bgeu	r3,r2,81142dc0 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81142db0:	e0bffd17 	ldw	r2,-12(fp)
81142db4:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81142db8:	e0fff317 	ldw	r3,-52(fp)
81142dbc:	18800236 	bltu	r3,r2,81142dc8 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
81142dc0:	00bff904 	movi	r2,-28
81142dc4:	0000a906 	br	8114306c <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81142dc8:	e0bffd17 	ldw	r2,-12(fp)
81142dcc:	10801817 	ldw	r2,96(r2)
81142dd0:	e0bff615 	stw	r2,-40(fp)
81142dd4:	e03ffc0d 	sth	zero,-16(fp)
81142dd8:	e0bffc0b 	ldhu	r2,-16(fp)
81142ddc:	e0fffc84 	addi	r3,fp,-14
81142de0:	180d883a 	mov	r6,r3
81142de4:	100b883a 	mov	r5,r2
81142de8:	e13ff617 	ldw	r4,-40(fp)
81142dec:	113946c0 	call	8113946c <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81142df0:	00800804 	movi	r2,32
81142df4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142df8:	0005303a 	rdctl	r2,status
81142dfc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142e00:	e0fff717 	ldw	r3,-36(fp)
81142e04:	00bfff84 	movi	r2,-2
81142e08:	1884703a 	and	r2,r3,r2
81142e0c:	1001703a 	wrctl	status,r2
  
  return context;
81142e10:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81142e14:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81142e18:	e0bffd17 	ldw	r2,-12(fp)
81142e1c:	10800317 	ldw	r2,12(r2)
81142e20:	10800104 	addi	r2,r2,4
81142e24:	e0fff117 	ldw	r3,-60(fp)
81142e28:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
81142e2c:	e0bffd17 	ldw	r2,-12(fp)
81142e30:	10800317 	ldw	r2,12(r2)
81142e34:	e0fffd17 	ldw	r3,-12(fp)
81142e38:	18c00317 	ldw	r3,12(r3)
81142e3c:	18c00037 	ldwio	r3,0(r3)
81142e40:	10c00035 	stwio	r3,0(r2)
81142e44:	e0bff217 	ldw	r2,-56(fp)
81142e48:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142e4c:	e0bffb17 	ldw	r2,-20(fp)
81142e50:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81142e54:	e0bffe17 	ldw	r2,-8(fp)
81142e58:	10001e26 	beq	r2,zero,81142ed4 <alt_msgdma_descriptor_async_transfer+0x194>
81142e5c:	e0bfff17 	ldw	r2,-4(fp)
81142e60:	10001c1e 	bne	r2,zero,81142ed4 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81142e64:	00001106 	br	81142eac <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81142e68:	01000044 	movi	r4,1
81142e6c:	1130bf40 	call	81130bf4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81142e70:	e0bff00b 	ldhu	r2,-64(fp)
81142e74:	1084e230 	cmpltui	r2,r2,5000
81142e78:	1000091e 	bne	r2,zero,81142ea0 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
81142e7c:	01204574 	movhi	r4,33045
81142e80:	212b5304 	addi	r4,r4,-21172
81142e84:	11451940 	call	81145194 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81142e88:	e0bffd17 	ldw	r2,-12(fp)
81142e8c:	10801817 	ldw	r2,96(r2)
81142e90:	1009883a 	mov	r4,r2
81142e94:	11397f40 	call	811397f4 <OSSemPost>
				
                return -ETIME;
81142e98:	00bff084 	movi	r2,-62
81142e9c:	00007306 	br	8114306c <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81142ea0:	e0bff00b 	ldhu	r2,-64(fp)
81142ea4:	10800044 	addi	r2,r2,1
81142ea8:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81142eac:	e0bffd17 	ldw	r2,-12(fp)
81142eb0:	10c00317 	ldw	r3,12(r2)
81142eb4:	e0bffd17 	ldw	r2,-12(fp)
81142eb8:	10800417 	ldw	r2,16(r2)
81142ebc:	e1bffe17 	ldw	r6,-8(fp)
81142ec0:	100b883a 	mov	r5,r2
81142ec4:	1809883a 	mov	r4,r3
81142ec8:	11427f40 	call	811427f4 <alt_msgdma_write_standard_descriptor>
81142ecc:	103fe61e 	bne	r2,zero,81142e68 <__reset+0xfb122e68>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81142ed0:	00002706 	br	81142f70 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81142ed4:	e0bffe17 	ldw	r2,-8(fp)
81142ed8:	10001f1e 	bne	r2,zero,81142f58 <alt_msgdma_descriptor_async_transfer+0x218>
81142edc:	e0bfff17 	ldw	r2,-4(fp)
81142ee0:	10001d26 	beq	r2,zero,81142f58 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
81142ee4:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81142ee8:	00001106 	br	81142f30 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81142eec:	01000044 	movi	r4,1
81142ef0:	1130bf40 	call	81130bf4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81142ef4:	e0bff00b 	ldhu	r2,-64(fp)
81142ef8:	1084e230 	cmpltui	r2,r2,5000
81142efc:	1000091e 	bne	r2,zero,81142f24 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
81142f00:	01204574 	movhi	r4,33045
81142f04:	212b6904 	addi	r4,r4,-21084
81142f08:	11451940 	call	81145194 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81142f0c:	e0bffd17 	ldw	r2,-12(fp)
81142f10:	10801817 	ldw	r2,96(r2)
81142f14:	1009883a 	mov	r4,r2
81142f18:	11397f40 	call	811397f4 <OSSemPost>
				
                return -ETIME;
81142f1c:	00bff084 	movi	r2,-62
81142f20:	00005206 	br	8114306c <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81142f24:	e0bff00b 	ldhu	r2,-64(fp)
81142f28:	10800044 	addi	r2,r2,1
81142f2c:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81142f30:	e0bffd17 	ldw	r2,-12(fp)
81142f34:	10c00317 	ldw	r3,12(r2)
81142f38:	e0bffd17 	ldw	r2,-12(fp)
81142f3c:	10800417 	ldw	r2,16(r2)
81142f40:	e1bfff17 	ldw	r6,-4(fp)
81142f44:	100b883a 	mov	r5,r2
81142f48:	1809883a 	mov	r4,r3
81142f4c:	11428900 	call	81142890 <alt_msgdma_write_extended_descriptor>
81142f50:	103fe61e 	bne	r2,zero,81142eec <__reset+0xfb122eec>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81142f54:	00000606 	br	81142f70 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81142f58:	e0bffd17 	ldw	r2,-12(fp)
81142f5c:	10801817 	ldw	r2,96(r2)
81142f60:	1009883a 	mov	r4,r2
81142f64:	11397f40 	call	811397f4 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81142f68:	00bfffc4 	movi	r2,-1
81142f6c:	00003f06 	br	8114306c <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
81142f70:	e0bffd17 	ldw	r2,-12(fp)
81142f74:	10800b17 	ldw	r2,44(r2)
81142f78:	10001c26 	beq	r2,zero,81142fec <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
81142f7c:	e0bffd17 	ldw	r2,-12(fp)
81142f80:	10c00d17 	ldw	r3,52(r2)
81142f84:	e0bff117 	ldw	r2,-60(fp)
81142f88:	1884b03a 	or	r2,r3,r2
81142f8c:	10800514 	ori	r2,r2,20
81142f90:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81142f94:	e0fff117 	ldw	r3,-60(fp)
81142f98:	00bff7c4 	movi	r2,-33
81142f9c:	1884703a 	and	r2,r3,r2
81142fa0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142fa4:	0005303a 	rdctl	r2,status
81142fa8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142fac:	e0fff917 	ldw	r3,-28(fp)
81142fb0:	00bfff84 	movi	r2,-2
81142fb4:	1884703a 	and	r2,r3,r2
81142fb8:	1001703a 	wrctl	status,r2
  
  return context;
81142fbc:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
81142fc0:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81142fc4:	e0bffd17 	ldw	r2,-12(fp)
81142fc8:	10800317 	ldw	r2,12(r2)
81142fcc:	10800104 	addi	r2,r2,4
81142fd0:	e0fff117 	ldw	r3,-60(fp)
81142fd4:	10c00035 	stwio	r3,0(r2)
81142fd8:	e0bff217 	ldw	r2,-56(fp)
81142fdc:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142fe0:	e0bff517 	ldw	r2,-44(fp)
81142fe4:	1001703a 	wrctl	status,r2
81142fe8:	00001b06 	br	81143058 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
81142fec:	e0bffd17 	ldw	r2,-12(fp)
81142ff0:	10c00d17 	ldw	r3,52(r2)
81142ff4:	e0bff117 	ldw	r2,-60(fp)
81142ff8:	1884b03a 	or	r2,r3,r2
81142ffc:	10800114 	ori	r2,r2,4
81143000:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81143004:	e0fff117 	ldw	r3,-60(fp)
81143008:	00bff3c4 	movi	r2,-49
8114300c:	1884703a 	and	r2,r3,r2
81143010:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143014:	0005303a 	rdctl	r2,status
81143018:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114301c:	e0fffa17 	ldw	r3,-24(fp)
81143020:	00bfff84 	movi	r2,-2
81143024:	1884703a 	and	r2,r3,r2
81143028:	1001703a 	wrctl	status,r2
  
  return context;
8114302c:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81143030:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81143034:	e0bffd17 	ldw	r2,-12(fp)
81143038:	10800317 	ldw	r2,12(r2)
8114303c:	10800104 	addi	r2,r2,4
81143040:	e0fff117 	ldw	r3,-60(fp)
81143044:	10c00035 	stwio	r3,0(r2)
81143048:	e0bff217 	ldw	r2,-56(fp)
8114304c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143050:	e0bff817 	ldw	r2,-32(fp)
81143054:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81143058:	e0bffd17 	ldw	r2,-12(fp)
8114305c:	10801817 	ldw	r2,96(r2)
81143060:	1009883a 	mov	r4,r2
81143064:	11397f40 	call	811397f4 <OSSemPost>
    
    return 0;
81143068:	0005883a 	mov	r2,zero
}
8114306c:	e037883a 	mov	sp,fp
81143070:	dfc00117 	ldw	ra,4(sp)
81143074:	df000017 	ldw	fp,0(sp)
81143078:	dec00204 	addi	sp,sp,8
8114307c:	f800283a 	ret

81143080 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81143080:	deffee04 	addi	sp,sp,-72
81143084:	de00012e 	bgeu	sp,et,8114308c <alt_msgdma_descriptor_sync_transfer+0xc>
81143088:	003b68fa 	trap	3
8114308c:	dfc01115 	stw	ra,68(sp)
81143090:	df001015 	stw	fp,64(sp)
81143094:	df001004 	addi	fp,sp,64
81143098:	e13ffd15 	stw	r4,-12(fp)
8114309c:	e17ffe15 	stw	r5,-8(fp)
811430a0:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
811430a4:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
811430a8:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
811430ac:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
811430b0:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811430b4:	e0bffd17 	ldw	r2,-12(fp)
811430b8:	10800317 	ldw	r2,12(r2)
811430bc:	10800204 	addi	r2,r2,8
811430c0:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811430c4:	10bfffcc 	andi	r2,r2,65535
811430c8:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811430cc:	e0bffd17 	ldw	r2,-12(fp)
811430d0:	10800317 	ldw	r2,12(r2)
811430d4:	10800204 	addi	r2,r2,8
811430d8:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811430dc:	1004d43a 	srli	r2,r2,16
811430e0:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
811430e4:	00807804 	movi	r2,480
811430e8:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811430ec:	00001906 	br	81143154 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
811430f0:	01000044 	movi	r4,1
811430f4:	1130bf40 	call	81130bf4 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811430f8:	e0bff10b 	ldhu	r2,-60(fp)
811430fc:	1084e230 	cmpltui	r2,r2,5000
81143100:	1000051e 	bne	r2,zero,81143118 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81143104:	01204574 	movhi	r4,33045
81143108:	212b7f04 	addi	r4,r4,-20996
8114310c:	11451940 	call	81145194 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
81143110:	00bff084 	movi	r2,-62
81143114:	0000d706 	br	81143474 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81143118:	e0bff10b 	ldhu	r2,-60(fp)
8114311c:	10800044 	addi	r2,r2,1
81143120:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81143124:	e0bffd17 	ldw	r2,-12(fp)
81143128:	10800317 	ldw	r2,12(r2)
8114312c:	10800204 	addi	r2,r2,8
81143130:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81143134:	10bfffcc 	andi	r2,r2,65535
81143138:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114313c:	e0bffd17 	ldw	r2,-12(fp)
81143140:	10800317 	ldw	r2,12(r2)
81143144:	10800204 	addi	r2,r2,8
81143148:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
8114314c:	1004d43a 	srli	r2,r2,16
81143150:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81143154:	e0bffd17 	ldw	r2,-12(fp)
81143158:	10800917 	ldw	r2,36(r2)
8114315c:	e0fff317 	ldw	r3,-52(fp)
81143160:	18bfe32e 	bgeu	r3,r2,811430f0 <__reset+0xfb1230f0>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81143164:	e0bffd17 	ldw	r2,-12(fp)
81143168:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114316c:	e0fff217 	ldw	r3,-56(fp)
81143170:	18bfdf2e 	bgeu	r3,r2,811430f0 <__reset+0xfb1230f0>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
81143174:	e0bffd17 	ldw	r2,-12(fp)
81143178:	10801817 	ldw	r2,96(r2)
8114317c:	e0bff815 	stw	r2,-32(fp)
81143180:	e03ffc0d 	sth	zero,-16(fp)
81143184:	e0bffc0b 	ldhu	r2,-16(fp)
81143188:	e0fffc84 	addi	r3,fp,-14
8114318c:	180d883a 	mov	r6,r3
81143190:	100b883a 	mov	r5,r2
81143194:	e13ff817 	ldw	r4,-32(fp)
81143198:	113946c0 	call	8113946c <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114319c:	0005303a 	rdctl	r2,status
811431a0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811431a4:	e0fffb17 	ldw	r3,-20(fp)
811431a8:	00bfff84 	movi	r2,-2
811431ac:	1884703a 	and	r2,r3,r2
811431b0:	1001703a 	wrctl	status,r2
  
  return context;
811431b4:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
811431b8:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811431bc:	e0bffd17 	ldw	r2,-12(fp)
811431c0:	10800317 	ldw	r2,12(r2)
811431c4:	10800104 	addi	r2,r2,4
811431c8:	00c00804 	movi	r3,32
811431cc:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
811431d0:	e0bffd17 	ldw	r2,-12(fp)
811431d4:	10800317 	ldw	r2,12(r2)
811431d8:	e0fffd17 	ldw	r3,-12(fp)
811431dc:	18c00317 	ldw	r3,12(r3)
811431e0:	18c00037 	ldwio	r3,0(r3)
811431e4:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
811431e8:	e0bffe17 	ldw	r2,-8(fp)
811431ec:	10001f26 	beq	r2,zero,8114326c <alt_msgdma_descriptor_sync_transfer+0x1ec>
811431f0:	e0bfff17 	ldw	r2,-4(fp)
811431f4:	10001d1e 	bne	r2,zero,8114326c <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
811431f8:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811431fc:	00001106 	br	81143244 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81143200:	01000044 	movi	r4,1
81143204:	1130bf40 	call	81130bf4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81143208:	e0bff10b 	ldhu	r2,-60(fp)
8114320c:	1084e230 	cmpltui	r2,r2,5000
81143210:	1000091e 	bne	r2,zero,81143238 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81143214:	01204574 	movhi	r4,33045
81143218:	212b9304 	addi	r4,r4,-20916
8114321c:	11451940 	call	81145194 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81143220:	e0bffd17 	ldw	r2,-12(fp)
81143224:	10801817 	ldw	r2,96(r2)
81143228:	1009883a 	mov	r4,r2
8114322c:	11397f40 	call	811397f4 <OSSemPost>
				
                return -ETIME;
81143230:	00bff084 	movi	r2,-62
81143234:	00008f06 	br	81143474 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81143238:	e0bff10b 	ldhu	r2,-60(fp)
8114323c:	10800044 	addi	r2,r2,1
81143240:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81143244:	e0bffd17 	ldw	r2,-12(fp)
81143248:	10c00317 	ldw	r3,12(r2)
8114324c:	e0bffd17 	ldw	r2,-12(fp)
81143250:	10800417 	ldw	r2,16(r2)
81143254:	e1bffe17 	ldw	r6,-8(fp)
81143258:	100b883a 	mov	r5,r2
8114325c:	1809883a 	mov	r4,r3
81143260:	11427f40 	call	811427f4 <alt_msgdma_write_standard_descriptor>
81143264:	103fe61e 	bne	r2,zero,81143200 <__reset+0xfb123200>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81143268:	00002706 	br	81143308 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114326c:	e0bffe17 	ldw	r2,-8(fp)
81143270:	10001f1e 	bne	r2,zero,811432f0 <alt_msgdma_descriptor_sync_transfer+0x270>
81143274:	e0bfff17 	ldw	r2,-4(fp)
81143278:	10001d26 	beq	r2,zero,811432f0 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
8114327c:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81143280:	00001106 	br	811432c8 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81143284:	01000044 	movi	r4,1
81143288:	1130bf40 	call	81130bf4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114328c:	e0bff10b 	ldhu	r2,-60(fp)
81143290:	1084e230 	cmpltui	r2,r2,5000
81143294:	1000091e 	bne	r2,zero,811432bc <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
81143298:	01204574 	movhi	r4,33045
8114329c:	212ba404 	addi	r4,r4,-20848
811432a0:	11451940 	call	81145194 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811432a4:	e0bffd17 	ldw	r2,-12(fp)
811432a8:	10801817 	ldw	r2,96(r2)
811432ac:	1009883a 	mov	r4,r2
811432b0:	11397f40 	call	811397f4 <OSSemPost>
				
                return -ETIME;
811432b4:	00bff084 	movi	r2,-62
811432b8:	00006e06 	br	81143474 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
811432bc:	e0bff10b 	ldhu	r2,-60(fp)
811432c0:	10800044 	addi	r2,r2,1
811432c4:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811432c8:	e0bffd17 	ldw	r2,-12(fp)
811432cc:	10c00317 	ldw	r3,12(r2)
811432d0:	e0bffd17 	ldw	r2,-12(fp)
811432d4:	10800417 	ldw	r2,16(r2)
811432d8:	e1bfff17 	ldw	r6,-4(fp)
811432dc:	100b883a 	mov	r5,r2
811432e0:	1809883a 	mov	r4,r3
811432e4:	11428900 	call	81142890 <alt_msgdma_write_extended_descriptor>
811432e8:	103fe61e 	bne	r2,zero,81143284 <__reset+0xfb123284>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811432ec:	00000606 	br	81143308 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811432f0:	e0bffd17 	ldw	r2,-12(fp)
811432f4:	10801817 	ldw	r2,96(r2)
811432f8:	1009883a 	mov	r4,r2
811432fc:	11397f40 	call	811397f4 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81143300:	00bfffc4 	movi	r2,-1
81143304:	00005b06 	br	81143474 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81143308:	e0bffd17 	ldw	r2,-12(fp)
8114330c:	10800317 	ldw	r2,12(r2)
81143310:	10800104 	addi	r2,r2,4
81143314:	e0fffd17 	ldw	r3,-12(fp)
81143318:	19000d17 	ldw	r4,52(r3)
8114331c:	00fff2c4 	movi	r3,-53
81143320:	20c6703a 	and	r3,r4,r3
81143324:	18c00114 	ori	r3,r3,4
81143328:	10c00035 	stwio	r3,0(r2)
8114332c:	e0bff517 	ldw	r2,-44(fp)
81143330:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143334:	e0bff717 	ldw	r2,-36(fp)
81143338:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
8114333c:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81143340:	e0bffd17 	ldw	r2,-12(fp)
81143344:	10800317 	ldw	r2,12(r2)
81143348:	10800037 	ldwio	r2,0(r2)
8114334c:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81143350:	00001506 	br	811433a8 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81143354:	01000044 	movi	r4,1
81143358:	1130bf40 	call	81130bf4 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114335c:	e0bff10b 	ldhu	r2,-60(fp)
81143360:	1084e230 	cmpltui	r2,r2,5000
81143364:	1000091e 	bne	r2,zero,8114338c <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81143368:	01204574 	movhi	r4,33045
8114336c:	212bb504 	addi	r4,r4,-20780
81143370:	11451940 	call	81145194 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81143374:	e0bffd17 	ldw	r2,-12(fp)
81143378:	10801817 	ldw	r2,96(r2)
8114337c:	1009883a 	mov	r4,r2
81143380:	11397f40 	call	811397f4 <OSSemPost>
			
            return -ETIME;
81143384:	00bff084 	movi	r2,-62
81143388:	00003a06 	br	81143474 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
8114338c:	e0bff10b 	ldhu	r2,-60(fp)
81143390:	10800044 	addi	r2,r2,1
81143394:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81143398:	e0bffd17 	ldw	r2,-12(fp)
8114339c:	10800317 	ldw	r2,12(r2)
811433a0:	10800037 	ldwio	r2,0(r2)
811433a4:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
811433a8:	e0fff017 	ldw	r3,-64(fp)
811433ac:	e0bff617 	ldw	r2,-40(fp)
811433b0:	1884703a 	and	r2,r3,r2
811433b4:	1000031e 	bne	r2,zero,811433c4 <alt_msgdma_descriptor_sync_transfer+0x344>
811433b8:	e0bff017 	ldw	r2,-64(fp)
811433bc:	1080004c 	andi	r2,r2,1
811433c0:	103fe41e 	bne	r2,zero,81143354 <__reset+0xfb123354>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
811433c4:	e0fff017 	ldw	r3,-64(fp)
811433c8:	e0bff617 	ldw	r2,-40(fp)
811433cc:	1884703a 	and	r2,r3,r2
811433d0:	10000626 	beq	r2,zero,811433ec <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811433d4:	e0bffd17 	ldw	r2,-12(fp)
811433d8:	10801817 	ldw	r2,96(r2)
811433dc:	1009883a 	mov	r4,r2
811433e0:	11397f40 	call	811397f4 <OSSemPost>
		
        return error;
811433e4:	e0bff617 	ldw	r2,-40(fp)
811433e8:	00002206 	br	81143474 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
811433ec:	e0bffd17 	ldw	r2,-12(fp)
811433f0:	10800317 	ldw	r2,12(r2)
811433f4:	10800104 	addi	r2,r2,4
811433f8:	10800037 	ldwio	r2,0(r2)
811433fc:	10800814 	ori	r2,r2,32
81143400:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143404:	0005303a 	rdctl	r2,status
81143408:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114340c:	e0fffa17 	ldw	r3,-24(fp)
81143410:	00bfff84 	movi	r2,-2
81143414:	1884703a 	and	r2,r3,r2
81143418:	1001703a 	wrctl	status,r2
  
  return context;
8114341c:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81143420:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81143424:	e0bffd17 	ldw	r2,-12(fp)
81143428:	10800317 	ldw	r2,12(r2)
8114342c:	10800104 	addi	r2,r2,4
81143430:	e0fff417 	ldw	r3,-48(fp)
81143434:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81143438:	e0bffd17 	ldw	r2,-12(fp)
8114343c:	10800317 	ldw	r2,12(r2)
81143440:	e0fffd17 	ldw	r3,-12(fp)
81143444:	18c00317 	ldw	r3,12(r3)
81143448:	18c00037 	ldwio	r3,0(r3)
8114344c:	10c00035 	stwio	r3,0(r2)
81143450:	e0bff517 	ldw	r2,-44(fp)
81143454:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143458:	e0bff917 	ldw	r2,-28(fp)
8114345c:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81143460:	e0bffd17 	ldw	r2,-12(fp)
81143464:	10801817 	ldw	r2,96(r2)
81143468:	1009883a 	mov	r4,r2
8114346c:	11397f40 	call	811397f4 <OSSemPost>
    
    return 0;
81143470:	0005883a 	mov	r2,zero

}
81143474:	e037883a 	mov	sp,fp
81143478:	dfc00117 	ldw	ra,4(sp)
8114347c:	df000017 	ldw	fp,0(sp)
81143480:	dec00204 	addi	sp,sp,8
81143484:	f800283a 	ret

81143488 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81143488:	defff804 	addi	sp,sp,-32
8114348c:	de00012e 	bgeu	sp,et,81143494 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81143490:	003b68fa 	trap	3
81143494:	dfc00715 	stw	ra,28(sp)
81143498:	df000615 	stw	fp,24(sp)
8114349c:	df000604 	addi	fp,sp,24
811434a0:	e13ffc15 	stw	r4,-16(fp)
811434a4:	e17ffd15 	stw	r5,-12(fp)
811434a8:	e1bffe15 	stw	r6,-8(fp)
811434ac:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
811434b0:	e0800217 	ldw	r2,8(fp)
811434b4:	d8800115 	stw	r2,4(sp)
811434b8:	e0bfff17 	ldw	r2,-4(fp)
811434bc:	d8800015 	stw	r2,0(sp)
811434c0:	e1fffe17 	ldw	r7,-8(fp)
811434c4:	000d883a 	mov	r6,zero
811434c8:	e17ffd17 	ldw	r5,-12(fp)
811434cc:	e13ffc17 	ldw	r4,-16(fp)
811434d0:	1142b500 	call	81142b50 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
811434d4:	e037883a 	mov	sp,fp
811434d8:	dfc00117 	ldw	ra,4(sp)
811434dc:	df000017 	ldw	fp,0(sp)
811434e0:	dec00204 	addi	sp,sp,8
811434e4:	f800283a 	ret

811434e8 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
811434e8:	defff804 	addi	sp,sp,-32
811434ec:	de00012e 	bgeu	sp,et,811434f4 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
811434f0:	003b68fa 	trap	3
811434f4:	dfc00715 	stw	ra,28(sp)
811434f8:	df000615 	stw	fp,24(sp)
811434fc:	df000604 	addi	fp,sp,24
81143500:	e13ffc15 	stw	r4,-16(fp)
81143504:	e17ffd15 	stw	r5,-12(fp)
81143508:	e1bffe15 	stw	r6,-8(fp)
8114350c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81143510:	e0800217 	ldw	r2,8(fp)
81143514:	d8800115 	stw	r2,4(sp)
81143518:	e0bfff17 	ldw	r2,-4(fp)
8114351c:	d8800015 	stw	r2,0(sp)
81143520:	000f883a 	mov	r7,zero
81143524:	e1bffe17 	ldw	r6,-8(fp)
81143528:	e17ffd17 	ldw	r5,-12(fp)
8114352c:	e13ffc17 	ldw	r4,-16(fp)
81143530:	1142b500 	call	81142b50 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81143534:	e037883a 	mov	sp,fp
81143538:	dfc00117 	ldw	ra,4(sp)
8114353c:	df000017 	ldw	fp,0(sp)
81143540:	dec00204 	addi	sp,sp,8
81143544:	f800283a 	ret

81143548 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81143548:	defff804 	addi	sp,sp,-32
8114354c:	de00012e 	bgeu	sp,et,81143554 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81143550:	003b68fa 	trap	3
81143554:	dfc00715 	stw	ra,28(sp)
81143558:	df000615 	stw	fp,24(sp)
8114355c:	df000604 	addi	fp,sp,24
81143560:	e13ffc15 	stw	r4,-16(fp)
81143564:	e17ffd15 	stw	r5,-12(fp)
81143568:	e1bffe15 	stw	r6,-8(fp)
8114356c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81143570:	e0800317 	ldw	r2,12(fp)
81143574:	d8800115 	stw	r2,4(sp)
81143578:	e0800217 	ldw	r2,8(fp)
8114357c:	d8800015 	stw	r2,0(sp)
81143580:	e1ffff17 	ldw	r7,-4(fp)
81143584:	e1bffe17 	ldw	r6,-8(fp)
81143588:	e17ffd17 	ldw	r5,-12(fp)
8114358c:	e13ffc17 	ldw	r4,-16(fp)
81143590:	1142b500 	call	81142b50 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81143594:	e037883a 	mov	sp,fp
81143598:	dfc00117 	ldw	ra,4(sp)
8114359c:	df000017 	ldw	fp,0(sp)
811435a0:	dec00204 	addi	sp,sp,8
811435a4:	f800283a 	ret

811435a8 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
811435a8:	defff004 	addi	sp,sp,-64
811435ac:	de00012e 	bgeu	sp,et,811435b4 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
811435b0:	003b68fa 	trap	3
811435b4:	dfc00f15 	stw	ra,60(sp)
811435b8:	df000e15 	stw	fp,56(sp)
811435bc:	df000e04 	addi	fp,sp,56
811435c0:	e13ff915 	stw	r4,-28(fp)
811435c4:	e17ffa15 	stw	r5,-24(fp)
811435c8:	e1bffb15 	stw	r6,-20(fp)
811435cc:	e1fffc15 	stw	r7,-16(fp)
811435d0:	e1000317 	ldw	r4,12(fp)
811435d4:	e0c00417 	ldw	r3,16(fp)
811435d8:	e0800517 	ldw	r2,20(fp)
811435dc:	e13ffd0d 	sth	r4,-12(fp)
811435e0:	e0fffe05 	stb	r3,-8(fp)
811435e4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
811435e8:	e0bffd0b 	ldhu	r2,-12(fp)
811435ec:	e0fffe03 	ldbu	r3,-8(fp)
811435f0:	e13fff0b 	ldhu	r4,-4(fp)
811435f4:	d9000615 	stw	r4,24(sp)
811435f8:	d8000515 	stw	zero,20(sp)
811435fc:	d8c00415 	stw	r3,16(sp)
81143600:	d8000315 	stw	zero,12(sp)
81143604:	d8800215 	stw	r2,8(sp)
81143608:	e0800217 	ldw	r2,8(fp)
8114360c:	d8800115 	stw	r2,4(sp)
81143610:	e0bffc17 	ldw	r2,-16(fp)
81143614:	d8800015 	stw	r2,0(sp)
81143618:	e1fffb17 	ldw	r7,-20(fp)
8114361c:	000d883a 	mov	r6,zero
81143620:	e17ffa17 	ldw	r5,-24(fp)
81143624:	e13ff917 	ldw	r4,-28(fp)
81143628:	1142be40 	call	81142be4 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
8114362c:	e037883a 	mov	sp,fp
81143630:	dfc00117 	ldw	ra,4(sp)
81143634:	df000017 	ldw	fp,0(sp)
81143638:	dec00204 	addi	sp,sp,8
8114363c:	f800283a 	ret

81143640 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81143640:	defff004 	addi	sp,sp,-64
81143644:	de00012e 	bgeu	sp,et,8114364c <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81143648:	003b68fa 	trap	3
8114364c:	dfc00f15 	stw	ra,60(sp)
81143650:	df000e15 	stw	fp,56(sp)
81143654:	df000e04 	addi	fp,sp,56
81143658:	e13ff915 	stw	r4,-28(fp)
8114365c:	e17ffa15 	stw	r5,-24(fp)
81143660:	e1bffb15 	stw	r6,-20(fp)
81143664:	e1fffc15 	stw	r7,-16(fp)
81143668:	e1000317 	ldw	r4,12(fp)
8114366c:	e0c00417 	ldw	r3,16(fp)
81143670:	e0800517 	ldw	r2,20(fp)
81143674:	e13ffd0d 	sth	r4,-12(fp)
81143678:	e0fffe05 	stb	r3,-8(fp)
8114367c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81143680:	e0bffd0b 	ldhu	r2,-12(fp)
81143684:	e0fffe03 	ldbu	r3,-8(fp)
81143688:	e13fff0b 	ldhu	r4,-4(fp)
8114368c:	d8000615 	stw	zero,24(sp)
81143690:	d9000515 	stw	r4,20(sp)
81143694:	d8000415 	stw	zero,16(sp)
81143698:	d8c00315 	stw	r3,12(sp)
8114369c:	d8800215 	stw	r2,8(sp)
811436a0:	e0800217 	ldw	r2,8(fp)
811436a4:	d8800115 	stw	r2,4(sp)
811436a8:	e0bffc17 	ldw	r2,-16(fp)
811436ac:	d8800015 	stw	r2,0(sp)
811436b0:	000f883a 	mov	r7,zero
811436b4:	e1bffb17 	ldw	r6,-20(fp)
811436b8:	e17ffa17 	ldw	r5,-24(fp)
811436bc:	e13ff917 	ldw	r4,-28(fp)
811436c0:	1142be40 	call	81142be4 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
811436c4:	e037883a 	mov	sp,fp
811436c8:	dfc00117 	ldw	ra,4(sp)
811436cc:	df000017 	ldw	fp,0(sp)
811436d0:	dec00204 	addi	sp,sp,8
811436d4:	f800283a 	ret

811436d8 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
811436d8:	deffee04 	addi	sp,sp,-72
811436dc:	de00012e 	bgeu	sp,et,811436e4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
811436e0:	003b68fa 	trap	3
811436e4:	dfc01115 	stw	ra,68(sp)
811436e8:	df001015 	stw	fp,64(sp)
811436ec:	df001004 	addi	fp,sp,64
811436f0:	e13ff715 	stw	r4,-36(fp)
811436f4:	e17ff815 	stw	r5,-32(fp)
811436f8:	e1bff915 	stw	r6,-28(fp)
811436fc:	e1fffa15 	stw	r7,-24(fp)
81143700:	e1800417 	ldw	r6,16(fp)
81143704:	e1400517 	ldw	r5,20(fp)
81143708:	e1000617 	ldw	r4,24(fp)
8114370c:	e0c00717 	ldw	r3,28(fp)
81143710:	e0800817 	ldw	r2,32(fp)
81143714:	e1bffb0d 	sth	r6,-20(fp)
81143718:	e17ffc05 	stb	r5,-16(fp)
8114371c:	e13ffd05 	stb	r4,-12(fp)
81143720:	e0fffe0d 	sth	r3,-8(fp)
81143724:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81143728:	e0bffb0b 	ldhu	r2,-20(fp)
8114372c:	e0fffc03 	ldbu	r3,-16(fp)
81143730:	e13ffd03 	ldbu	r4,-12(fp)
81143734:	e17ffe0b 	ldhu	r5,-8(fp)
81143738:	e1bfff0b 	ldhu	r6,-4(fp)
8114373c:	d9800615 	stw	r6,24(sp)
81143740:	d9400515 	stw	r5,20(sp)
81143744:	d9000415 	stw	r4,16(sp)
81143748:	d8c00315 	stw	r3,12(sp)
8114374c:	d8800215 	stw	r2,8(sp)
81143750:	e0800317 	ldw	r2,12(fp)
81143754:	d8800115 	stw	r2,4(sp)
81143758:	e0800217 	ldw	r2,8(fp)
8114375c:	d8800015 	stw	r2,0(sp)
81143760:	e1fffa17 	ldw	r7,-24(fp)
81143764:	e1bff917 	ldw	r6,-28(fp)
81143768:	e17ff817 	ldw	r5,-32(fp)
8114376c:	e13ff717 	ldw	r4,-36(fp)
81143770:	1142be40 	call	81142be4 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81143774:	e037883a 	mov	sp,fp
81143778:	dfc00117 	ldw	ra,4(sp)
8114377c:	df000017 	ldw	fp,0(sp)
81143780:	dec00204 	addi	sp,sp,8
81143784:	f800283a 	ret

81143788 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81143788:	defffb04 	addi	sp,sp,-20
8114378c:	de00012e 	bgeu	sp,et,81143794 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81143790:	003b68fa 	trap	3
81143794:	df000415 	stw	fp,16(sp)
81143798:	df000404 	addi	fp,sp,16
8114379c:	e13ffc15 	stw	r4,-16(fp)
811437a0:	e17ffd15 	stw	r5,-12(fp)
811437a4:	e1bffe15 	stw	r6,-8(fp)
811437a8:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
811437ac:	e0bffc17 	ldw	r2,-16(fp)
811437b0:	10c01217 	ldw	r3,72(r2)
811437b4:	e0800117 	ldw	r2,4(fp)
811437b8:	18800436 	bltu	r3,r2,811437cc <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
811437bc:	e0bffc17 	ldw	r2,-16(fp)
811437c0:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
811437c4:	10803fcc 	andi	r2,r2,255
811437c8:	10000226 	beq	r2,zero,811437d4 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811437cc:	00bffa84 	movi	r2,-22
811437d0:	00001406 	br	81143824 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
811437d4:	e0bffd17 	ldw	r2,-12(fp)
811437d8:	e0fffe17 	ldw	r3,-8(fp)
811437dc:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
811437e0:	e0bffd17 	ldw	r2,-12(fp)
811437e4:	e0ffff17 	ldw	r3,-4(fp)
811437e8:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811437ec:	e0bffd17 	ldw	r2,-12(fp)
811437f0:	e0c00117 	ldw	r3,4(fp)
811437f4:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
811437f8:	e0fffd17 	ldw	r3,-12(fp)
811437fc:	e0bffd17 	ldw	r2,-12(fp)
81143800:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81143804:	e0c00217 	ldw	r3,8(fp)
81143808:	00900034 	movhi	r2,16384
8114380c:	10bfffc4 	addi	r2,r2,-1
81143810:	1884703a 	and	r2,r3,r2
81143814:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81143818:	e0bffd17 	ldw	r2,-12(fp)
8114381c:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81143820:	0005883a 	mov	r2,zero
}
81143824:	e037883a 	mov	sp,fp
81143828:	df000017 	ldw	fp,0(sp)
8114382c:	dec00104 	addi	sp,sp,4
81143830:	f800283a 	ret

81143834 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81143834:	defff404 	addi	sp,sp,-48
81143838:	de00012e 	bgeu	sp,et,81143840 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8114383c:	003b68fa 	trap	3
81143840:	df000b15 	stw	fp,44(sp)
81143844:	df000b04 	addi	fp,sp,44
81143848:	e13ff715 	stw	r4,-36(fp)
8114384c:	e17ff815 	stw	r5,-32(fp)
81143850:	e1bff915 	stw	r6,-28(fp)
81143854:	e1fffa15 	stw	r7,-24(fp)
81143858:	e1800517 	ldw	r6,20(fp)
8114385c:	e1400617 	ldw	r5,24(fp)
81143860:	e1000717 	ldw	r4,28(fp)
81143864:	e0c00817 	ldw	r3,32(fp)
81143868:	e0800917 	ldw	r2,36(fp)
8114386c:	e1bffb0d 	sth	r6,-20(fp)
81143870:	e17ffc05 	stb	r5,-16(fp)
81143874:	e13ffd05 	stb	r4,-12(fp)
81143878:	e0fffe0d 	sth	r3,-8(fp)
8114387c:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81143880:	e0bff717 	ldw	r2,-36(fp)
81143884:	10c01217 	ldw	r3,72(r2)
81143888:	e0800317 	ldw	r2,12(fp)
8114388c:	18801936 	bltu	r3,r2,811438f4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81143890:	e13ff717 	ldw	r4,-36(fp)
81143894:	20801317 	ldw	r2,76(r4)
81143898:	20c01417 	ldw	r3,80(r4)
8114389c:	e13ffe0b 	ldhu	r4,-8(fp)
811438a0:	213fffcc 	andi	r4,r4,65535
811438a4:	2015883a 	mov	r10,r4
811438a8:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
811438ac:	1ac01136 	bltu	r3,r11,811438f4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
811438b0:	58c0011e 	bne	r11,r3,811438b8 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
811438b4:	12800f36 	bltu	r2,r10,811438f4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811438b8:	e13ff717 	ldw	r4,-36(fp)
811438bc:	20801317 	ldw	r2,76(r4)
811438c0:	20c01417 	ldw	r3,80(r4)
811438c4:	e13fff0b 	ldhu	r4,-4(fp)
811438c8:	213fffcc 	andi	r4,r4,65535
811438cc:	2011883a 	mov	r8,r4
811438d0:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
811438d4:	1a400736 	bltu	r3,r9,811438f4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
811438d8:	48c0011e 	bne	r9,r3,811438e0 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
811438dc:	12000536 	bltu	r2,r8,811438f4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
811438e0:	e0bff717 	ldw	r2,-36(fp)
811438e4:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811438e8:	10803fcc 	andi	r2,r2,255
811438ec:	10800060 	cmpeqi	r2,r2,1
811438f0:	1000021e 	bne	r2,zero,811438fc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
811438f4:	00bffa84 	movi	r2,-22
811438f8:	00003106 	br	811439c0 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
811438fc:	e0bff817 	ldw	r2,-32(fp)
81143900:	e0fff917 	ldw	r3,-28(fp)
81143904:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81143908:	e0bff817 	ldw	r2,-32(fp)
8114390c:	e0fffa17 	ldw	r3,-24(fp)
81143910:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81143914:	e0bff817 	ldw	r2,-32(fp)
81143918:	e0c00117 	ldw	r3,4(fp)
8114391c:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
81143920:	e0bff817 	ldw	r2,-32(fp)
81143924:	e0c00217 	ldw	r3,8(fp)
81143928:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114392c:	e0bff817 	ldw	r2,-32(fp)
81143930:	e0c00317 	ldw	r3,12(fp)
81143934:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81143938:	e0bff817 	ldw	r2,-32(fp)
8114393c:	e0fffb0b 	ldhu	r3,-20(fp)
81143940:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81143944:	e0bff817 	ldw	r2,-32(fp)
81143948:	e0fffc03 	ldbu	r3,-16(fp)
8114394c:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
81143950:	e0bff817 	ldw	r2,-32(fp)
81143954:	e0fffd03 	ldbu	r3,-12(fp)
81143958:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
8114395c:	e0bff817 	ldw	r2,-32(fp)
81143960:	e0fffe0b 	ldhu	r3,-8(fp)
81143964:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
81143968:	e0bff817 	ldw	r2,-32(fp)
8114396c:	e0ffff0b 	ldhu	r3,-4(fp)
81143970:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
81143974:	e0bff817 	ldw	r2,-32(fp)
81143978:	1019883a 	mov	r12,r2
8114397c:	001b883a 	mov	r13,zero
81143980:	e33ff515 	stw	r12,-44(fp)
81143984:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
81143988:	e0fff517 	ldw	r3,-44(fp)
8114398c:	e0bff817 	ldw	r2,-32(fp)
81143990:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
81143994:	e0fff617 	ldw	r3,-40(fp)
81143998:	e0bff817 	ldw	r2,-32(fp)
8114399c:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811439a0:	e0c00417 	ldw	r3,16(fp)
811439a4:	00900034 	movhi	r2,16384
811439a8:	10bfffc4 	addi	r2,r2,-1
811439ac:	1884703a 	and	r2,r3,r2
811439b0:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
811439b4:	e0bff817 	ldw	r2,-32(fp)
811439b8:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
811439bc:	0005883a 	mov	r2,zero
}
811439c0:	e037883a 	mov	sp,fp
811439c4:	df000017 	ldw	fp,0(sp)
811439c8:	dec00104 	addi	sp,sp,4
811439cc:	f800283a 	ret

811439d0 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
811439d0:	defff804 	addi	sp,sp,-32
811439d4:	de00012e 	bgeu	sp,et,811439dc <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
811439d8:	003b68fa 	trap	3
811439dc:	dfc00715 	stw	ra,28(sp)
811439e0:	df000615 	stw	fp,24(sp)
811439e4:	df000604 	addi	fp,sp,24
811439e8:	e13ffc15 	stw	r4,-16(fp)
811439ec:	e17ffd15 	stw	r5,-12(fp)
811439f0:	e1bffe15 	stw	r6,-8(fp)
811439f4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
811439f8:	e0800317 	ldw	r2,12(fp)
811439fc:	d8800115 	stw	r2,4(sp)
81143a00:	e0800217 	ldw	r2,8(fp)
81143a04:	d8800015 	stw	r2,0(sp)
81143a08:	e1ffff17 	ldw	r7,-4(fp)
81143a0c:	e1bffe17 	ldw	r6,-8(fp)
81143a10:	e17ffd17 	ldw	r5,-12(fp)
81143a14:	e13ffc17 	ldw	r4,-16(fp)
81143a18:	11437880 	call	81143788 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
81143a1c:	e037883a 	mov	sp,fp
81143a20:	dfc00117 	ldw	ra,4(sp)
81143a24:	df000017 	ldw	fp,0(sp)
81143a28:	dec00204 	addi	sp,sp,8
81143a2c:	f800283a 	ret

81143a30 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81143a30:	defff804 	addi	sp,sp,-32
81143a34:	de00012e 	bgeu	sp,et,81143a3c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81143a38:	003b68fa 	trap	3
81143a3c:	dfc00715 	stw	ra,28(sp)
81143a40:	df000615 	stw	fp,24(sp)
81143a44:	df000604 	addi	fp,sp,24
81143a48:	e13ffc15 	stw	r4,-16(fp)
81143a4c:	e17ffd15 	stw	r5,-12(fp)
81143a50:	e1bffe15 	stw	r6,-8(fp)
81143a54:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81143a58:	e0800217 	ldw	r2,8(fp)
81143a5c:	d8800115 	stw	r2,4(sp)
81143a60:	e0bfff17 	ldw	r2,-4(fp)
81143a64:	d8800015 	stw	r2,0(sp)
81143a68:	e1fffe17 	ldw	r7,-8(fp)
81143a6c:	000d883a 	mov	r6,zero
81143a70:	e17ffd17 	ldw	r5,-12(fp)
81143a74:	e13ffc17 	ldw	r4,-16(fp)
81143a78:	11437880 	call	81143788 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
81143a7c:	e037883a 	mov	sp,fp
81143a80:	dfc00117 	ldw	ra,4(sp)
81143a84:	df000017 	ldw	fp,0(sp)
81143a88:	dec00204 	addi	sp,sp,8
81143a8c:	f800283a 	ret

81143a90 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
81143a90:	defff804 	addi	sp,sp,-32
81143a94:	de00012e 	bgeu	sp,et,81143a9c <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
81143a98:	003b68fa 	trap	3
81143a9c:	dfc00715 	stw	ra,28(sp)
81143aa0:	df000615 	stw	fp,24(sp)
81143aa4:	df000604 	addi	fp,sp,24
81143aa8:	e13ffc15 	stw	r4,-16(fp)
81143aac:	e17ffd15 	stw	r5,-12(fp)
81143ab0:	e1bffe15 	stw	r6,-8(fp)
81143ab4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81143ab8:	e0800217 	ldw	r2,8(fp)
81143abc:	d8800115 	stw	r2,4(sp)
81143ac0:	e0bfff17 	ldw	r2,-4(fp)
81143ac4:	d8800015 	stw	r2,0(sp)
81143ac8:	000f883a 	mov	r7,zero
81143acc:	e1bffe17 	ldw	r6,-8(fp)
81143ad0:	e17ffd17 	ldw	r5,-12(fp)
81143ad4:	e13ffc17 	ldw	r4,-16(fp)
81143ad8:	11437880 	call	81143788 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
81143adc:	e037883a 	mov	sp,fp
81143ae0:	dfc00117 	ldw	ra,4(sp)
81143ae4:	df000017 	ldw	fp,0(sp)
81143ae8:	dec00204 	addi	sp,sp,8
81143aec:	f800283a 	ret

81143af0 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
81143af0:	deffee04 	addi	sp,sp,-72
81143af4:	de00012e 	bgeu	sp,et,81143afc <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81143af8:	003b68fa 	trap	3
81143afc:	dfc01115 	stw	ra,68(sp)
81143b00:	df001015 	stw	fp,64(sp)
81143b04:	df001004 	addi	fp,sp,64
81143b08:	e13ff915 	stw	r4,-28(fp)
81143b0c:	e17ffa15 	stw	r5,-24(fp)
81143b10:	e1bffb15 	stw	r6,-20(fp)
81143b14:	e1fffc15 	stw	r7,-16(fp)
81143b18:	e1000417 	ldw	r4,16(fp)
81143b1c:	e0c00517 	ldw	r3,20(fp)
81143b20:	e0800617 	ldw	r2,24(fp)
81143b24:	e13ffd0d 	sth	r4,-12(fp)
81143b28:	e0fffe05 	stb	r3,-8(fp)
81143b2c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
81143b30:	e0bffd0b 	ldhu	r2,-12(fp)
81143b34:	e0fffe03 	ldbu	r3,-8(fp)
81143b38:	e13fff0b 	ldhu	r4,-4(fp)
81143b3c:	d9000815 	stw	r4,32(sp)
81143b40:	d8000715 	stw	zero,28(sp)
81143b44:	d8c00615 	stw	r3,24(sp)
81143b48:	d8000515 	stw	zero,20(sp)
81143b4c:	d8800415 	stw	r2,16(sp)
81143b50:	e0800317 	ldw	r2,12(fp)
81143b54:	d8800315 	stw	r2,12(sp)
81143b58:	e0800217 	ldw	r2,8(fp)
81143b5c:	d8800215 	stw	r2,8(sp)
81143b60:	e0bffc17 	ldw	r2,-16(fp)
81143b64:	d8800115 	stw	r2,4(sp)
81143b68:	e0bffb17 	ldw	r2,-20(fp)
81143b6c:	d8800015 	stw	r2,0(sp)
81143b70:	000f883a 	mov	r7,zero
81143b74:	000d883a 	mov	r6,zero
81143b78:	e17ffa17 	ldw	r5,-24(fp)
81143b7c:	e13ff917 	ldw	r4,-28(fp)
81143b80:	11438340 	call	81143834 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
81143b84:	e037883a 	mov	sp,fp
81143b88:	dfc00117 	ldw	ra,4(sp)
81143b8c:	df000017 	ldw	fp,0(sp)
81143b90:	dec00204 	addi	sp,sp,8
81143b94:	f800283a 	ret

81143b98 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81143b98:	deffee04 	addi	sp,sp,-72
81143b9c:	de00012e 	bgeu	sp,et,81143ba4 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
81143ba0:	003b68fa 	trap	3
81143ba4:	dfc01115 	stw	ra,68(sp)
81143ba8:	df001015 	stw	fp,64(sp)
81143bac:	df001004 	addi	fp,sp,64
81143bb0:	e13ff915 	stw	r4,-28(fp)
81143bb4:	e17ffa15 	stw	r5,-24(fp)
81143bb8:	e1bffb15 	stw	r6,-20(fp)
81143bbc:	e1fffc15 	stw	r7,-16(fp)
81143bc0:	e1000417 	ldw	r4,16(fp)
81143bc4:	e0c00517 	ldw	r3,20(fp)
81143bc8:	e0800617 	ldw	r2,24(fp)
81143bcc:	e13ffd0d 	sth	r4,-12(fp)
81143bd0:	e0fffe05 	stb	r3,-8(fp)
81143bd4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81143bd8:	e0bffd0b 	ldhu	r2,-12(fp)
81143bdc:	e0fffe03 	ldbu	r3,-8(fp)
81143be0:	e13fff0b 	ldhu	r4,-4(fp)
81143be4:	d8000815 	stw	zero,32(sp)
81143be8:	d9000715 	stw	r4,28(sp)
81143bec:	d8000615 	stw	zero,24(sp)
81143bf0:	d8c00515 	stw	r3,20(sp)
81143bf4:	d8800415 	stw	r2,16(sp)
81143bf8:	e0800317 	ldw	r2,12(fp)
81143bfc:	d8800315 	stw	r2,12(sp)
81143c00:	e0800217 	ldw	r2,8(fp)
81143c04:	d8800215 	stw	r2,8(sp)
81143c08:	d8000115 	stw	zero,4(sp)
81143c0c:	d8000015 	stw	zero,0(sp)
81143c10:	e1fffc17 	ldw	r7,-16(fp)
81143c14:	e1bffb17 	ldw	r6,-20(fp)
81143c18:	e17ffa17 	ldw	r5,-24(fp)
81143c1c:	e13ff917 	ldw	r4,-28(fp)
81143c20:	11438340 	call	81143834 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
81143c24:	e037883a 	mov	sp,fp
81143c28:	dfc00117 	ldw	ra,4(sp)
81143c2c:	df000017 	ldw	fp,0(sp)
81143c30:	dec00204 	addi	sp,sp,8
81143c34:	f800283a 	ret

81143c38 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81143c38:	deffec04 	addi	sp,sp,-80
81143c3c:	de00012e 	bgeu	sp,et,81143c44 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
81143c40:	003b68fa 	trap	3
81143c44:	dfc01315 	stw	ra,76(sp)
81143c48:	df001215 	stw	fp,72(sp)
81143c4c:	df001204 	addi	fp,sp,72
81143c50:	e13ff715 	stw	r4,-36(fp)
81143c54:	e17ff815 	stw	r5,-32(fp)
81143c58:	e1bff915 	stw	r6,-28(fp)
81143c5c:	e1fffa15 	stw	r7,-24(fp)
81143c60:	e1800617 	ldw	r6,24(fp)
81143c64:	e1400717 	ldw	r5,28(fp)
81143c68:	e1000817 	ldw	r4,32(fp)
81143c6c:	e0c00917 	ldw	r3,36(fp)
81143c70:	e0800a17 	ldw	r2,40(fp)
81143c74:	e1bffb0d 	sth	r6,-20(fp)
81143c78:	e17ffc05 	stb	r5,-16(fp)
81143c7c:	e13ffd05 	stb	r4,-12(fp)
81143c80:	e0fffe0d 	sth	r3,-8(fp)
81143c84:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81143c88:	e0bffb0b 	ldhu	r2,-20(fp)
81143c8c:	e0fffc03 	ldbu	r3,-16(fp)
81143c90:	e13ffd03 	ldbu	r4,-12(fp)
81143c94:	e17ffe0b 	ldhu	r5,-8(fp)
81143c98:	e1bfff0b 	ldhu	r6,-4(fp)
81143c9c:	d9800815 	stw	r6,32(sp)
81143ca0:	d9400715 	stw	r5,28(sp)
81143ca4:	d9000615 	stw	r4,24(sp)
81143ca8:	d8c00515 	stw	r3,20(sp)
81143cac:	d8800415 	stw	r2,16(sp)
81143cb0:	e0800517 	ldw	r2,20(fp)
81143cb4:	d8800315 	stw	r2,12(sp)
81143cb8:	e0800417 	ldw	r2,16(fp)
81143cbc:	d8800215 	stw	r2,8(sp)
81143cc0:	e0800317 	ldw	r2,12(fp)
81143cc4:	d8800115 	stw	r2,4(sp)
81143cc8:	e0800217 	ldw	r2,8(fp)
81143ccc:	d8800015 	stw	r2,0(sp)
81143cd0:	e1fffa17 	ldw	r7,-24(fp)
81143cd4:	e1bff917 	ldw	r6,-28(fp)
81143cd8:	e17ff817 	ldw	r5,-32(fp)
81143cdc:	e13ff717 	ldw	r4,-36(fp)
81143ce0:	11438340 	call	81143834 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
81143ce4:	e037883a 	mov	sp,fp
81143ce8:	dfc00117 	ldw	ra,4(sp)
81143cec:	df000017 	ldw	fp,0(sp)
81143cf0:	dec00204 	addi	sp,sp,8
81143cf4:	f800283a 	ret

81143cf8 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81143cf8:	defffc04 	addi	sp,sp,-16
81143cfc:	de00012e 	bgeu	sp,et,81143d04 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
81143d00:	003b68fa 	trap	3
81143d04:	df000315 	stw	fp,12(sp)
81143d08:	df000304 	addi	fp,sp,12
81143d0c:	e13ffe15 	stw	r4,-8(fp)
81143d10:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
81143d14:	e0bfff17 	ldw	r2,-4(fp)
81143d18:	1000021e 	bne	r2,zero,81143d24 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81143d1c:	00bffa84 	movi	r2,-22
81143d20:	00002f06 	br	81143de0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
81143d24:	e0bfff17 	ldw	r2,-4(fp)
81143d28:	10c00317 	ldw	r3,12(r2)
81143d2c:	e0bfff17 	ldw	r2,-4(fp)
81143d30:	18800226 	beq	r3,r2,81143d3c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81143d34:	00bffa84 	movi	r2,-22
81143d38:	00002906 	br	81143de0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
81143d3c:	e0bffe17 	ldw	r2,-8(fp)
81143d40:	10800017 	ldw	r2,0(r2)
81143d44:	1000051e 	bne	r2,zero,81143d5c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
81143d48:	e0bffe17 	ldw	r2,-8(fp)
81143d4c:	e0ffff17 	ldw	r3,-4(fp)
81143d50:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
81143d54:	0005883a 	mov	r2,zero
81143d58:	00002106 	br	81143de0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
81143d5c:	e0bffe17 	ldw	r2,-8(fp)
81143d60:	10c00017 	ldw	r3,0(r2)
81143d64:	e0bfff17 	ldw	r2,-4(fp)
81143d68:	1880021e 	bne	r3,r2,81143d74 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81143d6c:	00bffa84 	movi	r2,-22
81143d70:	00001b06 	br	81143de0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81143d74:	e0bffe17 	ldw	r2,-8(fp)
81143d78:	10800017 	ldw	r2,0(r2)
81143d7c:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81143d80:	00000906 	br	81143da8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
81143d84:	e0bffd17 	ldw	r2,-12(fp)
81143d88:	10c00317 	ldw	r3,12(r2)
81143d8c:	e0bfff17 	ldw	r2,-4(fp)
81143d90:	1880021e 	bne	r3,r2,81143d9c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81143d94:	00bffa84 	movi	r2,-22
81143d98:	00001106 	br	81143de0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81143d9c:	e0bffd17 	ldw	r2,-12(fp)
81143da0:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
81143da4:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81143da8:	e0bffd17 	ldw	r2,-12(fp)
81143dac:	10800317 	ldw	r2,12(r2)
81143db0:	e0fffe17 	ldw	r3,-8(fp)
81143db4:	18c00017 	ldw	r3,0(r3)
81143db8:	10fff21e 	bne	r2,r3,81143d84 <__reset+0xfb123d84>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
81143dbc:	e0ffff17 	ldw	r3,-4(fp)
81143dc0:	e0bffd17 	ldw	r2,-12(fp)
81143dc4:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
81143dc8:	e0bffe17 	ldw	r2,-8(fp)
81143dcc:	10800017 	ldw	r2,0(r2)
81143dd0:	1007883a 	mov	r3,r2
81143dd4:	e0bfff17 	ldw	r2,-4(fp)
81143dd8:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
81143ddc:	0005883a 	mov	r2,zero
}
81143de0:	e037883a 	mov	sp,fp
81143de4:	df000017 	ldw	fp,0(sp)
81143de8:	dec00104 	addi	sp,sp,4
81143dec:	f800283a 	ret

81143df0 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
81143df0:	defff804 	addi	sp,sp,-32
81143df4:	de00012e 	bgeu	sp,et,81143dfc <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
81143df8:	003b68fa 	trap	3
81143dfc:	df000715 	stw	fp,28(sp)
81143e00:	df000704 	addi	fp,sp,28
81143e04:	e13ffe15 	stw	r4,-8(fp)
81143e08:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
81143e0c:	e13fff17 	ldw	r4,-4(fp)
81143e10:	2000021e 	bne	r4,zero,81143e1c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81143e14:	00bffa84 	movi	r2,-22
81143e18:	00005906 	br	81143f80 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
81143e1c:	e13fff17 	ldw	r4,-4(fp)
81143e20:	2015883a 	mov	r10,r4
81143e24:	0017883a 	mov	r11,zero
81143e28:	e2bffc15 	stw	r10,-16(fp)
81143e2c:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81143e30:	e13fff17 	ldw	r4,-4(fp)
81143e34:	21400317 	ldw	r5,12(r4)
81143e38:	e13ffc17 	ldw	r4,-16(fp)
81143e3c:	29000626 	beq	r5,r4,81143e58 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
81143e40:	e13fff17 	ldw	r4,-4(fp)
81143e44:	21400b17 	ldw	r5,44(r4)
81143e48:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81143e4c:	29000226 	beq	r5,r4,81143e58 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81143e50:	00bffa84 	movi	r2,-22
81143e54:	00004a06 	br	81143f80 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
81143e58:	e13ffe17 	ldw	r4,-8(fp)
81143e5c:	21000017 	ldw	r4,0(r4)
81143e60:	2000051e 	bne	r4,zero,81143e78 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
81143e64:	e0bffe17 	ldw	r2,-8(fp)
81143e68:	e0ffff17 	ldw	r3,-4(fp)
81143e6c:	10c00015 	stw	r3,0(r2)
		return 0;
81143e70:	0005883a 	mov	r2,zero
81143e74:	00004206 	br	81143f80 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
81143e78:	e13ffe17 	ldw	r4,-8(fp)
81143e7c:	21400017 	ldw	r5,0(r4)
81143e80:	e13fff17 	ldw	r4,-4(fp)
81143e84:	2900021e 	bne	r5,r4,81143e90 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81143e88:	00bffa84 	movi	r2,-22
81143e8c:	00003c06 	br	81143f80 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81143e90:	e13ffe17 	ldw	r4,-8(fp)
81143e94:	21000017 	ldw	r4,0(r4)
81143e98:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
81143e9c:	e13ffe17 	ldw	r4,-8(fp)
81143ea0:	21000017 	ldw	r4,0(r4)
81143ea4:	2011883a 	mov	r8,r4
81143ea8:	0013883a 	mov	r9,zero
81143eac:	e23ffa15 	stw	r8,-24(fp)
81143eb0:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81143eb4:	00001806 	br	81143f18 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
81143eb8:	e13fff17 	ldw	r4,-4(fp)
81143ebc:	200d883a 	mov	r6,r4
81143ec0:	000f883a 	mov	r7,zero
81143ec4:	e1bffc15 	stw	r6,-16(fp)
81143ec8:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
81143ecc:	e13ff917 	ldw	r4,-28(fp)
81143ed0:	21400317 	ldw	r5,12(r4)
81143ed4:	e13ffc17 	ldw	r4,-16(fp)
81143ed8:	2900061e 	bne	r5,r4,81143ef4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
81143edc:	e13ff917 	ldw	r4,-28(fp)
81143ee0:	21400b17 	ldw	r5,44(r4)
81143ee4:	e13ffd17 	ldw	r4,-12(fp)
81143ee8:	2900021e 	bne	r5,r4,81143ef4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81143eec:	00bffa84 	movi	r2,-22
81143ef0:	00002306 	br	81143f80 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81143ef4:	e13ff917 	ldw	r4,-28(fp)
81143ef8:	21000317 	ldw	r4,12(r4)
81143efc:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81143f00:	e13ff917 	ldw	r4,-28(fp)
81143f04:	21000b17 	ldw	r4,44(r4)
81143f08:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81143f0c:	e13ffc17 	ldw	r4,-16(fp)
81143f10:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81143f14:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81143f18:	e13ff917 	ldw	r4,-28(fp)
81143f1c:	21400317 	ldw	r5,12(r4)
81143f20:	e13ffa17 	ldw	r4,-24(fp)
81143f24:	29000426 	beq	r5,r4,81143f38 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81143f28:	e13ff917 	ldw	r4,-28(fp)
81143f2c:	21400b17 	ldw	r5,44(r4)
81143f30:	e13ffb17 	ldw	r4,-20(fp)
81143f34:	293fe01e 	bne	r5,r4,81143eb8 <__reset+0xfb123eb8>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81143f38:	e13fff17 	ldw	r4,-4(fp)
81143f3c:	2005883a 	mov	r2,r4
81143f40:	0007883a 	mov	r3,zero
81143f44:	e0bffc15 	stw	r2,-16(fp)
81143f48:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
81143f4c:	e0fffc17 	ldw	r3,-16(fp)
81143f50:	e0bff917 	ldw	r2,-28(fp)
81143f54:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
81143f58:	e0fffd17 	ldw	r3,-12(fp)
81143f5c:	e0bff917 	ldw	r2,-28(fp)
81143f60:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
81143f64:	e0fffa17 	ldw	r3,-24(fp)
81143f68:	e0bfff17 	ldw	r2,-4(fp)
81143f6c:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
81143f70:	e0fffb17 	ldw	r3,-20(fp)
81143f74:	e0bfff17 	ldw	r2,-4(fp)
81143f78:	10c00b15 	stw	r3,44(r2)
	return 0;
81143f7c:	0005883a 	mov	r2,zero
}
81143f80:	e037883a 	mov	sp,fp
81143f84:	df000017 	ldw	fp,0(sp)
81143f88:	dec00104 	addi	sp,sp,4
81143f8c:	f800283a 	ret

81143f90 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
81143f90:	defffc04 	addi	sp,sp,-16
81143f94:	de00012e 	bgeu	sp,et,81143f9c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
81143f98:	003b68fa 	trap	3
81143f9c:	df000315 	stw	fp,12(sp)
81143fa0:	df000304 	addi	fp,sp,12
81143fa4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81143fa8:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
81143fac:	e0bfff17 	ldw	r2,-4(fp)
81143fb0:	1000021e 	bne	r2,zero,81143fbc <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81143fb4:	00bffa84 	movi	r2,-22
81143fb8:	00001906 	br	81144020 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81143fbc:	e0bfff17 	ldw	r2,-4(fp)
81143fc0:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81143fc4:	00000a06 	br	81143ff0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
81143fc8:	e0bffd17 	ldw	r2,-12(fp)
81143fcc:	10800717 	ldw	r2,28(r2)
81143fd0:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81143fd4:	e0bffe17 	ldw	r2,-8(fp)
81143fd8:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81143fdc:	e0bffd17 	ldw	r2,-12(fp)
81143fe0:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81143fe4:	e0bffd17 	ldw	r2,-12(fp)
81143fe8:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
81143fec:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81143ff0:	e0bffd17 	ldw	r2,-12(fp)
81143ff4:	10c00317 	ldw	r3,12(r2)
81143ff8:	e0bfff17 	ldw	r2,-4(fp)
81143ffc:	18bff21e 	bne	r3,r2,81143fc8 <__reset+0xfb123fc8>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
81144000:	e0bffd17 	ldw	r2,-12(fp)
81144004:	10800717 	ldw	r2,28(r2)
81144008:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114400c:	e0bffe17 	ldw	r2,-8(fp)
81144010:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81144014:	e0bffd17 	ldw	r2,-12(fp)
81144018:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8114401c:	0005883a 	mov	r2,zero
}
81144020:	e037883a 	mov	sp,fp
81144024:	df000017 	ldw	fp,0(sp)
81144028:	dec00104 	addi	sp,sp,4
8114402c:	f800283a 	ret

81144030 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
81144030:	defff804 	addi	sp,sp,-32
81144034:	de00012e 	bgeu	sp,et,8114403c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81144038:	003b68fa 	trap	3
8114403c:	df000715 	stw	fp,28(sp)
81144040:	df000704 	addi	fp,sp,28
81144044:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81144048:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8114404c:	e13fff17 	ldw	r4,-4(fp)
81144050:	2000021e 	bne	r4,zero,8114405c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81144054:	00bffa84 	movi	r2,-22
81144058:	00002806 	br	811440fc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114405c:	e13fff17 	ldw	r4,-4(fp)
81144060:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
81144064:	e13fff17 	ldw	r4,-4(fp)
81144068:	2005883a 	mov	r2,r4
8114406c:	0007883a 	mov	r3,zero
81144070:	e0bffb15 	stw	r2,-20(fp)
81144074:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81144078:	00001006 	br	811440bc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8114407c:	e0bff917 	ldw	r2,-28(fp)
81144080:	10800f17 	ldw	r2,60(r2)
81144084:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81144088:	e0bffa17 	ldw	r2,-24(fp)
8114408c:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81144090:	e0bff917 	ldw	r2,-28(fp)
81144094:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81144098:	e0bff917 	ldw	r2,-28(fp)
8114409c:	10800317 	ldw	r2,12(r2)
811440a0:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
811440a4:	e0bff917 	ldw	r2,-28(fp)
811440a8:	10800b17 	ldw	r2,44(r2)
811440ac:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
811440b0:	e0bffd17 	ldw	r2,-12(fp)
811440b4:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
811440b8:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811440bc:	e0bff917 	ldw	r2,-28(fp)
811440c0:	10c00317 	ldw	r3,12(r2)
811440c4:	e0bffb17 	ldw	r2,-20(fp)
811440c8:	18800426 	beq	r3,r2,811440dc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
811440cc:	e0bff917 	ldw	r2,-28(fp)
811440d0:	10c00b17 	ldw	r3,44(r2)
811440d4:	e0bffc17 	ldw	r2,-16(fp)
811440d8:	18bfe81e 	bne	r3,r2,8114407c <__reset+0xfb12407c>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
811440dc:	e0bff917 	ldw	r2,-28(fp)
811440e0:	10800f17 	ldw	r2,60(r2)
811440e4:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811440e8:	e0bffa17 	ldw	r2,-24(fp)
811440ec:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
811440f0:	e0bff917 	ldw	r2,-28(fp)
811440f4:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
811440f8:	0005883a 	mov	r2,zero
}
811440fc:	e037883a 	mov	sp,fp
81144100:	df000017 	ldw	fp,0(sp)
81144104:	dec00104 	addi	sp,sp,4
81144108:	f800283a 	ret

8114410c <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114410c:	deffeb04 	addi	sp,sp,-84
81144110:	de00012e 	bgeu	sp,et,81144118 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
81144114:	003b68fa 	trap	3
81144118:	dfc01415 	stw	ra,80(sp)
8114411c:	df001315 	stw	fp,76(sp)
81144120:	df001304 	addi	fp,sp,76
81144124:	e13ffb15 	stw	r4,-20(fp)
81144128:	e17ffc15 	stw	r5,-16(fp)
8114412c:	e1bffd15 	stw	r6,-12(fp)
81144130:	3807883a 	mov	r3,r7
81144134:	e0800217 	ldw	r2,8(fp)
81144138:	e0fffe05 	stb	r3,-8(fp)
8114413c:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
81144140:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
81144144:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
81144148:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8114414c:	e0bffc17 	ldw	r2,-16(fp)
81144150:	e0bff815 	stw	r2,-32(fp)
81144154:	e0bffd17 	ldw	r2,-12(fp)
81144158:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114415c:	e0bffb17 	ldw	r2,-20(fp)
81144160:	10801817 	ldw	r2,96(r2)
81144164:	e0bff615 	stw	r2,-40(fp)
81144168:	e03ff70d 	sth	zero,-36(fp)
8114416c:	e0bff70b 	ldhu	r2,-36(fp)
81144170:	e0fffa04 	addi	r3,fp,-24
81144174:	180d883a 	mov	r6,r3
81144178:	100b883a 	mov	r5,r2
8114417c:	e13ff617 	ldw	r4,-40(fp)
81144180:	113946c0 	call	8113946c <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
81144184:	e0bffb17 	ldw	r2,-20(fp)
81144188:	10800617 	ldw	r2,24(r2)
8114418c:	10800037 	ldwio	r2,0(r2)
81144190:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
81144194:	e0bfed17 	ldw	r2,-76(fp)
81144198:	1080004c 	andi	r2,r2,1
8114419c:	10000626 	beq	r2,zero,811441b8 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
811441a0:	e0bffb17 	ldw	r2,-20(fp)
811441a4:	10801817 	ldw	r2,96(r2)
811441a8:	1009883a 	mov	r4,r2
811441ac:	11397f40 	call	811397f4 <OSSemPost>
		return -EBUSY;
811441b0:	00bffc04 	movi	r2,-16
811441b4:	00009606 	br	81144410 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811441b8:	00800804 	movi	r2,32
811441bc:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811441c0:	0005303a 	rdctl	r2,status
811441c4:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811441c8:	e0fff217 	ldw	r3,-56(fp)
811441cc:	00bfff84 	movi	r2,-2
811441d0:	1884703a 	and	r2,r3,r2
811441d4:	1001703a 	wrctl	status,r2
  
  return context;
811441d8:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811441dc:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811441e0:	e0bffb17 	ldw	r2,-20(fp)
811441e4:	10800317 	ldw	r2,12(r2)
811441e8:	10800104 	addi	r2,r2,4
811441ec:	e0ffee17 	ldw	r3,-72(fp)
811441f0:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
811441f4:	e0bffb17 	ldw	r2,-20(fp)
811441f8:	10800317 	ldw	r2,12(r2)
811441fc:	e0fffb17 	ldw	r3,-20(fp)
81144200:	18c00317 	ldw	r3,12(r3)
81144204:	18c00037 	ldwio	r3,0(r3)
81144208:	10c00035 	stwio	r3,0(r2)
8114420c:	e0bfef17 	ldw	r2,-68(fp)
81144210:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144214:	e0bff017 	ldw	r2,-64(fp)
81144218:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
8114421c:	e0bffb17 	ldw	r2,-20(fp)
81144220:	10800b17 	ldw	r2,44(r2)
81144224:	10002326 	beq	r2,zero,811442b4 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
81144228:	e0bffb17 	ldw	r2,-20(fp)
8114422c:	10c00d17 	ldw	r3,52(r2)
81144230:	e0bfee17 	ldw	r2,-72(fp)
81144234:	1884b03a 	or	r2,r3,r2
81144238:	10800514 	ori	r2,r2,20
8114423c:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81144240:	e0ffee17 	ldw	r3,-72(fp)
81144244:	00bff7c4 	movi	r2,-33
81144248:	1884703a 	and	r2,r3,r2
8114424c:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81144250:	e0bfed17 	ldw	r2,-76(fp)
81144254:	10800214 	ori	r2,r2,8
81144258:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114425c:	0005303a 	rdctl	r2,status
81144260:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144264:	e0fff417 	ldw	r3,-48(fp)
81144268:	00bfff84 	movi	r2,-2
8114426c:	1884703a 	and	r2,r3,r2
81144270:	1001703a 	wrctl	status,r2
  
  return context;
81144274:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
81144278:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114427c:	e0bffb17 	ldw	r2,-20(fp)
81144280:	10800317 	ldw	r2,12(r2)
81144284:	10800104 	addi	r2,r2,4
81144288:	e0ffee17 	ldw	r3,-72(fp)
8114428c:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81144290:	e0bffb17 	ldw	r2,-20(fp)
81144294:	10800617 	ldw	r2,24(r2)
81144298:	e0ffed17 	ldw	r3,-76(fp)
8114429c:	10c00035 	stwio	r3,0(r2)
811442a0:	e0bfef17 	ldw	r2,-68(fp)
811442a4:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811442a8:	e0bff117 	ldw	r2,-60(fp)
811442ac:	1001703a 	wrctl	status,r2
811442b0:	00002306 	br	81144340 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
811442b4:	e0bffb17 	ldw	r2,-20(fp)
811442b8:	10c00d17 	ldw	r3,52(r2)
811442bc:	e0bfee17 	ldw	r2,-72(fp)
811442c0:	1884b03a 	or	r2,r3,r2
811442c4:	10800114 	ori	r2,r2,4
811442c8:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
811442cc:	e0ffee17 	ldw	r3,-72(fp)
811442d0:	00bff3c4 	movi	r2,-49
811442d4:	1884703a 	and	r2,r3,r2
811442d8:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
811442dc:	e0ffed17 	ldw	r3,-76(fp)
811442e0:	00bffdc4 	movi	r2,-9
811442e4:	1884703a 	and	r2,r3,r2
811442e8:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811442ec:	0005303a 	rdctl	r2,status
811442f0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811442f4:	e0fff517 	ldw	r3,-44(fp)
811442f8:	00bfff84 	movi	r2,-2
811442fc:	1884703a 	and	r2,r3,r2
81144300:	1001703a 	wrctl	status,r2
  
  return context;
81144304:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
81144308:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114430c:	e0bffb17 	ldw	r2,-20(fp)
81144310:	10800317 	ldw	r2,12(r2)
81144314:	10800104 	addi	r2,r2,4
81144318:	e0ffee17 	ldw	r3,-72(fp)
8114431c:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81144320:	e0bffb17 	ldw	r2,-20(fp)
81144324:	10800617 	ldw	r2,24(r2)
81144328:	e0ffed17 	ldw	r3,-76(fp)
8114432c:	10c00035 	stwio	r3,0(r2)
81144330:	e0bfef17 	ldw	r2,-68(fp)
81144334:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144338:	e0bff317 	ldw	r2,-52(fp)
8114433c:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81144340:	e0bffb17 	ldw	r2,-20(fp)
81144344:	10800617 	ldw	r2,24(r2)
81144348:	10800104 	addi	r2,r2,4
8114434c:	e0fff817 	ldw	r3,-32(fp)
81144350:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81144354:	e0bffb17 	ldw	r2,-20(fp)
81144358:	10800617 	ldw	r2,24(r2)
8114435c:	10800204 	addi	r2,r2,8
81144360:	e0fff917 	ldw	r3,-28(fp)
81144364:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
81144368:	e0bffe03 	ldbu	r2,-8(fp)
8114436c:	10000426 	beq	r2,zero,81144380 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81144370:	e0bfed17 	ldw	r2,-76(fp)
81144374:	10800414 	ori	r2,r2,16
81144378:	e0bfed15 	stw	r2,-76(fp)
8114437c:	00000406 	br	81144390 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81144380:	e0ffed17 	ldw	r3,-76(fp)
81144384:	00bffbc4 	movi	r2,-17
81144388:	1884703a 	and	r2,r3,r2
8114438c:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81144390:	e0bfff03 	ldbu	r2,-4(fp)
81144394:	10000e26 	beq	r2,zero,811443d0 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
81144398:	e0bfed17 	ldw	r2,-76(fp)
8114439c:	10800094 	ori	r2,r2,2
811443a0:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
811443a4:	e0bffb17 	ldw	r2,-20(fp)
811443a8:	10800617 	ldw	r2,24(r2)
811443ac:	10800304 	addi	r2,r2,12
811443b0:	10800037 	ldwio	r2,0(r2)
811443b4:	10000a1e 	bne	r2,zero,811443e0 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
811443b8:	e0bffb17 	ldw	r2,-20(fp)
811443bc:	10800617 	ldw	r2,24(r2)
811443c0:	10800304 	addi	r2,r2,12
811443c4:	00c03fc4 	movi	r3,255
811443c8:	10c00035 	stwio	r3,0(r2)
811443cc:	00000406 	br	811443e0 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
811443d0:	e0ffed17 	ldw	r3,-76(fp)
811443d4:	00bfff44 	movi	r2,-3
811443d8:	1884703a 	and	r2,r3,r2
811443dc:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
811443e0:	e0bfed17 	ldw	r2,-76(fp)
811443e4:	10800054 	ori	r2,r2,1
811443e8:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811443ec:	e0bffb17 	ldw	r2,-20(fp)
811443f0:	10800617 	ldw	r2,24(r2)
811443f4:	e0ffed17 	ldw	r3,-76(fp)
811443f8:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
811443fc:	e0bffb17 	ldw	r2,-20(fp)
81144400:	10801817 	ldw	r2,96(r2)
81144404:	1009883a 	mov	r4,r2
81144408:	11397f40 	call	811397f4 <OSSemPost>
	 
	 return 0;
8114440c:	0005883a 	mov	r2,zero
}
81144410:	e037883a 	mov	sp,fp
81144414:	dfc00117 	ldw	ra,4(sp)
81144418:	df000017 	ldw	fp,0(sp)
8114441c:	dec00204 	addi	sp,sp,8
81144420:	f800283a 	ret

81144424 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
81144424:	defff704 	addi	sp,sp,-36
81144428:	de00012e 	bgeu	sp,et,81144430 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
8114442c:	003b68fa 	trap	3
81144430:	dfc00815 	stw	ra,32(sp)
81144434:	df000715 	stw	fp,28(sp)
81144438:	dc400615 	stw	r17,24(sp)
8114443c:	dc000515 	stw	r16,20(sp)
81144440:	df000704 	addi	fp,sp,28
81144444:	e13ffa15 	stw	r4,-24(fp)
81144448:	e17ffb15 	stw	r5,-20(fp)
8114444c:	3007883a 	mov	r3,r6
81144450:	3805883a 	mov	r2,r7
81144454:	e0fffc05 	stb	r3,-16(fp)
81144458:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8114445c:	e13ffb17 	ldw	r4,-20(fp)
81144460:	1143f900 	call	81143f90 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
81144464:	10000226 	beq	r2,zero,81144470 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81144468:	00bffa84 	movi	r2,-22
8114446c:	00000b06 	br	8114449c <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81144470:	e0bffb17 	ldw	r2,-20(fp)
81144474:	1021883a 	mov	r16,r2
81144478:	0023883a 	mov	r17,zero
8114447c:	e0fffc03 	ldbu	r3,-16(fp)
81144480:	e0bffd03 	ldbu	r2,-12(fp)
81144484:	d8800015 	stw	r2,0(sp)
81144488:	180f883a 	mov	r7,r3
8114448c:	800b883a 	mov	r5,r16
81144490:	880d883a 	mov	r6,r17
81144494:	e13ffa17 	ldw	r4,-24(fp)
81144498:	114410c0 	call	8114410c <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114449c:	e6fffe04 	addi	sp,fp,-8
811444a0:	dfc00317 	ldw	ra,12(sp)
811444a4:	df000217 	ldw	fp,8(sp)
811444a8:	dc400117 	ldw	r17,4(sp)
811444ac:	dc000017 	ldw	r16,0(sp)
811444b0:	dec00404 	addi	sp,sp,16
811444b4:	f800283a 	ret

811444b8 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
811444b8:	defff704 	addi	sp,sp,-36
811444bc:	de00012e 	bgeu	sp,et,811444c4 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
811444c0:	003b68fa 	trap	3
811444c4:	dfc00815 	stw	ra,32(sp)
811444c8:	df000715 	stw	fp,28(sp)
811444cc:	dc400615 	stw	r17,24(sp)
811444d0:	dc000515 	stw	r16,20(sp)
811444d4:	df000704 	addi	fp,sp,28
811444d8:	e13ffa15 	stw	r4,-24(fp)
811444dc:	e17ffb15 	stw	r5,-20(fp)
811444e0:	3007883a 	mov	r3,r6
811444e4:	3805883a 	mov	r2,r7
811444e8:	e0fffc05 	stb	r3,-16(fp)
811444ec:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
811444f0:	e13ffb17 	ldw	r4,-20(fp)
811444f4:	11440300 	call	81144030 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
811444f8:	10000226 	beq	r2,zero,81144504 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
811444fc:	00bffa84 	movi	r2,-22
81144500:	00000b06 	br	81144530 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
81144504:	e0bffb17 	ldw	r2,-20(fp)
81144508:	1021883a 	mov	r16,r2
8114450c:	0023883a 	mov	r17,zero
81144510:	e0fffc03 	ldbu	r3,-16(fp)
81144514:	e0bffd03 	ldbu	r2,-12(fp)
81144518:	d8800015 	stw	r2,0(sp)
8114451c:	180f883a 	mov	r7,r3
81144520:	800b883a 	mov	r5,r16
81144524:	880d883a 	mov	r6,r17
81144528:	e13ffa17 	ldw	r4,-24(fp)
8114452c:	114410c0 	call	8114410c <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81144530:	e6fffe04 	addi	sp,fp,-8
81144534:	dfc00317 	ldw	ra,12(sp)
81144538:	df000217 	ldw	fp,8(sp)
8114453c:	dc400117 	ldw	r17,4(sp)
81144540:	dc000017 	ldw	r16,0(sp)
81144544:	dec00404 	addi	sp,sp,16
81144548:	f800283a 	ret

8114454c <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8114454c:	defffc04 	addi	sp,sp,-16
81144550:	de00012e 	bgeu	sp,et,81144558 <alt_msgdma_open+0xc>
81144554:	003b68fa 	trap	3
81144558:	dfc00315 	stw	ra,12(sp)
8114455c:	df000215 	stw	fp,8(sp)
81144560:	df000204 	addi	fp,sp,8
81144564:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81144568:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
8114456c:	d1603504 	addi	r5,gp,-32556
81144570:	e13fff17 	ldw	r4,-4(fp)
81144574:	1144af00 	call	81144af0 <alt_find_dev>
81144578:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
8114457c:	e0bffe17 	ldw	r2,-8(fp)
81144580:	1000041e 	bne	r2,zero,81144594 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
81144584:	11427b00 	call	811427b0 <alt_get_errno>
81144588:	1007883a 	mov	r3,r2
8114458c:	008004c4 	movi	r2,19
81144590:	18800015 	stw	r2,0(r3)
    }

    return dev;
81144594:	e0bffe17 	ldw	r2,-8(fp)
}
81144598:	e037883a 	mov	sp,fp
8114459c:	dfc00117 	ldw	ra,4(sp)
811445a0:	df000017 	ldw	fp,0(sp)
811445a4:	dec00204 	addi	sp,sp,8
811445a8:	f800283a 	ret

811445ac <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
811445ac:	defff604 	addi	sp,sp,-40
811445b0:	de00012e 	bgeu	sp,et,811445b8 <alt_msgdma_init+0xc>
811445b4:	003b68fa 	trap	3
811445b8:	dfc00915 	stw	ra,36(sp)
811445bc:	df000815 	stw	fp,32(sp)
811445c0:	df000804 	addi	fp,sp,32
811445c4:	e13ffd15 	stw	r4,-12(fp)
811445c8:	e17ffe15 	stw	r5,-8(fp)
811445cc:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
811445d0:	e0bffd17 	ldw	r2,-12(fp)
811445d4:	10801783 	ldbu	r2,94(r2)
811445d8:	10803fcc 	andi	r2,r2,255
811445dc:	10000b26 	beq	r2,zero,8114460c <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
811445e0:	e0bffd17 	ldw	r2,-12(fp)
811445e4:	10800617 	ldw	r2,24(r2)
811445e8:	00c00104 	movi	r3,4
811445ec:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
811445f0:	0001883a 	nop
811445f4:	e0bffd17 	ldw	r2,-12(fp)
811445f8:	10800617 	ldw	r2,24(r2)
811445fc:	10800037 	ldwio	r2,0(r2)
81144600:	1080010c 	andi	r2,r2,4
81144604:	1005d0ba 	srai	r2,r2,2
81144608:	103ffa1e 	bne	r2,zero,811445f4 <__reset+0xfb1245f4>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8114460c:	e0bffd17 	ldw	r2,-12(fp)
81144610:	10800317 	ldw	r2,12(r2)
81144614:	10800104 	addi	r2,r2,4
81144618:	00c00084 	movi	r3,2
8114461c:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81144620:	0001883a 	nop
81144624:	e0bffd17 	ldw	r2,-12(fp)
81144628:	10800317 	ldw	r2,12(r2)
8114462c:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81144630:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81144634:	103ffb1e 	bne	r2,zero,81144624 <__reset+0xfb124624>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81144638:	e0bffd17 	ldw	r2,-12(fp)
8114463c:	10800317 	ldw	r2,12(r2)
81144640:	10800104 	addi	r2,r2,4
81144644:	10800037 	ldwio	r2,0(r2)
81144648:	1007883a 	mov	r3,r2
8114464c:	00bffbc4 	movi	r2,-17
81144650:	1884703a 	and	r2,r3,r2
81144654:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81144658:	e0bff917 	ldw	r2,-28(fp)
8114465c:	10800814 	ori	r2,r2,32
81144660:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81144664:	e0bffd17 	ldw	r2,-12(fp)
81144668:	10800317 	ldw	r2,12(r2)
8114466c:	10800104 	addi	r2,r2,4
81144670:	e0fff917 	ldw	r3,-28(fp)
81144674:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81144678:	e0bffd17 	ldw	r2,-12(fp)
8114467c:	10800317 	ldw	r2,12(r2)
81144680:	e0fffd17 	ldw	r3,-12(fp)
81144684:	18c00317 	ldw	r3,12(r3)
81144688:	18c00037 	ldwio	r3,0(r3)
8114468c:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81144690:	e0bffd17 	ldw	r2,-12(fp)
81144694:	10801783 	ldbu	r2,94(r2)
81144698:	10803fcc 	andi	r2,r2,255
8114469c:	10000826 	beq	r2,zero,811446c0 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
811446a0:	e0bffd17 	ldw	r2,-12(fp)
811446a4:	10800617 	ldw	r2,24(r2)
811446a8:	10800404 	addi	r2,r2,16
811446ac:	e0fffd17 	ldw	r3,-12(fp)
811446b0:	18c00617 	ldw	r3,24(r3)
811446b4:	18c00404 	addi	r3,r3,16
811446b8:	18c00037 	ldwio	r3,0(r3)
811446bc:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
811446c0:	d1603504 	addi	r5,gp,-32556
811446c4:	e13ffd17 	ldw	r4,-12(fp)
811446c8:	1144a440 	call	81144a44 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
811446cc:	e0bffd17 	ldw	r2,-12(fp)
811446d0:	10801804 	addi	r2,r2,96
811446d4:	e0bffb15 	stw	r2,-20(fp)
811446d8:	00800044 	movi	r2,1
811446dc:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811446e0:	e0bffc0b 	ldhu	r2,-16(fp)
811446e4:	1009883a 	mov	r4,r2
811446e8:	11391440 	call	81139144 <OSSemCreate>
811446ec:	1007883a 	mov	r3,r2
811446f0:	e0bffb17 	ldw	r2,-20(fp)
811446f4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811446f8:	e0bffb17 	ldw	r2,-20(fp)
811446fc:	10800017 	ldw	r2,0(r2)
81144700:	10000226 	beq	r2,zero,8114470c <alt_msgdma_init+0x160>
81144704:	0005883a 	mov	r2,zero
81144708:	00000106 	br	81144710 <alt_msgdma_init+0x164>
8114470c:	00bfffc4 	movi	r2,-1
81144710:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81144714:	e0bffa17 	ldw	r2,-24(fp)
81144718:	1000081e 	bne	r2,zero,8114473c <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
8114471c:	d8000015 	stw	zero,0(sp)
81144720:	e1fffd17 	ldw	r7,-12(fp)
81144724:	01a04534 	movhi	r6,33044
81144728:	318a7104 	addi	r6,r6,10692
8114472c:	e17fff17 	ldw	r5,-4(fp)
81144730:	e13ffe17 	ldw	r4,-8(fp)
81144734:	1144d7c0 	call	81144d7c <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81144738:	00000406 	br	8114474c <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
8114473c:	01204574 	movhi	r4,33045
81144740:	212bc704 	addi	r4,r4,-20708
81144744:	11451940 	call	81145194 <alt_printf>
    }
    
    return;
81144748:	0001883a 	nop

}
8114474c:	e037883a 	mov	sp,fp
81144750:	dfc00117 	ldw	ra,4(sp)
81144754:	df000017 	ldw	fp,0(sp)
81144758:	dec00204 	addi	sp,sp,8
8114475c:	f800283a 	ret

81144760 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81144760:	defffb04 	addi	sp,sp,-20
81144764:	de00012e 	bgeu	sp,et,8114476c <alt_msgdma_register_callback+0xc>
81144768:	003b68fa 	trap	3
8114476c:	df000415 	stw	fp,16(sp)
81144770:	df000404 	addi	fp,sp,16
81144774:	e13ffc15 	stw	r4,-16(fp)
81144778:	e17ffd15 	stw	r5,-12(fp)
8114477c:	e1bffe15 	stw	r6,-8(fp)
81144780:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81144784:	e0bffc17 	ldw	r2,-16(fp)
81144788:	e0fffd17 	ldw	r3,-12(fp)
8114478c:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81144790:	e0bffc17 	ldw	r2,-16(fp)
81144794:	e0ffff17 	ldw	r3,-4(fp)
81144798:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
8114479c:	e0bffc17 	ldw	r2,-16(fp)
811447a0:	e0fffe17 	ldw	r3,-8(fp)
811447a4:	10c00d15 	stw	r3,52(r2)

    return ;
811447a8:	0001883a 	nop
}
811447ac:	e037883a 	mov	sp,fp
811447b0:	df000017 	ldw	fp,0(sp)
811447b4:	dec00104 	addi	sp,sp,4
811447b8:	f800283a 	ret

811447bc <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
811447bc:	defffc04 	addi	sp,sp,-16
811447c0:	de00012e 	bgeu	sp,et,811447c8 <alt_msgdma_standard_descriptor_async_transfer+0xc>
811447c4:	003b68fa 	trap	3
811447c8:	dfc00315 	stw	ra,12(sp)
811447cc:	df000215 	stw	fp,8(sp)
811447d0:	df000204 	addi	fp,sp,8
811447d4:	e13ffe15 	stw	r4,-8(fp)
811447d8:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
811447dc:	000d883a 	mov	r6,zero
811447e0:	e17fff17 	ldw	r5,-4(fp)
811447e4:	e13ffe17 	ldw	r4,-8(fp)
811447e8:	1142d400 	call	81142d40 <alt_msgdma_descriptor_async_transfer>

}
811447ec:	e037883a 	mov	sp,fp
811447f0:	dfc00117 	ldw	ra,4(sp)
811447f4:	df000017 	ldw	fp,0(sp)
811447f8:	dec00204 	addi	sp,sp,8
811447fc:	f800283a 	ret

81144800 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81144800:	defffc04 	addi	sp,sp,-16
81144804:	de00012e 	bgeu	sp,et,8114480c <alt_msgdma_extended_descriptor_async_transfer+0xc>
81144808:	003b68fa 	trap	3
8114480c:	dfc00315 	stw	ra,12(sp)
81144810:	df000215 	stw	fp,8(sp)
81144814:	df000204 	addi	fp,sp,8
81144818:	e13ffe15 	stw	r4,-8(fp)
8114481c:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
81144820:	e1bfff17 	ldw	r6,-4(fp)
81144824:	000b883a 	mov	r5,zero
81144828:	e13ffe17 	ldw	r4,-8(fp)
8114482c:	1142d400 	call	81142d40 <alt_msgdma_descriptor_async_transfer>
}
81144830:	e037883a 	mov	sp,fp
81144834:	dfc00117 	ldw	ra,4(sp)
81144838:	df000017 	ldw	fp,0(sp)
8114483c:	dec00204 	addi	sp,sp,8
81144840:	f800283a 	ret

81144844 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81144844:	defffc04 	addi	sp,sp,-16
81144848:	de00012e 	bgeu	sp,et,81144850 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
8114484c:	003b68fa 	trap	3
81144850:	dfc00315 	stw	ra,12(sp)
81144854:	df000215 	stw	fp,8(sp)
81144858:	df000204 	addi	fp,sp,8
8114485c:	e13ffe15 	stw	r4,-8(fp)
81144860:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
81144864:	000d883a 	mov	r6,zero
81144868:	e17fff17 	ldw	r5,-4(fp)
8114486c:	e13ffe17 	ldw	r4,-8(fp)
81144870:	11430800 	call	81143080 <alt_msgdma_descriptor_sync_transfer>
}
81144874:	e037883a 	mov	sp,fp
81144878:	dfc00117 	ldw	ra,4(sp)
8114487c:	df000017 	ldw	fp,0(sp)
81144880:	dec00204 	addi	sp,sp,8
81144884:	f800283a 	ret

81144888 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81144888:	defffc04 	addi	sp,sp,-16
8114488c:	de00012e 	bgeu	sp,et,81144894 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
81144890:	003b68fa 	trap	3
81144894:	dfc00315 	stw	ra,12(sp)
81144898:	df000215 	stw	fp,8(sp)
8114489c:	df000204 	addi	fp,sp,8
811448a0:	e13ffe15 	stw	r4,-8(fp)
811448a4:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
811448a8:	e1bfff17 	ldw	r6,-4(fp)
811448ac:	000b883a 	mov	r5,zero
811448b0:	e13ffe17 	ldw	r4,-8(fp)
811448b4:	11430800 	call	81143080 <alt_msgdma_descriptor_sync_transfer>
}
811448b8:	e037883a 	mov	sp,fp
811448bc:	dfc00117 	ldw	ra,4(sp)
811448c0:	df000017 	ldw	fp,0(sp)
811448c4:	dec00204 	addi	sp,sp,8
811448c8:	f800283a 	ret

811448cc <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
811448cc:	defff504 	addi	sp,sp,-44
811448d0:	de00012e 	bgeu	sp,et,811448d8 <alt_alarm_start+0xc>
811448d4:	003b68fa 	trap	3
811448d8:	df000a15 	stw	fp,40(sp)
811448dc:	df000a04 	addi	fp,sp,40
811448e0:	e13ffc15 	stw	r4,-16(fp)
811448e4:	e17ffd15 	stw	r5,-12(fp)
811448e8:	e1bffe15 	stw	r6,-8(fp)
811448ec:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
811448f0:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811448f4:	d0a08217 	ldw	r2,-32248(gp)
  
  if (alt_ticks_per_second ())
811448f8:	10003c26 	beq	r2,zero,811449ec <alt_alarm_start+0x120>
  {
    if (alarm)
811448fc:	e0bffc17 	ldw	r2,-16(fp)
81144900:	10003826 	beq	r2,zero,811449e4 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81144904:	e0bffc17 	ldw	r2,-16(fp)
81144908:	e0fffe17 	ldw	r3,-8(fp)
8114490c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
81144910:	e0bffc17 	ldw	r2,-16(fp)
81144914:	e0ffff17 	ldw	r3,-4(fp)
81144918:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114491c:	0005303a 	rdctl	r2,status
81144920:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144924:	e0fff917 	ldw	r3,-28(fp)
81144928:	00bfff84 	movi	r2,-2
8114492c:	1884703a 	and	r2,r3,r2
81144930:	1001703a 	wrctl	status,r2
  
  return context;
81144934:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81144938:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8114493c:	d0a08317 	ldw	r2,-32244(gp)
      
      current_nticks = alt_nticks();
81144940:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81144944:	e0fffd17 	ldw	r3,-12(fp)
81144948:	e0bff617 	ldw	r2,-40(fp)
8114494c:	1885883a 	add	r2,r3,r2
81144950:	10c00044 	addi	r3,r2,1
81144954:	e0bffc17 	ldw	r2,-16(fp)
81144958:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
8114495c:	e0bffc17 	ldw	r2,-16(fp)
81144960:	10c00217 	ldw	r3,8(r2)
81144964:	e0bff617 	ldw	r2,-40(fp)
81144968:	1880042e 	bgeu	r3,r2,8114497c <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
8114496c:	e0bffc17 	ldw	r2,-16(fp)
81144970:	00c00044 	movi	r3,1
81144974:	10c00405 	stb	r3,16(r2)
81144978:	00000206 	br	81144984 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
8114497c:	e0bffc17 	ldw	r2,-16(fp)
81144980:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
81144984:	e0bffc17 	ldw	r2,-16(fp)
81144988:	d0e01404 	addi	r3,gp,-32688
8114498c:	e0fffa15 	stw	r3,-24(fp)
81144990:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81144994:	e0bffb17 	ldw	r2,-20(fp)
81144998:	e0fffa17 	ldw	r3,-24(fp)
8114499c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
811449a0:	e0bffa17 	ldw	r2,-24(fp)
811449a4:	10c00017 	ldw	r3,0(r2)
811449a8:	e0bffb17 	ldw	r2,-20(fp)
811449ac:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
811449b0:	e0bffa17 	ldw	r2,-24(fp)
811449b4:	10800017 	ldw	r2,0(r2)
811449b8:	e0fffb17 	ldw	r3,-20(fp)
811449bc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
811449c0:	e0bffa17 	ldw	r2,-24(fp)
811449c4:	e0fffb17 	ldw	r3,-20(fp)
811449c8:	10c00015 	stw	r3,0(r2)
811449cc:	e0bff817 	ldw	r2,-32(fp)
811449d0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811449d4:	e0bff717 	ldw	r2,-36(fp)
811449d8:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
811449dc:	0005883a 	mov	r2,zero
811449e0:	00000306 	br	811449f0 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
811449e4:	00bffa84 	movi	r2,-22
811449e8:	00000106 	br	811449f0 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
811449ec:	00bfde84 	movi	r2,-134
  }
}
811449f0:	e037883a 	mov	sp,fp
811449f4:	df000017 	ldw	fp,0(sp)
811449f8:	dec00104 	addi	sp,sp,4
811449fc:	f800283a 	ret

81144a00 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81144a00:	defffe04 	addi	sp,sp,-8
81144a04:	de00012e 	bgeu	sp,et,81144a0c <alt_get_errno+0xc>
81144a08:	003b68fa 	trap	3
81144a0c:	dfc00115 	stw	ra,4(sp)
81144a10:	df000015 	stw	fp,0(sp)
81144a14:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81144a18:	d0a01017 	ldw	r2,-32704(gp)
81144a1c:	10000326 	beq	r2,zero,81144a2c <alt_get_errno+0x2c>
81144a20:	d0a01017 	ldw	r2,-32704(gp)
81144a24:	103ee83a 	callr	r2
81144a28:	00000106 	br	81144a30 <alt_get_errno+0x30>
81144a2c:	d0a07204 	addi	r2,gp,-32312
}
81144a30:	e037883a 	mov	sp,fp
81144a34:	dfc00117 	ldw	ra,4(sp)
81144a38:	df000017 	ldw	fp,0(sp)
81144a3c:	dec00204 	addi	sp,sp,8
81144a40:	f800283a 	ret

81144a44 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
81144a44:	defffa04 	addi	sp,sp,-24
81144a48:	de00012e 	bgeu	sp,et,81144a50 <alt_dev_llist_insert+0xc>
81144a4c:	003b68fa 	trap	3
81144a50:	dfc00515 	stw	ra,20(sp)
81144a54:	df000415 	stw	fp,16(sp)
81144a58:	df000404 	addi	fp,sp,16
81144a5c:	e13ffe15 	stw	r4,-8(fp)
81144a60:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
81144a64:	e0bffe17 	ldw	r2,-8(fp)
81144a68:	10000326 	beq	r2,zero,81144a78 <alt_dev_llist_insert+0x34>
81144a6c:	e0bffe17 	ldw	r2,-8(fp)
81144a70:	10800217 	ldw	r2,8(r2)
81144a74:	1000061e 	bne	r2,zero,81144a90 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
81144a78:	1144a000 	call	81144a00 <alt_get_errno>
81144a7c:	1007883a 	mov	r3,r2
81144a80:	00800584 	movi	r2,22
81144a84:	18800015 	stw	r2,0(r3)
    return -EINVAL;
81144a88:	00bffa84 	movi	r2,-22
81144a8c:	00001306 	br	81144adc <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
81144a90:	e0bffe17 	ldw	r2,-8(fp)
81144a94:	e0ffff17 	ldw	r3,-4(fp)
81144a98:	e0fffc15 	stw	r3,-16(fp)
81144a9c:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81144aa0:	e0bffd17 	ldw	r2,-12(fp)
81144aa4:	e0fffc17 	ldw	r3,-16(fp)
81144aa8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81144aac:	e0bffc17 	ldw	r2,-16(fp)
81144ab0:	10c00017 	ldw	r3,0(r2)
81144ab4:	e0bffd17 	ldw	r2,-12(fp)
81144ab8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81144abc:	e0bffc17 	ldw	r2,-16(fp)
81144ac0:	10800017 	ldw	r2,0(r2)
81144ac4:	e0fffd17 	ldw	r3,-12(fp)
81144ac8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81144acc:	e0bffc17 	ldw	r2,-16(fp)
81144ad0:	e0fffd17 	ldw	r3,-12(fp)
81144ad4:	10c00015 	stw	r3,0(r2)

  return 0;  
81144ad8:	0005883a 	mov	r2,zero
}
81144adc:	e037883a 	mov	sp,fp
81144ae0:	dfc00117 	ldw	ra,4(sp)
81144ae4:	df000017 	ldw	fp,0(sp)
81144ae8:	dec00204 	addi	sp,sp,8
81144aec:	f800283a 	ret

81144af0 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
81144af0:	defffa04 	addi	sp,sp,-24
81144af4:	de00012e 	bgeu	sp,et,81144afc <alt_find_dev+0xc>
81144af8:	003b68fa 	trap	3
81144afc:	dfc00515 	stw	ra,20(sp)
81144b00:	df000415 	stw	fp,16(sp)
81144b04:	df000404 	addi	fp,sp,16
81144b08:	e13ffe15 	stw	r4,-8(fp)
81144b0c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
81144b10:	e0bfff17 	ldw	r2,-4(fp)
81144b14:	10800017 	ldw	r2,0(r2)
81144b18:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
81144b1c:	e13ffe17 	ldw	r4,-8(fp)
81144b20:	111cf340 	call	8111cf34 <strlen>
81144b24:	10800044 	addi	r2,r2,1
81144b28:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81144b2c:	00000d06 	br	81144b64 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
81144b30:	e0bffc17 	ldw	r2,-16(fp)
81144b34:	10800217 	ldw	r2,8(r2)
81144b38:	e0fffd17 	ldw	r3,-12(fp)
81144b3c:	180d883a 	mov	r6,r3
81144b40:	e17ffe17 	ldw	r5,-8(fp)
81144b44:	1009883a 	mov	r4,r2
81144b48:	11459040 	call	81145904 <memcmp>
81144b4c:	1000021e 	bne	r2,zero,81144b58 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
81144b50:	e0bffc17 	ldw	r2,-16(fp)
81144b54:	00000706 	br	81144b74 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
81144b58:	e0bffc17 	ldw	r2,-16(fp)
81144b5c:	10800017 	ldw	r2,0(r2)
81144b60:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81144b64:	e0fffc17 	ldw	r3,-16(fp)
81144b68:	e0bfff17 	ldw	r2,-4(fp)
81144b6c:	18bff01e 	bne	r3,r2,81144b30 <__reset+0xfb124b30>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
81144b70:	0005883a 	mov	r2,zero
}
81144b74:	e037883a 	mov	sp,fp
81144b78:	dfc00117 	ldw	ra,4(sp)
81144b7c:	df000017 	ldw	fp,0(sp)
81144b80:	dec00204 	addi	sp,sp,8
81144b84:	f800283a 	ret

81144b88 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
81144b88:	defffb04 	addi	sp,sp,-20
81144b8c:	de00012e 	bgeu	sp,et,81144b94 <alt_find_file+0xc>
81144b90:	003b68fa 	trap	3
81144b94:	dfc00415 	stw	ra,16(sp)
81144b98:	df000315 	stw	fp,12(sp)
81144b9c:	df000304 	addi	fp,sp,12
81144ba0:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
81144ba4:	d0a00b17 	ldw	r2,-32724(gp)
81144ba8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81144bac:	00003106 	br	81144c74 <alt_find_file+0xec>
  {
    len = strlen(next->name);
81144bb0:	e0bffd17 	ldw	r2,-12(fp)
81144bb4:	10800217 	ldw	r2,8(r2)
81144bb8:	1009883a 	mov	r4,r2
81144bbc:	111cf340 	call	8111cf34 <strlen>
81144bc0:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
81144bc4:	e0bffd17 	ldw	r2,-12(fp)
81144bc8:	10c00217 	ldw	r3,8(r2)
81144bcc:	e0bffe17 	ldw	r2,-8(fp)
81144bd0:	10bfffc4 	addi	r2,r2,-1
81144bd4:	1885883a 	add	r2,r3,r2
81144bd8:	10800003 	ldbu	r2,0(r2)
81144bdc:	10803fcc 	andi	r2,r2,255
81144be0:	1080201c 	xori	r2,r2,128
81144be4:	10bfe004 	addi	r2,r2,-128
81144be8:	10800bd8 	cmpnei	r2,r2,47
81144bec:	1000031e 	bne	r2,zero,81144bfc <alt_find_file+0x74>
    {
      len -= 1;
81144bf0:	e0bffe17 	ldw	r2,-8(fp)
81144bf4:	10bfffc4 	addi	r2,r2,-1
81144bf8:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81144bfc:	e0bffe17 	ldw	r2,-8(fp)
81144c00:	e0ffff17 	ldw	r3,-4(fp)
81144c04:	1885883a 	add	r2,r3,r2
81144c08:	10800003 	ldbu	r2,0(r2)
81144c0c:	10803fcc 	andi	r2,r2,255
81144c10:	1080201c 	xori	r2,r2,128
81144c14:	10bfe004 	addi	r2,r2,-128
81144c18:	10800be0 	cmpeqi	r2,r2,47
81144c1c:	1000081e 	bne	r2,zero,81144c40 <alt_find_file+0xb8>
81144c20:	e0bffe17 	ldw	r2,-8(fp)
81144c24:	e0ffff17 	ldw	r3,-4(fp)
81144c28:	1885883a 	add	r2,r3,r2
81144c2c:	10800003 	ldbu	r2,0(r2)
81144c30:	10803fcc 	andi	r2,r2,255
81144c34:	1080201c 	xori	r2,r2,128
81144c38:	10bfe004 	addi	r2,r2,-128
81144c3c:	10000a1e 	bne	r2,zero,81144c68 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
81144c40:	e0bffd17 	ldw	r2,-12(fp)
81144c44:	10800217 	ldw	r2,8(r2)
81144c48:	e0fffe17 	ldw	r3,-8(fp)
81144c4c:	180d883a 	mov	r6,r3
81144c50:	e17fff17 	ldw	r5,-4(fp)
81144c54:	1009883a 	mov	r4,r2
81144c58:	11459040 	call	81145904 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81144c5c:	1000021e 	bne	r2,zero,81144c68 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
81144c60:	e0bffd17 	ldw	r2,-12(fp)
81144c64:	00000706 	br	81144c84 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
81144c68:	e0bffd17 	ldw	r2,-12(fp)
81144c6c:	10800017 	ldw	r2,0(r2)
81144c70:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81144c74:	e0fffd17 	ldw	r3,-12(fp)
81144c78:	d0a00b04 	addi	r2,gp,-32724
81144c7c:	18bfcc1e 	bne	r3,r2,81144bb0 <__reset+0xfb124bb0>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
81144c80:	0005883a 	mov	r2,zero
}
81144c84:	e037883a 	mov	sp,fp
81144c88:	dfc00117 	ldw	ra,4(sp)
81144c8c:	df000017 	ldw	fp,0(sp)
81144c90:	dec00204 	addi	sp,sp,8
81144c94:	f800283a 	ret

81144c98 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
81144c98:	defff904 	addi	sp,sp,-28
81144c9c:	de00012e 	bgeu	sp,et,81144ca4 <alt_get_fd+0xc>
81144ca0:	003b68fa 	trap	3
81144ca4:	dfc00615 	stw	ra,24(sp)
81144ca8:	df000515 	stw	fp,20(sp)
81144cac:	df000504 	addi	fp,sp,20
81144cb0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
81144cb4:	00bffa04 	movi	r2,-24
81144cb8:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
81144cbc:	d0a07917 	ldw	r2,-32284(gp)
81144cc0:	e0bffd15 	stw	r2,-12(fp)
81144cc4:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81144cc8:	e0bffe0b 	ldhu	r2,-8(fp)
81144ccc:	e0fffe84 	addi	r3,fp,-6
81144cd0:	180d883a 	mov	r6,r3
81144cd4:	100b883a 	mov	r5,r2
81144cd8:	e13ffd17 	ldw	r4,-12(fp)
81144cdc:	113946c0 	call	8113946c <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81144ce0:	e03ffb15 	stw	zero,-20(fp)
81144ce4:	00001906 	br	81144d4c <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
81144ce8:	00a04574 	movhi	r2,33045
81144cec:	10ae3604 	addi	r2,r2,-18216
81144cf0:	e0fffb17 	ldw	r3,-20(fp)
81144cf4:	18c00324 	muli	r3,r3,12
81144cf8:	10c5883a 	add	r2,r2,r3
81144cfc:	10800017 	ldw	r2,0(r2)
81144d00:	10000f1e 	bne	r2,zero,81144d40 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
81144d04:	00a04574 	movhi	r2,33045
81144d08:	10ae3604 	addi	r2,r2,-18216
81144d0c:	e0fffb17 	ldw	r3,-20(fp)
81144d10:	18c00324 	muli	r3,r3,12
81144d14:	10c5883a 	add	r2,r2,r3
81144d18:	e0ffff17 	ldw	r3,-4(fp)
81144d1c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
81144d20:	d0e00f17 	ldw	r3,-32708(gp)
81144d24:	e0bffb17 	ldw	r2,-20(fp)
81144d28:	1880020e 	bge	r3,r2,81144d34 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
81144d2c:	e0bffb17 	ldw	r2,-20(fp)
81144d30:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
81144d34:	e0bffb17 	ldw	r2,-20(fp)
81144d38:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
81144d3c:	00000606 	br	81144d58 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81144d40:	e0bffb17 	ldw	r2,-20(fp)
81144d44:	10800044 	addi	r2,r2,1
81144d48:	e0bffb15 	stw	r2,-20(fp)
81144d4c:	e0bffb17 	ldw	r2,-20(fp)
81144d50:	10800810 	cmplti	r2,r2,32
81144d54:	103fe41e 	bne	r2,zero,81144ce8 <__reset+0xfb124ce8>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
81144d58:	d0a07917 	ldw	r2,-32284(gp)
81144d5c:	1009883a 	mov	r4,r2
81144d60:	11397f40 	call	811397f4 <OSSemPost>

  return rc;
81144d64:	e0bffc17 	ldw	r2,-16(fp)
}
81144d68:	e037883a 	mov	sp,fp
81144d6c:	dfc00117 	ldw	ra,4(sp)
81144d70:	df000017 	ldw	fp,0(sp)
81144d74:	dec00204 	addi	sp,sp,8
81144d78:	f800283a 	ret

81144d7c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81144d7c:	defff904 	addi	sp,sp,-28
81144d80:	de00012e 	bgeu	sp,et,81144d88 <alt_ic_isr_register+0xc>
81144d84:	003b68fa 	trap	3
81144d88:	dfc00615 	stw	ra,24(sp)
81144d8c:	df000515 	stw	fp,20(sp)
81144d90:	df000504 	addi	fp,sp,20
81144d94:	e13ffc15 	stw	r4,-16(fp)
81144d98:	e17ffd15 	stw	r5,-12(fp)
81144d9c:	e1bffe15 	stw	r6,-8(fp)
81144da0:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
81144da4:	e0800217 	ldw	r2,8(fp)
81144da8:	d8800015 	stw	r2,0(sp)
81144dac:	e1ffff17 	ldw	r7,-4(fp)
81144db0:	e1bffe17 	ldw	r6,-8(fp)
81144db4:	e17ffd17 	ldw	r5,-12(fp)
81144db8:	e13ffc17 	ldw	r4,-16(fp)
81144dbc:	1144f4c0 	call	81144f4c <alt_iic_isr_register>
}  
81144dc0:	e037883a 	mov	sp,fp
81144dc4:	dfc00117 	ldw	ra,4(sp)
81144dc8:	df000017 	ldw	fp,0(sp)
81144dcc:	dec00204 	addi	sp,sp,8
81144dd0:	f800283a 	ret

81144dd4 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
81144dd4:	defff904 	addi	sp,sp,-28
81144dd8:	de00012e 	bgeu	sp,et,81144de0 <alt_ic_irq_enable+0xc>
81144ddc:	003b68fa 	trap	3
81144de0:	df000615 	stw	fp,24(sp)
81144de4:	df000604 	addi	fp,sp,24
81144de8:	e13ffe15 	stw	r4,-8(fp)
81144dec:	e17fff15 	stw	r5,-4(fp)
81144df0:	e0bfff17 	ldw	r2,-4(fp)
81144df4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144df8:	0005303a 	rdctl	r2,status
81144dfc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144e00:	e0fffb17 	ldw	r3,-20(fp)
81144e04:	00bfff84 	movi	r2,-2
81144e08:	1884703a 	and	r2,r3,r2
81144e0c:	1001703a 	wrctl	status,r2
  
  return context;
81144e10:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81144e14:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
81144e18:	00c00044 	movi	r3,1
81144e1c:	e0bffa17 	ldw	r2,-24(fp)
81144e20:	1884983a 	sll	r2,r3,r2
81144e24:	1007883a 	mov	r3,r2
81144e28:	d0a07a17 	ldw	r2,-32280(gp)
81144e2c:	1884b03a 	or	r2,r3,r2
81144e30:	d0a07a15 	stw	r2,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81144e34:	d0a07a17 	ldw	r2,-32280(gp)
81144e38:	100170fa 	wrctl	ienable,r2
81144e3c:	e0bffc17 	ldw	r2,-16(fp)
81144e40:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144e44:	e0bffd17 	ldw	r2,-12(fp)
81144e48:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81144e4c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
81144e50:	0001883a 	nop
}
81144e54:	e037883a 	mov	sp,fp
81144e58:	df000017 	ldw	fp,0(sp)
81144e5c:	dec00104 	addi	sp,sp,4
81144e60:	f800283a 	ret

81144e64 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
81144e64:	defff904 	addi	sp,sp,-28
81144e68:	de00012e 	bgeu	sp,et,81144e70 <alt_ic_irq_disable+0xc>
81144e6c:	003b68fa 	trap	3
81144e70:	df000615 	stw	fp,24(sp)
81144e74:	df000604 	addi	fp,sp,24
81144e78:	e13ffe15 	stw	r4,-8(fp)
81144e7c:	e17fff15 	stw	r5,-4(fp)
81144e80:	e0bfff17 	ldw	r2,-4(fp)
81144e84:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144e88:	0005303a 	rdctl	r2,status
81144e8c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144e90:	e0fffb17 	ldw	r3,-20(fp)
81144e94:	00bfff84 	movi	r2,-2
81144e98:	1884703a 	and	r2,r3,r2
81144e9c:	1001703a 	wrctl	status,r2
  
  return context;
81144ea0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81144ea4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
81144ea8:	00c00044 	movi	r3,1
81144eac:	e0bffa17 	ldw	r2,-24(fp)
81144eb0:	1884983a 	sll	r2,r3,r2
81144eb4:	0084303a 	nor	r2,zero,r2
81144eb8:	1007883a 	mov	r3,r2
81144ebc:	d0a07a17 	ldw	r2,-32280(gp)
81144ec0:	1884703a 	and	r2,r3,r2
81144ec4:	d0a07a15 	stw	r2,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81144ec8:	d0a07a17 	ldw	r2,-32280(gp)
81144ecc:	100170fa 	wrctl	ienable,r2
81144ed0:	e0bffc17 	ldw	r2,-16(fp)
81144ed4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144ed8:	e0bffd17 	ldw	r2,-12(fp)
81144edc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81144ee0:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
81144ee4:	0001883a 	nop
}
81144ee8:	e037883a 	mov	sp,fp
81144eec:	df000017 	ldw	fp,0(sp)
81144ef0:	dec00104 	addi	sp,sp,4
81144ef4:	f800283a 	ret

81144ef8 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
81144ef8:	defffc04 	addi	sp,sp,-16
81144efc:	de00012e 	bgeu	sp,et,81144f04 <alt_ic_irq_enabled+0xc>
81144f00:	003b68fa 	trap	3
81144f04:	df000315 	stw	fp,12(sp)
81144f08:	df000304 	addi	fp,sp,12
81144f0c:	e13ffe15 	stw	r4,-8(fp)
81144f10:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
81144f14:	000530fa 	rdctl	r2,ienable
81144f18:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
81144f1c:	00c00044 	movi	r3,1
81144f20:	e0bfff17 	ldw	r2,-4(fp)
81144f24:	1884983a 	sll	r2,r3,r2
81144f28:	1007883a 	mov	r3,r2
81144f2c:	e0bffd17 	ldw	r2,-12(fp)
81144f30:	1884703a 	and	r2,r3,r2
81144f34:	1004c03a 	cmpne	r2,r2,zero
81144f38:	10803fcc 	andi	r2,r2,255
}
81144f3c:	e037883a 	mov	sp,fp
81144f40:	df000017 	ldw	fp,0(sp)
81144f44:	dec00104 	addi	sp,sp,4
81144f48:	f800283a 	ret

81144f4c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81144f4c:	defff504 	addi	sp,sp,-44
81144f50:	de00012e 	bgeu	sp,et,81144f58 <alt_iic_isr_register+0xc>
81144f54:	003b68fa 	trap	3
81144f58:	dfc00a15 	stw	ra,40(sp)
81144f5c:	df000915 	stw	fp,36(sp)
81144f60:	df000904 	addi	fp,sp,36
81144f64:	e13ffc15 	stw	r4,-16(fp)
81144f68:	e17ffd15 	stw	r5,-12(fp)
81144f6c:	e1bffe15 	stw	r6,-8(fp)
81144f70:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
81144f74:	00bffa84 	movi	r2,-22
81144f78:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
81144f7c:	e0bffd17 	ldw	r2,-12(fp)
81144f80:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81144f84:	e0bff817 	ldw	r2,-32(fp)
81144f88:	10800808 	cmpgei	r2,r2,32
81144f8c:	1000271e 	bne	r2,zero,8114502c <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144f90:	0005303a 	rdctl	r2,status
81144f94:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144f98:	e0fffb17 	ldw	r3,-20(fp)
81144f9c:	00bfff84 	movi	r2,-2
81144fa0:	1884703a 	and	r2,r3,r2
81144fa4:	1001703a 	wrctl	status,r2
  
  return context;
81144fa8:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
81144fac:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
81144fb0:	00a045b4 	movhi	r2,33046
81144fb4:	10991b04 	addi	r2,r2,25708
81144fb8:	e0fff817 	ldw	r3,-32(fp)
81144fbc:	180690fa 	slli	r3,r3,3
81144fc0:	10c5883a 	add	r2,r2,r3
81144fc4:	e0fffe17 	ldw	r3,-8(fp)
81144fc8:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
81144fcc:	00a045b4 	movhi	r2,33046
81144fd0:	10991b04 	addi	r2,r2,25708
81144fd4:	e0fff817 	ldw	r3,-32(fp)
81144fd8:	180690fa 	slli	r3,r3,3
81144fdc:	10c5883a 	add	r2,r2,r3
81144fe0:	10800104 	addi	r2,r2,4
81144fe4:	e0ffff17 	ldw	r3,-4(fp)
81144fe8:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
81144fec:	e0bffe17 	ldw	r2,-8(fp)
81144ff0:	10000526 	beq	r2,zero,81145008 <alt_iic_isr_register+0xbc>
81144ff4:	e0bff817 	ldw	r2,-32(fp)
81144ff8:	100b883a 	mov	r5,r2
81144ffc:	e13ffc17 	ldw	r4,-16(fp)
81145000:	1144dd40 	call	81144dd4 <alt_ic_irq_enable>
81145004:	00000406 	br	81145018 <alt_iic_isr_register+0xcc>
81145008:	e0bff817 	ldw	r2,-32(fp)
8114500c:	100b883a 	mov	r5,r2
81145010:	e13ffc17 	ldw	r4,-16(fp)
81145014:	1144e640 	call	81144e64 <alt_ic_irq_disable>
81145018:	e0bff715 	stw	r2,-36(fp)
8114501c:	e0bffa17 	ldw	r2,-24(fp)
81145020:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145024:	e0bff917 	ldw	r2,-28(fp)
81145028:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8114502c:	e0bff717 	ldw	r2,-36(fp)
}
81145030:	e037883a 	mov	sp,fp
81145034:	dfc00117 	ldw	ra,4(sp)
81145038:	df000017 	ldw	fp,0(sp)
8114503c:	dec00204 	addi	sp,sp,8
81145040:	f800283a 	ret

81145044 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
81145044:	defff904 	addi	sp,sp,-28
81145048:	de00012e 	bgeu	sp,et,81145050 <alt_open_fd+0xc>
8114504c:	003b68fa 	trap	3
81145050:	dfc00615 	stw	ra,24(sp)
81145054:	df000515 	stw	fp,20(sp)
81145058:	df000504 	addi	fp,sp,20
8114505c:	e13ffc15 	stw	r4,-16(fp)
81145060:	e17ffd15 	stw	r5,-12(fp)
81145064:	e1bffe15 	stw	r6,-8(fp)
81145068:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8114506c:	e1bfff17 	ldw	r6,-4(fp)
81145070:	e17ffe17 	ldw	r5,-8(fp)
81145074:	e13ffd17 	ldw	r4,-12(fp)
81145078:	11320a80 	call	811320a8 <open>
8114507c:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
81145080:	e0bffb17 	ldw	r2,-20(fp)
81145084:	10001c16 	blt	r2,zero,811450f8 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
81145088:	00a04574 	movhi	r2,33045
8114508c:	10ae3604 	addi	r2,r2,-18216
81145090:	e0fffb17 	ldw	r3,-20(fp)
81145094:	18c00324 	muli	r3,r3,12
81145098:	10c5883a 	add	r2,r2,r3
8114509c:	10c00017 	ldw	r3,0(r2)
811450a0:	e0bffc17 	ldw	r2,-16(fp)
811450a4:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
811450a8:	00a04574 	movhi	r2,33045
811450ac:	10ae3604 	addi	r2,r2,-18216
811450b0:	e0fffb17 	ldw	r3,-20(fp)
811450b4:	18c00324 	muli	r3,r3,12
811450b8:	10c5883a 	add	r2,r2,r3
811450bc:	10800104 	addi	r2,r2,4
811450c0:	10c00017 	ldw	r3,0(r2)
811450c4:	e0bffc17 	ldw	r2,-16(fp)
811450c8:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
811450cc:	00a04574 	movhi	r2,33045
811450d0:	10ae3604 	addi	r2,r2,-18216
811450d4:	e0fffb17 	ldw	r3,-20(fp)
811450d8:	18c00324 	muli	r3,r3,12
811450dc:	10c5883a 	add	r2,r2,r3
811450e0:	10800204 	addi	r2,r2,8
811450e4:	10c00017 	ldw	r3,0(r2)
811450e8:	e0bffc17 	ldw	r2,-16(fp)
811450ec:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
811450f0:	e13ffb17 	ldw	r4,-20(fp)
811450f4:	113234c0 	call	8113234c <alt_release_fd>
  }
} 
811450f8:	0001883a 	nop
811450fc:	e037883a 	mov	sp,fp
81145100:	dfc00117 	ldw	ra,4(sp)
81145104:	df000017 	ldw	fp,0(sp)
81145108:	dec00204 	addi	sp,sp,8
8114510c:	f800283a 	ret

81145110 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
81145110:	defffb04 	addi	sp,sp,-20
81145114:	de00012e 	bgeu	sp,et,8114511c <alt_io_redirect+0xc>
81145118:	003b68fa 	trap	3
8114511c:	dfc00415 	stw	ra,16(sp)
81145120:	df000315 	stw	fp,12(sp)
81145124:	df000304 	addi	fp,sp,12
81145128:	e13ffd15 	stw	r4,-12(fp)
8114512c:	e17ffe15 	stw	r5,-8(fp)
81145130:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
81145134:	01c07fc4 	movi	r7,511
81145138:	01800044 	movi	r6,1
8114513c:	e17ffd17 	ldw	r5,-12(fp)
81145140:	01204574 	movhi	r4,33045
81145144:	212e3904 	addi	r4,r4,-18204
81145148:	11450440 	call	81145044 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114514c:	01c07fc4 	movi	r7,511
81145150:	000d883a 	mov	r6,zero
81145154:	e17ffe17 	ldw	r5,-8(fp)
81145158:	01204574 	movhi	r4,33045
8114515c:	212e3604 	addi	r4,r4,-18216
81145160:	11450440 	call	81145044 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
81145164:	01c07fc4 	movi	r7,511
81145168:	01800044 	movi	r6,1
8114516c:	e17fff17 	ldw	r5,-4(fp)
81145170:	01204574 	movhi	r4,33045
81145174:	212e3c04 	addi	r4,r4,-18192
81145178:	11450440 	call	81145044 <alt_open_fd>
}  
8114517c:	0001883a 	nop
81145180:	e037883a 	mov	sp,fp
81145184:	dfc00117 	ldw	ra,4(sp)
81145188:	df000017 	ldw	fp,0(sp)
8114518c:	dec00204 	addi	sp,sp,8
81145190:	f800283a 	ret

81145194 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
81145194:	defff204 	addi	sp,sp,-56
81145198:	de00012e 	bgeu	sp,et,811451a0 <alt_printf+0xc>
8114519c:	003b68fa 	trap	3
811451a0:	dfc00a15 	stw	ra,40(sp)
811451a4:	df000915 	stw	fp,36(sp)
811451a8:	df000904 	addi	fp,sp,36
811451ac:	e13fff15 	stw	r4,-4(fp)
811451b0:	e1400215 	stw	r5,8(fp)
811451b4:	e1800315 	stw	r6,12(fp)
811451b8:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
811451bc:	e0800204 	addi	r2,fp,8
811451c0:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
811451c4:	e0bfff17 	ldw	r2,-4(fp)
811451c8:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
811451cc:	00006f06 	br	8114538c <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
811451d0:	e0bff807 	ldb	r2,-32(fp)
811451d4:	10800960 	cmpeqi	r2,r2,37
811451d8:	1000041e 	bne	r2,zero,811451ec <alt_printf+0x58>
        {
            alt_putchar(c);
811451dc:	e0bff807 	ldb	r2,-32(fp)
811451e0:	1009883a 	mov	r4,r2
811451e4:	11453c80 	call	811453c8 <alt_putchar>
811451e8:	00006806 	br	8114538c <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
811451ec:	e0bff717 	ldw	r2,-36(fp)
811451f0:	10c00044 	addi	r3,r2,1
811451f4:	e0fff715 	stw	r3,-36(fp)
811451f8:	10800003 	ldbu	r2,0(r2)
811451fc:	e0bff805 	stb	r2,-32(fp)
81145200:	e0bff807 	ldb	r2,-32(fp)
81145204:	10006926 	beq	r2,zero,811453ac <alt_printf+0x218>
            {
                if (c == '%')
81145208:	e0bff807 	ldb	r2,-32(fp)
8114520c:	10800958 	cmpnei	r2,r2,37
81145210:	1000041e 	bne	r2,zero,81145224 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
81145214:	e0bff807 	ldb	r2,-32(fp)
81145218:	1009883a 	mov	r4,r2
8114521c:	11453c80 	call	811453c8 <alt_putchar>
81145220:	00005a06 	br	8114538c <alt_printf+0x1f8>
                } 
                else if (c == 'c')
81145224:	e0bff807 	ldb	r2,-32(fp)
81145228:	108018d8 	cmpnei	r2,r2,99
8114522c:	1000081e 	bne	r2,zero,81145250 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
81145230:	e0bffe17 	ldw	r2,-8(fp)
81145234:	10c00104 	addi	r3,r2,4
81145238:	e0fffe15 	stw	r3,-8(fp)
8114523c:	10800017 	ldw	r2,0(r2)
81145240:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
81145244:	e13ffd17 	ldw	r4,-12(fp)
81145248:	11453c80 	call	811453c8 <alt_putchar>
8114524c:	00004f06 	br	8114538c <alt_printf+0x1f8>
                }
                else if (c == 'x')
81145250:	e0bff807 	ldb	r2,-32(fp)
81145254:	10801e18 	cmpnei	r2,r2,120
81145258:	1000341e 	bne	r2,zero,8114532c <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114525c:	e0bffe17 	ldw	r2,-8(fp)
81145260:	10c00104 	addi	r3,r2,4
81145264:	e0fffe15 	stw	r3,-8(fp)
81145268:	10800017 	ldw	r2,0(r2)
8114526c:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
81145270:	e0bffb17 	ldw	r2,-20(fp)
81145274:	1000031e 	bne	r2,zero,81145284 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
81145278:	01000c04 	movi	r4,48
8114527c:	11453c80 	call	811453c8 <alt_putchar>
                        continue;
81145280:	00004206 	br	8114538c <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
81145284:	00800704 	movi	r2,28
81145288:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8114528c:	00000306 	br	8114529c <alt_printf+0x108>
                        digit_shift -= 4;
81145290:	e0bff917 	ldw	r2,-28(fp)
81145294:	10bfff04 	addi	r2,r2,-4
81145298:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8114529c:	00c003c4 	movi	r3,15
811452a0:	e0bff917 	ldw	r2,-28(fp)
811452a4:	1884983a 	sll	r2,r3,r2
811452a8:	1007883a 	mov	r3,r2
811452ac:	e0bffb17 	ldw	r2,-20(fp)
811452b0:	1884703a 	and	r2,r3,r2
811452b4:	103ff626 	beq	r2,zero,81145290 <__reset+0xfb125290>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
811452b8:	00001906 	br	81145320 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
811452bc:	00c003c4 	movi	r3,15
811452c0:	e0bff917 	ldw	r2,-28(fp)
811452c4:	1884983a 	sll	r2,r3,r2
811452c8:	1007883a 	mov	r3,r2
811452cc:	e0bffb17 	ldw	r2,-20(fp)
811452d0:	1886703a 	and	r3,r3,r2
811452d4:	e0bff917 	ldw	r2,-28(fp)
811452d8:	1884d83a 	srl	r2,r3,r2
811452dc:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
811452e0:	e0bffc17 	ldw	r2,-16(fp)
811452e4:	108002a8 	cmpgeui	r2,r2,10
811452e8:	1000041e 	bne	r2,zero,811452fc <alt_printf+0x168>
                            c = '0' + digit;
811452ec:	e0bffc17 	ldw	r2,-16(fp)
811452f0:	10800c04 	addi	r2,r2,48
811452f4:	e0bff805 	stb	r2,-32(fp)
811452f8:	00000306 	br	81145308 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
811452fc:	e0bffc17 	ldw	r2,-16(fp)
81145300:	108015c4 	addi	r2,r2,87
81145304:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
81145308:	e0bff807 	ldb	r2,-32(fp)
8114530c:	1009883a 	mov	r4,r2
81145310:	11453c80 	call	811453c8 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81145314:	e0bff917 	ldw	r2,-28(fp)
81145318:	10bfff04 	addi	r2,r2,-4
8114531c:	e0bff915 	stw	r2,-28(fp)
81145320:	e0bff917 	ldw	r2,-28(fp)
81145324:	103fe50e 	bge	r2,zero,811452bc <__reset+0xfb1252bc>
81145328:	00001806 	br	8114538c <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8114532c:	e0bff807 	ldb	r2,-32(fp)
81145330:	10801cd8 	cmpnei	r2,r2,115
81145334:	1000151e 	bne	r2,zero,8114538c <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81145338:	e0bffe17 	ldw	r2,-8(fp)
8114533c:	10c00104 	addi	r3,r2,4
81145340:	e0fffe15 	stw	r3,-8(fp)
81145344:	10800017 	ldw	r2,0(r2)
81145348:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114534c:	00000906 	br	81145374 <alt_printf+0x1e0>
                      alt_putchar(*s++);
81145350:	e0bffa17 	ldw	r2,-24(fp)
81145354:	10c00044 	addi	r3,r2,1
81145358:	e0fffa15 	stw	r3,-24(fp)
8114535c:	10800003 	ldbu	r2,0(r2)
81145360:	10803fcc 	andi	r2,r2,255
81145364:	1080201c 	xori	r2,r2,128
81145368:	10bfe004 	addi	r2,r2,-128
8114536c:	1009883a 	mov	r4,r2
81145370:	11453c80 	call	811453c8 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
81145374:	e0bffa17 	ldw	r2,-24(fp)
81145378:	10800003 	ldbu	r2,0(r2)
8114537c:	10803fcc 	andi	r2,r2,255
81145380:	1080201c 	xori	r2,r2,128
81145384:	10bfe004 	addi	r2,r2,-128
81145388:	103ff11e 	bne	r2,zero,81145350 <__reset+0xfb125350>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8114538c:	e0bff717 	ldw	r2,-36(fp)
81145390:	10c00044 	addi	r3,r2,1
81145394:	e0fff715 	stw	r3,-36(fp)
81145398:	10800003 	ldbu	r2,0(r2)
8114539c:	e0bff805 	stb	r2,-32(fp)
811453a0:	e0bff807 	ldb	r2,-32(fp)
811453a4:	103f8a1e 	bne	r2,zero,811451d0 <__reset+0xfb1251d0>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
811453a8:	00000106 	br	811453b0 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
811453ac:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
811453b0:	0001883a 	nop
811453b4:	e037883a 	mov	sp,fp
811453b8:	dfc00117 	ldw	ra,4(sp)
811453bc:	df000017 	ldw	fp,0(sp)
811453c0:	dec00504 	addi	sp,sp,20
811453c4:	f800283a 	ret

811453c8 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
811453c8:	defffd04 	addi	sp,sp,-12
811453cc:	de00012e 	bgeu	sp,et,811453d4 <alt_putchar+0xc>
811453d0:	003b68fa 	trap	3
811453d4:	dfc00215 	stw	ra,8(sp)
811453d8:	df000115 	stw	fp,4(sp)
811453dc:	df000104 	addi	fp,sp,4
811453e0:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
811453e4:	d0a00517 	ldw	r2,-32748(gp)
811453e8:	10800217 	ldw	r2,8(r2)
811453ec:	100b883a 	mov	r5,r2
811453f0:	e13fff17 	ldw	r4,-4(fp)
811453f4:	111c8440 	call	8111c844 <putc>
#endif
#endif
}
811453f8:	e037883a 	mov	sp,fp
811453fc:	dfc00117 	ldw	ra,4(sp)
81145400:	df000017 	ldw	fp,0(sp)
81145404:	dec00204 	addi	sp,sp,8
81145408:	f800283a 	ret

8114540c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8114540c:	deffff04 	addi	sp,sp,-4
81145410:	de00012e 	bgeu	sp,et,81145418 <altera_nios2_gen2_irq_init+0xc>
81145414:	003b68fa 	trap	3
81145418:	df000015 	stw	fp,0(sp)
8114541c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
81145420:	000170fa 	wrctl	ienable,zero
}
81145424:	0001883a 	nop
81145428:	e037883a 	mov	sp,fp
8114542c:	df000017 	ldw	fp,0(sp)
81145430:	dec00104 	addi	sp,sp,4
81145434:	f800283a 	ret

81145438 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81145438:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8114543c:	de002436 	bltu	sp,et,811454d0 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81145440:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
81145444:	d1209c17 	ldw	r4,-32144(gp)

      stw ra,  0(sp)
81145448:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8114544c:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81145450:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
81145454:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81145458:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8114545c:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
81145460:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
81145464:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
81145468:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8114546c:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
81145470:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
81145474:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81145478:	11456d40 	call	811456d4 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8114547c:	d1209617 	ldw	r4,-32168(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
81145480:	d1608d87 	ldb	r5,-32202(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
81145484:	d1209c15 	stw	r4,-32144(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
81145488:	d1608dc5 	stb	r5,-32201(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8114548c:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
81145490:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
81145494:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
81145498:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8114549c:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
811454a0:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
811454a4:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
811454a8:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
811454ac:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
811454b0:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
811454b4:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
811454b8:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
811454bc:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
811454c0:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
811454c4:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
811454c8:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
811454cc:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
811454d0:	003da0fa 	break	3

811454d4 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
811454d4:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
811454d8:	047fff84 	movi	r17,-2
      and   r18, r18, r17
811454dc:	9464703a 	and	r18,r18,r17
      wrctl status, r18
811454e0:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
811454e4:	11456d40 	call	811456d4 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
811454e8:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
811454ec:	d4a08b05 	stb	r18,-32212(gp)

      /*
       * start execution of the new task.
       */

      br 9b
811454f0:	003fe206 	br	8114547c <__reset+0xfb12547c>

811454f4 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
811454f4:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
811454f8:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
811454fc:	10800054 	ori	r2,r2,1
      wrctl status, r2
81145500:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
81145504:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81145508:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8114550c:	dec00204 	addi	sp,sp,8

      callr r2
81145510:	103ee83a 	callr	r2

      nop
81145514:	0001883a 	nop

81145518 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81145518:	defff704 	addi	sp,sp,-36
8114551c:	de00012e 	bgeu	sp,et,81145524 <OSTaskStkInit+0xc>
81145520:	003b68fa 	trap	3
81145524:	dfc00815 	stw	ra,32(sp)
81145528:	df000715 	stw	fp,28(sp)
8114552c:	df000704 	addi	fp,sp,28
81145530:	e13ffc15 	stw	r4,-16(fp)
81145534:	e17ffd15 	stw	r5,-12(fp)
81145538:	e1bffe15 	stw	r6,-8(fp)
8114553c:	3805883a 	mov	r2,r7
81145540:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
81145544:	e0fffe17 	ldw	r3,-8(fp)
81145548:	00bfff04 	movi	r2,-4
8114554c:	1884703a 	and	r2,r3,r2
81145550:	10bef704 	addi	r2,r2,-1060
81145554:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81145558:	01810904 	movi	r6,1060
8114555c:	000b883a 	mov	r5,zero
81145560:	e13ff917 	ldw	r4,-28(fp)
81145564:	111c5900 	call	8111c590 <memset>
81145568:	e0bff917 	ldw	r2,-28(fp)
8114556c:	10c0bb04 	addi	r3,r2,748
81145570:	e0bff917 	ldw	r2,-28(fp)
81145574:	10c00115 	stw	r3,4(r2)
81145578:	e0bff917 	ldw	r2,-28(fp)
8114557c:	10c0d504 	addi	r3,r2,852
81145580:	e0bff917 	ldw	r2,-28(fp)
81145584:	10c00215 	stw	r3,8(r2)
81145588:	e0bff917 	ldw	r2,-28(fp)
8114558c:	10c0ef04 	addi	r3,r2,956
81145590:	e0bff917 	ldw	r2,-28(fp)
81145594:	10c00315 	stw	r3,12(r2)
81145598:	e0fff917 	ldw	r3,-28(fp)
8114559c:	00a04574 	movhi	r2,33045
811455a0:	10abcf04 	addi	r2,r2,-20676
811455a4:	18800d15 	stw	r2,52(r3)
811455a8:	e0bff917 	ldw	r2,-28(fp)
811455ac:	00c00044 	movi	r3,1
811455b0:	10c02915 	stw	r3,164(r2)
811455b4:	10002a15 	stw	zero,168(r2)
811455b8:	e0bff917 	ldw	r2,-28(fp)
811455bc:	00ccc384 	movi	r3,13070
811455c0:	10c02b0d 	sth	r3,172(r2)
811455c4:	e0bff917 	ldw	r2,-28(fp)
811455c8:	00eaf344 	movi	r3,-21555
811455cc:	10c02b8d 	sth	r3,174(r2)
811455d0:	e0bff917 	ldw	r2,-28(fp)
811455d4:	00c48d04 	movi	r3,4660
811455d8:	10c02c0d 	sth	r3,176(r2)
811455dc:	e0bff917 	ldw	r2,-28(fp)
811455e0:	00f99b44 	movi	r3,-6547
811455e4:	10c02c8d 	sth	r3,178(r2)
811455e8:	e0bff917 	ldw	r2,-28(fp)
811455ec:	00f7bb04 	movi	r3,-8468
811455f0:	10c02d0d 	sth	r3,180(r2)
811455f4:	e0bff917 	ldw	r2,-28(fp)
811455f8:	00c00144 	movi	r3,5
811455fc:	10c02d8d 	sth	r3,182(r2)
81145600:	e0bff917 	ldw	r2,-28(fp)
81145604:	00c002c4 	movi	r3,11
81145608:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114560c:	e0bff917 	ldw	r2,-28(fp)
81145610:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
81145614:	e0bffa17 	ldw	r2,-24(fp)
81145618:	10bff304 	addi	r2,r2,-52
8114561c:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
81145620:	e0bffb17 	ldw	r2,-20(fp)
81145624:	10800c04 	addi	r2,r2,48
81145628:	e0fffc17 	ldw	r3,-16(fp)
8114562c:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
81145630:	e0bffb17 	ldw	r2,-20(fp)
81145634:	10800b04 	addi	r2,r2,44
81145638:	e0fffd17 	ldw	r3,-12(fp)
8114563c:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
81145640:	e0bffb17 	ldw	r2,-20(fp)
81145644:	10800a04 	addi	r2,r2,40
81145648:	e0fff917 	ldw	r3,-28(fp)
8114564c:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
81145650:	00a04534 	movhi	r2,33044
81145654:	10953d04 	addi	r2,r2,21748
81145658:	10c00104 	addi	r3,r2,4
8114565c:	e0bffb17 	ldw	r2,-20(fp)
81145660:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
81145664:	e0bffb17 	ldw	r2,-20(fp)
}
81145668:	e037883a 	mov	sp,fp
8114566c:	dfc00117 	ldw	ra,4(sp)
81145670:	df000017 	ldw	fp,0(sp)
81145674:	dec00204 	addi	sp,sp,8
81145678:	f800283a 	ret

8114567c <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8114567c:	defffe04 	addi	sp,sp,-8
81145680:	de00012e 	bgeu	sp,et,81145688 <OSTaskCreateHook+0xc>
81145684:	003b68fa 	trap	3
81145688:	df000115 	stw	fp,4(sp)
8114568c:	df000104 	addi	fp,sp,4
81145690:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
81145694:	0001883a 	nop
81145698:	e037883a 	mov	sp,fp
8114569c:	df000017 	ldw	fp,0(sp)
811456a0:	dec00104 	addi	sp,sp,4
811456a4:	f800283a 	ret

811456a8 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
811456a8:	defffe04 	addi	sp,sp,-8
811456ac:	de00012e 	bgeu	sp,et,811456b4 <OSTaskDelHook+0xc>
811456b0:	003b68fa 	trap	3
811456b4:	df000115 	stw	fp,4(sp)
811456b8:	df000104 	addi	fp,sp,4
811456bc:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
811456c0:	0001883a 	nop
811456c4:	e037883a 	mov	sp,fp
811456c8:	df000017 	ldw	fp,0(sp)
811456cc:	dec00104 	addi	sp,sp,4
811456d0:	f800283a 	ret

811456d4 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
811456d4:	deffff04 	addi	sp,sp,-4
811456d8:	de00012e 	bgeu	sp,et,811456e0 <OSTaskSwHook+0xc>
811456dc:	003b68fa 	trap	3
811456e0:	df000015 	stw	fp,0(sp)
811456e4:	d839883a 	mov	fp,sp
}
811456e8:	0001883a 	nop
811456ec:	e037883a 	mov	sp,fp
811456f0:	df000017 	ldw	fp,0(sp)
811456f4:	dec00104 	addi	sp,sp,4
811456f8:	f800283a 	ret

811456fc <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
811456fc:	deffff04 	addi	sp,sp,-4
81145700:	de00012e 	bgeu	sp,et,81145708 <OSTaskStatHook+0xc>
81145704:	003b68fa 	trap	3
81145708:	df000015 	stw	fp,0(sp)
8114570c:	d839883a 	mov	fp,sp
}
81145710:	0001883a 	nop
81145714:	e037883a 	mov	sp,fp
81145718:	df000017 	ldw	fp,0(sp)
8114571c:	dec00104 	addi	sp,sp,4
81145720:	f800283a 	ret

81145724 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
81145724:	defffe04 	addi	sp,sp,-8
81145728:	de00012e 	bgeu	sp,et,81145730 <OSTimeTickHook+0xc>
8114572c:	003b68fa 	trap	3
81145730:	dfc00115 	stw	ra,4(sp)
81145734:	df000015 	stw	fp,0(sp)
81145738:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114573c:	d0a0b00b 	ldhu	r2,-32064(gp)
81145740:	10800044 	addi	r2,r2,1
81145744:	d0a0b00d 	sth	r2,-32064(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
81145748:	d0a0b00b 	ldhu	r2,-32064(gp)
8114574c:	10bfffcc 	andi	r2,r2,65535
81145750:	10807d30 	cmpltui	r2,r2,500
81145754:	1000021e 	bne	r2,zero,81145760 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
81145758:	d020b00d 	sth	zero,-32064(gp)
        OSTmrSignal();
8114575c:	113c0740 	call	8113c074 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
81145760:	0001883a 	nop
81145764:	e037883a 	mov	sp,fp
81145768:	dfc00117 	ldw	ra,4(sp)
8114576c:	df000017 	ldw	fp,0(sp)
81145770:	dec00204 	addi	sp,sp,8
81145774:	f800283a 	ret

81145778 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
81145778:	deffff04 	addi	sp,sp,-4
8114577c:	de00012e 	bgeu	sp,et,81145784 <OSInitHookBegin+0xc>
81145780:	003b68fa 	trap	3
81145784:	df000015 	stw	fp,0(sp)
81145788:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8114578c:	d020b00d 	sth	zero,-32064(gp)
#endif
}
81145790:	0001883a 	nop
81145794:	e037883a 	mov	sp,fp
81145798:	df000017 	ldw	fp,0(sp)
8114579c:	dec00104 	addi	sp,sp,4
811457a0:	f800283a 	ret

811457a4 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
811457a4:	deffff04 	addi	sp,sp,-4
811457a8:	de00012e 	bgeu	sp,et,811457b0 <OSInitHookEnd+0xc>
811457ac:	003b68fa 	trap	3
811457b0:	df000015 	stw	fp,0(sp)
811457b4:	d839883a 	mov	fp,sp
}
811457b8:	0001883a 	nop
811457bc:	e037883a 	mov	sp,fp
811457c0:	df000017 	ldw	fp,0(sp)
811457c4:	dec00104 	addi	sp,sp,4
811457c8:	f800283a 	ret

811457cc <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
811457cc:	deffff04 	addi	sp,sp,-4
811457d0:	de00012e 	bgeu	sp,et,811457d8 <OSTaskIdleHook+0xc>
811457d4:	003b68fa 	trap	3
811457d8:	df000015 	stw	fp,0(sp)
811457dc:	d839883a 	mov	fp,sp
}
811457e0:	0001883a 	nop
811457e4:	e037883a 	mov	sp,fp
811457e8:	df000017 	ldw	fp,0(sp)
811457ec:	dec00104 	addi	sp,sp,4
811457f0:	f800283a 	ret

811457f4 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
811457f4:	defffe04 	addi	sp,sp,-8
811457f8:	de00012e 	bgeu	sp,et,81145800 <OSTCBInitHook+0xc>
811457fc:	003b68fa 	trap	3
81145800:	df000115 	stw	fp,4(sp)
81145804:	df000104 	addi	fp,sp,4
81145808:	e13fff15 	stw	r4,-4(fp)
}
8114580c:	0001883a 	nop
81145810:	e037883a 	mov	sp,fp
81145814:	df000017 	ldw	fp,0(sp)
81145818:	dec00104 	addi	sp,sp,4
8114581c:	f800283a 	ret

81145820 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
81145820:	defffe04 	addi	sp,sp,-8
81145824:	de00012e 	bgeu	sp,et,8114582c <alt_exception_cause_generated_bad_addr+0xc>
81145828:	003b68fa 	trap	3
8114582c:	df000115 	stw	fp,4(sp)
81145830:	df000104 	addi	fp,sp,4
81145834:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
81145838:	e0bfff17 	ldw	r2,-4(fp)
8114583c:	10bffe84 	addi	r2,r2,-6
81145840:	10c00428 	cmpgeui	r3,r2,16
81145844:	18001a1e 	bne	r3,zero,811458b0 <alt_exception_cause_generated_bad_addr+0x90>
81145848:	100690ba 	slli	r3,r2,2
8114584c:	00a04534 	movhi	r2,33044
81145850:	10961804 	addi	r2,r2,22624
81145854:	1885883a 	add	r2,r3,r2
81145858:	10800017 	ldw	r2,0(r2)
8114585c:	1000683a 	jmp	r2
81145860:	811458a0 	cmpeqi	r4,r16,20834
81145864:	811458a0 	cmpeqi	r4,r16,20834
81145868:	811458b0 	cmpltui	r4,r16,20834
8114586c:	811458b0 	cmpltui	r4,r16,20834
81145870:	811458b0 	cmpltui	r4,r16,20834
81145874:	811458a0 	cmpeqi	r4,r16,20834
81145878:	811458a8 	cmpgeui	r4,r16,20834
8114587c:	811458b0 	cmpltui	r4,r16,20834
81145880:	811458a0 	cmpeqi	r4,r16,20834
81145884:	811458a0 	cmpeqi	r4,r16,20834
81145888:	811458b0 	cmpltui	r4,r16,20834
8114588c:	811458a0 	cmpeqi	r4,r16,20834
81145890:	811458a8 	cmpgeui	r4,r16,20834
81145894:	811458b0 	cmpltui	r4,r16,20834
81145898:	811458b0 	cmpltui	r4,r16,20834
8114589c:	811458a0 	cmpeqi	r4,r16,20834
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
811458a0:	00800044 	movi	r2,1
811458a4:	00000306 	br	811458b4 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
811458a8:	0005883a 	mov	r2,zero
811458ac:	00000106 	br	811458b4 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
811458b0:	0005883a 	mov	r2,zero
  }
}
811458b4:	e037883a 	mov	sp,fp
811458b8:	df000017 	ldw	fp,0(sp)
811458bc:	dec00104 	addi	sp,sp,4
811458c0:	f800283a 	ret

811458c4 <exit>:
811458c4:	defffe04 	addi	sp,sp,-8
811458c8:	000b883a 	mov	r5,zero
811458cc:	de00012e 	bgeu	sp,et,811458d4 <exit+0x10>
811458d0:	003b68fa 	trap	3
811458d4:	dc000015 	stw	r16,0(sp)
811458d8:	dfc00115 	stw	ra,4(sp)
811458dc:	2021883a 	mov	r16,r4
811458e0:	1145a6c0 	call	81145a6c <__call_exitprocs>
811458e4:	00a04574 	movhi	r2,33045
811458e8:	10b34d04 	addi	r2,r2,-13004
811458ec:	11000017 	ldw	r4,0(r2)
811458f0:	20800f17 	ldw	r2,60(r4)
811458f4:	10000126 	beq	r2,zero,811458fc <exit+0x38>
811458f8:	103ee83a 	callr	r2
811458fc:	8009883a 	mov	r4,r16
81145900:	1145bf40 	call	81145bf4 <_exit>

81145904 <memcmp>:
81145904:	01c000c4 	movi	r7,3
81145908:	3980192e 	bgeu	r7,r6,81145970 <memcmp+0x6c>
8114590c:	2144b03a 	or	r2,r4,r5
81145910:	11c4703a 	and	r2,r2,r7
81145914:	10000f26 	beq	r2,zero,81145954 <memcmp+0x50>
81145918:	20800003 	ldbu	r2,0(r4)
8114591c:	28c00003 	ldbu	r3,0(r5)
81145920:	10c0151e 	bne	r2,r3,81145978 <memcmp+0x74>
81145924:	31bfff84 	addi	r6,r6,-2
81145928:	01ffffc4 	movi	r7,-1
8114592c:	00000406 	br	81145940 <memcmp+0x3c>
81145930:	20800003 	ldbu	r2,0(r4)
81145934:	28c00003 	ldbu	r3,0(r5)
81145938:	31bfffc4 	addi	r6,r6,-1
8114593c:	10c00e1e 	bne	r2,r3,81145978 <memcmp+0x74>
81145940:	21000044 	addi	r4,r4,1
81145944:	29400044 	addi	r5,r5,1
81145948:	31fff91e 	bne	r6,r7,81145930 <__reset+0xfb125930>
8114594c:	0005883a 	mov	r2,zero
81145950:	f800283a 	ret
81145954:	20c00017 	ldw	r3,0(r4)
81145958:	28800017 	ldw	r2,0(r5)
8114595c:	18bfee1e 	bne	r3,r2,81145918 <__reset+0xfb125918>
81145960:	31bfff04 	addi	r6,r6,-4
81145964:	21000104 	addi	r4,r4,4
81145968:	29400104 	addi	r5,r5,4
8114596c:	39bff936 	bltu	r7,r6,81145954 <__reset+0xfb125954>
81145970:	303fe91e 	bne	r6,zero,81145918 <__reset+0xfb125918>
81145974:	003ff506 	br	8114594c <__reset+0xfb12594c>
81145978:	10c5c83a 	sub	r2,r2,r3
8114597c:	f800283a 	ret

81145980 <strncpy>:
81145980:	2906b03a 	or	r3,r5,r4
81145984:	18c000cc 	andi	r3,r3,3
81145988:	2005883a 	mov	r2,r4
8114598c:	18002c1e 	bne	r3,zero,81145a40 <strncpy+0xc0>
81145990:	010000c4 	movi	r4,3
81145994:	21802a2e 	bgeu	r4,r6,81145a40 <strncpy+0xc0>
81145998:	033fbff4 	movhi	r12,65279
8114599c:	02e02074 	movhi	r11,32897
811459a0:	633fbfc4 	addi	r12,r12,-257
811459a4:	5ae02004 	addi	r11,r11,-32640
811459a8:	100f883a 	mov	r7,r2
811459ac:	2a000017 	ldw	r8,0(r5)
811459b0:	3815883a 	mov	r10,r7
811459b4:	4313883a 	add	r9,r8,r12
811459b8:	0206303a 	nor	r3,zero,r8
811459bc:	48c6703a 	and	r3,r9,r3
811459c0:	1ac6703a 	and	r3,r3,r11
811459c4:	1800261e 	bne	r3,zero,81145a60 <strncpy+0xe0>
811459c8:	39c00104 	addi	r7,r7,4
811459cc:	52000015 	stw	r8,0(r10)
811459d0:	31bfff04 	addi	r6,r6,-4
811459d4:	3811883a 	mov	r8,r7
811459d8:	29400104 	addi	r5,r5,4
811459dc:	21bff336 	bltu	r4,r6,811459ac <__reset+0xfb1259ac>
811459e0:	30001e26 	beq	r6,zero,81145a5c <strncpy+0xdc>
811459e4:	29c00003 	ldbu	r7,0(r5)
811459e8:	31bfffc4 	addi	r6,r6,-1
811459ec:	40c00044 	addi	r3,r8,1
811459f0:	41c00005 	stb	r7,0(r8)
811459f4:	39c03fcc 	andi	r7,r7,255
811459f8:	39c0201c 	xori	r7,r7,128
811459fc:	39ffe004 	addi	r7,r7,-128
81145a00:	29400044 	addi	r5,r5,1
81145a04:	38001026 	beq	r7,zero,81145a48 <strncpy+0xc8>
81145a08:	1811883a 	mov	r8,r3
81145a0c:	00000906 	br	81145a34 <strncpy+0xb4>
81145a10:	29c00003 	ldbu	r7,0(r5)
81145a14:	31bfffc4 	addi	r6,r6,-1
81145a18:	29400044 	addi	r5,r5,1
81145a1c:	41c00005 	stb	r7,0(r8)
81145a20:	39c03fcc 	andi	r7,r7,255
81145a24:	39c0201c 	xori	r7,r7,128
81145a28:	39ffe004 	addi	r7,r7,-128
81145a2c:	1811883a 	mov	r8,r3
81145a30:	38000526 	beq	r7,zero,81145a48 <strncpy+0xc8>
81145a34:	18c00044 	addi	r3,r3,1
81145a38:	303ff51e 	bne	r6,zero,81145a10 <__reset+0xfb125a10>
81145a3c:	f800283a 	ret
81145a40:	1011883a 	mov	r8,r2
81145a44:	003fe606 	br	811459e0 <__reset+0xfb1259e0>
81145a48:	30000726 	beq	r6,zero,81145a68 <strncpy+0xe8>
81145a4c:	198d883a 	add	r6,r3,r6
81145a50:	18000005 	stb	zero,0(r3)
81145a54:	18c00044 	addi	r3,r3,1
81145a58:	19bffd1e 	bne	r3,r6,81145a50 <__reset+0xfb125a50>
81145a5c:	f800283a 	ret
81145a60:	3811883a 	mov	r8,r7
81145a64:	003fdf06 	br	811459e4 <__reset+0xfb1259e4>
81145a68:	f800283a 	ret

81145a6c <__call_exitprocs>:
81145a6c:	defff504 	addi	sp,sp,-44
81145a70:	de00012e 	bgeu	sp,et,81145a78 <__call_exitprocs+0xc>
81145a74:	003b68fa 	trap	3
81145a78:	df000915 	stw	fp,36(sp)
81145a7c:	dd400615 	stw	r21,24(sp)
81145a80:	dc800315 	stw	r18,12(sp)
81145a84:	dfc00a15 	stw	ra,40(sp)
81145a88:	ddc00815 	stw	r23,32(sp)
81145a8c:	dd800715 	stw	r22,28(sp)
81145a90:	dd000515 	stw	r20,20(sp)
81145a94:	dcc00415 	stw	r19,16(sp)
81145a98:	dc400215 	stw	r17,8(sp)
81145a9c:	dc000115 	stw	r16,4(sp)
81145aa0:	d9000015 	stw	r4,0(sp)
81145aa4:	2839883a 	mov	fp,r5
81145aa8:	04800044 	movi	r18,1
81145aac:	057fffc4 	movi	r21,-1
81145ab0:	00a04574 	movhi	r2,33045
81145ab4:	10b34d04 	addi	r2,r2,-13004
81145ab8:	12000017 	ldw	r8,0(r2)
81145abc:	45005217 	ldw	r20,328(r8)
81145ac0:	44c05204 	addi	r19,r8,328
81145ac4:	a0001c26 	beq	r20,zero,81145b38 <__call_exitprocs+0xcc>
81145ac8:	a0800117 	ldw	r2,4(r20)
81145acc:	15ffffc4 	addi	r23,r2,-1
81145ad0:	b8000d16 	blt	r23,zero,81145b08 <__call_exitprocs+0x9c>
81145ad4:	14000044 	addi	r16,r2,1
81145ad8:	8421883a 	add	r16,r16,r16
81145adc:	8421883a 	add	r16,r16,r16
81145ae0:	84402004 	addi	r17,r16,128
81145ae4:	a463883a 	add	r17,r20,r17
81145ae8:	a421883a 	add	r16,r20,r16
81145aec:	e0001e26 	beq	fp,zero,81145b68 <__call_exitprocs+0xfc>
81145af0:	80804017 	ldw	r2,256(r16)
81145af4:	e0801c26 	beq	fp,r2,81145b68 <__call_exitprocs+0xfc>
81145af8:	bdffffc4 	addi	r23,r23,-1
81145afc:	843fff04 	addi	r16,r16,-4
81145b00:	8c7fff04 	addi	r17,r17,-4
81145b04:	bd7ff91e 	bne	r23,r21,81145aec <__reset+0xfb125aec>
81145b08:	00800034 	movhi	r2,0
81145b0c:	10800004 	addi	r2,r2,0
81145b10:	10000926 	beq	r2,zero,81145b38 <__call_exitprocs+0xcc>
81145b14:	a0800117 	ldw	r2,4(r20)
81145b18:	1000301e 	bne	r2,zero,81145bdc <__call_exitprocs+0x170>
81145b1c:	a0800017 	ldw	r2,0(r20)
81145b20:	10003226 	beq	r2,zero,81145bec <__call_exitprocs+0x180>
81145b24:	a009883a 	mov	r4,r20
81145b28:	98800015 	stw	r2,0(r19)
81145b2c:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
81145b30:	9d000017 	ldw	r20,0(r19)
81145b34:	a03fe41e 	bne	r20,zero,81145ac8 <__reset+0xfb125ac8>
81145b38:	dfc00a17 	ldw	ra,40(sp)
81145b3c:	df000917 	ldw	fp,36(sp)
81145b40:	ddc00817 	ldw	r23,32(sp)
81145b44:	dd800717 	ldw	r22,28(sp)
81145b48:	dd400617 	ldw	r21,24(sp)
81145b4c:	dd000517 	ldw	r20,20(sp)
81145b50:	dcc00417 	ldw	r19,16(sp)
81145b54:	dc800317 	ldw	r18,12(sp)
81145b58:	dc400217 	ldw	r17,8(sp)
81145b5c:	dc000117 	ldw	r16,4(sp)
81145b60:	dec00b04 	addi	sp,sp,44
81145b64:	f800283a 	ret
81145b68:	a0800117 	ldw	r2,4(r20)
81145b6c:	80c00017 	ldw	r3,0(r16)
81145b70:	10bfffc4 	addi	r2,r2,-1
81145b74:	15c01426 	beq	r2,r23,81145bc8 <__call_exitprocs+0x15c>
81145b78:	80000015 	stw	zero,0(r16)
81145b7c:	183fde26 	beq	r3,zero,81145af8 <__reset+0xfb125af8>
81145b80:	95c8983a 	sll	r4,r18,r23
81145b84:	a0806217 	ldw	r2,392(r20)
81145b88:	a5800117 	ldw	r22,4(r20)
81145b8c:	2084703a 	and	r2,r4,r2
81145b90:	10000b26 	beq	r2,zero,81145bc0 <__call_exitprocs+0x154>
81145b94:	a0806317 	ldw	r2,396(r20)
81145b98:	2088703a 	and	r4,r4,r2
81145b9c:	20000c1e 	bne	r4,zero,81145bd0 <__call_exitprocs+0x164>
81145ba0:	89400017 	ldw	r5,0(r17)
81145ba4:	d9000017 	ldw	r4,0(sp)
81145ba8:	183ee83a 	callr	r3
81145bac:	a0800117 	ldw	r2,4(r20)
81145bb0:	15bfbf1e 	bne	r2,r22,81145ab0 <__reset+0xfb125ab0>
81145bb4:	98800017 	ldw	r2,0(r19)
81145bb8:	153fcf26 	beq	r2,r20,81145af8 <__reset+0xfb125af8>
81145bbc:	003fbc06 	br	81145ab0 <__reset+0xfb125ab0>
81145bc0:	183ee83a 	callr	r3
81145bc4:	003ff906 	br	81145bac <__reset+0xfb125bac>
81145bc8:	a5c00115 	stw	r23,4(r20)
81145bcc:	003feb06 	br	81145b7c <__reset+0xfb125b7c>
81145bd0:	89000017 	ldw	r4,0(r17)
81145bd4:	183ee83a 	callr	r3
81145bd8:	003ff406 	br	81145bac <__reset+0xfb125bac>
81145bdc:	a0800017 	ldw	r2,0(r20)
81145be0:	a027883a 	mov	r19,r20
81145be4:	1029883a 	mov	r20,r2
81145be8:	003fb606 	br	81145ac4 <__reset+0xfb125ac4>
81145bec:	0005883a 	mov	r2,zero
81145bf0:	003ffb06 	br	81145be0 <__reset+0xfb125be0>

81145bf4 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
81145bf4:	defffc04 	addi	sp,sp,-16
81145bf8:	de00012e 	bgeu	sp,et,81145c00 <_exit+0xc>
81145bfc:	003b68fa 	trap	3
81145c00:	dfc00315 	stw	ra,12(sp)
81145c04:	df000215 	stw	fp,8(sp)
81145c08:	df000204 	addi	fp,sp,8
81145c0c:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
81145c10:	d0a01217 	ldw	r2,-32696(gp)
81145c14:	10800058 	cmpnei	r2,r2,1
81145c18:	1000031e 	bne	r2,zero,81145c28 <_exit+0x34>
81145c1c:	01204574 	movhi	r4,33045
81145c20:	212bd004 	addi	r4,r4,-20672
81145c24:	11318b80 	call	811318b8 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
81145c28:	d0a01217 	ldw	r2,-32696(gp)
81145c2c:	10800058 	cmpnei	r2,r2,1
81145c30:	1000041e 	bne	r2,zero,81145c44 <_exit+0x50>
81145c34:	e17fff17 	ldw	r5,-4(fp)
81145c38:	01204574 	movhi	r4,33045
81145c3c:	212bdb04 	addi	r4,r4,-20628
81145c40:	11318b80 	call	811318b8 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
81145c44:	d0a01217 	ldw	r2,-32696(gp)
81145c48:	10800058 	cmpnei	r2,r2,1
81145c4c:	1000031e 	bne	r2,zero,81145c5c <_exit+0x68>
81145c50:	01204574 	movhi	r4,33045
81145c54:	212be604 	addi	r4,r4,-20584
81145c58:	11318b80 	call	811318b8 <alt_log_printf_proc>
  ALT_OS_STOP();
81145c5c:	d0208b05 	stb	zero,-32212(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
81145c60:	d0a01217 	ldw	r2,-32696(gp)
81145c64:	10800058 	cmpnei	r2,r2,1
81145c68:	1000031e 	bne	r2,zero,81145c78 <_exit+0x84>
81145c6c:	01204574 	movhi	r4,33045
81145c70:	212bf004 	addi	r4,r4,-20544
81145c74:	11318b80 	call	811318b8 <alt_log_printf_proc>
81145c78:	e0bfff17 	ldw	r2,-4(fp)
81145c7c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
81145c80:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
81145c84:	10000226 	beq	r2,zero,81145c90 <_exit+0x9c>
    ALT_SIM_FAIL();
81145c88:	002af070 	cmpltui	zero,zero,43969
81145c8c:	00000106 	br	81145c94 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
81145c90:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
81145c94:	d0a01217 	ldw	r2,-32696(gp)
81145c98:	10800058 	cmpnei	r2,r2,1
81145c9c:	1000031e 	bne	r2,zero,81145cac <_exit+0xb8>
81145ca0:	01204574 	movhi	r4,33045
81145ca4:	212bfa04 	addi	r4,r4,-20504
81145ca8:	11318b80 	call	811318b8 <alt_log_printf_proc>
  while (1);
81145cac:	003fff06 	br	81145cac <__reset+0xfb125cac>
